 // RPC_NO_WINDOWS_H

#ifdef __cplusplus
}
#endif

#endif // __RPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\win32inc\AfxWin.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXWIN_H__
#ifndef RC_INVOKED
#define __AFXWIN_H__

/////////////////////////////////////////////////////////////////////////////
// Make sure 'afx.h' is included first

#ifndef __AFX_H__
    #include <afx.h>
#endif

// Note: WINDOWS.H already included from AFXV_W32.H

#ifndef _INC_SHELLAPI
    #include <shellapi.h>
#endif

#ifndef __AFXRES_H__
    #include <afxres.h>     // standard resource IDs
#endif

#ifndef __AFXCOLL_H__
    #include <afxcoll.h>    // standard collections
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifndef _AFX_NOFORCE_LIBS
#pragma comment(lib, "uuid.lib")
#endif

#ifdef _INC_WINDOWSX
// The following names from WINDOWSX.H collide with names in this header
#undef SubclassWindow
#undef CopyRgn
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

class CSize;
class CPoint;
class CRect;

//CObject
    //CException
        //CSimpleException
            class CResourceException;// Win resource failure exception
            class CUserException;    // Message Box alert and stop operation

    class CGdiObject;            // CDC drawing tool
        class CPen;              // a pen / HPEN wrapper
        class CBrush;            // a brush / HBRUSH wrapper
        class CFont;             // a font / HFONT wrapper
        class CBitmap;           // a bitmap / HBITMAP wrapper
        class CPalette;          // a palette / HPALLETE wrapper
        class CRgn;              // a region / HRGN wrapper

    class CDC;                   // a Display Context / HDC wrapper
        class CClientDC;         // CDC for client of window
        class CWindowDC;         // CDC for entire window
        class CPaintDC;          // embeddable BeginPaint struct helper

    class CMenu;                 // a menu / HMENU wrapper

    class CCmdTarget;            // a target for user commands
        class CWnd;                 // a window / HWND wrapper
            class CDialog;          // a dialog

            // standard windows controls
            class CStatic;          // Static control
            class CButton;          // Button control
            class CListBox;         // ListBox control
                class CCheckListBox;// special listbox with checks
            class CComboBox;        // ComboBox control
            class CEdit;            // Edit control
            class CScrollBar;       // ScrollBar control

            // frame windows
            class CFrameWnd;        // standard SDI frame
                class CMDIFrameWnd; // standard MDI frame
                class CMDIChildWnd; // standard MDI child
                class CMiniFrameWnd;// half-height caption frame wnd

            // views on a document
            class CView;            // a view on a document
                class CScrollView;  // a scrolling view

        class CWinThread;           // thread base class
            class CWinApp;          // application base class

        class CDocTemplate;         // template for document creation
            class CSingleDocTemplate;// SDI support
            class CMultiDocTemplate; // MDI support

        class CDocument;            // main document abstraction


// Helper classes
class CCmdUI;           // Menu/button enabling
class CDataExchange;    // Data exchange and validation context
class CCommandLineInfo; // CommandLine parsing helper
class CDocManager;      // CDocTemplate manager object

/////////////////////////////////////////////////////////////////////////////

// Type modifier for message handlers
#ifndef afx_msg
#define afx_msg         // intentional placeholder
#endif

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// CSize - An extent, similar to Windows SIZE structure.

class CSize : public tagSIZE
{
public:

// Constructors
    // construct an uninitialized size
    CSize();
    // create from two integers
    CSize(int initCX, int initCY);
    // create from another size
    CSize(SIZE initSize);
    // create from a point
    CSize(POINT initPt);
    // create from a DWORD: cx = LOWORD(dw) cy = HIWORD(dw)
    CSize(DWORD dwSize);

// Operations
    BOOL operator==(SIZE size) const;
    BOOL operator!=(SIZE size) const;
    void operator+=(SIZE size);
    void operator-=(SIZE size);

// Operators returning CSize values
    CSize operator+(SIZE size) const;
    CSize operator-(SIZE size) const;
    CSize operator-() const;

// Operators returning CPoint values
    CPoint operator+(POINT point) const;
    CPoint operator-(POINT point) const;

// Operators returning CRect values
    CRect operator+(const RECT* lpRect) const;
    CRect operator-(const RECT* lpRect) const;
};

/////////////////////////////////////////////////////////////////////////////
// CPoint - A 2-D point, similar to Windows POINT structure.

class CPoint : public tagPOINT
{
public:

// Constructors
    // create an uninitialized point
    CPoint();
    // create from two integers
    CPoint(int initX, int initY);
    // create from another point
    CPoint(POINT initPt);
    // create from a size
    CPoint(SIZE initSize);
    // create from a dword: x = LOWORD(dw) y = HIWORD(dw)
    CPoint(DWORD dwPoint);

// Operations

// translate the point
    void Offset(int xOffset, int yOffset);
    void Offset(POINT point);
    void Offset(SIZE size);

    BOOL operator==(POINT point) const;
    BOOL operator!=(POINT point) const;
    void operator+=(SIZE size);
    void operator-=(SIZE size);
    void operator+=(POINT point);
    void operator-=(POINT point);

// Operators returning CPoint values
    CPoint operator+(SIZE size) const;
    CPoint operator-(SIZE size) const;
    CPoint operator-() const;
    CPoint operator+(POINT point) const;

// Operators returning CSize values
    CSize operator-(POINT point) const;

// Operators returning CRect values
    CRect operator+(const RECT* lpRect) const;
    CRect operator-(const RECT* lpRect) const;
};

/////////////////////////////////////////////////////////////////////////////
// CRect - A 2-D rectangle, similar to Windows RECT structure.

typedef const RECT* LPCRECT;    // pointer to read/only RECT

class CRect : public tagRECT
{
public:

// Constructors

    // uninitialized rectangle
    CRect();
    // from left, top, right, and bottom
    CRect(int l, int t, int r, int b);
    // copy constructor
    CRect(const RECT& srcRect);
    // from a pointer to another rect
    CRect(LPCRECT lpSrcRect);
    // from a point and size
    CRect(POINT point, SIZE size);
    // from two points
    CRect(POINT topLeft, POINT bottomRight);

// Attributes (in addition to RECT members)

    // retrieves the width
    int Width() const;
    // returns the height
    int Height() const;
    // returns the size
    CSize Size() const;
    // reference to the top-left point
    CPoint& TopLeft();
    // reference to the bottom-right point
    CPoint& BottomRight();
    // const reference to the top-left point
    const CPoint& TopLeft() const;
    // const reference to the bottom-right point
    const CPoint& BottomRight() const;
    // the geometric center point of the rectangle
    CPoint CenterPoint() const;
    // swap the left and right
    void SwapLeftRight();
    static void SwapLeftRight(LPRECT lpRect);

    // convert between CRect and LPRECT/LPCRECT (no need for &)
    operator LPRECT();
    operator LPCRECT() const;

    // returns TRUE if rectangle has no area
    BOOL IsRectEmpty() const;
    // returns TRUE if rectangle is at (0,0) and has no area
    BOOL IsRectNull() const;
    // returns TRUE if point is within rectangle
    BOOL PtInRect(POINT point) const;

// Operations

    // set rectangle from left, top, right, and bottom
    void SetRect(int x1, int y1, int x2, int y2);
    void SetRect(POINT topLeft, POINT bottomRight);
    // empty the rectangle
    void SetRectEmpty();
    // copy from another rectangle
    void CopyRect(LPCRECT lpSrcRect);
    // TRUE if exactly the same as another rectangle
    BOOL EqualRect(LPCRECT lpRect) const;

    // inflate rectangle's width and height without
    // moving its top or left
    void InflateRect(int x, int y);
    void InflateRect(SIZE size);
    void InflateRect(LPCRECT lpRect);
    void InflateRect(int l, int t, int r, int b);
    // deflate the rectangle's width and height without
    // moving its top or left
    void DeflateRect(int x, int y);
    void DeflateRect(SIZE size);
    void DeflateRect(LPCRECT lpRect);
    void DeflateRect(int l, int t, int r, int b);

    // translate the rectangle by moving its top and left
    void OffsetRect(int x, int y);
    void OffsetRect(SIZE size);
    void OffsetRect(POINT point);
    void NormalizeRect();

    // set this rectangle to intersection of two others
    BOOL IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2);

    // set this rectangle to bounding union of two others
    BOOL UnionRect(LPCRECT lpRect1, LPCRECT lpRect2);

    // set this rectangle to minimum of two others
    BOOL SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2);

// Additional Operations
    void operator=(const RECT& srcRect);
    BOOL operator==(const RECT& rect) const;
    BOOL operator!=(const RECT& rect) const;
    void operator+=(POINT point);
    void operator+=(SIZE size);
    void operator+=(LPCRECT lpRect);
    void operator-=(POINT point);
    void operator-=(SIZE size);
    void operator-=(LPCRECT lpRect);
    void operator&=(const RECT& rect);
    void operator|=(const RECT& rect);

// Operators returning CRect values
    CRect operator+(POINT point) const;
    CRect operator-(POINT point) const;
    CRect operator+(LPCRECT lpRect) const;
    CRect operator+(SIZE size) const;
    CRect operator-(SIZE size) const;
    CRect operator-(LPCRECT lpRect) const;
    CRect operator&(const RECT& rect2) const;
    CRect operator|(const RECT& rect2) const;
    CRect MulDiv(int nMultiplier, int nDivisor) const;
};

#ifdef _DEBUG
// Diagnostic Output
CDumpContext& AFXAPI operator<<(CDumpContext& dc, SIZE size);
CDumpContext& AFXAPI operator<<(CDumpContext& dc, POINT point);
CDumpContext& AFXAPI operator<<(CDumpContext& dc, const RECT& rect);
#endif //_DEBUG

// Serialization
CArchive& AFXAPI operator<<(CArchive& ar, SIZE size);
CArchive& AFXAPI operator<<(CArchive& ar, POINT point);
CArchive& AFXAPI operator<<(CArchive& ar, const RECT& rect);
CArchive& AFXAPI operator>>(CArchive& ar, SIZE& size);
CArchive& AFXAPI operator>>(CArchive& ar, POINT& point);
CArchive& AFXAPI operator>>(CArchive& ar, RECT& rect);

/////////////////////////////////////////////////////////////////////////////
// Standard exceptions

class CResourceException : public CSimpleException    // resource failure
{
    DECLARE_DYNAMIC(CResourceException)
public:
    CResourceException();

// Implementation
public:
    CResourceException(BOOL bAutoDelete);
    CResourceException(BOOL bAutoDelete, UINT nResourceID);
    virtual ~CResourceException();
};

class CUserException : public CSimpleException   // general user visible alert
{
    DECLARE_DYNAMIC(CUserException)
public:
    CUserException();

// Implementation
public:
    CUserException(BOOL bAutoDelete);
    CUserException(BOOL bAutoDelete, UINT nResourceID);
    virtual ~CUserException();
};

void AFXAPI AfxThrowResourceException();
void AFXAPI AfxThrowUserException();

/////////////////////////////////////////////////////////////////////////////
// CGdiObject abstract class for CDC SelectObject

class CGdiObject : public CObject
{
    DECLARE_DYNCREATE(CGdiObject)
public:

// Attributes
    HGDIOBJ m_hObject;                  // must be first data member
    operator HGDIOBJ() const;
    HGDIOBJ GetSafeHandle() const;

    static CGdiObject* PASCAL FromHandle(HGDIOBJ hObject);
    static void PASCAL DeleteTempMap();
    BOOL Attach(HGDIOBJ hObject);
    HGDIOBJ Detach();

// Constructors
    CGdiObject(); // must Create a derived class object
    BOOL DeleteObject();

// Operations
    int GetObject(int nCount, LPVOID lpObject) const;
    UINT GetObjectType() const;
    BOOL CreateStockObject(int nIndex);
    BOOL UnrealizeObject();
    BOOL operator==(const CGdiObject& obj) const;
    BOOL operator!=(const CGdiObject& obj) const;

// Implementation
public:
    virtual ~CGdiObject();
#ifdef _DEBUG
    virtual void Dump(CDumpContext& dc) const;
    virtual void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CGdiObject subclasses (drawing tools)

class CPen : public CGdiObject
{
    DECLARE_DYNAMIC(CPen)

public:
    static CPen* PASCAL FromHandle(HPEN hPen);

// Constructors
    CPen();
    CPen(int nPenStyle, int nWidth, COLORREF crColor);
    CPen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush,
            int nStyleCount = 0, const DWORD* lpStyle = NULL);
    BOOL CreatePen(int nPenStyle, int nWidth, COLORREF crColor);
    BOOL CreatePen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush,
            int nStyleCount = 0, const DWORD* lpStyle = NULL);
    BOOL CreatePenIndirect(LPLOGPEN lpLogPen);

// Attributes
    operator HPEN() const;
    int GetLogPen(LOGPEN* pLogPen);
    int GetExtLogPen(EXTLOGPEN* pLogPen);

// Implementation
public:
    virtual ~CPen();
#ifdef _DEBUG
    virtual void Dump(CDumpContext& dc) const;
#endif
};

class CBrush : public CGdiObject
{
    DECLARE_DYNAMIC(CBrush)

public:
    static CBrush* PASCAL FromHandle(HBRUSH hBrush);

// Constructors
    CBrush();
    CBrush(COLORREF crColor);             // CreateSolidBrush
    CBrush(int nIndex, COLORREF crColor); // CreateHatchBrush
    CBrush(CBitmap* pBitmap);          // CreatePatternBrush

    BOOL CreateSolidBrush(COLORREF crColor);
    BOOL CreateHatchBrush(int nIndex, COLORREF crColor);
    BOOL CreateBrushIndirect(const LOGBRUSH* lpLogBrush);
    BOOL CreatePatternBrush(CBitmap* pBitmap);
    BOOL CreateDIBPatternBrush(HGLOBAL hPackedDIB, UINT nUsage);
    BOOL CreateDIBPatternBrush(const void* lpPackedDIB, UINT nUsage);
    BOOL CreateSysColorBrush(int nIndex);

// Attributes
    operator HBRUSH() const;
    int GetLogBrush(LOGBRUSH* pLogBrush);

// Implementation
public:
    virtual ~CBrush();
#ifdef _DEBUG
    virtual void Dump(CDumpContext& dc) const;
#endif
};

class CFont : public CGdiObject
{
    DECLARE_DYNAMIC(CFont)

public:
    static CFont* PASCAL FromHandle(HFONT hFont);

// Constructors
    CFont();
    BOOL CreateFontIndirect(const LOGFONT* lpLogFont);
    BOOL CreateFont(int nHeight, int nWidth, int nEscapement,
                    int nOrientation, int nWeight, BYTE bItalic, BYTE bUnderline,
                    BYTE cStrikeOut, BYTE nCharSet, BYTE nOutPrecision,
                    BYTE nClipPrecision, BYTE nQuality, BYTE nPitchAndFamily,
                    LPCTSTR lpszFacename);
    BOOL CreatePointFont(int nPointSize, LPCTSTR lpszFaceName, CDC* pDC = NULL);
    BOOL CreatePointFontIndirect(const LOGFONT* lpLogFont, CDC* pDC = NULL);

// Attributes
    operator HFONT() const;
    int GetLogFont(LOGFONT* pLogFont);

// Implementation
public:
    virtual ~CFont();
#ifdef _DEBUG
    virtual void Dump(CDumpContext& dc) const;
#endif
};

class CBitmap : public CGdiObject
{
    DECLARE_DYNAMIC(CBitmap)

public:
    static CBitmap* PASCAL FromHandle(HBITMAP hBitmap);

// Constructors
    CBitmap();

    BOOL LoadBitmap(LPCTSTR lpszResourceName);
    BOOL LoadBitmap(UINT nIDResource);
    BOOL LoadOEMBitmap(UINT nIDBitmap); // for OBM_/OCR_/OIC_
    BOOL LoadMappedBitmap(UINT nIDBitmap, UINT nFlags = 0,
            LPCOLORMAP lpColorMap = NULL, int nMapSize = 0);
    BOOL CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitcount,
                    const void* lpBits);
    BOOL CreateBitmapIndirect(LPBITMAP lpBitmap);
    BOOL CreateCompatibleBitmap(CDC* pDC, int nWidth, int nHeight);
    BOOL CreateDiscardableBitmap(CDC* pDC, int nWidth, int nHeight);

// Attributes
    operator HBITMAP() const;
    int GetBitmap(BITMAP* pBitMap);

// Operations
    DWORD SetBitmapBits(DWORD dwCount, const void* lpBits);
    DWORD GetBitmapBits(DWORD dwCount, LPVOID lpBits) const;
    CSize SetBitmapDimension(int nWidth, int nHeight);
    CSize GetBitmapDimension() const;

// Implementation
public:
    virtual ~CBitmap();
#ifdef _DEBUG
    virtual void Dump(CDumpContext& dc) const;
#endif
};

class CPalette : public CGdiObject
{
    DECLARE_DYNAMIC(CPalette)

public:
    static CPalette* PASCAL FromHandle(HPALETTE hPalette);

// Constructors
    CPalette();
    BOOL CreatePalette(LPLOGPALETTE lpLogPalette);
    BOOL CreateHalftonePalette(CDC* pDC);

// Attributes
    operator HPALETTE() const;
    int GetEntryCount();
    UINT GetPaletteEntries(UINT nStartIndex, UINT nNumEntries,
                    LPPALETTEENTRY lpPaletteColors) const;
    UINT SetPaletteEntries(UINT nStartIndex, UINT nNumEntries,
                    LPPALETTEENTRY lpPaletteColors);

// Operations
    void AnimatePalette(UINT nStartIndex, UINT nNumEntries,
                    LPPALETTEENTRY lpPaletteColors);
    UINT GetNearestPaletteIndex(COLORREF crColor) const;
    BOOL ResizePalette(UINT nNumEntries);

// Implementation
    virtual ~CPalette();
};

class CRgn : public CGdiObject
{
    DECLARE_DYNAMIC(CRgn)

public:
    static CRgn* PASCAL FromHandle(HRGN hRgn);
    operator HRGN() const;

// Constructors
    CRgn();
    BOOL CreateRectRgn(int x1, int y1, int x2, int y2);
    BOOL CreateRectRgnIndirect(LPCRECT lpRect);
    BOOL CreateEllipticRgn(int x1, int y1, int x2, int y2);
    BOOL CreateEllipticRgnIndirect(LPCRECT lpRect);
    BOOL CreatePolygonRgn(LPPOINT lpPoints, int nCount, int nMode);
    BOOL CreatePolyPolygonRgn(LPPOINT lpPoints, LPINT lpPolyCounts,
                    int nCount, int nPolyFillMode);
    BOOL CreateRoundRectRgn(int x1, int y1, int x2, int y2, int x3, int y3);
    BOOL CreateFromPath(CDC* pDC);
    BOOL CreateFromData(const XFORM* lpXForm, int nCount,
            const RGNDATA* pRgnData);

// Operations
    void SetRectRgn(int x1, int y1, int x2, int y2);
    void SetRectRgn(LPCRECT lpRect);
    int CombineRgn(CRgn* pRgn1, CRgn* pRgn2, int nCombineMode);
    int CopyRgn(CRgn* pRgnSrc);
    BOOL EqualRgn(CRgn* pRgn) const;
    int OffsetRgn(int x, int y);
    int OffsetRgn(POINT point);
    int GetRgnBox(LPRECT lpRect) const;
    BOOL PtInRegion(int x, int y) const;
    BOOL PtInRegion(POINT point) const;
    BOOL RectInRegion(LPCRECT lpRect) const;
    int GetRegionData(LPRGNDATA lpRgnData, int nCount) const;

// Implementation
    virtual ~CRgn();
};

/////////////////////////////////////////////////////////////////////////////
// The device context

class CDC : public CObject
{
    DECLARE_DYNCREATE(CDC)
public:

// Attributes
    HDC m_hDC;          // The output DC (must be first data member)
    HDC m_hAttribDC;    // The Attribute DC
    operator HDC() const;
    HDC GetSafeHdc() const; // Always returns the Output DC
    CWnd* GetWindow() const;

    static CDC* PASCAL FromHandle(HDC hDC);
    static void PASCAL DeleteTempMap();
    BOOL Attach(HDC hDC);   // Attach/Detach affects only the Output DC
    HDC Detach();

    virtual void SetAttribDC(HDC hDC);  // Set the Attribute DC
    virtual void SetOutputDC(HDC hDC);  // Set the Output DC
    virtual void ReleaseAttribDC();     // Release the Attribute DC
    virtual void ReleaseOutputDC();     // Release the Output DC

    BOOL IsPrinting() const;            // TRUE if being used for printing

    CPen* GetCurrentPen() const;
    CBrush* GetCurrentBrush() const;
    CPalette* GetCurrentPalette() const;
    CFont* GetCurrentFont() const;
    CBitmap* GetCurrentBitmap() const;

#if _MFC_VER>=0x0600
    // for bidi and mirrored localization
    DWORD GetLayout() const;
    DWORD SetLayout(DWORD dwLayout);
#endif

// Constructors
    CDC();
    BOOL CreateDC(LPCTSTR lpszDriverName, LPCTSTR lpszDeviceName,
            LPCTSTR lpszOutput, const void* lpInitData);
    BOOL CreateIC(LPCTSTR lpszDriverName, LPCTSTR lpszDeviceName,
            LPCTSTR lpszOutput, const void* lpInitData);
    BOOL CreateCompatibleDC(CDC* pDC);

    BOOL DeleteDC();

// Device-Context Functions
    virtual int SaveDC();
    virtual BOOL RestoreDC(int nSavedDC);
    int GetDeviceCaps(int nIndex) const;
    UINT SetBoundsRect(LPCRECT lpRectBounds, UINT flags);
    UINT GetBoundsRect(LPRECT lpRectBounds, UINT flags);
    BOOL ResetDC(const DEVMODE* lpDevMode);

// Drawing-Tool Functions
    CPoint GetBrushOrg() const;
    CPoint SetBrushOrg(int x, int y);
    CPoint SetBrushOrg(POINT point);
    int EnumObjects(int nObjectType,
                    int (CALLBACK* lpfn)(LPVOID, LPARAM), LPARAM lpData);

// Type-safe selection helpers
public:
    virtual CGdiObject* SelectStockObject(int nIndex);
    CPen* SelectObject(CPen* pPen);
    CBrush* SelectObject(CBrush* pBrush);
    virtual CFont* SelectObject(CFont* pFont);
    CBitmap* SelectObject(CBitmap* pBitmap);
    int SelectObject(CRgn* pRgn);       // special return for regions
    CGdiObject* SelectObject(CGdiObject* pObject);
            // CGdiObject* provided so compiler doesn't use SelectObject(HGDIOBJ)

// Color and Color Palette Functions
    COLORREF GetNearestColor(COLORREF crColor) const;
    CPalette* SelectPalette(CPalette* pPalette, BOOL bForceBackground);
    UINT RealizePalette();
    void UpdateColors();

// Drawing-Attribute Functions
    COLORREF GetBkColor() const;
    int GetBkMode() const;
    int GetPolyFillMode() const;
    int GetROP2() const;
    int GetStretchBltMode() const;
    COLORREF GetTextColor() const;

    virtual COLORREF SetBkColor(COLORREF crColor);
    int SetBkMode(int nBkMode);
    int SetPolyFillMode(int nPolyFillMode);
    int SetROP2(int nDrawMode);
    int SetStretchBltMode(int nStretchMode);
    virtual COLORREF SetTextColor(COLORREF crColor);

    BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
    BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);

// Mapping Functions
    int GetMapMode() const;
    CPoint GetViewportOrg() const;
    virtual int SetMapMode(int nMapMode);
    // Viewport Origin
    virtual CPoint SetViewportOrg(int x, int y);
                    CPoint SetViewportOrg(POINT point);
    virtual CPoint OffsetViewportOrg(int nWidth, int nHeight);

    // Viewport Extent
    CSize GetViewportExt() const;
    virtual CSize SetViewportExt(int cx, int cy);
                    CSize SetViewportExt(SIZE size);
    virtual CSize ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom);

    // Window Origin
    CPoint GetWindowOrg() const;
    CPoint SetWindowOrg(int x, int y);
    CPoint SetWindowOrg(POINT point);
    CPoint OffsetWindowOrg(int nWidth, int nHeight);

    // Window extent
    CSize GetWindowExt() const;
    virtual CSize SetWindowExt(int cx, int cy);
                    CSize SetWindowExt(SIZE size);
    virtual CSize ScaleWindowExt(int xNum, int xDenom, int yNum, int yDenom);

// Coordinate Functions
    void DPtoLP(LPPOINT lpPoints, int nCount = 1) const;
    void DPtoLP(LPRECT lpRect) const;
    void DPtoLP(LPSIZE lpSize) const;
    void LPtoDP(LPPOINT lpPoints, int nCount = 1) const;
    void LPtoDP(LPRECT lpRect) const;
    void LPtoDP(LPSIZE lpSize) const;

// Special Coordinate Functions (useful for dealing with metafiles and OLE)
    void DPtoHIMETRIC(LPSIZE lpSize) const;
    void LPtoHIMETRIC(LPSIZE lpSize) const;
    void HIMETRICtoDP(LPSIZE lpSize) const;
    void HIMETRICtoLP(LPSIZE lpSize) const;

// Region Functions
    BOOL FillRgn(CRgn* pRgn, CBrush* pBrush);
    BOOL FrameRgn(CRgn* pRgn, CBrush* pBrush, int nWidth, int nHeight);
    BOOL InvertRgn(CRgn* pRgn);
    BOOL PaintRgn(CRgn* pRgn);

// Clipping Functions
    virtual int GetClipBox(LPRECT lpRect) const;
    virtual BOOL PtVisible(int x, int y) const;
                    BOOL PtVisible(POINT point) const;
    virtual BOOL RectVisible(LPCRECT lpRect) const;
                    int SelectClipRgn(CRgn* pRgn);
                    int ExcludeClipRect(int x1, int y1, int x2, int y2);
                    int ExcludeClipRect(LPCRECT lpRect);
                    int ExcludeUpdateRgn(CWnd* pWnd);
                    int IntersectClipRect(int x1, int y1, int x2, int y2);
                    int IntersectClipRect(LPCRECT lpRect);
                    int OffsetClipRgn(int x, int y);
                    int OffsetClipRgn(SIZE size);
    int SelectClipRgn(CRgn* pRgn, int nMode);

// Line-Output Functions
    CPoint GetCurrentPosition() const;
    CPoint MoveTo(int x, int y);
    CPoint MoveTo(POINT point);
    BOOL LineTo(int x, int y);
    BOOL LineTo(POINT point);
    BOOL Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
    BOOL Arc(LPCRECT lpRect, POINT ptStart, POINT ptEnd);
    BOOL Polyline(LPPOINT lpPoints, int nCount);

    BOOL AngleArc(int x, int y, int nRadius, float fStartAngle, float fSweepAngle);
    BOOL ArcTo(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
    BOOL ArcTo(LPCRECT lpRect, POINT ptStart, POINT ptEnd);
    int GetArcDirection() const;
    int SetArcDirection(int nArcDirection);

    BOOL PolyDraw(const POINT* lpPoints, const BYTE* lpTypes, int nCount);
    BOOL PolylineTo(const POINT* lpPoints, int nCount);
    BOOL PolyPolyline(const POINT* lpPoints,
            const DWORD* lpPolyPoints, int nCount);

    BOOL PolyBezier(const POINT* lpPoints, int nCount);
    BOOL PolyBezierTo(const POINT* lpPoints, int nCount);

// Simple Drawing Functions
    void FillRect(LPCRECT lpRect, CBrush* pBrush);
    void FrameRect(LPCRECT lpRect, CBrush* pBrush);
    void InvertRect(LPCRECT lpRect);
    BOOL DrawIcon(int x, int y, HICON hIcon);
    BOOL DrawIcon(POINT point, HICON hIcon);
#if WINVER>=0x400
    BOOL DrawState(CPoint pt, CSize size, HBITMAP hBitmap, UINT nFlags,
            HBRUSH hBrush = NULL);
    BOOL DrawState(CPoint pt, CSize size, CBitmap* pBitmap, UINT nFlags,
            CBrush* pBrush = NULL);
    BOOL DrawState(CPoint pt, CSize size, HICON hIcon, UINT nFlags,
            HBRUSH hBrush = NULL);
    BOOL DrawState(CPoint pt, CSize size, HICON hIcon, UINT nFlags,
            CBrush* pBrush = NULL);
    BOOL DrawState(CPoint pt, CSize size, LPCTSTR lpszText, UINT nFlags,
            BOOL bPrefixText = TRUE, int nTextLen = 0, HBRUSH hBrush = NULL);
    BOOL DrawState(CPoint pt, CSize size, LPCTSTR lpszText, UINT nFlags,
            BOOL bPrefixText = TRUE, int nTextLen = 0, CBrush* pBrush = NULL);
    BOOL DrawState(CPoint pt, CSize size, DRAWSTATEPROC lpDrawProc,
            LPARAM lData, UINT nFlags, HBRUSH hBrush = NULL);
    BOOL DrawState(CPoint pt, CSize size, DRAWSTATEPROC lpDrawProc,
            LPARAM lData, UINT nFlags, CBrush* pBrush = NULL);
#endif

// Ellipse and Polygon Functions
    BOOL Chord(int x1, int y1, int x2, int y2, int x3, int y3,
            int x4, int y4);
    BOOL Chord(LPCRECT lpRect, POINT ptStart, POINT ptEnd);
    void DrawFocusRect(LPCRECT lpRect);
    BOOL Ellipse(int x1, int y1, int x2, int y2);
    BOOL Ellipse(LPCRECT lpRect);
    BOOL Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
    BOOL Pie(LPCRECT lpRect, POINT ptStart, POINT ptEnd);
    BOOL Polygon(LPPOINT lpPoints, int nCount);
    BOOL PolyPolygon(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount);
    BOOL Rectangle(int x1, int y1, int x2, int y2);
    BOOL Rectangle(LPCRECT lpRect);
    BOOL RoundRect(int x1, int y1, int x2, int y2, int x3, int y3);
    BOOL RoundRect(LPCRECT lpRect, POINT point);

// Bitmap Functions
    BOOL PatBlt(int x, int y, int nWidth, int nHeight, DWORD dwRop);
    BOOL BitBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
            int xSrc, int ySrc, DWORD dwRop);
    BOOL StretchBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
            int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, DWORD dwRop);
    COLORREF GetPixel(int x, int y) const;
    COLORREF GetPixel(POINT point) const;
    COLORREF SetPixel(int x, int y, COLORREF crColor);
    COLORREF SetPixel(POINT point, COLORREF crColor);
    BOOL FloodFill(int x, int y, COLORREF crColor);
    BOOL ExtFloodFill(int x, int y, COLORREF crColor, UINT nFillType);
    BOOL MaskBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
            int xSrc, int ySrc, CBitmap& maskBitmap, int xMask, int yMask,
            DWORD dwRop);
    BOOL PlgBlt(LPPOINT lpPoint, CDC* pSrcDC, int xSrc, int ySrc,
            int nWidth, int nHeight, CBitmap& maskBitmap, int xMask, int yMask);
    BOOL SetPixelV(int x, int y, COLORREF crColor);
    BOOL SetPixelV(POINT point, COLORREF crColor);

// Text Functions
    virtual BOOL TextOut(int x, int y, LPCTSTR lpszString, int nCount);
                    BOOL TextOut(int x, int y, const CString& str);
    virtual BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
                            LPCTSTR lpszString, UINT nCount, LPINT lpDxWidths);
                    BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
                            const CString& str, LPINT lpDxWidths);
    virtual CSize TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount,
                            int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
                    CSize TabbedTextOut(int x, int y, const CString& str,
                            int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
    virtual int DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect,
                            UINT nFormat);
                    int DrawText(const CString& str, LPRECT lpRect, UINT nFormat);
    CSize GetTextExtent(LPCTSTR lpszString, int nCount) const;
    CSize GetTextExtent(const CString& str) const;
    CSize GetOutputTextExtent(LPCTSTR lpszString, int nCount) const;
    CSize GetOutputTextExtent(const CString& str) const;
    CSize GetTabbedTextExtent(LPCTSTR lpszString, int nCount,
            int nTabPositions, LPINT lpnTabStopPositions) const;
    CSize GetTabbedTextExtent(const CString& str,
            int nTabPositions, LPINT lpnTabStopPositions) const;
    CSize GetOutputTabbedTextExtent(LPCTSTR lpszString, int nCount,
            int nTabPositions, LPINT lpnTabStopPositions) const;
    CSize GetOutputTabbedTextExtent(const CString& str,
            int nTabPositions, LPINT lpnTabStopPositions) const;
    virtual BOOL GrayString(CBrush* pBrush,
            BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, int), LPARAM lpData,
                    int nCount, int x, int y, int nWidth, int nHeight);
    UINT GetTextAlign() const;
    UINT SetTextAlign(UINT nFlags);
    int GetTextFace(int nCount, LPTSTR lpszFacename) const;
    int GetTextFace(CString& rString) const;
    BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
    BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
    int SetTextJustification(int nBreakExtra, int nBreakCount);
    int GetTextCharacterExtra() const;
    int SetTextCharacterExtra(int nCharExtra);

// Advanced Drawing
#if WINVER>=0x400
    BOOL DrawEdge(LPRECT lpRect, UINT nEdge, UINT nFlags);
    BOOL DrawFrameControl(LPRECT lpRect, UINT nType, UINT nState);
#endif

// Scrolling Functions
    BOOL ScrollDC(int dx, int dy, LPCRECT lpRectScroll, LPCRECT lpRectClip,
            CRgn* pRgnUpdate, LPRECT lpRectUpdate);

// Font Functions
    BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const;
    BOOL GetOutputCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const;
    DWORD SetMapperFlags(DWORD dwFlag);
    CSize GetAspectRatioFilter() const;

    BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABC lpabc) const;
    DWORD GetFontData(DWORD dwTable, DWORD dwOffset, LPVOID lpData, DWORD cbData) const;
    int GetKerningPairs(int nPairs, LPKERNINGPAIR lpkrnpair) const;
    UINT GetOutlineTextMetrics(UINT cbData, LPOUTLINETEXTMETRIC lpotm) const;
    DWORD GetGlyphOutline(UINT nChar, UINT nFormat, LPGLYPHMETRICS lpgm,
            DWORD cbBuffer, LPVOID lpBuffer, const MAT2* lpmat2) const;

    BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar,
            LPABCFLOAT lpABCF) const;
    BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar,
            float* lpFloatBuffer) const;

// Printer/Device Escape Functions
    virtual int Escape(int nEscape, int nCount,
            LPCSTR lpszInData, LPVOID lpOutData);
    int Escape(int nEscape, int nInputSize, LPCSTR lpszInputData,
            int nOutputSize, LPSTR lpszOutputData);
    int DrawEscape(int nEscape, int nInputSize, LPCSTR lpszInputData);

    // Escape helpers
    int StartDoc(LPCTSTR lpszDocName);  // old Win3.0 version
    int StartDoc(LPDOCINFO lpDocInfo);
    int StartPage();
    int EndPage();
    int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
    int AbortDoc();
    int EndDoc();

// MetaFile Functions
    BOOL PlayMetaFile(HMETAFILE hMF);
    BOOL PlayMetaFile(HENHMETAFILE hEnhMetaFile, LPCRECT lpBounds);
    BOOL AddMetaFileComment(UINT nDataSize, const BYTE* pCommentData);
            // can be used for enhanced metafiles only

// Path Functions
    BOOL AbortPath();
    BOOL BeginPath();
    BOOL CloseFigure();
    BOOL EndPath();
    BOOL FillPath();
    BOOL FlattenPath();
    BOOL StrokeAndFillPath();
    BOOL StrokePath();
    BOOL WidenPath();
    float GetMiterLimit() const;
    BOOL SetMiterLimit(float fMiterLimit);
    int GetPath(LPPOINT lpPoints, LPBYTE lpTypes, int nCount) const;
    BOOL SelectClipPath(int nMode);

// Misc Helper Functions
    static CBrush* PASCAL GetHalftoneBrush();
    void DrawDragRect(LPCRECT lpRect, SIZE size,
            LPCRECT lpRectLast, SIZE sizeLast,
            CBrush* pBrush = NULL, CBrush* pBrushLast = NULL);
    void FillSolidRect(LPCRECT lpRect, COLORREF clr);
    void FillSolidRect(int x, int y, int cx, int cy, COLORREF clr);
    void Draw3dRect(LPCRECT lpRect, COLORREF clrTopLeft, COLORREF clrBottomRight);
    void Draw3dRect(int x, int y, int cx, int cy,
            COLORREF clrTopLeft, COLORREF clrBottomRight);

// Implementation
public:
    virtual ~CDC();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    // advanced use and implementation
    BOOL m_bPrinting;
    HGDIOBJ SelectObject(HGDIOBJ);      // do not use for regions

protected:
    // used for implementation of non-virtual SelectObject calls
    static CGdiObject* PASCAL SelectGdiObject(HDC hDC, HGDIOBJ h);
};

/////////////////////////////////////////////////////////////////////////////
// CDC Helpers

class CPaintDC : public CDC
{
    DECLARE_DYNAMIC(CPaintDC)

// Constructors
public:
    CPaintDC(CWnd* pWnd);   // BeginPaint

// Attributes
protected:
    HWND m_hWnd;
public:
    PAINTSTRUCT m_ps;       // actual paint struct!

// Implementation
public:
    virtual ~CPaintDC();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
};

class CClientDC : public CDC
{
    DECLARE_DYNAMIC(CClientDC)

// Constructors
public:
    CClientDC(CWnd* pWnd);

// Attributes
protected:
    HWND m_hWnd;

// Implementation
public:
    virtual ~CClientDC();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
};

class CWindowDC : public CDC
{
    DECLARE_DYNAMIC(CWindowDC)

// Constructors
public:
    CWindowDC(CWnd* pWnd);

// Attributes
protected:
    HWND m_hWnd;

// Implementation
public:
    virtual ~CWindowDC();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CMenu

class CMenu : public CObject
{
    DECLARE_DYNCREATE(CMenu)
public:

// Constructors
    CMenu();

    BOOL CreateMenu();
    BOOL CreatePopupMenu();
    BOOL LoadMenu(LPCTSTR lpszResourceName);
    BOOL LoadMenu(UINT nIDResource);
    BOOL LoadMenuIndirect(const void* lpMenuTemplate);
    BOOL DestroyMenu();

// Attributes
    HMENU m_hMenu;          // must be first data member
    HMENU GetSafeHmenu() const;
    operator HMENU() const;

    static CMenu* PASCAL FromHandle(HMENU hMenu);
    static void PASCAL DeleteTempMap();
    BOOL Attach(HMENU hMenu);
    HMENU Detach();

// CMenu Operations
    BOOL DeleteMenu(UINT nPosition, UINT nFlags);
    BOOL TrackPopupMenu(UINT nFlags, int x, int y,
                                            CWnd* pWnd, LPCRECT lpRect = 0);
    BOOL operator==(const CMenu& menu) const;
    BOOL operator!=(const CMenu& menu) const;

// CMenuItem Operations
    BOOL AppendMenu(UINT nFlags, UINT_PTR nIDNewItem = 0,
                                    LPCTSTR lpszNewItem = NULL);
    BOOL AppendMenu(UINT nFlags, UINT_PTR nIDNewItem, const CBitmap* pBmp);
    UINT CheckMenuItem(UINT nIDCheckItem, UINT nCheck);
    UINT EnableMenuItem(UINT nIDEnableItem, UINT nEnable);
    UINT GetMenuItemCount() const;
    UINT GetMenuItemID(int nPos) const;
    UINT GetMenuState(UINT nID, UINT nFlags) const;
    int GetMenuString(UINT nIDItem, LPTSTR lpString, int nMaxCount,
                                    UINT nFlags) const;
    int GetMenuString(UINT nIDItem, CString& rString, UINT nFlags) const;
#if _MFC_VER>=0x0600
	BOOL GetMenuItemInfo(UINT nIDItem, LPMENUITEMINFO lpMenuItemInfo,
					BOOL fByPos = FALSE);
#endif
    CMenu* GetSubMenu(int nPos) const;
    BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem = 0,
                                    LPCTSTR lpszNewItem = NULL);
    BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem,
                                    const CBitmap* pBmp);
    BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem = 0,
                                    LPCTSTR lpszNewItem = NULL);
    BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem,
                                    const CBitmap* pBmp);
    BOOL RemoveMenu(UINT nPosition, UINT nFlags);
    BOOL SetMenuItemBitmaps(UINT nPosition, UINT nFlags,
                                    const CBitmap* pBmpUnchecked, const CBitmap* pBmpChecked);
    BOOL CheckMenuRadioItem(UINT nIDFirst, UINT nIDLast, UINT nIDItem, UINT nFlags);
#if _MFC_VER>=0x0600
	BOOL SetDefaultItem(UINT uItem, BOOL fByPos = FALSE);
	UINT GetDefaultItem(UINT gmdiFlags, BOOL fByPos = FALSE);
#endif

// Context Help Functions
    BOOL SetMenuContextHelpId(DWORD dwContextHelpId);
    DWORD GetMenuContextHelpId() const;

// Overridables (must override draw and measure for owner-draw menu items)
    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
    virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);

// Implementation
public:
    virtual ~CMenu();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
    static CMenu* PASCAL CMenu::FromHandlePermanent(HMENU hMenu);
};

/////////////////////////////////////////////////////////////////////////////
// Window message map handling

struct AFX_MSGMAP_ENTRY;       // declared below after CWnd

struct AFX_MSGMAP
{
#ifdef _AFXDLL
    const AFX_MSGMAP* (PASCAL* pfnGetBaseMap)();
#else
    const AFX_MSGMAP* pBaseMap;
#endif
    const AFX_MSGMAP_ENTRY* lpEntries;
};

#ifdef _AFXDLL
#define DECLARE_MESSAGE_MAP() \
private: \
    static const AFX_MSGMAP_ENTRY _messageEntries[]; \
protected: \
    static AFX_DATA const AFX_MSGMAP messageMap; \
    static const AFX_MSGMAP* PASCAL _GetBaseMessageMap(); \
    virtual const AFX_MSGMAP* GetMessageMap() const; \

#else
#define DECLARE_MESSAGE_MAP() \
private: \
    static const AFX_MSGMAP_ENTRY _messageEntries[]; \
protected: \
    static AFX_DATA const AFX_MSGMAP messageMap; \
    virtual const AFX_MSGMAP* GetMessageMap() const; \

#endif

#ifdef _AFXDLL
#define BEGIN_MESSAGE_MAP(theClass, baseClass) \
    const AFX_MSGMAP* PASCAL theClass::_GetBaseMessageMap() \
            { return &baseClass::messageMap; } \
    const AFX_MSGMAP* theClass::GetMessageMap() const \
            { return &theClass::messageMap; } \
    AFX_COMDAT AFX_DATADEF const AFX_MSGMAP theClass::messageMap = \
    { &theClass::_GetBaseMessageMap, &theClass::_messageEntries[0] }; \
    AFX_COMDAT const AFX_MSGMAP_ENTRY theClass::_messageEntries[] = \
    { \

#else
#define BEGIN_MESSAGE_MAP(theClass, baseClass) \
    const AFX_MSGMAP* theClass::GetMessageMap() const \
            { return &theClass::messageMap; } \
    AFX_COMDAT AFX_DATADEF const AFX_MSGMAP theClass::messageMap = \
    { &baseClass::messageMap, &theClass::_messageEntries[0] }; \
    AFX_COMDAT const AFX_MSGMAP_ENTRY theClass::_messageEntries[] = \
    { \

#endif

#define END_MESSAGE_MAP() \
            {0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 } \
    }; \

// Message map signature values and macros in separate header
#include <afxmsg_.h>

/////////////////////////////////////////////////////////////////////////////
// Dialog data exchange (DDX_) and validation (DDV_)

// CDataExchange - for data exchange and validation
class CDataExchange
{
// Attributes
public:
    BOOL m_bSaveAndValidate;   // TRUE => save and validate data
    CWnd* m_pDlgWnd;           // container usually a dialog

// Operations (for implementors of DDX and DDV procs)
    HWND PrepareCtrl(int nIDC);     // return HWND of control
    HWND PrepareEditCtrl(int nIDC); // return HWND of control
    void Fail();                    // will throw exception

#ifndef _AFX_NO_OCC_SUPPORT
    CWnd* PrepareOleCtrl(int nIDC); // for OLE controls in dialog
#endif

// Implementation
    CDataExchange(CWnd* pDlgWnd, BOOL bSaveAndValidate);

    HWND m_hWndLastControl;    // last control used (for validation)
    BOOL m_bEditLastControl;   // last control was an edit item
};

#include <afxdd_.h>     // standard DDX_ and DDV_ routines

/////////////////////////////////////////////////////////////////////////////
// OLE types

typedef LONG HRESULT;

struct IUnknown;
typedef IUnknown* LPUNKNOWN;

struct IDispatch;
typedef IDispatch* LPDISPATCH;

struct IConnectionPoint;
typedef IConnectionPoint* LPCONNECTIONPOINT;

struct IEnumOLEVERB;
typedef IEnumOLEVERB* LPENUMOLEVERB;

typedef struct _GUID GUID;
typedef GUID IID;
typedef GUID CLSID;
#ifndef _REFCLSID_DEFINED
#define REFCLSID const CLSID &
#endif

typedef long DISPID;
typedef unsigned short VARTYPE;
typedef long SCODE;

#if !defined
typedef WCHAR OLECHAR;
#else
typedef char OLECHAR;
#endif
typedef OLECHAR* BSTR;

struct tagDISPPARAMS;
typedef tagDISPPARAMS DISPPARAMS;

struct tagVARIANT;
typedef tagVARIANT VARIANT;

struct ITypeInfo;
typedef ITypeInfo* LPTYPEINFO;

struct ITypeLib;
typedef ITypeLib* LPTYPELIB;

/////////////////////////////////////////////////////////////////////////////
// CCmdTarget

// private structures
struct AFX_CMDHANDLERINFO;  // info about where the command is handled
struct AFX_EVENT;           // info about an event
class CTypeLibCache;        // cache for OLE type libraries

/////////////////////////////////////////////////////////////////////////////
// OLE interface map handling (more in AFXDISP.H)

#ifndef _AFX_NO_OLE_SUPPORT

struct AFX_INTERFACEMAP_ENTRY
{
    const void* piid;       // the interface id (IID) (NULL for aggregate)
    size_t nOffset;         // offset of the interface vtable from m_unknown
};

struct AFX_INTERFACEMAP
{
#ifdef _AFXDLL
    const AFX_INTERFACEMAP* (PASCAL* pfnGetBaseMap)(); // NULL is root class
#else
    const AFX_INTERFACEMAP* pBaseMap;
#endif
    const AFX_INTERFACEMAP_ENTRY* pEntry; // map for this class
};


#ifdef _AFXDLL
#define DECLARE_INTERFACE_MAP() \
private: \
    static const AFX_INTERFACEMAP_ENTRY _interfaceEntries[]; \
protected: \
    static AFX_DATA const AFX_INTERFACEMAP interfaceMap; \
    static const AFX_INTERFACEMAP* PASCAL _GetBaseInterfaceMap(); \
    virtual const AFX_INTERFACEMAP* GetInterfaceMap() const; \

#else
#define DECLARE_INTERFACE_MAP() \
private: \
    static const AFX_INTERFACEMAP_ENTRY _interfaceEntries[]; \
protected: \
    static AFX_DATA const AFX_INTERFACEMAP interfaceMap; \
    virtual const AFX_INTERFACEMAP* GetInterfaceMap() const; \

#endif

#endif //!_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// OLE dispatch map handling (more in AFXDISP.H)

#ifndef _AFX_NO_OLE_SUPPORT

struct AFX_DISPMAP_ENTRY;

struct AFX_DISPMAP
{
#ifdef _AFXDLL
    const AFX_DISPMAP* (PASCAL* pfnGetBaseMap)();
#else
    const AFX_DISPMAP* pBaseMap;
#endif
    const AFX_DISPMAP_ENTRY* lpEntries;
    UINT* lpEntryCount;
    DWORD* lpStockPropMask;
};

#ifdef _AFXDLL
#define DECLARE_DISPATCH_MAP() \
private: \
    static const AFX_DISPMAP_ENTRY _dispatchEntries[]; \
    static UINT _dispatchEntryCount; \
    static DWORD _dwStockPropMask; \
protected: \
    static AFX_DATA const AFX_DISPMAP dispatchMap; \
    static const AFX_DISPMAP* PASCAL _GetBaseDispatchMap(); \
    virtual const AFX_DISPMAP* GetDispatchMap() const; \

#else
#define DECLARE_DISPATCH_MAP() \
private: \
    static const AFX_DISPMAP_ENTRY _dispatchEntries[]; \
    static UINT _dispatchEntryCount; \
    static DWORD _dwStockPropMask; \
protected: \
    static AFX_DATA const AFX_DISPMAP dispatchMap; \
    virtual const AFX_DISPMAP* GetDispatchMap() const; \

#endif

#endif //!_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// OLE Document Object command target handling

#ifndef _AFX_NO_DOCOBJECT_SUPPORT

struct AFX_OLECMDMAP_ENTRY
{
   const GUID* pguid;   // id of the command group
   ULONG       cmdID;   // OLECMD ID
   UINT        nID;     // corresponding WM_COMMAND message ID
};

struct AFX_OLECMDMAP
{
#ifdef _AFXDLL
    const AFX_OLECMDMAP* (PASCAL* pfnGetBaseMap)();
#else
    const AFX_OLECMDMAP* pBaseMap;
#endif
    const AFX_OLECMDMAP_ENTRY* lpEntries;
};

#ifdef _AFXDLL
#define DECLARE_OLECMD_MAP() \
private: \
    static const AFX_OLECMDMAP_ENTRY _commandEntries[]; \
protected: \
    static AFX_DATA const AFX_OLECMDMAP commandMap; \
    static const AFX_OLECMDMAP* PASCAL _GetBaseCommandMap(); \
    virtual const AFX_OLECMDMAP* GetCommandMap() const; \

#else
#define DECLARE_OLECMD_MAP() \
private: \
    static const AFX_OLECMDMAP_ENTRY _commandEntries[]; \
protected: \
    static AFX_DATA const AFX_OLECMDMAP commandMap; \
    virtual const AFX_OLECMDMAP* GetCommandMap() const; \

#endif

#ifdef _AFXDLL
#define BEGIN_OLECMD_MAP(theClass, baseClass) \
    const AFX_OLECMDMAP* PASCAL theClass::_GetBaseCommandMap() \
            { return &baseClass::commandMap; } \
    const AFX_OLECMDMAP* theClass::GetCommandMap() const \
            { return &theClass::commandMap; } \
    AFX_COMDAT AFX_DATADEF const AFX_OLECMDMAP theClass::commandMap = \
    { &theClass::_GetBaseCommandMap, &theClass::_commandEntries[0] }; \
    AFX_COMDAT const AFX_OLECMDMAP_ENTRY theClass::_commandEntries[] = \
    { \

#else
#define BEGIN_OLECMD_MAP(theClass, baseClass) \
    const AFX_OLECMDMAP* theClass::GetCommandMap() const \
            { return &theClass::commandMap; } \
    AFX_COMDAT AFX_DATADEF const AFX_OLECMDMAP theClass::commandMap = \
    { &baseClass::commandMap, &theClass::_commandEntries[0] }; \
    AFX_COMDAT const AFX_OLECMDMAP_ENTRY theClass::_commandEntries[] = \
    { \

#endif

#define END_OLECMD_MAP() \
            {NULL, 0, 0} \
    }; \

class COleCmdUI;

#endif //!_AFX_NO_DOCOBJECT_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// OLE event sink map handling (more in AFXDISP.H)

#ifndef _AFX_NO_OCC_SUPPORT

struct AFX_EVENTSINKMAP_ENTRY;

struct AFX_EVENTSINKMAP
{
#ifdef _AFXDLL
    const AFX_EVENTSINKMAP* (PASCAL* pfnGetBaseMap)();
#else
    const AFX_EVENTSINKMAP* pBaseMap;
#endif
    const AFX_EVENTSINKMAP_ENTRY* lpEntries;
    UINT* lpEntryCount;
};

#ifdef _AFXDLL
#define DECLARE_EVENTSINK_MAP() \
private: \
    static const AFX_EVENTSINKMAP_ENTRY _eventsinkEntries[]; \
    static UINT _eventsinkEntryCount; \
protected: \
    static AFX_DATA const AFX_EVENTSINKMAP eventsinkMap; \
    static const AFX_EVENTSINKMAP* PASCAL _GetBaseEventSinkMap(); \
    virtual const AFX_EVENTSINKMAP* GetEventSinkMap() const; \

#else
#define DECLARE_EVENTSINK_MAP() \
private: \
    static const AFX_EVENTSINKMAP_ENTRY _eventsinkEntries[]; \
    static UINT _eventsinkEntryCount; \
protected: \
    static AFX_DATA const AFX_EVENTSINKMAP eventsinkMap; \
    virtual const AFX_EVENTSINKMAP* GetEventSinkMap() const; \

#endif

#endif //!_AFX_NO_OCC_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// OLE connection map handling (more in AFXDISP.H)

#ifndef _AFX_NO_OLE_SUPPORT

struct AFX_CONNECTIONMAP_ENTRY
{
    const void* piid;   // the interface id (IID)
    size_t nOffset;         // offset of the interface vtable from m_unknown
};

struct AFX_CONNECTIONMAP
{
#ifdef _AFXDLL
    const AFX_CONNECTIONMAP* (PASCAL* pfnGetBaseMap)(); // NULL is root class
#else
    const AFX_CONNECTIONMAP* pBaseMap;
#endif
    const AFX_CONNECTIONMAP_ENTRY* pEntry; // map for this class
};

#ifdef _AFXDLL
#define DECLARE_CONNECTION_MAP() \
private: \
    static const AFX_CONNECTIONMAP_ENTRY _connectionEntries[]; \
protected: \
    static AFX_DATA const AFX_CONNECTIONMAP connectionMap; \
    static const AFX_CONNECTIONMAP* PASCAL _GetBaseConnectionMap(); \
    virtual const AFX_CONNECTIONMAP* GetConnectionMap() const; \

#else
#define DECLARE_CONNECTION_MAP() \
private: \
    static const AFX_CONNECTIONMAP_ENTRY _connectionEntries[]; \
protected: \
    static AFX_DATA const AFX_CONNECTIONMAP connectionMap; \
    virtual const AFX_CONNECTIONMAP* GetConnectionMap() const; \

#endif

#endif //!_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// CCmdTarget proper

#ifndef _AFX_NO_OCC_SUPPORT
class COccManager;      // forward reference (see ..\src\occimpl.h)
#endif

#ifdef _AFXDLL
class CCmdTarget : public CObject
#else
class AFX_NOVTABLE CCmdTarget : public CObject
#endif
{
    DECLARE_DYNAMIC(CCmdTarget)
protected:

public:
// Constructors
    CCmdTarget();

// Attributes
    LPDISPATCH GetIDispatch(BOOL bAddRef);
            // retrieve IDispatch part of CCmdTarget
    static CCmdTarget* PASCAL FromIDispatch(LPDISPATCH lpDispatch);
            // map LPDISPATCH back to CCmdTarget* (inverse of GetIDispatch)
    BOOL IsResultExpected();
            // returns TRUE if automation function should return a value

// Operations
    void EnableAutomation();
            // call in constructor to wire up IDispatch
    void EnableConnections();
            // call in constructor to wire up IConnectionPointContainer

    void BeginWaitCursor();
    void EndWaitCursor();
    void RestoreWaitCursor();       // call after messagebox

#ifndef _AFX_NO_OLE_SUPPORT
    // dispatch OLE verbs through the message map
    BOOL EnumOleVerbs(LPENUMOLEVERB* ppenumOleVerb);
    BOOL DoOleVerb(LONG iVerb, LPMSG lpMsg, HWND hWndParent, LPCRECT lpRect);
#endif

// Overridables
    // route and dispatch standard command message types
    //   (more sophisticated than OnCommand)
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
            AFX_CMDHANDLERINFO* pHandlerInfo);

#ifndef _AFX_NO_OLE_SUPPORT
    // called when last OLE reference is released
    virtual void OnFinalRelease();
#endif

#ifndef _AFX_NO_OLE_SUPPORT
    // called before dispatching to an automation handler function
    virtual BOOL IsInvokeAllowed(DISPID dispid);
#endif

#ifndef _AFX_NO_OLE_SUPPORT
    // support for OLE type libraries
    void EnableTypeLib();
    HRESULT GetTypeInfoOfGuid(LCID lcid, const GUID& guid,
            LPTYPEINFO* ppTypeInfo);
    virtual BOOL GetDispatchIID(IID* pIID);
    virtual UINT GetTypeInfoCount();
    virtual CTypeLibCache* GetTypeLibCache();
    virtual HRESULT GetTypeLib(LCID lcid, LPTYPELIB* ppTypeLib);
#endif

// Implementation
public:
    virtual ~CCmdTarget();
#ifdef _DEBUG
    virtual void Dump(CDumpContext& dc) const;
    virtual void AssertValid() const;
#endif
#ifndef _AFX_NO_OLE_SUPPORT
    void GetNotSupported();
    void SetNotSupported();
#endif

protected:
    friend class CView;

    CView* GetRoutingView();
    CFrameWnd* GetRoutingFrame();
#if _MFC_VER>=0x0600
	static CView* PASCAL GetRoutingView_();
	static CFrameWnd* PASCAL GetRoutingFrame_();
#endif
    DECLARE_MESSAGE_MAP()       // base class - no {{ }} macros

#ifndef _AFX_NO_DOCOBJECT_SUPPORT
    DECLARE_OLECMD_MAP()
    friend class COleCmdUI;
#endif

#ifndef _AFX_NO_OLE_SUPPORT
    DECLARE_DISPATCH_MAP()
    DECLARE_CONNECTION_MAP()
    DECLARE_INTERFACE_MAP()

#ifndef _AFX_NO_OCC_SUPPORT
    DECLARE_EVENTSINK_MAP()
#endif // !_AFX_NO_OCC_SUPPORT

    // OLE interface map implementation
public:
    // data used when CCmdTarget is made OLE aware
    long m_dwRef;
    LPUNKNOWN m_pOuterUnknown;  // external controlling unknown if != NULL
    DWORD_PTR m_xInnerUnknown;  // place-holder for inner controlling unknown

public:
    // advanced operations
    void EnableAggregation();       // call to enable aggregation
    void ExternalDisconnect();      // forcibly disconnect
    LPUNKNOWN GetControllingUnknown();
            // get controlling IUnknown for aggregate creation

    // these versions do not delegate to m_pOuterUnknown
    DWORD InternalQueryInterface(const void*, LPVOID* ppvObj);
    DWORD InternalAddRef();
    DWORD InternalRelease();
    // these versions delegate to m_pOuterUnknown
    DWORD ExternalQueryInterface(const void*, LPVOID* ppvObj);
    DWORD ExternalAddRef();
    DWORD ExternalRelease();

    // implementation helpers
    LPUNKNOWN GetInterface(const void*);
    LPUNKNOWN QueryAggregates(const void*);

    // advanced overrideables for implementation
    virtual BOOL OnCreateAggregates();
    virtual LPUNKNOWN GetInterfaceHook(const void*);

    // OLE automation implementation
protected:
    struct XDispatch
    {
            DWORD_PTR m_vtbl;   // place-holder for IDispatch vtable
#ifndef _AFX_NO_NESTED_DERIVATION
            size_t m_nOffset;
#endif
    } m_xDispatch;
    BOOL m_bResultExpected;

    // member variable-based properties
    void GetStandardProp(const AFX_DISPMAP_ENTRY* pEntry,
            VARIANT* pvarResult, UINT* puArgErr);
    SCODE SetStandardProp(const AFX_DISPMAP_ENTRY* pEntry,
            DISPPARAMS* pDispParams, UINT* puArgErr);

    // DISPID to dispatch map lookup
    static UINT PASCAL GetEntryCount(const AFX_DISPMAP* pDispMap);
    const AFX_DISPMAP_ENTRY* PASCAL GetDispEntry(LONG memid);
    static LONG PASCAL MemberIDFromName(const AFX_DISPMAP* pDispMap, LPCTSTR lpszName);

    // helpers for member function calling implementation
    static UINT PASCAL GetStackSize(const BYTE* pbParams, VARTYPE vtResult);
#ifdef _SHADOW_DOUBLES
    SCODE PushStackArgs(BYTE* pStack, const BYTE* pbParams,
            void* pResult, VARTYPE vtResult, DISPPARAMS* pDispParams,
            UINT* puArgErr, VARIANT* rgTempVars, UINT nSizeArgs);
#else
    SCODE PushStackArgs(BYTE* pStack, const BYTE* pbParams,
            void* pResult, VARTYPE vtResult, DISPPARAMS* pDispParams,
            UINT* puArgErr, VARIANT* rgTempVars);
#endif
    SCODE CallMemberFunc(const AFX_DISPMAP_ENTRY* pEntry, WORD wFlags,
            VARIANT* pvarResult, DISPPARAMS* pDispParams, UINT* puArgErr);

    friend class COleDispatchImpl;

#ifndef _AFX_NO_OCC_SUPPORT
public:
    // OLE event sink implementation
    BOOL OnEvent(UINT idCtrl, AFX_EVENT* pEvent,
            AFX_CMDHANDLERINFO* pHandlerInfo);
protected:
    const AFX_EVENTSINKMAP_ENTRY* PASCAL GetEventSinkEntry(UINT idCtrl,
            AFX_EVENT* pEvent);
#endif // !_AFX_NO_OCC_SUPPORT

    // OLE connection implementation
    struct XConnPtContainer
    {
            DWORD_PTR m_vtbl;   // place-holder for IConnectionPointContainer vtable
#ifndef _AFX_NO_NESTED_DERIVATION
            size_t m_nOffset;
#endif
    } m_xConnPtContainer;

#ifdef _AFXDLL
    AFX_MODULE_STATE* m_pModuleState;
    friend class CInnerUnknown;
    friend UINT APIENTRY _AfxThreadEntry(void* pParam);
#endif

    virtual BOOL GetExtraConnectionPoints(CPtrArray* pConnPoints);
    virtual LPCONNECTIONPOINT GetConnectionHook(const IID& iid);

    friend class COleConnPtContainer;

#endif //!_AFX_NO_OLE_SUPPORT
};

class CCmdUI        // simple helper class
{
public:
// Attributes
    UINT m_nID;
    UINT m_nIndex;          // menu item or other index

    // if a menu item
    CMenu* m_pMenu;         // NULL if not a menu
    CMenu* m_pSubMenu;      // sub containing menu item
                                                    // if a popup sub menu - ID is for first in popup

    // if from some other window
    CWnd* m_pOther;         // NULL if a menu or not a CWnd

// Operations to do in ON_UPDATE_COMMAND_UI
    virtual void Enable(BOOL bOn = TRUE);
    virtual void SetCheck(int nCheck = 1);   // 0, 1 or 2 (indeterminate)
    virtual void SetRadio(BOOL bOn = TRUE);
    virtual void SetText(LPCTSTR lpszText);

// Advanced operation
    void ContinueRouting();

// Implementation
    CCmdUI();
    BOOL m_bEnableChanged;
    BOOL m_bContinueRouting;
    UINT m_nIndexMax;       // last + 1 for iterating m_nIndex

    CMenu* m_pParentMenu;   // NULL if parent menu not easily determined
                                                    //  (probably a secondary popup menu)

    BOOL DoUpdate(CCmdTarget* pTarget, BOOL bDisableIfNoHndler);
};

// special CCmdUI derived classes are used for other UI paradigms
//  like toolbar buttons and status indicators

// pointer to afx_msg member function
#ifndef AFX_MSG_CALL
#define AFX_MSG_CALL
#endif
typedef void (AFX_MSG_CALL CCmdTarget::*AFX_PMSG)(void);

enum AFX_DISPMAP_FLAGS
{
    afxDispCustom = 0,
    afxDispStock = 1
};

// BUGBUG - WIN64: AFX_DISPMAP_ENTRY could be ordered more efficiently to reduce size
// bloat from alignment
#pragma warning(disable:4121)
struct AFX_DISPMAP_ENTRY
{
    LPCTSTR lpszName;       // member/property name
    long lDispID;           // DISPID (may be DISPID_UNKNOWN)
    LPCSTR lpszParams;      // member parameter description
    WORD vt;                // return value type / or type of property
    AFX_PMSG pfn;           // normal member On<membercall> or, OnGet<property>
    AFX_PMSG pfnSet;        // special member for OnSet<property>
    size_t nPropOffset;     // property offset
    AFX_DISPMAP_FLAGS flags;// flags (e.g. stock/custom)
};

#pragma warning(default:4121)

struct AFX_EVENTSINKMAP_ENTRY
{
    AFX_DISPMAP_ENTRY dispEntry;
    UINT nCtrlIDFirst;
    UINT nCtrlIDLast;
};

// DSC Sink state/reason codes passed to MFC user event handlers
enum DSCSTATE
{
    dscNoState = 0,
    dscOKToDo,
    dscCancelled,
    dscSyncBefore,
    dscAboutToDo,
    dscFailedToDo,
    dscSyncAfter,
    dscDidEvent
};

enum DSCREASON
{
    dscNoReason = 0,
    dscClose,
    dscCommit,
    dscDelete,
    dscEdit,
    dscInsert,
    dscModify,
    dscMove
};

/////////////////////////////////////////////////////////////////////////////
// CWnd implementation

// structures (see afxext.h)
struct CCreateContext;      // context for creating things
struct CPrintInfo;          // print preview customization info

struct AFX_MSGMAP_ENTRY
{
    UINT nMessage;   // windows message
    UINT nCode;      // control code or WM_NOTIFY code
    UINT nID;        // control ID (or 0 for windows messages)
    UINT nLastID;    // used for entries specifying a range of control id's
    UINT_PTR nSig;   // signature type (action) or pointer to message #
    AFX_PMSG pfn;    // routine to call (or special value)
};

/////////////////////////////////////////////////////////////////////////////
// CWnd - a Microsoft Windows application window

class COleDropTarget;   // for more information see AFXOLE.H
class COleControlContainer;
class COleControlSite;

// CWnd::m_nFlags (generic to CWnd)
#define WF_TOOLTIPS         0x0001  // window is enabled for tooltips
#define WF_TEMPHIDE         0x0002  // window is temporarily hidden
#define WF_STAYDISABLED     0x0004  // window should stay disabled
#define WF_MODALLOOP        0x0008  // currently in modal loop
#define WF_CONTINUEMODAL    0x0010  // modal loop should continue running
#define WF_OLECTLCONTAINER  0x0100  // some descendant is an OLE control
#if _MFC_VER>=0x0600
#define WF_TRACKINGTOOLTIPS 0x0400  // window is enabled for tracking tooltips
#endif

// CWnd::m_nFlags (specific to CFrameWnd)
#define WF_STAYACTIVE       0x0020  // look active even though not active
#define WF_NOPOPMSG         0x0040  // ignore WM_POPMESSAGESTRING calls
#define WF_MODALDISABLE     0x0080  // window is disabled
#define WF_KEEPMINIACTIVE   0x0200  // stay activate even though you are deactivated

// flags for CWnd::RunModalLoop
#define MLF_NOIDLEMSG       0x0001  // don't send WM_ENTERIDLE messages
#define MLF_NOKICKIDLE      0x0002  // don't send WM_KICKIDLE messages
#define MLF_SHOWONIDLE      0x0004  // show window if not visible at idle time

// extra MFC defined TTF_ flags for TOOLINFO::uFlags
#define TTF_NOTBUTTON       0x80000000L // no status help on buttondown
#define TTF_ALWAYSTIP       0x40000000L // always show the tip even if not active

class CWnd : public CCmdTarget
{
    DECLARE_DYNCREATE(CWnd)
protected:
    static const MSG* PASCAL GetCurrentMessage();

// Attributes
public:
    HWND m_hWnd;            // must be first data member
    operator HWND() const;
    BOOL operator==(const CWnd& wnd) const;
    BOOL operator!=(const CWnd& wnd) const;

    HWND GetSafeHwnd() const;
    DWORD GetStyle() const;
    DWORD GetExStyle() const;
    BOOL ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0);
    BOOL ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0);

    CWnd* GetOwner() const;
    void SetOwner(CWnd* pOwnerWnd);

// Constructors and other creation
    CWnd();

    static CWnd* PASCAL FromHandle(HWND hWnd);
    static CWnd* PASCAL FromHandlePermanent(HWND hWnd);
    static void PASCAL DeleteTempMap();
    BOOL Attach(HWND hWndNew);
    HWND Detach();

    // subclassing/unsubclassing functions
    virtual void PreSubclassWindow();
    BOOL SubclassWindow(HWND hWnd);
    BOOL SubclassDlgItem(UINT nID, CWnd* pParent);
    HWND UnsubclassWindow();

    // handling of RT_DLGINIT resource (extension to RT_DIALOG)
    BOOL ExecuteDlgInit(LPCTSTR lpszResourceName);
    BOOL ExecuteDlgInit(LPVOID lpResource);

public:
    // for child windows, views, panes etc
    virtual BOOL Create(LPCTSTR lpszClassName,
            LPCTSTR lpszWindowName, DWORD dwStyle,
            const RECT& rect,
            CWnd* pParentWnd, UINT nID,
            CCreateContext* pContext = NULL);

    // advanced creation (allows access to extended styles)
    BOOL CreateEx(DWORD dwExStyle, LPCTSTR lpszClassName,
            LPCTSTR lpszWindowName, DWORD dwStyle,
            int x, int y, int nWidth, int nHeight,
            HWND hWndParent, HMENU nIDorHMenu, LPVOID lpParam = NULL);

    BOOL CreateEx(DWORD dwExStyle, LPCTSTR lpszClassName,
            LPCTSTR lpszWindowName, DWORD dwStyle,
            const RECT& rect,
            CWnd* pParentWnd, UINT nID,
            LPVOID lpParam = NULL);

#ifndef _AFX_NO_OCC_SUPPORT
    // for wrapping OLE controls
    BOOL CreateControl(REFCLSID clsid, LPCTSTR pszWindowName, DWORD dwStyle,
            const RECT& rect, CWnd* pParentWnd, UINT nID, CFile* pPersist=NULL,
            BOOL bStorage=FALSE, BSTR bstrLicKey=NULL);

    BOOL CreateControl(LPCTSTR pszClass, LPCTSTR pszWindowName, DWORD dwStyle,
            const RECT& rect, CWnd* pParentWnd, UINT nID, CFile* pPersist=NULL,
            BOOL bStorage=FALSE, BSTR bstrLicKey=NULL);
#if _MFC_VER>=0x0600
    // Another overload for creating controls that use default extents.
    BOOL CreateControl( REFCLSID clsid, LPCTSTR pszWindowName, DWORD dwStyle,
       const POINT* ppt, const SIZE* psize, CWnd* pParentWnd, UINT nID,
       CFile* pPersist = NULL, BOOL bStorage = FALSE, BSTR bstrLicKey = NULL );
#endif

    LPUNKNOWN GetControlUnknown();
#endif

    virtual BOOL DestroyWindow();

    // special pre-creation and window rect adjustment hooks
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

    // Advanced: virtual AdjustWindowRect
    enum AdjustType { adjustBorder = 0, adjustOutside = 1 };
    virtual void CalcWindowRect(LPRECT lpClientRect,
            UINT nAdjustType = adjustBorder);

// Window tree access
    int GetDlgCtrlID() const;
    int SetDlgCtrlID(int nID);
            // get and set window ID, for child windows only
    CWnd* GetDlgItem(int nID) const;
            // get immediate child with given ID
    void GetDlgItem(int nID, HWND* phWnd) const;
            // as above, but returns HWND
    CWnd* GetDescendantWindow(int nID, BOOL bOnlyPerm = FALSE) const;
            // like GetDlgItem but recursive
    void SendMessageToDescendants(UINT message, WPARAM wParam = 0,
            LPARAM lParam = 0, BOOL bDeep = TRUE, BOOL bOnlyPerm = FALSE);
    CFrameWnd* GetParentFrame() const;
    CWnd* GetTopLevelParent() const;
    CWnd* GetTopLevelOwner() const;
    CWnd* GetParentOwner() const;
    CFrameWnd* GetTopLevelFrame() const;
    static CWnd* PASCAL GetSafeOwner(CWnd* pParent = NULL, HWND* pWndTop = NULL);

// Message Functions
    LRESULT SendMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0);
    BOOL PostMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0);

    BOOL SendNotifyMessage(UINT message, WPARAM wParam, LPARAM lParam);
    BOOL SendChildNotifyLastMsg(LRESULT* pResult = NULL);

// Message processing for modeless dialog-like windows
    BOOL IsDialogMessage(LPMSG lpMsg);

// Window Text Functions
    void SetWindowText(LPCTSTR lpszString);
    int GetWindowText(LPTSTR lpszStringBuf, int nMaxCount) const;
    void GetWindowText(CString& rString) const;
    int GetWindowTextLength() const;
    void SetFont(CFont* pFont, BOOL bRedraw = TRUE);
    CFont* GetFont() const;

// CMenu Functions - non-Child windows only
    CMenu* GetMenu() const;
    BOOL SetMenu(CMenu* pMenu);
    void DrawMenuBar();
    CMenu* GetSystemMenu(BOOL bRevert) const;
    BOOL HiliteMenuItem(CMenu* pMenu, UINT nIDHiliteItem, UINT nHilite);

// Window Size and Position Functions
    BOOL IsIconic() const;
    BOOL IsZoomed() const;
    void MoveWindow(int x, int y, int nWidth, int nHeight,
                            BOOL bRepaint = TRUE);
    void MoveWindow(LPCRECT lpRect, BOOL bRepaint = TRUE);
    int SetWindowRgn(HRGN hRgn, BOOL bRedraw);
    int GetWindowRgn(HRGN hRgn) const;

    static AFX_DATA const CWnd wndTop; // SetWindowPos's pWndInsertAfter
    static AFX_DATA const CWnd wndBottom; // SetWindowPos's pWndInsertAfter
    static AFX_DATA const CWnd wndTopMost; // SetWindowPos pWndInsertAfter
    static AFX_DATA const CWnd wndNoTopMost; // SetWindowPos pWndInsertAfter

    BOOL SetWindowPos(const CWnd* pWndInsertAfter, int x, int y,
                            int cx, int cy, UINT nFlags);
    UINT ArrangeIconicWindows();
    void BringWindowToTop();
    void GetWindowRect(LPRECT lpRect) const;
    void GetClientRect(LPRECT lpRect) const;

    BOOL GetWindowPlacement(WINDOWPLACEMENT* lpwndpl) const;
    BOOL SetWindowPlacement(const WINDOWPLACEMENT* lpwndpl);

// Coordinate Mapping Functions
    void ClientToScreen(LPPOINT lpPoint) const;
    void ClientToScreen(LPRECT lpRect) const;
    void ScreenToClient(LPPOINT lpPoint) const;
    void ScreenToClient(LPRECT lpRect) const;
    void MapWindowPoints(CWnd* pwndTo, LPPOINT lpPoint, UINT nCount) const;
    void MapWindowPoints(CWnd* pwndTo, LPRECT lpRect) const;

// Update/Painting Functions
    CDC* BeginPaint(LPPAINTSTRUCT lpPaint);
    void EndPaint(LPPAINTSTRUCT lpPaint);
    CDC* GetDC();
    CDC* GetWindowDC();
    int ReleaseDC(CDC* pDC);
    void Print(CDC* pDC, DWORD dwFlags) const;
    void PrintClient(CDC* pDC, DWORD dwFlags) const;

    void UpdateWindow();
    void SetRedraw(BOOL bRedraw = TRUE);
    BOOL GetUpdateRect(LPRECT lpRect, BOOL bErase = FALSE);
    int GetUpdateRgn(CRgn* pRgn, BOOL bErase = FALSE);
    void Invalidate(BOOL bErase = TRUE);
    void InvalidateRect(LPCRECT lpRect, BOOL bErase = TRUE);
    void InvalidateRgn(CRgn* pRgn, BOOL bErase = TRUE);
    void ValidateRect(LPCRECT lpRect);
    void ValidateRgn(CRgn* pRgn);
    BOOL ShowWindow(int nCmdShow);
    BOOL IsWindowVisible() const;
    void ShowOwnedPopups(BOOL bShow = TRUE);

    CDC* GetDCEx(CRgn* prgnClip, DWORD flags);
    BOOL LockWindowUpdate();    // for backward compatibility
    void UnlockWindowUpdate();
    BOOL RedrawWindow(LPCRECT lpRectUpdate = NULL,
            CRgn* prgnUpdate = NULL,
            UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
    BOOL EnableScrollBar(int nSBFlags, UINT nArrowFlags = ESB_ENABLE_BOTH);

// Timer Functions
    UINT_PTR SetTimer(UINT_PTR nIDEvent, UINT nElapse,
            void (CALLBACK* lpfnTimer)(HWND, UINT, UINT_PTR, DWORD));
    BOOL KillTimer(UINT_PTR nIDEvent);

// ToolTip Functions
    BOOL EnableToolTips(BOOL bEnable = TRUE);
#if _MFC_VER>=0x0600
    BOOL EnableTrackingToolTips(BOOL bEnable = TRUE);
#endif
    static void PASCAL CancelToolTips(BOOL bKeys = FALSE);
    void FilterToolTipMessage(MSG* pMsg);

    // for command hit testing (used for automatic tooltips)
    virtual int OnToolHitTest(CPoint point, TOOLINFO* pTI) const;

// Window State Functions
    BOOL IsWindowEnabled() const;
    BOOL EnableWindow(BOOL bEnable = TRUE);

    // the active window applies only to top-level (frame windows)
    static CWnd* PASCAL GetActiveWindow();
    CWnd* SetActiveWindow();

    // the foreground window applies only to top-level windows (frame windows)
    BOOL SetForegroundWindow();
    static CWnd* PASCAL GetForegroundWindow();

    // capture and focus apply to all windows
    static CWnd* PASCAL GetCapture();
    CWnd* SetCapture();
    static CWnd* PASCAL GetFocus();
    CWnd* SetFocus();

    static CWnd* PASCAL GetDesktopWindow();

// Obsolete and non-portable APIs - not recommended for new code
    void CloseWindow();
    BOOL OpenIcon();

// Dialog-Box Item Functions
// (NOTE: Dialog-Box Items/Controls are not necessarily in dialog boxes!)
    void CheckDlgButton(int nIDButton, UINT nCheck);
    void CheckRadioButton(int nIDFirstButton, int nIDLastButton,
                                    int nIDCheckButton);
    int GetCheckedRadioButton(int nIDFirstButton, int nIDLastButton);
    int DlgDirList(LPTSTR lpPathSpec, int nIDListBox,
                                    int nIDStaticPath, UINT nFileType);
    int DlgDirListComboBox(LPTSTR lpPathSpec, int nIDComboBox,
                                    int nIDStaticPath, UINT nFileType);
    BOOL DlgDirSelect(LPTSTR lpString, int nIDListBox);
    BOOL DlgDirSelectComboBox(LPTSTR lpString, int nIDComboBox);

    UINT GetDlgItemInt(int nID, BOOL* lpTrans = NULL,
                                    BOOL bSigned = TRUE) const;
    int GetDlgItemText(int nID, LPTSTR lpStr, int nMaxCount) const;
    int GetDlgItemText(int nID, CString& rString) const;
    CWnd* GetNextDlgGroupItem(CWnd* pWndCtl, BOOL bPrevious = FALSE) const;

    CWnd* GetNextDlgTabItem(CWnd* pWndCtl, BOOL bPrevious = FALSE) const;
    UINT IsDlgButtonChecked(int nIDButton) const;
    LRESULT SendDlgItemMessage(int nID, UINT message,
                                    WPARAM wParam = 0, LPARAM lParam = 0);
    void SetDlgItemInt(int nID, UINT nValue, BOOL bSigned = TRUE);
    void SetDlgItemText(int nID, LPCTSTR lpszString);

// Scrolling Functions
    int GetScrollPos(int nBar) const;
    void GetScrollRange(int nBar, LPINT lpMinPos, LPINT lpMaxPos) const;
    void ScrollWindow(int xAmount, int yAmount,
                                    LPCRECT lpRect = NULL,
                                    LPCRECT lpClipRect = NULL);
    int SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE);
    void SetScrollRange(int nBar, int nMinPos, int nMaxPos,
                    BOOL bRedraw = TRUE);
    void ShowScrollBar(UINT nBar, BOOL bShow = TRUE);
    void EnableScrollBarCtrl(int nBar, BOOL bEnable = TRUE);
    virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
                    // return sibling scrollbar control (or NULL if none)

    int ScrollWindowEx(int dx, int dy,
                            LPCRECT lpRectScroll, LPCRECT lpRectClip,
                            CRgn* prgnUpdate, LPRECT lpRectUpdate, UINT flags);
    BOOL SetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo,
            BOOL bRedraw = TRUE);
    BOOL GetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, UINT nMask = SIF_ALL);
    int GetScrollLimit(int nBar);

// Window Access Functions
    CWnd* ChildWindowFromPoint(POINT point) const;
    CWnd* ChildWindowFromPoint(POINT point, UINT nFlags) const;
    static CWnd* PASCAL FindWindow(LPCTSTR lpszClassName, LPCTSTR lpszWindowName);
    CWnd* GetNextWindow(UINT nFlag = GW_HWNDNEXT) const;
    CWnd* GetTopWindow() const;

    CWnd* GetWindow(UINT nCmd) const;
    CWnd* GetLastActivePopup() const;

    BOOL IsChild(const CWnd* pWnd) const;
    CWnd* GetParent() const;
    CWnd* SetParent(CWnd* pWndNewParent);
    static CWnd* PASCAL WindowFromPoint(POINT point);

// Alert Functions
    BOOL FlashWindow(BOOL bInvert);
    int MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption = NULL,
                    UINT nType = MB_OK);

// Clipboard Functions
    BOOL ChangeClipboardChain(HWND hWndNext);
    HWND SetClipboardViewer();
    BOOL OpenClipboard();
    static CWnd* PASCAL GetClipboardOwner();
    static CWnd* PASCAL GetClipboardViewer();
    static CWnd* PASCAL GetOpenClipboardWindow();

// Caret Functions
    void CreateCaret(CBitmap* pBitmap);
    void CreateSolidCaret(int nWidth, int nHeight);
    void CreateGrayCaret(int nWidth, int nHeight);
    static CPoint PASCAL GetCaretPos();
    static void PASCAL SetCaretPos(POINT point);
    void HideCaret();
    void ShowCaret();

// Shell Interaction Functions
    void DragAcceptFiles(BOOL bAccept = TRUE);

// Icon Functions
    HICON SetIcon(HICON hIcon, BOOL bBigIcon);
    HICON GetIcon(BOOL bBigIcon) const;

// Context Help Functions
    BOOL SetWindowContextHelpId(DWORD dwContextHelpId);
    DWORD GetWindowContextHelpId() const;


// Dialog Data support
public:
    BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
                    // data wnd must be same type as this

// Help Command Handlers
    afx_msg void OnHelp();          // F1 (uses current context)
    afx_msg void OnHelpIndex();     // ID_HELP_INDEX
    afx_msg void OnHelpFinder();    // ID_HELP_FINDER, ID_DEFAULT_HELP
    afx_msg void OnHelpUsing();     // ID_HELP_USING
    virtual void WinHelp(DWORD_PTR dwData, UINT nCmd = HELP_CONTEXT);

// Layout and other functions
public:
    enum RepositionFlags
            { reposDefault = 0, reposQuery = 1, reposExtra = 2 };
    void RepositionBars(UINT nIDFirst, UINT nIDLast, UINT nIDLeftOver,
            UINT nFlag = reposDefault, LPRECT lpRectParam = NULL,
            LPCRECT lpRectClient = NULL, BOOL bStretch = TRUE);

    // dialog support
    void UpdateDialogControls(CCmdTarget* pTarget, BOOL bDisableIfNoHndler);
    void CenterWindow(CWnd* pAlternateOwner = NULL);
    int RunModalLoop(DWORD dwFlags = 0);
    virtual BOOL ContinueModal();
    virtual void EndModalLoop(int nResult);

#ifndef _AFX_NO_OCC_SUPPORT
// OLE control wrapper functions
    void AFX_CDECL InvokeHelper(DISPID dwDispID, WORD wFlags,
            VARTYPE vtRet, void* pvRet, const BYTE* pbParamInfo, ...);
    void AFX_CDECL SetProperty(DISPID dwDispID, VARTYPE vtProp, ...);
    void GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const;
    IUnknown* GetDSCCursor();
    void BindDefaultProperty(DISPID dwDispID, VARTYPE vtProp, LPCTSTR szFieldName, CWnd* pDSCWnd);
    void BindProperty(DISPID dwDispId, CWnd* pWndDSC);
#endif

// Window-Management message handler member functions
protected:
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

    afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
    afx_msg void OnActivateApp(BOOL bActive, HTASK hTask);
    afx_msg LRESULT OnActivateTopLevel(WPARAM, LPARAM);
    afx_msg void OnCancelMode();
    afx_msg void OnChildActivate();
    afx_msg void OnClose();
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint pos);
    afx_msg BOOL OnCopyData(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);

    afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);

    afx_msg void OnDestroy();
    afx_msg void OnEnable(BOOL bEnable);
    afx_msg void OnEndSession(BOOL bEnding);
    afx_msg void OnEnterIdle(UINT nWhy, CWnd* pWho);
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);
    afx_msg BOOL OnHelpInfo(HELPINFO* lpHelpInfo);
    afx_msg void OnIconEraseBkgnd(CDC* pDC);
    afx_msg void OnKillFocus(CWnd* pNewWnd);
    afx_msg LRESULT OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu);
    afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);
    afx_msg void OnMove(int x, int y);
    afx_msg void OnPaint();
    afx_msg void OnParentNotify(UINT message, LPARAM lParam);
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg BOOL OnQueryEndSession();
    afx_msg BOOL OnQueryNewPalette();
    afx_msg BOOL OnQueryOpen();
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnTCard(UINT idAction, DWORD dwActionData);
    afx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);
    afx_msg void OnWindowPosChanged(WINDOWPOS* lpwndpos);

// Nonclient-Area message handler member functions
    afx_msg BOOL OnNcActivate(BOOL bActive);
    afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpncsp);
    afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnNcDestroy();
    afx_msg UINT OnNcHitTest(CPoint point);
    afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);
    afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
    afx_msg void OnNcLButtonUp(UINT nHitTest, CPoint point);
    afx_msg void OnNcMButtonDblClk(UINT nHitTest, CPoint point);
    afx_msg void OnNcMButtonDown(UINT nHitTest, CPoint point);
    afx_msg void OnNcMButtonUp(UINT nHitTest, CPoint point);
    afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
    afx_msg void OnNcPaint();
    afx_msg void OnNcRButtonDblClk(UINT nHitTest, CPoint point);
    afx_msg void OnNcRButtonDown(UINT nHitTest, CPoint point);
    afx_msg void OnNcRButtonUp(UINT nHitTest, CPoint point);

// System message handler member functions
    afx_msg void OnDropFiles(HDROP hDropInfo);
    afx_msg void OnPaletteIsChanging(CWnd* pRealizeWnd);
    afx_msg void OnSysChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnSysDeadChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSysKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnCompacting(UINT nCpuTime);
    afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
    afx_msg void OnFontChange();
    afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
    afx_msg void OnSpoolerStatus(UINT nStatus, UINT nJobs);
    afx_msg void OnSysColorChange();
    afx_msg void OnTimeChange();
    afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg void OnWinIniChange(LPCTSTR lpszSection);

// Input message handler member functions
    afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnDeadChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMButtonDblClk(UINT nFlags, CPoint point);
    afx_msg void OnMButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnMButtonUp(UINT nFlags, CPoint point);
    afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
    afx_msg LRESULT OnRegisteredMouseWheel(WPARAM wParam, LPARAM lParam);
    afx_msg void OnRButtonDblClk(UINT nFlags, CPoint point);
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
    afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
    afx_msg void OnTimer(UINT_PTR nIDEvent);

// Initialization message handler member functions
    afx_msg void OnInitMenu(CMenu* pMenu);
    afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);

// Clipboard message handler member functions
    afx_msg void OnAskCbFormatName(UINT nMaxCount, LPTSTR lpszString);
    afx_msg void OnChangeCbChain(HWND hWndRemove, HWND hWndAfter);
    afx_msg void OnDestroyClipboard();
    afx_msg void OnDrawClipboard();
    afx_msg void OnHScrollClipboard(CWnd* pClipAppWnd, UINT nSBCode, UINT nPos);
    afx_msg void OnPaintClipboard(CWnd* pClipAppWnd, HGLOBAL hPaintStruct);
    afx_msg void OnRenderAllFormats();
    afx_msg void OnRenderFormat(UINT nFormat);
    afx_msg void OnSizeClipboard(CWnd* pClipAppWnd, HGLOBAL hRect);
    afx_msg void OnVScrollClipboard(CWnd* pClipAppWnd, UINT nSBCode, UINT nPos);

// Control message handler member functions
    afx_msg int OnCompareItem(int nIDCtl, LPCOMPAREITEMSTRUCT lpCompareItemStruct);
    afx_msg void OnDeleteItem(int nIDCtl, LPDELETEITEMSTRUCT lpDeleteItemStruct);
    afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
    afx_msg UINT OnGetDlgCode();
    afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    afx_msg int OnCharToItem(UINT nChar, CListBox* pListBox, UINT nIndex);
    afx_msg int OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT nIndex);

// MDI message handler member functions
    afx_msg void OnMDIActivate(BOOL bActivate,
            CWnd* pActivateWnd, CWnd* pDeactivateWnd);

// Menu loop notification messages
    afx_msg void OnEnterMenuLoop(BOOL bIsTrackPopupMenu);
    afx_msg void OnExitMenuLoop(BOOL bIsTrackPopupMenu);

// Win4 messages
    afx_msg void OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
    afx_msg void OnStyleChanging(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
    afx_msg void OnSizing(UINT nSide, LPRECT lpRect);
    afx_msg void OnMoving(UINT nSide, LPRECT lpRect);
    afx_msg void OnCaptureChanged(CWnd* pWnd);
    afx_msg BOOL OnDeviceChange(UINT nEventType, DWORD_PTR dwData);

// Overridables and other helpers (for implementation of derived classes)
protected:
    // for deriving from a standard control
    virtual WNDPROC* GetSuperWndProcAddr();

    // for dialog data exchange and validation
    virtual void DoDataExchange(CDataExchange* pDX);

public:
    // for modality
    virtual void BeginModalState();
    virtual void EndModalState();

    // for translating Windows messages in main message pump
    virtual BOOL PreTranslateMessage(MSG* pMsg);

#ifndef _AFX_NO_OCC_SUPPORT
    // for ambient properties exposed to contained OLE controls
    virtual BOOL OnAmbientProperty(COleControlSite* pSite, DISPID dispid,
            VARIANT* pvar);
#endif

protected:
    // for processing Windows messages
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    virtual BOOL OnWndMsg(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult);

    // for handling default processing
    LRESULT Default();
    virtual LRESULT DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam);

    // for custom cleanup after WM_NCDESTROY
    virtual void PostNcDestroy();

    // for notifications from parent
    virtual BOOL OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult);
            // return TRUE if parent should not process this message
    BOOL ReflectChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult);
    static BOOL PASCAL ReflectLastMsg(HWND hWndChild, LRESULT* pResult = NULL);

// Implementation
public:
    virtual ~CWnd();
    virtual BOOL CheckAutoCenter();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
#ifndef _AFX_NO_CTL3D_SUPPORT
    // 3D support (these APIs will be obsolete with next version of Windows)
    BOOL SubclassCtl3d(int nControlType = -1);
            // see CTL3D.H for list of control types
    BOOL SubclassDlg3d(DWORD dwMask = 0xFFFF /*CTL3D_ALL*/);
            // see CTL3D.H for list of mask values
#endif
    static BOOL PASCAL GrayCtlColor(HDC hDC, HWND hWnd, UINT nCtlColor,
            HBRUSH hbrGray, COLORREF clrText);
#ifndef _AFX_NO_GRAYDLG_SUPPORT
    HBRUSH OnGrayCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
#endif

    // helper routines for implementation
    BOOL HandleFloatingSysCommand(UINT nID, LPARAM lParam);
    BOOL IsTopParentActive() const;
    void ActivateTopParent();
    static BOOL PASCAL WalkPreTranslateTree(HWND hWndStop, MSG* pMsg);
    static CWnd* PASCAL GetDescendantWindow(HWND hWnd, int nID,
            BOOL bOnlyPerm);
    static void PASCAL SendMessageToDescendants(HWND hWnd, UINT message,
            WPARAM wParam, LPARAM lParam, BOOL bDeep, BOOL bOnlyPerm);
    virtual BOOL IsFrameWnd() const; // IsKindOf(RUNTIME_CLASS(CFrameWnd)))
    virtual void OnFinalRelease();
    BOOL PreTranslateInput(LPMSG lpMsg);
    static BOOL PASCAL ModifyStyle(HWND hWnd, DWORD dwRemove, DWORD dwAdd,
            UINT nFlags);
    static BOOL PASCAL ModifyStyleEx(HWND hWnd, DWORD dwRemove, DWORD dwAdd,
            UINT nFlags);
    static void PASCAL _FilterToolTipMessage(MSG* pMsg, CWnd* pWnd);
#if _MFC_VER>=0x0600
	BOOL _EnableToolTips(BOOL bEnable, UINT nFlag);
	static HWND PASCAL GetSafeOwner_(HWND hWnd, HWND* pWndTop);
#endif

public:
    HWND m_hWndOwner;   // implementation of SetOwner and GetOwner
    UINT m_nFlags;      // see WF_ flags above

protected:
    WNDPROC m_pfnSuper; // for subclassing of controls
    static const UINT m_nMsgDragList;
    int m_nModalResult; // for return values from CWnd::RunModalLoop

    COleDropTarget* m_pDropTarget;  // for automatic cleanup of drop target
    friend class COleDropTarget;
    friend class CFrameWnd;

    // for creating dialogs and dialog-like windows
    BOOL CreateDlg(LPCTSTR lpszTemplateName, CWnd* pParentWnd);
    BOOL CreateDlgIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd);
    BOOL CreateDlgIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd,
            HINSTANCE hInst);

#ifndef _AFX_NO_OCC_SUPPORT
    COleControlContainer* m_pCtrlCont;  // for containing OLE controls
    COleControlSite* m_pCtrlSite;       // for wrapping an OLE control
    friend class COccManager;
    friend class COleControlSite;
    friend class COleControlContainer;
    BOOL InitControlContainer();
    virtual BOOL SetOccDialogInfo(struct _AFX_OCC_DIALOG_INFO* pOccDialogInfo);
    void AttachControlSite(CHandleMap* pMap);
public:
    void AttachControlSite(CWnd* pWndParent);
#endif

protected:
    // implementation of message dispatch/hooking
    friend LRESULT CALLBACK _AfxSendMsgHook(int, WPARAM, LPARAM);
    friend void AFXAPI _AfxStandardSubclass(HWND);
    friend LRESULT CALLBACK _AfxCbtFilterHook(int, WPARAM, LPARAM);
    friend LRESULT AFXAPI AfxCallWndProc(CWnd*, HWND, UINT, WPARAM, LPARAM);

    // standard message implementation
    afx_msg LRESULT OnNTCtlColor(WPARAM wParam, LPARAM lParam);
#ifndef _AFX_NO_CTL3D_SUPPORT
    afx_msg LRESULT OnQuery3dControls(WPARAM, LPARAM);
#endif
    afx_msg LRESULT OnDisplayChange(WPARAM, LPARAM);
    afx_msg LRESULT OnDragList(WPARAM, LPARAM);

    //{{AFX_MSG(CWnd)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CWnd(HWND hWnd);    // just for special initialization
};

// helpers for registering your own WNDCLASSes
LPCTSTR AFXAPI AfxRegisterWndClass(UINT nClassStyle,
    HCURSOR hCursor = 0, HBRUSH hbrBackground = 0, HICON hIcon = 0);

BOOL AFXAPI AfxRegisterClass(WNDCLASS* lpWndClass);

// helper to initialize rich edit control
BOOL AFXAPI AfxInitRichEdit();

// Implementation
LRESULT CALLBACK AfxWndProc(HWND, UINT, WPARAM, LPARAM);

WNDPROC AFXAPI AfxGetAfxWndProc();
#define AfxWndProc (*AfxGetAfxWndProc())

typedef void (AFX_MSG_CALL CWnd::*AFX_PMSGW)(void);
    // like 'AFX_PMSG' but for CWnd derived classes only

typedef void (AFX_MSG_CALL CWinThread::*AFX_PMSGT)(void);
    // like 'AFX_PMSG' but for CWinThread-derived classes only

/////////////////////////////////////////////////////////////////////////////
// CDialog - a modal or modeless dialog

class CDialog : public CWnd
{
    DECLARE_DYNAMIC(CDialog)

    // Modeless construct
public:
    CDialog();

    BOOL Create(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
    BOOL Create(UINT nIDTemplate, CWnd* pParentWnd = NULL);
    BOOL CreateIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd = NULL,
            void* lpDialogInit = NULL);
    BOOL CreateIndirect(HGLOBAL hDialogTemplate, CWnd* pParentWnd = NULL);

    // Modal construct
public:
    CDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
    CDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);
    BOOL InitModalIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd = NULL,
            void* lpDialogInit = NULL);
    BOOL InitModalIndirect(HGLOBAL hDialogTemplate, CWnd* pParentWnd = NULL);

// Attributes
public:
    void MapDialogRect(LPRECT lpRect) const;
    void SetHelpID(UINT nIDR);

// Operations
public:
    // modal processing
    virtual INT_PTR DoModal();

    // support for passing on tab control - use 'PostMessage' if needed
    void NextDlgCtrl() const;
    void PrevDlgCtrl() const;
    void GotoDlgCtrl(CWnd* pWndCtrl);

    // default button access
    void SetDefID(UINT nID);
    DWORD GetDefID() const;

    // termination
    void EndDialog(int nResult);

// Overridables (special message map entries)
    virtual BOOL OnInitDialog();
    virtual void OnSetFont(CFont* pFont);
protected:
    virtual void OnOK();
    virtual void OnCancel();

// Implementation
public:
    virtual ~CDialog();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
            AFX_CMDHANDLERINFO* pHandlerInfo);
    virtual BOOL CheckAutoCenter();

protected:
    UINT m_nIDHelp;                 // Help ID (0 for none, see HID_BASE_RESOURCE)

    // parameters for 'DoModal'
    LPCTSTR m_lpszTemplateName;     // name or MAKEINTRESOURCE
    HGLOBAL m_hDialogTemplate;      // indirect (m_lpDialogTemplate == NULL)
    LPCDLGTEMPLATE m_lpDialogTemplate;  // indirect if (m_lpszTemplateName == NULL)
    void* m_lpDialogInit;           // DLGINIT resource data
    CWnd* m_pParentWnd;             // parent/owner window
    HWND m_hWndTop;                 // top level parent window (may be disabled)

#ifndef _AFX_NO_OCC_SUPPORT
    _AFX_OCC_DIALOG_INFO* m_pOccDialogInfo;
    virtual BOOL SetOccDialogInfo(_AFX_OCC_DIALOG_INFO* pOccDialogInfo);
#endif
    virtual void PreInitDialog();

    // implementation helpers
    HWND PreModal();
    void PostModal();

    BOOL CreateIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd,
            void* lpDialogInit, HINSTANCE hInst);
    BOOL CreateIndirect(HGLOBAL hDialogTemplate, CWnd* pParentWnd,
            HINSTANCE hInst);

protected:
    //{{AFX_MSG(CDialog)
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
    afx_msg LRESULT HandleSetFont(WPARAM, LPARAM);
    //}}AFX_MSG
#ifndef _AFX_NO_GRAYDLG_SUPPORT
    afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
#endif
    DECLARE_MESSAGE_MAP()
};

// all CModalDialog functionality is now in CDialog
#define CModalDialog    CDialog

/////////////////////////////////////////////////////////////////////////////
// Standard Windows controls

class CStatic : public CWnd
{
    DECLARE_DYNAMIC(CStatic)

// Constructors
public:
    CStatic();
    BOOL Create(LPCTSTR lpszText, DWORD dwStyle,
                            const RECT& rect, CWnd* pParentWnd, UINT nID = 0xffff);

// Operations
    HICON SetIcon(HICON hIcon);
    HICON GetIcon() const;

#if WINVER>=0x400
    HENHMETAFILE SetEnhMetaFile(HENHMETAFILE hMetaFile);
    HENHMETAFILE GetEnhMetaFile() const;
    HBITMAP SetBitmap(HBITMAP hBitmap);
    HBITMAP GetBitmap() const;
    HCURSOR SetCursor(HCURSOR hCursor);
    HCURSOR GetCursor();
#endif

// Implementation
public:
    virtual ~CStatic();
};

class CButton : public CWnd
{
    DECLARE_DYNAMIC(CButton)

// Constructors
public:
    CButton();
    BOOL Create(LPCTSTR lpszCaption, DWORD dwStyle,
                            const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
    UINT GetState() const;
    void SetState(BOOL bHighlight);
    int GetCheck() const;
    void SetCheck(int nCheck);
    UINT GetButtonStyle() const;
    void SetButtonStyle(UINT nStyle, BOOL bRedraw = TRUE);

#if WINVER>=0x400
    HICON SetIcon(HICON hIcon);
    HICON GetIcon() const;
    HBITMAP SetBitmap(HBITMAP hBitmap);
    HBITMAP GetBitmap() const;
    HCURSOR SetCursor(HCURSOR hCursor);
    HCURSOR GetCursor();
#endif

// Overridables (for owner draw only)
    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
    virtual ~CButton();
protected:
    virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

class CListBox : public CWnd
{
    DECLARE_DYNAMIC(CListBox)

// Constructors
public:
    CListBox();
    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes

    // for entire listbox
    int GetCount() const;
    int GetHorizontalExtent() const;
    void SetHorizontalExtent(int cxExtent);
    int GetTopIndex() const;
    int SetTopIndex(int nIndex);
    LCID GetLocale() const;
    LCID SetLocale(LCID nNewLocale);
#if WINVER>=0x400
    int InitStorage(int nItems, UINT nBytes);
    UINT ItemFromPoint(CPoint pt, BOOL& bOutside) const;
#endif
    // for single-selection listboxes
    int GetCurSel() const;
    int SetCurSel(int nSelect);

    // for multiple-selection listboxes
    int GetSel(int nIndex) const;           // also works for single-selection
    int SetSel(int nIndex, BOOL bSelect = TRUE);
    int GetSelCount() const;
    int GetSelItems(int nMaxItems, LPINT rgIndex) const;
    void SetAnchorIndex(int nIndex);
    int GetAnchorIndex() const;

    // for listbox items
    DWORD_PTR GetItemData(int nIndex) const;
    int SetItemData(int nIndex, DWORD_PTR dwItemData);
    void* GetItemDataPtr(int nIndex) const;
    int SetItemDataPtr(int nIndex, void* pData);
    int GetItemRect(int nIndex, LPRECT lpRect) const;
    int GetText(int nIndex, LPTSTR lpszBuffer) const;
    void GetText(int nIndex, CString& rString) const;
    int GetTextLen(int nIndex) const;

    // Settable only attributes
    void SetColumnWidth(int cxWidth);
    BOOL SetTabStops(int nTabStops, LPINT rgTabStops);
    void SetTabStops();
    BOOL SetTabStops(const int& cxEachStop);    // takes an 'int'

    int SetItemHeight(int nIndex, UINT cyItemHeight);
    int GetItemHeight(int nIndex) const;
    int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const;
    int GetCaretIndex() const;
    int SetCaretIndex(int nIndex, BOOL bScroll = TRUE);

// Operations
    // manipulating listbox items
    int AddString(LPCTSTR lpszItem);
    int DeleteString(UINT nIndex);
    int InsertString(int nIndex, LPCTSTR lpszItem);
    void ResetContent();
    int Dir(UINT attr, LPCTSTR lpszWildCard);

    // selection helpers
    int FindString(int nStartAfter, LPCTSTR lpszItem) const;
    int SelectString(int nStartAfter, LPCTSTR lpszItem);
    int SelItemRange(BOOL bSelect, int nFirstItem, int nLastItem);

// Overridables (must override draw, measure and compare for owner draw)
    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
    virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
    virtual void DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);
    virtual int VKeyToItem(UINT nKey, UINT nIndex);
    virtual int CharToItem(UINT nKey, UINT nIndex);

// Implementation
public:
    virtual ~CListBox();
protected:
    virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

class CCheckListBox : public CListBox
{
    DECLARE_DYNAMIC(CCheckListBox)

// Constructors
public:
    CCheckListBox();
    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
    void SetCheckStyle(UINT nStyle);
    UINT GetCheckStyle();
    void SetCheck(int nIndex, int nCheck);
    int GetCheck(int nIndex);
    void Enable(int nIndex, BOOL bEnabled = TRUE);
    BOOL IsEnabled(int nIndex);

    virtual CRect OnGetCheckPosition(CRect rectItem, CRect rectCheckBox);

// Overridables (must override draw, measure and compare for owner draw)
    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
    virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);

// Implementation
protected:
    void PreDrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
    void PreMeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    int PreCompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
    void PreDeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);

    virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);

#if _MFC_VER>=0x0600
    void SetSelectionCheck( int nCheck );
#endif

#ifdef _DEBUG
    virtual void PreSubclassWindow();
#endif

    int CalcMinimumItemHeight();
    void InvalidateCheck(int nIndex);
    void InvalidateItem(int nIndex);
    int CheckFromPoint(CPoint point, BOOL& bInCheck);

    int m_cyText;
    UINT m_nStyle;

    // Message map functions
protected:
    //{{AFX_MSG(CCheckListBox)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBAddString(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBFindString(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBFindStringExact(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBGetItemData(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBGetText(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBInsertString(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBSelectString(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBSetItemData(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBSetItemHeight(WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

class CComboBox : public CWnd
{
    DECLARE_DYNAMIC(CComboBox)

// Constructors
public:
    CComboBox();
    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
    // for entire combo box
    int GetCount() const;
    int GetCurSel() const;
    int SetCurSel(int nSelect);
    LCID GetLocale() const;
    LCID SetLocale(LCID nNewLocale);
// Win4
    int GetTopIndex() const;
    int SetTopIndex(int nIndex);
    int InitStorage(int nItems, UINT nBytes);
    void SetHorizontalExtent(UINT nExtent);
    UINT GetHorizontalExtent() const;
    int SetDroppedWidth(UINT nWidth);
    int GetDroppedWidth() const;

    // for edit control
    DWORD GetEditSel() const;
    BOOL LimitText(int nMaxChars);
    BOOL SetEditSel(int nStartChar, int nEndChar);

    // for combobox item
    DWORD_PTR GetItemData(int nIndex) const;
    int SetItemData(int nIndex, DWORD_PTR dwItemData);
    void* GetItemDataPtr(int nIndex) const;
    int SetItemDataPtr(int nIndex, void* pData);
    int GetLBText(int nIndex, LPTSTR lpszText) const;
    void GetLBText(int nIndex, CString& rString) const;
    int GetLBTextLen(int nIndex) const;

    int SetItemHeight(int nIndex, UINT cyItemHeight);
    int GetItemHeight(int nIndex) const;
    int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const;
    int SetExtendedUI(BOOL bExtended = TRUE);
    BOOL GetExtendedUI() const;
    void GetDroppedControlRect(LPRECT lprect) const;
    BOOL GetDroppedState() const;

// Operations
    // for drop-down combo boxes
    void ShowDropDown(BOOL bShowIt = TRUE);

    // manipulating listbox items
    int AddString(LPCTSTR lpszString);
    int DeleteString(UINT nIndex);
    int InsertString(int nIndex, LPCTSTR lpszString);
    void ResetContent();
    int Dir(UINT attr, LPCTSTR lpszWildCard);

    // selection helpers
    int FindString(int nStartAfter, LPCTSTR lpszString) const;
    int SelectString(int nStartAfter, LPCTSTR lpszString);

    // Clipboard operations
    void Clear();
    void Copy();
    void Cut();
    void Paste();

// Overridables (must override draw, measure and compare for owner draw)
    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
    virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
    virtual void DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);

// Implementation
public:
    virtual ~CComboBox();
protected:
    virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

class CEdit : public CWnd
{
    DECLARE_DYNAMIC(CEdit)

// Constructors
public:
    CEdit();
    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
    BOOL CanUndo() const;
    int GetLineCount() const;
    BOOL GetModify() const;
    void SetModify(BOOL bModified = TRUE);
    void GetRect(LPRECT lpRect) const;
    DWORD GetSel() const;
    void GetSel(int& nStartChar, int& nEndChar) const;
    HLOCAL GetHandle() const;
    void SetHandle(HLOCAL hBuffer);
#if WINVER>=0x400
    void SetMargins(UINT nLeft, UINT nRight);
    DWORD GetMargins() const;
    void SetLimitText(UINT nMax);
    UINT GetLimitText() const;
    CPoint PosFromChar(UINT nChar) const;
    int CharFromPos(CPoint pt) const;
#endif

    // NOTE: first word in lpszBuffer must contain the size of the buffer!
    int GetLine(int nIndex, LPTSTR lpszBuffer) const;
    int GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const;

// Operations
    void EmptyUndoBuffer();
    BOOL FmtLines(BOOL bAddEOL);

    void LimitText(int nChars = 0);
    int LineFromChar(int nIndex = -1) const;
    int LineIndex(int nLine = -1) const;
    int LineLength(int nLine = -1) const;
    void LineScroll(int nLines, int nChars = 0);
    void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE);
    void SetPasswordChar(TCHAR ch);
    void SetRect(LPCRECT lpRect);
    void SetRectNP(LPCRECT lpRect);
    void SetSel(DWORD dwSelection, BOOL bNoScroll = FALSE);
    void SetSel(int nStartChar, int nEndChar, BOOL bNoScroll = FALSE);
    BOOL SetTabStops(int nTabStops, LPINT rgTabStops);
    void SetTabStops();
    BOOL SetTabStops(const int& cxEachStop);    // takes an 'int'

    // Clipboard operations
    BOOL Undo();
    void Clear();
    void Copy();
    void Cut();
    void Paste();

    BOOL SetReadOnly(BOOL bReadOnly = TRUE);
    int GetFirstVisibleLine() const;
    TCHAR GetPasswordChar() const;

// Implementation
public:
    virtual ~CEdit();
};

class CScrollBar : public CWnd
{
    DECLARE_DYNAMIC(CScrollBar)

// Constructors
public:
    CScrollBar();
    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
    int GetScrollPos() const;
    int SetScrollPos(int nPos, BOOL bRedraw = TRUE);
    void GetScrollRange(LPINT lpMinPos, LPINT lpMaxPos) const;
    void SetScrollRange(int nMinPos, int nMaxPos, BOOL bRedraw = TRUE);
    void ShowScrollBar(BOOL bShow = TRUE);

    BOOL EnableScrollBar(UINT nArrowFlags = ESB_ENABLE_BOTH);

    BOOL SetScrollInfo(LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE);
    BOOL GetScrollInfo(LPSCROLLINFO lpScrollInfo, UINT nMask = SIF_ALL);
    int GetScrollLimit();

// Implementation
public:
    virtual ~CScrollBar();
};

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd - base class for SDI and other frame windows

// Frame window styles
#define FWS_ADDTOTITLE  0x00008000L // modify title based on content
#define FWS_PREFIXTITLE 0x00004000L // show document name before app name
#define FWS_SNAPTOBARS  0x00002000L // snap size to size of contained bars

struct CPrintPreviewState;  // forward reference (see afxext.h)
class CControlBar;          // forward reference (see afxext.h)
#if _MFC_VER>=0x0600
class CReBar;				// forward reference (see afxext.h)
#endif

class CDockBar;             // forward reference (see afxpriv.h)
class CMiniDockFrameWnd;    // forward reference (see afxpriv.h)
class CDockState;           // forward reference (see afxpriv.h)

class COleFrameHook;        // forward reference (see ..\src\oleimpl2.h)

class CFrameWnd : public CWnd
{
    DECLARE_DYNCREATE(CFrameWnd)

// Constructors
public:
    static AFX_DATA const CRect rectDefault;
    CFrameWnd();

    BOOL LoadAccelTable(LPCTSTR lpszResourceName);
    BOOL Create(LPCTSTR lpszClassName,
                            LPCTSTR lpszWindowName,
                            DWORD dwStyle = WS_OVERLAPPEDWINDOW,
                            const RECT& rect = rectDefault,
                            CWnd* pParentWnd = NULL,        // != NULL for popups
                            LPCTSTR lpszMenuName = NULL,
                            DWORD dwExStyle = 0,
                            CCreateContext* pContext = NULL);

    // dynamic creation - load frame and associated resources
    virtual BOOL LoadFrame(UINT nIDResource,
                            DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,
                            CWnd* pParentWnd = NULL,
                            CCreateContext* pContext = NULL);

    // special helper for view creation
    CWnd* CreateView(CCreateContext* pContext, UINT nID = AFX_IDW_PANE_FIRST);

// Attributes
    virtual CDocument* GetActiveDocument();

    // Active child view maintenance
    CView* GetActiveView() const;           // active view or NULL
    void SetActiveView(CView* pViewNew, BOOL bNotify = TRUE);
            // active view or NULL, bNotify == FALSE if focus should not be set

    // Active frame (for frames within frames -- MDI)
    virtual CFrameWnd* GetActiveFrame();

    // For customizing the default messages on the status bar
    virtual void GetMessageString(UINT nID, CString& rMessage) const;

    BOOL m_bAutoMenuEnable;
            // TRUE => menu items without handlers will be disabled

    BOOL IsTracking() const;

// Operations
    virtual void RecalcLayout(BOOL bNotify = TRUE);
    virtual void ActivateFrame(int nCmdShow = -1);
    void InitialUpdateFrame(CDocument* pDoc, BOOL bMakeVisible);
#if _MFC_VER>=0x0600
	void SetTitle(LPCTSTR lpszTitle);
	CString GetTitle() const;
#endif

    // to set text of standard status bar
    void SetMessageText(LPCTSTR lpszText);
    void SetMessageText(UINT nID);

    // control bar docking
    void EnableDocking(DWORD dwDockStyle);
    void DockControlBar(CControlBar* pBar, UINT nDockBarID = 0,
            LPCRECT lpRect = NULL);
    void FloatControlBar(CControlBar* pBar, CPoint point,
            DWORD dwStyle = CBRS_ALIGN_TOP);
    CControlBar* GetControlBar(UINT nID);

    // frame window based modality
    virtual void BeginModalState();
    virtual void EndModalState();
    BOOL InModalState() const;
    void ShowOwnedWindows(BOOL bShow);

    // saving and loading control bar state
    void LoadBarState(LPCTSTR lpszProfileName);
    void SaveBarState(LPCTSTR lpszProfileName) const;
    void ShowControlBar(CControlBar* pBar, BOOL bShow, BOOL bDelay);
    void SetDockState(const CDockState& state);
    void GetDockState(CDockState& state) const;

// Overridables
    virtual void OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState);
    virtual CWnd* GetMessageBar();

    // border space negotiation
    enum BorderCmd
            { borderGet = 1, borderRequest = 2, borderSet = 3 };
    virtual BOOL NegotiateBorderSpace(UINT nBorderCmd, LPRECT lpRectBorder);

protected:
    virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

// Command Handlers
public:
    afx_msg void OnContextHelp();   // for Shift+F1 help
    afx_msg void OnUpdateControlBarMenu(CCmdUI* pCmdUI);
    afx_msg BOOL OnBarCheck(UINT nID);

// Implementation
public:
    virtual ~CFrameWnd();
    int m_nWindow;  // general purpose window number - display as ":n"
                                    // -1 => unknown, 0 => only window viewing document
                                    // 1 => first of many windows viewing document, 2=> second

    HMENU m_hMenuDefault;       // default menu resource for this frame
    HACCEL m_hAccelTable;       // accelerator table
    DWORD m_dwPromptContext;    // current help prompt context for message box
    BOOL m_bHelpMode;           // if TRUE, then Shift+F1 help mode is active
    CFrameWnd* m_pNextFrameWnd; // next CFrameWnd in app global list
    CRect m_rectBorder;         // for OLE border space negotiation
    COleFrameHook* m_pNotifyHook;

    CPtrList m_listControlBars; // array of all control bars that have this
                                                            // window as their dock site
    int m_nShowDelay;           // SW_ command for delay show/hide

    CMiniDockFrameWnd* CreateFloatingFrame(DWORD dwStyle);
    DWORD CanDock(CRect rect, DWORD dwDockStyle,
            CDockBar** ppDockBar = NULL); // called by CDockContext
    void AddControlBar(CControlBar *pBar);
    void RemoveControlBar(CControlBar *pBar);
    void DockControlBar(CControlBar* pBar, CDockBar* pDockBar,
            LPCRECT lpRect = NULL);
    void ReDockControlBar(CControlBar* pBar, CDockBar* pDockBar,
            LPCRECT lpRect = NULL);
    void NotifyFloatingWindows(DWORD dwFlags);
    void DestroyDockBars();

protected:
    UINT m_nIDHelp;             // Help ID (0 for none, see HID_BASE_RESOURCE)
    UINT m_nIDTracking;         // tracking command ID or string IDS
    UINT m_nIDLastMessage;      // last displayed message string IDS
    CView* m_pViewActive;       // current active view
    BOOL (CALLBACK* m_lpfnCloseProc)(CFrameWnd* pFrameWnd);
    UINT m_cModalStack;         // BeginModalState depth
    HWND* m_phWndDisable;       // windows disabled because of BeginModalState
    HMENU m_hMenuAlt;           // menu to update to (NULL means default)
    CString m_strTitle;         // default title (original)
    BOOL m_bInRecalcLayout;     // avoid recursion in RecalcLayout
    CRuntimeClass* m_pFloatingFrameClass;
    static const DWORD dwDockBarMap[4][2];

public:
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
    virtual BOOL IsFrameWnd() const;
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
            AFX_CMDHANDLERINFO* pHandlerInfo);
    virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
    virtual void OnUpdateFrameMenu(HMENU hMenuAlt);
    virtual HACCEL GetDefaultAccelerator();
    virtual BOOL PreTranslateMessage(MSG* pMsg);

    // idle update of frame user interface
    enum IdleFlags
            { idleMenu = 1, idleTitle = 2, idleNotify = 4, idleLayout = 8 };
    UINT m_nIdleFlags;          // set of bit flags for idle processing
    virtual void DelayUpdateFrameMenu(HMENU hMenuAlt);
    void DelayUpdateFrameTitle();
    void DelayRecalcLayout(BOOL bNotify = TRUE);

    // for Shift+F1 help support
    BOOL CanEnterHelpMode();
    virtual void ExitHelpMode();

    // implementation helpers
#if _MFC_VER>=0x0600
    void UpdateFrameTitleForDocument(LPCTSTR lpszDocName);
protected:
#else
protected:
    void UpdateFrameTitleForDocument(LPCTSTR lpszDocName);
#endif
    LPCTSTR GetIconWndClass(DWORD dwDefaultStyle, UINT nIDResource);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void PostNcDestroy();   // default to delete this.
    int OnCreateHelper(LPCREATESTRUCT lpcs, CCreateContext* pContext);
    void BringToTop(int nCmdShow);
            // bring window to top for SW_ commands which affect z-order

    // implementation helpers for Shift+F1 help mode
    BOOL ProcessHelpMsg(MSG& msg, DWORD* pContext);
    HWND SetHelpCapture(POINT point, BOOL* pbDescendant);

    // CFrameWnd list management
    void AddFrameWnd();
    void RemoveFrameWnd();

    friend class CWnd;  // for access to m_bModalDisable
#if _MFC_VER>=0x0600
	friend class CReBar; // for access to m_bInRecalcLayout
#endif

    //{{AFX_MSG(CFrameWnd)
    // Windows messages
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    afx_msg void OnClose();
#if _MFC_VER>=0x0600
	afx_msg void OnInitMenu(CMenu*);
#endif
    afx_msg void OnInitMenuPopup(CMenu*, UINT, BOOL);
    afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);
    afx_msg LRESULT OnPopMessageString(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);
#if _MFC_VER>=0x0600
	afx_msg LRESULT OnHelpPromptAddr(WPARAM wParam, LPARAM lParam);
#endif
    afx_msg void OnIdleUpdateCmdUI();
    afx_msg void OnEnterIdle(UINT nWhy, CWnd* pWho);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
    afx_msg BOOL OnNcActivate(BOOL bActive);
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg BOOL OnQueryEndSession();
    afx_msg void OnEndSession(BOOL bEnding);
    afx_msg void OnDropFiles(HDROP hDropInfo);
    afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnActivateTopLevel(WPARAM wParam, LPARAM lParam);
    afx_msg void OnEnable(BOOL bEnable);
    afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
    afx_msg BOOL OnQueryNewPalette();
    // standard commands
    afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnUpdateKeyIndicator(CCmdUI* pCmdUI);
    afx_msg void OnHelp();
    afx_msg void OnUpdateContextHelp(CCmdUI* pCmdUI);
    //}}AFX_MSG
protected:
    afx_msg LRESULT OnDDEInitiate(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnDDEExecute(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnDDETerminate(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnRegisteredMouseWheel(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()

    friend class CWinApp;
};

/////////////////////////////////////////////////////////////////////////////
// MDI Support

class CMDIFrameWnd : public CFrameWnd
{
    DECLARE_DYNCREATE(CMDIFrameWnd)

public:
// Constructors
    CMDIFrameWnd();

// Operations
    void MDIActivate(CWnd* pWndActivate);
    CMDIChildWnd* MDIGetActive(BOOL* pbMaximized = NULL) const;
    void MDIIconArrange();
    void MDIMaximize(CWnd* pWnd);
    void MDINext();
    void MDIRestore(CWnd* pWnd);
    CMenu* MDISetMenu(CMenu* pFrameMenu, CMenu* pWindowMenu);
    void MDITile();
    void MDICascade();
    void MDITile(int nType);
    void MDICascade(int nType);
#if _MFC_VER>=0x0600
	CMDIChildWnd* CreateNewChild(CRuntimeClass* pClass,	UINT nResource,
		HMENU hMenu = NULL, HACCEL hAccel = NULL);
#endif

// Overridables
    // MFC 1.0 backward compatible CreateClient hook (called by OnCreateClient)
    virtual BOOL CreateClient(LPCREATESTRUCT lpCreateStruct, CMenu* pWindowMenu);
    // customize if using an 'Window' menu with non-standard IDs
    virtual HMENU GetWindowMenuPopup(HMENU hMenuBar);

// Implementation
public:
    HWND m_hWndMDIClient;       // MDI Client window handle

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual BOOL LoadFrame(UINT nIDResource,
                            DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,
                            CWnd* pParentWnd = NULL,
                            CCreateContext* pContext = NULL);
    virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
            AFX_CMDHANDLERINFO* pHandlerInfo);
    virtual void OnUpdateFrameMenu(HMENU hMenuAlt);
    virtual void DelayUpdateFrameMenu(HMENU hMenuAlt);
    virtual CFrameWnd* GetActiveFrame();

protected:
    virtual LRESULT DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam);
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

    //{{AFX_MSG(CMDIFrameWnd)
    afx_msg void OnDestroy();
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnUpdateMDIWindowCmd(CCmdUI* pCmdUI);
    afx_msg BOOL OnMDIWindowCmd(UINT nID);
    afx_msg void OnWindowNew();
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    afx_msg void OnIdleUpdateCmdUI();
    afx_msg LRESULT OnMenuChar(UINT nChar, UINT, CMenu*);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

class CMDIChildWnd : public CFrameWnd
{
    DECLARE_DYNCREATE(CMDIChildWnd)

// Constructors
public:
    CMDIChildWnd();

    virtual BOOL Create(LPCTSTR lpszClassName,
                            LPCTSTR lpszWindowName,
                            DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW,
                            const RECT& rect = rectDefault,
                            CMDIFrameWnd* pParentWnd = NULL,
                            CCreateContext* pContext = NULL);

// Attributes
    CMDIFrameWnd* GetMDIFrame();

// Operations
    void MDIDestroy();
    void MDIActivate();
    void MDIMaximize();
    void MDIRestore();
#if _MFC_VER>=0x0600
	void SetHandles(HMENU hMenu, HACCEL hAccel);
#endif

// Implementation
protected:
    HMENU m_hMenuShared;        // menu when we are active

public:
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle,
                                    CWnd* pParentWnd, CCreateContext* pContext = NULL);
            // 'pParentWnd' parameter is required for MDI Child
    virtual BOOL DestroyWindow();
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    virtual void ActivateFrame(int nCmdShow = -1);
    virtual void OnUpdateFrameMenu(BOOL bActive, CWnd* pActivateWnd,
            HMENU hMenuAlt);

    BOOL m_bPseudoInactive;     // TRUE if window is MDI active according to
                                                            //  windows, but not according to MFC...

protected:
    virtual CWnd* GetMessageBar();
    virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
    virtual LRESULT DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam);
    BOOL UpdateClientEdge(LPRECT lpRect = NULL);

    //{{AFX_MSG(CMDIChildWnd)
    afx_msg void OnMDIActivate(BOOL bActivate, CWnd*, CWnd*);
    afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnWindowPosChanging(LPWINDOWPOS lpWndPos);
    afx_msg BOOL OnNcActivate(BOOL bActive);
    afx_msg void OnDestroy();
#if _MFC_VER>=0x0600
	afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);
#endif
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CMiniFrameWnd

// MiniFrame window styles
#define MFS_SYNCACTIVE      0x00000100L // syncronize activation w/ parent
#define MFS_4THICKFRAME     0x00000200L // thick frame all around (no tiles)
#define MFS_THICKFRAME      0x00000400L // use instead of WS_THICKFRAME
#define MFS_MOVEFRAME       0x00000800L // no sizing, just moving
#define MFS_BLOCKSYSMENU    0x00001000L // block hit testing on system menu

class CMiniFrameWnd : public CFrameWnd
{
    DECLARE_DYNCREATE(CMiniFrameWnd)

// Constructors
public:
    CMiniFrameWnd();
    BOOL Create(LPCTSTR lpClassName, LPCTSTR lpWindowName,
            DWORD dwStyle, const RECT& rect,
            CWnd* pParentWnd = NULL, UINT nID = 0);
    BOOL CreateEx(DWORD dwExStyle, LPCTSTR lpClassName, LPCTSTR lpWindowName,
            DWORD dwStyle, const RECT& rect,
            CWnd* pParentWnd = NULL, UINT nID = 0);

// Implementation
public:
    ~CMiniFrameWnd();

    static void AFX_CDECL Initialize();

    //{{AFX_MSG(CMiniFrameWnd)
    afx_msg BOOL OnNcActivate(BOOL bActive);
    afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpParams);
    afx_msg UINT OnNcHitTest(CPoint point);
    afx_msg void OnNcPaint();
    afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint pt);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint pt);
    afx_msg void OnMouseMove(UINT nFlags, CPoint pt);
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO* pMMI);
    afx_msg LRESULT OnGetText(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetTextLength(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnFloatStatus(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnQueryCenterWnd(WPARAM wParam, LPARAM lParam);
    afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpcs);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    virtual void CalcWindowRect(LPRECT lpClientRect,
            UINT nAdjustType = adjustBorder);

    static void PASCAL CalcBorders(LPRECT lpClientRect,
            DWORD dwStyle = WS_THICKFRAME | WS_CAPTION, DWORD dwExStyle = 0);

protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

protected:
    BOOL m_bSysTracking;
    BOOL m_bInSys;
    BOOL m_bActive;
    CString m_strCaption;

    void InvertSysMenu();
};

/////////////////////////////////////////////////////////////////////////////
// class CView is the client area UI for a document

class CPrintDialog;     // forward reference (see afxdlgs.h)
class CPreviewView;     // forward reference (see afxpriv.h)
class CSplitterWnd;     // forward reference (see afxext.h)
class COleServerDoc;    // forward reference (see afxole.h)

typedef DWORD DROPEFFECT;
class COleDataObject;   // forward reference (see afxole.h)

#ifdef _AFXDLL
class CView : public CWnd
#else
class AFX_NOVTABLE CView : public CWnd
#endif
{
    DECLARE_DYNAMIC(CView)

// Constructors
protected:
    CView();

// Attributes
public:
    CDocument* GetDocument() const;

// Operations
public:
    // for standard printing setup (override OnPreparePrinting)
    BOOL DoPreparePrinting(CPrintInfo* pInfo);

// Overridables
public:
    virtual BOOL IsSelected(const CObject* pDocItem) const; // support for OLE

    // OLE scrolling support (used for drag/drop as well)
    virtual BOOL OnScroll(UINT nScrollCode, UINT nPos, BOOL bDoScroll = TRUE);
    virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll = TRUE);

    // OLE drag/drop support
    virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject,
            DWORD dwKeyState, CPoint point);
    virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject,
            DWORD dwKeyState, CPoint point);
    virtual void OnDragLeave();
    virtual BOOL OnDrop(COleDataObject* pDataObject,
            DROPEFFECT dropEffect, CPoint point);
    virtual DROPEFFECT OnDropEx(COleDataObject* pDataObject,
            DROPEFFECT dropDefault, DROPEFFECT dropList, CPoint point);
    virtual DROPEFFECT OnDragScroll(DWORD dwKeyState, CPoint point);

    virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);

    virtual void OnInitialUpdate(); // called first time after construct

protected:
    // Activation
    virtual void OnActivateView(BOOL bActivate, CView* pActivateView,
                                    CView* pDeactiveView);
    virtual void OnActivateFrame(UINT nState, CFrameWnd* pFrameWnd);

    // General drawing/updating
    virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    virtual void OnDraw(CDC* pDC) = 0;

    // Printing support
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
            // must override to enable printing and print preview

    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

    // Advanced: end print preview mode, move to point
    virtual void OnEndPrintPreview(CDC* pDC, CPrintInfo* pInfo, POINT point,
            CPreviewView* pView);

// Implementation
public:
    virtual ~CView();
#ifdef _DEBUG
    virtual void Dump(CDumpContext&) const;
    virtual void AssertValid() const;
#endif //_DEBUG

    // Advanced: for implementing custom print preview
    BOOL DoPrintPreview(UINT nIDResource, CView* pPrintView,
                    CRuntimeClass* pPreviewViewClass, CPrintPreviewState* pState);

    virtual void CalcWindowRect(LPRECT lpClientRect,
            UINT nAdjustType = adjustBorder);
    virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
    static CSplitterWnd* PASCAL GetParentSplitter(
            const CWnd* pWnd, BOOL bAnyState);

protected:
    CDocument* m_pDocument;

#if _MFC_VER>=0x600
public:
#endif
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
            AFX_CMDHANDLERINFO* pHandlerInfo);
#if _MFC_VER>=0x600
protected:
#endif
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void PostNcDestroy();

    // friend classes that call protected CView overridables
    friend class CDocument;
    friend class CDocTemplate;
    friend class CPreviewView;
    friend class CFrameWnd;
    friend class CMDIFrameWnd;
    friend class CMDIChildWnd;
    friend class CSplitterWnd;
    friend class COleServerDoc;
    friend class CDocObjectServer;

    //{{AFX_MSG(CView)
    afx_msg int OnCreate(LPCREATESTRUCT lpcs);
    afx_msg void OnDestroy();
    afx_msg void OnPaint();
    afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
    // commands
    afx_msg void OnUpdateSplitCmd(CCmdUI* pCmdUI);
    afx_msg BOOL OnSplitCmd(UINT nID);
    afx_msg void OnUpdateNextPaneMenu(CCmdUI* pCmdUI);
    afx_msg BOOL OnNextPaneCmd(UINT nID);

    // not mapped commands - must be mapped in derived class
    afx_msg void OnFilePrint();
    afx_msg void OnFilePrintPreview();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// class CCtrlView allows almost any control to be a view

#ifdef _AFXDLL
class CCtrlView : public CView
#else
class AFX_NOVTABLE CCtrlView : public CView
#endif
{
    DECLARE_DYNCREATE(CCtrlView)

public:
    CCtrlView(LPCTSTR lpszClass, DWORD dwStyle);

// Attributes
protected:
    CString m_strClass;
    DWORD m_dwDefaultStyle;

// Overrides
    virtual void OnDraw(CDC*);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// Implementation
public:
#ifdef _DEBUG
    virtual void Dump(CDumpContext&) const;
    virtual void AssertValid() const;
#endif //_DEBUG

protected:
    afx_msg void OnPaint();
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// class CScrollView supports simple scrolling and scaling

class CScrollView : public CView
{
    DECLARE_DYNAMIC(CScrollView)

// Constructors
protected:
    CScrollView();

public:
    static AFX_DATA const SIZE sizeDefault;
            // used to specify default calculated page and line sizes

    // in logical units - call one of the following Set routines
    void SetScaleToFitSize(SIZE sizeTotal);
    void SetScrollSizes(int nMapMode, SIZE sizeTotal,
                            const SIZE& sizePage = sizeDefault,
                            const SIZE& sizeLine = sizeDefault);

// Attributes
public:
    CPoint GetScrollPosition() const;       // upper corner of scrolling
    CSize GetTotalSize() const;             // logical size

    // for device units
    CPoint GetDeviceScrollPosition() const;
    void GetDeviceScrollSizes(int& nMapMode, SIZE& sizeTotal,
                    SIZE& sizePage, SIZE& sizeLine) const;

// Operations
public:
    void ScrollToPosition(POINT pt);    // set upper left position
    void FillOutsideRect(CDC* pDC, CBrush* pBrush);
    void ResizeParentToFit(BOOL bShrinkOnly = TRUE);
    BOOL DoMouseWheel(UINT fFlags, short zDelta, CPoint point);

// Implementation
protected:
    int m_nMapMode;
    CSize m_totalLog;           // total size in logical units (no rounding)
    CSize m_totalDev;           // total size in device units
    CSize m_pageDev;            // per page scroll size in device units
    CSize m_lineDev;            // per line scroll size in device units

    BOOL m_bCenter;             // Center output if larger than total size
    BOOL m_bInsideUpdate;       // internal state for OnSize callback
    void CenterOnPoint(CPoint ptCenter);
    void ScrollToDevicePosition(POINT ptDev); // explicit scrolling no checking

protected:
    virtual void OnDraw(CDC* pDC) = 0;      // pass on pure virtual

    void UpdateBars();          // adjust scrollbars etc
    BOOL GetTrueClientSize(CSize& size, CSize& sizeSb);
            // size with no bars
    void GetScrollBarSizes(CSize& sizeSb);
    void GetScrollBarState(CSize sizeClient, CSize& needSb,
            CSize& sizeRange, CPoint& ptMove, BOOL bInsideClient);

public:
    virtual ~CScrollView();
#ifdef _DEBUG
    virtual void Dump(CDumpContext&) const;
    virtual void AssertValid() const;
#endif //_DEBUG
    virtual void CalcWindowRect(LPRECT lpClientRect,
            UINT nAdjustType = adjustBorder);
    virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);

    // scrolling implementation support for OLE
    virtual BOOL OnScroll(UINT nScrollCode, UINT nPos, BOOL bDoScroll = TRUE);
    virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll = TRUE);

    //{{AFX_MSG(CScrollView)
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg BOOL OnMouseWheel(UINT fFlags, short zDelta, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CWinThread

typedef UINT (AFX_CDECL *AFX_THREADPROC)(LPVOID);

class COleMessageFilter;        // forward reference (see afxole.h)

class CWinThread : public CCmdTarget
{
    DECLARE_DYNAMIC(CWinThread)

public:
// Constructors
    CWinThread();
    BOOL CreateThread(DWORD dwCreateFlags = 0, UINT nStackSize = 0,
            LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);

// Attributes
    CWnd* m_pMainWnd;       // main window (usually same AfxGetApp()->m_pMainWnd)
    CWnd* m_pActiveWnd;     // active main window (may not be m_pMainWnd)
    BOOL m_bAutoDelete;     // enables 'delete this' after thread termination

    // only valid while running
    HANDLE m_hThread;       // this thread's HANDLE
    operator HANDLE() const;
    DWORD m_nThreadID;      // this thread's ID

    int GetThreadPriority();
    BOOL SetThreadPriority(int nPriority);

// Operations
    DWORD SuspendThread();
    DWORD ResumeThread();
    BOOL PostThreadMessage(UINT message, WPARAM wParam, LPARAM lParam);

// Overridables
    // thread initialization
    virtual BOOL InitInstance();

    // running and idle processing
    virtual int Run();
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    virtual BOOL PumpMessage();     // low level message pump
    virtual BOOL OnIdle(LONG lCount); // return TRUE if more idle processing
    virtual BOOL IsIdleMessage(MSG* pMsg);  // checks for special messages

    // thread termination
    virtual int ExitInstance(); // default will 'delete this'

    // Advanced: exception handling
    virtual LRESULT ProcessWndProcException(CException* e, const MSG* pMsg);

    // Advanced: handling messages sent to message filter hook
    virtual BOOL ProcessMessageFilter(int code, LPMSG lpMsg);

    // Advanced: virtual access to m_pMainWnd
    virtual CWnd* GetMainWnd();

// Implementation
public:
    virtual ~CWinThread();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
    int m_nDisablePumpCount; // Diagnostic trap to detect illegal re-entrancy
#endif
    void CommonConstruct();
    virtual void Delete();
            // 'delete this' only if m_bAutoDelete == TRUE

    // message pump for Run
    MSG m_msgCur;                   // current message

public:
    // constructor used by implementation of AfxBeginThread
    CWinThread(AFX_THREADPROC pfnThreadProc, LPVOID pParam);

    // valid after construction
    LPVOID m_pThreadParams; // generic parameters passed to starting function
    AFX_THREADPROC m_pfnThreadProc;

    // set after OLE is initialized
    void (AFXAPI* m_lpfnOleTermOrFreeLib)(BOOL, BOOL);
    COleMessageFilter* m_pMessageFilter;

protected:
    CPoint m_ptCursorLast;      // last mouse position
    UINT m_nMsgLast;            // last mouse message
    BOOL DispatchThreadMessageEx(MSG* msg);  // helper
    void DispatchThreadMessage(MSG* msg);  // obsolete
};

// global helpers for threads

CWinThread* AFXAPI AfxBeginThread(AFX_THREADPROC pfnThreadProc, LPVOID pParam,
    int nPriority = THREAD_PRIORITY_NORMAL, UINT nStackSize = 0,
    DWORD dwCreateFlags = 0, LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);
CWinThread* AFXAPI AfxBeginThread(CRuntimeClass* pThreadClass,
    int nPriority = THREAD_PRIORITY_NORMAL, UINT nStackSize = 0,
    DWORD dwCreateFlags = 0, LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);

CWinThread* AFXAPI AfxGetThread();
void AFXAPI AfxEndThread(UINT nExitCode, BOOL bDelete = TRUE);

void AFXAPI AfxInitThread();
void AFXAPI AfxTermThread(HINSTANCE hInstTerm = NULL);

/////////////////////////////////////////////////////////////////////////////
// Global functions for access to the one and only CWinApp

#define afxCurrentWinApp    AfxGetModuleState()->m_pCurrentWinApp
#define afxCurrentInstanceHandle    AfxGetModuleState()->m_hCurrentInstanceHandle
#define afxCurrentResourceHandle    AfxGetModuleState()->m_hCurrentResourceHandle
#define afxCurrentAppName   AfxGetModuleState()->m_lpszCurrentAppName
#define afxContextIsDLL     AfxGetModuleState()->m_bDLL
#define afxRegisteredClasses    AfxGetModuleState()->m_fRegisteredClasses

#ifndef _AFX_NO_OCC_SUPPORT
#define afxOccManager   AfxGetModuleState()->m_pOccManager
#endif

// Advanced initialization: for overriding default WinMain
BOOL AFXAPI AfxWinInit(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    LPTSTR lpCmdLine, int nCmdShow);
void AFXAPI AfxWinTerm();

// Global Windows state data helper functions (inlines)
CWinApp* AFXAPI AfxGetApp();
CWnd* AFXAPI AfxGetMainWnd();
HINSTANCE AFXAPI AfxGetInstanceHandle();
HINSTANCE AFXAPI AfxGetResourceHandle();
void AFXAPI AfxSetResourceHandle(HINSTANCE hInstResource);
LPCTSTR AFXAPI AfxGetAppName();

// Use instead of PostQuitMessage in OLE server applications
void AFXAPI AfxPostQuitMessage(int nExitCode);

// Use AfxFindResourceHandle to find resource in chain of extension DLLs
#ifndef _AFXDLL
#define AfxFindResourceHandle(lpszResource, lpszType) AfxGetResourceHandle()
#else
HINSTANCE AFXAPI AfxFindResourceHandle(LPCTSTR lpszName, LPCTSTR lpszType);
#endif

#if _MFC_VER>=0x0600
LONG AFXAPI AfxDelRegTreeHelper(HKEY hParentKey, const CString& strKeyName);
#endif

class CRecentFileList;          // forward reference (see afxpriv.h)

// access to message filter in CWinApp
COleMessageFilter* AFXAPI AfxOleGetMessageFilter();

/////////////////////////////////////////////////////////////////////////////
// CCommandLineInfo

class CCommandLineInfo : public CObject
{
public:
    // Sets default values
    CCommandLineInfo();

    //plain char* version on UNICODE for source-code backwards compatibility
    virtual void ParseParam(const TCHAR* pszParam, BOOL bFlag, BOOL bLast);
#ifdef _UNICODE
    virtual void ParseParam(const char* pszParam, BOOL bFlag, BOOL bLast);
#endif

    BOOL m_bShowSplash;
    BOOL m_bRunEmbedded;
    BOOL m_bRunAutomated;
    enum { FileNew, FileOpen, FilePrint, FilePrintTo, FileDDE,
            AppUnregister, FileNothing = -1 } m_nShellCommand;

    // not valid for FileNew
    CString m_strFileName;

    // valid only for FilePrintTo
    CString m_strPrinterName;
    CString m_strDriverName;
    CString m_strPortName;

    ~CCommandLineInfo();
// Implementation
protected:
    void ParseParamFlag(const char* pszParam);
    void ParseParamNotFlag(const TCHAR* pszParam);
#ifdef _UNICODE
    void ParseParamNotFlag(const char* pszParam);
#endif
    void ParseLast(BOOL bLast);
};

/////////////////////////////////////////////////////////////////////////////
// CDocManager

class CDocManager : public CObject
{
    DECLARE_DYNAMIC(CDocManager)
public:

// Constructor
    CDocManager();

    //Document functions
    virtual void AddDocTemplate(CDocTemplate* pTemplate);
    virtual POSITION GetFirstDocTemplatePosition() const;
    virtual CDocTemplate* GetNextDocTemplate(POSITION& pos) const;
    virtual void RegisterShellFileTypes(BOOL bCompat);
    void UnregisterShellFileTypes();
    virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName); // open named file
    virtual BOOL SaveAllModified(); // save before exit
    virtual void CloseAllDocuments(BOOL bEndSession); // close documents before exiting
    virtual int GetOpenDocumentCount();

    // helper for standard commdlg dialogs
    virtual BOOL DoPromptFileName(CString& fileName, UINT nIDSTitle,
                    DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate);

//Commands
    // Advanced: process async DDE request
    virtual BOOL OnDDECommand(LPTSTR lpszCommand);
    virtual void OnFileNew();
    virtual void OnFileOpen();

// Implementation
protected:
    CPtrList m_templateList;
#if _MFC_VER>=0x0600
	int GetDocumentCount();	// helper to count number of total documents
#endif

public:
    static CPtrList* pStaticList;       // for static CDocTemplate objects
    static BOOL bStaticInit;            // TRUE during static initialization
    static CDocManager* pStaticDocManager;  // for static CDocTemplate objects

public:
    virtual ~CDocManager();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CWinApp - the root of all Windows applications

#if defined
#define Enable3dControls()
#define Enable3dControlsStatic()
#endif

#define _AFX_MRU_COUNT   4      // default support for 4 entries in file MRU
#define _AFX_MRU_MAX_COUNT 16   // currently allocated id range supports 16

class CWinApp : public CWinThread
{
    DECLARE_DYNAMIC(CWinApp)
public:

// Constructor
    CWinApp(LPCTSTR lpszAppName = NULL);     // app name defaults to EXE name

// Attributes
    // Startup args (do not change)
    HINSTANCE m_hInstance;
    HINSTANCE m_hPrevInstance;
    LPTSTR m_lpCmdLine;
    int m_nCmdShow;

    // Running args (can be changed in InitInstance)
    LPCTSTR m_pszAppName;  // human readable name
                                                            //  (from constructor or AFX_IDS_APP_TITLE)
    LPCTSTR m_pszRegistryKey;   // used for registry entries
    CDocManager* m_pDocManager;

    // Support for Shift+F1 help mode.
    BOOL m_bHelpMode;           // are we in Shift+F1 mode?

public:  // set in constructor to override default
    LPCTSTR m_pszExeName;       // executable name (no spaces)
    LPCTSTR m_pszHelpFilePath;  // default based on module path
    LPCTSTR m_pszProfileName;   // default based on app name

// Initialization Operations - should be done in InitInstance
protected:
    void LoadStdProfileSettings(UINT nMaxMRU = _AFX_MRU_COUNT); // load MRU file list and last preview state
    void EnableShellOpen();

#ifndef _AFX_NO_GRAYDLG_SUPPORT
    void SetDialogBkColor(COLORREF clrCtlBk = RGB(192, 192, 192),
                            COLORREF clrCtlText = RGB(0, 0, 0));
            // set dialog box and message box background color
#endif

    void SetRegistryKey(LPCTSTR lpszRegistryKey);
    void SetRegistryKey(UINT nIDRegistryKey);
            // enables app settings in registry instead of INI files
            //  (registry key is usually a "company name")

#if !defined
    BOOL Enable3dControls(); // use CTL3D32.DLL for 3D controls in dialogs
#ifndef _AFXDLL
    BOOL Enable3dControlsStatic();  // statically link CTL3D.LIB instead
#endif
#endif

    void RegisterShellFileTypes(BOOL bCompat=FALSE);
            // call after all doc templates are registered
    void RegisterShellFileTypesCompat();
            // for backwards compatibility
    void UnregisterShellFileTypes();

// Helper Operations - usually done in InitInstance
public:
    // Cursors
    HCURSOR LoadCursor(LPCTSTR lpszResourceName) const;
    HCURSOR LoadCursor(UINT nIDResource) const;
    HCURSOR LoadStandardCursor(LPCTSTR lpszCursorName) const; // for IDC_ values
    HCURSOR LoadOEMCursor(UINT nIDCursor) const;             // for OCR_ values

    // Icons
    HICON LoadIcon(LPCTSTR lpszResourceName) const;
    HICON LoadIcon(UINT nIDResource) const;
    HICON LoadStandardIcon(LPCTSTR lpszIconName) const;       // for IDI_ values
    HICON LoadOEMIcon(UINT nIDIcon) const;                   // for OIC_ values

    // Profile settings (to the app specific .INI file, or registry)
    UINT GetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nDefault);
    BOOL WriteProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nValue);
    CString GetProfileString(LPCTSTR lpszSection, LPCTSTR lpszEntry,
                            LPCTSTR lpszDefault = NULL);
    BOOL WriteProfileString(LPCTSTR lpszSection, LPCTSTR lpszEntry,
                            LPCTSTR lpszValue);
    BOOL GetProfileBinary(LPCTSTR lpszSection, LPCTSTR lpszEntry,
                            LPBYTE* ppData, UINT* pBytes);
    BOOL WriteProfileBinary(LPCTSTR lpszSection, LPCTSTR lpszEntry,
                            LPBYTE pData, UINT nBytes);

    BOOL Unregister();
    LONG DelRegTree(HKEY hParentKey, const CString& strKeyName);

// Running Operations - to be done on a running application
    // Dealing with document templates
    void AddDocTemplate(CDocTemplate* pTemplate);
    POSITION GetFirstDocTemplatePosition() const;
    CDocTemplate* GetNextDocTemplate(POSITION& pos) const;

    // Dealing with files
    virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName); // open named file
    virtual void AddToRecentFileList(LPCTSTR lpszPathName);  // add to MRU

    // Printer DC Setup routine, 'struct tagPD' is a PRINTDLG structure
    void SelectPrinter(HANDLE hDevNames, HANDLE hDevMode,
            BOOL bFreeOld = TRUE);
    BOOL CreatePrinterDC(CDC& dc);
#ifndef _UNICODE
    BOOL GetPrinterDeviceDefaults(struct tagPDA* pPrintDlg);
#else
    BOOL GetPrinterDeviceDefaults(struct tagPDW* pPrintDlg);
#endif

    // Command line parsing
    BOOL RunEmbedded();
    BOOL RunAutomated();
    void ParseCommandLine(CCommandLineInfo& rCmdInfo);
    BOOL ProcessShellCommand(CCommandLineInfo& rCmdInfo);

// Overridables
    // hooks for your initialization code
    virtual BOOL InitApplication();

    // exiting
    virtual BOOL SaveAllModified(); // save before exit
    void HideApplication();
    void CloseAllDocuments(BOOL bEndSession); // close documents before exiting

    // Advanced: to override message boxes and other hooks
    virtual int DoMessageBox(LPCTSTR lpszPrompt, UINT nType, UINT nIDPrompt);
    virtual void DoWaitCursor(int nCode); // 0 => restore, 1=> begin, -1=> end

    // Advanced: process async DDE request
    virtual BOOL OnDDECommand(LPTSTR lpszCommand);

    // Advanced: Help support
    virtual void WinHelp(DWORD_PTR dwData, UINT nCmd = HELP_CONTEXT);

// Command Handlers
protected:
    // map to the following for file new/open
    afx_msg void OnFileNew();
    afx_msg void OnFileOpen();

    // map to the following to enable print setup
    afx_msg void OnFilePrintSetup();

    // map to the following to enable help
    afx_msg void OnContextHelp();   // shift-F1
    afx_msg void OnHelp();          // F1 (uses current context)
    afx_msg void OnHelpIndex();     // ID_HELP_INDEX
    afx_msg void OnHelpFinder();    // ID_HELP_FINDER, ID_DEFAULT_HELP
    afx_msg void OnHelpUsing();     // ID_HELP_USING

// Implementation
protected:
    HGLOBAL m_hDevMode;             // printer Dev Mode
    HGLOBAL m_hDevNames;            // printer Device Names
    DWORD m_dwPromptContext;        // help context override for message box

    int m_nWaitCursorCount;         // for wait cursor (>0 => waiting)
    HCURSOR m_hcurWaitCursorRestore; // old cursor to restore after wait cursor

    CRecentFileList* m_pRecentFileList;

    void UpdatePrinterSelection(BOOL bForceDefaults);
    void SaveStdProfileSettings();  // save options to .INI file

public: // public for implementation access
    CCommandLineInfo* m_pCmdInfo;

    ATOM m_atomApp, m_atomSystemTopic;   // for DDE open
    UINT m_nNumPreviewPages;        // number of default printed pages

    size_t  m_nSafetyPoolSize;      // ideal size

    void (AFXAPI* m_lpfnDaoTerm)();

    void DevModeChange(LPTSTR lpDeviceName);
    void SetCurrentHandles();
    int GetOpenDocumentCount();

    // helpers for standard commdlg dialogs
    BOOL DoPromptFileName(CString& fileName, UINT nIDSTitle,
                    DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate);
    INT_PTR DoPrintDialog(CPrintDialog* pPD);

    void EnableModeless(BOOL bEnable); // to disable OLE in-place dialogs

    // overrides for implementation
    virtual BOOL InitInstance();
    virtual int ExitInstance(); // return app exit code
    virtual int Run();
    virtual BOOL OnIdle(LONG lCount); // return TRUE if more idle processing
    virtual LRESULT ProcessWndProcException(CException* e, const MSG* pMsg);

public:
    virtual ~CWinApp();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    // helpers for registration
    HKEY GetSectionKey(LPCTSTR lpszSection);
    HKEY GetAppRegistryKey();

protected:
    //{{AFX_MSG(CWinApp)
    afx_msg void OnAppExit();
    afx_msg void OnUpdateRecentFileMenu(CCmdUI* pCmdUI);
    afx_msg BOOL OnOpenRecentFile(UINT nID);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// class CWaitCursor

class CWaitCursor
{
// Construction/Destruction
public:
    CWaitCursor();
    ~CWaitCursor();

// Operations
public:
    void Restore();
};

/////////////////////////////////////////////////////////////////////////////
// class CDocTemplate creates documents

#ifdef _AFXDLL
class CDocTemplate : public CCmdTarget
#else
class AFX_NOVTABLE CDocTemplate : public CCmdTarget
#endif
{
    DECLARE_DYNAMIC(CDocTemplate)

// Constructors
protected:
    CDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
            CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);

public:
    virtual void LoadTemplate();

// Attributes
public:
    // setup for OLE containers
    void SetContainerInfo(UINT nIDOleInPlaceContainer);

    // setup for OLE servers
    void SetServerInfo(UINT nIDOleEmbedding, UINT nIDOleInPlaceServer = 0,
            CRuntimeClass* pOleFrameClass = NULL, CRuntimeClass* pOleViewClass = NULL);

    // iterating over open documents
    virtual POSITION GetFirstDocPosition() const = 0;
    virtual CDocument* GetNextDoc(POSITION& rPos) const = 0;

// Operations
public:
    virtual void AddDocument(CDocument* pDoc);      // must override
    virtual void RemoveDocument(CDocument* pDoc);   // must override

    enum DocStringIndex
    {
            windowTitle,        // default window title
            docName,            // user visible name for default document
            fileNewName,        // user visible name for FileNew
            // for file based documents:
            filterName,         // user visible name for FileOpen
            filterExt,          // user visible extension for FileOpen
            // for file based documents with Shell open support:
            regFileTypeId,      // REGEDIT visible registered file type identifier
            regFileTypeName,    // Shell visible registered file type name
    };
    virtual BOOL GetDocString(CString& rString,
            enum DocStringIndex index) const; // get one of the info strings
    CFrameWnd* CreateOleFrame(CWnd* pParentWnd, CDocument* pDoc,
            BOOL bCreateView);

// Overridables
public:
    enum Confidence
    {
            noAttempt,
            maybeAttemptForeign,
            maybeAttemptNative,
            yesAttemptForeign,
            yesAttemptNative,
            yesAlreadyOpen
    };
    virtual Confidence MatchDocType(LPCTSTR lpszPathName,
                                    CDocument*& rpDocMatch);
    virtual CDocument* CreateNewDocument();
    virtual CFrameWnd* CreateNewFrame(CDocument* pDoc, CFrameWnd* pOther);
    virtual void InitialUpdateFrame(CFrameWnd* pFrame, CDocument* pDoc,
            BOOL bMakeVisible = TRUE);
    virtual BOOL SaveAllModified();     // for all documents
    virtual void CloseAllDocuments(BOOL bEndSession);
    virtual CDocument* OpenDocumentFile(
            LPCTSTR lpszPathName, BOOL bMakeVisible = TRUE) = 0;
                                    // open named file
                                    // if lpszPathName == NULL => create new file with this type
    virtual void SetDefaultTitle(CDocument* pDocument) = 0;

// Implementation
public:
    BOOL m_bAutoDelete;
    virtual ~CDocTemplate();

    // back pointer to OLE or other server (NULL if none or disabled)
    CObject* m_pAttachedFactory;

    // menu & accelerator resources for in-place container
    HMENU m_hMenuInPlace;
    HACCEL m_hAccelInPlace;

    // menu & accelerator resource for server editing embedding
    HMENU m_hMenuEmbedding;
    HACCEL m_hAccelEmbedding;

    // menu & accelerator resource for server editing in-place
    HMENU m_hMenuInPlaceServer;
    HACCEL m_hAccelInPlaceServer;

#ifdef _DEBUG
    virtual void Dump(CDumpContext&) const;
    virtual void AssertValid() const;
#endif
    virtual void OnIdle();             // for all documents
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
            AFX_CMDHANDLERINFO* pHandlerInfo);

protected:
    UINT m_nIDResource;                 // IDR_ for frame/menu/accel as well
    UINT m_nIDServerResource;           // IDR_ for OLE inplace frame/menu/accel
    UINT m_nIDEmbeddingResource;        // IDR_ for OLE open frame/menu/accel
    UINT m_nIDContainerResource;        // IDR_ for container frame/menu/accel

    CRuntimeClass* m_pDocClass;         // class for creating new documents
    CRuntimeClass* m_pFrameClass;       // class for creating new frames
    CRuntimeClass* m_pViewClass;        // class for creating new views
    CRuntimeClass* m_pOleFrameClass;    // class for creating in-place frame
    CRuntimeClass* m_pOleViewClass;     // class for creating in-place view

    CString m_strDocStrings;    // '\n' separated names
            // The document names sub-strings are represented as _one_ string:
            // windowTitle\ndocName\n ... (see DocStringIndex enum)
};

// SDI support (1 document only)
class CSingleDocTemplate : public CDocTemplate
{
    DECLARE_DYNAMIC(CSingleDocTemplate)

// Constructors
public:
    CSingleDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
            CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);

// Implementation
public:
    virtual ~CSingleDocTemplate();
    virtual void AddDocument(CDocument* pDoc);
    virtual void RemoveDocument(CDocument* pDoc);
    virtual POSITION GetFirstDocPosition() const;
    virtual CDocument* GetNextDoc(POSITION& rPos) const;
    virtual CDocument* OpenDocumentFile(
            LPCTSTR lpszPathName, BOOL bMakeVisible = TRUE);
    virtual void SetDefaultTitle(CDocument* pDocument);

#ifdef _DEBUG
    virtual void Dump(CDumpContext&) const;
    virtual void AssertValid() const;
#endif //_DEBUG

protected:  // standard implementation
    CDocument* m_pOnlyDoc;
};

// MDI support (zero or more documents)
class CMultiDocTemplate : public CDocTemplate
{
    DECLARE_DYNAMIC(CMultiDocTemplate)

// Constructors
public:
    CMultiDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
            CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);

// Implementation
public:
    // Menu and accel table for MDI Child windows of this type
    HMENU m_hMenuShared;
    HACCEL m_hAccelTable;

    virtual ~CMultiDocTemplate();
    virtual void LoadTemplate();
    virtual void AddDocument(CDocument* pDoc);
    virtual void RemoveDocument(CDocument* pDoc);
    virtual POSITION GetFirstDocPosition() const;
    virtual CDocument* GetNextDoc(POSITION& rPos) const;
    virtual CDocument* OpenDocumentFile(
            LPCTSTR lpszPathName, BOOL bMakeVisible = TRUE);
    virtual void SetDefaultTitle(CDocument* pDocument);

#ifdef _DEBUG
    virtual void Dump(CDumpContext&) const;
    virtual void AssertValid() const;
#endif //_DEBUG

protected:  // standard implementation
    CPtrList m_docList;          // open documents of this type
    UINT m_nUntitledCount;   // start at 0, for "Document1" title
};

/////////////////////////////////////////////////////////////////////////////
// class CDocument is the main document data abstraction

#ifdef _AFXDLL
class CDocument : public CCmdTarget
#else
class AFX_NOVTABLE CDocument : public CCmdTarget
#endif
{
    DECLARE_DYNAMIC(CDocument)

public:
// Constructors
    CDocument();

// Attributes
public:
    const CString& GetTitle() const;
    virtual void SetTitle(LPCTSTR lpszTitle);
    const CString& GetPathName() const;
    virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);

    CDocTemplate* GetDocTemplate() const;
    virtual BOOL IsModified();
    virtual void SetModifiedFlag(BOOL bModified = TRUE);

// Operations
    void AddView(CView* pView);
    void RemoveView(CView* pView);
    virtual POSITION GetFirstViewPosition() const;
    virtual CView* GetNextView(POSITION& rPosition) const;

    // Update Views (simple update - DAG only)
    void UpdateAllViews(CView* pSender, LPARAM lHint = 0L,
            CObject* pHint = NULL);

// Overridables
    // Special notifications
    virtual void OnChangedViewList(); // after Add or Remove view
    virtual void DeleteContents(); // delete doc items etc

    // File helpers
    virtual BOOL OnNewDocument();
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
    virtual void OnCloseDocument();
    virtual void ReportSaveLoadException(LPCTSTR lpszPathName,
                            CException* e, BOOL bSaving, UINT nIDPDefault);
    virtual CFile* GetFile(LPCTSTR lpszFileName, UINT nOpenFlags,
            CFileException* pError);
    virtual void ReleaseFile(CFile* pFile, BOOL bAbort);

    // advanced overridables, closing down frame/doc, etc.
    virtual BOOL CanCloseFrame(CFrameWnd* pFrame);
    virtual BOOL SaveModified(); // return TRUE if ok to continue
    virtual void PreCloseFrame(CFrameWnd* pFrame);

// Implementation
protected:
    // default implementation
    CString m_strTitle;
    CString m_strPathName;
    CDocTemplate* m_pDocTemplate;
    CPtrList m_viewList;                // list of views
    BOOL m_bModified;                   // changed since last saved

public:
    BOOL m_bAutoDelete;     // TRUE => delete document when no more views
    BOOL m_bEmbedded;       // TRUE => document is being created by OLE

#ifdef _DEBUG
    virtual void Dump(CDumpContext&) const;
    virtual void AssertValid() const;
#endif //_DEBUG
    virtual ~CDocument();

    // implementation helpers
    virtual BOOL DoSave(LPCTSTR lpszPathName, BOOL bReplace = TRUE);
    virtual BOOL DoFileSave();
    virtual void UpdateFrameCounts();
    void DisconnectViews();
    void SendInitialUpdate();

    // overridables for implementation
    virtual HMENU GetDefaultMenu(); // get menu depending on state
    virtual HACCEL GetDefaultAccelerator();
    virtual void OnIdle();
    virtual void OnFinalRelease();

    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
            AFX_CMDHANDLERINFO* pHandlerInfo);
    friend class CDocTemplate;

protected:
    // file menu commands
    //{{AFX_MSG(CDocument)
    afx_msg void OnFileClose();
    afx_msg void OnFileSave();
    afx_msg void OnFileSaveAs();
    //}}AFX_MSG
    // mail enabling
    afx_msg void OnFileSendMail();
    afx_msg void OnUpdateFileSendMail(CCmdUI* pCmdUI);
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// Extra diagnostic tracing options

#ifdef _DEBUG

extern AFX_DATA UINT afxTraceFlags;
enum AfxTraceFlags
{
    traceMultiApp = 1,      // multi-app debugging
    traceAppMsg = 2,        // main message pump trace (includes DDE)
    traceWinMsg = 4,        // Windows message tracing
    traceCmdRouting = 8,    // Windows command routing trace (set 4+8 for control notifications)
    traceOle = 16,          // special OLE callback trace
    traceDatabase = 32,     // special database trace
    traceInternet = 64      // special Internet client trace
};

#endif // _DEBUG

//////////////////////////////////////////////////////////////////////////////
// MessageBox helpers

void AFXAPI AfxFormatString1(CString& rString, UINT nIDS, LPCTSTR lpsz1);
void AFXAPI AfxFormatString2(CString& rString, UINT nIDS,
                            LPCTSTR lpsz1, LPCTSTR lpsz2);
int AFXAPI AfxMessageBox(LPCTSTR lpszText, UINT nType = MB_OK,
                            UINT nIDHelp = 0);
int AFXAPI AfxMessageBox(UINT nIDPrompt, UINT nType = MB_OK,
                            UINT nIDHelp = (UINT)-1);

// Implementation string helpers
void AFXAPI AfxFormatStrings(CString& rString, UINT nIDS,
                            LPCTSTR const* rglpsz, int nString);
void AFXAPI AfxFormatStrings(CString& rString, LPCTSTR lpszFormat,
                            LPCTSTR const* rglpsz, int nString);
BOOL AFXAPI AfxExtractSubString(CString& rString, LPCTSTR lpszFullString,
                            int iSubString, TCHAR chSep = '\n');

/////////////////////////////////////////////////////////////////////////////
// Special target variant APIs

#ifdef _AFXDLL
    #include <afxdll_.h>
#endif

// Windows Version compatibility (obsolete)
#define AfxEnableWin30Compatibility()
#define AfxEnableWin31Compatibility()
#define AfxEnableWin40Compatibility()

// Temporary map management (locks temp map on current thread)
void AFXAPI AfxLockTempMaps();
BOOL AFXAPI AfxUnlockTempMaps(BOOL bDeleteTemps = TRUE);

/////////////////////////////////////////////////////////////////////////////
// Special OLE related functions (see OLELOCK.CPP)

void AFXAPI AfxOleOnReleaseAllObjects();
BOOL AFXAPI AfxOleCanExitApp();
void AFXAPI AfxOleLockApp();
void AFXAPI AfxOleUnlockApp();

void AFXAPI AfxOleSetUserCtrl(BOOL bUserCtrl);
BOOL AFXAPI AfxOleGetUserCtrl();

#ifndef _AFX_NO_OCC_SUPPORT
BOOL AFXAPI AfxOleLockControl(REFCLSID clsid);
BOOL AFXAPI AfxOleUnlockControl(REFCLSID clsid);
BOOL AFXAPI AfxOleLockControl(LPCTSTR lpszProgID);
BOOL AFXAPI AfxOleUnlockControl(LPCTSTR lpszProgID);
void AFXAPI AfxOleUnlockAllControls();
#endif

/////////////////////////////////////////////////////////////////////////////
// Use version 1.0 of the RichEdit control

#define _RICHEDIT_VER 0x0100

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXWIN_INLINE AFX_INLINE
#include <afxwin1.inl>
#include <afxwin2.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

/////////////////////////////////////////////////////////////////////////////

#else
#include <afxres.h>     // standard resource IDs
#endif //RC_INVOKED

#endif //__AFXWIN_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\win32inc\RpcDce.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    rpcdce.h

Abstract:

    This module contains the DCE RPC runtime APIs.

--*/

#ifndef __RPCDCE_H__
#define __RPCDCE_H__

#if _MSC_VER>1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

/*typedef char small;*/
/*typedef unsigned char byte;*/
/*typedef unsigned char boolean;*/

typedef I_RPC_HANDLE RPC_BINDING_HANDLE;
typedef RPC_BINDING_HANDLE handle_t;
#define rpc_binding_handle_t RPC_BINDING_HANDLE

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

#ifndef UUID_DEFINED
#define UUID_DEFINED
typedef GUID UUID;
#ifndef uuid_t
#define uuid_t UUID
#endif
#endif

typedef struct _RPC_BINDING_VECTOR
{
    unsigned long Count;
    RPC_BINDING_HANDLE BindingH[1];
} RPC_BINDING_VECTOR;
#ifndef rpc_binding_vector_t
#define rpc_binding_vector_t RPC_BINDING_VECTOR
#endif

typedef struct _UUID_VECTOR
{
  unsigned long Count;
  UUID *Uuid[1];
} UUID_VECTOR;
#ifndef uuid_vector_t
#define uuid_vector_t UUID_VECTOR
#endif

typedef void __RPC_FAR * RPC_IF_HANDLE;

#ifndef IFID_DEFINED
#define IFID_DEFINED
typedef struct _RPC_IF_ID
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_IF_ID;
#endif

#define RPC_C_BINDING_INFINITE_TIMEOUT 10
#define RPC_C_BINDING_MIN_TIMEOUT 0
#define RPC_C_BINDING_DEFAULT_TIMEOUT 5
#define RPC_C_BINDING_MAX_TIMEOUT 9

#define RPC_C_CANCEL_INFINITE_TIMEOUT -1

#define RPC_C_LISTEN_MAX_CALLS_DEFAULT 1234
#define RPC_C_PROTSEQ_MAX_REQS_DEFAULT 10

// RPC_POLICY EndpointFlags.
#define RPC_C_BIND_TO_ALL_NICS          1
#define RPC_C_USE_INTERNET_PORT         0x1
#define RPC_C_USE_INTRANET_PORT         0x2
#define RPC_C_DONT_FAIL                          0x4

// RPC_POLICY EndpointFlags specific to the Falcon/RPC transport:
#define RPC_C_MQ_TEMPORARY                  0x0000
#define RPC_C_MQ_PERMANENT                  0x0001
#define RPC_C_MQ_CLEAR_ON_OPEN              0x0002
#define RPC_C_MQ_USE_EXISTING_SECURITY      0x0004
#define RPC_C_MQ_AUTHN_LEVEL_NONE           0x0000
#define RPC_C_MQ_AUTHN_LEVEL_PKT_INTEGRITY  0x0008
#define RPC_C_MQ_AUTHN_LEVEL_PKT_PRIVACY    0x0010

// Client: RpcBindingSetOption() values for the Falcon/RPC transport:
#define RPC_C_OPT_MQ_DELIVERY            1
#define RPC_C_OPT_MQ_PRIORITY            2
#define RPC_C_OPT_MQ_JOURNAL             3
#define RPC_C_OPT_MQ_ACKNOWLEDGE         4
#define RPC_C_OPT_MQ_AUTHN_SERVICE       5
#define RPC_C_OPT_MQ_AUTHN_LEVEL         6
#define RPC_C_OPT_MQ_TIME_TO_REACH_QUEUE 7
#define RPC_C_OPT_MQ_TIME_TO_BE_RECEIVED 8
#define RPC_C_OPT_BINDING_NONCAUSAL      9
#define RPC_C_OPT_SECURITY_CALLBACK      10
#define RPC_C_OPT_UNIQUE_BINDING         11
#define RPC_C_OPT_MAX_OPTIONS            12

#define RPC_C_MQ_EXPRESS                0  // Client: RPC_C_MQ_DELIVERY.
#define RPC_C_MQ_RECOVERABLE            1

#define RPC_C_MQ_JOURNAL_NONE           0  // Client: RPC_C_MQ_JOURNAL.
#define RPC_C_MQ_JOURNAL_DEADLETTER     1
#define RPC_C_MQ_JOURNAL_ALWAYS         2

// flags for RpcServerInqAuthClientEx
//
#define RPC_C_FULL_CERT_CHAIN 0x0001



#ifdef RPC_UNICODE_SUPPORTED
typedef struct _RPC_PROTSEQ_VECTORA
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORA;

typedef struct _RPC_PROTSEQ_VECTORW
{
    unsigned int Count;
    unsigned short __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORW;

#ifdef UNICODE
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORW
#else
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORA
#endif /* UNICODE */

#else

typedef struct _RPC_PROTSEQ_VECTOR
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTOR;

#endif /* RPC_UNICODE_SUPPORTED */
typedef struct _RPC_POLICY {
    unsigned int Length ;
    unsigned long EndpointFlags ;
    unsigned long NICFlags ;
    } RPC_POLICY,  __RPC_FAR *PRPC_POLICY ;

typedef void __RPC_USER
RPC_OBJECT_INQ_FN (
    IN UUID __RPC_FAR * ObjectUuid,
    OUT UUID __RPC_FAR * TypeUuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

typedef RPC_STATUS RPC_ENTRY
RPC_IF_CALLBACK_FN (
    IN RPC_IF_HANDLE  InterfaceUuid,
    IN void *Context
    ) ;

typedef void RPC_ENTRY
RPC_SECURITY_CALLBACK_FN (
    IN void *Context
    ) ;

#define RPC_MGR_EPV void

typedef struct
{
    unsigned int Count;
    unsigned long Stats[1];
} RPC_STATS_VECTOR;

#define RPC_C_STATS_CALLS_IN 0
#define RPC_C_STATS_CALLS_OUT 1
#define RPC_C_STATS_PKTS_IN 2
#define RPC_C_STATS_PKTS_OUT 3

typedef struct
{
  unsigned long Count;
  RPC_IF_ID __RPC_FAR * IfId[1];
} RPC_IF_ID_VECTOR;

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFree (
    IN OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#define ULONG_PTR LONG
/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetOption( IN RPC_BINDING_HANDLE hBinding,
                     IN unsigned long      option,
                     IN ULONG_PTR          optionValue );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqOption( IN  RPC_BINDING_HANDLE hBinding,
                     IN  unsigned long      option,
                     OUT ULONG_PTR         *pOptionValue );

/* client */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBindingA (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBindingW (
    IN unsigned short __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#ifdef UNICODE
#define RpcBindingFromStringBinding RpcBindingFromStringBindingW
#else
#define RpcBindingFromStringBinding RpcBindingFromStringBindingA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBinding (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsGetContextBinding (
    IN void *ContextHandle,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqObject (
    IN RPC_BINDING_HANDLE Binding,
    OUT UUID __RPC_FAR * ObjectUuid
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingReset (
    IN RPC_BINDING_HANDLE Binding
    );

/* RpcBindingServerFromClient : UNSUPPORTED */
/* RpcBindingSetAuthInfo */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetObject (
    IN RPC_BINDING_HANDLE Binding,
    IN UUID __RPC_FAR * ObjectUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqDefaultProtectLevel(
    IN  unsigned long AuthnSvc,
    OUT unsigned long __RPC_FAR *AuthnLevel
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBindingA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBindingW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding
    );

#ifdef UNICODE
#define RpcBindingToStringBinding RpcBindingToStringBindingW
#else
#define RpcBindingToStringBinding RpcBindingToStringBindingA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBinding (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingVectorFree (
    IN OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingComposeA (
    IN unsigned char __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned char __RPC_FAR * Protseq OPTIONAL,
    IN unsigned char __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned char __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned char __RPC_FAR * Options OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingComposeW (
    IN unsigned short __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned short __RPC_FAR * Protseq OPTIONAL,
    IN unsigned short __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned short __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned short __RPC_FAR * Options OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

#ifdef UNICODE
#define RpcStringBindingCompose RpcStringBindingComposeW
#else
#define RpcStringBindingCompose RpcStringBindingComposeA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingCompose (
    IN unsigned char __RPC_FAR * ObjUuid OPTIONAL,
    IN unsigned char __RPC_FAR * Protseq OPTIONAL,
    IN unsigned char __RPC_FAR * NetworkAddr OPTIONAL,
    IN unsigned char __RPC_FAR * Endpoint OPTIONAL,
    IN unsigned char __RPC_FAR * Options OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParseA (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParseW (
    IN unsigned short __RPC_FAR * StringBinding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

#ifdef UNICODE
#define RpcStringBindingParse RpcStringBindingParseW
#else
#define RpcStringBindingParse RpcStringBindingParseA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParse (
    IN unsigned char __RPC_FAR * StringBinding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFreeA (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR * String
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFreeW (
    IN OUT unsigned short __RPC_FAR * __RPC_FAR * String
    );

#ifdef UNICODE
#define RpcStringFree RpcStringFreeW
#else
#define RpcStringFree RpcStringFreeA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFree (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR * String
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcIfInqId (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_IF_ID __RPC_FAR * RpcIfId
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValidA (
    IN unsigned char __RPC_FAR * Protseq
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValidW (
    IN unsigned short __RPC_FAR * Protseq
    );

#ifdef UNICODE
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidW
#else
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValid (
    IN unsigned char __RPC_FAR * Protseq
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Timeout
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned int Timeout
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetCancelTimeout(
    long Timeout
    );


/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqsA (
    OUT RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqsW (
    OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#ifdef UNICODE
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsW
#else
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqs (
    OUT RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectInqType (
    IN UUID __RPC_FAR * ObjUuid,
    OUT UUID __RPC_FAR * TypeUuid OPTIONAL
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectSetInqFn (
    IN RPC_OBJECT_INQ_FN __RPC_FAR * InquiryFn
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectSetType (
    IN UUID __RPC_FAR * ObjUuid,
    IN UUID __RPC_FAR * TypeUuid OPTIONAL
    );

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFreeA (
    IN OUT RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFreeW (
    IN OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#ifdef UNICODE
#define RpcProtseqVectorFree RpcProtseqVectorFreeW
#else
#define RpcProtseqVectorFree RpcProtseqVectorFreeA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFree (
    IN OUT RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqBindings (
    OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid, OPTIONAL
    OUT RPC_MGR_EPV __RPC_FAR * __RPC_FAR * MgrEpv
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaxCalls,
    IN unsigned int DontWait
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid OPTIONAL,
    IN RPC_MGR_EPV __RPC_FAR * MgrEpv OPTIONAL
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIfEx (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid,
    IN RPC_MGR_EPV __RPC_FAR * MgrEpv,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN RPC_IF_CALLBACK_FN __RPC_FAR *IfCallback
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIf2 (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID * MgrTypeUuid,
    IN RPC_MGR_EPV * MgrEpv,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN unsigned int MaxRpcSize,
    IN RPC_IF_CALLBACK_FN *IfCallbackFn
    );


/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUnregisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID __RPC_FAR * MgrTypeUuid, OPTIONAL
    IN unsigned int WaitForCallsToComplete
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqs (
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsEx (
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsIf (
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsIfEx (
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );


/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqExA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqExW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseq RpcServerUseProtseqW
#define RpcServerUseProtseqEx RpcServerUseProtseqExW
#else
#define RpcServerUseProtseq RpcServerUseProtseqA
#define RpcServerUseProtseqEx RpcServerUseProtseqExA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseq (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEx (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpExA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned short __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpExW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned short __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseqEp RpcServerUseProtseqEpW
#define RpcServerUseProtseqEpEx RpcServerUseProtseqEpExW
#else
#define RpcServerUseProtseqEp RpcServerUseProtseqEpA
#define RpcServerUseProtseqEpEx RpcServerUseProtseqEpExA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEp (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpEx (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfExA (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfExW (
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseqIf RpcServerUseProtseqIfW
#define RpcServerUseProtseqIfEx RpcServerUseProtseqIfExW
#else
#define RpcServerUseProtseqIf RpcServerUseProtseqIfA
#define RpcServerUseProtseqIfEx RpcServerUseProtseqIfExA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIf (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfEx (
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void __RPC_FAR * SecurityDescriptor,
    IN PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
void
RPC_ENTRY
RpcServerYield (
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtStatsVectorFree (
    IN RPC_STATS_VECTOR ** StatsVector
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqStats (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_STATS_VECTOR ** Statistics
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtIsServerListening (
    IN RPC_BINDING_HANDLE Binding
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtStopServerListening (
    IN RPC_BINDING_HANDLE Binding
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtWaitServerListen (
    void
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetServerStackSize (
    IN unsigned long ThreadStackSize
    );

/* server */
RPCRTAPI
void
RPC_ENTRY
RpcSsDontSerializeContext (
    void
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEnableIdleCleanup (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqIfIds (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcIfIdVectorFree (
    IN OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincNameA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincNameW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName
    );

#ifdef UNICODE
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameW
#else
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincNameA (
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * PrincName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincNameW (
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * PrincName
    );

#ifdef UNICODE
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameW
#else
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincName (
    IN unsigned long AuthnSvc,
    OUT unsigned char __RPC_FAR * __RPC_FAR * PrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpResolveBinding (
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_IF_HANDLE IfSpec
    );

/* client */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryNameA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned char __RPC_FAR * __RPC_FAR * EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryNameW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned short __RPC_FAR * __RPC_FAR * EntryName
    );

#ifdef UNICODE
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameW
#else
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned char __RPC_FAR * __RPC_FAR * EntryName
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef void __RPC_FAR * RPC_AUTH_IDENTITY_HANDLE;
typedef void __RPC_FAR * RPC_AUTHZ_HANDLE;

#define RPC_C_AUTHN_LEVEL_DEFAULT       0
#define RPC_C_AUTHN_LEVEL_NONE          1
#define RPC_C_AUTHN_LEVEL_CONNECT       2
#define RPC_C_AUTHN_LEVEL_CALL          3
#define RPC_C_AUTHN_LEVEL_PKT           4
#define RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5
#define RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6

#define RPC_C_IMP_LEVEL_DEFAULT      0
#define RPC_C_IMP_LEVEL_ANONYMOUS    1
#define RPC_C_IMP_LEVEL_IDENTIFY     2
#define RPC_C_IMP_LEVEL_IMPERSONATE  3
#define RPC_C_IMP_LEVEL_DELEGATE     4

#define RPC_C_QOS_IDENTITY_STATIC    0
#define RPC_C_QOS_IDENTITY_DYNAMIC   1

#define RPC_C_QOS_CAPABILITIES_DEFAULT       0
#define RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH   1
#define RPC_C_QOS_CAPABILITIES_MAKE_FULLSIC  2
#define RPC_C_QOS_CAPABILITIES_ANY_AUTHORITY 4

#define RPC_C_PROTECT_LEVEL_DEFAULT       (RPC_C_AUTHN_LEVEL_DEFAULT)
#define RPC_C_PROTECT_LEVEL_NONE          (RPC_C_AUTHN_LEVEL_NONE)
#define RPC_C_PROTECT_LEVEL_CONNECT       (RPC_C_AUTHN_LEVEL_CONNECT)
#define RPC_C_PROTECT_LEVEL_CALL          (RPC_C_AUTHN_LEVEL_CALL)
#define RPC_C_PROTECT_LEVEL_PKT           (RPC_C_AUTHN_LEVEL_PKT)
#define RPC_C_PROTECT_LEVEL_PKT_INTEGRITY (RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
#define RPC_C_PROTECT_LEVEL_PKT_PRIVACY   (RPC_C_AUTHN_LEVEL_PKT_PRIVACY)

#define RPC_C_AUTHN_NONE          0
#define RPC_C_AUTHN_DCE_PRIVATE   1
#define RPC_C_AUTHN_DCE_PUBLIC    2
#define RPC_C_AUTHN_DEC_PUBLIC    4
#define RPC_C_AUTHN_GSS_NEGOTIATE 9
#define RPC_C_AUTHN_WINNT        10
#define RPC_C_AUTHN_GSS_SCHANNEL 14
#define RPC_C_AUTHN_GSS_KERBEROS 16
#define RPC_C_AUTHN_MSN          17
#define RPC_C_AUTHN_DPA          18
#define RPC_C_AUTHN_MQ          100
#define RPC_C_AUTHN_DEFAULT     0xFFFFFFFFL

#define RPC_C_NO_CREDENTIALS ((RPC_AUTH_IDENTITY_HANDLE) ~0UL)

#define RPC_C_SECURITY_QOS_VERSION  1L

typedef struct _RPC_SECURITY_QOS {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
} RPC_SECURITY_QOS, *PRPC_SECURITY_QOS;

#if defined
typedef struct _SEC_WINNT_AUTH_IDENTITY
{
  char __RPC_FAR *User;
  char __RPC_FAR *Domain;
  char __RPC_FAR *Password;
} SEC_WINNT_AUTH_IDENTITY;
#else


#define SEC_WINNT_AUTH_IDENTITY_ANSI    0x1
#define SEC_WINNT_AUTH_IDENTITY_UNICODE 0x2

typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
  unsigned short __RPC_FAR *User;
  unsigned long UserLength;
  unsigned short __RPC_FAR *Domain;
  unsigned long DomainLength;
  unsigned short __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;

typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
  unsigned char __RPC_FAR *User;
  unsigned long UserLength;
  unsigned char __RPC_FAR *Domain;
  unsigned long DomainLength;
  unsigned char __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A;


#ifdef UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_W
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_W
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_W
#else
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_A
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_A
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_A
#endif // UNICODE
#endif // defined(__RPC_DOS__) || defined(__RPC_WIN16__)

#define RPC_C_AUTHZ_NONE    0
#define RPC_C_AUTHZ_NAME    1
#define RPC_C_AUTHZ_DCE     2
#define RPC_C_AUTHZ_DEFAULT 0xffffffff

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcImpersonateClient (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelfEx (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelf (
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientA (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientW (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientExA (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc, OPTIONAL
    IN  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientExW (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc, OPTIONAL
    IN  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoExA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc,
    IN RPC_SECURITY_QOS *SecurityQos OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoExW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc, OPTIONAL
    IN RPC_SECURITY_QOS *SecurityQOS
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoExA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc, OPTIONAL
    IN  unsigned long RpcQosVersion,
    OUT RPC_SECURITY_QOS *SecurityQOS
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoExW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL,
    IN  unsigned long RpcQosVersion,
    OUT RPC_SECURITY_QOS *SecurityQOS
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    IN void __RPC_FAR * Arg,
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long KeyVer,
    OUT void __RPC_FAR * __RPC_FAR * Key,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterAuthInfoA (
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void __RPC_FAR * Arg OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterAuthInfoW (
    IN unsigned short __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void __RPC_FAR * Arg OPTIONAL
    );

#ifdef UNICODE
#define RpcBindingInqAuthClient RpcBindingInqAuthClientW
#define RpcBindingInqAuthClientEx RpcBindingInqAuthClientExW
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoW
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoW
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoW
#define RpcBindingInqAuthInfoEx RpcBindingInqAuthInfoExW
#define RpcBindingSetAuthInfoEx RpcBindingSetAuthInfoExW
#else
#define RpcBindingInqAuthClient RpcBindingInqAuthClientA
#define RpcBindingInqAuthClientEx RpcBindingInqAuthClientExA
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoA
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoA
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoA
#define RpcBindingInqAuthInfoEx RpcBindingInqAuthInfoExA
#define RpcBindingSetAuthInfoEx RpcBindingSetAuthInfoExA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClient (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientEx (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc, OPTIONAL
    IN  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfo (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity, OPTIONAL
    OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfo (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    IN void __RPC_FAR * Arg,
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long KeyVer,
    OUT void __RPC_FAR * __RPC_FAR * Key,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterAuthInfo (
    IN unsigned char __RPC_FAR * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void __RPC_FAR * Arg OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef struct {
    unsigned char __RPC_FAR * UserName;
    unsigned char __RPC_FAR * ComputerName;
    unsigned short Privilege;
    unsigned long AuthFlags;
} RPC_CLIENT_INFORMATION1, __RPC_FAR * PRPC_CLIENT_INFORMATION1;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingServerFromClient (
    IN RPC_BINDING_HANDLE ClientBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * ServerBinding
    );

RPCRTAPI
void
RPC_ENTRY
RpcRaiseException (
    IN RPC_STATUS exception
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcTestCancel(
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerTestCancel (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCancelThread(
    IN void * Thread
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCancelThreadEx(
    IN void * Thread,
    IN long Timeout
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidCreate (
    OUT UUID __RPC_FAR * Uuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidCreateSequential (
    OUT UUID __RPC_FAR * Uuid
    );

#ifdef RPC_UNICODE_SUPPORTED

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToStringA (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidFromStringA (
    IN unsigned char __RPC_FAR * StringUuid,
    OUT UUID __RPC_FAR * Uuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToStringW (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned short __RPC_FAR * __RPC_FAR * StringUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidFromStringW (
    IN unsigned short __RPC_FAR * StringUuid,
    OUT UUID __RPC_FAR * Uuid
    );

#ifdef UNICODE
#define UuidFromString UuidFromStringW
#define UuidToString UuidToStringW
#else
#define UuidFromString UuidFromStringA
#define UuidToString UuidToStringA
#endif /* UNICODE */

#else

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToString (
    IN UUID __RPC_FAR * Uuid,
    OUT unsigned char __RPC_FAR * __RPC_FAR * StringUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidFromString (
    IN unsigned char __RPC_FAR * StringUuid,
    OUT UUID __RPC_FAR * Uuid
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
signed int
RPC_ENTRY
UuidCompare (
    IN UUID __RPC_FAR * Uuid1,
    IN UUID __RPC_FAR * Uuid2,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidCreateNil (
    OUT UUID __RPC_FAR * NilUuid
    );

RPCRTAPI
int
RPC_ENTRY
UuidEqual (
    IN UUID __RPC_FAR * Uuid1,
    IN UUID __RPC_FAR * Uuid2,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
unsigned short
RPC_ENTRY
UuidHash (
    IN UUID __RPC_FAR * Uuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
int
RPC_ENTRY
UuidIsNil (
    IN UUID __RPC_FAR * Uuid,
    OUT RPC_STATUS __RPC_FAR * Status
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterNoReplaceA (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterNoReplaceW (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned short  * Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterA (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterW (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned short * Annotation
    );

#ifdef UNICODE
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceW
#define RpcEpRegister RpcEpRegisterW
#else
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceA
#define RpcEpRegister RpcEpRegisterA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterNoReplace (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned  char * Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegister (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    );

#endif /* RPC_UNICODE_SUPPORTED */


RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpUnregister(
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
DceErrorInqTextA (
    IN RPC_STATUS RpcStatus,
    OUT unsigned char __RPC_FAR * ErrorText
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
DceErrorInqTextW (
    IN RPC_STATUS RpcStatus,
    OUT unsigned short __RPC_FAR * ErrorText
    );

#ifdef UNICODE
#define DceErrorInqText DceErrorInqTextW
#else
#define DceErrorInqText DceErrorInqTextA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
DceErrorInqText (
    IN RPC_STATUS RpcStatus,
    OUT unsigned char __RPC_FAR * ErrorText
    );

#endif /* RPC_UNICODE_SUPPORTED */

#define DCE_C_ERROR_STRING_LEN 256

typedef I_RPC_HANDLE * RPC_EP_INQ_HANDLE;

#define  RPC_C_EP_ALL_ELTS        0
#define  RPC_C_EP_MATCH_BY_IF     1
#define  RPC_C_EP_MATCH_BY_OBJ    2
#define  RPC_C_EP_MATCH_BY_BOTH   3

#define  RPC_C_VERS_ALL           1
#define  RPC_C_VERS_COMPATIBLE    2
#define  RPC_C_VERS_EXACT         3
#define  RPC_C_VERS_MAJOR_ONLY    4
#define  RPC_C_VERS_UPTO          5

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqBegin (
    IN RPC_BINDING_HANDLE EpBinding OPTIONAL,
    IN unsigned long InquiryType,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption OPTIONAL,
    IN UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqDone (
    IN OUT RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqNextA (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqNextW (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    );

#ifdef UNICODE
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextW
#else
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextA
#endif /* UNICODE */

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqNext (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpUnregister (
    IN RPC_BINDING_HANDLE EpBinding OPTIONAL,
    IN RPC_IF_ID __RPC_FAR * IfId,
    IN RPC_BINDING_HANDLE Binding,
    IN UUID __RPC_FAR * ObjectUuid OPTIONAL
    );

typedef int
(__RPC_API * RPC_MGMT_AUTHORIZATION_FN) (
    IN RPC_BINDING_HANDLE ClientBinding,
    IN unsigned long RequestedMgmtOperation,
    OUT RPC_STATUS __RPC_FAR * Status
    );

#define RPC_C_MGMT_INQ_IF_IDS         0
#define RPC_C_MGMT_INQ_PRINC_NAME     1
#define RPC_C_MGMT_INQ_STATS          2
#define RPC_C_MGMT_IS_SERVER_LISTEN   3
#define RPC_C_MGMT_STOP_SERVER_LISTEN 4

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetAuthorizationFn (
    IN RPC_MGMT_AUTHORIZATION_FN AuthorizationFn
    );


#define RPC_C_PARM_MAX_PACKET_LENGTH    1
#define RPC_C_PARM_BUFFER_LENGTH        2

#define RPC_IF_AUTOLISTEN               0x0001
#define RPC_IF_OLE                      0x0002
#define RPC_IF_ALLOW_UNKNOWN_AUTHORITY  0x0004
#define RPC_IF_ALLOW_SECURE_ONLY  0x0008

#include <rpcdcep.h>

#ifdef __cplusplus
}
#endif

#endif /* __RPCDCE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\boards\generic\vdgendrv.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "boards/generic/win32/vdgendrv.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\boards\generic\win32\vdgendrv.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define TRACE_VDR_CALLS 0
#define TRACE_VDR_CALLS_E 0

#include "library/common/prelude.h"
#include "library/common/tags.h"

#include "idllspec.h"
#include "vdgendrv.h"

#include "../lowlevel/ntkernel/genersys.h"

#include "library/common/vddebug.h"

#include "library/support/vdsup32/vdsup32.h"
#include "ddraw.h"

#define MAX_UNITS	100

#define PIP_SUPPORT	1
#define WIN_SUPPORT  1
#define OVERLAY_SUPPORT  0
#define RET_HOOK  0

#define USE_HOOK_PROCESS 1

#define WIDTHBYTES(bits)		(((bits) + 31) / 32 * 4)

///////////////////////////////////////////////////////////////////////////////
// Special Hooks
///////////////////////////////////////////////////////////////////////////////

class MPEGUnitsRefillHook : public MPEGStreamHook {
	private:
		HWND	hwnd;
		WORD	msg;

		friend Error CALLBACK MPEGUnitsRefillCall(MPEGStreamHook * me, MPEGStreamMsg& data);
		Error RefillRequest(void)
			{
			if (!pending)
				{
				pending = TRUE;
				::PostMessage(hwnd, WM_USER, msg, 0);
				}

			GNRAISE_OK;
			}
	public:
		BOOL	pending;

		MPEGUnitsRefillHook(HWND hwnd, WORD msg)
			: MPEGStreamHook(MPEGUnitsRefillCall)
			{this->hwnd = hwnd; this->msg = msg;pending = FALSE; VDR_RegisterCallback(this);}

		~MPEGUnitsRefillHook(void) {VDR_UnregisterCallback(this);}
	};

Error CALLBACK MPEGUnitsRefillCall(MPEGStreamHook * me, MPEGStreamMsg& msg)
	{
	return ((MPEGUnitsRefillHook *)me)->RefillRequest();
	}

class MPEGUnitsSignalHook : public MPEGSignalHook {
	private:
		HWND	hwnd;
		WORD	msg;
		friend Error CALLBACK MPEGUnitsSignalCall(MPEGSignalHook * me, MPEGSignalMsg& data);
		Error SignalRequest(DWORD pos)
			{
			::PostMessage(hwnd, WM_USER, msg, pos);

			GNRAISE_OK;
			}
	public:
		MPEGUnitsSignalHook(HWND hwnd, WORD msg)
			: MPEGSignalHook(MPEGUnitsSignalCall)
			{this->hwnd = hwnd; this->msg = msg; VDR_RegisterCallback(this);}

		~MPEGUnitsSignalHook(void) {VDR_UnregisterCallback(this);}
	};

Error CALLBACK MPEGUnitsSignalCall(MPEGSignalHook * me, MPEGSignalMsg& msg)
	{
	return ((MPEGUnitsSignalHook *)me)->SignalRequest(msg.position);
	}

class MPEGUnitsDoneHook : public MPEGSignalHook {
	private:
		HWND	hwnd;
		WORD	msg;
		friend Error CALLBACK MPEGUnitsDoneCall(MPEGSignalHook * me, MPEGSignalMsg& data);
		Error DoneRequest(void)
			{
			::PostMessage(hwnd, WM_USER, msg, 0);

			GNRAISE_OK;
			}
	public:
		MPEGUnitsDoneHook(HWND hwnd, WORD msg)
			: MPEGSignalHook(MPEGUnitsDoneCall)
			{this->hwnd = hwnd; this->msg = msg; VDR_RegisterCallback(this);}

		~MPEGUnitsDoneHook(void) {VDR_UnregisterCallback(this);}
	};

Error CALLBACK MPEGUnitsDoneCall(MPEGSignalHook * me, MPEGSignalMsg& msg)
	{
	return ((MPEGUnitsDoneHook *)me)->DoneRequest();
	}

///////////////////////////////////////////////////////////////////////////////
// Class definitions.
///////////////////////////////////////////////////////////////////////////////

typedef class IUnitSetClass
	{
	public:
		int		id;
		int		prev, next;
#if PIP_SUPPORT
		HWND		pipWindow;
		BOOL		pipEnabled;
#endif
		BOOL		hasMPEGDecoder;

		MPEGUnitsRefillHook		*	refillHook;
		MPEGUnitsSignalHook		*	signalHook;
		MPEGUnitsDoneHook			*	doneHook;

		VDRHandle handle;
		KUnitSet	kunits;
	} * IUnitSet;





///////////////////////////////////////////////////////////////////////////////
// Support functions.
///////////////////////////////////////////////////////////////////////////////

static DWORD staticRGBs[20] = {0x000000, 0x000080, 0x008000, 0x008080, 0x800000,
										 0x800080, 0x808000, 0xc0c0c0, 0xc0dcc0, 0xf0caa6,
										 0xf0fbff, 0xa4a0a0, 0x808080, 0x0000ff, 0x00ff00,
										 0x00ffff, 0xff0000, 0xff00ff, 0xffff00, 0xffffff};


static DWORD ConvertKeyColor (DWORD colorRGB, DWORD redBitMask, DWORD greenBitMask, DWORD blueBitMask)
	{
	DWORD newKeyColor;
	DWORD curMask;
	int i, redCount, greenCount, blueCount;

	newKeyColor = 0L;

	redCount		= 7;
	greenCount	= 15;
	blueCount	= 23;

	for (i = 31;  i >= 0;  i--)
		{
		curMask = 1L << i;

		if (redBitMask & curMask)
			{
			if (colorRGB & (1L << redCount))
				newKeyColor |= curMask;
			redCount--;
			}
		else if (greenBitMask & curMask)
			{
			if (colorRGB & (1L << greenCount))
				newKeyColor |= curMask;
			greenCount--;
			}
		else if (blueBitMask & curMask)
			{
			if (colorRGB & (1L << blueCount))
				newKeyColor |= curMask;
			blueCount--;
			}
		}

	return newKeyColor;
	}


DWORD ConvertKeyIndex (DWORD __far &colorIndex)
	{
	if (colorIndex > 9  &&  colorIndex < 246)
		colorIndex = 253;   // default to magenta if index is invalid

	if (colorIndex >= 246)
		return staticRGBs[colorIndex - 236];
	else
		return staticRGBs[colorIndex];
	}





///////////////////////////////////////////////////////////////////////////////
// VDRHandle implementation.
///////////////////////////////////////////////////////////////////////////////

class VDRHandleClass
	{
	public:
		Error Initialize (void);
		Error Free (void);

		~VDRHandleClass (void) {Free();}

	public:
		DWORD boardID;
		KernelHandle kHandle;

		// Direct Draw stuff
		DDAccess		ddAccess;
		BOOL			colorKeyed;
		BOOL			dmaOverlayEnabled;

		RECT			keyPaintRect;

		DWORD			keyColor;
		DWORD			keyIndex;
		DWORD			keyColorRGB;
		DWORD			keyColorIndex;

		BOOL			alwaysOverlay;
		DWORD			overlayPossible;
		BOOL			forceOverlay;

		WORD			screenWidth, screenHeight;

		DDSURFACEDESC	surface;
	};


Error VDRHandleClass::Initialize (void)
	{
	boardID = boardID;
	kHandle = NULL;
	ddAccess = NULL;

	// Set default Color Key color (magenta).
	keyColorRGB		= RGB(0xff, 0x00, 0xff);
	keyColorIndex	= 253;   // magenta in the system palette

	colorKeyed = FALSE;
#if OVERLAY_SUPPORT
	if (! VD32_OpenDDAccess (ddAccess, overlayPossible, &surface))
		{
		DP(__TEXT("Can't get DD access"));
		GNRAISE(GNR_OBJECT_NOT_FOUND);
		}
DP(__TEXT("overlayPossible %ld"), (long)overlayPossible);

   screenWidth = surface.dwWidth;
	screenHeight = surface.dwHeight;

	if (surface.ddpfPixelFormat.dwRBitMask)
		{
		keyColor = ConvertKeyColor (keyColorRGB,
		                            surface.ddpfPixelFormat.dwRBitMask,
		                            surface.ddpfPixelFormat.dwGBitMask,
		                            surface.ddpfPixelFormat.dwBBitMask);
		keyIndex = keyColorRGB;
		}
	else
		{
		keyIndex = ConvertKeyIndex (keyColorIndex);
		keyColor = keyColorIndex;
		}
#else
	overlayPossible = FALSE;
#endif

	GNRAISE_OK;
	}


Error VDRHandleClass::Free (void)
	{
	if (ddAccess)
		{
#if OVERLAY_SUPPORT
		VD32_CloseDDAccess (ddAccess);
		ddAccess = NULL;
#endif
		}
	GNRAISE_OK;
	}





///////////////////////////////////////////////////////////////////////////////
// Process instance variables.
///////////////////////////////////////////////////////////////////////////////

HANDLE			kDriver;
HINSTANCE		hinst;
HANDLE			WorkerThread;
HANDLE			WorkerDriver;
PKWorkerQueue	WorkerQueue;
DWORD				WorkerID;

int				DriverOpenCnt;

HANDLE			clipMutex;

HANDLE	ServiceLock;
HANDLE	ServiceRequest;
HANDLE	ServiceDone;

///////////////////////////////////////////////////////////////////////////////
// Variables shared between processes.
///////////////////////////////////////////////////////////////////////////////

#pragma data_seg(".sdata")

IUnitSetClass	Units[MAX_UNITS]	= {0};
int				firstFree			= 0;
int				firstActive			= -1;
int				openCnt				= 0;

#if PIP_SUPPORT
int				activePIPCnt		= 0;
UINT				doneMsg				= 0;
HHOOK				sizeHook				= NULL;
HHOOK				doneHook				= NULL;
int				msgPending			= 0;
volatile HWND	lastMoved			= 0;
#endif

class VDRHandleClass DriverInstanceHandle;

volatile enum	{	DD_NONE,
						DD_TERMINATE,
						DD_INSTALLHOOK,
						DD_REMOVEHOOK} ServiceCommand = DD_NONE;

volatile BOOL	ServiceSuccess = FALSE;
volatile BOOL	ServiceActive = FALSE;
volatile long	ServiceProcesses = 0;

PROCESS_INFORMATION processInfo = {0};

#pragma data_seg()





///////////////////////////////////////////////////////////////////////////////
// IUnitSet implementation.
///////////////////////////////////////////////////////////////////////////////

inline UnitSet TU(IUnitSet units) {return (UnitSet)(units->id+0x40000000);}
inline IUnitSet TU(UnitSet units) {return Units + ((int)units-0x40000000);}


void InitUnits(void)
	{
	int i;

	for (i=0; i<MAX_UNITS; i++)
		{
		Units[i].next = i+1;
		Units[i].id   = i;
		}
	Units[MAX_UNITS-1].next = -1;
	firstFree = 0;
	}


IUnitSet AllocUnit (VDRHandle handle)
	{
	int i;

	if	(firstFree != -1)
		{
		i = firstFree;
		firstFree = Units[firstFree].next;

#if PIP_SUPPORT
		Units[i].pipWindow = NULL;
		Units[i].pipEnabled = FALSE;
#endif
		Units[i].hasMPEGDecoder = NULL;

		Units[i].refillHook	= NULL;
		Units[i].signalHook	= NULL;
		Units[i].doneHook		= NULL;

		Units[i].handle = handle;

		if (firstActive != -1)
			{
			Units[firstActive].prev = i;
			}
		Units[i].prev = -1;
		Units[i].next = firstActive;
		firstActive = i;

		return Units+i;
		}
	else
		return NULL;
	}


void FreeUnit (IUnitSet unit)
	{
	if (unit->prev != -1)
		Units[unit->prev].next = unit->next;
	else
		firstActive = unit->next;
	if (unit->next != -1)
		Units[unit->next].prev = unit->prev;

	unit->next = firstFree;
	firstFree = unit->id;
	}




///////////////////////////////////////////////////////////////////////////////
// Worker Queue
///////////////////////////////////////////////////////////////////////////////

void RegisterWorker(void)
	{
	INIT_IOCTL(REGISTER_WORKER);
	DO_IOCTL(REGISTER_WORKER);
	WorkerQueue = out.queue;
	}

void UnregisterWorker(void)
	{
	INIT_IOCTL(UNREGISTER_WORKER);
	in.queue = WorkerQueue;
	DO_IOCTL(UNREGISTER_WORKER);
	WorkerQueue = NULL;
	}

DWORD __stdcall WorkerRoutine(void * param)
	{
	HANDLE kDriver = CreateFile(KERNEL_DRIVER_SYMBOLIC_NAME,
								GENERIC_WRITE | GENERIC_READ,
								FILE_SHARE_READ,
								NULL,
								OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL,
								NULL);

	if (INVALID_HANDLE_VALUE == kDriver)
		{
		DWORD error = GetLastError();
		ExitThread(0);
		}

	for(;;)
		{
		if (!WorkerQueue)
			{
			DP(__TEXT("No worker queue any more!"));
			CloseHandle(kDriver);
			ExitThread(0);
			}

		INIT_IOCTL(GET_WORKER_WORK);
		in.queue = WorkerQueue;
		DO_IOCTL(GET_WORKER_WORK);

		if (!(out.me))
			{
			DP(__TEXT("DoneWork"));
			CloseHandle(kDriver);
			ExitThread(0);
			}
		else
			{
			DummyHook	*	p = (DummyHook *)(out.me);

			p->Call(out.data);
			}
		}

	return 0;
	}

void InitThreadContext(void)
	{
	DP(__TEXT("InitThreadContext+"));
	RegisterWorker();
	WorkerThread = CreateThread(NULL, 0, WorkerRoutine, NULL, 0, &WorkerID);
	SetThreadPriority(WorkerThread, THREAD_PRIORITY_HIGHEST);
	DP(__TEXT("InitThreadContext-"));
	}

void FiniThreadContext(void)
	{
	DP(__TEXT("FiniThreadContext+"));
	UnregisterWorker();
	if (WorkerThread)
		{
		WaitForSingleObject(WorkerThread, 0x7fffffff);
		CloseHandle(WorkerThread);
		WorkerThread = NULL;
		}
//	while (WorkerThread) ;
	DP(__TEXT("FiniThreadContext-"));
	}




///////////////////////////////////////////////////////////////////////////////
// PIP Support
///////////////////////////////////////////////////////////////////////////////

#if PIP_SUPPORT



// DirectDraw support

int			ddOpenCnt = 0;
HINSTANCE	ddInst;

HRESULT (WINAPI * xDirectDrawCreate) (GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter);


BOOL OpenDDLib(void)
	{
	if (!ddOpenCnt)
		{
		ddInst = LoadLibrary(__TEXT("ddraw.dll"));
		if (ddInst != NULL)
			{
			ddOpenCnt = 1;
			(FARPROC &)xDirectDrawCreate = GetProcAddress(ddInst, "DirectDrawCreate");

			return TRUE;
			}
		else
			return FALSE;
		}
	else
		{
		ddOpenCnt++;
		return TRUE;
		}
	}


void CloseDDLib(void)
	{
	if (ddOpenCnt)
		{
		ddOpenCnt--;
		if (!ddOpenCnt)
			{
			FreeLibrary(ddInst);
			ddInst = NULL;
			}
		}
	}


BOOL GetDDPrimaryCaps (void)
	{
	HWND					hwnd;

	LPDIRECTDRAW			lpDD = NULL;
	LPDIRECTDRAWSURFACE	lpDDSPrimary = NULL;

	DDSURFACEDESC		ddsd;
	HRESULT				ddrval;

	BOOL					success = FALSE;

	if (! OpenDDLib())
		{
		DP(__TEXT("Can't open DDraw"));
		}
	else
		{
		hwnd = CreateWindowEx(NULL,
									 __TEXT("STATIC"),
									 __TEXT("DDIFWIN"),
									 WS_POPUP,
									 -20, -20, 10, 10,
									 NULL, NULL, hinst, NULL);

		if (! hwnd)
			{
			DP(__TEXT("CreateWindowEx failed"));
			}
		else
			{
			ddrval = xDirectDrawCreate (NULL, &lpDD, NULL);
			if (ddrval != DD_OK)
				{
				DP(__TEXT("xDirectDrawCreate failed"));
				}
			else
				{
				ddrval = lpDD->SetCooperativeLevel (hwnd, DDSCL_NORMAL);
				if (ddrval != DD_OK)
					{
					DP(__TEXT("SetCooperativeLevel failed"));
					}
				else
					{
					ddsd.dwSize = sizeof(DDSURFACEDESC);
					ddsd.dwFlags = DDSD_CAPS;
					ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
					ddrval = lpDD->CreateSurface( &ddsd, &lpDDSPrimary, NULL );
					if( ddrval != DD_OK )
						{
						DP(__TEXT("CreateSurface failed"));
						}
					else
						{
						DDSURFACEDESC desc;
						desc.dwSize = sizeof(desc);

						ddrval = lpDDSPrimary->Lock(NULL, &desc, DDLOCK_SURFACEMEMORYPTR|DDLOCK_WAIT, NULL);

						if( ddrval == DD_OK )
							{
							lpDDSPrimary->Unlock(&desc);
							if ((desc.dwFlags & (DDSD_PITCH | DDSD_PIXELFORMAT)) ==
								 (DDSD_PITCH | DDSD_PIXELFORMAT))
								{
								// Needed members are there.
								if (desc.ddpfPixelFormat.dwFlags & DDPF_RGB)
									{
									PIPFormat pixelFormat;
									success = TRUE;
									switch (desc.ddpfPixelFormat.dwRGBBitCount)
										{
										case 15:
											pixelFormat = PFMT_RGB_555;
											break;
										case 16:
										case DDBD_16:
											if (desc.ddpfPixelFormat.dwRBitMask == 0x7C00  &&
											    desc.ddpfPixelFormat.dwGBitMask == 0x03E0  &&
											    desc.ddpfPixelFormat.dwBBitMask == 0x001F)
												pixelFormat = PFMT_RGB_555;
											else
												pixelFormat = PFMT_RGB_565;
											break;
										case 24:
										case DDBD_24:
											pixelFormat = PFMT_RGB_888;
											break;
										case 32:
										case DDBD_32:
											pixelFormat = PFMT_RGB_888x;
											break;
										default:
											success = FALSE;
											break;
										}
									if (success)
										{
										INIT_IOCTL(SET_PIP_BASES);
										in.logicalBase = desc.lpSurface;
										in.bytesPerRow = desc.lPitch;
										in.pixelFormat = pixelFormat;
										DO_IOCTL(SET_PIP_BASES);
										if (IS_ERROR(out.error))
											success = FALSE;
										}
									}
								}
							}
						lpDDSPrimary->Release();
						}
					}
				lpDD->Release();
				}
			DestroyWindow( hwnd );
			}
		CloseDDLib();
		}
	return success;
	}





void SendWinDesc (IUnitSet units)
	{
	TAG tags[2];
	WinDesc wd;
	WinDescRect wr[32];
	WinDescRect *wp;
	RECT rect, mrect, hr;
	POINT pos;
	HDC hdc;
	HWND hwnd, hw2;
	HBRUSH hbr, hbrOld;
	DWORD style;
	BOOL childMode;
	int orgLeft, orgTop;
	int screenWidth, screenHeight, width, height;
	RECT fullRect;


	if (units->pipWindow == NULL  ||  ! ::IsWindowVisible (units->pipWindow))
		{
		tags[0] = SET_PIP_WINDOW_DESC(NULL);
		tags[1] = TAGDONE;
		}
	else
		{
		tags[0] = SET_PIP_WINDOW_DESC(&wd);
		tags[1] = TAGDONE;

		// Get the window main rect in screen coordinates.
		::GetClientRect (units->pipWindow, &rect);
		hdc = ::GetDC (units->pipWindow);
		::GetDCOrgEx (hdc, &pos);
		::ReleaseDC (units->pipWindow,hdc);
		orgLeft = pos.x;
		orgTop = pos.y;
		rect.left   += orgLeft;
		rect.top    += orgTop;
		rect.right  += orgLeft;
		rect.bottom += orgTop;

		DriverInstanceHandle.colorKeyed = FALSE;
		width = rect.right - rect.left;
		height = rect.bottom - rect.top;

		INIT_IOCTL(IS_PIP_OVERLAY);
		in.units = units->kunits;
		in.targetWidth = width;
		in.targetHeight = height;
		DO_IOCTL(IS_PIP_OVERLAY);

		if (! IS_ERROR(out.error)  &&  out.maxDMAWidth > 0  &&
		    DriverInstanceHandle.overlayPossible  &&  DriverInstanceHandle.ddAccess)
			{
			DDCtrlIn ddIn;
			DDCtrlOut ddOut;

			ddIn.colorKey = DriverInstanceHandle.keyColor;
			ddIn.left = rect.left;
			ddIn.top = rect.top;
			ddIn.width = width;
			ddIn.height = height;
			ddIn.minDMAWidth = 16;
			ddIn.minDMAHeight = 16;
			ddIn.maxDMAWidth = out.maxDMAWidth;
			ddIn.maxDMAHeight = out.maxDMAHeight;
			ddIn.pipFormats = 0xffffffff;

#if OVERLAY_SUPPORT
			if (VD32_SetDDOverlay (DriverInstanceHandle.ddAccess, ddIn, ddOut))
				{
				INIT_IOCTL(SET_PIP_OFFSCREEN);
				in.units = units->kunits;
				in.logicalBase = (FPTR)ddOut.destAddress;
				in.stride = ddOut.stride;
				in.format = (PIPFormat)ddOut.pipFormat;
				in.left = ddOut.dmaLeft;
				in.top = ddOut.dmaTop;
				in.width = ddOut.dmaWidth;
				in.height = ddOut.dmaHeight;
				DO_IOCTL(SET_PIP_OFFSCREEN);

				if (IS_ERROR(out.error))
					{
					VD32_RemoveDDOverlay (DriverInstanceHandle.ddAccess);
					}
				else
					{
					// Overlay successful.
					DP(__TEXT("Installed overlay"));
					DriverInstanceHandle.colorKeyed = TRUE;
					}
				}
#endif
			}

//		if (! DriverInstanceHandle.colorKeyed)
			{
			// Use inlay.
			INIT_IOCTL(SET_PIP_OFFSCREEN);
			in.units = units->kunits;
			in.logicalBase = NULL;   // switch off overlay, use inlay instead
			DO_IOCTL(SET_PIP_OFFSCREEN);
//			DP(__TEXT("Installing inlay"));

			// Initialize the windows description and its clip list.
			wd.frame = rect;
			wd.clips = 1;
			wd.clip = wr;
			wr[0].include = TRUE;
			wr[0].pos = wd.frame;
			screenWidth = ::GetSystemMetrics (SM_CXSCREEN);
			screenHeight = ::GetSystemMetrics (SM_CYSCREEN);

			// See if the window is moved over the screen limitations and mask these parts.
			if (wr[0].pos.left < 0) wr[0].pos.left = 0;
			if (wr[0].pos.top  < 0) wr[0].pos.top = 0;
			if (wr[0].pos.right  > screenWidth ) wr[0].pos.right = screenWidth;
			if (wr[0].pos.bottom > screenHeight) wr[0].pos.bottom = screenHeight;


			// Clip against all child windows.
			for (hw2 = ::GetWindow (units->pipWindow, GW_CHILD);  hw2 != NULL;  hw2 = GetWindow (hw2, GW_HWNDNEXT))
				{
				style = ::GetWindowLong (hw2, GWL_STYLE);
				if (::IsWindowVisible (hw2)  &&  (!(style & WS_CHILD) || (style & WS_CLIPSIBLINGS)))
					{
					// Add rectangle to the clip list.
					::GetWindowRect (hw2, &hr);
					wp = wr + wd.clips;
					wd.clips++;
					wp->include = FALSE;
					wp->pos.left   = hr.left;
					wp->pos.top    = hr.top;
					wp->pos.right  = hr.right;
					wp->pos.bottom = hr.bottom;
					}
				}


			childMode = TRUE;
			hwnd = units->pipWindow;
			do {
				if (childMode)
					{
					// Clip into the surrounding window
					::GetClientRect (hwnd, &mrect);
					hdc = ::GetDC (hwnd);
					::GetDCOrgEx (hdc, &pos);
					::ReleaseDC (hwnd, hdc);
					mrect.left = pos.x;
					mrect.top  = pos.y;
					mrect.right  += mrect.left;
					mrect.bottom += mrect.top;

					if (rect.left < mrect.left)   // check left edge
						{
						wp = wr + wd.clips;
						wd.clips++;
						wp->include = FALSE;
						wp->pos.left   = rect.left;
						wp->pos.top    = rect.top;
						wp->pos.right  = mrect.left;
						wp->pos.bottom = rect.bottom;
						}
					if (rect.top < mrect.top)   // check top edge
						{
						wp = wr + wd.clips;
						wd.clips++;
						wp->include = FALSE;
						wp->pos.left   = rect.left;
						wp->pos.top    = rect.top;
						wp->pos.right  = rect.right;
						wp->pos.bottom = mrect.top;
						}
					if (rect.right > mrect.right)   // check right edge
						{
						wp = wr + wd.clips;
						wd.clips++;
						wp->include = FALSE;
						wp->pos.left   = mrect.right;
						wp->pos.top    = rect.top;
						wp->pos.right  = rect.right;
						wp->pos.bottom = rect.bottom;
						}
					if (rect.bottom > mrect.bottom)   // check bottom edge
						{
						wp = wr + wd.clips;
						wd.clips++;
						wp->include = FALSE;
						wp->pos.left   = rect.left;
						wp->pos.top    = mrect.bottom;
						wp->pos.right  = rect.right;
						wp->pos.bottom = rect.bottom;
						}
					} // if (childMode)

				// Now iterate through all siblings in front of us.
				hw2 = hwnd;
				while (hwnd = ::GetWindow (hwnd, GW_HWNDPREV))
					{
					style = ::GetWindowLong (hwnd, GWL_STYLE);
					if (::IsWindowVisible (hwnd)  &&  (!(style & WS_CHILD) || (style & WS_CLIPSIBLINGS)))
						{
						// Add rectangle to the clip list.
						::GetWindowRect (hwnd, &hr);
						wp = wr + wd.clips;
						wd.clips++;
						wp->include = FALSE;
						wp->pos.left   = hr.left;
						wp->pos.top    = hr.top;
						wp->pos.right  = hr.right;
						wp->pos.bottom = hr.bottom;
						}
					}

				// Check if we are still a child.
				if (! (::GetWindowLong (hw2, GWL_STYLE) & WS_CHILD))
					childMode = FALSE;

				// Advance to the next parent window level.
				hwnd = GetParent (hw2);

				} while (::GetWindowLong (hw2, GWL_STYLE) & WS_CHILD);
			}
		}


	INIT_IOCTL(CONFIGURE_UNITS);
	in.units = units->kunits;
	in.tags = tags;
	DO_IOCTL(CONFIGURE_UNITS);
	}





static BOOL IsPIPWindow (HWND win)
	{
	int i;
	HWND hw;

	for (i = firstActive;  i != -1;  i = Units[i].next)
		{
		if (Units[i].pipEnabled)
			{
			hw = Units[i].pipWindow;

			while (hw != NULL)
				{
				if (hw == win) return TRUE;
				if (::GetWindowLong (hw, GWL_STYLE) & WS_CHILD)
					hw = GetParent(hw);
				else
					hw = NULL;
				}
			}
		}
	return FALSE;
	}





BOOL Affects (WINDOWPOS *hpos)
	{
	HWND hw, pw, aw;
	RECT rect;
	DWORD pos;
	HDC hdc;
	RECT hr, pr;
	POINT p;
	BOOL parentVisible;


	hw = hpos->hwnd;   // the window to be moved, sized, etc.

	::GetWindowRect (hw, &hr);
	if (::GetWindowLong (hw, GWL_STYLE) & WS_CHILD)
		{
//		DP(__TEXT("Is child"));
		p.x = hr.left;
		p.y = hr.top;
		pw = (HWND) ::GetWindowLong (hw, GWL_HWNDPARENT);
		::GetWindowRect (pw, &pr);
		::ScreenToClient (pw, &p);
		pr.left   = p.x;
		pr.top    = p.y;
		pr.right  = hr.right  - hr.left + pr.left;
		pr.bottom = hr.bottom - hr.top  + pr.top;

		parentVisible = TRUE;

		while (parentVisible  &&  pw)
			{
			parentVisible &= IsWindowVisible (pw);
			pw = (HWND)::GetWindowLong (pw, GWL_HWNDPARENT);
			}
		}
	else
		{
		// We are not a child.
		pr = hr;
		parentVisible = TRUE;
		}

	//DP(__TEXT("Flags %08lx"), hpos->flags);
/*
	DP(__TEXT("%x %x %08lx (%x) (%d,%d)-(%d,%d) (%d,%d)-(%d,%d)"), hw, pw, hpos->flags,
			      hpos->hwndInsertAfter,
			      hpos->x, hpos->y,hpos->cx, hpos->cy,
			      pr.left, pr.top, pr.right-pr.left, pr.bottom-pr.top);
  */

	if (! parentVisible)
		return FALSE;

	// If a window will show and is invisible, the PIP is affected.
	if ((SWP_SHOWWINDOW & hpos->flags)  &&  ! IsWindowVisible (hw))
		{
		//DP(__TEXT("win real show"));
		return TRUE;
		}
	if (0 && ! IsWindowVisible (hw))
		{
		//DP(__TEXT("win invisible"));
		return FALSE;
		}

	// If a window was really moved or sized, the PIP is affected.
	if (! (SWP_NOMOVE & hpos->flags)  &&  (hpos->x != pr.left  ||  hpos->y != pr.top))
		{
		//DP(__TEXT("win real move"));
		return TRUE;
		}
	if (! (SWP_NOSIZE & hpos->flags)  &&  (hpos->cx != pr.right-pr.left  ||  hpos->cy != pr.bottom-pr.top))
		{
		//DP(__TEXT("win real size"));
		return TRUE;
		}

	// If a window will hide and is visible, the PIP is affected.
	if ((SWP_HIDEWINDOW & hpos->flags)  &&  IsWindowVisible (hw))
		{
		//DP(__TEXT("win real hide"));
		return TRUE;
		}

/*	HWND tw = hw;
	while(tw)
		{
		DP(__TEXT("ZOrder %08lx"), tw);
		tw = ::GetWindow(tw, GW_HWNDPREV);
		}
*/
	// If the Z order is the same, the PIP is not affected.
	if (SWP_NOZORDER & hpos->flags)
		return FALSE;

	// Now, the Z order decides.
	// If all windows between hw and hpos->hwndInsertAfter are
	// invisible, we need not do anything. Else the PIP is affected.
	BOOL pipMoved = IsPIPWindow(hw);

	parentVisible = FALSE;
	HWND prev = ::GetWindow (hw, GW_HWNDPREV);
	while (prev != NULL  &&  prev != hpos->hwndInsertAfter)
		{
		if (IsWindowVisible (prev))
			{
			if (pipMoved)
				{
				//DP(__TEXT("  pipmoved %08lx visible"), prev);
				parentVisible = TRUE;
				}
			else if (IsPIPWindow(prev))
				{
				//DP(__TEXT("  ispip %08lx visible"), prev);
				parentVisible = TRUE;
				}
//			else
				//DP(__TEXT("neither pip %08lx visible"), prev);
			}
//		else
			//DP(__TEXT("  win %08lx not visible"), prev);
		prev = ::GetWindow (prev, GW_HWNDPREV);
		}
	if (prev == hpos->hwndInsertAfter)
		{
		return parentVisible;
		}

	// The hwndInsertAfter window is not in front of us, so it
	// must be behind us. Again, decide on visibility.
	//DP(__TEXT("  got to NULL"));
	parentVisible = FALSE;
	prev = ::GetWindow (hw, GW_HWNDNEXT);
	while (prev != NULL  &&  prev != hpos->hwndInsertAfter)
		{
		if (IsWindowVisible (prev))
			{
//			DP(__TEXT("  win %08lx visible"), prev);
			if (pipMoved)
				{
				//DP(__TEXT("  pipmoved %08lx visible"), prev);
				parentVisible = TRUE;
				}
			else if (IsPIPWindow(prev))
				{
				//DP(__TEXT("  ispip %08lx visible"), prev);
				parentVisible = TRUE;
				}
//			else
//				//DP(__TEXT("neither pip %08lx visible"), prev);
			}
//		else
			//DP(__TEXT("  win %08lx not visible"), prev);
		prev = ::GetWindow (prev, GW_HWNDNEXT);
		}
	if (prev == hpos->hwndInsertAfter)
		{
		if (IsWindowVisible (hpos->hwndInsertAfter)  &&  IsPIPWindow(hpos->hwndInsertAfter))
			{
			//DP(__TEXT("  after %08lx visible"), prev);
			return TRUE;
			}
		return parentVisible;
		}
	//DP(__TEXT("  win already bottom2"));
	return FALSE;
	}



LRESULT CALLBACK CallWndProc (int code, WPARAM wParam, LPARAM lParam)
	{
	int i;

	if (code >= 0)
		{
#if RET_HOOK
		CWPRETSTRUCT *msg = (CWPRETSTRUCT *)lParam;
#else
		CWPSTRUCT *msg = (CWPSTRUCT *)lParam;
#endif

		if (msg->message == WM_WINDOWPOSCHANGING)
			{
			LPWINDOWPOS pos = (LPWINDOWPOS)(msg->lParam);

			//DP(__TEXT("CallWndProc: Pos changing"));

			WaitForSingleObject (clipMutex, 0x7fffffff);

			if (Affects (pos) /*&& !lastMoved*/)
				{
				//DP(__TEXT("lastMoved is %08lx"), msg->hwnd);
				lastMoved = msg->hwnd;

//				DP(__TEXT("CallWndProc: check start"));
#if OVERLAY_SUPPORT
				if (DriverInstanceHandle.colorKeyed)
					{
					//DP(__TEXT("removing overlay"));
					VD32_RemoveDDOverlay (DriverInstanceHandle.ddAccess);
					DriverInstanceHandle.colorKeyed = FALSE;
					}
#endif
//				DP(__TEXT("CallWndProc: check end"));

DP(__TEXT("P-"));

				// Switch off all enabled PIPs.
				for (i = firstActive;  i != -1;  i = Units[i].next)
					{
					if (Units[i].pipEnabled)
						{
						/*
						if (!msgPending)
							{
							msgPending = TRUE;
							PostMessage(Units[i].pipWindow, doneMsg, 0, 0);
							}
						*/
//DP(__TEXT("CallWndProc: pip off"));
						INIT_IOCTL(ENABLE_PIP);
						in.units = Units[i].kunits;
						in.enable = FALSE;
						DO_IOCTL(ENABLE_PIP);
						}
					}

				}
			else if (lastMoved != NULL)
				{
				//DP(__TEXT("Hey last moved is set"));
				}
			ReleaseMutex (clipMutex);
			}
		else if (msg->message == WM_WINDOWPOSCHANGED  &&  lastMoved) //msg->hwnd == lastMoved)
			{
			//DP(__TEXT("CallWndProc: Pos changed"));

			WaitForSingleObject (clipMutex, 0x7fffffff);

			msgPending = FALSE;

DP(__TEXT("P+"));

			for (i = firstActive;  i != -1;  i = Units[i].next)
				{
				if (Units[i].pipEnabled)
					{
					SendWinDesc (Units + i);

//DP(__TEXT("CallWndProc: pip on"));
					INIT_IOCTL(ENABLE_PIP);
					in.units = Units[i].kunits;
					in.enable = TRUE;
					DO_IOCTL(ENABLE_PIP);

					VDR_UpdatePIP (TU(Units + i));
					}
				}

			//DP(__TEXT("lastMoved is NULL"));
			lastMoved = NULL;

			ReleaseMutex (clipMutex);
			}
		}

	return CallNextHookEx (sizeHook, code, wParam, lParam);
	}





LRESULT CALLBACK GetMsgProc (int code, WPARAM wParam, LPARAM lParam)
	{
	int i;

	if (code >= 0)
		{
		MSG *msg = (MSG *)lParam;

		if (msg->message == doneMsg)
			{
			WaitForSingleObject (clipMutex, 0x7fffffff);

			msgPending = FALSE;

			for (i = firstActive;  i != -1;  i = Units[i].next)
				{
				if (Units[i].pipEnabled)
					{
					SendWinDesc (Units + i);

					INIT_IOCTL(ENABLE_PIP);
					in.units = Units[i].kunits;
					in.enable = TRUE;
					DO_IOCTL(ENABLE_PIP);
					}
				}

			ReleaseMutex (clipMutex);
			}
		}

	return CallNextHookEx (doneHook, code, wParam, lParam);
	}



void VDR_ServiceProcess (void)
	{
	BOOL terminate = FALSE;

	DP(__TEXT("Entering PIP Service Process"));
	while (! terminate)
		{
		WaitForSingleObject (ServiceRequest, INFINITE);
		switch (ServiceCommand)
			{
			case DD_INSTALLHOOK:
				DP(__TEXT("Installing PIP hook"));
#if RET_HOOK
				sizeHook = SetWindowsHookEx(WH_CALLWNDPROCRET,
													 (HOOKPROC)CallWndProc, hinst,
													 NULL);
#else
				sizeHook = SetWindowsHookEx(WH_CALLWNDPROC,
													 (HOOKPROC)CallWndProc, hinst,
													 NULL);
#endif
				break;
			case DD_REMOVEHOOK:
				DP(__TEXT("Removing PIP hook"));
				if (sizeHook) UnhookWindowsHookEx(sizeHook);
				sizeHook = NULL;
				break;
			case DD_TERMINATE:
				terminate = TRUE;
				break;
			case DD_NONE:
				break;
			default:
				//DP(__TEXT("Invalid command %ld"), ServiceCommand);
				break;
			}
		ServiceCommand = DD_NONE;
		SetEvent (ServiceDone);
		}

	// Leaving the loop means to terminate.
	DP(__TEXT("Terminate PIP Service Process"));
	}


#if USE_HOOK_PROCESS

int CreateServiceProcess (void)
	{
	if (ServiceProcesses == 0  &&  ! ServiceActive)
		{
		STARTUPINFO startupInfo =	{
											sizeof(STARTUPINFO),
											NULL, NULL, NULL,
											0, 0, 0, 0,
											0, 0,
											0,
											STARTF_FORCEOFFFEEDBACK,
											0,
											0,
											NULL, NULL, NULL, NULL
											};
DP(__TEXT("Creating Hook process\n\n"));
		ServiceActive = TRUE;
		ServiceCommand = DD_NONE;
		if (! CreateProcess (NULL,
									__TEXT("VDCMSERV"),
									NULL, NULL,
									FALSE,
									CREATE_NEW_PROCESS_GROUP | NORMAL_PRIORITY_CLASS,
									NULL,
									NULL,
									&startupInfo,
									&processInfo))
			{
			DP(__TEXT("  can't create hook process"));
			ServiceActive = FALSE;
			return FALSE;
			}
		}
//	else
		ServiceProcesses++;
	return TRUE;
	}


void FinishServiceProcess (void)
	{
//	if (ServiceProcesses > 0)
		ServiceProcesses--;
	if (ServiceProcesses <= 0  &&  ServiceActive)
		{
DP(__TEXT("Deleting hook process\n\n"));
		WaitForSingleObject (ServiceLock, INFINITE);
		ServiceCommand = DD_TERMINATE;
		ServiceActive = FALSE;
		SetEvent (ServiceRequest);
		WaitForSingleObject (ServiceDone, INFINITE);
		SetEvent (ServiceLock);
		WaitForSingleObject (processInfo.hProcess, 2000);
		CloseHandle (processInfo.hProcess);
		CloseHandle (processInfo.hThread);
		}
	}

#endif

#endif	// PIP_SUPPORT



///////////////////////////////////////////////////////////////////////////////
// Exported DLL Functions
///////////////////////////////////////////////////////////////////////////////


DllEXPORT	void	WINAPI VDR_RegisterCallback(GenericHook * hook)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_RegisterCallback+"));
#endif

	if (!WorkerThread) InitThreadContext();
	hook->Register(WorkerQueue);

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_RegisterCallback-"));
#endif
	}

DllEXPORT	void	WINAPI VDR_UnregisterCallback(GenericHook * hook)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_UnregisterCallback+"));
#endif

	if (WorkerThread && WorkerQueue)
		{
		INIT_IOCTL(UNREGISTER_CALLBACK);

		in.queue = WorkerQueue;
		in.hook	= hook;

		DO_IOCTL(UNREGISTER_CALLBACK);
		}

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_UnregisterCallback-"));
#endif
	}


DllEXPORT Error WINAPI VDR_OpenDriver (TCHAR __far *name, DWORD boardID, VDRHandle __far &handle)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_OpenDriver+"));
#endif

	if (DriverOpenCnt == 0)
		{
		if (!WorkerThread) InitThreadContext();

		GNREASSERT(DriverInstanceHandle.Initialize());
//		GetDDPrimaryCaps ();
		}

	DriverOpenCnt++;

	handle = &DriverInstanceHandle;

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_OpenDriver-"));
#endif

	GNRAISE_OK;
	}


DllEXPORT Error WINAPI VDR_CloseDriver (VDRHandle handle)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_CloseDriver+"));
#endif

	if (DriverOpenCnt)
		{
		if (handle == &DriverInstanceHandle)
			{
			DriverOpenCnt--;

/*			INIT_IOCTL(CLOSE_DRIVER);
			in.handle = driver->handle;
			DO_IOCTL(CLOSE_DRIVER);

			if (IS_ERROR(out.error))
				GNRAISE(out.error);
*/

			if (DriverOpenCnt == 0)
				{
				if (WorkerThread) FiniThreadContext();
				DriverInstanceHandle.Free ();
				}
			}
		else
			{
			DP(__TEXT("VDR_CLoseDriver: invalid handle!"));
			GNRAISE(GNR_OBJECT_NOT_FOUND);
			}
		}

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_CloseDriver-"));
#endif

	GNRAISE_OK;
	}

DllEXPORT Error WINAPI VDR_ReconfigureDriver(VDRHandle handle)
	{
	INIT_IOCTL(RECONFIGURE_DRIVER);
	DO_IOCTL(RECONFIGURE_DRIVER);

	return out.error;
	}

DllEXPORT DWORD WINAPI VDR_AvailUnits (VDRHandle handle)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_AvailUnits+"));
#endif

	INIT_IOCTL(AVAIL_UNITS);
//	in.handle = driver->handle;
	DO_IOCTL(AVAIL_UNITS);

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_AvailUnits-"));
#endif

	return out.units;
	}


DllEXPORT Error WINAPI VDR_OpenUnits (VDRHandle handle, DWORD requnits, UnitSet __far &units)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_OpenUnits+"));
#endif

	IUnitSet	iunits;


#if PIP_SUPPORT
	if (requnits & PIP_UNIT)
		{
		GetDDPrimaryCaps ();
		}
#endif

	INIT_IOCTL(ALLOCATE_UNITS);

	units = NULL;
	in.units = requnits;

	DO_IOCTL(ALLOCATE_UNITS);

	if (!IS_ERROR(out.error))
		{
		if (!openCnt)
			{
			InitUnits();
			}
		openCnt++;

		if (!WorkerThread) InitThreadContext();

		iunits = AllocUnit(handle);
		units = TU(iunits);
		iunits->kunits = out.units;

		if (requnits & MPEG_DECODER_UNIT)
			iunits->hasMPEGDecoder = TRUE;
		}

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_OpenUnits-"));
#endif

	GNRAISE(out.error);
	}

DllEXPORT	Error WINAPI VDR_OpenSubUnits(UnitSet parent, DWORD requnits, UnitSet __far &units)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_OpenSubUnits+"));
#endif

	IUnitSet	iunits;

	INIT_IOCTL(ALLOC_SUB_UNITS);

	units = NULL;
	in.parent = TU(parent)->kunits;
	in.units = requnits;

	DO_IOCTL(ALLOC_SUB_UNITS);

	if (!IS_ERROR(out.error))
		{
		iunits = AllocUnit(TU(parent)->handle);
		units = TU(iunits);
		iunits->kunits = out.units;

		if (requnits & MPEG_DECODER_UNIT)
			iunits->hasMPEGDecoder = TRUE;

		openCnt++;
		}

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_OpenSubUnits-"));
#endif

	GNRAISE(out.error);
	}

DllEXPORT	Error WINAPI VDR_CloseUnits(UnitSet units)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_CloseUnits+"));
#endif
//DP(__TEXT("VDR_CloseUnits %lx"), TU(units)->id);

	if (TU(units)->pipEnabled)
		VDR_EnablePIP (units, FALSE);

	INIT_IOCTL(FREE_UNITS);

	in.units = TU(units)->kunits;

	DO_IOCTL(FREE_UNITS);

	FreeUnit(TU(units));

	openCnt--;
	if (!openCnt)
		{
		}

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_CloseUnits-"));
#endif

	GNRAISE(out.error);
	}

#pragma optimize("", off)
DllEXPORT	Error WINAPI VDR_ConfigureUnits(UnitSet units, TAG __far * tags)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_ConfigureUnits+"));
#endif
//DP(__TEXT("VDR_ConfigureUnits+"));

	BOOL changed = FALSE;

	INIT_IOCTL(CONFIGURE_UNITS);

	in.units = TU(units)->kunits;
	in.tags = tags;

#if PIP_SUPPORT
	PARSE_TAGS_START(tags);
		GETSETC(PIP_WINDOW, TU(units)->pipWindow);
	PARSE_TAGS_END;
#endif

	DO_IOCTL(CONFIGURE_UNITS);

#if PIP_SUPPORT
	{
	BOOL needUpdate = FALSE;
	PARSE_TAGS_START(tags);
		case CSET_PIP_DEST_LEFT:
		case CSET_PIP_DEST_TOP:
		case CSET_PIP_DEST_WIDTH:
		case CSET_PIP_DEST_HEIGHT:
			needUpdate = TRUE;
			break;
	PARSE_TAGS_END;
	if (needUpdate)
		VDR_UpdatePIP (units);
	}

	WaitForSingleObject (clipMutex, 0x7fffffff);

	if (changed && TU(units)->pipEnabled)
		SendWinDesc(TU(units));

	ReleaseMutex (clipMutex);
#endif

	Sleep(1);


//DP(__TEXT("VDR_ConfigureUnits-"));

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_ConfigureUnits-"));
#endif

	GNRAISE(out.error);
	}

#pragma optimize("", on)


DllEXPORT	Error WINAPI VDR_LockUnits(UnitSet units)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_LockUnits+"));
#endif

	INIT_IOCTL(LOCK_UNITS);

	in.units = TU(units)->kunits;

	DO_IOCTL(LOCK_UNITS);

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_LockUnits-"));
#endif

	GNRAISE(out.error);
	}

DllEXPORT	Error WINAPI VDR_UnlockUnits(UnitSet units)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_UnlockUnits+"));
#endif

	INIT_IOCTL(UNLOCK_UNITS);

	in.units = TU(units)->kunits;

	DO_IOCTL(UNLOCK_UNITS);

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_UnlockUnits-"));
#endif

	GNRAISE(out.error);
	}


DllEXPORT	Error WINAPI VDR_ActivateUnits(UnitSet units)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_ActivateUnits+"));
#endif

	INIT_IOCTL(ACTIVATE_UNITS);

	in.units = TU(units)->kunits;

	DO_IOCTL(ACTIVATE_UNITS);

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_ActivateUnits-"));
#endif

	GNRAISE(out.error);
	}


DllEXPORT	Error WINAPI VDR_PassivateUnits(UnitSet units)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_PassivateUnits+"));
#endif

	INIT_IOCTL(PASSIVATE_UNITS);

	in.units = TU(units)->kunits;

	DO_IOCTL(PASSIVATE_UNITS);

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_PassivateUnits-"));
#endif

	GNRAISE(out.error);
	}



DllEXPORT	Error WINAPI VDR_EnablePIP(UnitSet units, BOOL enable)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_EnablePIP+"));
#endif

#if PIP_SUPPORT
	BOOL switchOff = (! enable  &&  TU(units)->pipEnabled);

	DP(__TEXT("VDR_EnablePIP: pip enable %d, %lx"), enable, TU(units)->id);

	if (lastMoved != NULL)
		{
		DP(__TEXT("  enable delayed (lastMoved)"));
		// Try again for 2 seconds, then ignore it.
		for (int i = 0;  i < 25*2  &&  lastMoved != NULL;  i++)
			Sleep (40);

		if (lastMoved != NULL)
			DP(__TEXT("  still not NULL"));
		}

	if (enable  &&  ! TU(units)->pipEnabled)
		{
		// A new PIP is enabled. Install hooks on the first one.
		if (activePIPCnt == 0)
			{
#if WIN_SUPPORT
			doneMsg = RegisterWindowMessage(__TEXT("Done Resizing"));
#if USE_HOOK_PROCESS
			CreateServiceProcess ();
			if (ServiceActive)
				{
				DP(__TEXT("  invoking pip install"));
				WaitForSingleObject (ServiceLock, INFINITE);
				ServiceCommand = DD_INSTALLHOOK;
				SetEvent (ServiceRequest);
				WaitForSingleObject (ServiceDone, INFINITE);
				SetEvent (ServiceLock);
				DP(__TEXT("  invoking done"));
				}
#else
#if RET_HOOK
			sizeHook = SetWindowsHookEx(WH_CALLWNDPROCRET,
												 (HOOKPROC)CallWndProc, hinst,
												 NULL);
#else
			sizeHook = SetWindowsHookEx(WH_CALLWNDPROC,
												 (HOOKPROC)CallWndProc, hinst,
												 NULL);
#endif
#endif	// USE_HOOK_PROCESS
#endif
			}
		activePIPCnt++;
		}

	WaitForSingleObject (clipMutex, 0x7fffffff);

	INIT_IOCTL(ENABLE_PIP);

//	if (enable && ! TU(units)->pipEnabled)
	if (enable || TU(units)->pipEnabled)
		{
		SendWinDesc(TU(units));
		}

	TU(units)->pipEnabled = enable;

	in.units = TU(units)->kunits;
	in.enable = enable;

	DO_IOCTL(ENABLE_PIP);

	ReleaseMutex (clipMutex);

	if (switchOff)
		{
		activePIPCnt--;
		DP(__TEXT("  activePIPCnt Off %ld"), activePIPCnt);
		if (activePIPCnt == 0)
			{
#if USE_HOOK_PROCESS
			if (ServiceActive)
				{
				DP(__TEXT("  invoking pip remove"));
				WaitForSingleObject (ServiceLock, INFINITE);
				ServiceCommand = DD_REMOVEHOOK;
				SetEvent (ServiceRequest);
				WaitForSingleObject (ServiceDone, INFINITE);
				SetEvent (ServiceLock);
				DP(__TEXT("  invoking done"));
				}
			FinishServiceProcess ();
#else
//			if (doneHook) UnhookWindowsHookEx(doneHook);
			if (sizeHook) UnhookWindowsHookEx(sizeHook);
//			doneHook = NULL;
			sizeHook = NULL;
#endif	// USE_HOOK_PROCESS
			}
		}

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_EnablePIP-"));
#endif

	GNRAISE(out.error);
#else

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_EnablePIP-"));
#endif

	GNRAISE_OK;
#endif
	}


Error InternalConfigureUnits(UnitSet units, TAG __far * tags)
	{
	INIT_IOCTL(CONFIGURE_UNITS);

	in.units = TU(units)->kunits;
	in.tags = tags;

	DO_IOCTL(CONFIGURE_UNITS);

	GNRAISE(out.error);
	}

Error InternalConfigureUnitsTags (UnitSet units, TAG tags, ...)
	{
	return InternalConfigureUnits (units, &tags);
	}


DllEXPORT	Error WINAPI VDR_UpdatePIP(UnitSet units)
	{
	HDC		dstDC;
	HBRUSH	hbrOld, hbr;
	RECT		rect;
	POINT		org;
	int		srcWidth, srcHeight;
	DWORD		dwLen;
	DWORD		dwBytesPerLine;
	Error		error = GNR_OK;

	BITMAPINFOHEADER		bi;
	LPSTR						lpDIBBits;   // pointer to DIB bits
	LPBITMAPINFOHEADER	dib;

#if TRACE_VDR_CALLS
	//DP(__TEXT("VDR_UpdatePIP+"));
#endif
//DP(__TEXT("VDR_UpdatePIP %lx"), TU(units)->id);

	if (TU(units)->id >= MAX_UNITS)
		DP(__TEXT("id > MAX_UNITS!"));

#if PIP_SUPPORT

//DP(__TEXT("UpdatePIP"));
	WaitForSingleObject (clipMutex, 0x7fffffff);

	// Get source size of PIP

	error = InternalConfigureUnitsTags(units, GET_PIP_SOURCE_WIDTH(srcWidth),
															GET_PIP_SOURCE_HEIGHT(srcHeight),
															TAGDONE);
	if (!IS_ERROR(error))
		{
		if (srcWidth != 0 && srcHeight != 0)
			{
			WORD wBitCount = 24;
			DWORD dwWidth = (DWORD) (srcWidth / 2);
			DWORD dwHeight = (DWORD) (srcHeight / 2);

			bi.biSize = sizeof(BITMAPINFOHEADER);
			bi.biWidth = dwWidth;         // fill in width from parameter
			bi.biHeight = dwHeight;       // fill in height from parameter
			bi.biPlanes = 1;          		// must be 1
			bi.biBitCount = wBitCount;		// we only work with 24 bits
			bi.biCompression = 0L;			// uncompressed bitmap, BI_RGB
			bi.biSizeImage = 0;				// 0's here mean "default"
			bi.biXPelsPerMeter = 0;
			bi.biYPelsPerMeter = 0;
			bi.biClrUsed = 0;
			bi.biClrImportant = 0;

			dwBytesPerLine = WIDTHBYTES(wBitCount * dwWidth);
			dwLen = bi.biSize + (dwBytesPerLine * dwHeight);

			// Allocate memory for DIB with bitmap info header
			dib = (LPBITMAPINFOHEADER) malloc(dwLen);
			}

		if (dib)
			{
			*dib = bi;

			INIT_IOCTL(UPDATE_PIP);
			in.units = TU(units)->kunits;
			in.dib	= dib;
			DO_IOCTL(UPDATE_PIP);

			if (!IS_ERROR(out.error)  &&  TU(units)->pipWindow)
				{
//				DP(__TEXT("Before out.dib check"));
				::GetClientRect (TU(units)->pipWindow, &rect);

				if (out.dib)
					{
//					DP(__TEXT("restoring DIB"));
					dstDC = GetDC(TU(units)->pipWindow);

					lpDIBBits = (LPSTR)(((BYTE __far *)dib)+dib->biSize);

					::SetStretchBltMode (dstDC, COLORONCOLOR);		// Set stretch mode for color

					::StretchDIBits (dstDC, rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top,
										 0, 0, dib->biWidth, dib->biHeight, lpDIBBits, (LPBITMAPINFO)dib, DIB_RGB_COLORS, SRCCOPY);

					ReleaseDC (TU(units)->pipWindow, dstDC);
					}
				else
					{
//					DP(__TEXT("Clearing area"));
					dstDC = GetDC (TU(units)->pipWindow);
					hbr = ::CreateSolidBrush (RGB(0,0,0));
					hbrOld = (HBRUSH) ::SelectObject (dstDC, hbr);
		//DP(__TEXT("client pos %ld, %ld"), (long)rect.left, (long)rect.top);
		//DP(__TEXT("client size %ld, %ld"), (long)(rect.right-rect.left), (long)(rect.bottom-rect.top));

					::GetDCOrgEx (dstDC, &org);
		//DP(__TEXT("DC org %ld, %ld"), (long)org.x, (long)org.y);
					if (out.destWidth	== 0  ||  out.destHeight == 0)
						::Rectangle (dstDC, rect.left, rect.top, rect.right, rect.bottom);
					else
						{
						::Rectangle (dstDC, rect.left, rect.top, rect.right, out.destTop-org.y);
						::Rectangle (dstDC, rect.left, out.destTop-org.y+out.destHeight, rect.right, rect.bottom);
						::Rectangle (dstDC, rect.left, out.destTop-org.y, out.destLeft-org.x, out.destTop-org.y+out.destHeight);
						::Rectangle (dstDC, out.destLeft-org.x+out.destWidth, out.destTop-org.y, rect.right, out.destTop-org.y+out.destHeight);
						}

					::SelectObject (dstDC, hbrOld);
					::DeleteObject (hbr);
					ReleaseDC (TU(units)->pipWindow, dstDC);
					}

				error = GNR_OK;
				}
			else
				{
				DP(__TEXT("Error in UPDATE_PIP ioctl"));
				error = out.error;
				}

			free(dib);
			}
		else
			{
			DP(__TEXT("########## no DIB!"));
			error = GNR_NOT_ENOUGH_MEMORY;
			}
		}

	ReleaseMutex (clipMutex);

#endif

#if TRACE_VDR_CALLS_E
	//DP(__TEXT("VDR_UpdatePIP-"));
#endif

	GNRAISE(error);
	}


DllEXPORT	Error WINAPI VDR_OptimizeBuffer(UnitSet units, int __far & minPixVal)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_OptimizeBuffer"));
#endif

	GNRAISE_OK;
	}


DllEXPORT	Error WINAPI VDR_GrabFrame(UnitSet units, FPTR base,
                            WORD width, WORD height,
                            WORD stride,
                            GrabFormat fmt)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_GrabFrame+"));
#endif

	INIT_IOCTL(GRAB_FRAME);

	in.units = TU(units)->kunits;
	in.base = base;
	in.width = width;
	in.height = height;
	in.stride = stride;
	in.fmt = fmt;

	DO_IOCTL(GRAB_FRAME);

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_GrabFrame-"));
#endif

	GNRAISE(out.error);
	}



DllEXPORT	DWORD WINAPI VDR_SendMPEGData(UnitSet units, HPTR data, DWORD size)
	{
#if TRACE_VDR_CALLS
//DP(__TEXT("VDR_SendMPEGData+"));
#endif

	INIT_IOCTL(SEND_MPEG_DATA);

	in.units = TU(units)->kunits;
	in.data = data;
	in.size = size;

	DO_IOCTL(SEND_MPEG_DATA);

#if TRACE_VDR_CALLS_E
//DP(__TEXT("VDR_SendMPEGData-"));
#endif

	return out.done;
	}

DllEXPORT	void WINAPI VDR_CompleteMPEGData(UnitSet units)
	{
#if TRACE_VDR_CALLS
//DP(__TEXT("VDR_CompleteMPEGData+"));
#endif

	INIT_IOCTL(COMPLETE_MPEG_DATA);

	in.units = TU(units)->kunits;

	DO_IOCTL(COMPLETE_MPEG_DATA);

#if TRACE_VDR_CALLS_E
//DP(__TEXT("VDR_CompleteMPEGData-"));
#endif
	}


DllEXPORT	Error WINAPI VDR_SendMPEGCommand(UnitSet units, MPEGCommand com, long param, DWORD __far &tag)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_SendMPEGCommand+, %x"), com);
#endif

	INIT_IOCTL(SEND_MPEG_COMMAND);

	in.units = TU(units)->kunits;
	in.com = com;
	in.param = param;

	DO_IOCTL(SEND_MPEG_COMMAND);

	tag = out.tag;

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_SendMPEGCommand-"));
#endif

	GNRAISE(out.error);
	}

DllEXPORT	Error WINAPI VDR_DoMPEGCommand(UnitSet units, MPEGCommand com, long param)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_DoMPEGCommand+"));
#endif

	INIT_IOCTL(DO_MPEG_COMMAND);

	in.units = TU(units)->kunits;
	in.com = com;
	in.param = param;

	DO_IOCTL(DO_MPEG_COMMAND);

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_DoMPEGCommand-"));
#endif

	GNRAISE(out.error);
	}

DllEXPORT	Error WINAPI VDR_CompleteMPEGCommand(UnitSet units, DWORD tag)
	{
#if TRACE_VDR_CALLS
//DP(__TEXT("VDR_CompleteMPEGCommand+"));
#endif

	INIT_IOCTL(COMPLETE_MPEG_COMMAND);

	in.units = TU(units)->kunits;
	in.tag = tag;

	DO_IOCTL(COMPLETE_MPEG_COMMAND);

#if TRACE_VDR_CALLS_E
//DP(__TEXT("VDR_CompleteMPEGCommand-"));
#endif

	GNRAISE(out.error);
	}

DllEXPORT BOOL	WINAPI VDR_MPEGCommandPending (UnitSet units, DWORD tag)
	{
#if TRACE_VDR_CALLS
//DP(__TEXT("VDR_MPEGCommandPending+"));
#endif

	INIT_IOCTL(MPEG_COMMAND_PENDING);

	in.units = TU(units)->kunits;
	in.tag = tag;

	DO_IOCTL(MPEG_COMMAND_PENDING);

#if TRACE_VDR_CALLS_E
//DP(__TEXT("VDR_MPEGCommandPending-"));
#endif

	return out.status;
	}

DllEXPORT	DWORD WINAPI VDR_CurrentMPEGLocation(UnitSet units)
	{
#if TRACE_VDR_CALLS
//DP(__TEXT("VDR_CurrentMPEGLocation+"));
#endif

	INIT_IOCTL(CURRENT_MPEG_LOCATION);

	in.units = TU(units)->kunits;

	DO_IOCTL(CURRENT_MPEG_LOCATION);

#if TRACE_VDR_CALLS_E
//DP(__TEXT("VDR_CurrentMPEGLocation-"));
#endif

	return out.pos;
	}

DllEXPORT DWORD WINAPI VDR_CurrentMPEGTransferLocation (UnitSet units)
	{
#if TRACE_VDR_CALLS
//DP(__TEXT("VDR_CurrentMPEGTransferLocation+"));
#endif

	INIT_IOCTL(CURRENT_MPEG_TRANSFER_LOCATION);

	in.units = TU(units)->kunits;

	DO_IOCTL(CURRENT_MPEG_TRANSFER_LOCATION);

#if TRACE_VDR_CALLS_E
//DP(__TEXT("VDR_CurrentMPEGTransferLocation-"));
#endif

	return out.pos;
	}

DllEXPORT	MPEGState WINAPI VDR_CurrentMPEGState(UnitSet units)
	{
#if TRACE_VDR_CALLS
//DP(__TEXT("VDR_CurrentMPEGState+"));
#endif

	INIT_IOCTL(CURRENT_MPEG_STATE);

	in.units = TU(units)->kunits;

	DO_IOCTL(CURRENT_MPEG_STATE);

#if TRACE_VDR_CALLS_E
//DP(__TEXT("VDR_CurrentMPEGState-"));
#endif

	return out.state;
	}

DllEXPORT Error WINAPI VDR_InstallMPEGWinHooks (UnitSet units, HWND hwnd, WORD refillMsg, WORD signalMsg, WORD doneMsg)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_InstallMPEGWinHooks+"));
#endif

	if (TU(units) && TU(units)->hasMPEGDecoder)
		{
		TU(units)->refillHook = new MPEGUnitsRefillHook(hwnd, refillMsg);
		TU(units)->signalHook = new MPEGUnitsSignalHook(hwnd, signalMsg);
		TU(units)->doneHook = new MPEGUnitsDoneHook(hwnd, doneMsg);

		INIT_IOCTL(INSTALL_MPEG_WIN_HOOKS);

		in.units = TU(units)->kunits;
		in.signalHook	= TU(units)->signalHook;
		in.doneHook		= TU(units)->doneHook;
		in.refillHook	= TU(units)->refillHook;

		DO_IOCTL(INSTALL_MPEG_WIN_HOOKS);

		GNRAISE(out.error);
		}

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_InstallMPEGWinHooks-"));
#endif

	GNRAISE_OK;
	}

DllEXPORT Error WINAPI VDR_RemoveMPEGWinHooks (UnitSet units)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_RemoveMPEGWinHooks+"));
#endif

	if (TU(units) && TU(units)->hasMPEGDecoder)
		{
		INIT_IOCTL(INSTALL_MPEG_WIN_HOOKS);

		in.units = TU(units)->kunits;
		in.signalHook	= NULL;
		in.doneHook		= NULL;
		in.refillHook	= NULL;

		DO_IOCTL(INSTALL_MPEG_WIN_HOOKS);

		delete TU(units)->refillHook;
		delete TU(units)->signalHook;
		delete TU(units)->doneHook;

		TU(units)->refillHook = NULL;
		TU(units)->signalHook = NULL;
		TU(units)->doneHook = NULL;
		}

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_RemoveMPEGWinHooks-"));
#endif

	GNRAISE_OK;
	}

DllEXPORT Error WINAPI VDR_CompleteMPEGRefillMessage (UnitSet units)
	{
#if TRACE_VDR_CALLS
//DP(__TEXT("VDR_CompleteMPEGRefillMessage+"));
#endif

	if (TU(units) && TU(units)->hasMPEGDecoder && TU(units)->refillHook)
		TU(units)->refillHook->pending = FALSE;

#if TRACE_VDR_CALLS_E
//DP(__TEXT("VDR_CompleteMPEGRefillMessage-"));
#endif

	GNRAISE_OK;
	}

DllEXPORT Error WINAPI VDR_DoAuthenticationCommand (UnitSet units, MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE * key)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_DoAuthenticationCommand+"));
#endif

	INIT_IOCTL(DO_AUTHENTICATION_COMMAND);

	in.units = TU(units)->kunits;
	in.com = com;
	in.sector = sector;
	in.key = key;

	DO_IOCTL(DO_AUTHENTICATION_COMMAND);

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_DoAuthenticationCommand-"));
#endif

	GNRAISE(out.error);
	}

DllEXPORT BOOL WINAPI VDR_CheckRegionCodeValid (UnitSet units, BYTE regionSet)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_CheckRegionCodeValid+"));
#endif

	INIT_IOCTL(CHECK_REGIONCODE_VALID);

	in.units = TU(units)->kunits;
	in.regionSet = regionSet;

	DO_IOCTL(CHECK_REGIONCODE_VALID);

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_CheckRegionCodeValid-"));
#endif

	return out.status;
	}



DllEXPORT Error WINAPI VDR_SendAudioNotification(UnitSet units, DWORD senderID, DWORD type, DWORD msg, DWORD data)
	{
#if TRACE_VDR_CALLS
DP(__TEXT("VDR_SendAudioNotification+"));
#endif

	INIT_IOCTL(SEND_AUDIO_NOTIFICATION)

	in.units = TU(units)->kunits;
	in.senderID = senderID;
	in.msg = msg;
	in.type = type;
	in.data = data;

	DO_IOCTL(SEND_AUDIO_NOTIFICATION);

#if TRACE_VDR_CALLS_E
DP(__TEXT("VDR_SendAudioNotification-"));
#endif

	GNRAISE(out.error);
	}


///////////////////////////////////////////////////////////////////////////////
// Driver/DLL Initialization
///////////////////////////////////////////////////////////////////////////////


BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
	{
	HKEY key;

	switch(fdwReason)
		{
		case DLL_PROCESS_ATTACH:
			DP(__TEXT("Process Attach+"));
			hinst = hinstDLL;

			if (ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE,
				                               EVENT_LOG_REG_LOCATION,
														 &key))
				{
				const TCHAR buffer[] = EVENT_LOG_REG_DRIVER;
				const DWORD seven = 7;

				RegSetValueEx(key, __TEXT("EventMessageFile"), 0, REG_SZ,
					           (BYTE *)buffer, sizeof(buffer));
				RegSetValueEx(key, __TEXT("TypesSupported"), 0, REG_DWORD,
					           (BYTE *)&seven, 4);
				RegCloseKey(key);
				}

			kDriver = CreateFile(KERNEL_DRIVER_SYMBOLIC_NAME,
										GENERIC_READ | GENERIC_WRITE,
										FILE_SHARE_READ,
										NULL,
										OPEN_EXISTING,
										FILE_ATTRIBUTE_NORMAL,
										NULL);

			if (kDriver == INVALID_HANDLE_VALUE || kDriver == NULL)
				{
				DWORD error = GetLastError();
				return FALSE;
				}

			clipMutex = CreateMutex(NULL, FALSE, __TEXT("VDRPIPMUTEX"));
//			dummyWindow = CreateWindow(__TEXT("STATIC"), __TEXT("Fake move"), WS_VISIBLE, 0, 0, 10, 10, NULL, NULL, hinstDLL, NULL);

#if USE_HOOK_PROCESS
			SECURITY_ATTRIBUTES sa;
			PSECURITY_DESCRIPTOR psd;
			BOOL success;
			success = FALSE;
			psd = (PSECURITY_DESCRIPTOR) LocalAlloc (LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
			if (psd == NULL)
				{
				DP(__TEXT("alloc psd failed"));
				}
			else
				{
				if (! InitializeSecurityDescriptor (psd, SECURITY_DESCRIPTOR_REVISION))
					{
					DP(__TEXT("InitializeSecurityDescriptor failed"));
					}
				else
					{
					// An empty ACL means full access.
					if (! SetSecurityDescriptorDacl (psd, TRUE, (PACL)NULL, FALSE))
						{
						DP(__TEXT("SetSecurityDescriptorDacl failed"));
						}
					else
						{
						sa.nLength = sizeof (SECURITY_ATTRIBUTES);
						sa.lpSecurityDescriptor = psd;
						sa.bInheritHandle = TRUE;
						ServiceLock		= CreateEvent(&sa, FALSE, TRUE, __TEXT("VDCMSERV.SERVICELOCK"));
						ServiceRequest	= CreateEvent(&sa, FALSE, FALSE, __TEXT("VDCMSERV.SERVICEREQUEST"));
						ServiceDone		= CreateEvent(&sa, FALSE, FALSE, __TEXT("VDCMSERV.SERVICEDONE"));
						if (! ServiceLock)
							{
							DP(__TEXT("No ServiceLock created!"));
							}
						}
					}
				if (psd)
					LocalFree (psd);
				}
#endif

			DP(__TEXT("Process Attach-"));
			break;

		case DLL_THREAD_ATTACH:
			break;

		case DLL_THREAD_DETACH:
			break;

		case DLL_PROCESS_DETACH:
			DP(__TEXT("Process Detach+"));
			if (WorkerThread) FiniThreadContext();
			DP(__TEXT("Closing process handle"));
			CloseHandle(kDriver);
			if (clipMutex) CloseHandle(clipMutex);

#if USE_HOOK_PROCESS
			if (ServiceLock)		CloseHandle(ServiceLock);
			if (ServiceRequest)	CloseHandle(ServiceRequest);
			if (ServiceDone)		CloseHandle(ServiceDone);
#endif

			DP(__TEXT("Process Detach-"));
			break;
		}

   return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\win32inc\RpcDceP.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    rpcdcep.h

Abstract:

    This module contains the private RPC runtime APIs for use by the
    stubs and by support libraries.  Applications must not call these
    routines.

--*/

#ifndef __RPCDCEP_H__
#define __RPCDCEP_H__

#if _MSC_VER>1000
#pragma once
#endif

// Set the packing level for RPC structures for Dos and Windows.

#if defined
#pragma pack(2)
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _RPC_VERSION {
    unsigned short MajorVersion;
    unsigned short MinorVersion;
} RPC_VERSION;

typedef struct _RPC_SYNTAX_IDENTIFIER {
    GUID SyntaxGUID;
    RPC_VERSION SyntaxVersion;
} RPC_SYNTAX_IDENTIFIER, __RPC_FAR * PRPC_SYNTAX_IDENTIFIER;

typedef struct _RPC_MESSAGE
{
    RPC_BINDING_HANDLE Handle;
    unsigned long DataRepresentation;
    void __RPC_FAR * Buffer;
    unsigned int BufferLength;
    unsigned int ProcNum;
    PRPC_SYNTAX_IDENTIFIER TransferSyntax;
    void __RPC_FAR * RpcInterfaceInformation;
    void __RPC_FAR * ReservedForRuntime;
    RPC_MGR_EPV __RPC_FAR * ManagerEpv;
    void __RPC_FAR * ImportContext;
    unsigned long RpcFlags;
} RPC_MESSAGE, __RPC_FAR * PRPC_MESSAGE;


typedef RPC_STATUS
RPC_ENTRY RPC_FORWARD_FUNCTION(
                       IN UUID             __RPC_FAR * InterfaceId,
                       IN RPC_VERSION      __RPC_FAR * InterfaceVersion,
                       IN UUID             __RPC_FAR * ObjectId,
                       IN unsigned char         __RPC_FAR * Rpcpro,
                       IN void __RPC_FAR * __RPC_FAR * ppDestEndpoint);

enum RPC_ADDRESS_CHANGE_TYPE
{
    PROTOCOL_NOT_LOADED = 1,
    PROTOCOL_LOADED,
    PROTOCOL_ADDRESS_CHANGE
};

typedef void
RPC_ENTRY RPC_ADDRESS_CHANGE_FN(
                        IN void * arg
                        );

/*
*  New context handle flavors.
*/

#define RPC_CONTEXT_HANDLE_DEFAULT_GUARD    ((void *)0xFFFFF00D)

#define RPC_CONTEXT_HANDLE_DEFAULT_FLAGS    0x00000000UL
#define RPC_CONTEXT_HANDLE_FLAGS            0x30000000UL
#define RPC_CONTEXT_HANDLE_SERIALIZE        0x10000000UL
#define RPC_CONTEXT_HANDLE_DONT_SERIALIZE   0x20000000UL

/*
 * Types of function calls for datagram rpc
 */

#define RPC_NCA_FLAGS_DEFAULT       0x00000000  /* 0b000...000 */
#define RPC_NCA_FLAGS_IDEMPOTENT    0x00000001  /* 0b000...001 */
#define RPC_NCA_FLAGS_BROADCAST     0x00000002  /* 0b000...010 */
#define RPC_NCA_FLAGS_MAYBE         0x00000004  /* 0b000...100 */

#define RPC_BUFFER_COMPLETE         0x00001000 /* used by pipes */
#define RPC_BUFFER_PARTIAL          0x00002000 /* used by pipes */
#define RPC_BUFFER_EXTRA            0x00004000 /* used by pipes */
#define RPC_BUFFER_ASYNC            0x00008000 /* used by async rpc */
#define RPC_BUFFER_NONOTIFY         0x00010000 /* used by async pipes */

#define RPCFLG_MESSAGE              0x01000000UL
#define RPCFLG_AUTO_COMPLETE        0x08000000UL
#define RPCFLG_LOCAL_CALL           0x10000000UL
#define RPCFLG_INPUT_SYNCHRONOUS    0x20000000UL
#define RPCFLG_ASYNCHRONOUS         0x40000000UL
#define RPCFLG_NON_NDR              0x80000000UL

#if defined
#define RPC_FLAGS_VALID_BIT 0x00008000
#elif defined
#define RPC_FLAGS_VALID_BIT 0x8000
#endif

typedef
void
(__RPC_STUB __RPC_FAR * RPC_DISPATCH_FUNCTION) (
    IN OUT PRPC_MESSAGE Message
    );

typedef struct {
    unsigned int DispatchTableCount;
    RPC_DISPATCH_FUNCTION __RPC_FAR * DispatchTable;
    LONG_PTR                          Reserved;
} RPC_DISPATCH_TABLE, __RPC_FAR * PRPC_DISPATCH_TABLE;

typedef struct _RPC_PROTSEQ_ENDPOINT
{
    unsigned char __RPC_FAR * RpcProtocolSequence;
    unsigned char __RPC_FAR * Endpoint;
} RPC_PROTSEQ_ENDPOINT, __RPC_FAR * PRPC_PROTSEQ_ENDPOINT;

/*
Both of these types MUST start with the InterfaceId and TransferSyntax.
Look at RpcIfInqId and I_RpcIfInqTransferSyntaxes to see why.
*/
#define NT351_INTERFACE_SIZE 0x40
#define RPC_INTERFACE_HAS_PIPES           0x0001

typedef struct _RPC_SERVER_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER InterfaceId;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    PRPC_DISPATCH_TABLE DispatchTable;
    unsigned int RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
    RPC_MGR_EPV __RPC_FAR *DefaultManagerEpv;
    void const __RPC_FAR *InterpreterInfo;
    unsigned int Flags ;
} RPC_SERVER_INTERFACE, __RPC_FAR * PRPC_SERVER_INTERFACE;

typedef struct _RPC_CLIENT_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER   InterfaceId;
    RPC_SYNTAX_IDENTIFIER   TransferSyntax;
    PRPC_DISPATCH_TABLE     DispatchTable;
    unsigned int            RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT   RpcProtseqEndpoint;
    ULONG_PTR               Reserved;
    void const __RPC_FAR *  InterpreterInfo;
    unsigned int Flags ;
} RPC_CLIENT_INTERFACE, __RPC_FAR * PRPC_CLIENT_INTERFACE;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetBufferWithObject (
    IN OUT RPC_MESSAGE __RPC_FAR * Message,
    IN UUID * ObjectUuid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSendReceive (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcFreeBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSend (
    IN OUT PRPC_MESSAGE Message
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcFreePipeBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN unsigned int NewSize
    ) ;

typedef void * I_RPC_MUTEX;

RPCRTAPI
void
RPC_ENTRY
I_RpcRequestMutex (
    IN OUT I_RPC_MUTEX * Mutex
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcClearMutex (
    IN I_RPC_MUTEX Mutex
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcDeleteMutex (
    IN I_RPC_MUTEX Mutex
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
I_RpcAllocate (
    IN unsigned int Size
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcFree (
    IN void __RPC_FAR * Object
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcPauseExecution (
    IN unsigned long Milliseconds
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetExtendedError (
    );

typedef
void
(__RPC_USER __RPC_FAR * PRPC_RUNDOWN) (
    void __RPC_FAR * AssociationContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle,
    IN PRPC_RUNDOWN RundownRoutine,
    IN void * Context
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcStopMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle
    );

RPCRTAPI
RPC_BINDING_HANDLE
RPC_ENTRY
I_RpcGetCurrentCallHandle(
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetAssociationContext (
    IN RPC_BINDING_HANDLE BindingHandle,
    OUT void __RPC_FAR * __RPC_FAR * AssociationContext
    );

RPCRTAPI
void *
RPC_ENTRY
I_RpcGetServerContextList (
    IN RPC_BINDING_HANDLE BindingHandle
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcSetServerContextList (
    IN RPC_BINDING_HANDLE BindingHandle,
    OUT void * ServerContextList
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsInterfaceExported (
    IN unsigned long EntryNameSyntax,
    IN unsigned short *EntryName,
    IN RPC_SERVER_INTERFACE * RpcInterfaceInformation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsInterfaceUnexported (
    IN unsigned long EntryNameSyntax,
    IN unsigned short *EntryName,
    IN RPC_SERVER_INTERFACE * RpcInterfaceInformation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingToStaticStringBindingW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short **StringBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqSecurityContext (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **SecurityContextHandle
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsBindingSetEntryNameW (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    IN unsigned short __RPC_FAR * EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsBindingSetEntryNameA (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    IN unsigned char __RPC_FAR * EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseqEp2A (
    IN unsigned char __RPC_FAR * NetworkAddress,
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor,
    IN void *Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseqEp2W (
    IN unsigned short __RPC_FAR * NetworkAddress,
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned short __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor,
    IN void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseq2W (
    IN unsigned short __RPC_FAR * NetworkAddress,
    IN unsigned short __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseq2A (
    IN unsigned char __RPC_FAR * NetworkAddress,
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN void * Policy
    );


#ifdef UNICODE
#define I_RpcNsBindingSetEntryName I_RpcNsBindingSetEntryNameW
#define I_RpcServerUseProtseqEp2 I_RpcServerUseProtseqEp2W
#define I_RpcServerUseProtseq2 I_RpcServerUseProtseq2W
#else
#define I_RpcNsBindingSetEntryName I_RpcNsBindingSetEntryNameA
#define I_RpcServerUseProtseqEp2 I_RpcServerUseProtseqEp2A
#define I_RpcServerUseProtseq2 I_RpcServerUseProtseq2A
#endif

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsBindingSetEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    IN unsigned char __RPC_FAR * EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseq2 (
    IN unsigned char __RPC_FAR * NetworkAddress,
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN void __RPC_FAR * SecurityDescriptor,
    IN void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseqEp2 (
    IN unsigned char __RPC_FAR * NetworkAddress,
    IN unsigned char __RPC_FAR * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char __RPC_FAR * Endpoint,
    IN void __RPC_FAR * SecurityDescriptor,
    IN void * Policy
    );
#endif

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqDynamicEndpointW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short __RPC_FAR * __RPC_FAR * DynamicEndpoint
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqDynamicEndpointA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * DynamicEndpoint
    );

#ifdef UNICODE
#define I_RpcBindingInqDynamicEndpoint I_RpcBindingInqDynamicEndpointW
#else
#define I_RpcBindingInqDynamicEndpoint I_RpcBindingInqDynamicEndpointA
#endif

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqDynamicEndpoint (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char __RPC_FAR * __RPC_FAR * DynamicEndpoint
    );

#endif

#define TRANSPORT_TYPE_CN        0x01
#define TRANSPORT_TYPE_DG        0x02
#define TRANSPORT_TYPE_LPC       0x04
#define TRANSPORT_TYPE_WMSG      0x08

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqTransportType (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Type
    );

typedef struct _RPC_TRANSFER_SYNTAX
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_TRANSFER_SYNTAX;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcIfInqTransferSyntaxes (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_TRANSFER_SYNTAX __RPC_FAR * TransferSyntaxes,
    IN unsigned int TransferSyntaxSize,
    OUT unsigned int __RPC_FAR * TransferSyntaxCount
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_UuidCreate (
    OUT UUID __RPC_FAR * Uuid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingIsClientLocal (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL,
    OUT unsigned int __RPC_FAR * ClientLocalFlag
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqConnId (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **ConnId,
    OUT int *pfFirstCall
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcSsDontSerializeContext (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcLaunchDatagramReceiveThread(
    void __RPC_FAR * pAddress
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerRegisterForwardFunction (
    IN RPC_FORWARD_FUNCTION  * pForwardFunction
    );

RPC_ADDRESS_CHANGE_FN * RPC_ENTRY
I_RpcServerInqAddressChangeFn();

RPC_STATUS RPC_ENTRY
I_RpcServerSetAddressChangeFn(
    IN RPC_ADDRESS_CHANGE_FN * pAddressChangeFn
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcConnectionInqSockBuffSize(
  OUT unsigned long __RPC_FAR * RecvBuffSize,
  OUT unsigned long __RPC_FAR * SendBuffSize
  );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcConnectionSetSockBuffSize(
   IN unsigned long RecvBuffSize,
   IN unsigned long SendBuffSize
   );

typedef
void
(*RPCLT_PDU_FILTER_FUNC) (
    IN void *Buffer,
    IN unsigned int BufferLength,
    IN int fDatagram
    );

typedef
void
(__cdecl *RPC_SETFILTER_FUNC) (
    IN RPCLT_PDU_FILTER_FUNC pfnFilter
    );

#ifndef WINNT
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerStartListening(
    void * hWnd
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerStopListening(
    ) ;

typedef RPC_STATUS (*RPC_BLOCKING_FN) (
    IN void * hWnd,
    IN void * Context,
    IN OPTIONAL void * hSyncEvent
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingSetAsync(
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_BLOCKING_FN BlockingFn,
    IN unsigned long ServerTid
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSetThreadParams(
    IN int fClientFree,
    IN OPTIONAL void *Context,
    IN OPTIONAL void * hWndClient
    );

RPCRTAPI
unsigned int
RPC_ENTRY
I_RpcWindowProc(
    IN void * hWnd,
    IN unsigned int Message,
    IN unsigned int wParam,
    IN unsigned long lParam
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUnregisterEndpointA (
    IN unsigned char * Protseq,
    IN unsigned char * Endpoint
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUnregisterEndpointW (
    IN unsigned short * Protseq,
    IN unsigned short * Endpoint
    );

#ifdef UNICODE
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointW
#else
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointA
#endif
#endif // WINNT

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerInqTransportType(
    OUT unsigned int __RPC_FAR * Type
    ) ;

RPCRTAPI
long
RPC_ENTRY
I_RpcMapWin32Status (
    IN RPC_STATUS Status
    );


#ifdef __cplusplus
}
#endif

// Reset the packing level for Dos and Windows.

#if defined
#pragma pack()
#endif

#endif /* __RPCDCEP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\boards\generic\win32\Vdgendrv.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef VDGENDRV_H
#define VDGENDRV_H

#define ONLY_EXTERNAL_VISIBLE

#include "library/common/prelude.h"

class GenericHook;


extern "C" {
DLLCALL	void	WINAPI VDR_RegisterCallback(GenericHook * hook);
DLLCALL	void	WINAPI VDR_UnregisterCallback(GenericHook * hook);
#define H20_RegisterCallback	VDR_RegisterCallback
}


#include "library/common/gnerrors.h"
#include "library/common/tags.h"
#include "library/common/tagunits.h"
#include "library/common/winports.h"

#include "library/hardware/videodma/generic/pip.h"

#include "library/hardware/video/generic/vidchip.h"


#include "library/hardware/video/generic/videnc.h"

#include "library/hardware/mpeg2dec/generic/mpeg2dec.h"
#ifndef NO_INTERNAL_INCLUDE
#include "library/hardware/mpeg2dec/generic/mp2dcryp.h"
#endif

#if BOARD_HAS_MPEG2_ENCODER
#include "library/hardware/mpeg2enc/generic/mpeg2enc.h"
#endif



typedef class __far UnitSetClass __far *UnitSet;
typedef class __far VDRHandleClass __far *VDRHandle;

extern "C" {

DLLCALL void VDR_ServiceProcess(void);

DLLCALL Error WINAPI VDR_OpenDriver(TCHAR * name, DWORD boardID, VDRHandle __far & handle);
DLLCALL Error WINAPI VDR_CloseDriver(VDRHandle handle);

DLLCALL DWORD WINAPI VDR_AvailUnits(VDRHandle handle);

DLLCALL Error WINAPI VDR_ReconfigureDriver(VDRHandle handle);

DLLCALL Error WINAPI VDR_OpenUnits(VDRHandle handle, DWORD requnits, UnitSet &units);
DLLCALL Error WINAPI VDR_OpenSubUnits(UnitSet parent, DWORD requnits, UnitSet &units);
DLLCALL Error WINAPI VDR_CloseUnits(UnitSet units);


DLLCALL Error WINAPI VDR_ConfigureUnits(UnitSet units, TAG * tags);
inline Error __cdecl VDR_ConfigureUnitsTags(UnitSet units, TAG tags, ...) {return VDR_ConfigureUnits(units, &tags);}

DLLCALL Error WINAPI VDR_LockUnits(UnitSet units);
DLLCALL Error WINAPI VDR_UnlockUnits(UnitSet units);
DLLCALL Error WINAPI VDR_ActivateUnits(UnitSet units);
DLLCALL Error WINAPI VDR_PassivateUnits(UnitSet units);


DLLCALL Error WINAPI VDR_EnablePIP(UnitSet units, BOOL enable);
DLLCALL Error WINAPI VDR_UpdatePIP(UnitSet units);
DLLCALL Error WINAPI VDR_GrabFrame(UnitSet units, FPTR base,
                                   WORD width, WORD height,
                                   WORD stride,
                                   GrabFormat fmt);

DLLCALL Error WINAPI VDR_OptimizeBuffer(UnitSet units, WORD __far & minPixVal);


//
// MPEG Functions
//
DLLCALL DWORD	WINAPI VDR_SendMPEGData(UnitSet units, HPTR data, DWORD size);
DLLCALL void	WINAPI VDR_CompleteMPEGData(UnitSet units);
DLLCALL DWORD	WINAPI VDR_SendMPEGDataMultiple(UnitSet units, MPEGDataSizePair * data, DWORD size);

DLLCALL DWORD	WINAPI VDR_SendMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType, HPTR data, DWORD size, LONG timeStamp);
DLLCALL void	WINAPI VDR_CompleteMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType);
DLLCALL DWORD  WINAPI VDR_SendMPEGDataSplitMultiple(UnitSet units, MPEGElementaryStreamType streamType, MPEGDataSizePair * data, DWORD size, int timeStamp);
DLLCALL void	WINAPI VDR_RestartMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType);

DLLCALL Error	WINAPI VDR_SendMPEGCommand(UnitSet units, MPEGCommand com, long param, DWORD __far &tag);
DLLCALL Error	WINAPI VDR_DoMPEGCommand(UnitSet units, MPEGCommand com, long param);
DLLCALL Error	WINAPI VDR_CompleteMPEGCommand(UnitSet units, DWORD tag);
DLLCALL BOOL	WINAPI VDR_MPEGCommandPending(UnitSet units, DWORD tag);

DLLCALL DWORD	WINAPI VDR_CurrentMPEGLocation(UnitSet units);
DLLCALL DWORD	WINAPI VDR_CurrentMPEGTransferLocation(UnitSet units);
DLLCALL MPEGState WINAPI VDR_CurrentMPEGState(UnitSet units);

DLLCALL Error	WINAPI VDR_InstallMPEGWinHooks(UnitSet units, HWND hwnd, WORD refillMsg, WORD signalMsg, WORD doneMsg);
DLLCALL Error	WINAPI VDR_RemoveMPEGWinHooks(UnitSet units);
DLLCALL Error	WINAPI VDR_CompleteMPEGRefillMessage(UnitSet units);

DLLCALL Error  WINAPI VDR_InstallMessagePort(UnitSet units, GenericMsgPort * port);
DLLCALL Error  WINAPI VDR_RemoveMessagePort(UnitSet units);

#ifndef NO_INTERNAL_INCLUDE
DLLCALL Error	WINAPI VDR_DoAuthenticationCommand(UnitSet units, MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key);
DLLCALL BOOL	WINAPI VDR_CheckRegionCodeValid(UnitSet units, BYTE regionSet);
#endif


#if BOARD_HAS_MPEG2_ENCODER

DLLCALL Error  WINAPI VDR_DoCommand(UnitSet units, MPEGCommand com, long param);
DLLCALL Error	WINAPI VDR_PutBuffer(UnitSet units, HPTR data, DWORD size);
DLLCALL Error  WINAPI VDR_InstallMPEGTransferDoneHook(UnitSet units, HWND hwnd, WORD transferDoneMsg);
DLLCALL Error  WINAPI VDR_RemoveMPEGTransferDoneHook(UnitSet units);
DLLCALL Error  WINAPI VDR_InstallMPEGEncoderBufferStarvingHook(UnitSet units, HWND hwnd, WORD bufferStarvingMsg);
DLLCALL Error  WINAPI VDR_RemoveMPEGEncoderBufferStarvingHook(UnitSet units);

#endif



	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\dongle\dvdbld\dvdbld.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dvdbld.cpp

Abstract:

    This module contains routines to generate ROM binary for DVD dongle.

--*/

#include "dvdbldp.h"

XDCS_DVD_CODE_INFORMATION xdcs;
HANDLE OutputFileHandle = INVALID_HANDLE_VALUE;
ULONG CompressedSize;
ULONG UncompressedSize;

UCHAR ImgbPrivateKeyData[] = {
    0x52,0x53,0x41,0x32,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0x9B,0x83,0xD4,0xD5,
    0xDE,0x16,0x25,0x8E,0xE5,0x15,0xF2,0x18,
    0x9D,0x19,0x1C,0xF8,0xFE,0x91,0xA5,0x83,
    0xAE,0xA5,0xA8,0x95,0x3F,0x01,0xB2,0xC9,
    0x34,0xFB,0xC7,0x51,0x2D,0xAC,0xFF,0x38,
    0xE6,0xB6,0x7B,0x08,0x4A,0xDF,0x98,0xA3,
    0xFD,0x31,0x81,0xBF,0xAA,0xD1,0x62,0x58,
    0xC0,0x6C,0x8F,0x8E,0xCD,0x96,0xCE,0x6D,
    0x03,0x44,0x59,0x93,0xCE,0xEA,0x8D,0xF4,
    0xD4,0x6F,0x6F,0x34,0x5D,0x50,0xF1,0xAE,
    0x99,0x7F,0x1D,0x92,0x15,0xF3,0x6B,0xDB,
    0xF9,0x95,0x8B,0x3F,0x54,0xAD,0x37,0xB5,
    0x4F,0x0A,0x58,0x7B,0x48,0xA2,0x9F,0x9E,
    0xA3,0x16,0xC8,0xBD,0x37,0xDA,0x9A,0x37,
    0xE6,0x3F,0x10,0x1B,0xA8,0x4F,0xA3,0x14,
    0xFA,0xBE,0x12,0xFB,0xD7,0x19,0x4C,0xED,
    0xAD,0xA2,0x95,0x8F,0x39,0x8C,0xC4,0x69,
    0x0F,0x7D,0xB8,0x84,0x0A,0x99,0x5C,0x53,
    0x2F,0xDE,0xF2,0x1B,0xC5,0x1D,0x4C,0x43,
    0x3C,0x97,0xA7,0xBA,0x8F,0xC3,0x22,0x67,
    0x39,0xC2,0x62,0x74,0x3A,0x0C,0xB5,0x57,
    0x01,0x3A,0x67,0xC6,0xDE,0x0C,0x0B,0xF6,
    0x08,0x01,0x64,0xDB,0xBD,0x81,0xE4,0xDC,
    0x09,0x2E,0xD0,0xF1,0xD0,0xD6,0x1E,0xBA,
    0x38,0x36,0xF4,0x4A,0xDD,0xCA,0x39,0xEB,
    0x76,0xCF,0x95,0xDC,0x48,0x4C,0xF2,0x43,
    0x8C,0xD9,0x44,0x26,0x7A,0x9E,0xEB,0x99,
    0xA3,0xD8,0xFB,0x30,0xA8,0x14,0x42,0x82,
    0x8D,0xB4,0x31,0xB3,0x1A,0xD5,0x2B,0xF6,
    0x32,0xBC,0x62,0xC0,0xFE,0x81,0x20,0x49,
    0xE7,0xF7,0x58,0x2F,0x2D,0xA6,0x1B,0x41,
    0x62,0xC7,0xE0,0x32,0x02,0x5D,0x82,0xEC,
    0xA3,0xE4,0x6C,0x9B,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xCD,0xE1,0xAD,0xFB,
    0x97,0x2B,0x02,0xF8,0xC9,0xB4,0xFF,0xF7,
    0x81,0x6C,0xC1,0x91,0x11,0xB8,0x44,0x5A,
    0xF9,0x18,0x6C,0x20,0xB5,0xBC,0xA9,0x17,
    0xD7,0x21,0x76,0x50,0x65,0xA0,0xB5,0x7B,
    0x70,0x57,0x19,0x3C,0xA0,0x03,0x59,0x27,
    0x5D,0xBA,0xE1,0x66,0xEE,0xAF,0xB1,0xFE,
    0x59,0xCE,0x9A,0x80,0x96,0xA8,0x8A,0x0A,
    0x96,0x05,0x92,0x1D,0x43,0xF9,0xB5,0x10,
    0x22,0xE8,0xB7,0xFC,0x93,0x40,0x85,0x63,
    0xF9,0x96,0xEC,0x24,0xE8,0xDE,0xAC,0x65,
    0x17,0xA7,0xD7,0x6C,0xFB,0x0A,0x6E,0x0C,
    0xFA,0xCC,0xF3,0xB1,0xC9,0x13,0x6A,0xB0,
    0x99,0x10,0x1B,0x69,0x7B,0xB0,0x1E,0x36,
    0x9E,0xDD,0x67,0xD4,0xD2,0xE3,0xB1,0x11,
    0xE7,0xEB,0x8C,0x14,0x6F,0xCC,0xCE,0x71,
    0xA5,0x29,0xA2,0xCE,0x00,0x00,0x00,0x00,
    0x07,0xB3,0xF5,0x5E,0x12,0x32,0x0D,0x07,
    0x28,0x09,0x10,0xCB,0x78,0xFD,0xDA,0x92,
    0xB3,0xCB,0x54,0xBF,0x66,0x5F,0x0E,0xCB,
    0x0B,0x66,0x94,0xDA,0x03,0xCB,0xBA,0x05,
    0xA5,0xE6,0x4B,0xBD,0x28,0xC8,0x12,0xB1,
    0x6C,0x6B,0x2A,0x9D,0x86,0xE1,0x57,0xAC,
    0xC1,0x8F,0x1B,0xF7,0x26,0x39,0x3E,0x44,
    0x9E,0x53,0x12,0x25,0x88,0x0A,0x3F,0xE0,
    0xF7,0xA5,0xB8,0xCD,0xF7,0xE3,0x63,0xA8,
    0xF3,0xBD,0x78,0xFE,0x5C,0xB2,0x73,0x84,
    0xE3,0x25,0x9A,0x28,0xE2,0x35,0x55,0xC3,
    0x4B,0xD4,0x17,0x96,0xBE,0xC8,0xC6,0x26,
    0x40,0x2C,0xEC,0x2E,0x54,0x28,0x0E,0xBC,
    0x6B,0xE0,0x0F,0x58,0xB7,0xAB,0x93,0x84,
    0x78,0x47,0x53,0x06,0xD1,0x84,0xBE,0x79,
    0x35,0x13,0xA6,0x75,0x76,0xCF,0x8E,0xC0,
    0x00,0x00,0x00,0x00,0x95,0xAE,0xEA,0x78,
    0x33,0xBB,0x54,0x92,0x45,0xE4,0xA6,0xD1,
    0xFA,0x5E,0xE0,0x94,0x1E,0xAC,0xFA,0x4D,
    0x06,0x48,0xEE,0x92,0x4F,0x19,0x2A,0xD3,
    0xE6,0x45,0x75,0x4E,0x24,0x6B,0xDB,0x18,
    0xF0,0xD0,0x42,0xEA,0x8E,0x2D,0x3F,0xC8,
    0x40,0xB1,0x30,0x59,0x0B,0x3C,0x94,0x6A,
    0x91,0xD8,0x3C,0xDC,0xC5,0xE7,0x84,0xB1,
    0x1D,0x01,0x38,0x62,0x38,0x0E,0x23,0x1E,
    0xCF,0x69,0x7C,0xAD,0xC5,0xA3,0xE2,0x97,
    0x57,0x72,0x65,0x66,0xD2,0x76,0x74,0x58,
    0x1C,0x58,0x6D,0x70,0x18,0x43,0x8D,0x83,
    0x45,0x29,0x23,0xC6,0xA0,0xB8,0x06,0x96,
    0x0E,0xCA,0x2B,0x16,0xF4,0x62,0x48,0x77,
    0x0B,0x1A,0x89,0xA8,0x41,0xB8,0xD6,0xFF,
    0x3A,0x76,0x4B,0xF4,0x2D,0x52,0x96,0xF8,
    0xC6,0x69,0xA9,0x31,0x00,0x00,0x00,0x00,
    0xB3,0xC9,0x4D,0xCE,0x69,0xEF,0x44,0x70,
    0x7E,0x77,0x52,0x14,0x0E,0x71,0x52,0xED,
    0x48,0x6D,0x2C,0xFA,0x77,0x6A,0xA0,0x78,
    0xC8,0x05,0x24,0xB7,0xD3,0x00,0x2E,0x44,
    0x36,0x73,0xE1,0x87,0x1A,0x75,0x4D,0x7F,
    0x62,0xA4,0x0D,0xB2,0x6C,0xB9,0x07,0x5E,
    0xF7,0x9E,0x21,0x42,0xDD,0xC9,0xA2,0x6A,
    0x62,0x96,0xD6,0x4B,0xF2,0x25,0x87,0x75,
    0x4B,0xE4,0x21,0x5F,0x59,0xCD,0x76,0x40,
    0x6D,0x35,0xC1,0xBD,0x6A,0x12,0xED,0x12,
    0x89,0xB5,0xA8,0x58,0xF4,0x15,0x95,0x47,
    0x84,0xFA,0xF1,0xD8,0xE2,0x85,0x9C,0x52,
    0x81,0xDD,0x0B,0x64,0x48,0xF0,0xFC,0x1F,
    0x9A,0x31,0x12,0xA1,0x08,0xD8,0x0C,0xF9,
    0x64,0xAE,0x36,0x04,0x2E,0x1D,0xCE,0xBD,
    0x3F,0xFC,0xEE,0x62,0xB2,0x8B,0x4E,0x4C,
    0x00,0x00,0x00,0x00,0xA3,0x67,0xDF,0xAE,
    0xF0,0x4B,0x5F,0xF5,0x46,0xB1,0x67,0x39,
    0x24,0x29,0xD6,0xE2,0xDF,0x78,0xB1,0x05,
    0x63,0x3F,0x03,0xB0,0xEF,0x01,0x14,0xD8,
    0x42,0x69,0x4D,0x1D,0x87,0xB2,0x4C,0x3B,
    0x21,0xD6,0xA2,0xA1,0xBD,0x5E,0xCB,0xB2,
    0x97,0xBB,0x23,0xD8,0xB6,0x0B,0x68,0x94,
    0x25,0x6F,0x2B,0xFD,0xAD,0x6F,0x33,0x58,
    0xB1,0x77,0x1E,0x77,0x0D,0xF3,0xFC,0xCE,
    0x32,0x58,0x9A,0x15,0xC7,0xCE,0x29,0x5A,
    0x8A,0x0F,0x94,0xF9,0xBD,0x3C,0xAC,0x45,
    0xC3,0x6E,0x3C,0x72,0x95,0x2D,0xDD,0x16,
    0x30,0x5F,0x9D,0xD7,0x1C,0x76,0xA2,0x6C,
    0xCE,0xF0,0x7B,0x35,0xDC,0xD4,0x7E,0xEF,
    0x8E,0x01,0x53,0xE8,0x43,0xF8,0x18,0xDF,
    0xBD,0x25,0x6C,0xBC,0x5E,0x42,0x5D,0xA1,
    0x75,0xC9,0x76,0x7E,0x00,0x00,0x00,0x00,
    0xA9,0x91,0x2B,0xBF,0x27,0x08,0x55,0xC3,
    0xDE,0xC9,0x11,0xF1,0x37,0xCC,0xAA,0xC9,
    0x81,0xC8,0x1D,0xD1,0x12,0xA4,0xB0,0xD6,
    0x65,0xAB,0xBB,0x92,0xD5,0x37,0x6F,0x70,
    0x8C,0xAC,0x30,0xF7,0xA7,0x79,0x10,0xEC,
    0x46,0xA3,0x08,0x2A,0xC4,0x9A,0xD0,0x49,
    0x3A,0x77,0x23,0xF2,0x86,0xEF,0x82,0xE5,
    0xE5,0x7B,0x50,0xED,0xD5,0x43,0xA7,0x33,
    0xED,0xD7,0xA4,0x7A,0xB6,0x35,0x60,0x9D,
    0xB9,0xAD,0x93,0xB4,0xD6,0x3C,0x3D,0xCE,
    0xDF,0x43,0x00,0xC2,0xFC,0xE1,0x5A,0x98,
    0x3A,0x07,0x7B,0xCE,0xA1,0x2F,0xEE,0x01,
    0x70,0x83,0x8B,0xC1,0x3F,0xB7,0x79,0x5E,
    0x3D,0x2F,0xBD,0x9F,0x7D,0xD9,0xBE,0x66,
    0xE2,0x32,0xD4,0x92,0x3D,0xD5,0xE1,0x9F,
    0xE7,0x2F,0x22,0x52,0xCA,0xD1,0xFB,0xBC,
    0x6F,0x80,0x82,0x34,0x1D,0x13,0x07,0x39,
    0x24,0xC7,0x83,0x7D,0x61,0x9A,0x73,0x84,
    0x6B,0x30,0x79,0x10,0xE6,0x1F,0xC7,0xC1,
    0x0F,0x22,0x09,0xAA,0x15,0xB7,0x00,0x1D,
    0x6E,0x1A,0x93,0x4D,0x34,0xC7,0x1B,0x75,
    0x56,0xAF,0x48,0x14,0x6D,0x66,0x9A,0xB6,
    0x8E,0x69,0xFA,0x67,0x95,0x78,0xEC,0xE6,
    0x9E,0xAF,0x43,0xA0,0x3D,0x43,0x6F,0xD1,
    0x49,0x4F,0x35,0x6A,0x9C,0x83,0xB3,0x03,
    0x50,0x40,0x2C,0x4A,0x63,0x2B,0x15,0x43,
    0x6C,0x1E,0xDD,0x9D,0x61,0xA3,0x04,0xBB,
    0x87,0xB6,0x35,0x1A,0x32,0x48,0x0F,0x87,
    0xF3,0xE9,0x32,0x38,0x8B,0x7A,0x5F,0x74,
    0x87,0x47,0x5A,0xEE,0x65,0x5C,0xBC,0x9F,
    0xAF,0xB5,0x88,0xA6,0x77,0x5B,0xA5,0x3A,
    0xB7,0xDB,0x54,0xB4,0xF5,0x78,0x32,0x1E,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00
};

VOID
TranslateError(
    IN DWORD ErrorCode
    )
{
    LPVOID lpMsgBuf;

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL, ErrorCode, 0, (LPTSTR)&lpMsgBuf, 0, NULL );
    fprintf( stderr, "DVDBLD : error DV%04x : %s\n", ErrorCode, lpMsgBuf );
    LocalFree( lpMsgBuf );
}

MI_MEMORY
DIAMONDAPI
LzxAlloc(
    ULONG cb
    )
{
    return LocalAlloc( LPTR, cb );
}

VOID
DIAMONDAPI
LzxFree(
    MI_MEMORY pv
    )
{
    LocalFree( pv );
}

int
DIAMONDAPI
CompressionCallback(
    void * pfol,
    unsigned char * compressed_data,
    long compressed_size,
    long uncompressed_size
    )
{
    ULONG BytesWritten;
    LZXBOX_BLOCK Block;

    //
    // Write block header
    //

    Block.CompressedSize = (USHORT)compressed_size;
    Block.UncompressedSize = (USHORT)uncompressed_size;

    CompressedSize += sizeof Block + compressed_size;
    UncompressedSize += uncompressed_size;

    if ( !WriteFile(OutputFileHandle, &Block, sizeof(Block), &BytesWritten, NULL) ) {
        return -1;
    }

    //
    // Write compressed data
    //

    if ( !WriteFile(OutputFileHandle, compressed_data, compressed_size, &BytesWritten, NULL) ) {
        return -1;
    }

    return 0;
}

DWORD
CompressFile(
    IN PVOID  InputBuffer,
    IN SIZE_T InputSize,
    IN HANDLE OutputFileHandle
    )
{
    DWORD error;
    UINT DestSize;
    int LciReturn;
    UINT SourceSize;
    ULONG_PTR Source;
    LZXCONFIGURATION cfg;
    LCI_CONTEXT_HANDLE Handle;
    SIZE_T BytesRead, BytesRemaining;
    SIZE_T BytesCompressed;

    SourceSize = LZX_CHUNK_SIZE;
    cfg.WindowSize = LZX_WINDOW_SIZE;
    cfg.SecondPartitionSize = 64 * 1024;

    LciReturn = LCICreateCompression( &SourceSize, &cfg, LzxAlloc, LzxFree,
                                      &DestSize, &Handle, CompressionCallback,
                                      NULL );

    if ( LciReturn != MCI_ERROR_NO_ERROR) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    BytesRemaining = InputSize;
    Source = (ULONG_PTR)InputBuffer;
    BytesRead = (BytesRemaining > SourceSize) ? SourceSize : BytesRemaining;

    while ( BytesRemaining ) {
        LciReturn = LCICompress( Handle, (PVOID)Source, BytesRead, NULL,
                                 DestSize, &BytesCompressed );

        if ( LciReturn != MCI_ERROR_NO_ERROR ) {
            fprintf( stderr, "Compression failed (%d)\n", LciReturn );
            break;
        }

        BytesRemaining -= BytesRead;
        BytesRead = (BytesRemaining > SourceSize) ? SourceSize : BytesRemaining;
        Source += SourceSize;
    }

    LCIFlushCompressorOutput( Handle );
    LCIDestroyCompression( Handle );

    return BytesRemaining ? ERROR_GEN_FAILURE : ERROR_SUCCESS;
}

enum { ftOther, ftXbe, ftBin };

int FtOfFile(LPCSTR szName)
{
    LPSTR psz;
    psz = strrchr(szName, '.');

    if(!psz)
        return ftOther;
    if ( _stricmp(psz,".bin") == 0 )
        return ftBin;
    if ( _stricmp(psz,".xbe") == 0 )
        return ftXbe;
    return ftOther;
}

int __cdecl main( int argc, char *argv[] )
{
    HANDLE InputFileHandle  = INVALID_HANDLE_VALUE;
    HANDLE InputFileMapped  = NULL;
    HANDLE OutputFileMapped = NULL;
    PBYTE  InputBuffer = NULL;
    XDCS_DVD_CODE_INFORMATION *MappedHeader = NULL;
    SIZE_T InputSize;
    DWORD  error = ~0;
    DWORD  BytesWritten;
    ULONG Region;
    ULONG Version;
    BYTE HeaderDigest[ XC_DIGEST_LEN ];
    PXBEIMAGE_HEADER pxih;
    PXBEIMAGE_CERTIFICATE pxcert;
    PXBEIMAGE_SECTION pxsh;
    ULONG cbXbeHeaders;
    int dcbHeaders;
    int ftInput, ftOutput;
    BYTE rgbBuf[8192];
    PBYTE pbSign;

    if ( argc != 5 && argc ) {
        fprintf(stderr, "Usage:\tDVDBLD <version> <region> <input-file> <output-file>\n");
        fprintf(stderr, "\tinput-file can be .exe, .xbe, or .rom\n");
        fprintf(stderr, "\toutputfile can be .xbe or .rom\n");
        TranslateError( ERROR_INVALID_PARAMETER );
        return -1;
    }

    ftInput = FtOfFile(argv[3]);
    ftOutput = FtOfFile(argv[4]);

    if(ftOutput == ftOther) {
        fprintf(stderr, "illegal output file type\n");
        TranslateError( ERROR_INVALID_PARAMETER );
        return -3;
    }

    __try {

        if ( ftInput == ftOutput ) {

            //
            // Copy from existing image file
            //

            if ( !CopyFile(argv[3], argv[4], FALSE) ) {
                goto Error;
            }
            OutputFileHandle = CreateFile( argv[4],
                GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, 0 );

            if ( OutputFileHandle == INVALID_HANDLE_VALUE ) {
                goto Error;
            }

        } else {
            /* We're going to do a file conversion, so set up the input and
             * output files and get ready to convert */

            InputFileHandle = CreateFile( argv[3], GENERIC_READ, FILE_SHARE_READ, 0,
                                          OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0 );

            if ( InputFileHandle == INVALID_HANDLE_VALUE ) {
                goto Error;
            }

            InputSize = GetFileSize( InputFileHandle, 0 );

            InputFileMapped = CreateFileMapping( InputFileHandle, 0, PAGE_READONLY,
                                                 0, InputSize, 0 );

            if ( InputFileMapped == NULL ) {
                goto Error;
            }

            InputBuffer = (PBYTE)MapViewOfFile( InputFileMapped, FILE_MAP_READ, 0, 0, 0 );

            if ( !InputBuffer ) {
                goto Error;
            }

            OutputFileHandle = CreateFile( argv[4],
                GENERIC_READ | GENERIC_WRITE, 0, 0, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL, 0 );

            if ( OutputFileHandle == INVALID_HANDLE_VALUE ) {
                goto Error;
            }

            switch(ftInput) {
            case ftXbe:
                /* Copying xbe->bin, so we need to spit out the header --
                 * we fill in the file size later on */
                pxih = (PXBEIMAGE_HEADER)InputBuffer;
                if(pxih->SizeOfImage != InputSize) {
                    error = ERROR_BAD_FORMAT;
                    goto Error;
                }
                if(!WriteFile(OutputFileHandle, &xdcs, sizeof xdcs,
                        &BytesWritten, NULL))
                    goto Error;
                if(!WriteFile(OutputFileHandle, InputBuffer,
                        InputSize, &BytesWritten, NULL))
                    goto Error;
                break;

            case ftBin:
                /* Copying bin->xbe, so we just need to lose the header */
                if(!WriteFile(OutputFileHandle,
                        ((XDCS_DVD_CODE_INFORMATION *)InputBuffer + 1),
                        InputSize - sizeof xdcs, &BytesWritten, NULL))
                    goto Error;
                break;

            default:
                /* Copying from a PE file, so we need to make space for the
                 * XBE headers */
                cbXbeHeaders = sizeof *pxih + XBEIMAGE_CERTIFICATE_BASE_SIZEOF +
					sizeof *pxsh;

                if ( ftOutput == ftBin && !WriteFile(OutputFileHandle,
                        &xdcs, sizeof xdcs, &BytesWritten, NULL) )
                    goto Error;

                if(INVALID_SET_FILE_POINTER == SetFilePointer(OutputFileHandle,
                        cbXbeHeaders, NULL, FILE_CURRENT))
                    goto Error;

                error = CompressFile( InputBuffer, InputSize, OutputFileHandle);

                if ( error != ERROR_SUCCESS ) {
                    TranslateError( error );
                    __leave;
                }

                if(UncompressedSize != InputSize) {
                    error = ERROR_GEN_FAILURE;
                    goto Error;
                }
                break;
            }
        }

        OutputFileMapped = CreateFileMapping( OutputFileHandle, 0, PAGE_READWRITE, 0, 0, 0 );

        if ( OutputFileMapped == INVALID_HANDLE_VALUE ) {
            goto Error;
        }

        MappedHeader = (XDCS_DVD_CODE_INFORMATION*)MapViewOfFile( OutputFileMapped, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
        if ( !MappedHeader ) {
            goto Error;
        }

        //
        // Locate the XBE headers
        //

        if(ftOutput == ftBin)
            pxih = (PXBEIMAGE_HEADER)(MappedHeader + 1);
        else
            pxih = (PXBEIMAGE_HEADER)MappedHeader;

        switch(ftInput) {
        case ftOther:
            pxcert = (PXBEIMAGE_CERTIFICATE)(pxih + 1);
            pxsh = (PXBEIMAGE_SECTION)((PUCHAR)pxcert +
				XBEIMAGE_CERTIFICATE_BASE_SIZEOF);

            //
            // Populate the base header
            //

            memset(pxih, 0, sizeof *pxih);
            pxih->Signature = XBEIMAGE_SIGNATURE;
            pxih->BaseAddress = (PVOID)XBEIMAGE_STANDARD_BASE_ADDRESS;
            pxih->SizeOfHeaders = cbXbeHeaders;
            pxih->SizeOfImage = cbXbeHeaders + CompressedSize;
            pxih->SizeOfImageHeader = sizeof *pxih;
            pxih->TimeDateStamp = time(NULL);
            pxih->Certificate = (PXBEIMAGE_CERTIFICATE)
                ((ULONG_PTR)pxcert - (ULONG_PTR)pxih +
                XBEIMAGE_STANDARD_BASE_ADDRESS);
            pxih->NumberOfSections = 1;
            pxih->SectionHeaders =  (PXBEIMAGE_SECTION)
                ((ULONG_PTR)pxsh - (ULONG_PTR)pxih +
                XBEIMAGE_STANDARD_BASE_ADDRESS);

            //
            // Populate the certificate
            //

            memset(pxcert, 0, sizeof *pxcert);
            pxcert->SizeOfCertificate = XBEIMAGE_CERTIFICATE_BASE_SIZEOF;
            pxcert->TimeDateStamp = pxih->TimeDateStamp;
            pxcert->TitleID = 0xfffe0000;
            pxcert->AllowedMediaTypes = XBEIMAGE_MEDIA_TYPE_DONGLE;

            //
            // Populate the section header
            //

            memset(pxsh, 0, sizeof *pxsh);
            pxsh->VirtualAddress = XBEIMAGE_STANDARD_BASE_ADDRESS +
                cbXbeHeaders;
            pxsh->VirtualSize = InputSize;
            pxsh->PointerToRawData = cbXbeHeaders;
            pxsh->SizeOfRawData = CompressedSize;

            //
            // Calculate digest of raw data (compressed code)
            //

            XCCalcDigest( (PBYTE)pxih + cbXbeHeaders,
                          pxsh->SizeOfRawData, pxsh->SectionDigest );

            break;

        default:
            pxcert = (PXBEIMAGE_CERTIFICATE)((PBYTE)pxih +
                (ULONG_PTR)pxih->Certificate - (ULONG_PTR)pxih->BaseAddress);
            pxsh = (PXBEIMAGE_SECTION)((PBYTE)pxih +
                (ULONG_PTR)pxih->SectionHeaders - (ULONG_PTR)pxih->BaseAddress);
            /* Make sure the header is big enough to contain the data we're
             * interested in.  If the file isn't big enough to contain ther
             * headers, we'll crash and error out */
            if(pxih->Signature != XBEIMAGE_SIGNATURE ||
                (PBYTE)pxcert < (PBYTE)pxih || (PBYTE)pxsh < (PBYTE)pxih ||
                ((PBYTE)pxcert + pxcert->SizeOfCertificate) -
				(PBYTE)pxih > (int)pxih->SizeOfHeaders ||
                (PBYTE)(pxsh + 1) - (PBYTE)pxih > (int)pxih->SizeOfHeaders)
            {
                error = ERROR_BAD_FORMAT;
                goto Error;
            }
        }

        Region = strtoul(argv[2], 0, 0);
        Version = strtoul( argv[1], 0, 0 );

        //
        // We only do the region/version stamping and signature computation if we
        // have a non-zero region/version.  Otherwise, we have to assume we're
        // just repackaging an already-signed (retail-signed) XBE
        //

        if(Region || Version) {

            //
            // Stamp the region
            //

            if(Region)
                pxcert->GameRegion = Region;

            //
            // Stamp the version
            //

            if(Version)
                pxcert->Version = Version;

            //
            // Sign the header
            //

            pbSign = pxih->EncryptedDigest + sizeof pxih->EncryptedDigest;
            XCCalcDigest(pbSign, (PBYTE)pxih + pxih->SizeOfHeaders - pbSign,
                HeaderDigest);
            XCSignDigest(HeaderDigest, ImgbPrivateKeyData, pxih->EncryptedDigest);
        }

        if(!pxcert->GameRegion || !pxcert->Version) {
            error = ERROR_INVALID_PARAMETER;
            goto Error;
        }

        //
        // And backfill the binary header
        //
        if(ftOutput == ftBin) {
            MappedHeader->bcdVersion = (USHORT)pxcert->Version;
            MappedHeader->dwCodeLength = sizeof xdcs + pxih->SizeOfImage;
        }

        //
        // Clean up
        //

        if ( !UnmapViewOfFile(MappedHeader)) {
Error:
            error = GetLastError();
            TranslateError( GetLastError() );
            __leave;
        }

        MappedHeader = NULL;
        error = ERROR_SUCCESS;

    } __finally {

        if ( InputBuffer ) {
            UnmapViewOfFile( InputBuffer );
        }

        if ( MappedHeader ) {
            UnmapViewOfFile( MappedHeader );
        }

        if ( InputFileMapped ) {
            CloseHandle( InputFileMapped );
        }

        if ( OutputFileMapped ) {
            CloseHandle( OutputFileMapped );
        }

        if ( InputFileHandle != INVALID_HANDLE_VALUE ) {
            CloseHandle( InputFileHandle );
        }

        if ( OutputFileHandle != INVALID_HANDLE_VALUE ) {
            CloseHandle( OutputFileHandle );
        }

        if ( error != ERROR_SUCCESS ) {
            DeleteFile( argv[4] );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\dongle\dvdlib\dvdlib.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dvdlib.cpp

Abstract:

    This module contains definition of procudures and data structures used
    by DVD playback library located in hardware key.

--*/

#if __cplusplus
extern "C" {
#endif

#include <xcrypt.h>

extern ULONG_PTR DvdAPIsBegin, DvdAPIsEnd;
extern ULONG_PTR DashAPIsBegin, DashAPIsEnd;

//
// Constants for LZX compression
//

#define LZX_WINDOW_SIZE     (128*1024)
#define LZX_CHUNK_SIZE      (32*1024)
#define LZX_WORKSPACE       (256*1024)

//
// This structure is the header for each compression block
//
typedef struct _LZXBOX_BLOCK
{
    USHORT  CompressedSize;
    USHORT  UncompressedSize;

} LZXBOX_BLOCK, *PLZXBOX_BLOCK;

#pragma pack(1)

typedef struct _IMPORT_API {

    UCHAR      __jmp;
    ULONG_PTR  Relative;
    UCHAR      __int3;

} IMPORT_API, *PIMPORT_API;

#if 0
typedef struct _DVDKEY_HEADER {

    XDCS_DVD_CODE_INFORMATION  xdcs;
    UCHAR   RawData[ ANYSIZE_ARRAY ];
} DVDKEY_HEADER, *PDVDKEY_HEADER;
#endif

#pragma pack()

typedef ULONG_PTR EXPORT_API;
typedef EXPORT_API *PEXPORT_API;

BOOL
WINAPI
DvdKeyInitialize(
    OUT PUCHAR DvdRegion,
    OUT PULONG ExtendedErrorInfo
    );

#if __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\dongle\dvdlib\dvdlib.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dvdlib.cpp

Abstract:

    This module contains wrapper routines used by Xbox Dashboard to access
    DVD playback library located in hardware key.

--*/

#include "dvdlibp.h"

#ifdef DEVKIT
#define ON_DISK_DONGLE
#endif

//
// Import the kernel's public key for dongle validation
//

extern "C" PBYTE XePublicKeyData;

//
// Base address of memory containing DVD-decoder binary
//

PVOID DvdCodeBaseAddress;

//
// Minimum version number of DVD key is 1.01
//

#define DVDKEY_MINIMUM_VERSION 0x0101

//
// The image name for ON_DISK_DONGLE build has to be full path since we will
// load the code off the harddisk if we couldn't find the dongle. In free build,
// however, the file name is just only the module name so that the debugger
// could load the symbol.
//

#if DBG
INITIALIZED_OBJECT_STRING( DvdLibFile, "\\Device\\Harddisk0\\Partition2\\dvdkeyd.bin" );
#else
INITIALIZED_OBJECT_STRING( DvdLibFile, "\\Device\\Harddisk0\\Partition2\\dvdkey.bin" );
#endif

NTSTATUS
DvdpSnapThunk(
    IN PVOID DllBase,
    IN PVOID ImageBase,
    IN PIMAGE_THUNK_DATA NameThunk,
    OUT PIMAGE_THUNK_DATA AddrThunk,
    IN PIMAGE_EXPORT_DIRECTORY ExportDirectory,
    IN ULONG ExportSize
    )
/*++

Routine Description:

    This function snaps a thunk using the specified Export Section data.
    If the section data does not support the thunk, then the thunk is
    partially snapped (Dll field is still non-null, but snap address is
    set).

Arguments:

    DllBase - Base of DLL being snapped to.

    ImageBase - Base of image that contains the thunks to snap.

    Thunk - On input, supplies the thunk to snap.  When successfully
        snapped, the function field is set to point to the address in
        the DLL, and the DLL field is set to NULL.

    ExportDirectory - Supplies the Export Section data from a DLL.

Return Value:

    STATUS_SUCCESS or STATUS_DRIVER_ENTRYPOINT_NOT_FOUND or
        STATUS_DRIVER_ORDINAL_NOT_FOUND

--*/
{
    BOOLEAN Ordinal;
    USHORT OrdinalNumber;
    PULONG Addr;
    NTSTATUS Status;

    Ordinal = (BOOLEAN)IMAGE_SNAP_BY_ORDINAL(NameThunk->u1.Ordinal);

    if ( !Ordinal ) {
        return STATUS_DRIVER_ORDINAL_NOT_FOUND;
    }

    OrdinalNumber = (USHORT)(IMAGE_ORDINAL(NameThunk->u1.Ordinal) -
                     ExportDirectory->Base);

    if ((ULONG)OrdinalNumber >= ExportDirectory->NumberOfFunctions) {
        Status = STATUS_DRIVER_ORDINAL_NOT_FOUND;
    } else {

        Addr = (PULONG)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfFunctions);
        *(PULONG_PTR)&AddrThunk->u1.Function = (ULONG_PTR)DllBase + Addr[OrdinalNumber];
        Status = STATUS_SUCCESS;

#if DBG
        if ( ((ULONG_PTR)AddrThunk->u1.Function > (ULONG_PTR)ExportDirectory) &&
             ((ULONG_PTR)AddrThunk->u1.Function < ((ULONG_PTR)ExportDirectory + ExportSize)) ) {
            ASSERTMSG( "LDR: forward is not allowed", TRUE );
        }
#endif

    }

    return Status;
}

NTSTATUS
DvdLoadSystemImage(
    IN PVOID ImageBuffer,
    IN PSTRING ImageFileName,
    OUT PVOID *EntryPoint OPTIONAL
    )
/*++

Routine Description:

    This routine fixes up and snap imports/exports thinks for the specified
    image.

Arguments:

    ImageBuffer - Buffer contains image to be loaded

    ImageFileName - Supplies the image name of the image to load.

    EntryPoint - Optional parameter to receive image's entry point

Return Value:

    Status of the load operation.

--*/
{
    NTSTATUS status;
    PCHAR BaseAddress;
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    ULONG ImportDescriptorSize;
    ULONG NumberOfImportDescriptors;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    ULONG ExportDirectorySize;
    PIMAGE_THUNK_DATA OriginalThunk;
    PIMAGE_THUNK_DATA Thunk;
    ULONG DebugDirectorySize;

    BaseAddress = (PCHAR)ImageBuffer;

    //
    // Relocate the image at its new base address.
    //

    __try {
        status = (NTSTATUS)LdrRelocateImage(BaseAddress, (PUCHAR)"SYSLDR",
            (ULONG)STATUS_SUCCESS, (ULONG)STATUS_CONFLICTING_ADDRESSES,
            (ULONG)STATUS_INVALID_IMAGE_FORMAT);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Bind to the images from the module's import table.
    //

    ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
        BaseAddress, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &ImportDescriptorSize);

    if (ImportDescriptor != NULL) {

        //
        // Count the number of images that we'll need to bind to.
        //

        NumberOfImportDescriptors = 0;

        while (ImportDescriptor->Name != 0 && ImportDescriptor->FirstThunk != 0) {
            NumberOfImportDescriptors++;
            ImportDescriptor++;
        }

        //
        // Only xboxkrnl.exe imports will be binded
        //

        if (NumberOfImportDescriptors != 1) {
            KdPrint(( "LDR: invalid number of import descriptor (%lu)\n",NumberOfImportDescriptors ));
            return STATUS_INVALID_IMAGE_PROTECT;
        }

        ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
            BaseAddress, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &ImportDescriptorSize);

        if (ImportDescriptor->Name != 0 && ImportDescriptor->FirstThunk != 0) {

            //
            // Build the file name to the module.  This path won't be accurate
            // for xboxkrnl.exe and hal.dll, but the above code that checks for
            // already loaded modules ignores the directory so it doesn't
            // matter.
            //

            if ( _stricmp("xboxkrnl.exe", BaseAddress + ImportDescriptor->Name) ) {
                KdPrint(( "LDR: invalid import module (%s)\n", BaseAddress + ImportDescriptor->Name ));
                return STATUS_INVALID_IMAGE_PROTECT;
            }

            //
            // Snap the import thunk to the export directory.
            //

            ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(
                PsNtosImageBase, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT,
                &ExportDirectorySize);

            if (ExportDirectory == NULL) {
                status = STATUS_DRIVER_ENTRYPOINT_NOT_FOUND;
                goto CleanupAndExit;
            }

            OriginalThunk = (PIMAGE_THUNK_DATA)(BaseAddress +
                ImportDescriptor->OriginalFirstThunk);
            Thunk = (PIMAGE_THUNK_DATA)(BaseAddress +
                ImportDescriptor->FirstThunk);

            while (OriginalThunk->u1.AddressOfData != 0) {

                status = DvdpSnapThunk(PsNtosImageBase, BaseAddress,
                    OriginalThunk, Thunk, ExportDirectory, ExportDirectorySize );

                if (!NT_SUCCESS(status)) {
                    KdPrint(("MiLoadSystemImage: %Z couldn't bind to export from %s\n",
                        &ImageFileName, BaseAddress + ImportDescriptor->Name));
                    goto CleanupAndExit;
                }

                OriginalThunk++;
                Thunk++;
            }
        }
    }

    if (ARGUMENT_PRESENT(EntryPoint)) {
        *EntryPoint = BaseAddress + \
            RtlImageNtHeader(BaseAddress)->OptionalHeader.AddressOfEntryPoint;
    }

    //
    // Notify the debugger of the newly loaded module.
    //

    if (RtlImageDirectoryEntryToData(BaseAddress, TRUE, IMAGE_DIRECTORY_ENTRY_DEBUG,
        &DebugDirectorySize) != NULL) {

#ifdef DEVKIT
        if (DmGetCurrentDmi() && DmGetCurrentDmi()->LoadedModuleList)
        {
            //
            // Insert loaded module into loaded module list
            //

            USHORT Length;
            PIMAGE_NT_HEADERS Hdr = RtlImageNtHeader(ImageBuffer);

            Length = ImageFileName->MaximumLength * sizeof(WCHAR);
            PLDR_DATA_TABLE_ENTRY Ldr = (PLDR_DATA_TABLE_ENTRY)\
                MmDbgAllocateMemory( sizeof(LDR_DATA_TABLE_ENTRY) + Length, PAGE_READWRITE );

            if ( Ldr ) {

                PWCHAR p;

                RtlZeroMemory( Ldr, sizeof(LDR_DATA_TABLE_ENTRY) );
                Ldr->DllBase = ImageBuffer;
                Ldr->SizeOfImage = Hdr->OptionalHeader.SizeOfImage;
                Ldr->CheckSum = Hdr->OptionalHeader.CheckSum;
                Ldr->LoadedImports = NULL;
                Ldr->LoadCount = 1;
                Ldr->Flags = LDRP_ENTRY_PROCESSED | LDRP_SYSTEM_MAPPED;
                Ldr->FullDllName.Buffer = (PWSTR)((ULONG_PTR)Ldr + sizeof(LDR_DATA_TABLE_ENTRY));
                Ldr->FullDllName.Length = 0;
                Ldr->FullDllName.MaximumLength = Length;
                RtlAnsiStringToUnicodeString( &Ldr->FullDllName, ImageFileName, FALSE );
                Ldr->BaseDllName = Ldr->FullDllName;

                ExInterlockedInsertTailList( DmGetCurrentDmi()->LoadedModuleList,
                    &Ldr->InLoadOrderLinks );

                p = wcsstr( Ldr->FullDllName.Buffer, L".bin" );
                if ( p ) {
                    wcsncpy( p, L".exe", 4 );
                }
            }

            DbgLoadImageSymbols(ImageFileName, BaseAddress, (ULONG_PTR)-1);
        }
#endif
    }

    //
    // The module is now successfully loaded.
    //

    status = STATUS_SUCCESS;

CleanupAndExit:

    return status;
}

MI_MEMORY
DIAMONDAPI
DvdpAlloc(
    ULONG NumberOfBytes
    )
{
    return LocalAlloc( LPTR, NumberOfBytes );
}

VOID
DIAMONDAPI
DvdpFree(
    MI_MEMORY pointer
    )
{
    LocalFree( pointer );
}

NTSTATUS
DvdpDecompress(
    IN ULONG FromAddress,
    IN ULONG ToAddress,
    IN ULONG CompressedSize,
    IN ULONG UncompressedSize
    )
/*++

Routine Description:

    This routine decompresses binary downloaded from XDCS into virtual memory
    area specified by ToAddress.  The adress has to be in lower 2GB under Xbox
    so that it can be executable.

Arguments:

    FromAddress - Address of compressed binary downloaded from XDCS

    ToAddress - Address to be decompressed, must be in lower 2GB

    UncompressedSize - Total size of uncompressed image

Return Value:

    NT status code

--*/
{
    LZXDECOMPRESS Decomp;
    PLZXBOX_BLOCK Block;
    ULONG Source;
    ULONG Dest;
    UINT SourceSize;
    UINT DestSize;
    UINT BytesDecompressed;
    LDI_CONTEXT_HANDLE Handle;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    ASSERT( (ToAddress + UncompressedSize) <= 0x7FFE0000 );

    //
    // Initialize decompression engine
    //

    Decomp.fCPUtype = LDI_CPU_80386;
    Decomp.WindowSize = LZX_WINDOW_SIZE;

    SourceSize = LZX_CHUNK_SIZE;
    if ( LDICreateDecompression(&SourceSize, &Decomp, DvdpAlloc, DvdpFree, &DestSize,
        &Handle, NULL,NULL,NULL,NULL,NULL) != MDI_ERROR_NO_ERROR ) {
        return STATUS_NO_MEMORY;
    }

    Source = FromAddress;
    Dest = ToAddress;

    while(CompressedSize) {

        //
        // Read the compression block
        //
        Block = (PLZXBOX_BLOCK)Source;
        Source += sizeof(LZXBOX_BLOCK);
        CompressedSize -= sizeof Block;

        //
        // Perform decompression
        //
        if (Block->CompressedSize > CompressedSize)
            goto CleanupAndExit;
        CompressedSize -= Block->CompressedSize;
        BytesDecompressed = Block->UncompressedSize;
        if (Dest + BytesDecompressed > ToAddress + UncompressedSize)
            goto CleanupAndExit;
        if ( LDIDecompress(Handle, (PVOID)Source, Block->CompressedSize, (PVOID)Dest,
            &BytesDecompressed) != MDI_ERROR_NO_ERROR ) {
            goto CleanupAndExit;
        }

        //
        // Advance the pointers
        //
        Source += Block->CompressedSize;
        Dest += Block->UncompressedSize;

    }

    if(0 == CompressedSize && ToAddress + UncompressedSize == Dest)
        Status = STATUS_SUCCESS;

CleanupAndExit:

    LDIDestroyDecompression( Handle );
    return Status;
}

VOID
XCCalcDigest(
    IN  PBYTE  pbMsgData,
    IN  DWORD  dwMsgDataLen,
    OUT PBYTE  pbDigest
    )
/*++

Routine Description:

    This function calculates a digest (hash) for the given daata

Arguments:

    pbMsgData - Pointer to data to be calculated

    dwMsgDataLen - Length of data in bytes

    pbDigest - Output buffer of digest

Return Value:

    None

--*/
{
    UCHAR SHAHash[XC_SERVICE_SHA_CONTEXT_SIZE];
    BYTE abSHADigest[ XC_DIGEST_LEN ];

    XcSHAInit( SHAHash );

    XcSHAUpdate( SHAHash, (PBYTE)&dwMsgDataLen, sizeof(DWORD) );
    XcSHAUpdate( SHAHash, pbMsgData, dwMsgDataLen );

    XcSHAFinal( SHAHash, abSHADigest );

    memcpy( pbDigest, abSHADigest, XC_DIGEST_LEN );
}

NTSTATUS
DvdpVerifyHeaderDigest(
    IN PXBEIMAGE_HEADER ImageHeader
    )
{
    PBYTE pbToSign;
    ULONG cbToSign;
    BYTE rgbDigest[XC_DIGEST_LEN];
    NTSTATUS st;

    pbToSign = ImageHeader->EncryptedDigest +
        sizeof ImageHeader->EncryptedDigest;
    cbToSign = (PBYTE)ImageHeader + ImageHeader->SizeOfHeaders - pbToSign;

    // Calculate the header digest
    XCCalcDigest(pbToSign, cbToSign, rgbDigest);

    // Verify it
    st = XcVerifyPKCS1Signature(ImageHeader->EncryptedDigest, XePublicKeyData,
        rgbDigest) ? STATUS_SUCCESS : STATUS_TRUST_FAILURE;
    return st;
}

BOOL
NTAPI
DvdKeyInitialize(
    OUT PUCHAR DvdRegion,
    OUT PULONG ExtendedErrorInfo
    )
/*++

Routine Description:

    This is the first routine XDash supposed to call before trying to access
    other DVD-playback functions.  It will load and initialize DVD playback
    library from hardware key, perform necessary uncompress, fix up exports
    and imports thunks, security checking, and finally call real DDP_Intialize
    to initialize DVD-playback engine.

Arguments:

    DvdRegion - Pointer to a byte to receive a DVD region of the DVD key

    ExtendedErrorInfo - Pointer to unsigned long to receive extended error
        information about DVD playback error

Return Value:

    Generic Win32 error code

--*/
{
    NTSTATUS Status;
    STRING ImageName;
    PCHAR BackSlashPtr;
    XDCS_DVD_CODE_INFORMATION *DvdKey;
    PXBEIMAGE_HEADER pxih;
    PXBEIMAGE_CERTIFICATE pxcert;
    PXBEIMAGE_SECTION pxsh;
    DWORD DeviceInstance = 0;
    HANDLE FileHandle = NULL;
    BOOL fDongleInserted = FALSE;
    PUCHAR CompressedBuffer = NULL;
    SIZE_T CompressedBufferSize;
    SIZE_T UncompressedBufferSize;
    PBYTE RawData;
    DWORD error, DonglePort, BytesRead;
    XDCS_DVD_CODE_INFORMATION DvdCodeInfo = { 0, 0 };
    NTSTATUS (__cdecl *EntryPoint)( PVOID, PVOID, PVOID, PVOID );
    BYTE HeaderDigest[XC_DIGEST_LEN];

#ifdef ON_DISK_DONGLE
    OBJECT_ATTRIBUTES ObjA;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
#endif

    __try {

        *ExtendedErrorInfo = 0;

        //
        // Look for the DVD dongle starting from left to right
        //

        DWORD dwDevices = XGetDevices( XDEVICE_TYPE_DVD_CODE_SERVER );

        for ( DonglePort=0; DonglePort<4; DonglePort++ ) {
            if ( dwDevices & (1 << DonglePort) ) {
                error = XDCSGetInformation( DonglePort, &DeviceInstance, &DvdCodeInfo );
                if ( error != ERROR_SUCCESS ) {
                    KdPrint(( "DVD: unable to read from the dongle on port %d, skipping\n", DonglePort ));
                    continue;
                }

                KdPrint(( "DVD: found dongle on port %d version %x.%x compressed code size = %d\n",
                          DonglePort, DvdCodeInfo.bcdVersion >> 8, DvdCodeInfo.bcdVersion & 0xFF,
                          DvdCodeInfo.dwCodeLength ));
                fDongleInserted = TRUE;
                break;
            }
        }

        if ( !fDongleInserted ) {
#ifdef ON_DISK_DONGLE
            //
            // We also load the code off the harddisk in ON_DISK_DONGLE build
            //

            KdPrint(( "DVD: unable to find DVD dongle, looking for one from harddisk\n" ));

TryHarddisk:

            InitializeObjectAttributes( &ObjA, &DvdLibFile, OBJ_CASE_INSENSITIVE, 0, 0 );

            Status = NtOpenFile( &FileHandle, GENERIC_READ, &ObjA, &IoStatusBlock,
                                 0, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE );

            if ( !NT_SUCCESS(Status) ) {
                KdPrint(( "DVD: unable to find %Z (%x)\n", &DvdLibFile, Status ));
                __leave;
            }

            Status = NtQueryInformationFile( FileHandle, &IoStatusBlock,
                                             &NetworkInfo, sizeof(NetworkInfo),
                                             FileNetworkOpenInformation );

            if ( !NT_SUCCESS(Status) ) {
                __leave;
            }

            ASSERT( NetworkInfo.EndOfFile.HighPart == 0 );
            ASSERT( NetworkInfo.EndOfFile.LowPart != 0 );

            DvdCodeInfo.dwCodeLength = NetworkInfo.EndOfFile.LowPart;
#else
            Status = STATUS_DEVICE_NOT_CONNECTED;
            __leave;
#endif
        }

        //
        // Preparing buffer for downloading compressed image from XDCS
        //

        ASSERT( DvdCodeBaseAddress == NULL );

        CompressedBufferSize = DvdCodeInfo.dwCodeLength;
        CompressedBuffer = (PUCHAR)ExAllocatePoolWithTag( CompressedBufferSize, '_DVD' );

        if ( !CompressedBuffer ) {
            Status = STATUS_NO_MEMORY;
            __leave;
        }

#ifdef ON_DISK_DONGLE
        //
        // For ON_DISK_DONGLE build if we couldn't find the dongle, fall back to harddisk
        //

        if ( !fDongleInserted ) {

            Status = NtReadFile( FileHandle, 0, 0, 0, &IoStatusBlock,
                                 CompressedBuffer, CompressedBufferSize, 0 );

            if ( !NT_SUCCESS(Status) ) {
                KdPrint(( "DVD: NtReadFile failed with status = %x\n", Status ));
                __leave;
            }

            BytesRead = IoStatusBlock.Information;
            error = ERROR_SUCCESS;

        } else {
            error = XDCSDownloadCode( DeviceInstance, CompressedBuffer, 0, CompressedBufferSize, &BytesRead );
        }
#else
        error = XDCSDownloadCode( DeviceInstance, CompressedBuffer, 0, CompressedBufferSize, &BytesRead );
#endif

        if ( error != ERROR_SUCCESS ) {
            Status = STATUS_UNSUCCESSFUL;
            *ExtendedErrorInfo = error;
            __leave;
        }

        if ( BytesRead != CompressedBufferSize ) {
            Status = STATUS_INFO_LENGTH_MISMATCH;
            __leave;
        }

        DvdKey = (XDCS_DVD_CODE_INFORMATION *)CompressedBuffer;

        if ( (DvdKey->bcdVersion & 0xFF00) != (DVDKEY_MINIMUM_VERSION & 0xFF00) ||
            (DvdKey->bcdVersion & 0xFF) < (DVDKEY_MINIMUM_VERSION & 0xFF)) {
            DbgPrint( "DVD: the version of this dongle is too old or incompatible (%x.%x)\n",
                      DvdKey->bcdVersion >> 8, DvdKey->bcdVersion & 0xFF );
#ifdef ON_DISK_DONGLE
            if ( !fDongleInserted ) {
                __asm int 3;
            } else {
                KdPrint(( "DVD: trying the dongle on the harddisk...\n" ));
                fDongleInserted = FALSE;
                goto TryHarddisk;
            }
#endif
            Status = STATUS_REVISION_MISMATCH;
            __leave;
        }


        //
        // Locate and authenticate the XBE header
        //

        pxih = (PXBEIMAGE_HEADER)(DvdKey + 1);
        if (pxih->Signature != XBEIMAGE_SIGNATURE || pxih->SizeOfImageHeader <
            sizeof *pxih || pxih->SizeOfHeaders < pxih->SizeOfImageHeader ||
            pxih->SizeOfHeaders > pxih->SizeOfImage ||
            pxih->SizeOfImage > DvdKey->dwCodeLength)
        {
            DbgPrint("DVD: unrecognized dongle image format\n");
            Status = STATUS_INVALID_IMAGE_FORMAT;
            __leave;
        }
        if (pxih->SizeOfImage + sizeof *DvdKey != DvdKey->dwCodeLength) {
            DbgPrint("DVD: dongle image sizes don't match\n");
            Status = STATUS_INVALID_IMAGE_FORMAT;
            __leave;
        }
        Status = DvdpVerifyHeaderDigest(pxih);
        if (!NT_SUCCESS(Status)) {
            DbgPrint("DVD: invalid image header digest\n");
            Status = STATUS_TRUST_FAILURE;
            __leave;
        }

        //
        // Locate the additional header information and ensure that it got
        // signed
        //

        pxcert = (PXBEIMAGE_CERTIFICATE)((PBYTE)pxih +
            (ULONG_PTR)pxih->Certificate - (ULONG_PTR)pxih->BaseAddress);
        pxsh = (PXBEIMAGE_SECTION)((PBYTE)pxih +
            (ULONG_PTR)pxih->SectionHeaders - (ULONG_PTR)pxih->BaseAddress);
        if (pxcert->SizeOfCertificate < XBEIMAGE_CERTIFICATE_BASE_SIZEOF ||
            (PBYTE)pxcert < (PBYTE)pxih || (PBYTE)pxsh < (PBYTE)pxih ||
            ((PBYTE)pxcert + pxcert->SizeOfCertificate) -
            (PBYTE)pxih > (int)pxih->SizeOfHeaders ||
            (PBYTE)(pxsh + 1) - (PBYTE)pxih > (int)pxih->SizeOfHeaders)
        {
            DbgPrint("DVD: invalid header data\n");
            Status = STATUS_INVALID_IMAGE_FORMAT;
            __leave;
        }

        //
        // Authenticate certificate data.  Must be signed to run from dongle
        // only
        //

        if (pxcert->AllowedMediaTypes != XBEIMAGE_MEDIA_TYPE_DONGLE) {
            DbgPrint("DVD: invalid image certificate\n");
            Status = STATUS_IMAGE_MEDIA_TYPE_VIOLATION;
            __leave;
        }
        if (pxcert->Version != DvdKey->bcdVersion) {
            DbgPrint("DVD: version stamps don't match\n");
            Status = STATUS_REVISION_MISMATCH;
            __leave;
        }

        //
        // Authenticate section data
        //

        RawData = (PBYTE)pxih + pxsh->PointerToRawData;
        if (RawData + pxsh->SizeOfRawData != (PBYTE)pxih + pxih->SizeOfImage) {
            DbgPrint("DVD: section data is invalid size\n");
            Status = STATUS_INVALID_IMAGE_FORMAT;
            __leave;
        }
        XCCalcDigest(RawData, pxsh->SizeOfRawData, HeaderDigest);
        if (memcmp(HeaderDigest, pxsh->SectionDigest, XC_DIGEST_LEN) != 0) {
            DbgPrint("DVD: invalid section digest\n");
            Status = STATUS_TRUST_FAILURE;
            __leave;
        }

        UncompressedBufferSize = pxsh->VirtualSize;
        ASSERT( UncompressedBufferSize );

        KdPrint(( "DVD: region of this dongle is %d\n", pxcert->GameRegion));

        Status = NtAllocateVirtualMemory( &DvdCodeBaseAddress, 0, &UncompressedBufferSize,
                                          MEM_TOP_DOWN | MEM_COMMIT, PAGE_EXECUTE_READWRITE );

        if ( !NT_SUCCESS(Status) ) {
            KdPrint(( "DVD: memory allocation failed\n" ));
            __leave;
        }

        Status = DvdpDecompress( (ULONG_PTR)RawData, (ULONG_PTR)DvdCodeBaseAddress,
            pxsh->SizeOfRawData, pxsh->VirtualSize);

        if ( !NT_SUCCESS(Status) ) {
            KdPrint(( "DVD: decompression failed\n" ));
            __leave;
        }

        // Fill the remainder of the page with zeroes
        if(pxsh->VirtualSize < UncompressedBufferSize) {
            memset((PBYTE)DvdCodeBaseAddress + pxsh->VirtualSize, 0,
                UncompressedBufferSize  - pxsh->VirtualSize);
        }

        BackSlashPtr = strrchr( DvdLibFile.Buffer, '\\' );

        if ( !BackSlashPtr ) {
            BackSlashPtr = DvdLibFile.Buffer;
        } else {
            BackSlashPtr++;
        }

        //
        // Fixup and snap all the imports and exports thunks
        //

        RtlInitObjectString( &ImageName, BackSlashPtr );

        Status = DvdLoadSystemImage( DvdCodeBaseAddress, &ImageName,
                                     (PVOID*)&EntryPoint );

        if ( !NT_SUCCESS(Status) ) {
            __leave;
        }

        //
        // Call the entry point so that the CRT and DDP get initialized
        //

        ULONG Error = EntryPoint( &DashAPIsBegin, &DashAPIsEnd, &DvdAPIsBegin, &DvdAPIsEnd );

        if ( !IS_ERROR(Error) ) {
            *DvdRegion = (UCHAR)pxcert->GameRegion;
            ASSERT( *DvdRegion >= 1 && *DvdRegion <= 6 );
        } else {
            Status = STATUS_UNSUCCESSFUL;
            *ExtendedErrorInfo = Error;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
    }

    if ( FileHandle ) {
        NtClose(FileHandle);
    }

    if ( CompressedBuffer ) {
        ExFreePool( CompressedBuffer );
    }

    if ( !NT_SUCCESS(Status) && DvdCodeBaseAddress ) {
        UncompressedBufferSize = 0;
        NtFreeVirtualMemory( &DvdCodeBaseAddress, &UncompressedBufferSize, MEM_RELEASE );
    }

    if ( !NT_SUCCESS(Status) && *ExtendedErrorInfo == 0 ) {
        *ExtendedErrorInfo = RtlNtStatusToDosError( Status );
    }

    return NT_SUCCESS(Status);
}

#ifdef _FAKE_DSOUND

struct _FakeDSound {

    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) { return S_OK; };
    STDMETHOD_(ULONG, Release)(THIS) { return S_OK; };

    // XMediaObject methods
    STDMETHOD(GetInfo)(THIS_ LPXMEDIAINFO pInfo)
    {
        pInfo->dwFlags = XMO_STREAMF_WHOLE_SAMPLES | XMO_STREAMF_FIXED_SAMPLE_SIZE | XMO_STREAMF_INPUT_ASYNC;
        pInfo->dwMaxLookahead = 1;
        pInfo->dwInputSize = 1;
        pInfo->dwOutputSize = 1;
        return S_OK;
    };

    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus) { return S_OK; };

    STDMETHOD(Process)(THIS_ LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket)
    {
        if ( pInputPacket ) {
            if ( pInputPacket->hCompletionEvent ) {
                SetEvent( pInputPacket->hCompletionEvent );
            }
            if ( pInputPacket->pdwCompletedSize ) {
                *pInputPacket->pdwCompletedSize = pInputPacket->dwMaxSize;
            }
            if ( pInputPacket->pdwStatus ) {
                *pInputPacket->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;
            }
        }

        if ( pOutputPacket ) {
            if ( pOutputPacket->hCompletionEvent ) {
                SetEvent( pOutputPacket->hCompletionEvent );
            }
            if ( pOutputPacket->pdwCompletedSize ) {
                *pOutputPacket->pdwCompletedSize = pOutputPacket->dwMaxSize;
            }
            if ( pOutputPacket->pdwStatus ) {
                *pOutputPacket->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;
            }
        }

        return S_OK;
    };

    STDMETHOD(Discontinuity)(THIS) { return S_OK; };
    STDMETHOD(Flush)(THIS) { return S_OK; };

    // IDirectSoundStream methods
    STDMETHOD(SetFrequency)(THIS_ DWORD dwFrequency) { return S_OK; };
    STDMETHOD(SetVolume)(THIS_ LONG lVolume) { return S_OK; };
#ifdef SILVER
    STDMETHOD(SetChannelVolume)(THIS_ LPCDSCHANNELVOLUME pVolume) { return S_OK; };
#else
    STDMETHOD(SetPitch)(THIS_ LONG lPitch) { return S_OK; };
    STDMETHOD(SetLFO)(THIS_ LPCDSLFODESC pLFODesc) { return S_OK; };
    STDMETHOD(SetEG)(THIS_ LPCDSENVELOPEDESC pEnvelopeDesc) { return S_OK; };
    STDMETHOD(SetFilter)(THIS_ LPCDSFILTERDESC pFilterDesc) { return S_OK; };
    STDMETHOD(SetOutputBuffer)(THIS_ LPDIRECTSOUNDBUFFER pOutputBuffer) { return S_OK; };
    STDMETHOD(SetMixBins)(THIS_ DWORD dwMixBins) { return S_OK; };
    STDMETHOD(SetMixBinVolumes)(THIS_ DWORD dwMixBins, const LONG *alVolumes) { return S_OK; };
    STDMETHOD(SetHeadroom)(THIS_ DWORD dwHeadroom) { return S_OK; };
    STDMETHOD(Pause)(THIS_ DWORD dwPause) { return S_OK; };
#endif

    // IDirectSound3DBuffer methods
    STDMETHOD(SetAllParameters)(THIS_ LPCDS3DBUFFER pds3db, DWORD dwApply) { return S_OK; };
    STDMETHOD(SetConeAngles)(THIS_ DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply) { return S_OK; };
    STDMETHOD(SetConeOrientation)(THIS_ FLOAT x, FLOAT y, FLOAT z, DWORD dwApply) { return S_OK; };
    STDMETHOD(SetConeOutsideVolume)(THIS_ LONG lConeOutsideVolume, DWORD dwApply) { return S_OK; };
    STDMETHOD(SetMaxDistance)(THIS_ FLOAT flMaxDistance, DWORD dwApply) { return S_OK; };
    STDMETHOD(SetMinDistance)(THIS_ FLOAT flMinDistance, DWORD dwApply) { return S_OK; };
    STDMETHOD(SetMode)(THIS_ DWORD dwMode, DWORD dwApply) { return S_OK; };
    STDMETHOD(SetPosition)(THIS_ FLOAT x, FLOAT y, FLOAT z, DWORD dwApply) { return S_OK; };
    STDMETHOD(SetVelocity)(THIS_ FLOAT x, FLOAT y, FLOAT z, DWORD dwApply) { return S_OK; };

} _FakeDSound;

EXTERN_C
HRESULT
FakeDirectSoundCreateStream(
    LPCDSSTREAMDESC  pdssd,
    LPDIRECTSOUNDSTREAM * ppStream
    )
{
    *ppStream = (LPDIRECTSOUNDSTREAM)&_FakeDSound;
    return S_OK;
}

EXTERN_C
VOID
FakeDirectSoundDoWork(
    VOID
    )
{
}

#endif // _FAKE_DSOUND
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\dongle\dvdbld\dvdbldp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dvdbldp.h

Abstract:

    This module contains structure definitions and prototype of procedures
    required by dvdbld.

--*/

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <windows.h>

extern "C" {
#include <lci.h>
}

#include <xbox.h>
#include <xboxp.h>
#include <xcrypt.h>
#include <xbeimage.h>

#include "dvdlib.h"

#include <time.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\dongle\dvdlib\dvdlibp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dvdlibp.cpp

Abstract:

    This module contains definition of procudures and data structures used
    by DVD playback library located in hardware key.

--*/

#include <ntos.h>
#include <xtl.h>
#include <stddef.h>

extern "C" {
#include <ldi.h>
}

#include <dm.h>
#include <xboxp.h>
#include <xbeimage.h>

#include "dvdlib.h"

#ifndef EXTERN_C
#define EXTERN_C extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\dongle\i386\dvdtls.asm ===
page    ,132
    title       dvdtls - TLS support object
;***
;atlssup.asm - Thread Local Storage support object (defines [_]_tls_array)
;
;       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Defines the symbol [_]_tls_array which is the offset into the
;       TEB (thread environment block) of the thread local storage pointer.
;
;Revision History:
;       03-19-93  SKS   Initial version (from ChuckM)
;       03-22-93  SKS   One less leading underscore with new include file
;       10-06-94  SKS   Added header file comment
;
;*******************************************************************************

.xlist
%   .model small, C
.list

; This symbol is being defined in the C language model
; and will have an extra underscore character prepended.

                public  _tls_array
_tls_array      equ     04h       ; TIB.StackBase

                public  _except_list
_except_list    equ     0

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\dongle\wrapper\wrapper.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wrapper.cpp

Abstract:

    This module contains templates used to generate imports library for
    module in hardware key.

--*/

#define EXTERN_C extern "C"

typedef void *P;

#define ARGUMENT0
#define ARGUMENT1   P
#define ARGUMENT2   P, P
#define ARGUMENT3   P, P, P
#define ARGUMENT4   P, P, P, P
#define ARGUMENT5   P, P, P, P, P
#define ARGUMENT6   P, P, P, P, P, P
#define ARGUMENT7   P, P, P, P, P, P, P
#define ARGUMENT8   P, P, P, P, P, P, P, P
#define ARGUMENT9   P, P, P, P, P, P, P, P, P
#define ARGUMENT10  P, P, P, P, P, P, P, P, P, P

EXTERN_C void __stdcall dummy0(  ARGUMENT0  ) {}
EXTERN_C void __stdcall dummy1(  ARGUMENT1  ) {}
EXTERN_C void __stdcall dummy2(  ARGUMENT2  ) {}
EXTERN_C void __stdcall dummy3(  ARGUMENT3  ) {}
EXTERN_C void __stdcall dummy4(  ARGUMENT4  ) {}
EXTERN_C void __stdcall dummy5(  ARGUMENT5  ) {}
EXTERN_C void __stdcall dummy6(  ARGUMENT6  ) {}
EXTERN_C void __stdcall dummy7(  ARGUMENT7  ) {}
EXTERN_C void __stdcall dummy8(  ARGUMENT8  ) {}
EXTERN_C void __stdcall dummy9(  ARGUMENT9  ) {}
EXTERN_C void __stdcall dummy10( ARGUMENT10 ) {}

EXTERN_C void __cdecl   cdummy() {}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\dongle\rom\dvdkey.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dvdkey.cpp

Abstract:

    This module contains DVD playback libraries for the Xbox Dashboard.
    The code is actually located in hardware key.

--*/

#include "dvdkeyp.h"

#if __cplusplus
extern "C" {
#endif

void _cinit ( void );
void _rtinit( void );

//
// Hack for new DVD code drop, this will be removed once we have new
// AvSendTVEncoderOption that doesn't require GPU address
//

volatile ULONG *D3D__GpuReg = NULL;

#if __cplusplus
}
#endif

ULONG NTAPI DDP_Initialize( void );

__declspec( naked )
NTSTATUS
__cdecl
mainCRTStartup(
    IN ULONG_PTR DashBegin,
    IN ULONG_PTR DashEnd,
    IN ULONG_PTR DvdBegin,
    IN ULONG_PTR DvdEnd
    )
/*++

Routine Description:

    This is a absolute entry point of the program. We need to define it here
    instead of using the version in XTL because we can't use XTL.  The code
    has to be written so that it contains the pattern at specific offset that
    imagebld looking for

Arguments:

    None

Return Value:

    Always TRUE

--*/
{
    SIZE_T Count;
    PEXPORT_API ExportPfn;
    PIMPORT_API ImportPfn;
    SIZE_T NumberOfDashAPIs;
    SIZE_T NumberOfDvdAPIs;
    SIZE_T NumberOfActualDashAPIs;
    SIZE_T NumberOfActualDvdAPIs;
    NTSTATUS Status;

    Status = STATUS_UNSUCCESSFUL;

    //
    // Use naked function and in-line assembly so that it contains particular
    // pattern at particular offset that imagebld is looking for
    //

    __asm {
        push    ebp
        mov     ebp, esp
        push    ecx
        xchg    ecx, ecx
        xchg    ecx, ecx
        xchg    ecx, ecx
        xchg    ecx, ecx
        nop
        mov     dword ptr [ebp-4], 0x0ff00110
        push    esi
        push    edi
        push    ebx
    }

    //
    // Calculate numbers of requested and actual thunks
    //

    NumberOfDashAPIs = (DashEnd-DashBegin) / sizeof(EXPORT_API);
    NumberOfDvdAPIs  = (DvdEnd-DvdBegin) / sizeof(IMPORT_API);

    NumberOfActualDashAPIs = ((ULONG_PTR)&DashAPIsEnd - (ULONG_PTR)&DashAPIsBegin) / sizeof(IMPORT_API);
    NumberOfActualDvdAPIs  = ((ULONG_PTR)&DvdAPIsEnd - (ULONG_PTR)&DvdAPIsBegin) / sizeof(EXPORT_API);

    if ( NumberOfDashAPIs != NumberOfActualDashAPIs) {
        KdPrint(( "DVD: invalid numbers of XDash APIs (expected %u, not %u)\n",
                  NumberOfActualDashAPIs, NumberOfDashAPIs ));
        Status = STATUS_INFO_LENGTH_MISMATCH;
        goto cleanup;
    }

    if ( NumberOfDvdAPIs != NumberOfActualDvdAPIs) {
        KdPrint(( "DVD: invalid numbers of DVD APIs (expected %u, not %u)\n",
                  NumberOfActualDvdAPIs, NumberOfDvdAPIs ));
        Status = STATUS_INFO_LENGTH_MISMATCH;
        goto cleanup;
    }

    //
    // Snap our import thunks to XDash export thunks
    //

    ImportPfn = (PIMPORT_API)&DashAPIsBegin;
    ExportPfn = (PEXPORT_API)DashBegin;

    for ( Count=0; Count<NumberOfActualDashAPIs; Count++ ) {
        ASSERT( ImportPfn->__jmp == 0xE9 );
        ASSERT( ImportPfn->__int3 == 0xCC );
        ImportPfn->Relative = *ExportPfn - (ULONG_PTR)&ImportPfn->__int3;
        ImportPfn++;
        ExportPfn++;
    }

    //
    // Snap XDash import thunks to our export thunks
    //

    ImportPfn = (PIMPORT_API)DvdBegin;
    ExportPfn = (PEXPORT_API)&DvdAPIsBegin;

    for ( Count=0; Count<NumberOfActualDvdAPIs; Count++ ) {
        ASSERT( ImportPfn->__jmp == 0xE9 );
        ASSERT( ImportPfn->__int3 == 0xCC );
        ImportPfn->Relative = *ExportPfn - (ULONG_PTR)&ImportPfn->__int3;
        ImportPfn++;
        ExportPfn++;
    }

    //
    // Self-modified code needs to flush cache and execute serialize instruction
    // See "Intel Software Developer's Manual" Volume 3, Chapter 7 for more
    // Information.
    //

    __asm {
        wbinvd
        push    ebx
        xor     eax, eax
        cpuid
        pop     ebx
    }

    //
    // Initialize C run-time library
    //

    _rtinit();
    _cinit();

    Status = DDP_Initialize();

cleanup:

    __asm {
        pop     ebx
        pop     edi
        pop     esi
        mov     eax, Status
        leave
        ret     0
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\dongle\rom\crt.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    crt.c

Abstract:

    This module contains minimum C runtime library startup for Ravisent's
    DVD playback library.

--*/

#include "dvdkeyp.h"

#if 0

ULONG _tls_index = 0;

//
// Special symbols to mark start and end of Thread Local Storage area.
//

#pragma data_seg(".tls")

char _tls_start = 0;

#pragma data_seg(".tls$ZZZ")

char _tls_end = 0;

//
// Start and end sections for Thread Local Storage CallBack Array.
// Actual array is constructed using .CRT$XLA, .CRT$XLC, .CRT$XLL,
// .CRT$XLU, .CRT$XLZ similar to the way global static initializers
// are done for C++.
//

#pragma data_seg(".CRT$XLA")

PIMAGE_TLS_CALLBACK __xl_a = 0;

#pragma data_seg(".CRT$XLZ")

PIMAGE_TLS_CALLBACK __xl_z = 0;

#pragma data_seg(".rdata$T")

#ifndef IMAGE_SCN_SCALE_INDEX
#define IMAGE_SCN_SCALE_INDEX   0x00000001  // Tls index is scaled
#endif

const IMAGE_TLS_DIRECTORY _tls_used =
{
    (ULONG)(ULONG_PTR)&_tls_start,  // start of tls data
    (ULONG)(ULONG_PTR)&_tls_end,    // end of tls data
    (ULONG)(ULONG_PTR)&_tls_index,  // address of tls_index
    (ULONG)(ULONG_PTR)&__xl_a,      // pointer to call back array
    (ULONG)0,                       // size of tls zero fill
    (ULONG)0                        // characteristics
};

#endif // 0

typedef void (__cdecl *PFV)(void);

#pragma data_seg(".CRT$XCA")
PFV __xc_a[] = { NULL };

#pragma data_seg(".CRT$XCZ")
PFV __xc_z[] = { NULL };

#pragma data_seg(".CRT$XIA")
PFV __xi_a[] = { NULL };

#pragma data_seg(".CRT$XIZ")
PFV __xi_z[] = { NULL };

#pragma data_seg(".CRT$RIA")
PFV __xri_a[] = { NULL };

#pragma data_seg(".CRT$RIZ")
PFV __xri_z[] = { NULL };

#if DBG
#pragma data_seg(".CRT$RII15")
extern void __cdecl _RTC_Initialize(void);
void *__rtc_init = _RTC_Initialize;
#endif

#pragma data_seg()

PFV _FPinit;

#pragma comment(linker, "/merge:.CRT=.data")

//
// This data is required for floating-point support
//

int _fltused = 0x9875;

void _initterm(PFV *a, PFV *z)
{
    for (; a < z; ++a)
        if(*a != NULL && *a != (PFV)-1)
            (**a)();
}

void _cinit(void)
{
    // Init floating point
    if (_FPinit) {
        (*_FPinit)();
    }

    // Do the initializers
    _initterm(__xi_a, __xi_z);

    // Now do the constructors
    _initterm(__xc_a, __xc_z);
}

void _rtinit(void)
{
    // Do the CRT initializers
    _initterm(__xri_a, __xri_z);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\Breakpoint.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Breakpoint Handling
//
////////////////////////////////////////////////////////////////////

#include "Breakpoint.h"
#include "library/common/vddebug.h"

#define DEBUG_TIME_BREAKPOINT 0

////////////////////////////////////////////////////////////////////
//
//  ERSBreakpointControl Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

ERSBreakpointControl::ERSBreakpointControl(EventDispatcher * eventDispatcher) : breakpoints()
	, EventSender(pEventDispatcher)
	{
	nextID = 0;
	}

//
//  Destructor
//

ERSBreakpointControl::~ERSBreakpointControl(void)
	{
	ClearBreakpoints();
	}

//
//  Set Breakpoint
//

Error ERSBreakpointControl::SetBreakpoint(WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id)
	{
	ERSBreakpoint * bp = new ERSBreakpoint(title, ptt, time, flags, nextID);

	breakpoints.Push(bp);
	id = nextID;
	nextID++;
	if (nextID == ERS_BREAKPOINT_NONE)
		nextID++;
	GNRAISE_OK;
	}

//
//  Get Breakpoint (ID is ERS_BREAKPOINT_NONE if there is none)
//

Error ERSBreakpointControl::GetBreakpoint(DWORD id, ERSBreakpoint & breakpoint)
	{
	ERSBreakpoint * bp = (ERSBreakpoint*)breakpoints.First();

	breakpoint.id = ERS_BREAKPOINT_NONE;

	while (bp != NULL)
		{
		if (bp->id == id && !BP_ABANDONED(bp))
			{
			breakpoint = *bp;
			GNRAISE_OK;
			}
		else
			bp = (ERSBreakpoint*)bp->Succ();
		}

	GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Get Next Breakpoint (ID is ERS_BREAKPOINT_NONE if there is none)
//  Note that this works only for breakpoints which do not have the ERS_ENDOFPTT flag set
//

Error ERSBreakpointControl::GetNextBreakpoint(WORD currentTitle, DVDTime currentTime, ERSPlaybackDir dir,
															 ERSBreakpoint & breakpoint)
	{
	ERSBreakpoint * bp = (ERSBreakpoint*)breakpoints.First();
	BOOL found = FALSE;

	breakpoint.id = ERS_BREAKPOINT_NONE;
	breakpoint.title = 0xffff;
	breakpoint.time = DVDTime(99, 59, 59, currentTime.FrameRate() - 1, currentTime.FrameRate());

	while (bp != NULL)
		{
		if (!BP_ABANDONED(bp))
			{
			if (BP_DIR_OK(dir, bp->flags) && (bp->title > currentTitle || (bp->title == currentTitle && (bp->time > currentTime || BP_EOT(bp->flags)))))
				{
				if (bp->title < breakpoint.title || (bp->title == breakpoint.title && (bp->time < breakpoint.time || BP_EOT(breakpoint.flags))))
					{
					breakpoint = *bp;
					found = TRUE;
					}
				}
			}
		bp = (ERSBreakpoint*)bp->Succ();
		}

	if (found)
		GNRAISE_OK;
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Get Previous Breakpoint (ID is ERS_BREAKPOINT_NONE if there is none)
//  Note that this works only for breakpoints which do not have the ERS_ENDOFPTT flag set
//

Error ERSBreakpointControl::GetPrevBreakpoint(WORD currentTitle, DVDTime currentTime, ERSPlaybackDir dir,
															 ERSBreakpoint & breakpoint)
	{
	ERSBreakpoint * bp = (ERSBreakpoint*)breakpoints.First();
	BOOL found = FALSE;

	breakpoint.id = ERS_BREAKPOINT_NONE;
	breakpoint.title = 0;
	breakpoint.time = DVDTime(0, 0, 0, 0, currentTime.FrameRate());

	while (bp != NULL)
		{
		if (!BP_ABANDONED(bp))
			{
			if (BP_DIR_OK(dir, bp->flags) && (bp->title < currentTitle || (bp->title == currentTitle && bp->time < currentTime && !BP_EOT(bp->flags))))
				{
//				DP("Comparing %d-%02d:%02d:%02d and %d-%02d:%02d:%02d", bp->title, bp->time.Minutes(), bp->time.Seconds(), bp->time.Frames(), breakpoint.title, breakpoint.time.Minutes(), breakpoint.time.Seconds(), breakpoint.time.Frames());
				if (bp->title > breakpoint.title || (bp->title == breakpoint.title && (bp->time > breakpoint.time || BP_EOT(bp->flags))))
					{
					breakpoint = *bp;
					found = TRUE;
					}
				}
			}
		bp = (ERSBreakpoint*)bp->Succ();
		}

	if (found)
		GNRAISE_OK;
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Execute Breakpoint
//

Error ERSBreakpointControl::ExecuteBreakpoint(DWORD id)
	{
	ERSBreakpoint * bp = (ERSBreakpoint*)breakpoints.First();

	while (bp != NULL)
		{
		if (bp->id == id)
			{
#if DEBUG_TIME_BREAKPOINT
			DP("Executing breakpoint # %d", id);
#endif
			if (BP_TOSTILL(bp->flags))
				StartBreakpointStillCallback();
			SetBreakpointActive(bp, FALSE);
			SendEvent(DNE_BREAKPOINT_REACHED, id);
			if (BP_CLEAR(bp->flags) || BP_ABANDONED(bp))
				ClearBreakpoint(id);
			GNRAISE_OK;
			}
		else
			bp = (ERSBreakpoint*)bp->Succ();
		}

	GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Clear Breakpoint
//

Error ERSBreakpointControl::ClearBreakpoint(DWORD id)
	{
	ERSBreakpoint * bp = (ERSBreakpoint*)breakpoints.First();

	while (bp != NULL)
		{
		if (bp->id == id)
			{
			if (BP_UPCOMING(bp))
				{
				DPF("Abandoned ....\n");
				bp->state = EBS_ABANDONED;
				}
			else
				{
				SetBreakpointActive(bp->id, FALSE);
				breakpoints.Remove((ERSBreakpoint*)bp);
				delete bp;
				}
			GNRAISE_OK;
			}
		bp = (ERSBreakpoint*)bp->Succ();
		}

	GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Clear all breakpoints
//

Error ERSBreakpointControl::ClearBreakpoints(void)
	{
	ERSBreakpoint * bp;
	int i;
	int n = breakpoints.Num();

	for (i=0; i<n; i++)
		{
		bp = (ERSBreakpoint*)breakpoints.Pop();
		delete bp;
		}

	GNRAISE_OK;
	}

//
//  Test if breakpoint has been reached and return it if so (else ID is ERS_BREAKPOINT_NONE)
//

BOOL ERSBreakpointControl::BreakpointReached(WORD title, DVDTime lowerLimit, DVDTime upperLimit, ERSPlaybackDir dir, ERSBreakpoint & breakpoint)
	{
	ERSBreakpoint * bp = (ERSBreakpoint*)breakpoints.First();
	BOOL found = FALSE;

//	DPF("Checking between %d-%02d:%02d:%02d:%02d (%02d) and %d-%02d:%02d:%02d:%02d (%02d)\n", title, lowerLimit.Hours(), lowerLimit.Minutes(), lowerLimit.Seconds(), lowerLimit.Frames(), lowerLimit.FrameRate(), title, upperLimit.Hours(), upperLimit.Minutes(), upperLimit.Seconds(), upperLimit.Frames(), upperLimit.FrameRate());
	breakpoint.id = ERS_BREAKPOINT_NONE;
	while (bp != NULL)
		{
//		DPF("Checking BP %d (%02d-%02d:%02d:%02d:%02d (%02d))\n", bp->id, bp->title, bp->time.Hours(), bp->time.Minutes(), bp->time.Seconds(), bp->time.Frames(), bp->time.FrameRate());
//		if (!BP_ABANDONED(bp))
			{
			if (BP_ATTIME(bp->flags) && lowerLimit <= bp->time && upperLimit >= bp->time && title == bp->title &&
				 BP_DIR_OK(dir, bp->flags))
				{
				//
				//  Breakpoint found
				//

				if (BP_ACTIVE(bp))
					{
					breakpoint = *bp;
					found = TRUE;
					}
				else
					DP("Not active");
				}
			else
				{
				SetBreakpointActive(bp, TRUE);
				}
			}

		bp = (ERSBreakpoint*)bp->Succ();
		}

	return found;
	}

//
//  Test if a breakpoint is contained inside an interval (else ID is ERS_BREAKPOINT_NONE)
//  This function does not activate breakpoints as BreakpointReached does. It finds either the first
//  or last breakpoint in the interval
//

BOOL ERSBreakpointControl::BreakpointContained(WORD title, DVDTime lowerLimit, DVDTime upperLimit, BOOL lowest,
															  ERSPlaybackDir dir, ERSBreakpoint & breakpoint)
	{
	ERSBreakpoint * bp = (ERSBreakpoint*)breakpoints.First();
	BOOL found = FALSE;

//	DP("Contain Check between %d-%02d:%02d:%02d:%02d (%02d) and %d-%02d:%02d:%02d:%02d (%02d)", title, lowerLimit.Hours(), lowerLimit.Minutes(), lowerLimit.Seconds(), lowerLimit.Frames(), lowerLimit.FrameRate(), title, upperLimit.Hours(), upperLimit.Minutes(), upperLimit.Seconds(), upperLimit.Frames(), upperLimit.FrameRate());
	breakpoint.id = ERS_BREAKPOINT_NONE;
	while (bp != NULL)
		{
//		DP("Contain Check BP %d (%02d-%02d:%02d:%02d:%02d (%02d))", bp->id, bp->title, bp->time.Hours(), bp->time.Minutes(), bp->time.Seconds(), bp->time.Frames(), bp->time.FrameRate());
		if (!BP_ABANDONED(bp))
			{
			if (BP_ATTIME(bp->flags) && lowerLimit <= bp->time && upperLimit >= bp->time && title == bp->title &&
				 BP_DIR_OK(dir, bp->flags))
				{
				//
				//  Breakpoint found
				//

				if (BP_ACTIVE(bp))
					{
					if (!found || (lowest && bp->time < breakpoint.time) || (!lowest && bp->time > breakpoint.time))
						{
						breakpoint = *bp;
						found = TRUE;
						}
					}
				}
			}

		bp = (ERSBreakpoint*)bp->Succ();
		}

	return found;
	}

//
//  Test if end-of-title breakpoint has been reached and return it if so (else ID is ERS_BREAKPOINT_NONE)
//

BOOL ERSBreakpointControl::EndOfTitleBreakpointReached(WORD title, ERSPlaybackDir dir, ERSBreakpoint & breakpoint)
	{
	ERSBreakpoint * bp = (ERSBreakpoint*)breakpoints.First();
	BOOL found = FALSE;

	breakpoint.id = ERS_BREAKPOINT_NONE;
	while (bp != NULL)
		{
//		DP("Checking %d with %d %d:%d:%d:%d:%d", title, bp->title, bp->time.Hours(), bp->time.Minutes(), bp->time.Seconds(), bp->time.Frames(), bp->time.FrameRate());
		if (!BP_ABANDONED(bp) && BP_EOT(bp->flags) && title == bp->title && BP_DIR_OK(dir, bp->flags))
			{
			//
			//  Breakpoint found
			//

			if (BP_ACTIVE(bp))
				{
				breakpoint = *bp;
				found = TRUE;
				}
			}

		bp = (ERSBreakpoint*)bp->Succ();
		}

	return found;
	}

//
//  Test if end-of-part-of-title breakpoint was reached
//

BOOL ERSBreakpointControl::EndOfPTTBreakpointReached(WORD title, WORD ptt, ERSPlaybackDir dir, ERSBreakpoint & breakpoint)
	{
	ERSBreakpoint * bp = (ERSBreakpoint*)breakpoints.First();
	BOOL found = FALSE;

	breakpoint.id = ERS_BREAKPOINT_NONE;
	while (bp != NULL)
		{
		if (!BP_ABANDONED(bp) && BP_EOPTT(bp->flags) && title == bp->title && ptt == bp->ptt && BP_DIR_OK(dir, bp->flags))
			{
			if (BP_ACTIVE(bp))
				{
				breakpoint = *bp;
				found = TRUE;
				}
			}

		bp = (ERSBreakpoint*)bp->Succ();
		}

	return found;
	}

//
//  Check for Begin-Of-PTT breakpoint
//

BOOL ERSBreakpointControl::BeginOfPTTBreakpointReached(WORD title, WORD ptt, ERSPlaybackDir dir, ERSBreakpoint & breakpoint)
	{
	ERSBreakpoint * bp = (ERSBreakpoint*)breakpoints.First();
	BOOL found = FALSE;

	breakpoint.id = ERS_BREAKPOINT_NONE;
	while (bp != NULL)
		{
		if (!BP_ABANDONED(bp) && BP_BOPTT(bp->flags) && title == bp->title && ptt == bp->ptt && BP_DIR_OK(dir, bp->flags))
			{
			if (BP_ACTIVE(bp))
				{
				breakpoint = *bp;
				found = TRUE;
				}
			}

		bp = (ERSBreakpoint*)bp->Succ();
		}

	return found;
	}

//
//  Set breakpoint activation state (internal)
//

void ERSBreakpointControl::SetBreakpointActive(ERSBreakpoint * bp, BOOL active)
	{
	if (!BP_ABANDONED(bp))
		{
		bp->state = active ? EBS_ACTIVE : EBS_INACTIVE;
		SetBreakpointActiveCallback(*bp, active);
		}
	}

//
//  Set breakpoint activation state
//

Error ERSBreakpointControl::SetBreakpointActive(DWORD id, BOOL active)
	{
	ERSBreakpoint * bp = (ERSBreakpoint*)breakpoints.First();

	while (bp != NULL)
		{
		if (bp->id == id)
			{
			SetBreakpointActive(bp, active);
			GNRAISE_OK;
			}
		bp = (ERSBreakpoint*)bp->Succ();
		}

	GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Set breakpoint to upcoming
//

Error ERSBreakpointControl::SetBreakpointUpcoming(DWORD id)
	{
	ERSBreakpoint * bp = (ERSBreakpoint*)breakpoints.First();

	while (bp != NULL)
		{
		if (bp->id == id && !BP_ABANDONED(bp))
			{
			bp->state = EBS_UPCOMING;
			GNRAISE_OK;
			}
		bp = (ERSBreakpoint*)bp->Succ();
		}

	GNRAISE(GNR_OBJECT_NOT_FOUND);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\dongle\rom\makefile.inc ===
obj\i386\dvdkey$(D).xbe : obj\i386\dvdkey$(D).exe
    dvdbld 0x0101 1 obj\i386\dvdkey$(D).exe obj\i386\dvdkey$(D).xbe
!ifdef _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) obj\i386\dvdkey$(D).exe
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) obj\i386\dvdkey$(D).xbe
!endif

obj\i386\dvdkey1$(D).bin : obj\i386\dvdkey$(D).xbe
    dvdbld 0x0101 1 obj\i386\dvdkey$(D).xbe obj\i386\dvdkey1$(D).bin
!ifdef _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!endif

obj\i386\dvdkey2$(D).bin : obj\i386\dvdkey1$(D).bin
    dvdbld 0x0101 2 obj\i386\dvdkey1$(D).bin obj\i386\dvdkey2$(D).bin
!ifdef _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!endif

obj\i386\dvdkey3$(D).bin : obj\i386\dvdkey1$(D).bin
    dvdbld 0x0101 3 obj\i386\dvdkey1$(D).bin obj\i386\dvdkey3$(D).bin
!ifdef _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!endif

obj\i386\dvdkey4$(D).bin : obj\i386\dvdkey1$(D).bin
    dvdbld 0x0101 4 obj\i386\dvdkey1$(D).bin obj\i386\dvdkey4$(D).bin
!ifdef _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!endif

obj\i386\dvdkey5$(D).bin : obj\i386\dvdkey1$(D).bin
    dvdbld 0x0101 5 obj\i386\dvdkey1$(D).bin obj\i386\dvdkey5$(D).bin
!ifdef _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!endif

obj\i386\dvdkey6$(D).bin : obj\i386\dvdkey1$(D).bin
    dvdbld 0x0101 6 obj\i386\dvdkey1$(D).bin obj\i386\dvdkey6$(D).bin
!ifdef _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\dongle\i386\thunks.asm ===
title  "Thunks for DVDLIB"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved.
;
; Module Name:
;
;    thunks.asm
;
; Abstract:
;
;    This module contains thunks for DVD library used by Xbox Dashboard
;
;--

        .686p

DECLARE_IMPORT  macro Func,N
    ifb <N>
        public  Func
        Func    db 0E9h, 0, 0, 0, 0, 0CCh
    else
        public  Func&@&N
        Func&@&N db 0E9h, 0, 0, 0, 0, 0CCh
    endif
endm

DECLARE_EXPORT  macro Func,N
        public  pfn_&Func
    ifb <N>
        extrn   Func:near
        pfn_&Func dd offset Func
    else
        extrn   Func&@&N:near
        pfn_&Func dd offset Func&@&N
    endif
endm

DECLARE_DVD_API macro Func,N
    ifdef XDCS
        DECLARE_EXPORT Func,N
    else
        DECLARE_IMPORT Func,N
    endif
endm

DECLARE_DASH_API macro Func,N
    ifdef XDCS
        DECLARE_IMPORT Func,N
    else
        DECLARE_EXPORT Func,N
    endif
endm

DVDTHUNK segment dword public 'CODE'

        assume  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        public  _DvdAPIsBegin, _DvdAPIsEnd
        public  _DashAPIsBegin, _DashAPIsEnd

_DvdAPIsBegin   label   near

        DECLARE_DVD_API     _DDP_AbortAsyncRequest,4
        DECLARE_DVD_API     _DDP_AdvanceFrame,4
        DECLARE_DVD_API     _DDP_AdvanceFrameBy,8
        DECLARE_DVD_API     _DDP_AngleChange,8
        DECLARE_DVD_API     _DDP_AudioStreamChange,8
        DECLARE_DVD_API     _DDP_BackwardScan,8
        DECLARE_DVD_API     _DDP_ButtonActivate,4
        DECLARE_DVD_API     _DDP_ButtonSelectAndActivate,8
        DECLARE_DVD_API     _DDP_ButtonSelectAndActivateAt,12
        DECLARE_DVD_API     _DDP_ButtonSelectAt,12
        DECLARE_DVD_API     _DDP_CheckDrive,8
        DECLARE_DVD_API     _DDP_CheckDriveWithPath,8
        DECLARE_DVD_API     _DDP_CheckMenuAvail,8
        DECLARE_DVD_API     _DDP_ClearBreakpoint,8
        DECLARE_DVD_API     _DDP_ClosePlayer,4
        DECLARE_DVD_API     _DDP_Defrost,12
        DECLARE_DVD_API     _DDP_DefrostExt,16
        DECLARE_DVD_API     _DDP_DetachDrive,16
        DECLARE_DVD_API     _DDP_EjectDiskInDrive,4
        DECLARE_DVD_API     _DDP_ExtendedPlay,20
        DECLARE_DVD_API     _DDP_ForwardScan,8
        DECLARE_DVD_API     _DDP_Freeze,12
        DECLARE_DVD_API     _DDP_GetAudioStreamAttributes,12
        DECLARE_DVD_API     _DDP_GetAvailStreams,12
        DECLARE_DVD_API     _DDP_GetAVFileInfo,12
        DECLARE_DVD_API     _DDP_GetCurrentAngle,4
        DECLARE_DVD_API     _DDP_GetCurrentAudioStream,4
        DECLARE_DVD_API     _DDP_GetCurrentButtonState,16
        DECLARE_DVD_API     _DDP_GetCurrentDisplayMode,4
        DECLARE_DVD_API     _DDP_GetCurrentDuration,8
        DECLARE_DVD_API     _DDP_GetCurrentLocation,8
        DECLARE_DVD_API     _DDP_GetCurrentSubPictureStream,4
        DECLARE_DVD_API     _DDP_GetDiskInfoAsync,16
        DECLARE_DVD_API     _DDP_GetDiskRegionSettings,24
        DECLARE_DVD_API     _DDP_GetDiskType,4
        DECLARE_DVD_API     _DDP_GetDriveStatus,12
        DECLARE_DVD_API     _DDP_GetExtendedPlayerState,8
        DECLARE_DVD_API     _DDP_GetForbiddenUserOperations,4
        DECLARE_DVD_API     _DDP_GetFrozenInfo,12
        DECLARE_DVD_API     _DDP_GetNumberOfAngles,8
        DECLARE_DVD_API     _DDP_GetNumberOfPartOfTitle,8
        DECLARE_DVD_API     _DDP_GetNumberOfTitles,4
        DECLARE_DVD_API     _DDP_GetPlayerMode,4
        DECLARE_DVD_API     _DDP_GetRegionSettings,20
        DECLARE_DVD_API     _DDP_GetSubPictureStreamAttributes,12
        DECLARE_DVD_API     _DDP_GetTitleDuration,12
        DECLARE_DVD_API     _DDP_GetVolumeName,8
        DECLARE_DVD_API     _DDP_GoUp,4
        DECLARE_DVD_API     _DDP_InitialLanguageSelect,20
        DECLARE_DVD_API     _DDP_InquireCurrentBitRate,8
        DECLARE_DVD_API     _DDP_InstallEventHandler,16
        DECLARE_DVD_API     _DDP_IsButtonAt,12
        DECLARE_DVD_API     _DDP_IsCurrentSubPictureEnabled,4
        DECLARE_DVD_API     _DDP_LeftButtonSelect,4
        DECLARE_DVD_API     _DDP_LoadDiskInDrive,8
        DECLARE_DVD_API     _DDP_LowerButtonSelect,4
        DECLARE_DVD_API     _DDP_MenuCall,8
        DECLARE_DVD_API     _DDP_MenuLanguageSelect,8
        DECLARE_DVD_API     _DDP_NextPGSearch,4
        DECLARE_DVD_API     _DDP_OpenPlayer,12
        DECLARE_DVD_API     _DDP_OpenPlayerAsync,16
        DECLARE_DVD_API     _DDP_OpenPlayerExtended,20
        DECLARE_DVD_API     _DDP_OpenPlayerWithPath,12
        DECLARE_DVD_API     _DDP_ParentalCountrySelect,8
        DECLARE_DVD_API     _DDP_ParentalLevelSelect,8
        DECLARE_DVD_API     _DDP_PauseOff,4
        DECLARE_DVD_API     _DDP_PauseOn,4
        DECLARE_DVD_API     _DDP_PbcOff,4
        DECLARE_DVD_API     _DDP_PbcOn,4
        DECLARE_DVD_API     _DDP_PlayFile,12
        DECLARE_DVD_API     _DDP_PrevPGSearch,4
        DECLARE_DVD_API     _DDP_PTTPlay,12
        DECLARE_DVD_API     _DDP_PTTPlayForced,12
        DECLARE_DVD_API     _DDP_PTTSearch,8
        DECLARE_DVD_API     _DDP_PTTSearchForced,8
        DECLARE_DVD_API     _DDP_RemoveEventHandler,8
        DECLARE_DVD_API     _DDP_Resume,4
        DECLARE_DVD_API     _DDP_ReversePlayback,4
        DECLARE_DVD_API     _DDP_RightButtonSelect,4
        DECLARE_DVD_API     _DDP_SetAudioStreamSelectionPreferences,8
        DECLARE_DVD_API     _DDP_SetBreakpoint,20
        DECLARE_DVD_API     _DDP_SetBreakpointExt,24
        DECLARE_DVD_API     _DDP_SetDisplayMode,8
        DECLARE_DVD_API     _DDP_SetPlaybackSpeed,8
        DECLARE_DVD_API     _DDP_SetSystemRegion,12
        DECLARE_DVD_API     _DDP_StartPresentation,4
        DECLARE_DVD_API     _DDP_StartPresentationExt,8
        DECLARE_DVD_API     _DDP_StillOff,4
        DECLARE_DVD_API     _DDP_Stop,4
        DECLARE_DVD_API     _DDP_StopScan,4
        DECLARE_DVD_API     _DDP_SubPictureStreamChange,12
        DECLARE_DVD_API     _DDP_TimePlay,12
        DECLARE_DVD_API     _DDP_TimePlayForced,12
        DECLARE_DVD_API     _DDP_TimeSearch,8
        DECLARE_DVD_API     _DDP_TimeSearchForced,8
        DECLARE_DVD_API     _DDP_TitlePlay,8
        DECLARE_DVD_API     _DDP_TitlePlayForced,8
        DECLARE_DVD_API     _DDP_TopPGSearch,4
        DECLARE_DVD_API     _DDP_TrickPlay,4
        DECLARE_DVD_API     _DDP_UpperButtonSelect,4
        DECLARE_DVD_API     _VDR_ActivateUnits,4
        DECLARE_DVD_API     _VDR_AvailUnits,4
        DECLARE_DVD_API     _VDR_CheckRegionCodeValid,8
        DECLARE_DVD_API     _VDR_CloseDriver,4
        DECLARE_DVD_API     _VDR_CloseUnits,4
        DECLARE_DVD_API     _VDR_CompleteMPEGCommand,8
        DECLARE_DVD_API     _VDR_CompleteMPEGData,4
        DECLARE_DVD_API     _VDR_CompleteMPEGDataSplit,8
        DECLARE_DVD_API     _VDR_CompleteMPEGRefillMessage,4
        DECLARE_DVD_API     _VDR_ConfigureUnits,8
        DECLARE_DVD_API     _VDR_CurrentMPEGLocation,4
        DECLARE_DVD_API     _VDR_CurrentMPEGState,4
        DECLARE_DVD_API     _VDR_CurrentMPEGTransferLocation,4
        DECLARE_DVD_API     _VDR_DoAuthenticationCommand,16
        DECLARE_DVD_API     _VDR_DoMPEGCommand,12
        DECLARE_DVD_API     _VDR_EnablePIP,8
        DECLARE_DVD_API     _VDR_GrabFrame,24
        DECLARE_DVD_API     _VDR_InstallMessagePort,8
        DECLARE_DVD_API     _VDR_InstallMPEGWinHooks,20
        DECLARE_DVD_API     _VDR_LockUnits,4
        DECLARE_DVD_API     _VDR_MPEGCommandPending,8
        DECLARE_DVD_API     _VDR_OpenDriver,12
        DECLARE_DVD_API     _VDR_OpenSubUnits,12
        DECLARE_DVD_API     _VDR_OpenUnits,12
        DECLARE_DVD_API     _VDR_PassivateUnits,4
        DECLARE_DVD_API     _VDR_ReconfigureDriver,4
        DECLARE_DVD_API     _VDR_RemoveMessagePort,4
        DECLARE_DVD_API     _VDR_RemoveMPEGWinHooks,4
        DECLARE_DVD_API     _VDR_RestartMPEGDataSplit,8
        DECLARE_DVD_API     _VDR_SendMPEGCommand,16
        DECLARE_DVD_API     _VDR_SendMPEGData,12
        DECLARE_DVD_API     _VDR_SendMPEGDataMultiple,12
        DECLARE_DVD_API     _VDR_SendMPEGDataSplit,20
        DECLARE_DVD_API     _VDR_UnlockUnits,4
        DECLARE_DVD_API     _VDR_UpdatePIP,4


_DvdAPIsEnd     label   near

_DashAPIsBegin  label   near

        DECLARE_DASH_API    _Ac97CreateMediaObject,16
        DECLARE_DASH_API    _CloseHandle,4
        DECLARE_DASH_API    _CreateEventA,16
        DECLARE_DASH_API    _CreateFileA,28
        DECLARE_DASH_API    _CreateMutexA,12
        DECLARE_DASH_API    _CreateSemaphoreA,16
        DECLARE_DASH_API    _CreateThread,24
        DECLARE_DASH_API    _D3DDevice_BlockUntilVerticalBlank,0
        DECLARE_DASH_API    _D3DDevice_CreateImageSurface,16
        DECLARE_DASH_API    _D3DDevice_EnableCC,4
        DECLARE_DASH_API    _D3DDevice_EnableOverlay,4
        DECLARE_DASH_API    _D3DDevice_GetCCStatus,8
        DECLARE_DASH_API    _D3DDevice_GetDisplayFieldStatus,4
        DECLARE_DASH_API    _D3DDevice_GetRasterStatus,4
        DECLARE_DASH_API    _D3DDevice_SendCC,12
        DECLARE_DASH_API    _D3DDevice_UpdateOverlay,20
        DECLARE_DASH_API    _D3DResource_IsBusy,4
        DECLARE_DASH_API    _D3DResource_Release,4
        DECLARE_DASH_API    _D3DSurface_GetDesc,8
        DECLARE_DASH_API    _DeviceIoControl,32
        DECLARE_DASH_API    _GetCurrentThreadId,0
        DECLARE_DASH_API    _GetLastError,0
        DECLARE_DASH_API    _GetProcessHeap,0
        DECLARE_DASH_API    _GetThreadPriority,4
        DECLARE_DASH_API    _GetTickCount,0
        DECLARE_DASH_API    _HeapFree,12
        DECLARE_DASH_API    _OutputDebugStringA,4
        DECLARE_DASH_API    _QueryPerformanceCounter,4
        DECLARE_DASH_API    _QueryPerformanceFrequency,4
        DECLARE_DASH_API    _ReadFile,20
        DECLARE_DASH_API    _ReleaseMutex,4
        DECLARE_DASH_API    _ReleaseSemaphore,12
        DECLARE_DASH_API    _ResetEvent,4
        DECLARE_DASH_API    _ResumeThread,4
        DECLARE_DASH_API    _SetEvent,4
        DECLARE_DASH_API    _SetFilePointer,16
        DECLARE_DASH_API    _SetThreadPriority,8
        DECLARE_DASH_API    _Sleep,4
        DECLARE_DASH_API    _VirtualAlloc,16
        DECLARE_DASH_API    _VirtualFree,12
        DECLARE_DASH_API    _WaitForMultipleObjects,16
        DECLARE_DASH_API    _WaitForSingleObject,8
        DECLARE_DASH_API    _WriteFile,20
        DECLARE_DASH_API    _wsprintfA
        DECLARE_DASH_API    _wvsprintfA,12
        DECLARE_DASH_API    _XGetAudioFlags,0
        DECLARE_DASH_API    _XPhysicalAlloc,16
        DECLARE_DASH_API    _XPhysicalFree,4

        DECLARE_DASH_API    ___CxxFrameHandler
        DECLARE_DASH_API    __chkstk
        DECLARE_DASH_API    __CIacos
        DECLARE_DASH_API    __CIexp
        DECLARE_DASH_API    __CIpow
        DECLARE_DASH_API    __CxxThrowException,8
        DECLARE_DASH_API    __EH_prolog
        DECLARE_DASH_API    __ftol2
        DECLARE_DASH_API    __purecall
        DECLARE_DASH_API    _atexit
        DECLARE_DASH_API    _ceil
        DECLARE_DASH_API    _floor
        DECLARE_DASH_API    _free
        DECLARE_DASH_API    _malloc
        DECLARE_DASH_API    _memmove
        DECLARE_DASH_API    _sprintf
        DECLARE_DASH_API    _strncpy

        DECLARE_DASH_API    ??0exception@@QAE@ABV0@@Z           ; "public: __thiscall exception::exception(class exception const &)"
        DECLARE_DASH_API    ??0exception@@QAE@XZ                ; "public: __thiscall exception::exception(void)"
        DECLARE_DASH_API    ??1exception@@UAE@XZ                ; "public: virtual __thiscall exception::~exception(void)"
        DECLARE_DASH_API    ??3@YAXPAX@Z                        ; "void __cdecl operator delete(void *)"
        DECLARE_DASH_API    ??_L@YGXPAXIHP6EX0@Z1@Z             ; "void __stdcall `eh vector constructor iterator'(void *,unsigned int,int,void (__thiscall*)(void *),void (__thiscall*)(void *))"
        DECLARE_DASH_API    ??_M@YGXPAXIHP6EX0@Z@Z              ; "void __stdcall `eh vector destructor iterator'(void *,unsigned int,int,void (__thiscall*)(void *))"
        DECLARE_DASH_API    ??_U@YAPAXI@Z                       ; "void * __cdecl operator new[](unsigned int)"
        DECLARE_DASH_API    ??_V@YAXPAX@Z                       ; "void __cdecl operator delete[](void *)"
        DECLARE_DASH_API    ?_Xlen@_String_base@std@@QBEXXZ     ; "public: void __thiscall std::_String_base::_Xlen(void)const "
        DECLARE_DASH_API    ?_Xran@_String_base@std@@QBEXXZ     ; "public: void __thiscall std::_String_base::_Xran(void)const "

;
; BUGBUG: need to figure this out for RTTI
;

        DECLARE_DASH_API    ??_7type_info@@6B@                  ; "const type_info::`vftable'" ()

if DBG
        DECLARE_DASH_API    __CrtMemCheckpoint
        DECLARE_DASH_API    __CrtMemDumpAllObjectsSince
        DECLARE_DASH_API    __RTC_Initialize
endif

_DashAPIsEnd    label   near

DVDTHUNK ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\dongle\rom\dvdkeyp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dvdkeyp.cpp

Abstract:

    This module contains DVD playback libraries for the Xbox Dashboard.
    The code is actually located in hardware key.

--*/

#include <ntos.h>
#include <xtl.h>
#include <xboxp.h>
#include <xcrypt.h>

#include "dvdlib.h"

#ifndef IS_ERROR
#define IS_ERROR(Status) ((unsigned long)(Status) >> 31 == SEVERITY_ERROR)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\Breakpoint.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Breakpoint Handling
//
////////////////////////////////////////////////////////////////////

#ifndef BREAKPOINT_H
#define BREAKPOINT_H

#include "Library/General/Lists.h"
#include "DVDTime.h"
#include "EventSender.h"
#include "Library/Common/GNErrors.h"

////////////////////////////////////////////////////////////////////
//
//  Helper macros with boolean results
//
////////////////////////////////////////////////////////////////////

#define BP_ATTIME(flags)		(flags & ERS_ATTIME)
#define BP_EOT(flags)			(flags & ERS_ENDOFTITLE)
#define BP_EOPTT(flags)			(flags & ERS_ENDOFPTT)
#define BP_FORWARD(flags)		(flags & ERS_FORWARD)
#define BP_BACKWARD(flags)		(flags & ERS_BACKWARD)
#define BP_TOSTILL(flags)		(flags & ERS_TOSTILL)
#define BP_CLEAR(flags)			(flags & ERS_CLEAR)
#define BP_BOPTT(flags)			(flags & ERS_BEGINOFPTT)

#define BP_END(flags)			(flags & (ERS_ENDOFTITLE | ERS_ENDOFPTT))
#define BP_DIR_OK(dir, flags)	(dir & flags)

#define BP_VALID(bp)				((bp).id != ERS_BREAKPOINT_NONE && !BP_ABANDONED(&(bp)))
#define BP_ACTIVE(bp)			((bp)->state == EBS_ACTIVE || (bp)->state == EBS_UPCOMING)
#define BP_UPCOMING(bp)			((bp)->state == EBS_UPCOMING)
#define BP_ABANDONED(bp)		((bp)->state == EBS_ABANDONED)

enum ERSPlaybackDir
	{
	EPD_FORWARD		= ERS_FORWARD,
	EPD_BACKWARD	= ERS_BACKWARD,
	EPD_BOTH			= ERS_FORWARD| ERS_BACKWARD
	};

enum ERSBreakpointState
	{
	EBS_INACTIVE,		// Breakpoint will currently not trigger
	EBS_ACTIVE,			// Breakpoint will trigger
	EBS_UPCOMING,		// Breakpoint is between BreakpointReached() and ExecuteBreakpoint()
	EBS_ABANDONED		// Breakpoint was upcoming, but should be deleted. Will be deleted once it is executed
	};

//
//  Breakpoint Class
//

class ERSBreakpoint : public Node
	{
	public:
		DWORD		id;
		WORD		title;
		WORD		ptt;
		DVDTime	time;
		DWORD		flags;
		ERSBreakpointState state;

		ERSBreakpoint(WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD id) : Node(), title(title), ptt(ptt),
																						time(time), flags(flags), id(id), state(EBS_INACTIVE) {}
		ERSBreakpoint(void) : Node(), id(ERS_BREAKPOINT_NONE), title(0), ptt(0), time(DVDTime()), flags(ERS_NONE), state(EBS_INACTIVE) {}
		~ERSBreakpoint(void) {}

		ERSBreakpoint & operator= (const ERSBreakpoint & bp)
			{ id = bp.id; title = bp.title; ptt = bp.ptt, time = bp.time; flags = bp.flags; state = EBS_INACTIVE; return *this;}

		void Clear(void)
			{ id = ERS_BREAKPOINT_NONE; title = 0; ptt = 0; time = DVDTime(); flags = ERS_NONE; state = EBS_INACTIVE; }
	};

//
//  Breakpoint Control Class
//

class ERSBreakpointControl : virtual public EventSender
	{
	private:
		List	breakpoints;
		DWORD	nextID;

		void	SetBreakpointActive(ERSBreakpoint * bp, BOOL active);

	protected:
		//
		//  Callbacks which can be overloaded by derived classes
		//

		virtual	void	StartBreakpointStillCallback(void)									{}
		virtual	void	SetBreakpointActiveCallback(ERSBreakpoint bp, BOOL active)	{}

	public:
		ERSBreakpointControl(EventDispatcher* pEventDispatcher);
		~ERSBreakpointControl(void);

		virtual	Error	SetBreakpoint(WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id);
					Error	GetBreakpoint(DWORD id, ERSBreakpoint & bp);
					Error	GetNextBreakpoint(WORD currentTitle, DVDTime currentTime, ERSPlaybackDir dir, ERSBreakpoint & bp);
					Error	GetPrevBreakpoint(WORD currentTitle, DVDTime currentTime, ERSPlaybackDir dir, ERSBreakpoint & bp);
					Error	ExecuteBreakpoint(DWORD id);
					Error	SetBreakpointActive(DWORD id, BOOL active);
					Error SetBreakpointUpcoming(DWORD id);
		virtual	Error	ClearBreakpoint(DWORD id);
		virtual	Error	ClearBreakpoints(void);
					BOOL	BreakpointReached(WORD title, DVDTime lowerLimit, DVDTime upperLimit,
													ERSPlaybackDir dir, ERSBreakpoint & bp);
					BOOL	BreakpointContained(WORD title, DVDTime lowerLimit, DVDTime upperLimit, BOOL lowest,
													  ERSPlaybackDir dir, ERSBreakpoint & bp);
					BOOL	EndOfTitleBreakpointReached(WORD title, ERSPlaybackDir dir, ERSBreakpoint & bp);
					BOOL	EndOfPTTBreakpointReached(WORD title, WORD ptt, ERSPlaybackDir dir, ERSBreakpoint & bp);
					BOOL	BeginOfPTTBreakpointReached(WORD title, WORD ptt, ERSPlaybackDir dir, ERSBreakpoint & bp);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\CDDiskPlayer.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
//  CDDiskPlayer Class
//
//////////////////////////////////////////////////////////////////////

#ifndef CDDISKPLAYER_H
#define CDDISKPLAYER_H

#include "Library/Common/WinPorts.h"
#include "NavErrors.h"
#include "EventSender.h"
#include "Breakpoint.h"
#include "Library/Files/RootFile.h"
//#include "Boards/Generic/Vdgendrv.h"

#pragma warning(disable : 4250)

//
//  Defines
//

#define STILL_TIME_MSG		2001

//
//  Macros for Extended Player State access
//

#define EPS_REQUEST(x)	(appEPS->request & x)
#define EPS_MONITOR(x)	(appEPS->monitor & x)
#define EPS_CHANGED(x)	(appEPS->x != eps.x)

////////////////////////////////////////////////////////////////////
//
//  CDDiskPlayerClass
//
//  This is an abstract base class for all Disk Player Classes
//
////////////////////////////////////////////////////////////////////

class CDDiskPlayerClass : virtual public EventSender, virtual public ERSBreakpointControl
	{
	protected:
		ExtendedPlayerState eps;
		DVDDiskType diskType;
		EventDispatcher eventDispatcherInstance; //(one and only) EventDispatcher object that should be used by Disk Player Classes

		virtual Error InternalGetMode(DVDPlayerMode & mode) = 0;

		virtual Error IsPlayingForward(BOOL & forward) = 0;

		virtual Error DiskIsEncrypted(BOOL & enc);

	public:
				  CDDiskPlayerClass(void);

		virtual ~CDDiskPlayerClass(void);

		virtual Error Init(WinPortServer * server, GenericProfile * profile, DVDDiskType diskType, GenericFileSystem * gfs);

		virtual Error Cleanup(void);

		virtual Error GetDiskType(DVDDiskType & type);

		virtual Error GetMode(DVDPlayerMode & mode) = 0;

		virtual Error GetExtendedPlayerState(ExtendedPlayerState * eps);

		virtual Error StopStillPhase(void) = 0;

		virtual Error Exit(Error err = GNR_OK) = 0;

		virtual Error CallMenu(VTSMenuType menu) = 0;

		virtual Error PausePlayback(void) = 0;

		virtual Error ResumePlayback(void) = 0;

		virtual Error SetPlaybackControl(BOOL playbackControl);

		virtual Error AdvanceFrame(void) = 0;

		virtual Error AdvanceFrameBy(int n) = 0;

		virtual Error SetPlaybackSpeed(WORD speed) = 0;

		virtual Error GetPlaybackSpeed(WORD & speed) = 0;

		virtual Error GetAudioStreamAttributes(WORD stream, DVDAudioStreamFormat	& attributes) = 0;

		virtual Error GetSubPictureStreamAttributes(WORD stream, DVDSubPictureStreamFormat	& attributes) = 0;

		virtual Error StartPresentation(DWORD flags) = 0;

		virtual Error GetCurrentLocation(DVDLocation & location) = 0;

		virtual Error GetCurrentDuration(DVDLocation & location) = 0;

		virtual Error GetTitleDuration(WORD title, DVDTime & duration) = 0;

		virtual Error MenuAvail(VTSMenuType menu, BOOL & avail) = 0;

		virtual Error GetUOPs(DWORD & uops);

		virtual Error UOPPermitted(int uops, BOOL & permitted) = 0;

		virtual Error GetTitleSearchUOPs(WORD title, DWORD & uops);

		virtual Error TitleSearchUOPPermitted(WORD title, int uops, BOOL & permitted);

		virtual Error NumberOfTitles(WORD & num) = 0;

		virtual Error NumberOfPartOfTitle(WORD title, WORD & num) = 0;

		virtual Error GetAvailStreams(BYTE & audio, DWORD & subPicture) = 0;

		virtual Error GetCurrentAudioStream(WORD & stream) = 0;

		virtual Error GetCurrentSubPictureStream(WORD & stream) = 0;

		virtual Error IsCurrentSubPictureEnabled(BOOL & enabled) = 0;

		virtual Error GetNumberOfAngles(WORD title, WORD & num) = 0;

		virtual Error GetCurrentAngle(WORD & angle) = 0;

		virtual Error TitlePlay(WORD title, DWORD flags = DDPSPF_NONE) = 0;

		virtual Error PTTPlay(WORD title, WORD part) = 0;

		virtual Error TimePlay(WORD title, DVDTime time) = 0;

		virtual Error GoUpProgramChain(void) = 0;

		virtual Error TimeSearch(DVDTime time) = 0;

		virtual Error PTTSearch(WORD part) = 0;

		virtual Error GoPrevProgram(void) = 0;

		virtual Error GoTopProgram(void) = 0;

		virtual Error GoNextProgram(void) = 0;

		virtual Error ExtendedPlay(DWORD flags, WORD title, WORD ptt, DVDTime time) = 0;

		virtual Error StartForwardScan(WORD speed) = 0;

		virtual Error StartBackwardScan(WORD speed) = 0;

		virtual Error GetScanSpeed(WORD & speed) = 0;

		virtual Error StopScan(void) = 0;

		virtual Error StartReversePlayback(void) = 0;

		virtual Error StartTrickplay(void) = 0;

		virtual Error ResumeFromSystemSpace(void) = 0;

		virtual Error ButtonUp(void) = 0;

		virtual Error ButtonDown(void) = 0;

		virtual Error ButtonLeft(void) = 0;

		virtual Error ButtonRight(void) = 0;

		virtual Error ButtonSelectAt(WORD x, WORD y) = 0;

		virtual Error ButtonActivate(void) = 0;

		virtual Error ButtonSelectAndActivate(WORD button) = 0;

		virtual Error ButtonSelectAtAndActivate(WORD x, WORD y) = 0;

		virtual Error IsButtonAt(WORD x, WORD y, BOOL & isButton) = 0;

		virtual Error HasPositionalButtons(BOOL & hasButtons) = 0;

		virtual Error MenuLanguageSelect(WORD language) = 0;

		virtual Error GetMenuLanguage(WORD & lang) = 0;

		virtual Error AudioStreamChange(WORD stream) = 0;

		virtual Error SubPictureStreamChange(WORD stream, BOOL enable) = 0;

		virtual Error AngleChange(WORD angle) = 0;

		virtual Error ParentalLevelSelect(WORD level) = 0;

		virtual Error ParentalCountrySelect(WORD country) = 0;

		virtual Error GetCurrentDisplayMode(DisplayPresentationMode & mode) = 0;

		virtual Error SetDisplayMode(DisplayPresentationMode mode) = 0;

		virtual Error GetCurrentVideoStandard(VideoStandard & standard) = 0;

		virtual Error SelectInitialLanguage(WORD audioLanguage, WORD audioExtension, WORD subPictureLanguage, WORD subPictureExtension) = 0;

		virtual Error GetCurrentBitrate(DWORD & bitrate) = 0;

		virtual Error GetCurrentButtonState(WORD & minButton, WORD & numButtons, WORD & currentButton) = 0;

		virtual Error Freeze (DDPFreezeState * state, DWORD & length) = 0;

		virtual Error Defrost(DDPFreezeState * state, DWORD & length, DWORD flags) = 0;

//		virtual Error SetBreakpoint(WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id) = 0;

//		virtual Error ClearBreakpoint(DWORD id) = 0;

		virtual Error GetAVFileInfo(GenericFileSystemIterator *gfsi, AVFInfo *pInfo);

		virtual Error PlayFile(GenericFileSystemIterator *gfsi, DWORD flags);

		virtual Error SetAudioStreamSelectionPreferences(DWORD flags);

		virtual Error EPSPermitted(BOOL & permitted);

	};

#pragma warning(default : 4250)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDAudioStillVideo.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD Audio Still Video Module
//
////////////////////////////////////////////////////////////////////

#include "DVDAudioStillVideo.h"

////////////////////////////////////////////////////////////////////
//
//  DVD Video Object Set for Audio Still Video Set Class
//
////////////////////////////////////////////////////////////////////

DVDASVOBS::DVDASVOBS(DVDHeaderFile * headerFile, DVDDataFile * dataFile, const DVDPTLMAI & ptlmai)
	: DVDVOBS(dataFile, ptlmai)
	{
	this->headerFile = headerFile;
	}

DVDASVOBS::~DVDASVOBS(void)
	{

	}

Error DVDASVOBS::GetNumberOfStillVideosInUnit(int item, BYTE & num)
	{
	GNREASSERT(headerFile->ReadByte(96 + 8 * item, num, &rh));

	GNRAISE_OK;
	}

Error DVDASVOBS::GetStillVideoAttribute(int item, WORD & attrib)
	{
	return headerFile->ReadWord(24 + 2 * item, attrib, &rh);
	}

////////////////////////////////////////////////////////////////////
//
//  DVD Audio Still Video Set Class
//
////////////////////////////////////////////////////////////////////

DVDASVS::DVDASVS(void)
	{
	hfile = NULL;
	dfile = NULL;
	asVobs = NULL;
	}

DVDASVS::~DVDASVS(void)
	{
	if (asVobs)
		{
		delete asVobs;
		asVobs = NULL;
		}

	if (hfile)
		{
		hfile->Close();
		delete hfile;
		hfile = NULL;
		}

	if (dfile)
		{
		dfile->Close();
		delete dfile;
		dfile = NULL;
		}
	}

Error DVDASVS::Init(DVDFileSystem * dvdfs)
	{
	GenericDiskItem * gdi;

	this->dvdfs = dvdfs;
	if (IS_ERROR(dvdfs->OpenItem("audio_ts\\audio_sv.ifo", FAT_HEADER, gdi)))
		GNREASSERT(dvdfs->OpenItem("audio_ts\\audio_sv.inf", FAT_HEADER, gdi));

	hfile = (DVDHeaderFile*)gdi;

	GNRAISE_OK;
	}

Error DVDASVS::GetASVOBS(DVDASVOBS * & asVobs)
	{
	GenericDiskItem * gdi;

	if (!this->asVobs)
		{
		if (!IS_ERROR(dvdfs->OpenItem("audio_ts\\audio_sv.vob", FAT_NONE, gdi)))
			dfile = (DVDDataFile*)gdi;
		else
			dfile = NULL;

		this->asVobs = new DVDASVOBS(hfile, dfile, ptlmai);
		}

	asVobs = this->asVobs;

	GNRAISE_OK;
	}

Error DVDASVS::GetNumberOfASVU(WORD & num)
	{
	GNREASSERT(hfile->ReadWord(12, num, &rh));
	num = XTBFW(0, 7, num);

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\CDDiskPlayer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
//  CDDiskPlayerClass
//
//////////////////////////////////////////////////////////////////////

#include "CDDiskPlayer.h"
#include "library/common/vddebug.h"

//
//  Constructor
//

CDDiskPlayerClass::CDDiskPlayerClass(void)
	: eventDispatcherInstance()
	, EventSender(&eventDispatcherInstance)
	, ERSBreakpointControl(&eventDispatcherInstance)
	{
	diskType = DDT_NONE;
	}

//
//  Destructor
//

CDDiskPlayerClass::~CDDiskPlayerClass(void)
	{
	}

//
//  Init
//

Error CDDiskPlayerClass::Init(WinPortServer * server, GenericProfile * profile, DVDDiskType diskType, GenericFileSystem * gfs)
	{
	this->diskType = diskType;
	GNRAISE_OK;
	}

//
//  Cleanup
//

Error CDDiskPlayerClass::Cleanup(void)
	{
	return Exit();
	}

//
//  Get Disk Type
//

Error CDDiskPlayerClass::GetDiskType(DVDDiskType & type)
	{
	type = diskType;
	GNRAISE_OK;
	}

//
//  Check if disk is encrypted
//

Error CDDiskPlayerClass::DiskIsEncrypted(BOOL & enc)
	{
	enc = FALSE;
	GNRAISE_OK;
	}

//
//  Get Extended Player State
//

Error CDDiskPlayerClass::GetExtendedPlayerState(ExtendedPlayerState * appEPS)
	{
	int i;

	//
	//  Player info
	//

	if (EPS_REQUEST(EPS_PLAYERINFO))
		{
		GNREASSERT(GetMode(eps.playerMode));
		GNREASSERT(GetPlaybackSpeed(eps.playbackSpeed));
		GNREASSERT(GetScanSpeed(eps.scanSpeed));
		GNREASSERT(GetUOPs(eps.forbiddenUOPs));
		GNREASSERT(IsPlayingForward(eps.playingForward));

		eps.valid |= EPS_PLAYERINFO;
		if (EPS_MONITOR(EPS_PLAYERINFO))
			{
			if (EPS_CHANGED(playerMode) || EPS_CHANGED(playbackSpeed) || EPS_CHANGED(scanSpeed) ||
				 EPS_CHANGED(forbiddenUOPs) || EPS_CHANGED(playingForward))
				eps.changed |= EPS_PLAYERINFO;
			}
		}

	//
	//  Misc. Info
	//

	if (EPS_REQUEST(EPS_MISC))
		{
		GNREASSERT(GetDiskType(eps.diskType));
		GNREASSERT(GetCurrentDisplayMode(eps.displayMode));
		GNREASSERT(GetCurrentVideoStandard(eps.videoStandard));
		GNREASSERT(GetCurrentBitrate(eps.currentBitRate));
		GNREASSERT(DiskIsEncrypted(eps.diskIsEncrypted));

		eps.valid |= EPS_MISC;
		if (EPS_MONITOR(EPS_MISC))
			if (EPS_CHANGED(diskType) || EPS_CHANGED(displayMode) || EPS_CHANGED(videoStandard) ||
				 EPS_CHANGED(currentBitRate) || EPS_CHANGED(diskIsEncrypted))
				eps.changed |= EPS_MISC;
		}

	//
	//  Title Information
	//

	GetCurrentLocation(eps.location);  // Always do this for internal use

	if (EPS_REQUEST(EPS_TITLE))
		{
		GetCurrentDuration(eps.duration);

		eps.valid |= EPS_TITLE;
		if (EPS_MONITOR(EPS_TITLE))
			{
			if (NotEqual(eps.location, appEPS->location) || NotEqual(eps.duration, appEPS->duration))
				eps.changed |= EPS_TITLE;
			}
		}

	//
	//  Menu Information
	//

	if (EPS_REQUEST(EPS_MENU))
		{
		GNREASSERT(GetMenuLanguage(eps.menuLanguage));
		GNREASSERT(MenuAvail(VMT_TITLE_MENU, eps.menuAvailable[VMT_TITLE_MENU]));
		GNREASSERT(MenuAvail(VMT_ROOT_MENU, eps.menuAvailable[VMT_ROOT_MENU]));
		GNREASSERT(MenuAvail(VMT_SUBPICTURE_MENU, eps.menuAvailable[VMT_ROOT_MENU]));
		GNREASSERT(MenuAvail(VMT_AUDIO_MENU, eps.menuAvailable[VMT_AUDIO_MENU]));
		GNREASSERT(MenuAvail(VMT_ANGLE_MENU, eps.menuAvailable[VMT_ANGLE_MENU]));
		GNREASSERT(MenuAvail(VMT_PTT_MENU, eps.menuAvailable[VMT_PTT_MENU]));
		eps.menuAvailable[VMT_NO_MENU] = FALSE;

		eps.valid |= EPS_MENU;
		if (EPS_MONITOR(EPS_MENU))
			if (EPS_CHANGED(menuLanguage))
				eps.changed |= EPS_MENU;
			else
				{
				for (i=0; i<VMT_NO_MENU; i++)
					if (EPS_CHANGED(menuAvailable[i]))
						{
						eps.changed |= EPS_MENU;
						break;
						}
				}
		}

	//
	//  Copy data to application buffer
	//

	eps.size = appEPS->size;
	eps.request = appEPS->request;
	eps.monitor = appEPS->monitor;
	memcpy(appEPS, &eps, min(sizeof(ExtendedPlayerState), appEPS->size));

	//
	//  So far, so good ...
	//

	GNRAISE_OK;
	}

//
//  Get UOPs
//

Error CDDiskPlayerClass::GetUOPs(DWORD & uops)
	{
	DVDPlayerMode mode;
	BOOL avail;

	uops = 0;
	GNREASSERT(MenuAvail(VMT_TITLE_MENU, avail));
	if (!avail)
		uops |= UOP_MENU_CALL_TITLE;
	GNREASSERT(MenuAvail(VMT_ROOT_MENU, avail));
	if (!avail)
		uops |= UOP_MENU_CALL_ROOT;
	GNREASSERT(MenuAvail(VMT_SUBPICTURE_MENU, avail));
	if (!avail)
		uops |= UOP_MENU_CALL_SUB_PICTURE;
	GNREASSERT(MenuAvail(VMT_AUDIO_MENU, avail));
	if (!avail)
		uops |= UOP_MENU_CALL_AUDIO;
	GNREASSERT(MenuAvail(VMT_ANGLE_MENU, avail));
	if (!avail)
		uops |= UOP_MENU_CALL_ANGLE;
	GNREASSERT(MenuAvail(VMT_PTT_MENU, avail));
	if (!avail)
		uops |= UOP_MENU_CALL_PTT;

	GNREASSERT(InternalGetMode(mode));
	switch (mode)
		{
		case DPM_STOPPED:
			uops |= UOP_STOP | UOP_GO_UP | UOP_TIME_PTT_SEARCH | UOP_PREV_TOP_PG_SEARCH |
					  UOP_NEXT_PG_SEARCH | UOP_FORWARD_SCAN | UOP_BACKWARD_SCAN | UOP_SCAN_OFF |
					  UOP_RESUME | UOP_BUTTON | UOP_STILL_OFF | UOP_PAUSE_ON | UOP_PAUSE_OFF;
			break;
		case DPM_STILL:
			uops |= UOP_FORWARD_SCAN | UOP_BACKWARD_SCAN | UOP_SCAN_OFF | UOP_PAUSE_ON | UOP_PAUSE_OFF;
			break;
		case DPM_PAUSED:
			uops |= UOP_BUTTON | UOP_STILL_OFF | UOP_SCAN_OFF;
			break;
		case DPM_SCANNING:
			uops |= UOP_PAUSE_OFF | UOP_STILL_OFF;
			break;
		case DPM_PLAYING:
			uops |= UOP_PAUSE_OFF | UOP_STILL_OFF | UOP_SCAN_OFF;
			break;
		case DPM_REVERSEPLAY:
			uops |= UOP_PAUSE_OFF | UOP_STILL_OFF;
			break;
		}

	GNREASSERT(HasPositionalButtons(avail));
	if (!avail)
		uops |= UOP_BUTTON;

	GNRAISE_OK;
	}

//
//  Get Title Search UOPs
//

Error CDDiskPlayerClass::GetTitleSearchUOPs (WORD title, DWORD & uops)
	{
	GNRAISE(GetUOPs(uops));
	}

//
//  Check if UOP is permitted for title search
//

Error CDDiskPlayerClass::TitleSearchUOPPermitted (WORD title, int uops, BOOL & permitted)
	{
	GNRAISE(UOPPermitted(uops, permitted));
	}

//
//	Set Playback Control for VCDs
//

Error CDDiskPlayerClass::SetPlaybackControl(BOOL playbackControl)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

//
//  Get AVF File Info
//

Error CDDiskPlayerClass::GetAVFileInfo(GenericFileSystemIterator *gfsi, AVFInfo *pInfo)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

//
//  Play File (same as Start Presentation, but with a Generic File System Iterator as an argument)
//

Error	CDDiskPlayerClass::PlayFile(GenericFileSystemIterator *gfsi, DWORD flags)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error CDDiskPlayerClass::SetAudioStreamSelectionPreferences(DWORD flags)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

//
//  You can enable/disable the GetExtendedPlayerState call with this method.
//  Normally it should be permitted. If you need to disable it then overwrite
//  this method with the parent class.
//

Error CDDiskPlayerClass::EPSPermitted(BOOL & permitted)
	{
	permitted = TRUE;

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\CDDAFile.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  CDDA Access Classes
//
////////////////////////////////////////////////////////////////////

#ifndef CDDAFILE_H
#define CDDAFILE_H

#include "Library/Files/RootFile.h"
#include "Library/Files/CDVDVolume.h"
#include "NavErrors.h"
#include "EventSender.h"

//
//  Forward declarations
//

class CDDATrack;
class CDDAIterator;
class CDDAFileSystem;

////////////////////////////////////////////////////////////////////
//
//  CDDA File Class
//
////////////////////////////////////////////////////////////////////

class CDDATrack : public GenericFile, public EventSender
	{
	friend class CDDAFileSystem;

	protected:
		GenericFileSystem * baseFS;
		GenericFile * file;
		DWORD lockFlags;

		CDDATrack(CDDAFileSystem * gfs, GenericFileSystem * baseFS, DWORD lockFlags, EventDispatcher* pEventDispatcher);

		virtual Error BuildUniqueKey(void);

	public:
		virtual ~CDDATrack(void);

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accessType);
		virtual Error Close(void);

		//
		//  Misc. inquiry
		//

		virtual Error GetUniqueKey(BYTE * key);
		virtual Error GetCopyManagementInfo(GenericCopyManagementInfo & gcmi);
		virtual Error GetStartBlock(DWORD & startBlock);

		//
		//  Access functions
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);

		//
		//  Inquiry
		//

		virtual Error GetName(DiskItemName & name);
		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetSize(KernelInt64 & size);
		virtual Error GetIterator(GenericFileSystemIterator * & gfsi);

		//
		//  Misc.
		//

		virtual Error Flush(void);
		virtual Error TerminateRequest(RequestHandle * rh);
	};

////////////////////////////////////////////////////////////////////
//
//  CDDA File System Iterator Class
//
////////////////////////////////////////////////////////////////////

class CDDAIterator : public GenericFileSystemIterator
	{
	friend class CDDAFileSystem;

	protected:
		GenericFileSystemIterator * gfsi;
		WORD track;

		CDDAIterator(CDDAFileSystem * baseFS, WORD track);

	public:
		virtual ~CDDAIterator(void);

		virtual Error Clone(GenericFileSystemIterator * & gfsi) const;
		virtual Error Clone(CDDAIterator * & cddai) const;

		//
		//  Directory Handling
		//

		virtual Error GoToFirstItem(void);
		virtual Error GoToNextItem(void);
		virtual Error GoToSubDir(GenericFileSystemIterator * & gfsi);
		virtual Error GoToParentDir(GenericFileSystemIterator * & gfsi);

		//
		//  Inquiry
		//

		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetItemType(DiskItemType & type);
		virtual Error GetItemName(DiskItemName & name);
		virtual Error GetItemSize(KernelInt64 & size);
		virtual Error GetNumberOfItems(DWORD & num);
		virtual Error GetCurrentDir(GenericDirectory * & gd);

		//
		//  File Access
		//

		virtual Error OpenItem(DWORD accessType, GenericDiskItem * & gdi);
		virtual Error OpenTrack(DWORD accessType, CDDATrack * & track);
	};

////////////////////////////////////////////////////////////////////
//
//  CDDA File System Class
//
////////////////////////////////////////////////////////////////////

class CDDAFileSystem : public GenericFileSystem, public EventSender
	{
	friend class CDDATrack;
	friend class CDDADirectory;
	friend class CDDAIterator;

	protected:
		GenericFileSystem * baseFS;
		//CDVDVolume * cdvdVolume;

		BOOL	readSubChannel;		// TRUE if we read subchannel, otherwise we fake it
		DWORD	lockFlags;				// Flags used when locking/unlocking blocks

		// DTS-related (set at initialization time)
		BOOL isDTS;
		GenericCopyManagementInfo gcmi;

		//
		//  Factory methods
		//

		virtual Error CreateFile(DWORD flags, GenericFile * & gf);
		virtual Error CreateDirectory(DWORD flags, GenericDirectory * & gd);

		//
		//  Data Access Methods
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);

		virtual Error BuildUniqueKey(void);

		//
		//  Internal helper functions
		//

		WORD	RBFS(DriveBlock * blocks, DWORD base, DWORD pos1, DWORD num, BOOL base16);
		WORD	RWFS(DriveBlock * blocks, DWORD pos);
		virtual Error InitHeaderAndData(GenericVolume * volume);
		Error InitDTSInfo();

		//
		//  Table of contents handling
		//

		GenericFileSystemIterator * audioTracks[CD_MAX_TOC_ENTRY_NUM];
		WORD	numberOfAudioTracks;

		void	FindAudioTracks(GenericFileSystemIterator * gfsi);
		Error GetBaseIterator(CDDAIterator * cddai, GenericFileSystemIterator * & baseIt);

		//
		//  Item handling
		//

		virtual Error GoToFirstItem(CDDAIterator * cddai);
		virtual Error GoToNextItem(CDDAIterator * cddai);
		virtual Error GoToParentDir(CDDAIterator * cddai, GenericFileSystemIterator * & gfsi);
		virtual Error GetPathName(CDDAIterator * cddai, DiskItemName & name);
		virtual Error GetItemName(CDDAIterator * cddai, DiskItemName & name);
		virtual Error GetItemSize(CDDAIterator * cddai, KernelInt64 & size);
		virtual Error GetNumberOfItems(CDDAIterator * cddai, DWORD & num);

	public:
		CDDAFileSystem(EventDispatcher* pEventDispatcher);
		virtual ~CDDAFileSystem(void);

		virtual Error Init(GenericFileSystemIterator * mountPoint, GenericVolume * volume, GenericProfile * profile);

		//
		//  Factory Methods
		//

		virtual Error CreateIterator(GenericFileSystemIterator * & gfsi);

		//
		//  Volume Information
		//

		virtual Error GetUniqueKey(BYTE * key);
		virtual Error GetDiskType(PhysicalDiskType & type);
		virtual Error GetLogicalBaseBlock(DWORD & logicalBaseBlock);
		Error GetDTSInfo(BOOL & isDTS, GenericCopyManagementInfo & gcmi){isDTS = this->isDTS; gcmi = this->gcmi; GNRAISE_OK;}
		//
		//  Drive "Pass Through" Functions
		//

		virtual Error GetNumberOfDriveBlocks(DWORD & num);
		virtual Error SetNumberOfDriveBlocks(DWORD num);
		virtual Error GetCurrentDriveBlockSize(DWORD & size);

		virtual Error TerminateRequest(RequestHandle * rh);
		virtual Error Flush(void);

		virtual Error GetDriveName(KernelString & name);
		virtual Error SpinUpDrive(void);
		virtual Error SpinDownDrive(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDAudioStillVideo.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD Audio Still Video Module
//
//	 Declares classes for use with Audio Titles with
//	 Audio Still Video Sets on a DVD-Audio
//
////////////////////////////////////////////////////////////////////

#ifndef DVDAUDIOSTILLVIDEO_H
#define DVDAUDIOSTILLVIDEO_H

#include "DVDFile.h"
#include "DVDHeader.h"


////////////////////////////////////////////////////////////////////
//
//  DVD Video Object Set for Audio Still Video Set Class
//
//	 Description:
//		This class describes an Audio Still Video Object Set. ASVOB
//		is the Presentation data for one Audio Still Video (ASV) and
//		contains Highlight Information data for Button, Sub-Picture
//		data for Button and Still picture data.
//
////////////////////////////////////////////////////////////////////

class DVDASVOBS : public DVDVOBS
	{
	protected:
		DVDHeaderFile * headerFile;

	public:
		DVDASVOBS(DVDHeaderFile * headerFile, DVDDataFile * dataFile, const DVDPTLMAI & ptlmai);
		virtual ~DVDASVOBS(void);

		Error GetVideoAttributes(WORD & attrib) {GNRAISE(GNR_UNIMPLEMENTED);}

		Error GetNumberOfAudioStreams(WORD & num) {GNRAISE(GNR_UNIMPLEMENTED);}
		Error GetAudioStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension, WORD & applicationInfo) {GNRAISE(GNR_UNIMPLEMENTED);}

		Error GetNumberOfSubPictureStreams(WORD & num) {GNRAISE(GNR_UNIMPLEMENTED);}
		Error GetSubPictureStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension) {GNRAISE(GNR_UNIMPLEMENTED);}

		Error GetNumberOfStillVideosInUnit(int item, BYTE & num);
		Error GetStillVideoAttribute(int item, WORD & attrib);

		Error GetParentalID(WORD level, WORD & id) {GNRAISE(GNR_UNIMPLEMENTED);}
	};

////////////////////////////////////////////////////////////////////
//
//  DVD Audio Still Video Set Class
//
//	 Description:
//		This class describes an Audio Still Video Set. An ASVS is a
//		logical unit to define the collection of Audio Still Video
//		(ASV) to be presented together with Audio data.
//
////////////////////////////////////////////////////////////////////

class DVDASVS
	{
	protected:
		RequestHandle		rh;
		DVDASVOBS		*	asVobs;
		DVDHeaderFile	*	hfile;
		DVDDataFile		*	dfile;
		DVDFileSystem	*	dvdfs;
		DVDPTLMAI			ptlmai;

	public:
		DVDASVS(void);
		virtual ~DVDASVS(void);

		Error Init(DVDFileSystem * dvdfs);

		Error GetASVOBS(DVDASVOBS * & asVobs);
		Error GetNumberOfASVU(WORD & num);
	};


#endif	// DVDAUDIOSTILLVIDEO_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDAVDisk.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "DVDAVDisk.h"
#include "DVDAVHeader.h"


//////////////////////////////////////////////////////////////////////
//
//  DVD Video Manager Menu Definition
//
//////////////////////////////////////////////////////////////////////

//
//  Constructor
//

DVDVMGM::DVDVMGM(DVDDiskPlayerFactory * factory) : DVDMGM(factory)
	{
	vmgmVobs = NULL;
	}

//
//  Destructor
//

DVDVMGM::~DVDVMGM(void)
	{
	delete vmgmVobs;
	}

//
//  Initialize
//

Error DVDVMGM::Init(DVDFileSystem * dvdfs, WORD parentalCountryCode)
	{
	GenericDiskItem * gdi;
	DWORD	d;

	this->dvdfs = dvdfs;
	if (IS_ERROR(dvdfs->OpenItem("video_ts\\video_ts.ifo", FAT_HEADER, gdi)))
		GNREASSERT(dvdfs->OpenItem("video_ts\\video_ts.inf", FAT_HEADER, gdi));

	hfile = (DVDHeaderFile*)gdi;
	GNREASSERT(hfile->ReadDWord(204, d, &rh));

	if (d)
		{
		DVDPTLMAIT ptlmait = DVDPTLMAIT(hfile, d * DVD_BLOCK_SIZE);
		return ptlmait.GetPTLMAI(parentalCountryCode, ptlmai);
		}

	GNRAISE_OK;
	}

//
// Identifies the Manager Menu. Just returning VMGM should be enough.
// The Video Management Table contains an identifier describing
//	"DVDVIDEO-VMG" in the first 12 bytes. This is currently not
//	considered.
//

Error DVDVMGM::Identify(DVDManagerMenuType & mgmType)
	{
	/*
	DWORD d[3];

	GNREASSERT(hfile->ReadDWord(0, d[0], &rh));
	GNREASSERT(hfile->ReadDWord(4, d[1], &rh));
	GNREASSERT(hfile->ReadDWord(8, d[2], &rh));
	*/

	mgmType = DMT_VMGM;

	GNRAISE_OK;
	}

//
// Returns always TRUE because DVD-Video always contains
// a Video Manager Menu (in contrast to DVD-Audio)
//

Error DVDVMGM::HasMGMVOBS(BOOL & hasMGMVOBS)
	{
	// DVD-Video always returns TRUE
	hasMGMVOBS = TRUE;

	GNRAISE_OK;
	}

//
//  Return MGMVOBS
//

Error DVDVMGM::GetMGMVOBS(DVDMGMVOBS * & mgmVobs)
	{
	GenericDiskItem * gdi;

	if (!this->vmgmVobs)
		{
		if (!IS_ERROR(dvdfs->OpenItem("video_ts\\video_ts.vob", FAT_NONE, gdi)))
			dfile = (DVDDataFile*)gdi;
		else
			dfile = NULL;

		this->vmgmVobs = new DVDVMGMVOBS(hfile, ptlmai, dfile);
		}

	mgmVobs = (DVDMGMVOBS *)this->vmgmVobs;

	GNRAISE_OK;
	}

//
//  Test on First Play PGC
//

Error DVDVMGM::HasFirstPlayPGC(BOOL & hasFPP)
	{
	DWORD d;

	GNREASSERT(hfile->ReadDWord(132, d, &rh));
	hasFPP = d != 0;
	GNRAISE_OK;
	}

//
//  Get First Play PGCI
//

Error DVDVMGM::GetFirstPlayPGCI(DVDGenericPGCI * & pgci)
	{
	Error err;
	DWORD d;

	GNREASSERT(hfile->ReadDWord(132, d, &rh));

	pgci = new DVDPGCI(factory);
	if (IS_ERROR(err = pgci->Init(hfile, d)))
		delete pgci;
	GNRAISE(err);
	}

//
//  Test on MPGCIUT
//

Error DVDVMGM::HasMPGCIUT(BOOL & hasMPGCIUT)
	{
	DWORD d;

	GNREASSERT(hfile->ReadDWord(200, d, &rh));

	hasMPGCIUT = d != 0;
	GNRAISE_OK;
	}

//
//  Return MPGCIUT
//

Error DVDVMGM::GetMPGCIUT(DVDPGCIUT & pgciut)
	{
	DWORD d;

	GNREASSERT(hfile->ReadDWord(200, d, &rh));

	pgciut = DVDPGCIUT(factory, hfile, d * DVD_BLOCK_SIZE);
	GNRAISE_OK;
	}

//
//  Get SRPT
//

Error DVDVMGM::GetSRPT(DVDSRPT * & srpt)
	{
	DWORD d;

	GNREASSERT(hfile->ReadDWord(196, d, &rh));
	srpt = (DVDSRPT *)new DVDVTTSRPT(hfile, d * DVD_BLOCK_SIZE);

	GNRAISE_OK;
	}

//////////////////////////////////////////////////////////////////////
//
//  DVD Audio Manager Menu Class
//
//////////////////////////////////////////////////////////////////////

DVDAMGM::DVDAMGM(DVDDiskPlayerFactory * factory) : DVDMGM(factory)
	{
	amgmVobs = NULL;
	}

DVDAMGM::~DVDAMGM(void)
	{
	delete amgmVobs;
	}

Error DVDAMGM::Init(DVDFileSystem * dvdfs, WORD parentalCountryCode)
	{
	GenericDiskItem * gdi;

	this->dvdfs = dvdfs;
	if (IS_ERROR(dvdfs->OpenItem("audio_ts\\audio_ts.ifo", FAT_HEADER, gdi)))
		GNREASSERT(dvdfs->OpenItem("audio_ts\\audio_ts.inf", FAT_HEADER, gdi));

	hfile = (DVDHeaderFile*)gdi;

	GNRAISE_OK;
	}

//
// Identifies the Manager Menu. Just returning VMGM should be enough.
// The Audio Management Table contains an identifier describing
//	"DVDAUDIO-VMG" in the first 12 bytes. This is currently not
//	considered.
//

Error DVDAMGM::Identify(DVDManagerMenuType & mgmType)
	{
	/*
	DWORD d[3];

	GNREASSERT(hfile->ReadDWord(0, d[0], &rh));
	GNREASSERT(hfile->ReadDWord(4, d[1], &rh));
	GNREASSERT(hfile->ReadDWord(8, d[2], &rh));
	*/

	mgmType = DMT_AMGM;

	GNRAISE_OK;
	}

Error	DVDAMGM::HasFirstPlayPGC(BOOL & hasFPP)
	{
	// always returns TRUE. Audio Manager Menu is defined as one PGC.
	// No First Play PGC detection is necessary.
	hasFPP = TRUE;

	GNRAISE_OK;
	}

Error	DVDAMGM::GetFirstPlayPGCI(DVDGenericPGCI * & pgci)
	{
	pgci = NULL;

	GNRAISE_OK;
	}

Error	DVDAMGM::HasMPGCIUT(BOOL & hasMPGCIUT)
	{
	DWORD d;

	GNREASSERT(hfile->ReadDWord(204, d, &rh));

	hasMPGCIUT = d != 0;
	GNRAISE_OK;
	}

Error	DVDAMGM::GetMPGCIUT(DVDPGCIUT & pgciut)
	{
	DWORD d;

	GNREASSERT(hfile->ReadDWord(204, d, &rh));

	pgciut = DVDPGCIUT(factory, hfile, d * DVD_BLOCK_SIZE);
	GNRAISE_OK;
	}

//
// Returns TRUE if DVD-Audio disc has an Audio Manager Menu
// else returns FALSE
//

Error DVDAMGM::HasMGMVOBS(BOOL & hasMGMVOBS)
	{
	GenericDiskItem * gdi;

	if (!IS_ERROR(dvdfs->OpenItem("audio_ts\\audio_ts.vob", FAT_NONE, gdi)))
		{
		hasMGMVOBS = TRUE;
		delete gdi;
		}
	else
		hasMGMVOBS = FALSE;

	GNRAISE_OK;
	}

Error DVDAMGM::GetMGMVOBS(DVDMGMVOBS * & mgmvobs)
	{
	GenericDiskItem * gdi;

	if (!this->amgmVobs)
		{
		if (!IS_ERROR(dvdfs->OpenItem("audio_ts\\audio_ts.vob", FAT_NONE, gdi)))
			{
			dfile = (DVDDataFile*)gdi;
			this->amgmVobs = new DVDAMGMVOBS(hfile, dfile, ptlmai);
			}
		else
			{
			dfile = NULL;
			this->amgmVobs = NULL;
			}
		}

	mgmvobs = (DVDMGMVOBS *)this->amgmVobs;

	GNRAISE_OK;
	}

Error DVDAMGM::GetSRPT(DVDSRPT * & srpt)
	{
	DWORD d;

	GNREASSERT(hfile->ReadDWord(196, d, &rh));
	srpt = (DVDSRPT *)new DVDATTSRPT(hfile, d * DVD_BLOCK_SIZE);

	GNRAISE_OK;
	}

//////////////////////////////////////////////////////////////////////
//
//  DVD Video Title Set Definition
//
//////////////////////////////////////////////////////////////////////

//
//  Constructor
//

DVDVTS::DVDVTS(DVDDiskPlayerFactory * factory) : DVDTS(factory)
	{
	vtsmVobs = NULL;
	vtsVobs = NULL;
	}

//
//  Destructor
//

DVDVTS::~DVDVTS(void)
	{
	delete vtsmVobs;
	delete vtsVobs;
	}

//
//  Initialize
//

Error DVDVTS::Init(DVDFileSystem * dvdfs, WORD ts, DVDPTLMAI ptlmai)
	{
	GenericDiskItem * gdi;
	KernelString s;

	s = KernelString("video_ts\\vts_") + KernelString(ts, 2) + KernelString("_0.ifo");

	if (IS_ERROR(dvdfs->OpenItem(s, FAT_HEADER, gdi)))
		{
		s = KernelString("video_ts\\vts_") + KernelString(ts, 2) + KernelString("_0.inf");
		GNREASSERT(dvdfs->OpenItem(s, FAT_HEADER, gdi));
		}
	hfile = (DVDHeaderFile*)gdi;

	s = KernelString("video_ts\\vts_") + KernelString(ts, 2) + KernelString("_0.vob");
	if (!IS_ERROR(dvdfs->OpenItem(s, FAT_NONE, gdi)))
		{
		mfile = (DVDDataFile*)gdi;
		}
	else
		{
		mfile = NULL;
		}

	s = KernelString("video_ts\\vts_") + KernelString(ts, 2) + KernelString("_1.vob");
	if (!IS_ERROR(dvdfs->OpenItem(s, FAT_CHAIN, gdi)))
		{
		dfile = (DVDDataFile*)gdi;
		}
	else
		{
		dfile = NULL;
		}

	vtsmVobs = new DVDVTSMVOBS(hfile, ptlmai, mfile, ts);
	vtsVobs = new DVDVTSVOBS(hfile, ptlmai, dfile, ts);

	GNRAISE_OK;
	}

//
// Check if we have a Part of Title Table
// Always TRUE for Video Title Set
//

Error DVDVTS::HasPTT(BOOL & hasPTT)
	{
	hasPTT = TRUE;

	GNRAISE_OK;
	}

//
//  Get Part of Title
//

Error DVDVTS::GetPTT(DVDPTT & ptt)
	{
	DWORD d;

	GNREASSERT(hfile->ReadDWord(200, d, &rh));
	ptt = DVDPTT(hfile, d * DVD_BLOCK_SIZE);
	GNRAISE_OK;
	}

//
//  Check if we have a Menu PGC Information Table
//

Error DVDVTS::HasMPGCIUT(BOOL & hasMPGCIUT)
	{
	DWORD d;

	GNREASSERT(hfile->ReadDWord(208, d, &rh));
	hasMPGCIUT = d != 0;
	GNRAISE_OK;
	}

//
//  Get Menu PGC Information Table
//

Error DVDVTS::GetMPGCIUT(DVDPGCIUT & pgciut)
	{
	DWORD d;

	GNREASSERT(hfile->ReadDWord(208, d, &rh));
	pgciut = DVDPGCIUT(factory, hfile, d * DVD_BLOCK_SIZE);
	GNRAISE_OK;
	}

//
//  Get PGC Information Table
//

Error DVDVTS::GetPGCIT(DVDPGCIT & pgcit)
	{
	DWORD d;

	GNREASSERT(hfile->ReadDWord(204, d, &rh));
	pgcit = DVDPGCIT(factory, hfile, d * DVD_BLOCK_SIZE);
	GNRAISE_OK;
	}

//////////////////////////////////////////////////////////////////////
//
//  DVD Audio Title Set Class
//
//////////////////////////////////////////////////////////////////////

DVDATS::DVDATS(DVDDiskPlayerFactory * factory) : DVDTS(factory)
	{
	atsAottObs = NULL;
	}

DVDATS::~DVDATS(void)
	{
	if (atsAottObs)
		{
		delete atsAottObs;
		atsAottObs = NULL;
		}
	}

Error DVDATS::Init(DVDFileSystem * dvdfs, WORD ts, DVDPTLMAI ptlmai)
	{
	GenericDiskItem * gdi;
	KernelString s;

	s = KernelString("audio_ts\\ats_") + KernelString(ts, 2) + KernelString("_0.ifo");

	if (IS_ERROR(dvdfs->OpenItem(s, FAT_HEADER, gdi)))
		{
		s = KernelString("audio_ts\\ats_") + KernelString(ts, 2) + KernelString("_0.inf");
		GNREASSERT(dvdfs->OpenItem(s, FAT_HEADER, gdi));
		}
	hfile = (DVDHeaderFile*)gdi;

	// Open first Audio Object Set for Titles
	s = KernelString("audio_ts\\ats_") + KernelString(ts, 2) + KernelString("_1.aob");
	if (!IS_ERROR(dvdfs->OpenItem(s, FAT_NONE, gdi)))
		{
		dfile = (DVDDataFile*)gdi;
		}
	else
		{
		dfile = NULL;
		}

	// DVD-Audio doesn't contain a Title Set Menu!
	mfile = NULL;

	atsAottObs = new DVDATSAOTTOBS(hfile, dfile);

	GNRAISE_OK;
	}

//
// Check if we have a Part of Title Information Table
//	Not available for Audio Title Set
//

Error DVDATS::HasPTT(BOOL & hasPTT)
	{
	hasPTT = FALSE;

	GNRAISE_OK;
	}

//
//  Get Part of Title
//	 Not available for Audio Title Set
//

Error DVDATS::GetPTT(DVDPTT & ptt)
	{
	GNRAISE_OK;
	}

//
//  Check if we have a Menu PGC Information Table
//	 Not available for Audio Title Set
//

Error DVDATS::HasMPGCIUT(BOOL & hasMPGCIUT)
	{
	hasMPGCIUT = FALSE;

	GNRAISE_OK;
	}

//
//  Get Menu PGC Information Table
//	 Not available for Audio Title Set
//

Error DVDATS::GetMPGCIUT(DVDPGCIUT & pgciut)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Get PGC Information Table
//

Error DVDATS::GetPGCIT(DVDPGCIT & pgcit)
	{
	DWORD d;

	GNREASSERT(hfile->ReadDWord(204, d, &rh));
	pgcit = DVDPGCIT(factory, hfile, d * DVD_BLOCK_SIZE, TRUE);

	GNRAISE_OK;
	}

//////////////////////////////////////////////////////////////////////
//
//  DVD Video Disk Class Definition
//
//////////////////////////////////////////////////////////////////////

//
//  Constructor
//

DVDVideoDisk::DVDVideoDisk(DVDDiskPlayerFactory * factory) : DVDDisk(factory)
	{
	vmgm = NULL;
	currentVTS = NULL;
	}

//
//  Destructor
//

DVDVideoDisk::~DVDVideoDisk(void)
	{
	if (vmgm)
		{
		delete vmgm;
		vmgm = NULL;
		}

	if (currentVTS)
		{
		delete currentVTS;
		currentVTS = NULL;
		}
	}

//
//  Initialize
//

Error DVDVideoDisk::Init(DVDFileSystem * diskfs, WORD parentalCountryCode)
	{
	this->diskfs = diskfs;
	vmgm = new DVDVMGM(factory);
	if (!vmgm)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	return vmgm->Init(diskfs, parentalCountryCode);
	}

//
//  Return pointer to a certain Video Title Set (Cached!!!)
//

Error DVDVideoDisk::GetTS(WORD num, DVDTS * & titleSet)
	{
	Error err;

	titleSet = NULL;

	//
	//  Return current VTS if that is the one requested, otherwise delete it
	//

	if (currentVTS != NULL)
		{
		if (num == currentTSNum)
			{
			titleSet = (DVDTS *)currentVTS;
			GNRAISE_OK;
			}
		else
			{
			delete currentVTS;
			currentVTS = NULL;
			}
		}

	//
	//  Create new VTS if there is none
	//

	if (currentVTS == NULL)
		{
		DVDPTLMAI ptlmai;

		GNREASSERT(vmgm->GetPTLMAI(ptlmai));
		currentVTS = new DVDVTS(factory);
		if (!currentVTS)
			GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		if (IS_ERROR(err = currentVTS->Init(diskfs, num, ptlmai)))
			{
			delete currentVTS;
			currentVTS = NULL;
			GNRAISE(err);
			}
		currentTSNum = num;
		}

	titleSet = (DVDTS *)currentVTS;
	GNRAISE_OK;
	}

//
//  Return pointer to a certain Video Title Set (must be delete by caller)
//

Error DVDVideoDisk::GetTSExclusive(WORD num, DVDTS * & titleSet, BOOL & deleteIt)
	{
	DVDPTLMAI ptlmai;
	Error err;

	//
	//  Return current VTS if that is the one requested
	//

	if (currentVTS != NULL && num == currentTSNum)
		{
		titleSet = (DVDTS *)currentVTS;
		deleteIt = FALSE;
		GNRAISE_OK;
		}

	//
	//  Create new VTS if it is a different one
	//

	deleteIt = TRUE;
	GNREASSERT(vmgm->GetPTLMAI(ptlmai));

	titleSet = new DVDVTS(factory);
	if (!titleSet)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	if (IS_ERROR(err = titleSet->Init(diskfs, num, ptlmai)))
		{
		delete titleSet;
		titleSet = NULL;
		}

	GNRAISE(err);
	}

//////////////////////////////////////////////////////////////////////
//
//  DVD Audio Disk Class Definition
//
//////////////////////////////////////////////////////////////////////

DVDAudioDisk::DVDAudioDisk(DVDDiskPlayerFactory * factory) : DVDDisk(factory)
	{
	amgm = NULL;
	currentATS = NULL;
	}

DVDAudioDisk::~DVDAudioDisk(void)
	{
	if (currentATS)
		{
		delete currentATS;
		currentATS = NULL;
		}

	if (amgm)
		{
		delete amgm;
		amgm = NULL;
		}
	}

Error	DVDAudioDisk::Init(DVDFileSystem * diskfs, WORD parentalCountryCode)
	{
	this->diskfs = diskfs;
	amgm = new DVDAMGM(factory);
	if (!amgm)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	return amgm->Init(diskfs, parentalCountryCode);
	}

Error	DVDAudioDisk::GetTS(WORD num, DVDTS * & titleSet)
	{
	Error err;

	titleSet = NULL;

	//
	//  Return current TS if that is the one requested, otherwise delete it
	//

	if (currentATS != NULL)
		{
		if (num == currentTSNum)
			{
			titleSet = (DVDTS *)currentATS;
			GNRAISE_OK;
			}
		else
			{
			delete currentATS;
			currentATS = NULL;
			}
		}

	//
	//  Create new VTS if there is none
	//

	if (currentATS == NULL)
		{
		DVDPTLMAI ptlmai;

		GNREASSERT(amgm->GetPTLMAI(ptlmai));
		currentATS = new DVDATS(factory);
		if (!currentATS)
			GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		if (IS_ERROR(err = currentATS->Init(diskfs, num, ptlmai)))
			{
			delete currentATS;
			currentATS = NULL;
			GNRAISE(err);
			}
		currentTSNum = num;
		}

	titleSet = (DVDTS *)currentATS;

	GNRAISE_OK;
	}

Error	DVDAudioDisk::GetTSExclusive(WORD num, DVDTS * & titleSet, BOOL & deleteIt)
	{
	DVDPTLMAI ptlmai;
	Error err;

	//
	//  Return current VTS if that is the one requested
	//

	if (currentATS != NULL && num == currentTSNum)
		{
		titleSet = (DVDTS *)currentATS;
		deleteIt = FALSE;
		GNRAISE_OK;
		}

	//
	//  Create new VTS if it is a different one
	//

	deleteIt = TRUE;
	GNREASSERT(amgm->GetPTLMAI(ptlmai));

	titleSet = new DVDATS(factory);
	if (!titleSet)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	if (IS_ERROR(err = titleSet->Init(diskfs, num, ptlmai)))
		{
		delete titleSet;
		titleSet = NULL;
		}

	GNRAISE(err);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDAVDisk.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD Audio/Video specific Disk Information
//
////////////////////////////////////////////////////////////////////

#ifndef DVDAVDISK_H
#define DVDAVDISK_H


#include "DVDDisk.h"
#include "DVDAVHeader.h"


//////////////////////////////////////////////////////////////////////
//
//  DVD Video Manager Menu Class
//
//	 Description:
//		The VMGM represents the Title Menu.
//
//////////////////////////////////////////////////////////////////////

class DVDVMGM : public DVDMGM
	{
	protected:
		DVDVMGMVOBS		*	vmgmVobs;

	public:
		DVDVMGM(DVDDiskPlayerFactory * factory);
		virtual ~DVDVMGM(void);

		Error	Init(DVDFileSystem * dvdfs, WORD parentalCountryCode);

		Error Identify(DVDManagerMenuType & mgmType);
		Error	HasFirstPlayPGC(BOOL & hasFPP);
		Error	GetFirstPlayPGCI(DVDGenericPGCI * & pgci);
		Error	HasMPGCIUT(BOOL & hasMPGCIUT);
		Error	GetMPGCIUT(DVDPGCIUT & pgciut);
		Error	GetSRPT(DVDSRPT * & srpt);
		Error HasMGMVOBS(BOOL & hasMGMVOBS);
		Error	GetMGMVOBS(DVDMGMVOBS * & mgmVobs);
	};

//////////////////////////////////////////////////////////////////////
//
//  DVD Audio Manager Menu Class
//
//	 Description:
//		DVD Audio Mananger Menu Class describes a table of contents for
//		all Audio Title Sets (ATSs) which exist in DVD-Audio zone, and
//		all Video Title Sets (VTSs) for Audio Titles, which exist in
//		DVD-Video zone.
//
//////////////////////////////////////////////////////////////////////

class DVDAMGM : public DVDMGM
	{
	protected:
		DVDAMGMVOBS	*	amgmVobs;

	public:
		DVDAMGM(DVDDiskPlayerFactory * factory);
		virtual ~DVDAMGM(void);

		Error Init(DVDFileSystem * dvdfs, WORD parentalCountryCode);

		Error Identify(DVDManagerMenuType & mgmType);
		Error	HasFirstPlayPGC(BOOL & hasFPP);
		Error	GetFirstPlayPGCI(DVDGenericPGCI * & pgci);
		Error	HasMPGCIUT(BOOL & hasMPGCIUT);
		Error	GetMPGCIUT(DVDPGCIUT & pgciut);
		Error	GetSRPT(DVDSRPT * & srpt);
		Error HasMGMVOBS(BOOL & hasMGMVOBS);
		Error	GetMGMVOBS(DVDMGMVOBS * & mgmvobs);
	};

//////////////////////////////////////////////////////////////////////
//
//  DVD Video Title Set Class
//
//	 Description:
//		The Video Title Set Class describes the Video Title Set. This
//		is a collection of Titles and VTSM.
//
//////////////////////////////////////////////////////////////////////

class DVDVTS : public DVDTS
	{
	protected:
		DVDVTSMVOBS		*	vtsmVobs;
		DVDVTSVOBS		*	vtsVobs;

	public:
		DVDVTS(DVDDiskPlayerFactory * factory);
		virtual ~DVDVTS(void);

		Error Init(DVDFileSystem * dvdfs, WORD ts, DVDPTLMAI ptlmai);

		Error HasPTT(BOOL & hasPTT);
		Error GetPTT(DVDPTT & ptt);
		Error HasMPGCIUT(BOOL & hasMPGCIUT);
		Error GetMPGCIUT(DVDPGCIUT & pgciut);
		Error GetPGCIT(DVDPGCIT & pgcit);
		DVDVTSMVOBS * GetVTSMVOBS(void) { return vtsmVobs; }
		DVDVTSVOBS * GetVTSVOBS(void) { return vtsVobs; }
		DVDOBS * GetTSOBS(void) { return vtsVobs; }
	};

//////////////////////////////////////////////////////////////////////
//
//  DVD Audio Title Set Class
//
//	 Description:
//		ATS defines the Audio Only Titles (AOTTs) which is defined by
//		the Navigation Data and the Audio Objects (AOBs) in the ATS,
//		or by the Navigation Data in the ATS and the audio part of
//		Video Objects (VOBs) in the VTS.
//
//////////////////////////////////////////////////////////////////////

class DVDATS : public DVDTS
	{
	protected:
		DVDATSAOTTOBS	*	atsAottObs;

	public:
		DVDATS(DVDDiskPlayerFactory * factory);
		virtual ~DVDATS(void);

		Error Init(DVDFileSystem * dvdfs, WORD ts, DVDPTLMAI ptlmai);

		virtual Error HasPTT(BOOL & hasPTT);
		virtual Error GetPTT(DVDPTT & ptt);
		virtual Error HasMPGCIUT(BOOL & hasMPGCIUT);
		virtual Error GetMPGCIUT(DVDPGCIUT & pgciut);
		virtual Error GetPGCIT(DVDPGCIT & pgcit);
		virtual DVDATSAOTTOBS * GetATSAOBS(void) { return atsAottObs; }
		DVDOBS * GetTSOBS(void) { return atsAottObs; }
	};

//////////////////////////////////////////////////////////////////////
//
//  DVD Video Disk Class
//
//////////////////////////////////////////////////////////////////////

class DVDVideoDisk : public DVDDisk
	{
	protected:
		DVDVMGM			*  vmgm;
		DVDVTS			*	currentVTS;

	public:
		DVDVideoDisk(DVDDiskPlayerFactory * factory);
		virtual ~DVDVideoDisk(void);

		Error	Init(DVDFileSystem * diskfs, WORD parentalCountryCode);
		DVDMGM * GetMGM(void) { return (DVDMGM *)vmgm; }
		Error	GetTS(WORD num, DVDTS * & titleSet);
		Error	GetTSExclusive(WORD num, DVDTS * & titleSet, BOOL & deleteIt);
	};

//////////////////////////////////////////////////////////////////////
//
//  DVD Audio Disk Class
//
//	 Description:
//
//////////////////////////////////////////////////////////////////////

class DVDAudioDisk : public DVDDisk
	{
	protected:
		DVDAMGM			*  amgm;
		DVDATS			*	currentATS;

	public:
		DVDAudioDisk(DVDDiskPlayerFactory * factory);
		virtual ~DVDAudioDisk(void);

		Error	Init(DVDFileSystem * diskfs, WORD parentalCountryCode);
		DVDMGM * GetMGM(void) { return (DVDMGM *)amgm; }
		Error	GetTS(WORD num, DVDTS * & titleSet);
		Error	GetTSExclusive(WORD num, DVDTS * & titleSet, BOOL & deleteIt);
	};


#endif // DVDAVDISK_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDAVStreamServer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD Audio/Video Stream Server Classes
//
////////////////////////////////////////////////////////////////////


#include "DVDAVStreamServer.h"
#include "Library/Lowlevel/timer.h"
#include "DVDPlayer.h"


////////////////////////////////////////////////////////////////////
//
//  DVD Scattered Stream Buffer Class
//
////////////////////////////////////////////////////////////////////

class DVDScatteredStreamBuffer : public DVDStreamBuffer
	{
	protected:
		DriveBlock					*	blocks;
		DWORD							*	blockIndices;
		MPEGDataSizePair			*	buffers;
		RequestHandle					rh;

		DWORD								numBlocks;
		DVDDataFile					*	file;

		BYTE								dummyBlock[DVD_BLOCK_SIZE];

		DWORD WriteFromBuffer(DVDStreamPlayer * player, DWORD at, DWORD num);
		Error ReadIntoBuffer(DVDDataFile * file, DWORD block, DWORD at, DWORD num);
		void UnlockBuffers(DVDDataFile * file, DWORD at, DWORD num);

	public:
		DVDScatteredStreamBuffer(DWORD bufferSize);
		~DVDScatteredStreamBuffer(void);

		Error ChangeBufferSize(DWORD size);
		void Flush(void);

		Error ReadIntoBuffer(DVDDataFile * file, DVDEStdTimeAdaption * eStdAdaption, DWORD block, DWORD num); // in blocks
		DWORD WriteFromBuffer(DVDStreamPlayer * player, DWORD num); // in bytes

		Error TerminateRequest(void);
	};

//
//  Constructor
//

DVDScatteredStreamBuffer::DVDScatteredStreamBuffer(DWORD bufferSize) : DVDStreamBuffer(bufferSize)
	{
	int i;

	blocks = new DriveBlock[bufferSize];
	blockIndices = new DWORD[bufferSize];
	buffers = new MPEGDataSizePair[bufferSize];
	file = NULL;
	numBlocks = bufferSize;
	for (i=0; i<DVD_BLOCK_SIZE; i++)
		dummyBlock[i] = 0;
	}

//
//  Destructor
//

DVDScatteredStreamBuffer::~DVDScatteredStreamBuffer(void)
	{
	Flush();
	delete[] blocks;
	delete[] blockIndices;
	delete[] buffers;
	}

//
//  Change buffer size
//

Error DVDScatteredStreamBuffer::ChangeBufferSize(DWORD size)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Unlock buffers
//

void DVDScatteredStreamBuffer::UnlockBuffers(DVDDataFile * file, DWORD at, DWORD num)
	{
	DWORD i;

	while (num)
		{
		i = 1;
		while (i < num && blockIndices[at+i] == blockIndices[at] + i) i++;

		file->UnlockBlocks(blockIndices[at], i, blocks + at, DAF_STREAMING | DAT_UNLOCK_CLEAN, &rh);

		at += i;
		num -= i;
		}

//	DP("Unlock %x %d %08lx", blockIndices[at], num, err);
	}

//
//  Flush
//

void DVDScatteredStreamBuffer::Flush(void)
	{
	DWORD s, e;

	if (file)
		{
		s = bufferStart / DVD_BLOCK_SIZE;
		e = bufferEnd / DVD_BLOCK_SIZE;

		if (e < numBlocks)
			{
			UnlockBuffers(file, s, e - s);
			}
		else
			{
			UnlockBuffers(file, s, numBlocks - s);
			UnlockBuffers(file, 0, e - numBlocks);
			}

		file = NULL;
		}

	DVDStreamBuffer::Flush();
	}

//
//  Read into buffer (internal)
//

Error DVDScatteredStreamBuffer::ReadIntoBuffer(DVDDataFile * file, DWORD block, DWORD at, DWORD num)
	{
	Error err;
	int i;

	#ifdef DEVKIT
    if (at + num > numBlocks) {
        OutputDebugStringA("HEAP CORRUPTION ABOUT TO OCCUR: CONTACT TRACYSH\n");
        __asm int 3;
    }
    #endif

	err = file->LockBlocks(block, num, blocks + at, DAF_STREAMING | DAT_LOCK_AND_READ, &rh);

//	DP("Lock %x %d %08lx", block, num, err);

	//
	//  Now initialize buffers with drive blocks
	//  In case of errors replace blocks by dummy block
	//

	for (i=0; i<(int)num; i++)
		{
		if (IS_ERROR(blocks[at + i].err))
			blocks[at + i].data = dummyBlock;

		blockIndices[at + i] = block + i;
		buffers[at + i].data = blocks[at+i].data;
		buffers[at + i].size = DVD_BLOCK_SIZE;
		buffers[at + i].timeStamp = -1;
		}

	GNRAISE(err);
	}

//
//  Read into buffer
//

Error DVDScatteredStreamBuffer::ReadIntoBuffer(DVDDataFile * file, DVDEStdTimeAdaption * eStdAdaption, DWORD block, DWORD num)
	{
	DWORD tnum;
	int i;
	Error err0 = GNR_OK;
	Error err1 = GNR_OK;

	this->file = file;

#ifdef DEVKIT
if (bufferStart > bufferSize) {
    OutputDebugStringA("ReadIntoBuffer assertion #1: CONTACT TRACYSH\n");
    __asm int 3;
}
if (bufferEnd - bufferStart > bufferSize) {
    OutputDebugStringA("ReadIntoBuffer assertion #2: CONTACT TRACYSH\n");
    __asm int 3;
}
#endif


	//
	//  Read data from the end of the current data to the end of the buffer
	//  (Note: to prevent overwriting data at bufferStart num must be smaller
	//  than the number of blocks left)
	//

	if (bufferEnd < bufferSize)
		{
		tnum = (bufferSize - bufferEnd) / DVD_BLOCK_SIZE;
		if (tnum > num) tnum = num;

		err0 = ReadIntoBuffer(file, block, bufferEnd / DVD_BLOCK_SIZE, tnum);
		if (!IS_ERROR(err0))
			{
			for (i=0; i<(int)tnum; i++)
				eStdAdaption->ConvertToEStdTime(blocks[bufferEnd / DVD_BLOCK_SIZE + i].data, 1);
			}

		bufferEnd += tnum * DVD_BLOCK_SIZE;
		num -= tnum;
		block += tnum;
		}

	//
	//  If we still have to read data then we must perform a wraparound
	//

	if (num)
		{
		tnum = (bufferSize + bufferStart - bufferEnd) / DVD_BLOCK_SIZE;

		if (tnum > num) tnum = num;

		err1 = ReadIntoBuffer(file, block, (bufferEnd - bufferSize) / DVD_BLOCK_SIZE, tnum);
		if (!IS_ERROR(err1))
			{
			for (i=0; i<(int)tnum; i++)
				eStdAdaption->ConvertToEStdTime(blocks[(bufferEnd - bufferSize) / DVD_BLOCK_SIZE + i].data, 1);
			}

		bufferEnd += tnum * DVD_BLOCK_SIZE;
		num -= tnum;
		}

	if (bufferStart >= bufferSize)
		{
		bufferStart -= bufferSize;
		bufferEnd -= bufferSize;
		}

	if (err0 == GNR_OPERATION_ABORTED) err0 = GNR_OK;
	if (err1 == GNR_OPERATION_ABORTED) err1 = GNR_OK;

	if (err0) return err0;
	else return err1;
	}

//
//  Write from buffer to player
//

DWORD DVDScatteredStreamBuffer::WriteFromBuffer(DVDStreamPlayer * player, DWORD at, DWORD num)
	{
	DWORD done, blk, offset;
	RequestHandle rh;

	blk = at / DVD_BLOCK_SIZE;
	offset = at % DVD_BLOCK_SIZE;

	buffers[blk].data = blocks[blk].data + offset;
	buffers[blk].size = DVD_BLOCK_SIZE - offset;
	done = player->SendDataMultiple(buffers+blk, num);

	DWORD s = at / DVD_BLOCK_SIZE;
	DWORD e = (at + done) / DVD_BLOCK_SIZE;

	UnlockBuffers(file, s, e - s);
	availData -= (e - s) * DVD_BLOCK_SIZE;

	return done;
	}

//
//  Write from buffer
//  num must be smaller than the amount of data in the buffer
//

DWORD DVDScatteredStreamBuffer::WriteFromBuffer(DVDStreamPlayer * player, DWORD num)
	{
	DWORD tnum, done;

#ifdef DEVKIT
    static DWORD __bufferStart;
    static DWORD __bufferEnd;
    static DWORD __num;
    __bufferStart = bufferStart;
    __bufferEnd = bufferEnd;
    __num = num;
    if (bufferStart > bufferSize) {
        OutputDebugStringA("WriteFromBuffer assertion #1: CONTACT TRACYSH\n");
        __asm int 3;
    }
    if (bufferEnd - bufferStart > bufferSize) {
        OutputDebugStringA("WriteFromBuffer assertion #3: CONTACT TRACYSH\n");
        __asm int 3;
    }
    if (bufferEnd - bufferStart < num) {
        OutputDebugStringA("WriteFromBuffer assertion #5: CONTACT TRACYSH\n");
        __asm int 3;
    }
#endif



	if (bufferEnd <= bufferSize || bufferStart + num < bufferSize)
		{
		// single data block

		done = WriteFromBuffer(player, bufferStart, num);
		bufferStart += done;

#ifdef DEVKIT
        if (bufferStart > bufferSize) {
            OutputDebugStringA("WriteFromBuffer assertion #8: CONTACT TRACYSH\n");
            __asm int 3;
        }
#endif
		
		}
	else
		{
		// double data block, both needed

		tnum = bufferSize - bufferStart;

		if (tnum)
			{
			done = WriteFromBuffer(player, bufferStart, tnum);
			bufferStart += done;
			num -= done;
 #ifdef DEVKIT
            if (bufferStart > bufferSize) {
                OutputDebugStringA("WriteFromBuffer assertion #6: CONTACT TRACYSH\n");
                __asm mov eax, done;
                __asm mov ecx, tnum;
                __asm mov edx, num;
                __asm int 3;
            }
#endif

			}

		if (bufferStart == bufferSize)
			{
			bufferStart -= bufferSize;
			bufferEnd -= bufferSize;

			if (num && tnum == done)
				{
				done = WriteFromBuffer(player, bufferStart, num);
				bufferStart += done;
#ifdef DEVKIT
                if (bufferStart > bufferSize) {
                    OutputDebugStringA("WriteFromBuffer assertion #7: CONTACT TRACYSH\n");
                    __asm mov eax, done;
                    __asm mov ecx, tnum;
                    __asm mov edx, num;
                    __asm int 3;
                }
#endif
				
				}
			}
		}

//	DP("After send %d vs %d", bufferStart, bufferEnd);

#ifdef DEVKIT
if (bufferStart > bufferSize) {
    OutputDebugStringA("WriteFromBuffer assertion #2: CONTACT TRACYSH\n");
    __asm mov eax, done;
    __asm mov ecx, tnum;
    __asm mov edx, num;
    __asm int 3;
}
if (bufferEnd - bufferStart > bufferSize) {
    OutputDebugStringA("WriteFromBuffer assertion #4: CONTACT TRACYSH\n");
    __asm mov eax, done;
    __asm mov ecx, tnum;
    __asm mov edx, num;
    __asm int 3;
}
#endif



	GNRAISE_OK;
	}

Error DVDScatteredStreamBuffer::TerminateRequest(void)
	{
	if (file)
		return file->TerminateRequest(&rh);
	else
		GNRAISE_OK;
	}

//////////////////////////////////////////////////////////////////////
//
//  DVD Video Stream Server Class
//
//////////////////////////////////////////////////////////////////////

#define ANGLE_CHANGE_NONE 0
#define ANGLE_CHANGE_CELL 0x7fffffff

//
//  Constructor
//

DVDVideoStreamServer::DVDVideoStreamServer(DVDSequencer * seq, WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher)
	: DVDStreamServer(seq, server, units, pEventDispatcher)
	, EventSender(pEventDispatcher)
	{
	int i;

	for(i=0; i<NUM_VOBU_BUFFERS; i++)
		{
		vobus[i].succ = vobus + (i + 1) % NUM_VOBU_BUFFERS;
		}

	FlushBuffers();  // Initializes cell buffers

	transferSemaphore = 0;
	positionCache.valid = FALSE;
	}

//
//  Destructor
//

DVDVideoStreamServer::~DVDVideoStreamServer(void)
	{
	if (streamBuffer)
		{
		delete streamBuffer;
		streamBuffer = NULL;
		}
	}

//
//  Initialize
//

Error DVDVideoStreamServer::Init(DVDFileSystem * dvdfs)
	{
	DVDStreamServer::Init(dvdfs);

	this->dvdfs = dvdfs;
	player->SetRefiller(this);

	GNRAISE_OK;
	}

//
//  Test, if readingVOBU is the last VOBU of the cell
//

BOOL DVDVideoStreamServer::IsFinalVOBUOfCell(void)
	{
//	DP("************** FirstBlock %d FirstVOBU %d", transferingVOBU->firstBlock, transferingCell->info->LastVOBUStart());
	if (readingCell->scan == CST_REVERSEPLAYBACK)
		return readingVOBU->firstBlock == readingCell->info.FirstVOBUStart();
	else
		return readingVOBU->firstBlock == readingCell->info.LastVOBUStart();
	}

//
//  Adapt PTM Entry
//

static void AdaptPTMEntry(BYTE * data, DWORD ptsOffset)
	{
	DWORD ptm, ptm2;
	ptm = ((DWORD)(data[0]) << 23) |
		   ((DWORD)(data[1]) << 15) |
		   ((DWORD)(data[2]) <<  7) |
		   ((DWORD)(data[3]) >>  1);

	ptm2 = ptm;

	if (ptm < 0x7fffffff && ptm != 0)
		{
		ptm += ptsOffset;
		data[0] =                    (BYTE)((ptm >> 23) & 0xff);
		data[1] =                    (BYTE)((ptm >> 15) & 0xff);
		data[2] =                    (BYTE)((ptm >>  7) & 0xff);
		data[3] = (data[3] & 0x01) | (BYTE)((ptm <<  1) & 0xfe);
		}


	}

//
//  Convert to ESdt time
//

void DVDVideoStreamServer::ConvertToEStdTime(BYTE * data, int num)
	{
	}

//
//  Refill Buffer
//

Error DVDVideoStreamServer::RefillBuffer(BOOL prefetch)
	{
	int cnt = 0;
	int availDVDBlockSpaceInBuffer, numDVDBlocksTransfered;
	Error err;
	ERSBreakpoint bp;

	//
	//  Read Data from disk
	//

	availDVDBlockSpaceInBuffer = streamBuffer->AvailSpace() / DVD_BLOCK_SIZE;
	if (availDVDBlockSpaceInBuffer > 32) availDVDBlockSpaceInBuffer = 32;
	numDVDBlocksTransfered = 0;

	//
	// The stillPending condition prevents additional data from entering the
	// buffer if a VOBU with a still condition is complete inside the buffer
	//

	while (!stillPending && !suspendTransfer &&
		    availDVDBlockSpaceInBuffer &&
			 numDVDBlocksTransfered < 64 &&
			 (prefetch || streamBuffer->IsEmpty()) &&
			 (!stillMode || playingCell->scan != CST_TRICKPLAY))
		{
		cnt ++;
		if (cnt == 40)
			{
			BREAKPOINT;
			GNRAISE(GNR_RANGE_VIOLATION);
			}

		//
		// VOS_FREE
		//

		//
		// Check, whether there is no VOBU being read currently
		//
		if (readingVOBU->state == VOS_FREE)
			{
			//
			// If so, check if there is a cell available that can supply a new VOBU to read
			//
			predReadingVOBU = NULL;
			if (readingCell->state == VOS_FREE) GNRAISE_OK;

			//
			// Check, whether there is no Cell being read currently
			//
			if (readingCell->state == VOS_READY)
				{
				DWORD firstBlock;

				//
				// If so, start reading the next available cell
				//
				readingCell->state = VOS_READING;

				//
				//  Identify the position of the first VOBU in the cell based on playback direction
				//

				if (readingCell->scan == CST_SCANBACKWARD || readingCell->scan == CST_REVERSEPLAYBACK)
					firstBlock = readingCell->info.LastVOBUStart();
				else
					firstBlock = readingCell->info.FirstVOBUStart();

				//
				//  Prepare to read the first VOBU of this cell
				//  If this vobu is played in scan mode, only a single frame of it
				//  will be read and sent
				//

				firstFreeVOBU->Init(file, readingCell, firstBlock, readingCell->scan == CST_SCANFORWARD || readingCell->scan == CST_SCANBACKWARD);
				//
				// Check if there is a scanning offset in this cell
				//
				if (readingCell->scanStart)
					{
					if (readingCell->scan == CST_SCANFORWARD)
						{
						GNREASSERT_EVENT(firstFreeVOBU->ReadNavigationPack(), DNE_READ_ERROR, 0);
						firstFreeVOBU->firstBlock = firstFreeVOBU->NextTemporalVOBU(readingCell->scanStart);
						readingCell->firstScanVOBUTime = firstFreeVOBU->GetTimeOffset();
						readingCell->firstScanSystemTime = Timer.GetMilliTicks();
						}
					else if (transferingCell->scan == CST_SCANBACKWARD)
						{
						GNREASSERT_EVENT(firstFreeVOBU->ReadNavigationPack(), DNE_READ_ERROR, 0);
						firstFreeVOBU->firstBlock = firstFreeVOBU->PrevTemporalVOBU(readingCell->scanStart);
						readingCell->firstScanVOBUTime = firstFreeVOBU->GetTimeOffset();
						readingCell->firstScanSystemTime = Timer.GetMilliTicks();
						}
					}
				else
					{
					if (transferingCell->scan == CST_SCANFORWARD)
						{
						GNREASSERT_EVENT(firstFreeVOBU->ReadNavigationPack(), DNE_READ_ERROR, 0);
						readingCell->firstScanVOBUTime = firstFreeVOBU->GetTimeOffset();
						readingCell->firstScanSystemTime = Timer.GetMilliTicks();
						}
					else if (transferingCell->scan == CST_SCANBACKWARD)
						{
						GNREASSERT_EVENT(firstFreeVOBU->ReadNavigationPack(), DNE_READ_ERROR, 0);
						readingCell->firstScanVOBUTime = firstFreeVOBU->GetTimeOffset();
						readingCell->firstScanSystemTime = Timer.GetMilliTicks();
						}
					}

				//
				// Advance in the list of VOBUs
				//
				firstFreeVOBU = firstFreeVOBU->succ;

				}
			}

		//
		// VOS_READY
		//

		//
		// Check if we start to read a new VOBU
		//
		if (readingVOBU->state == VOS_READY)
			{
			//
			// If so, check if there are additional VOBU buffers available,
			// and if not, don't start reading
			//
			if (firstFreeVOBU->state != VOS_FREE) 
			    {

                //
                // This is a workaround for the bug where the signal gets lost somewhere,
                // the player callback never gets called and the VOBUs never get released.
                // This is not the correct fix but it should get things going again.
                //
                
                player->SetCallback(playingVOBU->endTransferCount, this);
                
			    GNRAISE_OK;
			    }

			//
			// Set this VOBU to reading state
			//
			predReadingVOBU = readingVOBU;
			readingVOBU->state = VOS_READING;

			//
			//  Read nav pack of VOBU
			//
			err = readingVOBU->ReadNavigationPack();

			if (IS_ERROR(err))
				{
				if (err == GNR_FILE_READ_ERROR)
					{
					//
					//  In case of error find next nav pack within cell
					//

					SendEvent(DNE_READ_ERROR, 0);
					if (IS_ERROR(err = readingVOBU->FindNextNavigationPack(readingCell->info.LastVOBUStart(), sequencer->CurrentAngle(), suspendTransfer)))
						{

						SendEvent(DNE_READ_ERROR, 0);
						if (err == GNR_RANGE_VIOLATION)
							{
							inTransfer = FALSE;
							SendCellCorrupt(readingCell);
							GNRAISE_OK;
//							readingVOBU->Init(file, readingCell, readingCell->info.LastVOBUStart(), readingCell->scan == CST_SCANFORWARD || readingCell->scan == CST_SCANBACKWARD);
//							readingVOBU->numBlocks = 1;
//							readingVOBU->state = VOS_READING;
							}
						else if (err == GNR_OPERATION_ABORTED)
							{
							readingVOBU->state = VOS_READY;
							continue;
							}
						else
							{
							readingVOBU->state = VOS_READY;

							GNRAISE(err);
							}
						}
					}
				else if (err == GNR_OPERATION_ABORTED)
					{
					readingVOBU->state = VOS_READY;
					continue;
					}
				else
					{
					readingVOBU->state = VOS_READY;

					GNRAISE(err);
					}
				}

			//
			// Calculate transfer positions in stream block numbers for this VOBU
			//
			readingVOBU->startReadCount = currentReadCount;
			readingVOBU->endReadCount = currentReadCount + readingVOBU->numBlocks;


//			DP("Transfering blocks %08lx-%08lx", transferingVOBU->firstBlock, transferingVOBU->firstBlock + transferingVOBU->numBlocks);
//			DP("Starting transfer of %d-%d", transferingVOBU->startTransferCount, transferingVOBU->endTransferCount);

			if (readingCell->scan == CST_TRICKPLAY)
				{
				readingVOBU->final = FALSE;
				if (readingVOBU->firstBlock == readingVOBU->cell->info.FirstVOBUStart())
					player->SetFirstAvailableVOBUID(currentVOBUID);
				if (readingVOBU->firstBlock == readingVOBU->cell->info.LastVOBUStart())
					player->SetLastAvailableVOBUID(currentVOBUID);
				}
			else
				{
				readingVOBU->final = FALSE;

				//
				// Check if we are in scanning mode
				//
				if (readingVOBU->singleFrame)
					{
					DWORD firstBlock;

					//
					// If so...
					//
					if (readingCell->scan == CST_SCANFORWARD)
						{
						int timeSkip;
						int timeDist;

						if (!readEveryVOBU)
							{
							//
							// Calculate VOBU offset for a given scan speed in forward scan
							//

							timeDist = (readingVOBU->GetTimeOffset() - readingCell->firstScanVOBUTime).Millisecs();
							timeSkip = Timer.GetMilliTicks() - readingCell->firstScanSystemTime;

							timeDist = (timeSkip * readingVOBU->cell->scanStep - timeDist);	// Delta between "should be" and "real" position

							if (timeDist < 0)
								timeDist = -1;

							if (sequencer->BreakpointContained((readingVOBU->cell->presentationTime + readingVOBU->GetTimeOffset()).Millisecs(),
								timeDist, TRUE, playbackDir, bp))
								{
								timeDist = 0;
								readEveryVOBU = TRUE;
								}
							}
						else
							timeDist = 0;

						if (timeDist < 0)
							firstBlock = readingVOBU->firstBlock;
						else
							firstBlock = readingVOBU->NextTemporalVOBU(timeDist / 500);
						}
					else if (readingCell->scan == CST_SCANBACKWARD)
						{
						int timeSkip;
						int timeDist;

						if (!readEveryVOBU)
							{
							//
							// Calculate VOBU offset for a given scan speed in forward scan
							//

							timeDist = (readingCell->firstScanVOBUTime - readingVOBU->GetTimeOffset()).Millisecs();
							timeSkip = Timer.GetMilliTicks() - readingCell->firstScanSystemTime;

							timeDist = (timeSkip * readingVOBU->cell->scanStep - timeDist);	// Delta between "should be" and "real" position

							if (timeDist < 0)
								timeDist = -1;

							if (sequencer->BreakpointContained((readingVOBU->cell->presentationTime + readingVOBU->GetTimeOffset()).Millisecs() - timeDist,
								timeDist, FALSE, playbackDir, bp))
								{
								timeDist = 0;
								readEveryVOBU = TRUE;
								}
							}
						else
							timeDist = 0;

						if (timeDist < 0)
							firstBlock = readingVOBU->firstBlock;
						else
							firstBlock = readingVOBU->PrevTemporalVOBU(timeDist / 500);
						}

					//
					// Check if the currently read VOBU is the last in the cell while scanning
					//
					if (firstBlock == 0x3fffffff)
						{
						//
						// If so, mark it as final
						//
						readingVOBU->final = TRUE;
						}
					else
						{
						//
						// If not, initialize the next VOBU
						//

						firstFreeVOBU->Init(file, readingVOBU->cell, firstBlock, TRUE);
						firstFreeVOBU = firstFreeVOBU->succ;
						}
					}
				else
					{
					//
					// We are not in scanning mode
					// Check if the current VOBU is not the last one of the cell
					//
					if (!IsFinalVOBUOfCell())
						{
						//
						// If this is the case, initialize the next VOBU (startBlock is done below)
						//

						firstFreeVOBU->Init(file, readingVOBU->cell, 0, FALSE);

						//
						// Check if there is a angle change request and the current VOBU is the last
						// one of the ILVU
						//
						if (angleChangeRequest && readingVOBU->IsLastVOBUinILVU())
							{
							//
							// If so, move to the new angle
							//
							firstFreeVOBU->firstBlock = readingVOBU->SeamlessAngleChangeVOBU(angleChangeRequest);
							angleChangeVOBU = firstFreeVOBU->firstBlock;
							angleChangeAngle = angleChangeRequest;
							angleChangeRequest = 0;
							if (firstFreeVOBU->firstBlock == 0x7fffffff)
								firstFreeVOBU->firstBlock = readingVOBU->NextVOBU();
							}
						else
							{
							//
							// If no pending angle change, just pick the next VOBU based on playback direction
							//
							if (readingCell->scan == CST_REVERSEPLAYBACK)
								firstFreeVOBU->firstBlock = readingVOBU->PrevVOBU();
							else
								firstFreeVOBU->firstBlock = readingVOBU->NextVOBU();

							if (angleChangeRequest)
								{
								angleChangeVOBU = firstFreeVOBU->firstBlock;
								angleChangeAngle = angleChangeRequest;
								}
							}
	//					DP("Preparing transfer of %d", firstFreeVOBU->firstBlock);
						firstFreeVOBU = firstFreeVOBU->succ;
						}
					else
						{
						//
						// If this is the final VOBU of the cell, mark it so
						//
						readingVOBU->final = TRUE;
						}
					}
				}


			//
			// Set read position and size
			//
			nextVOBUBlock = readingVOBU->firstBlock;
			numVOBUBlocks = readingVOBU->numBlocks;
			}

		//
		// Check if there is a VOBU to read from
		//
		if (readingVOBU->state & VOS_READING)
			{
			//
			// And there is still data inside this VOBU which is not yet read
			//
			if (numVOBUBlocks)
				{
				//
				// Check if there is more data inside the VOBU than what would fit into the buffer
				//
				if (numVOBUBlocks > (DWORD)availDVDBlockSpaceInBuffer)
					{
					//
					// If so, just fill the buffer
					//
					if (IS_ERROR(err = streamBuffer->ReadIntoBuffer(file, this, nextVOBUBlock, availDVDBlockSpaceInBuffer)))
						{
						SendEvent(DNE_READ_ERROR, 0);

						if (err != GNR_FILE_READ_ERROR)
							GNRAISE(err);
						else
							err = GNR_OK;
						}

					//
					// Update the buffer levels and read positions
					//
					currentReadCount += availDVDBlockSpaceInBuffer;
					nextVOBUBlock += availDVDBlockSpaceInBuffer;
					numDVDBlocksTransfered += availDVDBlockSpaceInBuffer;
					numVOBUBlocks -= availDVDBlockSpaceInBuffer;
					finalBuffer = FALSE;
					}
				else
					{
					//
					// If the VOBU data fits into the buffer,
					// read all the data into the buffer
					//
					if (IS_ERROR(err = streamBuffer->ReadIntoBuffer(file, this, nextVOBUBlock, numVOBUBlocks)))
						{
						SendEvent(DNE_READ_ERROR, 0);

						if (err != GNR_FILE_READ_ERROR)
							GNRAISE(err);
						else
							err = GNR_OK;
						}

//					DP("Transfering final");

					//
					// Update the buffer levels and read positions
					//
					numDVDBlocksTransfered += numVOBUBlocks;
					currentReadCount += numVOBUBlocks;
					nextVOBUBlock += numVOBUBlocks;
					numVOBUBlocks = 0;

					//
					// Set flag, that is will be the final buffer of this VOBU
					//
					finalBuffer = TRUE;

					//
					// remove the reading attribute from the current VOBU state
					//
					readingVOBU->state &= ~VOS_READING;
					readingVOBU->state |= VOS_READCOMPLETE;

					if (readingVOBU->singleFrame || readingCell->scan == CST_TRICKPLAY)
						{
						stillPending = TRUE;
						}
					else if (readingCell->info.ContinuousPresentation())
						{
						readingVOBU->still = TRUE;
						stillPending = TRUE;
						}

					//
					// If this is the final VOBU of the cell
					//
					if (readingVOBU->final)
						{
						//
						// Finish reading of the cell
						//
						readingCell->state &= ~VOS_READING;
						readingCell->state |= VOS_READCOMPLETE;

//						DP("VOBU final of cell %08lx", readingCell);
						if (readingCell->still)
							{
//							DP("Reading cell is still");
							stillPending = TRUE;
							}

						readingCell = readingCell->succ;
						}

					readingVOBU = readingVOBU->succ;
					}
				}
			else
				{
				//
				// Set flag, that is will be the final buffer of this VOBU
				//
				finalBuffer = TRUE;

				//
				// remove the reading attribute from the current VOBU state
				//
				readingVOBU->state &= ~VOS_READING;
				readingVOBU->state |= VOS_READCOMPLETE;

				if (readingVOBU->singleFrame || readingCell->scan == CST_TRICKPLAY)
					{
					stillPending = TRUE;
					}
				else if (readingCell->info.ContinuousPresentation())
					{
					readingVOBU->still = TRUE;
					stillPending = TRUE;
					}

				//
				// If this is the final VOBU of the cell
				//
				if (readingVOBU->final)
					{
					//
					// Finish reading of the cell
					//
					readingCell->state &= ~VOS_READING;
					readingCell->state |= VOS_READCOMPLETE;

//						DP("VOBU final of cell %08lx", readingCell);
					if (readingCell->still)
						{
//							DP("Reading cell is still");
						stillPending = TRUE;
						}

					readingCell = readingCell->succ;
					}

				readingVOBU = readingVOBU->succ;
				}
			}

		availDVDBlockSpaceInBuffer = streamBuffer->AvailSpace() / DVD_BLOCK_SIZE;
		if (availDVDBlockSpaceInBuffer > 32) availDVDBlockSpaceInBuffer = 32;
		}

	GNRAISE_OK;
	}

//
//  Send buffer to player
//

Error DVDVideoStreamServer::SendBuffer(void)
	{
	DWORD done, num;

	if (!stillMode || playRequest)
		{
		//
		//  Send as much data as we have or as much as the decoder wants
		//

		do {
			//
			//  Look for transfering cell
			//

			if (!(transferingCell->state & VOS_TRANSFERING))
				{
				if (transferingCell->state & (VOS_READING | VOS_READCOMPLETE))
					{
					transferingCell->state |= VOS_TRANSFERING;

					if (transferingCell == playingCell)
						{
						playingCell->state |= VOS_PLAYING;
						SendCellStarted(playingCell);
						}
					}
				else
					GNRAISE_OK;
				}

			//
			//  Look for transfering VOBU
			//

			if (!(transferingVOBU->state & VOS_TRANSFERING))
				{
				if (transferingVOBU->state & (VOS_READING | VOS_READCOMPLETE))
					{
					transferingVOBU->state |= VOS_TRANSFERING;

					transferingVOBU->startTransferCount = player->transferCount;
					transferingVOBU->endTransferCount   = transferingVOBU->startTransferCount + transferingVOBU->numBlocks;

//					DP("*** Mark VOBU from %08lx to %08lx", transferingVOBU->startTransferCount, transferingVOBU->endTransferCount);

					}
				else
					GNRAISE_OK;
				}

			//
			//  Transfer Data
			//

			num = (transferingVOBU->endTransferCount - player->transferCount) * DVD_BLOCK_SIZE - player->transferCountRemainder;
//			DP("*** Num is %08lx buffer %08lx", num, streamBuffer->AvailData());
			if (num > streamBuffer->AvailData()) num = streamBuffer->AvailData();

			if (transferingVOBU == playingVOBU && !(playingVOBU->state & VOS_PLAYING))
				{
				playingVOBU->state |= VOS_PLAYING;

				SendVOBUStarted(playingVOBU);
				player->SetTimeBase(playingVOBU->GetTimeOffset() + playingVOBU->cell->presentationTime);

//				DP("*** First Set Signal at %08lx %x %d", playingVOBU->endTransferCount, playingVOBU->state, playingVOBU->singleFrame);
				if (playingVOBU->singleFrame)
					player->SetCallback(0x3fffffff, this);
				else
					player->SetCallback(playingVOBU->endTransferCount, this);
				}

//			DP("*** Check VOBU till %08lx at %08lx", transferingVOBU->endTransferCount, player->transferCount);

			done = streamBuffer->WriteFromBuffer(player, num);

			//
			// If all data of a VOBU has been transfered go to next cell/vobu
			//
			if (player->transferCount >= transferingVOBU->endTransferCount)
				{
				transferingVOBU->state &= ~VOS_TRANSFERING;
				transferingVOBU->state |= VOS_TRANSFERCOMPLETE;

				if (transferingVOBU->final)
					{
					transferingCell->state &= ~VOS_TRANSFERING;
					transferingCell->state |= VOS_TRANSFERCOMPLETE;

					transferingCell = transferingCell->succ;
					}

				transferingVOBU = transferingVOBU->succ;
				}
			} while (done && !(streamBuffer->IsEmpty()));
		}

//	DP("SB %d %d %d", BufferEmpty(), finalBuffer, stillPending);

	//
	//  If buffer is empty and it is the last one before still, complete data
	//

	if (streamBuffer->IsEmpty() && finalBuffer && stillPending)
		{
//		DP("Buffer finished");
		player->CompleteData();
		stillMode = TRUE;
		stillPending = FALSE;
		finalBuffer = FALSE;
		endPTM = 0;
		ptsOffset = 22500;
		}

	GNRAISE_OK;
	}

//
//  Flush Buffers
//

Error DVDVideoStreamServer::FlushBuffers(void)
	{
	int i;

	for(i=0; i<NUM_VOBU_BUFFERS; i++)
		{
		vobus[i].Cleanup();
		}

	firstFreeVOBU = readingVOBU = transferingVOBU = playingVOBU = vobus;

	for(i=0; i<NUM_CELL_BUFFERS; i++)
		{
		cells[i].state = VOS_FREE;
		}

	firstFreeCell = readingCell = transferingCell = playingCell = cells;

	if (streamBuffer) streamBuffer->Flush();
	numVOBUBlocks = 0;

	stillMode = FALSE;
	stillPending = FALSE;
	finalBuffer = FALSE;
	playRequest = TRUE;
	inTransfer = FALSE;
	suspendTransfer = FALSE;

	callbackSemaphore	= FALSE;
	angleChangeRequest = 0;
	angleChangeVOBU = ANGLE_CHANGE_NONE;

	readEveryVOBU = FALSE;
	stopAfterNextVOBU = FALSE;

	endPTM = 0;
	ptsOffset = 22500;

	currentReadCount = 0;

	FlushMessages();

	GNRAISE_OK;
	}

//
//  Message sending functions
//

#define MSG_VOBU_STARTED			0x2000
#define MSG_VOBU_COMPLETED			0x2001
#define MSG_CELL_STARTED			0x2002
#define MSG_CELL_COMPLETED			0x2003
#define MSG_PLAYBACK_TERMINATED	0x2004
#define MSG_CELL_CORRUPT			0x2005

Error DVDVideoStreamServer::SendPlaybackTerminated(Error err)
	{
	SendMessage(MSG_PLAYBACK_TERMINATED, (DWORD)err);

	GNRAISE_OK;
	}

Error DVDVideoStreamServer::SendVOBUStarted(DVDVOBU * vobu)
	{
	WORD w;

	w = vobu->GetPCIWord(4);

	player->SetAnalogCopyProtectionMode(XTBFW(14, 2, w));

	SendMessage(MSG_VOBU_STARTED, (DWORD)vobu);

	//
	//  Send Angle Change Event
	//

	if (angleChangeVOBU == vobu->firstBlock)
		{
		SendEvent(DNE_ANGLE_CHANGE, angleChangeAngle);
		angleChangeVOBU = ANGLE_CHANGE_NONE;
		sequencer->AngleChanged();
		}

	GNRAISE_OK;
	}

Error DVDVideoStreamServer::SendVOBUCompleted(DVDVOBU * vobu)
	{
	SendMessage(MSG_VOBU_COMPLETED, (DWORD)vobu);

	GNRAISE_OK;
	}

Error DVDVideoStreamServer::SendCellStarted(DVDCell * cell)
	{
	if (playbackDir == EPD_FORWARD)
		sequencer->BeginOfCellBreakpointReached(cell, EPD_FORWARD, cell->breakpoint);

	SendMessage(MSG_CELL_STARTED, (DWORD)cell);
	if (angleChangeVOBU == ANGLE_CHANGE_CELL)
		{
		SendEvent(DNE_ANGLE_CHANGE, angleChangeAngle);
		angleChangeVOBU = ANGLE_CHANGE_NONE;
		sequencer->AngleChanged();
		}

	GNRAISE_OK;
	}

Error DVDVideoStreamServer::SendCellCompleted(DVDCell * cell)
	{
	SendMessage(MSG_CELL_COMPLETED, (DWORD)cell);

	GNRAISE_OK;
	}

Error DVDVideoStreamServer::SendCellCorrupt(DVDCell * cell)
	{
	SendMessage(MSG_CELL_CORRUPT, (DWORD)cell);

	GNRAISE_OK;
	}

void DVDVideoStreamServer::Message(WPARAM wParam, LPARAM dParam)
	{
	switch (wParam)
		{
		case MSG_VOBU_STARTED:
			sequencer->VOBUStarted((DVDVOBU *)dParam);
			break;
		case MSG_VOBU_COMPLETED:
			sequencer->VOBUCompleted((DVDVOBU *)dParam);
			break;
		case MSG_CELL_STARTED:
			sequencer->CellStarted((DVDCell *)dParam);
			break;
		case MSG_CELL_COMPLETED:
			sequencer->CellCompleted((DVDCell *)dParam);
			break;
		case MSG_CELL_CORRUPT:
			sequencer->CellCorrupt((DVDCell *)dParam);
			break;
		case MSG_PLAYBACK_TERMINATED:
			sequencer->PlaybackTerminated((Error)dParam);
			break;
		}
	}

//
//  Advance trick mode
//

// TO BE DONE
Error DVDVideoStreamServer::AdvanceTrickMode(void)
	{
	DWORD req;
	DVDVOBU	*	prevVOBU;
	DWORD finalBlock;

	req = player->GetRequestedVOBUID();

	if (currentVOBUID != req && (playingCell->state & VOS_PLAYING))
		{
		firstFreeVOBU->singleFrame = FALSE;

		prevVOBU = playingVOBU;

		if (req < currentVOBUID)
			finalBlock = playingCell->info.FirstVOBUStart();
		else
			finalBlock = playingCell->info.LastVOBUStart();

		while (req != currentVOBUID)
			{
			if (prevVOBU->firstBlock == finalBlock)
				{
				DP("############# HELP ################\n");

				GNRAISE_OK;
				}
			else
				{
				if (req < currentVOBUID)
					{
					firstFreeVOBU->Init(file, playingCell, prevVOBU->PrevVOBU(), FALSE);

//					firstFreeVOBU->firstBlock = prevVOBU->PrevVOBU();
					if (IS_ERROR(firstFreeVOBU->ReadNavigationPack()))
						SendEvent(DNE_READ_ERROR, 0);
					prevVOBU = firstFreeVOBU;
					currentVOBUID--;
					}
				else
					{
					firstFreeVOBU->Init(file, playingCell, prevVOBU->NextVOBU(), FALSE);

//					firstFreeVOBU->firstBlock = prevVOBU->NextVOBU();
					if (IS_ERROR(firstFreeVOBU->ReadNavigationPack()))
						SendEvent(DNE_READ_ERROR, 0);
					prevVOBU = firstFreeVOBU;
					currentVOBUID++;
					}
				}
			}

		playingVOBU->state = VOS_PLAYCOMPLETED;
		playingVOBU->breakpoint = ERSBreakpoint();
		SendVOBUCompleted(playingVOBU);

//		firstFreeVOBU->Init(file, playingVOBU->cell, 0, FALSE);

		firstFreeVOBU = firstFreeVOBU->succ;

		playingVOBU = playingVOBU->succ;

		stillMode = FALSE;
		}

	GNRAISE_OK;
	}

//
//  Perform Cell Transfer
//

Error DVDVideoStreamServer::PerformTransfer(int maxTransfer)
	{
	int transfer;
	Error error;

	transfer = maxTransfer;
	while (transfer && !suspendTransfer)
		{
		lock.Enter();

		transfer--;

		if (inTransfer && !suspendTransfer)
			{
			if (transferingCell->scan == CST_TRICKPLAY)
				{
				if (stillMode) AdvanceTrickMode();
				}

			if (!stillMode || player->Completed())
				{
				SendBuffer();
				if (streamBuffer->IsEmpty())
					{
					if (IS_ERROR(error = RefillBuffer(TRUE)))
						{
						if (error != GNR_OPERATION_ABORTED)
							{
							player->TerminatePlayback();
							SendPlaybackTerminated(error);
							}

						lock.Leave();

						GNRAISE(error);
						}

					if (streamBuffer->IsEmpty())
						{
						transfer = 0;
						}
					}
				else
					{
					transfer = 0;
					RefillBuffer(TRUE);
					}
				}
			else
				transfer = 0;
			}
		else
			transfer = 0;

		lock.Leave();
		}

	GNRAISE_OK;
	}

//
//  Transfer cell and start at certain time
//

Error DVDVideoStreamServer::TransferCellAt(DVDGenericPGCI * pgci, WORD num, BOOL still, BOOL final, DVDTime presentationTime, DVDTime time)
	{
	DWORD prev, next;
	DVDTime vtime;
	Error err;
	VDAutoMutex	mutex(&lock);

	// solves the problem that some discs (e.g. Shanghai Noon, Blue Streak) hangs when Title Repeat is executed!
	// 02/02/01 (MST)
	FlushBuffers();

	player->SetReversePlayback(FALSE);
	player->SetStillFrameSequenceMode(FALSE);
	playbackDir = EPD_FORWARD;

	//
	// Check if we have space
	//

	if (firstFreeCell->state == VOS_FREE)
		{
		firstFreeCell->presentationTime = presentationTime;
		firstFreeCell->state = VOS_READY;
		GNREASSERT(pgci->GetCellInformation(num, firstFreeCell->info));
		firstFreeCell->pgci = pgci;
		firstFreeCell->num = num;
		firstFreeCell->still = still || firstFreeCell->info.StillTime() ||
		                       firstFreeCell->info.CommandNumber() ||
									  firstFreeCell->info.ContinuousPresentation() ||
									  firstFreeCell->info.LastVOBUStart() == firstFreeCell->info.LastVOBUEnd();

		firstFreeCell->final = final;

		firstFreeCell->scan = CST_PLAYBACK;
		firstFreeCell->breakpoint = ERSBreakpoint();
		firstFreeCell = firstFreeCell->succ;

		// TO BE DONE
		readingCell->state = VOS_READING;

		//
		//  Read first VOBU, or the one from cache
		//

		if (positionCache.valid && num == positionCache.cell && time == positionCache.time &&
			 pgci->GetID() == positionCache.pgciID)
			{
			firstFreeVOBU->Init(file, transferingCell, positionCache.firstBlock, FALSE);
			}
		else
			{
			firstFreeVOBU->Init(file, transferingCell, transferingCell->info.FirstVOBUStart(), FALSE);
			positionCache.valid = FALSE;
			}

		if (IS_ERROR(err = firstFreeVOBU->ReadNavigationPack()))
			{
                if (IS_ERROR(err = firstFreeVOBU->ReadNavigationPack()))
    				{
    				SendEvent(DNE_READ_ERROR, 0);

    				GNRAISE(err);
    				}
			}

		if (!positionCache.valid)
			{
			//
			//  Search for suitable VOBU (with proper presentation time)
			//

			prev = firstFreeVOBU->firstBlock;

			for(;;)
				{
				if (firstFreeVOBU->firstBlock == readingCell->info.LastVOBUStart()) break;
				vtime = firstFreeVOBU->GetTimeOffset();
				if (vtime >= time) break;

				prev = firstFreeVOBU->firstBlock;
				vtime = time - vtime;

				next = firstFreeVOBU->NextLowerTemporalVOBU((WORD)(vtime.Millisecs() / 500));
				if (next != 0x3fffffff)
					firstFreeVOBU->firstBlock = next;
				else
					firstFreeVOBU->firstBlock = firstFreeVOBU->NextVOBU();

				if (next == prev)
					break;

				GNREASSERT_EVENT(firstFreeVOBU->ReadNavigationPack(), DNE_READ_ERROR, 0);
				}

			if (firstFreeVOBU->GetTimeOffset() > time)
				{
				firstFreeVOBU->firstBlock = prev;
				GNREASSERT_EVENT(firstFreeVOBU->ReadNavigationPack(), DNE_READ_ERROR, 0);
				}

			//
			//  Search backwards for VOBU with video data
			//

			if (!firstFreeVOBU->HasVideoData())
				{
				firstFreeVOBU->firstBlock = firstFreeVOBU->PrevVOBU();
				if (firstFreeVOBU->firstBlock == 0x3fffffff)
					{
					firstFreeVOBU->firstBlock = transferingCell->info.FirstVOBUStart();
					}
				GNREASSERT_EVENT(firstFreeVOBU->ReadNavigationPack(), DNE_READ_ERROR, 0);
				}
			}

		//
		//  We found a VOBU, so let's save the information
		//

		positionCache.valid = TRUE;
		positionCache.cell = num;
		positionCache.time = time;
		positionCache.pgciID = pgci->GetID();
		positionCache.firstBlock = firstFreeVOBU->firstBlock;
//		DP("ID is %d", positionCache.pgciID);

		firstFreeVOBU = firstFreeVOBU->succ;

//		SendCellStarted(playingCell);

		if (!inTransfer)
			{
			inTransfer = TRUE;
			PerformTransfer(16);
			}

		if (playRequest)
			{
			player->StartPlayback();
			playRequest = FALSE;
			}

		GNRAISE_OK;
		}
	else
		{
		GNRAISE(GNR_OBJECT_FULL);
		}
	}

//
//  Transfer Cell
//

Error DVDVideoStreamServer::TransferCell(DVDGenericPGCI * pgci, WORD num, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu, WORD angle)
	{
	WORD cn;
	Error err;
	VDAutoMutex	mutex(&lock);

	if (!file) GNRAISE(GNR_OBJECT_NOT_FOUND);

	player->SetReversePlayback(FALSE);  // No reverse playback
	playbackDir = EPD_FORWARD;

	if (firstFreeCell->state == VOS_FREE)  // Check if a cell is free
		{
		DP("TransferCell %08lx %d Angle %d", firstFreeCell, num, angle);
		firstFreeCell->presentationTime = presentationTime;
		firstFreeCell->state = VOS_READY;
		GNREASSERT(pgci->GetCellInformation(num, firstFreeCell->info));
		firstFreeCell->pgci = pgci;

		//
		//  Find cell for requested angle
		//

		if (angle)
			{
			if (firstFreeCell->info.BlockType() == CBT_ANGLE_BLOCK)
				{
				while (firstFreeCell->info.BlockMode() != CBM_FIRST_CELL_IN_BLOCK)
					{
					num--;
					GNREASSERT(pgci->GetCellInformation(num, firstFreeCell->info));
					}
				cn = 1;
				while (firstFreeCell->info.BlockMode() != CBM_LAST_CELL_IN_BLOCK && cn < angle)
					{
					cn++;
					num++;
					GNREASSERT(pgci->GetCellInformation(num, firstFreeCell->info));
					}
				}
			else
				angle = 0;
			}

		firstFreeCell->num = num;
		firstFreeCell->still = still || firstFreeCell->info.StillTime() ||
		                       firstFreeCell->info.CommandNumber() ||
									  firstFreeCell->info.ContinuousPresentation() ||
									  firstFreeCell->info.LastVOBUStart() == firstFreeCell->info.LastVOBUEnd();

		firstFreeCell->final = final;

		if (firstFreeCell == playingCell)
			{
			player->SetStillFrameSequenceMode(firstFreeCell->info.StillTime() &&
				                               firstFreeCell->info.FirstVOBUStart() == firstFreeCell->info.LastVOBUStart());
			}

		firstFreeCell->scan = CST_PLAYBACK;
		firstFreeCell->breakpoint = ERSBreakpoint();

		firstFreeCell = firstFreeCell->succ;

		//
		//  Read the requested VOBU
		//

		if (vobu)
			{
			readingCell->state = VOS_READING;// | VOS_TRANSFERING | VOS_PLAYING;

			firstFreeVOBU->Init(file, readingCell, vobu, FALSE);
// Does not work, because NVPCK has not been read into the buffer
// yet.  We don't want to read the NVPCK in yet, because this would
// delay navigation.  Time base will be set, as soon as NVPCK is read
// by the pumping thread.
//			player->SetTimeBase(firstFreeVOBU->GetTimeOffset() + firstFreeVOBU->cell->presentationTime);

			//
			//  Perform angle change
			//

			if (angle)
				{
				//
				//  Read Nav Pack
				//

				if (IS_ERROR(err = firstFreeVOBU->ReadNavigationPack()))
					{
					SendEvent(DNE_READ_ERROR, 0);
					GNRAISE(err);
					}

				//
				//  Perform Angle Change
				//

				if (readingCell->info.SeamlessAngleChange())
					{
					//
					//  Perform Seamless Angle Change
					//

					vobu = firstFreeVOBU->SeamlessAngleChangeVOBU(angle);
					if (vobu)
						{
						angleChangeVOBU = vobu;
						angleChangeAngle = angle;
						if (firstFreeVOBU->IsLastVOBUinILVU())
							{
							if (vobu != 0x7fffffff)
								firstFreeVOBU->firstBlock = vobu;
							}
						else
							{
							angleChangeRequest = angle;
							}
						}
					}
				else
					{
					//
					//  Perform Non Seamless Angle Change
					//

					vobu = firstFreeVOBU->NonSeamlessAngleChangeVOBU(angle);
					if (vobu)
						{
						firstFreeVOBU->firstBlock = vobu;
						angleChangeVOBU = vobu;
						angleChangeAngle = angle;
						}
					}
				}

			firstFreeVOBU = firstFreeVOBU->succ;
			}

		DP("Before enabled transfer");
		if (!inTransfer)
			{
			inTransfer = TRUE;
//			PerformTransfer(16);
			}

		DP("Before play starts");
		if (playRequest)
			{
			player->StartPlayback();
			playRequest = FALSE;
			}
		DP("Done starting CELL");

		GNRAISE_OK;
		}
	else
		{
		GNRAISE(GNR_OBJECT_FULL);
		}
	}

//
//  Transfer cell in scan mode
//

Error DVDVideoStreamServer::TransferCellScan(DVDGenericPGCI * pgci, WORD cell, BOOL still, BOOL final, DVDTime presentationTime, BOOL forward, WORD first, WORD skip, DWORD vobu)
	{
	VDAutoMutex mutex(&lock);
	Error err;

	if (!file) GNRAISE(GNR_OBJECT_NOT_FOUND);

	player->SetStillFrameSequenceMode(FALSE);
	player->SetReversePlayback(FALSE);
	playbackDir = forward ? EPD_FORWARD : EPD_BACKWARD;

	if (firstFreeCell->state == VOS_FREE)
		{
		firstFreeCell->presentationTime = presentationTime;
		firstFreeCell->state = VOS_READY;
		GNREASSERT(pgci->GetCellInformation(cell, firstFreeCell->info));
		firstFreeCell->pgci = pgci;
		firstFreeCell->num = cell;
		firstFreeCell->still = still || firstFreeCell->info.StillTime() ||
									  firstFreeCell->info.ContinuousPresentation() ||
									  firstFreeCell->info.LastVOBUStart() == firstFreeCell->info.LastVOBUEnd();

		firstFreeCell->final = final;

		firstFreeCell->scan = forward ? CST_SCANFORWARD : CST_SCANBACKWARD;
		firstFreeCell->scanStart = first;
		firstFreeCell->scanStep = skip;
		firstFreeCell->breakpoint = ERSBreakpoint();
		firstFreeCell = firstFreeCell->succ;

		if (vobu)
			{
			readingCell->state = VOS_READING;

			firstFreeVOBU->Init(file, readingCell, vobu, TRUE);

			if (IS_ERROR(err = firstFreeVOBU->ReadNavigationPack()))
				{
				SendEvent(DNE_READ_ERROR, 0);
				GNRAISE(err);
				}

			readingCell->firstScanVOBUTime = firstFreeVOBU->GetTimeOffset();
			readingCell->firstScanSystemTime = Timer.GetMilliTicks();

			firstFreeVOBU = firstFreeVOBU->succ;

//			SendCellStarted(playingCell);
			}

		player->StartScan();

		if (!inTransfer)
			{
			inTransfer = TRUE;
			PerformTransfer();
			}

		GNRAISE_OK;
		}
	else
		{
		GNRAISE(GNR_OBJECT_FULL);
		}
	}

//
//  Transfer cell in reverse playback mode
//

Error DVDVideoStreamServer::TransferCellReverse(DVDGenericPGCI * pgci, WORD cell, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu)
	{
	VDAutoMutex mutex(&lock);

	if (!file) GNRAISE(GNR_OBJECT_NOT_FOUND);

	player->SetStillFrameSequenceMode(FALSE);
	player->SetReversePlayback(TRUE);
	playbackDir = EPD_BACKWARD;

	if (firstFreeCell->state == VOS_FREE)
		{
		firstFreeCell->presentationTime = presentationTime;
		firstFreeCell->state = VOS_READY;
		GNREASSERT(pgci->GetCellInformation(cell, firstFreeCell->info));
		firstFreeCell->pgci = pgci;
		firstFreeCell->num = cell;
		firstFreeCell->still = still;
		firstFreeCell->final = final;
		firstFreeCell->scan = CST_REVERSEPLAYBACK;
		firstFreeCell->breakpoint = ERSBreakpoint();
		firstFreeCell = firstFreeCell->succ;

		if (vobu)
			{
			readingCell->state = VOS_READING;// | VOS_TRANSFERING | VOS_PLAYING;

			firstFreeVOBU->Init(file, readingCell, vobu, FALSE);
			firstFreeVOBU = firstFreeVOBU->succ;

			SendCellStarted(playingCell);
			}

		if (!inTransfer)
			{
			inTransfer = TRUE;
			PerformTransfer(128);
			}

		if (playRequest)
			{
			player->StartPlayback();
			playRequest = FALSE;
			}

		GNRAISE_OK;
		}
	else
		{
		GNRAISE(GNR_OBJECT_FULL);
		}
	}

//
//  Transfer cell trickplay
//

Error DVDVideoStreamServer::TransferCellTrickplay(DVDGenericPGCI * pgci, WORD cell, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu)
	{
	Error err;
	VDAutoMutex mutex(&lock);

	if (!file) GNRAISE(GNR_OBJECT_NOT_FOUND);

	player->SetStillFrameSequenceMode(FALSE);
	player->SetReversePlayback(FALSE);

	if (firstFreeCell->state == VOS_FREE)
		{
		firstFreeCell->presentationTime = presentationTime;
		firstFreeCell->state = VOS_READY;
		GNREASSERT(pgci->GetCellInformation(cell, firstFreeCell->info));
		firstFreeCell->pgci = pgci;
		firstFreeCell->num = cell;
		firstFreeCell->still = TRUE;
		firstFreeCell->final = final;
		firstFreeCell->scan = CST_TRICKPLAY;
		firstFreeCell->breakpoint = ERSBreakpoint();
		firstFreeCell = firstFreeCell->succ;

		if (vobu)
			{
			readingCell->state = VOS_READING;// | VOS_TRANSFERING | VOS_PLAYING;

			firstFreeVOBU->Init(file, readingCell, vobu, FALSE);

			if (IS_ERROR(err = firstFreeVOBU->ReadNavigationPack()))
				{
				SendEvent(DNE_READ_ERROR, 0);

				GNRAISE(err);
				}

			firstFreeVOBU = firstFreeVOBU->succ;

//			SendCellStarted(playingCell);
			}

		player->StartTrickplay();
		currentVOBUID = player->GetRequestedVOBUID();

		if (!inTransfer)
			{
			inTransfer = TRUE;
			PerformTransfer();
			}

		GNRAISE_OK;
		}
	else
		{
		GNRAISE(GNR_OBJECT_FULL);
		}
	}

//
//  Abort transfer
//

Error DVDVideoStreamServer::AbortTransfer(void)
	{
	suspendTransfer = TRUE;
	streamBuffer->TerminateRequest();
	lock.Enter();
	suspendTransfer = FALSE;

	player->CancelCallback();
//	player->SetAnalogCopyProtectionMode(0);
	player->CancelData();
	FlushBuffers();

	lock.Leave();

	player->WaitForCallbackCanceled();

	GNRAISE_OK;
	}

//
//  Abort transfer accurate
//

Error DVDVideoStreamServer::AbortTransferAccurate(void)
	{
	DWORD signalPosition;

	suspendTransfer = TRUE;
	streamBuffer->TerminateRequest();
	lock.Enter();
	suspendTransfer = FALSE;

	//
	//  Reset Player
	//

	player->CancelCallback();
//	player->SetAnalogCopyProtectionMode(0);
	player->CancelData();

	signalPosition = player->CurrentLocation();

	while (signalPosition >= playingVOBU->startTransferCount &&
		    (playingVOBU->state & VOS_PLAYING) &&
			(!stillMode || !playingVOBU->final ||
			 !playingVOBU->cell->still ||
			 signalPosition == 0xffffffff))
		{
		//
		//  Mark all VOBUs as completed
		//

		playingVOBU->state = VOS_PLAYCOMPLETED;
		playingVOBU->breakpoint = ERSBreakpoint();
		sequencer->VOBUCompleted(playingVOBU);

		//
		//  Complete cell if we reached end of it
		//

		if (playingVOBU->final)
			{
			playingCell->state = VOS_PLAYCOMPLETED;

			sequencer->CellCompleted(playingCell);

			playingCell = playingCell->succ;
			if (playingCell->state & (VOS_TRANSFERING | VOS_TRANSFERCOMPLETE))
				{
				playingCell->state |= VOS_PLAYING;
				sequencer->CellStarted(playingCell);
				}
			}
		//
		//  Go to next VOBU
		//

		playingVOBU = playingVOBU->succ;
		if (playingVOBU->state & (VOS_TRANSFERING | VOS_TRANSFERCOMPLETE))
			{
			playingVOBU->state |= VOS_PLAYING;
			sequencer->VOBUStarted(playingVOBU);

			if (playingCell->IsScanning()) break;
			}
		}

	FlushBuffers();

	lock.Leave();

	player->WaitForCallbackCanceled();

	GNRAISE_OK;
	}

//
//  Stop playback
//

Error DVDVideoStreamServer::StopPlayback(void)
	{
	angleChangeVOBU = 0xffffffff;

	GNRAISE_OK;
	}

//
//  Get angle change type
//

Error DVDVideoStreamServer::GetAngleChangeType(AngleChangeType & type)
	{
	if (playingCell == readingCell)
		{
		if ((playingCell->info.BlockType()) == CBT_NOT_IN_BLOCK && (firstFreeCell->state == VOS_FREE))
			{
//			DPF("Type: Deferred angle change\n");
			type = ACT_DEFERRED;
			}
		else if (playingCell->info.SeamlessAngleChange() && (firstFreeCell->state == VOS_FREE))
			{
//			DPF("Type: Seamless angle change\n");
			type = ACT_SEAMLESS;
			}
		else
			{
//			DPF("Type: Non Seamless angle change\n");
			type = ACT_NON_SEAMLESS;
			}
		}
	else
		{
		if (readingCell->info.BlockType() == CBT_NOT_IN_BLOCK)
			{
//			DPF("Type: Deferred angle change\n");
			type = ACT_DEFERRED;
			}
		else
			{
//			DPF("Type: Non Seamless angle change\n");
			type = ACT_NON_SEAMLESS;
			}
		}

	GNRAISE_OK;
	}

//
//  Seamless angle change
//

Error DVDVideoStreamServer::SeamlessAngleChange(WORD angle)
	{
	VDAutoMutex mutex(&lock);

	DVDVOBU * vobu = readingVOBU->succ;
	DVDCell * cell = readingCell->succ;
	WORD	cn;
	DWORD next;

	angleChangeRequest = 0;

	if (vobu->state == VOS_READY && (readingVOBU->state & VOS_READING))
		{
		//
		//  If successor of readingVOBU is ready to be filled then give it a new angle (cell)
		//

		if (vobu->cell->info.BlockType() == CBT_ANGLE_BLOCK)
			{
			next = readingVOBU->SeamlessAngleChangeVOBU(angle);
			if (next)
				{
				DP("Has seamless angle change");

				angleChangeVOBU = next;
				angleChangeAngle = angle;
				if (readingVOBU->IsLastVOBUinILVU())
					{
					if (next != 0x7fffffff)
						vobu->firstBlock = next;
					}
				else
					angleChangeRequest = angle;

				if (next != 0x7fffffff)
					{
					while (vobu->cell->info.BlockMode() != CBM_FIRST_CELL_IN_BLOCK)
						{
						vobu->cell->num--;
						GNREASSERT(vobu->cell->pgci->GetCellInformation(vobu->cell->num, vobu->cell->info));
						}
					cn = 1;
					while (vobu->cell->info.BlockMode() != CBM_LAST_CELL_IN_BLOCK && cn < angle)
						{
						cn++;
						vobu->cell->num++;
						GNREASSERT(vobu->cell->pgci->GetCellInformation(vobu->cell->num, vobu->cell->info));
						}
					}
				}
			}
		}
	else if (vobu->state == VOS_FREE && readingVOBU->state == VOS_READY &&
				(predReadingVOBU->state & VOS_TRANSFERCOMPLETE))
		{
		//
		//  Reading VOBU has not started reading yet, its successor is not allocated then change
		//  readingVOBU's data to point to new angle
		//

		DP("Fallback to previous mode");
		if (readingVOBU->cell->info.BlockType() == CBT_ANGLE_BLOCK)
			{
			next = predReadingVOBU->SeamlessAngleChangeVOBU(angle);
			if (next)
				{
				DP("Has seamless angle change");

				angleChangeVOBU = next;
				angleChangeAngle = angle;
				if (predReadingVOBU->IsLastVOBUinILVU())
					{
					if (next != 0x7fffffff)
						readingVOBU->firstBlock = next;
					}
				else
					{
					angleChangeRequest = angle;
					}

				if (next != 0x7fffffff)
					{
					while (readingVOBU->cell->info.BlockMode() != CBM_FIRST_CELL_IN_BLOCK)
						{
						readingVOBU->cell->num--;
						GNREASSERT(readingVOBU->cell->pgci->GetCellInformation(readingVOBU->cell->num, readingVOBU->cell->info));
						}
					cn = 1;
					while (readingVOBU->cell->info.BlockMode() != CBM_LAST_CELL_IN_BLOCK && cn < angle)
						{
						cn++;
						readingVOBU->cell->num++;
						GNREASSERT(readingVOBU->cell->pgci->GetCellInformation(readingVOBU->cell->num, readingVOBU->cell->info));
						}
					}
				}
			}
		}

	//
	//  Check if next cell is ready to be filled. If so then change it to the proper angle
	//

	if (cell->state == VOS_READY && (readingCell->state & VOS_READING))
		{
		DP("Next cell is ready, current is transfering");

		if (cell->info.BlockType() == CBT_ANGLE_BLOCK)
			{
			DP("Current cell is angle block");

			angleChangeVOBU = ANGLE_CHANGE_CELL;
			angleChangeAngle = angle;

			while (cell->info.BlockMode() != CBM_FIRST_CELL_IN_BLOCK)
				{
				cell->num--;
				GNREASSERT(cell->pgci->GetCellInformation(cell->num, cell->info));
				}
			cn = 1;
			while (cell->info.BlockMode() != CBM_LAST_CELL_IN_BLOCK && cn < angle)
				{
				cn++;
				cell->num++;
				GNREASSERT(cell->pgci->GetCellInformation(cell->num, cell->info));
				}
			}
		}

	GNRAISE_OK;
	}

//
//  Set VOBS
//
//  GNR_OK
//

Error DVDVideoStreamServer::SetOBS(DVDOBS * obs)
	{
	this->vobs = (DVDVOBS *)obs;
	GNREASSERT(obs->GetDataFile(file));

	if (!streamBuffer)
		streamBuffer = new DVDScatteredStreamBuffer(streamBufferSize);

	GNRAISE_OK;
	}

//
//  Player Callback
//

void DVDVideoStreamServer::PlayerCallback(DWORD signalPosition)
	{
	BOOL stillCell = FALSE;
	int frameRate = player->GetCurrentFrameRate();
	BOOL bpReached = FALSE;
	ERSBreakpoint bp;
	DVDTime startTime;
	DVDTime endTime;
	VDAutoMutex mutex(&lock);

	//DP("Player callback");

	if (inTransfer)
		{
		if (signalPosition == 0xffffffff && transferingVOBU->state & VOS_TRANSFERING && !playingCell->IsScanning())
			{
			BREAKPOINT;
			}

//		DP("*** Signal at %08lx VOBU %08lx %x %d %d", signalPosition, playingVOBU->endTransferCount, playingVOBU->state, stillMode, playingVOBU->final);

		while (signalPosition >= playingVOBU->endTransferCount && (playingVOBU->state & VOS_PLAYING) &&
				(!stillMode || !playingVOBU->final || !playingVOBU->cell->still || signalPosition == 0xffffffff))
			{
			playingVOBU->state = VOS_PLAYCOMPLETED;

			//
			//  If previous VOBU contained breakpoint go to still (in forward scan)
			//

			if (stopAfterNextVOBU)
				{
				playingVOBU->breakpoint = breakpoint;
				SendVOBUCompleted(playingVOBU);
				stillMode = TRUE;
				stopAfterNextVOBU = FALSE;
				bpReached = TRUE;
				readEveryVOBU = FALSE;
				inTransfer = FALSE;
				}
			else
				{
				//
				//  Test on breakpoint
				//

				if (playingCell->scan != CST_REVERSEPLAYBACK)
					{
					//
					//  Calculate the interval the VOBU covers
					//  NOTE: We don't use DVDVOBU::GetDuration() here since the frame rate might not be correctly
					//  encoded. See: Billy Joel: Greatest Hits Vol. 3
					//

					startTime = playingVOBU->cell->presentationTime + playingVOBU->GetTimeOffset();
					endTime = startTime + DVDTime(playingVOBU->GetEPTM() - playingVOBU->GetSPTM(), 90, player->GetCurrentFrameRate());

					if (bpReached = sequencer->BreakpointReached(startTime, endTime, playbackDir, bp))
						sequencer->SetBreakpointUpcoming(bp.id);

					if (playingVOBU->final && playingVOBU->cell->final)
						{
						if (!bpReached)
							bpReached = sequencer->EndOfCellBreakpointReached(playingVOBU->cell, playbackDir, bp);

						if (!bpReached && playingVOBU->cell->scan == CST_SCANBACKWARD)
							bpReached = sequencer->BeginOfCellBreakpointReached(playingVOBU->cell, playbackDir, bp);
						}

					if (bpReached)
						{
						switch (playingCell->scan)
							{
							case CST_PLAYBACK:
								if (BP_TOSTILL(bp.flags))
									{
									stillMode = TRUE;
									inTransfer = FALSE;
									}
								playingVOBU->breakpoint = bp;
								SendVOBUCompleted(playingVOBU);
								break;
							case CST_SCANFORWARD:
								if (BP_TOSTILL(bp.flags))
									{
#if BREAKPOINT_DEFERRED
									breakpoint = bp;
									stopAfterNextVOBU = TRUE;
									playingVOBU->breakpoint = ERSBreakpoint();
#else
									stillMode = TRUE;
									inTransfer = FALSE;
									playingVOBU->breakpoint = bp;
#endif
									}
								else
									{
									playingVOBU->breakpoint = bp;
									}
								readEveryVOBU = FALSE;
								SendVOBUCompleted(playingVOBU);
								break;
							case CST_SCANBACKWARD:
								if (BP_TOSTILL(bp.flags))
									{
									stillMode = TRUE;
									inTransfer = FALSE;
									}
								readEveryVOBU = FALSE;
								playingVOBU->breakpoint = bp;
								SendVOBUCompleted(playingVOBU);
								break;
							default:
								bpReached = FALSE;
								break;
							}
						}
					else
						{
						playingVOBU->breakpoint = ERSBreakpoint();
						SendVOBUCompleted(playingVOBU);
						}
					}
				else
					{
					SendVOBUCompleted(playingVOBU);
					}
				}

			if (bpReached)
				break;

			//
			//  Complete cell if we're there
			//

			if (playingVOBU->final)
				{
				DP("Final VOBU");
				playingCell->state = VOS_PLAYCOMPLETED;
				stillCell = playingCell->still;

				SendCellCompleted(playingCell);

				playingCell = playingCell->succ;

				if (playingCell->state & (VOS_TRANSFERING | VOS_TRANSFERCOMPLETE))
					{
					playingCell->state |= VOS_PLAYING;
					SendCellStarted(playingCell);
					}
				}

			//
			//  Go to next VOBU
			//

			playingVOBU = playingVOBU->succ;

			if (playingVOBU->state & (VOS_TRANSFERING | VOS_TRANSFERCOMPLETE))
				{
				playingVOBU->state |= VOS_PLAYING;
				SendVOBUStarted(playingVOBU);
				player->SetTimeBase(playingVOBU->GetTimeOffset() + playingVOBU->cell->presentationTime);
				if (playingVOBU->singleFrame)
					player->SetCallback(0x3fffffff, this);
				else
					{
//					DP("*** Set Signal at %08lx %x %d %d", playingVOBU->endTransferCount, playingVOBU->state, stillMode, playingVOBU->final);
					player->SetCallback(playingVOBU->endTransferCount, this);
					}
				}

			//
			//  Check Breakpoints in reverse playback mode
			//

			if (playingCell->scan == CST_REVERSEPLAYBACK && playingVOBU->state != VOS_FREE)
				{
				if (playingVOBU->cell)
					startTime = playingVOBU->cell->presentationTime + playingVOBU->GetTimeOffset();
				else
					startTime = playingVOBU->GetTimeOffset();

				if (bpReached = sequencer->BreakpointReached(startTime, startTime + playingVOBU->GetDuration(), playbackDir, bp))
					sequencer->SetBreakpointUpcoming(bp.id);

				if (playingVOBU->final && playingVOBU->cell && playingVOBU->cell->final)
					{
					if (!bpReached)
						bpReached = sequencer->EndOfCellBreakpointReached(playingVOBU->cell, playbackDir, bp);

					if (!bpReached)
						bpReached = sequencer->BeginOfCellBreakpointReached(playingVOBU->cell, playbackDir, bp);
					}

				if (bpReached)
					{
					bpReached = FALSE;
					if (BP_TOSTILL(bp.flags))
						{
						stillMode = TRUE;
						bpReached = TRUE;
						inTransfer = FALSE;
						}
					playingVOBU->breakpoint = bp;
					SendVOBUCompleted(playingVOBU);
					}
				}
			}

		if (playingVOBU == transferingVOBU->succ)
			{
			BREAKPOINT;
			}

		if (playingCell->IsScanning() && !stillCell && !bpReached)
			{
			stillMode = FALSE;
			PerformTransfer();
			}
		}
	}

//
//  Return VOBU
//

Error DVDVideoStreamServer::ReturnVOBU(DVDVOBU * vobu)
	{
	//
	// There is no lock needed, because the vobu that is freed is outside
	// the active area of the pumping thread
	//
//	lock.Enter();

	vobu->Cleanup();

//	lock.Leave();

	GNRAISE_OK;
	}

//
//  Return cell
//

Error DVDVideoStreamServer::ReturnCell(DVDCell * cell)
	{
	//
	// There is no lock needed, because the cell that is freed is outside
	// the active area of the pumping thread
	//
//	lock.Enter();

	cell->state = VOS_FREE;

//	lock.Leave();

	GNRAISE_OK;
	}

//
//  Complete still
//

Error DVDVideoStreamServer::CompleteStill(void)
	{
	VDAutoMutex mutex(&lock);

	if (stillMode)
		{
		if (playingCell->IsScanning())
			{
			stillMode = FALSE;
			PerformTransfer();
			}
		else
			{
			player->CancelData();
			stillMode = FALSE;
			if (playingCell->state)
				{
				if (playingCell->scan == CST_PLAYBACK)
					PerformTransfer(16);
				else
					player->RequestRefill();

				if (playingCell->state & VOS_PLAYING)
					{
					if (playingCell->scan == CST_PLAYBACK)
						player->StartPlayback();
					playRequest = FALSE;
					}
				else
					playRequest = TRUE;
				}
			else
				playRequest = TRUE;
			}
		}

	GNRAISE_OK;
	}

Error DVDVideoStreamServer::TerminateStill(void)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Defrost
//

Error DVDVideoStreamServer::Defrost(void)
	{
	positionCache.valid = FALSE;
	GNRAISE_OK;
	}

////////////////////////////////////////////////////////////////////
//
//  DVDAudioStreamServer Class
//
////////////////////////////////////////////////////////////////////

//
// Constructor
//

DVDAudioStreamServer::DVDAudioStreamServer (DVDSequencer * seq, WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher)
	: DVDStreamServer(seq, server, units, pEventDispatcher)
	, EventSender(pEventDispatcher)
	{
	FlushBuffers();  // Initializes cell buffers

	/*
	transferSemaphore = 0;
	positionCache.valid = FALSE;
	*/
	}

//
// Destructor
//

DVDAudioStreamServer::~DVDAudioStreamServer(void)
	{
	if (streamBuffer)
		{
		delete streamBuffer;
		streamBuffer = NULL;
		}
	}

//
//  Initialize
//

Error DVDAudioStreamServer::Init(DVDFileSystem * dvdfs)
	{
	DVDStreamServer::Init(dvdfs);

	this->dvdfs = dvdfs;
	player->SetRefiller(this);

	GNRAISE_OK;
	}

Error DVDAudioStreamServer::RefillBuffer(BOOL prefetch)
	{
	GNRAISE_OK;
	}

Error DVDAudioStreamServer::SendBuffer(void)
	{
	GNRAISE_OK;
	}

//
//  Flush Buffers
//

Error DVDAudioStreamServer::FlushBuffers(void)
	{
	int i;

	for(i=0; i<NUM_CELL_BUFFERS; i++)
		{
		cells[i].state = VOS_FREE;
		}

	firstFreeCell = readingCell = transferingCell = playingCell = cells;

	if (streamBuffer) streamBuffer->Flush();

	/*
	numVOBUBlocks = 0;

	stillMode = FALSE;
	stillPending = FALSE;
	finalBuffer = FALSE;
	playRequest = TRUE;
	inTransfer = FALSE;
	suspendTransfer = FALSE;

	callbackSemaphore	= FALSE;
	angleChangeRequest = 0;
	angleChangeVOBU = ANGLE_CHANGE_NONE;

	readEveryVOBU = FALSE;
	stopAfterNextVOBU = FALSE;

	endPTM = 0;
	ptsOffset = 22500;

	currentReadCount = 0;
	*/

	FlushMessages();

	GNRAISE_OK;
	}

Error DVDAudioStreamServer::SendCellStarted(DVDCell * cell)
	{
	GNRAISE_OK;
	}

Error DVDAudioStreamServer::SendCellCompleted(DVDCell * cell)
	{
	GNRAISE_OK;
	}

void DVDAudioStreamServer::ConvertToEStdTime(BYTE * data, int num)
	{
	return;
	}

void DVDAudioStreamServer::Message(WPARAM wParam, LPARAM dParam)
	{
	return;
	}

Error DVDAudioStreamServer::Defrost(void)
	{
	GNRAISE_OK;
	}

Error DVDAudioStreamServer::PerformTransfer(int maxTransfer)
	{
	int transfer;
	Error error;

	transfer = maxTransfer;
	while (transfer && !suspendTransfer)
		{
		lock.Enter();

		transfer--;

		if (inTransfer && !suspendTransfer)
			{
			/*
			if (transferingCell->scan == CST_TRICKPLAY)
				{
				if (stillMode) AdvanceTrickMode();
				}
			*/
			if (player->Completed())
				{
				SendBuffer();
				if (streamBuffer->IsEmpty())
					{
					if (IS_ERROR(error = RefillBuffer(TRUE)))
						{
						if (error != GNR_OPERATION_ABORTED)
							player->TerminatePlayback();

						lock.Leave();

						GNRAISE(error);
						}

					if (streamBuffer->IsEmpty())
						{
						transfer = 0;
						}
					}
				else
					{
					transfer = 0;
					RefillBuffer(TRUE);
					}
				}
			else
				transfer = 0;
			}
		else
			transfer = 0;

		lock.Leave();
		}

	GNRAISE_OK;
	}

//
//  Transfer Cell
//

Error DVDAudioStreamServer::TransferCell(DVDGenericPGCI * pgci, WORD num, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu, WORD angle)
	{
	/*
	WORD cn;
	Error err;
	VDAutoMutex	mutex(&lock);
	WORD program;
	WORD lastCell;
	*/

	if (!file) GNRAISE(GNR_OBJECT_NOT_FOUND);

	player->SetReversePlayback(FALSE);  // No reverse playback
	playbackDir = EPD_FORWARD;

	if (firstFreeCell->state == VOS_FREE)  // Check if a cell is free
		{
		firstFreeCell->presentationTime = presentationTime;
		firstFreeCell->state = VOS_READY;
		GNREASSERT(pgci->GetATSCellInformation(num, firstFreeCell->atsInfo));
		firstFreeCell->pgci = pgci;

		firstFreeCell->num = num;

		/*
		firstFreeCell->final = final;
		*/

		firstFreeCell->scan = CST_PLAYBACK;
		firstFreeCell->breakpoint = ERSBreakpoint();

		firstFreeCell = firstFreeCell->succ;

		/*
		//
		//  Read the requested VOBU
		//

		if (vobu)
			{
			readingCell->state = VOS_READING;// | VOS_TRANSFERING | VOS_PLAYING;

			firstFreeVOBU->Init(file, readingCell, vobu, FALSE);
			player->SetTimeBase(firstFreeVOBU->GetTimeOffset() + firstFreeVOBU->cell->presentationTime);

			firstFreeVOBU = firstFreeVOBU->succ;
			}
		*/

		if (!inTransfer)
			{
			inTransfer = TRUE;
//			PerformTransfer(16);
			}

		if (playRequest)
			{
			player->StartPlayback();
			playRequest = FALSE;
			}

		GNRAISE_OK;
		}
	else
		{
		GNRAISE(GNR_OBJECT_FULL);
		}
	}

Error DVDAudioStreamServer::TransferCellAt(DVDGenericPGCI * pgci, WORD num, BOOL still, BOOL final, DVDTime presentationTime, DVDTime time)
	{
	GNRAISE_OK;
	}

Error DVDAudioStreamServer::TransferCellScan(DVDGenericPGCI * pgci, WORD cell, BOOL still, BOOL final, DVDTime presentationTime, BOOL forward, WORD first, WORD skip, DWORD vobu)
	{
	GNRAISE_OK;
	}

Error DVDAudioStreamServer::TransferCellReverse(DVDGenericPGCI * pgci, WORD cell, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu)
	{
	GNRAISE_OK;
	}

Error DVDAudioStreamServer::TransferCellTrickplay(DVDGenericPGCI * pgci, WORD cell, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu)
	{
	GNRAISE_OK;
	}

Error DVDAudioStreamServer::AbortTransfer(void)
	{
	GNRAISE_OK;
	}

Error DVDAudioStreamServer::AbortTransferAccurate(void)
	{
	GNRAISE_OK;
	}

Error DVDAudioStreamServer::StopPlayback(void)
	{
	GNRAISE_OK;
	}

Error DVDAudioStreamServer::CompleteStill(void)
	{
	GNRAISE_OK;
	}

Error DVDAudioStreamServer::TerminateStill(void)
	{
	GNRAISE_OK;
	}

Error DVDAudioStreamServer::GetAngleChangeType(AngleChangeType & type)
	{
	type = ACT_NONE;
	GNRAISE_OK;
	}

Error DVDAudioStreamServer::SeamlessAngleChange(WORD angle)
	{
	GNRAISE_OK;
	}

//
//  Set AOBS
//
//  GNR_OK
//

Error DVDAudioStreamServer::SetOBS(DVDOBS * obs)
	{
	this->aobs = (DVDAOBS *)obs;
	GNREASSERT(obs->GetDataFile(file));

	if (!streamBuffer)
		streamBuffer = new DVDScatteredStreamBuffer(streamBufferSize);

	GNRAISE_OK;
	}

Error DVDAudioStreamServer::ReturnVOBU(DVDVOBU * vobu)
	{
	GNRAISE_OK;
	}

Error DVDAudioStreamServer::ReturnCell(DVDCell * cell)
	{
	GNRAISE_OK;
	}

void DVDAudioStreamServer::PlayerCallback(DWORD signalPosition)
	{
	return;
	}

Error DVDAudioStreamServer::GetPlaybackTime(DVDTime & time)
	{
	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDAVStreamServer.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD Audio/Video Stream Server Module
//
//  Declares DVDVideoStreamServer, DVDAudioStreamServer
//
////////////////////////////////////////////////////////////////////

#ifndef DVDAVSTREAMSERVER_H
#define DVDAVSTREAMSERVER_H


#include "DVDStreamServer.h"
#include "Library/Common/WinPorts.h"
#include "Boards/Generic/Vdgendrv.h"
#include "DVDSequencer.h"


////////////////////////////////////////////////////////////////////
//
//  DVDVideoStreamServer Class
//
////////////////////////////////////////////////////////////////////

class DVDVideoStreamServer : public DVDStreamServer
	{
	friend class DVDPGCSequencer;
	protected:
		DWORD				nextVOBUBlock;
		DWORD				numVOBUBlocks;

		DWORD				currentVOBUID;
		DWORD				endPTM, ptsOffset;
		DWORD				translatedStartPTM, translatedEndPTM;

		DVDVOBU			vobus[NUM_VOBU_BUFFERS];
		DVDVOBU		*  firstFreeVOBU;					// First free VOBU in VOBU buffer
		DVDVOBU		*	predReadingVOBU;				// Predecessor of VOBU being currently read
		DVDVOBU		*	readingVOBU;					// VOBU currently being read
		DVDVOBU		*	transferingVOBU;				// VOBU currently being transfered
		DVDVOBU		*	playingVOBU;					// VOBU currently playing
		DWORD				angleChangeVOBU;				// VOBU for which angle change event is to be send
		WORD				angleChangeAngle;				// New angle to send with event

		DWORD				currentReadCount;

		WORD				transferSemaphore;

		DVDVOBS		*	vobs;

		BOOL 				singleFrame, stillMode, finalBuffer, stillPending;
		BOOL				inTransfer, callbackSemaphore;
		WORD				angleChangeRequest;

		ERSBreakpoint breakpoint;			// The breakpoint reached
		BOOL stopAfterNextVOBU;				// TRUE if we have to stop after next VOBU
		BOOL readEveryVOBU;					// If we need to find a special VOBU during scan, set this to TRUE, so every VOBU is read

		struct PositionCache					// To cache some info for TimePlay/Search (TransferCellAt)
			{
			BOOL		valid;
			WORD		cell;				// Number of the cell
			DVDTime	time;				// Presentation time
			DWORD		pgciID;			// Unique ID for pgci
			DWORD		firstBlock;		// First block of VOBU to play
			} positionCache;

		BOOL IsFinalVOBUOfCell(void);

		void ConvertToEStdTime(BYTE * data, int num);

		virtual Error RefillBuffer(BOOL prefetch);
		virtual Error SendBuffer(void);

		virtual Error FlushBuffers(void);

		Error SendVOBUStarted(DVDVOBU * vobu);
		Error SendVOBUCompleted(DVDVOBU * vobu);

		virtual Error SendCellStarted(DVDCell * cell);
		virtual Error SendCellCompleted(DVDCell * cell);
		virtual Error SendCellCorrupt(DVDCell * cell);

		Error SendPlaybackTerminated(Error err);

		virtual void Message(WPARAM wParam, LPARAM dParam);

		Error AdvanceTrickMode(void);

		virtual Error Defrost(void);

	public:
		DVDVideoStreamServer(DVDSequencer * seq, WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher);
		virtual ~DVDVideoStreamServer(void);

		virtual Error Init(DVDFileSystem * dvdfs);

		//
		// To be called once in a while
		//
		virtual Error PerformTransfer(int maxTransfer = 0xffff);

		virtual Error TransferCell(DVDGenericPGCI * pgci, WORD num, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu = 0, WORD angle = 0);
		virtual Error TransferCellAt(DVDGenericPGCI * pgci, WORD num, BOOL still, BOOL final, DVDTime presentationTime, DVDTime time);
		virtual Error TransferCellScan(DVDGenericPGCI * pgci, WORD cell, BOOL still, BOOL final, DVDTime presentationTime, BOOL forward, WORD first, WORD skip, DWORD vobu);
		virtual Error TransferCellReverse(DVDGenericPGCI * pgci, WORD cell, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu);
		virtual Error TransferCellTrickplay(DVDGenericPGCI * pgci, WORD cell, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu);

//		virtual Error ReplaceCell(DVDGenericPGCI * pgci, WORD num, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu = 0, WORD angle = 0);

		virtual Error AbortTransfer(void);
		virtual Error AbortTransferAccurate(void);

		virtual Error StopPlayback(void);

		virtual Error CompleteStill(void);
		virtual Error TerminateStill(void);

		virtual Error GetAngleChangeType(AngleChangeType & type);
		virtual Error SeamlessAngleChange(WORD angle);

		virtual Error SetOBS(DVDOBS * obs);

		virtual Error ReturnVOBU(DVDVOBU * vobu);
		virtual Error ReturnCell(DVDCell * cell);

      virtual void PlayerCallback(DWORD signalPosition);

		virtual Error GetPlaybackTime(DVDTime & time) {return player->GetPlaybackTime(time);}
	};

////////////////////////////////////////////////////////////////////
//
//  DVDAudioStreamServer Class
//
//	 Description:
//		Describes a Stream Server Class for DVD-Audio playback.
//		It is used either for DVD-Audios which contain Audio Only
//		Titles with Audio Still Videos or just Audio Only Titles.
//		Audio Titles with Video (AVTT) are using the
//		DVDVideoStreamServer Class.
//
////////////////////////////////////////////////////////////////////

class DVDAudioStreamServer : public DVDStreamServer
	{
	protected:
		DVDAOBS		*	aobs;

		virtual Error RefillBuffer(BOOL prefetch);
		virtual Error SendBuffer(void);

		virtual Error FlushBuffers(void);

		virtual Error SendCellStarted(DVDCell * cell);
		virtual Error SendCellCompleted(DVDCell * cell);

		void ConvertToEStdTime(BYTE * data, int num);

		virtual void Message(WPARAM wParam, LPARAM dParam);

		virtual Error Defrost(void);

	public:
		DVDAudioStreamServer(DVDSequencer * seq, WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher);
		virtual ~DVDAudioStreamServer(void);

		virtual Error Init(DVDFileSystem * dvdfs);

		//
		// To be called once in a while
		//
		virtual Error PerformTransfer(int maxTransfer = 0xffff);

		virtual Error TransferCell(DVDGenericPGCI * pgci, WORD num, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu = 0, WORD angle = 0);
		virtual Error TransferCellAt(DVDGenericPGCI * pgci, WORD num, BOOL still, BOOL final, DVDTime presentationTime, DVDTime time);
		virtual Error TransferCellScan(DVDGenericPGCI * pgci, WORD cell, BOOL still, BOOL final, DVDTime presentationTime, BOOL forward, WORD first, WORD skip, DWORD vobu);
		virtual Error TransferCellReverse(DVDGenericPGCI * pgci, WORD cell, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu);
		virtual Error TransferCellTrickplay(DVDGenericPGCI * pgci, WORD cell, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu);

//		virtual Error ReplaceCell(DVDGenericPGCI * pgci, WORD num, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu = 0, WORD angle = 0);

		virtual Error AbortTransfer(void);
		virtual Error AbortTransferAccurate(void);

		virtual Error StopPlayback(void);

		virtual Error CompleteStill(void);
		virtual Error TerminateStill(void);

		virtual Error GetAngleChangeType(AngleChangeType & type);
		virtual Error SeamlessAngleChange(WORD angle);

		virtual Error SetOBS(DVDOBS * obs);

		virtual Error ReturnVOBU(DVDVOBU * vobu);
		virtual Error ReturnCell(DVDCell * cell);

      virtual void PlayerCallback(DWORD signalPosition);

		virtual Error GetPlaybackTime(DVDTime & time);
	};


#endif // DVDAVSTREAMSERVER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDAVHeader.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD Audio/Video specific Header File Information
//
////////////////////////////////////////////////////////////////////


#ifndef DVDAVHEADER_H
#define DVDAVHEADER_H

#include "DVDHeader.h"


////////////////////////////////////////////////////////////////////
//
//  Program Chain Information Class
//
////////////////////////////////////////////////////////////////////

class DVDPGCI : public DVDGenericPGCI
	{
	protected:
		DVDNavigationCommand	*	cmd;
		WORD							numPreCmd, numPostCmd;
		BYTE							firstCellOfProgram[128];

		Error ReadCommandList(void);

	public:
		DVDPGCI(DVDDiskPlayerFactory * factory);
		virtual ~DVDPGCI(void);

		Error Init(DVDHeaderFile * file, DWORD start);

		Error GetPresentationTime(DVDTime & time);

		Error GetUserOperations(DWORD & uops);
		Error GetAudioStreamControl(int num, WORD & asc);
		Error GetSubPictureStreamControl(int num, DWORD & spsc);

		Error GetNextProgramChain(WORD & next);
		Error GetPreviousProgramChain(WORD & prev);
		Error GetUpperProgramChain(WORD & upper);

		Error GetPlaybackMode(BYTE & mode);
		Error GetStillTimeValue(BYTE & stillTime);

		Error GetSubPicturePalette(int entry, DWORD & palette);

		Error GetPreCommands(int & num,  DVDNavigationCommand * & cmds);
		Error GetPostCommands(int & num, DVDNavigationCommand * & cmds);
		Error GetCellCommands(DVDNavigationCommand * & cmds);

		Error GetCellInformation(int cell, DVDCPBI & cpbi);
		Error GetATSCellInformation(int cell, DVDATSCPBI & atscpbi);
		Error GetFirstCellOfProgram(int program, WORD & first);
		Error GetLastCellOfProgram(int program, WORD & last);
		Error GetProgramOfCell(int cell, WORD & prog);
		Error GetNumberOfCellsInProgram(int program, WORD & num);
	};

///////////////////////////////////////////////////////////////////////
//
//  Audio Title Set Program Chain Information Class
//
//	 Description:
//		The Audio Title Set Program Chain Information Class describes
//		the ATS_PGCI. ATS_PGCI comprises ATS_PGC General Information,
//		ATS Program Information Table, ATS Cell Playback Information
//		Table and ATS_ASV Playback Information Table.
//		Note that the ATS_PGCI is different as well from the DVD-Video
//		Program Chain Information as from the DVD-Audio Manager Menu
//		Program Chain Information.
//
///////////////////////////////////////////////////////////////////////

class DVDATSPGCI : public DVDGenericPGCI
	{
	protected:

	public:
		DVDATSPGCI(DVDDiskPlayerFactory * factory);
		virtual ~DVDATSPGCI(void);

		Error Init(DVDHeaderFile * file, DWORD start);

		Error GetPresentationTime(DVDTime & time);

		Error GetUserOperations(DWORD & uops);
		Error GetAudioStreamControl(int num, WORD & asc);
		Error GetSubPictureStreamControl(int num, DWORD & spsc);

		Error GetNextProgramChain(WORD & next);
		Error GetPreviousProgramChain(WORD & prev);
		Error GetUpperProgramChain(WORD & upper);

		Error GetPlaybackMode(BYTE & mode);
		Error GetStillTimeValue(BYTE & stillTime);

		Error GetSubPicturePalette(int entry, DWORD & palette);

		Error GetPreCommands(int & num,  DVDNavigationCommand * & cmds);
		Error GetPostCommands(int & num, DVDNavigationCommand * & cmds);
		Error GetCellCommands(DVDNavigationCommand * & cmds);

		Error GetCellInformation(int cell, DVDCPBI & cpbi);
		Error GetATSCellInformation(int cell, DVDATSCPBI & atscpbi);
		Error GetFirstCellOfProgram(int program, WORD & first);
		Error GetLastCellOfProgram(int program, WORD & last);
		Error GetProgramOfCell(int cell, WORD & prog);
		Error GetNumberOfCellsInProgram(int program, WORD & num);
	};

////////////////////////////////////////////////////////////////////
//
//  Program Chain Information Table
//
//	 Description:
//		The class implements a table that describes as well the
//		VTS Program Chain Information (VTS_PGCI) as the ATS
//		Program Chain Information (ATS_PGCI). Furthermore the Video
//		Manager Menu Program Chain Information and the Audio Manager Menu
//		Program Chain Information. Program Chain Information
//		is the Navigation Data to control the presentation of PGC.
//		The PGCIT for Audio Title Set is a little bit different in
//		in comparison with the other PGCIT. The reason that we use
//		one class and not two different classes is that we allocate the
//		PGCIT statically and not dynamically.
//		The Bool value 'isATSPGCIT' is used to distinguish between an
//		ATS_PGCIT and other PGCIT.
//
////////////////////////////////////////////////////////////////////

class DVDPGCIT
	{
	protected:
		DVDDiskPlayerFactory * factory;
		DVDHeaderFile	*	file;
		RequestHandle		rh;
		DWORD					start;
		BOOL					isATSPGCIT;

	public:
		DVDPGCIT(DVDDiskPlayerFactory * factory, DVDHeaderFile * file, DWORD start)
			{this->factory = factory; this->file = file; this->start = start; isATSPGCIT = FALSE;}
		DVDPGCIT(DVDDiskPlayerFactory * factory, DVDHeaderFile * file, DWORD start, BOOL ats)
			{this->factory = factory; this->file = file; this->start = start; isATSPGCIT = ats;}
		DVDPGCIT(void)
			{factory = NULL; file = NULL; start = 0; isATSPGCIT = FALSE;}

		Error GetNumberOfPGC(WORD & num);
		Error GetParentalID(WORD pgc, WORD & id);
		Error GetTitle(WORD pgc, WORD & title);
		Error GetMenuType(WORD pgc, VTSMenuType & type);

		Error FindMenu(VTSMenuType type, WORD & menu);

		Error GetBlockMode(WORD pgc, PGCBlockMode & mode);
		Error GetBlockType(WORD pgc, PGCBlockType & type);
		Error HasEntryPGC(WORD pgc, BOOL & hasPGC);

		// used only for DVD-Audio Title Set PGCIT
		Error GetAudioChannels(WORD pgc, BOOL & hasMoreThanTwoChannels);
		// used only for DVD-Audio Title Set PGCIT
		Error GetAudioCodingMode(WORD pgc, DVDAudioCodingMode & acm);

		Error GetPGCI(WORD pgc, DVDGenericPGCI * & pgci); // to be deleted by caller
	};

////////////////////////////////////////////////////////////////////
//
//  Program Chain Information Unit Table
//
//	 Description:
//		The Program Chain Information Unit Table is a table that
//		describes both the information on VMG Menu Program Chain
//		Information which presents Video Manager Menu in each
//		language and the information on AMGM Program Chain Infor-
//		mation which presents Audio Manager Menu in each language.
//
////////////////////////////////////////////////////////////////////

class DVDPGCIUT
	{
	protected:
		DVDDiskPlayerFactory * factory;
		DVDHeaderFile	*	file;
		RequestHandle		rh;
		DWORD					start;

	public:
		DVDPGCIUT(DVDDiskPlayerFactory * factory, DVDHeaderFile * file, DWORD start)
			{this->factory = factory; this->file = file; this->start = start;}
		DVDPGCIUT(void) {factory = NULL; file = NULL; start = 0;}

		Error GetNumberOfLanguageUnits(WORD & num);
		Error MenuExists(WORD lu, VTSMenuType type, BOOL & exists);
		Error GetLanguageCode(WORD lu, WORD & lc);
		Error GetPGCIT(WORD lu, DVDPGCIT & pgcit);
	};

//////////////////////////////////////////////////////////////////////
//
//  Video Title Search Pointer Table (in VMGI)
//
//  Description:
//		Describes search information of Video Title under VIDEO_TS
//		directory.
//
//////////////////////////////////////////////////////////////////////

class DVDVTTSRPT : public DVDSRPT
	{
	public:
		DVDVTTSRPT(void);
		DVDVTTSRPT(DVDHeaderFile * file, DWORD start);
		DVDVTTSRPT(const DVDVTTSRPT & srpt);
		virtual ~DVDVTTSRPT(void);

		Error GetNumberOfPartOfTitle(WORD title, WORD & num);
		Error GetNumberOfAngles(WORD title, WORD & num);
		Error GetUOPS(WORD title, DWORD & uops);

		Error GetTitle(WORD title, WORD & tsn, WORD & ttn);
		Error GetTitleOfTSTitle(WORD tsn, WORD tsTitle, WORD & title);

		Error IsOneSequentialPGCTitle(WORD title, BOOL & iospt);
	};

//////////////////////////////////////////////////////////////////////
//
//  Audio Title Search Pointer Table (in AMGI)
//
//  Description:
//		The DVDATTSRPT implements the ATT_SRPT table that describes
//		the search information of Audio Titles (ATTs).
//
//////////////////////////////////////////////////////////////////////

class DVDATTSRPT : public DVDSRPT
	{
	protected:
		Error IsAOTT(WORD title, BOOL & isAOTT);

	public:
		DVDATTSRPT(void);
		DVDATTSRPT(DVDHeaderFile * file, DWORD start);
		DVDATTSRPT(const DVDATTSRPT & srpt);
		virtual ~DVDATTSRPT(void);

		Error GetNumberOfPartOfTitle(WORD title, WORD & num);
		Error GetNumberOfAngles(WORD title, WORD & num);
		Error GetUOPS(WORD title, DWORD & uops);

		Error GetTitle(WORD title, WORD & tsn, WORD & ttn);
		Error GetTitleOfTSTitle(WORD tsn, WORD tsTitle, WORD & title);

		Error IsOneSequentialPGCTitle(WORD title, BOOL & iospt);
	};

//////////////////////////////////////////////////////////////////////
//
//  Audio Only Title Search Pointer Table (in AMGI)
//
//  Description:
//		The DVDAOTTSRPT implements AOTT_SRPT that describes the
//		search information of Audio Only Titles (AOTTs), and is
//		used for Audio Only Player.
//		Must be implemented when doing an Audio Only Player.
//		For now Audio Only Player Capability is not integrated.
//		(MST, 11/27/2000)
//
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
//  Audio Still Video Search Pointer Table
//
//  Description:
//		This class describes the search pointer of ASVOB for every ASV
//		in ASVOBS.
//
//////////////////////////////////////////////////////////////////////

class DVDASVSRPT
	{
	protected:
		DVDHeaderFile * hfile;
		RequestHandle rh;
		DWORD start;

	public:
		DVDASVSRPT(void) { hfile = NULL; start = 0; }
		DVDASVSRPT(DVDHeaderFile * file, DWORD start) {this->hfile = file; this->start = start;}
		virtual ~DVDASVSRPT(void) {}

		Error GetASVStartAddress(int absAsvn, int asvIndex, WORD & asv_sa);
	};

//////////////////////////////////////////////////////////////////////
//
//  Video Object Set for Video Manager Menu
//
//	 Description:
//
//////////////////////////////////////////////////////////////////////

class DVDVMGMVOBS : public DVDMGMVOBS
	{
	public:
		DVDVMGMVOBS(DVDHeaderFile * headerFile, const DVDPTLMAI & ptlmai, DVDDataFile * dataFile);
		virtual ~DVDVMGMVOBS(void);

		Error	GetNumberOfAudioStreams(WORD & num);
		Error	GetAudioStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension, WORD & applicationInfo);
	};

//////////////////////////////////////////////////////////////////////
//
//  Video Object Set for Audio Manager Menu
//
//	 Description:
//		An Video Object Set for Audio Manager Menu (AMGM_VOB) contains
//		the Presentation Data and the part of the Navigation Data. The
//		Navigation Data are AMGM Presentation Control Information and
//		AMGM Data Search Information. The Presentation Data are Video
//		data, Sub-picture data and Audio data.
//
//////////////////////////////////////////////////////////////////////

class DVDAMGMVOBS : public DVDMGMVOBS
	{
	public:
		DVDAMGMVOBS(DVDHeaderFile * headerFile, DVDDataFile * dataFile, const DVDPTLMAI & ptlmai);
		virtual ~DVDAMGMVOBS(void);

		Error GetNumberOfAudioStreams(WORD & num);
		Error GetAudioStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension, WORD & applicationInfo);
	};



#endif // DVDAVHEADER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDDisk.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "DVDDisk.h"

//////////////////////////////////////////////////////////////////////
//
//  DVD Manager Menu Class
//
//////////////////////////////////////////////////////////////////////

DVDMGM::DVDMGM(DVDDiskPlayerFactory * factory)
	{
	hfile = NULL;
	dfile = NULL;
	this->factory = factory;
	}

DVDMGM::~DVDMGM(void)
	{
	if (hfile)
		{
		hfile->Close();
		delete hfile;
		hfile = NULL;
		}

	if (dfile)
		{
		dfile->Close();
		delete dfile;
		dfile = NULL;
		}
	}

//
//  Get number of Title Sets
//

Error DVDMGM::GetNumberOfTS(WORD & num)
	{
	GNREASSERT(hfile->ReadWord(62, num, &rh));
	num = XTBFW(0, 7, num);
	GNRAISE_OK;
	}

//////////////////////////////////////////////////////////////////////
//
//  DVD Title Set Definition
//
//////////////////////////////////////////////////////////////////////

DVDTS::DVDTS(DVDDiskPlayerFactory * factory)
	{
	this->factory = factory;
	hfile = NULL;
	mfile = NULL;
	dfile = NULL;
	}

DVDTS::~DVDTS(void)
	{
	if (hfile)
		{
		hfile->Close();
		delete hfile;
		hfile = NULL;
		}

	if (mfile)
		{
		mfile->Close();
		delete mfile;
		mfile = NULL;
		}

	if (dfile)
		{
		dfile->Close();
		delete dfile;
		dfile = NULL;
		}
	}

//////////////////////////////////////////////////////////////////////
//
//  DVD Disk Class Definition
//
//////////////////////////////////////////////////////////////////////

//
//  Constructor
//

DVDDisk::DVDDisk(DVDDiskPlayerFactory * factory)
	{
	this->factory = factory;
	}

//
//  Destructor
//

DVDDisk::~DVDDisk(void)
	{

	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDAVHeader.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD Audio/Video specific Header File Information
//
////////////////////////////////////////////////////////////////////


#include "DVDAVHeader.h"


//////////////////////////////////////////////////////////////////////
//
//  Program Chain Information
//
//////////////////////////////////////////////////////////////////////

//
//  Constructor
//

DVDPGCI::DVDPGCI(DVDDiskPlayerFactory * factory) : DVDGenericPGCI(factory)
	{
	cmd = NULL;
	}

//
//  Destructor
//

DVDPGCI::~DVDPGCI(void)
	{
	delete[]cmd;
	}

Error DVDPGCI::Init(DVDHeaderFile * file, DWORD start)
	{
	WORD num, program;
	WORD w;

	this->file = file;
	this->start = start;

	GNREASSERT(GetNumberOfPrograms(num));

	GNREASSERT(file->ReadWord(start + 230, w, &rh));
	for(program=1; program<=num; program++)
		{
		GNREASSERT(file->ReadByte(start + w + (program - 1), firstCellOfProgram[program-1], &rh));
		}

	GNRAISE_OK;
	}

Error DVDPGCI::GetPresentationTime(DVDTime & time)
	{
	DWORD d;

	GNREASSERT(file->ReadDWord(start + 4, d, &rh));
	time = DVDTime(d);
	GNRAISE_OK;
	}


Error DVDPGCI::GetUserOperations(DWORD & uop)
	{
	return file->ReadDWord(start + 8, uop, &rh);
	}


Error DVDPGCI::GetAudioStreamControl(int num, WORD & asc)
	{
	if (num > 7)
		{
		asc = 0;
		GNRAISE_OK;
		}
	else
		return file->ReadWord(start + 12 + 2 * num, asc, &rh);
	}


Error DVDPGCI::GetSubPictureStreamControl(int num, DWORD & spsc)
	{
	if (num > 31)
		{
		spsc = 0;
		GNRAISE_OK;
		}
	else
		return file->ReadDWord(start + 28 + 4 * num, spsc, &rh);
	}


Error DVDPGCI::GetNextProgramChain(WORD & next)
	{
	GNREASSERT(file->ReadWord(start + 156, next, &rh));
	next = XTBFW(0, 15, next);
	GNRAISE_OK;
	}


Error DVDPGCI::GetPreviousProgramChain(WORD & prev)
	{
	GNREASSERT(file->ReadWord(start + 156 + 2, prev, &rh));
	prev = XTBFW(0, 15, prev);
	GNRAISE_OK;
	}


Error DVDPGCI::GetUpperProgramChain(WORD & upper)
	{
	return file->ReadWord(start + 156 + 4, upper, &rh);
	}


Error DVDPGCI::GetPlaybackMode(BYTE & mode)
	{
	return file->ReadByte(start + 156 + 6, mode, &rh);
	}


Error DVDPGCI::GetStillTimeValue(BYTE & stillTime)
	{
	return file->ReadByte(start + 156 + 7, stillTime, &rh);
	}


Error DVDPGCI::GetSubPicturePalette(int entry, DWORD & palette)
	{
	GNREASSERT(file->ReadDWord(start + 164 + 4 * entry, palette, &rh));
	palette <<= 8;
	GNRAISE_OK;
	}

//
//  Read Command List
//
//  GNR_OK
//

Error DVDPGCI::ReadCommandList(void)
	{
	RequestHandle rh;
	DWORD position;
	WORD	w;

	if (!cmd)
		{
		GNREASSERT(file->ReadWord(start + 228, w, &rh));
		if (w)
			{
			position = start + w;
			GNREASSERT(file->ReadWordSeq(position, numPreCmd, &rh));
			GNREASSERT(file->ReadWordSeq(position, numPostCmd, &rh));
			GNREASSERT(file->ReadWordSeq(position, w, &rh));
			position += 2;
			cmd = new DVDNavigationCommand[numPreCmd + numPostCmd + w];
			GNREASSERT(file->ReadBytes(position, 8 * (numPreCmd + numPostCmd + w), (HBPTR)cmd, DAF_CACHED, &rh));
			}
		else
			{
			numPreCmd = numPostCmd = 0;
			cmd = NULL;
			}
		}

	GNRAISE_OK;
	}

//
//  Return Pre Commands
//
//  GNR_OK
//

Error DVDPGCI::GetPreCommands(int & num,  DVDNavigationCommand * & cmds)
	{
	GNREASSERT(ReadCommandList());

	if (cmd)
		{
		cmds = cmd;
		num = numPreCmd;
		}
	else
		{
		cmds = NULL;
		num = 0;
		}

	GNRAISE_OK;
	}

//
//  Return Post Commands
//
//  GNR_OK
//

Error DVDPGCI::GetPostCommands(int & num, DVDNavigationCommand * & cmds)
	{
	GNREASSERT(ReadCommandList());

	if (cmd)
		{
		cmds = cmd + numPreCmd;
		num = numPostCmd;
		}
	else
		{
		cmds = NULL;
		num = 0;
		}

	GNRAISE_OK;
	}

//
//  Get Cell Commands
//
//  GNR_OK
//

Error DVDPGCI::GetCellCommands(DVDNavigationCommand * & cmds)
	{
	GNREASSERT(ReadCommandList());

	if (cmd)
		cmds = cmd + numPreCmd + numPostCmd;
	else
		cmds = NULL;

	GNRAISE_OK;
	}


Error DVDPGCI::GetCellInformation(int cell, DVDCPBI & cpbi)
	{
	WORD w;

	GNREASSERT(file->ReadWord(start + 232, w, &rh));
	return cpbi.Init(file, start + w + 24 * (cell - 1));
	}

Error DVDPGCI::GetATSCellInformation(int cell, DVDATSCPBI & atscpbi)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

Error DVDPGCI::GetFirstCellOfProgram(int program, WORD & first)
	{
	first = firstCellOfProgram[program-1];

	GNRAISE_OK;
	}


Error DVDPGCI::GetLastCellOfProgram(int program, WORD & last)
	{
	WORD first;
	WORD num;

	GNREASSERT(GetFirstCellOfProgram(program, first));
	GNREASSERT(GetNumberOfCellsInProgram(program, num));
	last = first + num - 1;
	GNRAISE_OK;
	}


Error DVDPGCI::GetProgramOfCell(int cell, WORD & prog)
	{
	WORD num;
	WORD first;

	GNREASSERT(GetNumberOfPrograms(num));

	prog = 1;
	GNREASSERT(GetFirstCellOfProgram(prog + 1, first));
	while (prog < num && cell >= first)
		{
		prog++;
		GNREASSERT(GetFirstCellOfProgram(prog + 1, first));
		}

	GNRAISE_OK;
	}


Error DVDPGCI::GetNumberOfCellsInProgram(int program, WORD & num)
	{
	WORD first;

	GNREASSERT(GetFirstCellOfProgram(program, first));
	GNREASSERT(GetNumberOfPrograms(num));

	if (program == num)
		{
		GNREASSERT(GetNumberOfCells(num));
		num = num + 1 - first;
		GNRAISE_OK;
		}
	else
		{
		GNREASSERT(GetFirstCellOfProgram(program + 1, num));
		num -= first;
		GNRAISE_OK;
		}
	}

////////////////////////////////////////////////////////////////////
//
//  Audio Title Set Program Chain Information Class
//
////////////////////////////////////////////////////////////////////

DVDATSPGCI::DVDATSPGCI(DVDDiskPlayerFactory * factory) : DVDGenericPGCI(factory)
	{

	}

DVDATSPGCI::~DVDATSPGCI(void)
	{
	}

Error DVDATSPGCI::Init(DVDHeaderFile * file, DWORD start)
	{
	this->file = file;
	this->start = start;
	GNRAISE_OK;
	}

//
// The total presentation time in ATS_PGCI is measured in the following
//	format:
//		Total presentation time = ATS_PGC_PB_TM[31..0] / 90000 (seconds)
//

Error DVDATSPGCI::GetPresentationTime(DVDTime & time)
	{
	DWORD d;

	GNREASSERT(file->ReadDWord(start + 4, d, &rh));
	time = DVDTime(0, 0, d/90000, 0, 0);
	GNRAISE_OK;
	}

//
// There are no user operation for AOTTs.
//	0b: Corresponding User Operation is permitted.
//	1b: Corresponding User Operation is prohibited.
//

Error DVDATSPGCI::GetUserOperations(DWORD & uops)
	{
	uops = 0;
	GNRAISE_OK;
	}

//
// There is no Audio Stream Control for AOTTs.
//

Error DVDATSPGCI::GetAudioStreamControl(int num, WORD & asc)
	{
	asc = 0;
	GNRAISE_OK;
	}

//
// There is no Sub-Picture Stream Control for AOTTs.
//

Error DVDATSPGCI::GetSubPictureStreamControl(int num, DWORD & spsc)
	{
	spsc = 0;
	GNRAISE_OK;
	}

//
// There is no Navigation Control for AOTTs.
// 0 means the PGC is nonexistent.
//

Error DVDATSPGCI::GetNextProgramChain(WORD & next)
	{
	next = 0;
	GNRAISE_OK;
	}

//
// There is no Navigation Control for AOTTs.
// 0 means the PGC is nonexistent.
//

Error DVDATSPGCI::GetPreviousProgramChain(WORD & prev)
	{
	prev = 0;
	GNRAISE_OK;
	}

//
// There is no Navigation Control for AOTTs.
// 0 means the PGC is nonexistent.
//

Error DVDATSPGCI::GetUpperProgramChain(WORD & upper)
	{
	upper = 0;
	GNRAISE_OK;
	}

//
// There is no Navigation Control for AOTTs.
// 0 means sequential playback.
//

Error DVDATSPGCI::GetPlaybackMode(BYTE & mode)
	{
	mode = 0;
	GNRAISE_OK;
	}

//
// There is no Navigation Control for AOTTs.
//	0 means no still value.
//

Error DVDATSPGCI::GetStillTimeValue(BYTE & stillTime)
	{
	stillTime = 0;
	GNRAISE_OK;
	}

//
// There is no Sub-Picture Palette for AOTTs.
// Return the min values for all colours:
//	16 <= Y <= 235
// 16 <= Cr <= 240
//	16 <= Cb <= 240
//

Error DVDATSPGCI::GetSubPicturePalette(int entry, DWORD & palette)
	{
	palette = 0x00101010;
	GNRAISE_OK;
	}

//
// There is no Command Table for AOTTs.
//

Error DVDATSPGCI::GetPreCommands(int & num,  DVDNavigationCommand * & cmds)
	{
	cmds = NULL;
	num = 0;
	GNRAISE_OK;
	}

//
// There is no Command Table for AOTTs.
//

Error DVDATSPGCI::GetPostCommands(int & num, DVDNavigationCommand * & cmds)
	{
	cmds = NULL;
	num = 0;
	GNRAISE_OK;
	}

//
// There is no Command Table for AOTTs.
//

Error DVDATSPGCI::GetCellCommands(DVDNavigationCommand * & cmds)
	{
	cmds = NULL;
	GNRAISE_OK;
	}

//
//	Only used for DVD-Video or DVD-Audio Manager Menu
//

Error DVDATSPGCI::GetCellInformation(int cell, DVDCPBI & cpbi)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
// Return Audio Title Set Cell Playback Information
//

Error DVDATSPGCI::GetATSCellInformation(int cell, DVDATSCPBI & atscpbi)
	{
	WORD w;

	GNREASSERT(file->ReadWord(start + 12, w, &rh));
	return atscpbi.Init(file, start + w + 12 * (cell - 1));
	}

//
// There is no Program Map for AOTTs.
//

Error DVDATSPGCI::GetFirstCellOfProgram(int program, WORD & first)
	{
	first = 0;
	GNRAISE_OK;
	}

Error DVDATSPGCI::GetLastCellOfProgram(int program, WORD & last)
	{
	last = 0;
	GNRAISE_OK;
	}

Error DVDATSPGCI::GetProgramOfCell(int cell, WORD & prog)
	{
	prog = 0;
	GNRAISE_OK;
	}

Error DVDATSPGCI::GetNumberOfCellsInProgram(int program, WORD & num)
	{
	num = 0;
	GNRAISE_OK;
	}

////////////////////////////////////////////////////////////////////
//
//  Program Chain Information Table
//
////////////////////////////////////////////////////////////////////

Error DVDPGCIT::GetNumberOfPGC(WORD & num)
	{
	return file->ReadWord(start, num, &rh);
	}

Error DVDPGCIT::GetParentalID(WORD pgc, WORD & id)
	{
	if (isATSPGCIT)
		id = 0;
	else
		GNREASSERT(file->ReadWord(start + 8 + 8 * (pgc - 1) + 2, id, &rh));

	GNRAISE_OK;
	}

Error DVDPGCIT::GetTitle(WORD pgc, WORD & title)
	{
	BYTE b;

	GNREASSERT(file->ReadByte(start + 8 + 8 * (pgc - 1), b, &rh));
	title = XTBFB(0, 7, b);
	GNRAISE_OK;
	}

Error DVDPGCIT::GetMenuType(WORD pgc, VTSMenuType & type)
	{
	BYTE b;

	GNREASSERT(file->ReadByte(start + 8 + 8 * (pgc - 1), b, &rh));

	switch (XTBFB(0, 4, b))
		{
		case 2:
			type = VMT_TITLE_MENU;
			break;
		case 3:
			type = VMT_ROOT_MENU;
			break;
		case 4:
			type = VMT_SUBPICTURE_MENU;
			break;
		case 5:
			type = VMT_AUDIO_MENU;
			break;
		case 6:
			type = VMT_ANGLE_MENU;
			break;
		case 7:
			type = VMT_PTT_MENU;
			break;
		default:
			type = VMT_NO_MENU;
			break;
		}

	GNRAISE_OK;
	}

Error DVDPGCIT::FindMenu(VTSMenuType type, WORD & menu)
	{
	VTSMenuType mt;
	WORD num;
	BOOL hasEntryPGC;

	GNREASSERT(GetNumberOfPGC(num));

	for (menu=1; menu<=num; menu++)
		{
		GNREASSERT(GetMenuType(menu, mt));
		GNREASSERT(HasEntryPGC(menu, hasEntryPGC));
		if (type == mt && hasEntryPGC)
			GNRAISE_OK;
		}

//	GNRAISE(GNR_OBJECT_NOT_FOUND);
	menu = 0;
	GNRAISE_OK;
	}

//
// Get the number of channels of the Audio data contained in an ATS_PGC.
// TRUE: Audio data of more than 2 channels is included
// FALSE: every Audio data is 2 channels or less
//

Error DVDPGCIT::GetAudioChannels(WORD pgc, BOOL & hasMoreThanTwoChannels)
	{
	BYTE b;

	GNREASSERT(file->ReadByte(start + 8 + 8 * (pgc - 1) + 1, b, &rh));

	hasMoreThanTwoChannels = XTBFB(0, 4, b);

	GNRAISE_OK;
	}

//
//	Get Audio coding mode of the audio data contained in an ATS_PGC
//

Error DVDPGCIT::GetAudioCodingMode(WORD pgc, DVDAudioCodingMode & acm)
	{
	BYTE b;

	GNREASSERT(file->ReadByte(start + 8 + 8 * (pgc - 1) + 2, b, &rh));

	//
	// Audio coding mode in ATS_PGC_TABLE is defined as follows:
	//		0000 0000b: Linear PCM audio
	//		0000 0001b: Packed PCM audio
	//		0000 0010b: Dolby Digital
	//		0000 0011b: MPEG-2 without extension
	//		0000 0100b: MPEG-2 with extension
	//		0000 0101b: DTS
	//		0000 0110b: SDDS

	switch (b)
		{
		case 0:
		case 1:
			acm = DAM_LPCM;
			break;
		case 2:
			acm = DAM_AC3;
			break;
		case 3:
		case 4:
			acm = DAM_MPEG2;
			break;
		case 5:
			acm = DAM_DTS;
			break;
		case 6:
			acm = DAM_SDDS;
			break;
		default:
			acm = DAM_LPCM;
			break;
		}

	GNRAISE_OK;
	}

Error DVDPGCIT::GetBlockMode(WORD pgc, PGCBlockMode & mode)
	{
	BYTE b;

	GNREASSERT(file->ReadByte(start + 8 + 8 * (pgc - 1) + 1, b, &rh));
	mode = (PGCBlockMode)XTBFB(6, 2, b);
	GNRAISE_OK;
	}

Error DVDPGCIT::GetBlockType(WORD pgc, PGCBlockType & type)
	{
	BYTE b;

	GNREASSERT(file->ReadByte(start + 8 + 8 * (pgc - 1) + 1, b, &rh));
	type = (PGCBlockType)XTBFB(4, 2, b);

	// value "1" for the block type is different in the meaning between DVD-Video and DVD-Audio.
	// For DVD-Video it means Parental Block whereas for DVD-Audio it means block for the difference
	// of only "Audio Coding Mode". So we have to adapt the block type!
	if (type == PBT_PARENTAL_BLOCK && isATSPGCIT)
		type = PBT_AUDIO_CODING_DIFF;

	GNRAISE_OK;
	}

Error DVDPGCIT::HasEntryPGC(WORD pgc, BOOL & entryPGC)
	{
	BYTE b;

	GNREASSERT(file->ReadByte(start + 8 + 8 * (pgc - 1), b, &rh));
	entryPGC = (BOOL)XTBF(7, b);
	GNRAISE_OK;
	}

Error DVDPGCIT::GetPGCI(WORD pgc, DVDGenericPGCI * & pgci)
	{
	Error err;
	DWORD d;

	GNREASSERT(file->ReadDWord(start + 8 + 8 * (pgc - 1) + 4, d, &rh));
	if (isATSPGCIT)
		pgci = new DVDATSPGCI(factory);
	else
		pgci = new DVDPGCI(factory);
	if (IS_ERROR(err = pgci->Init(file, start + d)))
		{
		delete pgci;
		pgci = NULL;
		}

	GNRAISE(err);
	}

//////////////////////////////////////////////////////////////////////
//
//  Program Chain Information Unit Table
//
//////////////////////////////////////////////////////////////////////

//
//  Return the number of language units
//

Error DVDPGCIUT::GetNumberOfLanguageUnits(WORD & num)
	{
	return file->ReadWord(start, num, &rh);
	}

//
//  Check if menu exists
//

Error DVDPGCIUT::MenuExists(WORD lu, VTSMenuType type, BOOL & exists)
	{
	BYTE b;

	GNREASSERT(file->ReadByte(start + 8 + (lu - 1) * 8 + 3, b, &rh));

	switch (type)
		{
		case VMT_TITLE_MENU:
			exists = XTBF(7, b);
			break;
		case VMT_ROOT_MENU:
			exists = XTBF(7, b);
			break;
		case VMT_SUBPICTURE_MENU:
			exists = XTBF(6, b);
			break;
		case VMT_AUDIO_MENU:
			exists = XTBF(5, b);
			break;
		case VMT_ANGLE_MENU:
			exists = XTBF(4, b);
			break;
		case VMT_PTT_MENU:
			exists = XTBF(3, b);
			break;
		default:
			GNRAISE(GNR_INVALID_PARAMETERS);
		}

	GNRAISE_OK;
	}

//
//  Return the language code
//

Error DVDPGCIUT::GetLanguageCode(WORD lu, WORD & lc)
	{
	return file->ReadWord(start + 8 + (lu - 1) * 8, lc, &rh);
	}

//
//  Initialize the PGCIT
//

Error DVDPGCIUT::GetPGCIT(WORD lu, DVDPGCIT & pgcit)
	{
	DWORD d;

	GNREASSERT(file->ReadDWord(start + 8 + (lu - 1) * 8 + 4, d, &rh));
	pgcit = DVDPGCIT(factory, file, start + d);
	GNRAISE_OK;
	}

//////////////////////////////////////////////////////////////////////
//
//  Video Title Search Pointer Table (in VMGI)
//
//////////////////////////////////////////////////////////////////////

DVDVTTSRPT::DVDVTTSRPT(void) : DVDSRPT()
	{

	}

DVDVTTSRPT::DVDVTTSRPT(DVDHeaderFile * file, DWORD start) : DVDSRPT(file, start)
	{

	}

DVDVTTSRPT::DVDVTTSRPT(const DVDVTTSRPT & srpt) : DVDSRPT(srpt)
	{

	}

DVDVTTSRPT::~DVDVTTSRPT(void)
	{

	}

//
//  Return number of Part Of Titles of Title 'title'
//

Error DVDVTTSRPT::GetNumberOfPartOfTitle(WORD title, WORD & num)
	{
	return file->ReadWord(start + 8 + (title - 1) * 12 + 2, num, &rh);
	}

//
//  Return number of Angles of Title 'title'
//

Error DVDVTTSRPT::GetNumberOfAngles(WORD title, WORD & num)
	{
	BYTE b;
	Error err;

	if (title)
		{
		err = file->ReadByte(start + 8 + (title - 1) * 12 + 1, b, &rh);
		num = b;
		GNRAISE(err);
		}
	else
		{
		num = 1;
		GNRAISE_OK;
		}
	}

//
//  Get UOPs
//

Error DVDVTTSRPT::GetUOPS(WORD title, DWORD & uops)
	{
	BYTE stat;

	GNREASSERT(file->ReadByte(start + 8 + (title - 1) * 12 + 0, stat, &rh));
	uops = (DWORD)stat & 3;
	GNRAISE_OK;
	}

//
//  Get Video Title Set and Video Title Set Title number from global Title Number
//

Error DVDVTTSRPT::GetTitle(WORD title, WORD & tsn, WORD & ttn)
	{
	BYTE vtsNumber, vtsTitleNumber;
	DWORD pos = start + 8 + (title - 1) * 12;

	pos += 6;

	GNREASSERT(file->ReadByteSeq(pos, vtsNumber, &rh));
	GNREASSERT(file->ReadByteSeq(pos, vtsTitleNumber, &rh));

	tsn = vtsNumber;
	ttn = vtsTitleNumber;

	GNRAISE_OK;
	}

//
//	 Get title from Video Title Set Number and Video Title Set Title Number
//

Error DVDVTTSRPT::GetTitleOfTSTitle(WORD tsn, WORD tsTitle, WORD & title)
	{
	BYTE vtsNumber, vtsTitleNumber;
	DWORD pos;
	WORD num;

	GNREASSERT(GetNumberOfTitles(num));
	for(title = 1; title <= num; title++)
		{
		pos = start + 8 + (title - 1) * 12 + 6;

		//
		// Check Video Title Set number
		//

		GNREASSERT(file->ReadByteSeq(pos, vtsNumber, &rh));
		if (vtsNumber == tsn)
			{
			//
			//  Check Video Title Set Title Number
			//

			GNREASSERT(file->ReadByteSeq(pos, vtsTitleNumber, &rh));
			if (vtsTitleNumber == tsTitle)
				GNRAISE_OK;
			}
		}

	title = 0;

	GNRAISE(GNR_RANGE_VIOLATION);
	}

//
//  Check if title is "OneSequentialPGCTitle"
//

Error DVDVTTSRPT::IsOneSequentialPGCTitle(WORD title, BOOL & iospt)
	{
	BYTE titlePlaybackType = 0x40;	// This makes sure that breakpoints are not allowed in case of error

	GNREASSERT(file->ReadByte(start + 8 + 12 * (title - 1), titlePlaybackType, &rh));
	iospt = !(titlePlaybackType & 0x40);
	GNRAISE_OK;
	}

//////////////////////////////////////////////////////////////////////
//
//  Audio Title Search Pointer Table (in AMGI)
//
//////////////////////////////////////////////////////////////////////

DVDATTSRPT::DVDATTSRPT(void) : DVDSRPT()
	{

	}

DVDATTSRPT::DVDATTSRPT(DVDHeaderFile * file, DWORD start) : DVDSRPT(file, start)
	{

	}

DVDATTSRPT::DVDATTSRPT(const DVDATTSRPT & srpt) : DVDSRPT(srpt)
	{

	}

DVDATTSRPT::~DVDATTSRPT(void)
	{

	}

//
// Describes whether this ATT is AOTT or AVTT
//	0b: AVTT, 1b: AOTT
//

Error DVDATTSRPT::IsAOTT(WORD title, BOOL & isAOTT)
	{
	BYTE b;

	GNREASSERT(file->ReadByte(start + 4 + (title - 1) * 14 + 0, b, &rh));
	if (b & 0x80) isAOTT = TRUE;
	else isAOTT = FALSE;

	GNRAISE_OK;
	}

Error DVDATTSRPT::GetNumberOfPartOfTitle(WORD title, WORD & num)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Return number of Angles of Title 'title' when this is a AVTT
//	 else return unimplemented
//

Error DVDATTSRPT::GetNumberOfAngles(WORD title, WORD & num)
	{
	BYTE b;
	Error err;
	BOOL isAOTT;

	GNREASSERT(IsAOTT(title, isAOTT));

	if (!isAOTT)
		{
		err = file->ReadByte(start + 4 + (title - 1) * 14 + 2, b, &rh);
		num = b;

		GNRAISE(err);
		}
	else
		num = 0;

	GNRAISE_OK;
	}

Error DVDATTSRPT::GetUOPS(WORD title, DWORD & uops)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

Error DVDATTSRPT::GetTitle(WORD title, WORD & tsn, WORD & ttn)
	{
	BYTE atsNumber, atsTrackNumber;
	DWORD pos = start + 4 + (title - 1) * 14;

	pos += 8;

	GNREASSERT(file->ReadByteSeq(pos, atsNumber, &rh));
	GNREASSERT(file->ReadByteSeq(pos, atsTrackNumber, &rh));

	tsn = atsNumber;
	ttn = atsTrackNumber;

	GNRAISE_OK;
	}

//
//	 Get title from Audio Title Set Number and Audio Title Set Title Number
//

Error DVDATTSRPT::GetTitleOfTSTitle(WORD tsn, WORD tsTitle, WORD & title)
	{
	BYTE atsNumber, atsTitleNumber;
	DWORD pos;
	WORD num;

	GNREASSERT(GetNumberOfTitles(num));
	for(title = 1; title <= num; title++)
		{
		pos = start + 4 + (title - 1) * 14 + 8;

		//
		// Check Audio Title Set number
		//

		GNREASSERT(file->ReadByteSeq(pos, atsNumber, &rh));
		if (atsNumber == tsn)
			{
			//
			//  Check Audio Title Set Title Number
			//

			GNREASSERT(file->ReadByteSeq(pos, atsTitleNumber, &rh));
			if (atsTitleNumber == tsTitle)
				GNRAISE_OK;
			}
		}

	title = 0;

	GNRAISE(GNR_RANGE_VIOLATION);
	}

Error DVDATTSRPT::IsOneSequentialPGCTitle(WORD title, BOOL & iospt)
	{
	//
	// An Audio with Video Title (AVTT) is always defined as One-sequential PGC in the VTS.
	// The AVTT is the ATT accompanied with video contents.
	// So we have to make a distinction if the ATT is an AVTT or AOTT and return the
	// appropriate type.
	// => if (AVTT) iospt = TRUE; else if (AOTT) iospt = FALSE;
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//////////////////////////////////////////////////////////////////////
//
//  Audio Still Video Search Pointer Table
//
//////////////////////////////////////////////////////////////////////

//
// Returns the start address of the ASVOB. Whereas absAsvn describes
//	the first ABS_ASVN of this ASVU and asvIndex describes the
// ASV number.
//

Error DVDASVSRPT::GetASVStartAddress(int absAsvn, int asvIndex, WORD & asv_sa)
	{
	GNREASSERT(hfile->ReadWord(start + absAsvn + 2 * asvIndex, asv_sa, &rh));

	GNRAISE_OK;
	}

//////////////////////////////////////////////////////////////////////
//
//  Video Manager Menu VOBS
//
//////////////////////////////////////////////////////////////////////

DVDVMGMVOBS::DVDVMGMVOBS(DVDHeaderFile * headerFile, const DVDPTLMAI & ptlmai, DVDDataFile * dataFile)
	: DVDMGMVOBS(headerFile, dataFile, ptlmai)
	{

	}

DVDVMGMVOBS::~DVDVMGMVOBS(void)
	{

	}

Error DVDVMGMVOBS::GetNumberOfAudioStreams(WORD & num)
	{
	return headerFile->ReadWord(258, num, &rh);
	}

Error DVDVMGMVOBS::GetAudioStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension, WORD & applicationInfo)
	{
	GNREASSERT(headerFile->ReadWord(260 + 8 * num, attrib, &rh));

	//
	// language, extension, and applicationInfo are reserved according to the DVD specification.
	// So initialize them with initial values (MST, 03/07/01)
	//
	language = 0xffff;
	extension = 0x0000;
	applicationInfo = 0x0000;

	GNRAISE_OK;
	}

//////////////////////////////////////////////////////////////////////
//
//  Video Object Set for Audio Manager Menu
//
//////////////////////////////////////////////////////////////////////

DVDAMGMVOBS::DVDAMGMVOBS(DVDHeaderFile * headerFile, DVDDataFile * dataFile, const DVDPTLMAI & ptlmai)
	: DVDMGMVOBS(headerFile, dataFile, ptlmai)
	{

	}

DVDAMGMVOBS::~DVDAMGMVOBS(void)
	{

	}

Error DVDAMGMVOBS::GetNumberOfAudioStreams(WORD & num)
	{
	return headerFile->ReadWord(348, num, &rh);
	}

Error DVDAMGMVOBS::GetAudioStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension, WORD & applicationInfo)
	{
	GNREASSERT(headerFile->ReadWord(350 + 8 * num, attrib, &rh));

	//
	// language, extension, and applicationInfo are reserved according to the DVD specification.
	// So initialize them with initial values (MST, 03/07/01)
	//
	language = 0xffff;
	extension = 0x0000;
	applicationInfo = 0x0000;

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDDisk.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef DVDDISK_H
#define DVDDISK_H

#include "DVDFile.h"
#include "DVDHeader.h"
#include "DVDAVHeader.h"


//////////////////////////////////////////////////////////////////////
//
//  DVD Manager Menu Class
//
//	 Description:
//		DVD Manager Menu Class is an abstract class as well for DVD
//		Video Manager Menu as for DVD Audio Manager Menu
//
//////////////////////////////////////////////////////////////////////

class DVDMGM
	{
	protected:
		RequestHandle				rh;
		DVDHeaderFile			*	hfile;
		DVDDataFile				*	dfile;
		DVDPTLMAI					ptlmai;
		DVDFileSystem			*	dvdfs;
		DVDDiskPlayerFactory	*	factory;

	public:
		DVDMGM(DVDDiskPlayerFactory * factory);
		virtual ~DVDMGM(void);

		virtual Error Init(DVDFileSystem * dvdfs, WORD parentalCountryCode) = 0;

		virtual Error Identify(DVDManagerMenuType & mgmType) = 0;
		virtual Error HasMGMVOBS(BOOL & hasMGMVOBS) = 0;
		virtual Error GetMGMVOBS(DVDMGMVOBS * & mgmvobs) = 0;
		virtual Error HasFirstPlayPGC(BOOL & hasFPP) = 0;
		virtual Error GetFirstPlayPGCI(DVDGenericPGCI * & pgci) = 0;
		virtual Error HasMPGCIUT(BOOL & hasMPGCIUT) = 0;
		virtual Error GetMPGCIUT(DVDPGCIUT & pgciut) = 0;
		virtual Error GetSRPT(DVDSRPT * & srpt) = 0;
		virtual Error GetNumberOfTS(WORD & num);
		virtual Error GetPTLMAI(DVDPTLMAI & ptlmai) { ptlmai = this->ptlmai; GNRAISE_OK; }
		virtual Error GetHeaderFile(DVDHeaderFile * & hfile) { hfile = this->hfile; GNRAISE_OK; }
	};

//////////////////////////////////////////////////////////////////////
//
//  DVD Title Set Class
//
//	 Description:
//		Abstract class for Video Title Set and Audio Title Set Class.
//
//////////////////////////////////////////////////////////////////////

class DVDTS
	{
	protected:
		DVDDiskPlayerFactory *	factory;
		DVDHeaderFile			*  hfile;
		DVDDataFile				*	mfile;
		DVDDataFile				*	dfile;
		RequestHandle				rh;

	public:
		DVDTS(DVDDiskPlayerFactory * factory);
		virtual ~DVDTS(void);

		virtual Error Init(DVDFileSystem * dvdfs, WORD ts, DVDPTLMAI ptlmai) = 0;

		virtual Error HasPTT(BOOL & hasPTT) = 0;
		virtual Error GetPTT(DVDPTT & ptt) = 0;
		virtual Error HasMPGCIUT(BOOL & hasMPGCIUT) = 0;
		virtual Error GetMPGCIUT(DVDPGCIUT & pgciut) = 0;
		virtual Error GetPGCIT(DVDPGCIT & pgcit) = 0;
		virtual DVDVTSMVOBS * GetVTSMVOBS(void) {return NULL;}
		virtual DVDVTSVOBS * GetVTSVOBS(void) {return NULL;}
		virtual DVDATSAOTTOBS * GetATSAOBS(void) {return NULL;}
		virtual DVDOBS * GetTSOBS(void) = 0;
	};

//////////////////////////////////////////////////////////////////////
//
//  DVD Disk Class
//
//////////////////////////////////////////////////////////////////////

class DVDDisk
	{
	protected:
		DVDDiskPlayerFactory * factory;
		DVDFileSystem	*	diskfs;
		int					currentTSNum;

	public:
		DVDDisk(DVDDiskPlayerFactory * factory);
		virtual ~DVDDisk(void);

		virtual Error	Init(DVDFileSystem * diskfs, WORD parentalCountryCode) = 0;
		virtual DVDMGM * GetMGM(void) = 0;
		virtual Error	GetTS(WORD num, DVDTS * & titleSet) = 0;
		virtual Error	GetTSExclusive(WORD num, DVDTS * & titleSet, BOOL & deleteIt) = 0;
		virtual DVDFileSystem * GetDiskFileSystem(void) { return diskfs; }
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDDiskPlayer.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVDDiskPlayerClass
//
//  Implements the player interface for DVDs
//
////////////////////////////////////////////////////////////////////

#ifndef DVDDISKPLAYER_H
#define DVDDISKPLAYER_H

#include "CDDiskPlayer.h"
#include "DVDDiskSeq.h"
#include "Config/DiskPlayerFactory.h"

#pragma warning(disable : 4250)

class DVDDiskPlayerClass : public CDDiskPlayerClass, protected DVDDiskSequencer, protected WinPort
	{
	protected:
		BOOL stillPhase;
		DVDFileSystem * dvdfs;

		virtual Error StartStillPhase(WORD delay);
		virtual Error CancelStillPhase(void);

		void Message(WPARAM wParam, LPARAM dParam);
		virtual Error InternalGetMode(DVDPlayerMode & mode);
		virtual Error IsPlayingForward(BOOL & forward);

		//
		//  Freezing stuff
		//

		class DVDFreezeState : public DDPFreezeState
			{
			public:
				DVDDSFreezeState dsFreezeState;
			};

		virtual Error DiskIsEncrypted(BOOL & enc);

		virtual Error GoTitle(WORD title, DWORD flags = DDPSPF_NONE);

		virtual Error GoPartOfTitle(WORD title, WORD part);

	public:
		DVDDiskPlayerClass(WinPortServer * server, UnitSet units, DVDDiskPlayerFactory * factory);

		~DVDDiskPlayerClass(void);

		virtual Error Init(WinPortServer * server, GenericProfile * profile, DVDDiskType diskType, DVDFileSystem * dvdfs, BYTE region);

		virtual Error GetMode(DVDPlayerMode & mode);

		virtual Error GetExtendedPlayerState(ExtendedPlayerState * eps);

		virtual Error StopStillPhase(void);

		virtual Error Exit(Error err = GNR_OK);

		virtual Error CallMenu(VTSMenuType menu);

		virtual Error PausePlayback(void);

		virtual Error ResumePlayback(void);

		virtual Error AdvanceFrame(void);

		virtual Error AdvanceFrameBy(int n);

		virtual Error SetPlaybackSpeed(WORD speed);

		virtual Error GetPlaybackSpeed(WORD & speed);

		virtual Error GetAudioStreamAttributes(WORD stream, DVDAudioStreamFormat	& attributes);

		virtual Error GetSubPictureStreamAttributes(WORD stream, DVDSubPictureStreamFormat	& attributes);

		virtual Error StartPresentation(DWORD flags);

		virtual Error GetCurrentLocation(DVDLocation & location);

		virtual Error GetCurrentDuration(DVDLocation & location);

		virtual Error GetTitleDuration(WORD title, DVDTime & duration);

		virtual Error MenuAvail(VTSMenuType menu, BOOL & avail);

		virtual Error GetUOPs(DWORD & uops);

		virtual Error UOPPermitted(int uops, BOOL & permitted);

		virtual Error GetTitleSearchUOPs(WORD title, DWORD & uops);

		virtual Error TitleSearchUOPPermitted(WORD title, int uops, BOOL & permitted);

		virtual Error NumberOfTitles(WORD & num);

		virtual Error NumberOfPartOfTitle(WORD title, WORD & num);

		virtual Error GetAvailStreams(BYTE & audio, DWORD & subPicture);

		virtual Error GetCurrentAudioStream(WORD & stream);

		virtual Error GetCurrentSubPictureStream(WORD & stream);

		virtual Error IsCurrentSubPictureEnabled(BOOL & enabled);

		virtual Error GetNumberOfAngles(WORD title, WORD & num);

		virtual Error GetCurrentAngle(WORD & angles);

		virtual Error ClearGPRMs(void);		// NOT virtual

		virtual Error TitlePlay(WORD title, DWORD flags = DDPSPF_NONE);

		virtual Error PTTPlay(WORD title, WORD part);

		virtual Error GoTrack(WORD track, WORD titleGroupNumber);

		virtual Error TimePlay(WORD title, DVDTime time);

		virtual Error GoUpProgramChain(void);

		virtual Error TimeSearch(DVDTime time);

		virtual Error PTTSearch(WORD part);

		virtual Error GoPrevProgram(void);

		virtual Error GoTopProgram(void);

		virtual Error GoNextProgram(void);

		virtual Error ExtendedPlay(DWORD flags, WORD title, WORD ptt, DVDTime time);

		virtual Error StartForwardScan(WORD speed);

		virtual Error StartBackwardScan(WORD speed);

		virtual Error GetScanSpeed(WORD & speed);

		virtual Error StopScan(void);

		virtual Error StartReversePlayback(void);

		virtual Error StartTrickplay(void);

		virtual Error ResumeFromSystemSpace(void);

		virtual Error ButtonUp(void);

		virtual Error ButtonDown(void);

		virtual Error ButtonLeft(void);

		virtual Error ButtonRight(void);

		virtual Error ButtonSelectAt(WORD x, WORD y);

		virtual Error ButtonActivate(void);

		virtual Error ButtonSelectAndActivate(WORD button);

		virtual Error ButtonSelectAtAndActivate(WORD x, WORD y);

		virtual Error IsButtonAt(WORD x, WORD y, BOOL & isButton);

		virtual Error HasPositionalButtons(BOOL & hasButtons);

		virtual Error MenuLanguageSelect(WORD language);

		virtual Error GetMenuLanguage(WORD & lang);

		virtual Error AudioStreamChange(WORD stream);

		virtual Error SubPictureStreamChange(WORD stream, BOOL enable);

		virtual Error AngleChange(WORD angle);

		virtual Error ParentalLevelSelect(WORD level);

		virtual Error ParentalCountrySelect(WORD country);

		virtual Error GetCurrentDisplayMode(DisplayPresentationMode & mode);

		virtual Error SetDisplayMode(DisplayPresentationMode mode);

		virtual Error GetCurrentVideoStandard(VideoStandard & standard);

		virtual Error SelectInitialLanguage(WORD audioLanguage, WORD audioExtension, WORD subPictureLanguage, WORD subPictureExtension);

		virtual Error TransferDiskKey(void);

		virtual Error GetCurrentBitrate(DWORD & bitrate);

		virtual Error GetCurrentButtonState(WORD & minButton, WORD & numButtons, WORD & currentButton);

		virtual Error Freeze (DDPFreezeState * state, DWORD & size);

		virtual Error Defrost(DDPFreezeState * state, DWORD & size, DWORD flags);

		virtual Error SetBreakpoint(WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id);

		virtual Error ClearBreakpoint(DWORD id);

		virtual Error SetAudioStreamSelectionPreferences(DWORD flags);
	};

#pragma warning(default : 4250)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDDiskPlayer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
//  DVDDiskPlayerClass
//
//////////////////////////////////////////////////////////////////////

#include "DVDDiskPlayer.h"

#define MKLANG(c, d)	(((WORD)c << 8) | (WORD)d)

//
//  Constructor
//

DVDDiskPlayerClass::DVDDiskPlayerClass(WinPortServer * server, UnitSet units, DVDDiskPlayerFactory * factory)
	: CDDiskPlayerClass() //this one HAS TO be called before constructors that pass &eventDispatcherInstance
	, WinPort(server)
	, DVDDiskSequencer(server, units, factory, &eventDispatcherInstance)
	, EventSender(&eventDispatcherInstance)
	, ERSBreakpointControl(&eventDispatcherInstance)
	{
	dvdfs = NULL;
	}

//
//  Destructor
//

DVDDiskPlayerClass::~DVDDiskPlayerClass(void)
	{
	Exit();
	if (dvdfs)
		{
		dvdfs->SetEventDispatcher(NULL);
		dvdfs->Release();
		}
	}

//
//  Initialize
//

Error DVDDiskPlayerClass::Init(WinPortServer * server, GenericProfile * profile, DVDDiskType diskType, DVDFileSystem * dvdfs, BYTE region)
	{
	BOOL enc;

	if (dvdfs)
		dvdfs->SetEventDispatcher(&eventDispatcherInstance);

	//
	//  Initialize base classes
	//

	GNREASSERT(CDDiskPlayerClass::Init(server, profile, diskType, dvdfs));
	GNREASSERT(DVDDiskSequencer::Init(dvdfs, MKLANG('e', 'n')));

	//
	//  Initialize *PRMs
	//

	ClearGPRMs();

	SetSPRM(0, MKLANG('e', 'n'));
	SetSPRM(1, 15);
	SetSPRM(2, 63);
	SetSPRM(9, 0);
	SetSPRM(10, 0);
	SetSPRM(13, 15);
	SetSPRM(16, MKLANG('e', 'n'));
	SetSPRM(18, MKLANG('e', 'n'));
	SetSPRM(20, region ^ 0xff);

	stillPhase = FALSE;

	//
	//  Check if disk is encrypted and perform key exchange if so
	//

	GNREASSERT(dvdDisk->GetDiskFileSystem()->DVDIsEncrypted(enc));
	if (enc)
		GNREASSERT(TransferDiskKey());

	else
		{
		// try for the encrypted but not marked disc(CliffHanger/CableGuy WS)
		DVDHeaderFile * headerFile;
		Error err;

		err = mgm->GetHeaderFile(headerFile);
		if (!IS_ERROR(err))
			{
			err = player->TransferDiskKey(headerFile);
			}
		}

	//
	//  Store the file system. This must not be done in case of errors, otherwise it will be deleted
	//  twice and the system will crash.
	//

	this->dvdfs = dvdfs;
	GNRAISE_OK;
	}

//
//  Test if DVD is encrypted
//

Error DVDDiskPlayerClass::DiskIsEncrypted(BOOL & enc)
	{
	return DVDDiskSequencer::DiskIsEncrypted(enc);
	}

//
//  Pause playback
//

Error DVDDiskPlayerClass::PausePlayback(void)
	{
	if (!stillPhase && GetDomain() != STOP_DOM)
		{
		if (IsScanning())
			return DVDDiskSequencer::StopScan(TRUE);
		else
			return DVDDiskSequencer::Pause();
		}
	else
		GNRAISE_OK;
	}

//
//  Resume playback
//

Error DVDDiskPlayerClass::ResumePlayback(void)
	{
	dvdDisk->GetDiskFileSystem()->SpinUpDrive();
	return DVDDiskSequencer::Resume();
	}

Error DVDDiskPlayerClass::AdvanceFrame(void)
	{
	if (!stillPhase && GetDomain() != STOP_DOM)
		{
		return player->Step();
		}
	else
		GNRAISE(GNR_OPERATION_PROHIBITED);
	}

Error DVDDiskPlayerClass::AdvanceFrameBy(int n)
	{
	if (!stillPhase && GetDomain() != STOP_DOM)
		{
		return player->StepBy(n);
		}
	else
		GNRAISE(GNR_OPERATION_PROHIBITED);
	}

Error DVDDiskPlayerClass::SetPlaybackSpeed(WORD speed)
	{
	return player->SetPlaybackSpeed(speed);
	}

Error DVDDiskPlayerClass::IsPlayingForward(BOOL & forward)
	{
	forward = DVDPGCSequencer::IsPlayingForward();
	GNRAISE_OK;
	}

Error DVDDiskPlayerClass::GetPlaybackSpeed(WORD & speed)
	{
	speed = player->GetPlaybackSpeed();
	GNRAISE_OK;
	}

Error DVDDiskPlayerClass::ClearGPRMs(void)
	{
	return navpu->ClearGPRMs();
	}

Error DVDDiskPlayerClass::GetAudioStreamAttributes(WORD stream, DVDAudioStreamFormat & attributes)
	{
	if (GetDomain() == STOP_DOM)
		{
		attributes.languageCode = 0;
		attributes.languageExtension = 0;
		attributes.codingMode = DAM_AC3;
		attributes.bitsPerSample = 16;
		attributes.samplesPerSecond = 48000;
		attributes.channels = 2;
		attributes.applicationMode = DAAM_UNDEFINED;
		attributes.channelAssignment = 0;
		attributes.mcIntro = 0;
		attributes.soloDuetMode = DKM_UNDEFINED;

		GNRAISE_OK;
		}
	else
		return vobs->GetAudioStreamAttributes(stream, attributes);
	}

Error DVDDiskPlayerClass::GetSubPictureStreamAttributes(WORD stream, DVDSubPictureStreamFormat & attributes)
	{
	if (GetDomain() == STOP_DOM)
		{
		attributes.languageCode = 0;

		GNRAISE_OK;
		}
	else
		return vobs->GetSubPictureStreamAttributes(stream, attributes);
	}

//
//  Message processing for still and playback phase
//

void DVDDiskPlayerClass::Message(WPARAM wParam, LPARAM dParam)
	{
	switch (wParam)
		{
		case STILL_TIME_MSG:
			if (stillPhase)
				{
				stillPhase = FALSE;
				StillPhaseCompleted();
				StateChanged();
				}
			break;
		}
	}

//
//  Still Phase Handling
//

Error DVDDiskPlayerClass::StartStillPhase(WORD delay)
	{
	if (delay == 0)
		GNREASSERT(StillPhaseCompleted());
	else
		{
		DVDTitleSequencer::StartStillPhase(delay);
		stillPhase = TRUE;
		if (delay < 255)
			ScheduleTimer(STILL_TIME_MSG, (DWORD)delay * 1000);
		SendEvent(DNE_STILL_ON, delay);
		}

	GNRAISE_OK;
	}

Error DVDDiskPlayerClass::StopStillPhase(void)
	{
	Error err = GNR_OK;

	if (stillPhase)
		{
		CancelTimer();
		stillPhase = FALSE;
		err = StillPhaseCompleted();
		if (!IS_ERROR(err))
			SendEvent(DNE_STILL_OFF, 0);
		}

	GNRAISE(err);
	}

Error DVDDiskPlayerClass::CancelStillPhase(void)
	{
	if (stillPhase)
		{
		CancelTimer();
		stillPhase = FALSE;
		SendEvent(DNE_STILL_OFF, 0);
		}

	GNRAISE_OK;
	}


Error DVDDiskPlayerClass::Exit(Error err)
	{
	if (IS_ERROR(err))
		SendEvent(DNE_ERROR, err);
	GNREASSERT(DVDDiskSequencer::Exit(err));

	GNRAISE_OK;
	}

//
//  Internal: Get current playback mode
//

Error DVDDiskPlayerClass::InternalGetMode(DVDPlayerMode & mode)
	{
	mode = DVDDiskSequencer::InternalGetMode();
	GNRAISE_OK;
	}

//
//  Get Mode
//

Error DVDDiskPlayerClass::GetMode(DVDPlayerMode & mode)
	{
	GNREASSERT(InternalGetMode(mode));

	GNRAISE_OK;
   }

//
//  Get Extendend Player State
//

Error DVDDiskPlayerClass::GetExtendedPlayerState(ExtendedPlayerState * appEPS)
	{
	DVDLocation loc;
	int i;
	WORD stream;

	//
	//  Reset bitmasks and get general data
	//

	eps.valid = 0;
	eps.changed = 0;
	GetCurrentLocation(loc);

	//
	//  Get audio and subpicture stream attributes
	//

	GNREASSERT(GetAvailStreams(eps.availableAudioStreams, eps.availableSubPictureStreams));

	if (EPS_REQUEST(EPS_AUDIOSTREAMS))
		{
		GNREASSERT(GetCurrentAudioStream(stream));
		eps.currentAudioStream = (WORD)stream;

		for (i=0; i<8; i++)
			{
			if (eps.availableAudioStreams & (1 << i))
				GetAudioStreamAttributes((WORD)i, eps.audioStream[i]);
			}

		GNREASSERT(player->GetAudioInformation(eps.mpeg2PrologicStatus, eps.mpeg2LFEStatus, eps.ac3AudioCodingMode));

		eps.valid |= EPS_AUDIOSTREAMS;

		if (EPS_MONITOR(EPS_AUDIOSTREAMS))
			{
			if (EPS_CHANGED(currentAudioStream) || EPS_CHANGED(availableAudioStreams) || EPS_CHANGED(mpeg2PrologicStatus) ||
				 EPS_CHANGED(mpeg2LFEStatus) || EPS_CHANGED(ac3AudioCodingMode))
				eps.changed |= EPS_AUDIOSTREAMS;
			for (i=0; i<8; i++)
				{
				if (EPS_CHANGED(audioStream[i]))
					{
					eps.changed |= EPS_AUDIOSTREAMS;
					break;
					}
				}
			}
		}

	//
	//  Get subpicture stream attributes
	//

	if (EPS_REQUEST(EPS_SUBPICTURESTREAMS))
		{
		GNREASSERT(GetCurrentSubPictureStream(stream));
		eps.currentSubPictureStream = (WORD)stream;

		for (i=0; i<32; i++)
			{
			if (eps.availableSubPictureStreams & (1 << i))
				GetSubPictureStreamAttributes((WORD)i, eps.subPictureStream[i]);
			}

		eps.valid |= EPS_SUBPICTURESTREAMS;
		if (EPS_MONITOR(EPS_SUBPICTURESTREAMS))
			{
			if (EPS_CHANGED(currentSubPictureStream) || EPS_CHANGED(availableSubPictureStreams))
				eps.changed |= EPS_SUBPICTURESTREAMS;
			for (i=0; i<32; i++)
				{
				if (EPS_CHANGED(subPictureStream[i]))
					{
					eps.changed |= EPS_SUBPICTURESTREAMS;
					break;
					}
				}
			}
		}

	//
	//  Angle Information
	//

	if (EPS_REQUEST(EPS_ANGLE))
		{
		GNREASSERT(GetNumberOfAngles(loc.title, eps.numberOfAngles));
		GNREASSERT(GetCurrentAngle(eps.currentAngle));
		eps.isMultiAngleScene = IsMultiAngleScene();
		eps.playingAngle = GetPlayingAngle(eps.isMultiAngleScene);

		eps.valid |= EPS_ANGLE;
		if (EPS_MONITOR(EPS_ANGLE))
			{
			if (EPS_CHANGED(numberOfAngles) || EPS_CHANGED(currentAngle) ||
				 EPS_CHANGED(isMultiAngleScene) || EPS_CHANGED(playingAngle))
				eps.changed |= EPS_ANGLE;
			}
		}

	//
	//  Parental Information
	//

	if (EPS_REQUEST(EPS_PARENTAL))
		{
		GNREASSERT(GetSPRM(12, eps.parentalCountry));
		GNREASSERT(GetSPRM(13, eps.parentalLevel));

		eps.valid |= EPS_PARENTAL;
		if (EPS_MONITOR(EPS_PARENTAL))
			{
			if (EPS_CHANGED(parentalCountry) || EPS_CHANGED(parentalLevel))
				eps.changed |= EPS_PARENTAL;
			}
		}

	//
	//  Button Information
	//

	if (EPS_REQUEST(EPS_BUTTON))
		{
		GetButtonGeneralInfo(eps.numberOfButtons, eps.selectedButton, eps.forcedlyActivatedButton,
									eps.userButtonOffset, eps.numberOfUserButtons);

		for (i=0; i<36; i++)
			GetButtonInfo(i, eps.buttonInfo[i].x, eps.buttonInfo[i].y, eps.buttonInfo[i].w, eps.buttonInfo[i].h,
								  eps.buttonInfo[i].upperButton, eps.buttonInfo[i].lowerButton,
								  eps.buttonInfo[i].leftButton, eps.buttonInfo[i].rightButton,
								  eps.buttonInfo[i].autoAction);

		eps.valid |= EPS_BUTTON;
		if (EPS_MONITOR(EPS_BUTTON))
			{
			if (EPS_CHANGED(numberOfButtons) || EPS_CHANGED(selectedButton) || EPS_CHANGED(forcedlyActivatedButton) ||
				 EPS_CHANGED(userButtonOffset) || EPS_CHANGED(numberOfUserButtons))
				eps.changed |= EPS_BUTTON;

			for (i=0; i<36; i++)
				{
				if (EPS_CHANGED(buttonInfo[i]))
					{
					eps.changed |= EPS_BUTTON;
					break;
					}
				}
			}
		}

	//
	//  Set video stream info
	//

	if (EPS_REQUEST(EPS_VIDEOSTREAM))
		{
		GetVideoStreamAttributes(eps.videoStream);
		eps.valid |= EPS_VIDEOSTREAM;

		if (EPS_MONITOR(EPS_VIDEOSTREAM))
			{
			if (EPS_CHANGED(videoStream))
				 eps.changed |= EPS_VIDEOSTREAM;
			}
		}

	//
	//  Set common data
	//

	return CDDiskPlayerClass::GetExtendedPlayerState(appEPS);
	}

//
//  CallMenu
//

Error DVDDiskPlayerClass::CallMenu(VTSMenuType menu)
	{
	WORD menuID;
	WORD domainID;
	BOOL avail;
	Error error = GNR_OK;

	GNREASSERT(MenuAvail(menu, avail));
	if (avail)
		{
		if (GetDomain() == STOP_DOM) ClearGPRMs();

		switch (menu)
			{
			case VMT_TITLE_MENU:
				domainID = 1;
				menuID = 1;
				break;
			case VMT_ROOT_MENU:
				domainID = 2;
				menuID = 3;
				break;
			case VMT_SUBPICTURE_MENU:
				domainID = 2;
				menuID = 4;
				break;
			case VMT_AUDIO_MENU:
				domainID = 2;
				menuID = 5;
				break;
			case VMT_ANGLE_MENU:
				domainID = 2;
				menuID = 6;
				break;
			case VMT_PTT_MENU:
				domainID = 2;
				menuID = 7;
				break;
			default:
				GNRAISE_OK;
			}

		if (GetDomain() == TT_DOM)
			error = CallSystemSpaceProgramChain(0, domainID, menuID, 0);
		else
			error = GoSystemSpaceProgramChain(0, domainID, menuID);

		if (error == GNR_PARENTAL_LEVEL_TOO_LOW)
			Exit(error);
		GNRAISE(error);
		}
	else
		GNRAISE(GNR_OPERATION_PROHIBITED);

	}


Error DVDDiskPlayerClass::StartPresentation(DWORD flags)
	{
	return DVDDiskSequencer::StartPresentation(flags);
	}

Error DVDDiskPlayerClass::GetCurrentLocation(DVDLocation & location)
	{
	return DVDDiskSequencer::GetCurrentLocation(location);
	}

Error DVDDiskPlayerClass::GetCurrentDuration(DVDLocation & location)
	{
	return DVDDiskSequencer::GetCurrentDuration(location);
	}

Error DVDDiskPlayerClass::GetTitleDuration(WORD title, DVDTime & duration)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error DVDDiskPlayerClass::MenuAvail(VTSMenuType menu, BOOL & avail)
	{
	return DVDDiskSequencer::MenuAvail(menu, avail);
	}

Error DVDDiskPlayerClass::GetUOPs(DWORD & uops)
	{
	DWORD huops;

	GNREASSERT(CDDiskPlayerClass::GetUOPs(uops));
	GNREASSERT(DVDDiskSequencer::GetUOPs(huops));
	uops |= huops;
	GNRAISE_OK;
	}

Error DVDDiskPlayerClass::UOPPermitted(int uops, BOOL & permitted)
	{
	return DVDDiskSequencer::UOPPermitted(uops, permitted);
	}

Error DVDDiskPlayerClass::GetTitleSearchUOPs(WORD title, DWORD & uops)
	{
	return DVDDiskSequencer::GetTitleSearchUOPs(title, uops);
	}

Error DVDDiskPlayerClass::TitleSearchUOPPermitted(WORD title, int uops, BOOL & permitted)
	{
	return DVDDiskSequencer::TitleSearchUOPPermitted(title, uops, permitted);
	}

Error DVDDiskPlayerClass::NumberOfTitles(WORD & num)
	{
	return srpt->GetNumberOfTitles(num);
	}

Error DVDDiskPlayerClass::NumberOfPartOfTitle(WORD title, WORD & num)
	{
	return srpt->GetNumberOfPartOfTitle(title, num);
	}

Error DVDDiskPlayerClass::GetAvailStreams(BYTE & audio, DWORD & subPicture)
	{
	return DVDDiskSequencer::GetAvailStreams(audio, subPicture);
	}

Error DVDDiskPlayerClass::GetCurrentAudioStream(WORD & stream)
	{
	return GetSPRM(1, stream);
	}

Error DVDDiskPlayerClass::GetCurrentSubPictureStream(WORD & stream)
	{
	GNREASSERT(GetSPRM(2, stream));
	stream &= 0x3f;
	GNRAISE_OK;
	}

Error DVDDiskPlayerClass::IsCurrentSubPictureEnabled(BOOL & enabled)
	{
	WORD sprm;

	GNREASSERT(GetSPRM(2, sprm));
	enabled = (sprm & 0x40) != 0;
	GNRAISE_OK;
	}

Error DVDDiskPlayerClass::GetNumberOfAngles(WORD title, WORD & num)
	{
	return srpt->GetNumberOfAngles(title, num);
	}

Error DVDDiskPlayerClass::GetCurrentAngle(WORD & angle)
	{
	return GetSPRM(3, angle);
	}

Error DVDDiskPlayerClass::TitlePlay(WORD title, DWORD flags)
	{
	ClearGPRMs();
	return DVDDiskSequencer::GoTitle(title, flags);
	}

Error DVDDiskPlayerClass::PTTPlay(WORD title, WORD part)
	{
	ClearGPRMs();
	return DVDDiskSequencer::GoPartOfTitle(title, part);
	}

Error DVDDiskPlayerClass::GoTitle(WORD title, DWORD flags)
	{
	return DVDDiskSequencer::GoTitle(title, flags);
	}

Error DVDDiskPlayerClass::GoPartOfTitle(WORD title, WORD part)
	{
	return DVDDiskSequencer::GoPartOfTitle(title, part);
	}

Error DVDDiskPlayerClass::GoTrack(WORD track, WORD titleGroupNumber)
	{
	return DVDDiskSequencer::GoTrack(track, titleGroupNumber);
	}

Error DVDDiskPlayerClass::ExtendedPlay(DWORD flags, WORD title, WORD ptt, DVDTime time)
	{
	return DVDDiskSequencer::ExtendedPlay(flags, title, ptt, time);
	}

Error DVDDiskPlayerClass::TimePlay(WORD title, DVDTime time)
	{
	ClearGPRMs();
	return DVDDiskSequencer::TimePlay(title, time);
	}

Error DVDDiskPlayerClass::GoUpProgramChain(void)
	{
	return DVDDiskSequencer::GoUpProgramChain();
	}

Error DVDDiskPlayerClass::TimeSearch(DVDTime time)
	{
	return DVDDiskSequencer::TimeSearch(time);
	}

Error DVDDiskPlayerClass::PTTSearch(WORD part)
	{
	return DVDTitleSequencer::GoPartOfTitle(part);
	}

Error DVDDiskPlayerClass::GoPrevProgram(void)
	{
	return DVDDiskSequencer::GoPrevProgram();
	}

Error DVDDiskPlayerClass::GoTopProgram(void)
	{
	return DVDDiskSequencer::GoTopProgram();
	}

Error DVDDiskPlayerClass::GoNextProgram(void)
	{
	return DVDDiskSequencer::GoNextProgram();
	}

Error DVDDiskPlayerClass::StartForwardScan(WORD speed)
	{
	return DVDDiskSequencer::StartForwardScan(speed);
	}

Error DVDDiskPlayerClass::StartBackwardScan(WORD speed)
	{
	return DVDDiskSequencer::StartBackwardScan(speed);
	}

Error DVDDiskPlayerClass::GetScanSpeed(WORD & speed)
	{
	speed = DVDDiskSequencer::GetScanSpeed();
	GNRAISE_OK;
	}

Error DVDDiskPlayerClass::StartTrickplay(void)
	{
	return DVDDiskSequencer::StartTrickPlayback();
	}

Error DVDDiskPlayerClass::StopScan(void)
	{
	return DVDDiskSequencer::StopScan(FALSE);
	}

Error DVDDiskPlayerClass::StartReversePlayback(void)
	{
	return DVDDiskSequencer::StartReversePlayback();
	}

Error DVDDiskPlayerClass::ResumeFromSystemSpace(void)
	{
	return DVDDiskSequencer::ResumeFromSystemSpace();
	}

Error DVDDiskPlayerClass::ButtonUp(void)
	{
	return DVDDiskSequencer::ButtonUp();
	}

Error DVDDiskPlayerClass::ButtonDown(void)
	{
	return DVDDiskSequencer::ButtonDown();
	}

Error DVDDiskPlayerClass::ButtonLeft(void)
	{
	return DVDDiskSequencer::ButtonLeft();
	}

Error DVDDiskPlayerClass::ButtonRight(void)
	{
	return DVDDiskSequencer::ButtonRight();
	}

Error DVDDiskPlayerClass::ButtonActivate(void)
	{
	return DVDDiskSequencer::ButtonActivate();
	}

Error DVDDiskPlayerClass::ButtonSelectAt(WORD x, WORD y)
	{
	return DVDDiskSequencer::ButtonSelectAt(x, y);
	}

Error DVDDiskPlayerClass::ButtonSelectAndActivate(WORD button)
	{
	return DVDDiskSequencer::ButtonSelectAndActivate(button);
	}

Error DVDDiskPlayerClass::ButtonSelectAtAndActivate(WORD x, WORD y)
	{
	return DVDDiskSequencer::ButtonSelectAtAndActivate(x, y);
	}

Error DVDDiskPlayerClass::IsButtonAt(WORD x, WORD y, BOOL & isButton)
	{
	isButton = DVDDiskSequencer::IsButtonAt(x, y);
	GNRAISE_OK;
	}


Error DVDDiskPlayerClass::HasPositionalButtons(BOOL & hasButtons)
	{
	hasButtons = DVDDiskSequencer::HasPositionalButtons();
	GNRAISE_OK;
	}

Error DVDDiskPlayerClass::MenuLanguageSelect(WORD language)
	{
	return SetSPRM(0, language);
	}

Error DVDDiskPlayerClass::GetMenuLanguage(WORD & language)
	{
	return GetSPRM(0, language);
	}

Error DVDDiskPlayerClass::AudioStreamChange(WORD stream)
	{
	return SetSPRM(1, stream);
	}

Error DVDDiskPlayerClass::SubPictureStreamChange(WORD stream, BOOL enable)
	{
	return SetSPRM(2, stream | (enable ? 0x40 : 0x00));
	}

Error DVDDiskPlayerClass::AngleChange(WORD angle)
	{
	return SetSPRM(3, angle);
	}

Error DVDDiskPlayerClass::ParentalLevelSelect(WORD level)
	{
	return DVDDiskSequencer::ParentalLevelSelect(level);
	}

Error DVDDiskPlayerClass::ParentalCountrySelect(WORD country)
	{
	return SetSPRM(12, country);
	}

Error DVDDiskPlayerClass::GetCurrentDisplayMode(DisplayPresentationMode & mode)
	{
	mode = DVDDiskSequencer::GetCurrentDisplayMode();
	GNRAISE_OK;
	}

Error DVDDiskPlayerClass::SetDisplayMode(DisplayPresentationMode mode)
	{
	return DVDDiskSequencer::SetDisplayMode(mode);
	}

Error DVDDiskPlayerClass::GetCurrentVideoStandard(VideoStandard & standard)
	{
	standard = player->GetCurrentVideoStandard();
	GNRAISE_OK;
	}

Error DVDDiskPlayerClass::SelectInitialLanguage(WORD audioLanguage, WORD audioExtension, WORD subPictureLanguage, WORD subPictureExtension)
	{
	SetSPRM(16, audioLanguage);
	SetSPRM(17, audioExtension);
	SetSPRM(18, subPictureLanguage);
	SetSPRM(19, subPictureExtension);

	GNRAISE_OK;
	}

Error DVDDiskPlayerClass::TransferDiskKey(void)
	{
	return DVDDiskSequencer::TransferDiskKey();
	}

Error DVDDiskPlayerClass::GetCurrentBitrate(DWORD & bitrate)
	{
	bitrate = CurrentBitrate();
	GNRAISE_OK;
	}

Error DVDDiskPlayerClass::GetCurrentButtonState(WORD & minButton, WORD & numButtons, WORD & currentButton)
	{
	return DVDDiskSequencer::GetCurrentButtonState(minButton, numButtons, currentButton);
	}

//
//  Freeze current player state
//

Error DVDDiskPlayerClass::Freeze(DDPFreezeState * state, DWORD & size)
	{
	DVDHeaderFile * hfile;

	//
	//  Check buffer size
	//

	if (size < sizeof(DVDFreezeState))
		{
		size = sizeof(DVDFreezeState);
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
	size = sizeof(DVDFreezeState);

	//
	// Build unique key
	//

	GNREASSERT(mgm->GetHeaderFile(hfile));
	GNREASSERT(hfile->GetUniqueKey(state->uniqueKey));
	state->diskType = diskType;

	//
	// Save data of base classes
	//

	DVDDiskSequencer::Freeze(((DVDFreezeState*)state)->dsFreezeState);
	GNREASSERT(GetSPRM(13, state->parentalLevel));
	GNRAISE(GetSPRM(12, state->parentalCountry));
	}

//
//  Restore player state
//

Error DVDDiskPlayerClass::Defrost(DDPFreezeState * state, DWORD & size, DWORD flags)
	{
	DVDHeaderFile * hfile;
	Error err = GNR_OK;
	BYTE uniqueKey[8];
	int i;

	//
	// Test parameters
	//

	if (!state)
		GNRAISE(GNR_INVALID_PARAMETERS);

	//
	// Test buffer size
	//

	if (size < sizeof(DVDFreezeState))
		{
		size = sizeof(DVDFreezeState);
		GNRAISE(GNR_OBJECT_INVALID);
		}
	size = sizeof(DVDFreezeState);

	//
	// Test unique key
	//

	GNREASSERT(mgm->GetHeaderFile(hfile));
	GNREASSERT(hfile->GetUniqueKey(uniqueKey));
	for (i=0; i<8; i++)
		{
		if (((DVDFreezeState*)state)->uniqueKey[i] != uniqueKey[i])
			GNRAISE(GNR_INVALID_UNIQUE_KEY);
		}

	//
	// Restore data
	//

	if (!XTBF(DDPSPF_ID_MATCH, flags))
		{
		if (IS_ERROR(err = DVDDiskSequencer::Defrost(((DVDFreezeState*)state)->dsFreezeState, flags)))
			Exit(err);
		}

	GNRAISE(err);
	}

//
//  Set Breakpoint
//

Error DVDDiskPlayerClass::SetBreakpoint(WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id)
	{
	if (title == 0)
		{
		DVDLocation loc;

		GetCurrentLocation(loc);
		title = loc.title;
		}

	return DVDDiskSequencer::SetBreakpoint(title, ptt, time, flags, id);
	}

//
//  Clear Breakpoint
//

Error DVDDiskPlayerClass::ClearBreakpoint(DWORD id)
	{
	return DVDDiskSequencer::ClearBreakpoint(id);
	}

Error DVDDiskPlayerClass::SetAudioStreamSelectionPreferences(DWORD flags)
	{
	return DVDDiskSequencer::SetAudioStreamSelectionPreferences(flags);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDDiskSeq.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD Disk Sequencer Class
//
////////////////////////////////////////////////////////////////////

#ifndef DVDDISKSEQ_H
#define DVDDISKSEQ_H

#include "DVDTitleSeq.h"
#include "DVDAVDisk.h"

#pragma warning(disable : 4250)

class DVDDiskSequencer : public DVDTitleSequencer
	{
	protected:
		DVDMGM	* mgm;
		DVDTS		* titleSet;
		DVDOBS	* vobs;
		DVDDisk	* dvdDisk;
		DVDSRPT	* srpt;

		WORD			vtsn;
		WORD			resumeVTSN;

		BOOL			menuCacheValid;
		BOOL			menuAvail[VMT_NO_MENU];

		struct								// Structure for change checks
			{
			WORD				title;			// for title change check
			WORD				partOfTitle;	// For PartOfTitle change check
			DWORD				uops;
			WORD				angles;
			WORD				audioStreams;
			DWORD				subPictureStreams;
			DVDPlayerMode	mode;
			} last;

		virtual	Error	VOBUStarted(DVDVOBU * vobu);
		virtual	void	StateChanged(void);
		virtual	Error	CheckTitleChange(void);
		virtual	BOOL	BreakpointReached(DVDTime lowerLimit, DVDTime upperLimit, ERSPlaybackDir dir, ERSBreakpoint & bp);
		virtual  BOOL	BreakpointContained(int start, int length, BOOL lowest, ERSPlaybackDir dir, ERSBreakpoint & bp);
		virtual	BOOL	EndOfPGCBreakpointReached(ERSPlaybackDir dir, ERSBreakpoint & bp);

		virtual	BOOL	EndOfPGBreakpointReached(WORD pgn, ERSPlaybackDir dir, ERSBreakpoint & bp);
		virtual	BOOL	BeginOfPGBreakpointReached(WORD pgn, ERSPlaybackDir dir, ERSBreakpoint & bp);

		Error InternalGoSystemSpaceProgramChain(WORD pgcn, int domainID, int menuID);

		//
		//  State freezing stuff
		//

		class DVDDSFreezeState
			{
			public:
				WORD					vtsn;
				WORD					resumeVTSN;
				DVDDomain			domain;

				DVDNCFreezeState	ncFreezeState;
				DVDTSFreezeState	tsFreezeState;
			};

		Error Freeze (DVDDSFreezeState & state);
		Error Defrost(DVDDSFreezeState & state, DWORD flags);

	public:
		DVDDiskSequencer (WinPortServer * server, UnitSet units, DVDDiskPlayerFactory * factory, EventDispatcher* pEventDispatcher);
		virtual ~DVDDiskSequencer(void);

		Error Init(DVDFileSystem * dvdfs, WORD parentalCountryCode);

   	Error TransferDiskKey(void);

		Error SelectPGCIT(DVDPGCIUT pgciut, DVDPGCIT & pgcit);

	   Error GetCurrentLocation(DVDLocation & loc);
		Error GetCurrentDuration(DVDLocation & loc);

		Error GetSPRM(int index, WORD & sprm);

		Error MenuAvail(VTSMenuType menu, BOOL & avail);

   	Error StartPresentation(DWORD flags);

		Error Exit(Error err = GNR_OK);

   	Error GoTitle(WORD title, DWORD flags);
   	Error GoPartOfTitle(WORD title, WORD ptt);
   	Error GoVideoTitleSetTitle(WORD title, BOOL toPause = FALSE);
   	Error GoVideoTitleSetPartOfTitle(WORD title, WORD ptt);
		Error GoTrack(WORD track, WORD titleGroupNumber);
		Error GoAudioTitleSetTrack(int track);
		Error TimePlay(WORD title, DVDTime time);
		Error AccessRestricted(WORD title, DVDTime time, BOOL & restricted);

		Error ExtendedPlay(DWORD flags, WORD title, WORD ptt, DVDTime time);

		Error GoSystemSpaceProgramChain(WORD pgcn, WORD domainID, WORD menuID);

   	Error GoSystemSpaceTitleSet(WORD titleSet, WORD title, WORD domainID, WORD menuID);

   	Error CallSystemSpaceProgramChain(WORD pgcn, WORD domainID, WORD menuID, WORD resumeCell);

		Error ResumeFromSystemSpace(void);
		Error SaveResumeInformation(void);

		Error GetUOPs(DWORD & uops);
		Error GetTitleSearchUOPs(WORD title, DWORD & uops);
		Error TitleSearchUOPPermitted(WORD title, int uops, BOOL & permitted);
		Error GetVideoStreamAttributes(VideoStreamFormat & videoStream);

		virtual DVDPlayerMode InternalGetMode(void);
		Error DiskIsEncrypted(BOOL & enc);

		Error SetBreakpoint(WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id);
	};

#pragma warning(default : 4250)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDDiskSeq.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
//  DVD Disk Sequencer Implementation
//
//////////////////////////////////////////////////////////////////////

#include "DVDDiskSeq.h"
#include "Library/Common/vddebug.h"

//
//  Constructor
//

DVDDiskSequencer::DVDDiskSequencer(WinPortServer * server, UnitSet units, DVDDiskPlayerFactory * factory, EventDispatcher* pEventDispatcher)
	: DVDTitleSequencer(server, units, pEventDispatcher)
	, EventSender(pEventDispatcher)
	, ERSBreakpointControl(pEventDispatcher)
	{
//#if DVD_AUDIO
//	dvdDisk = new DVDAudioDisk();
//#else
//	dvdDisk = new DVDVideoDisk();
//#endif
	factory->CreateDVDDisk(dvdDisk);
	srpt = NULL;
	vtsn = 0;
	}

//
//  Destructor
//

DVDDiskSequencer::~DVDDiskSequencer(void)
	{
	if (srpt)
		{
		delete srpt;
		srpt = NULL;
		}

	if (dvdDisk)
		{
		delete dvdDisk;
		dvdDisk = NULL;
		}
	}

//
//  Initialize
//

Error DVDDiskSequencer::Init(DVDFileSystem * dvdfs, WORD parentalCountryCode)
	{
	DVDMGMVOBS * mgmVobs;

	if (!dvdDisk)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	GNREASSERT(dvdDisk->Init(dvdfs, parentalCountryCode));
	mgm = dvdDisk->GetMGM();
	GNREASSERT(DVDTitleSequencer::Init(dvdfs));

	resumeAvail = FALSE;
	TransferDiskKey();
	GNREASSERT(mgm->GetMGMVOBS(mgmVobs));
	vobs = mgmVobs;
	titleSet = NULL;
	menuCacheValid = FALSE;

	GNREASSERT(mgm->GetSRPT(srpt));

	GNRAISE_OK;
	}

//
//  Test if disk is encrypted
//

Error DVDDiskSequencer::DiskIsEncrypted(BOOL & isEnc)
	{
	DVDHeaderFile * headerFile;

	GNREASSERT(mgm->GetHeaderFile(headerFile));

	return headerFile->IsEncrypted(isEnc);
	}

//
//  Transfer disk key
//

Error DVDDiskSequencer::TransferDiskKey(void)
	{
	DVDHeaderFile * headerFile;
	BOOL isEnc;

	GNREASSERT(mgm->GetHeaderFile(headerFile));
	GNREASSERT(headerFile->IsEncrypted(isEnc));

	if (isEnc)
		{
		return player->TransferDiskKey(headerFile);
		}
	else
		GNRAISE_OK;
	}

//
//  Select PGCIT with selected language code
//

Error DVDDiskSequencer::SelectPGCIT(DVDPGCIUT pgciut, DVDPGCIT & pgcit)
	{
	WORD languageCode;
	WORD i, num;
	WORD lc;

	GNREASSERT(GetSPRM(0, languageCode));
	GNREASSERT(pgciut.GetNumberOfLanguageUnits(num));

	for (i=1; i<=num; i++)
		{
		GNREASSERT(pgciut.GetLanguageCode(i, lc));
		if (languageCode == lc)
			{
			return pgciut.GetPGCIT(i, pgcit);
			}
		}

	return pgciut.GetPGCIT(1, pgcit);
	}

//
//  VOBU started -> Check Valid UOP change
//

Error DVDDiskSequencer::VOBUStarted(DVDVOBU * vobu)
	{
	DWORD uops;

	GNREASSERT(GetUOPs(uops));

	if (uops != last.uops)
		{
		SendEvent(DNE_VALID_UOP_CHANGE, uops);
		last.uops = uops;
		}

	return DVDTitleSequencer::VOBUStarted(vobu);
	}

//
//  Check title/part of title change
//

Error DVDDiskSequencer::CheckTitleChange(void)
	{
	DVDLocation	loc;
	WORD			angles;
	BYTE			audio;
	DWORD			subPicture;

	GNREASSERT(DVDDiskSequencer::GetCurrentLocation(loc));
	if (loc.title != last.title)
		{
		SendEvent(DNE_TITLE_CHANGE, loc.title);

		last.title = loc.title;
		last.partOfTitle = loc.partOfTitle;

		//
		//  Check for number of angle, audio streams or subpicture streams change
		//

		GNREASSERT(srpt->GetNumberOfAngles(loc.title, angles));
		GNREASSERT(GetAvailStreams(audio, subPicture));
		if (angles != last.angles || audio != last.audioStreams || subPicture != last.subPictureStreams)
			SendEvent(DNE_STREAMS_CHANGE, 0);

		}
	else if (loc.partOfTitle != last.partOfTitle)
		{
		SendEvent(DNE_PART_OF_TITLE_CHANGE, loc.partOfTitle);
		last.partOfTitle = loc.partOfTitle;
		}

	GNRAISE_OK;
	}

//
//  PGCSequencer state has changed -> check for mode change
//

void DVDDiskSequencer::StateChanged(void)
	{
	DVDPlayerMode newMode = InternalGetMode();

	if (newMode != last.mode)
		{
		SendEvent(DNE_PLAYBACK_MODE_CHANGE, newMode);
		last.mode = newMode;
		}
	}

//
//  Check breakpoints
//

BOOL DVDDiskSequencer::BreakpointReached(DVDTime lowerLimit, DVDTime upperLimit, ERSPlaybackDir dir, ERSBreakpoint & bp)
	{
	DVDLocation loc;

	if (!IS_ERROR(DVDDiskSequencer::GetCurrentLocation(loc)))
		return ERSBreakpointControl::BreakpointReached(loc.title, lowerLimit, upperLimit, dir, bp);
	else
		return FALSE;
	}

//
//  Check breakpoints, but do not activate
//  Start:	Lower limit of search interval (in milliseconds)
//  Length:	Length interval (in milliseconds)
//  Lowest:	If TRUE find breakpoint with lowest time, else find highest
//

BOOL DVDDiskSequencer::BreakpointContained(int start, int length, BOOL lowest, ERSPlaybackDir dir, ERSBreakpoint & bp)
	{
	DVDLocation loc;
	int frameRate;

	if (!IS_ERROR(DVDDiskSequencer::GetCurrentLocation(loc)))
		{
		frameRate = loc.titleTime.FrameRate();
		return ERSBreakpointControl::BreakpointContained(loc.title, DVDTime(start, 1, frameRate),
																		 DVDTime(start + length, 1, frameRate), lowest, dir, bp);
		}
	else
		return FALSE;
	}

//
//  Check EndOfTitle breakpoints
//

BOOL DVDDiskSequencer::EndOfPGCBreakpointReached(ERSPlaybackDir dir, ERSBreakpoint & bp)
	{
	DVDLocation loc;

	if (!IS_ERROR(DVDDiskSequencer::GetCurrentLocation(loc)))
		return ERSBreakpointControl::EndOfTitleBreakpointReached(loc.title, dir, bp);
	else
		return FALSE;
	}

//
//  Test on End-Of-Program Breakpoint
//

BOOL DVDDiskSequencer::EndOfPGBreakpointReached(WORD pgn, ERSPlaybackDir dir, ERSBreakpoint & bp)
	{
	WORD pttn;
	WORD vtsTitle;
	WORD title;

	if (!IS_ERROR(pgcit.GetTitle(pgcn, vtsTitle)))
		{
		if (!IS_ERROR(ptt.GetPartAndTitle(pgcn, pgn, vtsTitle, pttn)))
			{
			if (!IS_ERROR(srpt->GetTitleOfTSTitle(vtsn, vtsTitle, title)))
				{
				return ERSBreakpointControl::EndOfPTTBreakpointReached(title, pttn, dir, bp);
				}
			}
		}

	return FALSE;
	}

//
//  Test on Begin-Of-Program Breakpoint
//

BOOL DVDDiskSequencer::BeginOfPGBreakpointReached(WORD pgn, ERSPlaybackDir dir, ERSBreakpoint & bp)
	{
	WORD pttn;
	WORD vtsTitle;
	WORD title;

	if (!IS_ERROR(pgcit.GetTitle(pgcn, vtsTitle)))
		{
		if (!IS_ERROR(ptt.GetPartAndTitle(pgcn, pgn, vtsTitle, pttn)))
			{
			if (!IS_ERROR(srpt->GetTitleOfTSTitle(vtsn, vtsTitle, title)))
				{
				//DP("PGCN %d, PGN %d, TTN %d PTTN %d", pgcn, pgn, title, pttn);
				return ERSBreakpointControl::BeginOfPTTBreakpointReached(title, pttn, dir, bp);
				}
			}
		}

	return FALSE;
	}

//
//  Get current playback location
//

Error DVDDiskSequencer::GetCurrentLocation(DVDLocation & loc)
	{
	GNREASSERT(DVDTitleSequencer::GetCurrentLocation(loc));

	loc.videoTitleSet = vtsn;

	if (GetDomain() == TT_DOM)
		GNREASSERT(srpt->GetTitleOfTSTitle(loc.videoTitleSet, loc.vtsTitle, loc.title));
	else
		loc.title = 0;

	loc.titleTime = loc.pgcTime;

	GNRAISE_OK;
	}

//
//  Get current duration
//

Error DVDDiskSequencer::GetCurrentDuration(DVDLocation & loc)
	{
	GNREASSERT(DVDTitleSequencer::GetCurrentDuration(loc));
	GNREASSERT(mgm->GetNumberOfTS(loc.videoTitleSet));

	if (GetDomain() == TT_DOM)
		GNREASSERT(srpt->GetNumberOfTitles(loc.title));
	else
		loc.title = 0;

	loc.titleTime = loc.pgcTime;

	GNRAISE_OK;
	}

//
//  Test if menu is available
//

Error DVDDiskSequencer::MenuAvail(VTSMenuType menuType, BOOL & avail)
	{
	DVDPGCIUT mpgciut;
	DVDPGCIT pgcit;
	BOOL hasMPGCIUT;
	WORD menu;
	VTSMenuType	mt;

	if (!menuCacheValid)
		{
		for(mt = VMT_TITLE_MENU; mt < VMT_NO_MENU; mt = (VTSMenuType)(mt + 1))
			{
			menuAvail[mt] = FALSE;

			if (mt == VMT_TITLE_MENU)
				{
				GNREASSERT(mgm->HasMPGCIUT(hasMPGCIUT));
				if (hasMPGCIUT)
					{
					GNREASSERT(mgm->GetMPGCIUT(mpgciut));
					GNREASSERT(SelectPGCIT(mpgciut, pgcit));
					GNREASSERT(pgcit.FindMenu(mt, menu));
					menuAvail[mt] = menu != 0;
					}
				}
			else if (titleSet || vtsn)
				{
				if (!titleSet)
					GNREASSERT(dvdDisk->GetTS(vtsn, titleSet));

				if (titleSet)
					{
					GNREASSERT(titleSet->HasMPGCIUT(hasMPGCIUT));
					if (hasMPGCIUT)
						{
						GNREASSERT(titleSet->GetMPGCIUT(mpgciut));
						GNREASSERT(SelectPGCIT(mpgciut, pgcit));
						GNREASSERT(pgcit.FindMenu(mt, menu));
						menuAvail[mt] = menu != 0;
						}
					}
				}
			}

		menuCacheValid = TRUE;
		}

	avail = menuAvail[menuType];

	GNRAISE_OK;
	}

//
//  Start presentation
//

Error DVDDiskSequencer::StartPresentation(DWORD flags)
	{
	DVDMGMVOBS	*	mgmVobs;
	DVDPGCIUT		mpgciut;
	DVDPGCIT			pgcit;
	DVDPTT			ptt;
	Error				err;
	BOOL				has;
	WORD				num;

	GNREASSERT(CloseTitleSet());

	SetDomain(STOP_DOM);

	GNREASSERT(mgm->GetMGMVOBS(mgmVobs));
	vobs = mgmVobs;

	navpu->ClearGPRMs();

	SetSPRM(1, 15);
	GNREASSERT(GetSPRM(2, num));
	SetSPRM(2, num & 0x40 | 62);
	SetSPRM(3, 1);
	SetSPRM(8, 1);
	SetSPRM(9, 0);
	SetSPRM(10, 0);

	GNREASSERT(mgm->HasMPGCIUT(has));
	if (has)
		{
		GNREASSERT(mgm->GetMPGCIUT(mpgciut));
		GNREASSERT(SelectPGCIT(mpgciut, pgcit));
		}

	//
	// DVD-Audio may not contain any vobs
	//

	if (vobs)
		OpenTitleSet(vobs, pgcit, ptt);

	GNREASSERT(mgm->HasFirstPlayPGC(has));
	if (has && vobs)
		{
		DVDGenericPGCI * pgci;
		DP("It has first play PGC");

		SetDomain(FP_DOM);

#if DVD_AUDIO
		GNREASSERT(pgcit.GetPGCI(1, pgci));	// get PGCI start address for DVD-Audio
#else
		GNREASSERT(mgm->GetFirstPlayPGCI(pgci));
#endif
		if (IS_ERROR(err = PlayPGCI(pgci, (flags & DDPSPF_TOPAUSE) != 0)))
			Exit(err);
		GNRAISE(err);
		}
	else
		{
		DP("No first play PGC or no Manager Menu");

		GNREASSERT(srpt->GetNumberOfTitles(num));
		if (num == 1)
			{
			return GoTitle(1, flags);
			}
		else
			GNRAISE(GNR_OBJECT_NOT_FOUND);
		}
	}

//
//  Stop presentation
//

Error DVDDiskSequencer::Exit(Error err)
	{
	GNREASSERT(DVDTitleSequencer::Exit());
	resumeAvail = FALSE;
   titleSet = NULL;
	menuCacheValid = FALSE;

	SetDomain(STOP_DOM);
	SendEvent(DNE_PLAYBACK_MODE_CHANGE, DPM_STOPPED);

	GNRAISE_OK;
	}

//
//  Go to a title
//

Error DVDDiskSequencer::GoTitle(WORD title, DWORD flags)
	{
	DVDPGCIT pgcit;
	DVDPTT ptt;
	WORD vttn;
	Error err;

	GNREASSERT(CloseTitleSet());

	resumeAvail = FALSE;

	GNREASSERT(srpt->GetTitle(title, vtsn, vttn));

	GNREASSERT(dvdDisk->GetTS(vtsn, titleSet));
	menuCacheValid = FALSE;
	vobs = titleSet->GetTSOBS();

	SetDomain(TT_DOM);

	GNREASSERT(titleSet->GetPGCIT(pgcit));
	GNREASSERT(titleSet->GetPTT(ptt));
	if (!IS_ERROR(err = OpenTitleSet(vobs, pgcit, ptt)))
		{
	 	if (!IS_ERROR(err = GoVideoTitleSetTitle(vttn, (flags & DDPSPF_TOPAUSE) != 0)))
			{
			GNRAISE_OK;
			}
		}

	SetDomain(STOP_DOM);

	GNRAISE(err);
	}

//
// Go to a Track (DVD-Audio only)
//

Error DVDDiskSequencer::GoTrack(WORD track, WORD titleGroupNumber)
	{
	DVDPGCIT	pgcit;
	DVDPTT	ptt;
	WORD		atkn;
	Error		err;

	GNREASSERT(CloseTitleSet());

	resumeAvail = FALSE;

	GNREASSERT(srpt->GetTitle(track, vtsn, atkn));

	GNREASSERT(dvdDisk->GetTS(vtsn, titleSet));
	menuCacheValid = FALSE;
	vobs = titleSet->GetTSOBS();

	SetDomain(TT_GR_DOM);

	GNREASSERT(titleSet->GetPGCIT(pgcit));
	if (!IS_ERROR(err = OpenTitleSet(vobs, pgcit, ptt)))
		{
		if (!IS_ERROR(err = GoAudioTitleSetTrack(atkn)))
			{
			GNRAISE_OK;
			}
		}

	SetDomain(STOP_DOM);

	GNRAISE_OK;
	}

//
//  Start time play
//

Error DVDDiskSequencer::TimePlay(WORD title, DVDTime time)
	{
	DVDPGCIT pgcit;
	DVDPTT ptt;
	WORD vttn;
	Error err;
	BOOL restricted;

	//
	//  Make sure the position requested allows TimePlay (because of AccessRestricted flag)
	//

	GNREASSERT(AccessRestricted(title, time, restricted));
	if (restricted)
		{
//		DPF("Time play forbidden");
		GNRAISE(GNR_OPERATION_PROHIBITED);
		}

//	DPF("Time Play allowed");

	//
	//  Op's a go, let's do it
	//

	resumeAvail = FALSE;

	GNREASSERT(CloseTitleSet());

	GNREASSERT(srpt->GetTitle(title, vtsn, vttn));

	GNREASSERT(dvdDisk->GetTS(vtsn, titleSet));
	menuCacheValid = FALSE;
	vobs = titleSet->GetVTSVOBS();

	GNREASSERT(titleSet->GetPGCIT(pgcit));
	GNREASSERT(titleSet->GetPTT(ptt));

	SetDomain(TT_DOM);

	if (!IS_ERROR(err = OpenTitleSet(vobs, pgcit, ptt)))
		{
		if (!IS_ERROR(err = DVDTitleSequencer::TimePlay(vttn, time)))
			GNRAISE_OK;
		}

	SetDomain(STOP_DOM);

	GNRAISE(err);
	}

//
//  Check if access to a position is restricted
//

Error DVDDiskSequencer::AccessRestricted(WORD title, DVDTime time, BOOL & restricted)
	{
	WORD vttn;
	WORD vtsn;
	DVDTS * ts;
	Error err;
	DVDPGCIT pgcit;
	DVDPTT ptt;
	BOOL deleteIt;

	GNREASSERT(srpt->GetTitle(title, vtsn, vttn));

	GNREASSERT(dvdDisk->GetTSExclusive(vtsn, ts, deleteIt));

	vobs = ts->GetVTSVOBS();

	GNREASSERT(ts->GetPGCIT(pgcit));
	GNREASSERT(ts->GetPTT(ptt));

	err = DVDTitleSequencer::AccessRestricted(vobs, pgcit, ptt, vttn, time, restricted);
	if (deleteIt)
		delete ts;
	GNRAISE(err);
	}

//
//  Go to part of title
//

Error DVDDiskSequencer::GoPartOfTitle(WORD title, WORD ptt)
	{
	WORD vttn;
	Error err;
	DVDPGCIT pgcit;
	DVDPTT dvdPtt;

	GNREASSERT(CloseTitleSet());

	resumeAvail = FALSE;

	GNREASSERT(srpt->GetTitle(title, vtsn, vttn));

	GNREASSERT(dvdDisk->GetTS(vtsn, titleSet));
	menuCacheValid = FALSE;
	vobs = titleSet->GetVTSVOBS();

	GNREASSERT(titleSet->GetPGCIT(pgcit));
	GNREASSERT(titleSet->GetPTT(dvdPtt));

	SetDomain(TT_DOM);

	if (!IS_ERROR(err = OpenTitleSet(vobs, pgcit, dvdPtt)))
		{
		if (!IS_ERROR(err = GoVideoTitleSetPartOfTitle(vttn, ptt)))
			{
			GNRAISE_OK;
			}
		}

	SetDomain(STOP_DOM);

	GNRAISE(err);
	}

//
//  Extended play
//

Error DVDDiskSequencer::ExtendedPlay(DWORD flags, WORD title, WORD ptt, DVDTime time)
	{
	WORD vttn;
	Error err;

	if (flags & DDPEPF_USE_TITLE)
		{
		DVDPGCIT pgcit;
		DVDPTT dvdPTT;

		navpu->ClearGPRMs();

		GNREASSERT(CloseTitleSet());

		resumeAvail = FALSE;

		GNREASSERT(srpt->GetTitle(title, vtsn, vttn));

		GNREASSERT(dvdDisk->GetTS(vtsn, titleSet));
		menuCacheValid = FALSE;
		vobs = titleSet->GetVTSVOBS();

		GNREASSERT(titleSet->GetPGCIT(pgcit));
		GNREASSERT(titleSet->GetPTT(dvdPTT));
		SetDomain(TT_DOM);

		if (!IS_ERROR(err = OpenTitleSet(vobs, pgcit, dvdPTT)))
			{
			if (!IS_ERROR(err = DVDTitleSequencer::ExtendedPlay(flags, vttn, ptt, time)))
				{
				GNRAISE_OK;
				}
			}

		SetDomain(STOP_DOM);

		GNRAISE(err);
		}
	else
		return DVDTitleSequencer::ExtendedPlay(flags, title, ptt, time);
	}

//
//  Go to video title set title
//

Error DVDDiskSequencer::GoVideoTitleSetTitle(WORD title, BOOL toPause)
	{
	if (GetDomain() != TT_DOM)
		{
		DVDPGCIT pgcit;
		DVDPTT ptt;

		GNREASSERT(CloseTitleSet());

		resumeAvail = FALSE;

		vobs = titleSet->GetVTSVOBS();


		GNREASSERT(titleSet->GetPGCIT(pgcit));
		GNREASSERT(titleSet->GetPTT(ptt));
		SetDomain(TT_DOM);

		GNREASSERT(OpenTitleSet(vobs, pgcit, ptt));
		}

	return DVDTitleSequencer::GoVideoTitleSetTitle(title, toPause);
	}

//
//  Go to video title set part of title
//

Error DVDDiskSequencer::GoVideoTitleSetPartOfTitle(WORD title, WORD ptt)
	{
	if (GetDomain() != TT_DOM)
		{
		DVDPGCIT pgcit;
		DVDPTT ptt;

		GNREASSERT(CloseTitleSet());

		resumeAvail = FALSE;

		vobs = titleSet->GetVTSVOBS();

		GNREASSERT(titleSet->GetPGCIT(pgcit));
		GNREASSERT(titleSet->GetPTT(ptt));
		SetDomain(TT_DOM);

		GNREASSERT(OpenTitleSet(vobs, pgcit, ptt));
		}

	return DVDTitleSequencer::GoVideoTitleSetPartOfTitle(title, ptt);
	}

//
//	Go to audio title set track
//

Error DVDDiskSequencer::GoAudioTitleSetTrack(int track)
	{
	if (GetDomain() != TT_GR_DOM)
		{
		DVDPGCIT pgcit;

		GNREASSERT(CloseTitleSet());

		resumeAvail = FALSE;

		vobs = titleSet->GetVTSVOBS();


		GNREASSERT(titleSet->GetPGCIT(pgcit));
		SetDomain(TT_GR_DOM);

		GNREASSERT(OpenTitleSet(vobs, pgcit, ptt));
		}

	return DVDTitleSequencer::GoAudioTitleSetTrack(track);
	}

Error DVDDiskSequencer::InternalGoSystemSpaceProgramChain(WORD pgcn, int domainID, int menuID)
	{
	DVDManagerMenuType mgmType;
	DVDMGMVOBS * mgmVobs;
	DVDPGCIUT pgciut;
	DVDPGCIT	pgcit;
	DVDGenericPGCI * pgci;
	BOOL has;
	Error err;

	switch (domainID)
		{
		case 0:
			GNREASSERT(mgm->GetMPGCIUT(pgciut));
			GNREASSERT(SelectPGCIT(pgciut, pgcit));
			GNREASSERT(mgm->HasFirstPlayPGC(has));
			if (has)
				{
				GNREASSERT(mgm->GetMGMVOBS(mgmVobs));
				vobs = mgmVobs;
				GNREASSERT(OpenTitleSet(vobs, pgcit, DVDPTT()));
				GNREASSERT(mgm->GetFirstPlayPGCI(pgci));
				SetDomain(FP_DOM);
				GNREASSERT(PlayPGCI(pgci));
				}
			break;
		case 1:
			GNREASSERT(mgm->GetMPGCIUT(pgciut));
			GNREASSERT(SelectPGCIT(pgciut, pgcit));
			GNREASSERT(pgcit.FindMenu(VMT_TITLE_MENU, pgcn));
			if (pgcn)
				{
				GNREASSERT(mgm->GetMGMVOBS(mgmVobs));
				vobs = mgmVobs;
				GNREASSERT(OpenTitleSet(vobs, pgcit, DVDPTT()));
				GNREASSERT(mgm->Identify(mgmType));
				if (mgmType == DMT_AMGM)
					SetDomain(AMGM_DOM);
				else
					SetDomain(VMGM_DOM);
				GNREASSERT(GoProgramChain(pgcn));
				}
			break;
		case 2:
			if (!titleSet && vtsn)
				{
				GNREASSERT(dvdDisk->GetTS(vtsn, titleSet));		// e.g. when in STOP state	no VTS is currently available!
				menuCacheValid = FALSE;
				}

			if (titleSet)
				{
				GNREASSERT(titleSet->GetMPGCIUT(pgciut));
				GNREASSERT(SelectPGCIT(pgciut, pgcit));

				switch(menuID)
					{
					case 3:
						GNREASSERT(pgcit.FindMenu(VMT_ROOT_MENU, pgcn));
						break;
					case 4:
						GNREASSERT(pgcit.FindMenu(VMT_SUBPICTURE_MENU, pgcn));
						break;
					case 5:
						GNREASSERT(pgcit.FindMenu(VMT_AUDIO_MENU, pgcn));
						break;
					case 6:
						GNREASSERT(pgcit.FindMenu(VMT_ANGLE_MENU, pgcn));
						break;
					case 7:
						GNREASSERT(pgcit.FindMenu(VMT_PTT_MENU, pgcn));
						break;
					}

				if (pgcn)
					{
					SetDomain(VTSM_DOM);
					vobs = titleSet->GetVTSMVOBS();

					if (IS_ERROR(err = OpenTitleSet(vobs, pgcit, DVDPTT())) ||
						 IS_ERROR(err = GoProgramChain(pgcn)))
						{
						Exit(err);

						GNRAISE(err);
						}
					}
				}
			break;
		case 3:
			GNREASSERT(mgm->GetMGMVOBS(mgmVobs));
			vobs = mgmVobs;
			GNREASSERT(mgm->GetMPGCIUT(pgciut));
			GNREASSERT(SelectPGCIT(pgciut, pgcit));
			SetDomain(VMGM_DOM);
			GNREASSERT(OpenTitleSet(vobs, pgcit, DVDPTT()));
			GNREASSERT(GoProgramChain(pgcn));
			break;
		}

	GNRAISE_OK;
	}

Error DVDDiskSequencer::GoSystemSpaceProgramChain(WORD pgcn, WORD domainID, WORD menuID)
	{
	if (GetDomain() == TT_DOM)
		{
		GNREASSERT(SaveResumeInformation());
		resumeValid = FALSE;
		}

	return InternalGoSystemSpaceProgramChain(pgcn, domainID, menuID);
	}

Error DVDDiskSequencer::GoSystemSpaceTitleSet(WORD ts, WORD title, WORD domainID, WORD menuID)
	{
	WORD numVTS;

	GNREASSERT(mgm->GetNumberOfTS(numVTS));

	if (ts == 0) ts = vtsn;

	if (ts > numVTS) ts = numVTS;
	else if (ts < 1) ts = 1;

	if (ts && !(titleSet && vtsn == ts))
		{
		GNREASSERT(CloseTitleSet());

		vtsn = ts;
		GNREASSERT(dvdDisk->GetTS(ts, titleSet));
		menuCacheValid = FALSE;
		}

	return InternalGoSystemSpaceProgramChain(0, domainID, menuID);
	}

Error DVDDiskSequencer::CallSystemSpaceProgramChain(WORD pgcn, WORD domainID, WORD menuID, WORD resumeCell)
	{
	if (GetDomain() == TT_DOM)
		{
		GNREASSERT(SaveResumeInformation());
		resumeValid = TRUE;
		}

	if (resumeCell)
		{
		this->resumeCell = resumeCell;
		resumeVOBU = 0;
		}

	return InternalGoSystemSpaceProgramChain(pgcn, domainID, menuID);
	}

Error DVDDiskSequencer::GetUOPs(DWORD & uops)
	{
	GNREASSERT(DVDTitleSequencer::GetUOPs(uops));

	if (!resumeAvail || !resumeValid) uops |= UOP_RESUME;

	GNRAISE_OK;
	}

Error DVDDiskSequencer::GetTitleSearchUOPs(WORD title, DWORD & uops)
	{
	if (title)
		return srpt->GetUOPS(title, uops);
	else if (GetDomain() == TT_DOM)
		{
		DVDLocation loc;

		DVDTitleSequencer::GetCurrentLocation(loc);

		loc.videoTitleSet = vtsn;
		srpt->GetTitleOfTSTitle(loc.videoTitleSet, loc.vtsTitle, loc.title);

		return srpt->GetUOPS(loc.title, uops);
		}
	else
		{
		uops = 3;
		GNRAISE_OK;
		}
	}

Error DVDDiskSequencer::TitleSearchUOPPermitted(WORD title, int uops, BOOL & permitted)
	{
	DWORD tsuops;

	GNREASSERT(GetTitleSearchUOPs(title, tsuops));
	permitted = !XTBF(uops, tsuops);
	GNRAISE_OK;
	}

//
//  Get video attributes
//

Error DVDDiskSequencer::GetVideoStreamAttributes(VideoStreamFormat & videoStream)
	{
	if (vobs)
		return vobs->GetVideoAttributes(videoStream);
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Get System Parameter
//

Error DVDDiskSequencer::GetSPRM(int index, WORD & sprm)
	{
	WORD w;

	switch(index)
		{
		case 4:
			if (GetDomain() == TT_DOM)
				{
				//DVDVTTSRPT srpt;

				//GNREASSERT(mgm->GetSRPT(srpt));
				GNREASSERT(GetSPRM(5, w));
				return srpt->GetTitleOfTSTitle(vtsn, w, sprm);
				}
			else if (resumeAvail)
				{
				//DVDVTTSRPT srpt;

				//GNREASSERT(mgm->GetSRPT(srpt));
				GNREASSERT(GetSPRM(5, w));
				return srpt->GetTitleOfTSTitle(vtsn, w, sprm);
				}
			else
				{
				sprm = 1;
				GNRAISE_OK;
				}
			break;
		default:
			return DVDTitleSequencer::GetSPRM(index, sprm);
		}
	}

//
//  Resume from system space
//

Error DVDDiskSequencer::ResumeFromSystemSpace(void)
	{
	Error err;

	if (resumeAvail && resumeValid)
		{
		DVDPGCIT pgcit;
		DVDPTT ptt;

		GNREASSERT(CloseTitleSet());

		resumeAvail = FALSE;
		resumeValid = FALSE;

		SetDomain(TT_DOM);

		vtsn = resumeVTSN;

		GNREASSERT(dvdDisk->GetTS(vtsn, titleSet));
		menuCacheValid = FALSE;
		vobs = titleSet->GetVTSVOBS();

		SetDomain(TT_DOM);

		GNREASSERT(titleSet->GetPTT(ptt));
		GNREASSERT(titleSet->GetPGCIT(pgcit));
		if (!IS_ERROR(err = DVDTitleSequencer::ResumeFromSystemSpace(vobs, pgcit, ptt)))
			{
			GNRAISE_OK;
			}

		SetDomain(STOP_DOM);

		GNRAISE(err);
		}
	else if (!resumeAvail)
		{
		Error err = GNR_OK;
		Exit(err);
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_NO_RESUME_INFORMATION);
	}

//
//  Save resume information
//

Error DVDDiskSequencer::SaveResumeInformation(void)
	{
	resumeVTSN = vtsn;

	return DVDTitleSequencer::SaveResumeInformation();
	}

//
//  Freeze current state
//

Error DVDDiskSequencer::Freeze(DVDDSFreezeState & state)
	{
	//
	// Do not freeze in FirstPlay domain
	//

	if (GetDomain() == FP_DOM)
		GNRAISE(GNR_OPERATION_PROHIBITED);

	//
	// Save data
	//

	state.vtsn = vtsn;
	state.resumeVTSN = resumeVTSN;
	state.domain = GetDomain();  // From DVDTitleSequencer

	GNREASSERT(DVDNavigationControl::Freeze(state.ncFreezeState));
	GNRAISE(DVDTitleSequencer::Freeze(state.tsFreezeState));
	}

//
//  Return to previously saved state
//

Error DVDDiskSequencer::Defrost(DVDDSFreezeState & state, DWORD flags)//, WORD parentalLevel)
	{
	DVDPGCIUT pgciut;
	DVDMGMVOBS * mgmVobs;

	//
	// Check if we eventually have FirstPlay domain (should never happen)
	//

	if (state.domain == FP_DOM)
		GNRAISE(GNR_OPERATION_PROHIBITED);

	//
	// Restore data
	//

	GNREASSERT(CloseTitleSet());

	GNREASSERT(DVDNavigationControl::Defrost(state.ncFreezeState));  // For SPRMs

	vtsn = state.vtsn;
	resumeVTSN = state.resumeVTSN;

	//
	// Restore domain, VTS and VOBS
	//

	SetDomain(state.domain);
	switch (GetDomain())  // FP_DOM can be omitted because of earlier check
		{
		case VMGM_DOM:
			GNREASSERT(mgm->GetMGMVOBS(mgmVobs));
			vobs = mgmVobs;
			GNREASSERT(mgm->GetMPGCIUT(pgciut));
			GNREASSERT(SelectPGCIT(pgciut, pgcit));
			ptt = DVDPTT();
			titleSet = NULL;
			menuCacheValid = FALSE;
			break;
		case VTSM_DOM:
			GNREASSERT(dvdDisk->GetTS(vtsn, titleSet));
			menuCacheValid = FALSE;
			vobs = titleSet->GetVTSMVOBS();
			GNREASSERT(titleSet->GetMPGCIUT(pgciut));
			GNREASSERT(SelectPGCIT(pgciut, pgcit));
			ptt = DVDPTT();
			break;
		case TT_DOM:
			GNREASSERT(dvdDisk->GetTS(vtsn, titleSet));
			menuCacheValid = FALSE;
			vobs = titleSet->GetVTSVOBS();
			GNREASSERT(titleSet->GetPGCIT(pgcit));
			GNREASSERT(titleSet->GetPTT(ptt));
			break;
		case STOP_DOM:
			titleSet = NULL;
			menuCacheValid = FALSE;
			vobs = NULL;
			break;
		}

	//
	// Defrost base class
	//

	if (GetDomain() != STOP_DOM)
		GNREASSERT(DVDTitleSequencer::Defrost(state.tsFreezeState, vobs, flags));

	//
	//  Restart playback
	//

	GNRAISE_OK;
	}

//
//  Get Playback Mode
//

DVDPlayerMode DVDDiskSequencer::InternalGetMode(void)
	{
	if (GetDomain() == STOP_DOM)
		return DPM_STOPPED;
	else if (IsStill())
		return DPM_STILL;
	else if (IsPaused())
		return DPM_PAUSED;
	else if (IsScanning())
		return DPM_SCANNING;
	else if (IsReversePlayback())
		return DPM_REVERSEPLAY;
	else if (IsTrickPlay())
		return DPM_TRICKPLAY;
	else
		return DPM_PLAYING;
	}

//
//  Set Breakpoint
//

Error DVDDiskSequencer::SetBreakpoint(WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id)
	{
	BOOL iospt;

	GNREASSERT(srpt->IsOneSequentialPGCTitle(title, iospt));
	if (!iospt)
		GNRAISE(GNR_OBJECT_INVALID);

	return DVDTitleSequencer::SetBreakpoint(title, ptt, time, flags, id);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDFile.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD File Classes
//
////////////////////////////////////////////////////////////////////

#include "DVDFile.h"

////////////////////////////////////////////////////////////////////
//
//  DVD Header File
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

DVDHeaderFile::DVDHeaderFile(DVDFileSystem * dvdfs, GenericFileSystem * baseFS, EventDispatcher* pEventDispatcher)
	: GenericFile(dvdfs)
	, EventSender(pEventDispatcher)
	{
	this->baseFS = baseFS;
	file = NULL;
	}

//
//  Destuctor
//

DVDHeaderFile::~DVDHeaderFile(void)
	{
	if (file)
		{
		file->Close();
		delete file;
		}
	}

//
//  Open file
//

Error DVDHeaderFile::Open(GenericFileSystemIterator * gfsi, DWORD accessType)
	{
	GenericDiskItem * gdi = NULL;
	RequestHandle rh;
	KernelInt64 size;
	BYTE b;
	int i;

	//
	//  Open the represented file
	//

	GNREASSERT(GenericFile::Open(gfsi, accessType));
	GNREASSERT(baseFS->OpenItem(gfsi, accessType, gdi));
	file = (GenericFile*)gdi;
	GNREASSERT(file->GetSize(size));

	//
	//  Initialize cache (forward because of streaming)
	//

	for (i=0; i<(int)(min(size, 8 * DVD_BLOCK_SIZE).ToDWORD()); i += DVD_BLOCK_SIZE)
		GNREASSERT(ReadByte(i, b, &rh));

	//
	//  Put cache data in LRU order, buffer 0 first)
	//

	for (i=(int)(min(size, 8 * DVD_BLOCK_SIZE).ToDWORD() - DVD_BLOCK_SIZE); i>=0; i -= DVD_BLOCK_SIZE)
		GNREASSERT(ReadByte(i, b, &rh));

	GNRAISE_OK;
	}

//
//  Close file
//

Error DVDHeaderFile::Close(void)
	{
	if (file)
		{
		GNREASSERT(file->Close());
		delete file;
		file = NULL;
		}

	GNRAISE_OK;
	}

//
//  Get copy management mode
//

Error DVDHeaderFile::GetCopyManagementInfo(GenericCopyManagementInfo & gcmi)
	{
	GNRAISE(file->GetCopyManagementInfo(gcmi));
	}

//
//  Get name
//

Error DVDHeaderFile::GetName(DiskItemName & name)
	{
	return file->GetName(name);
	}

//
//  Get path name
//

Error DVDHeaderFile::GetPathName(DiskItemName & name)
	{
	return file->GetPathName(name);
	}

//
//  Get size
//

Error DVDHeaderFile::GetSize(KernelInt64 & size)
	{
	return file->GetSize(size);
	}

//
//  Get iterator
//

Error DVDHeaderFile::GetIterator(GenericFileSystemIterator * & gfsi)
	{
	return file->GetIterator(gfsi);
	}

//
//  Build Unique Key
//

Error DVDHeaderFile::BuildUniqueKey(void)
	{
	VDAutoMutex mutex(&lock);
	RequestHandle rh;
	DriveBlock db;
	DWORD block;
	DWORD i;
	KernelInt64 size;
	DWORD headerSize;
	DWORD dataSize;
	Error err;

	GNREASSERT(file->GetSize(size));
	headerSize = baseFS->GetHeaderHeaderSize();
	dataSize = baseFS->GetHeaderDataSize();

	for (i=0; i<8; i++)
		uniqueKey.key[i] = 0x00;

	//
	//  Read all the blocks and use them for unique key
	//

	for (block=0; block < (size / dataSize).ToDWORD(); block++)
		{
		if (!IS_ERROR(err = LockBlocks(block, 1, &db, baseFS->GetHeaderSectorType() | DAF_CACHED | DAT_LOCK_AND_READ, &rh)))
			{
			for (i=headerSize; i<headerSize + dataSize; i++)
				{
				uniqueKey.key[0] += db.data[i];
				uniqueKey.key[1] += uniqueKey.key[0] + 0x32;
				uniqueKey.key[2] += uniqueKey.key[1] + 0x47;
				uniqueKey.key[3] += uniqueKey.key[2] + 0x21;
				uniqueKey.key[4] += uniqueKey.key[3] + 0x46;
				uniqueKey.key[5] += uniqueKey.key[4] + 0x57;
				uniqueKey.key[6] += uniqueKey.key[5] + 0x94;
				uniqueKey.key[7] += uniqueKey.key[6] + 0x25;
				}
			}

		UnlockBlocks(block, 1, &db, baseFS->GetHeaderSectorType() | DAF_CACHED | DAT_UNLOCK_CLEAN, &rh);
		GNREASSERT(err);
		}

	GNRAISE_OK;
	}

//
//  Test if file is encrypted
//

Error DVDHeaderFile::IsEncrypted(BOOL & enc)
	{
	return ((DVDFileSystem*)gfs)->DVDIsEncrypted(enc);
	}

//
//  Do authentication command
//

Error DVDHeaderFile::DoAuthenticationCommand(DVDAuthenticationCommand com, BYTE * key)
	{
	DWORD block;

	GNREASSERT(file->GetStartBlock(block));
	return ((DVDFileSystem*)gfs)->DoAuthenticationCommand(com, block, key);
	}

//
//  Read Byte
//

Error DVDHeaderFile::ReadByte(DWORD position, BYTE & b, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);

	return file->ReadByte(position, b, DAF_CACHED, rh);
	}

//
//  Read Word
//

Error DVDHeaderFile::ReadWord(DWORD position, WORD & w, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);

	return file->ReadWord(position, w, DAF_CACHED, rh);
	}

//
//  Read DWord
//

Error DVDHeaderFile::ReadDWord(DWORD position, DWORD & d, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);

	return file->ReadDWord(position, d, DAF_CACHED, rh);
	}

//
//  Read Byte Sequentially
//

Error DVDHeaderFile::ReadByteSeq(DWORD & position, BYTE & b, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);

	GNREASSERT(file->ReadByte(position, b, DAF_CACHED, rh));
	position++;
	GNRAISE_OK;
	}

//
//  Read Word Sequentially
//

Error DVDHeaderFile::ReadWordSeq(DWORD & position, WORD & w, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);

	GNREASSERT(file->ReadWord(position, w, DAF_CACHED, rh));
	position += 2;
	GNRAISE_OK;
	}

//
//  Read DWord Sequentially
//

Error DVDHeaderFile::ReadDWordSeq(DWORD & position, DWORD & d, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);

	GNREASSERT(file->ReadDWord(position, d, DAF_CACHED, rh));
	position += 4;
	GNRAISE_OK;
	}

//
//  Seek block
//

Error DVDHeaderFile::SeekBlock(DWORD block, DWORD flags, RequestHandle * rh)
	{
	return file->SeekBlock(block, flags, rh);
	}

//
//  Lock blocks
//

Error DVDHeaderFile::LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	Error err;
	err = file->LockBlocks(block, num, blocks, flags, rh);
	//DP("Lock %08lx %08lx %08lx", block, num, err);
	if (err == GNR_FILE_READ_ERROR)
		SendEvent(DNE_READ_ERROR, 0);
	GNRAISE(err);
	}

//
//  Unlock blocks
//

Error DVDHeaderFile::UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	Error err = file->UnlockBlocks(block, num, blocks, flags, rh);
//	DP("Unlock %08lx %08lx %08lx", block, num, err);
	GNRAISE(err);
	}


//
//  Flush
//

Error DVDHeaderFile::Flush(void)
	{
	return file->Flush();
	}

//
//  Terminate request
//

Error DVDHeaderFile::TerminateRequest(RequestHandle * rh)
	{
	return file->TerminateRequest(rh);
	}

////////////////////////////////////////////////////////////////////
//
//  File node class
//
////////////////////////////////////////////////////////////////////

//
//  Class declaration
//

class ChainFileNode : public Node
	{
	public:
		ChainFileNode(void);
		~ChainFileNode(void);

		GenericFile * gf;
		KernelInt64 size;
		DWORD numBlocks;
	};

//
//  Constructor
//

ChainFileNode::ChainFileNode(void)
	{
	gf = NULL;
	size = 0;
	numBlocks = 0;
	}

//
//  Destructor
//

ChainFileNode::~ChainFileNode(void)
	{
	if (gf)
		{
		gf->Close();
		delete gf;
		}
	}

////////////////////////////////////////////////////////////////////
//
//  DVD Data File
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

DVDDataFile::DVDDataFile(DVDFileSystem * dvdfs, GenericFileSystem * baseFS, EventDispatcher* pEventDispatcher)
	: GenericFile(dvdfs)
	, EventSender(pEventDispatcher)
	{
	this->baseFS = baseFS;
	}

//
//  Destructor
//

DVDDataFile::~DVDDataFile(void)
	{
	RemoveFiles();
	}

//
//  Open file
//

Error DVDDataFile::Open(GenericFileSystemIterator * gfsi, DWORD accessType)
	{
	GenericFileSystemIterator * gfsi2;
	DiskItemName name;
	Error err;

	//
	//  So far this is read only
	//

	if (accessType & FAT_WRITE)
		GNRAISE(GNR_FILE_READ_ONLY);

	//
	//  Initialize misc. variables
	//

	size = 0;
	fileOffset = 0;
	headerSize = baseFS->GetHeaderHeaderSize();
	dataSize = baseFS->GetHeaderDataSize();

	//
	//  Open this one and add the first file to the list
	//

	GNREASSERT(GenericFile::Open(gfsi, accessType | FAT_HEADER));
	GNREASSERT(AppendFile(gfsi, accessType));
	lastFile.node = (ChainFileNode*)files.First();
	lastFile.relativeStartBlock = 0x0;

	//
	//  Append more files if we open as chain file
	//

	if (accessType & FAT_CHAIN)
		{
		GNREASSERT(gfsi->GetItemName(name));
		name[name.Length() - 5]++;

		while (!IS_ERROR(err = baseFS->FindItem(name, DIT_FILE, FIF_NONE, gfsi, gfsi2)))
			{
			err = AppendFile(gfsi2, accessType);
			delete gfsi2;

			if (IS_ERROR(err))
				break;
			name[name.Length() - 5]++;		// For the moment only one character changes (i.e. xxx_1.vob, xxx_2.vob, etc.)
			}

		//
		//  If there is no more file, that's ok
		//

		if (err != GNR_OK && err != GNR_ITEM_NOT_FOUND)
			GNRAISE(err);
		}

	//
	//  Some more things to init
	//

	GNREASSERT(FindVOBStart());
	GNREASSERT(FindFirstEncryptedBlock());

	GNRAISE_OK;
	}

//
//  Close file
//

Error DVDDataFile::Close(void)
	{
	return RemoveFiles();
	}

//
//  Append file
//

Error DVDDataFile::AppendFile(GenericFileSystemIterator * gfsi, DWORD accessType)
	{
	GenericDiskItem * gdi;
	ChainFileNode * node;
	Error err;

	//
	//  Get new node
	//

	node = new ChainFileNode();
	if (!node)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	//
	//  Fill node with data
	//

	err = gfsi->OpenItem(accessType | FAT_HEADER, gdi);
	if (!IS_ERROR(err))
		{
		node->gf = (GenericFile*)gdi;
		if (!IS_ERROR(err = gfsi->GetItemSize(node->size)))
			{
			node->numBlocks = (node->size / dataSize).ToDWORD();
			size += node->size;
			}
		}

	//
	//  Insert node into file list
	//

	if (!IS_ERROR(err))
		files.InsertLast(node);
	else
		delete node;

	GNRAISE(err);
	}

//
//  Remove files
//

Error DVDDataFile::RemoveFiles(void)
	{
	ChainFileNode * node;

	while (files.Num())
		{
		node = (ChainFileNode*)files.Pop();
		delete node;
		}

	GNRAISE_OK;
	}

//
//  Get pointer to file containing a certain block
//

Error DVDDataFile::GetFile(DWORD block, GenericFile * & file)
	{
	DWORD dummy1, dummy2;

	return GetFile(block, 1, file, dummy1, dummy2);
	}

//
//  Get pointer to file containing a certain block and the number of blocks available after that block in the file
//

Error DVDDataFile::GetFile(DWORD block, DWORD num, GenericFile * & file, DWORD & relativeStart, DWORD & avail)
	{
	DWORD currentBlock = 0;
	ChainFileNode * node;

	//
	//  Let's see if last file requested will do the job
	//

	if (lastFile.relativeStartBlock <= block && lastFile.relativeStartBlock + lastFile.node->numBlocks > block)
		{
		node = lastFile.node;
		relativeStart = lastFile.relativeStartBlock;

		file = node->gf;
		avail = node->numBlocks - (block - relativeStart);
		if (avail > num)
			avail = num;
		GNRAISE_OK;
		}
	else
		{
		//
		//  Look for the file containing the requested block
		//

		ITERATE_UNTIL(node, &files, currentBlock + node->numBlocks > block)
			currentBlock += node->numBlocks;
		ITERATE_END;

		//
		//  See if we found the file and return it if so
		//

		if (node && currentBlock + node->numBlocks > block)
			{
			file = node->gf;
			avail = node->numBlocks - (block - currentBlock);
			if (avail > num)
				avail = num;

			lastFile.node = node;
			lastFile.relativeStartBlock = currentBlock;
			relativeStart = currentBlock;

			GNRAISE_OK;
			}
		else
			GNRAISE(GNR_OBJECT_NOT_FOUND);
		}
	}

//
//  Find VOB start
//  BUG fix for Madonna "Truth or Dare"
//  This title has an offset into the "vob" files.
//

Error DVDDataFile::FindVOBStart(void)
	{
	RequestHandle rh;
	DriveBlock driveBlock;
	Error err = GNR_OBJECT_NOT_FOUND;
	DWORD offset = 0;
	DWORD num = (size / dataSize).ToDWORD();
	if (num > 16) num = 16;

	while (offset < num && err == GNR_OBJECT_NOT_FOUND)
		{
		if (!IS_ERROR(err = LockBlocks(offset, 1, &driveBlock, DAT_LOCK_AND_READ, &rh)))
			{
			if (driveBlock.data[0]  == 0x00 && driveBlock.data[1]  == 0x00 &&
				 driveBlock.data[2]  == 0x01 && driveBlock.data[3]  == 0xba &&
				 driveBlock.data[14] == 0x00 && driveBlock.data[15] == 0x00 &&
				 driveBlock.data[16] == 0x01 && driveBlock.data[17] == 0xbb)
				{
				SetFileOffset(fileOffset);
				err = GNR_OK;
				}
			else
				err = GNR_OBJECT_NOT_FOUND;
			}

		UnlockBlocks(offset, 1, &driveBlock, DAT_UNLOCK_CLEAN, &rh);
		offset++;
		}

	if (offset == num)
		GNRAISE_OK;
	else
		GNRAISE(err);
	}

//
//  Find first encrypted block
//

Error DVDDataFile::FindFirstEncryptedBlock(void)
	{
	RequestHandle rh;
	BYTE b;
	DWORD num;

	num = (size / (KernelInt64)dataSize).ToDWORD();
	if (num > 16) num = 16;

	firstEncryptedBlock = 1;

	while (firstEncryptedBlock < num)
		{
		// If the read attempt fails because the sector is encrypted and cannot be
		// accessed, firstEncryptedBlock already has the correct value.
		GNREASSERT(ReadByte(firstEncryptedBlock * dataSize + 17, b, &rh));
		if ((b & 0xf8) == 0xe0 || ((b & 0xf8) == 0xc0) || (b == 0xbd))
			{
			GNREASSERT(ReadByte(firstEncryptedBlock * dataSize + 20, b, &rh));
			if ((b & 0x30) != 0)
				GNRAISE_OK;
			}

		firstEncryptedBlock++;
		}

	firstEncryptedBlock = 0;

	GNRAISE_OK;
	}

//
//  Get name
//

Error DVDDataFile::GetName(DiskItemName & name)
	{
	GenericFile * file;

	GNREASSERT(GetFile(0, file));
	return file->GetName(name);
	}

//
//  Get path name
//

Error DVDDataFile::GetPathName(DiskItemName & name)
	{
	GenericFile * file;

	GNREASSERT(GetFile(0, file));
	return file->GetPathName(name);
	}

//
//  Get size
//

Error DVDDataFile::GetSize(KernelInt64 & size)
	{
	size = this->size;
	GNRAISE_OK;
	}

//
//  Get iterator
//

Error DVDDataFile::GetIterator(GenericFileSystemIterator * & gfsi)
	{
	GenericFile * file;

	GNREASSERT(GetFile(0, file));
	return file->GetIterator(gfsi);
	}

//
//  Build unique key
//

Error DVDDataFile::BuildUniqueKey(void)
	{
	int i;

	for (i=0; i<8; i++)
		uniqueKey.key[i] = 0x00;

	GNRAISE_OK;
	}

//
//  Seek block
//

Error DVDDataFile::SeekBlock(DWORD block, DWORD flags, RequestHandle * rh)
	{
	GenericFile * file;

	GNREASSERT(GetFile(block, file));

	return file->SeekBlock(block, flags, rh);
	}

//
//  Lock blocks
//

Error DVDDataFile::LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	GenericFile * file;
	DWORD relativeStart;
	DWORD avail;
	DWORD i;

	while (num)
		{
		Error err;
		GNREASSERT(GetFile(block, num, file, relativeStart, avail));
		err = file->LockBlocks(block - relativeStart, avail, blocks, flags | DAF_STREAMING, rh);
		for (i=0; i<avail; i++)
			blocks[i].data += headerSize;

		if (err == GNR_FILE_READ_ERROR)
			SendEvent(DNE_READ_ERROR, 0);

		GNREASSERT(err);

		num -= avail;
		block += avail;
		blocks += avail;
		}

	GNRAISE_OK;
	}

//
//  Unlock blocks
//

Error DVDDataFile::UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	GenericFile * file;
	DWORD relativeStart;
	DWORD avail;

	while (num)
		{
		GNREASSERT(GetFile(block, num, file, relativeStart, avail));
		GNREASSERT(file->UnlockBlocks(block - relativeStart, avail, blocks, flags | DAF_STREAMING, rh));
		num -= avail;
		block += avail;
		blocks += avail;
		}

	GNRAISE_OK;
	}

//
//  Read byte
//

Error DVDDataFile::ReadByte(KernelInt64 position, BYTE & b, RequestHandle * rh)
	{
	GenericFile * file;
	DWORD block;

	block = (position / dataSize).ToDWORD();
	GNREASSERT(GetFile(block, file));

	return file->ReadBytes(position, 1, &b, DAF_STREAMING, rh);
	}

//
//  Test if file is encrypted
//

Error DVDDataFile::IsEncrypted(BOOL & enc)
	{
	GNREASSERT(((DVDFileSystem*)gfs)->DVDIsEncrypted(enc));
	enc = enc && firstEncryptedBlock != 0;
	GNRAISE_OK;
	}

//
//  Do authentication command
//

Error DVDDataFile::DoAuthenticationCommand(DVDAuthenticationCommand com, DWORD & block, BYTE * key, int retry)
	{
	GenericFile * file;

	GNREASSERT(GetFile(0, file));
	GNREASSERT(file->GetStartBlock(block));

	if (com == DAC_READ_TITLE_KEY)
		block += firstEncryptedBlock + retry;

	return ((DVDFileSystem*)gfs)->DoAuthenticationCommand(com, block, key);
	}

//
//  Get copy management mode
//

Error DVDDataFile::GetCopyManagementInfo(GenericCopyManagementInfo & gcmi)
	{
	GenericFile * file;

	GNREASSERT(GetFile(0, file));
	GNRAISE(file->GetCopyManagementInfo(gcmi));
	}

//
//  Flush
//

Error DVDDataFile::Flush(void)
	{
	GNRAISE_OK;
	}

//
//  Terminate request
//

Error DVDDataFile::TerminateRequest(RequestHandle * rh)
	{
	GNRAISE_OK;
	}

////////////////////////////////////////////////////////////////////
//
//  DVD Iterator Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

DVDIterator::DVDIterator(DVDFileSystem * dvdfs, GenericFileSystemIterator * gfsi) : GenericFileSystemIterator(dvdfs)
	{
	this->gfsi = gfsi;
	}

//
//  Destructor
//

DVDIterator::~DVDIterator(void)
	{
	delete gfsi;
	}

//
//  Clone
//

Error DVDIterator::Clone(GenericFileSystemIterator * & gfsi) const
	{
	DVDIterator * dvdi;

	GNREASSERT(Clone(dvdi));
	gfsi = dvdi;
	GNRAISE_OK;
	}

//
//  Clone
//

Error DVDIterator::Clone(DVDIterator * & dvdi) const
	{
	GenericFileSystemIterator * help;

	GNREASSERT(gfsi->Clone(help));
	dvdi = new DVDIterator((DVDFileSystem*)gfs, help);
	if (dvdi)
		GNRAISE_OK;
	else
		{
		delete gfsi;
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
	}

//
//  Comparison function
//

BOOL DVDIterator::Equals(GenericFileSystemIterator * gfsi)
	{
	return *(this->gfsi) == (*gfsi);
	}

//
//  Go to first item
//

Error DVDIterator::GoToFirstItem(void)
	{
	return gfsi->GoToFirstItem();
	}

//
//  Go to next item
//

Error DVDIterator::GoToNextItem(void)
	{
	return gfsi->GoToNextItem();
	}

//
//  Go to sub dir
//

Error DVDIterator::GoToSubDir(GenericFileSystemIterator * & gfsi)
	{
	GenericFileSystemIterator * help;

	GNREASSERT(this->gfsi->GoToSubDir(help));
	gfsi = new DVDIterator((DVDFileSystem*)gfs, help);

	if (gfsi)
		GNRAISE_OK;
	else
		{
		delete help;
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
	}

//
//  Go to parent dir
//

Error DVDIterator::GoToParentDir(GenericFileSystemIterator * & gfsi)
	{
	GenericFileSystemIterator * help;

	GNREASSERT(this->gfsi->GoToSubDir(help));
	gfsi = new DVDIterator((DVDFileSystem*)gfs, help);

	if (gfsi)
		GNRAISE_OK;
	else
		{
		delete help;
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
	}

//
//  Get path name
//

Error DVDIterator::GetPathName(DiskItemName & name)
	{
	return gfsi->GetPathName(name);
	}

//
//  Get item type
//

Error DVDIterator::GetItemType(DiskItemType & type)
	{
	return gfsi->GetItemType(type);
	}

//
//  Get item name
//

Error DVDIterator::GetItemName(DiskItemName & name)
	{
	return gfsi->GetItemName(name);
	}

//
//  Get item size
//

Error DVDIterator::GetItemSize(KernelInt64 & size)
	{
	return gfsi->GetItemSize(size);
	}

//
//  Get number of items
//

Error DVDIterator::GetNumberOfItems(DWORD & num)
	{
	return gfsi->GetNumberOfItems(num);
	}

//
// Get current dir
//

Error DVDIterator::GetCurrentDir(GenericDirectory * & gd)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Open item
//

Error DVDIterator::OpenItem(DWORD accessType, GenericDiskItem * & gdi)
	{
	return gfs->OpenItem(this, accessType, gdi);
	}

////////////////////////////////////////////////////////////////////
//
//  DVD File System Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

DVDFileSystem::DVDFileSystem(EventDispatcher* pEventDispatcher)
	: GenericFileSystem()
	, EventSender(pEventDispatcher)
	{
	cdvdVolume = NULL;
	baseFS = NULL;
	fileSystemType = FS_DVD;
	}

//
//  Destructor
//

DVDFileSystem::~DVDFileSystem(void)
	{
	//DP("From ~DVDFileSystem - FS R:");
	if (baseFS)
		baseFS->Release();

	//DP("From ~DVDFileSystem - V R:");
	if (cdvdVolume)
		cdvdVolume->Release();
	}

//
//  Initialize
//  (Note that volume is ignored)
//

Error DVDFileSystem::Init(GenericFileSystemIterator * mountPoint, GenericVolume * volume, GenericProfile * profile)
	{
	GNREASSERT(((RootIterator*)mountPoint)->ObtainSubFileSystem(baseFS));
	GNREASSERT(baseFS->ObtainVolume(volume));
	cdvdVolume = (CDVDVolume*)volume;
	GNREASSERT(GenericFileSystem::Init(mountPoint, volume, profile));
	return baseFS->GetLogicalBaseBlock(logicalBaseBlock);
	}

//
//  Open item by iterator
//

Error DVDFileSystem::OpenItem(GenericFileSystemIterator * gfsi, DWORD accessType, GenericDiskItem * & gdi)
	{
	GenericFile * gf;
	GenericDirectory * gd;
	DiskItemType type;
	Error err;

	GNREASSERT(gfsi->GetItemType(type));
	if (type == DIT_FILE)
		{
		GNREASSERT(CreateFile(accessType, gf));
		gdi = gf;
		}
	else if (type == DIT_DIR)
		{
		GNREASSERT(CreateDirectory(accessType, gd));
		gdi = gd;
		}
	else
		GNRAISE(GNR_OBJECT_INVALID);

	if (IS_ERROR(err = gdi->Open(((DVDIterator*)gfsi)->gfsi, accessType)))
		delete gdi;

	GNRAISE(err);
	}

//
//  Open item by name (this is here only because of the stupidity of C++)
//

Error DVDFileSystem::OpenItem(const DiskItemName & name, DWORD accessType, GenericDiskItem * & gdi)
	{
	return GenericFileSystem::OpenItem(name, accessType, gdi);
	}

//
//  Create file
//

Error DVDFileSystem::CreateFile(DWORD flags, GenericFile * & gf)
	{
	if (flags & FAT_HEADER)
		gf = new DVDHeaderFile(this, baseFS, GetEventDispatcher());
	else
		gf = new DVDDataFile(this, baseFS, GetEventDispatcher());

	if (gf)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Create directory
//

Error DVDFileSystem::CreateDirectory(DWORD flags, GenericDirectory * & gd)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Create iterator
//

Error DVDFileSystem::CreateIterator(GenericFileSystemIterator * & gfsi)
	{
	GenericFileSystemIterator * help;

	GNREASSERT(baseFS->CreateIterator(help));

	gfsi = new DVDIterator(this, help);
	if (gfsi)
		GNRAISE_OK;
	else
		{
		delete help;
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
	}

//
//  Seek block
//

Error DVDFileSystem::SeekBlock(DWORD block, DWORD flags, RequestHandle * rh)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

//
//  Lock blocks
//

Error DVDFileSystem::LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

//
//  Unlock blocks
//

Error DVDFileSystem::UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

//
//  Get copy management mode
//

Error DVDFileSystem::GetCopyManagementInfo(DWORD block, GenericCopyManagementInfo & gcmi)
	{
	gcmi = GCMI_COPY_FORBIDDEN;
	GNRAISE_OK;
	}

//
//  Get volume name
//

Error DVDFileSystem::GetVolumeName(KernelString & name)
	{
	return baseFS->GetVolumeName(name);
	}

//
//  Get volume set name
//

Error DVDFileSystem::GetVolumeSetName(KernelString & name)
	{
	return baseFS->GetVolumeSetName(name);
	}

//
//  Get volume set index
//

Error DVDFileSystem::GetVolumeSetIndex(int & index)
	{
	return baseFS->GetVolumeSetIndex(index);
	}

//
//  Get volume set size
//

Error DVDFileSystem::GetVolumeSetSize(int & size)
	{
	return baseFS->GetVolumeSetSize(size);
	}

//
//  Build unique key
//

Error DVDFileSystem::BuildUniqueKey(void)
	{
	GenericDiskItem * gdi;
	DVDHeaderFile * file;
	Error err = GNR_OK;

	err = GNR_INVALID_UNIQUE_KEY;
	if (!IS_ERROR(OpenItem("video_ts\\video_ts.ifo", FAT_HEADER, gdi)) ||
		 !IS_ERROR(OpenItem("video_ts\\video_ts.inf", FAT_HEADER, gdi)) ||
		 !IS_ERROR(OpenItem("audio_ts\\audio_ts.ifo", FAT_HEADER, gdi)))
		{
		file = (DVDHeaderFile*)gdi;
		err = file->GetUniqueKey(uniqueKey.key);
		file->Close();
		delete file;
		}

	GNRAISE(err);
	}

//
//  Set drive block size
//

Error DVDFileSystem::SetDriveBlockSize(DWORD size)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

//
//  Get number of drive blocks
//

Error DVDFileSystem::GetNumberOfDriveBlocks(DWORD & num)
	{
	return baseFS->GetNumberOfDriveBlocks(num);
	}

//
//  Set number of drive blocks
//

Error DVDFileSystem::SetNumberOfDriveBlocks(DWORD num)
	{
	return baseFS->SetNumberOfDriveBlocks(num);
	}

//
//  Terminate request
//

Error DVDFileSystem::TerminateRequest(RequestHandle * rh)
	{
	return baseFS->TerminateRequest(rh);
	}

//
//  Flush
//

Error DVDFileSystem::Flush(void)
	{
	return baseFS->Flush();
	}

//
//  Get drive name
//

Error DVDFileSystem::GetDriveName(KernelString & name)
	{
	return baseFS->GetDriveName(name);
	}

//
//  Test if DVD is encrypted
//

Error DVDFileSystem::DVDIsEncrypted(BOOL & enc)
	{
	if (cdvdVolume)
		return cdvdVolume->DVDIsEncrypted(enc);
	else
		GNRAISE(GNR_NO_VOLUME);
	}

//
//  Do authentication command
//

Error DVDFileSystem::DoAuthenticationCommand(DVDAuthenticationCommand com, DWORD block, BYTE * key)
	{
	if (cdvdVolume)
		return cdvdVolume->DoAuthenticationCommand(com, logicalBaseBlock + block, key);
	else
		GNRAISE(GNR_NO_VOLUME);
	}

//
//  Get RPC data
//

Error DVDFileSystem::GetRPCData(BOOL & isRPC2, BYTE & region, BYTE & availSets)
	{
	if (cdvdVolume)
		return cdvdVolume->GetRPCData(isRPC2, region, availSets);
	else
		GNRAISE(GNR_NO_VOLUME);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDHeader.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD Header File Information
//
////////////////////////////////////////////////////////////////////

#include "DVDHeader.h"


//////////////////////////////////////////////////////////////////////
//
//  Cell Playback Information
//
//////////////////////////////////////////////////////////////////////

//
// Constructor
//

DVDCPBI::DVDCPBI(void)
	{

	}

//
// Destructor
//

DVDCPBI::~DVDCPBI(void)
	{

	}

Error DVDCPBI::Init(DVDHeaderFile * file, DWORD start)
	{
	RequestHandle rh;

	GNREASSERT(file->ReadDWordSeq(start, cat, &rh));
	GNREASSERT(file->ReadDWordSeq(start, pbtm, &rh));
	GNREASSERT(file->ReadDWordSeq(start, fvobu_sa, &rh));
	GNREASSERT(file->ReadDWordSeq(start, filvu_ea, &rh));
	GNREASSERT(file->ReadDWordSeq(start, lvobu_sa, &rh));
	return file->ReadDWordSeq(start, lvobu_ea, &rh);
	}

//////////////////////////////////////////////////////////////////////
//
//  Audio Manager Menu Cell Playback Information
//
//////////////////////////////////////////////////////////////////////

//
// Constructor
//

DVDAMGMCPBI::DVDAMGMCPBI(void)
	{

	}

//
// Destructor
//

DVDAMGMCPBI::~DVDAMGMCPBI(void)
	{

	}

Error DVDAMGMCPBI::Init(DVDHeaderFile * file, DWORD start)
	{
	RequestHandle rh;

	GNREASSERT(file->ReadDWordSeq(start, cat, &rh));
	GNREASSERT(file->ReadDWordSeq(start, pbtm, &rh));
	GNREASSERT(file->ReadDWordSeq(start, fvobu_sa, &rh));
	GNREASSERT(file->ReadDWordSeq(start, lvobu_sa, &rh));
	return file->ReadDWordSeq(start, lvobu_ea, &rh);
	}

////////////////////////////////////////////////////////////////////
//
//  Cell Playback Information for Audio Only Title
//
////////////////////////////////////////////////////////////////////

//
// Constructor
//

DVDATSCPBI::DVDATSCPBI(void)
	{

	}

//
// Destructor
//

DVDATSCPBI::~DVDATSCPBI(void)
	{

	}

Error DVDATSCPBI::Init(DVDHeaderFile * file, DWORD start)
	{
	RequestHandle rh;

	GNREASSERT(file->ReadByteSeq(start, ats_ixn, &rh));
	GNREASSERT(file->ReadByteSeq(start, ats_ty, &rh));
	GNREASSERT(file->ReadDWordSeq(start, ats_sa, &rh));
	return file->ReadDWordSeq(start, ats_ea, &rh);
	}

//////////////////////////////////////////////////////////////////////
//
//  Generic Program Chain Information
//
//////////////////////////////////////////////////////////////////////

DVDGenericPGCI::DVDGenericPGCI(DVDDiskPlayerFactory * factory)
	{
	this->factory = factory;
	}

DVDGenericPGCI::~DVDGenericPGCI(void)
	{

	}

Error DVDGenericPGCI::GetNumberOfPrograms(WORD & num)
	{
	DWORD d;

	GNREASSERT(file->ReadDWord(start, d, &rh));
	num = (WORD)XTBF(8, 7, d);
	GNRAISE_OK;
	}

Error DVDGenericPGCI::GetNumberOfCells(WORD & num)
	{
	DWORD d;

	GNREASSERT(file->ReadDWord(start, d, &rh));
	num = (WORD)XTBF(0, 8, d);
	GNRAISE_OK;
	}

//////////////////////////////////////////////////////////////////////
//
//  Part of Title
//
//////////////////////////////////////////////////////////////////////

Error DVDPTT::GetNumberOfTitleUnits(WORD & num)
	{
	if (file)
		return file->ReadWord(start, num, &rh);
	else
		GNRAISE(GNR_OBJECT_NOT_ALLOCATED);
	}


Error DVDPTT::GetNumberOfPartOfTitle(WORD unit, WORD & num)
	{
	DWORD d1, d2;
	WORD w;

	if (file)
		{
		GNREASSERT(file->ReadWord(start, w, &rh));  // Number of Title Units
		GNREASSERT(file->ReadDWord(start + 8 + 4 * (unit - 1), d1, &rh));

		if  (unit == w)
			{
			GNREASSERT(file->ReadDWord(start + 4, d2, &rh));
			d2++;
			}
		else
			{
			GNREASSERT(file->ReadDWord(start + 8 + 4 * (unit - 1) + 4, d2, &rh));
			}

		num = (WORD)((d2 - d1) / 4);
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_OBJECT_NOT_ALLOCATED);
	}

//
//  Get Program Chain and Program Number from Part Of Title and Title Unit
//

Error DVDPTT::GetPartOfTitlePGC(WORD unit, WORD ptt, WORD & pgc, WORD & pg)
	{
	DWORD d;

	if (file)
		{
		GNREASSERT(file->ReadDWord(start + 8 + 4 * (unit - 1), d, &rh));
		GNREASSERT(file->ReadDWord(start + d + 4 * (ptt - 1), d, &rh));

		pgc = (WORD)XTBF(16, 16, d);
		pg  = (WORD)XTBF(0, 8, d);
		}
	else
		{
		pgc =  0;
		pg = 0;
		}

	GNRAISE_OK;
	}

//
//  Get Part Of Title from PGC, Program and Title
//

Error DVDPTT::GetPartAndTitle(WORD pgcn, WORD pgn, WORD title, WORD & ptt)
	{
	WORD hptt, pnum;
   WORD hpgcn, hpg;

	if (file)
		{
		if (title)
			{
			ptt = 1;
			GNREASSERT(GetNumberOfPartOfTitle(title, pnum));
			for(hptt = 1; hptt <= pnum; hptt++)
				{
				GNREASSERT(GetPartOfTitlePGC(title, hptt, hpgcn, hpg));

				if (hpgcn == pgcn)
					{
					for(;hptt <= pnum; hptt++)
						{
						GNREASSERT(GetPartOfTitlePGC(title, hptt, hpgcn, hpg));

						if (hpgcn != pgcn || hpg > pgn)
							GNRAISE_OK;

						ptt = hptt;
						}

					GNRAISE_OK;
					}

				ptt = hptt;
				}
			}
		else
			ptt = 0;

		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_OBJECT_NOT_ALLOCATED);
	}

//
//  Get part of title
//

Error DVDPTT::GetPartOfTitle(WORD title, WORD pgcn, WORD pg, WORD & pptt)
	{
	WORD ptt, pnum, hpgcn, hpg;

	pptt = 1;
	GNREASSERT(GetNumberOfPartOfTitle(title, pnum));

	for (ptt=2; ptt<=pnum; ptt++)
		{
		GNREASSERT(GetPartOfTitlePGC(title, ptt, hpgcn, hpg));

		if (hpgcn == pgcn)
			{
			if (hpg > pg)
				GNRAISE_OK;
			pptt = ptt;
			}
		}

	GNRAISE_OK;
	}

//////////////////////////////////////////////////////////////////////
//
//  Title Search Pointer Table (in VMGI or AMGI)
//
//////////////////////////////////////////////////////////////////////

//
// Return number of titles
//

Error DVDSRPT::GetNumberOfTitles(WORD & num)
	{
	return file->ReadWord(start, num, &rh);
	}

//////////////////////////////////////////////////////////////////////
//
//  Parental Management Information Table
//
//////////////////////////////////////////////////////////////////////

Error DVDPTLMAIT::GetNumberOfVTS(WORD & num)
	{
	GNREASSERT(file->ReadWord(start + 2, num, &rh));
	num &= 0x7f;
	GNRAISE_OK;
	}

Error DVDPTLMAIT::GetNumberOfCountries(WORD & num)
	{
	return file->ReadWord(start, num, &rh);
	}

Error DVDPTLMAIT::GetCountryCode(WORD entry, WORD & cc)
	{
	return file->ReadWord(start + 8 + 8 * (entry - 1), cc, &rh);
	}

Error DVDPTLMAIT::GetPTLMAI(WORD countryCode, DVDPTLMAI & ptlmai)
	{
	WORD w, i, numVTS;
	WORD cc;

	GNREASSERT(GetNumberOfCountries(i));
	GNREASSERT(GetNumberOfVTS(numVTS));

	while (i > 1)
		{
		GNREASSERT(GetCountryCode(i, cc));
		if (i == cc)
			break;
		i--;
		}

	GNREASSERT(file->ReadWord(start + 8 + 8 * (i - 1) + 4, w, &rh));

	ptlmai = DVDPTLMAI(file, start + w, numVTS);
	GNRAISE_OK;
	}

////////////////////////////////////////////////////////////////////
//
//  Parental Management Information
//
////////////////////////////////////////////////////////////////////

Error DVDPTLMAI::GetVMGId(WORD level, WORD & id)
	{
	if (!file || level < 1 || level > 8)
		{
		id = 0xffff;
		GNRAISE_OK;
		}
	else
		return file->ReadWord(start + (8-level) * (numVTS + 1) * 2, id, &rh);
	}

Error DVDPTLMAI::GetVTSId(WORD vtsn, WORD level, WORD & id)
	{
	if (!file || level < 1 || level > 8)
		{
		id = 0xffff;
		GNRAISE_OK;
		}
	else
		return file->ReadWord(start + (8-level) * (numVTS + 1 ) * 2 + 2 * vtsn, id, &rh);
	}

//////////////////////////////////////////////////////////////////////
//
//  Object Set
//
//////////////////////////////////////////////////////////////////////

DWORD DVDOBS::uniqueKeys;

//////////////////////////////////////////////////////////////////////
//
//  Video Object Set
//
//////////////////////////////////////////////////////////////////////

//
//  Return video attributes decoded
//

Error DVDVOBS::GetVideoAttributes(VideoStreamFormat & videoStream)
	{
	WORD attr;

	GNREASSERT(GetVideoAttributes(attr));

	//
	//  Get video compression mode
	//

	switch (XTBF(14, 2, attr))
		{
		case 0: videoStream.compressionMode = VCM_MPEG1; break;
		case 1: videoStream.compressionMode = VCM_MPEG2; break;
		default: videoStream.compressionMode = VCM_UNKNOWN; break;
		}

	//
	//  Get video standard
	//

	switch (XTBF(12, 2, attr))
		{
		case 0: videoStream.videoStandard = VSTD_NTSC; break;
		case 1: videoStream.videoStandard = VSTD_PAL; break;
		default: videoStream.videoStandard = VSTD_UNKNOWN; break;
		}

	//
	//  Get aspect ratio
	//

	switch (XTBF(10, 2, attr))
		{
		case 0: videoStream.sourceAspectRatio = DPM_4BY3; break;
		case 3: videoStream.sourceAspectRatio = DPM_16BY9; break;
		default: videoStream.sourceAspectRatio = DPM_NONE; break;
		}

	//
	//  Get display mode on 4 by 3 display
	//

	switch (XTBF(8, 2, attr))
		{
		case 0: videoStream.panScanOn4By3 = videoStream.letterboxedOn4By3 = TRUE; break;
		case 1: videoStream.panScanOn4By3 = TRUE; videoStream.letterboxedOn4By3 = FALSE; break;
		case 2: videoStream.panScanOn4By3 = FALSE; videoStream.letterboxedOn4By3 = TRUE; break;
		default: videoStream.panScanOn4By3 = videoStream.letterboxedOn4By3 = FALSE; break;
		}

	//
	//  Get line 21 information
	//

	switch (XTBF(6, 2, attr))
		{
		case 0: videoStream.line21Mode = L21M_NO_DATA; break;
		case 1: videoStream.line21Mode = L21M_SECOND_FIELD; break;
		case 2: videoStream.line21Mode = L21M_FIRST_FIELD; break;
		case 3: videoStream.line21Mode = L21M_BOTH_FIELDS; break;
		}

	//
	//  Get source picture resolution
	//

	if (videoStream.videoStandard == VSTD_NTSC)
		videoStream.sourceHeight = 480;
	else
		videoStream.sourceHeight = 576;

	switch (XTBF(3, 2, attr))
		{
		case 0: videoStream.sourceWidth = 720; break;
		case 1: videoStream.sourceWidth = 704; break;
		case 2: videoStream.sourceWidth = 352; break;
		case 3: videoStream.sourceWidth = 352; videoStream.sourceHeight >>= 1; break;		// Half height only
		default: videoStream.sourceWidth = videoStream.sourceHeight = 0; break;
		}

	//
	//  Get source letterboxed information
	//

	videoStream.sourceLetterboxed = XTBF(2, attr);

	GNRAISE_OK;
	}

//
//  Get audio stream attributes
//

Error DVDVOBS::GetAudioStreamAttributes(int num, DVDAudioStreamFormat & format)
	{
	WORD attrib;
	WORD language, extension;
	WORD appInfo;

	GNREASSERT(GetAudioStreamAttribute(num, attrib, language, extension, appInfo));

	format.languageCode = language;
	format.languageExtension = extension;

	switch (XTBF(13, 3, attrib))
		{
		case 0: format.codingMode = DAM_AC3;   break;
		case 2: format.codingMode = DAM_MPEG1; break;
		case 3: format.codingMode = DAM_MPEG2; break;
		case 4: format.codingMode = DAM_LPCM;  break;
		case 6: format.codingMode = DAM_DTS;   break;
		case 7: format.codingMode = DAM_SDDS;  break;
		}

	if (format.codingMode == DAM_LPCM)
		format.bitsPerSample = (WORD)XTBF(6,2, attrib) * 4 + 16;
	else
		format.bitsPerSample = 16;

	format.samplesPerSecond = 48000 * (1 + XTBF(4, 2, attrib));
	format.channels = (WORD)XTBF(0, 3, attrib) + 1;

	switch (XTBF(8, 2, attrib))
		{
		case 0: format.applicationMode = DAAM_UNDEFINED;	break;
		case 1: format.applicationMode = DAAM_KARAOKE;		break;
		case 2: format.applicationMode = DAAM_SURROUND;		break;
		default: format.applicationMode = DAAM_UNDEFINED;	break;
		}

	format.channelAssignment = (BYTE)XTBF(4, 3, appInfo);

	if (format.applicationMode == DAAM_KARAOKE)
		{
		format.mcIntro = (BYTE)XTBF(1, 1, appInfo);

		switch (XTBF(0, 1, appInfo))
			{
			case 0: format.soloDuetMode = DKM_SOLO;	break;
			case 1: format.soloDuetMode = DKM_DUET;	break;
			default: format.soloDuetMode = DKM_UNDEFINED;	break;
			}
		}
	else
		{
		format.mcIntro = 0;
		format.soloDuetMode = DKM_UNDEFINED;
		}

	GNRAISE_OK;
	}

//
//  Get sub picture stream attributes
//

Error DVDVOBS::GetSubPictureStreamAttributes(int num, DVDSubPictureStreamFormat & format)
	{
	WORD attrib;
	WORD language;
	WORD extension;

	GNREASSERT(GetSubPictureStreamAttribute(num, attrib, language, extension));

	format.languageCode = language;
	format.languageExtension = extension;

	GNRAISE_OK;
	}

Error DVDVOBS::HasParentalIDs(BOOL & hasIDs)
	{
	WORD id;
	WORD i;

	hasIDs = FALSE;
	for(i=1; i<=8; i++)
		{
		GNREASSERT(GetParentalID(i, id));
		if (id)
			{
			hasIDs = TRUE;
			GNRAISE_OK;
			}
		}

	GNRAISE_OK;
	}

//////////////////////////////////////////////////////////////////////
//
//  Video Object Set for Manager Menu
//
//////////////////////////////////////////////////////////////////////

DVDMGMVOBS::DVDMGMVOBS(DVDHeaderFile * headerFile, DVDDataFile * dataFile, const DVDPTLMAI & ptlmai)
	: DVDVOBS(dataFile, ptlmai)
	{
	this->headerFile = headerFile;
	}

DVDMGMVOBS::~DVDMGMVOBS(void)
	{

	}

Error DVDMGMVOBS::GetVideoAttributes(WORD & attrib)
	{
	return headerFile->ReadWord(256, attrib, &rh);
	}

Error DVDMGMVOBS::GetNumberOfSubPictureStreams(WORD & num)
	{
	return headerFile->ReadWord(340, num, &rh);
	}

Error DVDMGMVOBS::GetSubPictureStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension)
	{
	GNREASSERT(headerFile->ReadWord(342 + 6 * num, attrib, &rh));
	GNREASSERT(headerFile->ReadWord(342 + 6 * num + 2, language, &rh));
	GNREASSERT(headerFile->ReadWord(342 + 6 * num + 4, extension, &rh));

	extension &= 0xff;

	GNRAISE_OK;
	}

Error DVDMGMVOBS::GetParentalID(WORD level, WORD & id)
	{
	return ptlmai.GetVMGId(level, id);
	}

//////////////////////////////////////////////////////////////////////
//
//  Video Title Set menu VOBS
//
//////////////////////////////////////////////////////////////////////

Error DVDVTSMVOBS::GetVideoAttributes(WORD & attrib)
	{
	return headerFile->ReadWord(256, attrib, &rh);
	}

Error DVDVTSMVOBS::GetNumberOfAudioStreams(WORD & num)
	{
	return headerFile->ReadWord(258, num, &rh);
	}

Error DVDVTSMVOBS::GetAudioStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension, WORD & applicationInfo)
	{
	GNREASSERT(headerFile->ReadWord(260 + 8 * num, attrib, &rh));

	//
	// language, extension, and applicationInfo are reserved according to the DVD specification.
	// So initialize them with initial values (MST, 03/07/01)
	//
	language = 0xffff;
	extension = 0x0000;
	applicationInfo = 0x0000;

	GNRAISE_OK;
	}

Error DVDVTSMVOBS::GetNumberOfSubPictureStreams(WORD & num)
	{
	return headerFile->ReadWord(340, num, &rh);
	}

Error DVDVTSMVOBS::GetSubPictureStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension)
	{
	GNREASSERT(headerFile->ReadWord(342 + 6 * num, attrib, &rh));
	GNREASSERT(headerFile->ReadWord(342 + 6 * num + 2, language, &rh));
	GNREASSERT(headerFile->ReadWord(342 + 6 * num + 4, extension, &rh));

	extension &= 0xff;

	GNRAISE_OK;
	}

Error DVDVTSMVOBS::GetParentalID(WORD level, WORD & id)
	{
	return ptlmai.GetVTSId(vtsn, level, id);
	}

//////////////////////////////////////////////////////////////////////
//
//  Video Title Set VOBS
//
//////////////////////////////////////////////////////////////////////

Error DVDVTSVOBS::GetVideoAttributes(WORD & attrib)
	{
	return headerFile->ReadWord(512, attrib, &rh);
	}

Error DVDVTSVOBS::GetNumberOfAudioStreams(WORD & num)
	{
	return headerFile->ReadWord(514, num, &rh);
	}

Error DVDVTSVOBS::GetAudioStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension, WORD & applicationInfo)
	{
	GNREASSERT(headerFile->ReadWord(516 + 8 * num, attrib, &rh));
	GNREASSERT(headerFile->ReadWord(516 + 8 * num + 2, language, &rh));
	GNREASSERT(headerFile->ReadWord(516 + 8 * num + 4, extension, &rh));
	GNREASSERT(headerFile->ReadWord(516 + 8 * num + 6, applicationInfo, &rh));

	extension &= 0xff;

	GNRAISE_OK;
	}

Error DVDVTSVOBS::GetNumberOfSubPictureStreams(WORD & num)
	{
	return headerFile->ReadWord(596, num, &rh);
	}

Error DVDVTSVOBS::GetSubPictureStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension)
	{
	GNREASSERT(headerFile->ReadWord(598 + 6 * num, attrib, &rh));
	GNREASSERT(headerFile->ReadWord(598 + 6 * num + 2, language, &rh));
	GNREASSERT(headerFile->ReadWord(598 + 6 * num + 4, extension, &rh));

	extension &= 0xff;

	GNRAISE_OK;
	}

Error DVDVTSVOBS::GetParentalID(WORD level, WORD & id)
	{
	return ptlmai.GetVTSId(vtsn, level, id);
	}

//////////////////////////////////////////////////////////////////////
//
//  DVD Audio Title Set Object Set for Audio Only Title
//
//////////////////////////////////////////////////////////////////////

Error DVDATSAOTTOBS::GetAudioStreamAttribute(int num)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDHliCtrl.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "DVDHliCtrl.h"
#include "Library/Common/vddebug.h"
#include "Library/lowlevel/timer.h"

//
//  Constructor
//

DVDHighlightControl::DVDHighlightControl(void)
	{
	buttonSelected = FALSE;
	highlightStarted = FALSE;
	buttonActivated = FALSE;
	presentationMode = DPM_4BY3;
	highlightActive = FALSE;
	numButtons = 0;
	}

//
//  Initialize
//

Error DVDHighlightControl::Init(DVDSPUDisplay * display, DVDNavigationProcessor * navpu)
	{
	this->display = display;
	this->navpu = navpu;
	GNRAISE_OK;
	}

//
//  Select a button
//

Error DVDHighlightControl::DoSelectButton(BOOL autoActivate)
	{
	ButtonInfo * b = buttons + selectedButton - 1;

	if (autoActivate && b->autoAction)
		return DoActivateButton();
	else
		{
		buttonSelected = TRUE;

		GNREASSERT(display->SetButtonColors(colors[b->colorGroup - 1].select, colors[b->colorGroup - 1].active));
		GNREASSERT(display->SetButtonPosition(buttonGroup, selectedButton, b->x, b->y, b->w, b->h));
		GNREASSERT(display->SetButtonSelect());

		GNRAISE_OK;
		}
	}

//
//  Activate button
//

Error DVDHighlightControl::DoActivateButton(void)
	{
	Error err;
	ButtonInfo * b = buttons + selectedButton - 1;
	int pc = 1;
	DVDNavigationProcessor::NavCommandDone done;
	WORD pml;

	buttonActivated = TRUE;

	GNREASSERT(display->SetButtonColors(colors[b->colorGroup - 1].select, colors[b->colorGroup - 1].active));
	GNREASSERT(display->SetButtonPosition(buttonGroup, selectedButton, b->x, b->y, b->w, b->h));
	GNREASSERT(display->SetButtonActive());

	Timer.WaitMilliSecs(300);

	err = navpu->InterpretCommand(b->com, pc, done, pml);

	if (err == GNR_NO_RESUME_INFORMATION)
		Exit(err);

	GNRAISE(err);
	}

//
//  Select button 'num' and activate it if necessary
//

Error DVDHighlightControl::SelectButton(WORD num, BOOL autoActivate)
	{
	if (num != selectedButton)
		{
		selectedButton = num;

		return DoSelectButton(autoActivate);
		}
	else
		GNRAISE_OK;
	}

//
//  Activate button 'num'
//

Error DVDHighlightControl::ActivateButton(WORD num)
	{
	selectedButton = num;

	return DoActivateButton();
	}

//
//  Complete highlight
//

Error DVDHighlightControl::CompleteHighlight(void)
	{
	if (buttonSelected && !buttonActivated && forcedActivateButton)
		{
		if (forcedActivateButton != 63)
			GNREASSERT(SelectButton(forcedActivateButton));

		GNREASSERT(DoActivateButton());
		}

	GNRAISE_OK;
	}

//
//  Test on valid highlight information for current display mode
//

static inline BOOL IsValidHLI(WORD flags, DisplayPresentationMode mode)
	{
	if      (mode == DPM_4BY3)        return flags == 0;
	else if (mode == DPM_16BY9)       return (flags & 1) != 0;
	else if (mode == DPM_LETTERBOXED) return (flags & 2) != 0;
	else if (mode == DPM_PANSCAN)     return (flags & 4) != 0;
	else return TRUE;
	}

Error DVDHighlightControl::CompleteHighlight(DVDVOBU * vobu)
	{
	int at;
	WORD w;
	DWORD startTime, stopTime, terminateTime, currentTime;

	//
	// Start with Highlight Status
	//

	at = 96;

	w = vobu->GetPCIWordSeq(at);

	startTime = vobu->GetPCIDWordSeq(at);
	stopTime = vobu->GetPCIDWordSeq(at);
	terminateTime = vobu->GetPCIDWordSeq(at);

	currentTime = vobu->GetPCIDWord(16);

	//DP("Complete Current %d Start %d Stop %d Terminate %d", currentTime / 90, startTime / 90, stopTime / 90, terminateTime / 90);

	if ((w & 3) != 0)
		{
		if (terminateTime != 0xffffffff && currentTime >= terminateTime)
			{
			CompleteHighlight();
			}
		}

	GNRAISE_OK;
	}
//
//  Start highlighting
//

Error DVDHighlightControl::StartHighlight(DVDVOBU * vobu)
	{
	int at, i;
	WORD w;
	DWORD d;
	WORD	buttonGroups, group;
	DWORD startTime, stopTime, terminateTime, currentTime;

	//
	// Start with Highlight Status
	//

	at = 96;

	w = vobu->GetPCIWordSeq(at);

	startTime = vobu->GetPCIDWordSeq(at);
	stopTime = vobu->GetPCIDWordSeq(at);
	terminateTime = vobu->GetPCIDWordSeq(at);

	currentTime = vobu->GetPCIDWord(12);

	//DP("Current %d Start %d Stop %d Terminate %d", currentTime / 90, startTime / 90, stopTime / 90, terminateTime / 90);

	if ((w & 3) == 2 && buttonSelected)
		{
		if (terminateTime != 0xffffffff && currentTime >= terminateTime)
			{
			CompleteHighlight();
			}

		highlightStarted = TRUE;
		GNRAISE_OK;  // HLI equal to previous VOBU
		}

	if (w & 3)  // if HLI exists
		{
		buttonSelected = FALSE;
		buttonActivated = FALSE;

		//
		// Read button mode => buttonGroups
		//

		w = vobu->GetPCIWordSeq(at);
		buttonGroups = XTBFW(12, 2, w);

		if (buttonGroups)
			{
			group = 0;
			while (group < buttonGroups && !IsValidHLI((WORD)XTBF(4 * (2 - group), 3, w), presentationMode)) group++;

			if (group >= buttonGroups)
				{
				group = 0;
				}

			buttonGroup = group + 1;

			userButtonOffset = vobu->GetPCIByteSeq(at);
			numButtons = vobu->GetPCIByteSeq(at);
			numUserButtons = vobu->GetPCIByteSeq(at);

			at+=1;  // Skip reserved

			//
			//  Read forcedly selected and activated buttons
			//

			w = vobu->GetPCIByteSeq(at);
			if (w) selectedButton = w;
			forcedActivateButton = vobu->GetPCIByteSeq(at);

			//
			// Read colors
			//

			for (i=0; i<3; i++)
				{
				colors[i].select = vobu->GetPCIDWordSeq(at);
				colors[i].active = vobu->GetPCIDWordSeq(at);
				}

			at += 18 * 36 / buttonGroups * group;

			//
			// Read button information
			//

			for (i=0; i<numButtons; i++)
				{
				ButtonInfo * b = buttons + i;

				d = vobu->GetPCIDWordSeq(at);
				b->colorGroup = (BYTE)XTBF(30, 2, d);
				b->x = (WORD)XTBF(20, 10, d);
				b->w = (WORD)XTBF( 8, 10, d) - b->x + 1;
				d = (d << 16) | vobu->GetPCIWordSeq(at);
				b->autoAction = XTBF(22, 2, d);
				b->y = (WORD)XTBF(12, 10, d);
				b->h = (WORD)XTBF( 0, 10, d) - b->y + 1;

//				DP("(%d, %d) - (%d, %d)", b->x, b->y, b->w, b->h);

				b->upper = vobu->GetPCIByteSeq(at) & 0x3f;
				b->lower = vobu->GetPCIByteSeq(at) & 0x3f;
				b->left = vobu->GetPCIByteSeq(at) & 0x3f;
				b->right = vobu->GetPCIByteSeq(at) & 0x3f;

				vobu->GetPCIBytesSeq(&(b->com), at, 8);
				}

			if (!selectedButton) selectedButton = 1;
			else if (selectedButton > numButtons) selectedButton = numButtons;

			GNREASSERT(DoSelectButton(FALSE));
			highlightActive = TRUE;
			}
		else
			GNREASSERT(CancelHighlight());
		}
	else
		{
		if (highlightStarted)
			{
			highlightStarted = FALSE;
			GNREASSERT(CompleteHighlight());
			}
		GNREASSERT(CancelHighlight());
		}

	GNRAISE_OK;
	}

//
//  Deselect and deactivate button
//

Error DVDHighlightControl::CancelHighlight(void)
	{
	buttonSelected = FALSE;
	buttonActivated = FALSE;
	highlightActive = FALSE;
	numButtons = 0;

	return display->SetButtonOff();
	}

//
//  Select upper button
//

Error DVDHighlightControl::ButtonUp(void)
	{
	if (buttonSelected)
		return SelectButton(buttons[selectedButton - 1].upper);
	else
		GNRAISE(GNR_BUTTON_NOT_FOUND);
	}

//
//  Select lower button
//

Error DVDHighlightControl::ButtonDown(void)
	{
	if (buttonSelected)
		{
		return SelectButton(buttons[selectedButton - 1].lower);
		}
	else
		GNRAISE(GNR_BUTTON_NOT_FOUND);
	}

//
//  Select left button
//

Error DVDHighlightControl::ButtonLeft(void)
	{
	if (buttonSelected)
		return SelectButton(buttons[selectedButton - 1].left);
	else
		GNRAISE(GNR_BUTTON_NOT_FOUND);
	}

//
//  Select right button
//

Error DVDHighlightControl::ButtonRight(void)
	{
	if (buttonSelected)
		return SelectButton(buttons[selectedButton - 1].right);
	else
		GNRAISE(GNR_BUTTON_NOT_FOUND);
	}

//
// ???
//

Error DVDHighlightControl::ButtonSet(WORD num)
	{
	if (buttonSelected && !buttonActivated)
		{
		return SelectButton(num);
		}
	else
		selectedButton = num;

	GNRAISE_OK;
	}

//
//  Select and activate button 'num'
//

Error DVDHighlightControl::ButtonSelectAndActivate(WORD num)
	{
	if (buttonSelected)
		{
		if (num - userButtonOffset >= 1 && num - userButtonOffset <= numUserButtons)
			return ActivateButton(num - userButtonOffset);
		else
			GNRAISE(GNR_RANGE_VIOLATION);
		}
	else
		GNRAISE_OK;
	}

//
//  Select and activate button at position (x, y)
//

Error DVDHighlightControl::ButtonSelectAtAndActivate(WORD x, WORD y)
	{
	WORD num;

//	DP("H (%d, %d)", x, y);

	if (buttonSelected)
		{
		for(num = 1; num <= numButtons; num++)
			{
			ButtonInfo * b = buttons + num - 1;

			if (x >= b->x && x < b->x + b->w && y >= b->y && y < b->y + b->h)
				return ActivateButton(num);
			}

		GNRAISE(GNR_RANGE_VIOLATION);
		}

	GNRAISE_OK;
	}

//
//  Select button at position (x, y)
//

Error DVDHighlightControl::ButtonSelectAt(WORD x, WORD y)
	{
	WORD num;

//	DP("H (%d, %d)", x, y);

	if (buttonSelected)
		{
		for(num = 1; num <= numButtons; num++)
			{
			ButtonInfo * b = buttons + num - 1;

			//
			// prevents selection of buttons in "Die Apothekerin" that causes
			// the menue to be non responsive to keyboard movement
			//
			if (x >= b->x && x < b->x + b->w && y >= b->y && y < b->y + b->h)
				{
				if (b->left == num && b->right == num && b->upper == num && b->lower == num)
					GNRAISE_OK;
				else
					return SelectButton(num, FALSE);
				}
			}

		GNRAISE(GNR_RANGE_VIOLATION);
		}

	GNRAISE_OK;
	}

//
//  Activate currently selected button
//

Error DVDHighlightControl::ButtonActivate(void)
	{
	if (buttonSelected)
		return DoActivateButton();
	else
		GNRAISE_OK;
	}

//
//  Check if there is a button at position (x, y)
//

BOOL DVDHighlightControl::IsButtonAt(WORD x, WORD y)
	{
	int num;

	if (buttonSelected)
		{
		for(num = 1; num <= numButtons; num++)
			{
			ButtonInfo * b = buttons + num - 1;

			if (x >= b->x && x < b->x + b->w && y >= b->y && y < b->y + b->h)
				return TRUE;
			}
		}

	return FALSE;
	}

//
//  Returns of we currently have positional buttons
//

BOOL DVDHighlightControl::HasPositionalButtons(void)
	{
	return buttonSelected != 0;
	}

//
//  Get the state of the currently selected button
//

Error DVDHighlightControl::GetCurrentButtonState(WORD & minButton, WORD & numButtons, WORD & currentButton)
	{
	if (buttonSelected)
		{
		minButton = 1;
		numButtons = numButtons;
		currentButton = selectedButton;
		}
	else
		{
		minButton = 0;
		numButtons = 0;
		currentButton = 0xffff;
		}

	GNRAISE_OK;
	}

//
//  Save current state
//

Error DVDHighlightControl::Freeze(DVDHCFreezeState & state)
	{
	//
	// Copy data into buffer
	//

	state.selectedButton = selectedButton;
	state.highlightActive = highlightActive;

	GNRAISE_OK;
	}

//
//  Return to previously saved state
//

Error DVDHighlightControl::Defrost(DVDHCFreezeState & state)
	{
	//
	// Restore data
	//

	selectedButton = state.selectedButton;
	highlightActive = state.highlightActive;

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDFile.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD File Classes
//
////////////////////////////////////////////////////////////////////

#ifndef DVDFILE_H
#define DVDFILE_H

class DVDFile;
class DVDChainFile;
class DVDFileSystem;

#include "Library/Files/RootFile.h"
#include "Library/Files/CDVDVolume.h"
#include "EventSender.h"

//////////////////////////////////////////////////////////////////////
//
//  DVD Header File Class
//
//////////////////////////////////////////////////////////////////////

class DVDHeaderFile : public GenericFile, public EventSender
	{
	friend class DVDFileSystem;

	protected:
		GenericFileSystem * baseFS;
		GenericFile * file;

		virtual Error BuildUniqueKey(void);

		DVDHeaderFile(DVDFileSystem * dvdfs, GenericFileSystem * baseFS, EventDispatcher* pEventDispatcher);

	public:
		virtual ~DVDHeaderFile(void);

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accessType);
		virtual Error Close(void);

		//
		//  Misc. inquiry
		//

		virtual Error GetCopyManagementInfo(GenericCopyManagementInfo & gcmi);
		virtual Error GetName(DiskItemName & name);
		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetSize(KernelInt64 & size);
		virtual Error GetIterator(GenericFileSystemIterator * & gfsi);

		//
		//  Access functions
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);

		Error ReadByte(DWORD position, BYTE & b, RequestHandle * rh);
		Error ReadWord(DWORD position, WORD & w, RequestHandle * rh);
		Error ReadDWord(DWORD position, DWORD & d, RequestHandle * rh);

		Error ReadByteSeq(DWORD & position, BYTE & b, RequestHandle * rh);
		Error ReadWordSeq(DWORD & position, WORD & w, RequestHandle * rh);
		Error ReadDWordSeq(DWORD & position, DWORD & d, RequestHandle * rh);

		//
		//  Misc.
		//

		virtual Error Flush(void);
		virtual Error TerminateRequest(RequestHandle * rh);

		//
		//  DVD specific functions
		//

		Error	IsEncrypted(BOOL & enc);
		Error DoAuthenticationCommand(DVDAuthenticationCommand com, BYTE * key);
	};

//////////////////////////////////////////////////////////////////////
//
//  DVD Data File Class
//
//////////////////////////////////////////////////////////////////////

class ChainFileNode;

class DVDDataFile : public GenericFile, public EventSender
	{
	friend class DVDFileSystem;

	protected:
		GenericFileSystem * baseFS;

		List files;

		KernelInt64 size;
		DWORD headerSize;
		DWORD dataSize;
		DWORD	nextBlock;
		DWORD	fileOffset;		// Offset in blocks in the file
		DWORD	firstEncryptedBlock;
		DWORD	secondEncryptedBlock;

		//
		//  Cache for accessing a chained file
		//

		struct
			{
			ChainFileNode * node;
			DWORD relativeStartBlock;
			} lastFile;

		//
		//  Specific functions
		//

		Error FindVOBStart(void);
		Error FindNextEncryptedBlock(DWORD & block);
		Error FindFirstEncryptedBlock(void);
		Error AppendFile(GenericFileSystemIterator * gfsi, DWORD accessType);
		Error RemoveFiles(void);

		//
		//  Internal helper functions
		//

		virtual Error BuildUniqueKey(void);
		void SetFileOffset(DWORD offset) { fileOffset = offset; }
		Error GetFile(DWORD block, GenericFile * & file);
		Error GetFile(DWORD block, DWORD num, GenericFile * & file, DWORD & relativeStart, DWORD & avail);

		DVDDataFile(DVDFileSystem * dvdfs, GenericFileSystem * baseFS, EventDispatcher* pEventDispatcher);

	public:
		~DVDDataFile(void);

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accesType);
		virtual Error Close(void);

		//
		//  Misc. inquiry
		//

		virtual Error GetCopyManagementInfo(GenericCopyManagementInfo & gcmi);
		virtual Error GetName(DiskItemName & name);
		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetSize(KernelInt64 & size);
		virtual Error GetIterator(GenericFileSystemIterator * & gfsi);

		//
		//  Access functions
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);

		virtual Error ReadByte(KernelInt64 position, BYTE & b, RequestHandle * rh);

		//
		//  Misc.
		//

		virtual Error Flush(void);
		virtual Error TerminateRequest(RequestHandle * rh);

		//
		//  DVD specific functions
		//

		Error IsEncrypted(BOOL & enc);
		Error DoAuthenticationCommand(DVDAuthenticationCommand com, DWORD & sector, BYTE * key, int retry);
	};

////////////////////////////////////////////////////////////////////
//
//  DVD Iterator Class
//
////////////////////////////////////////////////////////////////////

class DVDIterator : public GenericFileSystemIterator
	{
	friend class DVDFileSystem;

	protected:
		GenericFileSystemIterator * gfsi;

		DVDIterator(DVDFileSystem * gfs, GenericFileSystemIterator * gfsi);

		virtual BOOL Equals(GenericFileSystemIterator * gfsi);

	public:
		virtual ~DVDIterator(void);

		virtual Error Clone(GenericFileSystemIterator * & gfsi) const;
		virtual Error Clone(DVDIterator * & dvdi) const;

		//
		//  Directory Handling
		//

		virtual Error GoToFirstItem(void);
		virtual Error GoToNextItem(void);
		virtual Error GoToSubDir(GenericFileSystemIterator * & gfsi);
		virtual Error GoToParentDir(GenericFileSystemIterator * & gfsi);

		//
		//  Inquiry
		//

		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetItemType(DiskItemType & type);
		virtual Error GetItemName(DiskItemName & name);
		virtual Error GetItemSize(KernelInt64 & size);
		virtual Error GetNumberOfItems(DWORD & num);
		virtual Error GetCurrentDir(GenericDirectory * & gd);
//		virtual Error GetFileSystem(GenericFileSystem * & gfs);

		//
		//  File Access
		//

		virtual Error OpenItem(DWORD accessType, GenericDiskItem * & gdi);
	};

////////////////////////////////////////////////////////////////////
//
//  DVD File System Class
//
////////////////////////////////////////////////////////////////////

class DVDFileSystem : public GenericFileSystem, public EventSender
	{
	friend class DVDFile;
	friend class DVDHeaderFile;
	friend class DVDDataFile;

	protected:
		GenericFileSystem * baseFS;
		CDVDVolume * cdvdVolume;

		//
		//  Factory methods
		//

		virtual Error CreateFile(DWORD flags, GenericFile * & gf);
		virtual Error CreateDirectory(DWORD flags, GenericDirectory * & gd);

		//
		//  Data Access Methods
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);

		//
		//  Internal functions
		//

		Error DoAuthenticationCommand(DVDAuthenticationCommand com, DWORD block, BYTE * key);
		Error GetCopyManagementInfo(DWORD block, GenericCopyManagementInfo & gcmi);
		Error OpenFile(DVDFile * file, GenericFileSystemIterator * gfsi, DWORD accessType);
		virtual Error BuildUniqueKey(void);

	public:
		DVDFileSystem(EventDispatcher* pEventDispatcher);
		virtual ~DVDFileSystem(void);

		virtual Error Init(GenericFileSystemIterator * mountPoint, GenericVolume * volume, GenericProfile * profile);

		//
		//  Item handling
		//

		virtual Error OpenItem(GenericFileSystemIterator * gfsi, DWORD accessType, GenericDiskItem * & gdi);
		virtual Error OpenItem(const DiskItemName & name, DWORD accessType, GenericDiskItem * & gdi);

		//
		//  Factory Methods
		//

		virtual Error CreateIterator(GenericFileSystemIterator * & gfsi);

		//
		//  Volume Information
		//

		virtual Error GetVolumeName(KernelString & name);
		virtual Error GetVolumeSetName(KernelString & name);
		virtual Error GetVolumeSetIndex(int & index);
		virtual Error GetVolumeSetSize(int & size);

		//
		//  Drive "Pass Through" Functions
		//

		virtual Error SetDriveBlockSize(DWORD size);

		virtual Error GetNumberOfDriveBlocks(DWORD & num);
		virtual Error SetNumberOfDriveBlocks(DWORD num);

		virtual Error TerminateRequest(RequestHandle * rh);
		virtual Error Flush(void);

		virtual Error GetDriveName(KernelString & name);

		//
		//  DVD specific functions
		//

		virtual Error DVDIsEncrypted(BOOL & enc);
		virtual Error GetRPCData(BOOL & isRPC2, BYTE & region, BYTE & availSets);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDHeader.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD Header File Information
//
////////////////////////////////////////////////////////////////////

#ifndef DVDHEADER_H
#define DVDHEADER_H

class DVDGenericPGCI;
class DVDGenericCPBI;

#include "DVDFile.h"
#include "DVDNavpu.h"
#include "DVDTime.h"
#include "Config/DiskPlayerFactory.h"

////////////////////////////////////////////////////////////////////
//
//  Cell Playback Information
//
////////////////////////////////////////////////////////////////////

enum CellBlockMode
	{
	CBM_NOT_A_CELL_IN_BLOCK,
	CBM_FIRST_CELL_IN_BLOCK,
	CBM_CELL_IN_BLOCK,
	CBM_LAST_CELL_IN_BLOCK
	};

enum CellBlockType
	{
	CBT_NOT_IN_BLOCK,
	CBT_ANGLE_BLOCK
	};

////////////////////////////////////////////////////////////////////
//
//  Cell Component Information used for Cell Playback Information
//	 for Audio Only Titles
//
////////////////////////////////////////////////////////////////////

enum CellComponent
	{
	AUDIO_ONLY,
	AUDIO_AND_RTI,
	AUDIO_SILENCE
	};

///////////////////////////////////////////////////////////////////////
//
//  Cell Playback Information
//
//	 Description:
//		The class Cell Playback Information describes information
//		necessary to play cells.
//		The DVDCPBI represents two types of Cell Playback Information:
//		AMGM_C_PBI (for Audio Manager Menu) and VTS_C_PBI (for DVD-Video).
//		They differ from each other a little bit. The advantage for
//		merging them together is that we only have one Cell Playback
//		Information that can be allocated statically instead of
//		dynamically.
//
///////////////////////////////////////////////////////////////////////

class DVDCPBI
	{
	protected:
		DWORD		cat;
		DWORD		pbtm;
		DWORD		fvobu_sa;
		DWORD		filvu_ea;
		DWORD		lvobu_sa;
		DWORD		lvobu_ea;
	public:
		DVDCPBI(void);
		~DVDCPBI(void);

		Error Init(DVDHeaderFile * file, DWORD start);

		CellBlockMode BlockMode(void) {return (CellBlockMode)XTBF(30, 2, cat);}
		CellBlockType BlockType(void) {return (CellBlockType)XTBF(28, 2, cat);}
		BOOL Seamless(void) {return XTBF(27, cat);}
		BOOL Interleaved(void) {return XTBF(26, cat);}
		BOOL STCDiscontinuity(void) {return XTBF(25, cat);}
		BOOL SeamlessAngleChange(void) {return XTBF(24, cat);}
		BOOL ContinuousPresentation(void) {return XTBF(22, cat);}
		BOOL AccessRestricted(void) {return XTBF(21, cat);}
		WORD StillTime(void) {return (WORD)XTBF(8, 8, cat);}
		WORD CommandNumber(void) {return (WORD)XTBF(0, 8, cat);}

		DVDTime PresentationTime(void) {return DVDTime(pbtm);}

		DWORD FirstVOBUStart(void) {return fvobu_sa;}
		DWORD FirstILVUEnd(void) {return filvu_ea;}
		DWORD LastVOBUStart(void) {return lvobu_sa;}
		DWORD LastVOBUEnd(void) {return lvobu_ea;}
	};

////////////////////////////////////////////////////////////////////
//
//  Cell Playback Information for Audio Manager Menu
//
//	 Description:
//		Describes the presentation order of Cells in an AMGM_PGC.
//		Use this for Audio Manager Menu.
//
////////////////////////////////////////////////////////////////////

class DVDAMGMCPBI
	{
	protected:
		DWORD		cat;
		DWORD		pbtm;
		DWORD		fvobu_sa;
		DWORD		lvobu_sa;
		DWORD		lvobu_ea;
	public:
		DVDAMGMCPBI(void);
		~DVDAMGMCPBI(void);

		Error Init(DVDHeaderFile * file, DWORD start);

		CellBlockMode BlockMode(void) {return CBM_NOT_A_CELL_IN_BLOCK;}
		CellBlockType BlockType(void) {return CBT_NOT_IN_BLOCK;}
		BOOL Seamless(void) {return XTBF(27, cat);}
		BOOL Interleaved(void) {return FALSE;}
		BOOL STCDiscontinuity(void) {return XTBF(25, cat);}
		BOOL SeamlessAngleChange(void) {return FALSE;}
		BOOL ContinuousPresentation(void) {return TRUE;}
		BOOL AccessRestricted(void) {return FALSE;}
		WORD StillTime(void) {return (WORD)XTBF(8, 8, cat);}
		WORD CommandNumber(void) {return (WORD)XTBF(0, 8, cat);}

		DVDTime PresentationTime(void) {return DVDTime(pbtm);}

		DWORD FirstVOBUStart(void) {return fvobu_sa;}
		DWORD FirstILVUEnd(void) {return 0;}
		DWORD LastVOBUStart(void) {return lvobu_sa;}
		DWORD LastVOBUEnd(void) {return lvobu_ea;}
	};

////////////////////////////////////////////////////////////////////
//
//  Cell Playback Information for Audio Only Title
//
//	 Description:
//		Describes the presentation order of Cells in an ATS_PGC.
//		NOTE: The DVDATSCPBI is only used when this ATS has an
//				AOTT_AOBS, otherwise Video-Cell is defined as ATS_C.
//				And the Video-Cell is the same as DVDCPBI.
//
////////////////////////////////////////////////////////////////////

class DVDATSCPBI
	{
	protected:
		BYTE	ats_ixn;
		BYTE	ats_ty;
		DWORD ats_sa;
		DWORD ats_ea;
	public:
		DVDATSCPBI(void);
		virtual ~DVDATSCPBI(void);

		Error Init(DVDHeaderFile * file, DWORD start);

		BYTE IndexNumber(void) {return ats_ixn;}
		CellComponent Component(void) {return (CellComponent)XTBFB(6, 2, ats_ty);}
		BOOL Spotlight(void) {return (XTBFB(0, 4, ats_ty) == 1);}
		DWORD ATSStart(void) {return ats_sa;}
		DWORD ATSEnd(void) {return ats_ea;}
	};

////////////////////////////////////////////////////////////////////
//
//  Generic Program Chain Information Class
//
//	 Description:
//		The Generic Program Chain Information Class serves as an
//		abstract class as well for the Program Chain Information
//		Class as for the Audio Title Set Program Chain Information
//		Class. Common code is implemented here.
//
////////////////////////////////////////////////////////////////////

class DVDGenericPGCI
	{
	protected:
		DVDDiskPlayerFactory *	factory;
		DVDHeaderFile			*	file;
		RequestHandle				rh;
		DWORD							start;

	public:
		DVDGenericPGCI(DVDDiskPlayerFactory * factory);
		virtual ~DVDGenericPGCI(void);

		virtual Error Init(DVDHeaderFile * file, DWORD start) = 0;
		virtual DWORD GetID(void) {return start;}
		virtual Error GetNumberOfPrograms(WORD & num);
		virtual Error GetNumberOfCells(WORD & num);

		virtual Error GetPresentationTime(DVDTime & time) = 0;

		virtual Error GetUserOperations(DWORD & uops) = 0;
		virtual Error GetAudioStreamControl(int num, WORD & asc) = 0;
		virtual Error GetSubPictureStreamControl(int num, DWORD & spsc) = 0;

		virtual Error GetNextProgramChain(WORD & next) = 0;
		virtual Error GetPreviousProgramChain(WORD & prev) = 0;
		virtual Error GetUpperProgramChain(WORD & upper) = 0;

		virtual Error GetPlaybackMode(BYTE & mode) = 0;
		virtual Error GetStillTimeValue(BYTE & stillTime) = 0;

		virtual Error GetSubPicturePalette(int entry, DWORD & palette) = 0;

		virtual Error GetPreCommands(int & num,  DVDNavigationCommand * & cmds) = 0;
		virtual Error GetPostCommands(int & num, DVDNavigationCommand * & cmds) = 0;
		virtual Error GetCellCommands(DVDNavigationCommand * & cmds) = 0;

		virtual Error GetCellInformation(int cell, DVDCPBI & cpbi) = 0;
		virtual Error GetATSCellInformation(int cell, DVDATSCPBI & atscpbi) = 0;
		virtual Error GetFirstCellOfProgram(int program, WORD & first) = 0;
		virtual Error GetLastCellOfProgram(int program, WORD & last) = 0;
		virtual Error GetProgramOfCell(int cell, WORD & prog) = 0;
		virtual Error GetNumberOfCellsInProgram(int program, WORD & num) = 0;
	};

////////////////////////////////////////////////////////////////////
//
//  Program Chain Information Table
//
////////////////////////////////////////////////////////////////////

enum PGCBlockMode
	{
	PBM_NOT_A_PGC_IN_BLOCK,
	PBM_FIRST_PGC_IN_BLOCK,
	PBM_PGC_IN_BLOCK,
	PBM_LAST_PGC_IN_BLOCK
	};

enum PGCBlockType
	{
	PBT_NOT_IN_BLOCK,
	PBT_PARENTAL_BLOCK,
	PBT_AUDIO_CHANNELS_DIFF,
	PBT_AUDIO_COD_CHN_DIFF,
	PBT_AUDIO_CODING_DIFF
	};

//////////////////////////////////////////////////////////////////////
//
//  Part Of Title Class
//
//////////////////////////////////////////////////////////////////////

class DVDPTT
	{
	protected:
		DVDHeaderFile	*	file;
		RequestHandle		rh;
		DWORD					start;

	public:
		DVDPTT(DVDHeaderFile * file, DWORD start) {this->file = file; this->start = start;}
		DVDPTT(void) {file = NULL; start = 0;}

		Error GetNumberOfTitleUnits(WORD & num);
		Error GetNumberOfPartOfTitle(WORD unit, WORD & num);
		Error GetPartOfTitlePGC(WORD unit, WORD ptt, WORD & pgc, WORD & pg);
		Error GetPartAndTitle(WORD pgcn, WORD pgn, WORD title, WORD & ptt);
		Error GetPartOfTitle(WORD title, WORD pgcn, WORD pg, WORD & ptt);
	};

//////////////////////////////////////////////////////////////////////
//
//  Title Search Pointer Table (in VMGI)
//
//////////////////////////////////////////////////////////////////////

class DVDSRPT
	{
	protected:
		DVDHeaderFile	*	file;
		RequestHandle		rh;
		DWORD					start;

	public:
		DVDSRPT(void) { file = NULL; start = 0; }
		DVDSRPT(DVDHeaderFile * file, DWORD start) {this->file = file; this->start = start;}
		DVDSRPT(const DVDSRPT & srpt) { file = srpt.file; start = srpt.start; }
		virtual ~DVDSRPT(void) {}

		virtual Error GetNumberOfTitles(WORD & num);
		virtual Error GetNumberOfPartOfTitle(WORD title, WORD & num) = 0;
		virtual Error GetNumberOfAngles(WORD title, WORD & num) = 0;
		virtual Error GetUOPS(WORD title, DWORD & uops) = 0;

		virtual Error GetTitle(WORD title, WORD & tsn, WORD & ttn) = 0;
		virtual Error GetTitleOfTSTitle(WORD tsn, WORD tsTitle, WORD & title) = 0;

		virtual Error IsOneSequentialPGCTitle(WORD title, BOOL & iospt) = 0;
	};

//////////////////////////////////////////////////////////////////////
//
//  Parental Management Information
//
//////////////////////////////////////////////////////////////////////

class DVDPTLMAI
	{
	protected:
		DVDHeaderFile	*	file;
		RequestHandle		rh;
		DWORD					start;
		WORD					numVTS;

	public:
		DVDPTLMAI(void) {file = NULL; start = 0; numVTS = 0;}
		DVDPTLMAI(DVDHeaderFile * file, DWORD start, WORD numVTS) {this->file = file; this->start = start; this->numVTS = numVTS;}
		DVDPTLMAI(const DVDPTLMAI & ptlmai) {file = ptlmai.file; start = ptlmai.start; numVTS = ptlmai.numVTS;}

		Error GetVMGId(WORD level, WORD & id);
		Error GetVTSId(WORD vtsn, WORD level, WORD & id);
	};

class DVDPTLMAIT
	{
	protected:
		DVDHeaderFile	*	file;
		RequestHandle		rh;
		DWORD					start;

		Error GetNumberOfVTS(WORD & num);
		Error GetNumberOfCountries(WORD & num);

		Error GetCountryCode(WORD entry, WORD & cc);

	public:
		DVDPTLMAIT(DVDHeaderFile * file, DWORD start) {this->file = file; this->start = start;}

		Error GetPTLMAI(WORD countryCode, DVDPTLMAI & ptlmai);
	};

//////////////////////////////////////////////////////////////////////
//
//  Object Set Abstract Base Class
//
//	 Description:
//		Serves as an abstract base class for DVD Video Object Set
//		and DVD Audio Object Set.
//
//////////////////////////////////////////////////////////////////////

class DVDOBS
	{
	protected:
		DVDDataFile *	dataFile;
		RequestHandle	rh;
		static DWORD	uniqueKeys;

	public:
		const DWORD		uniqueKey;

		DVDOBS(DVDDataFile * dataFile) : uniqueKey(++uniqueKeys) {this->dataFile = dataFile;}

		virtual Error GetVideoAttributes(WORD & attrib) = 0;
		virtual Error GetVideoAttributes(VideoStreamFormat & videoStream) = 0;

		virtual Error GetNumberOfAudioStreams(WORD & num) = 0;
		virtual Error GetAudioStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension, WORD & applicationInfo) = 0;

		virtual Error GetAudioStreamAttributes(int num, DVDAudioStreamFormat & format) = 0;

		virtual Error GetNumberOfSubPictureStreams(WORD & num) = 0;
		virtual Error GetSubPictureStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension) = 0;

		virtual Error GetSubPictureStreamAttributes(int num, DVDSubPictureStreamFormat & format) = 0;

		virtual Error GetParentalID(WORD level, WORD & id) = 0;
		virtual Error HasParentalIDs(BOOL & hasIDs) = 0;

		Error GetDataFile(DVDDataFile * & file) { file = dataFile; GNRAISE_OK; }
	};

//////////////////////////////////////////////////////////////////////
//
//  Video Object Set Abstract Base Class
//
//	 Description:
//		The DVD Video Object Set Class is an abstract class that
//		describes a collection of VOBs. Three types exist according
//		to the attribution of VOB: VMGM_VOBS, VTSM_VOBS, and VTS_VOBS.
//
//////////////////////////////////////////////////////////////////////

class DVDVOBS : public DVDOBS
	{
	protected:
		DVDPTLMAI		ptlmai;

	public:
		DVDVOBS(DVDDataFile * dataFile, const DVDPTLMAI & ptlmai) : DVDOBS(dataFile) {this->ptlmai = ptlmai;}

		virtual Error GetVideoAttributes(WORD & attrib) {GNRAISE_OK;}
		Error GetVideoAttributes(VideoStreamFormat & videoStream);

		virtual Error GetNumberOfAudioStreams(WORD & num) {GNRAISE_OK;}
		virtual Error GetAudioStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension, WORD & applicationInfo) {GNRAISE_OK;}

		Error GetAudioStreamAttributes(int num, DVDAudioStreamFormat & format);

		virtual Error GetNumberOfSubPictureStreams(WORD & num) {GNRAISE_OK;}
		virtual Error GetSubPictureStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension) {GNRAISE_OK;}

		Error GetSubPictureStreamAttributes(int num, DVDSubPictureStreamFormat & format);

		virtual Error GetParentalID(WORD level, WORD & id) {GNRAISE_OK;}
		Error HasParentalIDs(BOOL & hasIDs);
	};

//////////////////////////////////////////////////////////////////////
//
//  Audio Object Set Abstract Base Class
//
//	 Description:
//		The Audio Object Set Class is an abstract class describing
//		an Audio Object Set. An Audio Object Set (AOBS) is a collection
//		of Audio Objects. An Audio Object (AOB) is the presentation
//		data to be used only for AOTT.
//
//////////////////////////////////////////////////////////////////////

class DVDAOBS : public DVDOBS
	{
	public:
		DVDAOBS(DVDDataFile * dataFile) : DVDOBS(dataFile) {}

		virtual Error GetVideoAttributes(WORD & attrib) {attrib = 0; GNRAISE_OK;}
		virtual Error GetVideoAttributes(VideoStreamFormat & videoStream) {GNRAISE_OK;}

		virtual Error GetNumberOfAudioStreams(WORD & num) {num = 0; GNRAISE_OK;}
		virtual Error GetAudioStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension, WORD & applicationInfo)
			{
			attrib = language = extension = applicationInfo = 0;
			GNRAISE_OK;
			}

		virtual Error GetAudioStreamAttributes(int num, DVDAudioStreamFormat & format) {GNRAISE_OK;}

		virtual Error GetNumberOfSubPictureStreams(WORD & num) {num = 0; GNRAISE_OK;}
		virtual Error GetSubPictureStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension)
			{
			attrib = language = extension = 0;
			GNRAISE_OK;
			}

		virtual Error GetSubPictureStreamAttributes(int num, DVDSubPictureStreamFormat & format) {GNRAISE_OK;}

		virtual Error GetParentalID(WORD level, WORD & id) {GNRAISE_OK;}
		virtual Error HasParentalIDs(BOOL & hasIDs) { hasIDs = FALSE; GNRAISE_OK; }
	};

//////////////////////////////////////////////////////////////////////
//
//  Video Object Set for Manager Menu
//
//	 Description:
//		Video Object Set for Video Manager Menu is an abstract class
//		for DVDVMGMVOBS and DVDAMGMVOBS.
//
//////////////////////////////////////////////////////////////////////

class DVDMGMVOBS : public DVDVOBS
	{
	protected:
		DVDHeaderFile	*	headerFile;

	public:
		DVDMGMVOBS(DVDHeaderFile * headerFile, DVDDataFile * dataFile, const DVDPTLMAI & ptlmai);
		virtual ~DVDMGMVOBS(void);

		virtual Error GetVideoAttributes(WORD & attrib);

		virtual Error GetNumberOfAudioStreams(WORD & num) {GNRAISE_OK;}
		virtual Error GetAudioStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension, WORD & applicationInfo) {GNRAISE_OK;}

		virtual Error GetNumberOfSubPictureStreams(WORD & num);
		virtual Error GetSubPictureStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension);

		virtual Error GetParentalID(WORD level, WORD & id);
	};

//////////////////////////////////////////////////////////////////////
//
//  DVD Video Title Set Menu VOBS
//
//////////////////////////////////////////////////////////////////////

class DVDVTSMVOBS : public DVDVOBS
	{
	protected:
		DVDHeaderFile	*	headerFile;
		WORD					vtsn;

	public:
		DVDVTSMVOBS(DVDHeaderFile * headerFile, const DVDPTLMAI & ptlmai, DVDDataFile * dataFile, WORD vtsn)
			: DVDVOBS(dataFile, ptlmai) {this->headerFile = headerFile; this->vtsn = vtsn;}

		virtual Error	GetVideoAttributes(WORD & attrib);

		virtual Error	GetNumberOfAudioStreams(WORD & num);
		virtual Error	GetAudioStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension, WORD & applicationInfo);

		virtual Error	GetNumberOfSubPictureStreams(WORD & num);
		virtual Error	GetSubPictureStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension);

		virtual Error	GetParentalID(WORD level, WORD & id);
	};

//////////////////////////////////////////////////////////////////////
//
//  DVD Video Title Set VOBS
//
//////////////////////////////////////////////////////////////////////

class DVDVTSVOBS : public DVDVOBS
	{
	protected:
		DVDHeaderFile	*	headerFile;
		WORD					vtsn;

	public:
		DVDVTSVOBS(DVDHeaderFile * headerFile, const DVDPTLMAI & ptlmai, DVDDataFile * dataFile, WORD vtsn)
			: DVDVOBS(dataFile, ptlmai) {this->headerFile = headerFile; this->vtsn = vtsn;}

		virtual Error	GetVideoAttributes(WORD & attrib);

		virtual Error	GetNumberOfAudioStreams(WORD & num);
		virtual Error GetAudioStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension, WORD & applicationInfo);

		virtual Error	GetNumberOfSubPictureStreams(WORD & num);
		virtual Error	GetSubPictureStreamAttribute(int num, WORD & attrib, WORD & language, WORD & extension);

		virtual Error	GetParentalID(WORD level, WORD & id);
	};

//////////////////////////////////////////////////////////////////////
//
//  DVD Audio Title Set Object Set for Audio Only Title
//
//	 Description:
//		When this ATS has an AOTT_AOBS, describes the attributes for
//		AOTT_AOB, else describes the attributes of each Audio stream
//		in the VOB which is used for AOTT_VOB.
//
//////////////////////////////////////////////////////////////////////

class DVDATSAOTTOBS : public DVDAOBS
	{
	protected:
		DVDHeaderFile	*	headerFile;

	public:
		DVDATSAOTTOBS(DVDHeaderFile * headerFile, DVDDataFile * dataFile)
			: DVDAOBS(dataFile) { this->headerFile = headerFile; }

		virtual Error GetAudioStreamAttribute(int num);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDHliCtrl.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
//  Sub Picture and Highlight Module
//
//////////////////////////////////////////////////////////////////////

#ifndef DVDHLICL_H
#define DVDHLICL_H

#include "DVDStreamServer.h"
#include "DVDNavpu.h"

//////////////////////////////////////////////////////////////////////
//
//  Sub Picture Unit
//
//////////////////////////////////////////////////////////////////////

class DVDSPUDisplay
	{
	public:
		virtual Error SetButtonColors(DWORD select, DWORD active) = 0;
		virtual Error SetButtonPosition(WORD group, WORD button, WORD x, WORD y, WORD w, WORD h) = 0;
		virtual Error SetButtonOff(void) = 0;
		virtual Error SetButtonSelect(void) = 0;
		virtual Error SetButtonActive(void) = 0;
	};

//////////////////////////////////////////////////////////////////////
//
//  Highlight Control
//
//////////////////////////////////////////////////////////////////////

class DVDHighlightControl
	{
	protected:
		BOOL	buttonSelected;
		BOOL	highlightStarted;
		BOOL	buttonActivated;
		BOOL	highlightActive;

		WORD 	userButtonOffset;
		WORD  numButtons;
		WORD	numUserButtons;
		WORD	selectedButton;
		WORD	forcedActivateButton;
		WORD	buttonGroup;				// Current button group

		DisplayPresentationMode	presentationMode;

		struct ButtonColors
			{
			DWORD select, active;
			} colors[3];

		struct ButtonInfo
			{
			BYTE						colorGroup;
			WORD						x, y, w, h;
			BOOL						autoAction;
			BYTE						upper, lower, left, right;
			DVDNavigationCommand com;
			} buttons[36];

		DVDSPUDisplay 				*	display;
		DVDNavigationProcessor	*	navpu;

		Error DoSelectButton(BOOL autoActivate = TRUE);
		virtual Error DoActivateButton(void);
		Error SelectButton(WORD num, BOOL autoActivate = TRUE);
		Error ActivateButton(WORD num);

		//
		//  Freezing stuff
		//

		class DVDHCFreezeState
			{
			public:
				WORD	selectedButton;
				BOOL	highlightActive;
			};

		Error Freeze (DVDHCFreezeState & state);
		Error Defrost(DVDHCFreezeState & state);

		//
		//  Inquiry methods
		//

		void GetButtonInfo(int button, WORD & x, WORD & y, WORD & w, WORD & h,
												 BYTE & upper, BYTE & lower, BYTE & left, BYTE & right, BOOL autoAction)
			{
			x = buttons[button].x; y = buttons[button].y; w = buttons[button].w; h = buttons[button].h;
			upper = buttons[button].upper; lower = buttons[button].lower; left = buttons[button].left; right = buttons[button].right;
			autoAction = buttons[button].autoAction;
			}

		void GetButtonGeneralInfo(WORD & numberOfButtons, WORD & selectedButton, WORD & forcedlyActivatedButton,
										  WORD & userButtonOffset, WORD & numberOfUserButtons)
			{
			numberOfButtons = numButtons; selectedButton = this->selectedButton; forcedlyActivatedButton = forcedActivateButton;
			userButtonOffset = this->userButtonOffset; numberOfUserButtons = numUserButtons;
			}

	public:
		DVDHighlightControl(void);

		Error Init(DVDSPUDisplay * display, DVDNavigationProcessor * navpu);
		virtual Error SetPresentationMode(DisplayPresentationMode mode) {presentationMode = mode; GNRAISE_OK;}

		Error StartHighlight(DVDVOBU * vobu);
		Error CompleteHighlight(DVDVOBU * vobu);
		Error CompleteHighlight(void);

		Error CancelHighlight(void);

		Error ButtonUp(void);
		Error ButtonDown(void);
		Error ButtonLeft(void);
		Error ButtonRight(void);
		Error ButtonSet(WORD num);
		Error ButtonSelectAt(WORD x, WORD y);

		Error ButtonSelectAndActivate(WORD num);
		Error ButtonSelectAtAndActivate(WORD x, WORD y);

		Error ButtonActivate(void);

		BOOL HasPositionalButtons(void);
		BOOL IsButtonAt(WORD x, WORD y);
		BOOL HighlightActive(void) { return highlightActive; }
		BOOL ButtonActivated(void) { return buttonActivated; }

		Error GetCurrentButtonState(WORD & minButton, WORD & numButtons, WORD & currentButton);

		virtual Error Exit(Error err = GNR_OK) = 0;
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDNavpu.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
//  Navigation Command Processing Unit
//
//////////////////////////////////////////////////////////////////////

#include "DVDNavpu.h"
#include "Library/lowlevel/timer.h"
#include "Library/Common/vddebug.h"

#define DDP_LOG_DVD_COMMANDS 0

#if DDP_LOG_DVD_COMMANDS
#define LDC DP
#else
#define LDC //
#endif

// Include header files needed for debug output
#if NAVPROCDEBUG
#include <stdio.h>
#include <stdarg.h>
#include <time.h>
#endif

//////////////////////////////////////////////////////////////////////
//
//  DVDNavigationControl Class
//
//////////////////////////////////////////////////////////////////////

//
//  Save current state
//
//  GNR_OK
//

Error DVDNavigationControl::Freeze(DVDNCFreezeState & state)
	{
	int i;

	for (i=0; i<32; i++)
		state.sprm[i] = sprm[i];

	GNRAISE_OK;
	}

//
//  Return to previously saved state
//
//  GNR_OK
//

Error DVDNavigationControl::Defrost(DVDNCFreezeState & state)
	{
	int i;

	//
	//  Check if parental level is high enough
	//

	if (sprm[13] < state.sprm[13])
		GNRAISE(GNR_PARENTAL_LEVEL_TOO_LOW);

	//
	//  Now set the SPRMs with exception of the following:
	//	  0: Menu Description Language Code
	//  12: Parental Country Code
	//  13: Parental Level
	//  14: Player Configuration For Video
	//  16: Initial Language Code For Audio Streams
	//  17: Initial Language Code Extension For Audio Streams
	//  18: Initial Language Code For Subpicture Streams
	//  19: Initial Language Code Extension For Subpicture Streams
	//  This is done because those are user settings.
	//

	for (i=1; i<12; i++)
		sprm[i] = state.sprm[i];

	sprm[15] = state.sprm[15];

	for (i=20; i<32; i++)
		sprm[i] = state.sprm[i];

	GNRAISE_OK;
	}

//////////////////////////////////////////////////////////////////////
//
//  Navigation Processor Class
//
//////////////////////////////////////////////////////////////////////

//
//  Constructor
//

DVDNavigationProcessor::DVDNavigationProcessor(void)
	{
	recursionLevel = 0;

#if NAVPROCDEBUG
	logFile = NULL;
#endif
	}

//
//  GPRM Access
//

WORD DVDNavigationProcessor::GetGPRM(int index)
	{
	LDC("GetGPRM %d is %04x", index, gprm[index]);

	if (gprmMode[index])
	   return gprm[index] + (WORD)((Timer.GetMilliTicks() - gprmTimerStart[index]) / 1000);
	else
		return gprm[index];
	}

void DVDNavigationProcessor::SetGPRM(int index, WORD val)
	{
	LDC("SetGRPM %d to %04x", index, val);

	gprm[index] = val;
	if (gprmMode[index])
		gprmTimerStart[index] = Timer.GetMilliTicks();
	}

void DVDNavigationProcessor::SetGPRMMode(int index, WORD val, BOOL counter)
	{
	gprm[index] = val;
	if (counter)
		gprmTimerStart[index] = Timer.GetMilliTicks();

	gprmMode[index] = counter;
	}

//
//  Clear GPRMs
//
//  GNR_OK
//

Error DVDNavigationProcessor::ClearGPRMs(void)
	{
	int i;

	for(i=0; i<16; i++)
		{
		SetGPRM(i, 0);
		gprmMode[i] = FALSE;
		}

	GNRAISE_OK;
	}

//
//  Saturation arithmetic help functions
//

WORD Saturate(long val)
	{
	if (val < 0) return 0;
	else if (val > 0xffff) return 0xffff;
	else return (WORD)val;
	}

WORD Saturate(DWORD val)
	{
	if (val > 0xffff) return 0xffff;
	else return (WORD)val;
	}

//
//  Execute operation
//
//  GNR_OK
//  GNR_ILLEGAL_NAVIGATION_COMMAND
//

Error DVDNavigationProcessor::ExecOp(int op, WORD & dst, WORD & src)
	{
	WORD tmp;

	switch (op)
		{
		case 1: dst = src; GNRAISE_OK;
		case 2: tmp = dst; dst = src; src = tmp; GNRAISE_OK;
		case 3: dst = Saturate((long)dst + (long)src); GNRAISE_OK;
		case 4: dst = Saturate((long)dst - (long)src); GNRAISE_OK;
		case 5: dst = Saturate((DWORD)dst * (DWORD)src); GNRAISE_OK;
		case 6: dst = src ? dst / src : 0xffff; GNRAISE_OK;
		case 7: dst = src ? dst % src : 0xffff; GNRAISE_OK;
		case 8:
			if (src)
				{
				seed = 1664525L * seed + 1013904223L;
				dst = (WORD)(seed % src) + 1;
				}
			else
				dst = 0;

			GNRAISE_OK;
			break;
		case 9: dst &= src; GNRAISE_OK;
		case 10: dst |= src; GNRAISE_OK;
		case 11: dst ^= src; GNRAISE_OK;
		}

	GNRAISE(GNR_ILLEGAL_NAVIGATION_COMMAND);
	}

//
//  Execute operation SP
//
//  GNR_OK
//  GNR_ILLEGAL_NAVIGATION_COMMAND
//

Error DVDNavigationProcessor::ExecOpSP(DVDNavigationCommand com, int sp1, int sp2)
	{
	int s1;
	WORD imm, w1, w2, sprm;

	imm = com.SegW(sp2, 16);
	s1 = com.SegDW(sp1, 4);

	if (com.SegBIT(60))
		{
		w1 = GetGPRM(s1);
		GNREASSERT(ExecOp(com.SegDW(56, 4), w1, imm));
		SetGPRM(s1, w1);
		}
	else if (XTBF(7, imm))
		{
		GNREASSERT(navigationControl->GetSPRM(XTBF(0, 5, imm), sprm));
		w1 = GetGPRM(s1);
		GNREASSERT(ExecOp(com.SegDW(56, 4), w1, sprm));
		SetGPRM(s1, w1);
		}
	else
		{
		imm = (WORD)XTBF(0, 4, imm);
		w1 = GetGPRM(s1);
		w2 = GetGPRM(imm);
		GNREASSERT(ExecOp(com.SegDW(56, 4), w1, w2));
		SetGPRM(imm, w2);
		SetGPRM(s1, w1);
		}

	// Log result
	LOGPRM((WORD)XTBF(0, 4, s1));

	GNRAISE_OK;
	}

//
//  Compare two values
//

BOOL DVDNavigationProcessor::Compare(WORD val1, WORD val2)
	{
	switch (compareField)
		{
		case 1: return (val1 & val2) != 0;	// Bitwise compare ???
		case 2: return val1 == val2;			// Equal
		case 3: return val1 != val2;			// Not Equal
		case 4: return val1 >= val2;			// Greater than or equal to
		case 5: return val1 > val2;			// Greater than
		case 6: return val1 <= val2;			// Less than or equal to
		case 7: return val1 < val2;			// Less than
		}

	return FALSE;
	}

//
//  Get register value
//

WORD DVDNavigationProcessor::GetPRM(WORD num)
	{
	WORD sprm;

	if (XTBF(7, num))
		{
		navigationControl->GetSPRM(XTBF(0, 5, num), sprm);
		return sprm; // ???????????
		}
	else
		return GetGPRM(XTBF(0, 4, num));
	}

//
//  Compare
//

BOOL DVDNavigationProcessor::CompareCP(DVDNavigationCommand com, int cp1, int cp2)
	{
	WORD c1, c2, r2;

	c1 = GetPRM(com.SegW(cp1, 8));

	if (com.SegBIT(55)) // immediate
		{
		c2 = com.SegW(cp2, 16);
		}
	else
		{
		r2 = com.SegW(cp2, 8);
		c2 = GetPRM(r2);
		if (r2 == 0x88 && ((c1 & 0xfc00) == 0) && ((c1 & 0x3f) != 0))
			{
//			DP("Shinji RA Munita workaround");

			c1 <<= 10;
			}
		}

//	DP("Compare %08x with %08x", c1, c2);
#if NPD_LOGEXECUTION
	BOOL result = Compare(c1, c2);
	NPD_LogResultLn("Compare result: %s", result ? "true" : "false");
	return result;
#else
	return Compare(c1, c2);
#endif
	}

//
//  Execution methods for the different commands
//
//  GNR_OK
//

Error DVDNavigationProcessor::ExecNop(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	LOGCOMMAND;

	pc++;
	done = NCD_NO;

	GNRAISE_OK;
	}

//
//  Execute Go To
//
//  GNR_OK
//  GNR_UNEXPECTED_NAVIGATION_ERROR
//  GNR_ILLEGAL_NAVIGATION_COMMAND
//

Error DVDNavigationProcessor::ExecGoTo(DVDNavigationCommand com, int & pc, NavCommandDone & done, WORD & pml)
	{
	WORD operand = com.SegW(0, 16);
	WORD sprm;

	LOGCOMMAND

	// Log execution
	LOGEXECUTION(NPD_MakeGoToString(com));

	done = NCD_NO;

	switch (branchField)
		{
		case 1: // GoTo
			pc = XTBF(0, 8, operand);
			break;
		case 2: // Break
			done = NCD_YES;
			break;
		case 3: // SetTmpPML
			switch (navigationControl->PMLChangeAllowed())
				{
				case DVDNavigationControl::PMH_ALLOW_CHANGE:
					navigationControl->SetSPRM(13, (WORD)XTBF(8, 4, operand));
					pc = XTBF(0, 8, operand);
					break;
				case DVDNavigationControl::PMH_FORBID_CHANGE:
					pc++;
					break;
				case DVDNavigationControl::PMH_DEFER_CHANGE:
					GNREASSERT(navigationControl->GetSPRM(13, sprm));
					if (sprm < (WORD)XTBF(8, 4, operand))
						{
						// Current PML is too low -> ask for permission
						done = NCD_SETTMPPML_DEFERED;
						pml = (WORD)XTBF(8, 4, operand);
						}
					else
						{
						// Current PML is higher -> set it and continue
						navigationControl->SetSPRM(13, (WORD)XTBF(8, 4, operand));
						pc = XTBF(0, 8, operand);
						}
					break;
				default:
					done = NCD_YES;
					GNRAISE(GNR_UNEXPECTED_NAVIGATION_ERROR);
				}
			break;
		default:
			done = NCD_YES;
			GNRAISE(GNR_ILLEGAL_NAVIGATION_COMMAND);
		}

	GNRAISE_OK;
	}

//
//  Execute Compare Go To
//

Error DVDNavigationProcessor::ExecCompareGoTo(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	WORD pml; // dummy here

	LOGCOMMAND;

   if (CompareCP(com, 32, 16))
	 	return ExecGoTo(com, pc, done, pml);
	else
		return ExecNop(com, pc, done);
	}

//
//  Set Highlight Button
//
//  Misc. Errors
//

Error DVDNavigationProcessor::SetHL_BTTN(WORD button)
	{
	if (button)
		return navigationControl->SetSPRM(8, button);
	else
		GNRAISE_OK;
	}

//
//  Execute Link
//

Error DVDNavigationProcessor::ExecLink(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	LOGCOMMAND;

	// Log execution
#if NPD_LOGEXECUTION
	if (branchField != 1)
	LOGEXECUTION(NPD_MakeLinkString(com));
#endif

	switch (branchField)
		{
		case 1: // LinkSIns
			return ExecLinkSIns(com, pc, done);
			break;
		case 2: // LinkTKN
			break;
		case 3: // LinkDLISTN
			break;
		case 4: // LinkPGCN
			GNREASSERT(navigationControl->GoProgramChain(com.SegW(0, 15)));
			break;
		case 5: // LinkPTTN
			GNREASSERT(SetHL_BTTN(com.SegW(10, 6)));
			GNREASSERT(navigationControl->GoPartOfTitle(com.SegW(0, 10)));
			break;
		case 6: // LinkPGN
			GNREASSERT(SetHL_BTTN(com.SegW(10, 6)));
			GNREASSERT(navigationControl->GoProgram(com.SegW(0, 7)));
			break;
		case 7: // LinkCN
			GNREASSERT(SetHL_BTTN(com.SegW(10, 6)));
			GNREASSERT(navigationControl->GoCell(com.SegW(0, 8)));
			break;
		case 10: // LinkTKNGP
			break;
		case 11: // LinkDLISTNGP
			break;
		case 12: // LinkPGCNGP
			break;
		case 14: // LinkPGNGP
			break;
		case 15: // LinkCNGP
			break;
		default:
			GNRAISE(GNR_ILLEGAL_NAVIGATION_COMMAND);
		}

	done = NCD_YES;

	GNRAISE_OK;
	}

//
//  Execute Link By Sub Instruction
//

Error DVDNavigationProcessor::ExecLinkSIns(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	GNREASSERT(SetHL_BTTN(com.SegW(10, 6)));

	// Log execution
	LOGEXECUTION(NPD_MakeLinkSInsString(com));

	switch (com.SegDW(0, 8))
		{
		case 0:
			done = NCD_NO;
			pc++;
			GNRAISE_OK;
			break;
		case 1: GNREASSERT(navigationControl->GoTopCell()); break;
		case 2: GNREASSERT(navigationControl->GoNextCell()); break;
		case 3: GNREASSERT(navigationControl->GoPrevCell()); break;
		case 5: GNREASSERT(navigationControl->GoTopProgram()); break;
		case 6: GNREASSERT(navigationControl->GoNextProgram()); break;
		case 7: GNREASSERT(navigationControl->GoPrevProgram()); break;
		case 9: GNREASSERT(navigationControl->GoTopProgramChain()); break;
		case 10: GNREASSERT(navigationControl->GoNextProgramChain()); break;
		case 11: GNREASSERT(navigationControl->GoPrevProgramChain()); break;
		case 12: GNREASSERT(navigationControl->GoUpProgramChain()); break;
		case 13: GNREASSERT(navigationControl->GoTailProgramChain()); break;
		case 16: GNREASSERT(navigationControl->ResumeFromSystemSpace()); break;
		default:
			GNRAISE(GNR_ILLEGAL_NAVIGATION_COMMAND);
		}

	done = NCD_YES;

	GNRAISE_OK;
	}

//
//  Execute Compare Link
//

Error DVDNavigationProcessor::ExecCompareLink(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	LOGCOMMAND;

	if (CompareCP(com, 32, 16))
		return ExecLink(com, pc, done);

	pc++;
	done = NCD_NO;

	GNRAISE_OK;
	}

//
//  Execute Jump
//

Error DVDNavigationProcessor::ExecJump(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	WORD domain;

	// Log the command itself (only when not already logged)
	LOGCOMMAND;

	// Log execution
	LOGEXECUTION(NPD_MakeJumpString(com));

   switch (branchField)
   	{
   	case 1: // Exit
   		GNREASSERT(navigationControl->Exit());
   		break;
   	case 2: // JumpTT
   		GNREASSERT(navigationControl->GoTitle(com.SegW(16, 7)));
   		break;
   	case 3: // JumpVTS_TT
   		GNREASSERT(navigationControl->GoVideoTitleSetTitle(com.SegW(16, 7)));
   		break;
   	case 5: // JumpVTS_PTT
   		GNREASSERT(navigationControl->GoVideoTitleSetPartOfTitle(com.SegW(16, 7), com.SegW(32, 10)));
   		break;
   	case 6: // JumpSS
   		domain = com.SegW(22, 2);
   		if (domain != 2)
   			GNREASSERT(navigationControl->GoSystemSpaceProgramChain(com.SegW(32, 15), domain, com.SegW(16, 4)));
   		else
   			GNREASSERT(navigationControl->GoSystemSpaceTitleSet(com.SegW(24, 7), com.SegW(32, 7), domain, com.SegW(16, 4)));
   		break;
   	case 8: // CallSS
  			GNREASSERT(navigationControl->CallSystemSpaceProgramChain(com.SegW(32, 15), com.SegW(22, 2), com.SegW(16, 4), com.SegW(24, 8)));
   		break;
		case 9: // JumpTT_GR
			break;
		case 10: // JumpTK - Start the presentation of a Track in the specified TT_GR (DVD-Audio only)
			GNREASSERT(navigationControl->GoTrack(com.SegW(16, 7), com.SegW(32, 4)));
			break;
		case 11: // AMGM_RSM
			break;
   	}

	done = NCD_YES;

	GNRAISE_OK;
	}

//
//  Execute Compare Jump
//

Error DVDNavigationProcessor::ExecCompareJump(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	LOGCOMMAND;

	if (CompareCP(com, 8, 0))
		return ExecJump(com, pc, done);

	pc++;
	done = NCD_NO;

	GNRAISE_OK;
	}

//
//  Execute Set System
//

Error DVDNavigationProcessor::ExecSetSystem(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	BOOL imm = com.SegBIT(60);
	WORD w1, w2, w3;

	LOGCOMMAND;

	// Log execution
	LOGEXECUTION(NPD_MakeSetSystemString(com));

	switch (com.SegDW(56, 4))
		{
		case 1: // SetSTN
		   w1 = (WORD)com.SegDW(32, 4);
		   w2 = (WORD)com.SegDW(24, 7);
		   w3 = (WORD)com.SegDW(16, 4);
		   if (!imm)
		   	{
		   	w1 = GetGPRM(w1);
		   	w2 = GetGPRM(w2);
		   	w3 = GetGPRM(w3);
		   	}

		   if (com.SegBIT(39)) GNREASSERT(navigationControl->SetSPRM(1, w1));
		   if (com.SegBIT(31)) GNREASSERT(navigationControl->SetSPRM(2, w2));
		   if (com.SegBIT(23)) GNREASSERT(navigationControl->SetSPRM(3, w3));

			break;
		case 2: // SetNVTMR
			w2 = (WORD)com.SegDW(16, 15);
			if (imm)
				w1 = (WORD)com.SegDW(32, 16);
			else
				w1 = GetGPRM(com.SegDW(32, 4));

			GNREASSERT(navigationControl->SetSPRM(10, w2));
			GNREASSERT(navigationControl->SetSPRM(9, w1));
			break;
		case 3: // SetGPRMMD
			if (imm)
				w1 = (WORD)com.SegDW(32, 16);
			else
				w1 = GetGPRM(com.SegDW(32, 4));

			w2 = (WORD)com.SegDW(16, 4);

			SetGPRMMode(w2, w1, com.SegBIT(23));
			break;
		case 4: // SetAMXMD
			if (imm)
				w1 = (WORD)com.SegDW(32, 16);
			else
				w1 = GetGPRM(com.SegDW(32, 4));

			GNREASSERT(navigationControl->SetSPRM(11, w1));
			break;
		case 6: // SetHL_BTNN
			if (imm)
				w1 = (WORD)com.SegDW(26, 6);
			else
				w1 = (WORD)XTBF(10, 6, GetGPRM(com.SegDW(16, 4)));

			GNREASSERT(SetHL_BTTN(w1));	// Logging is done inside this function
			break;
		default:
			GNRAISE(GNR_ILLEGAL_NAVIGATION_COMMAND);
		}

	pc++;
	done = NCD_NO;

	GNRAISE_OK;
	}

//
//  Execute Compare Set System
//

Error DVDNavigationProcessor::ExecCompareSetSystem(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	LOGCOMMAND;
	if (CompareCP(com, 8, 0))
		return ExecSetSystem(com, pc, done);

	pc++;
	done = NCD_NO;

	GNRAISE_OK;
	}

//
//  Execute Set System Link
//

Error DVDNavigationProcessor::ExecSetSystemLink(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	LOGCOMMAND;
	GNREASSERT(ExecSetSystem(com, pc, done));
	pc--;
	return ExecLink(com, pc, done);
	}

//
//  Execute Set
//

Error DVDNavigationProcessor::ExecSet(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	LOGCOMMAND;
	GNREASSERT(ExecOpSP(com, 32, 16));

	pc++;
	done = NCD_NO;

	GNRAISE_OK;
	}

//
//  Execute Compare Set
//

Error DVDNavigationProcessor::ExecCompareSet(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	LOGCOMMAND;
	if (CompareCP(com, 40, 0))
		{
		GNREASSERT(ExecOpSP(com, 32, 16));
		}

	pc++;
	done = NCD_NO;

	GNRAISE_OK;
	}

//
//  Execute Set Link
//

Error DVDNavigationProcessor::ExecSetLink(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	LOGCOMMAND;
	GNREASSERT(ExecOpSP(com, 32, 16));
	return ExecLink(com, pc, done);
	}

//
//  Execute Set Compare Link By Sub Instruction
//

Error DVDNavigationProcessor::ExecSetCompareLinkSIns(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	LOGCOMMAND;
	GNREASSERT(ExecOpSP(com, 48, 32));
	if (CompareCP(com, 48, 16))
		return ExecLinkSIns(com, pc, done);

	pc++;
	done = NCD_NO;

	GNRAISE_OK;
	}

//
//  Execute Compare And Set Link By Sub Instruction
//

Error DVDNavigationProcessor::ExecCompareAndSetLinkSIns(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	LDC("CompareAndSetLinkSIns");
	if (!com.SegBIT(60))
		{
		if (CompareCP(com, 32, 16))
		 	{
			GNREASSERT(ExecOpSP(com, 48, 40));
			return ExecLinkSIns(com, pc, done);
			}
		}
	else
		{
		if (CompareCP(com, 24, 16))
		 	{
			GNREASSERT(ExecOpSP(com, 48, 32));
			return ExecLinkSIns(com, pc, done);
			}
		}

	pc++;
	done = NCD_NO;

	GNRAISE_OK;
	}

//
//  Execute Compare Set And Link By Sub Instruction
//

Error DVDNavigationProcessor::ExecCompareSetAndLinkSIns(DVDNavigationCommand com, int & pc, NavCommandDone & done)
	{
	LDC("CompareSetAndLinkSIns");
	if (!com.SegBIT(60))
		{
		if (CompareCP(com, 32, 16))
		 	{
			GNREASSERT(ExecOpSP(com, 48, 40));
			}
		}
	else
		{
		if (CompareCP(com, 24, 16))
		 	{
			GNREASSERT(ExecOpSP(com, 48, 32));
			}
		}

	return ExecLinkSIns(com, pc, done);
	}

BOOL DVDNavigationProcessor::IsBasicCellLinkCommand(DVDNavigationCommand com)
	{
	DWORD opcode = com.SegDW(48, 16);
	DWORD oplink = com.SegDW(0, 16);

	if (opcode == 0x2007 ||
		 opcode == 0x2001 && (oplink & 0x00ff) >= 0x0001 && (oplink & 0x00ff) <= 0x0003)
		{
		return (oplink & 0xfc00) == 0x0000;
		}
	else if (opcode == 0x0000)
		return TRUE;
	else
		return FALSE;
	}

Error DVDNavigationProcessor::GetBasicCellLinkTarget(DVDNavigationCommand com, WORD & cellID)
	{
	DWORD opcode = com.SegDW(48, 16);
	DWORD oplink = com.SegDW(0, 16);

	if (opcode == 0x2007)
		{
		cellID = (WORD)(oplink & 0x00ff);
		}
	else if (opcode == 0x0000)
		{
		cellID++; // NOP
		}
	else if (opcode == 0x2001)
		{
		switch (oplink & 0x00ff)
			{
			case 0x0001:         ; break;
			case 0x0002: cellID++; break;
			case 0x0003: cellID--; break;
			default:
				GNRAISE(GNR_ILLEGAL_NAVIGATION_COMMAND);
			}
		}
	else
		GNRAISE(GNR_ILLEGAL_NAVIGATION_COMMAND);

	GNRAISE_OK;
	}

//
//  Interpret Command
//
//  GNR_OK
//  GNR_ILLEGAL_NAVIGATION_COMMAND
//  GNR_UNEXPECTED_NAVIGATION_ERROR
//

Error DVDNavigationProcessor::InterpretCommand(DVDNavigationCommand com, int & pc, NavCommandDone & done, WORD & pml)
	{
	int cmdid1;

//	DP("PC : %02x Command %08lx%08lx", pc, FLIPENDIAN(com.dw[0]), FLIPENDIAN(com.dw[1]));

#if NPD_LOGEXECUTION
	// The new instruction is used to avoid logging combined instructions more than once
	// if the second and/or the third instruction are executed. This flag is reset
	// by the NPD_LogCommand()
	npd_newInstruction = true;
#endif

	cmdid1 = com.SegDW(61, 3);

	compareField = com.SegDW(52, 3);
	branchField = com.SegDW(48, 4);

	switch (cmdid1)
		{
		case 0:
			if (!branchField)
				return ExecNop(com, pc, done);
			else if (!compareField)
				return ExecGoTo(com, pc, done, pml);
			else
				return ExecCompareGoTo(com, pc, done);
			break;
		case 1:
			if (!com.SegBIT(60))
				{
				if (!compareField)
					return ExecLink(com, pc, done);
				else
					return ExecCompareLink(com, pc, done);
				break;
				}
			else
				{
				if (!compareField)
					return ExecJump(com, pc, done);
				else
					return ExecCompareJump(com, pc, done);
				break;
				}
		case 2:
			if (compareField)
				return ExecCompareSetSystem(com, pc, done);
			else if (branchField)
				return ExecSetSystemLink(com, pc, done);
			else
				return ExecSetSystem(com, pc, done);
			break;
		case 3:
			if (compareField)
				return ExecCompareSet(com, pc, done);
			else if (branchField)
				return ExecSetLink(com, pc, done);
			else
				return ExecSet(com, pc, done);
			break;
		case 4:
			return ExecSetCompareLinkSIns(com, pc, done);
			break;
		case 5:
			return ExecCompareAndSetLinkSIns(com, pc, done);
			break;
		case 6:
			return ExecCompareSetAndLinkSIns(com, pc, done);
			break;
		default:
			done = NCD_NO;
			GNRAISE(GNR_ILLEGAL_NAVIGATION_COMMAND);
			break;
		}

	GNRAISE_OK;
	}

//
//  Interpret Command List
//
//  GNR_OK
//  GNR_UNEXPECTED_NAVIGATION_ERROR
//

Error DVDNavigationProcessor::InterpretCommandList(DVDNavigationCommand * com, int & pc, int num, NavCommandDone & done, WORD & pml)
	{
#if NPD_LOGCMDLISTS
	NPD_LogCommandList(com, pc, num);
#endif

#if NPD_LOGEXECUTION
	NPD_LogLn("*** Begin executing command list, recursionLevel = %i", recursionLevel + 1);
	NPD_LogPRM();
#endif

	if (recursionLevel < 200)
		{
		recursionLevel++;

		do {
			GNREASSERT(InterpretCommand(com[pc-1], pc, done, pml));
			} while (done == NCD_NO && pc <= num);

		recursionLevel--;
		}
	else
   	navigationControl->Exit(GNR_UNEXPECTED_NAVIGATION_ERROR);

#if NPD_LOGEXECUTION
	NPD_LogString("*** End executing command list\n");
#endif

	GNRAISE_OK;
	}

//
//  Freeze current state
//
//  GNR_OK
//

Error DVDNavigationProcessor::Freeze(DVDNPFreezeState & state)
	{
	int i;

	//
	// Save data
	//

	state.seed = seed;
	state.gprmMode = 0;

	for (i=0; i<16; i++)
		{
		state.gprm[i] = gprm[i];
		state.gprmMode |= MKBFW(i, gprmMode[i]);

		if (gprmMode[i])
			{
			// Create relative time
			state.gprmTimerStart[i] = Timer.GetMilliTicks() - gprmTimerStart[i];
			}
		}

	GNRAISE_OK;
	}

//
//  Restore previously saved state
//
//  GNR_OK
//

Error DVDNavigationProcessor::Defrost(DVDNPFreezeState & state)
	{
	int i;

	//
	// Restore data
	//

	seed = state.seed;
	for (i=0; i<16; i++)
		{
		gprm[i] = state.gprm[i];
		gprmMode[i] = (BOOL) XTBFW(i, state.gprmMode);

		if (gprmMode[i])
			{
			// Recreate absolute time
			gprmTimerStart[i] = state.gprmTimerStart[i] + Timer.GetMilliTicks();
			}
		}

	GNRAISE_OK;
	}

#if NAVPROCDEBUG

// Print a log message either to debug out or to a file
void DVDNavigationProcessor::NPD_LogString(const char * string)
	{
	// Log to file
#if NPD_LOGTOFILE
	if (!logFile)
		{
		// Open logfile if neccessary
		logFile = fopen(NPD_LOGFILENAME, "a+t");
		if (logFile)
			{
			char buffer[20], buffer1[20];
			fprintf(logFile, "\n\n*** Logging started at %s on %s\n", _strtime(buffer), _strdate(buffer1));
			}
		}
	if (logFile)
		{
		fprintf(logFile, string);
		fflush(logFile);
		}
#endif

	// Log to debug out
#if NPD_LOGTODBGOUT
	OutputDebugString(string);
#endif
	}

// These function below help logging things by using variable arguments and printf() - kompatible syntax
// to log strings

void DVDNavigationProcessor::NPD_LogLn(int pc, const char * format, ...)
	{
	va_list	list;
	char		buffer1[200], buffer2[210];

	va_start(list, format);

	// Create the string to log
	_vsnprintf(buffer1, 200, format, list);
	_snprintf(buffer2, 210, "%04i: %s\n", pc, buffer1);

	NPD_LogString(buffer2);
	}

void DVDNavigationProcessor::NPD_LogResultLn(const char * format, ...)
	{
	va_list	list;
	char		buffer[200];

	va_start(list, format);

	// Create the string to log
	_vsnprintf(buffer, 200, format, list);

	NPD_LogLn("      %s", buffer);
	}

void DVDNavigationProcessor::NPD_LogLn(const char * format, ...)
	{
	va_list	list;
	char		buffer1[200], buffer2[210];

	va_start(list, format);

	// Create the string to log
	_vsnprintf(buffer1, 200, format, list);
	_snprintf(buffer2, 210, "%s\n", buffer1);

	NPD_LogString(buffer2);
	}

//
// Each of the NPD_MakeXXXX functions returns a pointer to a string that describes that particular
// command. You are responsible for the deletion of the string memory


char * DVDNavigationProcessor::NPD_MakePRMString(WORD num, bool runtime)
	{
	char *string = new char[50];

	if (runtime)
		{
		if (XTBF(7, num))
			_snprintf(string, 50, "SPRM(%i)[0x%x]", XTBF(0, 5, num), GetPRM(num));
		else
			_snprintf(string, 50, "GPRM(%i)[0x%x]", XTBF(0, 4, num), GetPRM(num));
		}
	else
		{
		if (XTBF(7, num))
			_snprintf(string, 50, "SPRM(%i)", XTBF(0, 5, num));
		else
			_snprintf(string, 50, "GPRM(%i)", XTBF(0, 4, num));
		}

	return string;
	}


// Retrieve the arguments for a compare operation
void DVDNavigationProcessor::NPD_MakeCompareArgs(DVDNavigationCommand com, int cp1, int cp2, char* &arg1, char* &arg2, bool runtime)
	{

	arg1 = NPD_MakePRMString(com.SegW(cp1, 8), runtime);

	//arg1 = GetPRM(com.SegW(cp1, 8));

	if (com.SegBIT(55)) // immediate
		{
		arg2 = new char[20];
		_snprintf(arg2, 20, "0x%x(Imm)", com.SegW(cp2, 16));
		}
	else
		arg2 = NPD_MakePRMString(com.SegW(cp2, 8), runtime);
	}

// build a string that describes the comparison
char * DVDNavigationProcessor::NPD_MakeCompareString(DVDNavigationCommand com, int cp1, int cp2, bool runtime)
	{
	char * buffer = new char[100];
	char opString[5];
	char *arg1, *arg2;

	NPD_MakeCompareArgs(com, cp1, cp2, arg1, arg2, runtime);

	if (compareField == 1)
		{
		_snprintf(buffer, 100, "Compare (%s & &s) != 0", arg1, arg2);
		}
	else
		{
		if (compareField < 8)
			{
			switch (compareField)
				{
				case 2: strcpy(opString, "=="); break;
				case 3: strcpy(opString, "!="); break;
				case 4: strcpy(opString, ">="); break;
				case 5: strcpy(opString, ">"); break;
				case 6: strcpy(opString, "<="); break;
				case 7: strcpy(opString, "<"); break;
				}
			_snprintf(buffer, 100, "Compare %s %s %s", arg1, opString, arg2);
			}
		else
			{
			_snprintf(buffer, 100, "Illegal compare Field (%i) Op1:%s, Op2:%s", compareField, arg1, arg2);
			}
		}

	delete arg1;
	delete arg2;

	return buffer;
	}

char * DVDNavigationProcessor::NPD_MakeString(const char * format, ...)
	{
	va_list	list;
	char*		buffer = new char[200];

	va_start(list, format);

	// Create the string to log
	_vsnprintf(buffer, 200, format, list);

	return buffer;
	}


char * DVDNavigationProcessor::NPD_MakeGoToString(DVDNavigationCommand com)
	{
	int operand = com.SegDW(0, 16);

	switch(branchField)
		{
		case 1: return NPD_MakeString("GoTo %04i", operand); break;
		case 2: return NPD_MakeString("Break"); break;
		case 3: return NPD_MakeString("SetTmpPML %i", XTBF(0, 8, operand)); break;
		default:
			return NPD_MakeString("GoTo: Illegal branch field (%i)", branchField); break;
		}
	}

char * DVDNavigationProcessor::NPD_MakeLinkSInsString(DVDNavigationCommand com)
	{
	return NPD_MakeString("LinkSIns %d", com.SegDW(0, 8));
	}


char * DVDNavigationProcessor::NPD_MakeLinkString(DVDNavigationCommand com)
	{
	switch (branchField)
		{
		case 1: // LinkSIns
			return NPD_MakeLinkSInsString(com);
			break;
		case 2: // LinkTKN
			return NPD_MakeString("LinkTKN command");
			break;
		case 3: // LinkDLISTN
			return NPD_MakeString("LinkDLISTN command");
			break;
		case 4: // LinkPGCN
			return NPD_MakeString("LinkPGCN %d", com.SegW(0, 15));
			break;
		case 5: // LinkPTTN
			return NPD_MakeString("LinkPTTN %d", com.SegW(0, 10));
			break;
		case 6: // LinkPGN
			return NPD_MakeString("LinkPGN %d", com.SegW(0, 7));
			break;
		case 7: // LinkCN
			return NPD_MakeString("LinkCN %d", com.SegW(0, 8));
			break;
		case 10: // LinkTKNGP
			return NPD_MakeString("LinkTKNGP command");
			break;
		case 11: // LinkDLISTNGP
			return NPD_MakeString("LinkDLISTNGP command");
			break;
		case 12: // LinkPGCNGP
			return NPD_MakeString("LinkPGCNP command");
			break;
		case 14: // LinkPGNGP
			return NPD_MakeString("LinkPGNGP command");
			break;
		case 15: // LinkCNGP
			return NPD_MakeString("LinkCNGP command");
			break;
		default:
			return NPD_MakeString("Illegal LINK command");
		}

	}

char * DVDNavigationProcessor::NPD_MakeJumpString(DVDNavigationCommand com)
	{
	WORD domain;

   switch (branchField)
   	{
   	case 1: // Exit
			return NPD_MakeString("Exit");
   		break;
   	case 2: // JumpTT
			return NPD_MakeString("JumpTT %d", com.SegW(16, 7));
   		break;
   	case 3: // JumpVTS_TT
			return NPD_MakeString("JumpVTS_TT %d", com.SegW(16, 7));
   		break;
   	case 5: // JumpVTS_PTT
			return NPD_MakeString("JumpVTS_PTT %d %d", com.SegW(16, 7), com.SegW(32, 10));
   		break;
   	case 6: // JumpSS
   		domain = com.SegW(22, 2);
			if (domain != 2)
				return NPD_MakeString("JumpSS %d VMGM_PCGN:%i MenuId:%i", com.SegW(22, 2), com.SegW(32, 15), com.SegW(16, 4));
			else
				return NPD_MakeString("JumpSS %d VTS_TTN:%i VTSN:%i MenuId:%i", com.SegW(22, 2), com.SegW(32, 7), com.SegW(24, 7), com.SegW(16, 4));
   		break;
   	case 8: // CallSS
			return NPD_MakeString("CallSS");
   		break;
		case 9: // JumpTT_GR
			return NPD_MakeString("JumpTT_GR");
			break;
		case 10: // JumpTK - Start the presentation of a Track in the specified TT_GR (DVD-Audio only)
			return NPD_MakeString("JumpTK %i %i", com.SegW(16, 7), com.SegW(32, 4));
			break;
		case 11: // AMGM_RSM
			return NPD_MakeString("AMGM_RSM");
			break;
		default:
			return NPD_MakeString("Invalid jump (%i)", branchField);
			break;
   	}
	}

char * DVDNavigationProcessor::NPD_MakeSetSystemString(DVDNavigationCommand com, bool runtime)
	{
	BOOL imm = com.SegBIT(60);
	WORD w1, w2, w3;

	switch (com.SegDW(56, 4))
		{
		case 1: // SetSTN
			char *buffer1, *buffer2, *buffer3;
			char *result;
		   w1 = (WORD)com.SegDW(32, 4);
		   w2 = (WORD)com.SegDW(24, 7);
		   w3 = (WORD)com.SegDW(16, 4);
		   if (!imm)
		   	{
				// Non-immediate
				char *prmString1,*prmString2,*prmString3;

		   	w1 = GetGPRM(w1);
		   	w2 = GetGPRM(w2);
		   	w3 = GetGPRM(w3);

				prmString1=NPD_MakePRMString((WORD)XTBF(0,4,w1), runtime);
				prmString2=NPD_MakePRMString((WORD)XTBF(0,4,w2), runtime);
				prmString3=NPD_MakePRMString((WORD)XTBF(0,4,w3), runtime);

				buffer1 = NPD_MakeString("%s->SPRM(1)", prmString1);
				buffer2 = NPD_MakeString("%s->SPRM(2)", prmString2);
				buffer3 = NPD_MakeString("%s->SPRM(3)", prmString3);

				delete prmString1;
				delete prmString2;
				delete prmString3;
		   	}
			else
				{
				// Immediate
				buffer1 = NPD_MakeString("0x%x->SPRM(1)", w1);
				buffer2 = NPD_MakeString("0x%x->SPRM(2)", w2);
				buffer3 = NPD_MakeString("0x%x->SPRM(3)", w3);
				}

			result= NPD_MakeString("SetSTN %s %s %s",
				com.SegBIT(39) ? buffer1 : "",
				com.SegBIT(31) ? buffer2 : "",
				com.SegBIT(23) ? buffer3 : "");

			delete buffer1;
			delete buffer2;
			delete buffer3;

			return result;
			break;
		case 2: // SetNVTMR
			{
			char *string; // Temporary string
			char *result;

			// Extract argument
			w2 = (WORD)com.SegDW(16, 15);

			if (imm)
				{
				string = new char[20];
				_snprintf(string, 20, "0x%x",(WORD)com.SegDW(32, 16));
				}
			else
				string = NPD_MakePRMString((WORD)com.SegDW(32, 4), runtime);

			result = NPD_MakeString("SetNVTMR 0x%x->SPRM(10) %s->SPRM(9)", w2, string);

			delete string;

			return result;
			}
			break;
		case 3: // SetGPRMMD
			{
			char *string; // Temporary string
			char *result;

			if (imm)
				{
				string = new char[20];
				_snprintf(string, 20, "0x%x",(WORD)com.SegDW(32, 16));
				}
			else
				string = NPD_MakePRMString((WORD)com.SegDW(32, 4), runtime);

			w2 = (WORD)com.SegDW(16, 4);

			result = NPD_MakeString("SetGPRMMD %s->GPRM(%i) Mode:%i",string, w2, com.SegBIT(23));

			delete string;

			return result;
			}
			break;
		case 4: // SetAMXMD
			{
			char *string; // Temporary string
			char *result;

			if (imm)
				{
				string = new char[20];
				_snprintf(string, 20, "0x%x",(WORD)com.SegDW(32, 16));
				}
			else
				string = NPD_MakePRMString((WORD)com.SegDW(32, 4), runtime);

			result = NPD_MakeString("SetAMXMD %s->SPRM(11)", string);
			return result;
			}
			break;
		case 6: // SetHL_BTNN
			if (imm)
				w1 = (WORD)com.SegDW(26, 6);
			else
				w1 = (WORD)XTBF(10, 6, GetGPRM(com.SegDW(16, 4)));

			return NPD_MakeString("SetHL_BTNN %i->SPRM(8) %s", w1, imm ? "(Imm)" : "");
			break;
		default:
			return NPD_MakeString("Illegal SetSystem command (%i)", com.SegDW(56, 4));
		}

	}

char * DVDNavigationProcessor::NPD_MakeOpString(int opcode)
	{
	switch (opcode)
		{
		case 1:return NPD_MakeString("Mov"); break;
		case 2:return NPD_MakeString("Swp"); break;
		case 3:return NPD_MakeString("Add"); break;
		case 4:return NPD_MakeString("Sub"); break;
		case 5:return NPD_MakeString("Mul"); break;
		case 6:return NPD_MakeString("Div"); break;
		case 7:return NPD_MakeString("Mod"); break;
		case 8:return NPD_MakeString("Rnd"); break;
		case 9:return NPD_MakeString("And"); break;
		case 10:return NPD_MakeString("Or"); break;
		case 11:return NPD_MakeString("Xor"); break;
		default:return NPD_MakeString("Invalid Set (%i)", opcode); break;
		}
	}

char * DVDNavigationProcessor::NPD_MakeSetString(DVDNavigationCommand com, int sp1, int sp2, bool runtime)
	{
	int s1;
	WORD imm;
	char * opString = NPD_MakeOpString(com.SegDW(56, 4));
	char * result = NULL;

	imm = com.SegW(sp2, 16);
	s1 = com.SegDW(sp1, 4);

	// Immediate?
	if (com.SegBIT(60))
		{
		result =  NPD_MakeString("%sI GPRM(%i), 0x%x", opString, s1, imm);
		}
	else
		{
		char * secondArg = NPD_MakePRMString(imm, runtime);
		result =  NPD_MakeString("%s GPRM(%i), %s", opString, s1, secondArg);
		delete secondArg;
		}

	delete opString;
	return result;
	}

// These two functions help logging multi-part commands

void DVDNavigationProcessor::NPD_LogDualCommand(int pc, char * pPart1, char * pPart2)
	{
	NPD_LogLn(pc, "%s %s", pPart1, pPart2);

	delete pPart1;
	delete pPart2;
	}

void DVDNavigationProcessor::NPD_LogTripleCommand(int pc, char * pPart1, char * pPart2, char * pPart3, int ampersandPos)
	{
	switch(ampersandPos)
		{
		case 1:NPD_LogLn(pc, "%s & %s %s", pPart1, pPart2, pPart3); break;
		case 2:NPD_LogLn(pc, "%s %s & %s", pPart1, pPart2, pPart3); break;
		default:NPD_LogLn(pc, "%s %s %s", pPart1, pPart2, pPart3); break;
		}

	delete pPart1;
	delete pPart2;
	delete pPart3;
	}

//
// Each function below logs a specific command. These functions are called from NPD_LogCommand()
//

void DVDNavigationProcessor::NPD_LogNop(DVDNavigationCommand com, int pc)
	{
	NPD_LogLn(pc, "Nop");
	}

void DVDNavigationProcessor::NPD_LogGoTo(DVDNavigationCommand com, int pc)
	{
	char * pString = NPD_MakeGoToString(com);

	NPD_LogLn(pc,pString);

	delete pString;
	}

void DVDNavigationProcessor::NPD_LogCompareGoTo(DVDNavigationCommand com, int pc, bool runtime)
	{
	NPD_LogDualCommand(pc, NPD_MakeCompareString(com, 32, 16, runtime), NPD_MakeGoToString(com));
	}

void DVDNavigationProcessor::NPD_LogLink(DVDNavigationCommand com, int pc)
	{
	char * pString = NPD_MakeLinkString(com);
	NPD_LogLn(pc, pString);
	delete pString;
	}

void DVDNavigationProcessor::NPD_LogCompareLink(DVDNavigationCommand com, int pc, bool runtime)
	{
	NPD_LogDualCommand(pc, NPD_MakeCompareString(com, 32, 16, runtime), NPD_MakeLinkString(com));
	}

void DVDNavigationProcessor::NPD_LogJump(DVDNavigationCommand com, int pc)
	{
	char * pString = NPD_MakeJumpString(com);
	NPD_LogLn(pc, pString);
	delete pString;
	}

void DVDNavigationProcessor::NPD_LogCompareJump(DVDNavigationCommand com, int pc, bool runtime)
	{
	NPD_LogDualCommand(pc, NPD_MakeCompareString(com, 8, 0, runtime), NPD_MakeJumpString(com));
	}

void DVDNavigationProcessor::NPD_LogSetSystem(DVDNavigationCommand com, int pc, bool runtime)
	{
	char * pString = NPD_MakeSetSystemString(com);
	NPD_LogLn(pc, pString);
	delete pString;
	}

void DVDNavigationProcessor::NPD_LogCompareSetSystem(DVDNavigationCommand com, int pc, bool runtime)
	{
	NPD_LogDualCommand(pc, NPD_MakeCompareString(com, 8, 0, runtime), NPD_MakeSetSystemString(com));
	}

void DVDNavigationProcessor::NPD_LogSetSystemLink(DVDNavigationCommand com, int pc, bool runtime)
	{
	NPD_LogDualCommand(pc, NPD_MakeLinkString(com), NPD_MakeSetSystemString(com));
	}

void DVDNavigationProcessor::NPD_LogSet(DVDNavigationCommand com, int pc, bool runtime)
	{
	char * pString = NPD_MakeSetString(com, 32, 16, runtime);
	NPD_LogLn(pc, pString);
	delete pString;
	}

void DVDNavigationProcessor::NPD_LogCompareSet(DVDNavigationCommand com, int pc, bool runtime)
	{
	NPD_LogDualCommand(pc, NPD_MakeCompareString(com, 40, 0, runtime), NPD_MakeSetString(com, 32, 16, runtime));
	}

void DVDNavigationProcessor::NPD_LogSetLink(DVDNavigationCommand com, int pc, bool runtime)
	{
	NPD_LogDualCommand(pc, NPD_MakeLinkString(com), NPD_MakeSetString(com, 32, 16, runtime));
	}

void DVDNavigationProcessor::NPD_LogSetCompareLinkSIns(DVDNavigationCommand com, int pc, bool runtime)
	{
	NPD_LogTripleCommand(pc, NPD_MakeSetString(com, 48, 32, runtime),
		NPD_MakeCompareString(com, 48, 16, runtime),
		NPD_MakeLinkSInsString(com), 0);

	}

void DVDNavigationProcessor::NPD_LogCompareAndSetLinkSIns(DVDNavigationCommand com, int pc, bool runtime)
	{
	if (!com.SegBIT(60))
		{
		NPD_LogTripleCommand(pc, NPD_MakeCompareString(com, 32, 16, runtime),
			NPD_MakeSetString(com, 48, 40, runtime),
			NPD_MakeLinkSInsString(com), 1);
		}
	else
		{
		NPD_LogTripleCommand(pc, NPD_MakeCompareString(com, 24, 16, runtime),
			NPD_MakeSetString(com, 48, 32, runtime),
			NPD_MakeLinkSInsString(com), 1);
		}
	}

void DVDNavigationProcessor::NPD_LogCompareSetAndLinkSIns(DVDNavigationCommand com, int pc, bool runtime)
	{
	if (!com.SegBIT(60))
		{
		NPD_LogTripleCommand(pc, NPD_MakeCompareString(com, 32, 16, runtime),
			NPD_MakeSetString(com, 48, 40, runtime),
			NPD_MakeLinkSInsString(com), 2);
		}
	else
		{
		NPD_LogTripleCommand(pc, NPD_MakeCompareString(com, 24, 16, runtime),
			NPD_MakeSetString(com, 48, 32, runtime),
			NPD_MakeLinkSInsString(com), 2);
		}
	}

// Log a the value of a single parameter

void DVDNavigationProcessor::NPD_LogResultPRM(WORD num)
	{
	char * string = NPD_MakePRMString(num, true);
	NPD_LogResultLn("result: %s", string);
	delete string;
	}

// Log a single instruction (only when npd_newInstruction is true, otherwise nothing happens.
// This mechanism is to prevent multiple logging of composite instructions):

void DVDNavigationProcessor::NPD_LogCommand(DVDNavigationCommand com, int pc, bool runtime)
	{
	int cmdId1;

//	DP("PC : %02x Command %08lx%08lx", pc, FLIPENDIAN(com.dw[0]), FLIPENDIAN(com.dw[1]));

#if NPD_LOGEXECUTION
	if (npd_newInstruction)
		{
#endif
		cmdId1 = com.SegDW(61, 3);

		compareField = com.SegDW(52, 3);
		branchField = com.SegDW(48, 4);

		switch (cmdId1)
			{
			case 0:
				if (!branchField)
					NPD_LogNop(com, pc);
				else if (!compareField)
					NPD_LogGoTo(com, pc);
				else
					NPD_LogCompareGoTo(com, pc, runtime);
				break;
			case 1:
				if (!com.SegBIT(60))
					{
					if (!compareField)
						NPD_LogLink(com, pc);
					else
						NPD_LogCompareLink(com, pc, runtime);
					break;
					}
				else
					{
					if (!compareField)
						NPD_LogJump(com, pc);
					else
						NPD_LogCompareJump(com, pc, runtime);
					break;
					}
			case 2:
				if (compareField)
					NPD_LogCompareSetSystem(com, pc, runtime);
				else if (branchField)
					NPD_LogSetSystemLink(com, pc, runtime);
				else
					NPD_LogSetSystem(com, pc, runtime);
				break;
			case 3:
				if (compareField)
					NPD_LogCompareSet(com, pc, runtime);
				else if (branchField)
					NPD_LogSetLink(com, pc, runtime);
				else
					NPD_LogSet(com, pc, runtime);
				break;
			case 4:
				NPD_LogSetCompareLinkSIns(com, pc, runtime);
				break;
			case 5:
				NPD_LogCompareAndSetLinkSIns(com, pc, runtime);
				break;
			case 6:
				NPD_LogCompareSetAndLinkSIns(com, pc, runtime);
				break;
			default:
				NPD_LogLn(pc, "Illegal Navigation Command (%i)", cmdId1);
				break;
			}
#if NPD_LOGEXECUTION
		}

	// The new instruction is used to avoid logging combined instructions more than once
	// if the second and/or the third instruction are executed. This flag is set
	// by the InterpretCommand()
	npd_newInstruction = false;
#endif

	}

// Log whole command list to a file or debug output

void DVDNavigationProcessor::NPD_LogCommandList(DVDNavigationCommand * com, int pc, int num)
	{
	NPD_LogString("*** Command List start\n");
	do {
		npd_newInstruction = true;
		NPD_LogCommand(com[pc-1], pc);
		pc++;
		} while (pc <= num);

	NPD_LogString("*** Command List end\n");
	}

// Close the log file on deletion

DVDNavigationProcessor::~DVDNavigationProcessor(void)
	{
	if (logFile != NULL)
		{
		fclose(logFile);
		logFile = NULL;
		}
	}

// Get the value of a SPRM
WORD DVDNavigationProcessor::NPD_GetSPRM(WORD num)
	{
	WORD w;
	navigationControl->GetSPRM(num, w);

	return w;
	}

// Log all SPRM values

void DVDNavigationProcessor::NPD_LogSPRM(void)
	{
	for (int i = 0; i < 24; i+=4)
		{
		NPD_LogResultLn("SPRM(%02i):0x%04x SPRM(%02i):0x%04x SPRM(%02i):0x%04x SPRM(%02i):0x%04x",
			i, NPD_GetSPRM(i), i+1, NPD_GetSPRM(i+1), i+2, NPD_GetSPRM(i+2), i+3, NPD_GetSPRM(i+3));
		}
	}

// Log all GPRM values

void DVDNavigationProcessor::NPD_LogGPRM(void)
	{
	for (int i = 0; i < 16; i+=4)
		{
		NPD_LogResultLn("GPRM(%02i):0x%04x GPRM(%02i):0x%04x GPRM(%02i):0x%04x GPRM(%02i):0x%04x",
			i, GetGPRM(i), i+1, GetGPRM(i+1), i+2, GetGPRM(i+2), i+3, GetGPRM(i+3));
		}
	}

// Log all parameters, GPRM and SPRM

void DVDNavigationProcessor::NPD_LogPRM(void)
	{
	NPD_LogGPRM();
	NPD_LogSPRM();
	}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDPGCSeq.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
//  Program Chain Server Module
//
//////////////////////////////////////////////////////////////////////

#ifndef DVDPGCSEQ_H
#define DVDPGCSEQ_H

#include "NavErrors.h"
#include "DVDAVStreamServer.h"
#include "DVDNavpu.h"
#include "DVDPlayer.h"
#include "DVDHliCtrl.h"

#pragma warning(disable : 4250)

class DVDNavigationTimer : protected WinPort
	{
	protected:
		BOOL							paused;
		BOOL							active, started;
		DVDNavigationControl	*	navControl;
		WORD							pgcn;
		DWORD							time;

		void Message (WPARAM wParam, LPARAM lParam);
	public:
		DVDNavigationTimer(WinPortServer * server, DVDNavigationControl * navControl);
		~DVDNavigationTimer(void);

		Error StartNavigationTimer(void);
		Error StopNavigationTimer(void);

		Error InitNavigationTimer(DWORD time, WORD pgcn);
		Error QueryNavigationTimer(DWORD & time, BOOL & active);
		Error ResetNavigationTimer(void);

		Error PauseNavigationTimer(void);
		Error ResumeNavigationTimer(void);
	};

class DVDPGCSequencer : public DVDSequencer, public DVDNavigationControl, public DVDHighlightControl, virtual protected EventSender
	{
	private:
		DWORD	currentBitrate;	// Please use the Set/Get methods to change this variable
		WORD	scanSpeed;			// Please use the Set/Get methods to change this variable

		Error SetScanSpeed(WORD speed);

	protected:
		DVDPlayer * player;
	   DVDNavigationProcessor * navpu;
		DVDVideoStreamServer * streamServer;

	   DVDOBS		*	vobs;
	   DVDGenericPGCI		*	pgci;

	   WORD 				currentPG, numPG;
	   WORD 				currentCell, finalCell, numCell;
	   WORD 				loopCnt, playingLoopCnt;
	   BYTE 				playbackMode;

		WORD				vobuCellCompletionDelay;

	   DVDTime			cellTime;
		DVDTime		*	cellTimes;

	   BOOL 				playbackDone;
	   BOOL			*	shuffleHistory;
		BOOL			*	playbackShuffleHistory;

	   DVDCell		*	stillCell;

	   WORD				playingCell;
	   WORD				playingPG;
	   DWORD				playingVOBU, nextVOBU;
	   DWORD				vobuUOPs, pgciUOPs;

		DVDNavigationTimer	navigationTimer;


	   WORD				angle;
		WORD				playingAngle;
		BOOL				isMultiAngleScene;
		BOOL				streaming;

   	WORD				resumeCell;
   	DWORD				resumeVOBU;
   	WORD				resumeLoopCnt;
		BOOL				resumeNavtimerActive;
		DWORD				resumeNavtimerTime;

		DisplayPresentationMode	currentPresentationMode;
		DisplayPresentationMode	requestedPresentationMode;
		DWORD				audioStreamSelectionPreferences;

	   enum State
	   	{
	   	pgcs_idle,						// 0
	   	pgcs_preCommand,				// 1
	   	pgcs_cellPlayback,			// 2
	   	pgcs_vobuStill,				// 3
	   	pgcs_cellStill,				// 4
	   	pgcs_cellCommand,				// 5
	   	pgcs_pgcStill,					// 6
	   	pgcs_postCommand,				// 7
	   	pgcs_scanForward,				// 8
	   	pgcs_scanBackward,			// 9
	   	pgcs_navigating,				// A
			pgcs_cellPlaybackReverse,	// B
			pgcs_cellTrickPlay,			// C
			pgcs_aborting,					// D
			pgcs_paused,					// E
			pgcs_awaitingPMLChange		// F
	   	} state, externalState;  // Please do not use "state" directly but use the Set/Get methods below

		// This enum describes the function to be called after a new PML has been set by the app.
		// pmlDeferLocation is only valid when in state pgcs_awaitingPMLChange
		enum PMLDeferLocation { PDL_NONE, PDL_STARTPGC, PDL_COMPLETEPGC, PDL_GOTOPPGC } pmlDeferLocation;
		int  awaitPMLChangePC;
		WORD requestedPML;

		DVDPGCSequencer::State GetState(void)					{return state;}
		DVDPGCSequencer::State GetExternalState(void)		{return externalState;}
		void	SetState(DVDPGCSequencer::State newState);
		BOOL IsInternalState(DVDPGCSequencer::State state);

		BOOL IsStillCell(void);
		Error IsFinalCell(WORD program, WORD cell, BOOL & isFinalCell);

		Error StartProgram(void);
		Error AdvanceCell(void);
		Error SuccCell(DVDGenericPGCI * pgci, WORD angle, WORD & cell, DVDCPBI & cpbi);
		Error PredCell(DVDGenericPGCI * pgci, WORD angle, WORD & cell, DVDCPBI & cpbi);
		Error StartCell(WORD cell, DWORD vobu = 0);
		Error StartCellAt(WORD cell, DVDTime time);
		Error SendNextCell(void);
		Error SendNextProgram(void);
		Error HasNextProgram(BOOL & hasNextProg);
		Error CompletePGCPlayback(void);
		Error PrepareNavigation(void);
		Error PrepareNavigationAccurate(void);

		Error VOBUStarted(DVDVOBU * vobu);
		Error VOBUCompleted(DVDVOBU * vobu);

      Error CellStarted(DVDCell * cell);
      Error CellCompleted(DVDCell * cell);
		Error CellCorrupt(DVDCell * cell);

		Error PlaybackTerminated(Error err);

      virtual Error PGCCompleted(DVDGenericPGCI * pgci) {GNRAISE_OK;}

      virtual Error StartStillPhase(WORD delay); // calls StillPhaseCompleted() after delay secs
      virtual Error CancelStillPhase(void) = 0;

      Error StillPhaseCompleted(void);

		Error GetCurrentPlayingProgram(WORD & pg);

		WORD CurrentAngle(void) { return angle; }
		WORD GetPlayingAngle(BOOL isMultiangle) { return (isMultiangle ? playingAngle:1); }
		virtual void AngleChanged(void);

		Error BuildCellTimes(DVDGenericPGCI * pgci, DVDTime * & times, WORD cellNum);

		Error DoActivateButton(void);

		virtual Error SelectAudioStream(WORD & strm);
		virtual Error SelectSPUStream(WORD & strm, BOOL & enable);
		virtual Error SelectDisplayPresentationMode(DisplayPresentationMode & mode);

		virtual Error PerformStreamChange(void);
		virtual Error PerformAudioStreamChange(void);
		virtual Error PerformSPUStreamChange(void);

		virtual Error SetStreamParameters(void);
		virtual Error SetAudioStreamParameters(void);
		virtual Error SetSPUStreamParameters(void);

		virtual Error AngleChange(void);

		virtual Error CheckTitleChange(void) = 0;
		virtual void  StateChanged(void)= 0;

		//
		//  Breakpoint handling
		//

		virtual BOOL EndOfPGCBreakpointReached(ERSPlaybackDir dir, ERSBreakpoint & bp) = 0;
		virtual BOOL EndOfCellBreakpointReached(DVDCell * cell, ERSPlaybackDir dir, ERSBreakpoint & bp);
		virtual BOOL EndOfPGBreakpointReached(WORD pgn, ERSPlaybackDir dir, ERSBreakpoint & bp) = 0;
		virtual BOOL BeginOfCellBreakpointReached(DVDCell * cell, ERSPlaybackDir dir, ERSBreakpoint & bp);
		virtual BOOL BeginOfPGBreakpointReached(WORD pgn, ERSPlaybackDir dir, ERSBreakpoint & bp) = 0;
		virtual void StartBreakpointStillCallback(void);

		State breakpointStillState;		// The still state in which the breakpoint leads
		ERSBreakpoint breakpoint;			// The breakpoint we reached
		DWORD restartVOBU;					// This VOBU must be restarted after stilling at a breakpoint
		WORD restartCell;						// This cell must be restarted after stilling at a breakpoint
		BOOL programStarted;					// This is set by StartProgram to prevent BeginOfPTT breakpoints from
													// triggering in the middle of a cell

		//
		//  Parental Management
		//

		void	SetAwaitPMLChangeState(PMLDeferLocation deferLoc, int pc);

		//
		//  Freezing stuff
		//

		class DVDPGCSFreezeState
			{
			public:
				WORD 		loopCnt;

				WORD		vobuCellCompletionDelay;

				DVDTime	cellTime;

				BOOL 		playbackDone;

				BOOL		shuffleHistoryExists;
				DWORD		shuffleHistory[4];

				WORD		playingCell;

				WORD		angle;

   			WORD		resumeCell;
   			DWORD		resumeVOBU;
   			WORD		resumeLoopCnt;
				BOOL		resumeNavtimerActive;
				DWORD		resumeNavtimerTime;

				BOOL		navtimerActive;
				DWORD		navtimerTime;

				DVDHCFreezeState hcFreezeState;
				DVDNavigationProcessor::DVDNPFreezeState npFreezeState;
			};

		Error Freeze (DVDPGCSFreezeState & state);
		Error Defrost(DVDPGCSFreezeState & state, DVDOBS * vobs, DVDGenericPGCI * pgci, DVDDomain domain, DWORD flags);

	public:
	   DVDPGCSequencer(WinPortServer * server, UnitSet units, EventDispatcher * eventDispatcher);
		virtual ~DVDPGCSequencer(void);

		Error Init(DVDFileSystem * dvdfs);

	   virtual Error GetCurrentLocation(DVDLocation & loc);
	   virtual Error GetCurrentDuration(DVDLocation & loc);

	   virtual Error GetUOPs(DWORD & uops);
	   virtual Error UOPPermitted(int uop, BOOL & permitted);
	   BOOL IsScanning(void) {return GetExternalState() == pgcs_scanForward || GetExternalState() == pgcs_scanBackward;}
		BOOL IsReversePlayback(void) {return GetExternalState() == pgcs_cellPlaybackReverse;}
		BOOL IsTrickPlay(void) {return GetExternalState() == pgcs_cellTrickPlay; }
		BOOL IsStill(void) {return GetExternalState() == pgcs_cellStill || GetExternalState() == pgcs_vobuStill ||
			                        GetExternalState() == pgcs_pgcStill;}
		BOOL IsPaused(void) {return GetExternalState() == pgcs_paused;}
		virtual BOOL IsPlayingForward(void);
		BOOL IsMultiAngleScene(void) {return isMultiAngleScene;}

		Error StartPGCPlayback(DVDOBS * vobs, DVDGenericPGCI * pgci, WORD program, BOOL skipPreCommands = FALSE, BOOL toPause = FALSE);
		Error StartPGCPlaybackWithTime(DVDOBS * vobs, DVDGenericPGCI * pgci, DVDTime timeOffset, BOOL skipPreCommands = FALSE, BOOL toPause = FALSE);
		Error StartPGCPlaybackWithParentalLevel(DVDGenericPGCI * pgci);
		Error StopPGCPlayback(void);
		Error	AccessRestricted(DVDGenericPGCI * pgci, DVDTime time, BOOL & restricted);

		virtual Error Exit(Error err = GNR_OK) {GNRAISE_OK;}

		Error StartForwardScan(WORD speed);
		Error StartBackwardScan(WORD speed);
		Error StartReversePlayback(void);
		Error StartTrickPlayback(void);
		Error StopScan(BOOL toPause);
		WORD	GetScanSpeed(void) { return scanSpeed; }
		Error Pause(void);
		Error Resume(void);

		Error	GetSPRM(int index, WORD & val);
		Error SetSPRM(int index, WORD val);

		Error GoProgram(WORD pgn);
		Error GoCell(WORD cell);
		Error GoPrevProgram(void);
		Error GoNextProgram(void);
		Error GoTopProgram(void);
		Error GoPrevCell(void);
		Error GoNextCell(void);
		Error GoTopCell(void);
		Error GoTopProgramChain(void);
		Error GoTailProgramChain(void);
		virtual Error GoProgramChain(WORD pgcn) = 0;

		Error ResumeFromSystemSpace(DVDOBS * vobs, DVDGenericPGCI * pgci);
		virtual Error SaveResumeInformation(void);

		DisplayPresentationMode GetCurrentDisplayMode(void) {return currentPresentationMode;}
		Error SetDisplayMode(DisplayPresentationMode mode);
		Error SetAudioStreamSelectionPreferences(DWORD flags);

		void	CurrentBitrateSet(DWORD currentBitrate)
			{
			if (currentBitrate != this->currentBitrate)
				SendEvent(DNE_BITRATE_CHANGE, currentBitrate);
			this->currentBitrate = currentBitrate;
			}
		DWORD	CurrentBitrate() { return currentBitrate; }

		virtual PMLHandling PMLChangeAllowed(void);
		Error ParentalLevelSelect(WORD level);
		Error SetEventHandler(DWORD event, DNEEventHandler handler, void * userData);
	};

#pragma warning(default : 4250)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\dvdpgcseq.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
//  DVD Program Chain Sequencer Implementation
//
//////////////////////////////////////////////////////////////////////

#include "DVDPGCSeq.h"
#include "Library\Common\vddebug.h"
#include "Library\lowlevel\timer.h"

//////////////////////////////////////////////////////////////////////
//
//  Navigation Timer Class
//
//////////////////////////////////////////////////////////////////////

DVDNavigationTimer::DVDNavigationTimer(WinPortServer * server, DVDNavigationControl * navControl)
	: WinPort(server)
	{
	this->navControl = navControl;
	active = FALSE;
	paused = FALSE;
	started = FALSE;
	}

DVDNavigationTimer::~DVDNavigationTimer(void)
	{
	}

Error DVDNavigationTimer::InitNavigationTimer(DWORD time, WORD pgcn)
	{
	CancelTimer();
	FlushMessages();

	active = TRUE;

	this->pgcn = pgcn;
	this->time = time;

	if (started)
		{
		ScheduleTimer(1000, time);

		time = Timer.GetMilliTicks() + time;
		}

	GNRAISE_OK;
	}

void DVDNavigationTimer::Message (WPARAM wParam, LPARAM lParam)
	{
	if (active)
		{
		active = FALSE;
		started = FALSE;
		navControl->GoProgramChain(pgcn);
		}
	}

Error DVDNavigationTimer::StartNavigationTimer(void)
	{
	if (!started && active && !paused)
		{
		started = TRUE;

		ScheduleTimer(1000, time);

		time = Timer.GetMilliTicks() + time;

		GNRAISE_OK;
		}
	else
		{
		started = TRUE;

		GNRAISE_OK;
		}
	}

Error DVDNavigationTimer::StopNavigationTimer(void)
	{
	if (started && active && !paused)
		{
		time = time - Timer.GetMilliTicks();

		CancelTimer();
		FlushMessages();
		}

	started = FALSE;

	GNRAISE_OK;
	}

Error DVDNavigationTimer::ResetNavigationTimer(void)
	{
	this->active = FALSE;
	this->paused = FALSE;
	CancelTimer();
	FlushMessages();

	GNRAISE_OK;
	}

Error DVDNavigationTimer::QueryNavigationTimer(DWORD & time, BOOL & active)
	{
	active = this->active;

	if (this->active)
		{
		if (paused || !started)
			time = this->time;
		else
			time = this->time - Timer.GetMilliTicks();
		}
	else
		time = 0;

	GNRAISE_OK;
	}

Error DVDNavigationTimer::PauseNavigationTimer(void)
	{
	if (active && !paused)
		{
		paused = true;
		CancelTimer();
		FlushMessages();

		if (started)
			time = time - Timer.GetMilliTicks();
		}

	GNRAISE_OK;
	}

Error DVDNavigationTimer::ResumeNavigationTimer(void)
	{
	if (active && paused)
		{
		paused = false;

		if (started)
			{
			ScheduleTimer(1000, time);

			time = time + Timer.GetMilliTicks();
			}
		}

	GNRAISE_OK;
	}

////////////////////////////////////////////////////////////////////
//
//  Program Chain Sequencer
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

#pragma warning(disable : 4355)
DVDPGCSequencer::DVDPGCSequencer (WinPortServer * server, UnitSet units, EventDispatcher * eventDispatcher)
	: DVDSequencer(eventDispatcher)
	, DVDNavigationControl()
	, DVDHighlightControl()
	, EventSender(eventDispatcher)
	, ERSBreakpointControl(eventDispatcher)
	, navigationTimer(server, this)
	{
	SetState(pgcs_idle);
	shuffleHistory = NULL;
	playbackShuffleHistory = NULL;
	cellTimes = NULL;
	angle = 1;
	playingAngle = 1;
	requestedPresentationMode = DPM_16BY9;
	scanSpeed = 1;
	pmlHandling = PMH_COMPATIBLE;
	breakpointStillState = pgcs_idle;
	isMultiAngleScene = FALSE;
	streaming = FALSE;
	navpu = NULL;
	state = pgcs_idle;
	audioStreamSelectionPreferences = 0;

	resumeNavtimerActive = FALSE;
	resumeNavtimerTime = 0;

	//
	//  Create stream server
	//
	streamServer = new DVDVideoStreamServer(this, server, units, pEventDispatcher);
	}
#pragma warning(default : 4355)

//
//  Destructor
//

DVDPGCSequencer::~DVDPGCSequencer(void)
	{
	delete[] shuffleHistory;
	delete[] playbackShuffleHistory;
	delete[] cellTimes;

	if (navpu)
		{
		delete navpu;
		navpu = NULL;
		}

	if (streamServer)
		{
		delete streamServer;
		streamServer = NULL;
		}
	}

//
//  Init
//

Error DVDPGCSequencer::Init(DVDFileSystem * dvdfs)
	{
	if (!streamServer)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	GNREASSERT(streamServer->Init(dvdfs));
	DVDPGCSequencer::player = (DVDPlayer*)streamServer->GetStreamPlayer();

	//
	//  Create navigation processor
	//

	navpu = new DVDNavigationProcessor();
	if (!navpu)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	navpu->SetNavigationControl(this);

	return DVDHighlightControl::Init(player, navpu);
	}

//
//  Playback terminated
//

Error DVDPGCSequencer::PlaybackTerminated(Error err)
	{
	Exit(err);

	GNRAISE_OK;
	}

//
//  VOBU Started
//

Error DVDPGCSequencer::VOBUStarted(DVDVOBU * vobu)
	{
	DWORD duration;

	playingVOBU = vobu->firstBlock;
	if (vobu->final)
		nextVOBU = playingVOBU;
	else
		nextVOBU = vobu->NextVOBU();

	if (GetState() != pgcs_aborting)
		{
		cellTime = vobu->GetTimeOffset();

		vobuUOPs = vobu->GetPCIDWord(0x08) & 0x01fdfff8;

		if (!vobu->singleFrame)
			GNREASSERT(StartHighlight(vobu));

		duration = vobu->GetPCIDWord(16) - vobu->GetPCIDWord(12);

		if (duration)
			{
//			DP("ILVU Pos %8d BitRate %8d ILVU Size %8d", vobu->GetDSIDWord(4), ScaleDWord(vobu->numBlocks * DVD_BLOCK_SIZE * 8, duration, 90000), vobu->GetDSIDWord(32+2));
			CurrentBitrateSet(ScaleDWord(vobu->numBlocks * DVD_BLOCK_SIZE * 8, duration, 90000));
			}
		else
			CurrentBitrateSet(0);
		}

	GNRAISE_OK;
	}

//
//  VOBU Completed
//

Error DVDPGCSequencer::VOBUCompleted(DVDVOBU * vobu)
	{
	BOOL				bpReached;
	BOOL				pauseBreakpoint = FALSE;
	Error				err = GNR_OK;

	if (GetState() != pgcs_aborting)
		{
		//
		//  Test breakpoint location
		//

		bpReached = BP_VALID(vobu->breakpoint);
		if (bpReached)
			{
			DP("Breakpoint reached");
			breakpoint = vobu->breakpoint;
			if (BP_TOSTILL(breakpoint.flags))
				{
				breakpointStillState = pgcs_vobuStill;
				pauseBreakpoint = TRUE;

				//
				//  Compute proper VOBU for restarting with StillOff() after reaching breakpoint
				//  While scanning forward we stop a VOBU to late which prevents to much jumping at still off (For AB repeat)
				//

				if (nextVOBU == playingVOBU)
					{
					if (IsPlayingForward())
						{
						//
						//  On last VOBU of cell we go to next cell or next pgc
						//

						if (playingCell < finalCell)
							{
							restartVOBU = 0;
							restartCell = vobu->cell->num + 1;
							}
						else
							breakpointStillState = pgcs_pgcStill;
						}
					else
						{
						restartVOBU = playingVOBU;
						restartCell = playingCell;
						}
					}
				else
					{
					if (GetState() == pgcs_scanForward)
						restartVOBU = playingVOBU;
					else
						restartVOBU = nextVOBU;
					restartCell = vobu->cell->num;
					}

				cellTime =  vobu->GetTimeOffset() + DVDTime(vobu->GetPCIDWord(16) - vobu->GetPCIDWord(12), 90, breakpoint.time.FrameRate());
				}
			}

		//
		//  Complete VOBU
		//

		if (vobu->singleFrame)
			{
			err = streamServer->ReturnVOBU(vobu);
			}
		else
   		{
			if (vobu->numBlocks == 1)
				vobuCellCompletionDelay++;

			if (!vobuCellCompletionDelay)
				GNREASSERT(CompleteHighlight(vobu));

			if (!pauseBreakpoint)
				{
				if (vobu->still)
					{
					SetState(pgcs_vobuStill);

					err = StartStillPhase(255);
					}
				}

			err = streamServer->ReturnVOBU(vobu);
			}

		if (bpReached)
			ExecuteBreakpoint(breakpoint.id);
		}

	GNRAISE(err);
	}

//
//  Generate random number
//

static WORD Rnd(WORD max)
	{
	static DWORD seed = Timer.GetMilliTicks();

	seed = 1664525L * seed + 1013904223L;
	return (WORD)(seed % max) + 1;
	}

//
//  Test if cell is still cell
//

BOOL DVDPGCSequencer::IsStillCell(void)
	{
	if (GetState() == pgcs_scanBackward || GetState() == pgcs_cellPlaybackReverse)
		{
		if (currentCell < finalCell)
			return (currentPG == 1 && (playbackMode == 0 || loopCnt == 1));
		}
	else
		{
		if (currentCell > finalCell)
			return (currentPG == numPG && (playbackMode == 0 || loopCnt == 1));
		}

	return FALSE;
	}

//
//	Test if cell is final cell of program
//

Error DVDPGCSequencer::IsFinalCell(WORD program, WORD cell, BOOL & isFinalCell)
	{
	WORD finalCell;
	DVDCPBI cpbi;
	WORD firstAngleCell;
	WORD lastAngleCell;
	WORD angleCell;

	GNREASSERT(pgci->GetCellInformation(cell, cpbi));

	//
	//	Search angle block for first and last Cell
	//

	if (cpbi.BlockType() == CBT_ANGLE_BLOCK)
		{
		angleCell = cell;
		while (cpbi.BlockMode() != CBM_FIRST_CELL_IN_BLOCK)
			{
			angleCell--;
			GNREASSERT(pgci->GetCellInformation(angleCell, cpbi));
			}
		firstAngleCell = angleCell;
		angleCell = cell;
		while (cpbi.BlockMode() != CBM_LAST_CELL_IN_BLOCK)
			{
			angleCell++;
			GNREASSERT(pgci->GetCellInformation(angleCell, cpbi));
			}
		lastAngleCell = angleCell;

		if (cell >= firstAngleCell && cell <= lastAngleCell)
			isFinalCell = TRUE;
		else
			isFinalCell = FALSE;
		}
	else
		{
		GNREASSERT(pgci->GetLastCellOfProgram(program, finalCell));

		isFinalCell = (cell == finalCell);
		}

	GNRAISE_OK;
	}

//
//  Go to next cell in playback direction
//

Error DVDPGCSequencer::AdvanceCell(void)
	{
	DVDNavigationCommand	* cmds;
	DVDCPBI cpbi;
	int cmd;

	GNREASSERT(pgci->GetCellInformation(currentCell, cpbi));

	//
	//  Search angle block for first/last Cell
	//

	if (cpbi.BlockType() == CBT_ANGLE_BLOCK)
		{
		if (GetState() == pgcs_scanBackward || GetState() == pgcs_cellPlaybackReverse)
			{
			while (cpbi.BlockMode() != CBM_FIRST_CELL_IN_BLOCK)
				{
				currentCell--;
				GNREASSERT(pgci->GetCellInformation(currentCell, cpbi));
				}
			}
		else
			{
			while (cpbi.BlockMode() != CBM_LAST_CELL_IN_BLOCK)
				{
				currentCell++;
				GNREASSERT(pgci->GetCellInformation(currentCell, cpbi));
				}
			}
		}

	//
	//  Now go back/foward one cell
	//

	if (GetState() == pgcs_scanBackward || GetState() == pgcs_cellPlaybackReverse)
		currentCell--;
	else
		{
		cmd = cpbi.CommandNumber();
		if (cmd)
			{
			pgci->GetCellCommands(cmds);
			if (cmds)
				{
				if (navpu->IsBasicCellLinkCommand(cmds[cmd-1]))
					{
					navpu->GetBasicCellLinkTarget(cmds[cmd-1], currentCell);
					}
				else
					currentCell++;
				}
			}
		else
			currentCell++;
		}

	GNRAISE_OK;
	}

//
//  Compute successor cell
//

Error DVDPGCSequencer::SuccCell(DVDGenericPGCI * pgci, WORD angle, WORD & cell, DVDCPBI & cpbi)
	{
	DVDNavigationCommand	*	cmds;
	int cmd;

	//
	//  Go to last cell of angle block
	//

	GNREASSERT(pgci->GetCellInformation(cell, cpbi));
	if (cpbi.BlockType() == CBT_ANGLE_BLOCK)
		{
		while (cpbi.BlockMode() != CBM_LAST_CELL_IN_BLOCK)
			{
			cell++;
			GNREASSERT(pgci->GetCellInformation(cell, cpbi));
			}
		}

	//
	//  Now go foward one cell, with respect to cell commands
	//

	cmd = cpbi.CommandNumber();
	if (cmd)
		{
		pgci->GetCellCommands(cmds);
		if (cmds)
			{
			if (navpu->IsBasicCellLinkCommand(cmds[cmd-1]))
				{
				navpu->GetBasicCellLinkTarget(cmds[cmd-1], cell);
				}
			else
				cell++;
			}
		}
	else
		cell++;

	//
	//  Now find proper cell within angle block
	//

	GNREASSERT(pgci->GetCellInformation(cell, cpbi));

	if (cpbi.BlockType() == CBT_ANGLE_BLOCK)
		{
		angle--;
		while (angle && cpbi.BlockMode() != CBM_LAST_CELL_IN_BLOCK)
			{
			angle--;
			cell++;
			GNREASSERT(pgci->GetCellInformation(cell, cpbi));
			}
		}

	GNRAISE_OK;
	}

//
//  Compute predecessor cell
//

Error DVDPGCSequencer::PredCell(DVDGenericPGCI * pgci, WORD angle, WORD & cell, DVDCPBI & cpbi)
	{
	GNREASSERT(pgci->GetCellInformation(cell, cpbi));
	if (cpbi.BlockType() == CBT_ANGLE_BLOCK)
		{
		while (cpbi.BlockMode() != CBM_FIRST_CELL_IN_BLOCK)
			{
			cell--;
			GNREASSERT(pgci->GetCellInformation(cell, cpbi));
			}
		}
	cell--;

	//
	//  Find proper cell within angle block
	//

	GNREASSERT(pgci->GetCellInformation(cell, cpbi));

	if (cpbi.BlockType() == CBT_ANGLE_BLOCK)
		{
		//
		//  Go to first cell
		//

		while (cpbi.BlockMode() != CBM_FIRST_CELL_IN_BLOCK)
			{
			cell--;
			GNREASSERT(pgci->GetCellInformation(cell, cpbi));
			}

		//
		//  From there search for proper angle
		//

		angle--;
		while (angle && cpbi.BlockMode() != CBM_LAST_CELL_IN_BLOCK)
			{
			angle--;
			cell++;
			GNREASSERT(pgci->GetCellInformation(cell, cpbi));
			}
		}

	GNRAISE_OK;
	}

//
//  Start Cell Playback
//

Error DVDPGCSequencer::StartCell(WORD cell, DWORD vobu)
	{
	BOOL still = FALSE;
	WORD num;
	WORD next;
	DVDCPBI cpbi;
	WORD program;
	WORD finalCell;
	BOOL isFinalCell = FALSE;

	//
	//  Find proper cell for angle
	//

	DP("Starting Cell %d VOBU %d, Angle %d", cell, vobu, angle);
	GNREASSERT(pgci->GetCellInformation(cell, cpbi));

	if (cpbi.BlockType() == CBT_ANGLE_BLOCK)
		{
		while (cpbi.BlockMode() != CBM_FIRST_CELL_IN_BLOCK)
			{
			cell--;
			GNREASSERT(pgci->GetCellInformation(cell, cpbi));
			}
		num = 1;
		while (cpbi.BlockMode() != CBM_LAST_CELL_IN_BLOCK && num < angle)
			{
			num++;
			cell++;
			GNREASSERT(pgci->GetCellInformation(cell, cpbi));
			}
		}

	currentCell = cell;
	playingAngle = angle;

	if (!streaming)
		{
		DP("Initial playing cell %d to %d", playingCell, cell);
		playingCell = cell;
		streaming = TRUE;
		if (!vobu) cellTime = 0;
		}

	GNREASSERT(AdvanceCell());

	//
	//  Now start cell
	//

	still = IsStillCell();
	playbackDone = FALSE;

	next = cell;

	GNREASSERT(pgci->GetProgramOfCell(cell, program));

	switch (GetState())
		{
		case pgcs_scanForward:
			SuccCell(pgci, angle, next, cpbi);
			still |= cpbi.AccessRestricted();
			GNREASSERT(IsFinalCell(program, cell, isFinalCell));
			GNREASSERT(streamServer->TransferCellScan(pgci, cell, still, isFinalCell, cellTimes[cell - 1], TRUE, 0, scanSpeed, vobu));
			break;

		case pgcs_scanBackward:
			PredCell(pgci, angle, next, cpbi);
			still |= cpbi.AccessRestricted();
			GNREASSERT(pgci->GetFirstCellOfProgram(program, finalCell));
			GNREASSERT(streamServer->TransferCellScan(pgci, cell, still, cell == finalCell, cellTimes[cell - 1], FALSE, 0, scanSpeed, vobu));
			break;

		case pgcs_cellPlaybackReverse:
			PredCell(pgci, angle, next, cpbi);
			still |= cpbi.AccessRestricted();
			GNREASSERT(pgci->GetFirstCellOfProgram(program, finalCell));
			GNREASSERT(streamServer->TransferCellReverse(pgci, cell, still, cell == finalCell, cellTimes[cell - 1], vobu));
			break;

		case pgcs_cellTrickPlay:
			break;	// Intended do-nothing

		default:
			GNREASSERT(IsFinalCell(program, cell, isFinalCell));
			GNREASSERT(streamServer->TransferCell(pgci, cell, still, isFinalCell, cellTimes[cell - 1], vobu, angle));
			break;
		}

	//
	//  Send Title Change Event
	//

	GNRAISE(CheckTitleChange());
	}

//
//  Start cell playback at certain time (always pgcs_cellPlayback)
//  NOTE: Here we do not care about "CellAccessRestricted" flag since this
//  has to be checked before calling this function
//

Error DVDPGCSequencer::StartCellAt(WORD cell, DVDTime time)
	{
	BOOL still = FALSE;
	WORD num;
	DVDCPBI cpbi;
	WORD program;
	WORD lastCell;

//	DP("Starting Cell %d with angle %d", cell, angle);
	GNREASSERT(pgci->GetCellInformation(cell, cpbi));

	if (cpbi.BlockType() == CBT_ANGLE_BLOCK)
		{
		//
		//  Find proper angle
		//

		while (cpbi.BlockMode() != CBM_FIRST_CELL_IN_BLOCK)
			{
			cell--;
			GNREASSERT(pgci->GetCellInformation(cell, cpbi));
			}
		num = 1;
		while (cpbi.BlockMode() != CBM_LAST_CELL_IN_BLOCK && num < angle)
			{
			num++;
			cell++;
			GNREASSERT(pgci->GetCellInformation(cell, cpbi));
			}
		currentCell = cell;
		}

	if (!streaming)
		{
		DP("Initial playing cell at %d to %d", playingCell, cell);
		playingCell = cell;
		streaming = TRUE;
		}
	playingAngle = angle;

	GNREASSERT(AdvanceCell());

	still = IsStillCell();

	GNREASSERT(pgci->GetProgramOfCell(cell, program));
	GNREASSERT(pgci->GetLastCellOfProgram(program, lastCell));

	GNREASSERT(streamServer->TransferCellAt(pgci, cell, still, cell == lastCell, cellTimes[cell - 1], time));

	GNRAISE(CheckTitleChange());
	}

//
//  Start Program Playback
//
//  GNR_OK
//

Error DVDPGCSequencer::StartProgram(void)
	{
	WORD firstCell;
	WORD numCells;
	playbackDone = FALSE;
	programStarted = TRUE;

	GNREASSERT(pgci->GetFirstCellOfProgram(currentPG, firstCell));
	GNREASSERT(pgci->GetNumberOfCellsInProgram(currentPG, numCells));

	if (GetState() == pgcs_scanBackward || GetState() == pgcs_cellPlaybackReverse)
		{
		currentCell = firstCell + numCells - 1;		// Start with the last one
		finalCell = firstCell;
		}
	else
		{
		currentCell = firstCell;
		finalCell = currentCell + numCells - 1;
		}

	playingPG = currentPG;
	StartCell(currentCell);

	GNRAISE_OK;
	}

//
//  Send next cell
//

Error DVDPGCSequencer::SendNextCell(void)
	{
	if (!playbackDone)
		{
		if (GetState() != pgcs_cellTrickPlay)
			{
			if (GetState() == pgcs_scanBackward || GetState() == pgcs_cellPlaybackReverse)
				{
				if (currentCell >= finalCell)
					GNRAISE(StartCell(currentCell));
				else
					GNRAISE(SendNextProgram());
				}
			else
				{
				if (currentCell <= finalCell)
					GNRAISE(StartCell(currentCell));
				else
					GNRAISE(SendNextProgram());
				}
			}
		else
			GNRAISE_OK;
		}
	else
		GNRAISE_OK;
	}

//
//  Has next program
//

Error DVDPGCSequencer::HasNextProgram(BOOL & hasNextProg)
	{
	WORD prog;

	if (!playbackDone)
		{
		if (playbackMode == 0)
			{
			GNREASSERT(pgci->GetProgramOfCell(playingCell, prog));

			if (GetState() == pgcs_scanBackward || GetState() == pgcs_cellPlaybackReverse)
				{
				hasNextProg = prog > 1;
				}
			else
				{
				hasNextProg = prog < numPG;
				}
			}
		else if (playbackMode & 0x80)
			{
			hasNextProg = loopCnt > 1;
			}
		else
			{
			hasNextProg = loopCnt > 1;
			}
		}
	else
		hasNextProg = FALSE;

	GNRAISE_OK;
	}

//
//  Send next program
//

Error DVDPGCSequencer::SendNextProgram(void)
	{
	int i;

	if (!playbackDone)
		{
		if (playbackMode == 0)  // Normal playback
			{
			if (IsPlayingForward())
				{
				currentPG++;
				if (currentPG <= numPG)
					StartProgram();
				else
					playbackDone = TRUE;
				}
			else
				{
				currentPG--;
				if (currentPG >= 1)
					StartProgram();
				else
					playbackDone = TRUE;
				}
			}
		else if (playbackMode & 0x80)  // Shuffle mode
			{
			loopCnt--;
			if (loopCnt)
				{
				BOOL allDone = TRUE;

				for(i=0; i<numPG; i++)
					allDone &= shuffleHistory[i];

				if (allDone)
					{
					for(i=0; i<numPG; i++)
						shuffleHistory[i] = FALSE;
					}

				do {
					currentPG = Rnd(numPG);
					} while (shuffleHistory[currentPG-1]);
				shuffleHistory[currentPG-1] = TRUE;

				StartProgram();
				}
			else
				playbackDone = TRUE;
			}
		else  // Random playback
			{
			loopCnt--;
			if (loopCnt)
				{
				currentPG = Rnd(numPG);
				StartProgram();
				}
			else
				playbackDone = TRUE;
			}
		}

	GNRAISE_OK;
	}

//
//  Cell started
//

Error DVDPGCSequencer::CellStarted(DVDCell * cell)
	{
	int i;
	BOOL first = programStarted;

//	DP("Cell Started: Curr %d Play %d Start %d", currentCell, playingCell, cell->num);
	vobuCellCompletionDelay = 0;
	playingCell = cell->num;
	playingLoopCnt = loopCnt;
	if (shuffleHistory && playbackShuffleHistory)
		{
		for (i=0; i<numPG; i++)
			playbackShuffleHistory[i] = shuffleHistory[i];
		}
	isMultiAngleScene = cell->IsMultiAngleCell();
	programStarted = FALSE;

	if (GetState() != pgcs_aborting)
		{
		//
		//  Check if we reached breakpoint
		//

		if (first && BP_VALID(cell->breakpoint))
			{
			if (BP_TOSTILL(cell->breakpoint.flags))
				{
				breakpointStillState = pgcs_vobuStill;
				stillCell = cell;
				restartCell = cell->num;
				restartVOBU = 0;
				}

			ExecuteBreakpoint(cell->breakpoint.id);
			GNRAISE_OK;
			}

		GNREASSERT(SendNextCell());
		}

	GNRAISE_OK;
	}

//
//  Cell completed
//

Error DVDPGCSequencer::CellCorrupt(DVDCell * cell)
	{
	DP("Advancing To Next Cell+");
	if (GoNextCell() == GNR_RANGE_VIOLATION)
		GoNextProgram();

	DP("Advancing To Next Cell-");

	GNRAISE_OK;
	}

Error DVDPGCSequencer::CellCompleted(DVDCell * cell)
	{
	WORD next = cell->num;
	DVDCPBI cpbi;

//	DP("Cell Completed: %d", cell->num);
	if (GetState() != pgcs_aborting)
		{
		//
		//  Test if we reached breakpoint
		//

		if (BP_VALID(cell->breakpoint))
			{
			if (BP_TOSTILL(cell->breakpoint.flags))
				breakpointStillState = pgcs_cellStill;

			ExecuteBreakpoint(cell->breakpoint.id);
			GNRAISE_OK;
			}

		//
		//  Test Access Restricted flag of next cell during normal playback
		//

		SuccCell(cell->pgci, angle, next, cpbi);
		if (GetState() == pgcs_cellPlayback)
			{
			if (cpbi.AccessRestricted())
				{
				if (player->IsPaused())		// This handles the case when we do single step over cell boundary
					Resume();
				else
					{
					if (player->GetPlaybackSpeed() != 1000)
						player->SetPlaybackSpeed(1000);
					}
				}
			}

		//
		//  Perform still actions (if any)
		//

		if (cell->still)
			{
			//
			//  Test if we reached beginning of PGC or Access Restricted cell during reverse playback
			//

			if (GetState() == pgcs_scanBackward || GetState() == pgcs_cellPlaybackReverse)
				{
				PredCell(cell->pgci, angle, next, cpbi);
				if (cpbi.AccessRestricted())
					{
					DP("Restricted cell access %d to %d", playingCell, cell->num);
					playingCell = cell->num;
					}

				if (GetState() == pgcs_cellPlaybackReverse)
					player->SetPlaybackSpeed(1000);

				StopScan(FALSE);
				}
			else
				{
				WORD timeOut = cell->info.StillTime();

				//
				//  Test Cell Access Restricted flag during forward scan
				//

				if (GetState() == pgcs_scanForward)
					{
					if (cpbi.AccessRestricted())
						{
						StopScan(FALSE);
						GNRAISE_OK;
						}
					}

				//
				//  Perform still actions
				//

				if (cell->info.ContinuousPresentation()) timeOut = 255;

	//				DP("timeOut %d", timeOut);

				if (timeOut < 255)
					{
					timeOut += vobuCellCompletionDelay / 2;
					}

				stillCell = cell;

				SetState(pgcs_cellStill);

				GNREASSERT(StartStillPhase(timeOut));
				}
			}
		else
			{
			GNREASSERT(streamServer->ReturnCell(cell));
			GNREASSERT(CompleteHighlight());
//			GNREASSERT(SendNextCell()); //URG!!
			}
		}

	GNRAISE_OK;
	}


//
//  Start Still Phase
//

Error DVDPGCSequencer::StartStillPhase(WORD delay)
	{
	if (delay > 0)
		{
		SetScanSpeed(1);
		player->SetPlaybackSpeed(1000);
		}
	GNRAISE_OK;
	}

//
//  Still phase completed
//

Error DVDPGCSequencer::StillPhaseCompleted(void)
	{
	int cmd;
	DVDNavigationCommand	*	cmds;
	DVDNavigationProcessor::NavCommandDone dummyDone;
	WORD dummyPML;

	//
	//  Handle breakpoint stills
	//

	if (breakpointStillState == pgcs_vobuStill)
		{
		CancelStillPhase();
		streamServer->AbortTransferAccurate();

//		DP("Still phase completed %d to %d", playingCell, restartCell);
		currentCell = playingCell = restartCell;

		GNREASSERT(pgci->GetProgramOfCell(playingCell, currentPG));
		GNREASSERT(pgci->GetLastCellOfProgram(currentPG, finalCell));

		state = pgcs_cellPlayback;					// Fake for AdvanceCell, but we don't want event here
		AdvanceCell();
		state = pgcs_vobuStill;						// No need for SetState() here, we don't want a change event twice
		externalState = pgcs_vobuStill;

		StartCell(restartCell, restartVOBU);

		player->Resume();
		}
	else if (breakpointStillState == pgcs_pgcStill)
		{
		state = pgcs_pgcStill;
		externalState = pgcs_pgcStill;
		breakpointStillState = pgcs_idle;
		player->Resume();
		}

	//
	//  Handle all other stills
	//

	switch (GetState())
		{
		case pgcs_vobuStill:
//			DP("StillPhaseCompleted: vobu still");
			GNREASSERT(streamServer->CompleteStill());
			if (breakpointStillState != pgcs_idle)
				{
				state = pgcs_cellPlayback;
				externalState = pgcs_cellPlayback;
				breakpointStillState = pgcs_idle;
				}
			break;
		case pgcs_cellStill:
//			DP("StillPhaseCompleted: cell still");
			cmd = stillCell->info.CommandNumber();
			GNREASSERT(streamServer->ReturnCell(stillCell));
			stillCell = NULL;

			//
			//  Perform forced activation of button
			//

			SetState(pgcs_cellCommand);
			GNREASSERT(CompleteHighlight());
			if (GetState() != pgcs_cellCommand)
         	GNRAISE_OK;

			//
			//  Execute cell commands
			//

			if (cmd)
				{
				pgci->GetCellCommands(cmds);
				if (cmds)
					{
					if (!(navpu->IsBasicCellLinkCommand(cmds[cmd-1])))
						{
						//  Here we don't need to check for SetTMPPML command since it is not allowed here
						navpu->InterpretCommand(cmds[cmd-1], cmd, dummyDone, dummyPML);
						if (GetState() != pgcs_cellCommand)
							GNRAISE_OK;
						}
					}
				}

			SetState(pgcs_cellPlayback);
			if (player->IsPaused())		// This handles the case when we do single step over cell boundary
				externalState = pgcs_paused;

//				SendNextCell();
			if (!playbackDone)
				streamServer->CompleteStill();
			else
				{
				BYTE timeOut;

				GNREASSERT(pgci->GetStillTimeValue(timeOut));

				if (EndOfPGCBreakpointReached(EPD_FORWARD, breakpoint))
					{
					if (BP_TOSTILL(breakpoint.flags))
						breakpointStillState = pgcs_pgcStill;
					ExecuteBreakpoint(breakpoint.id);
					}
				else
					breakpoint.flags = 0;

				if (!BP_TOSTILL(breakpoint.flags))
					{
					SetState(pgcs_pgcStill);
					GNREASSERT(StartStillPhase(timeOut));
					}
				}
			break;
		case pgcs_pgcStill:
//			DP("StillPhaseCompleted: pgc still");
			GNREASSERT(streamServer->CompleteStill());
			GNREASSERT(streamServer->AbortTransfer());
			GNREASSERT(CompletePGCPlayback());
			break;
		}

	GNRAISE_OK;
	}


//
//  Return current playing program
//

Error DVDPGCSequencer::GetCurrentPlayingProgram(WORD & pg)
	{
	switch (GetState())
		{
		case pgcs_idle:
			pg = 1;
			break;
		case pgcs_preCommand:
			pg = currentPG;
			break;
		default:
			return pgci->GetProgramOfCell(playingCell, pg);
		}
	GNRAISE_OK;
	}

//
//  Complete PGC playback
//
//  GNR_OK
//  GNR_PARENTAL_LEVEL_TOO_LOW
//  GNR_UNEXPECTED_NAVIGATION_ERROR
//  GNR_ILLEGAL_NAVIGATION_COMMAND
//

Error DVDPGCSequencer::CompletePGCPlayback(void)
	{
	int numCmd, pc;
	DVDNavigationCommand * cmd;
	DVDNavigationProcessor::NavCommandDone done;

	//
	//  Only execute first part if we didn't wait for PML change
	//

	if (state != pgcs_awaitingPMLChange)
		{
		GNREASSERT(CancelHighlight());

		SetState(pgcs_postCommand);

		pc = 1;
		GNREASSERT(pgci->GetPostCommands(numCmd, cmd));	// Always returns GNR_OK
		}
	else
		{
		//
		// Check if PML has been set (this point is never reached if PML handling is PMH_COMPATIBLE)
		//

		if (pmlHandling == PMH_DEFER_CHANGE)
			GNRAISE(GNR_PARENTAL_LEVEL_TOO_LOW);

		SetState(pgcs_postCommand);
		pc = awaitPMLChangePC;
		GNREASSERT(pgci->GetPostCommands(numCmd, cmd));	// numCmd is at least 1 (because of SetTMPPML), always returns GNR_OK
		}

	//
	//  Execute post commands and send "playback completed"
	//

	if (numCmd)
		{
		//
		// Execute post commands and wait in case of SetTMPPML request
		//

		GNREASSERT(navpu->InterpretCommandList(cmd, pc, numCmd, done, requestedPML));
		if (done == DVDNavigationProcessor::NCD_SETTMPPML_DEFERED)
			{
			SetAwaitPMLChangeState(PDL_COMPLETEPGC, pc);
			GNRAISE_OK;
			}
		}

	if (GetState() == pgcs_postCommand)
		{
		SetState(pgcs_idle);
		PGCCompleted(pgci);
		}

	GNRAISE_OK;
	}

//
//  Do activate button
//

Error DVDPGCSequencer::DoActivateButton(void)
	{
	GNREASSERT(DVDHighlightControl::DoActivateButton());
	if (buttonActivated && GetState() == pgcs_cellStill)
		{
		GNREASSERT(CancelStillPhase());
		GNREASSERT(StillPhaseCompleted());
		SendEvent(DNE_STILL_OFF, 0);
		}

	GNRAISE_OK;
	}

Error DVDPGCSequencer::SetAudioStreamSelectionPreferences(DWORD flags)
	{
	audioStreamSelectionPreferences = flags;

	GNRAISE_OK;
	}

//
//  Select audio stream
//
Error DVDPGCSequencer::SelectAudioStream(WORD & strm)
	{
	WORD num;						// Number of audio streams
	WORD attr;
	WORD ctrl;						// Audio stream control information
	WORD language, extension;  // Language and extension
	WORD appInfo;					// Application Information
	WORD reqlang, reqextend;	// Requested language and extension
	WORD potentialStreams, i;
	WORD tattr, tlanguage, textension, tappInfo;

	//
	//  Get current audio stream and check if it is available
	//  (Note: This selection algo is described in DVD Spec Chapter 3.3.9)
	//

	GNREASSERT(GetSPRM(1, strm));
	GNREASSERT(pgci->GetAudioStreamControl(strm, ctrl));

	if (!XTBF(15, ctrl))
		{
		//
		//  Stream is not available
		//

		potentialStreams = 0;

		GNREASSERT(vobs->GetNumberOfAudioStreams(num));
		GNREASSERT(GetSPRM(16, reqlang));
		GNREASSERT(GetSPRM(17, reqextend));

		//
		//  Find all stream which match exactly the requested one
		//

		for (strm=0; strm<num; strm++)
			{
			GNREASSERT(vobs->GetAudioStreamAttribute(strm, attr, language, extension, appInfo));
			if (language == reqlang && extension == reqextend)
				{
				GNREASSERT(pgci->GetAudioStreamControl(strm, ctrl));
				if (XTBF(15, ctrl))
					potentialStreams |= MKFLAG(strm);
				}
			}

		if (!potentialStreams)
			{
			//
			//  Find a stream which has the requested language
			//

			for (strm=0; strm<num; strm++)
				{
				GNREASSERT(vobs->GetAudioStreamAttribute(strm, attr, language, extension, appInfo));
				if (language == reqlang)
					{
					GNREASSERT(pgci->GetAudioStreamControl(strm, ctrl));
					if (XTBF(15, ctrl))
						potentialStreams |= MKFLAG(strm);
					}
				}
			}

		if (!potentialStreams)
			{
			//
			//  Find a stream which has the requested language extension
			//

			for (strm=0; strm<num; strm++)
				{
				GNREASSERT(vobs->GetAudioStreamAttribute(strm, attr, language, extension, appInfo));
				if (extension == reqextend)
					{
					GNREASSERT(pgci->GetAudioStreamControl(strm, ctrl));
					if (XTBF(15, ctrl))
						potentialStreams |= MKFLAG(strm);
					}
				}
			}

		if (!potentialStreams)
			{
			//
			//  Find a stream which is just available
			//

			for (strm=0; strm<num; strm++)
				{
				GNREASSERT(pgci->GetAudioStreamControl(strm, ctrl));
				if (XTBF(15, ctrl))
					potentialStreams |= MKFLAG(strm);
				}
			}

		if (potentialStreams)
			{
			strm = 0;
			while (!XTBF(strm, potentialStreams)) strm++;

			if (audioStreamSelectionPreferences)
				{
				GNREASSERT(vobs->GetAudioStreamAttribute(strm, attr, language, extension, appInfo));

				i = strm + 1;
				while (i < 8)
					{
					GNREASSERT(vobs->GetAudioStreamAttribute(i, tattr, tlanguage, textension, tappInfo));

					if ((DDPASSP_DTS & audioStreamSelectionPreferences) && XTBF(13, 3, attr) != 6 && XTBF(13, 3, tattr) == 6)
						{
						strm = i;
						GNREASSERT(vobs->GetAudioStreamAttribute(strm, attr, language, extension, appInfo));
						}
					else if ((DDPASSP_DTS & audioStreamSelectionPreferences) && XTBF(13, 3, attr) == 6 && XTBF(13, 3, tattr) != 6)
						{
						}
					else if ((DDPASSP_NO_DTS & audioStreamSelectionPreferences) && XTBF(13, 3, attr) == 6 && XTBF(13, 3, tattr) != 6)
						{
						strm = i;
						GNREASSERT(vobs->GetAudioStreamAttribute(strm, attr, language, extension, appInfo));
						}
					else if ((DDPASSP_NO_DTS & audioStreamSelectionPreferences) && XTBF(13, 3, attr) != 6 && XTBF(13, 3, tattr) == 6)
						{
						}
					else if (DDPASSP_MAXCHANNELS & audioStreamSelectionPreferences && XTBF(0, 3, attr) < XTBF(0, 3, tattr))
						{
						strm = i;
						GNREASSERT(vobs->GetAudioStreamAttribute(strm, attr, language, extension, appInfo));
						}
					}
				}

			return SetSPRM(1, strm);
			}
		else
			{
			//
			//  No proper stream found
			//

			strm = 15;

			return SetSPRM(1, strm);
			}
		}
	else
		GNRAISE_OK;  // Stream was available
	}

//
//  Select SPU stream
//

Error DVDPGCSequencer::SelectSPUStream(WORD & strm, BOOL & enable)
	{
	WORD num, full;
	WORD attr, language, reqlang, extension, reqextend;
	DWORD ctrl;

	GNREASSERT(GetSPRM(2, full));
	strm = full & 0x3f;
	full &= 0x40;
	enable = full != 0;

	if (strm == 63)
		GNRAISE_OK;

	GNREASSERT(pgci->GetSubPictureStreamControl(strm, ctrl));

	if (!XTBF(31, ctrl))
		{
		GNREASSERT(vobs->GetNumberOfSubPictureStreams(num));
		GNREASSERT(GetSPRM(18, reqlang));
		GNREASSERT(GetSPRM(19, reqextend));

		for (strm=0; strm<num; strm++)
			{
			GNREASSERT(vobs->GetSubPictureStreamAttribute(strm, attr, language, extension));
			if (language == reqlang && extension == reqextend)
				{
				GNREASSERT(pgci->GetSubPictureStreamControl(strm, ctrl));
				if (XTBF(31, ctrl))
					return SetSPRM(2, strm | full);
				}
			}

		for (strm=0; strm<num; strm++)
			{
			GNREASSERT(vobs->GetSubPictureStreamAttribute(strm, attr, language, extension));
			if (language == reqlang)
				{
				GNREASSERT(pgci->GetSubPictureStreamControl(strm, ctrl));
				if (XTBF(31, ctrl))
					return SetSPRM(2, strm | full);
				}
			}

		for (strm=0; strm<num; strm++)
			{
			GNREASSERT(vobs->GetSubPictureStreamAttribute(strm, attr, language, extension));
			if (extension == reqextend)
				{
				GNREASSERT(pgci->GetSubPictureStreamControl(strm, ctrl));
				if (XTBF(31, ctrl))
					return SetSPRM(2, strm | full);
				}
			}

		for (strm=0; strm<num; strm++)
			{
			GNREASSERT(pgci->GetSubPictureStreamControl(strm, ctrl));
			if (XTBF(31, ctrl))
				return SetSPRM(2, strm | full);
			}

		strm = 62;

		return SetSPRM(2, strm | full);
		}
	else
		GNRAISE_OK;
	}

//
//  Select display presentation mode
//

Error DVDPGCSequencer::SelectDisplayPresentationMode(DisplayPresentationMode & mode)
	{
	WORD attrib;

	GNREASSERT(vobs->GetVideoAttributes(attrib));

	if (XTBF(10, 2, attrib) == 0)
		{
		// 4 by 3
		mode = DPM_4BY3;
		}
	else
		{
		if (requestedPresentationMode == DPM_16BY9 || XTBF(8, 2, attrib) == 3)
			{
			// 16 by 9 presentation
			mode = DPM_16BY9;
			}
		else if (XTBF(8, 2, attrib) == 1)
			{
			mode = DPM_PANSCAN;
			}
		else if (XTBF(8, 2, attrib) == 2)
			{
			mode = DPM_LETTERBOXED;
			}
		else
			{
			if (requestedPresentationMode == DPM_PANSCAN)
				{
				mode = DPM_PANSCAN;
				}
			else
				{
				mode = DPM_LETTERBOXED;
				}
			}
		}

	GNRAISE_OK;
	}

//
//  Initialize array of cell times
//
//  GNR_OK
//

Error DVDPGCSequencer::BuildCellTimes(DVDGenericPGCI * pgci, DVDTime * & times, WORD cellNum)
	{
	int i;
	DVDTime	timeTotal;
	BOOL initial = TRUE;

	//
	//  Set up time array
	//

	if (times)
		delete[] times;
	times = new DVDTime[cellNum + 1];

	for(i=1; i<=cellNum; i++)
		{
		DVDCPBI cpbi;

		GNREASSERT(pgci->GetCellInformation(i, cpbi));

		//
		// get frame rate from first time stamp, if at least one is available,
		// otherwise just stick with default, it will not matter anyway.
		//
		if (initial)
			{
			timeTotal = DVDTime(0, 0, 0, 0, cpbi.PresentationTime().FrameRate());
			initial = FALSE;
			}

		times[i-1] = timeTotal;

		if (cpbi.BlockType() != CBT_ANGLE_BLOCK || cpbi.BlockMode() == CBM_LAST_CELL_IN_BLOCK)
			{
			timeTotal += cpbi.PresentationTime();
			}
		}
	times[cellNum] = timeTotal;

	GNRAISE_OK;
	}

//
//  Set Stream Parameters
//

Error DVDPGCSequencer::SetStreamParameters(void)
	{
	WORD audioStream, audioStreamID, audioStreamCtrl;
	WORD spuStream, spuStreamID;
   DWORD spuStreamCtrl;
	DisplayPresentationMode presentationMode;
	WORD videoAttr;
	WORD audioAttr, language, extension;
	WORD appInfo;
	WORD subPictureAttr;
	BOOL spuEnable;
	DWORD palette;
	int i;

	SelectAudioStream(audioStream);
	SelectSPUStream(spuStream, spuEnable);
	SelectDisplayPresentationMode(presentationMode);

	//
	// Set up audio stream
	//

	GNREASSERT(pgci->GetAudioStreamControl(audioStream, audioStreamCtrl));
	GNREASSERT(pgci->GetSubPictureStreamControl(spuStream, spuStreamCtrl));

	audioStreamID = (WORD)XTBF(8, 3, audioStreamCtrl);
	if (!XTBF(15, audioStreamCtrl)) audioStreamID = 0x0f;

	//
	// Set up presentation mode
	//

	switch (presentationMode)
		{
		case DPM_4BY3:
			spuStreamID = (WORD)XTBF(24, 5, spuStreamCtrl);
			break;
		case DPM_16BY9:
			spuStreamID = (WORD)XTBF(16, 5, spuStreamCtrl);
			break;
		case DPM_LETTERBOXED:
			spuStreamID = (WORD)XTBF( 8, 5, spuStreamCtrl);
			break;
		case DPM_PANSCAN:
			spuStreamID = (WORD)XTBF( 0, 5, spuStreamCtrl);
			break;
		}

	//
	//  Set up sub pictures
	//

	if (spuEnable) spuStreamID |= 0x40;

	if (numPG)
		{
		GNREASSERT(vobs->GetVideoAttributes(videoAttr));
		GNREASSERT(vobs->GetAudioStreamAttribute(audioStream, audioAttr, language, extension, appInfo));
		GNREASSERT(vobs->GetSubPictureStreamAttribute(spuStream, subPictureAttr, language, extension));

		GNREASSERT(SetPresentationMode(presentationMode));
		GNREASSERT(player->SetStreamAttributes(videoAttr,
			                                    audioStreamID, audioAttr,
			                                    spuStreamID, subPictureAttr,
			                                    presentationMode));

		for(i=0; i<16; i++)
			{
			GNREASSERT(pgci->GetSubPicturePalette(i, palette));
			player->SetSubPicturePalette(i, palette);
			}
		}

	if (currentPresentationMode != presentationMode)
		SendEvent(DNE_DISPLAY_MODE_CHANGE, presentationMode);
	currentPresentationMode = presentationMode;

	GNRAISE_OK;
	}

//
//  Set audio stream parameters
//

Error DVDPGCSequencer::SetAudioStreamParameters(void)
	{
	WORD audioStream, audioStreamID, audioStreamCtrl;
	WORD audioAttr, language, extension;
	WORD appInfo;

	//
	//  Get audio stream id
	//

	SelectAudioStream(audioStream);
	GNREASSERT(pgci->GetAudioStreamControl(audioStream, audioStreamCtrl));
	audioStreamID = (WORD)XTBF(8, 3, audioStreamCtrl);
	if (!XTBF(15, audioStreamCtrl))
		audioStreamID = 0x0f;

	//
	//  Set audio attributes

	GNREASSERT(vobs->GetAudioStreamAttribute(audioStream, audioAttr, language, extension, appInfo));
	GNREASSERT(player->SetAudioStreamAttributes(audioStreamID, audioAttr));
	GNRAISE_OK;
	}

//
//  Set SPU stream parameters
//

Error DVDPGCSequencer::SetSPUStreamParameters(void)
	{
	WORD spuStream, spuStreamID;
   DWORD spuStreamCtrl;
	WORD language, extension;
	WORD subPictureAttr;
	BOOL spuEnable;

	SelectSPUStream(spuStream, spuEnable);

	GNREASSERT(pgci->GetSubPictureStreamControl(spuStream, spuStreamCtrl));

	//
	//  Set up sub pictures
	//
	switch (currentPresentationMode)
		{
		case DPM_4BY3:
			spuStreamID = (WORD)XTBF(24, 5, spuStreamCtrl);
			break;
		case DPM_16BY9:
			spuStreamID = (WORD)XTBF(16, 5, spuStreamCtrl);
			break;
		case DPM_LETTERBOXED:
			spuStreamID = (WORD)XTBF( 8, 5, spuStreamCtrl);
			break;
		case DPM_PANSCAN:
			spuStreamID = (WORD)XTBF( 0, 5, spuStreamCtrl);
			break;
		}

	if (spuEnable) spuStreamID |= 0x40;

	if (numPG)
		{
		GNREASSERT(vobs->GetSubPictureStreamAttribute(spuStream, subPictureAttr, language, extension));
		GNREASSERT(player->SetSubPictureStreamAttributes(spuStreamID, subPictureAttr));
		}

	GNRAISE_OK;
	}

//
//  Start Program Chain Playback
//
//  GNR_OK
//  GNR_OBJECT_IN_USE - The playback is already running
//  GNR_INVALID_NAV_INFO
//  GNR_PARENTAL_LEVEL_TOO_LOW
//  GNR_ILLEGAL_NAVIGATION_COMMAND
//  GNR_UNEXPECTED_NAVIGATION_ERROR
//

Error DVDPGCSequencer::StartPGCPlayback(DVDOBS * vobs, DVDGenericPGCI * pgci, WORD program, BOOL skipPreCommands, BOOL toPause)
	{
	int numCmd, pc, i;
	DVDNavigationCommand * cmd;
	DVDNavigationProcessor::NavCommandDone done;

	if (GetState() != pgcs_idle)
		GNRAISE(GNR_OBJECT_IN_USE);

	this->vobs = vobs;
	this->pgci = pgci;

	GNREASSERT(pgci->GetNumberOfPrograms(numPG));
	GNREASSERT(pgci->GetNumberOfCells(numCell));
	GNREASSERT(pgci->GetUserOperations(pgciUOPs));
	GNREASSERT(pgci->GetPlaybackMode(playbackMode));
	playingCell = 1;

	DP("Starting params numPG %d numCell %d pgciUOPs %d playbackMode %d", numPG, numCell, pgciUOPs, playbackMode);

	if (numPG)
		{
		GNREASSERT(BuildCellTimes(pgci, cellTimes, numCell));	// Always returns GNR_OK

		if (playbackMode == 0)
			{
			currentPG = program;
			loopCnt = 0;
			}
		else if (playbackMode & 0x80)  // Shuffle mode
			{
			loopCnt = playbackMode & 0x7f;
			if (shuffleHistory)
				delete[] shuffleHistory;
			if (playbackShuffleHistory)
				delete[] playbackShuffleHistory;
			shuffleHistory = new BOOL[numPG];
			playbackShuffleHistory = new BOOL[numPG];
			for(i=0; i<numPG; i++)
				shuffleHistory[i] = FALSE;
			currentPG = Rnd(numPG);
			shuffleHistory[currentPG-1] = TRUE;
			for(i=0; i<numPG; i++)
				playbackShuffleHistory[i] = shuffleHistory[i];
			}
		else
			{
			loopCnt = playbackMode & 0x7f;
			currentPG = Rnd(numPG);
			}
		loopCnt++;
		}
	playingLoopCnt = loopCnt;

	GNREASSERT(streamServer->SetOBS(vobs));	// Always returns GNR_OK

	//
	//  Execute Pre Commands
	//

	if (!skipPreCommands)
		{
		SetState(pgcs_preCommand);

		pc = 1;
		GNREASSERT(pgci->GetPreCommands(numCmd, cmd));	// Always returns GNR_OK
		if (numCmd)
			{
			//
			// Execute pre commands and wait in case of SetTMPPML request
			//

//			GNREASSERTMAP(navpu->InterpretCommandList(cmd, pc, numCmd, done, requestedPML), GNR_INVALID_NAV_INFO);
			GNREASSERT(navpu->InterpretCommandList(cmd, pc, numCmd, done, requestedPML));
			if (done == DVDNavigationProcessor::NCD_SETTMPPML_DEFERED)
				{
				SetAwaitPMLChangeState(PDL_STARTPGC, pc);
				GNRAISE_OK;
				}
			}

		if (GetState() != pgcs_preCommand)
			{
			if (toPause) Pause();
			GNRAISE_OK;
			}
		}

	//
	//  Start playback
	//

	GNREASSERT(SetStreamParameters());

	if (numPG)
		{
	   SetState(pgcs_cellPlayback);
		SetScanSpeed(1);
		player->SetPlaybackSpeed(1000);
		breakpointStillState = pgcs_idle;

		playbackDone = FALSE;

		if (toPause) Pause();

		GNREASSERT(StartProgram());
		GNREASSERT(navigationTimer.StartNavigationTimer());
		}
	else
		{
		if (toPause) Pause();
		GNREASSERT(CompletePGCPlayback());
		}

	GNRAISE_OK;
	}

//
//  Start PGC Playback With Parental Level Change
//

Error DVDPGCSequencer::StartPGCPlaybackWithParentalLevel(DVDGenericPGCI * pgci)
	{
	int numCmd, pc;
	DVDNavigationCommand * cmd;
	DVDNavigationProcessor::NavCommandDone done;

	if (GetState() != pgcs_awaitingPMLChange)
		GNRAISE(GNR_UNEXPECTED_NAVIGATION_ERROR);

	//
	// Check if PML has been set (this point is never reached if PML handling is PMH_COMPATIBLE)
	//

	if (pmlHandling == PMH_DEFER_CHANGE)
		GNRAISE(GNR_PARENTAL_LEVEL_TOO_LOW);

	SetState(pgcs_preCommand);
	pc = awaitPMLChangePC;
	GNREASSERT(pgci->GetPreCommands(numCmd, cmd));	// PC stays as it was, numCmd is at least 1 (because of SetTMPPML)

	//
	// Execute pre commands and wait in case of SetTMPPML request
	//

	GNREASSERT(navpu->InterpretCommandList(cmd, pc, numCmd, done, requestedPML));
	if (done == DVDNavigationProcessor::NCD_SETTMPPML_DEFERED)
		{
		SetAwaitPMLChangeState(PDL_STARTPGC, pc);
		GNRAISE_OK;
		}

	if (GetState() != pgcs_preCommand)
		GNRAISE_OK;

	//
	//  Start playback
	//

	GNREASSERT(SetStreamParameters());

	if (numPG)
		{
	   SetState(pgcs_cellPlayback);
		SetScanSpeed(1);
		player->SetPlaybackSpeed(1000);
		breakpointStillState = pgcs_idle;

		playbackDone = FALSE;

//		if (toPause) Pause();	// We don't need this here

		GNREASSERT(StartProgram());
		GNREASSERT(navigationTimer.StartNavigationTimer());
		}
	else
		{
//		if (toPause) Pause();	// We don't need this here
		GNREASSERT(CompletePGCPlayback());
		}

	GNRAISE_OK;
	}

//
//  Start Program Chain Playback
//

Error DVDPGCSequencer::StartPGCPlaybackWithTime(DVDOBS * vobs, DVDGenericPGCI * pgci, DVDTime time, BOOL skipPreCommands, BOOL toPause)
	{
	int numCmd, pc;
	DVDNavigationCommand * cmd;
	DVDNavigationProcessor::NavCommandDone done;

//	skipPreCommands = TRUE;

	if (GetState() != pgcs_idle)
		GNRAISE(GNR_OBJECT_IN_USE);
	else
		{
		this->vobs = vobs;
		this->pgci = pgci;

		GNREASSERT(pgci->GetNumberOfPrograms(numPG));
		GNREASSERT(pgci->GetNumberOfCells(numCell));
		GNREASSERT(pgci->GetPlaybackMode(playbackMode));
		GNREASSERT(pgci->GetUserOperations(pgciUOPs));
		playingCell = 1;

		if (playbackMode)
			GNRAISE(GNR_OBJECT_NOT_FOUND);

		if (numPG)
			{
			GNREASSERT(BuildCellTimes(pgci, cellTimes, numCell));
			}

		GNREASSERT(streamServer->SetOBS(vobs));

		//
		//  Execute PreCommands
		//

		if (!skipPreCommands)
			{
			SetState(pgcs_preCommand);
			pc = 1;
			GNREASSERT(pgci->GetPreCommands(numCmd, cmd));
			if (numCmd)
				GNREASSERT(navpu->InterpretCommandList(cmd, pc, numCmd, done, requestedPML));

			if (GetState() != pgcs_preCommand)
				GNRAISE_OK;
			}

		//
		//  Start Playback
		//

		GNREASSERT(SetStreamParameters());

		if (numPG)
			{
	      SetState(pgcs_cellPlayback);
			SetScanSpeed(1);
			player->SetPlaybackSpeed(1000);
			breakpointStillState = pgcs_idle;

			playbackDone = FALSE;

			currentCell = 1;
			while (currentCell < numCell && cellTimes[currentCell] < time)
				currentCell++;

			GNREASSERT(pgci->GetProgramOfCell(currentCell, currentPG));
			GNREASSERT(pgci->GetLastCellOfProgram(currentPG, finalCell));

			if (toPause) Pause();

			GNREASSERT(StartCellAt(currentCell, time - cellTimes[currentCell-1]));
			GNREASSERT(navigationTimer.StartNavigationTimer());
			}
		else
			{
			if (toPause) Pause();
			GNREASSERT(CompletePGCPlayback());
			}
		}

	GNRAISE_OK;
	}

//
//  Test access restriction of cell by time
//

Error DVDPGCSequencer::AccessRestricted(DVDGenericPGCI * pgci, DVDTime time, BOOL & restricted)
	{
	DVDCPBI cpbi;
	WORD cell;
	WORD numCells;
	DVDTime * times = NULL;

	cell = 1;
	GNREASSERT(pgci->GetNumberOfCells(numCells));
	GNREASSERT(BuildCellTimes(pgci, times, numCells));

	while (cell < numCells && times[cell] < time)
		cell++;

	delete[] times;

	if (cell <= numCells)
		{
		GNREASSERT(pgci->GetCellInformation(cell, cpbi));
		restricted = cpbi.AccessRestricted();
		}
	else
		restricted = FALSE;

	GNRAISE_OK;
	}

//
//  Get User Operations
//

Error DVDPGCSequencer::GetUOPs(DWORD & uops)
	{
	DVDCPBI cpbi;

	if (GetState() == pgcs_idle)
		{
		uops = 0;
		}
	else
		{
		uops = vobuUOPs | pgciUOPs | MKBF(17, !HighlightActive() || ButtonActivated()) |
				 MKBF(18, !(GetState() == pgcs_vobuStill || GetState() == pgcs_cellStill || GetState() == pgcs_pgcStill));

		//
		//  If we reached a breakpoint we have to enable "still off"
		//

		if (breakpointStillState != pgcs_idle)
			uops &= ~UOP_STILL_OFF;

		//
		//  If cell has Access restricted flag set we have to disable scanning
		//

		GNREASSERT(pgci->GetCellInformation(playingCell, cpbi));
		if (cpbi.AccessRestricted())
			uops |= UOP_FORWARD_SCAN | UOP_BACKWARD_SCAN;
		}

	GNRAISE_OK;
	}

//
//  Check if UOP is permitted
//

Error DVDPGCSequencer::UOPPermitted(int uop, BOOL & permitted)
	{
	DWORD uops;

	GNREASSERT(GetUOPs(uops));

	permitted = !XTBF(uop, uops);
	GNRAISE_OK;
	}

//
//  Get Current Location in stream
//

Error DVDPGCSequencer::GetCurrentLocation(DVDLocation & loc)
	{
	DVDTime playbackTime;

	if (GetState() == pgcs_cellPlayback)
		{
		GNREASSERT(pgci->GetProgramOfCell(playingCell, loc.program));
		loc.cell     = playingCell;
		loc.cellTime = cellTime;
		if (IS_ERROR(streamServer->GetPlaybackTime(playbackTime)))
			{
			playbackTime = cellTime + cellTimes[playingCell - 1];
			}
		loc.pgcTime = playbackTime;
		}
	else if (GetState() != pgcs_idle)
		{
		GNREASSERT(pgci->GetProgramOfCell(playingCell, loc.program));
		loc.cell     = playingCell;
		loc.cellTime = cellTime;
		loc.pgcTime = cellTime + cellTimes[playingCell - 1];
		}
	else
		{
		loc.program = 0;
		loc.cell = 0;
		loc.cellTime = 0;
		loc.pgcTime = 0;
		}

	GNRAISE_OK;
	}

//
//  Get Current Duration (of cell)
//

Error DVDPGCSequencer::GetCurrentDuration(DVDLocation & loc)
	{
	if (GetState() != pgcs_idle)
		{
		loc.program  = numPG;
		loc.cell		 = numCell;
		loc.cellTime = cellTimes[playingCell] - cellTimes[playingCell-1];
		GNREASSERT(pgci->GetPresentationTime(loc.pgcTime));
		}
	else
		{
		loc.program = 0;
		loc.cell = 0;
		loc.cellTime = 0;
		loc.pgcTime = 0;
		}

	GNRAISE_OK;
	}

//
//  Stop Program Chain Playback
//

Error DVDPGCSequencer::StopPGCPlayback(void)
	{
	switch (GetState())
		{
		case pgcs_idle:
		case pgcs_preCommand:
		case pgcs_postCommand:
			break;
		case pgcs_cellStill:
			GNREASSERT(streamServer->ReturnCell(stillCell));
			stillCell = NULL;
		case pgcs_pgcStill:
//			GNREASSERT(CompleteStill());
//			GNREASSERT(CancelStillPhase());
//			break;
		case pgcs_cellCommand:
		case pgcs_vobuStill:
			GNREASSERT(CancelStillPhase());
//			GNREASSERT(CompleteStill());
		case pgcs_scanForward:
		case pgcs_scanBackward:
		case pgcs_cellPlayback:
		case pgcs_cellPlaybackReverse:
		case pgcs_cellTrickPlay:
			GNREASSERT(streamServer->AbortTransfer());
			GNREASSERT(player->Resume());
			break;
		}

	GNREASSERT(CancelHighlight());
	GNREASSERT(navigationTimer.StopNavigationTimer());

	pgci = NULL;
	SetState(pgcs_idle);
	streamServer->StopPlayback();
	isMultiAngleScene = FALSE;
	streaming = FALSE;

	if (EventHasHandler(DNE_PARENTAL_LEVEL_CHANGE))
		pmlHandling = PMH_DEFER_CHANGE;
	else
		pmlHandling = PMH_COMPATIBLE;

	player->SetAnalogCopyProtectionMode(0);

	GNRAISE_OK;
	}

//
//  Prepare navigation accurate
//

Error DVDPGCSequencer::PrepareNavigationAccurate(void)
	{
	switch(GetState())
		{
		case pgcs_idle:
			GNRAISE(GNR_OBJECT_NOT_FOUND);
			break;
		case pgcs_preCommand:
		case pgcs_postCommand:
			break;
		case pgcs_cellStill:
			GNREASSERT(streamServer->ReturnCell(stillCell));
			stillCell = NULL;
		case pgcs_vobuStill:
		case pgcs_pgcStill:
			GNREASSERT(CancelStillPhase());
		case pgcs_cellCommand:
			GNREASSERT(streamServer->CompleteStill());
		case pgcs_scanForward:
		case pgcs_scanBackward:
		case pgcs_cellPlayback:
		case pgcs_cellPlaybackReverse:
		case pgcs_cellTrickPlay:
			SetState(pgcs_aborting);
			GNREASSERT(streamServer->AbortTransferAccurate());
			GNREASSERT(player->Resume());
			break;
		}

	SetState(pgcs_navigating);
	breakpointStillState = pgcs_idle;
	programStarted = FALSE;
	streaming = FALSE;

	GNRAISE_OK;
	}

//
//  Prepare Navigation Change
//

Error DVDPGCSequencer::PrepareNavigation(void)
	{
	switch(GetState())
		{
		case pgcs_idle:
			GNRAISE(GNR_OBJECT_NOT_FOUND);
			break;
		case pgcs_preCommand:
		case pgcs_postCommand:
			break;
		case pgcs_cellStill:
			GNREASSERT(streamServer->ReturnCell(stillCell));
			stillCell = NULL;
		case pgcs_vobuStill:
		case pgcs_pgcStill:
			GNREASSERT(CancelStillPhase());
		case pgcs_cellCommand:
//			GNREASSERT(CompleteStill());
		case pgcs_scanForward:
		case pgcs_scanBackward:
		case pgcs_cellPlayback:
		case pgcs_cellPlaybackReverse:
		case pgcs_cellTrickPlay:
			GNREASSERT(streamServer->AbortTransfer());
			GNREASSERT(player->Resume());
			break;
		}

	SetState(pgcs_navigating);
	breakpointStillState = pgcs_idle;
	programStarted = FALSE;
	streaming = FALSE;

	GNRAISE_OK;
	}

//
//  Start Forward Scan
//

Error DVDPGCSequencer::StartForwardScan(WORD speed)
	{
	if (GetState() == pgcs_cellPlayback || GetState() == pgcs_scanForward ||
		 GetState() == pgcs_scanBackward || GetState() == pgcs_cellPlaybackReverse)
		{
		GNREASSERT(PrepareNavigationAccurate());

		SetScanSpeed(speed);
		player->SetPlaybackSpeed(1000);
		SetState(pgcs_scanForward);

		loopCnt = playingLoopCnt;
		GNREASSERT(pgci->GetProgramOfCell(playingCell, currentPG));
		GNREASSERT(pgci->GetLastCellOfProgram(currentPG, finalCell));

		playbackDone = FALSE;

		GNRAISE(StartCell(playingCell, nextVOBU));
		}
	else
		GNRAISE(GNR_OPERATION_PROHIBITED);
	}

//
//  Start Backward Scan
//

Error DVDPGCSequencer::StartBackwardScan(WORD speed)
	{
	if (GetState() == pgcs_cellPlayback || GetState() == pgcs_scanForward ||
		 GetState() == pgcs_scanBackward || GetState() == pgcs_cellPlaybackReverse )
		{
		GNREASSERT(PrepareNavigationAccurate());

		SetScanSpeed(speed);
		player->SetPlaybackSpeed(1000);
		SetState(pgcs_scanBackward);

		loopCnt = playingLoopCnt;
		GNREASSERT(pgci->GetProgramOfCell(playingCell, currentPG));
		GNREASSERT(pgci->GetFirstCellOfProgram(currentPG, finalCell));

		playbackDone = FALSE;

		GNRAISE(StartCell(playingCell, playingVOBU));
		}
	else
		GNRAISE(GNR_OPERATION_PROHIBITED);
	}

//
//  Start Reverse Playback
//

Error DVDPGCSequencer::StartReversePlayback(void)
	{
	if (GetState() == pgcs_cellPlayback || GetState() == pgcs_scanForward ||
		 GetState() == pgcs_scanBackward)
		{
		GNREASSERT(PrepareNavigationAccurate());

		SetScanSpeed(1);
		SetState(pgcs_cellPlaybackReverse);

		GNREASSERT(pgci->GetProgramOfCell(playingCell, currentPG));
		GNREASSERT(pgci->GetFirstCellOfProgram(currentPG, finalCell));

		currentCell = playingCell;
		playbackDone = FALSE;

		GNRAISE(StartCell(playingCell, playingVOBU));
		}

	GNRAISE_OK;
	}

//
//  Start trick playback
//  NOTE: Here we do not care about "Cell Access Restricted" flag since this is
//  prohibited if Fwd/BwdScan is prohibited by UOPs (set if CAR flag is set).
//

Error DVDPGCSequencer::StartTrickPlayback(void)
	{
	BOOL still;

	if (GetState() == pgcs_cellPlayback)
		{
		GNREASSERT(PrepareNavigationAccurate());

		SetState(pgcs_cellTrickPlay);

		GNREASSERT(pgci->GetProgramOfCell(playingCell, currentPG));
		GNREASSERT(pgci->GetFirstCellOfProgram(currentPG, finalCell));

		currentCell = playingCell;

//		GNREASSERT(AdvanceCell());

		still = IsStillCell();

		GNREASSERT(streamServer->TransferCellTrickplay(pgci, playingCell, still, FALSE, cellTimes[playingCell - 1], playingVOBU));
		}

	GNRAISE_OK;
	}

//
//  Stop Scanning, continue with normal playback
//  NOTE: Here wo do not care about "Cell Access Restricted" flag since
//  scan of is exactly what we would want in this case.
//

Error DVDPGCSequencer::StopScan(BOOL toPause)
	{
	BOOL still;

	if (GetState() == pgcs_scanForward || GetState() == pgcs_scanBackward || GetState() == pgcs_cellPlaybackReverse || GetState() == pgcs_cellTrickPlay)
		{
		GNREASSERT(PrepareNavigationAccurate());

		SetState(pgcs_cellPlayback);

		GNREASSERT(pgci->GetProgramOfCell(playingCell, currentPG));
		GNREASSERT(pgci->GetLastCellOfProgram(currentPG, finalCell));

		loopCnt = playingLoopCnt;
		currentCell = playingCell;
		SetScanSpeed(1);

		playbackDone = FALSE;
		GNREASSERT(AdvanceCell());

		still = IsStillCell();

		if (toPause) Pause();

		streaming = TRUE;

		GNREASSERT(streamServer->TransferCell(pgci, playingCell, still, playingCell == finalCell, cellTimes[playingCell - 1], playingVOBU, angle));
		}

	GNRAISE_OK;
	}

//
//  Perform audio stream change
//

Error DVDPGCSequencer::PerformAudioStreamChange(void)
	{
	if (GetState() == pgcs_cellPlayback)
		{
		GNREASSERT(SetAudioStreamParameters());
		}

	GNRAISE_OK;
	}

//
//  Perform SPU stream change
//

Error DVDPGCSequencer::PerformSPUStreamChange(void)
	{
	if (GetState() == pgcs_scanForward || GetState() == pgcs_scanBackward ||
		 GetState() == pgcs_cellPlaybackReverse || GetState() == pgcs_cellTrickPlay ||
	    GetState() == pgcs_cellPlayback)
		{
		GNREASSERT(SetSPUStreamParameters());
		}

	GNRAISE_OK;
	}

//
//  Perform stream change
//

Error DVDPGCSequencer::PerformStreamChange(void)
	{
	if (GetState() == pgcs_cellPlayback)
		{
		GNREASSERT(PrepareNavigationAccurate());

		GNREASSERT(SetStreamParameters());

		SetState(pgcs_cellPlayback);

		GNREASSERT(pgci->GetProgramOfCell(playingCell, currentPG));
		GNREASSERT(pgci->GetLastCellOfProgram(currentPG, finalCell));

		GNRAISE(StartCell(playingCell, playingVOBU));
		}

	GNRAISE_OK;
	}

//
//  Perform angle change
//

Error DVDPGCSequencer::AngleChange(void)
	{
	AngleChangeType type;
	Error err = GNR_OK;

	if (GetState() == pgcs_cellPlayback)
		{

		GNREASSERT(streamServer->GetAngleChangeType(type));

		switch (type)
			{
			case ACT_NONE:
				break;
			case ACT_DEFERRED:
				break;
			case ACT_SEAMLESS:
				DP("Seamless angle change");
				err = streamServer->SeamlessAngleChange(angle);
				break;
			case ACT_NON_SEAMLESS:
				DP("Non seamless angle change");

				GNREASSERT(PrepareNavigationAccurate());

				SetState(pgcs_cellPlayback);

				GNREASSERT(pgci->GetProgramOfCell(playingCell, currentPG));
				GNREASSERT(pgci->GetLastCellOfProgram(currentPG, finalCell));

				GNREASSERT(StartCell(playingCell, playingVOBU));
				SendEvent(DNE_ANGLE_CHANGE, angle);
				break;
			default:
				BREAKPOINT;
			};
		}
	else
		DP("Wrong state during angle change");

	GNRAISE(err);
	}

//
//  Get System Parameter
//

Error DVDPGCSequencer::GetSPRM(int index, WORD & sprm)
	{
	BOOL active;
	DWORD dw;

	switch(index)
		{
		case 3:
			sprm = angle;
			break;
		case 9:
			navigationTimer.QueryNavigationTimer(dw, active);
			if (!active)
				sprm = 0;
			else
				sprm = (WORD)(dw / 1000);
			break;
		case 8:
			sprm = (WORD)(MKBF(10, 6, selectedButton));
			break;
		case 14:
			switch(requestedPresentationMode)
				{
				case DPM_4BY3:
				case DPM_LETTERBOXED:
				case DPM_PANSCAN:
					sprm = 0x0000;
					break;
				case DPM_16BY9:
					sprm = 0x0c00;
					break;
				}

			switch (currentPresentationMode)
				{
				case DPM_4BY3:
					sprm |= 0x0000;
					break;
				case DPM_LETTERBOXED:
					sprm |= 0x0200;
					break;
				case DPM_PANSCAN:
					sprm |= 0x0100;
					break;
				case DPM_16BY9:
					sprm |= 0x0000;
					break;
				}
			break;
		default:
			GNRAISE(DVDNavigationControl::GetSPRM(index, sprm));
		}

	GNRAISE_OK;
	}

//
//  Set System Parameter
//

Error DVDPGCSequencer::SetSPRM(int index, WORD val)
	{
	WORD sprm;

	switch(index)
		{
		case 3:
//			DP("Set angle %d to %d", angle, val);
			if (angle != val)
				{
				angle = val;
				GNRAISE(DVDPGCSequencer::AngleChange());
				}
			break;

		case 1: // Audio Stream
			GNREASSERT(DVDNavigationControl::GetSPRM(1, sprm));
			if (sprm != val)
				{
				GNREASSERT(DVDNavigationControl::SetSPRM(1, val));
				GNREASSERT(PerformAudioStreamChange());
				SendEvent(DNE_AUDIO_STREAM_CHANGE, val);
				}
			break;

		case 2: // SPU Stream
			GNREASSERT(DVDNavigationControl::GetSPRM(2, sprm));
			if (sprm != val)
				{
				GNREASSERT(DVDNavigationControl::SetSPRM(2, val));
				GNREASSERT(PerformSPUStreamChange());
				SendEvent(DNE_SUBPICTURE_STREAM_CHANGE, val);
				}
			break;

		case 8:
			GNRAISE(ButtonSet(val));

		case 9:
			GNREASSERT(GetSPRM(10, sprm));
			if (val)
				navigationTimer.InitNavigationTimer((DWORD)val*1000, sprm);
			else
				navigationTimer.ResetNavigationTimer();
			break;

		default:
			GNRAISE(DVDNavigationControl::SetSPRM(index, val));
		}

	GNRAISE_OK;
	}

//
//  Go to a program
//

Error DVDPGCSequencer::GoProgram(WORD pgn)
	{
	if (!playbackMode && pgn >=1 && pgn <= numPG)
		{
		if (GetState() == pgcs_preCommand)
			currentPG = pgn;
		else
			{
			GNREASSERT(PrepareNavigation());
			currentPG = pgn;
		   SetState(pgcs_cellPlayback);
			GNREASSERT(StartProgram());
			}
		}
	else
		GNRAISE(GNR_RANGE_VIOLATION);

	GNRAISE_OK;
	}

//
//  Go to a cell
//

Error DVDPGCSequencer::GoCell(WORD cell)
	{
	WORD numCells;

	GNREASSERT(pgci->GetNumberOfCells(numCells));
	if (!playbackMode && cell >=1 && cell <= numCells)
		{
		if (GetState() == pgcs_preCommand)
			{
			GNREASSERT(SetStreamParameters());

			SetScanSpeed(1);
			player->SetPlaybackSpeed(1000);
			playbackDone = FALSE;
			}
		else
			GNREASSERT(PrepareNavigation());

		GNREASSERT(pgci->GetProgramOfCell(cell, currentPG));
		GNREASSERT(pgci->GetLastCellOfProgram(currentPG, finalCell));
		currentCell = cell;
	   SetState(pgcs_cellPlayback);
		GNRAISE(StartCell(currentCell));
		}
	else
		GNRAISE(GNR_RANGE_VIOLATION);
	}

//
//  Go to previous program
//

Error DVDPGCSequencer::GoPrevProgram(void)
	{
	GNREASSERT(pgci->GetProgramOfCell(playingCell, playingPG));

	if (!playbackMode && playingPG > 1)
		{
		GNREASSERT(PrepareNavigation());
		currentPG = playingPG - 1;
	   SetState(pgcs_cellPlayback);
		GNREASSERT(StartProgram());
		}
	else
		GNRAISE(GNR_RANGE_VIOLATION);

	GNRAISE_OK;
	}

//
// Go to next program
//

Error DVDPGCSequencer::GoNextProgram(void)
	{
	int i;
	BOOL hasNext;
	WORD nextPGC;

	loopCnt = playingLoopCnt;
	if (shuffleHistory && playbackShuffleHistory)
		{
		for(i=0; i<numPG; i++)
			shuffleHistory[i] = playbackShuffleHistory[i];
		}
	GNREASSERT(HasNextProgram(hasNext));
	if (!hasNext)
		{
		GNREASSERT(pgci->GetNextProgramChain(nextPGC));
		if (!nextPGC)
			GNRAISE_OK;
		}

	//
	//  There is a next program, so let's go there
	//

	GNREASSERT(PrepareNavigation());
	GNREASSERT(pgci->GetProgramOfCell(playingCell, currentPG));
	SetState(pgcs_cellPlayback);
	GNREASSERT(SendNextProgram());
	if (playbackDone)
		GNREASSERT(CompletePGCPlayback());

	GNRAISE_OK;
	}

//
//  Go to top program
//

Error DVDPGCSequencer::GoTopProgram(void)
	{
	GNREASSERT(PrepareNavigation());

	GNREASSERT(pgci->GetProgramOfCell(playingCell, currentPG));

   SetState(pgcs_cellPlayback);
	GNREASSERT(StartProgram());

	GNRAISE_OK;
	}

//
//  Go to previous cell
//

Error DVDPGCSequencer::GoPrevCell(void)
	{
	WORD prog;
	WORD first;

	GNREASSERT(pgci->GetProgramOfCell(playingCell, prog));
	GNREASSERT(pgci->GetFirstCellOfProgram(prog, first));

	if (playingCell > first)
		{
		GNREASSERT(PrepareNavigation());
		loopCnt = playingLoopCnt;
		GNREASSERT(pgci->GetProgramOfCell(playingCell, currentPG));
		currentCell = playingCell - 1;
	   SetState(pgcs_cellPlayback);
		GNRAISE(StartCell(currentCell));
		}
	else
		GNRAISE(GNR_RANGE_VIOLATION);
	}

//
//  Go to next cell
//

Error DVDPGCSequencer::GoNextCell(void)
	{
	DP("GoNextCell Playiung %d Final %d", playingCell, finalCell);
	if (playingCell <= finalCell)
		{
		DP("1");
		GNREASSERT(PrepareNavigation());
		DP("2");
		GNREASSERT(pgci->GetProgramOfCell(playingCell, currentPG));
		DP("3");
	   SetState(pgcs_cellPlayback);
		currentCell = playingCell + 1;
		GNRAISE(StartCell(currentCell));
		DP("4");
		}
	else
		GNRAISE(GNR_RANGE_VIOLATION);

	GNRAISE_OK;
	}

//
//  Go to top cell
//

Error DVDPGCSequencer::GoTopCell(void)
	{
	GNREASSERT(PrepareNavigation());
	currentCell = playingCell;
   SetState(pgcs_cellPlayback);
	GNRAISE(StartCell(currentCell));
	}

//
//  Go to top program chain
//

Error DVDPGCSequencer::GoTopProgramChain(void)
	{
	int numCmd, pc, i;
	DVDNavigationCommand * cmd;
	DVDNavigationProcessor::NavCommandDone done;

	//
	//  Only execute the first part if we didn't wait for PML change
	//

	if (GetState() != pgcs_awaitingPMLChange)
		{
		GNREASSERT(PrepareNavigation());

		if (numPG)
			{
			if (playbackMode == 0)
				{
				currentPG = 1;
				loopCnt = 0;
				}
			else if (playbackMode & 0x80)
				{
				loopCnt = playbackMode & 0x7f;
				for(i=0; i<numPG; i++)
					shuffleHistory[i] = FALSE;
				currentPG = Rnd(numPG);
				shuffleHistory[currentPG-1] = FALSE;
				}
			else
				{
				loopCnt = playbackMode & 0x7f;
				currentPG = Rnd(numPG);
				}
			loopCnt++;
			playingLoopCnt = loopCnt;
			}

		SetState(pgcs_preCommand);

		pc = 1;
		GNREASSERT(pgci->GetPreCommands(numCmd, cmd));
		}
	else
		{
		//
		// Check if PML has been set (this point is never reached if PML handling is PMH_COMPATIBLE)
		//

		if (pmlHandling == PMH_DEFER_CHANGE)
			GNRAISE(GNR_OPERATION_PROHIBITED);

		SetState(pgcs_preCommand);
		pc = awaitPMLChangePC;
		GNREASSERT(pgci->GetPreCommands(numCmd, cmd));
		}

	//
	//  Execute pre commands
	//

	if (numCmd)
		{
		//
		// Execute pre commands and wait in case of SetTMPPML request
		//

		GNREASSERT(navpu->InterpretCommandList(cmd, pc, numCmd, done, requestedPML));
		if (done == DVDNavigationProcessor::NCD_SETTMPPML_DEFERED)
			{
			SetAwaitPMLChangeState(PDL_GOTOPPGC, pc);
			GNRAISE_OK;
			}
		}

	if (GetState() != pgcs_preCommand)
		GNRAISE_OK;

	if (numPG)
		{
      SetState(pgcs_cellPlayback);

		GNREASSERT(StartProgram());
		}
	else
		GNREASSERT(CompletePGCPlayback());

	GNRAISE_OK;
	}

//
//  Go Tail Program Chain
//

Error DVDPGCSequencer::GoTailProgramChain(void)
	{
	GNREASSERT(PrepareNavigation());
	GNREASSERT(CompletePGCPlayback());

	GNRAISE_OK;
	}

//
//  Set Display Mode
//

Error DVDPGCSequencer::SetDisplayMode(DisplayPresentationMode mode)
	{
	if (requestedPresentationMode != mode)
		{
		requestedPresentationMode = mode;

		GNREASSERT(PerformStreamChange());
		SendEvent(DNE_DISPLAY_MODE_CHANGE, mode);
		}

	GNRAISE_OK;
	}

//
//  Resume playback
//

Error DVDPGCSequencer::ResumeFromSystemSpace(DVDOBS * vobs, DVDGenericPGCI * pgci)
	{
	BOOL still = FALSE;
	WORD pgcn;

	if (GetState() != pgcs_idle) GNREASSERT(PrepareNavigation());

	this->vobs = vobs;
	this->pgci = pgci;

	GNREASSERT(pgci->GetNumberOfPrograms(numPG));
	GNREASSERT(pgci->GetNumberOfCells(numCell));
	GNREASSERT(pgci->GetPlaybackMode(playbackMode));
	GNREASSERT(pgci->GetUserOperations(pgciUOPs));

	GNREASSERT(BuildCellTimes(pgci, cellTimes, numCell));

	GNREASSERT(streamServer->SetOBS(vobs));

	GNREASSERT(SetStreamParameters());

	playingLoopCnt = loopCnt = resumeLoopCnt;

   SetState(pgcs_cellPlayback);

	GNREASSERT(pgci->GetProgramOfCell(resumeCell, currentPG));
	playingCell = currentCell = resumeCell;
	GNREASSERT(pgci->GetLastCellOfProgram(currentPG, finalCell));
	playbackDone = FALSE;

	GNREASSERT(StartCell(playingCell, resumeVOBU));

	if (resumeNavtimerActive)
		{
		GetSPRM(10, pgcn);
		navigationTimer.InitNavigationTimer(resumeNavtimerTime, pgcn);
		navigationTimer.StartNavigationTimer();
		}

	GNRAISE_OK;
	}

//
//  Save information for resume
//

Error DVDPGCSequencer::SaveResumeInformation(void)
	{
	resumeVOBU = playingVOBU;
	resumeCell = playingCell;

	resumeLoopCnt = playingLoopCnt;
	if (shuffleHistory && playbackShuffleHistory)
		{
		for(int i=0; i<numPG; i++)
			shuffleHistory[i] = playbackShuffleHistory[i];
		}
	navigationTimer.QueryNavigationTimer(resumeNavtimerTime, resumeNavtimerActive);
	navigationTimer.ResetNavigationTimer(); // a little ugly here...

	GNRAISE_OK;
	}

//
//  Freeze current state
//

Error DVDPGCSequencer::Freeze(DVDPGCSFreezeState & state)
	{
	int i;

	//
	//  Freeze state of base classes
	//

	DVDHighlightControl::Freeze(state.hcFreezeState);
	navpu->Freeze(state.npFreezeState);

	//
	// Freeze miscellaneous
	//

	state.cellTime = cellTime;
	state.angle = angle;

	//
	// Freeze shuffle history
	//

	if (shuffleHistory)
		{
		for (i=0; i < 4; i++)
			state.shuffleHistory[i] = 0;

		state.shuffleHistoryExists = TRUE;

		for (i=0; i<numPG; i++)
			state.shuffleHistory[i >> 5] |= MKBF(i & 0x1f, playbackShuffleHistory[i]);
		}
	else
		state.shuffleHistoryExists = FALSE;

	//
	// Freeze cell data
	//

	state.playingCell = playingCell;
	state.loopCnt = loopCnt;

	//
	// Freeze navtimer information
	//
	navigationTimer.QueryNavigationTimer(state.navtimerTime, state.navtimerActive);

	//
	//  Save resume information
	//

   state.resumeCell = resumeCell;
   state.resumeVOBU = resumeVOBU;
   state.resumeLoopCnt = resumeLoopCnt;
	state.resumeNavtimerActive = resumeNavtimerActive;
	state.resumeNavtimerTime = resumeNavtimerTime;

	GNRAISE_OK;
	}

//
//  Return to previously saved state
//

Error DVDPGCSequencer::Defrost(DVDPGCSFreezeState & state, DVDOBS * vobs, DVDGenericPGCI * pgci, DVDDomain domain, DWORD flags)
	{
	BOOL still = FALSE;
	int i;

	//
	// Restore state of other classes
	//

	DVDHighlightControl::Defrost(state.hcFreezeState);
	GNREASSERT(navpu->Defrost(state.npFreezeState));
	streamServer->Defrost();

	//
	// Reread data
	//

	this->vobs = vobs;
	this->pgci = pgci;

	GNREASSERT(pgci->GetNumberOfPrograms(numPG));
	GNREASSERT(pgci->GetNumberOfCells(numCell));
	GNREASSERT(pgci->GetPlaybackMode(playbackMode));
	GNREASSERT(pgci->GetUserOperations(pgciUOPs));

	//
	// Set up cell times
	//

	cellTime = state.cellTime;
	GNREASSERT(BuildCellTimes(pgci, cellTimes, numCell));

	GNREASSERT(SetStreamParameters());
	SetState(pgcs_cellPlayback);
	SetScanSpeed(1);
	player->SetPlaybackSpeed(1000);
	breakpointStillState = pgcs_idle;

	//
	// Restore cell data
	//

	playingCell = state.playingCell;
	GNREASSERT(pgci->GetProgramOfCell(playingCell, playingPG));
	currentCell = playingCell;
	currentPG = playingPG;
	GNREASSERT(pgci->GetLastCellOfProgram(playingPG, finalCell));

	//
	// Restore miscellaneous
	//

	playingLoopCnt = loopCnt = state.loopCnt;
	angle = state.angle;
	playingAngle = angle;
	SetState(pgcs_cellPlayback);  // Always start normal playback

	//
	// Restore resume data
	//

   resumeCell = state.resumeCell;
   resumeVOBU = state.resumeVOBU;
   resumeLoopCnt = state.resumeLoopCnt;
	resumeNavtimerActive = state.resumeNavtimerActive;
	resumeNavtimerTime = state.resumeNavtimerTime;

	//
	// Restore shuffle history
	//

	if (state.shuffleHistoryExists)
		{
		if (shuffleHistory)
			delete[] shuffleHistory;
		if (playbackShuffleHistory)
			delete[] playbackShuffleHistory;
		shuffleHistory = new BOOL[numPG];
		playbackShuffleHistory = new BOOL[numPG];

		for (i=0; i<numPG; i++)
			playbackShuffleHistory[i] = shuffleHistory[i] = XTBF(i & 0x1f, state.shuffleHistory[i >> 5]);
		}

	playbackDone = FALSE;

	//
	// Misc Setup
	//

	GNREASSERT(streamServer->SetOBS(vobs));
	GNREASSERT(SetStreamParameters());

	if (HighlightActive())
		StartCell(playingCell);
	else
		StartCellAt(playingCell, cellTime);

	//
	// Defrost navtimer information
	//

	if (state.navtimerActive)
		{
		WORD pgcn;

		GetSPRM(10, pgcn);

		navigationTimer.InitNavigationTimer(resumeNavtimerTime, pgcn);
		navigationTimer.StartNavigationTimer();
		}

	if (flags & DDPSPF_TOPAUSE)
		Pause();

	GNRAISE_OK;
	}

//
//  Set State
//

void DVDPGCSequencer::SetState(DVDPGCSequencer::State newState)
	{
	if (newState != state)
		{
		state = newState;
		externalState = newState;
		if (!IsInternalState(newState))
			StateChanged();
		}
	}

//
//  Test if state is internal only
//

BOOL DVDPGCSequencer::IsInternalState(DVDPGCSequencer::State state)
	{
	switch (state)
		{
		case pgcs_cellPlayback:
		case pgcs_vobuStill:
		case pgcs_cellStill:
		case pgcs_pgcStill:
		case pgcs_scanForward:
		case pgcs_scanBackward:
		case pgcs_cellPlaybackReverse:
		case pgcs_cellTrickPlay:
		case pgcs_paused:
			return FALSE;
		default:
			return TRUE;
		}
	}

//
//  Pause Playback
//

Error DVDPGCSequencer::Pause(void)
	{
	Error err = player->Pause();
	if (!IS_ERROR(err))
		{
		navigationTimer.PauseNavigationTimer();
		externalState = pgcs_paused;
		StateChanged();
		}
	return err;
	}

//
//  Resume Playback
//

Error DVDPGCSequencer::Resume(void)
	{
	Error err = player->Resume();
	if (!IS_ERROR(err))
		{
		navigationTimer.ResumeNavigationTimer();
		externalState = GetState();
		StateChanged();
		}
	return err;
	}

//
//  Select Parental Level (to be called from the app only)
//

Error DVDPGCSequencer::ParentalLevelSelect(WORD level)
	{
	WORD pml;

	DP("Parental Level Select %d", level);
	if (level >= 1 && level <= 8 || level == 15)
		{
		if (GetState() != pgcs_awaitingPMLChange)
			{
			SetSPRM(13, level);
			GNRAISE_OK;
			}
		else
			{
			//
			//  Configure navigation processor to accept/reject PML change
			//

			GNREASSERT(GetSPRM(13, pml));
			if (level != pml)
				pmlHandling = PMH_ALLOW_CHANGE;
			else
				pmlHandling = PMH_FORBID_CHANGE;

			//
			//  Restart defered functions
			//

			switch (pmlDeferLocation)
				{
				case PDL_STARTPGC:
					GNRAISE(StartPGCPlaybackWithParentalLevel(pgci));
				case PDL_COMPLETEPGC:
					GNRAISE(CompletePGCPlayback());
				case PDL_GOTOPPGC:
					GNRAISE(GoTopProgramChain());
				default:
					GNRAISE(GNR_UNEXPECTED_NAVIGATION_ERROR);
				}
			}
		}
	else
		GNRAISE(GNR_RANGE_VIOLATION);
	}

//
//  Request PML Change
//

DVDNavigationControl::PMLHandling DVDPGCSequencer::PMLChangeAllowed(void)
	{
	WORD pml;

	switch (pmlHandling)
		{
		case PMH_COMPATIBLE:
			GetSPRM(13, pml);
			if (pml == 15)
				return PMH_ALLOW_CHANGE;
			else
				return PMH_FORBID_CHANGE;

		case PMH_ALLOW_CHANGE:
			pmlHandling = PMH_DEFER_CHANGE;
			return PMH_ALLOW_CHANGE;

		case PMH_FORBID_CHANGE:
			pmlHandling = PMH_DEFER_CHANGE;
			return PMH_FORBID_CHANGE;

		case PMH_DEFER_CHANGE:
			return PMH_DEFER_CHANGE;

		default:
			return PMH_FORBID_CHANGE;
		}
	}

//
//  Wait for parental level change
//

void DVDPGCSequencer::SetAwaitPMLChangeState(PMLDeferLocation deferLoc, int pc)
	{
	//
	//  Send PGCSequencer to a pause state and inform application of SetTMPPML request
	//

	SetState(pgcs_awaitingPMLChange);
	pmlDeferLocation = deferLoc;
	awaitPMLChangePC = pc;
	SendEvent(DNE_PARENTAL_LEVEL_CHANGE, requestedPML);
	}

//
//  Register Event Handler
//

Error DVDPGCSequencer::SetEventHandler(DWORD event, DNEEventHandler handler, void * userData)
	{
	Error err;

	if (!IS_ERROR(err = EventSender::SetEventHandler(event, handler, userData)))
		{
		if (EventHasHandler(DNE_PARENTAL_LEVEL_CHANGE))
			pmlHandling = PMH_DEFER_CHANGE;
		else
			pmlHandling = PMH_COMPATIBLE;
		}

	GNRAISE(err);
	}

//
//  Set Scan Speed
//

Error DVDPGCSequencer::SetScanSpeed(WORD speed)
	{
	if (speed != scanSpeed)
		SendEvent(DNE_SCAN_SPEED_CHANGE, speed);
	scanSpeed = speed;
	GNRAISE_OK;
	}

//
//  Start breakpoint pause
//

void DVDPGCSequencer::StartBreakpointStillCallback()
	{
	//
	//  Go to still state
	//

//	if (GetState() == pgcs_scanForward || GetState() == pgcs_scanBackward)
//		StopScan(TRUE);
//	else
		player->Pause();
	player->SetPlaybackSpeed(1000);
	SetScanSpeed(1);
	StartStillPhase(255);
	SetState(breakpointStillState);
	}

//
//  Test if we reached End-Of-Cell breakpoint
//

BOOL DVDPGCSequencer::EndOfCellBreakpointReached(DVDCell * cell, ERSPlaybackDir dir, ERSBreakpoint & bp)
	{
	WORD num;

	if (IS_ERROR(pgci->GetProgramOfCell(cell->num, num)))
		return FALSE;

	if (dir == EPD_BACKWARD)
		num--;

	return EndOfPGBreakpointReached(num, dir, bp);
	}

//
//  Test if we reached Begin-Of-Cell breakpoint
//

BOOL DVDPGCSequencer::BeginOfCellBreakpointReached(DVDCell * cell, ERSPlaybackDir dir, ERSBreakpoint & bp)
	{
	WORD num;

	if (IS_ERROR(pgci->GetProgramOfCell(cell->num, num)))
		return FALSE;

//	if (dir == EPD_BACKWARD)
//		num--;

	return BeginOfPGBreakpointReached(num, dir, bp);
	}

//
//  Test if we are playing forward
//

BOOL DVDPGCSequencer::IsPlayingForward(void)
	{
	return (GetState() != pgcs_cellPlaybackReverse && GetState() != pgcs_scanBackward);
	}

//
//  Notification of angle change
//

void DVDPGCSequencer::AngleChanged(void)
	{
	playingAngle = angle;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDNavpu.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
//  Navigation Module
//
//  Declares DVDNavigationCommand, DVDNavigationControl and
//  DVDNavigationProcessor
//
//////////////////////////////////////////////////////////////////////

#ifndef DVDNAVPU_H
#define DVDNAVPU_H

// Turn debugging of commands on/off
//
// After you turned debugging on by setting NAVPROCDEBUG to 1 make sure to set the debug options correctly.
// Namely these are NPD_LOGTOFILE, NPD_LOGFILENAME, NPD_LOGTODBGOUT which define where the debug output goes and
// NPD_LOGCMDLISTS and NPD_LOGEXECUTION which define what to log.

#define NAVPROCDEBUG 0


#include "Library/Common/Prelude.h"
#include "NavErrors.h"
#include "EventSender.h"
#include "DVDTime.h"

#if NAVPROCDEBUG

#include <stdio.h>

// Log to file yes/no (set file name, too !)
#define NPD_LOGTOFILE	1
#define NPD_LOGFILENAME	"e:\\npdlog.txt"

// Log to debug output yes/no
#define NPD_LOGTODBGOUT	1

#if !NPD_LOGTOFILE && !NPD_LOGTODBGOUT
#error Check debug defines! Set NAVPROCDEBUG to 0 to disable logging
#endif

// Log whole command lists before they are executed (InterpretCommandList())
#define NPD_LOGCMDLISTS 1

// Log each command before it is executed and log the results
#define NPD_LOGEXECUTION 1

// Useful execution logging macros
#if NPD_LOGEXECUTION
#define LOGCOMMAND NPD_LogCommand(com, pc, true);
#define LOGPRM(num) NPD_LogResultPRM(num)
#define LOGEXECUTION(call) { char * buffer = call; NPD_LogResultLn("Exec %s", buffer); delete buffer; }
#else
#define LOGCOMMAND
#define LOGPRM
#define LOGEXECUTION(call)
#endif // NPD_LOGEXECUTION

#else
#define LOGCOMMAND
#define LOGPRM
#define LOGEXECUTION(call)
#endif // NAVPROCDEBUG

//////////////////////////////////////////////////////////////////////
//
//  DVDNavigationCommand Class
//
//////////////////////////////////////////////////////////////////////

class DVDNavigationCommand
	{
	public:
		DWORD dw[2];

		//
		//  Extract segment from 64 bit word
		//
		DWORD SegDW(int pos, int len)
			{
			if (pos >= 32)
				return XTBF(pos - 32, len, FLIPENDIAN(dw[0]));
			else
				return XTBF(pos, len, FLIPENDIAN(dw[1]));
			}

		WORD SegW(int pos, int len)
			{
			if (pos >= 32)
				return (WORD)(XTBF(pos - 32, len, FLIPENDIAN(dw[0])));
			else
				return (WORD)(XTBF(pos, len, FLIPENDIAN(dw[1])));
			}

		//
		//  Check if a certain bit of 64 bit word is set
		//
		BOOL SegBIT(int pos)
			{
			if (pos >= 32)
				return XTBF(pos - 32, FLIPENDIAN(dw[0]));
			else
				return XTBF(pos, FLIPENDIAN(dw[1]));
			}
	};

//////////////////////////////////////////////////////////////////////
//
//  DVDNavigationControl Class
//
//  Base class for high level navigation functions
//
//////////////////////////////////////////////////////////////////////

class DVDNavigationControl
	{
	public:
		// PMH_COMPATIBLE allows setting of PML only when the current level is "undefined"
		// With PMH_ALLOW/FORBID_CHANGE the execution of the SetTmpPML command can be
		// allowed/forbidden

		enum PMLHandling { PMH_COMPATIBLE, PMH_ALLOW_CHANGE, PMH_FORBID_CHANGE, PMH_DEFER_CHANGE };

	protected:
		WORD			sprm[32];
		PMLHandling	pmlHandling;

		//
		//  Freezing stuff
		//

		class DVDNCFreezeState
			{
			public:
				WORD			sprm[32];
				PMLHandling	pmlHandling;
			};

		Error Freeze (DVDNCFreezeState & state);
		Error Defrost(DVDNCFreezeState & state);

	public:
		virtual Error GoProgram(WORD pgn) = 0;
		virtual Error GoCell(WORD cell) = 0;

		virtual Error GoPrevProgram(void) = 0;
		virtual Error GoNextProgram(void) = 0;
		virtual Error GoTopProgram(void) = 0;
		virtual Error GoPrevCell(void) = 0;
		virtual Error GoNextCell(void) = 0;
		virtual Error GoTopCell(void) = 0;
		virtual Error GoTopProgramChain(void) = 0;
		virtual Error GoTailProgramChain(void) = 0;

		virtual Error GoProgramChain(WORD pgcn) = 0;
		virtual Error GoPartOfTitle(WORD pttn) = 0;

		virtual Error GoPrevProgramChain(void) = 0;
		virtual Error GoNextProgramChain(void) = 0;
		virtual Error GoUpProgramChain(void) = 0;

   	virtual Error Exit(Error err = GNR_OK) = 0;
   	virtual Error GoTitle(WORD title, DWORD flags = DDPSPF_NONE) = 0;
   	virtual Error GoVideoTitleSetTitle(WORD title, BOOL toPause = FALSE) = 0;
   	virtual Error GoVideoTitleSetPartOfTitle(WORD title, WORD ptt) = 0;
   	virtual Error GoSystemSpaceProgramChain(WORD pgcn, WORD domainID, WORD menuID) = 0;
   	virtual Error GoSystemSpaceTitleSet(WORD titleSet, WORD title, WORD domainID, WORD menuID) = 0;
   	virtual Error CallSystemSpaceProgramChain(WORD pgcn, WORD domainID, WORD menuID, WORD resumeCell) = 0;
		virtual Error GoTrack(WORD track, WORD titleGroupNumber) = 0;

		virtual Error ResumeFromSystemSpace(void) = 0;

		virtual Error GetSPRM(int index, WORD & val) { val = sprm[index]; GNRAISE_OK;}
		virtual Error SetSPRM(int index, WORD val) {sprm[index] = val; GNRAISE_OK;}

		// Only returns PMH_ALLOW/FORBID/DEFER_CHANGE
		virtual PMLHandling PMLChangeAllowed(void) = 0;
	};

//////////////////////////////////////////////////////////////////////
//
//  DVDNavigationProcessor Class
//
//  Processes low level navigation commands
//
//////////////////////////////////////////////////////////////////////

class DVDNavigationProcessor
	{
	public:
		// This type specifies if processing of commands is to be terminated
		// or just defered because of the SetTMPPML command
		enum NavCommandDone { NCD_NO, NCD_YES, NCD_SETTMPPML_DEFERED };

	private:
		DWORD seed;
		WORD	gprm[16];
		BOOL	gprmMode[16];
		DWORD	gprmTimerStart[16];

		int	recursionLevel;
		WORD	requestedPML;

#if NAVPROCDEBUG
		FILE*	logFile;
		bool	npd_newInstruction;
#endif

	protected:
		DVDNavigationControl	*	navigationControl;

		virtual WORD GetGPRM(int index);
		virtual void SetGPRM(int index, WORD val);
		virtual void SetGPRMMode(int index, WORD val, BOOL counter);

		Error SetHL_BTTN(WORD button);

		BOOL Compare(WORD val1, WORD val2);
		BOOL CompareCP(DVDNavigationCommand com, int cp1, int cp2);

		Error ExecOp(int op, WORD & dst, WORD & src);
		Error ExecOpSP(DVDNavigationCommand com, int sp1, int sp2);

		WORD GetPRM(WORD num);

		Error ExecNop(DVDNavigationCommand com, int & pc, NavCommandDone & done);
		Error ExecGoTo(DVDNavigationCommand com, int & pc, NavCommandDone & done, WORD & pml);
		Error ExecCompareGoTo(DVDNavigationCommand com, int & pc, NavCommandDone & done);
		Error ExecLink(DVDNavigationCommand com, int & pc, NavCommandDone & done);
		Error ExecCompareLink(DVDNavigationCommand com, int & pc, NavCommandDone & done);
		Error ExecJump(DVDNavigationCommand com, int & pc, NavCommandDone & done);
		Error ExecCompareJump(DVDNavigationCommand com, int & pc, NavCommandDone & done);
		Error ExecSetSystem(DVDNavigationCommand com, int & pc, NavCommandDone & done);
		Error ExecCompareSetSystem(DVDNavigationCommand com, int & pc, NavCommandDone & done);
		Error ExecSetSystemLink(DVDNavigationCommand com, int & pc, NavCommandDone & done);
		Error ExecSet(DVDNavigationCommand com, int & pc, NavCommandDone & done);
		Error ExecCompareSet(DVDNavigationCommand com, int & pc, NavCommandDone & done);
		Error ExecSetLink(DVDNavigationCommand com, int & pc, NavCommandDone & done);
		Error ExecLinkSIns(DVDNavigationCommand com, int & pc, NavCommandDone & done);
		Error ExecSetCompareLinkSIns(DVDNavigationCommand com, int & pc, NavCommandDone & done);
		Error ExecCompareAndSetLinkSIns(DVDNavigationCommand com, int & pc, NavCommandDone & done);
		Error ExecCompareSetAndLinkSIns(DVDNavigationCommand com, int & pc, NavCommandDone & done);

		//
		// Debug functions
		//

#if NAVPROCDEBUG

		void NPD_LogString(const char * string);
		//void NPD_Log(int pc, const char * format, ...);
		//void NPD_Log(const char * format, ...);
		void NPD_LogLn(int pc, const char * format, ...);
		void NPD_LogLn(const char * format, ...);
		void NPD_LogResultLn(const char * format, ...);

		// Make string stuff...
		char * NPD_MakeString(const char * format, ...);
		char * NPD_MakeGoToString(DVDNavigationCommand com);
		char * NPD_MakePRMString(WORD num, bool runtime = false);
		void NPD_MakeCompareArgs(DVDNavigationCommand com, int cp1, int cp2, char* & arg1, char* & arg2, bool runtime = false);
		char * NPD_MakeCompareString(DVDNavigationCommand com, int cp1, int cp2, bool runtime = false);
		char * NPD_MakeLinkSInsString(DVDNavigationCommand com);
		char * NPD_MakeLinkString(DVDNavigationCommand com);
		char * NPD_MakeJumpString(DVDNavigationCommand com);
		char * NPD_MakeSetSystemString(DVDNavigationCommand com, bool runtime = false);
		char * NPD_MakeOpString(int opcode);
		char * NPD_MakeSetString(DVDNavigationCommand com, int sp1, int sp2, bool runtime = false);


//		void NPD_LogGoTo(DVDNavigationCommand com);
		void NPD_LogDualCommand(int pc, char * pPart1, char * pPart2);
		void NPD_LogTripleCommand(int pc, char * pPart1, char * pPart2, char * pPart3, int ampersandPos);

		// Goto group
		void NPD_LogNop(DVDNavigationCommand com, int pc);
		void NPD_LogGoTo(DVDNavigationCommand com, int pc);
		void NPD_LogCompareGoTo(DVDNavigationCommand com, int pc, bool runtime = false);

		// Link group
		void NPD_LogLink(DVDNavigationCommand com, int pc);
		void NPD_LogCompareLink(DVDNavigationCommand com, int pc, bool runtime = false);

		// Jump group
		void NPD_LogJump(DVDNavigationCommand com, int pc);
		void NPD_LogCompareJump(DVDNavigationCommand com, int pc, bool runtime = false);

		// SetSystem group
		void NPD_LogSetSystem(DVDNavigationCommand com, int pc, bool runtime = false);
		void NPD_LogCompareSetSystem(DVDNavigationCommand com, int pc, bool runtime = false);
		void NPD_LogSetSystemLink(DVDNavigationCommand com, int pc, bool runtime = false);

		// Set group
		void NPD_LogSet(DVDNavigationCommand com, int pc, bool runtime = false);
		void NPD_LogCompareSet(DVDNavigationCommand com, int pc, bool runtime = false);
		void NPD_LogSetLink(DVDNavigationCommand com, int pc, bool runtime = false);

		void NPD_LogSetCompareLinkSIns(DVDNavigationCommand com, int pc, bool runtime = false);
		void NPD_LogCompareAndSetLinkSIns(DVDNavigationCommand com, int pc, bool runtime = false);
		void NPD_LogCompareSetAndLinkSIns(DVDNavigationCommand com, int pc, bool runtime = false);

		void NPD_LogResultPRM(WORD num);

		void NPD_LogCommand(DVDNavigationCommand com, int pc, bool runtime = false);
		void NPD_LogCommandList(DVDNavigationCommand * com, int pc, int num);

		WORD NPD_GetSPRM(WORD num);

		void NPD_LogSPRM(void);
		void NPD_LogGPRM(void);
		void NPD_LogPRM(void);
#endif

		int compareField;
		int branchField;

	public:
		DVDNavigationProcessor(void);

#if NAVPROCDEBUG
		~DVDNavigationProcessor(void);
#endif


		Error ClearGPRMs(void);

		Error InterpretCommand(DVDNavigationCommand com, int & pc, NavCommandDone & done, WORD & pml);
		Error InterpretCommandList(DVDNavigationCommand * com, int & pc, int num, NavCommandDone & done, WORD & pml);

		BOOL IsBasicCellLinkCommand(DVDNavigationCommand com);
		Error GetBasicCellLinkTarget(DVDNavigationCommand com, WORD & cellID);

		void SetNavigationControl(DVDNavigationControl * control) {navigationControl = control;}

		//
		// Freezing stuff
		//

		class DVDNPFreezeState
			{
			public:
				DWORD seed;
				WORD	gprm[16];
				WORD	gprmMode;
				DWORD	gprmTimerStart[16];
			};

		Error Freeze (DVDNPFreezeState & state);
		Error Defrost(DVDNPFreezeState & state);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDPlayer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD Player Class
//
////////////////////////////////////////////////////////////////////

#include "DVDPlayer.h"
#include "Library/Common/vddebug.h"
#include "Library/lowlevel/timer.h"

#define REFILL_MSG		0x1000
#define SIGNAL_MSG		0x1001
#define ERROR_MSG			0x1002
#define DONE_MSG			0x1003

#define MEASURE_TRANSFER_RATE	0

//
//  Constructor
//

DVDPlayer::DVDPlayer(WinPortServer *server, UnitSet units, EventDispatcher* pEventDispatcher) : EventPortWorkerThread(server, THREAD_PRIORITY_HIGHEST)
	, DVDStreamPlayer(pEventDispatcher)
	{
	this->units = units;
	VDR_OpenSubUnits(units, MPEG_DECODER_UNIT, decUnits);

	callback = NULL;

	videoAttr = 0xffff;   // this illegal value ensures complete computation of video attributes
	audioStreamID = 0;
	audioAttr = 0xffff;
	subPictureStreamID = 0;
	subPictureAttr = 0xffff;
	stillFrameSequence = FALSE;
	videoStandard = VSTD_NTSC;

	transferCount = 0;
	transferTotal = 0;
 	transferCountRemainder = 0;

	playbackSpeed = 1000;
	backward = FALSE;
	inCallback = FALSE;
	paused = FALSE;
	refiller = NULL;

	VDR_InstallMessagePort(units, GetPort());
	VDR_ConfigureUnitsTags(units, SET_MPEG2_REFILL_MSG(REFILL_MSG),
		                           SET_MPEG2_SIGNAL_MSG(SIGNAL_MSG),
											SET_MPEG2_DONE_MSG(DONE_MSG),
											SET_MPEG2_ERROR_MSG(ERROR_MSG),
											TAGDONE);

	VDR_ConfigureUnitsTags(units, SET_MPEG2_DVD_STREAM_DEMUX(TRUE),
											SET_MPEG2_CODING_STANDARD(TRUE),
										   SET_ENC_COPY_PROTECTION(0),
	                              TAGDONE);

	VDR_ConfigureUnitsTags(decUnits, SET_MPEG2_SPU_ENABLE(FALSE),
												SET_MPEG2_DVD_STREAM_ENCRYPTED(FALSE),

												SET_MPEG_VIDEO_BITRATE(5000000),
												SET_MPEG_STREAM_BITRATE(7000000),

												SET_MPEG_VIDEO_WIDTH(720),
												SET_MPEG_VIDEO_HEIGHT(480),
												SET_MPEG_VIDEO_FPS(30000),
												SET_MPEG_ASPECT_RATIO(256),
												SET_MPEG_STREAM_TYPE(multiplexed),
//												SET_MPEG_VIDEOSTANDARD(VSTD_NTSC),
												SET_MPEG2_PRESENTATION_MODE(MPM_FULLSIZE),

												SET_MPEG_AUDIO_BITRATE(300000),
												SET_MPEG_AUDIO_SAMPLERATE(48000),
												SET_MPEG_AUDIO_LAYER(MPAUDLAYER_1),
												SET_MPEG2_AUDIO_AC3(TRUE),
												SET_MPEG2_AUDIO_LPCM(FALSE),

												SET_MPEG2_LPCM_BITSPERSAMPLE(16),
												SET_MPEG2_LPCM_CHANNELS(2),

												SET_MPEG2_POSITION_SCALE(MP2SR_SCALE_DVDPES),
												SET_MPEG2_STILL_FRAME_SEQUENCE(stillFrameSequence),
												SET_MPEG2_AUDIO_TYPE(MP2AUDTYP_AC3),
												TAGDONE);

	scanning = FALSE;
	trickplay = FALSE;

	timeBaseValid = FALSE;
	lastDecoderTime = 0;
	}

//
//  Destructor
//

DVDPlayer::~DVDPlayer(void)
	{
	// Restore default settings for security critical tags
	VDR_ConfigureUnitsTags(units, SET_ENC_COPY_PROTECTION(0),
											SET_MPEG2_SPDIF_COPY_MODE(SPDIFCM_DEFAULT),
											SET_ENC_COPY_MODE(VCPMD_DEFAULT),
											SET_MPEG2_DVD_STREAM_ENCRYPTED(FALSE),
											TAGDONE);

	VDR_PassivateUnits(decUnits);

	VDR_RemoveMessagePort(units);

	VDR_CloseUnits(decUnits);

	TerminateWorker();
	}

//
//  Terminate playback
//

void DVDPlayer::TerminatePlayback(void)
	{
	VDR_ConfigureUnitsTags(units, SET_ENC_COPY_PROTECTION(0), TAGDONE);

	VDR_PassivateUnits(decUnits);
	}

//
//  Request refill
//

void DVDPlayer::RequestRefill(void)
	{
	SendWorkMessage(REFILL_MSG, 0);
	}

void DVDPlayer::RequestCallback(DWORD position)
	{
	SendWorkMessage(SIGNAL_MSG, position);
	}

//
//  Process message
//

void DVDPlayer::WorkMessage(WPARAM wParam, LPARAM dParam)
	{
	DVDStreamServer * cb = callback;

//	DP("Msg %d %d", wParam, dParam);

	switch (wParam)
		{
		case REFILL_MSG:
//			DP("Refill Request");
			// Latencies are improved when executing this before PerformTransfer
			VDR_CompleteMPEGRefillMessage(units);

			if (refiller)
				refiller->PerformTransfer(32);
			break;
		case SIGNAL_MSG:
//			DP("Get Callback %d %d", dParam, transferCount);
			if (cb)
				{
//				DP("Has cb %d %d", dParam, transferCount);
				inCallback = TRUE;
				if (dParam < (LONG)transferCount || !expectingDone && dParam == (LONG)transferCount)
					{
//					DP("dParam < transferCount");
					if (dParam >= (LONG)callbackPosition)
						{
//						DP("dParam >= callbackPosition");
						callback = NULL;
						cb->PlayerCallback(dParam);
						}
					}
				inCallback = FALSE;
				}
			break;
		case DONE_MSG:
//			DP("Got done message");
			if (cb && expectingDone)
				{
				inCallback = TRUE;
//				DP("As expected");
				callback = NULL;
				cb->PlayerCallback(0xffffffff);
				inCallback = FALSE;
				}
			else
				{
//				DP("Done Message Unexpected");
				}
			break;
		case ERROR_MSG:
			DP("Error Msg %08lx", dParam);
			SendEvent(DNE_ERROR, (DWORD)dParam);
			break;
		}
	}

//
//  Pause Playback
//

Error DVDPlayer::Pause(void)
	{
	MPEGState state;

	if (!paused)
		{
		state = VDR_CurrentMPEGState(units);
		if (state == mps_playing || state == mps_initial || state == mps_resyncing)
			{
//			GNREASSERT(VDR_SendMPEGCommand(units, mpc_freeze, 0, tag));
// Use DoMPEGCommand to prevent racing condition on hardware solutions like 5505
// (for example, when next command is a "set playback speed" command). The decoder
// may not yet have made the transition to the mps_frozen state.
			GNREASSERT(VDR_DoMPEGCommand(units, mpc_freeze, 0));
			}

		paused = TRUE;
		}

	GNRAISE_OK;
	}

//
//  Resume Playback
//

Error DVDPlayer::Resume(void)
	{
	DWORD tag;

	if (paused)
		{
		if (VDR_CurrentMPEGState(units) == mps_frozen)
			{
			GNREASSERT(VDR_SendMPEGCommand(units, mpc_play, playbackSpeed, tag));
			}

		paused = FALSE;
		}

	GNRAISE_OK;
	}

//
//  Single Step
//

Error DVDPlayer::Step(void)
	{
	DWORD tag;
	MPEGState state = VDR_CurrentMPEGState(units);

	if (state == mps_frozen || state == mps_trickplaying)
		return VDR_SendMPEGCommand(units, mpc_step, 1, tag);
	else
		GNRAISE(GNR_OPERATION_PROHIBITED);
	}

//
//  Step by amount
//

Error DVDPlayer::StepBy(int val)
	{
	DWORD tag;

	if (VDR_CurrentMPEGState(units) == mps_trickplaying)
		return VDR_SendMPEGCommand(units, mpc_step, val, tag);
	else
		GNRAISE(GNR_OPERATION_PROHIBITED);
	}

//
//  Set playback speed
//

Error DVDPlayer::SetPlaybackSpeed(WORD speed)
	{
	DWORD tag;

	if (speed > 2000) speed = 2000;
	else if (speed < 50) speed = 50;

	if (speed != playbackSpeed)
		{
		playbackSpeed = speed;
		SendEvent(DNE_PLAYBACK_SPEED_CHANGE, playbackSpeed);

		if (VDR_CurrentMPEGState(units) == mps_playing ||
			 VDR_CurrentMPEGState(units) == mps_resyncing)
			{
			return VDR_SendMPEGCommand(units, mpc_play, playbackSpeed, tag);
			}
		else
			GNRAISE_OK;
		}
	else
		GNRAISE_OK;
	}

//
//  Test if decoder is paused
//

BOOL DVDPlayer::IsPaused(void)
	{
	MPEGState state = VDR_CurrentMPEGState(units);
	return  state == mps_frozen || state == mps_stepping;
	}

//
//  Test if decoder is preempted
//

BOOL DVDPlayer::IsPreempted(void)
	{
	return VDR_CurrentMPEGState(units) == mps_preempted;
	}

//
//  Set audio attributes
//

inline void DVDPlayer::ExtractAudioAttributes(WORD audioAttr, MPEG2AudioType & type, WORD & channels,
															 DWORD & audioBitsPerSecond, DWORD & samplesPerSecond, DWORD &bitsPerSample)
	{
	channels = (WORD)XTBF(0, 3, audioAttr) + 1;

	switch (XTBF(13, 3, audioAttr))
		{
		case 0:	// AC3
			type = MP2AUDTYP_AC3;
			samplesPerSecond = 48000;
			audioBitsPerSecond = 384000 * (DWORD)channels / 6;
			if (audioBitsPerSecond < 192000)
				audioBitsPerSecond = 192000;
			bitsPerSample = 16;
			break;
		case 2:	// MPEG1 or MPEG-2 without extension stream
			if (channels > 2)
				{
				type = MP2AUDTYP_MPEG2;
				audioBitsPerSecond = 500000;
				}
			else
				{
				type = MP2AUDTYP_MPEG;
				audioBitsPerSecond = 200000;
				}
			bitsPerSample = 16;
			samplesPerSecond = 48000;
			break;
		case 3:	// MPEG2
			type = MP2AUDTYP_MPEG2;
			samplesPerSecond = 48000;
			audioBitsPerSecond = 500000;
			bitsPerSample = 16;
			break;
		case 4:	// LPCM
			type = MP2AUDTYP_LPCM;
			samplesPerSecond = XTBF(4, 2, audioAttr) ? 96000 : 48000;
			bitsPerSample = XTBF(6, 2, audioAttr) * 4 + 16;
			audioBitsPerSecond = samplesPerSecond * bitsPerSample * channels;
			break;
		case 6:	// DTS
			type = MP2AUDTYP_DTS;
			samplesPerSecond = 48000;
			bitsPerSample = 16;
			audioBitsPerSecond = 768000;
			break;
		case 7:	// SDDS
			type = MP2AUDTYP_SDDS;
			samplesPerSecond = 48000;
			bitsPerSample = 16;
			audioBitsPerSecond = 768000;
			break;
		}
	}

//
//  Set audio stream attributes
//

Error DVDPlayer::SetAudioStreamAttributes(WORD audioStreamID, WORD audioAttr)
	{
	MPEG2AudioType	type;
	WORD				channels;
	DWORD				audioBitsPerSecond;
	DWORD				samplesPerSecond;
	DWORD				bitsPerSample;
	DWORD				tag;
	Error				error;
	VDAutoMutex		mutex(&lock);

	this->audioStreamID = audioStreamID;

	if (!expectingDone)
		{
		if (this->audioAttr != audioAttr || (this->audioStreamID == 0x0f && audioStreamID != 0x0f))
			{
			//
			//  Attributes have changed/audio stream has been activated => full change
			//

			ExtractAudioAttributes(audioAttr, type, channels, audioBitsPerSecond, samplesPerSecond, bitsPerSample);

			GNREASSERT(VDR_DoMPEGCommand(decUnits, mpc_seekaudio, 0));
			if (audioStreamID != 0x0f)
				{
				error = VDR_ConfigureUnitsTags(decUnits,  SET_MPEG_AUDIO_STREAMID(0xc0 | audioStreamID),
																			SET_MPEG2_AUDIO_AC3_STREAMID(0x80 | audioStreamID),
																			SET_MPEG2_AUDIO_LPCM_STREAMID(0xa0 | audioStreamID),
																			SET_MPEG2_AUDIO_DTS_STREAMID(0x88 | audioStreamID),
																			SET_MPEG_AUDIO_BITRATE(audioBitsPerSecond),
																			SET_MPEG_AUDIO_SAMPLERATE((WORD)samplesPerSecond),
																			SET_MPEG2_AUDIO_AC3((BOOL)(type == MP2AUDTYP_AC3)),
																			SET_MPEG2_AUDIO_LPCM((BOOL)(type == MP2AUDTYP_LPCM)),
																			SET_MPEG2_LPCM_BITSPERSAMPLE((WORD)bitsPerSample),
																			SET_MPEG2_LPCM_CHANNELS(channels),
																			SET_MPEG2_AUDIO_TYPE(type),
																			TAGDONE);
				}
			GNREASSERT(VDR_SendMPEGCommand(decUnits, mpc_resyncaudio, 0, tag));
			}
		else
			{
			//
			//  Only stream id has changed => partial change
			//

			GNREASSERT(VDR_DoMPEGCommand(decUnits, mpc_seekaudio, 0));
			if (audioStreamID != 0x0f)
				{
				error = VDR_ConfigureUnitsTags(decUnits,  SET_MPEG_AUDIO_STREAMID(0xc0 | audioStreamID),
																			SET_MPEG2_AUDIO_AC3_STREAMID(0x80 | audioStreamID),
																			SET_MPEG2_AUDIO_LPCM_STREAMID(0xa0 | audioStreamID),
																			SET_MPEG2_AUDIO_DTS_STREAMID(0x88 | audioStreamID),
																			TAGDONE);
				}
			GNREASSERT(VDR_SendMPEGCommand(decUnits, mpc_resyncaudio, 0, tag));
			}
		}

	this->audioAttr = audioAttr;
	GNRAISE_OK;
	}

//
//  Get information about audio decoder status and content
//

Error DVDPlayer::GetAudioInformation(MPEG2PrologicStatus & prologicStatus, MPEG2LFEStatus & lfeStatus, AC3AudioCodingMode & ac3Mode)
	{
	BOOL proStat;
	BOOL lfeStat;
	BOOL tagSupported;

	//
	//  Get prologic status
	//

	prologicStatus = MP2PS_UNKNOWN;
	if (!IS_ERROR(VDR_ConfigureUnitsTags(decUnits, QRY_MPEG2_PROLOGIC_STATUS(tagSupported), TAGDONE)))
		{
		if (tagSupported)
			{
			if (!IS_ERROR(VDR_ConfigureUnitsTags(decUnits, GET_MPEG2_PROLOGIC_STATUS(proStat), TAGDONE)))
				prologicStatus = proStat ? MP2PS_ON : MP2PS_OFF;
			}
		}

	//
	//  Get LFE status
	//

	lfeStatus = MP2LFE_UNKNOWN;
	if (!IS_ERROR(VDR_ConfigureUnitsTags(decUnits, QRY_MPEG2_LFE_STATUS(tagSupported), TAGDONE)))
		{
		if (tagSupported)
			{
			if (!IS_ERROR(VDR_ConfigureUnitsTags(decUnits, GET_MPEG2_LFE_STATUS(lfeStat), TAGDONE)))
				lfeStatus = lfeStat ? MP2LFE_ON : MP2LFE_OFF;
			}
		}

	//
	//  Get AC3 coding mode
	//

	ac3Mode = AC3ACMOD_UNKNOWN;
	if (!IS_ERROR(VDR_ConfigureUnitsTags(decUnits, QRY_MPEG2_AC3_AUDIO_CODING_MODE(tagSupported), TAGDONE)))
		{
		if (tagSupported)
			{
			if (IS_ERROR(VDR_ConfigureUnitsTags(decUnits, GET_MPEG2_AC3_AUDIO_CODING_MODE(ac3Mode), TAGDONE)))
				ac3Mode = AC3ACMOD_UNKNOWN;
			// If no error occurred ac3Mode already has the correct value
			}
		}

	GNRAISE_OK;
	}

//
//  Set subpicture stream attributes
//

Error DVDPlayer::SetSubPictureStreamAttributes(WORD subPictureStreamID, WORD subPictureAttr)
	{
	this->subPictureStreamID = subPictureStreamID;

	return VDR_ConfigureUnitsTags(units, SET_MPEG2_SPU_STREAMID(0x20 | (subPictureStreamID & 0x3f)),
 													 SET_MPEG2_SPU_ENABLE(XTBF(6, subPictureStreamID)),
													 TAGDONE);
	}

//
//  Set stream attributes
//

Error DVDPlayer::SetStreamAttributes(WORD videoAttr,
                                     WORD audioStreamID, WORD audioAttr,
                                     WORD subPictureStreamID, WORD subPictureAttr,
		                          		 DisplayPresentationMode mode)
	{
	DWORD tag;
	WORD width, height, framesPerSecond, aspectRatio, channels;
	MPEG2AudioType type;
	DWORD audioBitsPerSecond, samplesPerSecond, bitsPerSample;
	VideoStandard newVideoStandard;
	MPEG2PresentationMode	m2mode;
	ForcedAspectRatio forcedRatio;

//	DP("################################################");
//	DP("Change attributes AS %d WAS %d", audioStreamID, this->audioStreamID);

	if (videoAttr != this->videoAttr ||
	    audioAttr != this->audioAttr ||
	    mode != presentationMode ||
		 this->audioStreamID == 0x0f && audioStreamID != 0x0f)
		{
//		DP("Full change");

		this->videoAttr = videoAttr;
		this->audioAttr = audioAttr;
		this->audioStreamID = audioStreamID;
		this->subPictureStreamID = subPictureStreamID;

		//
		//  Set video playback data
		//

		presentationMode = mode;

		switch (XTBF(12, 2, videoAttr))
			{
			case 0:
				height = 480;
				framesPerSecond = 30;
				newVideoStandard = VSTD_NTSC;
				break;
			case 1:
				height = 576;
				framesPerSecond = 25;
				newVideoStandard = VSTD_PAL;
				break;
			}

		if (videoStandard != newVideoStandard)
			SendEvent(DNE_VIDEO_STANDARD_CHANGE, videoStandard);
		videoStandard = newVideoStandard;

		switch (XTBF(3, 3, videoAttr))
			{
			case 0:
				width = 720;
				break;
			case 1:
				width = 704;
				break;
			case 2:
				width = 352;
				break;
			case 3:
				width = 352;
				height /= 2;
				break;
			default:
				width = 720;
				break;
			}

		aspectRatio = ScaleWord(0x0155, width, height);

		switch (XTBF(10, 2, videoAttr))
			{
			case 0:
				forcedRatio = FORCED_AR_4_BY_3;
				break;
			case 3:
				forcedRatio = FORCED_AR_16_BY_9;
				break;
			default:
				forcedRatio = FORCED_AR_DEFAULT;
			}

		switch (mode)
			{
			case DPM_4BY3:
				m2mode = MPM_FULLSIZE;
				break;
			case DPM_16BY9:
				m2mode = MPM_FULLSIZE16by9;
				break;
			case DPM_PANSCAN:
				m2mode = MPM_PANSCAN;
				break;
			case DPM_LETTERBOXED:
				m2mode = MPM_LETTERBOXED;
				break;
			}

		//
		//  Get audio attributes
		//

		ExtractAudioAttributes(audioAttr, type, channels, audioBitsPerSecond, samplesPerSecond, bitsPerSample);

		//
		//  Pass new data to decoder
		//

		GNREASSERT(VDR_PassivateUnits(decUnits));
		GNREASSERT(VDR_ConfigureUnitsTags(units, SET_PIP_VIDEOSTANDARD(videoStandard),
			                                      SET_VID_VIDEOSTANDARD(videoStandard),
															  TAGDONE));

		if (audioStreamID != 0x0f)
			{
			GNREASSERT(VDR_ConfigureUnitsTags(decUnits,  SET_MPEG_AUDIO_STREAMID(0xc0 | audioStreamID),
																		SET_MPEG2_AUDIO_AC3_STREAMID(0x80 | audioStreamID),
																		SET_MPEG2_AUDIO_LPCM_STREAMID(0xa0 | audioStreamID),
																		SET_MPEG2_AUDIO_DTS_STREAMID(0x88 | audioStreamID),
																		SET_MPEG_AUDIO_BITRATE(audioBitsPerSecond),
																		SET_MPEG_AUDIO_SAMPLERATE((WORD)samplesPerSecond),
																		SET_MPEG2_AUDIO_AC3((BOOL)(type == MP2AUDTYP_AC3)),
																		SET_MPEG2_AUDIO_LPCM((BOOL)(type == MP2AUDTYP_LPCM)),

																		SET_MPEG2_LPCM_BITSPERSAMPLE((WORD)bitsPerSample),
																		SET_MPEG2_LPCM_CHANNELS(channels),
																		SET_MPEG2_AUDIO_TYPE(type),
																		TAGDONE));
			}


#if TEST_PAL_TO_NTSC

		GNREASSERT(VDR_ConfigureUnitsTags(decUnits,  SET_MPEG2_SPU_STREAMID(0x20 | (subPictureStreamID & 0x3f)),
 																	SET_MPEG2_SPU_ENABLE(XTBF(6, subPictureStreamID)),

																	SET_MPEG_VIDEO_STREAMID(0xe0),
																	SET_MPEG_VIDEO_BITRATE(5000000),
																	SET_MPEG_STREAM_BITRATE(7000000),

 																	SET_MPEG_VIDEO_WIDTH(width),
 																	SET_MPEG_VIDEO_HEIGHT(height),
 																	SET_MPEG_VIDEO_FPS(framesPerSecond),
 																	SET_MPEG_ASPECT_RATIO(aspectRatio),

																	SET_MPEG_VIDEOSTANDARD(videoStandard),
																	SET_MPEG_APP_VIDEOSTANDARD(videoStandard),

 																	SET_MPEG2_PRESENTATION_MODE(m2mode),

																	SET_MPEG_SIGNAL_POSITION(0),
																	SET_MPEG2_FORCED_SOURCE_ASPECT_RATIO(forcedRatio),

																	TAGDONE));

#else

		GNREASSERT(VDR_ConfigureUnitsTags(decUnits,  SET_MPEG2_SPU_STREAMID(0x20 | (subPictureStreamID & 0x3f)),
 																	SET_MPEG2_SPU_ENABLE(XTBF(6, subPictureStreamID)),

																	SET_MPEG_VIDEO_STREAMID(0xe0),
																	SET_MPEG_VIDEO_BITRATE(5000000),
																	SET_MPEG_STREAM_BITRATE(7000000),

 																	SET_MPEG_VIDEO_WIDTH(width),
 																	SET_MPEG_VIDEO_HEIGHT(height),
 																	SET_MPEG_VIDEO_FPS(framesPerSecond),
 																	SET_MPEG_ASPECT_RATIO(aspectRatio),
 																	SET_MPEG_VIDEOSTANDARD(videoStandard),
 																	SET_MPEG2_PRESENTATION_MODE(m2mode),

																	SET_MPEG_SIGNAL_POSITION(0),
																	SET_MPEG2_FORCED_SOURCE_ASPECT_RATIO(forcedRatio),

																	TAGDONE));
#endif

		transferCount = 0;
		transferTotal = 0;
		transferCountRemainder = 0;
//		GNREASSERT(VDR_DoMPEGCommand(units, mpc_seek, 0));
		PerformSeek();
		GNREASSERT(VDR_SendMPEGCommand(units, backward ? mpc_reverse : mpc_resync, 0, tag));
		}
	else
		{
//		DP("Partial change");

		this->audioStreamID = audioStreamID;
		this->subPictureStreamID = subPictureStreamID;

		if (audioStreamID != 0x0f)
			{
			GNREASSERT(VDR_ConfigureUnitsTags(decUnits,  SET_MPEG_AUDIO_STREAMID(0xc0 | audioStreamID),
																		SET_MPEG2_AUDIO_AC3_STREAMID(0x80 | audioStreamID),
																		SET_MPEG2_AUDIO_LPCM_STREAMID(0xa0 | audioStreamID),
																		SET_MPEG2_AUDIO_DTS_STREAMID(0x88 | audioStreamID),
																		TAGDONE));
			}

		GNREASSERT(VDR_ConfigureUnitsTags(units,  SET_MPEG2_SPU_STREAMID(0x20 | (subPictureStreamID & 0x3f)),
 																SET_MPEG2_SPU_ENABLE(XTBF(6, subPictureStreamID)),
																TAGDONE));

		}

	GNREASSERT(VDR_ActivateUnits(units));
	expectingDone = FALSE;

	GNRAISE_OK;
	}

//
//  Set Still Frame Sequence Mode
//

void DVDPlayer::SetStillFrameSequenceMode(BOOL stillFrameSequence)
	{
	DWORD tag;

	if (stillFrameSequence != this->stillFrameSequence)
		{
		this->stillFrameSequence = stillFrameSequence;

		VDR_ConfigureUnitsTags(units,  SET_MPEG2_STILL_FRAME_SEQUENCE(stillFrameSequence),
												TAGDONE);

		transferCount = 0;
		transferTotal = 0;
		transferCountRemainder = 0;
		PerformSeek();
		VDR_SendMPEGCommand(units, backward ? mpc_reverse : mpc_resync, 0, tag);
		}
	}

//
//  Set video standard
//

Error DVDPlayer::SetVideoStandard(WORD videoAttr)
	{
	VideoStandard newVideoStandard;

	if (videoAttr != this->videoAttr)
		{
		switch (XTBF(12, 2, videoAttr))
			{
			case 0:
				newVideoStandard = VSTD_NTSC;
				break;
			case 1:
				newVideoStandard = VSTD_PAL;
				break;
			}

		if (videoStandard != newVideoStandard)
			SendEvent(DNE_VIDEO_STANDARD_CHANGE, videoStandard);
		videoStandard = newVideoStandard;

		GNREASSERT(VDR_PassivateUnits(decUnits));
		GNREASSERT(VDR_ConfigureUnitsTags(units, SET_PIP_VIDEOSTANDARD(videoStandard),
			                                      SET_VID_VIDEOSTANDARD(videoStandard),
															  SET_MPEG_VIDEOSTANDARD(videoStandard),
															  TAGDONE));
		}

	GNRAISE_OK;
	}

//
//  Set subpicture palette
//

Error DVDPlayer::SetSubPicturePalette(int entry, DWORD color)
	{
	return VDR_ConfigureUnitsTags(units, SET_MPEG2_SPU_PALETTE_ENTRY(color | entry), TAGDONE);
	}

//
//  Set analog copy protection mode
//

Error DVDPlayer::SetAnalogCopyProtectionMode(int mode)
	{
//	DP("Mode : %d", mode);

	return VDR_ConfigureUnitsTags(units, SET_ENC_COPY_PROTECTION(mode), TAGDONE);
	}

//
//  Set digital out copy managment mode
//

Error DVDPlayer::SetCopyManagementMode(GenericCopyManagementInfo mode)
	{
	SPDIFCopyMode spdifCopyMode;
	VideoCopyMode vidCopyMode;

	switch (mode)
		{
		case GCMI_NO_RESTRICTION :
			spdifCopyMode	= SPDIFCM_UNRESTRICTED;
			vidCopyMode		= VCPMD_COPYING_PERMITTED;
			break;

		case GCMI_ONE_GENERATION :
			spdifCopyMode	= SPDIFCM_ONE_GENERATION;
			vidCopyMode		= VCPMD_ONE_COPY_PERMITTED;
			break;

		case GCMI_COPY_FORBIDDEN :
			spdifCopyMode	= SPDIFCM_NO_COPIES ;
			vidCopyMode		= VCPMD_NO_COPYING_PERMITTED;
			break;

		default :
			spdifCopyMode	= SPDIFCM_NO_COPIES;
			vidCopyMode		= VCPMD_DEFAULT;
			break;
		}

	GNRAISE(VDR_ConfigureUnitsTags(units,
											 SET_MPEG2_SPDIF_COPY_MODE(spdifCopyMode),
											 SET_ENC_COPY_MODE(vidCopyMode),
											 TAGDONE));
	}

//
//  Send data multiple
//

DWORD DVDPlayer::SendDataMultiple(MPEGDataSizePair * data, DWORD size)
	{
	DWORD tag;
	DWORD done;
	MPEGState state;

	lock.Enter();

	expectingDone = FALSE;

#if MEASURE_TRANSFER_RATE
int time;
time = Timer.GetMicroTicks();
#endif

	switch (state = VDR_CurrentMPEGState(units))
		{
		case mps_reset:
		case mps_preempted:
			lock.Leave();
			return 0;
			break;
		case mps_stopped:
			FlushWorkMessages();
			VDR_CompleteMPEGRefillMessage(units);
			PerformSeek(); //	Includes: VDR_DoMPEGCommand(units, mpc_seek, 0);
			if (scanning)
				VDR_SendMPEGCommand(units, mpc_scan, 0, tag);
			else if (trickplay)
				VDR_SendMPEGCommand(units, mpc_trickplay, 0, tag);
			else if (backward)
				VDR_SendMPEGCommand(units, mpc_reverse, 0, tag);
			else
				VDR_SendMPEGCommand(units, mpc_resync, 0, tag);
			transferCount = 0;
			transferTotal = 0;
			transferCountRemainder = 0;
		case mps_seeking:
			done = VDR_SendMPEGDataMultiple(units, data, size);
			break;
		case mps_playing:
		case mps_resyncing:
		case mps_initial:
		case mps_frozen:
		case mps_scanning:
		case mps_stepping:
		case mps_trickplaying:
			done = VDR_SendMPEGDataMultiple(units, data, size);
			break;
		default:
			done = 0;
		}

#if MEASURE_TRANSFER_RATE
time = Timer.GetMicroTicks() - time;
static int timeSum;
static int dataSum;

timeSum += time;
dataSum += done;

if (timeSum >= 1000000)
	{
	printf("Write KBytes per sec %d\n", ScaleDWord(dataSum, timeSum, 1000));
	timeSum = dataSum = 0;
	}
#endif

	transferTotal += done;
//#if ST20LITE
	KernelInt64 temp = transferTotal >> 11;
	transferCount = temp.ToDWORD();
	temp = transferTotal & (DVD_BLOCK_SIZE - 1);
	transferCountRemainder = temp.ToDWORD();

	lock.Leave();

	return done;
	}

//
//  Send data
//

DWORD DVDPlayer::SendData(HBPTR data, DWORD size)
	{
	DWORD tag;
	DWORD done;
	MPEGState state;

	lock.Enter();

	expectingDone = FALSE;

#if MEASURE_TRANSFER_RATE
int time;
time = Timer.GetMicroTicks();
#endif

	switch (state = VDR_CurrentMPEGState(units))
		{
		case mps_reset:
		case mps_preempted:
			lock.Leave();
			return 0;
			break;
		case mps_stopped:
			FlushWorkMessages();
			VDR_CompleteMPEGRefillMessage(units);
			PerformSeek(); //	Includes: VDR_DoMPEGCommand(units, mpc_seek, 0);
			if (scanning)
				VDR_SendMPEGCommand(units, mpc_scan, 0, tag);
			else if (trickplay)
				VDR_SendMPEGCommand(units, mpc_trickplay, 0, tag);
			else if (backward)
				VDR_SendMPEGCommand(units, mpc_reverse, 0, tag);
			else
				VDR_SendMPEGCommand(units, mpc_resync, 0, tag);
			transferCount = 0;
			transferTotal = 0;
			transferCountRemainder = 0;
		case mps_seeking:
			done = VDR_SendMPEGData(units, data, size);
			break;
		case mps_playing:
		case mps_resyncing:
		case mps_initial:
		case mps_frozen:
		case mps_scanning:
		case mps_stepping:
		case mps_trickplaying:
			done = VDR_SendMPEGData(units, data, size);
			break;
		default:
			done = 0;
		}

#if MEASURE_TRANSFER_RATE
time = Timer.GetMicroTicks() - time;
static int timeSum;
static int dataSum;

timeSum += time;
dataSum += done;

if (timeSum >= 1000000)
	{
	printf("Write KBytes per sec %d\n", ScaleDWord(dataSum, timeSum, 1000));
	timeSum = dataSum = 0;
	}
#endif

	transferTotal += done;
//#if ST20LITE
	KernelInt64 temp = transferTotal >> 11;
	transferCount = temp.ToDWORD();
	temp = transferTotal & (DVD_BLOCK_SIZE - 1);
	transferCountRemainder = temp.ToDWORD();

	lock.Leave();

	return done;
	}

//
//  Complete data
//

void DVDPlayer::CompleteData(void)
	{
	lock.Enter();
//	DP("complete data");
	expectingDone = TRUE;
	VDR_CompleteMPEGData(units);
	lock.Leave();
	}

//
//  Cancel data
//

void DVDPlayer::CancelData(void)
	{
	DWORD tag;

	lock.Enter();

//	DP("cancel data");

	PerformSeek();
	VDR_SendMPEGCommand(units, backward ? mpc_reverse : mpc_resync, 0, tag);
	transferCount = 0;
	transferTotal = 0;
	transferCountRemainder = 0;
	Timer.WaitMilliSecs(20);
	FlushWorkMessages();
	VDR_CompleteMPEGRefillMessage(units);
	scanning = FALSE;
	trickplay = FALSE;
	expectingDone = FALSE;

	lock.Leave();
	}

//
//  Set callback
//

void DVDPlayer::SetCallback(DWORD position, DVDStreamServer * callback)
	{
	DWORD cp = VDR_CurrentMPEGLocation(units);
	MPEGState state;

	this->callback = NULL;

//	DP("Set Callback %d %d", position, cp);

	state = VDR_CurrentMPEGState(units);

	if ((state == mps_playing || state == mps_stepping) && position < cp)
		{
		callbackPosition = 0;
		VDR_ConfigureUnitsTags(units, SET_MPEG_SIGNAL_POSITION(0), TAGDONE);
		callback->PlayerCallback(cp);
		}
	else
		{
		callbackPosition = position;
		this->callback = callback;
		VDR_ConfigureUnitsTags(units, SET_MPEG_SIGNAL_POSITION(position), TAGDONE);
		cp = VDR_CurrentMPEGLocation(units);
		if (cp >= position)
			{
			RequestCallback(callbackPosition);
			VDR_ConfigureUnitsTags(units, SET_MPEG_SIGNAL_POSITION(0), TAGDONE);
			}
		}
	}

//
//  Cancel callback
//

void DVDPlayer::CancelCallback(void)
	{
	this->callback = 0;
	VDR_ConfigureUnitsTags(units, SET_MPEG_SIGNAL_POSITION(0), TAGDONE);
	}

//
//  Wait for callback canceled
//

void DVDPlayer::WaitForCallbackCanceled(void)
	{
	while (inCallback)
		{
		Timer.WaitMilliSecs(100);
		}
	}

//
//  Return current location
//

DWORD DVDPlayer::CurrentLocation(void)
	{
	return VDR_CurrentMPEGLocation(units);
	}

//
//  Test if decoder is done
//

BOOL DVDPlayer::Completed(void)
	{
	MPEGState state = VDR_CurrentMPEGState(units);

	return state == mps_stopped;
	}

//
//  Start Playback
//

void DVDPlayer::StartPlayback(void)
	{
	DWORD tag;

	lock.Enter();

	if (scanning || trickplay)
		{
		DP("Starting from scan or backward");
		scanning = FALSE;
		trickplay = FALSE;
		PerformSeek();
		VDR_SendMPEGCommand(units, backward ? mpc_reverse : mpc_resync, 0, tag);
		expectingDone = FALSE;
		}

	if (!paused)
		VDR_SendMPEGCommand(units, mpc_play, playbackSpeed, tag);

	lock.Leave();
	}

//
//  Start Scanning
//

void DVDPlayer::StartScan(void)
	{
	DWORD tag;

	lock.Enter();


	if (!scanning)
		{
		DP("Scanning from start");
		scanning = TRUE;
		trickplay = FALSE;
		PerformSeek();
		VDR_SendMPEGCommand(units, mpc_scan, 0, tag);
		expectingDone = FALSE;
		}

	lock.Leave();
	}

//
//  Start trickplay
//

void DVDPlayer::StartTrickplay(void)
	{
	DWORD tag;

	lock.Enter();

	if (!trickplay)
		{
		DP("Scanning from start");
		trickplay = TRUE;
		scanning = FALSE;
		PerformSeek();
		VDR_SendMPEGCommand(units, mpc_trickplay, 0, tag);
		expectingDone = FALSE;
		}

	lock.Leave();
	}

//
//  Start reverse playback
//

void DVDPlayer::SetReversePlayback(BOOL reverse)
	{
	DWORD tag;

	lock.Enter();

	if (reverse != backward)
		{
		backward = reverse;

		PerformSeek();
		VDR_SendMPEGCommand(units, backward ? mpc_reverse : mpc_resync, 0, tag);
		expectingDone = FALSE;
		}

	lock.Leave();
	}

//
//  Set button colors
//

Error DVDPlayer::SetButtonColors(DWORD select, DWORD active)
	{
	return VDR_ConfigureUnitsTags(units, SET_MPEG2_SPU_BUTTON_SELECT_COLOR(select),
	                                     SET_MPEG2_SPU_BUTTON_ACTIVE_COLOR(active),
	                                     TAGDONE);
	}

//
//  Set button position
//

Error DVDPlayer::SetButtonPosition(WORD group, WORD button, WORD x, WORD y, WORD w, WORD h)
	{
	DP("Set Button pos %d,%d - %d,%d", x, y, w, h);
	return VDR_ConfigureUnitsTags(units, SET_MPEG2_SPU_BUTTON_ID(MAKEWORD(button, group)),
		                                  SET_MPEG2_SPU_BUTTON_LEFT(x),
	                                     SET_MPEG2_SPU_BUTTON_TOP(y),
	                                     SET_MPEG2_SPU_BUTTON_WIDTH(w),
	                                     SET_MPEG2_SPU_BUTTON_HEIGHT(h),
	                                     TAGDONE);
	}

//
//  Set button off
//

Error DVDPlayer::SetButtonOff(void)
	{
	return VDR_ConfigureUnitsTags(units, SET_MPEG2_SPU_BUTTON_STATE(SBS_DISABLED), TAGDONE);
	}

//
//  Set button select
//

Error DVDPlayer::SetButtonSelect(void)
	{
	return VDR_ConfigureUnitsTags(units, SET_MPEG2_SPU_BUTTON_STATE(SBS_SELECTED), TAGDONE);
	}

//
//  Set button active
//

Error DVDPlayer::SetButtonActive(void)
	{
	return VDR_ConfigureUnitsTags(units, SET_MPEG2_SPU_BUTTON_STATE(SBS_ACTIVATED), TAGDONE);
	}

//
//  Transfer disk key
//

Error DVDPlayer::TransferDiskKey(DVDHeaderFile * file)
	{
	Error err;
	BYTE buffer[DVD_BLOCK_SIZE];
	int retry;

	GNREASSERT(VDR_LockUnits(units));

	for (retry = 0; retry < 3; retry++)
		{
		if (!IS_ERROR(VDR_ActivateUnits(units)))
			{
			if (!IS_ERROR(err = file->DoAuthenticationCommand(DAC_START_AUTHENTICATION, buffer)))
				{
				if (!IS_ERROR(err = VDR_DoAuthenticationCommand(units, M2D_START_AUTHENTICATION, 0, buffer)))
					{
					if (!IS_ERROR(err = VDR_DoAuthenticationCommand(units, M2D_READ_CHALLENGE_KEY, 0, buffer)) &&
						 !IS_ERROR(err = file->DoAuthenticationCommand(DAC_WRITE_CHALLENGE_KEY, buffer)) &&
						 !IS_ERROR(err = file->DoAuthenticationCommand(DAC_READ_BUS_KEY, buffer)) &&
						 !IS_ERROR(err = VDR_DoAuthenticationCommand(units, M2D_WRITE_BUS_KEY, 0, buffer)) &&
						 !IS_ERROR(err = file->DoAuthenticationCommand(DAC_READ_CHALLENGE_KEY, buffer)) &&
						 !IS_ERROR(err = VDR_DoAuthenticationCommand(units, M2D_WRITE_CHALLENGE_KEY, 0, buffer)) &&
						 !IS_ERROR(err = VDR_DoAuthenticationCommand(units, M2D_READ_BUS_KEY, 0, buffer)) &&
						 !IS_ERROR(err = file->DoAuthenticationCommand(DAC_WRITE_BUS_KEY, buffer)) &&
						 !IS_ERROR(err = file->DoAuthenticationCommand(DAC_READ_DISK_KEY, buffer)) &&
						 !IS_ERROR(err = VDR_DoAuthenticationCommand(units, M2D_WRITE_DISK_KEY, 0, buffer)))
						{
						if (!IS_ERROR(err = VDR_DoAuthenticationCommand(units, M2D_COMPLETE_AUTHENTICATION, 0, buffer)))
							{
							if (!IS_ERROR(err = file->DoAuthenticationCommand(DAC_COMPLETE_AUTHENTICATION, buffer)))
								{
								GNREASSERT(VDR_UnlockUnits(units));

								GNRAISE_OK;
								}
							else
								{
								file->DoAuthenticationCommand(DAC_CANCEL_AUTHENTICATION, buffer);

								GNREASSERT(VDR_UnlockUnits(units));

								GNRAISE(err);
								}
							}
						}
					}

				VDR_DoAuthenticationCommand(units, M2D_CANCEL_AUTHENTICATION, 0, buffer);
				}

			file->DoAuthenticationCommand(DAC_CANCEL_AUTHENTICATION, buffer);
			}

		VDR_PassivateUnits(units);
		}

	GNREASSERT(VDR_UnlockUnits(units));

	return err;
	}

//
//  Transfer title key
//

Error DVDPlayer::TransferTitleKey(DVDDataFile * file)
	{
	Error err;
	BYTE buffer[DVD_BLOCK_SIZE];
	DWORD sector;
	int retry;

	GNREASSERT(VDR_LockUnits(units));
	if (!IS_ERROR(err = VDR_ActivateUnits(units)))
		{
		GNREASSERT(VDR_ConfigureUnitsTags(units, SET_MPEG2_DVD_STREAM_ENCRYPTED(TRUE), TAGDONE));

		for (retry = 0; retry < 4; retry++)
			{
			if (!IS_ERROR(err = file->DoAuthenticationCommand(DAC_START_AUTHENTICATION, sector, buffer, retry)))
				{
				if (!IS_ERROR(err = VDR_DoAuthenticationCommand(units, M2D_START_AUTHENTICATION, sector, buffer)))
					{
					if (!IS_ERROR(err = VDR_DoAuthenticationCommand(units, M2D_READ_CHALLENGE_KEY, sector, buffer)) &&
						 !IS_ERROR(err = file->DoAuthenticationCommand(DAC_WRITE_CHALLENGE_KEY, sector, buffer, retry)) &&
						 !IS_ERROR(err = file->DoAuthenticationCommand(DAC_READ_BUS_KEY, sector, buffer, retry)) &&
						 !IS_ERROR(err = VDR_DoAuthenticationCommand(units, M2D_WRITE_BUS_KEY, sector, buffer)) &&
						 !IS_ERROR(err = file->DoAuthenticationCommand(DAC_READ_CHALLENGE_KEY, sector, buffer, retry)) &&
						 !IS_ERROR(err = VDR_DoAuthenticationCommand(units, M2D_WRITE_CHALLENGE_KEY, sector, buffer)) &&
						 !IS_ERROR(err = VDR_DoAuthenticationCommand(units, M2D_READ_BUS_KEY, sector, buffer)) &&
						 !IS_ERROR(err = file->DoAuthenticationCommand(DAC_WRITE_BUS_KEY, sector, buffer, retry)) &&
						 !IS_ERROR(err = file->DoAuthenticationCommand(DAC_READ_TITLE_KEY, sector, buffer, retry)) &&
						 !IS_ERROR(err = VDR_DoAuthenticationCommand(units, M2D_WRITE_TITLE_KEY, sector, buffer)))
						{
						if (!IS_ERROR(err = VDR_DoAuthenticationCommand(units, M2D_COMPLETE_AUTHENTICATION, sector, buffer)))
							{
							if (!IS_ERROR(err = file->DoAuthenticationCommand(DAC_COMPLETE_AUTHENTICATION, sector, buffer, retry)))
								{
								GNREASSERT(VDR_UnlockUnits(units));

								GNRAISE_OK;
								}
							else
								{
								file->DoAuthenticationCommand(DAC_CANCEL_AUTHENTICATION, sector, buffer, retry);

								GNREASSERT(VDR_UnlockUnits(units));

								GNRAISE(err);
								}
							}
						}
					}

				VDR_DoAuthenticationCommand(units, M2D_CANCEL_AUTHENTICATION, sector, buffer);
				}

			file->DoAuthenticationCommand(DAC_CANCEL_AUTHENTICATION, sector, buffer, retry);
			}

		VDR_PassivateUnits(units);
		}

	GNREASSERT(VDR_UnlockUnits(units));

	if (err == GNR_OBJECT_NOT_FOUND) err = GNR_OK;

	return err;
	}

Error DVDPlayer::CancelTitleKey(void)
	{
	BYTE buffer[DVD_BLOCK_SIZE];
	DWORD sector = 0;

	VDR_DoAuthenticationCommand(units, M2D_START_AUTHENTICATION, sector, buffer);
	VDR_DoAuthenticationCommand(units, M2D_CANCEL_AUTHENTICATION, sector, buffer);

	GNREASSERT(VDR_ConfigureUnitsTags(units,
												 SET_MPEG2_DVD_STREAM_ENCRYPTED(FALSE),
												 TAGDONE));

	GNRAISE_OK;
	}

//
//  Perform seek and invalidate timeBase
//

void DVDPlayer::PerformSeek(void)
	{
	Error err;
	LONG decoderTime;

	VDR_DoMPEGCommand(units, mpc_seek, 0);
	if (timeBaseValid)
		{
		if (!IS_ERROR(err = VDR_ConfigureUnitsTags(units, GET_MPEG2_CURRENT_PLAYBACK_TIME(decoderTime), TAGDONE)))
			lastDecoderTime = decoderTime;
		else
			lastDecoderTime = 0;
		}
	timeBaseValid = FALSE;
	}

//
//  Set time base
//

void DVDPlayer::SetTimeBase(DVDTime newTimeBase)
	{
	if (!timeBaseValid)
		{
		timeBase = newTimeBase;
		timeBaseValid = TRUE;
		}
	}
//
//  Get current playback time
//

Error DVDPlayer::GetPlaybackTime(DVDTime & playbackTime)
	{
	LONG decoderTime;

	if (timeBaseValid)
		{
		GNREASSERT(VDR_ConfigureUnitsTags(units, GET_MPEG2_CURRENT_PLAYBACK_TIME(decoderTime), TAGDONE));
		playbackTime = timeBase + DVDTime(0, 0, 0, (decoderTime * timeBase.FrameRate()) / 1000,
													timeBase.FrameRate());
		}
	else
		{
		GNRAISE(GNR_OBJECT_INVALID);
		/*

		playbackTime = timeBase + DVDTime(0, 0, 0, (lastDecoderTime * timeBase.FrameRate()) / 1000,
													timeBase.FrameRate());
													*/
		}

	GNRAISE_OK;
	}

//
//  Get requested VOBU ID
//

DWORD DVDPlayer::GetRequestedVOBUID(void)
	{
	DWORD data;

	if (IS_ERROR(VDR_ConfigureUnitsTags(units, GET_MPEG_CURRENT_STREAM_SEGMENT(data), TAGDONE)))
		return 0;
	else
		return data;
	}

//
//  Set first available VOBU ID
//

void DVDPlayer::SetFirstAvailableVOBUID(DWORD id)
	{
	VDR_ConfigureUnitsTags(units, SET_MPEG_FIRST_STREAM_SEGMENT(id), TAGDONE);
	}

//
//  Set last available VOBU ID
//

void DVDPlayer::SetLastAvailableVOBUID(DWORD id)
	{
	VDR_ConfigureUnitsTags(units, SET_MPEG_LAST_STREAM_SEGMENT(id), TAGDONE);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDPlayer.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
//  DVD Player Class
//
//////////////////////////////////////////////////////////////////////

#ifndef DVDPLAYER_H
#define DVDPLAYER_H

#include "DVDStreamServer.h"
#include "DVDHliCtrl.h"
#include "Boards/Generic/vdgendrv.h"
#include "Library/Common/WinPorts.h"
#include "Library/Common/KrnlSync.h"
#include "DVDTime.h"

class DVDPlayer : public DVDStreamPlayer, public DVDSPUDisplay, private EventPortWorkerThread
	{
	protected:
		UnitSet				units, decUnits;
		DVDStreamServer * callback;
		DVDStreamServer * refiller;
		VDLocalMutex		lock;

		DWORD					callbackPosition;

		BOOL scanning, trickplay, expectingDone, backward, paused;

		void WorkMessage(WPARAM wParam, LPARAM dParam);

		KernelInt64 transferTotal;

		WORD playbackSpeed;
		WORD videoAttr;
		WORD audioStreamID;
		WORD audioAttr;
		WORD subPictureStreamID;
		WORD subPictureAttr;
		BOOL stillFrameSequence;
		DisplayPresentationMode presentationMode;
		VideoStandard videoStandard;

		DVDTime	timeBase;
		BOOL		timeBaseValid;
		LONG		lastDecoderTime;

		volatile BOOL inCallback;

		void PerformSeek(void);

	public:
		DVDPlayer(WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher);
		virtual ~DVDPlayer(void);

		Error Pause(void);
		Error Resume(void);
		Error Step(void);
		Error StepBy(int value);
		Error SetPlaybackSpeed(WORD speed);
		WORD	GetPlaybackSpeed(void) {return playbackSpeed;}

		BOOL IsPaused(void);
		BOOL IsPreempted(void);

		void	ExtractAudioAttributes(WORD audioAttr, MPEG2AudioType & type, WORD & channels,
											  DWORD & audioBitsPerSecond, DWORD & samplesPerSecond, DWORD &bitsPerSample);
		Error SetAudioStreamAttributes(WORD audioStreamID, WORD audioAttr);
		Error GetAudioInformation(MPEG2PrologicStatus & prologicStatus, MPEG2LFEStatus & lfeStatus, AC3AudioCodingMode & ac3Mode);
		Error SetSubPictureStreamAttributes(WORD subPictureStreamID, WORD subPictureAttr);
		Error SetStreamAttributes(WORD videoAttr, WORD audioStreamID, WORD audioAttr,
		                          WORD subPictureStreamID, WORD subPictureAttr, DisplayPresentationMode mode);
		Error SetSubPicturePalette(int entry, DWORD color);

		Error				SetVideoStandard(WORD videoAttr);
		VideoStandard	GetCurrentVideoStandard(void) { return videoStandard; }
		int				GetCurrentFrameRate(void)		{ return videoStandard == VSTD_NTSC ? 30 : 25; }

		Error SetAnalogCopyProtectionMode(int mode);

		Error SetCopyManagementMode(GenericCopyManagementInfo mode);

		DWORD SendData(HBPTR data, DWORD size);
		DWORD SendDataMultiple(MPEGDataSizePair * data, DWORD size);
		void CompleteData(void);
		void CancelData(void);

		void SetRefiller(DVDStreamServer * refiller) {this->refiller = refiller;}
		void DeleteRefiller(void) {refiller = NULL;}
		void RequestRefill(void);

		void SetCallback(DWORD position, DVDStreamServer * callback);
		void CancelCallback(void);
		void WaitForCallbackCanceled(void);
		void RequestCallback(DWORD position);
		DWORD CurrentLocation(void);

		BOOL Completed(void);
		void SetStillFrameSequenceMode(BOOL stillFrameSequence);
		void StartPlayback(void);
		void StartScan(void);
		void StartTrickplay(void);
		void SetReversePlayback(BOOL reverse);
		void TerminatePlayback(void);

		Error SetButtonColors(DWORD select, DWORD active);
		Error SetButtonPosition(WORD group, WORD button, WORD x, WORD y, WORD w, WORD h);
		Error SetButtonOff(void);
		Error SetButtonSelect(void);
		Error SetButtonActive(void);

		Error TransferDiskKey(DVDHeaderFile * file);
		Error TransferTitleKey(DVDDataFile * file);
		Error CancelTitleKey(void);

		void	SetTimeBase(DVDTime timeBase);
		Error GetPlaybackTime(DVDTime & playbackTime);
		DWORD GetRequestedVOBUID(void);
		void SetFirstAvailableVOBUID(DWORD id);
		void SetLastAvailableVOBUID(DWORD id);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDSequencer.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// DVD Sequencer Module
//
// Description: Declares DVDSequencer. DVDSequencer is an abstract
//			class for all Sequencer classes.
//
//		DVDSequencer <-- DVDProgramChainSequencer <-- DVDTitleSequencer ...
//
//
///////////////////////////////////////////////////////////////////////////////


#ifndef DVDSEQUENCER_H
#define DVDSEQUENCER_H


#include "Breakpoint.h"


//
// Forward Declaration because of conflicts
// (DVDSequencer.h including DVDStreamServer.h
//	and DVDStreamServer.h including DVDSequencer.h)
//

class DVDCell;
class DVDVOBU;


////////////////////////////////////////////////////////////////////
//
//  DVDSequencer Class
//
////////////////////////////////////////////////////////////////////

class DVDSequencer : virtual public ERSBreakpointControl
	{
	friend class DVDVideoStreamServer;
	protected:
		virtual WORD CurrentAngle(void) = 0;
		virtual void AngleChanged(void) = 0;

		virtual BOOL BreakpointReached(DVDTime lowerLimit, DVDTime upperLimit, ERSPlaybackDir dir, ERSBreakpoint & bp) = 0;
		virtual BOOL BreakpointContained(int start, int length, BOOL lowest, ERSPlaybackDir dir, ERSBreakpoint & bp) = 0;
		virtual BOOL EndOfCellBreakpointReached(DVDCell * cell, ERSPlaybackDir dir, ERSBreakpoint & bp) = 0;
		virtual BOOL BeginOfCellBreakpointReached(DVDCell * cell, ERSPlaybackDir dir, ERSBreakpoint & bp) = 0;

		virtual Error VOBUStarted(DVDVOBU * vobu) {GNRAISE_OK;}
		virtual Error VOBUCompleted(DVDVOBU * vobu) {GNRAISE_OK;}

      virtual Error CellStarted(DVDCell * cell) {GNRAISE_OK;}
      virtual Error CellCompleted(DVDCell * cell) {GNRAISE_OK;}
		virtual Error CellCorrupt(DVDCell * cell) {GNRAISE_OK;}

		virtual Error PlaybackTerminated(Error err) {GNRAISE_OK;}

	public:
		DVDSequencer(EventDispatcher* pEventDispatcher)
			: EventSender(pEventDispatcher)
			, ERSBreakpointControl(pEventDispatcher)
			{}
		virtual ~DVDSequencer(void) {}
	};


#endif //DVDSEQUENCER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDStreamServer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD Stream Server Classes
//
////////////////////////////////////////////////////////////////////


#include "DVDStreamServer.h"
#include "Library/Common/vddebug.h"
#include "Library/Lowlevel/timer.h"
#include "DVDPlayer.h"



////////////////////////////////////////////////////////////////////
//
//  DVD VOBU Class
//
////////////////////////////////////////////////////////////////////

#define BREAKPOINT_DEFERRED	0	// Set this to 1 to have a seamless FFWD breakpoint still/still off


//
//  Constructor
//

DVDVOBU::DVDVOBU (void)
	{
	file = NULL;
	navPackBlock = 0xffffffff;
	}

//
//  Destructor
//

DVDVOBU::~DVDVOBU (void)
	{
	}

//
//  Initialize
//

void DVDVOBU::Init(DVDDataFile * file, DVDCell * cell, DWORD firstBlock, BOOL singleFrame)
	{
	state = VOS_READY;
	this->file = file;
	this->cell = cell;
	this->firstBlock = firstBlock;
	this->singleFrame = singleFrame;
	this->still = FALSE;
	navPackBlock = 0xffffffff;
	}

//
//  Cleanup
//

void DVDVOBU::Cleanup(void)
	{
	if (file && navPackBlock != 0xffffffff)
		{
		file->UnlockBlocks(navPackBlock, 1, &navPackDriveBlock, DAT_UNLOCK_CLEAN | DAF_STREAMING, &rh);
		file = NULL;
		navPackBlock = 0xffffffff;
		}
	state = VOS_FREE;
	}

//
//  Test on non-seamless angle change info
//

BOOL DVDVOBU::HasNonSeamlessAngleInfo(void)
	{
	int i;

	for (i=0; i<9; i++)
		{
		if (GetNVDWord(45 + 60 + 4 * i) != 0)
			return TRUE;
		}
	return FALSE;
	}

//
//  Test on seamless angle change info
//

BOOL DVDVOBU::HasSeamlessAngleInfo(void)
	{
	int i;

	for (i=0; i<9; i++)
		{
		if (GetNVDWord(1024 + 7 + 32 + 148 + 6 * i) != 0)
			return TRUE;
		}
	return FALSE;
	}

//
//  Find next navigation pack
//

Error DVDVOBU::FindNextNavigationPack(DWORD final, WORD angle, BOOL & suspendTransfer)
	{
	Error error = GNR_FILE_READ_ERROR;
	DWORD step, next;

	//
	//  Repeat until end of search area
	//

	DP("Starting search of next nav pack from %d to %d", firstBlock, final);

	step = 64;
	while (error == GNR_FILE_READ_ERROR && firstBlock < final)
		{
		if (suspendTransfer) GNRAISE(GNR_OPERATION_ABORTED);

		DP("In Recover for %08lx until %08lx\n", firstBlock, final);

		//
		//  Find a readable block
		//

		firstBlock += step;
		while (firstBlock <= final && (error = ReadNavPackData(firstBlock)) == GNR_FILE_READ_ERROR)
			{
			DP("Bad block at %08lx\n", firstBlock);
			step *= 2;
			firstBlock += step;
			if (suspendTransfer) GNRAISE(GNR_OPERATION_ABORTED);
			}
		if (firstBlock > final) firstBlock = final;

		//
		//  Look for PCI and DSI data
		//
		while (firstBlock < final && error == GNR_OK && (GetNVDWord(38) != 0x000001bf || GetNVDWord(1024) != 0x000001bf))
			{
			firstBlock++;
			error = ReadNavPackData(firstBlock);
			}

		DP("Found Nav Pack at %08lx\n", firstBlock);

		//
		//  Could not recover inside area
		//

		if (firstBlock == final)
			GNRAISE(GNR_RANGE_VIOLATION);

		//
		//  Ok, we found a nav pack
		//

		if (error == GNR_OK)
			{
			//
			// Skip that VOBU and continue with next
			//

			next = NextVOBU();
			if (next != 0x3fffffff)
				{
				//
				//  Read Nav Pack of next VOBU
				//

				error = ReadNavPackData(next);
				if (error == GNR_OK && GetNVDWord(1024) == 0x000001bf)
					{
					DP("Checking second OK %08lx\n", next);
					error = ReadNavPackData(firstBlock);
					}
				else
					{
					DP("Checking second Failed %08lx\n", next);
					error = GNR_FILE_READ_ERROR;
					}
				}

			//
			// Now find next VOBU for current angle
			//

			if (!IS_ERROR(error))
				{
				if (singleFrame)
					numBlocks = GetDSIDWord(12) + 1;
				else
					numBlocks = GetDSIDWord(8) + 1;
				}
			}
		}

	DP("Now leaving search with error %08lx", error);

	GNRAISE(error);
	}

//
//  Read navigation pack
//

Error DVDVOBU::ReadNavigationPack(void)
	{
	GNREASSERT(ReadNavPackData(firstBlock));

	if (GetNVDWord(38) != 0x000001bf || GetNVDWord(1024) != 0x000001bf)
		{
		DP("Tertiary Error reading NavPack");
		file->UnlockBlocks(firstBlock, 1, &navPackDriveBlock, DAT_UNLOCK_CLEAN | DAF_STREAMING, &rh);
		navPackBlock = 0xffffffff;

		GNRAISE(GNR_FILE_READ_ERROR);
		}
	else
		{
		if (singleFrame)
			numBlocks = GetDSIDWord(12) + 1;
		else
			numBlocks = GetDSIDWord(8) + 1;

		GNRAISE_OK;
		}
	}

//
//  Read navpack data
//

Error DVDVOBU::ReadNavPackData(DWORD block)
	{
	Error err;

	if (navPackBlock != 0xffffffff)
		{
		file->UnlockBlocks(navPackBlock, 1, &navPackDriveBlock, DAT_UNLOCK_CLEAN | DAF_STREAMING, &rh);
		}

	if (!IS_ERROR(err = file->LockBlocks(block, 1, &navPackDriveBlock, DAT_LOCK_AND_READ | DAF_STREAMING, &rh)))
		{
		if (navPackDriveBlock.data[0] != 0x00 || navPackDriveBlock.data[1] != 0x00 ||
			 navPackDriveBlock.data[2] != 0x01 || navPackDriveBlock.data[3] != 0xba)
			{
			DP("Secondary Error reading NavPack");
			file->UnlockBlocks(block, 1, &navPackDriveBlock, DAT_UNLOCK_CLEAN | DAF_STREAMING, &rh);
			navPackBlock = 0xffffffff;

			err = GNR_FILE_READ_ERROR;
			}
		else
			navPackBlock = block;
		}
	else
		{
		DP("Error reading NavPack");
		file->UnlockBlocks(block, 1, &navPackDriveBlock, DAT_UNLOCK_CLEAN | DAF_STREAMING, &rh);
		navPackBlock = 0xffffffff;
		}

	GNRAISE(err);
	}

//
//  Get Navigation Bytes
//

void DVDVOBU::GetNVBytes(FPTR buff, int at, int num)
	{
	int i;

	for(i=0; i<num; i++)
		{
		((BYTE *)buff)[i] = navPackDriveBlock.data[at+i];
		}
	}

//
//  Find the VOBU which is closest to the requested time (in the future)
//

DWORD DVDVOBU::NextTemporalVOBU(WORD halfSeconds)
	{
	DWORD succ;

	if (halfSeconds > 180)
		succ = GetDSIDWord(234 + 4) & 0x3fffffff;
	else if (halfSeconds > 90)
		succ = GetDSIDWord(234 + 8) & 0x3fffffff;
	else if (halfSeconds > 40)
		succ = GetDSIDWord(234 + 12) & 0x3fffffff;
	else if (halfSeconds > 17)
		succ = GetDSIDWord(234 + 16) & 0x3fffffff;
	else if (halfSeconds > 15)
		succ = GetDSIDWord(234 + 20) & 0x3fffffff;	// Go back to 15 half seconds
	else if (halfSeconds > 1)
		succ = GetDSIDWord(234 + (20 - halfSeconds) * 4) & 0x3fffffff;
	else
		succ = GetDSIDWord(234) & 0x3fffffff; // Direct successor

	if (succ != 0x3fffffff) succ += firstBlock;

	return succ;
	}

//
//  Find the next VOBU which is before ("lower") the requested point in time
//

DWORD DVDVOBU::NextLowerTemporalVOBU(WORD halfSeconds)
	{
	DWORD succ;

	if (halfSeconds >= 240)
		succ = GetDSIDWord(234 + 4) & 0x3fffffff;
	else if (halfSeconds >= 120)
		succ = GetDSIDWord(234 + 8) & 0x3fffffff;
	else if (halfSeconds >= 60)
		succ = GetDSIDWord(234 + 12) & 0x3fffffff;
	else if (halfSeconds >= 20)
		succ = GetDSIDWord(234 + 16) & 0x3fffffff;
	else if (halfSeconds > 15)
		succ = GetDSIDWord(234 + 20) & 0x3fffffff;	// Go back to 15 half seconds
	else if (halfSeconds >= 1)
		succ = GetDSIDWord(234 + 20 + (15 - halfSeconds) * 4) & 0x3fffffff;
	else
		succ = GetDSIDWord(234) & 0x3fffffff; // Direct successor

	if (succ != 0x3fffffff) succ += firstBlock;

	return succ;
	}

//
//  Find the VOBU which is closest to the requested time (in the past)
//

DWORD DVDVOBU::PrevTemporalVOBU(WORD halfSeconds)
	{
	DWORD succ;

	if (halfSeconds > 180)
		succ = GetDSIDWord(234 + 160) & 0x3fffffff;
	else if (halfSeconds > 90)
		succ = GetDSIDWord(234 + 156) & 0x3fffffff;
	else if (halfSeconds > 40)
		succ = GetDSIDWord(234 + 152) & 0x3fffffff;
	else if (halfSeconds > 17)
		succ = GetDSIDWord(234 + 148) & 0x3fffffff;
	else if (halfSeconds > 15)
		succ = GetDSIDWord(234 + 144) & 0x3fffffff;	// Go back to 15 half seconds
	else if (halfSeconds > 1)
		succ = GetDSIDWord(234 + (21 + halfSeconds) * 4) & 0x3fffffff;
	else
		succ = GetDSIDWord(234 + 164) & 0x3fffffff; // Direct successor

	if (succ != 0x3fffffff) succ = firstBlock - succ;

	return succ;
	}

BOOL DVDVOBU::IsLastVOBUinILVU(void)
	{
	DWORD next = GetDSIDWord(8);

	return (next == GetDSIDWord(32 + 2) && XTBF(14, GetDSIWord(32)));
	}

DWORD DVDVOBU::NextVOBU(void)
	{
	DWORD next = GetDSIDWord(8);

	if (next == GetDSIDWord(32 + 2) && XTBF(14, GetDSIWord(32)))
		{
		return firstBlock + GetDSIDWord(32 + 6);
		}
	else
		return firstBlock + next + 1;
	}

DWORD DVDVOBU::PrevVOBU(void)
	{
	DWORD succ = GetDSIDWord(398) & 0x3fffffff;

	if (succ != 0x3fffffff) succ = firstBlock - succ;

	return succ;
	}

BOOL DVDVOBU::HasVideoData(void)
	{
	return GetDSIDWord(12) != 0;
	}

DWORD DVDVOBU::SeamlessAngleChangeVOBU(WORD angle)
	{
	DWORD succ;

	succ = GetDSIDWord(180 + 6 * (angle - 1)) & 0x7fffffff;
	if (succ != 0x7fffffff)
		succ += firstBlock;

	return succ;
	}

DWORD DVDVOBU::NonSeamlessAngleChangeVOBU(WORD angle)
	{
	DWORD succ;

	succ = GetPCIDWord(60 + 4 * (angle - 1));
	if (succ)
		{
		if (succ & 0x80000000)
			succ = firstBlock - (succ & 0x7fffffff);
		else
			succ = firstBlock + (succ & 0x7fffffff);
		}

	return succ;
	}

DWORD	DVDVOBU::GetSPTM(void)
	{
	return GetPCIDWord(12);
	}

DWORD DVDVOBU::GetEPTM(void)
	{
	return GetPCIDWord(16);
	}

DVDTime DVDVOBU::GetTimeOffset(void)
	{
	return DVDTime(GetPCIDWord(24));
	}

DVDTime DVDVOBU::GetDuration(void)
	{
	return DVDTime(GetPCIDWord(16) - GetPCIDWord(12), 90, (GetPCIDWord(24) & 0xc) == 0x4 ? 25 : 30);
	}

////////////////////////////////////////////////////////////////////
//
//  DVD Stream Buffer Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

DVDStreamBuffer::DVDStreamBuffer(DWORD bufferSize)
	{
	this->bufferSize = bufferSize * DVD_BLOCK_SIZE;

	Flush();
	}

//
//  Destructor
//

DVDStreamBuffer::~DVDStreamBuffer(void)
	{
	}

//
//  Flush
//

void DVDStreamBuffer::Flush(void)
	{
	bufferStart = 0;
	bufferEnd = 0;
	availData = 0;
	}

//////////////////////////////////////////////////////////////////////
//
//  DVD Stream Server Class
//
//////////////////////////////////////////////////////////////////////

//
//  Constructor
//

DVDStreamServer::DVDStreamServer (DVDSequencer * seq, WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher)
	: WinPort (server)
	, EventSender(pEventDispatcher)
	{
	int i;

	for(i=0; i<NUM_CELL_BUFFERS; i++)
		{
		cells[i].succ = cells + (i + 1) % NUM_CELL_BUFFERS;
		cells[i].pred = cells + (i + NUM_CELL_BUFFERS - 1) % NUM_CELL_BUFFERS;
		}

	//NOTE: with smaller buffer sizes the chance for buffer underrun is increased when buffer read/consuming
	//thread can't get control often enough (e.g. Win16 mutex is held during decoding or all the CPU power is used up).

	streamBuffer = NULL;
	streamBufferSize = NUM_DVD_BLOCKS_IN_BUFFER;

	/*
	//FlushBuffers();  // Initializes cell buffers

	transferSemaphore = 0;
	positionCache.valid = FALSE;
	*/

	dvdfs = NULL;

	this->sequencer = seq;
	this->server = server;
	this->units = units;

	player = NULL;
	}

//
//  Destructor
//

DVDStreamServer::~DVDStreamServer(void)
	{
	if (player)
		{
		player->DeleteRefiller();
		delete player;
		player = NULL;
		}
	}

Error DVDStreamServer::Init(DVDFileSystem * dvdfs)
	{
	//
	//  Create player if none exist
	//

	if (!player)
		{
		player = new DVDPlayer(server, units, GetEventDispatcher());

		if (!player)
			GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}

	GNRAISE_OK;
	}

//
// Return stream player
//

DVDStreamPlayer * DVDStreamServer::GetStreamPlayer(void)
	{
	return player;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDStreamServer.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD Stream Server Module
//
//  Declares DVDCell, DVDVOBU, DVDStreamPlayer, DVDStreamServer
//
////////////////////////////////////////////////////////////////////

#ifndef DVDSTREAMSERVER_H
#define DVDSTREAMSERVER_H

#include "Library/Common/WinPorts.h"
#include "Library/Common/KrnlSync.h"
#include "DVDAVHeader.h"
#include "Breakpoint.h"
#include "DVDSequencer.h"
#include "Library/Hardware/mpeg2dec/generic/mp2eldec.h"

////////////////////////////////////////////////////////////////////
//
//  Defines and types
//
////////////////////////////////////////////////////////////////////

#define VOS_FREE						0		// entry is not used, and available
#define VOS_READY						1		// entry is initialized, but not being read yet
#define VOS_READING					2		// entry is currently being read into the buffer
#define VOS_READCOMPLETE			4		// all data has been read from the disk
#define VOS_TRANSFERING				8		// entry is currently being transfered to decoder
#define VOS_TRANSFERCOMPLETE		16		// the transfer to the decoder is complete
#define VOS_PLAYING					32		// the entry is currently being played
#define VOS_PLAYCOMPLETED			64		// playback is completed

#define VOS_TRANSFERING_PLAYING	(VOS_TRANSFERING | VOS_PLAYING)

#define NUM_VOBU_BUFFERS	100
#define NUM_CELL_BUFFERS	4
#define NUM_DVD_BLOCKS_IN_BUFFER	32

enum CellScanType
	{
	CST_PLAYBACK,
	CST_REVERSEPLAYBACK,
	CST_SCANFORWARD,
	CST_SCANBACKWARD,
	CST_TRICKPLAY
	};

enum AngleChangeType
	{
	ACT_NONE,
	ACT_DEFERRED,
	ACT_SEAMLESS,
	ACT_NON_SEAMLESS
	};

////////////////////////////////////////////////////////////////////
//
//  DVDCell Class
//
//  Represents a DVD Cell
//
////////////////////////////////////////////////////////////////////

class DVDCell
	{
	public:
		DVDCell(void) {succ = NULL; pgci = NULL; state = VOS_FREE;}

		DVDCell		*	succ, * pred;

		DVDCPBI				info;
		DVDATSCPBI			atsInfo;
		DVDGenericPGCI	*	pgci;

		BYTE				state;
		BOOL				still;
		BOOL				final;			// TRUE if this is final cell of program
		CellScanType	scan;
		WORD				scanStart, scanStep;

		WORD				num;

		DVDTime			presentationTime;

		DVDTime			firstScanVOBUTime;
		int				firstScanSystemTime;

		ERSBreakpoint breakpoint;		// This one must be initialized before CellCompleted is called

		BOOL IsScanning(void) {return scan == CST_SCANFORWARD || scan == CST_SCANBACKWARD;}
		BOOL IsMultiAngleCell(void) {return info.BlockType() == CBT_ANGLE_BLOCK;}
	};

////////////////////////////////////////////////////////////////////
//
//  DVDVOBU Class
//
//  Represents a DVD VOBU
//
////////////////////////////////////////////////////////////////////

class DVDVOBU
	{
	friend class DVDStreamServer;
	protected:
		RequestHandle rh;
		DVDDataFile * file;
		DWORD navPackBlock;
		DriveBlock navPackDriveBlock;

		Error ReadNavPackData(DWORD block);

	public:
		DVDVOBU	*	succ;
		DWORD			startTransferCount;
		DWORD			endTransferCount;
		DWORD			startReadCount;
		DWORD			endReadCount;

		DWORD			firstBlock;
		DWORD			numBlocks;

		BOOL			still, singleFrame, final;

		BYTE			state;
		DVDCell	*	cell;

		ERSBreakpoint breakpoint;		// This one must be initialized before VOBUCompleted is called

		DVDVOBU (void);
		~DVDVOBU (void);

		void	Init(DVDDataFile * file, DVDCell * cell, DWORD firstBlock, BOOL singleFrame);
		void	Cleanup(void);

		BYTE	GetNVByte(int at) {return navPackDriveBlock.data ? navPackDriveBlock.data[at] : 0;}
		WORD	GetNVWord(int at) {return navPackDriveBlock.data ? MAKEWORD(navPackDriveBlock.data[at+1], navPackDriveBlock.data[at]) : 0;}
		DWORD	GetNVDWord(int at) {return navPackDriveBlock.data ? MAKELONG4(navPackDriveBlock.data[at+3], navPackDriveBlock.data[at+2],
													navPackDriveBlock.data[at+1], navPackDriveBlock.data[at+0]) : 0;}
		void	GetNVBytes(FPTR buff, int at, int num);

		BYTE	GetPCIByte(int at) {return GetNVByte(at + 45);}
		WORD	GetPCIWord(int at) {return GetNVWord(at + 45);}
		DWORD	GetPCIDWord(int at) {return GetNVDWord(at + 45);}
		void	GetPCIBytes(FPTR buff, int at, int num) {GetNVBytes(buff, at + 45, num);}

		BYTE	GetPCIByteSeq(int & at) {at += 1; return GetNVByte(at - 1 + 45);}
		WORD	GetPCIWordSeq(int & at) {at += 2; return GetNVWord(at - 2 + 45);}
		DWORD	GetPCIDWordSeq(int & at) {at += 4; return GetNVDWord(at - 4 + 45);}
		void	GetPCIBytesSeq(FPTR buff, int & at, int num) {at += num; GetNVBytes(buff, at - num + 45, num);}

		BYTE	GetDSIByte(int at) {return GetNVByte(at + 1031);}
		WORD	GetDSIWord(int at) {return GetNVWord(at + 1031);}
		DWORD	GetDSIDWord(int at) {return GetNVDWord(at + 1031);}

		BYTE	GetDSIByteSeq(int & at) {at += 1; return GetNVByte(at - 1 + 1031);}
		WORD	GetDSIWordSeq(int & at) {at += 2; return GetNVWord(at - 2 + 1031);}
		DWORD	GetDSIDWordSeq(int & at) {at += 4; return GetNVDWord(at - 4 + 1031);}

		BOOL	HasNonSeamlessAngleInfo(void);
		BOOL	HasSeamlessAngleInfo(void);
		Error	ReadNavigationPack(void);
		Error	FindNextNavigationPack(DWORD final, WORD angle, BOOL & suspendTransfer);

		DWORD	NextVOBU(void);
		DWORD	PrevVOBU(void);
		BOOL	HasVideoData(void);
		DWORD	SeamlessAngleChangeVOBU(WORD angle);
		DWORD	NonSeamlessAngleChangeVOBU(WORD angle);
		DWORD	NextTemporalVOBU(WORD halfSeconds);
		DWORD	NextLowerTemporalVOBU(WORD halfSeconds);
		DWORD	PrevTemporalVOBU(WORD halfSeconds);
		BOOL	IsLastVOBUinILVU(void);

		DWORD	GetSPTM(void);
		DWORD GetEPTM(void);
		DVDTime GetTimeOffset(void);
		DVDTime GetDuration(void);
	};

////////////////////////////////////////////////////////////////////
//
//  DVDStreamPlayer Class
//
////////////////////////////////////////////////////////////////////

class DVDStreamPlayer : public EventSender
	{
	public:
		DWORD transferCount, transferCountRemainder;

		DVDStreamPlayer(EventDispatcher* pEventDispatcher) : EventSender(pEventDispatcher) {}
		virtual ~DVDStreamPlayer(void) {}

		virtual DWORD SendData(HBPTR data, DWORD size) = 0;
		virtual DWORD SendDataMultiple(MPEGDataSizePair * data, DWORD size) = 0;
		virtual void  CompleteData(void) = 0;
		virtual void  CancelData(void) = 0;

		virtual void  SetCallback(DWORD position, DVDStreamServer * callback) = 0;
		virtual void  CancelCallback(void) = 0;
		virtual void  WaitForCallbackCanceled(void) = 0;
		virtual DWORD CurrentLocation(void) = 0;

		virtual BOOL  Completed(void) = 0;
		virtual void  StartPlayback(void) = 0;
		virtual void  StartScan(void) = 0;
		virtual void  StartTrickplay(void) = 0;
		virtual void  SetReversePlayback(BOOL reverse) = 0;
		virtual void  SetStillFrameSequenceMode(BOOL stillFrameSequence) = 0;
		virtual void  TerminatePlayback(void) = 0;

		virtual void  SetRefiller(DVDStreamServer * refiller) = 0;
		virtual void  DeleteRefiller(void) = 0;
		virtual void  RequestRefill(void) = 0;

		virtual Error SetAnalogCopyProtectionMode(int mode) = 0;

		virtual void  SetTimeBase(DVDTime timeBase) = 0;
		virtual Error GetPlaybackTime(DVDTime & time) = 0;
		virtual DWORD GetRequestedVOBUID(void) = 0;
		virtual void  SetFirstAvailableVOBUID(DWORD id) = 0;
		virtual void  SetLastAvailableVOBUID(DWORD id) = 0;
		virtual int   GetCurrentFrameRate(void) = 0;
	};

////////////////////////////////////////////////////////////////////
//
//  DVD EStd Time Adaption
//
////////////////////////////////////////////////////////////////////

class DVDEStdTimeAdaption
	{
	public:
		virtual void ConvertToEStdTime(BYTE * data, int num) = 0;
	};

////////////////////////////////////////////////////////////////////
//
//  DVD Stream Buffer
//
////////////////////////////////////////////////////////////////////

class DVDStreamBuffer
	{
	protected:
		DWORD	bufferStart, bufferEnd, bufferSize, availData;

	public:
		DVDStreamBuffer(DWORD bufferSize);
		virtual ~DVDStreamBuffer(void);

//		DWORD AvailData(void) {return availData;}
//		DWORD AvailSpace(void) {return bufferSize - availData;}
		DWORD AvailData(void) {return bufferEnd - bufferStart;}
		DWORD AvailSpace(void) {return bufferSize - AvailData();}

		BOOL IsEmpty(void) {return AvailData() == 0;}
		BOOL IsFull(void) {return AvailSpace() == 0;}

		virtual void Flush(void);

		virtual Error ChangeBufferSize(DWORD size) = 0;

		virtual Error ReadIntoBuffer(DVDDataFile * file, DVDEStdTimeAdaption * eStdAdaption, DWORD block, DWORD num) = 0; // in blocks
		virtual DWORD WriteFromBuffer(DVDStreamPlayer * player, DWORD num) = 0; // in bytes

		virtual Error TerminateRequest(void) = 0;
	};


////////////////////////////////////////////////////////////////////
//
//  DVDStreamServer Class
//
////////////////////////////////////////////////////////////////////

class DVDStreamServer : protected WinPort, virtual protected EventSender, protected DVDEStdTimeAdaption
	{
	friend class DVDPGCSequencer;
	protected:
		DVDFileSystem		* dvdfs;
		DVDSequencer		* sequencer;
		DVDStreamPlayer	* player;

		WinPortServer		* server;
		UnitSet				units;

		VDLocalMutex	lock;

		DVDStreamBuffer *	streamBuffer;
		DWORD					streamBufferSize;

		/*
		DWORD				nextVOBUBlock;
		DWORD				numVOBUBlocks;

		DWORD				currentVOBUID;
		DWORD				endPTM, ptsOffset;
		DWORD				translatedStartPTM, translatedEndPTM;

		DVDVOBU			vobus[NUM_VOBU_BUFFERS];
		DVDVOBU		*  firstFreeVOBU;					// First free VOBU in VOBU buffer
		DVDVOBU		*	predReadingVOBU;				// Predecessor of VOBU being currently read
		DVDVOBU		*	readingVOBU;					// VOBU currently being read
		DVDVOBU		*	transferingVOBU;				// VOBU currently being transfered
		DVDVOBU		*	playingVOBU;					// VOBU currently playing
		DWORD				angleChangeVOBU;				// VOBU for which angle change event is to be send
		WORD				angleChangeAngle;				// New angle to send with event

		DWORD				currentReadCount;
		*/

		DVDCell			cells[NUM_CELL_BUFFERS];
		DVDCell		*	firstFreeCell;
		DVDCell		*	readingCell;
		DVDCell		*	transferingCell;
		DVDCell		*	playingCell;

		//WORD				transferSemaphore;

		DVDDataFile	*	file;

		//BOOL 				singleFrame, stillMode, finalBuffer, stillPending;
		BOOL				inTransfer, callbackSemaphore, playRequest, suspendTransfer;
		/*
		WORD				angleChangeRequest;

		ERSBreakpoint breakpoint;			// The breakpoint reached
		BOOL stopAfterNextVOBU;				// TRUE if we have to stop after next VOBU
		BOOL readEveryVOBU;					// If we need to find a special VOBU during scan, set this to TRUE, so every VOBU is read
		*/
		ERSPlaybackDir playbackDir;

		/*
		struct PositionCache					// To cache some info for TimePlay/Search (TransferCellAt)
			{
			BOOL		valid;
			DVDTime	time;				// Presentation time
			DWORD		pgciID;			// Unique ID for pgci
			DWORD		firstBlock;		// First block of VOBU to play
			} positionCache;
		*/

		virtual Error RefillBuffer(BOOL prefetch) = 0;
		virtual Error SendBuffer(void) = 0;

		virtual Error FlushBuffers(void) = 0;

		virtual Error SendCellStarted(DVDCell * cell) = 0;
		virtual Error SendCellCompleted(DVDCell * cell) = 0;
		virtual Error SendCellCorrupt(DVDCell * cell) = 0;

		virtual void Message(WPARAM wParam, LPARAM dParam) = 0;

		virtual DVDStreamPlayer * GetStreamPlayer(void);

		virtual Error Defrost(void) = 0;

	public:
		DVDStreamServer (DVDSequencer * seq, WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher);
		virtual ~DVDStreamServer(void);

		virtual Error Init(DVDFileSystem * dvdfs);

		//
		// To be called once in a while
		//
		virtual Error PerformTransfer(int maxTransfer = 0xffff) = 0;

		virtual Error TransferCell(DVDGenericPGCI * pgci, WORD num, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu = 0, WORD angle = 0) = 0;
		virtual Error TransferCellAt(DVDGenericPGCI * pgci, WORD num, BOOL still, BOOL final, DVDTime presentationTime, DVDTime time) = 0;
		virtual Error TransferCellScan(DVDGenericPGCI * pgci, WORD cell, BOOL still, BOOL final, DVDTime presentationTime, BOOL forward, WORD first, WORD skip, DWORD vobu) = 0;
		virtual Error TransferCellReverse(DVDGenericPGCI * pgci, WORD cell, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu) = 0;
		virtual Error TransferCellTrickplay(DVDGenericPGCI * pgci, WORD cell, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu) = 0;

//		virtual Error ReplaceCell(DVDGenericPGCI * pgci, WORD num, BOOL still, BOOL final, DVDTime presentationTime, DWORD vobu = 0, WORD angle = 0) = 0;

		virtual Error AbortTransfer(void) = 0;
		virtual Error AbortTransferAccurate(void) = 0;

		virtual Error StopPlayback(void) = 0;

		virtual Error CompleteStill(void) = 0;
		virtual Error TerminateStill(void) = 0;

		virtual Error GetAngleChangeType(AngleChangeType & type) = 0;
		virtual Error SeamlessAngleChange(WORD angle) = 0;

		virtual Error SetOBS(DVDOBS * obs) = 0;

		virtual Error ReturnVOBU(DVDVOBU * vobu) = 0;
		virtual Error ReturnCell(DVDCell * cell) = 0;

      virtual void PlayerCallback(DWORD signalPosition) = 0;

		virtual Error GetPlaybackTime(DVDTime & time) = 0;
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDPLDRV.CPP ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DDP Layer Implementation
//
////////////////////////////////////////////////////////////////////

#include "library/Common/WinPorts.h"
#include "Dvdpld32.h"
#include "Library/Files/GenericFile.h"
#include "CDDiskPlayer.h"
#include "Region.h"
#include "Library/Common/VDDebug.h"
#include "Library/Common/Profiles.h"
#include "Library/lowlevel/timer.h"
#include "Config/DiskPlayerFactory.h"
#include "Config/FileSystemFactory.h"

////////////////////////////////////////////////////////////////////
//
//  General stuff
//
////////////////////////////////////////////////////////////////////

#define MKLANG(c, d)	(((WORD)c << 8) | (WORD)d)

//
//  Logging of DDP calls
//

#define LOGDDP_NONE			0x0000		// No DDP logging at all
#define LOGDDP_STATUS		0x0001		// Log status inquiries
#define LOGDDP_PLAYBACK		0x0002		// Log playback commands
#define LOGDDP_CONFIG		0x0004		// Log configuration commands
#define LOGDDP_MISC			0x0008		// Log misc calls
#define LOGDDP_EXIT			0x0010		// Log termination of DDP call

#define LOGDDP_ALL				(LOGDDP_STATUS   | LOGDDP_PLAYBACK | LOGDDP_CONFIG	| LOGDDP_MISC | LOGDDP_EXIT)
#define LOGDDP_ALL_BUT_EXIT	(LOGDDP_STATUS   | LOGDDP_PLAYBACK | LOGDDP_CONFIG	| LOGDDP_MISC)
#define LOGDDP_NO_STATUS		(LOGDDP_PLAYBACK | LOGDDP_CONFIG   | LOGDDP_MISC    | LOGDDP_EXIT)

#define LOGDDPCALLS LOGDDP_NONE // LOGDDP_PLAYBACK | LOGDDP_CONFIG | LOGDDP_MISC | LOGDDP_EXIT 		// Use the LOGDDP_* flags above to configure logging

////////////////////////////////////////////////////////////////////
//
//  ST20LITE specific
//
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
//
//  Windows specific
//
////////////////////////////////////////////////////////////////////


#define DLLP1 DLLCALL
#define DLLP2 WINAPI

#if LOGDDPCALLS
#define LOGDDP(text, type) if (LOGDDP_##type & (LOGDDPCALLS)) DP("DDP_%s", #text)
#define LOGDDPEXIT(text, type) if ((LOGDDP_##type & (LOGDDPCALLS)) && (LOGDDP_EXIT & (LOGDDPCALLS))) DP("DDP_%s END (%08lx)\n", #text, err)
#else
#define LOGDDP(text, type)
#define LOGDDPEXIT(text, type)
#endif


////////////////////////////////////////////////////////////////////
//
//  Message handling
//
////////////////////////////////////////////////////////////////////

//
//  Player message codes
//

#define	DDPMSG_OPENDVDVIDEOPLAYER					1
#define	DDPMSG_OPENDVDAUDIOPLAYER					78
#define	DDPMSG_OPENVCDPLAYER							54
#define	DDPMSG_OPENCDDAPLAYER						62
#define	DDPMSG_OPENAVFPLAYER							75
#define	DDPMSG_CLOSEPLAYER							2
#define	DDPMSG_STARTPRESENTATION					3
#define	DDPMSG_GETCURRENTLOCATION					4
#define	DDPMSG_GETCURRENTDURATION					5
#define	DDPMSG_GETPLAYERMODE							6
#define	DDPMSG_GETFORBIDDENUSEROPERATIONS		7
#define	DDPMSG_GETNUMBEROFTITLES					8
#define	DDPMSG_GETNUMBEROFPARTOFTITLES			9
#define	DDPMSG_GETAVAILSTREAMS						10
#define	DDPMSG_GETCURRENTAUDIOSTREAM				11
#define	DDPMSG_GETCURRENTSUBPICTURESTREAM		12
#define	DDPMSG_ISCURRENTSUBPICTURENENABLED		56
#define	DDPMSG_GETNUMBEROFANGLES					13
#define	DDPMSG_GETCURRENTANGLE						14
#define	DDPMSG_CHECKMENUAVAIL						15
#define	DDPMSG_TITLEPLAY								16
#define	DDPMSG_PTTPLAY									17
#define	DDPMSG_TIMEPLAY								18
#define  DDPMSG_EXTENDEDPLAY							70
#define	DDPMSG_STOP										19
#define	DDPMSG_GOUP										20
#define	DDPMSG_TIMESEARCH								21
#define	DDPMSG_PTTSEARCH								22
#define	DDPMSG_PREVPGSEARCH							23
#define	DDPMSG_TOPPGSEARCH							24
#define	DDPMSG_NEXTPGSEARCH							25
#define	DDPMSG_FORWARDSCAN							26
#define	DDPMSG_BACKWARDSCAN							27
#define	DDPMSG_STOPSCAN								28
#define	DDPMSG_REVERSEPLAY							59
#define	DDPMSG_MENUCALL								29
#define	DDPMSG_RESUME									30
#define	DDPMSG_UPPERBUTTONSELECT					31
#define	DDPMSG_LOWERBUTTONSELECT					32
#define	DDPMSG_LEFTBUTTONSELECT						33
#define	DDPMSG_RIGHTBUTTONSELECT					34
#define	DDPMSG_BUTTONACTIVATE						35
#define	DDPMSG_BUTTONSELECTANDACTIVATE			36
#define	DDPMSG_BUTTONSELECTANDACTIVATEAT			37
#define  DDPMSG_BUTTONSELECTAT						55
#define	DDPMSG_ISBUTTONAT								57
#define	DDPMSG_STILLOFF								38
#define	DDPMSG_PAUSEON									39
#define	DDPMSG_PAUSEOFF								40
#define	DDPMSG_MENULANGUAGESELECT					41
#define	DDPMSG_AUDIOSTREAMCHANGE					42
#define	DDPMSG_SUBPICTURESTREAMCHANGE				43
#define	DDPMSG_ANGLECHANGE							44
#define	DDPMSG_PARENTALLEVELSELECT					45
#define	DDPMSG_PARENTALCOUNTRYSELECT				46
#define	DDPMSG_GETAUDIOSTREAMATTRIBUTES			47
#define	DDPMSG_GETSUBPICTURESTREAMATTRIBUTES	48
#define	DDPMSG_GETCURRENTDISPLAYMODE				49
#define	DDPMSG_SETDISPLAYMODE						50
#define	DDPMSG_SELECTINITIALLANGUAGE				51
#define	DDPMSG_ADVANCEFRAME							52
#define	DDPMSG_SETPLAYBACKSPEED						53
#define  DDPMSG_GETCURRENTBUTTONSTATE				58
#define	DDPMSG_FREEZE									60
#define	DDPMSG_DEFROST									61
#define	DDPMSG_TRICKPLAY								63
#define	DDPMSG_ADVANCEFRAMEBY						64
#define	DDPMSG_GETEXTENDEDPLAYERSTATE				65
#define	DDPMSG_EVENTHANDLERON						66
#define	DDPMSG_EVENTHANDLEROFF						67
#define	DDPMSG_SETBREAKPOINT							68
#define	DDPMSG_CLEARBREAKPOINT						69
#define  DDPMSG_DETACHDRIVE							71		// OBSOLETE
#define  DDPMSG_GETTITLEDURATION						72
#define	DDPMSG_TIMEPLAYFORCED						73
#define	DDPMSG_TIMESEARCHFORCED						74
#define	DDPMSG_GETAVFILEINFO							76
#define	DDPMSG_PLAYFILE								77
#define	DDPMSG_PROCESS_ASYNC_RQ						79
#define	DDPMSG_SETAUDIOSTREAMSELECTIONPREFS		80
#define	DDPMSG_PTTPLAYFORCED							81
#define	DDPMSG_TITLEPLAYFORCED						82
#define	DDPMSG_PTTSEARCHFORCED						83
#define	DDPMSG_PBCON									84
#define	DDPMSG_PBCOFF									85

// please note DDPMSG 85 in use

//
//  Player message structure
//

struct DVDPlayerMsg
	{
	UnitSet								units;
	DVDDiskPlayer						player;
	Error									error;

	DVDDiskType							diskType;
	DVDTime								time;
	DVDLocation						*	location;
	DVDAudioStreamFormat			*	audioStreamFormat;
	DVDSubPictureStreamFormat	*	subPictureStreamFormat;
	DVDPlayerMode						mode;
	DisplayPresentationMode			dpmode;
	BOOL									boolean;

	char									ch;
	char								*	str;

	BYTE									byte;
	WORD									word, title, part, x, y, word2, word3;
	DWORD									dword, dword2;
	int									val;

	WORD									audioLanguage, audioExtension, subPictureLanguage, subPictureExtension;

	VTSMenuType							menu;

	void								*	pointer, * pointer2;
	};

////////////////////////////////////////////////////////////////////
//
//  Global variables
//
////////////////////////////////////////////////////////////////////


//
//  Some inevitable global variables
//

WinPortServer				* DriverInstance = NULL;
RegionHandler				* RegionMan = NULL;						// This one caches region information
DriveTable					* SystemDriveTable = NULL;
RootFileSystem				* FileSystem = NULL;
GenericProfile				* SystemProfile = NULL;
DVDDiskPlayerFactory		* dvdVideoDiskPlayerFactory = NULL;
DVDDiskPlayerFactory		* dvdAudioDiskPlayerFactory = NULL;
VCDDiskPlayerFactory		* vcdDiskPlayerFactory = NULL;
CDDADiskPlayerFactory	* cddaDiskPlayerFactory = NULL;
AVFDiskPlayerFactory		* avfDiskPlayerFactory = NULL;
FileSystemFactory			* dvdFileSystemFactory = NULL;
FileSystemFactory			* vcdFileSystemFactory = NULL;
FileSystemFactory			* cddaFileSystemFactory = NULL;
FileSystemFactory			* avfFileSystemFactory = NULL;
FileSystemFactory			* osFileSystemFactory = NULL;

////////////////////////////////////////////////////////////////////
//
//  DDP Scheduler Class
//
////////////////////////////////////////////////////////////////////


class DDPScheduler : public EventPort
	{
	public:
		DDPScheduler(WinPortServer *server) : EventPort(server) {}

		void Message(WPARAM wParam, LPARAM dParam);

	} * ddpScheduler;

DWORD WINAPI DDPScheduleRoutine(LPVOID param)
	{
	ddpScheduler = new DDPScheduler(DriverInstance);

	DriverInstance->ProcessMessages();

	delete ddpScheduler;

	return 0;
	}

HANDLE DDPScheduleThread;



///////////////////////////////
//
// GetDiskInfoAsyncRequestScheduler class and related structures
//
///////////////////////////////

typedef struct tagAsyncRqDescriptior
	{
	ARQReqestID asyncRqID; //ID of request being scheduled/processed
	void* rqData;
	KernelString drivePath;
	ARQAsyncRequestDoneCB asyncRequestDoneCallback;
	DWORD rqHandle;
	} AsyncRqDescriptior;


class MissionControl
	{
	public:
		virtual BOOL IsAbortRequested(void) = 0;
	};

class GetDiskInfoAsyncRequestScheduler : public MissionControl
	{
	protected:
		const DWORD constRqHandle; //Only one request at a time allowed for now
		AsyncRqDescriptior rqPending; //This should be a list once multiple requests at a time are allowed

		DVDPlayerMsg msg;

		BOOL requestInProgress; //busy flag
		BOOL abortRequest; //true while aborting current request
		VDLocalMutex flagMutex; //Mutex for accesssing flags
		VDSemaphore asyncRqDone;

		BOOL IsRequestInProgress(){VDAutoMutex mutex(&flagMutex); return requestInProgress;}
		void SetRequestInProgressFlag(BOOL flagValue){VDAutoMutex mutex(&flagMutex); requestInProgress = flagValue;}

		void SetAbortRequestFlag(BOOL flagValue){VDAutoMutex mutex(&flagMutex); abortRequest = flagValue;}

		//handle should be unique ID of the request processed, but at the moment there is
		//not much use of the handle until we allow multiple asynchronous requests, so
		//we just return constant value
		DWORD GetNewHandle(void){return constRqHandle;}

	public:
		GetDiskInfoAsyncRequestScheduler()
			: constRqHandle(1)
			{
			requestInProgress = FALSE;
			abortRequest = FALSE;
			asyncRqDone.Reset();
			rqPending.asyncRqID = ARQ_NONE;
			}

		~GetDiskInfoAsyncRequestScheduler()
			{
			}

		Error ScheduleRequest(ARQReqestID asyncRqID, KernelString& drivePath, ARQAsyncRequestDoneCB ARQCallback, void* diskOnlyInfo, DWORD & rqHandle);
		Error ProcessAsyncRequest(DWORD rqHandle);
		Error AbortAndDisableDiskRequests(DWORD rqHandle);

		BOOL IsAbortRequested(void){VDAutoMutex mutex(&flagMutex); return abortRequest;}

	} * getDiskInfoAsyncRqScheduler = NULL;


//
//  Process message by application
//

void DDPScheduler::Message(WPARAM wParam, LPARAM dParam)
	{
	DVDPlayerMsg	*	msg = (DVDPlayerMsg *)dParam;
	DVDDiskPlayer		player = msg->player;
	Error					err = GNR_UOP_PROHIBITED;
	BOOL					permitted;

//	int ctime = ::GetTickCount();
//	char buffer[500];
//	wsprintf(buffer, "##### Message+, %d THREAD %08lx\n", wParam, GetCurrentThread());
//	OutputDebugString(buffer);

	switch(wParam)
		{
		case DDPMSG_PROCESS_ASYNC_RQ:
			LOGDDP(PROCESSASYNCRQ, STATUS);
			err = getDiskInfoAsyncRqScheduler->ProcessAsyncRequest(msg->dword);
			LOGDDPEXIT(PROCESSASYNCRQ, STATUS);
			break;
		case DDPMSG_OPENDVDVIDEOPLAYER:
			{
			BYTE systemRegion, diskRegion, availSets;
			RegionSource regionSource;

			LOGDDP(OPENDVDVIDEOPLAYER, PLAYBACK);

			if (!IS_ERROR(err = RegionMan->GetRegionSettings(msg->units, (RootIterator*)(msg->pointer2),
																			   systemRegion, diskRegion, regionSource, availSets)))
				err = dvdVideoDiskPlayerFactory->CreateDiskPlayer(DriverInstance, msg->units, SystemProfile, msg->diskType,
																					 (DVDFileSystem*)(msg->pointer), systemRegion, msg->player);
			LOGDDPEXIT(OPENDVDVIDEOPLAYER, PLAYBACK);
			break;
			}
		case DDPMSG_OPENDVDAUDIOPLAYER:
			LOGDDP(OPENDVDAUDIOPLAYER, PLAYBACK);
			err = dvdAudioDiskPlayerFactory->CreateDiskPlayer(DriverInstance, msg->units, SystemProfile, msg->diskType,
																				 (DVDFileSystem*)(msg->pointer), 0, msg->player);
			LOGDDPEXIT(OPENDVDAUDIOPLAYER, PLAYBACK);
			break;
		case DDPMSG_OPENVCDPLAYER:
			LOGDDP(OPENVCDPLAYER, PLAYBACK);
			err = vcdDiskPlayerFactory->CreateDiskPlayer(DriverInstance, msg->units, SystemProfile, msg->diskType,
																		  (VCDFileSystem*)(msg->pointer), msg->player);
			LOGDDPEXIT(OPENVCDPLAYER, PLAYBACK);
			break;
		case DDPMSG_OPENCDDAPLAYER:
			LOGDDP(OPENCDDAPLAYER, PLAYBACK);
			err = cddaDiskPlayerFactory->CreateDiskPlayer(DriverInstance, msg->units, SystemProfile, msg->diskType,
																			(CDDAFileSystem*)(msg->pointer), msg->player);
			LOGDDPEXIT(OPENCDDAPLAYER, PLAYBACK);
			break;
		case DDPMSG_OPENAVFPLAYER:
			LOGDDP(OPENAVFPLAYER, PLAYBACK);
			err = avfDiskPlayerFactory->CreateDiskPlayer(DriverInstance, msg->units, SystemProfile, msg->diskType,
																		  (GenericFileSystem*)(msg->pointer), msg->player);
			LOGDDPEXIT(OPENAVFPLAYER, PLAYBACK);
			break;
		case DDPMSG_CLOSEPLAYER:
			LOGDDP(CLOSEPLAYER, PLAYBACK);
			delete msg->player;		// ??? Cleanup()
			err = GNR_OK;
			LOGDDPEXIT(CLOSEPLAYER, PLAYBACK);
			break;
		case DDPMSG_STARTPRESENTATION:
			LOGDDP(STARTPRESENTATION, PLAYBACK);
			err = player->StartPresentation(msg->dword);
			LOGDDPEXIT(STARTPRESENTATION, PLAYBACK);
			break;
		case DDPMSG_GETCURRENTLOCATION:
			LOGDDP(GETCURRENTLOCATION, STATUS);
			err = player->GetCurrentLocation(*(msg->location));
			LOGDDPEXIT(GETCURRENTLOCATION, STATUS);
			break;
		case DDPMSG_GETCURRENTDURATION:
			LOGDDP(GETCURRENTDURATION, STATUS);
			err = player->GetCurrentDuration(*(msg->location));
			LOGDDPEXIT(GETCURRENTDURATION, STATUS);
			break;
		case DDPMSG_GETTITLEDURATION:
			LOGDDP(GETTITLEDURATION, STATUS);
			err = player->GetTitleDuration(msg->word, msg->time);
			LOGDDPEXIT(GETTITLEDURATION, STATUS);
			break;
		case DDPMSG_GETPLAYERMODE:
			LOGDDP(GETPLAYERMODE, STATUS);
			err  = player->GetMode(msg->mode);
			LOGDDPEXIT(GETPLAYERMODE, STATUS);
			break;
		case DDPMSG_GETFORBIDDENUSEROPERATIONS:
			LOGDDP(GETFORBIDDENUSEROPERATIONS, STATUS);
			err = player->GetUOPs(msg->dword);
			LOGDDPEXIT(GETFORBIDDENUSEROPERATIONS, STATUS);
			break;
		case DDPMSG_GETNUMBEROFTITLES:
			LOGDDP(GETNUMBEROFTITLES, STATUS);
			err = player->NumberOfTitles(msg->word);
			LOGDDPEXIT(GETNUMBEROFTITLES, STATUS);
			break;
		case DDPMSG_GETNUMBEROFPARTOFTITLES:
			LOGDDP(GETNUMBEROFPARTOFTITLES, STATUS);
		   err = player->NumberOfPartOfTitle(msg->title, msg->word);
			LOGDDPEXIT(GETNUMBEROFPARTOFTITLES, STATUS);
			break;
		case DDPMSG_GETAVAILSTREAMS:
			LOGDDP(GETAVAILSTREAMS, STATUS);
			err = player->GetAvailStreams(msg->byte, msg->dword);
			LOGDDPEXIT(GETAVAILSTREAMS, STATUS);
			break;
		case DDPMSG_GETCURRENTAUDIOSTREAM:
			LOGDDP(GETCURRENTAUDIOSTREAM, STATUS);
			err = player->GetCurrentAudioStream(msg->word);
			LOGDDPEXIT(GETCURRENTAUDIOSTREAM, STATUS);
			break;
		case DDPMSG_GETCURRENTSUBPICTURESTREAM:
			LOGDDP(GETCURRENTSUBPICTURESTREAM, STATUS);
			err = player->GetCurrentSubPictureStream(msg->word);
			LOGDDPEXIT(GETCURRENTSUBPICTURESTREAM, STATUS);
			break;
		case DDPMSG_ISCURRENTSUBPICTURENENABLED:
			LOGDDP(ISCURRENTSUBPICTUREENABLED, STATUS);
			err = player->IsCurrentSubPictureEnabled(msg->boolean);
			LOGDDPEXIT(ISCURRENTSUBPICTUREENABLED, STATUS);
			break;
		case DDPMSG_GETAUDIOSTREAMATTRIBUTES:
			LOGDDP(GETAUDIOSTREAMATTRIBUTES, STATUS);
			err = player->GetAudioStreamAttributes(msg->word, *(msg->audioStreamFormat));
			LOGDDPEXIT(GETAUDIOSTREAMATTRIBUTES, STATUS);
			break;
		case DDPMSG_GETSUBPICTURESTREAMATTRIBUTES:
			LOGDDP(GETSUBPICTURESTREAMATTRIBUTES, STATUS);
			err = player->GetSubPictureStreamAttributes(msg->word, *(msg->subPictureStreamFormat));
			LOGDDPEXIT(GETSUBPICTURESTREAMATTRIBUTES, STATUS);
			break;
		case DDPMSG_GETNUMBEROFANGLES:
			LOGDDP(GETNUMBEROFANGLES, STATUS);
		   err = player->GetNumberOfAngles(msg->title, msg->word);
			LOGDDPEXIT(GETNUMBEROFANGLES, STATUS);
			break;
		case DDPMSG_GETCURRENTANGLE:
			LOGDDP(GETCURRENTANGLE, STATUS);
			err = player->GetCurrentAngle(msg->word);
			LOGDDPEXIT(GETCURRENTANGLE, STATUS);
			break;
		case DDPMSG_CHECKMENUAVAIL:
			LOGDDP(CHECKMENUAVAIL, STATUS);
			err = player->MenuAvail(msg->menu, msg->boolean);
			LOGDDPEXIT(CHECKMENUAVAIL, STATUS);
			break;
		case DDPMSG_TITLEPLAY:
			LOGDDP(TITLEPLAY, PLAYBACK);
			err = player->UOPPermitted(2, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->TitlePlay(msg->title);
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(TITLEPLAY, PLAYBACK);
			break;
		case DDPMSG_TITLEPLAYFORCED:
			LOGDDP(TITLEPLAYFORCED, PLAYBACK);
			err = player->TitlePlay(msg->title);
			LOGDDPEXIT(TITLEPLAYFORCED, PLAYBACK);
			break;
		case DDPMSG_PTTPLAY:
			LOGDDP(PTTPLAY, PLAYBACK);
			err = player->UOPPermitted(1, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					{
					err = player->TitleSearchUOPPermitted(msg->title, 1, permitted);
					if (!IS_ERROR(err))
						{
						if (permitted)
							err = player->PTTPlay(msg->title, msg->part);
						else
							err = GNR_UOP_PROHIBITED;
						}
					}
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(PTTPLAY, PLAYBACK);
			break;
		case DDPMSG_PTTPLAYFORCED:
			LOGDDP(PTTPLAYFORCED, PLAYBACK);
			err = player->PTTPlay(msg->title, msg->part);
			LOGDDPEXIT(PTTPLAYFORCED, PLAYBACK);
			break;
		case DDPMSG_TIMEPLAY:
			LOGDDP(TIMEPLAY, PLAYBACK);
			err = player->UOPPermitted(0, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					{
					err = player->TitleSearchUOPPermitted(msg->title, 0, permitted);
					if (!IS_ERROR(err))
						{
						if (permitted)
							err = player->TimePlay(msg->title, msg->time);
						else
							err = GNR_UOP_PROHIBITED;
						}
					}
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(TIMEPLAY, PLAYBACK);
			break;
		case DDPMSG_TIMEPLAYFORCED:
			LOGDDP(TIMEPLAYFORCED, PLAYBACK);
			err = player->TimePlay(msg->title, msg->time);
			LOGDDPEXIT(TIMEPLAYFORCED, PLAYBACK);
			break;
		case DDPMSG_EXTENDEDPLAY:
			LOGDDP(EXTENDEDPLAY, PLAYBACK);
			err = player->ExtendedPlay(msg->dword, msg->title, msg->part, msg->time);
			LOGDDPEXIT(EXTENDEDPLAY, PLAYBACK);
			break;
		case DDPMSG_STOP:
			LOGDDP(STOP, PLAYBACK);
			err = player->Exit();
			LOGDDPEXIT(STOP, PLAYBACK);
			break;
		case DDPMSG_GOUP:
			LOGDDP(GOUP, PLAYBACK);
			err = player->UOPPermitted(0, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->GoUpProgramChain();
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(GOUP, PLAYBACK);
			break;
		case DDPMSG_TIMESEARCH:
			LOGDDP(TIMESEARCH, PLAYBACK);
			err = player->UOPPermitted(0, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					{
					err = player->UOPPermitted(5, permitted);
					if (!IS_ERROR(err))
						{
						if (permitted)
							{
							err = player->TitleSearchUOPPermitted(0, 0, permitted);
							if (!IS_ERROR(err))
								{
								if (permitted)
									err = player->TimeSearch(msg->time);
								else
									err = GNR_UOP_PROHIBITED;
								}
							}
						else
							err = GNR_UOP_PROHIBITED;
						}
					}
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(TIMESEARCH, PLAYBACK);
			break;
		case DDPMSG_TIMESEARCHFORCED:
			LOGDDP(TIMESEARCHFORCED, PLAYBACK);
			err = player->TimeSearch(msg->time);
			LOGDDPEXIT(TIMESEARCHFORCED, PLAYBACK);
			break;
		case DDPMSG_PTTSEARCH:
			LOGDDP(PTTSEARCH, PLAYBACK);
			err = player->UOPPermitted(1, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					{
					err = player->UOPPermitted(5, permitted);
					if (!IS_ERROR(err))
						{
						if (permitted)
							{
							err = player->TitleSearchUOPPermitted(0, 1, permitted);
							if (!IS_ERROR(err))
								{
								if (permitted)
									err = player->PTTSearch(msg->part);
								else
									err = GNR_UOP_PROHIBITED;
								}
							}
						else
							err = GNR_UOP_PROHIBITED;
						}
					}
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(PTTSEARCH, PLAYBACK);
			break;
		case DDPMSG_PTTSEARCHFORCED:
			LOGDDP(PTTSEARCHFORCED, PLAYBACK);
			err = player->PTTSearch(msg->part);
			LOGDDPEXIT(PTTSEARCHFORCED, PLAYBACK);
			break;
		case DDPMSG_PREVPGSEARCH:
			LOGDDP(PREVPGSEARCH, PLAYBACK);
			err = player->UOPPermitted(6, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->GoPrevProgram();
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(PREVPGSEARCH, PLAYBACK);
			break;
		case DDPMSG_TOPPGSEARCH:
			LOGDDP(TOPPGSEARCH, PLAYBACK);
			err = player->UOPPermitted(6, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->GoTopProgram();
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(TOPPGSEARCH, PLAYBACK);
			break;
		case DDPMSG_NEXTPGSEARCH:
			LOGDDP(NEXTPGSEARCH, PLAYBACK);
			err = player->UOPPermitted(7, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->GoNextProgram();
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(NEXTPGSEARCH, PLAYBACK);
			break;
		case DDPMSG_FORWARDSCAN:
			LOGDDP(FORWARDSCAN, PLAYBACK);
			err = player->UOPPermitted(8, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->StartForwardScan(msg->word);
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(FORWARDSCAN, PLAYBACK);
			break;
		case DDPMSG_BACKWARDSCAN:
			LOGDDP(BACKWARDSCAN, PLAYBACK);
			err = player->UOPPermitted(9, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->StartBackwardScan(msg->word);
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(BACKWARDSCAN, PLAYBACK);
			break;
		case DDPMSG_TRICKPLAY:
			LOGDDP(TRICKPLAY, PLAYBACK);
			err = player->UOPPermitted(9, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					{
					err = player->UOPPermitted(8, permitted);
					if (!IS_ERROR(err))
						{
						if (permitted)
							err = player->StartTrickplay();
						else
							err = GNR_UOP_PROHIBITED;
						}
					}
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(TRICKPLAY, PLAYBACK);
			break;
		case DDPMSG_STOPSCAN:
			LOGDDP(STOPSCAN, PLAYBACK);
			err = player->UOPPermitted(25, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->StopScan();
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(STOPSCAN, PLAYBACK);
			break;
		case DDPMSG_REVERSEPLAY:
			LOGDDP(REVERSEPLAY, PLAYBACK);
			err = player->UOPPermitted(9, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->StartReversePlayback();
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(REVERSEPLAY, PLAYBACK);
			break;
		case DDPMSG_SETPLAYBACKSPEED:
			LOGDDP(SETPLAYBACKSPEED, CONFIG);
			err = player->UOPPermitted(8, permitted);
			if (!IS_ERROR(err))
				{
				if (msg->word <= 1000 || permitted)
					err = player->SetPlaybackSpeed(msg->word);
				else
					err = GNR_UOP_PROHIBITED;
				}
			break;
		case DDPMSG_MENUCALL:
			LOGDDP(MENUCALL, PLAYBACK);
			switch(msg->menu)
				{
				case VMT_TITLE_MENU:
					err = player->UOPPermitted(10, permitted);
					if (!IS_ERROR(err))
						{
						if (permitted)
							err = player->CallMenu(msg->menu);
						else
							err = GNR_UOP_PROHIBITED;
						}
					break;
				case VMT_ROOT_MENU:
					err = player->UOPPermitted(11, permitted);
					if (!IS_ERROR(err))
						{
						if (permitted)
							err = player->CallMenu(msg->menu);
						else
							err = GNR_UOP_PROHIBITED;
						}
					break;
				case VMT_SUBPICTURE_MENU:
					err = player->UOPPermitted(12, permitted);
					if (!IS_ERROR(err))
						{
						if (permitted)
							err = player->CallMenu(msg->menu);
						else
							err = GNR_UOP_PROHIBITED;
						}
					break;
				case VMT_AUDIO_MENU:
					err = player->UOPPermitted(13, permitted);
					if (!IS_ERROR(err))
						{
						if (permitted)
							err = player->CallMenu(msg->menu);
						else
							err = GNR_UOP_PROHIBITED;
						}
					break;
				case VMT_ANGLE_MENU:
					err = player->UOPPermitted(14, permitted);
					if (!IS_ERROR(err))
						{
						if (permitted)
							err = player->CallMenu(msg->menu);
						else
							err = GNR_UOP_PROHIBITED;
						}
					break;
				case VMT_PTT_MENU:
					err = player->UOPPermitted(15, permitted);
					if (!IS_ERROR(err))
						{
						if (permitted)
							err = player->CallMenu(msg->menu);
						else
							err = GNR_UOP_PROHIBITED;
						}
					break;
				}
			LOGDDPEXIT(MENUCALL, PLAYBACK);
			break;
		case DDPMSG_RESUME:
			LOGDDP(RESUME, PLAYBACK);
			err = player->UOPPermitted(16, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->ResumeFromSystemSpace();
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(RESUME, PLAYBACK);
			break;
		case DDPMSG_UPPERBUTTONSELECT:
			LOGDDP(UPPERBUTTONSELECT, PLAYBACK);
			err = player->UOPPermitted(17, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->ButtonUp();
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(UPPERBUTTONSELECT, PLAYBACK);
			break;
		case DDPMSG_LOWERBUTTONSELECT:
			LOGDDP(LOWERBUTTONSELECT, PLAYBACK);
			err = player->UOPPermitted(17, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->ButtonDown();
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(LOWERBUTTONSELECT, PLAYBACK);
			break;
		case DDPMSG_LEFTBUTTONSELECT:
			LOGDDP(LEFTBUTTONSELECT, PLAYBACK);
			err = player->UOPPermitted(17, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->ButtonLeft();
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(LEFTBUTTONSELECT, PLAYBACK);
			break;
		case DDPMSG_RIGHTBUTTONSELECT:
			LOGDDP(RIGHTBUTTONSELECT, PLAYBACK);
			err = player->UOPPermitted(17, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->ButtonRight();
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(RIGHTBUTTONSELECT, PLAYBACK);
			break;
		case DDPMSG_BUTTONACTIVATE:
			LOGDDP(BUTTONACTIVATE, PLAYBACK);
			err = player->UOPPermitted(17, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->ButtonActivate();
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(BUTTONACTIVATE, PLAYBACK);
			break;
		case DDPMSG_BUTTONSELECTANDACTIVATE:
			LOGDDP(BUTTONSELECTANDACTIVATE, PLAYBACK);
			err = player->UOPPermitted(17, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->ButtonSelectAndActivate(msg->word);
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(BUTTONSELECTANDACTIVATE, PLAYBACK);
			break;
		case DDPMSG_BUTTONSELECTANDACTIVATEAT:
			LOGDDP(BUTTONSELECTANDACTIVATEAT, PLAYBACK);
			err = player->UOPPermitted(17, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->ButtonSelectAtAndActivate(msg->x, msg->y);
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(BUTTONSELECTANDACTIVATEAT, PLAYBACK);
			break;
		case DDPMSG_BUTTONSELECTAT:
			LOGDDP(BUTTONSELECTAT, PLAYBACK);
			err = player->UOPPermitted(17, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->ButtonSelectAt(msg->x, msg->y);
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(BUTTONSELECTAT, PLAYBACK);
			break;
		case DDPMSG_ISBUTTONAT:
			LOGDDP(ISBUTTONAT, STATUS);
			err = player->UOPPermitted(17, permitted);
			if (!IS_ERROR(err) && permitted)
				err = player->IsButtonAt(msg->x, msg->y, msg->boolean);
			else
				msg->boolean = FALSE;
			LOGDDPEXIT(ISBUTTONAT, STATUS);
			break;
		case DDPMSG_STILLOFF:
			LOGDDP(STILLOFF, PLAYBACK);
			err = player->UOPPermitted(18, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->StopStillPhase();
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(STILLOFF, PLAYBACK);
			break;
		case DDPMSG_PAUSEON:
			LOGDDP(PAUSEON, PLAYBACK);
			err = player->UOPPermitted(19, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->PausePlayback();
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(PAUSEON, PLAYBACK);
			break;
		case DDPMSG_PAUSEOFF:
			LOGDDP(PAUSEOFF, PLAYBACK);
			err = player->ResumePlayback();
			LOGDDPEXIT(PAUSEOFF, PLAYBACK);
			break;
		case DDPMSG_PBCON:
			LOGDDP(PBCON, PLAYBACK);
			err = player->SetPlaybackControl(TRUE);
			LOGDDPEXIT(PBCON, PLAYBACK);
			break;
		case DDPMSG_PBCOFF:
			LOGDDP(PBCOFF, PLAYBACK);
			err = player->SetPlaybackControl(FALSE);
			LOGDDPEXIT(PBCOFF, PLAYBACK);
			break;
		case DDPMSG_ADVANCEFRAME:
			LOGDDP(ADVANCEFRAME, PLAYBACK);
			err = player->AdvanceFrame();
			LOGDDPEXIT(ADVANCEFRAME, PLAYBACK);
			break;
		case DDPMSG_ADVANCEFRAMEBY:
			LOGDDP(ADVANCEFRAMEBY, PLAYBACK);
			err = player->AdvanceFrameBy(msg->val);
			LOGDDPEXIT(ADVANCEFRAMEBY, PLAYBACK);
			break;
		case DDPMSG_MENULANGUAGESELECT:
			LOGDDP(MENULANGUAGESELECT, CONFIG);
			err = player->MenuLanguageSelect(msg->word);
			LOGDDPEXIT(MENULANGUAGESELECT, CONFIG);
			break;
		case DDPMSG_AUDIOSTREAMCHANGE:
			LOGDDP(AUDIOSTREAMCHANGE, CONFIG);
			err = player->UOPPermitted(20, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					{
					DVDPlayerMode mode;

					if (!IS_ERROR(err = player->GetMode(mode)))
						{
						err = player->AudioStreamChange(msg->word);

						if (mode == DPM_PAUSED)
							player->PausePlayback();
						}
					}
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(AUDIOSTREAMCHANGE, CONFIG);
			break;
		case DDPMSG_SUBPICTURESTREAMCHANGE:
			LOGDDP(SUBPICTURESTREAMCHANGE, CONFIG);
			if (player)
				{
				err = player->UOPPermitted(21, permitted);
				if (!IS_ERROR(err))
					{
					if (permitted)
						{
						DVDPlayerMode mode;

						if (!IS_ERROR(err = player->GetMode(mode)))
							{
							err = player->SubPictureStreamChange(msg->word, msg->boolean);

							if (mode == DPM_PAUSED)
								player->PausePlayback();
							}
						}
					else
						err = GNR_UOP_PROHIBITED;
					}
				}
			else
				{
				err = GNR_OBJECT_NOT_ALLOCATED;
				}

			LOGDDPEXIT(SUBPICTURESTREAMCHANGE, CONFIG);
			break;
		case DDPMSG_ANGLECHANGE:
			LOGDDP(ANGLECHANGE, CONFIG);
			err = player->UOPPermitted(22, permitted);
			if (!IS_ERROR(err))
				{
				if (permitted)
					err = player->AngleChange(msg->word);
				else
					err = GNR_UOP_PROHIBITED;
				}
			LOGDDPEXIT(ANGLECHANGE, CONFIG);
			break;
		case DDPMSG_PARENTALLEVELSELECT:
			LOGDDP(PARENTALLEVELSELECT, CONFIG);
			err = player->ParentalLevelSelect(msg->word);
			LOGDDPEXIT(PARENTALLEVELSELECT, CONFIG);
			break;
		case DDPMSG_PARENTALCOUNTRYSELECT:
			LOGDDP(PARENTALCOUNTRYSELECT, CONFIG);
			err = player->ParentalCountrySelect(msg->word);
			LOGDDPEXIT(PARENTALCOUNTRYSELECT, CONFIG);
			break;
		case DDPMSG_GETCURRENTDISPLAYMODE:
			LOGDDP(GETCURRENTDISPLAYMODE, STATUS);
			err = player->GetCurrentDisplayMode(msg->dpmode);
			LOGDDPEXIT(GETCURRENTDISPLAYMODE, STATUS);
			break;
		case DDPMSG_SETDISPLAYMODE:
			LOGDDP(SETDISPLAYMODE, CONFIG);
			err = player->SetDisplayMode(msg->dpmode);
			LOGDDPEXIT(SETDISPLAYMODE, CONFIG);
			break;
		case DDPMSG_SELECTINITIALLANGUAGE:
			LOGDDP(SELECTINITIALLANGUAGE, CONFIG);
			err = player->SelectInitialLanguage(msg->audioLanguage, msg->audioExtension,
			                                      msg->subPictureLanguage, msg->subPictureExtension);
			LOGDDPEXIT(SELECTINITIALLANGUAGE, CONFIG);
			break;
		case DDPMSG_GETCURRENTBUTTONSTATE:
			LOGDDP(GEETCURRENTBUTTONSTATE, STATUS);
			err = player->GetCurrentButtonState(msg->word, msg->word2, msg->word3);
			LOGDDPEXIT(GEETCURRENTBUTTONSTATE, STATUS);
			break;
		case DDPMSG_FREEZE:
			LOGDDP(FREEZE, MISC);
			err = player->Freeze((DDPFreezeState*)msg->pointer, msg->dword);
			LOGDDPEXIT(FREEZE, MISC);
			break;
		case DDPMSG_DEFROST:
			LOGDDP(DEFROST, MISC);
			err = player->Defrost((DDPFreezeState*)msg->pointer, msg->dword, msg->dword2);
			LOGDDPEXIT(DEFROST, MISC);
			break;
		case DDPMSG_GETEXTENDEDPLAYERSTATE:
			LOGDDP(GETEXTENDEDPLAYERSTATE, STATUS);
			err = player->EPSPermitted(permitted);
			if (!IS_ERROR(err) && permitted)
				err = player->GetExtendedPlayerState((ExtendedPlayerState*)(msg->pointer));
			LOGDDPEXIT(GETEXTENDEDPLAYERSTATE, STATUS);
			break;
		case DDPMSG_EVENTHANDLERON:
			LOGDDP(EVENTHANDLERON, MISC);
			err = player->SetEventHandler(msg->dword, (DNEEventHandler)msg->pointer, msg->pointer2);
			LOGDDPEXIT(EVENTHANDLERON, MISC);
			break;
		case DDPMSG_EVENTHANDLEROFF:
			LOGDDP(EVENTHANDLEROFF, MISC);
			err = player->SetEventHandler(msg->dword, NULL, 0);
			LOGDDPEXIT(EVENTHANDLEROFF, MISC);
			break;
		case DDPMSG_SETBREAKPOINT:
			LOGDDP(SETBREAKPOINT, MISC);
			err = player->SetBreakpoint(msg->word, msg->word2, msg->time, msg->dword, msg->dword2);
			LOGDDPEXIT(SETBREAKPOINT, MISC);
			break;
		case DDPMSG_CLEARBREAKPOINT:
			LOGDDP(CLEARBREAKPOINT, MISC);
			err = player->ClearBreakpoint(msg->dword);
			LOGDDPEXIT(CLEARBREAKPOINT, MISC);
			break;
		case DDPMSG_DETACHDRIVE:
			LOGDDP(DETACHDRIVE, PLAYBACK);
			err = GNR_OPERATION_NOT_SUPPORTED;
			LOGDDPEXIT(DETACHDRIVE, PLAYBACK);
			break;
		case DDPMSG_GETAVFILEINFO:
			LOGDDP(GETAVFILEINFO, MISC);
			err = player->GetAVFileInfo((GenericFileSystemIterator *)(msg->pointer), (AVFInfo *)(msg->pointer2));
			LOGDDPEXIT(GETAVFILEINFO, MISC);
			break;
		case DDPMSG_PLAYFILE:
			LOGDDP(PLAYFILE, PLAYBACK);
			err = player->PlayFile((GenericFileSystemIterator *)(msg->pointer), msg->dword);
			LOGDDPEXIT(PLAYFILE, PLAYBACK);
			break;
		case DDPMSG_SETAUDIOSTREAMSELECTIONPREFS:
			LOGDDP(DDPMSG_SETAUDIOSTREAMSELECTIONPREFS, CONFIG);
			err = player->SetAudioStreamSelectionPreferences(msg->dword);
			LOGDDPEXIT(DDPMSG_SETAUDIOSTREAMSELECTIONPREFS, CONFIG);
			break;

		default:
			err = GNR_OPERATION_NOT_SUPPORTED;
			break;
		}

//	ctime = ::GetTickCount() - ctime;
//	wsprintf(buffer, "##### Message-, %d Err %08lx TIME %4d\n", wParam, err, ctime);
//	OutputDebugString(buffer);

	msg->error = err;
	}

////////////////////////////////////////////////////////////////////
//
//  DDP Function Implementations
//
////////////////////////////////////////////////////////////////////

//
//  Get root iterator pointing to certain drive
//

Error GetDriveIterator(const DiskItemName & driveName, RootIterator * & rit)
	{
	GenericFileSystemIterator * gfsi;
	DiskItemName itemName;
	Error err;
	BOOL found = FALSE;

	GNREASSERT(FileSystem->CreateRootIterator(gfsi));

	//
	//  Iterator over all drives and try to find the proper one
	//

	err = gfsi->GoToFirstItem();
	while (!IS_ERROR(err))
		{
		if (!IS_ERROR(err = gfsi->GetItemName(itemName)))
			{
			if (itemName == driveName)
				{
				found = TRUE;
				break;
				}
			err = gfsi->GoToNextItem();
			}
		}

	//
	//  If there is no drive with that name then we are done
	//

	if (!found)
		{
		delete gfsi;
		GNRAISE(GNR_OBJECT_NOT_FOUND);
		}

	rit = (RootIterator*)gfsi;
	GNRAISE_OK;
	}

//
//  Get Volume Name
//

DLLP1 Error DLLP2 DDP_GetVolumeName(char driveLetter, char * name)
	{
	RootIterator * rit;
	Error err;
	KernelString	str;

	LOGDDP(GETVOLUMENAME, STATUS);

	if (driveLetter <'A' || driveLetter > 'Z')
		GNRAISE(GNR_INVALID_DRIVE_LETTER);

	GNREASSERT(GetDriveIterator(driveLetter, rit));

	err = FileSystem->GetVolumeName(rit, str);
	str.Get(name, 255);
	delete rit;
	LOGDDPEXIT(GETVOLUMENAME, STATUS);
	GNRAISE(err);
	}

//
//  Get Disk Region Settings
//

DLLP1 Error DLLP2 DDP_GetDiskRegionSettings(UnitSet units, char driveLetter, BYTE __far & systemRegion, BYTE __far & availSets, RegionSource __far & regionSource, BYTE & diskRegion)
	{
	RootIterator * rit;
	DiskItemName driveName(driveLetter);
	Error err;

	LOGDDP(GETDISKREGIONSETTINGS, STATUS);

	GNREASSERT(GetDriveIterator(driveName, rit));
	err = RegionMan->GetRegionSettings(units, rit, systemRegion, diskRegion, regionSource, availSets);
	delete rit;

	LOGDDPEXIT(GETDISKREGIONSETTINGS, STATUS);
	GNRAISE(err);
	}

//
//  Get Region Settings
//

DLLP1 Error DLLP2 DDP_GetRegionSettings(UnitSet units, char driveLetter, BYTE __far & systemRegion, BYTE __far & availSets, RegionSource __far & regionSource)
	{
	RootIterator * rit;
	DiskItemName driveName(driveLetter);
	Error err;
	BYTE dummy;

	LOGDDP(GETREGIONSETTINGS, STATUS);

	GNREASSERT(GetDriveIterator(driveName, rit));
	err = RegionMan->GetRegionSettings(units, rit, systemRegion, dummy, regionSource, availSets);
	delete rit;

	LOGDDPEXIT(GETREGIONSETTINGS, STATUS);
	GNRAISE(err);
	}

//
//  Set System Region
//

DLLP1 Error DLLP2 DDP_SetSystemRegion(UnitSet units, char driveLetter, BYTE systemRegion)
	{
	RootIterator * rit;
	DiskItemName driveName(driveLetter);
	Error err;

	LOGDDP(SETSYSTEMREGION, CONFIG);

	GNREASSERT(GetDriveIterator(driveName, rit));
	err = RegionMan->SetSystemRegion(units, rit, systemRegion);
	delete rit;

	LOGDDPEXIT(SETSYSTEMREGION, CONFIG);
	GNRAISE(err);
	}

//
//  Check Drive For DVD
//
//  Return values:
//  GNR_OK, GNR_OBJECT_NOT_FOUND
//

Error CheckDriveForDVD(UnitSet units, RootIterator * rit, GenericFileSystem * gfs, DVDDiskType & type)
	{
	GenericFileSystemIterator * root;
	GenericFileSystemIterator * item;
	Error err;

	DP("Trying DVD ...");

	//
	//  Test on DVD
	//  One of those files must be present
	//

	GNREASSERT(gfs->CreateIterator(root));

	//
	// check for DVD-Video
	//

	err = gfs->FindItem("video_ts\\video_ts.ifo", DIT_FILE, FIF_NONE, root, item);

	if (IS_ERROR(err))
		err = gfs->FindItem("video_ts\\video_ts.inf", DIT_FILE, FIF_NONE, root, item);

	if (!IS_ERROR(err))
		{
		type = DDT_VIDEO_DVD;
		}
	else
		{
		//
		// check for DVD-Audio
		//

		if (IS_ERROR(err))
			{
			err = gfs->FindItem("audio_ts\\audio_ts.ifo", DIT_FILE, FIF_NONE, root, item);
			if (!IS_ERROR(err))
				type = DDT_AUDIO_DVD;
			}
		}

	//
	//  Cleanup
	//

	delete root;
	if (!IS_ERROR(err))
		{
		delete item;

		if (type == DDT_VIDEO_DVD)
			err = RegionMan->CheckRegionCodeValid(units, rit);
		GNRAISE(err);
		}
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Check Drive For VCD. Might also be SVCD.
//
//  Return values:
//  GNR_OK, GNR_OBJECT_NOT_FOUND
//

Error CheckDriveForVCD(GenericFileSystem * gfs, DVDDiskType & type)
	{
	GenericFileSystemIterator * root;
	GenericFileSystemIterator * item;
	Error err;

	DP("Trying Video CD ...");

	//
	//  Test on VCD
	//  For an explanation of this function see VCDHeader.cpp: VCDInfo::Initialize
	//

	GNREASSERT(gfs->CreateIterator(root));

	if (!IS_ERROR(err = gfs->FindItem("vcd\\info.vcd", DIT_FILE, FIF_NONE, root, item)))
		type = DDT_VIDEO_CD;

	if (IS_ERROR(err))
		{
		if (!IS_ERROR(err = gfs->FindItem("svcd\\info.svd", DIT_FILE, FIF_NONE, root, item)))
			type = DDT_SUPER_VIDEO_CD;
		}

	if(IS_ERROR(err))
		{
		if (!IS_ERROR(err = gfs->FindItem("hqvcd\\info.vcd", DIT_FILE, FIF_NONE, root, item)))
			type = DDT_SUPER_VIDEO_CD;
		}

	if(IS_ERROR(err))
		{
		if (!IS_ERROR(err = gfs->FindItem("mpegav\\music01.dat", DIT_FILE, FIF_NONE, root, item)))
			type = DDT_VIDEO_CD;
		}

	//
	//  Cleanup
	//

	delete root;
	if (!IS_ERROR(err))
		{
		delete item;
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Check what kind of disk we have
//
//  Return values:
//  GNR_OK, GNR_OBJECT_NOT_FOUND, GNR_REGION_*
//

Error CheckDrive(UnitSet units, const DiskItemName & driveName, DDPDiskInfo * diskInfo, GenericFileSystem * & gfs)
	{
	RootIterator * rit;
	GenericFileSystem * baseFS;
	PhysicalDiskType diskType;
	Error err = GNR_OK;

	DWORD inTime = Timer.GetMilliTicks(); //remove

	//
	//  Get us the file system and the type of the disk first
	//

	DPF("at %d ms: CheckDrive 0 - spent %d ms so far, err: %08x, abort: %d\n", Timer.GetMilliTicks(), Timer.GetMilliTicks() - inTime, err, getDiskInfoAsyncRqScheduler->IsAbortRequested()); //remove

	if (!getDiskInfoAsyncRqScheduler->IsAbortRequested())
		{
		diskInfo->type = DDT_NONE;
		GNREASSERT(GetDriveIterator(driveName, rit));

		err = FileSystem->LoadMedia(rit, 0, LMF_WAIT);

		if (IS_ERROR(err = rit->ObtainSubFileSystem(baseFS)))
			{
			delete rit;
			GNRAISE(err);
			}
		}

	if (getDiskInfoAsyncRqScheduler->IsAbortRequested())
		err = GNR_OPERATION_ABORTED;

	if (!IS_ERROR(err))
		err = baseFS->GetDiskType(diskType);

	DPF("at %d ms: CheckDrive 1 - spent %d ms so far, err: %08x, abort: %d\n", Timer.GetMilliTicks(), Timer.GetMilliTicks() - inTime, err, getDiskInfoAsyncRqScheduler->IsAbortRequested()); //remove

	//
	//  Now let's check if there are certain files that indicate the disk type
	//

	if (getDiskInfoAsyncRqScheduler->IsAbortRequested())
		err = GNR_OPERATION_ABORTED;

	if (!IS_ERROR(err))
		{
		switch (diskType)
			{
			case PHDT_NONE:
				err = GNR_OBJECT_NOT_FOUND;
				break;
			case PHDT_CDDA:
				diskInfo->type = DDT_AUDIO_CD;
				break;
			case PHDT_CDROM:
			case PHDT_CDROM_XA:
				//
				//  Assume it's a VCD first, then try DVD
				//  If you are nothing at all, but you have audio tracks,
				//  I'll assume your are AUDIO CD; if not, I'll call you MULTI_DISK
				//

				if (IS_ERROR(err = CheckDriveForVCD(baseFS, diskInfo->type)))
					{
					if (IS_ERROR(err = CheckDriveForDVD(units, rit, baseFS, diskInfo->type)))
						{
						GenericVolume* volume;
						VolumeInfo volumeInfo;
						//DP("From CheckDrive1.1 - V O:");
						if (!IS_ERROR(err = baseFS->ObtainVolume(volume)))
							{
							err = volume->GetVolumeInfo(volumeInfo);
							//DP("From CheckDrive1.1 - V R:");
							volume->Release();

							if (!IS_ERROR(err))
								{
								if (volumeInfo.attributes & VIA_CONTAINS_AUDIO_TRACKS)
									{
									diskInfo->type = DDT_AUDIO_CD;
									rit->ReleaseSubFileSystem();
									rit->ObtainSubFileSystem(baseFS, FS_CD_FILE_SYSTEM_REQUIRED);
									}
								else
									diskInfo->type = DDT_MULTI_DISK;
								}
							}
						}
					}
				break;
			case PHDT_DVD_ROM:
				if ((err = CheckDriveForDVD(units, rit, baseFS, diskInfo->type)) == GNR_OBJECT_NOT_FOUND)
					{
					diskInfo->type = DDT_MULTI_DISK;
					err = GNR_OK;
					}
				break;
			case PHDT_ILLEGAL:
				err = GNR_NO_VALID_DISK;
				break;
			default:
				err = GNR_UNEXPECTED_NAVIGATION_ERROR;
				break;
			}
		}

	DPF("at %d ms: CheckDrive 2 - spent %d ms so far, err: %08x, abort: %d\n", Timer.GetMilliTicks(), Timer.GetMilliTicks() - inTime, err, getDiskInfoAsyncRqScheduler->IsAbortRequested()); //remove

	//
	//  Create file system according to disk type
	//

	if (getDiskInfoAsyncRqScheduler->IsAbortRequested())
		err = GNR_OPERATION_ABORTED;

	if (!IS_ERROR(err))
		{
		switch (diskInfo->type)
			{
			case DDT_VIDEO_DVD:
			case DDT_AUDIO_DVD:
				err = dvdFileSystemFactory->CreateFileSystem(rit, SystemProfile, gfs);
				break;
			case DDT_AUDIO_CD:
			case DDT_DTS_AUDIO_CD:
				if (!IS_ERROR(err = cddaFileSystemFactory->CreateFileSystem(rit, SystemProfile, gfs)))
					{
					//Check if disk is DTS audio, and if so, make sure diskInfo->type is DDT_DTS_AUDIO_CD
					BOOL isDTS = FALSE;
					GenericCopyManagementInfo gcmi;
					err = gfs->GetDTSInfo(isDTS, gcmi);
					diskInfo->type = isDTS ? DDT_DTS_AUDIO_CD : DDT_AUDIO_CD;
					}
				break;
			case DDT_VIDEO_CD:
			case DDT_SUPER_VIDEO_CD:
				err = vcdFileSystemFactory->CreateFileSystem(rit, SystemProfile, gfs);
				break;
			case DDT_MULTI_DISK:
				err = avfFileSystemFactory->CreateFileSystem(rit, SystemProfile, gfs);
				break;
			default:
				err = GNR_UNEXPECTED_NAVIGATION_ERROR;
				break;
			}
		}

	//Cleanup after CreateFileSystem in case of abort or error
	if (!IS_ERROR(err) && getDiskInfoAsyncRqScheduler->IsAbortRequested())
		{
		//DP("From CheckDrive2.1 - FS R:");
		gfs->Release();
		gfs = NULL;
		err = GNR_OPERATION_ABORTED;
		}
	else if (IS_ERROR(err))
		gfs = NULL;

	DPF("at %d ms: CheckDrive 3 - spent %d ms so far, err: %08x, abort: %d\n", Timer.GetMilliTicks(), Timer.GetMilliTicks() - inTime, err, getDiskInfoAsyncRqScheduler->IsAbortRequested()); //remove

	//
	//  Compute unique key if wanted
	//

	if (getDiskInfoAsyncRqScheduler->IsAbortRequested())
		err = GNR_OPERATION_ABORTED;

	if (!IS_ERROR(err))
		err = gfs->GetUniqueKey((BYTE*)&(diskInfo->uniqueKey[0]));

	DPF("at %d ms: CheckDrive 4 - spent %d ms so far, err: %08x, abort: %d\n", Timer.GetMilliTicks(), Timer.GetMilliTicks() - inTime, err, getDiskInfoAsyncRqScheduler->IsAbortRequested()); //remove

	if (getDiskInfoAsyncRqScheduler->IsAbortRequested())
		err = GNR_OPERATION_ABORTED;

	if (!IS_ERROR(err) && (diskInfo->type == DDT_VIDEO_DVD || diskInfo->type == DDT_AUDIO_DVD) )
		err = RegionMan->GetDiskRegion(rit, diskInfo->diskRegion);
	else
		diskInfo->diskRegion = 0;

	//
	//  Cleanup and out of here
	//

	rit->ReleaseSubFileSystem();
	delete rit;
	DPF("CheckDrive done. It took %d msec\n", Timer.GetMilliTicks() - inTime); //remove

	//Release gfs in case error happened after gfs was successfully allocated
	if (IS_ERROR(err) && gfs)
		{
		//DP("From CheckDrive4.1 - FS R:");
		gfs->Release();
		gfs = NULL;
		}

	GNRAISE(err);
	}

//
//  Check drive with drive letter
//

DLLP1 Error DLLP2 DDP_CheckDrive(char driveLetter, char __far * id)
	{
	DiskItemName driveName(driveLetter);
	DDPDiskInfo diskInfo;
	GenericFileSystem * gfs = NULL;
	Error err;

	LOGDDP(CHECKDRIVE, STATUS);

	//
	//  Check drive letter
	//

	if (driveLetter < 'A' || driveLetter > 'Z')
		{
		DP("CheckDrive: Illegal drive letter! %c", driveLetter);
		GNRAISE(GNR_INVALID_DRIVE_LETTER);
		}

	if (!IS_ERROR(err = CheckDrive(NULL, driveName, &diskInfo, gfs)) && gfs)
		{
		//DP("From DDP_CheckDrive - FS R:");
		gfs->Release();
		}

	if (id)
		memcpy(id, diskInfo.uniqueKey, 8);

	LOGDDPEXIT(CHECKDRIVE, STATUS);
	GNRAISE(err);
	}

//
//  Check drive with path
//

DLLP1 Error DLLP2  DDP_CheckDriveWithPath(char * drivePath, char __far * id)
	{
	DDPDiskInfo diskInfo;
	DiskItemName driveName(drivePath);
	GenericFileSystem * gfs = NULL;
	Error err;

	LOGDDP(CHECKDRIVEWITHPATH, STATUS);

	if (!IS_ERROR(err = CheckDrive(NULL, driveName, &diskInfo, gfs)) && gfs)
		{
		//DP("From DDP_CheckDriveWithPath - FS R:");
		gfs->Release();
		}

	if (id)
		memcpy(id, diskInfo.uniqueKey, 8);

	LOGDDPEXIT(CHECKDRIVEWITHPATH, STATUS);
	GNRAISE(err);
	}

//
//  Open Player
//

Error OpenPlayer(UnitSet units, const DiskItemName & driveName, DVDDiskPlayer & player, DDPDiskInfo * diskInfo)
	{
	GenericFileSystem * gfs = NULL;
	RootIterator * rit;
	DVDPlayerMsg msg;
	DiskItemName name(driveName);

	//
	//  Determine disk type
	//

	DPF("Enter OpenPlayer");
	DWORD inTime = Timer.GetMilliTicks(); //remove

	GNREASSERT(CheckDrive(units, driveName, diskInfo, gfs));

	//
	//  Wait for scheduler to become ready
	//


	DWORD inTime2 = Timer.GetMilliTicks(); //remove

	//
	//  Initialize message
	//

	msg.units = units;
	msg.str = (TCHAR*)name;
	msg.player = NULL;
	msg.error = GNR_OK;
	msg.pointer = gfs;

	//
	// Open appropriate player
	//


	if (IS_ERROR(msg.error = GetDriveIterator(driveName, rit)))
		rit = NULL;

	if (!IS_ERROR(msg.error))
		{
		msg.diskType = diskInfo->type;
		msg.pointer2 = rit;

		switch (diskInfo->type)
			{
			case DDT_VIDEO_DVD:
				ddpScheduler->DoMessage(DDPMSG_OPENDVDVIDEOPLAYER, (DWORD)&msg);
				break;
			case DDT_AUDIO_DVD:
				ddpScheduler->DoMessage(DDPMSG_OPENDVDAUDIOPLAYER, (DWORD)&msg);
				break;
			case DDT_VIDEO_CD:
			case DDT_SUPER_VIDEO_CD:	// Intended fall through
				ddpScheduler->DoMessage(DDPMSG_OPENVCDPLAYER, (DWORD)&msg);
				break;
			case DDT_AUDIO_CD:
			case DDT_DTS_AUDIO_CD:		// Intended fall through
				ddpScheduler->DoMessage(DDPMSG_OPENCDDAPLAYER, (DWORD)&msg);
				break;
			case DDT_MULTI_DISK:
				ddpScheduler->DoMessage(DDPMSG_OPENAVFPLAYER, (DWORD)&msg);
				break;
			default:
				msg.error = GNR_UNEXPECTED_NAVIGATION_ERROR;
				break;
			}
		}

	//
	//  Return the results
	//

	player = msg.player;
	delete rit;
	if (IS_ERROR(msg.error) && gfs)
		{
		//DP("From OpenPlayer - FS R:");
		gfs->Release();
		}

	DPF("OpenPlayer done, it took %d ms in total, %d ms after CheckDrive\n", Timer.GetMilliTicks()-inTime, Timer.GetMilliTicks()-inTime2);
	GNRAISE(msg.error);
	}


//
//  Open Player with direct call. This function is intented to be called during handling asynchrnous open player request.
//

Error OpenPlayerDirect(UnitSet units, const DiskItemName & driveName, DVDDiskPlayer & player, DDPDiskInfo * diskInfo)
	{
	GenericFileSystem * gfs = NULL;
	RootIterator * rit = NULL;
	Error err;

	//
	//  Determine disk type
	//

	DPF("At %d: Enter OpenPlayerDirect\n", Timer.GetMilliTicks());
	DWORD inTime = Timer.GetMilliTicks(); //remove

	GNREASSERT(err = CheckDrive(units, driveName, diskInfo, gfs));

	DWORD inTime2 = Timer.GetMilliTicks(); //remove

	//
	// Open appropriate player
	//

	player = NULL;
	if (IS_ERROR(err = GetDriveIterator(driveName, rit)))
		rit = NULL;

	if (!IS_ERROR(err))
		{
		switch (diskInfo->type)
			{
			case DDT_VIDEO_DVD:
				{
				BYTE systemRegion, diskRegion, availSets;
				RegionSource regionSource;

				LOGDDP(OPENDVDVIDEOPLAYER, PLAYBACK);

				if (!IS_ERROR(err = RegionMan->GetRegionSettings(units, rit, systemRegion, diskRegion, regionSource, availSets)))
					err = dvdVideoDiskPlayerFactory->CreateDiskPlayer(DriverInstance, units, SystemProfile, diskInfo->type,
																						(DVDFileSystem*)gfs, systemRegion, player);
				LOGDDPEXIT(OPENDVDVIDEOPLAYER, PLAYBACK);
				}
				break;
			case DDT_AUDIO_DVD:
				LOGDDP(OPENDVDAUDIOPLAYER, PLAYBACK);
				err = dvdAudioDiskPlayerFactory->CreateDiskPlayer(DriverInstance, units, SystemProfile, diskInfo->type,
																					(DVDFileSystem*)gfs, 0, player);
				LOGDDPEXIT(OPENDVDAUDIOPLAYER, PLAYBACK);
				break;
			case DDT_VIDEO_CD:
			case DDT_SUPER_VIDEO_CD:	// Intended fall through
				LOGDDP(OPENVCDPLAYER, PLAYBACK);
				err = vcdDiskPlayerFactory->CreateDiskPlayer(DriverInstance, units, SystemProfile, diskInfo->type,
																			  (VCDFileSystem*)gfs, player);
				LOGDDPEXIT(OPENVCDPLAYER, PLAYBACK);
				break;
			case DDT_AUDIO_CD:
			case DDT_DTS_AUDIO_CD:		// Intended fall through
				LOGDDP(OPENCDDAPLAYER, PLAYBACK);
				err = cddaDiskPlayerFactory->CreateDiskPlayer(DriverInstance, units, SystemProfile, diskInfo->type,
																				(CDDAFileSystem*)gfs, player);
				LOGDDPEXIT(OPENCDDAPLAYER, PLAYBACK);
				break;
			case DDT_MULTI_DISK:
				LOGDDP(OPENAVFPLAYER, PLAYBACK);
				err = avfDiskPlayerFactory->CreateDiskPlayer(DriverInstance, units, SystemProfile, diskInfo->type,
																			  (GenericFileSystem*)gfs, player);
				LOGDDPEXIT(OPENAVFPLAYER, PLAYBACK);
				break;
			default:
				err = GNR_UNEXPECTED_NAVIGATION_ERROR;
				break;
			}
		}

	//
	//  Return the results
	//

	delete rit;
	if (IS_ERROR(err) && gfs)
		{
		//DP("From OpenPlayerDirect - FS R:");
		gfs->Release();
		}

	if (getDiskInfoAsyncRqScheduler->IsAbortRequested())
		{
		err = GNR_OPERATION_ABORTED;
		player = NULL;
		}
	DPF("OpenPlayerDirect done, it took %d ms in total, %d ms after CheckDrive\n", Timer.GetMilliTicks()-inTime, Timer.GetMilliTicks()-inTime2);
	GNRAISE(err);
	}

//
//  Open Player
//

DLLP1 Error DLLP2 DDP_OpenPlayer(UnitSet units, char driveLetter, DVDDiskPlayer __far & player)
	{
	DDPDiskInfo dummy;
	DiskItemName driveName(driveLetter);
	Error err = GNR_INVALID_DRIVE_LETTER;

	LOGDDP(OPENPLAYER, PLAYBACK);

	//
	//  Check drive letter
	//

	if (driveLetter >= 'A' || driveLetter <= 'Z')
		err = OpenPlayer(units, driveName, player, &dummy);
	else
		DP("CheckDrive: Illegal drive letter! %c", driveLetter);

	LOGDDPEXIT(OPENPLAYER, PLAYBACK);
	GNRAISE(err);
	}

//
//  Open Player With Path
//

DLLP1 Error DLLP2 DDP_OpenPlayerWithPath(UnitSet units, char * drivePath, DVDDiskPlayer __far & player)
	{
	DDPDiskInfo dummy;
	DiskItemName driveName(drivePath);
	Error err;

	LOGDDP(OPENPLAYERWITHPATH, PLAYBACK);
	err = OpenPlayer(units, driveName, player, &dummy);
	LOGDDPEXIT(OPENPLAYERWITHPATH, PLAYBACK);
	GNRAISE(err);
	}

//
//  Extended Open Player
//

DLLP1 Error DLLP2 DDP_OpenPlayerExtended(UnitSet units, char driveLetter, char * drivePath,
													  DVDDiskPlayer __far & player, DDPDiskInfo __far & diskInfo)
	{
	DDPDiskInfo di;
	Error err = GNR_OK;
	DiskItemName driveName;

	LOGDDP(OPENPLAYEREXTENDED, PLAYBACK);

	//
	//  Check drive letter
	//

	if (!drivePath)
		{
		if (driveLetter < 'A' || driveLetter > 'Z')
			err = GNR_INVALID_DRIVE_LETTER;

		driveName = DiskItemName(driveLetter);
		}
	else
		driveName = DiskItemName(drivePath);

	if (!IS_ERROR(err) && !IS_ERROR(err = OpenPlayer(units, driveName, player, &di)))
		{
		di.size = diskInfo.size;
		memcpy(&diskInfo, &di, min(diskInfo.size, di.size));
		}

	LOGDDPEXIT(OPENPLAYEREXTENDED, PLAYBACK);
	GNRAISE(err);
	}


//
//  Close player
//

DLLP1 Error DLLP2 DDP_ClosePlayer(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_CLOSEPLAYER, (DWORD)&msg);

	GNRAISE(msg.error);
	}

//
//  Get Drive Status
//  Return values:
//  GNR_OK, GNR_INVALID_DRIVE_LETTER
//

#if MSNDISC
DLLP1 Error DLLP2 DDP_GetDriveStatus(char driveLetter, BOOL & opened, BOOL & closed)
	{
	RootIterator * rit;
	DWORD status;
	DWORD position;
	DiskItemName driveName(driveLetter);
	Error err;

	LOGDDP(GETDRIVESTATUS, STATUS);

	if (driveLetter < 'A' || driveLetter > 'Z')
		err = GNR_INVALID_DRIVE_LETTER;
	else
		{
		if (!IS_ERROR(err = GetDriveIterator(driveName, rit)))
			{
			err = FileSystem->GetChangerStatus(rit, status, position);

			if (!IS_ERROR(err))
				{

				if ( status & GCS_OPEN )
					{
					opened = TRUE;
					closed = FALSE;
					}
				else
				if ( status & GCS_CLOSED )
					{
					opened = FALSE;
					closed = TRUE;
					}
				else
				if (( status & GCS_OPENING ) || ( status & GCS_CLOSING) )
					{
					opened = FALSE;
					closed = FALSE;
					}
				else
					{
					opened = TRUE;
					closed = TRUE;
					}
				}
			delete rit;
			}
		}

	LOGDDPEXIT(GETDRIVESTATUS, STATUS);
	GNRAISE(err);
	}


#else

DLLP1 Error DLLP2 DDP_GetDriveStatus(char driveLetter, BOOL & opened, BOOL & closed)
	{
	RootIterator * rit;
	GenericTrayStatus status;
	DiskItemName driveName(driveLetter);
	Error err;

	LOGDDP(GETDRIVESTATUS, STATUS);

	if (driveLetter < 'A' || driveLetter > 'Z')
		err = GNR_INVALID_DRIVE_LETTER;
	else
		{
		if (!IS_ERROR(err = GetDriveIterator(driveName, rit)))
			{
			err = FileSystem->GetTrayStatus(rit, status);

			if (!IS_ERROR(err))
				{
				switch (status)
					{
					case GTS_TRAY_OPEN:
						opened = TRUE;
						closed = FALSE;
						break;
					case GTS_TRAY_CLOSED:
						opened = FALSE;
						closed = TRUE;
						break;
					case GTS_TRAY_MOVING:
						opened = FALSE;
						closed = FALSE;
						break;
					case GTS_TRAY_UNKNOWN:
						opened = TRUE;
						closed = TRUE;
						break;
					}
				}
			delete rit;
			}
		}

	LOGDDPEXIT(GETDRIVESTATUS, STATUS);
	GNRAISE(err);
	}

#endif

//
//  Load Disk In Drive
//

DLLP1 Error DLLP2 DDP_LoadDiskInDrive(char driveLetter, BOOL wait)
	{
	RootIterator * rit;
	DiskItemName driveName(driveLetter);
	DWORD flags;
	Error err;

	LOGDDP(LOADDISKINDRIVE, MISC);

	if (!IS_ERROR(err = GetDriveIterator(driveName, rit)))
		{
		if (wait)
			flags = LMF_WAIT;
		else
			flags = LMF_NONE;
		err = FileSystem->LoadMedia(rit, 0, flags);
		delete rit;
		}

	LOGDDPEXIT(LOADDISKINDRIVE, MISC);
	GNRAISE(err);
	}

//
//  Eject Disk In Drive
//

DLLP1 Error DLLP2 DDP_EjectDiskInDrive(char driveLetter)
	{
	RootIterator * rit;
	DiskItemName driveName(driveLetter);
	Error err;

	LOGDDP(EJECTDISKINDRIVE, MISC);

	if (!IS_ERROR(err = GetDriveIterator(driveName, rit)))
		{
		err = FileSystem->UnloadMedia(rit, UMF_NONE);
		delete rit;
		}

	LOGDDPEXIT(EJECTDISKINDRIVE, MISC);
	GNRAISE(err);
	}

#if MSNDISC

DLLP1 Error DLLP2 DDP_LoadMedia(char driveLetter, BOOL wait)
	{
	RootIterator * rit;
	DiskItemName driveName(driveLetter);
	DWORD flags;
	Error err;

	LOGDDP(LOADMEDIA, MISC);

	if (!IS_ERROR(err = GetDriveIterator(driveName, rit)))
		{
		if (wait)
			flags = LMF_WAIT;
		else
			flags = LMF_NONE;
		err = FileSystem->LoadMedia(rit, 0, flags);
		delete rit;
		}

	LOGDDPEXIT(LOADMEDIA, MISC);
	GNRAISE(err);
	}


DLLP1 Error DLLP2 DDP_UnloadMedia(char driveLetter, BOOL wait)
	{
	RootIterator * rit;
	DiskItemName driveName(driveLetter);
	DWORD flags;
	Error err;

	LOGDDP(UNLOADMEDIA, MISC);

	if (!IS_ERROR(err = GetDriveIterator(driveName, rit)))
		{
		if (wait)
			flags = UMF_WAIT;
		else
			flags = UMF_NONE;
		err = FileSystem->UnloadMedia(rit, flags);
		delete rit;
		}

	LOGDDPEXIT(UNLOADMEDIA, MISC);
	GNRAISE(err);
	}


DLLP1 Error DLLP2  DDP_GetDriveCaps(char driveLetter, DWORD &caps, DWORD &slots, DWORD& positions, DWORD& changerOpenOffset )
	{
	RootIterator * rit;
	DiskItemName driveName(driveLetter);
	Error err;

	LOGDDP(GETDRIVECAPS, MISC);

	if (!IS_ERROR(err = GetDriveIterator(driveName, rit)))
		{
		err = FileSystem->GetDriveCaps(rit, caps, slots, positions, changerOpenOffset );
		delete rit;
		}

	LOGDDPEXIT(GETDRIVECAPS, MISC);
	GNRAISE(err);
	}

DLLP1 Error DLLP2 DDP_MoveChanger(char driveLetter, DWORD operation, DWORD flags, DWORD param)
	{
	RootIterator * rit;
	DiskItemName driveName(driveLetter);
	Error err;

	LOGDDP(MOVECHANGER, MISC);

	if (!IS_ERROR(err = GetDriveIterator(driveName, rit)))
		{
		err = FileSystem->MoveChanger(rit, operation, flags, param);
		delete rit;
		}

	LOGDDPEXIT(MOVECHANGER, MISC);
	GNRAISE(err);
	}

DLLP1 Error DLLP2 DDP_GetChangerStatus(char driveLetter, DWORD& status, DWORD& position )
	{
	RootIterator * rit;
	DiskItemName driveName(driveLetter);
	Error err;

	LOGDDP(GETCHANGERSTATUS, MISC);

	if (!IS_ERROR(err = GetDriveIterator(driveName, rit)))
		{
		err = FileSystem->GetChangerStatus(rit,status,position );
		delete rit;
		}

	LOGDDPEXIT(GETCHANGERSTATUS, MISC);
	GNRAISE(err);
	}

DLLP1 Error DLLP2 DDP_GetSlotStatus(char driveLetter, DWORD slot, DWORD& status )
	{
	RootIterator * rit;
	DiskItemName driveName(driveLetter);
	Error err;

	LOGDDP(GETSLOTSTATUS, MISC);

	if (!IS_ERROR(err = GetDriveIterator(driveName, rit)))
		{
		err = FileSystem->GetSlotStatus(rit,slot,status);
		delete rit;
		}

	LOGDDPEXIT(GETSLOTSTATUS, MISC);
	GNRAISE(err);
	}
#endif



//
//  Get disk type
//

DLLP1 DVDDiskType DLLP2 DDP_GetDiskType(DVDDiskPlayer player)
	{
	DVDDiskType type;
	Error err;

	LOGDDP(GETDISKTYPE, STATUS);
	if (IS_ERROR(err = player->GetDiskType(type)))
		type = DDT_NONE;

	LOGDDPEXIT(GETDISKTYPE, STATUS);
	return type;
	}


//
//  Get info asinchonously (return right away and report result later by calling ARQCallback).
//  On return rqHandle contains unique request to request being processed. Application should
//  pass this handle when calling DDP_AbortAsyncRequest()
//

DLLP1 Error DLLP2 DDP_GetDiskInfoAsync(char * drivePath, ARQAsyncRequestDoneCB ARQCallback, DDPDiskOnlyInfo* diskOnlyInfo, DWORD & rqHandle)
	{
	Error err;
	LOGDDP(GETDISKINFOASYNC, STATUS);
	KernelString ksDrivePath(drivePath);
	err = getDiskInfoAsyncRqScheduler->ScheduleRequest(ARQ_GET_DISK_INFO, ksDrivePath, ARQCallback, (void*)diskOnlyInfo, rqHandle);
	LOGDDPEXIT(GETDISKINFOASYNC, STATUS);
	GNRAISE(err);
	}

//
//  Open player asynchrnously (return right away and report result later by calling ARQCallback).
//  On return rqHandle contains unique request to request being processed. Application should
//  pass this handle when calling DDP_AbortAsyncRequest()
//

DLLP1 Error DLLP2 DDP_OpenPlayerAsync(char * drivePath, ARQAsyncRequestDoneCB ARQCallback, DDPOpenPlayerInfo* openPlayerInfo, DWORD & rqHandle)
	{
	Error err = GNR_OK;
	KernelString ksDrivePath;

	LOGDDP(OPENPLAYERASYNC, PLAYBACK);

	DPF("At %d: Enter DDP_OpenPlayerAsync\n", Timer.GetMilliTicks());
	ksDrivePath = drivePath;
	err = getDiskInfoAsyncRqScheduler->ScheduleRequest(ARQ_OPEN_PLAYER, ksDrivePath, ARQCallback, (void*)openPlayerInfo, rqHandle);
	DPF("At %d: OpenPlayerAsync returns %08x\n", Timer.GetMilliTicks(), err);

	LOGDDPEXIT(OPENPLAYERASYNC, PLAYBACK);
	GNRAISE(err);
	}


//
// Abort asynchronous request
// dwHandle is ID of request to be aborted (obtained from one of DDP_...Async() calls)
//

DLLP1 Error DLLP2 DDP_AbortAsyncRequest(DWORD rqHandle)
	{
	Error err;
	LOGDDP(ABORTGETDISKINFOASYNC, STATUS);
	err = getDiskInfoAsyncRqScheduler->AbortAndDisableDiskRequests(rqHandle);
	LOGDDPEXIT(ABORTGETDISKINFOASYNC, STATUS);
	GNRAISE(err);
	}

//
// GetDiskInfoAsyncRequestScheduler::ScheduleRequest
//

Error GetDiskInfoAsyncRequestScheduler::ScheduleRequest(ARQReqestID asyncRqID, KernelString& drivePath, ARQAsyncRequestDoneCB ARQCallback, void* rqData, DWORD & rqHandle)
	{
	if (!ARQCallback)
		return GNR_INVALID_PARAMETERS;

	if (IsRequestInProgress())
		return GNR_OBJECT_IN_USE; //sorry, only one request at a time...

	SetRequestInProgressFlag(TRUE); //has to be reset to FALSE by DDPMSG_PROCESS_ASYNC_RQ message handler

	rqPending.rqHandle = rqHandle = GetNewHandle();
	rqPending.asyncRqID = asyncRqID;
	rqPending.rqData = rqData;
	rqPending.drivePath = drivePath;
	rqPending.asyncRequestDoneCallback = ARQCallback;

	msg.dword = rqHandle;

	if (ddpScheduler->SendMessage(DDPMSG_PROCESS_ASYNC_RQ, (DWORD)&msg))
		GNRAISE_OK;
	else
		GNRAISE(GNR_OPERATION_FAILED);
	}


//
//  ProcessAsyncRequest() processes DDPMSG_PROCESS_ASYNC_RQ message sent by GetDiskInfoAsyncRequestScheduler::ScheduleRequest()
//

Error GetDiskInfoAsyncRequestScheduler::ProcessAsyncRequest(DWORD rqHandle)
	{
	Error err = GNR_OK;

	asyncRqDone.Reset();

	//Generate error if request is not found
	if (rqHandle != constRqHandle)
		err = GNR_OBJECT_NOT_FOUND;

	if (!IS_ERROR(err))
		{
		DP("At %d ms: Process asyncRequest %d", Timer.GetMilliTicks(), rqPending.asyncRqID);//remove
		DiskItemName driveName(rqPending.drivePath);
		switch(rqPending.asyncRqID)
			{
			case ARQ_GET_DISK_INFO:
				{
				DDPDiskInfo diskInfo;
				GenericFileSystem * gfs = NULL;
				KernelString volumeName;
				if ( !IS_ERROR(err = CheckDrive(NULL, driveName, &diskInfo, gfs)) )
					{
					DDPDiskOnlyInfo* diskOnlyInfo = (DDPDiskOnlyInfo*)rqPending.rqData;
					gfs->GetVolumeName(volumeName);
					volumeName.Get(diskOnlyInfo->volumeName, 255);
					diskOnlyInfo->type = diskInfo.type;
					memcpy(diskOnlyInfo->uniqueKey, diskInfo.uniqueKey, 8);
					diskOnlyInfo->diskRegion = diskInfo.diskRegion;
					if (gfs)
						{
						//DP("From ProcessAsyncRequest - FS R:");
						gfs->Release();
						}
					}
				}
				break;

			case ARQ_OPEN_PLAYER:
				{
				DDPOpenPlayerInfo* openPlayerInfo = (DDPOpenPlayerInfo*)rqPending.rqData;
				err = OpenPlayerDirect((UnitSet)openPlayerInfo->units, driveName, *(DVDDiskPlayer*)(openPlayerInfo->pplayer), &openPlayerInfo->diskInfo);
				}
				break;
			}

		if (rqPending.asyncRequestDoneCallback)
			rqPending.asyncRequestDoneCallback(rqPending.asyncRqID, rqPending.rqHandle, rqPending.rqData, err);
		}

	asyncRqDone.Signal();
	DP("At %d ms: asyncRqDone set - returns %08x.\n", Timer.GetMilliTicks(), err);//remove
	SetRequestInProgressFlag(FALSE); //Make yourself available for new requests
	GNRAISE(err);
	}

//
//	 GetDiskInfoAsyncRequestScheduler::AbortAndDisableDiskRequests
//

Error GetDiskInfoAsyncRequestScheduler::AbortAndDisableDiskRequests(DWORD rqHandle)
	{
	RootIterator * rit;
	Error err;
	KernelString drivePath = "";

	DWORD timeIn = Timer.GetMilliTicks();//remove
	DPF("At %d: Enter abort\n", Timer.GetMilliTicks());//remove
	if (!IsRequestInProgress())
		{
		DPF("No request in progress - bye...\n");
		GNRAISE_OK;
		}

	//Generate error if request is not found
	if (rqHandle != constRqHandle)
		GNRAISE(GNR_OBJECT_NOT_FOUND);

	SetAbortRequestFlag(TRUE);
	DPF("Request in progress, trying to abort...\n");//remove

	DiskItemName driveName(rqPending.drivePath);
	if (IS_ERROR(err = GetDriveIterator(driveName, rit)))
		{
		SetAbortRequestFlag(FALSE);
		GNRAISE(err);
		}

	DPF("at %d ms: Telling disk to abort...\n", Timer.GetMilliTicks());//remove
	err = FileSystem->AbortAndDisableDiskRequests(rit);

	DPF("at %d ms: ...Disk told to abort. Wait for curent async call to finish...\n", Timer.GetMilliTicks());//remove
	asyncRqDone.Wait();
	SetAbortRequestFlag(FALSE);
	DPF("at %d ms: Done waiting (spent %d ms so far)\n", Timer.GetMilliTicks(), Timer.GetMilliTicks()-timeIn);//remove
	FileSystem->EnableDiskRequests(rit);

	delete rit;

	DPF("Abort done. Spent %d ms in total\n", Timer.GetMilliTicks()-timeIn);//remove
	GNRAISE(err);
	}


//
//  Start presentation
//

DLLP1 Error DLLP2 DDP_StartPresentation(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.dword = DDPSPF_NONE;

	ddpScheduler->DoMessage(DDPMSG_STARTPRESENTATION, (DWORD)&msg);

	GNRAISE(msg.error);
	}

//
//  Start presentation extended
//

DLLP1 Error DLLP2 DDP_StartPresentationExt(DVDDiskPlayer player, DWORD flags)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.dword = flags;

	ddpScheduler->DoMessage(DDPMSG_STARTPRESENTATION, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_GetCurrentLocation(DVDDiskPlayer player, DVDLocation & location)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.location = &location;

	ddpScheduler->DoMessage(DDPMSG_GETCURRENTLOCATION, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_GetCurrentDuration(DVDDiskPlayer player, DVDLocation & duration)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.location = &duration;

	ddpScheduler->DoMessage(DDPMSG_GETCURRENTDURATION, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_GetTitleDuration(DVDDiskPlayer player, WORD title, DVDTime & duration)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.word = title;

	ddpScheduler->DoMessage(DDPMSG_GETTITLEDURATION, (DWORD)&msg);

	duration = msg.time;
	GNRAISE(msg.error);
	}

DLLP1 DVDPlayerMode DLLP2 DDP_GetPlayerMode(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_GETPLAYERMODE, (DWORD)&msg);

	return msg.mode;
	}

DLLP1 Error DLLP2 DDP_GetExtendedPlayerState(DVDDiskPlayer player, ExtendedPlayerState & eps)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.pointer = &eps;

	ddpScheduler->DoMessage(DDPMSG_GETEXTENDEDPLAYERSTATE, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 DWORD DLLP2 DDP_GetForbiddenUserOperations(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_GETFORBIDDENUSEROPERATIONS, (DWORD)&msg);

	return msg.dword;
	}

DLLP1 WORD DLLP2 DDP_GetNumberOfTitles(DVDDiskPlayer player)
   {
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_GETNUMBEROFTITLES, (DWORD)&msg);

	return msg.word;
   }

DLLP1 WORD DLLP2 DDP_GetNumberOfPartOfTitle(DVDDiskPlayer player, WORD title)
   {
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.title = title;

	ddpScheduler->DoMessage(DDPMSG_GETNUMBEROFPARTOFTITLES, (DWORD)&msg);

	return msg.word;
   }

DLLP1 Error DLLP2 DDP_GetAvailStreams(DVDDiskPlayer player, BYTE __far & audioMask, DWORD __far & subPictureMask)
   {
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_GETAVAILSTREAMS, (DWORD)&msg);

	audioMask = msg.byte;
	subPictureMask = msg.dword;

	GNRAISE(msg.error);
   }

DLLP1 WORD DLLP2 DDP_GetCurrentAudioStream(DVDDiskPlayer player)
   {
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_GETCURRENTAUDIOSTREAM, (DWORD)&msg);

	DVDAudioStreamFormat format;
	DDP_GetAudioStreamAttributes(player, msg.word, format);

	return msg.word;
   }

DLLP1 WORD DLLP2 DDP_GetCurrentSubPictureStream(DVDDiskPlayer player)
   {
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_GETCURRENTSUBPICTURESTREAM, (DWORD)&msg);

	return msg.word;
   }

DLLP1 BOOL DLLP2 DDP_IsCurrentSubPictureEnabled(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_ISCURRENTSUBPICTURENENABLED, (DWORD)&msg);

	return msg.boolean;
	}

DLLP1 Error DLLP2 DDP_GetAudioStreamAttributes(DVDDiskPlayer player, WORD stream, DVDAudioStreamFormat __far & format)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.word = stream;
	msg.audioStreamFormat = &format;

	ddpScheduler->DoMessage(DDPMSG_GETAUDIOSTREAMATTRIBUTES, (DWORD)&msg);

	return msg.error;
	}

DLLP1 Error DLLP2 DDP_GetSubPictureStreamAttributes(DVDDiskPlayer player, WORD stream, DVDSubPictureStreamFormat __far & format)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.word = stream;
	msg.subPictureStreamFormat = &format;

	ddpScheduler->DoMessage(DDPMSG_GETSUBPICTURESTREAMATTRIBUTES, (DWORD)&msg);

	return msg.error;
	}

DLLP1 DisplayPresentationMode DLLP2  DDP_GetCurrentDisplayMode(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_GETCURRENTDISPLAYMODE, (DWORD)&msg);

	return msg.dpmode;
	}

DLLP1 Error DLLP2  DDP_SetDisplayMode(DVDDiskPlayer player, DisplayPresentationMode mode)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.dpmode = mode;

	ddpScheduler->DoMessage(DDPMSG_SETDISPLAYMODE, (DWORD)&msg);

	return msg.error;
	}

DLLP1 WORD DLLP2 DDP_GetNumberOfAngles(DVDDiskPlayer player, WORD title)
   {
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.title = title;

	ddpScheduler->DoMessage(DDPMSG_GETNUMBEROFANGLES, (DWORD)&msg);

	return msg.word;
   }

DLLP1 WORD DLLP2 DDP_GetCurrentAngle(DVDDiskPlayer player)
   {
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_GETCURRENTANGLE, (DWORD)&msg);

	return msg.word;
   }

DLLP1 BOOL DLLP2 DDP_CheckMenuAvail(DVDDiskPlayer player, VTSMenuType menu)
   {
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.menu = menu;

	ddpScheduler->DoMessage(DDPMSG_CHECKMENUAVAIL, (DWORD)&msg);

	return msg.boolean;
   }


DLLP1 Error DLLP2 DDP_TitlePlay(DVDDiskPlayer player, WORD title)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.title = title;

	ddpScheduler->DoMessage(DDPMSG_TITLEPLAY, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_TitlePlayForced(DVDDiskPlayer player, WORD title)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.title = title;

	ddpScheduler->DoMessage(DDPMSG_TITLEPLAYFORCED, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_PTTPlay(DVDDiskPlayer player, WORD title, WORD part)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.title = title;
	msg.part = part;

	ddpScheduler->DoMessage(DDPMSG_PTTPLAY, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_PTTPlayForced(DVDDiskPlayer player, WORD title, WORD part)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.title = title;
	msg.part = part;

	ddpScheduler->DoMessage(DDPMSG_PTTPLAYFORCED, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_TimePlay(DVDDiskPlayer player, WORD title, DVDTime time)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.title = title;
	msg.time = time;

	ddpScheduler->DoMessage(DDPMSG_TIMEPLAY, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_TimePlayForced(DVDDiskPlayer player, WORD title, DVDTime time)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.title = title;
	msg.time = time;

	ddpScheduler->DoMessage(DDPMSG_TIMEPLAYFORCED, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_ExtendedPlay(DVDDiskPlayer player, DWORD flags, WORD title, WORD ptt, DVDTime time)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.dword = flags;
	msg.title = title;
	msg.part = ptt;
	msg.time = time;

	ddpScheduler->DoMessage(DDPMSG_EXTENDEDPLAY, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_Stop(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_STOP, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_GoUp(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_GOUP, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_TimeSearch(DVDDiskPlayer player, DVDTime time)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.time = time;

	ddpScheduler->DoMessage(DDPMSG_TIMESEARCH, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_TimeSearchForced(DVDDiskPlayer player, DVDTime time)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.time = time;

	ddpScheduler->DoMessage(DDPMSG_TIMESEARCHFORCED, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_PTTSearch(DVDDiskPlayer player, WORD part)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.part = part;

	ddpScheduler->DoMessage(DDPMSG_PTTSEARCH, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_PTTSearchForced(DVDDiskPlayer player, WORD part)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.part = part;

	ddpScheduler->DoMessage(DDPMSG_PTTSEARCHFORCED, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_PrevPGSearch(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_PREVPGSEARCH, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_TopPGSearch(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_TOPPGSEARCH, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_NextPGSearch(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_NEXTPGSEARCH, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_ForwardScan(DVDDiskPlayer player, WORD speed)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.word = speed;

	ddpScheduler->DoMessage(DDPMSG_FORWARDSCAN, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_BackwardScan(DVDDiskPlayer player, WORD speed)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.word = speed;

	ddpScheduler->DoMessage(DDPMSG_BACKWARDSCAN, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_TrickPlay(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_TRICKPLAY, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_StopScan(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_STOPSCAN, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_ReversePlayback(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_REVERSEPLAY, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_MenuCall(DVDDiskPlayer player, VTSMenuType menu)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.menu = menu;

	ddpScheduler->DoMessage(DDPMSG_MENUCALL, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_Resume(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_RESUME, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_UpperButtonSelect(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_UPPERBUTTONSELECT, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_LowerButtonSelect(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_LOWERBUTTONSELECT, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_LeftButtonSelect(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_LEFTBUTTONSELECT, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_RightButtonSelect(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_RIGHTBUTTONSELECT, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_ButtonSelectAt(DVDDiskPlayer player, WORD x, WORD y)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.x = x; msg.y = y;

	ddpScheduler->DoMessage(DDPMSG_BUTTONSELECTAT, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 BOOL DLLP2 DDP_IsButtonAt(DVDDiskPlayer player, WORD x, WORD y)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.x = x; msg.y = y;

	ddpScheduler->DoMessage(DDPMSG_ISBUTTONAT, (DWORD)&msg);

	return msg.boolean;
	}

DLLP1 Error DLLP2 DDP_ButtonActivate(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_BUTTONACTIVATE, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_ButtonSelectAndActivate(DVDDiskPlayer player, WORD num)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.word = num;

	ddpScheduler->DoMessage(DDPMSG_BUTTONSELECTANDACTIVATE, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_ButtonSelectAndActivateAt(DVDDiskPlayer player, WORD x, WORD y)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.x = x; msg.y = y;

	ddpScheduler->DoMessage(DDPMSG_BUTTONSELECTANDACTIVATEAT, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_StillOff(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_STILLOFF, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_PauseOn(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_PAUSEON, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_PauseOff(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_PAUSEOFF, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_PbcOn(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_PBCON, (DWORD)&msg);

	GNRAISE_OK;
	}

DLLP1 Error DLLP2 DDP_PbcOff(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_PBCOFF, (DWORD)&msg);

	GNRAISE_OK;
	}

DLLP1 Error DLLP2 DDP_AdvanceFrame(DVDDiskPlayer player)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_ADVANCEFRAME, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_AdvanceFrameBy(DVDDiskPlayer player, int by)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.val = by;

	ddpScheduler->DoMessage(DDPMSG_ADVANCEFRAMEBY, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_SetPlaybackSpeed(DVDDiskPlayer player, WORD speed)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.word = speed;

	ddpScheduler->DoMessage(DDPMSG_SETPLAYBACKSPEED, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_MenuLanguageSelect(DVDDiskPlayer player, WORD language)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.word = language;

	ddpScheduler->DoMessage(DDPMSG_MENULANGUAGESELECT, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_AudioStreamChange(DVDDiskPlayer player, WORD streamID)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.word = streamID;

	ddpScheduler->DoMessage(DDPMSG_AUDIOSTREAMCHANGE, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_SubPictureStreamChange(DVDDiskPlayer player, WORD streamID, BOOL display)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.word = streamID;
	msg.boolean = display;

	ddpScheduler->DoMessage(DDPMSG_SUBPICTURESTREAMCHANGE, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_AngleChange(DVDDiskPlayer player, WORD angle)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.word = angle;

	ddpScheduler->DoMessage(DDPMSG_ANGLECHANGE, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_ParentalLevelSelect(DVDDiskPlayer player, WORD parentalLevel)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.word = parentalLevel;

	ddpScheduler->DoMessage(DDPMSG_PARENTALLEVELSELECT, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_ParentalCountrySelect(DVDDiskPlayer player, WORD country)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.word = country;

	ddpScheduler->DoMessage(DDPMSG_PARENTALCOUNTRYSELECT, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_InitialLanguageSelect(DVDDiskPlayer player,
														  WORD audioLanguage,
														  WORD audioExtension,
														  WORD subPictureLanguage,
														  WORD subPictureExtension)
	{
	DVDPlayerMsg	msg;

	msg.player = player;
	msg.audioLanguage = audioLanguage;
	msg.audioExtension = audioExtension;
	msg.subPictureLanguage = subPictureLanguage;
	msg.subPictureExtension = subPictureExtension;

	ddpScheduler->DoMessage(DDPMSG_SELECTINITIALLANGUAGE, (DWORD)&msg);

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2  DDP_InquireCurrentBitRate(DVDDiskPlayer player, DWORD & bitsPerSecond)
	{
	Error err;

	LOGDDP(INQUIRECURRENTBITRATE, STATUS);
	err = player->GetCurrentBitrate(bitsPerSecond);
	LOGDDPEXIT(INQUIRECURRENTBITRATE, STATUS);
	GNRAISE(err);
	}

DLLP1 Error DLLP2  DDP_GetCurrentButtonState(DVDDiskPlayer player, WORD & minButton, WORD & numButtons, WORD & currentButton)
	{
	DVDPlayerMsg	msg;

	msg.player = player;

	ddpScheduler->DoMessage(DDPMSG_GETCURRENTBUTTONSTATE, (DWORD)&msg);

	minButton = msg.word;
	numButtons = msg.word2;
	currentButton = msg.word3;

	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_Freeze(DVDDiskPlayer player, BYTE * buffer,  DWORD & size)
	{
	DVDPlayerMsg msg;

	msg.player = player;
	msg.dword = size;
	msg.pointer = buffer;

	ddpScheduler->DoMessage(DDPMSG_FREEZE, (DWORD)&msg);

	size = msg.dword;
	GNRAISE(msg.error);
	}

DLLP1 Error DLLP2 DDP_Defrost(DVDDiskPlayer player, BYTE * buffer, DWORD & size)
	{
	DVDPlayerMsg msg;

	msg.player = player;
	msg.dword = size;
	msg.pointer = buffer;
	msg.dword2 = DDPSPF_NONE;

	ddpScheduler->DoMessage(DDPMSG_DEFROST, (DWORD)&msg);

	size = msg.dword;
	GNRAISE(msg.error);
	}

DLLCALL Error WINAPI DDP_DefrostExt(DVDDiskPlayer player, BYTE * buffer, DWORD & size, DWORD flags)
	{
	DVDPlayerMsg msg;

	msg.player = player;
	msg.dword = size;
	msg.pointer = buffer;
	msg.dword2 = flags;

	ddpScheduler->DoMessage(DDPMSG_DEFROST, (DWORD)&msg);

	size = msg.dword;
	GNRAISE(msg.error);
	}

//
//  Extract information from frozen state
//

DLLCALL Error WINAPI DDP_GetFrozenInfo(BYTE * buffer, DWORD length, DDPFreezeState & state)
	{
	DDPFreezeState * bufState = (DDPFreezeState*)buffer;
	int i;

	for (i=0; i<8; i++)
		state.uniqueKey[i] = bufState->uniqueKey[i];

	state.diskType = bufState->diskType;
	state.parentalLevel = bufState->parentalLevel;
	state.parentalCountry = bufState->parentalCountry;

	GNRAISE_OK;
	}

//
//  Turn Event Handler On
//

DLLP1 Error DLLP2 DDP_InstallEventHandler(DVDDiskPlayer player, DWORD event, DNEEventHandler handler, void * userData)
	{
	DVDPlayerMsg msg;

	msg.player = player;
	msg.dword = event;
	msg.pointer = (void *) handler;
	msg.pointer2 = userData;

	ddpScheduler->DoMessage(DDPMSG_EVENTHANDLERON, (DWORD)&msg);

	GNRAISE(msg.error);
	}

//
//  Turn Event Handler Off
//

DLLP1 Error DLLP2 DDP_RemoveEventHandler(DVDDiskPlayer player, DWORD event)
	{
	DVDPlayerMsg msg;

	msg.player = player;
	msg.dword = event;

	ddpScheduler->DoMessage(DDPMSG_EVENTHANDLEROFF, (DWORD)&msg);

	GNRAISE(msg.error);
	}

//
//  Set a breakpoint, "old style"
//

DLLP1 Error DLLP2 DDP_SetBreakpoint(DVDDiskPlayer player, WORD title, DVDTime time, DWORD flags, DWORD & id)
	{
	DVDPlayerMsg msg;

	msg.player = player;
	msg.word = title;
	msg.time = time;
	msg.dword = ERS_FORWARD| ERS_BACKWARD;

	//
	//  Translate "old style" flags to "new style" flags
	//

	if (flags & ERS_PAUSE)
		msg.dword |= ERS_TOSTILL;

	if (flags & ERS_AUTOCLEAR)
		msg.dword |= ERS_CLEAR;

	if (flags & ERS_PAUSEATEND)
		msg.dword |= ERS_ENDOFTITLE;
	else
		msg.dword |= ERS_ATTIME;

	ddpScheduler->DoMessage(DDPMSG_SETBREAKPOINT, (DWORD)&msg);

	id = msg.dword2;
	GNRAISE(msg.error);
	}

//
//  Set a breakpoint, "new style"
//

DLLP1 Error DLLP2 DDP_SetBreakpointExt(DVDDiskPlayer player, WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id)
	{
	DVDPlayerMsg msg;

	msg.player = player;
	msg.word = title;
	msg.word2 = ptt;
	msg.time = time;
	msg.dword = flags;

	ddpScheduler->DoMessage(DDPMSG_SETBREAKPOINT, (DWORD)&msg);

	id = msg.dword2;
	GNRAISE(msg.error);
	}

//
//  Clear a breakpoint
//

DLLP1 Error DLLP2 DDP_ClearBreakpoint(DVDDiskPlayer player, DWORD id)
	{
	DVDPlayerMsg msg;

	msg.player = player;
	msg.dword = id;

	ddpScheduler->DoMessage(DDPMSG_CLEARBREAKPOINT, (DWORD)&msg);

	GNRAISE(msg.error);
	}

//
//  Detach drive
//

DLLP1 Error DLLP2  DDP_DetachDrive(DVDDiskPlayer player, DWORD flags, DVDTime time, DWORD bufferSize)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

//
//  Get AV File Info
//

DLLP1 Error DLLP2 DDP_GetAVFileInfo(DVDDiskPlayer player, HIter * it, AVFInfo * pInfo)
	{
	DVDPlayerMsg msg;

	msg.player = player;
	msg.pointer = it;
	msg.pointer2 = pInfo;

	ddpScheduler->DoMessage(DDPMSG_GETAVFILEINFO, (DWORD)&msg);
	GNRAISE(msg.error);
	}

//
//  Play file
//

DLLP1 Error DLLP2 DDP_PlayFile(DVDDiskPlayer player, HIter * it, DWORD flags)
	{
	DVDPlayerMsg msg;

	msg.player = player;
	msg.pointer = it;
	msg.dword = flags;

	ddpScheduler->DoMessage(DDPMSG_PLAYFILE, (DWORD)&msg);
	GNRAISE(msg.error);
	}

//
// Set audio stream selection preferences
//
DLLP1 Error DLLP2 DDP_SetAudioStreamSelectionPreferences(DVDDiskPlayer player, DWORD flags)
	{
	DVDPlayerMsg msg;

	msg.player = player;
	msg.dword = flags;

	ddpScheduler->DoMessage(DDPMSG_SETAUDIOSTREAMSELECTIONPREFS, (DWORD)&msg);

	GNRAISE(msg.error);
	}


////////////////////////////////////////////////////////////////////
//
//  DLL/Lib Initialization Functions
//
////////////////////////////////////////////////////////////////////

//
//  DDP Common Initialization Function
//

DLLCALL Error WINAPI DDP_Init(WinPortServer				* driverInstance,
										GenericProfile				* profile,
										DriveTable					* driveTable,
										DVDDiskPlayerFactory		* dvdVideoDiskPlayerFactory,
										DVDDiskPlayerFactory		* dvdAudioDiskPlayerFactory,
										VCDDiskPlayerFactory		* vcdDiskPlayerFactory,
										CDDADiskPlayerFactory	* cddaDiskPlayerFactory,
										AVFDiskPlayerFactory		* avfDiskPlayerFactory,
										FileSystemFactory			* dvdFileSystemFactory,
										FileSystemFactory			* vcdFileSystemFactory,
										FileSystemFactory			* cddaFileSystemFactory,
										FileSystemFactory			* avfFileSystemFactory,
										FileSystemFactory			* osFileSystemFactory)
	{
	DWORD	dd;
	Error err;

	//
	//  Copy factories and init other parameters passed
	//

	::dvdVideoDiskPlayerFactory = dvdVideoDiskPlayerFactory;
	::dvdAudioDiskPlayerFactory = dvdAudioDiskPlayerFactory;
	::vcdDiskPlayerFactory = vcdDiskPlayerFactory;
	::cddaDiskPlayerFactory	= cddaDiskPlayerFactory;
	::avfDiskPlayerFactory = avfDiskPlayerFactory;
	::dvdFileSystemFactory = dvdFileSystemFactory;
	::vcdFileSystemFactory = vcdFileSystemFactory;
	::cddaFileSystemFactory = cddaFileSystemFactory;
	::avfFileSystemFactory = avfFileSystemFactory;
	::osFileSystemFactory = osFileSystemFactory;

	DriverInstance = driverInstance;
	SystemProfile = profile;
	SystemDriveTable = driveTable;

	//
	//  Create region handler
	//

	RegionMan = new RegionHandler();
	if (!RegionMan)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	GNREASSERT(RegionMan->Init(profile));

	//
	//  Create file system
	//

	FileSystem = new RootFileSystem();
	if (!FileSystem)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	if (IS_ERROR(err = FileSystem->Init(profile, SystemDriveTable)))
		{
		DP("Could not initialize Root File System (Error %08lx)!", err);
		delete FileSystem;
		FileSystem = NULL;
		return err;
		}

	//
	// Create async. request scheduler
	//

	getDiskInfoAsyncRqScheduler = new GetDiskInfoAsyncRequestScheduler;

	GNREASSERT(VFI_Init(FileSystem));

	//
	//  Set up threads
	//


	DDPScheduleThread = CreateThread(NULL, 20000, DDPScheduleRoutine, NULL, CREATE_SUSPENDED, &dd);
	SetThreadPriority(DDPScheduleThread, THREAD_PRIORITY_HIGHEST);
	ResumeThread(DDPScheduleThread);


	GNRAISE_OK;
	}

//
//  DDP Common Cleanup Function
//

DLLCALL Error WINAPI DDP_Cleanup(void)
	{
	VFI_Cleanup();

	delete RegionMan;
	delete FileSystem;

	delete DriverInstance;

	delete SystemProfile;
	SystemDriveTable->Cleanup();
	delete SystemDriveTable;

	delete dvdVideoDiskPlayerFactory;
	delete dvdAudioDiskPlayerFactory;
	delete vcdDiskPlayerFactory;
	delete cddaDiskPlayerFactory;
	delete avfDiskPlayerFactory;
	delete dvdFileSystemFactory;
	delete vcdFileSystemFactory;
	delete cddaFileSystemFactory;
	delete avfFileSystemFactory,
	delete osFileSystemFactory;

	delete getDiskInfoAsyncRqScheduler;

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\Dvdpld32.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DDP Interface Declaration
//
////////////////////////////////////////////////////////////////////

#ifndef DVDPLD32_H
#define DVDPLD32_H

////////////////////////////////////////////////////////////////////
//
//  General Includes
//
////////////////////////////////////////////////////////////////////

#include "Library/Files/VFI.h"
#include "DVDTime.h"
#include "NavErrors.h"

typedef class CDDiskPlayerClass * DVDDiskPlayer;

////////////////////////////////////////////////////////////////////
//
//  Internal Stuff
//
////////////////////////////////////////////////////////////////////

#ifndef ONLY_EXTERNAL_VISIBLE

#include "Library/Common/WinPorts.h"
#include "Config/DiskPlayerFactory.h"
#include "Config/DVDDiskPlayerFactory.h"
#include "Config/FileSystemFactory.h"
#include "Library/Common/Profiles.h"
#include "Library/Hardware/Drives/Generic/DriveTable.h"

//
//  DDP_Init() and DDP_Cleanup() are internal functions only
//  They should not be called from outside the configuration/platform dependent files
//

DLLCALL Error WINAPI DDP_Init(WinPortServer					* driverInstance,
										GenericProfile					* profile,
										DriveTable						* driveTable,
										DVDDiskPlayerFactory			* dvdVideoDiskPlayerFactory,
										DVDDiskPlayerFactory			* dvdAudioDiskPlayerFactory,
										VCDDiskPlayerFactory			* vcdDiskPlayerFactory,
										CDDADiskPlayerFactory		* cddaDiskPlayerFactory,
										AVFDiskPlayerFactory			* avfDiskPlayerFactory,
										FileSystemFactory				* dvdFileSystemFactory,
										FileSystemFactory				* vcdFileSystemFactory,
										FileSystemFactory				* cddaFileSystemFactory,
										FileSystemFactory				* avfFileSystemFactory,
										FileSystemFactory				* osFileSystemFactory);

DLLCALL Error WINAPI  DDP_Cleanup(void);

//
//  Special declarations for ST20LITE
//

DLLCALL Error WINAPI DDP_Initialize(void);

#endif	// ONLY_EXTERNAL_VISIBLE

#include "boards/generic/vdgendrv.h"

////////////////////////////////////////////////////////////////////
//
//  Interface declaration
//
////////////////////////////////////////////////////////////////////

extern "C" {

DLLCALL Error WINAPI  DDP_CheckDrive(char driveLetter, char __far * id);

DLLCALL Error WINAPI  DDP_CheckDriveWithPath(char * drivePath, char __far * id);

DLLCALL Error WINAPI  DDP_GetVolumeName(char driveLetter, char * name);

DLLCALL Error WINAPI  DDP_GetDiskRegionSettings(UnitSet units, char driveLetter, BYTE __far &region, BYTE __far &availSets, RegionSource __far & regionSource, BYTE & diskRegion);

DLLCALL Error WINAPI  DDP_GetRegionSettings(UnitSet units, char driveLetter, BYTE __far &region, BYTE __far &availSets, RegionSource __far &regionSource);

DLLCALL Error WINAPI  DDP_SetSystemRegion(UnitSet units, char driveLetter, BYTE region);

DLLCALL Error WINAPI  DDP_EjectDiskInDrive(char driveLetter);

#if MSNDISC
DLLCALL Error WINAPI  DDP_LoadMedia(char driveLetter, BOOL wait);
DLLCALL Error WINAPI  DDP_UnloadMedia(char driveLetter, BOOL wait);
DLLCALL Error WINAPI  DDP_GetDriveCaps(char driveLetter, DWORD &caps, DWORD &slots, DWORD& positions, DWORD& changerOpenOffset);
DLLCALL Error WINAPI  DDP_MoveChanger(char driveLetter, DWORD operation, DWORD flags, DWORD param);
DLLCALL Error WINAPI  DDP_GetChangerStatus(char driveLetter, DWORD& status, DWORD& position );
DLLCALL Error WINAPI  DDP_GetSlotStatus(char driveLetter, DWORD slot, DWORD& status );
#endif

DLLCALL Error WINAPI  DDP_GetDriveStatus(char driveLetter, BOOL & opened, BOOL & closed);

DLLCALL Error WINAPI  DDP_LoadDiskInDrive(char driveLetter, BOOL wait);

DLLCALL Error WINAPI  DDP_OpenPlayer(UnitSet units, char diskLetter, DVDDiskPlayer __far & player);

DLLCALL Error WINAPI  DDP_OpenPlayerWithPath(UnitSet units, char * drivePath, DVDDiskPlayer __far & player);

DLLCALL Error WINAPI  DDP_OpenPlayerExtended(UnitSet units, char driveLetter, char * drivePath,
															DVDDiskPlayer __far & player, DDPDiskInfo __far & diskInfo);

DLLCALL Error WINAPI  DDP_ClosePlayer(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_StartPresentation(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_StartPresentationExt(DVDDiskPlayer player, DWORD flags);

DLLCALL DVDDiskType	 WINAPI DDP_GetDiskType(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_GetDiskInfoAsync(char * drivePath, ARQAsyncRequestDoneCB ARQCallback, DDPDiskOnlyInfo* diskOnlyInfo, DWORD & dwRqHandle);

DLLCALL Error WINAPI  DDP_OpenPlayerAsync(char * drivePath, ARQAsyncRequestDoneCB ARQCallback, DDPOpenPlayerInfo* openPlayerInfo, DWORD & rqHandle);

DLLCALL Error WINAPI  DDP_AbortAsyncRequest(DWORD dwRqHandle);

DLLCALL Error WINAPI  DDP_GetCurrentLocation(DVDDiskPlayer player, DVDLocation __far & location);

DLLCALL Error WINAPI  DDP_GetCurrentDuration(DVDDiskPlayer player, DVDLocation __far & location);

DLLCALL Error WINAPI  DDP_GetTitleDuration(DVDDiskPlayer player, WORD title, DVDTime & duration);

DLLCALL DVDPlayerMode WINAPI DDP_GetPlayerMode(DVDDiskPlayer player);

DLLCALL Error WINAPI	 DDP_GetExtendedPlayerState(DVDDiskPlayer player, ExtendedPlayerState & eps);

DLLCALL DWORD WINAPI  DDP_GetForbiddenUserOperations(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetNumberOfTitles(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetNumberOfPartOfTitle(DVDDiskPlayer player, WORD title);

DLLCALL Error WINAPI  DDP_GetAvailStreams(DVDDiskPlayer player, BYTE __far & audioMask, DWORD __far & subPictureMask);

DLLCALL Error WINAPI  DDP_GetAudioStreamAttributes(DVDDiskPlayer player, WORD stream, DVDAudioStreamFormat __far & format);

DLLCALL Error WINAPI  DDP_GetSubPictureStreamAttributes(DVDDiskPlayer player, WORD stream, DVDSubPictureStreamFormat __far & format);

DLLCALL WORD  WINAPI  DDP_GetCurrentAudioStream(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetCurrentSubPictureStream(DVDDiskPlayer player);

DLLCALL BOOL  WINAPI  DDP_IsCurrentSubPictureEnabled(DVDDiskPlayer player);

DLLCALL WORD  WINAPI  DDP_GetNumberOfAngles(DVDDiskPlayer player, WORD title);

DLLCALL WORD  WINAPI  DDP_GetCurrentAngle(DVDDiskPlayer player);

DLLCALL BOOL  WINAPI  DDP_CheckMenuAvail(DVDDiskPlayer player, VTSMenuType menu);

DLLCALL DisplayPresentationMode WINAPI  DDP_GetCurrentDisplayMode(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_SetDisplayMode(DVDDiskPlayer player, DisplayPresentationMode mode);

DLLCALL Error WINAPI  DDP_TitlePlay(DVDDiskPlayer player, WORD title);

DLLCALL Error WINAPI  DDP_TitlePlayForced(DVDDiskPlayer player, WORD title);

DLLCALL Error WINAPI  DDP_PTTPlay(DVDDiskPlayer player, WORD title, WORD part);

DLLCALL Error WINAPI  DDP_PTTPlayForced(DVDDiskPlayer player, WORD title, WORD part);

DLLCALL Error WINAPI  DDP_TimePlay(DVDDiskPlayer player, WORD title, DVDTime time);

DLLCALL Error WINAPI  DDP_TimePlayForced(DVDDiskPlayer player, WORD title, DVDTime time);

DLLCALL Error WINAPI  DDP_ExtendedPlay(DVDDiskPlayer player, DWORD flags, WORD title, WORD ptt, DVDTime time);

DLLCALL Error WINAPI  DDP_Stop(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_GoUp(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_TimeSearch(DVDDiskPlayer player, DVDTime time);

DLLCALL Error WINAPI  DDP_TimeSearchForced(DVDDiskPlayer player, DVDTime time);

DLLCALL Error WINAPI  DDP_PTTSearch(DVDDiskPlayer player, WORD part);

DLLCALL Error WINAPI  DDP_PTTSearchForced(DVDDiskPlayer player, WORD part);

DLLCALL Error WINAPI  DDP_PrevPGSearch(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_TopPGSearch(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_NextPGSearch(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_ForwardScan(DVDDiskPlayer player, WORD speed);

DLLCALL Error WINAPI  DDP_BackwardScan(DVDDiskPlayer player, WORD speed);

DLLCALL Error WINAPI  DDP_TrickPlay(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_StopScan(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_ReversePlayback(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_MenuCall(DVDDiskPlayer player, VTSMenuType menu);

DLLCALL Error WINAPI  DDP_Resume(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_UpperButtonSelect(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_LowerButtonSelect(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_LeftButtonSelect(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_RightButtonSelect(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_ButtonSelectAt(DVDDiskPlayer player, WORD x, WORD y);

DLLCALL Error WINAPI  DDP_ButtonActivate(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_ButtonSelectAndActivate(DVDDiskPlayer player, WORD num);

DLLCALL Error WINAPI  DDP_ButtonSelectAndActivateAt(DVDDiskPlayer player, WORD x, WORD y);

DLLCALL BOOL  WINAPI  DDP_IsButtonAt(DVDDiskPlayer player, WORD x, WORD y);

DLLCALL Error WINAPI  DDP_StillOff(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_PauseOn(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_PauseOff(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_PbcOn(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_PbcOff(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_AdvanceFrame(DVDDiskPlayer player);

DLLCALL Error WINAPI  DDP_AdvanceFrameBy(DVDDiskPlayer player, int by);

DLLCALL Error WINAPI  DDP_SetPlaybackSpeed(DVDDiskPlayer player, WORD speed);

DLLCALL Error WINAPI  DDP_MenuLanguageSelect(DVDDiskPlayer player, WORD language);

DLLCALL Error WINAPI  DDP_AudioStreamChange(DVDDiskPlayer player, WORD streamID);

DLLCALL Error WINAPI  DDP_SubPictureStreamChange(DVDDiskPlayer player, WORD streamID, BOOL display);

DLLCALL Error WINAPI  DDP_AngleChange(DVDDiskPlayer player, WORD angle);

DLLCALL Error WINAPI  DDP_ParentalLevelSelect(DVDDiskPlayer player, WORD parentalLevel);

DLLCALL Error WINAPI  DDP_ParentalCountrySelect(DVDDiskPlayer player, WORD country);

DLLCALL Error WINAPI  DDP_InitialLanguageSelect(DVDDiskPlayer player,
														      WORD audioLanguage,
														      WORD audioExtension,
														      WORD subPictureLanguage,
														      WORD subPictureExtension);

DLLCALL Error WINAPI  DDP_InquireCurrentBitRate(DVDDiskPlayer player, DWORD & bitsPerSecond);

DLLCALL Error WINAPI  DDP_GetCurrentButtonState(DVDDiskPlayer player, WORD & minButton, WORD & numButtons, WORD & currentButton);

DLLCALL Error WINAPI  DDP_Freeze(DVDDiskPlayer player, BYTE * buffer, DWORD & length);

DLLCALL Error WINAPI  DDP_Defrost(DVDDiskPlayer player, BYTE * buffer, DWORD & length);

DLLCALL Error WINAPI  DDP_DefrostExt(DVDDiskPlayer player, BYTE * buffer, DWORD & length, DWORD flags);

DLLCALL Error WINAPI  DDP_GetFrozenInfo(BYTE * buffer, DWORD length, DDPFreezeState & state);

DLLCALL Error WINAPI  DDP_InstallEventHandler(DVDDiskPlayer player, DWORD event, DNEEventHandler handler, void * userData);

DLLCALL Error WINAPI  DDP_RemoveEventHandler(DVDDiskPlayer player, DWORD event);

DLLCALL Error WINAPI  DDP_SetBreakpoint(DVDDiskPlayer player, WORD title, DVDTime time, DWORD flags, DWORD & id);

DLLCALL Error WINAPI  DDP_SetBreakpointExt(DVDDiskPlayer player, WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id);

DLLCALL Error WINAPI  DDP_ClearBreakpoint(DVDDiskPlayer player, DWORD id);

DLLCALL Error WINAPI  DDP_DetachDrive(DVDDiskPlayer player, DWORD flags, DVDTime time, DWORD bufferSize);

DLLCALL Error WINAPI  DDP_GetAVFileInfo(DVDDiskPlayer player, HIter * it, AVFInfo * pInfo);

DLLCALL Error WINAPI  DDP_PlayFile(DVDDiskPlayer player, HIter * it, DWORD flags);

DLLCALL Error WINAPI  DDP_SetAudioStreamSelectionPreferences(DVDDiskPlayer player, DWORD flags);

}	// extern "C"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\NavErrors.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Error Declaration for DVDPLD32
//
////////////////////////////////////////////////////////////////////


#ifndef NAVERRORS_H
#define NAVERRORS_H

#include "Library/Common/GNErrors.h"
#include "Library/hardware/drives/generic/DriveErrors.h"
#include "Library/Files/FileErrors.h"

//  Navigation in general

#define GNR_UNEXPECTED_NAVIGATION_ERROR				MKERR(ERROR,	NAVIGATION,	INTERNALSTATE,		0x00)
// Some internal error happened

#define GNR_INVALID_PLAYER									MKERR(ERROR,	NAVIGATION,	OBJECT,				0x00)
// The player handle is invalid

#define GNR_INVALID_NAV_INFO								MKERR(ERROR,	NAVIGATION,	OBJECT,				0x02)
// The navigation information is invalid (possible causes: wrong authoring, read error from drive, internal error)

#define GNR_LOST_DECODER									MKERR(ERROR,	NAVIGATION,	OBJECT,				0x03)
// The decoder has been preempted

#define GNR_DISK_TYPE_NOT_SUPPORTED						MKERR(ERROR,	NAVIGATION, OBJECT,				0x04)
// The disk type is not supported by the current version

#define GNR_OPERATION_NOT_SUPPORTED						MKERR(ERROR,	NAVIGATION, OPERATION,			0x00)
// This operation is (currently) not supported by the player

#define GNR_TITLE_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x01)
// The title specified does not exist

#define GNR_CHAPTER_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x02)
// The chapter specified does not exist

#define GNR_TIME_OUT_OF_RANGE								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x03)
// The time specified (e.g. for a search operation) is out of range

#define GNR_PROGRAM_LINK_NOT_FOUND						MKERR(ERROR,	NAVIGATION,	OPERATION,			0x04)
// The current program does not have a next/prev/upper/etc. program

#define GNR_MENU_DOES_NOT_EXIST							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x05)
// The requested menu does not exist

#define GNR_STREAM_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x06)
// The stream (audio/subpicture) does not exist

#define GNR_FLAGS_NOT_SUPPORTED							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x07)
// The flags specified for this operation are not supported

#define GNR_BUTTON_NOT_FOUND								MKERR(ERROR,	NAVIGATION,	OPERATION,			0x08)
// The specified button does not exist

#define GNR_UNKNOWN_EVENT_TYPE							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x09)
// The event type specified does not exist

#define GNR_BREAKPOINT_NOT_FOUND							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x0a)
// The breakpoint to be deleted does not exist

#define GNR_INVALID_UNIQUE_KEY							MKERR(ERROR,	NAVIGATION,	OPERATION,			0x0b)
// The unique key could not be created/was invalid

#define GNR_ERROR_RECOVERY									MKERR(ERROR,	NAVIGATION, INTERNALSTATE,		0x0c)
// The navigation is currently in an error recovery mode for some reason and therefore it could be
// that some queries can't be satisfied (e.g. the GetExtendedPlayerState())

//
//  DVD specific errors
//

#define GNR_UOP_PROHIBITED									MKERR(ERROR,	DVD,			UOP,					0x01)
// The current UOPs do not allow this action

#define GNR_REGIONS_DONT_MATCH							MKERR(ERROR,	DVD,			REGION,				0x00)
// The system and disk regions don't match

#define GNR_REGION_CODE_INVALID							MKERR(ERROR,	DVD,			REGION,				0x01)
// The region code specified was invalid (e.g. multiregion when trying to set region)

#define GNR_NO_MORE_REGION_SETS							MKERR(ERROR,	DVD,			REGION,				0x02)
// The number of region changes is exhausted

#define GNR_REGION_WRITE_ERROR							MKERR(ERROR,	DVD,			REGION,				0x03)
// Unable to write region

#define GNR_REGION_READ_ERROR								MKERR(ERROR,	DVD,			REGION,				0x04)
// Unable to read region

#define GNR_PARENTAL_LEVEL_TOO_LOW						MKERR(ERROR,	DVD,			PARENTAL,			0x03)
// The parental level currently set is too low to play the disc

#define GNR_ILLEGAL_NAVIGATION_COMMAND					MKERR(ERROR,	DVD,			OPERATION,			0x00)
// The DVD contains an illegal navigation command

#define GNR_ILLEGAL_DOMAIN									MKERR(ERROR,	DVD,			OPERATION,			0x01)
// The domain is illegal for this operation

#define GNR_NO_RESUME_INFORMATION						MKERR(ERROR,	DVD,			OPERATION,			0x02)
// No resume information currently available

#define GNR_COULD_NOT_CHANGE_ANGLE						MKERR(ERROR,	DVD,			OPERATION,			0x03)
// Angle change was not possible

//
//  VCD specific errors
//

//
//  CDDA specific errors
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDTime.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef DVDTIME_H
#define DVDTIME_H

#include "Library/Common/Prelude.h"
#include "Library/Common/GNErrors.h"
#include "Library/hardware/video/generic/vidtypes.h"
#include "Library/hardware/audio/generic/ac3setup.h"
#include "Driver/Dvdpldrv/Common/AVF/MPEGAudioTypes.h"
#include "NavErrors.h"


enum DVDPlayerMode
	{
	DPM_STOPPED,
	DPM_PAUSED,
	DPM_STILL,
	DPM_PLAYING,
	DPM_BUSY,
	DPM_SCANNING,
	DPM_INACTIVE,
	DPM_REVERSEPLAY,
	DPM_TRICKPLAY,
	DPM_REVERSESCAN
	};

enum DVDDomain
	{
	FP_DOM,
	VMGM_DOM,
	VTSM_DOM,
	TT_DOM,
	STOP_DOM,
	AMGM_DOM,
	TT_GR_DOM
	};

enum VTSMenuType
	{
	VMT_TITLE_MENU,
	VMT_ROOT_MENU,
	VMT_SUBPICTURE_MENU,
	VMT_AUDIO_MENU,
	VMT_ANGLE_MENU,
	VMT_PTT_MENU,
	VMT_NO_MENU		// Note that this is used in ExtendedPlayerState as array size
	};

enum DVDManagerMenuType
	{
	DMT_VMGM,
	DMT_AMGM,
	DMT_UNDEFINED
	};

enum DisplayPresentationMode
	{
	DPM_4BY3,
	DPM_16BY9,
	DPM_LETTERBOXED,
	DPM_PANSCAN,
	DPM_NONE
	};

enum DVDAudioCodingMode
	{
	DAM_AC3,
	DAM_MPEG1,
	DAM_MPEG2,
	DAM_LPCM,
	DAM_DTS,
	DAM_SDDS,
	DAM_NONE = 0xFF
	};

enum DVDAudioApplicationMode
	{
	DAAM_UNDEFINED		= 0,
	DAAM_KARAOKE		= 1,
	DAAM_SURROUND		= 2
	};

enum DVDKaraokeSoloDuetMode
	{
	DKM_SOLO				= 0,
	DKM_DUET				= 1,
	DKM_UNDEFINED		= 2
	};

enum MPEG2PrologicStatus		// Status of the decoder (actually played!)
	{
	MP2PS_OFF,
	MP2PS_ON,
	MP2PS_UNKNOWN
	};

enum MPEG2LFEStatus				// Content, not playing
	{
	MP2LFE_OFF,
	MP2LFE_ON,
	MP2LFE_UNKNOWN
	};

enum DVDDiskType
	{
	DDT_NONE,
	DDT_VIDEO_DVD,
	DDT_AUDIO_DVD,
	DDT_VIDEO_CD,
	DDT_AUDIO_CD,
	DDT_SUPER_AUDIO_CD,
	DDT_DTS_AUDIO_CD,
	DDT_SUPER_VIDEO_CD,
	DDT_MULTI_DISK			// Describes a CD-R or similar with files of different types on it
	};

enum RegionSource
	{
	RGSRC_UNDEFINED	= 0,
	RGSRC_DRIVE			= 1,
	RGSRC_BOARD			= 2
	};

enum VideoCompressionMode
	{
	VCM_UNKNOWN,
	VCM_MPEG1,
	VCM_MPEG2
	};

enum Line21Mode
	{
	L21M_NO_DATA,
	L21M_FIRST_FIELD,
	L21M_SECOND_FIELD,
	L21M_BOTH_FIELDS
	};

//
//  User Operation Bitmasks
//

#define UOP_TIME_PLAY_SEARCH				MKFLAG(0)
#define UOP_PTT_PLAY_SEARCH				MKFLAG(1)
#define UOP_TITLE_PLAY						MKFLAG(2)
#define UOP_STOP								MKFLAG(3)
#define UOP_GO_UP								MKFLAG(4)
#define UOP_TIME_PTT_SEARCH				MKFLAG(5)
#define UOP_PREV_TOP_PG_SEARCH			MKFLAG(6)
#define UOP_NEXT_PG_SEARCH					MKFLAG(7)
#define UOP_FORWARD_SCAN					MKFLAG(8)
#define UOP_BACKWARD_SCAN					MKFLAG(9)
#define UOP_SCAN_OFF							MKFLAG(25)	// additional
#define UOP_MENU_CALL_TITLE				MKFLAG(10)
#define UOP_MENU_CALL_ROOT					MKFLAG(11)
#define UOP_MENU_CALL_SUB_PICTURE		MKFLAG(12)
#define UOP_MENU_CALL_AUDIO				MKFLAG(13)
#define UOP_MENU_CALL_ANGLE				MKFLAG(14)
#define UOP_MENU_CALL_PTT					MKFLAG(15)
#define UOP_RESUME							MKFLAG(16)
#define UOP_BUTTON							MKFLAG(17)
#define UOP_STILL_OFF						MKFLAG(18)
#define UOP_PAUSE_ON							MKFLAG(19)
#define UOP_PAUSE_OFF						MKFLAG(26)	// additional
#define UOP_AUDIO_STREAM_CHANGE			MKFLAG(20)
#define UOP_SUB_PICTURE_STREAM_CHANGE	MKFLAG(21)
#define UOP_ANGLE_CHANGE					MKFLAG(22)
#define UOP_KARAOKE_MODE_CHANGE			MKFLAG(23)
#define UOP_VIDEO_MODE_CHANGE				MKFLAG(24)

//
//  Disc Information Structure
//

class __far DDPDiskInfo
	{
	public:
		DDPDiskInfo(void)			{size = sizeof(DDPDiskInfo);}

		DWORD				size;				// Size of the structure passed, DO NOT CHANGE!!!
		DVDDiskType		type;				// Type of media inserted
		char				uniqueKey[8];	// Unique identifier of disk
		BYTE				systemRegion;	// System region (decoder or drive, only for type == DDT_VIDEO_DVD)
		BYTE				diskRegion;		// Disk region (only for type == DDT_VIDEO_DVD)
		RegionSource	regionSource;	// Region source (decoder or drive, only for type == DDT_VIDEO_DVD)
		BYTE				availSets;		// Number of region sets left (only for type == DDT_VIDEO_DVD)
	};

//
//  Disc-Only Information Structure (no system region related info)
//

class DDPDiskOnlyInfo
	{
	public:
		DDPDiskOnlyInfo(void)			{size = sizeof(DDPDiskOnlyInfo);}

		DWORD				size;				// Size of the structure passed, DO NOT CHANGE!!!
		DWORD				dwUserData;		// User data, not touched by DDP layer
		DVDDiskType		type;				// Type of media inserted
		char				uniqueKey[8];	// Unique identifier of disk
		BYTE				diskRegion;		// Disk region (only for type == DDT_VIDEO_DVD)
		char				volumeName[256];
	};


class DDPOpenPlayerInfo
	{
	public:
		DDPOpenPlayerInfo(){size = sizeof(DDPOpenPlayerInfo);}

		DWORD				size;				// Size of the structure passed, DO NOT CHANGE!!!
		DWORD				dwUserData;		// User data, not touched by DDP layer
		void*				units;			// UnitSet currently open, cast to void*
		void**			pplayer;			// Pointer to DVDDiskPlayer (cast to void**)
		DDPDiskInfo		diskInfo;		// structure filled out with relevant disk data upon successful player opening
	};


//
//  DVD Time Class
//

class __far DVDTime
	{
	private:
		DWORD	stamp;  // Format HHHH HHHH MMMM MMMM SSSS SSSS RR FF FFFF
	public:
		DVDTime(DWORD stamp) {this->stamp = stamp;}
		DVDTime(void) {this->stamp = 0;}
		DVDTime(int hours, int minutes, int seconds, int frames, int frameRate);
		DVDTime(int millisecs, int divider, int frameRate);

		int FrameRate(void)	const {return XTBF(7, stamp) ? 30 : 25;}
		int Frames(void)		const {return (int)(XTBF(0, 4, stamp) + 10 * XTBF(4, 2, stamp));}
		int Seconds(void)		const {return (int)(XTBF(8, 4, stamp) + 10 * XTBF(12, 4, stamp));}
		int Minutes(void)		const {return (int)(XTBF(16, 4, stamp) + 10 * XTBF(20, 4, stamp));}
		int Hours(void)		const {return (int)(XTBF(24, 4, stamp) + 10 * XTBF(28, 4, stamp));}

		DWORD FrameTotal(void)	const	{return (Seconds() + Minutes() * 60 + Hours() * 3600) * FrameRate() + Frames();}

		DWORD Millisecs(void) const {return 1000 * Frames() / FrameRate() +
		                              1000 * Seconds() +
		                              60000 * Minutes() +
		                              3600000 * Hours();}

		friend DVDTime operator+ (const DVDTime u, const DVDTime v);
		friend DVDTime operator- (const DVDTime u, const DVDTime v);

		DVDTime & operator+= (const DVDTime u);
		DVDTime & operator-= (const DVDTime u);

		int Compare(const DVDTime u) const;

		friend BOOL operator==(const DVDTime u, const DVDTime v) {return u.Compare(v) == 0;}
		friend BOOL operator!=(const DVDTime u, const DVDTime v) {return u.Compare(v) != 0;}
		friend BOOL operator<(const DVDTime u, const DVDTime v)  {return u.Compare(v) < 0;}
		friend BOOL operator>(const DVDTime u, const DVDTime v)  {return u.Compare(v) > 0;}
		friend BOOL operator<=(const DVDTime u, const DVDTime v) {return u.Compare(v) <= 0;}
		friend BOOL operator>=(const DVDTime u, const DVDTime v) {return u.Compare(v) >= 0;}

		BOOL IsZero(void)		const {return (stamp & 0xffffff3f) == 0;}
		BOOL IsNotZero(void)	const {return (stamp & 0xffffff3f) != 0;}
	};

//
//  DVD Location
//

class __far DVDLocation
	{
	public:
		DVDDomain	domain;
		WORD			videoTitleSet;
		WORD			title;
		WORD			vtsTitle;
		DVDTime		titleTime;
		WORD			partOfTitle;
		WORD			programChain;
		DVDTime		pgcTime;
		WORD			program;
		WORD			cell;
		DVDTime		cellTime;

		DVDLocation(void) {};
		friend BOOL	NotEqual(const DVDLocation u, const DVDLocation v);
		friend BOOL operator !=(const DVDLocation u, const DVDLocation v) { return (BOOL)memcmp(&u, &v, sizeof(DVDLocation)); }
	};

//
//  Audio Stream Format
//

class __far DVDAudioStreamFormat
	{
	public:
		WORD							languageCode;
		WORD							languageExtension;
		DVDAudioCodingMode		codingMode;
		WORD							bitsPerSample;
		DWORD							samplesPerSecond;
		WORD							channels;
		DVDAudioApplicationMode	applicationMode;
		BYTE							channelAssignment;
		BYTE							mcIntro;
		DVDKaraokeSoloDuetMode	soloDuetMode;

		friend BOOL operator==(const DVDAudioStreamFormat u, const DVDAudioStreamFormat v);
		friend BOOL operator!=(const DVDAudioStreamFormat u, const DVDAudioStreamFormat v);
	};

//
//  Video Stream Format
//

class VideoStreamFormat
	{
	public:
		VideoCompressionMode			compressionMode;			// Compression technique used
		VideoStandard					videoStandard;				// Source video standard
		DisplayPresentationMode		sourceAspectRatio;		// Aspect ratio of source picture
		BOOL								panScanOn4By3;				// TRUE if Pan & Scan is allowed on 4 by 3 display
		BOOL								letterboxedOn4By3;		// TRUE if letterboxed is allowed on 4 by 3 display
		Line21Mode						line21Mode;					// Encoded line 21 data
		WORD								sourceWidth;				// Width of source picture
		WORD								sourceHeight;				// Height of source picture
		BOOL								sourceLetterboxed;		// TRUE is source material is letterboxed

		friend BOOL operator==(const VideoStreamFormat & u, const VideoStreamFormat & v);
		friend BOOL operator!=(const VideoStreamFormat & u, const VideoStreamFormat & v);
	};

//
//  Subpicture Stream Format
//

class __far DVDSubPictureStreamFormat
	{
	public:
		WORD						languageCode;
		WORD						languageExtension;

		friend BOOL operator==(const DVDSubPictureStreamFormat u, const DVDSubPictureStreamFormat v);
		friend BOOL operator!=(const DVDSubPictureStreamFormat u, const DVDSubPictureStreamFormat v);
	};

//
//  Button Information
//

#define DBI_MAX_BUTTON_NUMBER 103

class __far DVDButtonInformation
	{
	public:
		WORD	x;
		WORD	y;
		WORD	w;
		WORD	h;
		BOOL	autoAction;
		BYTE	upperButton;
		BYTE	lowerButton;
		BYTE	leftButton;
		BYTE	rightButton;

		friend BOOL operator==(const DVDButtonInformation u, const DVDButtonInformation v);
		friend BOOL operator!=(const DVDButtonInformation u, const DVDButtonInformation v);
	};

//
//  Extended player state
//

class __far ExtendedPlayerState
	{
	public:
		DWORD								size;								// Size of the structure passed

		// Request bitmasks

		DWORD								request;							// Bitmask for requested data
		DWORD								valid;							// Bitmask for delivered data
		DWORD								monitor;							// Bitmask indicating the elements to check for changes
		DWORD								changed;							// Bitmask indicating the elements that have changed

		// Player Information (EPS_PLAYERINFO, additions below)

		DVDPlayerMode					playerMode;						// Current player mode
		WORD								playbackSpeed;					// Current playback speed
		WORD								scanSpeed;						// Current scan speed
		DWORD								forbiddenUOPs;					// Forbidden UOPs

		// Hardware Information (EPS_MISC)

		DVDDiskType						diskType;						// Current disk type
		DisplayPresentationMode		displayMode;					// Current display mode
		VideoStandard					videoStandard;					// Current video standard
		DWORD								currentBitRate;				// Current bitrate

		// Audio Stream Information (EPS_AUDIOSTREAMS)

		int								currentAudioStream;			// Current Audio Stream ID
		BYTE								availableAudioStreams;		// Bitmask of audio streams available
		DVDAudioStreamFormat			audioStream[8];				// Audio stream data

		// Sub Picture Stream Information (EPS_SUBPICTURESTREAMS)

		int								currentSubPictureStream;	// Current sub picture Stream ID
		DWORD								availableSubPictureStreams;// Bitmask of sub picture streams available
		DVDSubPictureStreamFormat	subPictureStream[32];		// Subpicture stream data
		BOOL								subPictureEnable;				// Subpicture enabled

		// Title Information (EPS_TITLE)

		DVDLocation						location;						// Current location
		DVDLocation						duration;						// Current duration

		// Menu Information (EPS_MENU)

		WORD								menuLanguage;
		BOOL								menuAvailable[VMT_NO_MENU+1];  // Use a VTSMenuType as index

		// Parental Information (EPS_PARENTAL)

		WORD								parentalCountry;
		WORD								parentalLevel;

		// Angle Information (EPS_ANGLE, addition below)

		WORD								numberOfAngles;
		WORD								currentAngle;

		// Button Information (EPS_BUTTON)

		WORD								numberOfButtons;
		WORD								selectedButton;
		WORD								forcedlyActivatedButton;
		WORD								userButtonOffset;
		WORD								numberOfUserButtons;
		DVDButtonInformation			buttonInfo[DBI_MAX_BUTTON_NUMBER];

		// CDDA Information (EPS_PLAYINGGAP)

		BOOL								playingGap;						// CDDA only: TRUE is gap between titles is played

		// Additional Player Information (EPS_PLAYERINFO)

		BOOL								playingForward;

		// Additional Angle Information (EPS_ANGLE)

		BOOL								isMultiAngleScene;
		WORD								playingAngle;

		// Video stream information (EPS_VIDEOSTREAM, additional to info in EPS_MISC)

		VideoStreamFormat				videoStream;

		// Hardware Information (EPS_MISC, additional)

		BOOL								diskIsEncrypted;				// TRUE if disk is encrypted

		// Additional Audio Information (EPS_AUDIOSTREAMS, additional)

		MPEG2PrologicStatus			mpeg2PrologicStatus;			// Indicating if Prologic decoding is currently done
		MPEG2LFEStatus					mpeg2LFEStatus;				// Indicates if LFE info is in content
		AC3AudioCodingMode			ac3AudioCodingMode;			// Encoding, not actual output

		// (S-)Video-CD specific information (EPS_VCDPLAYERINFO)

		BOOL								isPlaybackControlOn;
	};

//
//  Request bitmask defines (00001000 in use)
//

#define EPS_PLAYERINFO				0x00000001
#define EPS_MISC						0x00000002
#define EPS_TITLE						0x00000004
#define EPS_AUDIOSTREAMS			0x00000008
#define EPS_SUBPICTURESTREAMS		0x00000010
#define EPS_ANGLE						0x00000020
#define EPS_MENU						0x00000040
#define EPS_PARENTAL					0x00000080
#define EPS_BUTTON					0x00000100
#define EPS_PLAYINGGAP				0x00000200
#define EPS_VIDEOSTREAM				0x00000400
#define EPS_KARAOKE					0x00000800
#define EPS_VCDPLAYERINFO			0x00001000


//
//  Shortcuts
//

#define EPS_COMMON					EPS_PLAYERINFO | EPS_MISC | EPS_TITLE
#define EPS_DVD						EPS_MENU | EPS_PARENTAL | EPS_BUTTON | EPS_ANGLE | EPS_AUDIOSTREAMS | \
											EPS_SUBPICTURESTREAMS | EPS_VIDEOSTREAM
#define EPS_VCD						EPS_BUTTON | EPS_AUDIOSTREAMS
#define EPS_CDA						EPS_PLAYINGGAP | EPS_AUDIOSTREAMS
#define EPS_ALL						EPS_COMMON | EPS_DVD | EPS_VCD | EPS_CDA

//
//  Async request processing
//

typedef enum ARQReqestID
	{
	ARQ_NONE = 0,
	ARQ_GET_DISK_INFO,
	ARQ_OPEN_PLAYER
	};

//
//  AsyncRequestDoneCallback - called e.g. when DDP_GetDiskInfoAsync is actually completed
//

typedef void (WINAPI * ARQAsyncRequestDoneCB)(ARQReqestID doneRqID, DWORD dwRqHandle, void * userData, Error err);

typedef void (WINAPI * DNEEventHandler)(DWORD event, void * userData, DWORD info);

//
//  Disk Navigation Event handling
//

typedef void (WINAPI * DNEEventHandler)(DWORD event, void * userData, DWORD info);

#define DNE_NONE								0
#define DNE_TITLE_CHANGE					1
#define DNE_PART_OF_TITLE_CHANGE			2
#define DNE_VALID_UOP_CHANGE				3
#define DNE_ANGLE_CHANGE					4
#define DNE_AUDIO_STREAM_CHANGE			5
#define DNE_SUBPICTURE_STREAM_CHANGE	6
#define DNE_DOMAIN_CHANGE					7
#define DNE_PARENTAL_LEVEL_CHANGE		8
#define DNE_BITRATE_CHANGE					9
#define DNE_STILL_ON							10
#define DNE_STILL_OFF						11
#define DNE_PLAYBACK_MODE_CHANGE			12
#define DNE_CDA_PLAYING_GAP				13
#define DNE_READ_ERROR						14
#define DNE_DISPLAY_MODE_CHANGE			15
#define DNE_STREAMS_CHANGE					16
#define DNE_SCAN_SPEED_CHANGE				17
#define DNE_PLAYBACK_SPEED_CHANGE		18
#define DNE_VIDEO_STANDARD_CHANGE		19
#define DNE_BREAKPOINT_REACHED			20
#define DNE_DRIVE_DETACHED					21		// OBSOLETE
#define DNE_ERROR								22

#define DNE_EVENT_NUMBER					23

//
//  ERS Breakpoints
//

#define ERS_BREAKPOINT_NONE				0xffffffff	// Defines an invalid breakpoint id

//
//  Flags for DDP_SetBreakpoint()
//

enum ERSBreakpointFlags
	{
	ERS_NONE					=	0x0000,	// No flags, normal breakpoint
	ERS_PAUSE				=	0x0001,	// Go to still mode when reaching breakpoint
	ERS_AUTOCLEAR			=	0x0002,	// Delete breakpoint when it has been reached
	ERS_PAUSEATEND			=	0x0004	// Trigger at end of title
	};

//
//  Flags for DDP_SetBreakpointExt()
//

enum ERSBreakpointExtFlags
	{
	ERS_ATTIME			=	0x0001,	// Trigger when reaching time in title
	ERS_ENDOFTITLE		=	0x0002,	// Trigger at end of title
	ERS_ENDOFPTT		=	0x0004,	// Trigger at and of part of title
	ERS_FORWARD			=	0x0008,	// Trigger when playing forward
	ERS_BACKWARD		=	0x0010,	// Trigger when playing backward
	ERS_TOSTILL			=	0x0020,	// Go to still when reaching breakpoint
	ERS_CLEAR			=	0x0040,	// Automatically delete breakpoint after triggering
	ERS_BEGINOFPTT		=	0x0080	// Trigger at begin of PTT
	};

//
//  Flags for ExtendedPlay(DWORD flags, WORD title, WORD ptt, DVDTime time);
//

#define DDPEPF_NONE					0
#define DDPEPF_PAUSE_AT_START		1
#define DDPEPF_USE_TIME				2
#define DDPEPF_USE_PTT				4
#define DDPEPF_USE_TITLE			8

//
//  Flags for DetachDrive(DWORD flags, DVDTime time);
//

#define DDPDDF_DETACH_IMMEDIATE				1
#define DDPDDF_DETACH_AT_TIME					2
#define DDPDDF_DETACH_AT_END_OF_CELL		4
#define DDPDDF_DETACH_AT_END_OF_PROGRAM	8
#define DDPDDF_DETACH_AT_END_OF_PGC			16

#define DDPDDF_DETACH_ANY						31

#define DDPDDF_STREAM_PREFETCH				32
#define DDPDDF_PREFETCH_BUFFER_SIZE			64

//
//  Flags for DDP_StartPresentationExt and DDP_DefrostExt
//

#define DDPSPF_NONE		0
#define DDPSPF_TOPAUSE	1
#define DDPSPF_ID_MATCH	2

//
//  Flags for DDP_PlayFile
//

#define DDPPFF_NONE				0
#define DDPPFF_PAUSE_AT_START	1

//
// Flags for DDP_SetAudioStreamSelectionPreferences
//
#define DDPASSP_NONE				0
#define DDPASSP_MAXCHANNELS	1
#define DDPASSP_NO_DTS			2
#define DDPASSP_DTS				4

//
//  AVF definitions
//

// Structure for AVFStreamServer::GetFileInfo()

class AVFInfo
	{
	public:
		DWORD								size;								// Size of the structure passed

		// Request bitmasks

		DWORD								request;							// Bitmask for requested data
		DWORD								valid;							// Bitmask for delivered data
		DWORD								monitor;							// Bitmask indicating the elements to check for changes
		DWORD								changed;							// Bitmask indicating the elements that have changed

		DVDLocation						duration;						// obviates need for ExtendedPlayerState call

		// MPEG Audio Characteristics (the following items will always be available for MPEG Audio)
		MPEGAudioFrameInfo			mpegAudio;

		// MPEG Audio ID3v1 information (optional)
		MPEGAudioID3V1Tag				id3;
	};

//
//  Request bitmask defines
//

#define AVFINFO_MPEG_AUDIO_FRAME			0x00000001
#define AVFINFO_MPEG_AUDIO_ID3			0x00000002
#define AVFINFO_VERIFY_FILENAME_ONLY	0x00000004

//
//  Freeze state info
//

class DDPFreezeState
	{
	public:
		DVDDiskType diskType;
		BYTE			uniqueKey[8];
		WORD			parentalLevel;
		WORD			parentalCountry;
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDTitleSeq.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef DVDTTSRV_H
#define DVDTTSRV_H

#include "DVDPGCSeq.h"
#include "DVDNavpu.h"
#include "DVDPlayer.h"

#pragma warning(disable : 4250)

class DVDTitleSequencer : public DVDPGCSequencer
	{
	private:
		DVDDomain	domain;  // Please do not use this variable directly but use the Set/Get methods below

	protected:
		DVDOBS			*	vobs;
		DWORD				vobsUniqueKey;
		DVDPGCIT			pgcit;
		DVDPTT			ptt;

		DVDGenericPGCI	*	pgci;
		WORD				pgcn;

		BOOL				resumeAvail;
		BOOL				resumeValid;

		WORD				resumePGCN;
		WORD				resumeTitle;
		WORD				resumePTT;
		WORD				resumePG;

      Error PGCCompleted(DVDGenericPGCI * pgci);

		Error SelectAudioStream(WORD & strm);
		Error SelectSPUStream(WORD & strm, BOOL & enable);

   	virtual Error TransferDiskKey(void) = 0;

		Error SelectProgramChain(void);
		Error AccessRestricted(DVDOBS * vobs, DVDPGCIT pgcit, DVDPTT ptt, WORD vttn, DVDTime time, BOOL & restricted);

		//
		//  Freezing stuff
		//

		class DVDTSFreezeState
			{
			public:
				WORD			pgcn;
				BOOL			resumeAvail;
				BOOL			resumeValid;
				WORD			resumePGCN;
				WORD			resumeTitle;
				WORD			resumePG;

				DVDPGCSFreezeState pgcsFreezeState;
			};

		Error Freeze (DVDTSFreezeState & state);
		Error Defrost(DVDTSFreezeState & state, DVDOBS * vobs, DWORD flags);

	public:
		DVDTitleSequencer (WinPortServer *server, UnitSet units, EventDispatcher* pEventDispatcher);
		virtual ~DVDTitleSequencer(void);

	   Error OpenTitleSet(DVDOBS * vobs, DVDPGCIT pgcit, DVDPTT ptt);
		Error CloseTitleSet(void);

		Error PlayPGCI(DVDGenericPGCI * pgci, BOOL toPause = FALSE);

		Error GetSPRM(int index, WORD & sprm);

	   Error GetCurrentLocation(DVDLocation & loc);
		Error GetCurrentDuration(DVDLocation & loc);

	  	Error GetAvailStreams(BYTE & audioStreams, DWORD & subPictureStreams);

		Error GoPrevProgram(void);

		Error GoProgramChain(WORD pgcn);
		Error GoPartOfTitle(WORD pttn);
		Error GoPrevProgramChain(void);
		Error GoNextProgramChain(void);
		Error GoUpProgramChain(void);

		Error Exit(Error err = GNR_OK);

		virtual Error TimeSearch(DVDTime time);

		virtual Error TimePlay(WORD title, DVDTime time);

   	Error GoVideoTitleSetTitle(WORD title, BOOL toPause);
   	Error GoVideoTitleSetPartOfTitle(WORD title, WORD ptt);

		Error GoAudioTitleSetTrack(int track);

		virtual Error ExtendedPlay(DWORD flags, WORD title, WORD ptt, DVDTime time);

		virtual Error ResumeFromSystemSpace(void) = 0;
		virtual Error ResumeFromSystemSpace(DVDOBS * vobs, DVDPGCIT pgcit, DVDPTT ptt);
		virtual Error SaveResumeInformation(void);

		void SetDomain(DVDDomain domain)
			{
			if (domain != this->domain)
				SendEvent(DNE_DOMAIN_CHANGE, domain);
			this->domain = domain;
			}

		DVDDomain GetDomain() { return domain; }
	};

#pragma warning(default : 4250)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDTitleSeq.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVD Tile Sequencer Class
//
////////////////////////////////////////////////////////////////////

#include "DVDTitleSeq.h"
#include "Library/Common/vddebug.h"

//
//  Constructor
//

DVDTitleSequencer::DVDTitleSequencer (WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher)
	: DVDPGCSequencer(server, units, pEventDispatcher)
	, EventSender(pEventDispatcher)
	, ERSBreakpointControl(pEventDispatcher)
	{
	pgci = NULL;
	SetDomain(STOP_DOM);
	}

//
//  Destructor
//

DVDTitleSequencer::~DVDTitleSequencer(void)
	{
	if (pgci) delete pgci;
	}

//
//  Program Chain Completed action
//

Error DVDTitleSequencer::PGCCompleted(DVDGenericPGCI * pgci)
	{
	//
	//  Go to next PGC
	//

	GNREASSERT(pgci->GetNextProgramChain(pgcn));
	if (!pgcn)
		GNREASSERT(pgci->GetUpperProgramChain(pgcn));

	delete this->pgci;
	this->pgci = NULL;

	if (pgcn == 0xffff)
		{
		return ResumeFromSystemSpace();
		}
	else if (pgcn)
		{
		GNREASSERT(pgcit.GetPGCI(pgcn, this->pgci));
		if (this->pgci)
			{
			return StartPGCPlayback(vobs, this->pgci, 1);
			}
		else
			GNRAISE(GNR_RANGE_VIOLATION);
		}
	else
		{
		GNREASSERT(Exit());
		}

	GNRAISE_OK;
	}

//
//  Open title set
//
Error DVDTitleSequencer::CloseTitleSet(void)
	{
	if (pgci)
		{
		StopPGCPlayback();
		delete pgci;
		pgci = NULL;
		}

	GNRAISE_OK;
	}

Error DVDTitleSequencer::OpenTitleSet(DVDOBS * vobs, DVDPGCIT pgcit, DVDPTT ptt)
	{
	DVDDataFile * file = NULL;
	Error error = GNR_OK;
	WORD vatt;
	BOOL enc;

	//
	// Stop playback and create new PGCI
	//

	if (pgci)
		{
		StopPGCPlayback();
		delete pgci;
		pgci = NULL;
		}

	this->pgcit = pgcit;
	this->ptt = ptt;

	if (!(this->vobs) || vobsUniqueKey != vobs->uniqueKey)
		{
		this->vobs = vobs;
		vobsUniqueKey = vobs->uniqueKey;

		GNREASSERT(vobs->GetDataFile(file));

		if (file)
			{
			GNREASSERT(vobs->GetVideoAttributes(vatt));

			GNREASSERT(player->SetVideoStandard(vatt));

			//
			// set digital copy managment mode ...
			//

			GenericCopyManagementInfo mode;
			error = file->GetCopyManagementInfo(mode);
			if (IS_ERROR(error))
				GNREASSERT(player->SetCopyManagementMode(GCMI_COPY_FORBIDDEN));
			else
				{
				GNREASSERT(player->SetCopyManagementMode(mode));
				}

			//
			//  Workaround ????
			//  Double key transfer
			//

			GNREASSERT(file->IsEncrypted(enc));
			if (enc)
				{
				GNREASSERT(TransferDiskKey());

				error = player->TransferTitleKey(file);

				DP("Transfer of title key result 1 %08lx", error);

				if (error != GNR_OK && error != GNR_UNIMPLEMENTED)
					{
					GNREASSERT(TransferDiskKey());
					error = player->TransferTitleKey(file);

					DP("Transfer of title key result 2 %08lx", error);

					if (error != GNR_OK && error != GNR_UNIMPLEMENTED)
						{
						GNRAISE(error);
						}
					}
				}
			else
				{
				GNREASSERT(player->CancelTitleKey());
				}
			}
		}

	GNRAISE_OK;
	}

//
//  Select audio  stream
//

Error DVDTitleSequencer::SelectAudioStream(WORD & strm)
	{
	if (GetDomain() == TT_DOM)
		{
		GNREASSERT(DVDPGCSequencer::SelectAudioStream(strm));
		}
	else
		strm = 0;

	GNRAISE_OK;
	}

//
//  Select subpicture stream
//

Error DVDTitleSequencer::SelectSPUStream(WORD & strm, BOOL & enable)
	{
	if (GetDomain() == TT_DOM)
		{
		GNREASSERT(DVDPGCSequencer::SelectSPUStream(strm, enable));
		}
	else
		{
		strm = 0x00;
		enable = TRUE;
		}

	GNRAISE_OK;
	}

//
//  Get current location in stream
//

Error DVDTitleSequencer::GetCurrentLocation(DVDLocation & loc)
	{
	GNREASSERT(DVDPGCSequencer::GetCurrentLocation(loc));

	loc.domain = GetDomain();
	loc.programChain = pgcn;

	if (GetDomain() == TT_DOM)
		{
		GNREASSERT(pgcit.GetTitle(pgcn, loc.vtsTitle));
		GNREASSERT(ptt.GetPartAndTitle(loc.programChain, loc.program, loc.vtsTitle, loc.partOfTitle));
		}
	else
		{
		loc.vtsTitle = 0;
		loc.partOfTitle = 0;
		}

	GNRAISE_OK;
	}

//
//  Get duration of current playback data
//

Error DVDTitleSequencer::GetCurrentDuration(DVDLocation & loc)
	{
	WORD title;

	GNREASSERT(DVDPGCSequencer::GetCurrentDuration(loc));

	loc.domain = GetDomain();

	if (GetDomain() == STOP_DOM)
		{
		loc.programChain = 0;
		}
	else if (GetDomain() != FP_DOM)
		{
		GNREASSERT(pgcit.GetNumberOfPGC(loc.programChain));

		if (GetDomain() == TT_DOM)
			{
			GNREASSERT(ptt.GetNumberOfTitleUnits(loc.vtsTitle));
			GNREASSERT(pgcit.GetTitle(pgcn, title));
			GNREASSERT(ptt.GetNumberOfPartOfTitle(title, loc.partOfTitle));
			}
		}
	else
		loc.programChain = 1;

	GNRAISE_OK;
	}

//
//  Get the available streams
//

Error DVDTitleSequencer::GetAvailStreams(BYTE & audioStreams, DWORD & subPictureStreams)
	{
	WORD num, strm, ctrl;
	DWORD sctrl;

	if (GetDomain() == TT_DOM)
		{
		audioStreams = 0;
		subPictureStreams = 0;

		GNREASSERT(vobs->GetNumberOfAudioStreams(num));
		for(strm = 0; strm <num; strm++)
			{
			GNREASSERT(pgci->GetAudioStreamControl(strm, ctrl));
			if (XTBF(15, ctrl)) audioStreams |= MKFLAG(strm);
			}

		GNREASSERT(vobs->GetNumberOfSubPictureStreams(num));
		for(strm = 0; strm <num; strm++)
			{
			GNREASSERT(pgci->GetSubPictureStreamControl(strm, sctrl));
			if (XTBF(31, sctrl)) subPictureStreams |= MKFLAG(strm);
			}

		GNRAISE_OK;
		}
	else if (GetDomain() == STOP_DOM)
		{
		audioStreams = 0x00;
		subPictureStreams = 0x00000000;

		GNRAISE_OK;
		}
	else
		{
		audioStreams = 0x01;
		subPictureStreams = 0x00000001;

		GNRAISE_OK;
		}
	}

//
//  Go to previous program
//

Error DVDTitleSequencer::GoPrevProgram(void)
	{
	Error err;

	if (pgci)
		{
		if (IS_ERROR(err = DVDPGCSequencer::GoPrevProgram()))
			{
			if (err == GNR_RANGE_VIOLATION)
				{
				return GoPrevProgramChain();
				}
			else
				GNRAISE(err);
			}
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Check if access to a certain position (via TimePlay) is allowed
//

Error DVDTitleSequencer::AccessRestricted(DVDOBS * vobs, DVDPGCIT pgcit, DVDPTT ptt, WORD vttn, DVDTime time, BOOL & restricted)
	{
	DVDGenericPGCI * pgci;
	Error err;
	WORD ptl;
	WORD pgcn;
	WORD pgn;
	WORD pgcitID;
	WORD ptlID;
	PGCBlockMode mode;
	PGCBlockType type;
	BOOL hasIDs;

	GNREASSERT(ptt.GetPartOfTitlePGC(vttn, 1, pgcn, pgn));

	GNREASSERT(GetSPRM(13, ptl));
	GNREASSERT(pgcit.GetParentalID(pgcn, pgcitID));
	GNREASSERT(vobs->HasParentalIDs(hasIDs));
	if (ptl != 15 &&  pgcitID && hasIDs)
		{
		GNREASSERT(vobs->GetParentalID(ptl, ptlID));

		for (;;)
			{
			GNREASSERT(pgcit.GetParentalID(pgcn, pgcitID));
			if (pgcitID & ptlID)
				break;

			GNREASSERT(pgcit.GetBlockType(pgcn, type));
			GNREASSERT(pgcit.GetBlockMode(pgcn, mode));
			if (type != PBT_PARENTAL_BLOCK || mode == PBM_LAST_PGC_IN_BLOCK)
				break;

			pgcn++;
			}
		}

	GNREASSERT(pgcit.GetPGCI(pgcn, pgci));
	err = DVDPGCSequencer::AccessRestricted(pgci, time, restricted);
	delete pgci;
	GNRAISE(err);
	}

//
//  Select program chain
//

Error DVDTitleSequencer::SelectProgramChain(void)
	{
	WORD ptl;
	WORD pgcitID;
	PGCBlockMode mode;
	PGCBlockType type;
	WORD ptlID;
	BOOL hasIDs;

	GNREASSERT(GetSPRM(13, ptl));
	GNREASSERT(pgcit.GetParentalID(pgcn, pgcitID));
	GNREASSERT(vobs->HasParentalIDs(hasIDs));
	if (ptl != 15 && pgcitID && hasIDs)
		{
		GNREASSERT(vobs->GetParentalID(ptl, ptlID));

		for(;;)
			{
			GNREASSERT(pgcit.GetParentalID(pgcn, pgcitID));
			if (pgcitID & ptlID)
				return pgcit.GetPGCI(pgcn, pgci);

			GNREASSERT(pgcit.GetBlockType(pgcn, type));
			GNREASSERT(pgcit.GetBlockMode(pgcn, mode));
			if (type != PBT_PARENTAL_BLOCK || mode == PBM_LAST_PGC_IN_BLOCK)
				GNRAISE(GNR_PARENTAL_LEVEL_TOO_LOW);

			pgcn++;
			}
		}
	else
		return pgcit.GetPGCI(pgcn, pgci);
	}

//
//  Play PGCI
//

Error DVDTitleSequencer::PlayPGCI(DVDGenericPGCI * pgci, BOOL toPause)
	{
	DP("Playing PGCI %08lx for %08lx", pgci, this->pgci);

	if (!pgci)
		GNRAISE(GNR_OBJECT_NOT_ALLOCATED);

	if (this->pgci)
		{
		GNREASSERT(StopPGCPlayback());
		delete this->pgci;
		}

	this->pgci = pgci;

	DP("Starting PGC Playback");

	return StartPGCPlayback(vobs, pgci, 1, FALSE, toPause);
	}

//
//  Go to a certain program chain
//

Error DVDTitleSequencer::GoProgramChain(WORD pgcn)
	{
	if (pgci)
		{
		GNREASSERT(StopPGCPlayback());
		delete pgci;
		pgci = NULL;
		}

	this->pgcn = pgcn;

	GNREASSERT(SelectProgramChain());
	return StartPGCPlayback(vobs, pgci, 1);
	}

//
//  Go to part of title
//

Error DVDTitleSequencer::GoPartOfTitle(WORD pttn)
	{
	WORD pgn, title;

	if (pgci && GetDomain() == TT_DOM)
		{
		GNREASSERT(pgcit.GetTitle(pgcn, title));
		if (title)
			{
			GNREASSERT(StopPGCPlayback());
			delete pgci;

			pgci = NULL;
			GNREASSERT(ptt.GetPartOfTitlePGC(title, pttn, pgcn, pgn));

			GNREASSERT(SelectProgramChain());
			return StartPGCPlayback(vobs, pgci, pgn, TRUE);
			}
		else
			GNRAISE(GNR_OBJECT_NOT_FOUND);
		}
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Go to previous program chain
//

Error DVDTitleSequencer::GoPrevProgramChain(void)
	{
	WORD w;

	if (pgci)
		{
		GNREASSERT(pgci->GetPreviousProgramChain(w));
		if (w)
			{
			GNREASSERT(StopPGCPlayback());

			delete pgci;

			pgcn = w;

			GNREASSERT(SelectProgramChain());
			return StartPGCPlayback(vobs, pgci, 1, FALSE);
			}
		else
			GNRAISE_OK;
		}
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Go to next program chain
//

Error DVDTitleSequencer::GoNextProgramChain(void)
	{
	WORD w;

	if (pgci)
		{
		GNREASSERT(pgci->GetNextProgramChain(w));
		if (w)
			{
			GNREASSERT(StopPGCPlayback());
			delete pgci;

			pgcn = w;

			GNREASSERT(SelectProgramChain());
			return StartPGCPlayback(vobs, pgci, 1, FALSE);
			}
		else
			GNRAISE_OK;
		}
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Go to upper program chain
//

Error DVDTitleSequencer::GoUpProgramChain(void)
	{
	WORD w;

	if (pgci)
		{
		GNREASSERT(pgci->GetUpperProgramChain(w));
		if (w == 0xffff)
			{
			return ResumeFromSystemSpace();
			}
		else if (w)
			{
			GNREASSERT(StopPGCPlayback());
			delete pgci;

			pgcn = w;

			GNREASSERT(SelectProgramChain());
			return StartPGCPlayback(vobs, pgci, 1, FALSE);
			}
		else
			GNRAISE_OK;
		}
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Go to certain title
//

Error DVDTitleSequencer::GoVideoTitleSetTitle(WORD title, BOOL toPause)
	{
	WORD pgn;

	if (pgci)
		{
		GNREASSERT(StopPGCPlayback());
		delete pgci;

		pgci = NULL;
		}

	GNREASSERT(SetSPRM(9, 0));

	GNREASSERT(ptt.GetPartOfTitlePGC(title, 1, pgcn, pgn));

	GNREASSERT(SelectProgramChain());
	return StartPGCPlayback(vobs, pgci, 1, FALSE, toPause);
	}

//
//  Go to certain part of title
//

Error DVDTitleSequencer::GoVideoTitleSetPartOfTitle(WORD title, WORD ptt)
	{
	WORD pgn;

	if (pgci)
		{
		GNREASSERT(StopPGCPlayback());
		delete pgci;

		pgci = NULL;
		}

	GNREASSERT(SetSPRM(9, 0));

	GNREASSERT(this->ptt.GetPartOfTitlePGC(title, ptt, pgcn, pgn));

	GNREASSERT(SelectProgramChain());
	return StartPGCPlayback(vobs, pgci, pgn, FALSE);
	}

//
//	Go to certain track (DVD-Audio only)
//

Error DVDTitleSequencer::GoAudioTitleSetTrack(int track)
	{
	if (pgci)
		{
		GNREASSERT(StopPGCPlayback());
		delete pgci;

		pgci = NULL;
		}

	// always set Program Chain Number = 1
	// not sure if this works (MST, 12/27/00)
	pgcn = 1;

	GNREASSERT(SelectProgramChain());
	//return StartPGCPlayback(vobs, pgci, 1, TRUE, FALSE);

	GNRAISE_OK;
	}

//
//  Perform time search
//

Error DVDTitleSequencer::TimeSearch(DVDTime time)
	{
	BOOL restricted;

	if (pgci)
		{
		GNREASSERT(DVDPGCSequencer::AccessRestricted(pgci, time, restricted));
		if (restricted)
			GNRAISE(GNR_OPERATION_PROHIBITED);

		GNREASSERT(StopPGCPlayback());
		GNRAISE(StartPGCPlaybackWithTime(vobs, pgci, time, TRUE, FALSE));
		}
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Stop playback
//

Error DVDTitleSequencer::Exit(Error err)
	{
	if (pgci)
		{
		GNREASSERT(StopPGCPlayback());
		delete pgci;

		pgci = NULL;
		pgcn = 0;
		}

	GNRAISE_OK;
	}

//
//  Perform time play
//

Error DVDTitleSequencer::TimePlay(WORD title, DVDTime time)
	{
	WORD pgn;

	if (pgci)
		{
		GNREASSERT(StopPGCPlayback());
		delete pgci;

		pgci = NULL;
		}
	GNREASSERT(SetSPRM(9, 0));

	GNREASSERT(this->ptt.GetPartOfTitlePGC(title, 1, pgcn, pgn));

	GNREASSERT(SelectProgramChain());
	GNRAISE(StartPGCPlaybackWithTime(vobs, pgci, time));
	}

//
//  Extended Play
//

Error DVDTitleSequencer::ExtendedPlay(DWORD flags, WORD title, WORD pttn, DVDTime time)
	{
	BOOL pause;
	WORD pgn;

	pause = (flags & DDPEPF_PAUSE_AT_START) != 0;

	if (flags & DDPEPF_USE_TITLE)
		{
		if (pgci)
			{
			GNREASSERT(StopPGCPlayback());
			delete pgci;

			pgci = NULL;
			}

		GNREASSERT(SetSPRM(9, 0));

		if (flags & DDPEPF_USE_PTT)
			GNREASSERT(this->ptt.GetPartOfTitlePGC(title, pttn, pgcn, pgn));
		else
			GNREASSERT(this->ptt.GetPartOfTitlePGC(title, 1, pgcn, pgn));

		GNREASSERT(SelectProgramChain());

		if (flags & DDPEPF_USE_TIME)
			GNRAISE(StartPGCPlaybackWithTime(vobs, pgci, time, FALSE, pause));
		else
			GNRAISE(StartPGCPlayback(vobs, pgci, pgn, FALSE, pause));
		}
	else
		{
		if (pgci && GetDomain() == TT_DOM)
			{
			GNREASSERT(pgcit.GetTitle(pgcn, title));
			if (title)
				{
				GNREASSERT(StopPGCPlayback());
				delete pgci;

				pgci = NULL;
				if (flags & DDPEPF_USE_PTT)
					GNREASSERT(ptt.GetPartOfTitlePGC(title, pttn, pgcn, pgn));
				else
					GNREASSERT(ptt.GetPartOfTitlePGC(title, 1, pgcn, pgn));

				GNREASSERT(SelectProgramChain());

				if (flags & DDPEPF_USE_TIME)
					GNRAISE(StartPGCPlaybackWithTime(vobs, pgci, time, TRUE, pause));
				else
					GNRAISE(StartPGCPlayback(vobs, pgci, pgn, TRUE, pause));
				}
			else
				GNRAISE(GNR_OBJECT_NOT_FOUND);
			}
		else
			GNRAISE(GNR_OBJECT_NOT_FOUND);
		}
	}

//
//  Get system parameter
//

Error DVDTitleSequencer::GetSPRM(int index, WORD & sprm)
	{
	switch(index)
		{
		case 5:
			if (GetDomain() == TT_DOM)
				return pgcit.GetTitle(pgcn, sprm);
			else if (resumeAvail)
				sprm = resumeTitle;
			else
				sprm = 1;
			break;
		case 6:
			if (GetDomain() == TT_DOM)
				sprm = pgcn;
			else if (resumeAvail)
				sprm = resumePGCN;
			else
				sprm = 1;
			break;
		case 7:
			if (GetDomain() == TT_DOM)
				{
				WORD title;
				WORD pg;

				GNREASSERT(pgcit.GetTitle(pgcn, title));
				GNREASSERT(GetCurrentPlayingProgram(pg));
				return ptt.GetPartOfTitle(title, pgcn, pg, sprm);
				}
			else if (resumeAvail)
				sprm = resumePTT;
			else
				sprm = 1;
			break;
		default:
			 return DVDPGCSequencer::GetSPRM(index, sprm);
		}
	GNRAISE_OK;
	}

//
//  Resume to previously saved state
//

Error DVDTitleSequencer::ResumeFromSystemSpace(DVDOBS * vobs, DVDPGCIT pgcit, DVDPTT ptt)
	{
	OpenTitleSet(vobs, pgcit, ptt);

	pgcn = resumePGCN;
	GNREASSERT(ptt.GetPartOfTitle(resumeTitle, pgcn, resumePG, resumePTT));
	GNREASSERT(SelectProgramChain());
	return DVDPGCSequencer::ResumeFromSystemSpace(vobs, pgci);
	}

//
//  Save state for resume
//

Error DVDTitleSequencer::SaveResumeInformation(void)
	{
	GNREASSERT(DVDPGCSequencer::SaveResumeInformation());

	resumePGCN = pgcn;
	GNREASSERT(pgcit.GetTitle(pgcn, resumeTitle));
	GNREASSERT(pgci->GetProgramOfCell(resumeCell, resumePG));
	GNREASSERT(ptt.GetPartOfTitle(resumeTitle, pgcn, resumePG, resumePTT));
	resumeAvail = TRUE;
	resumeValid = FALSE;

	GNRAISE_OK;
	}

//
//  Freeze current state
//

Error DVDTitleSequencer::Freeze(DVDTSFreezeState & state)
	{
	//
	// Save data
	//

	state.pgcn = pgcn;

	state.resumeAvail = resumeAvail;
	state.resumeValid = resumeValid;
	state.resumePGCN = resumePGCN;
	state.resumeTitle = resumeTitle;
	state.resumePG = resumePG;

	GNRAISE(DVDPGCSequencer::Freeze(state.pgcsFreezeState));
	}

//
//  Return to previously saved state
//

Error DVDTitleSequencer::Defrost(DVDTSFreezeState & state, DVDOBS * vobs, DWORD flags)
	{
	//
	// Open title set and program chain
	//

	OpenTitleSet(vobs, pgcit, ptt);  // Initializes vobs, pgcit, ptt

	pgcn = state.pgcn;
	GNREASSERT(SelectProgramChain());  // initializes PGCI

	//
	// Restore resume data
	//

	resumeAvail = state.resumeAvail;
	resumeValid = state.resumeValid;
	resumePGCN = state.resumePGCN;
	resumeTitle = state.resumeTitle;
	resumePG = state.resumePG;

	GNRAISE(DVDPGCSequencer::Defrost(state.pgcsFreezeState, vobs, pgci, GetDomain(), flags));
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\EventSender.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "EventSender.h"

//
//  Standard Constructors
//

EventDispatcher::EventDispatcher(void)
	{
	int i;

	for (i=0; i < DNE_EVENT_NUMBER; i++)
		SetEventHandler(i, NULL, 0);
	}

EventSender::EventSender(EventDispatcher* pNewEventDispatcher) :
	pEventDispatcher(pNewEventDispatcher)
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\DVDTime.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVDTime Class
//
////////////////////////////////////////////////////////////////////

#include "DVDTime.h"

//
//  Constructor
//

DVDTime::DVDTime(int hours, int minutes, int seconds, int frames, int frameRate)
	{
	if (frames >= frameRate)
		{
		seconds += frames / frameRate;
		frames %= frameRate;
		}

	while (frames < 0)
		{
		frames += frameRate;
		seconds -= 1;
		}

	if (seconds >= 60)
		{
		minutes += seconds / 60;
		seconds %= 60;
		}

	while (seconds < 0)
		{
		seconds += 60;
		minutes -= 1;
		}

	if (minutes >= 60)
		{
		hours += minutes / 60;
		minutes %= 60;
		}

	while (minutes < 0)
		{
		minutes += 60;
		hours -= 1;
		}

	if (hours < 0)
		{
		hours = minutes = seconds = frames = 0;
		}

	stamp = MKBF(28, 4, hours / 10) |
	        MKBF(24, 4, hours % 10) |
	        MKBF(20, 4, minutes / 10) |
	        MKBF(16, 4, minutes % 10) |
	        MKBF(12, 4, seconds / 10) |
	        MKBF(8, 4, seconds % 10) |
	        MKBF(6, 2, frameRate == 25 ? 1 : 3) |
	        MKBF(4, 2, frames / 10) |
	        MKBF(0, 4, frames % 10);
	}

//
//  Constructor from fraction of millisecs (meant e.g. for the 90 KHz time stamps on DVD)
//

DVDTime::DVDTime(int millisecs, int divider, int frameRate)
	{
	int hours = 0, minutes = 0, seconds = 0, frames;

	frames = ScaleDWord(millisecs, divider * 1000, frameRate);

	if (frames >= frameRate)
		{
		seconds += frames / frameRate;
		frames %= frameRate;
		}

	while (frames < 0)
		{
		frames += frameRate;
		seconds -= 1;
		}

	if (seconds >= 60)
		{
		minutes += seconds / 60;
		seconds %= 60;
		}

	while (seconds < 0)
		{
		seconds += 60;
		minutes -= 1;
		}

	if (minutes >= 60)
		{
		hours += minutes / 60;
		minutes %= 60;
		}

	while (minutes < 0)
		{
		minutes += 60;
		hours -= 1;
		}

	if (hours < 0)
		{
		hours = minutes = seconds = frames = 0;
		}

	stamp = MKBF(28, 4, hours / 10) |
	        MKBF(24, 4, hours % 10) |
	        MKBF(20, 4, minutes / 10) |
	        MKBF(16, 4, minutes % 10) |
	        MKBF(12, 4, seconds / 10) |
	        MKBF(8, 4, seconds % 10) |
	        MKBF(6, 2, frameRate == 25 ? 1 : 3) |
	        MKBF(4, 2, frames / 10) |
	        MKBF(0, 4, frames % 10);
	}

//
//  Operator +
//

DVDTime operator+ (const DVDTime u, const DVDTime v)
	{
	return DVDTime(u.Hours() + v.Hours(),
	               u.Minutes() + v.Minutes(),
	               u.Seconds() + v.Seconds(),
	               u.Frames() + v.Frames(),
	               u.FrameRate());
	}

//
//  Operator -
//

DVDTime operator- (const DVDTime u, const DVDTime v)
	{
	return DVDTime(u.Hours() - v.Hours(),
	               u.Minutes() - v.Minutes(),
	               u.Seconds() - v.Seconds(),
	               u.Frames() - v.Frames(),
	               u.FrameRate());
	}

//
//  Operator +=
//

DVDTime & DVDTime::operator+= (const DVDTime u)
	{
	*this = *this + u;
	return *this;
	}

//
//  Operator -=
//

DVDTime & DVDTime::operator-= (const DVDTime u)
	{
	*this = *this - u;
	return *this;
	}

//
//  Compare
//

int DVDTime::Compare(const DVDTime u) const
	{
	if (stamp < u.stamp)
		return -1;
	else if (stamp > u.stamp)
		return 1;
	else
		return 0;
	}

////////////////////////////////////////////////////////////////////
//
//  DVDLocation Class
//
////////////////////////////////////////////////////////////////////

//
//  Compare two DVDLocations
//  Note that this function does not compare the times!!!
//

BOOL NotEqual(const DVDLocation u, const DVDLocation v)
	{
	if (u.domain			!= v.domain				||
		 u.videoTitleSet	!= v.videoTitleSet	||
		 u.title				!= v.title				||
		 u.vtsTitle			!= v.vtsTitle			||
		 u.titleTime		!= v.titleTime			||
		 u.partOfTitle		!= v.partOfTitle		||
		 u.programChain	!= v.programChain		||
		 u.pgcTime			!= v.pgcTime			||
		 u.program			!= v.program			||
		 u.cell				!= v.cell				||
		 u.cellTime			!= v.cellTime)
		 return TRUE;
	else
		return FALSE;
	}

////////////////////////////////////////////////////////////////////
//
//  DVDAudioStreamFormat
//
////////////////////////////////////////////////////////////////////

//
//  Operator==
//

BOOL operator==(const DVDAudioStreamFormat u, const DVDAudioStreamFormat v)
	{
	return (u.languageCode == v.languageCode) &&
			 (u.languageExtension == v.languageExtension) &&
			 (u.codingMode == v.codingMode) &&
			 (u.bitsPerSample == v.bitsPerSample) &&
			 (u.samplesPerSecond == v.samplesPerSecond) &&
			 (u.channels == v.channels);
	}

//
//  Operator!=
//

BOOL operator!=(const DVDAudioStreamFormat u, const DVDAudioStreamFormat v)
	{
	return (u.languageCode != v.languageCode) ||
			 (u.languageExtension != v.languageExtension) ||
			 (u.codingMode != v.codingMode) ||
			 (u.bitsPerSample != v.bitsPerSample) ||
			 (u.samplesPerSecond != v.samplesPerSecond) ||
			 (u.channels != v.channels);
	}

////////////////////////////////////////////////////////////////////
//
//  Video Stream Format
//
////////////////////////////////////////////////////////////////////

//
//  Operator==
//

BOOL operator==(const VideoStreamFormat & u, const VideoStreamFormat & v)
	{
	return (u.compressionMode == v.compressionMode) &&
			 (u.videoStandard == v.videoStandard) &&
			 (u.sourceAspectRatio == v.sourceAspectRatio) &&
			 (u.panScanOn4By3 == v.panScanOn4By3) &&
			 (u.letterboxedOn4By3 == v.letterboxedOn4By3) &&
			 (u.line21Mode == v.line21Mode) &&
			 (u.sourceWidth == v.sourceWidth) &&
			 (u.sourceHeight == v.sourceHeight) &&
			 (u.sourceLetterboxed == v.sourceLetterboxed);
	}

//
//  Operator!=
//

BOOL operator!=(const VideoStreamFormat & u, const VideoStreamFormat & v)
	{
	return (u.compressionMode != v.compressionMode) ||
			 (u.videoStandard != v.videoStandard) ||
			 (u.sourceAspectRatio != v.sourceAspectRatio) ||
			 (u.panScanOn4By3 != v.panScanOn4By3) ||
			 (u.letterboxedOn4By3 != v.letterboxedOn4By3) ||
			 (u.line21Mode != v.line21Mode) ||
			 (u.sourceWidth != v.sourceWidth) ||
			 (u.sourceHeight != v.sourceHeight) ||
			 (u.sourceLetterboxed != v.sourceLetterboxed);
	}

////////////////////////////////////////////////////////////////////
//
//  DVDSubPictureStreamFormat
//
////////////////////////////////////////////////////////////////////

//
//  Operator==
//

BOOL operator==(const DVDSubPictureStreamFormat u, const DVDSubPictureStreamFormat v)
	{
	return (u.languageCode == v.languageCode) && (u.languageExtension == v.languageExtension);
	}

//
//  Operator!=
//

BOOL operator!=(const DVDSubPictureStreamFormat u, const DVDSubPictureStreamFormat v)
	{
	return (u.languageCode != v.languageCode) || (u.languageExtension != v.languageExtension);
	}

////////////////////////////////////////////////////////////////////
//
//  DVDButtonInformation
//
////////////////////////////////////////////////////////////////////

//
//  Operator==
//

BOOL operator==(const DVDButtonInformation u, const DVDButtonInformation v)
	{
	return (u.x == v.y) && (u.y == v.y) && (u.w == v.w) && (u.h == v.h) && (u.autoAction == v.autoAction) &&
			 (u.upperButton == v.upperButton) && (u.lowerButton == v.lowerButton) &&
			 (u.leftButton == v.leftButton) && (u.rightButton == v.rightButton);
	}

//
//  Operator!=
//

BOOL operator!=(const DVDButtonInformation u, const DVDButtonInformation v)
	{
	return (u.x != v.x) || (u.y != v.y) || (u.w != v.w) || (u.h != v.h) || (u.autoAction != v.autoAction) ||
			 (u.upperButton != v.upperButton) || (u.lowerButton != v.lowerButton) ||
			 (u.leftButton != v.leftButton) || (u.rightButton != v.rightButton);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\EventDispatcher.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Event Disptacher Class
//
//  - All of the real work about event handling is actually happening here
//
////////////////////////////////////////////////////////////////////

#ifndef EVENTDISPATCHER_H

#define EVENTDISPATCHER_H

#include "DVDTime.h"
#include "library/common/krnlsync.h"
#include "library/common/vddebug.h"

class EventDispatcher
	{
	protected:
		VDLocalMutex eventDispatcherLock;

		struct
			{
			DNEEventHandler		handler;
			void					*	userData;
			} eventHandler[DNE_EVENT_NUMBER];

	public:
		EventDispatcher(void);
		virtual ~EventDispatcher(void) {}

		virtual Error SetEventHandler(DWORD event, DNEEventHandler handler, void * userData)
			{
			if (event < DNE_EVENT_NUMBER)
				{
				eventDispatcherLock.Enter();
				eventHandler[event].handler = handler;
				eventHandler[event].userData = userData;
				eventDispatcherLock.Leave();
				GNRAISE_OK;
				}
			else
				GNRAISE(GNR_RANGE_VIOLATION);
			}

		BOOL EventHasHandler(DWORD event) {return eventHandler[event].handler != NULL;}

		Error SendEvent(DWORD event, DWORD info)
			{
			eventDispatcherLock.Enter();


			if (EventHasHandler(event))
				{
				eventHandler[event].handler(event, eventHandler[event].userData, info);
				}
//			else
//				DP("No handler for %ld", event);

			eventDispatcherLock.Leave();

			GNRAISE_OK;
			}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\Region.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Region Handling
//
////////////////////////////////////////////////////////////////////

#ifndef REGION_H
#define REGION_H

#include "Boards/Generic/vdgendrv.h"

#include "DVDTime.h"
#include "Library/General/Dictnary.h"
#include "Library/Files/RootFile.h"
#include "DVDFile.h"

////////////////////////////////////////////////////////////////////
//
//  Region Handler Class
//
//  Does region management for board and drives
//
////////////////////////////////////////////////////////////////////

class RegionHandler
	{
	protected:
		RootFileSystem * rootfs;

		//
		//  Structure containing RPC information about a drive
		//

		struct RPCInfo
			{
			BOOL	isRPC2;
			BYTE	region;			// Region of drive
			BYTE	availSets;		// Number of region changes left for drive
			};

		StringDictionary rpcInfos;

		BOOL	disableRPC2Write;		// Disable setting the region code on RPC2 drives

		//
		//  Internal functions
		//

		Error	GetBoardRegion(UnitSet units, BYTE & boardRegion, BYTE & availSets);
		Error	SetBoardRegion(UnitSet units, BYTE boardRegion);
		Error CheckRegionCodeWithBoard(UnitSet units, BYTE region);
		Error	GetDriveRegion(RootIterator * rit, BOOL & isRPC2, BYTE & driveRegion, BYTE & availSets);
		Error SetDriveRegion(RootIterator * rit, BYTE & driveRegion);

		BOOL	IsSingleRegion(BYTE region);
		BOOL	IsValidRegion(BYTE region)		{ return (region & 0xff) != 0; }

	public:
		RegionHandler(void);
		virtual ~RegionHandler(void);

		Error Init(GenericProfile * profile);
		Error	GetRegionSettings(UnitSet units, RootIterator * rit, BYTE & systemRegion, BYTE & diskRegion,
										RegionSource & regionSource, BYTE & availSets);
		Error	SetSystemRegion(UnitSet units, RootIterator * rit, BYTE newSystemRegion);
		Error	CheckRegionCodeValid(UnitSet units, RootIterator * rit);
		Error	GetDiskRegion(RootIterator * rit, BYTE & diskRegion);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\EventSender.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Event Sender Class
//
////////////////////////////////////////////////////////////////////

#ifndef EVENTSENDER_H

#define EVENTSENDER_H

#include "DVDTime.h"
#include "EventDispatcher.h"
#include "library/common/krnlsync.h"
#include "library/common/vddebug.h"

class EventSender
	{
	protected:
		EventDispatcher* pEventDispatcher;

	public:
		EventSender(EventDispatcher* pNewEventDispatcher);
		virtual ~EventSender(void) {}

		virtual Error SetEventHandler(DWORD event, DNEEventHandler handler, void * userData)
			{
			if (pEventDispatcher)
				return pEventDispatcher->SetEventHandler(event, handler, userData);
			else
				GNRAISE(GNR_OBJECT_EMPTY);
			}

		BOOL EventHasHandler(DWORD event)
			{
			if (pEventDispatcher)
				return pEventDispatcher->EventHasHandler(event);
			else
				GNRAISE(GNR_OBJECT_EMPTY);
			}

		Error SendEvent(DWORD event, DWORD info)
			{
			if (pEventDispatcher)
				return pEventDispatcher->SendEvent(event, info);
			else
				GNRAISE(GNR_OBJECT_EMPTY);
			}

		void SetEventDispatcher(EventDispatcher* pNewEventDispatcher)
			{
			pEventDispatcher = pNewEventDispatcher;
			}

		EventDispatcher* GetEventDispatcher(){ return pEventDispatcher; }
	};

#define GNREASSERT_EVENT(cond, event, info) { Error e; if (e = (cond)) { SendEvent(event, info); GNRAISE(e); } }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\Region.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Region Handling Implementation
//
////////////////////////////////////////////////////////////////////

//  Note:
//  Regions are represented by a one-byte bitmask. Cleared bits represent allowed regions,
//  set bits represent forbidden regions.

#include "Region.h"

//
//  Constructor
//

RegionHandler::RegionHandler(void)
	{
	}

//
//  Destructor
//

RegionHandler::~RegionHandler(void)
	{
	RPCInfo * rpcInfo;

	ITERATE(rpcInfo, &rpcInfos)
		delete rpcInfo;
	ITERATE_END;
	}

//
//  Initialization
//

Error RegionHandler::Init(GenericProfile * profile)
	{
	profile->Read("drives", "disablerpc2write", disableRPC2Write, TRUE);
	GNRAISE_OK;
	}

//
//  Test if region pattern contains only single region
//

BOOL RegionHandler::IsSingleRegion(BYTE region)
	{
	BYTE regionCnt = 0;

	for (int i = 0; i < 8; i++)
		{
		regionCnt += (region & 0x1);
		region >>= 1;
		}

	return (regionCnt == 7);
	}

//
//  Get Disk Region
//
//  Return values:
//  GNR_OK
//

Error RegionHandler::GetDiskRegion(RootIterator * rit, BYTE & diskRegion)
	{
	GenericFileSystem * gfs;
	GenericFile * file;
	GenericDiskItem * gdi;
	RequestHandle rh;
	Error err;

	//
	//  Read setting from file
	//

	diskRegion = 0;
	err = rit->ObtainSubFileSystem(gfs);

	if (!IS_ERROR(err))
		{
		if (!IS_ERROR(err = gfs->OpenItem("video_ts\\video_ts.ifo", FAT_HEADER, gdi)) ||
			 !IS_ERROR(err = gfs->OpenItem("video_ts\\video_ts.inf", FAT_HEADER, gdi)))
			{
			file = (GenericFile*)gdi;
			if (!IS_ERROR(file->ReadBytes(35, 1, &diskRegion, DAF_CACHED, &rh)))
				err = GNR_OK;
			file->Close();
			delete file;
			}

		rit->ReleaseSubFileSystem();
		}

	//
	//  If file could not be opened, the allow all regions
	//

	if (IS_ERROR(err))
		diskRegion = 0;

	GNRAISE_OK;
	}

//
//  Get Board Region
//
//  Return values:
//  GNR_OK
//

Error RegionHandler::GetBoardRegion(UnitSet units, BYTE & pBoardRegion, BYTE & pBoardAvailSets)
	{
	BOOL tagSupported = FALSE;
	WORD availSets;
	BYTE boardRegion = 0;
	BYTE boardAvailSets = 0;

	//
	//  Get supported regions of board
	//

	for (int i=0; i<8; i++)
		{
		if (VDR_CheckRegionCodeValid(units, ~MKBFB(i, 1)))
			boardRegion |= MKBFB(i, 1);
		}
	boardRegion = ~boardRegion;

	//
	//  Get available region sets of decoder
	//

	if (!IS_ERROR(VDR_ConfigureUnitsTags(units, QRY_BOARD_REGION_COUNT(tagSupported), TAGDONE)))
		{
		if (tagSupported && !IS_ERROR(VDR_ConfigureUnitsTags(units, GET_BOARD_REGION_COUNT(availSets), TAGDONE)))
			availSets = 5 - availSets;
		}

	pBoardRegion = boardRegion;
	pBoardAvailSets = boardAvailSets;
	GNRAISE_OK;
	}

//
//  Set board region
//
//  Return values:
//  GNR_OK, GNR_REGION_CODE_INVALID, REGION_WRITE_ERROR
//

Error RegionHandler::SetBoardRegion(UnitSet units, BYTE boardRegion)
	{
	BOOL	tagSupported = FALSE;
	BYTE	regionCode = 0;
	Error	err;

	//
	//  Decoder may only have one region
	//

	if (!IsSingleRegion(boardRegion))
		GNRAISE(GNR_REGION_CODE_INVALID);

	//
	//  Get region code from bitmask
	//

	for (int i=0; i<8; i++)
		{
		if (!XTBFW(i, boardRegion))
			regionCode = (BYTE)i;
		}
	regionCode++;

	//
	//  Write  region code to board
	//

	err = VDR_ConfigureUnitsTags(units, QRY_BOARD_REGION_CODE(tagSupported), TAGDONE);
	if (!IS_ERROR(err) && tagSupported)
		GNRAISE(VDR_ConfigureUnitsTags(units, SET_BOARD_REGION_CODE(regionCode), TAGDONE));
	else
		GNRAISE(GNR_REGION_WRITE_ERROR);
	}

//
//  Check validity of region code with board region
//  Return values:
//  GNR_OK, GNR_REGIONS_DONT_MATCH
//

Error RegionHandler::CheckRegionCodeWithBoard(UnitSet units, BYTE region)
	{
	if (VDR_CheckRegionCodeValid(units, region))
		GNRAISE_OK;
	else
		GNRAISE(GNR_REGIONS_DONT_MATCH);
	}

//
//  Get Drive Region
//  Return values:
//  GNR_OK
//

Error RegionHandler::GetDriveRegion(RootIterator * rit, BOOL & isRPC2, BYTE & driveRegion, BYTE & availSets)
	{
	void * rpcInfo;
	DiskItemName itemName;

	//
	//  Initialize default values
	//

	isRPC2 = FALSE;
	driveRegion = 0;
	availSets = 0;

	//
	//  Try to find info in cache
	//

	GNREASSERT(rit->GetItemName(itemName));
	if (IS_ERROR(rpcInfos.Lookup((char*)itemName, rpcInfo)))
		{
		if (!IS_ERROR(rit->GetRPCData(isRPC2, driveRegion, availSets)))
			{
			//
			//  Try to create new RPC Info and add it to cache
			//

			if (rpcInfo = (void*)new RPCInfo())
				{
				((RPCInfo *)rpcInfo)->isRPC2 = isRPC2;
				((RPCInfo *)rpcInfo)->region = driveRegion;
				((RPCInfo *)rpcInfo)->availSets = availSets;

				if (IS_ERROR(rpcInfos.Insert(itemName, rpcInfo)))
					delete ((RPCInfo *)rpcInfo);
				}
			}
		}
	else
		{
		isRPC2 = ((RPCInfo *)rpcInfo)->isRPC2;
		driveRegion = ((RPCInfo *)rpcInfo)->region;
		availSets = ((RPCInfo *)rpcInfo)->availSets;
		}

	GNRAISE_OK;
	}

//
//  Set Drive Region
//  Return values:
//  GNR_OK, GNR_OPERATION_PROHIBITED, GNR_REGION_CODE_INVALID
//

Error RegionHandler::SetDriveRegion(RootIterator * rit, BYTE & region)
	{
	DiskItemName itemName;
	void * rpcInfo;

	//
	//  First make sure we are allowed to do that and that the region is valid
	//

	GNREASSERT(rit->GetItemName(itemName));
	DP("Setting Region Code of %d", (char*)itemName);
	if (disableRPC2Write)
		GNRAISE(GNR_OPERATION_PROHIBITED);
	else if (!IsSingleRegion(region))
		GNRAISE(GNR_REGION_CODE_INVALID);

	//
	//  Now write the region code and update the cache
	//

	DP("Writing Region");
	GNREASSERT(rit->SetRegionCode(region));
	if (!IS_ERROR(rpcInfos.Lookup((char*)itemName, rpcInfo)))
		{
		((RPCInfo*)rpcInfo)->region = region;
		((RPCInfo*)rpcInfo)->availSets--;
		}

	GNRAISE_OK;
	}

//
//  Get Region Settings (initializes cached data)
//
//  Return values:
//  GNR_OK, GNR_REGION_READ_ERROR
//

Error RegionHandler::GetRegionSettings(UnitSet units, RootIterator * rit, BYTE & pSystemRegion, BYTE & pDiskRegion,
													RegionSource & pRegionSource, BYTE & pSystemAvailSets)
	{
	BYTE pDriveRegion;
	BYTE pDriveAvailSets;
	BOOL pDriveIsRPC2;
	BYTE pBoardRegion;
	BYTE pBoardAvailSets;

	if (!rit)
		GNRAISE(GNR_REGION_READ_ERROR);

	//
	//  Read region settings
	//

	GNREASSERT(GetDiskRegion(rit, pDiskRegion));
	GNREASSERT(GetDriveRegion(rit, pDriveIsRPC2, pDriveRegion, pDriveAvailSets));
	GNREASSERT(GetBoardRegion(units, pBoardRegion, pBoardAvailSets));

	//
	//  Determine region source
	//

	if (pDriveIsRPC2)
		{
		pRegionSource = RGSRC_DRIVE;
		pSystemRegion = pDriveRegion;
		pSystemAvailSets = pDriveAvailSets;
		}
	else
		{
		pRegionSource = RGSRC_BOARD;
		pSystemRegion = pBoardRegion;
		pSystemAvailSets = pBoardAvailSets;
		}

	GNRAISE_OK;
	}

//
//  Set System Region
//
//  Return Values:
//  GNR_OK, GNR_REGION_WRITE_ERROR, GNR_REGIONS_DONT_MATCH
//

Error RegionHandler::SetSystemRegion(UnitSet units, RootIterator * rit, BYTE newSystemRegion)
	{
	RegionSource regionSource;
	BYTE	availSets;
	BYTE	systemRegion = 0;
	BYTE	diskRegion = 0;

	if (!rit)
		GNRAISE(GNR_REGION_WRITE_ERROR);

	//
	//  If new region matches current one then we are done
	//  Do not set region if disk is not single region
	//  or new region doesn't match disk region
	//

	GetRegionSettings(units, rit, systemRegion, diskRegion, regionSource, availSets);
	if (systemRegion == newSystemRegion)
		GNRAISE(GNR_OK);
	if (((~diskRegion) & (~newSystemRegion) & 0xff) == (BYTE)0)
		GNRAISE(GNR_REGIONS_DONT_MATCH);

	//
	//  Set region on drive or board
	//

	if (regionSource == RGSRC_DRIVE)
		GNRAISE(SetDriveRegion(rit, newSystemRegion));
	else
		GNRAISE(SetBoardRegion(units, newSystemRegion));
	}

//
//  Check validity of region code
//
//  Return values:
//  GNR_OK, GNR_REGION_READ_ERROR, GNR_REGIONS_DONT_MATCH
//

Error RegionHandler::CheckRegionCodeValid(UnitSet units, RootIterator * rit)
	{
	BYTE	diskRegion;
	BYTE	driveRegion;
	BYTE	driveAvailSets;
	BOOL	isRPC2;
	Error	err;

	if (!rit)
		GNRAISE(GNR_REGION_READ_ERROR);

	//
	//  Get disk region and allow an all region disc to play always
	//

	GNREASSERT(GetDiskRegion(rit, diskRegion));
	if (!IsValidRegion(diskRegion))
		GNRAISE_OK;

	//
	// Check region code
	//

	GNREASSERT(GetDriveRegion(rit, isRPC2, driveRegion, driveAvailSets));
	if (isRPC2)
		{
		//
		// RPC2 drive
		//

		err = GNR_REGIONS_DONT_MATCH;
		if (driveRegion == 0xff)
			{
			//
			// Drive has no region, means drive is not initialized....
			// And we should not try to write a region code that means not a single region
			//

			if (IsSingleRegion(diskRegion))
				{
				if (!IS_ERROR(SetDriveRegion(rit, diskRegion)))
					err = GNR_OK;
				}
			}
		else
			{
			if (((~driveRegion) & (~diskRegion) & 0xff) != (BYTE) 0 )
				err = GNR_OK;
			}

		if (err != GNR_REGIONS_DONT_MATCH)
			err = GNR_OK;
		}
	else
		{
		//
		// Only board has region code
		//

		err = CheckRegionCodeWithBoard(units, diskRegion);
		}

	GNRAISE(err);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\VCDDiskPlayer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
//  VCDDiskPlayerClass
//
//////////////////////////////////////////////////////////////////////

#include "VCDDiskPlayer.h"

//
//  VCDDiskPlayerClass Constructor
//

VCDDiskPlayerClass::VCDDiskPlayerClass(WinPortServer * server, UnitSet units)
	: CDDiskPlayerClass() //this one HAS TO be called before constructors that pass &eventDispatcherInstance
	, VCDSelectionListSequencer(server, units, &eventDispatcherInstance)
	, EventSender(&eventDispatcherInstance)
	, ERSBreakpointControl(&eventDispatcherInstance)
	{
	search = NULL;
	tracks = NULL;
	psd = NULL;
	entries = NULL;
	info = NULL;
	vcdfs = NULL;
	}

//
//  Destructor
//

VCDDiskPlayerClass::~VCDDiskPlayerClass(void)
	{
	Exit();
	delete search;
	delete tracks;
	delete psd;
	delete entries;
	delete info;
	if (vcdfs)
		{
		vcdfs->SetEventDispatcher(NULL);
		vcdfs->Release();
		}
	}

//
//  Initialize
//

Error VCDDiskPlayerClass::Init(WinPortServer * server, GenericProfile * profile, DVDDiskType diskType, VCDFileSystem * vcdfs)
	{

	if (vcdfs)
		vcdfs->SetEventDispatcher(&eventDispatcherInstance);

	GNREASSERT(CDDiskPlayerClass::Init(server, profile, diskType, vcdfs));

	//
	//  Build file system
	//

	this->vcdfs = vcdfs;

	//
	//  Create entries (mandatory)
	//

	entries = new VCDEntries();
	if (!entries)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	GNREASSERT(entries->Initialize(vcdfs, diskType));

	//
	//  Create info (mandatory) and PSD(X) (optional)
	//

	info = new VCDInfo();
	if (!info)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	GNREASSERT(info->Initialize(vcdfs));

	if (info->HasPSDX())
		{
		psd = new VCDPSDX();
		if (!psd)
			GNRAISE(GNR_NOT_ENOUGH_MEMORY);

		if (IS_ERROR(psd->InitializeExtended(vcdfs)))
			{
			delete psd;
			psd = NULL;
			}
		}
	else
		{
		psd = new VCDPSD();
		if (!psd)
			GNRAISE(GNR_NOT_ENOUGH_MEMORY);

		if (IS_ERROR(psd->Initialize(vcdfs)))
			{
			delete psd;
			psd = NULL;
			}
		}

	//
	//  Create tracks
	//

	tracks = new VCDTracks();
	if (tracks)
		{
		if(IS_ERROR(tracks->Initialize(vcdfs)))
			{
			delete tracks;
			tracks = NULL;
			}
		}

	//
	//  Create search
	//

	search = new VCDSearch();
	if (search)
		{
		if(IS_ERROR(search->Initialize(vcdfs)))
			{
			delete search;
			search = NULL;
			}
		}

	return VCDSelectionListSequencer::Initialize(vcdfs, info, entries, tracks, search, psd);
	}

//
//  Get disk type
//

Error VCDDiskPlayerClass::GetDiskType(DVDDiskType & type)
	{
	return CDDiskPlayerClass::GetDiskType(type);
	}

//
//  Internal: Get current playback mode
//

Error VCDDiskPlayerClass::InternalGetMode(DVDPlayerMode & mode)
	{
	mode = VCDSelectionListSequencer::InternalGetMode();
	GNRAISE_OK;
	}

//
//  Return current player mode
//


Error VCDDiskPlayerClass::GetMode(DVDPlayerMode & mode)
	{
	GNREASSERT(InternalGetMode(mode));

	if (mode != DPM_STOPPED && player->IsPreempted())
		{
		Exit(GNR_LOST_DECODER);

		mode = DPM_STOPPED;
		}

	GNRAISE_OK;
	}

//
//  Get extended player state
//

Error VCDDiskPlayerClass::GetExtendedPlayerState(ExtendedPlayerState * appEPS)
	{
	WORD stream;
	int i;

	//
	//  Reset bitmasks
	//

	eps.valid = 0;
	eps.changed = 0;

	//
	//  Set VCD specific data
	//

	//
	//  Button Information
	//

	if (EPS_REQUEST(EPS_BUTTON))
		{
		GetButtonInformation(eps.numberOfButtons, eps.userButtonOffset, eps.buttonInfo);
		eps.selectedButton = eps.forcedlyActivatedButton = eps.numberOfUserButtons = 0;

		eps.valid |= EPS_BUTTON;
		if (EPS_MONITOR(EPS_BUTTON))
			{
			if (EPS_CHANGED(numberOfButtons) || EPS_CHANGED(userButtonOffset))
				eps.changed |= EPS_BUTTON;

			for (i=0; i<eps.numberOfButtons; i++)
				{
				if (EPS_CHANGED(buttonInfo[i]))
					{
					eps.changed |= EPS_BUTTON;
					break;
					}
				}
			}
		}

	//
	//  Get audio and subpicture stream attributes
	//

	GetAvailStreams(eps.availableAudioStreams, eps.availableSubPictureStreams);

	//
	//  Get Audio Stream Data
	//

	if (EPS_REQUEST(EPS_AUDIOSTREAMS))
		{
		GNREASSERT(GetCurrentAudioStream(stream));
		eps.currentAudioStream = (WORD)stream;

		//
		// a S-VCD can have a maximum of 2 audio streams
		//	whereas a VCD can have only 1 audio stream
		// So let the loop go two times
		//
		for (i=0; i<2; i++)
			{
			if (eps.availableAudioStreams & (1 << i))
				GetAudioStreamAttributes((WORD)i, eps.audioStream[i]);
			}

		GNREASSERT(player->GetAudioInformation(eps.mpeg2PrologicStatus, eps.mpeg2LFEStatus, eps.ac3AudioCodingMode));

		eps.valid |= EPS_AUDIOSTREAMS;

		if (EPS_MONITOR(EPS_AUDIOSTREAMS))
			{
			if (EPS_CHANGED(currentAudioStream) || EPS_CHANGED(availableAudioStreams) || EPS_CHANGED(audioStream[0]) ||
				 EPS_CHANGED(mpeg2PrologicStatus) || EPS_CHANGED(mpeg2LFEStatus) || EPS_CHANGED(ac3AudioCodingMode))
				eps.changed |= EPS_AUDIOSTREAMS;
			for (i=0; i<2; i++)
				{
				if (EPS_CHANGED(audioStream[i]))
					{
					eps.changed |= EPS_AUDIOSTREAMS;
					break;
					}
				}
			}
		}

	//
	//  Set common data
	//

	return CDDiskPlayerClass::GetExtendedPlayerState(appEPS);
	}

Error VCDDiskPlayerClass::StopStillPhase(void)
	{
	return VCDSelectionListSequencer::StopStillPhase();
	}

Error VCDDiskPlayerClass::Exit(Error err)
	{
	SendEvent(DNE_PLAYBACK_MODE_CHANGE, DPM_STOPPED);
	if (IS_ERROR(err))
		SendEvent(DNE_ERROR, err);
	return AbortActionList();
	}

Error VCDDiskPlayerClass::CallMenu(VTSMenuType menu)
	{
	if (psd)
		{
		AbortActionList();
		return StartActionList(0x0000);
		}
	else
		GNRAISE_OK;
	}

Error VCDDiskPlayerClass::PausePlayback(void)
	{
	if (IsScanning())
		return VCDSelectionListSequencer::StopScan(TRUE);
	else
		return VCDSelectionListSequencer::Pause();
	}

Error VCDDiskPlayerClass::ResumePlayback(void)
	{
	vcdfs->SpinUpDrive();
	return VCDSelectionListSequencer::Resume();
	}

Error VCDDiskPlayerClass::AdvanceFrame(void)
	{
	return player->Step();
	}

Error VCDDiskPlayerClass::AdvanceFrameBy(int n)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::SetPlaybackSpeed(WORD speed)
	{
	return player->SetPlaybackSpeed(speed);
	}

Error VCDDiskPlayerClass::GetPlaybackSpeed(WORD & speed)
	{
	speed = player->GetPlaybackSpeed();
	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::IsPlayingForward(BOOL & forward)
	{
	forward = VCDPlayListSequencer::IsPlayingForward();
	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::GetAudioStreamAttributes(WORD stream, DVDAudioStreamFormat & attributes)
	{
	return VCDPlayListSequencer::GetAudioStreamAttributes(stream, attributes);
	}

Error VCDDiskPlayerClass::GetSubPictureStreamAttributes(WORD stream, DVDSubPictureStreamFormat	& attributes)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::StartPresentation(DWORD flags)
	{
	if (psd)
		return StartActionList(0x0000, flags);
	else
		return GoTitle(1, flags);
	}

//
//  Get current location
//

Error VCDDiskPlayerClass::GetCurrentLocation(DVDLocation & location)
	{
	DVDTime	time;
	DWORD loc;
	WORD item;
	DVDDiskType diskType;

	if (IsPlaying() || IsStillPhase() || IsScanning() || IsPaused())
		{
		item = CurrentPlayItem();

		if (item <= 99)
			{
			location.domain = TT_DOM;
			location.title = item - 1;
			location.partOfTitle = TranslateBlockToPart(item, CurrentBlock());
			if (!location.partOfTitle) location.partOfTitle = 1;
			}
		else
			{
			location.domain = VMGM_DOM;
			location.title = 1;
			location.partOfTitle = 1;
			}

		GNREASSERT(GetDiskType(diskType));
		if (diskType == DDT_VIDEO_CD)
			{
			loc = CurrentLocation()  / (CD_FRAME_RATE * CD_FRAME_SIZE);
			time = DVDTime(0, 0, loc, 0, player->GetCurrentFrameRate());
			}
		else if (diskType == DDT_SUPER_VIDEO_CD)
			{
			//
			// do not show any time when in still mode
			//

			if (IsStillPhase())
				time = 0;
			else
				GetPlaybackTime(time);
			}

		location.videoTitleSet = 1;
		location.vtsTitle = location.title;
		location.titleTime = time;
		location.programChain = location.title;
		location.pgcTime = time;
		location.program = location.partOfTitle;
		location.cell = location.program;
		location.cellTime = time;
		}
	else
		{
		location.domain = STOP_DOM;
		}

	GNRAISE_OK;
	}

//
//  Get current duration
//

Error VCDDiskPlayerClass::GetCurrentDuration(DVDLocation & location)
	{
	DVDTime	time;
	DWORD		dur;
	DVDDiskType diskType;

	if (IsPlaying() || IsStillPhase() || IsScanning() || IsPaused())
		{
		if (CurrentPlayItem() <= 99)
			location.domain = TT_DOM;
		else
			location.domain = VMGM_DOM;
		}
	else
		{
		location.domain = STOP_DOM;
		}

	GNREASSERT(GetDiskType(diskType));
	if (diskType == DDT_VIDEO_CD)
		{
		GNREASSERT(CurrentDuration(dur));
		dur = dur / (CD_FRAME_RATE * CD_FRAME_SIZE);
		time = DVDTime(0, 0, dur, 0, 25);
		}
	else if (diskType == DDT_SUPER_VIDEO_CD)
		{
		//
		// note that CurrentPlayingTime() returns the playing time in seconds
		//

		GNREASSERT(CurrentPlayingTime(dur));
		time = DVDTime(0, 0, dur, 0, 25);
		}

	location.videoTitleSet = 1;
	location.title = 1;
	location.vtsTitle = 1;
	location.titleTime = time;
	location.partOfTitle = 1;
	location.programChain = 1;
	location.pgcTime = time;
	location.program = 1;
	location.cell = 1;
	location.cellTime = time;

	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::GetTitleDuration(WORD title, DVDTime & duration)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::MenuAvail(VTSMenuType menu, BOOL & avail)
	{
	avail = (psd != NULL) && (menu == VMT_TITLE_MENU);
	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::GetUOPs(DWORD & uops)
	{
	GNREASSERT(CDDiskPlayerClass::GetUOPs(uops));

	uops |=	UOP_MENU_CALL_ROOT
		  |	UOP_MENU_CALL_SUB_PICTURE
		  |	UOP_MENU_CALL_AUDIO
		  |	UOP_MENU_CALL_ANGLE
		  |	UOP_MENU_CALL_PTT
		  |	UOP_RESUME
		  |	UOP_SUB_PICTURE_STREAM_CHANGE
		  |	UOP_ANGLE_CHANGE
		  |	UOP_KARAOKE_MODE_CHANGE
		  |	UOP_VIDEO_MODE_CHANGE;

	if (InPlayList())
		{
		uops |= UOP_BUTTON;
		}
	else if (InSelectionList())
		{
		}
	else
		{
		uops |= UOP_BUTTON |
				 UOP_GO_UP;
		}

	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::UOPPermitted(int uop, BOOL & permitted)
	{
	DWORD uops;

	GNREASSERT(GetUOPs(uops));

	permitted = !XTBF(uop, uops);
	GNRAISE_OK;
	}

//
//  Return Number Of Titles, computed from ENTRIES.VCD
//

Error VCDDiskPlayerClass::NumberOfTitles(WORD & num)
	{
	num = VCDSelectionListSequencer::NumberOfTitles();
	GNRAISE_OK;
	}

//
//  Compute number of Part Of Title from number of entries for a track in ENTRIES.VCD
//

Error VCDDiskPlayerClass::NumberOfPartOfTitle(WORD title, WORD & num)
	{
	int i, t, m;

	m = entries->EntriesUsed();
	num = 0;
	for(i = 1; i <= m; i++)
		{
		t = entries->GetEntryTrack(i) - 1;
		if (t == title) num++;
		}

	if (num == 0) num = 1;

	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::GetAvailStreams(BYTE & audio, DWORD & subPicture)
	{
	return VCDSelectionListSequencer::GetAvailStreams(audio, subPicture);
	}

Error VCDDiskPlayerClass::GetCurrentAudioStream(WORD & stream)
	{
	stream = VCDSelectionListSequencer::GetCurrentAudioStream();
	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::GetCurrentSubPictureStream(WORD & stream)
	{
	stream = 0;
	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::IsCurrentSubPictureEnabled(BOOL & enabled)
	{
	enabled = FALSE;
	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::GetNumberOfAngles(WORD title, WORD & num)
	{
	num = 1;
	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::GetCurrentAngle(WORD & angle)
	{
	angle = 1;
	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::GoTitle(WORD title, DWORD flags)
	{
	return VCDSelectionListSequencer::TitlePlay(title, flags);
	}

Error VCDDiskPlayerClass::ExtendedPlay(DWORD flags, WORD title, WORD ptt, DVDTime time)
	{
	DVDLocation loc;
	WORD item;

	GetCurrentLocation(loc);

	//
	//  Start with title
	//

	if (!(flags & DDPEPF_USE_TITLE))
		title = loc.title;

	//
	//  Start part of title
	//

	if (!(flags & DDPEPF_USE_PTT))
		ptt = loc.partOfTitle;

	//
	//  Start current title at at time
	//

	if (!(flags & DDPEPF_USE_TIME))
		time = DVDTime(0, 0, 0, 0, loc.titleTime.FrameRate());

	//
	//  Now start playback
	//

	item = TranslatePartToEntry(title + 1, ptt);
	if (item)
		{
		return VCDSelectionListSequencer::TimePlay(title, time + DVDTime(0, 0, 0, entries->GetEntrySector(item),
																 time.FrameRate()),
																(flags & DDPEPF_PAUSE_AT_START) != 0);
		}
	else
		GNRAISE(GNR_INVALID_PARAMETERS);
	}

Error VCDDiskPlayerClass::GoPartOfTitle(WORD title, WORD part)
	{
	WORD item = TranslatePartToEntry(title + 1, part);

	if (item)
		{
		AbortActionList();
		GNREASSERT(StartPlayItem(item, 0));
		}

	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::TimePlay(WORD title, DVDTime time)
	{
	return VCDSelectionListSequencer::TimePlay(title, time);
	}

Error VCDDiskPlayerClass::GoUpProgramChain(void)
	{
	return GoReturnList();
	}

Error VCDDiskPlayerClass::TimeSearch(DVDTime time)
	{
	return RestartTrackAt(time.Millisecs() * 3 / 40);
	}

//
//  Go Part Of Title
//

Error VCDDiskPlayerClass::GoPartOfTitle(WORD part)
	{
	WORD item = CurrentPlayItem();

	if (item >= 2 && item <= 99)
		{
		item = TranslatePartToEntry(item, part);

		if (item)
			{
			AbortActionList();
			GNREASSERT(StartPlayItem(item, 0));
			}
		}

	GNRAISE_OK;
	}

//
//  Go Prev Program
//

Error VCDDiskPlayerClass::GoPrevProgram(void)
	{
	return PreviousFunction();
	}

//
//  Go Top Program
//

Error VCDDiskPlayerClass::GoTopProgram(void)
	{
	WORD item, part;

	if (IsPlaying() || IsScanning())
		{
		item = CurrentPlayItem();

		if (item >= 2 && item <= 99)
			{
			part = TranslateBlockToPart(item, CurrentBlock());
			if (!part) part = 1;

			item = TranslatePartToEntry(item, part);
			if (item)
				return RestartTrackAtItem(item);
			}
		}

	return GoTopList();
	}

//
//  Go Next Program
//

Error VCDDiskPlayerClass::GoNextProgram(void)
	{
	return NextFunction();
	}

Error VCDDiskPlayerClass::StartForwardScan(WORD speed)
	{
	return VCDSelectionListSequencer::StartForwardScan(speed);
	}

Error VCDDiskPlayerClass::StartBackwardScan(WORD speed)
	{
	return VCDSelectionListSequencer::StartBackwardScan(speed);
	}

Error VCDDiskPlayerClass::GetScanSpeed(WORD & speed)
	{
	speed = VCDSelectionListSequencer::GetScanSpeed();
	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::StartTrickplay(void)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::StopScan(void)
	{
	return VCDSelectionListSequencer::StopScan(FALSE);
	}

Error VCDDiskPlayerClass::StartReversePlayback(void)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::ResumeFromSystemSpace(void)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::ButtonUp(void)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::ButtonDown(void)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::ButtonLeft(void)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::ButtonRight(void)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::ButtonSelectAt(WORD x, WORD y)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::ButtonActivate(void)
	{
	return GoDefaultList();
	}

Error VCDDiskPlayerClass::ButtonSelectAndActivate(WORD button)
	{
	return GoSelectionList(button);
	}

Error VCDDiskPlayerClass::ButtonSelectAtAndActivate(WORD x, WORD y)
	{
	return GoSelectionListAt(x, y);
	}

Error VCDDiskPlayerClass::IsButtonAt(WORD x, WORD y, BOOL & isButton)
	{
	isButton = VCDSelectionListSequencer::IsButtonAt(x, y);
	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::HasPositionalButtons(BOOL & hasButtons)
	{
	hasButtons = VCDSelectionListSequencer::HasPositionalButtons();
	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::MenuLanguageSelect(WORD language)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::GetMenuLanguage(WORD & language)
	{
	language = 0xffff;
	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::AudioStreamChange(WORD stream)
	{
	return VCDSelectionListSequencer::AudioStreamChange(stream);
	}

Error VCDDiskPlayerClass::SubPictureStreamChange(WORD stream, BOOL enable)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::AngleChange(WORD angle)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::ParentalLevelSelect(WORD level)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::ParentalCountrySelect(WORD country)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::GetCurrentDisplayMode(DisplayPresentationMode & mode)
	{
	mode = DPM_4BY3;
	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::SetDisplayMode(DisplayPresentationMode mode)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::GetCurrentVideoStandard(VideoStandard & standard)
	{
	standard = player->GetCurrentVideoStandard();
	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::SelectInitialLanguage(WORD audioLanguage, WORD audioExtension, WORD subPictureLanguage, WORD subPictureExtension)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

Error VCDDiskPlayerClass::GetCurrentBitrate(DWORD & bitrate)
	{
	bitrate = 1350000;
	GNRAISE_OK;
	}

Error VCDDiskPlayerClass::GetCurrentButtonState(WORD & minButton, WORD & numButtons, WORD & currentButton)
	{
	return VCDSelectionListSequencer::GetCurrentButtonState(minButton, numButtons, currentButton);
	}

//
//  Freeze current player state
//

Error VCDDiskPlayerClass::Freeze(BYTE * buffer, DWORD & size)
	{
	//
	//  Check buffer size
	//

	if (size < sizeof(VCDDPCFreezeState))
		{
		size = sizeof(VCDDPCFreezeState);
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}

	//
	// BuildUniqueKey
	//

	GNREASSERT(info->BuildUniqueKey(((VCDDPCFreezeState*)buffer)->uniqueKey));
	size = sizeof(VCDDPCFreezeState);

	//
	//  Save player state
	//

	return VCDSelectionListSequencer::Freeze(&((VCDDPCFreezeState*)buffer)->vcdSLSState);
	}

//
//  Restore player state
//

Error VCDDiskPlayerClass::Defrost(BYTE * buffer, DWORD & size, DWORD flags)
	{
	BYTE uniqueKey[8];
	int i;

	//
	// Test buffer size
	//

	if (size < sizeof(VCDDPCFreezeState))
		{
		size = sizeof(VCDDPCFreezeState);
		GNRAISE(GNR_OBJECT_INVALID);
		}
	size = sizeof(VCDDPCFreezeState);

	//
	// Check unique key
	//

	GNREASSERT(info->BuildUniqueKey(uniqueKey));
	for (i=0; i<8; i++)
		{
		if (((VCDDPCFreezeState*)buffer)->uniqueKey[i] != uniqueKey[i])
			GNRAISE(GNR_INVALID_UNIQUE_KEY);
		}

	//
	// Defrost lower level data
	//

	if (!XTBF(DDPSPF_ID_MATCH, flags))
		{
		if (IS_ERROR(VCDSelectionListSequencer::Defrost(&((VCDDPCFreezeState*)buffer)->vcdSLSState, flags)))
			{
			Exit(GNR_INVALID_NAV_INFO);
			GNRAISE(GNR_OBJECT_INVALID);
			}
		}

	GNRAISE_OK;
	}

//
//  Set Breakpoint
//

Error VCDDiskPlayerClass::SetBreakpoint(WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id)
	{
	if (flags & ERS_ENDOFPTT)
		GNRAISE(GNR_OPERATION_NOT_SUPPORTED);

	if (title == 0)
		{
		DVDLocation loc;

		GetCurrentLocation(loc);
		title = loc.title;
		}

	return VCDSelectionListSequencer::SetBreakpoint(title, ptt, time, flags, id);
	}

//
//  Clear Breakpoint
//

Error VCDDiskPlayerClass::ClearBreakpoint(DWORD id)
	{
	return VCDSelectionListSequencer::ClearBreakpoint(id);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\VCDFile.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  VCD File Classes
//
////////////////////////////////////////////////////////////////////

#ifndef VCDFILE_H
#define VCDFILE_H

class VCDFile;
class VCDHeaderFile;
class VCDDataFile;
class VCDDirectory;
class VCDIterator;
class VCDFileSystem;

#include "Library/Files/RootFile.h"
#include "EventSender.h"

////////////////////////////////////////////////////////////////////
//
//  VCD File Class
//
////////////////////////////////////////////////////////////////////

class VCDFile : public GenericFile, public EventSender
	{
	protected:
		GenericFileSystem * baseFS;
		GenericFile * file;
		KernelInt64 size;

		VCDFile(VCDFileSystem * vcdfs, GenericFileSystem * baseFS, EventDispatcher* pEventDispatcher);

	public:
		virtual ~VCDFile(void);

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accessType);
		virtual Error Close(void);

		//
		//  Inquiry
		//

		virtual Error GetName(DiskItemName & name);
		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetSize(KernelInt64 & size);
		virtual Error GetIterator(GenericFileSystemIterator * & gfsi);

		//
		//  Misc. inquiry
		//

		virtual Error GetCopyManagementInfo(GenericCopyManagementInfo & gcmi);

		//
		//  Access functions
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);

		virtual Error ReadBytes(KernelInt64 pos, KernelInt64 num, BYTE * buffer, DWORD flags, RequestHandle * rh);
		virtual Error WriteBytes(KernelInt64 pos, KernelInt64 num, BYTE * buffer, DWORD flags, RequestHandle * rh);

		//
		//  Misc.
		//

		virtual Error Flush(void);
		virtual Error TerminateRequest(RequestHandle * rh);
	};

////////////////////////////////////////////////////////////////////
//
//  VCD Header File Class
//
////////////////////////////////////////////////////////////////////

class VCDHeaderFile : public VCDFile
	{
	friend class VCDFileSystem;

	protected:
		int useCount;

		VCDHeaderFile(VCDFileSystem * vcdfs, GenericFileSystem * baseFS, EventDispatcher* pEventDispatcher);

		virtual Error BuildUniqueKey(void);

	public:
		virtual ~VCDHeaderFile(void);

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accessType);

		void Obtain(void);
		void Release(void);

		Error ReadByte(DWORD position, BYTE & b, RequestHandle * rh);
		Error ReadWord(DWORD position, WORD & w, RequestHandle * rh);
		Error ReadDWord(DWORD position, DWORD & d, RequestHandle * rh);
		Error ReadSectorAddress(DWORD position, DWORD & a, RequestHandle * rh);
	};

////////////////////////////////////////////////////////////////////
//
//  VCD Data File Class
//
////////////////////////////////////////////////////////////////////

class VCDDataFile : public VCDFile
	{
	friend class VCDFileSystem;

	protected:
		DWORD nextBlock;
		DWORD numBlocks;
		BOOL	isPAL;

		VCDDataFile(VCDFileSystem * vcdfs, GenericFileSystem * baseFS, EventDispatcher* pEventDispatcher);

		virtual Error BuildUniqueKey(void);

	public:
		virtual ~VCDDataFile(void);

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accessType);

		Error GetNumberOfBlocks(DWORD & num) { num = numBlocks; GNRAISE_OK; }

		DWORD SectorToBlock(DWORD sector)
			{
			if (sector > startBlock)
				return sector - startBlock;
			else
				return 0;
			}

		DWORD AbsoluteBlockAddress(DWORD block)
			{
			return block + startBlock;
			}

		Error IsPALSequence(BOOL & pal) { pal = isPAL; GNRAISE_OK; }
	};

////////////////////////////////////////////////////////////////////
//
//  VCD Directory Class
//
////////////////////////////////////////////////////////////////////

class VCDDirectory : public GenericDirectory
	{
	friend class VCDFileSystem;

	protected:
		GenericFileSystem * baseFS;
		GenericDirectory * gd;

		VCDDirectory(VCDFileSystem * gfs, GenericFileSystem * baseFS);

	public:
		virtual ~VCDDirectory(void);

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accessType);
		virtual Error Close(void);

		//
		//  Inquiry
		//

		virtual Error GetName(DiskItemName & name);
		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetIterator(GenericFileSystemIterator * & gfsi);

		//
		//  Misc.
		//

		virtual Error Flush(void);
		virtual Error TerminateRequest(RequestHandle * rh);

		//
		//  Item handling
		//

		virtual Error CreateItem(DWORD diskItemType, const DiskItemName & name, GenericDiskItem * & gdi);
		virtual Error DeleteItem(GenericFileSystemIterator * gfsi);

		virtual Error GetNumberOfItems(DWORD & num);
		virtual Error FindItem(const DiskItemName & name, DiskItemType type, DWORD flags, GenericFileSystemIterator * & gfsi);
	};

////////////////////////////////////////////////////////////////////
//
//  VCD File System Iterator Class
//
////////////////////////////////////////////////////////////////////

class VCDIterator : public GenericFileSystemIterator
	{
	friend class VCDFileSystem;

	protected:
		GenericFileSystemIterator * gfsi;

		VCDIterator(VCDFileSystem * vcdfs, GenericFileSystemIterator * gfsi);

	public:
		virtual ~VCDIterator(void);

		virtual Error Clone(GenericFileSystemIterator * & gfsi) const;
		virtual Error Clone(VCDIterator * & vcdi) const;

		//
		//  Directory Handling
		//

		virtual Error GoToFirstItem(void);
		virtual Error GoToNextItem(void);
		virtual Error GoToSubDir(GenericFileSystemIterator * & gfsi);
		virtual Error GoToParentDir(GenericFileSystemIterator * & gfsi);

		//
		//  Inquiry
		//

		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetItemType(DiskItemType & type);
		virtual Error GetItemName(DiskItemName & name);
		virtual Error GetItemSize(KernelInt64 & size);
		virtual Error GetNumberOfItems(DWORD & num);
		virtual Error GetCurrentDir(GenericDirectory * & gd);

		//
		//  File Access
		//

		virtual Error OpenItem(DWORD accessType, GenericDiskItem * & gdi);
	};

////////////////////////////////////////////////////////////////////
//
//  VCD File System Class
//
////////////////////////////////////////////////////////////////////

class VCDFileSystem : public GenericFileSystem, public EventSender
	{
	friend class VCDFile;
	friend class VCDDirectory;
	friend class VCDIterator;

	protected:
		GenericFileSystem * baseFS;

		//
		//  Factory methods
		//

		virtual Error CreateFile(DWORD flags, GenericFile * & gf);
		virtual Error CreateDirectory(DWORD flags, GenericDirectory * & gd);

		//
		//  Data Access Methods
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);

		//
		//  Internal helper functions
		//

		virtual Error BuildUniqueKey(void);

	public:
		VCDFileSystem(EventDispatcher* pEventDispatcher);
		virtual ~VCDFileSystem(void);

		virtual Error Init(GenericFileSystemIterator * mountPoint, GenericVolume * volume, GenericProfile * profile);

		//
		//  Item handling
		//

		virtual Error OpenItem(GenericFileSystemIterator * gfsi, DWORD accessType, GenericDiskItem * & gdi);
		virtual Error OpenItem(const DiskItemName & name, DWORD accessType, GenericDiskItem * & gdi);

		//
		//  Factory Methods
		//

		virtual Error CreateIterator(GenericFileSystemIterator * & gfsi);

		//
		//  Volume Information
		//

		virtual Error GetVolumeName(KernelString & name);
		virtual Error GetVolumeSetName(KernelString & name);
		virtual Error GetVolumeSetIndex(int & index);
		virtual Error GetVolumeSetSize(int & size);

		//
		//  Drive "Pass Through" Functions
		//

		virtual Error SetDriveBlockSize(DWORD size);

		virtual Error GetNumberOfDriveBlocks(DWORD & num);
		virtual Error SetNumberOfDriveBlocks(DWORD num);

		virtual Error TerminateRequest(RequestHandle * rh);
		virtual Error Flush(void);

		virtual Error GetDriveName(KernelString & name);
		virtual Error SpinUpDrive(void);
		virtual Error SpinDownDrive(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\VCDFile.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  VCD File Classes Implemetation
//
////////////////////////////////////////////////////////////////////

#include "VCDFile.h"
#include "VCDHeader.h"
#include "Library\Common\VDDebug.h"

////////////////////////////////////////////////////////////////////
//
//  VCD File Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

VCDFile::VCDFile(VCDFileSystem * vcdfs, GenericFileSystem * baseFS, EventDispatcher* pEventDispatcher)
	: GenericFile(vcdfs)
	, EventSender(pEventDispatcher)
	{
	this->baseFS = baseFS;
	file = NULL;
	}

//
//  Destructor
//

VCDFile::~VCDFile(void)
	{
	if (file)
		{
		file->Close();
		delete file;
		file = NULL;
		}
	}

//
//  Open
//

Error VCDFile::Open(GenericFileSystemIterator * gfsi, DWORD accessType)
	{
	GenericDiskItem * gdi;

	GNREASSERT(GenericFile::Open(gfsi, accessType));
	GNREASSERT(baseFS->OpenItem(gfsi, accessType, gdi));
	file = (GenericFile*)gdi;
	GNREASSERT(file->GetStartBlock(startBlock));
	GNREASSERT(file->GetSize(size));
	GNRAISE_OK;
	}

//
//  Close
//

Error VCDFile::Close(void)
	{
	if (file)
		{
		GNREASSERT(file->Close());
		delete file;
		file = NULL;
		}

	GNRAISE_OK;
	}

//
//  Get name
//

Error VCDFile::GetName(DiskItemName & name)
	{
	return file->GetName(name);
	}

//
//  Get path name
//

Error VCDFile::GetPathName(DiskItemName & name)
	{
	return file->GetPathName(name);
	}

//
//  Get size
//

Error VCDFile::GetSize(KernelInt64 & size)
	{
	return file->GetSize(size);
	}

//
//  Get iterator
//

Error VCDFile::GetIterator(GenericFileSystemIterator * & gfsi)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Get copy management mode
//

Error VCDFile::GetCopyManagementInfo(GenericCopyManagementInfo & gcmi)
	{
	gcmi = GCMI_COPY_FORBIDDEN;
	GNRAISE_OK;
	}

//
//  Seek block
//

Error VCDFile::SeekBlock(DWORD block, DWORD flags, RequestHandle * rh)
	{
	return file->SeekBlock(block, flags, rh);
	}

//
//  Lock blocks
//

Error VCDFile::LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	Error err = file->LockBlocks(block, num, blocks, (flags & ~GD_COMMAND_MASK) | DAT_LOCK_AND_READ, rh);
	if (err == GNR_FILE_READ_ERROR)
		SendEvent(DNE_READ_ERROR, 0);
	return err;
	}

//
// Unlock blocks
//

Error VCDFile::UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	return file->UnlockBlocks(block, num, blocks, (flags & ~GD_COMMAND_MASK) | DAT_UNLOCK_CLEAN, rh);
	}

//
//  Read bytes
//

Error VCDFile::ReadBytes(KernelInt64 pos, KernelInt64 num, BYTE * buffer, DWORD flags, RequestHandle * rh)
	{
	return file->ReadBytes(pos, num, buffer, flags, rh);
	}

//
//  Write bytes
//

Error VCDFile::WriteBytes(KernelInt64 pos, KernelInt64 num, BYTE * buffer, DWORD flags, RequestHandle * rh)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Flush
//

Error VCDFile::Flush(void)
	{
	return file->Flush();
	}

//
//  Terminate request
//

Error VCDFile::TerminateRequest(RequestHandle * rh)
	{
	return file->TerminateRequest(rh);
	}

////////////////////////////////////////////////////////////////////
//
//  VCD Header File Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

VCDHeaderFile::VCDHeaderFile(VCDFileSystem * vcdfs, GenericFileSystem * baseFS, EventDispatcher* pEventDispatcher)
	: VCDFile(vcdfs, baseFS, pEventDispatcher)
	{
	}

//
//  Destructor
//

VCDHeaderFile::~VCDHeaderFile(void)
	{
	}

//
//  Open file
//

Error VCDHeaderFile::Open(GenericFileSystemIterator * gfsi, DWORD accessType)
	{
	GNREASSERT(VCDFile::Open(gfsi, accessType));
	useCount = 1;
	GNRAISE_OK;
	}

//
//  Build unique key
//

Error VCDHeaderFile::BuildUniqueKey(void)
	{
	VDAutoMutex mutex(&lock);
	RequestHandle rh;
	DriveBlock db;
	DWORD block, lastBlock;
	DWORD i, bytesToRead;
	Error err;

	memset(uniqueKey.key, 0, 8);
	if (size <= 0) GNRAISE_OK;

	lastBlock = ((size-1) / baseFS->GetHeaderDataSize()).ToDWORD();
	bytesToRead = size.ToDWORD() & 0xffff; //truncate because we don't wanna waste time reading too big files, anyway
	for (block=0; block <= lastBlock; block++)
		{
		if (!IS_ERROR(err = LockBlocks(block, 1, &db, baseFS->GetHeaderSectorType() | DAF_CACHED, &rh)))
			{
			for (i=0; i<baseFS->GetHeaderDataSize() && bytesToRead; i++)
				{
				uniqueKey.key[0] += db.data[baseFS->GetHeaderHeaderSize() + i];
				bytesToRead--;
				uniqueKey.key[1] += uniqueKey.key[0] + 0x32;
				uniqueKey.key[2] += uniqueKey.key[1] + 0x47;
				uniqueKey.key[3] += uniqueKey.key[2] + 0x21;
				uniqueKey.key[4] += uniqueKey.key[3] + 0x46;
				uniqueKey.key[5] += uniqueKey.key[4] + 0x57;
				uniqueKey.key[6] += uniqueKey.key[5] + 0x94;
				uniqueKey.key[7] += uniqueKey.key[6] + 0x25;
				}
			}

		UnlockBlocks(block, 1, &db, baseFS->GetHeaderSectorType() | DAF_CACHED, &rh);
		GNREASSERT(err);
		}

	GNRAISE_OK;
	}

//
//  Obtain file
//

void VCDHeaderFile::Obtain(void)
	{
	useCount++;
	}

//
//  Release file
//

void VCDHeaderFile::Release(void)
	{
	if (!(--useCount))
		delete this;
	}

//
//  Read byte
//

Error VCDHeaderFile::ReadByte(DWORD position, BYTE & b, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);

	return VCDFile::ReadByte(position, b, DAF_CACHED, rh);
	}

//
//  Read word
//

Error VCDHeaderFile::ReadWord(DWORD position, WORD & w, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);

	return VCDFile::ReadWord(position, w, DAF_CACHED, rh);
	}

//
//  Read DWord
//

Error VCDHeaderFile::ReadDWord(DWORD position, DWORD & d, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);

	return VCDFile::ReadDWord(position, d, DAF_CACHED, rh);
	}

//
//  Read sector address
//

Error VCDHeaderFile::ReadSectorAddress(DWORD position, DWORD & address, RequestHandle * rh)
	{
	VDAutoMutex mutex(&lock);
	BYTE b[3];
	BYTE min, sec, fra;

	GNREASSERT(ReadBytes(position, 3, b, DAF_CACHED, rh));
	min = (b[0] >> 4) * 10 + (b[0] & 0x0f);
	sec = (b[1] >> 4) * 10 + (b[1] & 0x0f);
	fra = (b[2] >> 4) * 10 + (b[2] & 0x0f);
	address = (min * 60 + sec) * 75 + fra;
	GNRAISE_OK;
	}

////////////////////////////////////////////////////////////////////
//
//  VCD Data File Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

VCDDataFile::VCDDataFile(VCDFileSystem * vcdfs, GenericFileSystem * baseFS, EventDispatcher* pEventDispatcher)
	: VCDFile(vcdfs, baseFS, pEventDispatcher)
	{
	}

//
//  Destructor
//

VCDDataFile::~VCDDataFile(void)
	{
	}

//
//  Open data file
//

Error VCDDataFile::Open(GenericFileSystemIterator * gfsi, DWORD accessType)
	{
	RequestHandle rh;
	DriveBlock db;
	DWORD blockSize;
	BOOL found = FALSE;
	Error err;
	DWORD blk;
	DWORD i;

	GNREASSERT(VCDFile::Open(gfsi, accessType));
	GNREASSERT(gfs->GetCurrentDriveBlockSize(blockSize));

	//
	//  Compute the number of blocks in this file
	//  Note that this is a little ugly since it is a mode 2 file with blocks
	//  larger than 2K, but as it seems the file size is computed on the base of
	//  2K blocks and therefore smaller.
	//

#define ISO_BLOCK_SIZE 2048
	numBlocks = (size / ISO_BLOCK_SIZE).ToDWORD();
//	numBlocks = (size / blockSize).ToDWORD();

	//
	//  Find a header to determine whether it's PAL or not
	//

	isPAL = FALSE;
	blk = 0;

	do
		{
		blk++;
		if (!IS_ERROR(err = LockBlocks(blk, 1, &db, DAF_NONE, &rh)))
			{
			if (db.data[18] == 0x62)
				{
				found = TRUE;
				break;
				}
			}
		UnlockBlocks(blk, 1, &db, DAF_NONE, &rh);
		GNREASSERT(err);
		}
	while (blk < 16);

	//
	//  If found find header and determine PAL or not
	//

	if (found)
		{
		i = 0;
		while (i < 2044 && (db.data[i  ] != 0x00 || db.data[i+1] != 0x00 ||
			                 db.data[i+2] != 0x01 || db.data[i+3] != 0xb3)) i++;

		if (i < 2044)
			isPAL = db.data[i+6] == 0x20;

		UnlockBlocks(blk, 1, &db, DAF_NONE, &rh);
		}

	GNRAISE_OK;
	}

//
//  Build unique key
//

Error VCDDataFile::BuildUniqueKey(void)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

////////////////////////////////////////////////////////////////////
//
//  VCD Directory Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

VCDDirectory::VCDDirectory(VCDFileSystem * vcdfs, GenericFileSystem * baseFS) : GenericDirectory(vcdfs)
	{
	this->baseFS = baseFS;
	gd = NULL;
	}

//
//  Destructor
//

VCDDirectory::~VCDDirectory(void)
	{
	}

//
//  Open
//

Error VCDDirectory::Open(GenericFileSystemIterator * gfsi, DWORD accessType)
	{
	GenericDiskItem * gdi;

	GNREASSERT(baseFS->OpenItem(gfsi, accessType, gdi));
	gd = (GenericDirectory*)gdi;
	GNRAISE_OK;
	}

//
//  Close
//

Error VCDDirectory::Close(void)
	{
	if (gd)
		{
		gd->Close();
		delete gd;
		gd = NULL;
		}
	GNRAISE_OK;
	}

//
//  Get name
//

Error VCDDirectory::GetName(DiskItemName & name)
	{
	return gd->GetName(name);
	}

//
//  Get path name
//

Error VCDDirectory::GetPathName(DiskItemName & name)
	{
	return gd->GetPathName(name);
	}

//
//  Get iterator
//

Error VCDDirectory::GetIterator(GenericFileSystemIterator * & gfsi)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Flush
//

Error VCDDirectory::Flush(void)
	{
	return gd->Flush();
	}

//
//  Terminate request
//

Error VCDDirectory::TerminateRequest(RequestHandle * rh)
	{
	return gd->TerminateRequest(rh);
	}

//
//  Create item
//

Error VCDDirectory::CreateItem(DWORD diskItemType, const DiskItemName & name, GenericDiskItem * & gdi)
	{
	return gd->CreateItem(diskItemType, name, gdi);
	}

//
//  Delete item
//

Error VCDDirectory::DeleteItem(GenericFileSystemIterator * gfsi)
	{
	return gd->DeleteItem(gfsi);
	}

//
//  Return number of items
//

Error VCDDirectory::GetNumberOfItems(DWORD & num)
	{
	return gd->GetNumberOfItems(num);
	}

//
//  Find item
//

Error VCDDirectory::FindItem(const DiskItemName & name, DiskItemType type, DWORD flags, GenericFileSystemIterator * & gfsi)
	{
	return gd->FindItem(name, type, flags, gfsi);
	}

////////////////////////////////////////////////////////////////////
//
//  VCD File System Iterator Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

VCDIterator::VCDIterator(VCDFileSystem * vcdfs, GenericFileSystemIterator * gfsi) : GenericFileSystemIterator(vcdfs)
	{
	this->gfsi = gfsi;
	}

//
//  Destructor
//

VCDIterator::~VCDIterator(void)
	{
	delete gfsi;
	}

//
//  Clone
//

Error VCDIterator::Clone(GenericFileSystemIterator * & gfsi) const
	{
	VCDIterator * vcdi;

	GNREASSERT(Clone(vcdi));
	gfsi = vcdi;
	GNRAISE_OK;
	}

//
//  Clone
//

Error VCDIterator::Clone(VCDIterator * & vcdi) const
	{
	GenericFileSystemIterator * help;

	GNREASSERT(gfsi->Clone(help));
	vcdi = new VCDIterator((VCDFileSystem*)gfs, help);
	if (vcdi)
		GNRAISE_OK;
	else
		{
		delete gfsi;
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
	}

//
//  Go to first item
//

Error VCDIterator::GoToFirstItem(void)
	{
	return gfsi->GoToFirstItem();
	}

//
//  Go to next item
//

Error VCDIterator::GoToNextItem(void)
	{
	return gfsi->GoToNextItem();
	}

//
//  Go to sub dir
//

Error VCDIterator::GoToSubDir(GenericFileSystemIterator * & gfsi)
	{
	GenericFileSystemIterator * help;

	GNREASSERT(this->gfsi->GoToSubDir(help));
	gfsi = new VCDIterator((VCDFileSystem*)gfs, help);

	if (gfsi)
		GNRAISE_OK;
	else
		{
		delete help;
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
	}

//
//  Go to parent dir
//

Error VCDIterator::GoToParentDir(GenericFileSystemIterator * & gfsi)
	{
	GenericFileSystemIterator * help;

	GNREASSERT(this->gfsi->GoToSubDir(help));
	gfsi = new VCDIterator((VCDFileSystem*)gfs, help);

	if (gfsi)
		GNRAISE_OK;
	else
		{
		delete help;
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
	}

//
//  Get path name
//

Error VCDIterator::GetPathName(DiskItemName & name)
	{
	return gfsi->GetPathName(name);
	}

//
//  Get item type
//

Error VCDIterator::GetItemType(DiskItemType & type)
	{
	return gfsi->GetItemType(type);
	}

//
//  Get item name
//

Error VCDIterator::GetItemName(DiskItemName & name)
	{
	return gfsi->GetItemName(name);
	}

//
//  Get item size
//

Error VCDIterator::GetItemSize(KernelInt64 & size)
	{
	return gfsi->GetItemSize(size);
	}

//
//  Get number of items in dir
//

Error VCDIterator::GetNumberOfItems(DWORD & num)
	{
	return gfsi->GetNumberOfItems(num);
	}

//
//  Get current dir
//

Error VCDIterator::GetCurrentDir(GenericDirectory * & gd)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Open item
//

Error VCDIterator::OpenItem(DWORD accessType, GenericDiskItem * & gdi)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

////////////////////////////////////////////////////////////////////
//
//  VCD File System Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

VCDFileSystem::VCDFileSystem(EventDispatcher* pEventDispatcher)
	: GenericFileSystem()
	, EventSender(pEventDispatcher)
	{
	baseFS = NULL;
	fileSystemType = FS_VCD;
	}

//
//  Destructor
//

VCDFileSystem::~VCDFileSystem(void)
	{
	if (baseFS)
		baseFS->Release();
	}

//
//  Initialize
//  (Note that volume is ignored)
//

Error VCDFileSystem::Init(GenericFileSystemIterator * mountPoint, GenericVolume * volume, GenericProfile * profile)
	{
	GNREASSERT(((RootIterator*)mountPoint)->ObtainSubFileSystem(baseFS));
	GNREASSERT(baseFS->ObtainVolume(volume));
	Error err = GenericFileSystem::Init(mountPoint, volume, profile);
	volume->Release();
	GNRAISE(err);
	}

//
//  Create file
//

Error VCDFileSystem::CreateFile(DWORD flags, GenericFile * & gf)
	{
	if (flags & FAT_HEADER)
		gf = new VCDHeaderFile(this, baseFS, GetEventDispatcher());
	else
		gf = new VCDDataFile(this, baseFS, GetEventDispatcher());

	if (gf)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Create directory
//

Error VCDFileSystem::CreateDirectory(DWORD flags, GenericDirectory * & gd)
	{
	gd = new VCDDirectory(this, baseFS);

	if (gd)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Create iterator
//

Error VCDFileSystem::CreateIterator(GenericFileSystemIterator * & gfsi)
	{
	GenericFileSystemIterator * help;

	GNREASSERT(baseFS->CreateIterator(help));

	gfsi = new VCDIterator(this, help);
	if (gfsi)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Seek block
//

Error VCDFileSystem::SeekBlock(DWORD block, DWORD flags, RequestHandle * rh)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Lock blocks
//

Error VCDFileSystem::LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Unlock blocks
//

Error VCDFileSystem::UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Build unique key
//

Error VCDFileSystem::BuildUniqueKey(void)
	{
	VCDInfo * info = new VCDInfo();
	Error err = GNR_INVALID_UNIQUE_KEY;

	if (info)
		{
		if (!IS_ERROR(err = info->Initialize(this)))
			{
			err = info->BuildUniqueKey(uniqueKey.key);
			}

		delete info;
		}

	GNRAISE(err);
	}

//
//  Open item
//

Error VCDFileSystem::OpenItem(GenericFileSystemIterator * gfsi, DWORD accessType, GenericDiskItem * & gdi)
	{
	DiskItemType type;
	GenericFile * gf;
	GenericDirectory * gd;
	Error err;

	GNREASSERT(gfsi->GetItemType(type));
	if (type == DIT_FILE)
		{
		GNREASSERT(CreateFile(accessType, gf));
		if (IS_ERROR(err = gf->Open(((VCDIterator*)gfsi)->gfsi, accessType)))
			delete gf;
		gdi = gf;
		GNRAISE(err);
		}
	else if (type == DIT_DIR)
		{
		GNREASSERT(CreateDirectory(accessType, gd));
		if (IS_ERROR(err = gd->Open(((VCDIterator*)gfsi)->gfsi, accessType)))
			delete gd;
		gdi = gd;
		GNRAISE(err);
		}
	else
		GNRAISE(GNR_OBJECT_INVALID);
	}

//
//  Open item by name (this is here only because of the stupidity of C++)
//

Error VCDFileSystem::OpenItem(const DiskItemName & name, DWORD accessType, GenericDiskItem * & gdi)
	{
	return GenericFileSystem::OpenItem(name, accessType, gdi);
	}

//
//  Get volume name
//

Error VCDFileSystem::GetVolumeName(KernelString & name)
	{
	return baseFS->GetVolumeName(name);
	}

//
//  Get volume set name
//

Error VCDFileSystem::GetVolumeSetName(KernelString & name)
	{
	return baseFS->GetVolumeSetName(name);
	}

//
//  Get volume set index
//

Error VCDFileSystem::GetVolumeSetIndex(int & index)
	{
	return baseFS->GetVolumeSetIndex(index);
	}

//
//  Get volume set size
//

Error VCDFileSystem::GetVolumeSetSize(int & size)
	{
	return baseFS->GetVolumeSetSize(size);
	}

//
//  Set drive block size
//

Error VCDFileSystem::SetDriveBlockSize(DWORD size)
	{
	GNRAISE(GNR_OPERATION_NOT_SUPPORTED);
	}

//
//  Get number of drive blocks
//

Error VCDFileSystem::GetNumberOfDriveBlocks(DWORD & num)
	{
	return baseFS->GetNumberOfDriveBlocks(num);
	}

//
//  Set number of drive blocks
//

Error VCDFileSystem::SetNumberOfDriveBlocks(DWORD num)
	{
	return baseFS->SetNumberOfDriveBlocks(num);
	}

//
//  Terminate request
//

Error VCDFileSystem::TerminateRequest(RequestHandle * rh)
	{
	return baseFS->TerminateRequest(rh);
	}

//
//  Flush
//

Error VCDFileSystem::Flush(void)
	{
	return baseFS->Flush();
	}

//
//  Get drive name
//

Error VCDFileSystem::GetDriveName(KernelString & name)
	{
	return baseFS->GetDriveName(name);
	}

//
//  Spin up drive
//

Error VCDFileSystem::SpinUpDrive(void)
	{
	return baseFS->SpinUpDrive();
	}

//
//  Spin down drive
//

Error VCDFileSystem::SpinDownDrive(void)
	{
	return baseFS->SpinDownDrive();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\VCDDiskPlayer.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  VCDDiskPlayerClass
//
//  Implements the player interface for VCDs
//
////////////////////////////////////////////////////////////////////

#ifndef VCDDISKPLAYER_H
#define VCDDISKPLAYER_H

#include "CDDiskPlayer.h"
#include "VCDSelSeq.h"

#pragma warning(disable : 4250)

class VCDDiskPlayerClass : public CDDiskPlayerClass, protected VCDSelectionListSequencer
	{
	protected:
		VCDInfo		*	info;
		VCDEntries	*	entries;
		VCDPSD		*	psd;

		virtual Error InternalGetMode(DVDPlayerMode & mode);
		virtual Error IsPlayingForward(BOOL & forward);

		//
		//  Freezing stuff
		//

		struct VCDDPCFreezeState
			{
			BYTE					uniqueKey[8];
			VCDSLSFreezeState	vcdSLSState;
			};

	public:
		VCDDiskPlayerClass(WinPortServer * server, UnitSet units);

		~VCDDiskPlayerClass(void);

		virtual Error Init(WinPortServer * server, GenericProfile * profile, DVDDiskType diskType, VCDFileSystem * vcdfs);

		virtual Error GetDiskType(DVDDiskType & type);

		virtual Error GetMode(DVDPlayerMode & mode);

		virtual Error GetExtendedPlayerState(ExtendedPlayerState * eps);

		virtual Error StopStillPhase(void);

		virtual Error Exit(Error err = GNR_OK);

		virtual Error CallMenu(VTSMenuType menu);

		virtual Error PausePlayback(void);

		virtual Error ResumePlayback(void);

		virtual Error AdvanceFrame(void);

		virtual Error AdvanceFrameBy(int n);

		virtual Error SetPlaybackSpeed(WORD speed);

		virtual Error GetPlaybackSpeed(WORD & speed);

		virtual Error GetAudioStreamAttributes(WORD stream, DVDAudioStreamFormat	& attributes);

		virtual Error GetSubPictureStreamAttributes(WORD stream, DVDSubPictureStreamFormat	& attributes);

		virtual Error StartPresentation(DWORD flags);

		virtual Error GetCurrentLocation(DVDLocation & location);

		virtual Error GetCurrentDuration(DVDLocation & location);

		virtual Error GetTitleDuration(WORD title, DVDTime & duration);

		virtual Error MenuAvail(VTSMenuType menu, BOOL & avail);

		virtual Error GetUOPs(DWORD & uops);

		virtual Error UOPPermitted(int uops, BOOL & permitted);

		virtual Error NumberOfTitles(WORD & num);

		virtual Error NumberOfPartOfTitle(WORD title, WORD & num);

		virtual Error GetAvailStreams(BYTE & audio, DWORD & subPicture);

		virtual Error GetCurrentAudioStream(WORD & stream);

		virtual Error GetCurrentSubPictureStream(WORD & stream);

		virtual Error IsCurrentSubPictureEnabled(BOOL & enabled);

		virtual Error GetNumberOfAngles(WORD title, WORD & num);

		virtual Error GetCurrentAngle(WORD & angle);

		virtual Error GoTitle(WORD title, DWORD flags = DDPSPF_NONE);

		virtual Error GoPartOfTitle(WORD title, WORD part);

		virtual Error TimePlay(WORD title, DVDTime time);

		virtual Error GoUpProgramChain(void);

		virtual Error TimeSearch(DVDTime time);

		virtual Error GoPartOfTitle(WORD part);

		virtual Error GoPrevProgram(void);

		virtual Error GoTopProgram(void);

		virtual Error GoNextProgram(void);

		virtual Error ExtendedPlay(DWORD flags, WORD title, WORD ptt, DVDTime time);

		virtual Error StartForwardScan(WORD speed);

		virtual Error StartBackwardScan(WORD speed);

		virtual Error GetScanSpeed(WORD & speed);

		virtual Error StopScan(void);

		virtual Error StartReversePlayback(void);

		virtual Error StartTrickplay(void);

		virtual Error ResumeFromSystemSpace(void);

		virtual Error ButtonUp(void);

		virtual Error ButtonDown(void);

		virtual Error ButtonLeft(void);

		virtual Error ButtonRight(void);

		virtual Error ButtonSelectAt(WORD x, WORD y);

		virtual Error ButtonActivate(void);

		virtual Error ButtonSelectAndActivate(WORD button);

		virtual Error ButtonSelectAtAndActivate(WORD x, WORD y);

		virtual Error IsButtonAt(WORD x, WORD y, BOOL & isButton);

		virtual Error HasPositionalButtons(BOOL & hasButtons);

		virtual Error MenuLanguageSelect(WORD language);

		virtual Error GetMenuLanguage(WORD & language);

		virtual Error AudioStreamChange(WORD stream);

		virtual Error SubPictureStreamChange(WORD stream, BOOL enable);

		virtual Error AngleChange(WORD angle);

		virtual Error ParentalLevelSelect(WORD level);

		virtual Error ParentalCountrySelect(WORD country);

		virtual Error GetCurrentDisplayMode(DisplayPresentationMode & mode);

		virtual Error SetDisplayMode(DisplayPresentationMode mode);

		virtual Error GetCurrentVideoStandard(VideoStandard & standard);

		virtual Error SelectInitialLanguage(WORD audioLanguage, WORD audioExtension, WORD subPictureLanguage, WORD subPictureExtension);

		virtual Error GetCurrentBitrate(DWORD & bitrate);

		virtual Error GetCurrentButtonState(WORD & minButton, WORD & numButtons, WORD & currentButton);

		virtual Error Freeze (BYTE * buffer, DWORD & size);

		virtual Error Defrost(BYTE * buffer, DWORD & size, DWORD flags);

		virtual Error SetBreakpoint(WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id);

		virtual Error ClearBreakpoint(DWORD id);
	};

#pragma warning(default : 4250)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\VCDHeader.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
// VCD Header Classes
//
////////////////////////////////////////////////////////////////////

#include "Library/Common/Prelude.h"
#include "VCDHeader.h"

////////////////////////////////////////////////////////////////////
//
//  VCD Info Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

VCDInfo::VCDInfo(void) : VCDHeader()
	{
	}

//
//  Initialize
//

Error VCDInfo::Initialize(VCDFileSystem * vcdfs)
	{
	Error error = GNR_OK;

	//
	// check for Video CD
	//
	error = VCDHeader::Initialize(vcdfs, "vcd\\info.vcd");
	if(IS_ERROR(error))
		{
		//
		// check for Super-Video CD
		//
		error = VCDHeader::Initialize(vcdfs, "svcd\\info.svd");
		if(IS_ERROR(error))
			{
			//
			// again check for Super-Video CD (some chinese Super-VCDs seem to ignore the S-VCD system specification and
			// have their own directory (\\hqvcd\\ instead of \\svcd\\)!
			//
			error = VCDHeader::Initialize(vcdfs, "hqvcd\\info.vcd");
			if(IS_ERROR(error))
				{
				GenericFileSystemIterator * root;
				GenericFileSystemIterator * result;

				GNREASSERT(vcdfs->CreateIterator(root));
				error = vcdfs->FindItem("mpegav\\music01.dat", DIT_FILE, FIF_NONE, root, result);
				delete root;
				delete result;
				}
			}
		}

	GNRAISE(error);
	}

//
// Function: IsVideoCD
//
//	Returns TRUE if a Video-CD is used or FALSE if a Super-Video-CD is used.
//	The detection is done with byte 1 to 8 from the info.vcd (info.svd) file. These
//	bytes contain the system identification ("VIDEO_CD", "SUPERVCD", or "HQ-VCD  ").
//

BOOL VCDInfo::IsVideoCD(void)
	{
	DWORD lowBytes;

	if (file)
		{
		file->ReadDWord(0, lowBytes, &rh);

		//
		// only check the first four letters. This should be enough
		// 0x56 - 'V'	0x49 - 'I'	0x44 - 'D'	0x45 - 'E'
		//

		if (XTBF(0, 8, lowBytes) == 0x45 && XTBF(8, 8, lowBytes) == 0x44
			&& XTBF(16, 8, lowBytes) == 0x49 && XTBF(24, 8, lowBytes) == 0x56)
			{
			//
			// Video-CD
			//

			return TRUE;
			}
		else
			//
			// no Video-CD, so we assume Super-Video CD
			//

			return FALSE;
		}
	else
		//
		// default value is Video-CD
		//

		return TRUE;
	}

WORD VCDInfo::NumberOfVolumes(void)
	{
	WORD w;

	if (file)
		file->ReadWord(26, w, &rh);
	else
		w = 1;

	return w;
	}

WORD VCDInfo::CurrentVolumeNumber(void)
	{
	WORD w;

	if (file)
		file->ReadWord(28, w, &rh);
	else
		w = 0;

	return w;
	}

BOOL VCDInfo::IsPALTrack(int track)
	{
	BYTE b;

	if (file)
		{
		track -= 2;

		file->ReadByte(30 + track / 8, b, &rh);

		return XTBF(track & 7, b);
		}
	else
		return FALSE;
	}

BOOL VCDInfo::KarinfoPresent(void)
	{
	BYTE b;

	if (file)
		{
		file->ReadByte(43, b, &rh);

		return XTBF(0, b);
		}
	else
		return FALSE;
	}

BOOL VCDInfo::HasClosedCaption(void)
	{
	BYTE b;

	if (file)
		{
		file->ReadByte(43, b, &rh);

		return XTBF(4, b);
		}
	else
		return FALSE;
	}

BOOL VCDInfo::StartNextWithID2(void)
	{
	BYTE b;

	if (file)
		{
		file->ReadByte(43, b, &rh);

		return XTBF(5, b);
		}
	else
		return FALSE;
	}

BOOL VCDInfo::StartNextWithTrack3(void)
	{
	BYTE b;

	if (file)
		{
		file->ReadByte(43, b, &rh);

		return XTBF(6, b);
		}
	else
		return FALSE;
	}

BOOL VCDInfo::HasPSDX(void)
	{
	BYTE b;

	if (file)
		{
		file->ReadByte(43, b, &rh);

		return XTBF(7, b);
		}
	else
		return FALSE;
	}

int VCDInfo::OffsetMultiplier(void)
	{
	BYTE b;

	if (file)
		file->ReadByte(51, b, &rh);
	else
		b = 1;

	return b;
	}

int VCDInfo::MaximumListID(void)
	{
	WORD w;

	if (file)
		file->ReadWord(52, w, &rh);
	else
		w = 0;

	return w;
	}

int VCDInfo::MaximumSegmentNumber(void)
	{
	WORD w;

	if (file)
		file->ReadWord(54, w, &rh);
	else
		w = 0;

	return w;
	}

SegPlayItemContent VCDInfo::GetSegPlayItemContent(int item)
	{
	BYTE b;

	if (file)
		file->ReadByte(55 + item, b, &rh);
	else
		b = 0;

	return SegPlayItemContent(b, IsVideoCD());
	}

Error VCDInfo::BuildUniqueKey(BYTE * key)
	{
	int i;

	if (file)
		return file->GetUniqueKey(key);
	else
		{
		for (i=0; i<8; i++)
			key[i] = 0;
		GNRAISE_OK;
		}
	}

////////////////////////////////////////////////////////////////////
//
//  VCD Entries Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

VCDEntries::VCDEntries(void) : VCDHeader()
	{
	}

//
//  Initialize
//

Error VCDEntries::Initialize(VCDFileSystem * vcdfs, DVDDiskType diskType)
	{
	Error err;
	DiskItemName name;

	//
	// check for Video-CD entries file
	//

	switch (diskType)
		{
		case DDT_VIDEO_CD:
			//
			//  Check if entries.vcd can be found
			//

			isSvcdStd = FALSE;
			if (IS_ERROR(err = VCDHeader::Initialize(vcdfs, "vcd\\entries.vcd")))
				{
				GenericFileSystemIterator * root;
				GenericFileSystemIterator * result;

				//
				//  If there is no entries.vcd, then look if there are just track files (Yamaha crap)
				//

				GNREASSERT(vcdfs->CreateIterator(root));
				numTracks = 0;
				name = KernelString("mpegav\\music") +	KernelString(numTracks + 1, 2) + KernelString(".dat");

				while (!IS_ERROR(vcdfs->FindItem(name, DIT_FILE, FIF_NONE, root, result)))
					{
					delete result;
					numTracks++;
					}
				delete root;

				if (numTracks)
					err = GNR_OK;
				}
			break;
		case DDT_SUPER_VIDEO_CD:
			//
			//  Check for Super-Video CD entries file
			//

			if(!IS_ERROR(err = VCDHeader::Initialize(vcdfs, "svcd\\entries.svd")))
				{
				isSvcdStd = TRUE;
				}
			else
				{
				if (!IS_ERROR(err = VCDHeader::Initialize(vcdfs, "hqvcd\\entries.vcd")))
					{
					isSvcdStd = FALSE;
					}
				}
			break;
		default:
			err = GNR_INVALID_PARAMETERS;
		}

	GNRAISE(err);
	}

//
//	 returns TRUE if the disc follows the S-VCD standard, else returns FALSE (e.g. CVDs)
//

BOOL VCDEntries::IsSVCDStandard(void)
	{
	return isSvcdStd;
	}

WORD VCDEntries::EntriesUsed(void)
	{
	WORD w;

	if (file)
		file->ReadWord(10, w, &rh);
	else
		w = (WORD)numTracks;


	return w;
	}

WORD VCDEntries::GetEntryTrack(int entry)
	{
	BYTE b;

	if (file)
		{
		file->ReadByte(12 + 4 * (entry - 1), b, &rh);

		b = (b >> 4) * 10 + (b & 0x0f);
		}
	else
		b = entry + 1;

	return b;
	}

DWORD VCDEntries::GetEntrySector(int entry)
	{
	DWORD a;

	if (file)
		{
		if (!IS_ERROR(file->ReadSectorAddress(13 + 4 * (entry - 1), a, &rh)))
			return a;
		}

	return 0;
	}

////////////////////////////////////////////////////////////////////
//
//  Playlist Class
//
////////////////////////////////////////////////////////////////////

int VCDPlayList::NumberOfItems(void)
	{
	BYTE b;

	file->ReadByte(offset + 1, b, &rh);

	return b;
	}

WORD VCDPlayList::ListID(void)
	{
	WORD w;

	file->ReadWord(offset + 2, w, &rh);

	return w;
	}

WORD VCDPlayList::PreviousListOffset(void)
	{
	WORD w;

	file->ReadWord(offset + 4, w, &rh);

	return w;
	}

WORD VCDPlayList::NextListOffset(void)
	{
	WORD w;

	file->ReadWord(offset + 6, w, &rh);

	return w;
	}

WORD VCDPlayList::ReturnListOffset(void)
	{
	WORD w;

	file->ReadWord(offset + 8, w, &rh);

	return w;
	}

DWORD VCDPlayList::PlayingTime(void)
	{
	WORD w;

	file->ReadWord(offset + 10, w, &rh);

	return (DWORD)w * 5;
	}

static WORD TranslateWaitTime(BYTE b)
	{
	if (b <= 60)
		return b;
	else if (b < 254)
		return (WORD)(b - 60) * 10 + 60;
	else if (b == 254)
		return 2000;
	else
		return 65535;
	}

WORD VCDPlayList::PlayItemWaitTime(void)
	{
	BYTE b;

	file->ReadByte(offset + 12, b, &rh);

	return TranslateWaitTime(b);
	}

WORD VCDPlayList::AutoPauseWaitTime(void)
	{
	BYTE b;

	file->ReadByte(offset + 13, b, &rh);

	return TranslateWaitTime(b);
	}

WORD VCDPlayList::PlayItemNumber(int item)
	{
	WORD w;

	file->ReadWord(offset + 14 + 2 * (item - 1), w, &rh);

	return w;
	}

////////////////////////////////////////////////////////////////////
//
//  Selection List Class
//
////////////////////////////////////////////////////////////////////

int VCDSelectionList::NumberOfSelections(void)
	{
	BYTE b;

	file->ReadByte(offset + 2, b, &rh);

	return b;
	}

WORD VCDSelectionList::BaseOfSelectionNumber(void)
	{
	BYTE b;

	file->ReadByte(offset + 3, b, &rh);

	return b;
	}

WORD VCDSelectionList::ListID(void)
	{
	WORD w;

	file->ReadWord(offset + 4, w, &rh);

	return w;
	}

WORD VCDSelectionList::PreviousListOffset(void)
	{
	WORD w;

	file->ReadWord(offset + 6, w, &rh);

	return w;
	}

WORD VCDSelectionList::NextListOffset(void)
	{
	WORD w;

	file->ReadWord(offset + 8, w, &rh);

	return w;
	}

WORD VCDSelectionList::ReturnListOffset(void)
	{
	WORD w;

	file->ReadWord(offset + 10, w, &rh);

	return w;
	}

WORD VCDSelectionList::DefaultListOffset(void)
	{
	WORD w;

	file->ReadWord(offset + 12, w, &rh);

	return w;
	}

WORD VCDSelectionList::TimeOutListOffset(void)
	{
	WORD w;

	file->ReadWord(offset + 14, w, &rh);

	return w;
	}

WORD VCDSelectionList::TimeOutTime(void)
	{
	BYTE b;

	file->ReadByte(offset + 16, b, &rh);

	return TranslateWaitTime(b);
	}

WORD VCDSelectionList::LoopCount(void)
	{
	BYTE b;

	file->ReadByte(offset + 17, b, &rh);

	return b & 0x7f;
	}

BOOL VCDSelectionList::JumpTiming(void)
	{
	BYTE b;

	file->ReadByte(offset + 17, b, &rh);

	return XTBF(7, b);
	}

WORD VCDSelectionList::PlayItemNumber(void)
	{
	WORD w;

	file->ReadWord(offset + 18, w, &rh);

	return w;
	}

WORD VCDSelectionList::SelectionOffset(int item)
	{
	WORD w;

	file->ReadWord(offset + 20 + 2 * (item - BaseOfSelectionNumber()), w, &rh);

	return w;
	}

DWORD VCDSelectionList::PreviousListSelectionArea(void) {return 0;}
DWORD VCDSelectionList::NextListSelectionArea(void) {return 0;}
DWORD VCDSelectionList::ReturnListSelectionArea(void) {return 0;}
DWORD VCDSelectionList::DefaultListSelectionArea(void) {return 0;}
DWORD VCDSelectionList::SelectionArea(int item) {return 0;}

////////////////////////////////////////////////////////////////////
//
//  Extended Selection List Class
//
////////////////////////////////////////////////////////////////////

DWORD VCDSelectionListX::PreviousListSelectionArea(void)
	{
	DWORD d;

	file->ReadDWord(offset + 20 + 2 * (NumberOfSelections()) + 0, d, &rh);

	return d;
	}

DWORD VCDSelectionListX::NextListSelectionArea(void)
	{
	DWORD d;

	file->ReadDWord(offset + 20 + 2 * (NumberOfSelections()) + 4, d, &rh);

	return d;
	}

DWORD VCDSelectionListX::ReturnListSelectionArea(void)
	{
	DWORD d;

	file->ReadDWord(offset + 20 + 2 * (NumberOfSelections()) + 8, d, &rh);

	return d;
	}

DWORD VCDSelectionListX::DefaultListSelectionArea(void)
	{
	DWORD d;

	file->ReadDWord(offset + 20 + 2 * (NumberOfSelections()) + 12, d, &rh);

	return d;
	}

DWORD VCDSelectionListX::SelectionArea(int item)
	{
	DWORD d;

	file->ReadDWord(offset + 20 + 2 * (NumberOfSelections()) + 16 + 4 * (item - BaseOfSelectionNumber()), d, &rh);

	return d;
	}

////////////////////////////////////////////////////////////////////
//
//  VCD PSD Class
//
////////////////////////////////////////////////////////////////////

VCDSelectionList * VCDPSD::GetSelectionList(WORD offset)
	{
	return new VCDSelectionList(this, offset);
	}

VCDPlayList * VCDPSD::GetPlayList(WORD offset)
	{
	return new VCDPlayList(this, offset);
	}

Error VCDPSD::Initialize(VCDFileSystem * vcdfs)
	{
	Error error = GNR_OK;

	//
	// check for Video CD Play Sequence Descriptor file
	//
	error = VCDHeader::Initialize(vcdfs, "vcd\\psd.vcd");
	if(IS_ERROR(error))
		{
		//
		// check for Super-Video CD Play Sequence Descriptor file
		//
		error = VCDHeader::Initialize(vcdfs, "svcd\\psd.svd");
		if(IS_ERROR(error))
			{
			error = VCDHeader::Initialize(vcdfs, "hqvcd\\psd.vcd");
			}
		}

	GNRAISE(error);
	}

Error VCDPSD::Initialize(VCDFileSystem * vcdfs, KernelString name)
	{
	GNRAISE(VCDHeader::Initialize(vcdfs, name));
	}

Error VCDPSD::InitializeExtended(VCDFileSystem * vcdfs)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

BOOL VCDPSD::IsPlayList(WORD offset)
	{
	BYTE b;

	file->ReadByte(offset, b, &rh);

	return b == 0x10;
	}

BOOL VCDPSD::IsSelectionList(WORD offset)
	{
	BYTE b;

	file->ReadByte(offset, b, &rh);

	return b == 0x18;
	}

BOOL VCDPSD::IsEndList(WORD offset)
	{
	BYTE b;

	file->ReadByte(offset, b, &rh);

	return b == 0x1f;
	}

////////////////////////////////////////////////////////////////////
//
//  Extended VCD PSD Class
//
////////////////////////////////////////////////////////////////////

VCDSelectionList * VCDPSDX::GetSelectionList(WORD offset)
	{
	BYTE b;

	file->ReadByte(offset, b, &rh);

	if (b == 0x1a)
		return new VCDSelectionListX(this, offset);
	else if (b == 0x18)
		return new VCDSelectionList(this, offset);
	else
		return NULL;
	}

Error VCDPSDX::InitializeExtended(VCDFileSystem * vcdfs)
	{
	GNRAISE(VCDPSD::Initialize(vcdfs, "ext\\psd_x.vcd"));
	}

BOOL VCDPSDX::IsSelectionList(WORD offset)
	{
	BYTE b;

	file->ReadByte(offset, b, &rh);

	return b == 0x1a || b == 0x18;
	}

////////////////////////////////////////////////////////////////////
//
//  VCD LOT Class
//
////////////////////////////////////////////////////////////////////

WORD VCDLOT::ListOffset(int listID)
	{
	WORD w;

	file->ReadWord(listID * 2, w, &rh);

	return w;
	}

////////////////////////////////////////////////////////////////////
//
//  VCD Tracks Class
//
////////////////////////////////////////////////////////////////////

Error VCDTracks::Initialize(VCDFileSystem * vcdfs)
	{
	DiskItemName name;
	GenericFileSystemIterator * root;
	GenericFileSystemIterator * result;
	Error error = GNR_OK;

	//
	// check for Super Video CD Tracks file
	// (only available on S-VCDs not on VCDs, see specification for
	//	more details)
	//
	error = VCDHeader::Initialize(vcdfs, "svcd\\tracks.svd");

	if(!IS_ERROR(error))
		{
		numberOfMpegTracks = GetNumberOfMPEGTracks();

		playingTimeOffset = 11;
		contentByteOffset = 11 + 3 * numberOfMpegTracks;
		}
	else	// No tracks.svd file was found.
		{
		numberOfMpegTracks = 1;
		GNREASSERT(vcdfs->CreateIterator(root));

		do
			{
			name = KernelString("mpeg2\\avseq") + KernelString(numberOfMpegTracks + 1, 2) + KernelString(".mpg");
			if (!IS_ERROR(error = vcdfs->FindItem(name, DIT_FILE, FIF_NONE, root, result)))
				{
				numberOfMpegTracks++;
				delete result;
				}
			}
		while (!IS_ERROR(error));
		delete root;
		}

	GNRAISE(error);
	}

WORD VCDTracks::GetNumberOfMPEGTracks(void)
	{
	BYTE b;

	//
	// read number of MPEG tracks
	//
	if (file)
		file->ReadByte(10, b, &rh);
	else
		b = 0;

	return b;
	}

TrackContent VCDTracks::GetTrackContent(int track)
	{
	BYTE b;

	if (file)
		file->ReadByte(contentByteOffset + (track - 1), b, &rh);
	else
		b = 0;

	return TrackContent(b);
	}

BOOL VCDTracks::IsDualAudioStream(WORD track)
	{
	BYTE b;

	if (file)
		file->ReadByte(contentByteOffset + (track - 1), b, &rh);
	else
		b = 0;

	return ((b & 0x03) == 0x2);
	}

BOOL VCDTracks::IsMultiChannelAudioTrack(WORD track)
	{
	BYTE b;

	if (file)
		file->ReadByte(contentByteOffset + (track - 1), b, &rh);
	else
		b = 0;

	return ((b & 0x03) == 0x3);
	}

DWORD VCDTracks::TrackPlayingTime(DWORD track)
	{
	DWORD offset;
	BYTE minutes, seconds;

	if (file)
		{
		offset = playingTimeOffset + 3 * (track - 1);
		file->ReadByte(offset, minutes, &rh);
		file->ReadByte(offset+1, seconds, &rh);
		minutes = ((minutes / 16) * 10) + (minutes % 16);
		seconds = ((seconds / 16) * 10) + (seconds % 16);
		}
	else
		minutes = seconds = 0;

	return minutes * 60 + seconds;
	}

////////////////////////////////////////////////////////////////////
//
//  VCDSearch Class
//
////////////////////////////////////////////////////////////////////

Error VCDSearch::Initialize(VCDFileSystem * vcdfs)
	{
	Error error = GNR_OK;

	//
	// check for Super Video CD Search file
	// (only available on S-VCDs not on VCDs, see specification for
	//	more details)
	//
	error = VCDHeader::Initialize(vcdfs, "svcd\\search.dat");
	if (!IS_ERROR(error))
		{
		if (file)
			file->ReadWord(10, numberOfScanPoints, &rh);
		else
			numberOfScanPoints = 0;
		}

	GNRAISE(error);
	}

//
// Function:
//		GetSectorAddress
// Parameter:
//		time: time in seconds
//	Return Value:
//		Sector address. If the function fails it returns zero.
// Description:
//		Returns the sector address for the given time or zero if the
//		function fails.
//
DWORD VCDSearch::GetSectorAddress(int time)
	{
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\VCDPlayer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  VCD Player Class
//
////////////////////////////////////////////////////////////////////

#include "VCDPlayer.h"
#include "Library/Common/vddebug.h"

#define REFILL_MSG		0x1000
#define SIGNAL_MSG		0x1001
#define ERROR_MSG			0x1002
#define DONE_MSG			0x1003

//
//  Constructor
//

VCDPlayer::VCDPlayer(WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher) : WinPortWorkerThread(server, THREAD_PRIORITY_HIGHEST)
	, EventSender(pEventDispatcher)
	{
	this->units = units;
	}

//
//  Destructor
//

VCDPlayer::~VCDPlayer(void)
	{
	VDR_PassivateUnits(decUnits);

	VDR_RemoveMPEGWinHooks(units);

	VDR_CloseUnits(decUnits);

	TerminateWorker();
	}

//
//  Initialize
//

Error VCDPlayer::Init(void)
	{
	VDR_OpenSubUnits(units, MPEG_DECODER_UNIT, decUnits);

	callback = NULL;

	vidStandard = VCDVID_UNKNOWN;   // this value ensures complete computation of video attributes
	videoCodingStandard = VCDCDS_UNKNOWN;
	audioCodingStandard = VCDCDS_UNKNOWN;
	audioStreamID = 0;

	transferCount = 0;

	playbackSpeed = 1000;
	paused = FALSE;

	VDR_InstallMessagePort(units, GetPort());
	VDR_ConfigureUnitsTags(units, SET_MPEG2_REFILL_MSG(REFILL_MSG),
		                           SET_MPEG2_SIGNAL_MSG(SIGNAL_MSG),
											SET_MPEG2_DONE_MSG(DONE_MSG),
											SET_MPEG2_ERROR_MSG(ERROR_MSG),
											TAGDONE);

	VDR_ConfigureUnitsTags(units, //SET_MPEG_AUDIO_MUTE(FALSE),
	                              SET_MPEG2_DVD_STREAM_DEMUX(FALSE),
											SET_MPEG2_CODING_STANDARD(FALSE),
										   SET_ENC_COPY_PROTECTION(0),
	                              TAGDONE);

	VDR_ConfigureUnitsTags(decUnits, SET_MPEG2_SPU_ENABLE(FALSE),
												SET_MPEG2_DVD_STREAM_ENCRYPTED(FALSE),

												SET_MPEG_VIDEO_BITRATE(1151929),
												SET_MPEG_STREAM_BITRATE(1377600),
												SET_MPEG_VIDEO_STREAMID(0xe0),

 												SET_MPEG_VIDEO_WIDTH(352),
 												SET_MPEG_VIDEO_HEIGHT(240),
 												SET_MPEG_VIDEO_FPS(29970),
 												SET_MPEG_ASPECT_RATIO(256),
	                                 SET_MPEG_STREAM_TYPE(multiplexed),
 												SET_MPEG_VIDEOSTANDARD(VSTD_NTSC),
 												SET_MPEG2_PRESENTATION_MODE(MPM_FULLSIZE),

												SET_MPEG_AUDIO_BITRATE(175000),
												SET_MPEG_AUDIO_SAMPLERATE(44100),
												SET_MPEG_AUDIO_STREAMID(0xc0),
												SET_MPEG2_AUDIO_AC3(FALSE),
												SET_MPEG2_AUDIO_LPCM(FALSE),

												SET_MPEG2_LPCM_BITSPERSAMPLE(16),
												SET_MPEG2_LPCM_CHANNELS(2),

												SET_MPEG2_POSITION_SCALE(MP2SR_SCALE_BYTES),

												SET_MPEG2_AUDIO_TYPE(MP2AUDTYP_MPEG),
												SET_MPEG_AUDIO_LAYER(MPAUDLAYER_1),
												TAGDONE);

	scanning = FALSE;
	GNRAISE_OK;
	}

//
//  Terminate Playback
//

void VCDPlayer::TerminatePlayback(void)
	{
	VDR_PassivateUnits(decUnits);
	}

//
//  Request a refill
//

void VCDPlayer::RequestRefill(void)
	{
	SendWorkMessage(REFILL_MSG, 0);
	}

//
//  Process decoder messages
//

void VCDPlayer::WorkMessage(WPARAM wParam, LPARAM dParam)
	{
	VCDStreamServer * cb = callback;

	switch (wParam)
		{
		case REFILL_MSG:
			if (refiller)
				refiller->PerformTransfer(64);
			VDR_CompleteMPEGRefillMessage(units);
			break;
		case SIGNAL_MSG:
			DP("Get Callback %d %d", dParam, transferCount);
			if (cb)
				{
				if (dParam < (LPARAM)transferCount)
					{
					if (dParam >= (LPARAM)callbackPosition)
						{
						callback = NULL;
						cb->PlayerCallback(dParam);
						}
					}
				}
			break;
		case DONE_MSG:
			DP("Got done message");
			if (cb)
				{
				DP("As expected");
				callback = NULL;
				cb->PlayerCallback(0xffffffff);
				}
			else
				DP("Unexpected!!!!");
			break;
		}
	}

//
//  Pause playback
//

Error VCDPlayer::Pause(void)
	{
	if (!paused)
		{
		if (VDR_CurrentMPEGState(units) == mps_playing)
			{
//			GNREASSERT(VDR_SendMPEGCommand(units, mpc_freeze, 0, tag));
			GNREASSERT(VDR_DoMPEGCommand(units, mpc_freeze, 0));
			}

		// note that this could lead to an error! If we are not in a playing state
		// we don't send the pause command to the decoder but we set the paused flag
		// to TRUE!!! Probably it has to be modified (for now it doesn't seem to
		// produce an error). mst 07/05/2000
		paused = TRUE;
		}

	GNRAISE_OK;
	}

//
//  Resume playback
//

Error VCDPlayer::Resume(void)
	{
	if (paused)
		{
		if (VDR_CurrentMPEGState(units) == mps_frozen)
			{
			GNREASSERT(VDR_DoMPEGCommand(units, mpc_play, playbackSpeed));
			}

		paused = FALSE;
		}

	GNRAISE_OK;
	}

//
//  Step one frame
//

Error VCDPlayer::Step(void)
	{
	DWORD tag;

	if (VDR_CurrentMPEGState(units) == mps_frozen)
		return VDR_SendMPEGCommand(units, mpc_step, 1, tag);
	else
		GNRAISE(GNR_OPERATION_PROHIBITED);
	}

//
//  Set playback speed
//

Error VCDPlayer::SetPlaybackSpeed(WORD speed)
	{
	if (speed > 2000) speed = 2000;
	else if (speed < 50) speed = 50;

	if (speed != playbackSpeed)
		{
		playbackSpeed = speed;
		SendEvent(DNE_PLAYBACK_SPEED_CHANGE, playbackSpeed);

		if (VDR_CurrentMPEGState(units) == mps_playing ||
			 VDR_CurrentMPEGState(units) == mps_resyncing)
			return VDR_DoMPEGCommand(units, mpc_play, playbackSpeed);
		else
			GNRAISE_OK;
		}
	else
		GNRAISE_OK;
	}

//
//  Test if player (decoder) is paused
//

BOOL VCDPlayer::IsPaused(void)
	{
	MPEGState state = VDR_CurrentMPEGState(units);
	return  state == mps_frozen || state == mps_stepping;
	}

//
//  Test if player (decoder) is preempted
//

BOOL VCDPlayer::IsPreempted(void)
	{
	return VDR_CurrentMPEGState(units) == mps_preempted;
	}

//
//   Test if decoder supports hires stills
//

BOOL VCDPlayer::SupportsHiResStills(void)
	{
	BOOL does = FALSE;

	GNREASSERT(VDR_ConfigureUnitsTags(units, GET_MPEG_SUPPORTS_HIRES_STILL(does), TAGDONE));

	return does;
	}

//
//  Set audio stream channel
//

Error VCDPlayer::SetAudioStreamChannel(WORD audStrID)
	{
	DWORD tag;
	Error error = GNR_OK;

	if ((audStrID == 0 || audStrID == 1) && (audStrID != audioStreamID))
		{
		audioStreamID = audStrID;

		GNREASSERT(VDR_DoMPEGCommand(units, mpc_seekaudio, 0));

		error = VDR_ConfigureUnitsTags(units, SET_MPEG_AUDIO_STREAMID(0xc0 | audioStreamID),
											TAGDONE);

		GNREASSERT(VDR_SendMPEGCommand(units, mpc_resyncaudio, 0, tag));
		}

	GNRAISE(error);
	}

//
//  Get audio stream channel
//

WORD VCDPlayer::GetAudioStreamChannel(void)
	{
	return audioStreamID;
	}

//
//  Set stream attributes
//

Error VCDPlayer::SetStreamAttributes(BOOL pal, BOOL mpeg1CodingStandard, BOOL mpeg1Audio)
	{
	DWORD tag;
	VCDVideoStandard vstd = pal ? VCDVID_PAL : VCDVID_NTSC;
	VCDCodingStandard cdstd = mpeg1CodingStandard ? VCDCDS_MPEG1 : VCDCDS_MPEG2;
	VCDCodingStandard audCodStd = mpeg1Audio ? VCDCDS_MPEG1 : VCDCDS_MPEG2;

	if (vstd != vidStandard || cdstd != videoCodingStandard || audCodStd != audioCodingStandard)
		{
		vidStandard = vstd;
		videoCodingStandard = cdstd;
		audioCodingStandard = audCodStd;

		if (vstd != vidStandard)
			SendEvent(DNE_VIDEO_STANDARD_CHANGE, pal ? VSTD_PAL : VSTD_NTSC);

		GNREASSERT(VDR_PassivateUnits(decUnits));

		if (mpeg1CodingStandard)
			{
			//
			// configure tags for Video-CD
			//

			VDR_ConfigureUnitsTags(units,
				                     SET_MPEG2_DVD_STREAM_DEMUX(FALSE),
											SET_MPEG2_CODING_STANDARD(FALSE),
							            TAGDONE);
			}
		else
			{
			//
			// configure tags for Super-Video CD
			//

			VDR_ConfigureUnitsTags(units,
											SET_MPEG2_DVD_STREAM_DEMUX(FALSE),
											SET_MPEG2_CODING_STANDARD(TRUE),
										   TAGDONE);
			}

		if (mpeg1Audio)
			{
			VDR_ConfigureUnitsTags(units, SET_MPEG_AUDIO_BITRATE(175000),
												SET_MPEG_AUDIO_SAMPLERATE(44100),
												SET_MPEG2_LPCM_BITSPERSAMPLE(16),
												SET_MPEG2_AUDIO_TYPE(MP2AUDTYP_MPEG),
												TAGDONE);
			}
		else	// MPEG-2 Audio
			{
			VDR_ConfigureUnitsTags(units, SET_MPEG_AUDIO_BITRATE(500000),
												SET_MPEG_AUDIO_SAMPLERATE(44100),
												SET_MPEG2_LPCM_BITSPERSAMPLE(16),
												SET_MPEG2_AUDIO_TYPE(MP2AUDTYP_MPEG2),
												TAGDONE);
			}

		if (pal)
			{
			GNREASSERT(VDR_ConfigureUnitsTags(units,
															SET_PIP_VIDEOSTANDARD(VSTD_PAL),
															SET_VID_VIDEOSTANDARD(VSTD_PAL),
															SET_MPEG_VIDEO_WIDTH(352),
															SET_MPEG_VIDEO_HEIGHT(288),
															SET_MPEG_VIDEO_FPS(25000),
															SET_MPEG_ASPECT_RATIO(0x111),
															SET_MPEG_VIDEOSTANDARD(VSTD_PAL),
															TAGDONE));
			}
		else
			{
			GNREASSERT(VDR_ConfigureUnitsTags(units,
															SET_PIP_VIDEOSTANDARD(VSTD_NTSC),
															SET_VID_VIDEOSTANDARD(VSTD_NTSC),
															SET_MPEG_VIDEO_WIDTH(352),
															SET_MPEG_VIDEO_HEIGHT(240),
															SET_MPEG_VIDEO_FPS(29970),
															SET_MPEG_ASPECT_RATIO(0x0e3),
															SET_MPEG_VIDEOSTANDARD(VSTD_NTSC),
															TAGDONE));
			}

		GNREASSERT(VDR_ConfigureUnitsTags(decUnits,  SET_MPEG_SIGNAL_POSITION(0),
																	TAGDONE));

		transferCount = 0;
		GNREASSERT(VDR_SendMPEGCommand(units, mpc_seek, 0, tag));
		GNREASSERT(VDR_SendMPEGCommand(units, mpc_resync, 0, tag));
		}

	GNREASSERT(VDR_ActivateUnits(units));

	GNRAISE_OK;
	}

//
//  Send data
//

DWORD VCDPlayer::SendData(HBPTR data, DWORD size)
	{
	DWORD tag;
	DWORD done;
	MPEGState state;

	lock.Enter();

	switch (state = VDR_CurrentMPEGState(units))
		{
		case mps_reset:
		case mps_preempted:
			lock.Leave();
			return 0;
		case mps_stopped:
			FlushWorkMessages();
			VDR_CompleteMPEGRefillMessage(units);
			VDR_DoMPEGCommand(units, mpc_seek, 0);
			if (scanning)
				VDR_SendMPEGCommand(units, mpc_scan, 0, tag);
			else
				VDR_SendMPEGCommand(units, mpc_resync, 0, tag);
			transferCount = 0;
		case mps_seeking:
			done = VDR_SendMPEGData(units, data, size);
			break;
		case mps_playing:
		case mps_resyncing:
		case mps_initial:
		case mps_frozen:
		case mps_scanning:
		case mps_stepping:
			done = VDR_SendMPEGData(units, data, size);
			break;
		default:
			done = 0;
		}

	transferCount+=done;

	lock.Leave();

	return done;
	}

DWORD VCDPlayer::SendDataMultiple(MPEGDataSizePair * data, DWORD size)
	{
	DWORD tag;
	DWORD done;
	MPEGState state;

	lock.Enter();

	switch (state = VDR_CurrentMPEGState(units))
		{
		case mps_reset:
		case mps_preempted:
			lock.Leave();
			return 0;
		case mps_stopped:
			FlushWorkMessages();
			VDR_CompleteMPEGRefillMessage(units);
			VDR_DoMPEGCommand(units, mpc_seek, 0);
			if (scanning)
				VDR_SendMPEGCommand(units, mpc_scan, 0, tag);
			else
				VDR_SendMPEGCommand(units, mpc_resync, 0, tag);
			transferCount = 0;
		case mps_seeking:
			done = VDR_SendMPEGDataMultiple(units, data, size);
			break;
		case mps_playing:
		case mps_resyncing:
		case mps_initial:
		case mps_frozen:
		case mps_scanning:
		case mps_stepping:
			done = VDR_SendMPEGDataMultiple(units, data, size);
			break;
		default:
			done = 0;
		}

	transferCount+=done;

	lock.Leave();

	return done;
	}

//
//  Complete data
//

void VCDPlayer::CompleteData(void)
	{
	lock.Enter();
	DP("complete data");
	VDR_CompleteMPEGData(units);
	lock.Leave();
	}

//
//  Cancel data
//

void VCDPlayer::CancelData(void)
	{
	DWORD tag;

	lock.Enter();

	DP("cancel data");

	VDR_DoMPEGCommand(units, mpc_seek, 0);
	VDR_SendMPEGCommand(units, mpc_resync, 0, tag);
	transferCount = 0;
	FlushWorkMessages();
	VDR_CompleteMPEGRefillMessage(units);
	scanning = FALSE;

	lock.Leave();
	}

//
//  Set callback
//

void VCDPlayer::SetCallback(DWORD position, VCDStreamServer * callback)
	{
	DWORD cp = VDR_CurrentMPEGLocation(units);
	MPEGState state;

	this->callback = NULL;

	DP("Set Callback %d %d", position, cp);

	state = VDR_CurrentMPEGState(units);

	if ((state == mps_playing || state == mps_stepping) && position < cp)
		{
		callbackPosition = 0;
		VDR_ConfigureUnitsTags(units, SET_MPEG_SIGNAL_POSITION(0), TAGDONE);
		callback->PlayerCallback(cp);
		}
	else
		{
		callbackPosition = position;
		this->callback = callback;
		VDR_ConfigureUnitsTags(units, SET_MPEG_SIGNAL_POSITION(position), TAGDONE);
		}
	}

//
//  Cancel callback
//

void VCDPlayer::CancelCallback(void)
	{
	this->callback = 0;
	VDR_ConfigureUnitsTags(units, SET_MPEG_SIGNAL_POSITION(0), TAGDONE);
	}

//
//  Test if playback is completed
//

BOOL VCDPlayer::IsCompleted(void)
	{
	MPEGState state = VDR_CurrentMPEGState(units);

	return state == mps_stopped;
	}

//
//  Start playback
//

void VCDPlayer::StartPlayback(BOOL toPause)
	{
	DWORD tag;

	lock.Enter();

	if (scanning)
		{
		DP("Starting from scan");
		scanning = FALSE;
		VDR_DoMPEGCommand(units, mpc_seek, 0);
		VDR_SendMPEGCommand(units, mpc_resync, 0, tag);
		}

	if (!paused)
		VDR_DoMPEGCommand(units, mpc_play, playbackSpeed);

	lock.Leave();
	}

//
//  Start scan
//

void VCDPlayer::StartScan(void)
	{
	DWORD tag;

	lock.Enter();

	if (!scanning)
		{
		DP("Scanning from start");
		scanning = TRUE;
		VDR_DoMPEGCommand(units, mpc_seek, 0);
		VDR_SendMPEGCommand(units, mpc_scan, 0, tag);
		}

	lock.Leave();
	}

//
//  Translate button position
//

Error VCDPlayer::TranslateButtonPosition(int & x, int & y)
	{
	int w, h;

	w = h = 0;
	VDR_ConfigureUnitsTags(units, GET_PIP_SOURCE_WIDTH(w),
				                     GET_PIP_SOURCE_HEIGHT(h),
				                     TAGDONE);
	x = 256 * x / w;
	y = 256 * y / h;
	GNRAISE_OK;
	}

//
//  Get current location
//

DWORD VCDPlayer::CurrentLocation(void)
	{
	return VDR_CurrentMPEGLocation(units);
	}

//
//  Get information about audio decoder status and content
//

Error VCDPlayer::GetAudioInformation(MPEG2PrologicStatus & prologicStatus, MPEG2LFEStatus & lfeStatus, AC3AudioCodingMode & ac3Mode)
	{
	BOOL proStat;
	BOOL lfeStat;
	BOOL tagSupported;

	//
	//  Get prologic status
	//

	prologicStatus = MP2PS_UNKNOWN;
	if (!IS_ERROR(VDR_ConfigureUnitsTags(decUnits, QRY_MPEG2_PROLOGIC_STATUS(tagSupported), TAGDONE)))
		{
		if (tagSupported)
			{
			if (!IS_ERROR(VDR_ConfigureUnitsTags(decUnits, GET_MPEG2_PROLOGIC_STATUS(proStat), TAGDONE)))
				prologicStatus = proStat ? MP2PS_ON : MP2PS_OFF;
			}
		}

	//
	//  Get LFE status
	//

	lfeStatus = MP2LFE_UNKNOWN;
	if (!IS_ERROR(VDR_ConfigureUnitsTags(decUnits, QRY_MPEG2_LFE_STATUS(tagSupported), TAGDONE)))
		{
		if (tagSupported)
			{
			if (!IS_ERROR(VDR_ConfigureUnitsTags(decUnits, GET_MPEG2_LFE_STATUS(lfeStat), TAGDONE)))
				lfeStatus = lfeStat ? MP2LFE_ON : MP2LFE_OFF;
			}
		}

	//
	//  Get AC3 coding mode
	//

	ac3Mode = AC3ACMOD_UNKNOWN;
	if (!IS_ERROR(VDR_ConfigureUnitsTags(decUnits, QRY_MPEG2_AC3_AUDIO_CODING_MODE(tagSupported), TAGDONE)))
		{
		if (tagSupported)
			{
			if (IS_ERROR(VDR_ConfigureUnitsTags(decUnits, GET_MPEG2_AC3_AUDIO_CODING_MODE(ac3Mode), TAGDONE)))
				ac3Mode = AC3ACMOD_UNKNOWN;
			// If no error occurred ac3Mode already has the correct value
			}
		}

	GNRAISE_OK;
	}

//
//  Get playback time
//

Error VCDPlayer::GetPlaybackTime(DVDTime & playbackTime)
	{
	LONG decoderTime;

	playbackTime = 0;

	GNREASSERT(VDR_ConfigureUnitsTags(units, GET_MPEG2_CURRENT_PLAYBACK_TIME(decoderTime), TAGDONE));

	playbackTime = DVDTime(0, 0, decoderTime / 1000, 0, GetCurrentFrameRate());

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\VCDHeader.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  VCD Header Classes
//
////////////////////////////////////////////////////////////////////

#ifndef VCDHEADER_H
#define VCDHEADER_H

#include "VCDFile.h"

//
//  VCD Header
//

class VCDHeader
	{
	friend class VCDSubHeader;

	protected:
		VCDFileSystem	*	vcdfs;
		VCDHeaderFile	*	file;
		RequestHandle		rh;

	public:
		BOOL	valid;

		VCDHeader(void) {valid = FALSE; file = NULL;}
		VCDHeader(VCDFileSystem * vcdfs, const DiskItemName & name)
			{
			GenericDiskItem * gdi;

			this->vcdfs = vcdfs;
			if (IS_ERROR(vcdfs->OpenItem(name, FAT_HEADER, gdi)))
				{
				file = NULL;
				valid = FALSE;
				}
			else
				{
				file = (VCDHeaderFile*)gdi;
				valid = TRUE;
				}
			}

		VCDHeader(VCDHeader * header, const DiskItemName & name)
			{
			GenericDiskItem * gdi;

			file = NULL;
			valid = FALSE;
			vcdfs = header->vcdfs;

			if (header->valid)
				{
				if (!IS_ERROR(vcdfs->OpenItem(name, FAT_HEADER, gdi)))
					{
					file = (VCDHeaderFile*)gdi;
					valid = TRUE;
					}
				}
			}

		~VCDHeader(void) {if (file) file->Release();}

		Error Initialize(VCDFileSystem * vcdfs, const DiskItemName & name)
			{
			Error err;
			GenericDiskItem * gdi;

			this->vcdfs = vcdfs;
			if (IS_ERROR(err = vcdfs->OpenItem(name, FAT_HEADER, gdi)))
				{
				file = NULL;
				valid = FALSE;
				}
			else
				{
				file = (VCDHeaderFile*)gdi;
				valid = TRUE;
				}

			GNRAISE(err);
			}
	};

//
//  VCD Sub Header
//

class VCDSubHeader : public VCDHeader
	{
	protected:
		DWORD	offset;
	public:
		VCDSubHeader(void) : VCDHeader() {offset = FALSE;}

		VCDSubHeader(VCDHeader * header, DWORD offset)
			{
			this->file = header->file;
			this->offset = offset;

			valid = header->valid;
			if (valid) file->Obtain();
			}

		VCDSubHeader(VCDSubHeader * header, DWORD offset)
			{
			this->file = header->file;
			this->offset = header->offset + offset;

			valid = header->valid;
			if (valid) file->Obtain();
			}
	};


/*
Segment Play Item Contents byte

				|				|										Description
Position		|	Value		|	Video-CD															|	Super-Video-CD
-----------------------------------------------------------------------------------------------------------------------
bit[0..1]   |	%00		|No MPEG audio data												|do.
				|	%10		|Single channel MPEG audio data								|one MPEG-1 or MPEG-2 audio stream
				|	%01		|Stereo or intensity stereo MPEG audio data				|two MPEG-1 or MPEG-2 audio streams
				|	%11		|dual channel MPEG audio data									|MPEG-2 multi-channel
				|				|																		|
bit[2..4]   |	%000		|No MPEG video data												|do.
				|	%100		|NTSC normal resolution size still picture				|NTSC still picture
				|	%010		|NTSC normal + high resolution size still picture		|reserved
				|	%110		|NTSC normal resolution size motion picture				|NTSC motion picture
				|	%001		|reserved															|reserved
				|	%101		|PAL normal resolution size still picture					|PAL still picture
				|	%011		|PAL normal + high resolution size still picture		|reserved
				|	%111		|PAL normal resolution size motion picture				|PAL motion picture
				|				|																		|
bit[5]		|	%0			|First or only segment of a Play Item						|do.
				|	%1			|Second or later segment of multi segment Play Item	|do.
				|				|																		|
bit[6..7]	|	%00		|reserved															|No OGT sub-stream available
				|	%10		|reserved															|OGT sub-stream 0 available
				|	%01		|reserved															|OGT sub-stream 0 and 1 available
				|	%11		|reserved															|all OGT sub-streams may be available
----------------------------------------------------------------------------------------------------------------------
OGT --- Overlay Graphics and Text
----------------------------------------------------------------------------------------------------------------------
*/

class SegPlayItemContent
	{
	protected:
		BYTE	status;

		//
		//	there are some differences in a segment play item content between
		//	a Video-CD and a Super-Video-CD. So we need a variable that tells us
		//	what kind of CD we are currently using.
		//

		BOOL	isVideoCD;
	public:
		SegPlayItemContent(BOOL isVCD) {status = 0; this->isVideoCD = isVCD;}
		SegPlayItemContent(BYTE b, BOOL isVCD) {this->status = b; this->isVideoCD = isVCD;}

		BOOL HasAudioData(void)   {return (status & 0x03) != 0;}
		BOOL HasVideoData(void)   {return (status & 0x1c) != 0;}
		BOOL HasOverlayData(void)
			{
			if (!isVideoCD)
				return (status & 0xc0) != 0;
			else
				return FALSE;
			}

		BOOL IsMultiChannelAudio(void)
			{
			//
			// Video-CD --> this means dual channel
			// Super-Video CD --> this means multi channel (5.1)
			//
			return (status & 0x03) == 0x3;
			}

		BOOL IsPALVideo(void)     {return (status & 0x10) != 0;}
		BOOL IsStillPicture(void)
			{
			if (isVideoCD)
				return ((status & 0x0c) != 0x0c && (status & 0x0c) != 0x00);
			else // Super-Video CD
				return ((status & 0x1c) == 0x04 || (status & 0x1c) == 0x14);
			}
		BOOL IsFirstSegment(void) {return (status & 0x20) == 0;}
		BOOL IsHiResStill(void)
			{
			if (isVideoCD)
				return (status & 0x0c) == 0x08;
			else
				//
				// note that a Super-Video-CD does not contain any information if a still picture is
				// saved in high resolution or normal resolution. So just return FALSE.
				// (it should not matter because the decoder can distinguish itself between Hi- or
				//	Normal-Resolution pictures).
				//
				return TRUE;
			}
	};

//
//  VCD Info
//

class VCDInfo : public VCDHeader
	{
	protected:
		RequestHandle rh;

	public:
		VCDInfo(void);
		Error Initialize(VCDFileSystem * vcdfs);

		BOOL IsVideoCD(void);

		WORD NumberOfVolumes(void);
		WORD CurrentVolumeNumber(void);

		BOOL IsPALTrack(int track);

		BOOL KarinfoPresent(void);
		BOOL HasClosedCaption(void);
		BOOL StartNextWithID2(void);
		BOOL StartNextWithTrack3(void);
		BOOL HasPSDX(void);

		int OffsetMultiplier(void);
		int MaximumListID(void);
		int MaximumSegmentNumber(void);

		SegPlayItemContent GetSegPlayItemContent(int item);

		Error BuildUniqueKey(BYTE * key);
	};

//
//  VCD Entries
//

class VCDEntries : public VCDHeader
	{
	protected:
		int	numTracks;
		BOOL	isSvcdStd;		// Says that SVCD follows original standard and is not e.g. Chaoji SVCD

	public:
		VCDEntries(void);

		Error Initialize(VCDFileSystem * vcdfs, DVDDiskType diskType);
		BOOL	IsSVCDStandard(void);

		WORD EntriesUsed(void);

		WORD GetEntryTrack(int entry);
		DWORD GetEntrySector(int entry);
	};

//
//  VCD Action List
//

class VCDActionList : public VCDSubHeader
	{
	public:
		VCDActionList(VCDHeader * header, DWORD offset) : VCDSubHeader(header, offset) {}

		virtual WORD ListID(void) = 0;
		virtual WORD PreviousListOffset(void) = 0;
		virtual WORD NextListOffset(void) = 0;
		virtual WORD ReturnListOffset(void) = 0;
	};

//
//  VCD Play LIst
//

class VCDPlayList : public VCDActionList
	{
	public:
		VCDPlayList(VCDHeader * header, DWORD offset) : VCDActionList(header, offset) {}

		int NumberOfItems(void);
		WORD ListID(void);
		WORD PreviousListOffset(void);
		WORD NextListOffset(void);
		WORD ReturnListOffset(void);
		DWORD PlayingTime(void);
		WORD PlayItemWaitTime(void);
		WORD AutoPauseWaitTime(void);
		WORD PlayItemNumber(int item);
	};

//
//  VCD Selection List
//

class VCDSelectionList : public VCDActionList
	{
	public:
		VCDSelectionList(VCDHeader * header, DWORD offset) : VCDActionList(header, offset) {}

		int NumberOfSelections(void);
		WORD BaseOfSelectionNumber(void);
		WORD ListID(void);
		WORD PreviousListOffset(void);
		WORD NextListOffset(void);
		WORD ReturnListOffset(void);
		WORD DefaultListOffset(void);
		WORD TimeOutListOffset(void);
		WORD TimeOutTime(void);
		WORD LoopCount(void);
		BOOL JumpTiming(void);
		WORD PlayItemNumber(void);
		WORD SelectionOffset(int item);

		virtual DWORD PreviousListSelectionArea(void);
		virtual DWORD NextListSelectionArea(void);
		virtual DWORD ReturnListSelectionArea(void);
		virtual DWORD DefaultListSelectionArea(void);
		virtual DWORD SelectionArea(int item);
	};

//
//  VCD Selection List Extended
//

class VCDSelectionListX : public VCDSelectionList
	{
	public:
		VCDSelectionListX(VCDHeader * header, DWORD offset) : VCDSelectionList(header, offset) {}

		virtual DWORD PreviousListSelectionArea(void);
		virtual DWORD NextListSelectionArea(void);
		virtual DWORD ReturnListSelectionArea(void);
		virtual DWORD DefaultListSelectionArea(void);
		virtual DWORD SelectionArea(int item);
	};

//
//  VCD PSD
//

class VCDPSD : public VCDHeader
	{
	protected:
		VCDPSD(VCDFileSystem * vcdfs, KernelString name) : VCDHeader(vcdfs, name) {}
	public:
		VCDPSD(VCDFileSystem * vcdfs) : VCDHeader(vcdfs, "vcd\\psd.vcd") {}
		VCDPSD(void) : VCDHeader() {}

		Error Initialize(VCDFileSystem * vcdfs);
		Error Initialize(VCDFileSystem * vcdfs, KernelString name);
		virtual Error InitializeExtended(VCDFileSystem * vcdfs);

		virtual VCDSelectionList * GetSelectionList(WORD offset);

		VCDPlayList * GetPlayList(WORD offset);

		BOOL IsPlayList(WORD offset);
		virtual BOOL IsSelectionList(WORD offset);
		BOOL IsEndList(WORD offset);
	};

//
//  VCD PSD Extended
//

class VCDPSDX : public VCDPSD
	{
	public:
		VCDPSDX(VCDFileSystem * vcdfs) : VCDPSD(vcdfs, "ext\\psd_x.vcd") {}
		VCDPSDX(void) : VCDPSD() {}

		virtual Error InitializeExtended(VCDFileSystem * vcdfs);

		VCDSelectionList * GetSelectionList(WORD offset);

		BOOL IsSelectionList(WORD offset);
	};

//
//  VCD LOT
//

class VCDLOT : public VCDHeader
	{
	protected:
		VCDLOT(VCDFileSystem * vcdfs, KernelString name) : VCDHeader(vcdfs, name) {}
	public:
		VCDLOT(VCDFileSystem * vcdfs) : VCDHeader(vcdfs, "vcd\\lot.vcd") {}

		WORD ListOffset(int listID);
	};

//
//  VCD LOT Extended
//

class VCDLOTX : public VCDLOT
	{
	public:
		VCDLOTX(VCDFileSystem * vcdfs) : VCDLOT(vcdfs, "ext\\lot_x.vcd") {}
	};

/*
Track Content byte (see also S-VCD specification)

				|				|							Description
Position		|	Value		|	Super-Video-CD
-------------------------------------------------------------------------------
bit[0..1]   |	%00		|No MPEG audio stream
				|	%10		|one MPEG-1 or MPEG-2 audio stream without extension
				|	%01		|two MPEG-1 or MPEG-2 audio streams without extensions
				|	%11		|one MPEG-2 multi-channel audio stream with extension
				|				|
bit[2..4]   |	%000		|No MPEG video data
				|	%100		|reserved
				|	%010		|reserved
				|	%110		|NTSC motion picture
				|	%001		|reserved
				|	%101		|reserved
				|	%011		|reserved
				|	%111		|PAL motion picture
				|				|
bit[5]		|	%0			|reserved
				|	%1			|reserved
				|				|
bit[6..7]	|	%00		|No OGT sub-stream available
				|	%10		|OGT sub-stream 0 available
				|	%01		|OGT sub-stream 0 and 1 available
				|	%11		|all OGT sub-streams may be available
-------------------------------------------------------------------------------
OGT --- Overlay Graphics and Text
-------------------------------------------------------------------------------
*/

class TrackContent
	{
	protected:
		WORD	status;

	public:
		TrackContent(void) {status = 0;}
		TrackContent(WORD w) {this->status = w;}

		BOOL HasTwoAudioStream(void)
			{
			return ((status & 0x03) == 0x2);
			}
		BOOL HasMultiChannelAudioData(void)
			{
			return ((status & 0x03) == 0x3);
			}
	};

//
// Class:
//		VCDTracks
//	Description:
//		The class VCDTracks implements the S-VCD specific TRACKS.SVD file. This file
//		contains content-related information as the Playing time, Video system type,
//		number of audio streams, and number of OGT sub-channels for each MPEG track on the disc.
//
class VCDTracks : public VCDHeader
	{
	protected:
		RequestHandle rh;

		WORD numberOfMpegTracks;				// number of tracks the CD contains
		DWORD contentByteOffset;				// offset to the first Track Content byte
		DWORD playingTimeOffset;				// offset to the first Track Playing time
		WORD GetNumberOfMPEGTracks(void);

	public:
		VCDTracks(void) : VCDHeader() {numberOfMpegTracks = 0;}

		Error Initialize(VCDFileSystem * volume);
		TrackContent GetTrackContent(int track);
		DWORD TrackPlayingTime(DWORD track);
		BOOL IsDualAudioStream(WORD track);
		BOOL IsMultiChannelAudioTrack(WORD track);
	};

//
// Class:
//		VCDSearch
// Description:
//		The class VCDSearch implements the SEARCH.DAT file.
//		SEARCH.DAT contains information about the relation between playing time and sector address.
//		Note that this file is NOT mandatory and therefore there should be another implementation
//		for solving the problem calculating the sector address from a given playing time!
//		MST 09/18/2000
//		Is solved by extracting the PTS directly from the stream. So for now the VCDSearch class
//		is not used but should be left in because of later use.
//		MST 10/04/2000
//
class VCDSearch : public VCDHeader
	{
	protected:
		WORD	numberOfScanPoints;	// contains the number of scan points in the table

	public:
		VCDSearch(void) : VCDHeader() {numberOfScanPoints = 0;}

		Error Initialize(VCDFileSystem * volume);
		DWORD GetSectorAddress(int time);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\VCDPlayer.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  VCD Player Classes
//
////////////////////////////////////////////////////////////////////

#ifndef VCDPLAYER_H
#define VCDPLAYER_H

#include "Library/Common/WinPorts.h"
#include "Library/Common/KrnlSync.h"
#include "EventSender.h"
#include "DVDTime.h"
#include "Boards/generic/vdgendrv.h"

////////////////////////////////////////////////////////////////////
//
//  VCD Stream Server Class
//
////////////////////////////////////////////////////////////////////

class VCDStreamServer
	{
	public:
		virtual Error PerformTransfer(int maxTransfer = 0xffff) = 0;
      virtual void PlayerCallback(DWORD signalPosition) = 0;
	};

////////////////////////////////////////////////////////////////////
//
//  VCD Player Class
//
////////////////////////////////////////////////////////////////////

class VCDPlayer : private WinPortWorkerThread, virtual public EventSender
	{
	protected:
		UnitSet				units, decUnits;
		VCDStreamServer * callback;
		VCDStreamServer * refiller;
		VDLocalMutex		lock;

		DWORD					callbackPosition;

		BOOL playing, scanning, paused;

		void WorkMessage(WPARAM wParam, LPARAM dParam);

		WORD playbackSpeed;

		enum VCDVideoStandard
			{
			VCDVID_NTSC, VCDVID_PAL, VCDVID_UNKNOWN
			} vidStandard;

		enum VCDCodingStandard
			{
			VCDCDS_MPEG1, VCDCDS_MPEG2, VCDCDS_UNKNOWN
			};

		//
		// contains the current audio stream id. When we have single channel audio then the
		//	audio stream id is zero. In dual channel mode the first channel has the audio stream id
		// 0 and the second channel audio stream id 1.
		//
		WORD audioStreamID;

		//
		// Video-CD contains only MPEG-1 coded material (audio and video)
		// Super-Video-CD contains always MPEG-2 video but may contain MPEG-1 or MPEG-2 audio.
		//
		VCDCodingStandard videoCodingStandard;
		VCDCodingStandard audioCodingStandard;

		//HANDLE fileHandle;
	public:
		DWORD	transferCount;

		VCDPlayer(WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher);
		virtual ~VCDPlayer(void);

		Error Init(void);

		Error Pause(void);
		Error Resume(void);
		Error Step(void);
		Error SetPlaybackSpeed(WORD speed);
		WORD	GetPlaybackSpeed(void) {return playbackSpeed;}

		BOOL IsPaused(void);
		BOOL IsPreempted(void);

		BOOL SupportsHiResStills(void);

		Error SetAudioStreamChannel(WORD audioStreamID);
		WORD  GetAudioStreamChannel(void);
		Error SetStreamAttributes(BOOL pal, BOOL mpeg1CodingStandard, BOOL mpeg1Audio = TRUE);

		DWORD SendData(HBPTR data, DWORD size);
		DWORD SendDataMultiple(MPEGDataSizePair * data, DWORD size);
		void CompleteData(void);
		void CancelData(void);

		void SetRefiller(VCDStreamServer * refiller) {this->refiller = refiller;}
		void RequestRefill(void);

		void SetCallback(DWORD position, VCDStreamServer * callback);
		void CancelCallback(void);

		BOOL IsCompleted(void);
		void StartPlayback(BOOL toPause = FALSE);
		void StartScan(void);
		void TerminatePlayback(void);

		Error TranslateButtonPosition(int & x, int & y);

		DWORD CurrentLocation(void);

		VideoStandard GetCurrentVideoStandard(void) { return (vidStandard == VCDVID_NTSC ? VSTD_NTSC : VSTD_PAL); }
		int			  GetCurrentFrameRate(void) { return vidStandard == VCDVID_NTSC ? 30 : 25; }

		Error GetPlaybackTime(DVDTime & playbackTime);

		Error GetAudioInformation(MPEG2PrologicStatus & prologicStatus, MPEG2LFEStatus & lfeStatus, AC3AudioCodingMode & ac3Mode);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\VCDPlaySeq.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef VCDPLAYSEQ_H
#define VCDPLAYSEQ_H

#include "VCDStreamServer.h"
#include "VCDHeader.h"
#include "EventSender.h"
#include "Breakpoint.h"

class VCDPlayListSequencer : public VCDStreamSequencer, virtual public ERSBreakpointControl
	{
	protected:
		VCDFileSystem	*	vcdfs;
		VCDInfo        *	info;
		VCDEntries		*	entries;
		VCDTracks		*	tracks;
		VCDSearch		*	search;
		VCDPlayList		*	list;
		VCDDataFile		*	file;

		int					currentItem;			// Index of current play item withing playlist
		WORD					repeatCount;
		WORD					waitTime;
		WORD					currentTrack;
		WORD					currentSegment;
		int					scanSpeed;				// Please use SetScanSpeed method to change this
		WORD					numberOfTitles;
		BOOL					playAllTracks;
		BOOL					playingAudioTrack;	// TRUE while playing CDDA track
		DWORD					currentDurationInMilliSecs;

		enum BreakpointState { BPS_NONE, BPS_NORMAL, BPS_EOT } bpReached;

		// WinPort functions.
		virtual void Message (WPARAM wParam, LPARAM lParam);

		enum PlsState {pls_idle, pls_stopped, pls_playing, pls_autopause, pls_still, pls_scanning, pls_paused} state;	// Please use SetPlaybackMode method to change this
		inline void SetPlaybackMode(PlsState newState);
		inline void SetScanSpeed(int newSpeed);

		// VCDStreamSequencer functions.
		virtual void TransferCompleted(void);
		virtual void PlaybackCompleted(void);
		virtual void AutoPauseReached(void);

		Error OpenTrack(WORD num);
		Error OpenSegment(WORD num);

		Error StopPlayItem(void);

		Error AdvancePlayItem(void);

		virtual Error PlayListCompleted(Error error = GNR_OK) {GNRAISE_OK;}
		virtual void PlayItemCompleted(void) {}

      virtual Error StartStillPhase(WORD delay); // calls StillPhaseCompleted() after delay secs
      virtual Error CancelStillPhase(void);

      Error StillPhaseCompleted(void);

		virtual void StartBreakpointStillCallback(void);

		WORD TranslatePartToEntry(WORD track, WORD part);
		WORD TranslateBlockToPart(WORD track, DWORD block);

	public:
		VCDPlayListSequencer(WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher);
		~VCDPlayListSequencer(void);

		Error Initialize(VCDFileSystem * vcdfs, VCDInfo * info, VCDEntries * entries, VCDTracks * tracks, VCDSearch * search);

		Error StartPlayItem(WORD item, WORD wait, WORD repeat = 0, DWORD numSectors = 0, BOOL toPause = FALSE);
		Error StartTrackAt(WORD track, DWORD startSector, BOOL toPause = FALSE);
		Error RestartTrackAt(DWORD startSector, BOOL toPause = FALSE);
		Error RestartTrackAtItem(WORD item);
		virtual Error StartPlayList(VCDPlayList * list, DWORD flags = DDPSPF_NONE);
		Error AbortPlayList(void);
		Error CompletePlayItem(void);

		Error GoPrevItem(void);
		Error GoNextItem(void);

		Error StartForwardScan(WORD scanSpeed);
		Error StartBackwardScan(WORD scanSpeed);
		Error StopScan(BOOL toPause);
		Error TimeSearch(DVDTime time);
		virtual Error Pause(void);
		Error Resume(void);

		Error EnterStopState(void);

		Error GetAvailStreams(BYTE & audio, DWORD & subPicture);
		WORD	GetCurrentAudioStream(void);
		Error GetAudioStreamAttributes(int num, DVDAudioStreamFormat & format);
		Error AudioStreamChange(WORD stream);

		WORD	GetScanSpeed(void) { if (scanSpeed >= 0) return (WORD)scanSpeed; else return (WORD)-scanSpeed; }

		WORD	CurrentPlayItem(void);

		Error StopStillPhase(void);

		BOOL IsStillPhase(void) {return state == pls_autopause || state == pls_still;}

		BOOL IsPlaying(void) {return state == pls_playing || state == pls_idle;}
		BOOL IsScanning(void) {return state == pls_scanning;}
		BOOL IsPaused(void) {return state == pls_paused;}
		BOOL IsIdle(void) {return state == pls_idle || state == pls_stopped;}
		BOOL IsStopped(void) {return state == pls_stopped;}
		virtual BOOL IsPlayingForward(void);

		virtual DVDPlayerMode InternalGetMode(void);
		virtual WORD NumberOfTitles(void);

		DWORD CurrentBlock(void);
		virtual Error CurrentDuration(DWORD & dur);
		virtual Error CurrentPlayingTime(DWORD & time);

		//
		//  Freezing Stuff
		//

		struct VCDPLSState
			{
			int		currentItem;
			WORD		currentTrack;
			WORD		repeatCount;
			WORD		waitTime;
			DWORD		numSectors;
			BOOL		playAllTracks;
			DWORD		transferCount;	// contains the number of bytes sent to the decoder while freeze command was executed
			};

		Error Freeze(VCDPLSState * buffer);
		Error Defrost(VCDPLSState * buffer, VCDPlayList * list, DWORD flags);

		virtual Error GetUOPs(DWORD & uops) = 0;
	};

////////////////////////////////////////////////////////////////////
//
//  Inline Functions
//
////////////////////////////////////////////////////////////////////

//
//  Set Playback Mode
//

void VCDPlayListSequencer::SetPlaybackMode(PlsState newState)
	{
	DVDPlayerMode oldMode, newMode;

	oldMode = InternalGetMode();
	state = newState;
	newMode = InternalGetMode();

	if (oldMode != newMode)
		SendEvent(DNE_PLAYBACK_MODE_CHANGE, newMode);
	}

//
//  Set Scan Speed
//
void VCDPlayListSequencer::SetScanSpeed(int newSpeed)
	{
	//
	//  Set new scan speed and send event if necessary
	//

	if (newSpeed != scanSpeed)
		{
		SendEvent(DNE_SCAN_SPEED_CHANGE, newSpeed);
		scanSpeed = newSpeed;
		}
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\VCDPlaySeq.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  VCD Play List Sequencer
//
////////////////////////////////////////////////////////////////////

#include "VCDPlaySeq.h"
#include "Library/Common/vddebug.h"


////////////////////////////////////////////////////////////////////
//
//  Macro Definitions
//
////////////////////////////////////////////////////////////////////

#define SAVE_UOPS		DWORD oldUOPs; DWORD newUOPs; GNREASSERT(GetUOPs(oldUOPs));
#define CHECK_UOPS	{ GNREASSERT(GetUOPs(newUOPs)); if (oldUOPs != newUOPs) SendEvent(DNE_VALID_UOP_CHANGE, newUOPs); }

////////////////////////////////////////////////////////////////////
//
//  Function Definitions
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

VCDPlayListSequencer::VCDPlayListSequencer(WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher)
	: VCDStreamSequencer(server, units, pEventDispatcher)
	, EventSender(pEventDispatcher)
	, ERSBreakpointControl(pEventDispatcher)
	{
	list = NULL;
	file = NULL;
	state = pls_stopped;
	scanSpeed = 0;

	currentTrack = 0;
	currentSegment = 0;
	numberOfTitles = 0;
	currentDurationInMilliSecs = 0;

	playingAudioTrack = FALSE;
	}

//
//  Destructor
//

VCDPlayListSequencer::~VCDPlayListSequencer(void)
	{
	delete file;
	delete list;
	}

//
//  Initialize
//

Error VCDPlayListSequencer::Initialize(VCDFileSystem * vcdfs, VCDInfo * info,	VCDEntries * entries,
													VCDTracks * tracks, VCDSearch * search)
	{
	GNREASSERT(VCDStreamSequencer::Init());

	this->info = info;
	this->entries = entries;
	this->tracks = tracks;
	this->search = search;

	GNREASSERT(SetAttributes(entries->IsSVCDStandard()));

	GNRAISE_OK;
	}

//
//  Message Function
//

void VCDPlayListSequencer::Message(WPARAM wParam, LPARAM lParam)
	{
	switch (wParam)
		{
		case STILL_TIME_MSG:
			StillPhaseCompleted();
			break;
		case PLAYBACK_TIME_MSG:
			// nothing to do
			break;
		case BREAKPOINT_MSG:
			{
			ERSBreakpoint	bp;
			DWORD				loc;
			int				frameRate = player->GetCurrentFrameRate();

			loc = ((CurrentLocation() / CD_FRAME_SIZE) * frameRate) / CD_FRAME_RATE;
			if (BreakpointReached(CurrentPlayItem() - 1, DVDTime(0, 0, 0, loc, frameRate),
				DVDTime(0, 0, 0, loc + 15, frameRate), IsPlayingForward() ? EPD_FORWARD : EPD_BACKWARD, bp))
				{
				bpReached = BPS_NORMAL;
				ExecuteBreakpoint(bp.id);
				}
			break;
			}
		default:
			// Call base class messaging.
			VCDStreamSequencer::Message (wParam, lParam);
			break;
		}
	}

//
//  Start A Still Phase
//

Error VCDPlayListSequencer::StartStillPhase(WORD delay)
	{
	if (delay == 0)
		GNREASSERT(StillPhaseCompleted());
	else
		{
		if (delay < 255)
			ScheduleTimer(STILL_TIME_MSG, (DWORD)delay * 1000);

		SendEvent(DNE_STILL_ON, delay);
		}

	GNRAISE_OK;
	}

//
//  Cancel Still Phase
//

Error VCDPlayListSequencer::CancelStillPhase(void)
	{
	CancelTimer();
	if (state == pls_still || state == pls_autopause)
		SendEvent(DNE_STILL_OFF, 0);

	GNRAISE_OK;
	}

//
//  Stop Still Phase
//

Error VCDPlayListSequencer::StopStillPhase(void)
	{
	Error err = GNR_OK;

	switch (bpReached)
		{
		case BPS_NONE:
			CancelTimer();

			if (state == pls_still || state == pls_autopause)
				GNREASSERT(StillPhaseCompleted());
			break;
		case BPS_NORMAL:
			player->Resume();
			bpReached = BPS_NONE;
			SetPlaybackMode(pls_playing);
			break;
		case BPS_EOT:
			bpReached = BPS_NONE;
			SetPlaybackMode(pls_playing);
			if (IS_ERROR(err = AdvancePlayItem()))
				SetPlaybackMode(pls_stopped);
			break;
		}

	if (!IS_ERROR(err))
		SendEvent(DNE_STILL_OFF, 0);
	GNRAISE(err);
	}

//
//  Transfer Completed
//

void VCDPlayListSequencer::TransferCompleted(void)
	{
	if (scanSpeed > 0)
		SetScanSpeed(0);

	if (repeatCount && !scanSpeed && file)
		{
		//
		// the value 0xFFFF for the variable 'repeatCount' means an infinity loop.
		// so do not decrement repeat count in this case!
		//

		if (repeatCount != 0xFFFF)
			repeatCount--;
		TransferStream(file, 0, 0, !repeatCount);
		}
	}

//
//  Playback Completed
//

void VCDPlayListSequencer::PlaybackCompleted(void)
	{
	ERSBreakpoint bp;

	if (scanSpeed < 0)
		{
		//
		//  We reached beginning of item in backward scan -> start forward scan
		//

		StopScan(FALSE);
		}
	else
		{
		//
		//  Test if we reached End-Of-Title breakpoint
		//

		if (EndOfTitleBreakpointReached(CurrentPlayItem() - 1, IsPlayingForward() ? EPD_FORWARD : EPD_BACKWARD, bp))
			bpReached = BPS_EOT;

		if (bpReached == BPS_EOT)
			ExecuteBreakpoint(bp.id);
		else
			bp.flags = 0;

		//
		//  Start still phase if we didn't reach pause breakpoint
		//

		if (!BP_TOSTILL(bp.flags))
			{
			if (waitTime)
				{
				SetPlaybackMode(pls_still);

				StartStillPhase(waitTime);
				}
			else
				{
				AdvancePlayItem();
				}
			}
		}
	}

//
//  Auto Pause Reached
//

void VCDPlayListSequencer::AutoPauseReached(void)
	{
	if (list)
		{
		SetPlaybackMode(pls_autopause);
		StartStillPhase(list->AutoPauseWaitTime());
		}
	else
		ContinueAutoPause();
	}

//
//  Stop Play Item
//

Error VCDPlayListSequencer::StopPlayItem(void)
	{
	GNREASSERT(AbortTransfer());
	player->Resume();

	GNRAISE_OK;
	}

//
//  Advance To Next Play Item
//

Error VCDPlayListSequencer::AdvancePlayItem(void)
	{
	Error err = GoNextItem();

	if (err == GNR_OBJECT_NOT_FOUND)
		{
		err = PlayListCompleted();
		if (IS_ERROR(err))
			SetPlaybackMode(pls_stopped);
		}
	else if (err == GNR_ITEM_NOT_FOUND)
		{
		err = PlayListCompleted(err);
		SetPlaybackMode(pls_stopped);
		}

	GNRAISE(err);
	}

//
//	Function:
//		FindLastPresentationTime
//	Parameter:
//		file: pointer to a VCDDataFile
//	Return Value:
//		last presentation time stamp in the given track (equals track playing time)
// Description:
//		Search for the last sector of the given track and extracts the PTS that is equal
//		to the track duration.
//		Usually there should be a file TRACKS.SVD on the disc that contains the duration
//		for each track. Unfortunately some illegal discs don't conform to the spec and
//		therefore don't provide the TRACKS.SVD file. For these discs use this function to
//		get the duration.
//
static DWORD FindLastPresentationTime(VCDDataFile * file)
	{
	DriveBlock db;
	RequestHandle rh;
	DWORD sector;
	BOOL found;
	BOOL readError;
	WORD numSearch;
	BYTE pts_dts_flags;
	DWORD pts, scr;
	Error err;

	if (file)
		{
		found = readError = FALSE;
		numSearch = 0;

		//
		// determine the number of sectors this track contains
		//

		if (IS_ERROR(file->GetNumberOfBlocks(sector)))
			sector = 0;

		while (!found && !readError)
			{
			//
			// read data
			//

			if (!IS_ERROR(err = file->LockBlocks(sector, 1, &db, DAF_NONE, &rh)))
				{
				//
				// look for a valid PTS
				//

				pts_dts_flags = db.data[45] & 0xc0;
				if (pts_dts_flags == 0xc0 || pts_dts_flags == 0x80)
					{
					//
					// extract the PTS
					//

					pts = (((DWORD)(db.data[47] & 0x0e) >> 1) << 29) |
							(((DWORD)(db.data[48]       )     ) << 21) |
							(((DWORD)(db.data[49] & 0xfe) >> 1) << 14) |
							(((DWORD)(db.data[50]       )     ) <<  6) |
							(((DWORD)(db.data[51] & 0xfc) >> 2));

					//
					// convert into milliseconds and round up
					//
					pts = pts/45 + 1000;

					found = TRUE;
					}
				else if (db.data[24] == 0x00 && db.data[25] == 0x00 && db.data[26] == 0x01 && db.data[27] == 0xba)
					{
					//
					// if no valid PTS can be found extract the SCR
					//

					scr = ((((DWORD)(db.data[28] & 0x38)	>> 1)	| ((DWORD)(db.data[28] & 0x03))) << 27) |
							(((DWORD) (db.data[29]		 )		 )													<< 19) |
							((((DWORD)(db.data[30] & 0xf8)	>> 1) | ((DWORD)(db.data[30] & 0x03))) << 12) |
							(((DWORD) (db.data[31]		 )		 )													<<  4) |
							(((DWORD) (db.data[32] & 0xf8)	>> 4));

					scr = scr/45 + 1000;
					pts = scr;

					found = TRUE;
					}
				}

			file->UnlockBlocks(sector, 1, &db, DAF_NONE, &rh);

			if (!found)
				{
				sector--;
				numSearch++;
				}

			//
			// 140 sectors means approximately 1 seconds (highest bitrate 2.6 Mbps)
			//
			if (numSearch >= 140)
				{
				DP("*** READ ERROR ***");
				pts = 0;
				readError = TRUE;
				}
			}

		return pts;
		}
	else
		return 0;
	}

//
//  Find Previous Sequence Header
//

static DWORD FindPrevSequenceHeader(VCDDataFile * file, DWORD blk)
	{
	RequestHandle rh;
	DriveBlock blocks[16];
	int		num, lockedBlocks;
	int		i;
	BYTE		*p;
	BOOL		found;
	DWORD		numBlocks;

	//
	// Do backward search for seq header, beginning with successor block
	//

	found = FALSE;
	blk++;

	file->GetNumberOfBlocks(numBlocks);
	if (blk > numBlocks) blk = numBlocks;

	num = 0;
	while (!found && blk > 0)
		{
		//
		//  Search 16 blocks wise
		//

		if (blk > 16)
			num = 16;
		else
			num = blk;

		lockedBlocks = num;
		blk-=num;
		if (!IS_ERROR(file->LockBlocks(blk, num, blocks, DAT_LOCK_AND_READ, &rh)))
			{
			//
			//  Now find pic header in blocks
			//

			while (!found && num)
				{
				num--;
				p = blocks[num].data;
				if (p[18] == 0x62)
					{
					i = 0;
					while (i < 2044 && (p[i] != 0x00 || p[i+1] != 0x00 || p[i+2] != 0x01 || (p[i+3] != 0xb3 && p[i+3] != 0xb8)))
						i++;
					found = i < 2044;
					}
				}
			}
		file->UnlockBlocks(blk, lockedBlocks, blocks, DAT_UNLOCK_CLEAN, &rh);
		}
	blk += num;

	return blk;
	}

//
//  Open A Segment
//

Error VCDPlayListSequencer::OpenSegment(WORD num)
	{
	DVDDiskType diskType;
	DiskItemName name;
	GenericDiskItem * gdi;
	BOOL isPAL;

	GNREASSERT(GetDiskType(diskType));

	SegPlayItemContent spic(diskType == DDT_VIDEO_CD);;

	if (diskType == DDT_VIDEO_CD)
		name = "segment\\item" + KernelString(num, 4) + ".dat";
	else if (diskType == DDT_SUPER_VIDEO_CD)
		name = "segment\\item" + KernelString(num, 4) + ".mpg";
	else
		GNRAISE(GNR_OBJECT_INVALID);

	GNREASSERT(vcdfs->OpenItem(name, FAT_READ, gdi));
	file = (VCDDataFile*)gdi;

	spic = info->GetSegPlayItemContent(num);

	GNREASSERT(file->IsPALSequence(isPAL));
	GNREASSERT(player->SetStreamAttributes(isPAL || spic.IsPALVideo(), diskType == DDT_VIDEO_CD));

	currentSegment = num;

	GNRAISE_OK;
	}

//
//  Open A Track
//

Error VCDPlayListSequencer::OpenTrack(WORD num)
	{
	DVDDiskType diskType;
	Error err;
	DiskItemName name;
	GenericDiskItem * gdi;
	BOOL isPAL;

	file = NULL;

	//
	//  Test on AV track
	//

	GNREASSERT(GetDiskType(diskType));
	if (diskType == DDT_VIDEO_CD)
		{
		name = "mpegav\\avseq" + KernelString((WORD)(num-1), 2) + ".dat";
		if (IS_ERROR(err = vcdfs->OpenItem(name, FAT_READ, gdi)))
			{
			//
			//  Test on AV track with alternative name
			//

			name = "mpegav\\music" + KernelString((WORD)(num-1), 2) + ".dat";
			err = vcdfs->OpenItem(name, FAT_READ, gdi);
			}
		}
	else if (diskType == DDT_SUPER_VIDEO_CD)
		{
		//
		// the MPEG-2 audio/video tracks can be found under the directory \\mpeg2\
		//	(like described in the SVCD system specification Version 1.0, May, 1999).
		//
		// some s-vcds have a directory \\mepgav\ instead of \\mpeg2\
		// so we have to support this too

		name = "mpeg2\\avseq" + KernelString((WORD)(num-1), 2) + ".mpg";
		if (IS_ERROR(err = vcdfs->OpenItem(name, FAT_READ, gdi)))
			{
			name = "mpegav\\avseq" + KernelString((WORD)(num-1), 2) + ".mpg";
			err = vcdfs->OpenItem(name, FAT_READ, gdi);
			}
		}
	else
		GNRAISE(GNR_OBJECT_INVALID);

	if (!IS_ERROR(err))
		{
		//
		//  We found an AV track
		//

		file = (VCDDataFile*)gdi;
		GNREASSERT(file->IsPALSequence(isPAL));
		GNREASSERT(player->SetStreamAttributes(isPAL || info->IsPALTrack(num), diskType == DDT_VIDEO_CD));
		currentTrack = num;
		if (diskType == DDT_SUPER_VIDEO_CD)
			{
			if (!tracks)
				currentDurationInMilliSecs = FindLastPresentationTime(file);
			else
				currentDurationInMilliSecs = 0;
			}
		}
	else
		list = NULL;

	GNRAISE(err);

	}

//
//  Restart Track At A Sector
//

Error VCDPlayListSequencer::RestartTrackAt(DWORD startSector, BOOL toPause)
	{
	if ((state == pls_playing || state == pls_scanning || state == pls_still) && file && currentTrack)
		{
		StopPlayItem();
		SetPlaybackMode(pls_playing);
		startSector = FindPrevSequenceHeader(file, startSector);
		GNREASSERT(TransferStream(file, startSector, 0, !repeatCount, 0, FALSE, toPause));
		}

	GNRAISE_OK;
	}

//
//  Restart Track At A Play Item
//

Error VCDPlayListSequencer::RestartTrackAtItem(WORD item)
	{
	if (state == pls_playing && file && item >= 100 && currentTrack && entries->GetEntryTrack(item - 99) == currentTrack)
		{
		StopPlayItem();

		GNREASSERT(TransferStream(file, file->SectorToBlock(entries->GetEntrySector(item - 99)), 0, !repeatCount));
		}

	GNRAISE_OK;
	}

//
//  Start Forward Scan
//

Error VCDPlayListSequencer::StartForwardScan(WORD scanSpeed)
	{
	DWORD startSector;
	SAVE_UOPS;

	SetScanSpeed(scanSpeed);
	startSector = CurrentLocation() / CD_FRAME_SIZE;
	StopPlayItem();
	startSector = FindPrevSequenceHeader(file, startSector);
	SetPlaybackMode(pls_scanning);
	GNREASSERT(TransferStream(file, startSector, 0, !repeatCount, this->scanSpeed));

	CHECK_UOPS;
	GNRAISE_OK;
	}

//
//  Start Backward Scan
//

Error VCDPlayListSequencer::StartBackwardScan(WORD scanSpeed)
	{
	DWORD startSector;
	SAVE_UOPS;

	SetScanSpeed(-(int)(scanSpeed));
	startSector = CurrentLocation() / CD_FRAME_SIZE;
	StopPlayItem();
	startSector = FindPrevSequenceHeader(file, startSector);
	SetPlaybackMode(pls_scanning);
	GNREASSERT(TransferStream(file, startSector, 0, !repeatCount, this->scanSpeed));

	CHECK_UOPS;
	GNRAISE_OK;
	}

//
//  Stop Scan
//

Error VCDPlayListSequencer::StopScan(BOOL toPause)
	{
	DWORD startSector;
	SAVE_UOPS;

	if (scanSpeed)
		{
		SetScanSpeed(0);
		startSector = CurrentLocation() / CD_FRAME_SIZE;
		StopPlayItem();
		startSector = FindPrevSequenceHeader(file, startSector);
		SetPlaybackMode(pls_playing);

		if (toPause) Pause();

		GNREASSERT(TransferStream(file, startSector, 0, !repeatCount));
		}
	else
		GNRAISE(GNR_OPERATION_PROHIBITED);

	CHECK_UOPS;
	GNRAISE_OK;
	}

//
// Time search (only called when playing an S-VCD)
//

DWORD VCDPlayListSequencer::TimeSearch(DVDTime time)
	{
	DWORD sector;

	StopPlayItem();
	SetPlaybackMode(pls_playing);

	sector = FindTimeSearchSector(file, time.Millisecs());

	return sector;
	}

//
//  Start Track At A Sector
//

Error VCDPlayListSequencer::StartTrackAt(WORD track, DWORD startSector, BOOL toPause)
	{
	repeatCount = 0;
	waitTime = 0;
	SetScanSpeed(0);
	playAllTracks = TRUE;
	currentTrack = track;

	GNREASSERT(OpenTrack(track));
	SetPlaybackMode(pls_playing);
	if (startSector) startSector = FindPrevSequenceHeader(file, startSector);

	GNREASSERT(TransferStream(file, startSector, 0, TRUE));
	if (toPause)
		Pause();

	GNRAISE_OK;
	}

//
//  Start Play Item
//  Repeat is equal to 0 except for play items started from a selection list
//

Error VCDPlayListSequencer::StartPlayItem(WORD item, WORD waitTime, WORD repeat, DWORD numSectors, BOOL toPause)
	{
	DVDDiskType diskType;
	SAVE_UOPS;

	GNREASSERT(GetDiskType(diskType));

	SegPlayItemContent spic(diskType == DDT_VIDEO_CD);

	if (waitTime > 0xfe)
		waitTime = 0xff;
	//
	// A 'repeat'-value of 0xffff means an infinity loop.
	// It has the same meaning as waitTime = 0xff and repeat = 0x0.
	// The problem is that a wait time of zero and a repeat value of 0xffff leads
	// to recursive procedure calls. After a while this leads to a deadlock.
	// To avoid this we set the wait time to 0xff and repeat to 0x0.
	// Martin (MST) 08/24/2000
	//
	if (repeat == 0xffff)
		{
		waitTime = 0xff;
		repeat = 0x0;
		}

	DP("Start Play Item Item %d Wait %d Repeat %d NumSectors %d", item, waitTime, repeat, numSectors);

	this->repeatCount = repeat;
	this->waitTime = waitTime;

	playAllTracks = FALSE;
	bpReached = BPS_NONE;
	SetScanSpeed(0);

	if (IsIdle())
		{
		if (item < 2)
			{
			PlaybackCompleted();
			}
		else if (item < 100)
			{
			GNREASSERT(OpenTrack(item));
			SetPlaybackMode(pls_playing);
			GNREASSERT(TransferStream(file, 0, numSectors, !repeat, 0, FALSE, toPause, FALSE));
			}
		else if (item < 600)
			{
			GNREASSERT(OpenTrack(entries->GetEntryTrack(item-99)));
			SetPlaybackMode(pls_playing);
			GNREASSERT(TransferStream(file, file->SectorToBlock(entries->GetEntrySector(item-99)), numSectors, !repeat, 0, FALSE, toPause));
			}
		else if (item < 1000)
			{
			GNRAISE(GNR_RANGE_VIOLATION);
			}
		else if (item < 2980)
			{
			GNREASSERT(OpenSegment(item-999));
			SetPlaybackMode(pls_playing);
			spic = info->GetSegPlayItemContent(item-999);
			GNREASSERT(TransferStream(file, 0, numSectors, !repeat, 0, spic.IsHiResStill(), toPause, FALSE));
			}
		else
			{
			GNRAISE(GNR_RANGE_VIOLATION);
			}
		}
	else
		GNRAISE(GNR_OBJECT_IN_USE);

	//
	//  Check for changes and send events
	//

	CHECK_UOPS;
	SendEvent(DNE_TITLE_CHANGE, item - 1);
	GNRAISE_OK;
	}

//
//  Go to previous play item
//

Error VCDPlayListSequencer::GoPrevItem(void)
	{
	if (list)
		{
		if (currentItem > 1)
			{
			bpReached = BPS_NONE;
			StopPlayItem();
			SetPlaybackMode(pls_idle);
			currentItem--;
			return StartPlayItem(list->PlayItemNumber(currentItem), list->PlayItemWaitTime(), 0, list->PlayingTime());
			}
		else
			GNRAISE(GNR_OBJECT_NOT_FOUND);
		}
	else if (playAllTracks)
		{
		WORD part, entry;

		part = TranslateBlockToPart(currentTrack, CurrentBlock());
		if (part)
			{
			entry = TranslatePartToEntry(currentTrack, part - 1);
			if (entry >= 100)
				return RestartTrackAtItem(entry);
			}

		if (currentTrack > 2)
			currentTrack--;
		else
			GNRAISE(GNR_OBJECT_NOT_FOUND);
		bpReached = BPS_NONE;
		StopPlayItem();
		SetPlaybackMode(pls_idle);
		return StartTrackAt(currentTrack, 0);
		}

	//
	//  No such thing as a previous play item
	//

	currentItem = 0;
	PlayItemCompleted();

	GNRAISE_OK;
	}

//
//  Go to next play item
//

Error VCDPlayListSequencer::GoNextItem(void)
	{
	if (list)
		{
		if (currentItem < list->NumberOfItems())
			{
			bpReached = BPS_NONE;
			StopPlayItem();
			SetPlaybackMode(pls_idle);
			currentItem++;
			return StartPlayItem(list->PlayItemNumber(currentItem), list->PlayItemWaitTime(), 0, list->PlayingTime());
			}
		else
			GNRAISE(GNR_OBJECT_NOT_FOUND);
		}
	else if (playAllTracks)
		{
		WORD part, entry;

		part = TranslateBlockToPart(currentTrack, CurrentBlock());	// Get currently played part
		if (part)
			{
			entry = TranslatePartToEntry(currentTrack, part + 1);
			if (entry >= 100)
				return RestartTrackAtItem(entry);
			}

		if (currentTrack <= NumberOfTitles())
			currentTrack++;
		else
			GNRAISE(GNR_OBJECT_NOT_FOUND);

		bpReached = BPS_NONE;
		StopPlayItem();
		SetPlaybackMode(pls_idle);
		return StartTrackAt(currentTrack, 0);
		}

	//
	//  No such thing as a next play item (e.g. single play item from selection list)
	//

	currentItem = 0;
	PlayItemCompleted();

	GNRAISE_OK;
	}

//
//  Still Phase Completed
//

Error VCDPlayListSequencer::StillPhaseCompleted(void)
	{
	if (state == pls_still)
		{
		GNREASSERT(AdvancePlayItem());
		}
	else if (state == pls_autopause)
		{
		SetPlaybackMode(pls_playing);
		GNREASSERT(ContinueAutoPause());
		}

	GNRAISE_OK;
	}

//
//  Start Play List
//

Error VCDPlayListSequencer::StartPlayList(VCDPlayList * list, DWORD flags)
	{
	if (IsIdle())
		{
		this->list = list;

		currentItem = 1;

		GNREASSERT(StartPlayItem(list->PlayItemNumber(currentItem), list->PlayItemWaitTime(), 0,
					  list->PlayingTime(), (flags & DDPSPF_TOPAUSE) != 0));

		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_OBJECT_IN_USE);
	}

//
//  Abort Play List
//

Error VCDPlayListSequencer::AbortPlayList(void)
	{
	if (!IsIdle())
		{
		SetPlaybackMode(pls_stopped);
		GNREASSERT(StopPlayItem());
		CancelStillPhase();

		currentTrack = 0;
		currentSegment = 0;

		if (file)
			{
			delete file;
			file = NULL;
			}

		list = NULL;
		file = NULL;
		}

	GNRAISE_OK;
	}

//
//  Complete Play Item
//

Error VCDPlayListSequencer::CompletePlayItem(void)
	{
	repeatCount = 0;
	waitTime = 0;

	switch (state)
		{
		case pls_stopped:
		case pls_idle:
			PlayItemCompleted();
			break;
		case pls_playing:
			GNREASSERT(CompleteStream());
			break;
		case pls_still:
			CancelStillPhase();
			GNREASSERT(AdvancePlayItem());
			break;
		case pls_autopause:
			GNREASSERT(CompleteStream());
			CancelStillPhase();
			SetPlaybackMode(pls_playing);
			GNREASSERT(ContinueAutoPause());
			break;
		}

	GNRAISE_OK;
	}

//
//  Get Current Play Item
//

WORD VCDPlayListSequencer::CurrentPlayItem(void)
	{
	if (currentSegment)
		return currentSegment + 999;
	else if (currentTrack)
		return currentTrack;
	else
		return 0;
	}

//
//  Get Current Block
//

DWORD VCDPlayListSequencer::CurrentBlock(void)
	{
	DWORD block = CurrentLocation() / CD_FRAME_SIZE;

	if (file)
		return file->AbsoluteBlockAddress(block);
	else
		return 0;
	}

//
//  Freeze current state
//

Error VCDPlayListSequencer::Freeze(VCDPLSState * buffer)
	{
	//
	//  Save data
	//
	buffer->transferCount = CurrentLocation();
	buffer->repeatCount = repeatCount;
	buffer->waitTime = waitTime;
	buffer->currentItem = currentItem;
	buffer->playAllTracks = playAllTracks;
	buffer->currentTrack = currentTrack;

	GNRAISE_OK;
	}

//
//  Restore previously saved state
//

Error VCDPlayListSequencer::Defrost(VCDPLSState * buffer, VCDPlayList * list, DWORD flags)
	{
	DVDDiskType			diskType;
	WORD					item;
	DWORD					currentSector;

	GNREASSERT(GetDiskType(diskType));

	SegPlayItemContent spic(diskType == DDT_VIDEO_CD);

	//
	//  Restore data
	//

	if (buffer->playAllTracks)
		{
		playAllTracks = TRUE;
		this->list = NULL;
		SetScanSpeed(0);
		numSectors = 0;
		SetPlaybackMode(pls_playing);
		currentTrack = buffer->currentTrack;
		GNREASSERT(OpenTrack(currentTrack));

		if (file)
			currentSector = FindPrevSequenceHeader(file, buffer->transferCount / CD_FRAME_SIZE);
		else
			currentSector = 0;

		GNREASSERT(RestartTrackAt(currentSector, (flags & DDPSPF_TOPAUSE) != 0));
		}
	else
		{
		playAllTracks = FALSE;
		this->list = list;
		repeatCount = buffer->repeatCount;
		waitTime = buffer->waitTime;
		currentItem = buffer->currentItem;
		item = list->PlayItemNumber(currentItem);
		SetScanSpeed(0);
		numSectors = 0;

		//
		//  Restart playback
		//

		if (item < 2)
			{
			PlaybackCompleted();
			}
		else if (item < 100)
			{
			GNREASSERT(OpenTrack(item));

			if (file)
				currentSector = FindPrevSequenceHeader(file, buffer->transferCount / CD_FRAME_SIZE);
			else
				currentSector = 0;

			SetPlaybackMode(pls_playing);
			GNREASSERT(TransferStream(file, currentSector, 0, !buffer->repeatCount, scanSpeed,
											  spic.IsHiResStill(), (flags & DDPSPF_TOPAUSE) != 0));
			}
		else if (item < 600)
			{
			GNREASSERT(OpenTrack(entries->GetEntryTrack(item - 99)));

			if (file)
				currentSector = FindPrevSequenceHeader(file, buffer->transferCount / CD_FRAME_SIZE);
			else
				currentSector = 0;

			SetPlaybackMode(pls_playing);
			GNREASSERT(TransferStream(file, currentSector, list->PlayingTime(), !buffer->repeatCount, scanSpeed,
											  spic.IsHiResStill(), (flags & DDPSPF_TOPAUSE) != 0));
			}
		else if (item < 1000)
			{
			GNRAISE(GNR_RANGE_VIOLATION);
			}
		else if (item < 2980)
			{
			GNREASSERT(OpenSegment(item - 999));
			SetPlaybackMode(pls_playing);
			spic = info->GetSegPlayItemContent(item - 999);
			GNREASSERT(TransferStream(file, 0, 0, !buffer->repeatCount, scanSpeed, spic.IsHiResStill(), (flags & DDPSPF_TOPAUSE) != 0));
			}
		else
			{
			GNRAISE(GNR_RANGE_VIOLATION);
			}
		}

	GNRAISE_OK;
	}


//
//  Pause Playback
//

Error VCDPlayListSequencer::Pause(void)
	{
	GNREASSERT(player->Pause());
	SetPlaybackMode(pls_paused);
	GNRAISE_OK;
	}

//
//  Resume Playback
//

Error VCDPlayListSequencer::Resume(void)
	{
	//
	// Resume playback
	//

	GNREASSERT(player->Resume());
	SetPlaybackMode(pls_playing);
	SetScanSpeed(0);
	GNRAISE_OK;
	}

//
//  Enter Stop State
//

Error VCDPlayListSequencer::EnterStopState(void)
	{
	SetPlaybackMode(pls_stopped);

	GNRAISE_OK;
	}

//
//  Pause due to breakpoint
//

void VCDPlayListSequencer::StartBreakpointStillCallback(void)
	{
	StartStillPhase(255);
	SetPlaybackMode(pls_still);
	player->Pause();
	}

//
//  Internal Get Mode
//

DVDPlayerMode VCDPlayListSequencer::InternalGetMode(void)
	{
	if (IsStillPhase())
		return DPM_STILL;
	else if (IsPlaying())
		return DPM_PLAYING;
	else if (IsPaused())
		return DPM_PAUSED;
	else if (IsScanning())
		return DPM_SCANNING;
	else
		return DPM_STOPPED;
	}

//
//  Number Of Titles
//

WORD VCDPlayListSequencer::NumberOfTitles(void)
	{
	if (numberOfTitles)
		return numberOfTitles;
	else
		{
		int i, t, m;

		m = entries->EntriesUsed();
		numberOfTitles = 1;
		for(i = 1; i <= m; i++)
			{
			t = entries->GetEntryTrack(i);
			if (t > numberOfTitles) numberOfTitles = (WORD)t;
			}
		numberOfTitles--;

		return numberOfTitles;
		}
	}

//
//  Translate Item (Track) and Part into Entry of ENTRIES.VCD
//

WORD VCDPlayListSequencer::TranslatePartToEntry(WORD track, WORD part)
	{
	int i, t, m;

	m = entries->EntriesUsed();
	for (i = 1; i <= m; i++)
		{
		t = entries->GetEntryTrack(i);
		if (t == track)
			{
			part--;
			if (!part) return i + 99;
			}
		}

	return track;
	}

//
//  Translate Item (Track) and Block into Part (Entry in ENTRIES.VCD)
//

WORD VCDPlayListSequencer::TranslateBlockToPart(WORD track, DWORD block)
	{
	int i, t, m;
	DWORD blk;
	WORD num = 0;

	m = entries->EntriesUsed();
	for (i = 1; i <= m; i++)
		{
		t = entries->GetEntryTrack(i);
		if (t == track)
			{
			blk = entries->GetEntrySector(i);
			if (blk <= block) num++;
			}
		}

	return num;
	}

//
//  Test if we are playing forward
//

BOOL VCDPlayListSequencer::IsPlayingForward(void)
	{
	return !(state == pls_scanning && scanSpeed < 0);
	}

//
//  Return current duration (in blocks/sectors) (called when using a VCD)
//

Error VCDPlayListSequencer::CurrentDuration(DWORD & dur)
	{
	if (state != pls_still)
		return VCDStreamSequencer::CurrentDuration(dur);
	else
		{
		if (waitTime != 0xff)
			dur = waitTime * CD_FRAME_RATE * CD_FRAME_SIZE;
		else
			dur = 0;
		GNRAISE_OK;
		}
	}

//
// Return current duration in seconds (only called when using a Super-VCD)
//

Error VCDPlayListSequencer::CurrentPlayingTime(DWORD & time)
	{
	if (tracks)
		{
		if (currentSegment)
			{
			GNREASSERT(CurrentDuration(time));
			time /= (75 * CD_FRAME_SIZE);
			}
		else if (currentTrack)
			return tracks->TrackPlayingTime(currentTrack-1);
		else
			time = 0;
		}
	else
		{
		// SPECIAL CASE: S-VCD without the file tracks.vcd
		return currentDurationInMilliSecs/1000;
		}

	GNRAISE_OK;
	}

//
//  Get available streams
//

Error VCDPlayListSequencer::GetAvailStreams(BYTE & audio, DWORD & subPicture)
	{
	BOOL isDualAudio;

	if (tracks)
		{
		if (currentTrack)
			{
			isDualAudio = tracks->IsDualAudioStream(currentTrack-1);
				{
				audio = 0x0;
				for(int strm = 0; strm < 2; strm++)
					{
					audio |= MKFLAG(strm);
					}
				}
			}
		else
			audio = MKFLAG(0);
		}
	else
		audio = MKFLAG(0);

	subPicture = 0x00000000;

	GNRAISE_OK;
	}

//
//  Get current audio stream
//

WORD VCDPlayListSequencer::GetCurrentAudioStream(void)
	{
	return player->GetAudioStreamChannel();
	}

Error VCDPlayListSequencer::GetAudioStreamAttributes(int num, DVDAudioStreamFormat & format)
	{
	format.languageCode = 0xffff;
	format.languageExtension = 0xffff;
	format.codingMode = DAM_MPEG1;			// VCD --> MPEG-1, S-VCD --> MPEG-1 or MPEG-2
	format.bitsPerSample = 16;
	format.samplesPerSecond = 44100;

	if (currentTrack && tracks)
		{
		if (tracks->IsMultiChannelAudioTrack(currentTrack))
			format.channels = 5+1;
		else
			format.channels = 2;
		}
	else
		format.channels = 2;

	GNRAISE_OK;
	}

//
//  Audio stream change
//

Error VCDPlayListSequencer::AudioStreamChange(WORD stream)
	{
	return player->SetAudioStreamChannel(stream);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\VCDSelSeq.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef VCDSELSEQ_H
#define VCDSELSEQ_H

#include "VCDPlaySeq.h"

#define VCD_MAX_BUTTON_NUMBER 103

class VCDSelectionListSequencer : public VCDPlayListSequencer
	{
	protected:
		VCDPSD				*	psd;

		VCDPlayList			*	playList;
		VCDSelectionList	*	selectionList;
		VCDActionList		*	actionList;

		WORD pendingSelection;
		WORD currentListOffset;

		// VCDPlayListSequencer functions.
		virtual Error PlayListCompleted(Error error = GNR_OK);
		virtual void PlayItemCompleted(void);

		Error StartSelectionList(VCDSelectionList * list, DWORD flags = DDPSPF_NONE);
		virtual Error StartPlayList(VCDPlayList * list, DWORD flags = DDPSPF_NONE);

		BOOL IsValidOffset (WORD offset);

		//
		//  Freezing stuff
		//

		struct VCDSLSFreezeState
			{
			WORD currentListOffset;

			VCDPlayListSequencer::VCDPLSState vcdPLSState;
			};

		Error Freeze(VCDSLSFreezeState * buffer);
		Error Defrost(VCDSLSFreezeState * buffer, DWORD flags);

	public:
		VCDSelectionListSequencer(WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher);

		Error Initialize(VCDFileSystem * vcfs, VCDInfo * info, VCDEntries * entries,
							  VCDTracks * tracks, VCDSearch * search, VCDPSD * psd);

		Error StartActionList(WORD offset, DWORD flags = DDPSPF_NONE);
		Error AbortActionList(void);

		Error GoTopList(void);
		Error GoPreviousList(void);
		Error GoNextList(void);
		Error GoReturnList(void);
		Error GoDefaultList(void);
		Error GoSelectionList(WORD selection);
		Error GoSelectionListAt(int x, int y);

		Error TitlePlay(WORD title, DWORD flags = DDPSPF_NONE);
		Error TimePlay(WORD title, DVDTime time, BOOL toPause = FALSE);

		Error PreviousFunction(void);
		Error NextFunction(void);

		BOOL	IsButtonAt(int x, int y);
		BOOL	HasPositionalButtons(void);

		BOOL	InPlayList(void) {return playList != NULL;}
		BOOL	InSelectionList(void) {return selectionList != NULL;}

		WORD	CurrentList(void) {return currentListOffset;}

		Error GetAvailStreams(BYTE & audio, DWORD & subPicture);
		WORD	GetCurrentAudioStream(void);
		Error AudioStreamChange(WORD stream);

		Error GetCurrentButtonState(WORD & minButton, WORD & numButtons, WORD & currentButton);
		void	GetButtonInformation(WORD & numberOfButtons, WORD & userButtonOffset, DVDButtonInformation * info);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\VCDStreamServer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  VCD Stream Server Class
//
////////////////////////////////////////////////////////////////////

#include "VCDStreamServer.h"
#include "Library\Common\vddebug.h"
#include "Library\Common\Prelude.h"


////////////////////////////////////////////////////////////////////
//
// Class: VCDStreamBuffer
//
// Description: Stream buffer management for Video-CD data with
//  lock/unlock mechanism.
//
////////////////////////////////////////////////////////////////////

//
// Constructor
//

VCDStreamBuffer::VCDStreamBuffer(DWORD numBuffers)
	{
	blocks = new DriveBlock[numBuffers];
	blockIndices = new DWORD[numBuffers];

	buffers = new MPEGDataSizePair[numBuffers];
	numBlocks = numBuffers;
	file = NULL;
	for (int i=0; i<CD_FRAME_SIZE; i++)
		dummyBlock[i] = 0;

	this->bufferSize = numBuffers * CD_FRAME_SIZE;
	Flush();
	}

//
// Destructor
//

VCDStreamBuffer::~VCDStreamBuffer(void)
	{
	Flush();

	delete[] blocks;
	delete[] blockIndices;
	delete[] buffers;
	}

//
// Function:
//		Flush
// Description:
//		Resets the variables and unlocks the buffers.
//

void VCDStreamBuffer::Flush(void)
	{
	if (file)
		{
		if (validBlocks)
			ClearBlocks();
		file = NULL;
		}

	bufferStart = bufferEnd = 0;
	dataBlocksInBuffer = 0;
	dataBlocksBackScanRead = 0;
	validBlocks = 0;
	firstBlock = 0;
	lastBlock = 0;
	}

void VCDStreamBuffer::ClearBlocks(void)
	{
	if (file)
		UnlockBuffers(file, 0, validBlocks);

	validBlocks = 0;
	firstBlock = lastBlock = 0;
	}

//
// Function:
//		ChangeBufferSize
// Description:
//		Not implemented
//

Error VCDStreamBuffer::ChangeBufferSize(DWORD size)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
// Function:
//		UnlockBuffers
// Parameters:
//		file: pointer to a Video-CD data file
//		at: offset to the existing DriveStreamBlockBuffer
//		num: number of blocks to unlock
// Description:
//		Unlocks the existing Drive Stream Block Buffers
//

void VCDStreamBuffer::UnlockBuffers(VCDDataFile * file, DWORD at, DWORD num)
	{
	RequestHandle rh;

	if (file)
		{
		//DP("unlock blocks %d, num %d, at %d", blockIndices[at], num, at);
		file->UnlockBlocks(blockIndices[at], num, blocks + at, DAT_UNLOCK_CLEAN, &rh);
		}

	}

//
// Function:
//		GetCurrentBlock
// Return Value:
//		byte pointer to the current block
// Description:
//		Returns a pointer to the current data block if data is available otherwise a NULL pointer.
//

BYTE * VCDStreamBuffer::GetCurrentBlock(void)
	{
	if(IsDataAvailable())
		return (blocks[firstBlock].data);
	else
		return NULL;
	}

//
//  Advance first block
//

Error VCDStreamBuffer::AdvanceFirstBlock(int amount)
	{
	// the maximum number of blocks that can be unlocked is the current number of blocks that are locked.
	// If 'amount' is greater than the current data blocks (this is mostly the case when in scanning mode)
	// then just Flush all buffers.
	if (amount <= (int)dataBlocksInBuffer)
		{
		dataBlocksInBuffer -= amount;
		}
	else
		{
		//Flush() --> is performed by the caller!!!!
		dataBlocksInBuffer = 0;
		}

	firstBlock = (firstBlock + amount) % numBlocks;

	GNRAISE_OK;
	}

//
//  Backward first block
//

Error VCDStreamBuffer::BackwardFirstBlock(DWORD amount)
	{
	if(firstBlock >= amount)
		{
		firstBlock -= amount;
		dataBlocksInBuffer = lastBlock - firstBlock + 1;
		dataBlocksBackScanRead += amount;
		}
	else
		{
		firstBlock = 0;
		dataBlocksInBuffer = 0;
		dataBlocksBackScanRead = 0;
		}

	GNRAISE_OK;
	}

//
//  Prepare backward scan
//

void VCDStreamBuffer::PrepareBackwardScan(void)
	{
	lastBlock--;
	firstBlock = lastBlock;
	dataBlocksBackScanRead = 0;
	}

//
//  Read into buffer
//

Error VCDStreamBuffer::ReadIntoBuffer(VCDDataFile * file, DWORD block, DWORD at, DWORD num)
	{
	RequestHandle rh;
	Error error;
	int i;

	if(validBlocks)
		{
		ClearBlocks();
		}
	//DP("Lock blocks %d, num %d, at %d\n", block, num, at);
	error = file->LockBlocks(block, num, blocks + at, DAT_LOCK_AND_READ, &rh);

	if (!IS_ERROR(error))
		{
		for (i=0; i<(int)num; i++)
			{
			if (IS_ERROR(blocks[at + i].err))
				{
				DP("error in block %d", i);
				blocks[at+i].data = dummyBlock;
				}
			else
				buffers[at+i].data = blocks[at+i].data;
			buffers[at+i].size = CD_FRAME_SIZE;
			buffers[at+i].timeStamp = -1;
			blockIndices[at + i] = block + i;
			}
		}
	else
		{
		UnlockBuffers(file, at, num);
		}

	GNRAISE(error);
	}

//
// Function:
//		ReadIntoBuffer
// Parameters:
//		file: pointer to Video-CD data file
//		blockIntegrity: pointer to a Video-CD block integrity class to check the data integrity
//		block: block number that should be read
//		num: number of bytes to read in blocks
// Return Value:
//		an Error value
// Description:
//

Error VCDStreamBuffer::ReadIntoBuffer(VCDDataFile * file, VCDBlockIntegrity * blockIntegrity, DWORD block, DWORD numBlocksToRead, DWORD &numBlocksDone, BOOL isScanning)
	{
	DWORD i;			// loop counter
	DWORD num;
	Error error = GNR_OK;

	this->file = file;

	if (isScanning)
		{
		error = ReadIntoBuffer(file, block, 0, numBlocksToRead);
		if(IS_ERROR(error))
			{
			lastBlock = num = 0;
			}
		else
			{
			lastBlock = num = numBlocksToRead;
			dataBlocksInBuffer += num;
			validBlocks = dataBlocksInBuffer;
			}
		}
	else
		{
		//
		//  Determine number of blocks to read during this repetition
		//

		num = numBlocksToRead >= numBlocks ? numBlocks : numBlocksToRead;

		//
		//	Perform the read
		//

		error = ReadIntoBuffer(file, block, bufferEnd / CD_FRAME_SIZE, num);

		if(!IS_ERROR(error))
			{
			//
			//	Check data integrity
			//

			for (i=0; i<num; i++)
				{
				if (!blockIntegrity->CheckBlockIntegrity(blocks[bufferEnd / CD_FRAME_SIZE + i].data))
					memset(blocks[bufferEnd / CD_FRAME_SIZE + i].data, 0, CD_FRAME_SIZE);
				else
					blockIntegrity->AssureBlockPTSIntegrity(blocks[bufferEnd / CD_FRAME_SIZE + i].data);
				}
			}

		lastBlock += num;
		if (lastBlock >= numBlocks)
			lastBlock = 0;
		dataBlocksInBuffer += num;
		validBlocks = dataBlocksInBuffer;
		}

	numBlocksDone = num;

	GNRAISE(error);
	}

//
// Function:
//		WriteFromBuffer
// Parameters:
//		player: pointer to Video-CD player
//		offset: byte offset within block
//		num: number of bytes to write
// Return Value:
//		 number of bytes that were written
// Description:
//		Sends data to the player.
//

DWORD VCDStreamBuffer::WriteFromBuffer(VCDPlayer * player, DWORD offset, DWORD num)
	{
	DWORD done;

	buffers[firstBlock].data = blocks[firstBlock].data + offset;
	buffers[firstBlock].size = num;

	done = player->SendDataMultiple(buffers+firstBlock, num);

	return done;
	}

////////////////////////////////////////////////////////////////////
//
//  Class: VCDStreamSequencer
//
//  Description:
//
////////////////////////////////////////////////////////////////////

//
// Constructor
//

VCDStreamSequencer::VCDStreamSequencer (WinPortServer *server, UnitSet units, EventDispatcher* pEventDispatcher) : WinPort (server)
	{
	int i;

	playRequest = TRUE;

	for (i = 0;  i < 256;  i++)
		searchSteps[i] = 4;
	searchSteps[0x00] = 2;
	searchSteps[0x01] = 1;
	searchSteps[0xb3] = 10000;
	searchSteps[0xb8] = 10000;

	streamBuffer = NULL;
	packHeaderOffset = 0;

	//
	//  Create player
	//

	player = new VCDPlayer(server, units, pEventDispatcher);
	}

//
//  Destructor
//

VCDStreamSequencer::~VCDStreamSequencer (void)
	{
	delete streamBuffer;
	delete player;
	}

//
//  Initialize
//

Error VCDStreamSequencer::Init(void)
	{
	//
	//  Initialize player
	//

	if (!player)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	GNREASSERT(player->Init());
	player->SetRefiller(this);

	streamBuffer = new VCDStreamBuffer(NUM_VCD_BUFFERS);

	FlushBuffers();

	GNRAISE_OK;
	}

//
//  Test if there is a sequencer header in the sector
//

BOOL VCDStreamSequencer::IsSequenceHeaderInSector(BYTE * sector)
	{
	BYTE	*	p;
	int	*	steps;
	BYTE	*	end;

	p = sector;

	if (p[18] == 0x62)
		{
		steps = searchSteps;
		end = p + 2347;

		p += 24 - 1;
		do {
			p += 4;

			while (p < end) p += steps[p[0]];

			p -= 10000;
			} while (p > sector  &&  ((p[0] != 0xb3 && p[0] != 0xb8) ||  p[-1] != 0x01  ||  p[-2] != 0x00  ||  p[-3] != 0x00));

		return p > sector;
		}
	else
		return FALSE;
	}

//
//	Function:
//		FindTimeSearchSector
//	Parameter:
//		file: pointer to a VCDDataFile
//		time: desired time in milliseconds
//	Return Value:
//		sector that belongs to the desired time
// Description:
//		Returns the nearest sector for a given playing time
//		The 'time' parameter must be given in milliseconds!
//

DWORD VCDStreamSequencer::FindTimeSearchSector(VCDDataFile * file, DWORD time)
	{
	BOOL foundValidSector = FALSE;
	BOOL foundSector = FALSE;
	DWORD currentTime = 0;
	DWORD numBlocksRead;
	int blocksAvailable;
	int num;
	DWORD maxSector, sector;
	DWORD desiredTimeInSeconds;
	DWORD numSectors;
	WORD numSearchValidSector = 0;
	WORD numSearchExactSector = 0;
	BOOL readError = FALSE;


	//
	// determine the number of sectors this track contains
	//

	if (IS_ERROR(file->GetNumberOfBlocks(numSectors)))
		numSectors = 0;


	desiredTimeInSeconds = time/1000;

	//
	// calculate a start sector to search for
	// max. bitrate is 2.6 Mbps --> 140 sectors/s
	// bitrate 2.3 Mbps ---> 124 sectors/s
	// bitrate 2 Mbps ---> 108 sectors/s
	//

	// the sector we're searching for cannot be greater than maxSector
	// because of the max bitrate of 2.6 Mbps!
	maxSector = desiredTimeInSeconds * 140;
	if (maxSector > numSectors) maxSector = numSectors;
	sector = desiredTimeInSeconds * 108;


	while(!foundSector && !readError)
		{
		//
		// flush buffers
		//

		streamBuffer->Flush();

		//
		// read new data
		//
		num = min(maxSector - sector, NUM_VCD_BUFFERS);
		streamBuffer->ReadIntoBuffer(file, this, sector, num, numBlocksRead, FALSE);

		foundValidSector = FALSE;
		currentTime = 0;

		//
		//  Now go and find a sector with a valid PTS
		//
		while (!currentTime && !readError)
			{
			//
			//  If buffer is empty, then read new data
			//

			blocksAvailable = streamBuffer->AvailBlocks();

			if (blocksAvailable <= 0)
				{
				streamBuffer->Flush();
				num = min(maxSector - sector, NUM_VCD_BUFFERS);
				streamBuffer->ReadIntoBuffer(file, this, sector, num, numBlocksRead, FALSE);
				}

			if (streamBuffer->IsDataAvailable())
				{
				//
				// extract the PTS in the current sector
				//

				currentTime = ExtractPTS(streamBuffer->GetCurrentBlock());
				}

			if (!currentTime)
				{
				AdvanceFirstBlock();
				sector += 1;
				numSearchValidSector++;
				if (numSearchValidSector >= 140)
					{
					DP("*** READ ERROR: no valid PTS found ***");
					readError = TRUE;
					}
				}
			else numSearchValidSector = 0;
			} // end while (!currentTime && !readError)

		//
		// calculate new sector start address when the sector is not exact enough
		//

		if (time > (currentTime + 750))
			{
			sector = (sector + maxSector)/2;
			foundSector = FALSE;
			}
		else if (time < (currentTime - 250))
			{
			DWORD s = maxSector - sector;
			maxSector = sector;
			if (sector > s)
				sector = sector - s;
			else
				sector = 0;
			foundSector = FALSE;
			}
		else
			foundSector = TRUE;

		numSearchExactSector++;
		if (numSearchExactSector >= 100)		// give up the search after 100 tries. 100 is just an estimated number!
			{
			DP("*** READ ERROR: no precise PTS found ***");
			readError = TRUE;
			sector = 0;
			}
		} // end while(!foundSector && !readError)

	return sector;
	}

//
//  Find the next sector for scanning
//

Error VCDStreamSequencer::FindNextScanSector(void)
	{
	BOOL	found;
	int	num;
	int targetSector;
	DWORD numBlocksRead;
	DWORD blocksAvailable;
	DWORD sectorsToJump;
	int	target;
	DWORD lastSector;

	BOOL isInitial = TRUE;
	found = FALSE;

	if (scanSpeed > 0)
		{
		//
		//  Forward scan: Determine sector to start search at
		//

		targetSector = scanSector + scanSpeed * 75 / 2;
		if (averageScanDistance)
			{
			targetSector = (targetSector + scanSector + averageScanDistance - NUM_VCD_BUFFERS / 2) / 2;
			}

		if ((DWORD)targetSector < currentSector) targetSector = currentSector;

		//
		//  Check if searched sector is already in buffer
		//

		num = streamBuffer->AvailBlocks() - (targetSector - currentSector);

		if (num <= 0)
			{
			sectorsToJump = -num;			// sectorsToJump contains the number of sectors to jump
			streamBuffer->Flush();

			if ((DWORD)numSectors > sectorsToJump)			// jump within current play item !
				{
				numSectors -= sectorsToJump;
				currentSector += sectorsToJump;
				}
			else	// no more sectors left in current play item !
				{
				currentSector += numSectors;
				numSectors = 0;
				}
			}
		else
			{
			AdvanceFirstBlock(targetSector - currentSector);
			}

		//
		//  Now go and find a sequence header
		//

		while (!found)
			{
			if (!numSectors) GNRAISE_OK;

			AdvanceFirstBlock();

			//
			//  If buffer is empty, then read new data
			//

			blocksAvailable = streamBuffer->AvailBlocks();
			if (blocksAvailable <= 0)
				{
				streamBuffer->Flush();

				if (numSectors > NUM_VCD_BUFFERS)
					num = NUM_VCD_BUFFERS;
				else
					num = numSectors;

				if (IS_ERROR(streamBuffer->ReadIntoBuffer(file, this, currentSector, num, numBlocksRead, TRUE)))
					{
					currentSector += num;			// skip sectors
					}
				else
					{
					numSectors -= num;
					currentSector += num;
					}
				}

			//
			//  Now check if we have a sequencer header in firstBuffer
			//

			if (streamBuffer->IsDataAvailable())
				{
				found = IsSequenceHeaderInSector(streamBuffer->GetCurrentBlock());
				}
			} // end while (!found)

		//
		// extract the PTS when scan sector was found
		//

		currentTimeInMilliSecs = ExtractPTS(streamBuffer->GetCurrentBlock());

		startSector = currentSector - streamBuffer->AvailBlocks();

		firstByte = 24;
		lastByte = firstByte + 2324;
		scanHeaderCount = 0;

		if (!averageScanDistance)
			averageScanDistance = currentSector - scanSector;
		else
			averageScanDistance = ((averageScanDistance * 3) + (currentSector - scanSector) + 2) >> 2;

		scanSector = currentSector;

		}
	else if (scanSpeed < 0)
		{

		//
		//  Backward scan: Determine sector to start search at
		//

		targetSector = scanSector + scanSpeed * 75 / 2;
		if (targetSector < 0)				// reached beginning of stream
			targetSector = 0;
		else if (averageScanDistance)
			targetSector = (targetSector + scanSector - averageScanDistance - NUM_VCD_BUFFERS / 2) / 2;

		//
		//	if the target sector is greater than the current sector than set target sector equal to current sector
		//

		if ((DWORD)targetSector > currentSector) targetSector = currentSector;

		//
		//  Check if target sector is already in buffer
		//

		target = streamBuffer->FreeBlocks() - (currentSector - targetSector);

		if (target < 0)	// the target is not in the buffer
			{
			if ((int)currentSector >= -target)			// current sector is within the current stream
				currentSector += target;
			else
				currentSector = 0;							// that means beginning of stream

		   streamBuffer->Flush();
			}
		else // target is in buffer!
			{
			}		// this case usually doesn't appear. Leave it for now! But has to be added later on! (mst 07/21/2000)

		//
		//  Repeat until we find a sequence header (or reached beginning of item)
		//

		while (!found)
			{
			streamBuffer->BackwardFirstBlock();

			//
			// if buffer is empty then read new data
			//

			if (streamBuffer->IsEmpty() || streamBuffer->AllBlocksRead())
				{
				//
				// initialize parameters
				//
				streamBuffer->Flush();

				if (!currentSector)						// if beginning of stream was found
					{
					streamBuffer->Flush();
					startSector = 0;

					GNRAISE_OK;
					}

				if (currentSector >= NUM_VCD_BUFFERS)			// if target is within the stream
					{
					currentSector -= NUM_VCD_BUFFERS;
					GNREASSERT(streamBuffer->ReadIntoBuffer(file, this, currentSector, NUM_VCD_BUFFERS, numBlocksRead, TRUE));
					}
				else	// if current sector is within the stream but the target is beginning of stream
					{
					lastSector = currentSector;		// lastSector contains the last known sector within the current play item
					currentSector = 0;
					GNREASSERT(streamBuffer->ReadIntoBuffer(file, this, currentSector, lastSector, numBlocksRead, TRUE));
					}

				streamBuffer->PrepareBackwardScan();
				} // end if (firstBuf <= 0)

			if (!(streamBuffer->AllBlocksRead()))
				{
				found = IsSequenceHeaderInSector(streamBuffer->GetCurrentBlock());
				}
			} // end while(!found)

		currentTimeInMilliSecs = ExtractPTS(streamBuffer->GetCurrentBlock());

		currentSector += numBlocksRead;
		num = streamBuffer->AvailBlocks() + 1;
		startSector = currentSector - num;
		firstByte = 24;
		lastByte = firstByte + 2324;
		scanHeaderCount = 0;
		GNREASSERT(file->GetNumberOfBlocks(numSectors));
		numSectors -= currentSector;

		if (!averageScanDistance)
			averageScanDistance = scanSector - currentSector;
		else
			averageScanDistance = ((averageScanDistance * 3) + (scanSector - currentSector) + 2) >> 2;

		scanSector = startSector;
		}

	GNRAISE_OK;
	}

//
//  Test if sector is correct
//

BOOL VCDStreamSequencer::CheckBlockIntegrity(BYTE * sector)
	{
	if (sector[0] == 0x00 && sector[11] == 0x00 &&
		 sector[1] == 0xff && sector[2] == 0xff &&
		 sector[3] == 0xff && sector[4] == 0xff &&
		 sector[5] == 0xff && sector[6] == 0xff &&
		 sector[7] == 0xff && sector[8] == 0xff &&
		 sector[9] == 0xff && sector[10] == 0xff)
		{
		if (sector[16] == sector[20] &&
			 sector[17] == sector[21] &&
          sector[18] == sector[22] &&
          sector[19] == sector[23])
			{
			return TRUE;
			}
		else
			return FALSE;
		}
	else
		return FALSE;
	}

//
//   Test if PTS of sector is correct
//

void VCDStreamSequencer::AssureBlockPTSIntegrity(BYTE * sector)
	{
	int t, i;
	DWORD pts;

	if (sector[39+packHeaderOffset] == 0xe0)
		{
		t = 42 + packHeaderOffset;
		while (sector[t] == 0xff) t++;				// extract stuffing bytes
		if ((sector[t] & 0xc0) == 0x40) t+= 2;
		if ((sector[t] & 0xf0) == 0x30)
			{
			pts = (((DWORD)(sector[t  ] & 0x0e) >> 1) << 29) |
				   (((DWORD)(sector[t+1]       )     ) << 21) |
					(((DWORD)(sector[t+2] & 0xfe) >> 1) << 14) |
					(((DWORD)(sector[t+3]       )     ) <<  6) |
					(((DWORD)(sector[t+4] & 0xfc) >> 2));

			if (previousVideoPTS && pts > previousVideoPTS + 45000)
				{
//				DP("Fixing PTS from %d , %d", previousVideoPTS, pts);
				previousVideoPTS += 45000;
				for(i=42; i<t+9; i++) sector[i] = 0xff;
				sector[t+9] = 0x0f;
				}
			else
				{
				previousVideoPTS = pts;
				}
			}
		else if ((sector[t] & 0xf0) == 0x20)
			{
			pts = (((DWORD)(sector[t  ] & 0x0e) >> 1) << 29) |
				   (((DWORD)(sector[t+1]       )     ) << 21) |
					(((DWORD)(sector[t+2] & 0xfe) >> 1) << 14) |
					(((DWORD)(sector[t+3]       )     ) <<  6) |
					(((DWORD)(sector[t+4] & 0xfc) >> 2));

			if (previousVideoPTS && pts > previousVideoPTS + 45000)
				{
//				DP("Fixing PTS from %d , %d", previousVideoPTS, pts);
				previousVideoPTS += 45000;
				for(i=42; i<t+4; i++) sector[i] = 0xff;
				sector[t+4] = 0x0f;
				}
			else
				{
				previousVideoPTS = pts;
				}
			}
		}

	}

//
// Function:
//		ExtractPTS
// Parameter:
//		sector: byte pointer that shows on a CD sector
// Return Value:
//		the extracted presentation time stamp in milliseconds
// Description:
//		extracts the PTS of the given sector and returns it in milliseconds.
//		NOTE: this function is only called when playing a S-VCD. This
//		function is only working correctly with MPEG-2 sector format!
//		It hasn't been tested with MPEG-1 sectors!
//

DWORD VCDStreamSequencer::ExtractPTS(BYTE * sector)
	{
	int t;
	BYTE pts_dts_flags = 0x0;
	DWORD pts, scr;

	//
	// first look for a valid PTS
	//

	pts_dts_flags = sector[43+packHeaderOffset] & 0xc0;

	if (pts_dts_flags == 0xc0 || pts_dts_flags == 0x80)
		{
		//
		// 24 bytes CD header
		// + 12 bytes Pack header
		// + 9 bytes offset in the packet header
		//
		t = 45 + packHeaderOffset;

		pts = (((DWORD)(sector[t  ] & 0x0e) >> 1) << 29) |
				(((DWORD)(sector[t+1]       )     ) << 21) |
				(((DWORD)(sector[t+2] & 0xfe) >> 1) << 14) |
				(((DWORD)(sector[t+3]       )     ) <<  6) |
				(((DWORD)(sector[t+4] & 0xfc) >> 2));

		//DP("PTS 0x%x", pts);

		return pts/45;
		}
	//
	// else look for a pack header
	//
	else if (sector[24] == 0x00 && sector[25] == 0x00 && sector[26] == 0x01 && sector[27] == 0xba)
		{
		//
		// no PTS found ---> instead extract the system clock reference (SCR)
		//

		t = 28;

		scr = ((((DWORD)(sector[t  ] & 0x38)	>> 1)	| ((DWORD)(sector[t  ] & 0x03))) << 27) |
				(((DWORD) (sector[t+1]		  )		 )												<<	19) |
				((((DWORD)(sector[t+2] & 0xf8)	>> 1) | ((DWORD)(sector[t+2] & 0x03)))	<< 12) |
				(((DWORD) (sector[t+3]		  )		 )												<<  4) |
				(((DWORD) (sector[t+4] & 0xf8)	>> 4));

		return scr/45;
		}
	else
		return 0;
	}

//
// Function:
//		HasValidPTS
//	Parameter:
//		sector: pointer to the sector to be investigated
//	Return Value:
//		TRUE if there is a valid PTS within the sector
//		FALSE if the sector doesn't contain a valid PTS
//

BOOL VCDStreamSequencer::HasValidPTS(BYTE * sector)
	{
	BYTE pts_dts_flags = 0x0;

	pts_dts_flags = sector[43+packHeaderOffset] & 0xc0;

	if (pts_dts_flags == 0xc0 || pts_dts_flags == 0x80)
		return TRUE;
	else
		return FALSE;
	}

//
//  Refill the buffer
//

Error VCDStreamSequencer::RefillBuffer(void)
	{
	int blocksToRead;			// Total number of blocks to read
	DWORD numBlocksRead = 0;		// number of blocks that were read
	Error error = GNR_OK;

	//
	//  Check if we are already done
	//

	if (FinalSector())
		GNRAISE_OK;

	//
	//  Check if first buffer is empty => advance it
	//

	if (firstByte == lastByte)
		firstByte = lastByte = 0;

	//
	//  Determine number of blocks to read
	//

	blocksToRead = min(numSectors, (int)(NUM_VCD_BUFFERS - streamBuffer->AvailBlocks()));

	while (blocksToRead && !suspendTransfer)
		{
		//
		//  Read data
		//

		error = streamBuffer->ReadIntoBuffer(file, this, currentSector, blocksToRead, numBlocksRead, FALSE);

		//
		//  Advance sector pointers/counters
		//

		blocksToRead -= numBlocksRead;
		currentSector += numBlocksRead;
		numSectors -= numBlocksRead;
		}

	ReadFirstBufferInfo(streamBuffer->GetCurrentBlock());

	GNRAISE_OK;
	}

//
//  Advance first block
//

void VCDStreamSequencer::AdvanceFirstBlock(int amount)
	{
	if(streamBuffer->IsDataAvailable())
		{
		streamBuffer->AdvanceFirstBlock(amount);
		ReadFirstBufferInfo(streamBuffer->GetCurrentBlock());
		}
	}

//
//  Read information of current small buffer (i.e. first buffer)
//

void VCDStreamSequencer::ReadFirstBufferInfo(BYTE * sector)
	{
	BYTE * buf;
	int i;
	WORD playItem;
	DVDDiskType dt;

	//
	//  Find information in CD-ROM XA subheader
	//

	if(sector)
		{
		buf = sector;

		GetDiskType(dt);
		if (dt == DDT_VIDEO_CD || (dt == DDT_SUPER_VIDEO_CD && followsSVCDStd))
			{
			if (XTBF(1, buf[18])  &&  buf[19] != (hiresStill ? 0x1f : 0x3f))	// Video block and no still data
				{

				//
				// the pack header for MPEG-2 contains 2 bytes more than the one for MPEG-1.
				// So the stream id for MPEG-2 can be found two byte fields later.
				//

				//
				// if it is a video block extract the stream id but leave the audio stream id (either 0xC0 or 0xC1)
				//
				if (buf[39+packHeaderOffset] != 0xc0 && buf[39+packHeaderOffset] != 0xc1)
					buf[39+packHeaderOffset] &= ~0x07;					// Extract stream id

				firstByte = 24;					// Skip header (CD-specific information)
				lastByte = firstByte + 2324;	// We have 2324 bytes of user data in sector

				//
				//  Find picture header for scanning
				//

				if (scanSpeed)
					{
					for (i = firstByte;  i < lastByte;  i++)
						{
						scanHeaderBuffer = (scanHeaderBuffer << 8) | buf[i];
						if (scanHeaderBuffer == 0x00000100)		// Picture Header/Picture start code
							scanHeaderCount++;
						}

					//
					//  If we found next picture start code, then picture is complete
					//

					if (scanHeaderCount > 1)
						scanFrameComplete = TRUE;
					}
				}
			else if (XTBF(2, buf[18])  &&  !scanSpeed)	// Audio block
				{
				firstByte = 24;					// Skip header

				// We have 2304 bytes of user data (VCDs seem to have only 2304 bytes of valid audio data.
				// The last 20 bytes seem to be stuffing bytes
				// MST 08/31/2000
				// changed it because some S-VCDs doesn't play with 2304 bytes size (MST, 02/23/2001)
				// NOTE: should be investigated once more!!!
				//lastByte = firstByte + 2304;
				lastByte = firstByte + 2324;
				}

			} // end if (dt == DDT_VIDEO_CD)
		else if (dt == DDT_SUPER_VIDEO_CD)
			{
			playItem = CurrentPlayItem();
			if (isSegment || buf[16] == playItem - 1)	// either still pic or file number (byte 16 in CD header) equals current play item
				{
				if (XTBF(1, buf[18])  &&  buf[19] != (hiresStill ? 0x1f : 0x3f))	// Video block and no still data
					{

					//
					// the pack header for MPEG-2 contains 2 bytes more than the one for MPEG-1.
					// So the stream id for MPEG-2 can be found two byte fields later.
					//

					//
					// if it is a video block extract the stream id but leave the audio stream id (either 0xC0 or 0xC1)
					//
					if (buf[39+packHeaderOffset] != 0xc0 && buf[39+packHeaderOffset] != 0xc1)
						buf[39+packHeaderOffset] &= ~0x07;					// Extract stream id

					firstByte = 24;					// Skip header (CD-specific information)
					lastByte = firstByte + 2324;	// We have 2324 bytes of user data in sector

					//
					//  Find picture header for scanning
					//

					if (scanSpeed)
						{
						for (i = firstByte;  i < lastByte;  i++)
							{
							scanHeaderBuffer = (scanHeaderBuffer << 8) | buf[i];
							if (scanHeaderBuffer == 0x00000100)		// Picture Header/Picture start code
								scanHeaderCount++;
							}

						//
						//  If we found next picture start code, then picture is complete
						//

						if (scanHeaderCount > 1)
							scanFrameComplete = TRUE;
						}
					}
				else if (XTBF(2, buf[18])  &&  !scanSpeed)	// Audio block
					{
					firstByte = 24;					// Skip header

					// We have 2324 bytes of user data for a S-VCD
					lastByte = firstByte + 2324;
					} // end if (XTBF(1, buf[18])  &&  buf[19] != (hiresStill ? 0x1f : 0x3f))	// Video block and no still data

				autoPause = XTBF(4, buf[18]);		// Trigger bit from CD-ROM XA subheader

				} // end if (isSegment || buf[16] == playItem - 1)	// either still pic or file number (byte 16 in CD header) equals current play item
			}
		autoPause = XTBF(4, buf[18]);		// Trigger bit from CD-ROM XA subheader
		} // end if(sector)
	}

//
//  Send data to the player
//	 Only one block at a time is sent!
//

Error VCDStreamSequencer::SendSmallBuffer(void)
	{
	if (!SmallBufferEmpty())
		firstByte += streamBuffer->WriteFromBuffer(player, firstByte, lastByte - firstByte);

	GNRAISE_OK;
	}


//
//  Flush the buffer
//

Error VCDStreamSequencer::FlushBuffers(void)
	{
	lock.Enter();

	firstByte = lastByte = 0;
	if(streamBuffer)
		streamBuffer->Flush();
	numSectors = 0;
	playRequest = TRUE;
	autoPause = FALSE;
	startSector = 0;
	currentSector = 0;
	transfering = FALSE;
	previousVideoPTS = 0;
	file = NULL;
	suspendTransfer = FALSE;
	currentTimeInMilliSecs = 0;

	lock.Leave();

	GNRAISE_OK;
	}

//
//  Process messages
//

void VCDStreamSequencer::Message (WPARAM wParam, LPARAM lParam)
	{
	switch (wParam)
		{
		case STILL_TIME_MSG:
		case PLAYBACK_TIME_MSG:
			// Nothing to do.
			break;
		case AUTOPAUSE_REACHED_MSG:
			AutoPauseReached ();
			break;
		case PLAY_COMPLETED_MSG:
			file = NULL;
			playRequest = TRUE;
			PlaybackCompleted();
			break;
		}
	}

//
//	Set specific attributes that are needed for playback
//

Error VCDStreamSequencer::SetAttributes(BOOL svcdStdDisc)
	{
	this->followsSVCDStd = svcdStdDisc;

	GNRAISE_OK;
	}

//
//  Transfer stream and start playback if necessary
//

Error VCDStreamSequencer::TransferStream(VCDDataFile * file, DWORD firstSector, DWORD numSectors, BOOL final, int scanSpeed, BOOL hiresStill, BOOL toPause, BOOL isSegment)
	{
	DVDDiskType diskType;

	lock.Enter();

	if (firstSector & 0x80000000)
		BREAKPOINT;

//	DP("Start : num %d size %d first %d", numSectors, file->NumberOfBlocks(), firstSector);

	//
	//  Initialize stream sequencer
	//

	GNREASSERT(GetDiskType(diskType));
	if (!this->numSectors)
		{
		if (!numSectors)
			{
			GNREASSERT(file->GetNumberOfBlocks(numSectors));
			numSectors -= firstSector;
			}

		this->file = file;
		this->currentSector = firstSector;
		this->numSectors = numSectors;
		this->finalStream = final;
		this->scanSpeed = scanSpeed;
		this->hiresStill = hiresStill && player->SupportsHiResStills();
		if (diskType == DDT_SUPER_VIDEO_CD)	// S-VCD --> assume MPEG-2 (contains 2 bytes more in the pack header)
			packHeaderOffset = 2;
		else	// VCD
			packHeaderOffset = 0;
		this->isSegment = isSegment;

		scanHeaderCount = 0;
		scanHeaderBuffer = 0;
		scanFrameComplete = FALSE;
		scanFramePending = FALSE;
		scanSector = currentSector;
		averageScanDistance = 0;

		stillMode = FALSE;

		startSector = currentSector;

		if (scanSpeed) player->StartScan();

		transfering = TRUE;
		PerformTransfer(256);

		if (playRequest)
			{
			if (!scanSpeed) player->StartPlayback();
			playRequest = FALSE;
			}

		if (toPause)
			Pause();

		lock.Leave();

		GNRAISE_OK;
		}
	else
		{
		lock.Leave();

		GNRAISE(GNR_OBJECT_FULL);
		}
	}

//
//  Abort current transfer
//

Error VCDStreamSequencer::AbortTransfer(void)
	{
	suspendTransfer = TRUE;
	if(file)
		file->TerminateRequest(&rh);
	lock.Enter();
	suspendTransfer = FALSE;

	player->CancelCallback();
	player->CancelData();
	FlushBuffers();

	lock.Leave();

	GNRAISE_OK;
	}

//
//  Perform transfer(s)
//  This function is called from another thread.
//

Error VCDStreamSequencer::PerformTransfer(int maxTransfer)
	{
	int transfer;
	Error error;

	//
	// Perform several transfers
	//

	transfer = maxTransfer;
	while (transfer && !suspendTransfer)
		{
		lock.Enter();

		transfer--;

		if (transfering && !autoPause && !scanFramePending && !suspendTransfer &&
			 (!stillMode || player->IsCompleted() &&  (!streamBuffer->IsEmpty() || !FinalSector())))
			{
			//
			//  Send data and go to next small buffer if current is empty
			//

			SendSmallBuffer();
			if (SmallBufferEmpty() && !scanFrameComplete)
				AdvanceFirstBlock();
			else
				transfer = 0;

			//
			//  Refill buffer
			//

			if (streamBuffer->IsEmpty())
				{
				if (IS_ERROR(error = RefillBuffer()))
					{
					player->TerminatePlayback();
					lock.Leave();

					GNRAISE(error);
					}
				}

			//
			//  Perform misc. actions for different playback situations
			//

			if (autoPause)
				{
				//
				//  Perform autopause
				//

				player->SetCallback(player->transferCount, this);
				player->CompleteData();

				transfer = 0;
				}
			else if (scanFrameComplete && SmallBufferEmpty())
				{
				//
				//  Perform scan
				//

				player->SetCallback(0xffffffff, this);
				player->CompleteData();
				scanFramePending = TRUE;
				if (IS_ERROR(error = FindNextScanSector()))
					{
					player->TerminatePlayback();
					lock.Leave();

					GNRAISE(error);
					}

				if (FinalSector())
					{
					scanFramePending = FALSE;
					scanSpeed = 0;
					stillMode = TRUE;
					TransferCompleted();
					}

				transfer = 0;
				}
			else if (streamBuffer->IsEmpty() && FinalSector())
				{
				//
				//  Finish transfer at end of data
				//

				if (finalStream)
					{
					player->SetCallback(player->transferCount, this);
					player->CompleteData();
					stillMode = TRUE;
					}

				TransferCompleted();

				transfer = 0;
				}
			}

		lock.Leave();
		}

	//
	//  Test on breakpoints
	//

	SendMessage(BREAKPOINT_MSG, 0);
	GNRAISE_OK;
}

//
//  Complete current stream
//

Error VCDStreamSequencer::CompleteStream(void)
	{
	lock.Enter();

	finalStream = TRUE;

	if (!stillMode)
		GNREASSERT(PerformTransfer(0xffff));

	lock.Leave();

	GNRAISE_OK;
	}

//
//  Continue after autopause
//

Error VCDStreamSequencer::ContinueAutoPause(void)
	{
	lock.Enter();

	autoPause = FALSE;

	player->CancelData();
	startSector = currentSector;
	GNREASSERT(PerformTransfer(0xffff));

	player->StartPlayback();

	lock.Leave();

	GNRAISE_OK;
	}

//
//  Player callback
//  This function is called from another thread.
//

void VCDStreamSequencer::PlayerCallback(DWORD signalPosition)
	{
	lock.Enter();

	//
	//  Test on misc playback situations
	//

	if (autoPause)
		{
		// Since we run on another thread, we cannot directly call AutoPauseReached().
		SendMessage (AUTOPAUSE_REACHED_MSG, 0);
		}
	else if (scanFramePending)
		{
		scanFramePending = FALSE;
		scanFrameComplete = FALSE;
		lock.Leave();

		PerformTransfer(0xffff);

		lock.Enter();
		}
	else
		{
		// Since we run on another thread, we cannot directly call PlaybackCompleted().
		SendMessage (PLAY_COMPLETED_MSG, 0);
		}

	lock.Leave();
	}

//
//  Return current location as sector number
//

DWORD VCDStreamSequencer::CurrentLocation(void)
	{
	if (player->transferCount)
		{
		return (startSector +
				  ScaleLong(player->CurrentLocation(), player->transferCount,
								currentSector - startSector - streamBuffer->AvailBlocks())) * CD_FRAME_SIZE;
		}
	else
		return startSector * CD_FRAME_SIZE;
	}

//
//  Return current duration (in sectors)
//

Error VCDStreamSequencer::CurrentDuration(DWORD & dur)
	{
	if (file)
		{
		GNREASSERT(file->GetNumberOfBlocks(dur));
		dur *= CD_FRAME_SIZE;
		}
	else
		dur = 0;
	GNRAISE_OK;
	}

//
//  Test if we reached the last sector
//

BOOL VCDStreamSequencer::FinalSector(void)
	{
	return scanSpeed >= 0 ? !numSectors : !currentSector;
	}

//
// Return current playback time
//

Error VCDStreamSequencer::GetPlaybackTime(DVDTime & time)
	{
	DWORD secs;

	//
	// playback
	//

	if (!scanSpeed)
		{
		GNREASSERT(player->GetPlaybackTime(time));
		}

	//
	// scanning
	//

	else if (scanSpeed < 0 || scanSpeed > 0)
		{
		//
		// time in seconds is exactly enough for Video-CD
		//

		secs = currentTimeInMilliSecs / 1000;
		time = DVDTime(0, 0, secs, 0, 25);
		}

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\VCDSelSeq.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  VCD Selection List Sequencer
//
////////////////////////////////////////////////////////////////////

#include "Library/Common/vddebug.h"
#include "VCDSelSeq.h"

////////////////////////////////////////////////////////////////////
//
//  Macro Definitions
//
////////////////////////////////////////////////////////////////////

#define CHECK_UOPS(command) { DWORD oldUOPs;												\
										DWORD newUOPs;												\
										GNREASSERT(GetUOPs(oldUOPs));							\
										command;														\
										GNREASSERT(GetUOPs(newUOPs));							\
										if (oldUOPs != newUOPs)									\
											SendEvent(DNE_VALID_UOP_CHANGE, newUOPs);		\
										}

////////////////////////////////////////////////////////////////////
//
//  Function Definitions
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

VCDSelectionListSequencer::VCDSelectionListSequencer(WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher)
	: VCDPlayListSequencer(server, units, pEventDispatcher)
	, EventSender(pEventDispatcher)
	, ERSBreakpointControl(pEventDispatcher)
	{
	playList = NULL;
	selectionList = NULL;
	actionList = NULL;
	pendingSelection = 0;
	}

//
//  Initialize Sequencer
//

Error VCDSelectionListSequencer::Initialize(VCDFileSystem * vcdfs, VCDInfo * info, VCDEntries * entries,
														  VCDTracks * tracks, VCDSearch * search, VCDPSD * psd)
	{
	this->psd = psd;

	GNREASSERT(VCDPlayListSequencer::Initialize(vcdfs, info, entries, tracks, search));

	GNRAISE_OK;
	}

//
//  Play List Completed
//

Error VCDSelectionListSequencer::PlayListCompleted(Error error)
	{
	Error err;

	if (error == GNR_ITEM_NOT_FOUND)
		{
		err = AbortActionList();
		GNRAISE(err);
		}
	if (playList)
		{
		err = GoNextList();
		if (IS_ERROR(err))
			{
			AbortActionList();
			GNRAISE(err);
			}
		}
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);

	GNRAISE_OK;
	}

//
//  Calculate Random Number
//

static WORD Rnd(WORD max)
	{
	static DWORD seed = ::timeGetTime();
	seed = 1664525L * seed + 1013904223L;
	return (WORD)(seed % max);
	}

//
//  Play Item Completed
//

void VCDSelectionListSequencer::PlayItemCompleted(void)
	{
	WORD w;

	if (selectionList)
		{
		if (pendingSelection)
			{
			w = selectionList->SelectionOffset(pendingSelection);
			pendingSelection = 0;
			}
		else
			{
			w = selectionList->TimeOutListOffset();
			if (w == 0xffff)
				{
				w =  (WORD)(selectionList->SelectionOffset((WORD)(selectionList->BaseOfSelectionNumber() + Rnd((WORD)(selectionList->NumberOfSelections())))));
				}
			}

		if (IsValidOffset(w))
			{
			AbortActionList();
			StartActionList(w);
			}
		else
			{
			PlayListCompleted(GNR_ITEM_NOT_FOUND);
			EnterStopState();
			}
		}
	else
		EnterStopState();
	}

//
//  Start A Selection List
//

Error VCDSelectionListSequencer::StartSelectionList(VCDSelectionList * list, DWORD flags)
	{
	CHECK_UOPS(selectionList = list);
	actionList = list;

	pendingSelection = 0;

	GNREASSERT(VCDPlayListSequencer::StartPlayItem(list->PlayItemNumber(), list->TimeOutTime(), list->LoopCount() - 1,
																  0, (flags & DDPSPF_TOPAUSE) != 0));

	GNRAISE_OK;
	}

//
//  Start A Play List
//

Error VCDSelectionListSequencer::StartPlayList(VCDPlayList * list, DWORD flags)
	{
	CHECK_UOPS(playList = list; actionList = list);

	GNREASSERT(VCDPlayListSequencer::StartPlayList(list, flags));

	GNRAISE_OK;
	}

//
//  Check If Offset Is Valid
//

BOOL VCDSelectionListSequencer::IsValidOffset (WORD offset)
	{
	if (psd == NULL)
		return TRUE;

	if (offset == 0xffff)
		return FALSE;

	offset *= (WORD)(info->OffsetMultiplier());

	return (psd->IsPlayList(offset)  ||  psd->IsSelectionList(offset));
	}

//
//  Start Action List
//

Error VCDSelectionListSequencer::StartActionList(WORD offset, DWORD flags)
	{
	if (psd)
		{
		if (!actionList)
			{
			currentListOffset = offset;

			offset *= (WORD)(info->OffsetMultiplier());

			if (psd->IsPlayList(offset))
				{
				GNREASSERT(StartPlayList(psd->GetPlayList(offset), flags));
				}
			else if (psd->IsSelectionList(offset))
				{
				GNREASSERT(StartSelectionList(psd->GetSelectionList(offset), flags));
				}
			else
				{
				}
			}
		else
			GNRAISE(GNR_OBJECT_IN_USE);
		}

	GNRAISE_OK;
	}

//
//  Abort Action List
//

Error VCDSelectionListSequencer::AbortActionList(void)
	{
	//
	//  Stop current playback
	//

	GNREASSERT(AbortPlayList());

	//
	//  Invalidate lists
	//

	if (actionList)
		{
		delete actionList;

		actionList = NULL;
		CHECK_UOPS(playList = NULL; selectionList = NULL);
		}

	GNRAISE_OK;
	}

//
//  Go To Top Of List
//

Error VCDSelectionListSequencer::GoTopList(void)
	{
	if (actionList)
		{
		GNREASSERT(AbortActionList());
		GNREASSERTMAP(StartActionList(currentListOffset), GNR_OBJECT_NOT_FOUND);
		GNRAISE_OK;
		}

	GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Go To Previous List
//

Error VCDSelectionListSequencer::GoPreviousList(void)
	{
	WORD w;

	if (actionList)
		{
		w = actionList->PreviousListOffset();
		if (IsValidOffset(w))
			{
			GNREASSERT(AbortActionList());
			GNREASSERTMAP(StartActionList(w), GNR_OBJECT_NOT_FOUND);
			GNRAISE_OK;
			}
		}

	GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Go To Next List
//

Error VCDSelectionListSequencer::GoNextList(void)
	{
	WORD w;

	if (actionList)
		{
		w = actionList->NextListOffset();
		if (IsValidOffset(w))
			{
			GNREASSERT(AbortActionList());
			GNREASSERTMAP(StartActionList(w), GNR_OBJECT_NOT_FOUND);
			GNRAISE_OK;
			}
		}

	GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Go To Return List
//

Error VCDSelectionListSequencer::GoReturnList(void)
	{
	WORD w;

	if (actionList)
		{
		w = actionList->ReturnListOffset();
		if (IsValidOffset(w))
			{
			GNREASSERT(AbortActionList());
			GNREASSERTMAP(StartActionList(w), GNR_OBJECT_NOT_FOUND);
			}
		}

	GNRAISE_OK;
	}

//
//  Go To Default List
//

Error VCDSelectionListSequencer::GoDefaultList(void)
	{
	WORD w;

	if (selectionList)
		{
		w = selectionList->DefaultListOffset();
		if (IsValidOffset(w))
			{
			GNREASSERT(AbortActionList());
			GNREASSERTMAP(StartActionList(w), GNR_OBJECT_NOT_FOUND);
			GNRAISE_OK;
			}
		}

	GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Go To A Selection
//

Error VCDSelectionListSequencer::GoSelectionList(WORD selection)
	{
	WORD w;

	if (selectionList)
		{
		if (selection >= selectionList->BaseOfSelectionNumber() &&
			 selection <  selectionList->BaseOfSelectionNumber() + selectionList->NumberOfSelections())
			{
			w = selectionList->SelectionOffset(selection);
			if (IsValidOffset(w))
				{
				if (selectionList->JumpTiming())
					{
					pendingSelection = selection;
					GNREASSERT(CompletePlayItem());
					}
				else
					{
					GNREASSERT(AbortActionList());
					GNREASSERT(StartActionList(w));
					}
				}
			}
		}

	GNRAISE_OK;
	}

//
//  Execute Previous Function
//

Error VCDSelectionListSequencer::PreviousFunction(void)
	{
	Error err;

	if (selectionList)
		return GoPreviousList();
	else
		{
		err = GoPrevItem();
		if (err == GNR_OBJECT_NOT_FOUND)
			return GoPreviousList();
		else
			GNRAISE(err);
		}
	}

//
//  Execute Next Function
//

Error VCDSelectionListSequencer::NextFunction(void)
	{
	Error err;

	if (selectionList)
		return GoNextList();
	else
		{
		err = GoNextItem();
		if (err == GNR_OBJECT_NOT_FOUND)
			return GoNextList();
		else
			GNRAISE(err);
		}
	}

//
//  Check A Selection
//

static BOOL CheckSelection(DWORD pos, int x, int y)
	{
	return (x >= (int)XTBF(24, 8, pos) && x <= (int)XTBF(8, 8, pos) &&
		     y >= (int)XTBF(16, 8, pos) && y <= (int)XTBF(0, 8, pos));
	}

//
//  Return Button Information
//

void VCDSelectionListSequencer::GetButtonInformation(WORD & numberOfButtons, WORD & userButtonOffset,
																	  DVDButtonInformation * info)
	{
	DWORD	position;
	int	i, x, y, w, h;

	//
	//  Test on (extended) selection list
	//

	numberOfButtons = 0;
	if (selectionList != NULL)
		{
		userButtonOffset = selectionList->BaseOfSelectionNumber();

		//
		// Get standard buttons
		//

		if (position = selectionList->PreviousListSelectionArea() != 0)
			{
			x = (int)XTBF(position, 24, 8);
			y = (int)XTBF(position, 16, 8);
			w = (int)XTBF(position, 8, 8) - x + 1;
			h = (int)XTBF(position, 0, 8) - y + 1;
			player->TranslateButtonPosition(x, y);
			player->TranslateButtonPosition(w, h);
			info[numberOfButtons].x = (WORD)x;
			info[numberOfButtons].y = (WORD)y;
			info[numberOfButtons].w = (WORD)w;
			info[numberOfButtons].h = (WORD)h;
			numberOfButtons++;
			}

		if (position = selectionList->NextListSelectionArea() != 0)
			{
			x = (int)XTBF(position, 24, 8);
			y = (int)XTBF(position, 16, 8);
			w = (int)XTBF(position, 8, 8) - x + 1;
			h = (int)XTBF(position, 0, 8) - y + 1;
			player->TranslateButtonPosition(x, y);
			player->TranslateButtonPosition(w, h);
			info[numberOfButtons].x = (WORD)x;
			info[numberOfButtons].y = (WORD)y;
			info[numberOfButtons].w = (WORD)w;
			info[numberOfButtons].h = (WORD)h;
			numberOfButtons++;
			}

		if (position = selectionList->ReturnListSelectionArea() != 0)
			{
			x = (int)XTBF(position, 24, 8);
			y = (int)XTBF(position, 16, 8);
			w = (int)XTBF(position, 8, 8) - x + 1;
			h = (int)XTBF(position, 0, 8) - y + 1;
			player->TranslateButtonPosition(x, y);
			player->TranslateButtonPosition(w, h);
			info[numberOfButtons].x = (WORD)x;
			info[numberOfButtons].y = (WORD)y;
			info[numberOfButtons].w = (WORD)w;
			info[numberOfButtons].h = (WORD)h;
			numberOfButtons++;
			}

		if (position = selectionList->DefaultListSelectionArea() != 0)
			{
			x = (int)XTBF(position, 24, 8);
			y = (int)XTBF(position, 16, 8);
			w = (int)XTBF(position, 8, 8) - x + 1;
			h = (int)XTBF(position, 0, 8) - y + 1;
			player->TranslateButtonPosition(x, y);
			player->TranslateButtonPosition(w, h);
			info[numberOfButtons].x = (WORD)x;
			info[numberOfButtons].y = (WORD)y;
			info[numberOfButtons].w = (WORD)w;
			info[numberOfButtons].h = (WORD)h;
			numberOfButtons++;
			}

		//
		// Get all other buttons
		//

		for (i=0; i<selectionList->NumberOfSelections(); i++)
			{
			if (position = selectionList->SelectionArea(i + userButtonOffset) != 0)
				{
				x = (int)XTBF(position, 24, 8);
				y = (int)XTBF(position, 16, 8);
				w = (int)XTBF(position, 8, 8) - x + 1;
				h = (int)XTBF(position, 0, 8) - y + 1;
				player->TranslateButtonPosition(x, y);
				player->TranslateButtonPosition(w, h);
				info[numberOfButtons].x = (WORD)x;
				info[numberOfButtons].y = (WORD)y;
				info[numberOfButtons].w = (WORD)w;
				info[numberOfButtons].h = (WORD)h;
				}
			else
				{
				info[numberOfButtons].x = 0;
				info[numberOfButtons].y = 0;
				info[numberOfButtons].w = 0;
				info[numberOfButtons].h = 0;
				}
			numberOfButtons++;
			}

		//
		// Clear unused data
		//

		for (i=0; i<numberOfButtons; i++)
			info[i].autoAction = info[i].upperButton = info[i].lowerButton = info[i].leftButton = info[i].rightButton = 0;
		}
	}

//
//  Check If There Are Positional Buttons
//

BOOL VCDSelectionListSequencer::HasPositionalButtons(void)
	{
	return selectionList != NULL;
	}

//
//  Check If There Is A Button At A Certain Position
//

BOOL VCDSelectionListSequencer::IsButtonAt(int x, int y)
	{
	int sel;

	if (selectionList)
		{
		GNREASSERT(player->TranslateButtonPosition(x, y));

		if      (CheckSelection(selectionList->PreviousListSelectionArea(), x, y))
			return TRUE;
		else if (CheckSelection(selectionList->NextListSelectionArea(), x, y))
			return TRUE;
		else if (CheckSelection(selectionList->ReturnListSelectionArea(), x, y))
			return TRUE;
		else if (CheckSelection(selectionList->DefaultListSelectionArea(), x, y))
			return TRUE;
		else
			{
			sel = selectionList->BaseOfSelectionNumber();

			while (sel < selectionList->BaseOfSelectionNumber() + selectionList->NumberOfSelections())
				{
				if (CheckSelection(selectionList->SelectionArea(sel), x, y))
					{
					return TRUE;
					}
				sel++;
				}
			}
		}

	return FALSE;
	}

//
//  Go To Selection Given By Mouse Position
//

Error VCDSelectionListSequencer::GoSelectionListAt(int x, int y)
	{
	int sel;

	if (selectionList)
		{
		GNREASSERT(player->TranslateButtonPosition(x, y));

		if      (CheckSelection(selectionList->PreviousListSelectionArea(), x, y))
			GNREASSERT(GoPreviousList());
		else if (CheckSelection(selectionList->NextListSelectionArea(), x, y))
			GNREASSERT(GoNextList());
		else if (CheckSelection(selectionList->ReturnListSelectionArea(), x, y))
			GNREASSERT(GoReturnList());
		else if (CheckSelection(selectionList->DefaultListSelectionArea(), x, y))
			GNREASSERT(GoDefaultList());
		else
			{
			sel = selectionList->BaseOfSelectionNumber();

			while (sel < selectionList->BaseOfSelectionNumber() + selectionList->NumberOfSelections())
				{
				if (CheckSelection(selectionList->SelectionArea(sel), x, y))
					{
					return GoSelectionList((WORD)sel);
					}
				sel++;
				}
			}
		}

	GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

//
//  Title Play
//

Error VCDSelectionListSequencer::TitlePlay(WORD title, DWORD flags)
	{
	AbortActionList();
	GNREASSERT(StartTrackAt(title + 1, 0, (flags & DDPSPF_TOPAUSE) != 0));

	GNRAISE_OK;
	}

//
//  Time Play
//

Error VCDSelectionListSequencer::TimePlay(WORD title, DVDTime time, BOOL toPause)
	{
	AbortActionList();
	return StartTrackAt(title + 1, time.Millisecs() * 3 / 40, toPause);
	}

//
//  Get available streams
//

Error VCDSelectionListSequencer::GetAvailStreams(BYTE & audio, DWORD & subPicture)
	{
	return VCDPlayListSequencer::GetAvailStreams(audio, subPicture);
	}

//
//  Get current audio stream
//

WORD VCDSelectionListSequencer::GetCurrentAudioStream(void)
	{
	return VCDPlayListSequencer::GetCurrentAudioStream();
	}

//
//  Audio stream change
//

Error VCDSelectionListSequencer::AudioStreamChange(WORD stream)
	{
	return VCDPlayListSequencer::AudioStreamChange(stream);
	}

//
//  Get State Of Buttons
//

Error VCDSelectionListSequencer::GetCurrentButtonState(WORD & minButton, WORD & numButtons, WORD & currentButton)
	{
	if (selectionList)
		{
		minButton = selectionList->BaseOfSelectionNumber();
		numButtons = (WORD)(selectionList->NumberOfSelections());
		}
	else
		{
		minButton = 0;
		numButtons = 0;
		}

	currentButton = 0xffff;

	GNRAISE_OK;
	}

//
//  Freeze current player state
//

Error VCDSelectionListSequencer::Freeze(VCDSLSFreezeState * buffer)
	{
	//
	//  Save lower level state
	//

	GNREASSERT(VCDPlayListSequencer::Freeze(&(buffer->vcdPLSState)));

	//
	//  Save own state
	//

	buffer->currentListOffset = currentListOffset;

	GNRAISE_OK;
	}

//
//  Restore previously saved player state
//

Error VCDSelectionListSequencer::Defrost(VCDSLSFreezeState * buffer, DWORD flags)
	{
	WORD offset;

	if (psd)
		{
		//
		//  Stop Current Playback
		//

		GNREASSERT(AbortActionList());

		//
		//  Restore own state
		//

		offset = buffer->currentListOffset * info->OffsetMultiplier();

		if (psd->IsPlayList(offset))
			{
			playList = psd->GetPlayList(offset);
			selectionList = NULL;
			actionList = playList;
			GNREASSERT(VCDPlayListSequencer::Defrost(&(buffer->vcdPLSState), playList, flags));
			}
		else if (psd->IsSelectionList(offset))
			{
			playList = NULL;
			StartSelectionList(psd->GetSelectionList(offset));
			}
		else if (psd->IsEndList(offset))
			{
			}
		else
			GNRAISE(GNR_OBJECT_INVALID);
		}
	else
		{
		GNREASSERT(VCDPlayListSequencer::Defrost(&(buffer->vcdPLSState), NULL, flags));
		}

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\VCDStreamServer.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  VCD Stream Server Classes
//
////////////////////////////////////////////////////////////////////

#ifndef VCDSTSRV_H
#define VCDSTSRV_H

#include "VCDPlayer.h"
#include "VCDHeader.h"

//
//  Constants
//

#define NUM_VCD_BUFFERS			27

//
// Messages.
//
#define STILL_TIME_MSG			2001
#define AUTOPAUSE_REACHED_MSG	2002
#define PLAY_COMPLETED_MSG		2003
#define BREAKPOINT_MSG			2004
#define PLAYBACK_TIME_MSG		2005

////////////////////////////////////////////////////////////////////
//
//  VCD Block Integrity Class
//
////////////////////////////////////////////////////////////////////

class VCDBlockIntegrity
	{
	public:
		virtual BOOL CheckBlockIntegrity(BYTE * sector) = 0;
		virtual void AssureBlockPTSIntegrity(BYTE * sector) = 0;
	};

////////////////////////////////////////////////////////////////////
//
//  VCD Stream Buffer Class
//
////////////////////////////////////////////////////////////////////

class VCDStreamBuffer
	{
	protected:
		DriveBlock			*	blocks;
		DWORD					*	blockIndices;
		MPEGDataSizePair	*	buffers;
		DWORD						bufferStart, bufferEnd;		// buffer start and buffer end in bytes
		DWORD						bufferSize;						// size of all buffers in bytes
		DWORD						dataBlocksInBuffer;			// number of blocks currently filled with valid data for normal playback
		DWORD						validBlocks;					// number of blocks which have been locked but not yet unlocked
		DWORD						dataBlocksBackScanRead;		// number of blocks which have been examined yet during backward scanning
		DWORD						firstBlock, lastBlock;		// offset to first and last block
		DWORD						numBlocks;						// number of blocks
		DWORD						blockSize;
		BYTE						dummyBlock[CD_FRAME_SIZE];
		VCDDataFile			*	file;

		void	ClearBlocks(void);
		void	UnlockBuffers(VCDDataFile * file, DWORD at, DWORD num);
		Error ReadIntoBuffer(VCDDataFile * file, DWORD block, DWORD at, DWORD num);

	public:
		VCDStreamBuffer(DWORD bufferSize);
		virtual ~VCDStreamBuffer(void);

		BOOL	IsEmpty(void) {return dataBlocksInBuffer == 0;}					// returns TRUE if no data is currently available otherwise FALSE
		BOOL	IsDataAvailable(void) {return dataBlocksInBuffer > 0;}

		BOOL	AllBlocksRead(void) {return dataBlocksBackScanRead > NUM_VCD_BUFFERS;}

		DWORD	AvailBlocks(void) {return dataBlocksInBuffer;}
		DWORD	AvailData(void) {return AvailBlocks() * blockSize;}

		void	Flush(void);

		Error ChangeBufferSize(DWORD size);

		BYTE *GetCurrentBlock(void);
		Error AdvanceFirstBlock(int amount);
		Error BackwardFirstBlock(DWORD amount = 1);
		int	GetFirstBlock(void) {return firstBlock;}
		void	PrepareBackwardScan(void);
		DWORD	FreeBlocks(void) {return numBlocks - dataBlocksBackScanRead;}

		Error	ReadIntoBuffer(VCDDataFile * file, VCDBlockIntegrity * blockIntegrity, DWORD block, DWORD numBlocksToRead, DWORD &numBlocksDone, BOOL isScanning); // num in blocks
		DWORD	WriteFromBuffer(VCDPlayer * player, DWORD offset, DWORD num); // num in bytes
	};

////////////////////////////////////////////////////////////////////
//
//   VCD Stream Sequencer Class
//
////////////////////////////////////////////////////////////////////

class VCDStreamSequencer : public VCDStreamServer, protected VCDBlockIntegrity, public WinPort
	{
	protected:
		VCDDataFile	*	file;
		VCDPlayer	*	player;
		VDLocalMutex	lock;
		RequestHandle	rh;

		VCDStreamBuffer * streamBuffer;
		DWORD					streamBufferSize;

		DWORD	currentSector;			// current sector that is played
		DWORD scanSector, averageScanDistance;
		DWORD numSectors;				// Number of sectors left in current play item
		BOOL	finalStream;
		BOOL	playRequest;
		BOOL	stillMode;
		BOOL	autoPause;
		BOOL	scanFrameComplete;
		BOOL	scanFramePending;
		BOOL	hiresStill;
		BOOL	isSegment;
		BOOL	followsSVCDStd;

		//
		// a MPEG-2 pack header contains 2 bytes more than a MPEG-1 pack header.
		//
		WORD packHeaderOffset;
		DWORD currentTimeInMilliSecs;

		BOOL	transfering;
		int	transferSemaphore;
		int	scanSpeed;
		DWORD	scanHeaderBuffer;
		int	scanHeaderCount;
		int	startSector;
		DWORD	previousVideoPTS;
		BOOL	suspendTransfer;

		// Fast search algorithm for sequence header.
		int searchSteps[256];

		int firstByte, lastByte;			// Offset to firstBuffer, pointing to first/last byte within this sector

		BOOL	SmallBufferEmpty(void) {return firstByte == lastByte;}		// Block within buffer
		BOOL	FinalSector(void);

		BOOL	IsSequenceHeaderInSector(BYTE * sector);
		BOOL	CheckBlockIntegrity(BYTE * sector);
		void	AssureBlockPTSIntegrity(BYTE * sector);
		DWORD ExtractPTS(BYTE * sector);
		BOOL	HasValidPTS(BYTE * sector);

		DWORD FindTimeSearchSector(VCDDataFile * file, DWORD time);
		Error FindNextScanSector(void);
		void	KillLastFrame(void);

		Error RefillBuffer(void);
		Error SendSmallBuffer(void);
		void	AdvanceFirstBlock(int amount = 1);
		void	ReadFirstBufferInfo(BYTE * sector);

		Error FlushBuffers(void);
		Error ContinueAutoPause(void);

		virtual void TransferCompleted(void) {}
		virtual void PlaybackCompleted(void) {}
		virtual void AutoPauseReached(void) {ContinueAutoPause();}

		// WinPort function.
		virtual void Message (WPARAM wParam, LPARAM lParam);

	public:
		VCDStreamSequencer (WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher);
		virtual ~VCDStreamSequencer (void);

		Error Init(void);
		Error SetAttributes(BOOL svcdStdDisc);
		Error TransferStream(VCDDataFile * file, DWORD firstSector, DWORD numSectors, BOOL final, int scanSpeed = 0, BOOL hiresStill = FALSE, BOOL toPause = FALSE, BOOL isSegment = FALSE);
		Error AbortTransfer(void);
		Error CompleteStream(void);
		virtual Error Pause(void) = 0;

		// VCDStreamServer functions. Note these functions are called from another thread.
		Error	PerformTransfer(int maxTransfer);
		void	PlayerCallback(DWORD signalPosition);

		DWORD	CurrentLocation(void);
		virtual Error CurrentDuration(DWORD & dur);

		virtual WORD CurrentPlayItem(void) = 0;

		//
		// virtual function. Should be overloaded by VCDDiskPlayerClass::GetDiskType()
		//

		virtual Error GetDiskType(DVDDiskType & type) = 0;

		Error GetPlaybackTime(DVDTime & time);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\AVF\AVFFilter.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:       Driver/Dvdpldrv/Common/AVF/AVFFilter.h
// AUTHOR:     Sam Frantz
// COPYRIGHT:  (c) 2000 Ravisent Technologies, Inc.
// CREATED:    23-OCT-2000
//
// PURPOSE:    Generic file parser for audio and video files
//
// HISTORY:

#ifndef AVFFILTER_H
#define AVFFILTER_H

#include "Library/Common/Prelude.h"
#include "Library/Files/GenericFile.h"
#include "Driver/Dvdpldrv/Common/DVDTime.h"
#include "Driver/Dvdpldrv/Common/AVF/AVFFrame.h"

#ifdef _DEBUG
#include "Library/Support/Shell/ShellToolKit.h"
#endif

#define LOCKBLOCKS_SEQUENTIAL_ACCESS_FLAGS	(DAF_STREAMING | DAT_LOCK_AND_READ)
#define LOCKBLOCKS_RANDOM_ACCESS_FLAGS	(DAF_STREAMING | DAT_LOCK_AND_READ)
// #define LOCKBLOCKS_SEQUENTIAL_ACCESS_FLAGS	(DAT_LOCK_AND_READ)
// #define LOCKBLOCKS_RANDOM_ACCESS_FLAGS			(DAT_LOCK_AND_READ)

#define AVF_MAX_BLOCKS_WITH_NO_HEADER	MPEG_AUDIO_MAX_BLOCKS_WITH_NO_HEADER
	// this does not include any headers

enum AVFileParseState
	{
	AVFPARSE_BEGINNING_OF_FILE,
	AVFPARSE_BEGINNING_FRAME_SEARCH,
	AVFPARSE_IN_FRAME,
	AVFPARSE_AFTER_FRAME
	};

//
// class AVFParseState
//

class AVFParseState
	{
	public:
		AVFileParseState		genericState;
		DWORD						currentBlockUnparsedOffset;
		DWORD						currentFrameOffset;
		BOOL						needToCleanUpBlocks;
		DWORD						currentFrameNum;
		DWORD						relativeBlockNum;
		DWORD						timestamp; // in milliseconds
		DWORD						frameByteCountInFile;
		DWORD						bytesToSkip;

		AVFParseState(void);
		~AVFParseState(void);
	};

enum AVFFilterType
	{
	AVF_FILTER_TYPE_NONE,
	AVF_FILTER_TYPE_UNSUPPORTED,
	AVF_FILTER_TYPE_RAW_BINARY,
	AVF_FILTER_TYPE_MPEG_AUDIO,
	AVF_FILTER_TYPE_TEXT
	};

typedef struct
	{
 	KernelInt64		fileSize;
	DWORD				totalSkippedBytes;
	DWORD				blocksInThisFile;
	DWORD				numLastBlockInFile;
	DWORD				numBytesInLastBlock;
	DWORD				headerSize;
	DWORD				dataSize;
	} AVFileSizeAttributes;

class AVFFilter
	{
	protected:
		DWORD							bytesPerSecond;	// if not variable bitrate
		BOOL							durationIsAvailable;
		BOOL							forwardScanEnabled;
		BOOL							reverseScanEnabled;
		DWORD							totalSeconds;	// aka duration
		DWORD							diskAccessFlags;

	public:
#ifdef _DEBUG
		BOOL							enableLogging;
		void PrintDump(unsigned char *bp, int len, int maxlen=0, BOOL dumpASCII=TRUE);
		ShellToolKit				*pShell;
		void SetShell(ShellToolKit *shell) { pShell = shell; }
#endif
		AVFInfo						fileInfo;	// defined in DVDTime.h

		AVFParseState				genericParseState;
		AVFParseState				preservedParseState;
		GenericFile					*gf;
		AVFileSizeAttributes		sizeInfo;
		DriveBlockNode				randomAccessBlock; // must be used and unlocked within one function call
																 // this is intended for ID3v1 and other nonAudio tags.
		RequestHandle				rh;


		AVFFilter(void);
		virtual ~AVFFilter(void);
		virtual void Cleanup(void);
		virtual void Invalidate(void);
		virtual void InvalidateButPreserveInfo(void);

		virtual Error FindNextFrame(DriveBlockNode *pBlockNode, AVFFrame *pFrame, BOOL lastBlockInFile) = 0;
		virtual Error OpenFileInitialization(GenericFile * gf,
				AVFileSizeAttributes *pSizeInfo, AVFInfo *pInfo = (AVFInfo *) NULL, BOOL streamingEnabled=FALSE);
		BOOL	IsDurationAvailable(void) { return durationIsAvailable; }
		virtual Error DetermineDuration(void) = 0;

		virtual void InitFirstFrameInFile(void);
		virtual void InitNewFrameSameBlock(void);
		virtual void InitSameFrameNewBlock(void);
		virtual void InitNewFrameNewBlock(void);

		DWORD GetLengthInSeconds(void) { return totalSeconds; }
		void SetLengthInSeconds(DWORD sec) { totalSeconds = sec; }
		virtual BOOL IsVariableBitRate(void) { return FALSE; } // this should be overridden
		BOOL IsForwardScanEnabled(void) { return forwardScanEnabled; }
		BOOL IsReverseScanEnabled(void) { return reverseScanEnabled; }
		virtual void PreserveParseState(void) { preservedParseState = genericParseState; }
		virtual void RestoreParseState(void) { genericParseState = preservedParseState; }

		DWORD GetBytesPerSecond(void) { return bytesPerSecond; }
		void SetBytesPerSecond(DWORD bytesPerSec) { bytesPerSecond = bytesPerSec; }
		virtual int GetMaxLockedFrames(void) = 0;
		virtual int GetNumberOfCheckpoints(void) = 0;
		virtual int GetMaxFrameSize(void) = 0;
		virtual int GetMaxFramesToLockEachRefill(void) = 0;
		virtual int GetNumberOfRefillsPerTransfer(void) = 0;
		virtual Error ReadFileInfo(AVFInfo * appFileInfo) = 0;
		virtual BOOL NeedToDampVolumeDuringScan(DWORD minBitrate) { return TRUE; }
		virtual void SetNewFile(void) { durationIsAvailable = FALSE; }
		DWORD	GetDiskAccessFlags(void) { return diskAccessFlags; }
		virtual void SetDiskAccessSequential(void) { diskAccessFlags = LOCKBLOCKS_SEQUENTIAL_ACCESS_FLAGS; }
		virtual void SetDiskAccessRandom(void) { diskAccessFlags = LOCKBLOCKS_RANDOM_ACCESS_FLAGS; }
		virtual DWORD GetRandomAccessDiskFlags(void) { return LOCKBLOCKS_RANDOM_ACCESS_FLAGS; }
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\AVF\AVFDiskPlayer.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  AVFDiskPlayerClass
//
//  Implements the Audio/Video File Player
//
////////////////////////////////////////////////////////////////////

#ifndef AVFDISKPLAYER_H
#define AVFDISKPLAYER_H

#include "Driver/Dvdpldrv/Common/CDDiskPlayer.h"
#include "AVFStreamServer.h"
#include "Driver/Dvdpldrv/Common/Config/DiskPlayerFactory.h"

// These settings are used in AVFDiskPlayerClass::GetAVFileInfo to prevent
// dropouts during playback.  Currently only the "healthiest" and "longest"
// are used.  These numbers were fine-tuned according to the Vestel ATAPI
// 5508 player using 320 kbps MP3 files.  The "buffer bytes" should probably
// based upon the layer's buffer depth in a dynamic way, rather than using
// a hard-coded constant as I have done here.
#define AVF_VERY_LOW_BUFFERED_BYTES_FOR_CONCURRENT_DISK_SEEK	0x12000
#define AVF_LOW_BUFFERED_BYTES_FOR_CONCURRENT_DISK_SEEK			0x14000
#define AVF_HEALTHY_BUFFERED_BYTES_FOR_CONCURRENT_DISK_SEEK		0x16000
#define AVF_HEALTHIEST_BUFFERED_BYTES_FOR_CONCURRENT_DISK_SEEK	0x18000
#define AVF_CONCURRENT_DISK_SEEK_WAIT_MILLISEC						100
#define AVF_LONGER_CONCURRENT_DISK_SEEK_WAIT_MILLISEC				150
#define AVF_LONGEST_CONCURRENT_DISK_SEEK_WAIT_MILLISEC			200
#define AVF_MAX_CONCURRENT_DISK_SEEK_WAIT_LOOPS						15

enum AVFDiskPlayerTitleAccessMethod
	{
	AVFDP_FILE_ACCESS_METHOD_UNKNOWN,
	AVFDP_ACCESS_FILES_BY_ITERATOR,
	AVFDP_ACCESS_FILES_BY_TITLENUM
	};

#pragma warning(disable : 4250)

class AVFDiskPlayerClass : public CDDiskPlayerClass, public AVFStreamServer
	{
	protected:
		GenericFileSystem * avffs;

		// fileInfoReader is used for asynchronous file scanning, possibly during file playback
		AVFileManager				fileInfoReader;

		DWORD numberOfTitles;
		DWORD currentTitle;
		GenericFileSystemIterator * currentTitleIt;
		GenericFileSystemIterator * rootIt;

		BOOL	newFileEPSLatch;

		BOOL	GetNewFileEPSLatch(void) { return newFileEPSLatch; }
		void	ClearNewFileEPSLatch() { newFileEPSLatch = FALSE; }
		void	SetNewFileEPSLatch() { newFileEPSLatch = TRUE; }

		virtual Error InternalGetMode(DVDPlayerMode & mode);
		virtual Error IsPlayingForward(BOOL & forward);
		virtual void PlaybackCompleted(void);

		// some functions with 'title' in the parameter list will behave
		// differently when used with an application that only uses title
		// numbers and an app that only uses a gfsi.  The titleAccessMethod
		// member determines which access method is to be used.
		AVFDiskPlayerTitleAccessMethod	titleAccessMethod;
		void SetTitleAccessMethod(AVFDiskPlayerTitleAccessMethod mode)
			{ titleAccessMethod = mode; }
		AVFDiskPlayerTitleAccessMethod GetTitleAccessMethod(void)
			{ return titleAccessMethod; }

		void InitializeExtendedPlayerState(ExtendedPlayerState * pEps);

	public:
		AVFDiskPlayerClass(WinPortServer * server, UnitSet units, AVFDiskPlayerFactory * factory);

		~AVFDiskPlayerClass(void);

		virtual Error Init(WinPortServer * server, GenericProfile * profile, DVDDiskType diskType, GenericFileSystem * gfs);

		virtual Error GetMode(DVDPlayerMode & mode);

		virtual Error GetExtendedPlayerState(ExtendedPlayerState * eps);

		// virtual Error GetFileInfo(AVFInfo * info); // inherited from AVFStreamServer

		virtual Error StopStillPhase(void);

		virtual Error Exit(Error err = GNR_OK);

		virtual Error CallMenu(VTSMenuType menu);

		virtual Error PausePlayback(void);

		virtual Error ResumePlayback(void);

		virtual Error AdvanceFrame(void);

		virtual Error AdvanceFrameBy(int n);

		virtual Error SetPlaybackSpeed(WORD speed);

		virtual Error GetPlaybackSpeed(WORD & speed);

		virtual Error GetAudioStreamAttributes(WORD stream, DVDAudioStreamFormat	& attributes);

		virtual Error GetSubPictureStreamAttributes(WORD stream, DVDSubPictureStreamFormat	& attributes);

		virtual Error StartPresentation(DWORD flags);

		virtual Error GetCurrentLocation(DVDLocation & location);

		virtual Error GetCurrentDuration(DVDLocation & location);

		virtual Error GetTitleDuration(WORD title, DVDTime & duration);

		virtual Error GetCurrentTitleDuration(DVDTime & duration);

		virtual Error MenuAvail(VTSMenuType menu, BOOL & avail);

		virtual Error GetUOPs(DWORD & uops);

		virtual Error UOPPermitted(int uops, BOOL & permitted);

		virtual Error NumberOfTitles(WORD & num);

		virtual Error NumberOfPartOfTitle(WORD title, WORD & num);

		virtual Error GetAvailStreams(BYTE & audio, DWORD & subPicture);

		virtual Error GetCurrentAudioStream(WORD & stream);

		virtual Error GetCurrentSubPictureStream(WORD & stream);

		virtual Error IsCurrentSubPictureEnabled(BOOL & enabled);

		virtual Error GetNumberOfAngles(WORD title, WORD & num);

		virtual Error GetCurrentAngle(WORD & num);

		virtual Error TitlePlay(WORD title, DWORD flags = DDPSPF_NONE);

		virtual Error PTTPlay(WORD title, WORD part);

		virtual Error TimePlay(WORD title, DVDTime time);

		virtual Error GoUpProgramChain(void);

		virtual Error TimeSearch(DVDTime time);

		virtual Error PTTSearch(WORD part);

		virtual Error GoPrevProgram(void);

		virtual Error GoTopProgram(void);

		virtual Error GoNextProgram(void);

		virtual Error ExtendedPlay(DWORD flags, WORD title, WORD ptt, DVDTime time);

		virtual Error StartForwardScan(WORD speed);

		virtual Error StartBackwardScan(WORD speed);

		virtual Error GetScanSpeed(WORD & speed);

		virtual Error StartTrickplay(void);

		virtual Error StopScan(void);

		virtual Error StartReversePlayback(void);

		virtual Error ResumeFromSystemSpace(void);

		virtual Error ButtonUp(void);

		virtual Error ButtonDown(void);

		virtual Error ButtonLeft(void);

		virtual Error ButtonRight(void);

		virtual Error ButtonSelectAt(WORD x, WORD y);

		virtual Error ButtonActivate(void);

		virtual Error ButtonSelectAndActivate(WORD button);

		virtual Error ButtonSelectAtAndActivate(WORD x, WORD y);

		virtual Error IsButtonAt(WORD x, WORD y, BOOL & isButton);

		virtual Error HasPositionalButtons(BOOL & hasButtons);

		virtual Error MenuLanguageSelect(WORD language);

		virtual Error GetMenuLanguage(WORD & language);

		virtual Error AudioStreamChange(WORD stream);

		virtual Error SubPictureStreamChange(WORD stream, BOOL enable);

		virtual Error AngleChange(WORD angle);

		virtual Error ParentalLevelSelect(WORD level);

		virtual Error ParentalCountrySelect(WORD country);

		virtual Error GetCurrentDisplayMode(DisplayPresentationMode & mode);

		virtual Error SetDisplayMode(DisplayPresentationMode mode);

		virtual Error GetCurrentVideoStandard(VideoStandard & standard);

		virtual Error SelectInitialLanguage(WORD audioLanguage, WORD audioExtension, WORD subPictureLanguage, WORD subPictureExtension);

		virtual Error GetCurrentBitrate(DWORD & bitrate);

		virtual Error GetCurrentButtonState(WORD & minButton, WORD & numButtons, WORD & currentButton);

		virtual Error Freeze (DDPFreezeState * buffer, DWORD & size);

		virtual Error Defrost(DDPFreezeState * buffer, DWORD & size, DWORD flags);

		virtual Error SetBreakpoint(WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id);

		virtual Error ClearBreakpoint(DWORD id);

		virtual Error	GetAVFileInfo(GenericFileSystemIterator *gfsi, AVFInfo *pInfo);

		virtual Error PlayFile(GenericFileSystemIterator *gfsi, DWORD flags);
	};

#pragma warning(default : 4250)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\AVF\AVFile.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:       Driver/Dvdpldrv/Common/AVF/AVFile.h
// AUTHOR:     Sam Frantz
// COPYRIGHT:  (c) 2000 Ravisent Technologies, Inc.
// CREATED:    8-NOV-2000
//
// PURPOSE:    Generic file reader for audio and video files.
//
// HISTORY:

#ifndef AVFILE_H
#define AVFILE_H

#include "Library/Common/Prelude.h"
#include "Driver/Dvdpldrv/Common/DVDTime.h"
#include "Library/Files/GenericFile.h"
#include "Driver/Dvdpldrv/Common/AVF/AVFFrame.h"
#include "Driver/Dvdpldrv/Common/AVF/AVFFilter.h"

////////////////////////////////////////////////////////////////////
//
//  Drive Block performance Analysis
//
////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
#include "Library/Lowlevel/Timer.h"
// #define _DEBUG_DRIVE_BLOCK_PERFORMANCE_TEST
#ifdef _DEBUG_DRIVE_BLOCK_PERFORMANCE_TEST
#define AVF_BLOCK_PERFORMANCE_TEST_CACHE_DEPTH		300
#define AVF_BLOCK_PERFORMANCE_TEST_STRLEN				31
#define AVF_BLOCK_PERFORMANCE_STRING_LOCATIONS		16
typedef struct
	{
	DWORD		startTime;
	DWORD		readTime;
	DWORD		blockNum;
	Error		err;
	int		loc;
	}	AVFDebugDriveBlockPerformanceInfo;

class AVFDebugDriveBlockPerformanceTestClass
	{
	public:
		AVFDebugDriveBlockPerformanceTestClass(void);
		void Invalidate(void);
		char	str[AVF_BLOCK_PERFORMANCE_STRING_LOCATIONS][AVF_BLOCK_PERFORMANCE_TEST_STRLEN+1];
		void	AddLocationString(int num, char *strParam);
		int	count;
		AVFDebugDriveBlockPerformanceInfo	info[AVF_BLOCK_PERFORMANCE_TEST_CACHE_DEPTH];
		void OutputSummary(void);
		void StartRead(DWORD blockNum);
		void EndRead(Error errParam, int locParam);
	};

#endif
#endif

////////////////////////////////////////////////////////////////////
//
//	 defines
//
////////////////////////////////////////////////////////////////////

#define AVF_DUMMY_FRAME_RATE	25			// frame rate used in DVDTime construction

////////////////////////////////////////////////////////////////////
//
//  Type declarations
//
////////////////////////////////////////////////////////////////////

enum DriveBlockCleanUpMode
	{
	DBPM_CLEANUP_ALL_BLOCKS,
	DBPM_CLEANUP_ALL_EXCEPT_LAST_BLOCK,
	DBPM_CLEANUP_ALL_UNUSED_BLOCKS,
	DBPM_CLEANUP_ALL_UNUSED_BLOCKS_EXCEPT_THE_LAST_ONE
	};

////////////////////////////////////////////////////////////////////
//
//  AVFileManager Class
//
////////////////////////////////////////////////////////////////////


class AVFileManager
	{
	protected:
		AVFFilter		*pFilter;	// the content-specific file parser
		AVFFilterType	filterType;	// file type
		int				maxLockedFrames;				// maximum number of frames in frameList
		int				maxFrameSize;					// maximum size of a single frame in bytes
		int				frameDetailsElementSize;	// content-specific per-frame data size
		BOOL				streamingIsEnabled;			// affects the sizes of the above values
		BOOL				endOfFileReached;				// set to TRUE in ReadNextFrame()

		// Larger data structures, created and deleted in CreateNewFilter,
		// also deleted in destructor
		BOOL								dataStructuresInitialized;
		DriveBlockPool					blockList;
		AVFFramePool					frameList;
		AVFFrameLocatorPool			frameLocatorList;
		DriveBlockCheckPointList	checkPointList;

		// Block-level data
		DriveBlockNode					*pCurrentBlockNode;
		DWORD								lastBlockRead;
		DWORD								lastBlockCheckPointed;
		int								numberOfCheckPoints;
		DWORD								nextCheckPointBlock;
		int								nextCheckPointNumber;
		DWORD								numberOfBytesRead;
		DriveBlockNode					dummyScanBlock;
		DWORD								diskAccessFlags;
		DWORD								dummyBlockNumber;
		DriveBlockNode					*pRealCurrentBlockNode;

		// Frame-level data
		AVFFrame							dummyScanFrame;

		// File and Filesystem data
		GenericFileSystem				*avffs;
		GenericFileSystemIterator	*gfsi;
		GenericDiskItem				*gdi;
		GenericFile						*gf;
		DiskItemType					itemType;
		KernelInt64						itemSize;
		Error								err;
		RequestHandle					rh;

		//
		//  Internal functions
		//

		Error MoveToCheckPoint(DriveBlockCheckPointNode *pCheckPoint);

		//
		//  Playback functions
		//

		Error	OpenDataSource(GenericFileSystemIterator * gfsi, int numberOfCheckPoints = 0,
									BOOL sameFileAsLastTime = FALSE);

		Error CreateNewFilter(AVFFilterType type);

		void	SetEndOfFile(void) { endOfFileReached = TRUE; }
		void	ClearEndOfFile(void) { endOfFileReached = FALSE; }

	public:
		AVFileSizeAttributes		fileSizeInfo;
#ifdef _DEBUG
		void EnableLogging(BOOL b) { if (pFilter) pFilter->enableLogging = b; }
#ifdef _DEBUG_DRIVE_BLOCK_PERFORMANCE_TEST
		AVFDebugDriveBlockPerformanceTestClass	debugDriveTest;
#endif
#endif
		DWORD				driveBlockSize;
		DWORD				headerSize;
		DWORD				dataSize;
		DWORD				dataEnd;

		BOOL				lastBlockInFile;

		AVFileManager(void);
		~AVFileManager(void);

		virtual Error Init(GenericFileSystem * avffs, BOOL enableStreaming = TRUE);

		// DetermineFilterType() can be used to determine if a file is playable or not.
		// It is used internally for finding which format-specific filter to
		// instantiate.
		Error DetermineFilterType(GenericFileSystemIterator * gfsi, AVFFilterType &type);
		AVFFilterType GetFilterType(void) { return filterType; }

		// ReadNextFrame(pFrame); does the actual file reading to pull frames from
		// the file one at a time in sequence.  The pFrame it returns can be used or
		// ignored, since it is managed by the frameList.  If you want to use the
		// PFrame right away, you may call ReleaseFrames(pFrame) immediately when
		// you are through without calling GetNextFrame() or ReadNextFrame() in the
		// interim.
		Error ReadNextFrame(AVFFrame * & pFrame, BOOL useDummyStructures = FALSE);

		// UnGetLastFrame(pFrame) is used when traversing a file at speeds other than
		// normal play speed.  It is similar to ReleaseFrames(pFrame,1), except it
		// frees from the end of the list, rather than from the beginning.
		Error UnGetLastFrames(AVFFrame *pFrame, int count = 1);

		// ReadFrameByNumber() allows random access through a file. taking advantage of
		// the checkPoint mechanism.
		Error ReadFrameByNumber(DWORD requestedFrameNum, AVFFrame * & pFrame);

		// ReadFrameByTimestamp() allows random access through a file. taking advantage of
		// the checkPoint mechanism.  This function will read the first frame whose timestamp
		// is >= the given timeStamp (in milliseconds), subsequent calls to ReadNextFrame()
		// will pick up from this location.
		Error ReadFrameByTimestamp(DWORD milliSec, AVFFrame * & pFrame);

		// GetLockedFrameCount() returns the number of queued frames in the frameList.
		int	GetLockedFrameCount(void) { return(frameList.GetLockedFrameCount()); }

		//	GetNextFrame returns the nth frame from the beginning of the queue.
		// it's called with offset = 0 twice in a row without calling ReleaseFrames(),
		// it will return the same frame pointer.  So typically, you should alternately
		// call pFrame = GetNextFrame(); and ReleaseFrames(pFrame).  Use the defaults
		// of offset=0 and count=1 for simplicity.
		AVFFrame	*GetNextFrame(int offset=0) { return(frameList.GetLockedFrame(offset)); }

		// If you forget to call ReleaseFrames, the frameList buffer will fill up and
		// every call to ReadNextFrame() will fail.
		Error	ReleaseFrames(AVFFrame *pFrame, int count = 1);

		DWORD	LastFrameNumberRead(void) { return(frameList.LastFrameNumberRead()); }
		Error Cleanup(void);

		//
		//  Data source handling
		//

		Error OpenFile(GenericFileSystemIterator * gfsi,
										AVFFilterType &type,
										AVFInfo *pInfo = (AVFInfo *) NULL,
										BOOL sameFileAsLastTime = FALSE);
		Error CloseFile(void);

		// General file attributes added during rewrite:
		BOOL IsFilterValid(void);
		DWORD GetBytesPerSecond(void);
		DWORD GetAvgFileBitrate(void);
		BOOL FileIsOpen(void);
		BOOL IsForwardScanEnabled(void);
		BOOL IsReverseScanEnabled(void);
		BOOL NeedToDampVolumeDuringScan(DWORD thresholdBitrate);
		BOOL IsBeginningOfFile(void);
		BOOL	IsEndOfFile(void);
		DVDAudioCodingMode GetCodingMode(void);
		DWORD GetSampleRate(void);
		WORD GetNumberOfAudioChannels(void);

		// frame locator stuff added during rewrite:
		void SetBufferedByteCount(DWORD num);
		DWORD GetCurrentLocatorSeconds(void);
		void SetCurrentLocatorSeconds(DWORD sec);
		AVFFrameLocator * GetFreeFrameLocators(int num);
		void ReleaseFrameLocator(AVFFrameLocator *pLoc);
		AVFFrameLocator * GetFrameLocator(int num);

		// frameList and parsing stuff added during rewrite:
		int GetAvailableFrameCount(void);
		void InitFirstFrameInFile(void);
		void ReverseLastSeveralFrames(int numFrames);
		void InvalidateFrameBlockAndLocatorLists(void);
		void PreserveParseState(void);

		BOOL IsMatchingFile(GenericFileSystemIterator *gfsiParam);
		BOOL IsStreamingEnabled(void) { return streamingIsEnabled; }
		BOOL IsDurationAvailable(void)
			{
			if (pFilter && pFilter->IsDurationAvailable())
				return TRUE;
			else
				return FALSE;
			}

		DWORD GetValidInfoFlags(void)
			{
			if (pFilter)
				return pFilter->fileInfo.valid;
			else
				return 0;
			}

		void	CleanUpBlockList(DriveBlockCleanUpMode cleanupMode);

		GenericFileSystemIterator *GetCurrentIterator(void) { return gfsi; }

		Error GetCurrentDuration(DVDTime &duration);
		Error GetFileInfo(AVFInfo * appFileInfo);
		DWORD GetFileLengthInSeconds(void)
					{ if (pFilter) return pFilter->GetLengthInSeconds();
					else return 0; }
		int GetMaxFramesToLockEachRefill(void)
					{ if (pFilter) return pFilter->GetMaxFramesToLockEachRefill();
					else return 0; }
		int GetNumberOfRefillsPerTransfer(void)
					{if (pFilter) return pFilter->GetNumberOfRefillsPerTransfer();
					else return 0; }

		DWORD	GetDiskAccessFlags(void) { return diskAccessFlags; }
		virtual void SetDiskAccessSequential(void)
			{ diskAccessFlags = LOCKBLOCKS_SEQUENTIAL_ACCESS_FLAGS;
			if (pFilter) pFilter->SetDiskAccessSequential(); }
		virtual void SetDiskAccessRandom(void)
			{ diskAccessFlags = LOCKBLOCKS_RANDOM_ACCESS_FLAGS;
			if (pFilter) pFilter->SetDiskAccessRandom(); }
		int GetMaxLockedFrames(void) { if (pFilter) return pFilter->GetMaxLockedFrames();
												 else return 0; }

#ifdef _DEBUG
		void DebugDumpBlockList(void);
		void DumpLockedFrameList(void) { frameList.DumpLockedFrameList(); }
		void PrintDump(unsigned char *bp, int len, int maxlen=0, BOOL dumpASCII=TRUE)
			{
			if (pFilter)
				pFilter->PrintDump(bp, len, maxlen, dumpASCII);
			}
#endif
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\AVF\AVFPlayer.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//  Audio/Video File Player Class
//
////////////////////////////////////////////////////////////////////////////////

#ifndef AVFPLAYER_H
#define AVFPLAYER_H

class AVFPlayer;

#include "Library/Common/Prelude.h"
#include "Library/Common/WinPorts.h"
#include "Library/Common/KrnlSync.h"
#include "boards/generic/vdgendrv.h"

#include "Driver/Dvdpldrv/Common/DVDTime.h"
#include "Driver/Dvdpldrv/Common/EventSender.h"
#include "AVFStreamServer.h"

#include "Library/hardware/mpeg2dec/generic/mp2eldec.h"

#ifdef _DEBUG
#include "Library/Support/Shell/ShellToolKit.h"
#endif

class AVFPlayer : private WinPortWorkerThread, virtual public EventSender
	{
	protected:
		DWORD					totalBytesSent;
		WORD					playbackSpeed;
		UnitSet				units;
		UnitSet				decUnits;

		AVFStreamServer * refiller;		// Stream Server for refill
		VDLocalMutex		decoderLock;	// To serve and to protect the decoder

		void	WorkMessage(WPARAM wParam, LPARAM dParam);
		Error SetCallbackPositionLocked(DWORD position);
		void SetTotalBytesSent(DWORD count) { totalBytesSent = count; }
		void AddToTotalBytesSent(DWORD add) { totalBytesSent += add; }

	public:
		AVFPlayer(WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher);
		~AVFPlayer(void);

		Error Init(void);

		//
		// Playback control
		//

		Error	StartPlayback(BOOL playRequest=TRUE, BOOL reduceVolume=FALSE, BOOL mute=FALSE);
		Error	StopPlayback(void);
		Error	PausePlayback(void);
		Error	ResumePlayback(void);
		Error	SetPlaybackSpeed(WORD speed);
		WORD	GetPlaybackSpeed(void) {return playbackSpeed;}

		Error SetAudioStreamAttributes(AVFInfo *pAttr);

		//
		// Player to decoder routines
		//

		DWORD	SendData(HBPTR data, DWORD size);
		DWORD SendDataMultiple(MPEGDataSizePair * data, DWORD size);
		void	CompleteData(void);
		void	CancelData(void);
		DWORD GetTotalBytesSent(void) { return totalBytesSent; }

		//
		// Callback routines
		//

		Error	SetCallbackPosition(DWORD position);
		void	CancelCallback(void);
		void	SetRefiller(AVFStreamServer * refiller) {this->refiller = refiller;}

		//
		// Misc
		//

		DWORD	GetPlaybackPosition(void);
		BOOL	IsPreempted(void);

		//
		// Copy protection / management
		//

		Error SetCopyManagementMode(GenericCopyManagementInfo mode);
		Error GetAudioInformation(MPEG2PrologicStatus & prologicStatus, MPEG2LFEStatus & lfeStatus, AC3AudioCodingMode & ac3Mode);
#ifdef _DEBUG
		ShellToolKit	shell;
#endif
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\AVF\AVFFrame.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:       Driver/Dvdpldrv/Common/AVF/AVFFrame.h
// AUTHOR:     Sam Frantz
// COPYRIGHT:  (c) 2000 Ravisent Technologies, Inc.
// CREATED:    3-SEP-2000
//
// PURPOSE:    Generic frame structures for audio and video files.
//
// HISTORY:

#ifndef AVFFRAME_H
#define AVFFRAME_H

#include "Library/Common/Prelude.h"
#include "Library/Files/GenericFile.h"

#define ONLY_EXTERNAL_VISIBLE		// Makes include of mp2eldec.h work
#include "Library/hardware/mpeg2dec/generic/mp2eldec.h"

////////////////////////////////////////////////////////////////////
//
//  Drive Block Node Class
//
////////////////////////////////////////////////////////////////////

class DriveBlockNode
	{
	private:
		int						userCount;
		BOOL						locked;
		GenericFile				*gf;
		RequestHandle			*pRequestHandle;

	public:
		DriveBlock				block;
		HBPTR						pData;	// &block.data + headerSize
		DWORD						relativeBlockNum;

		DriveBlockNode(void);
		~DriveBlockNode(void);

		Error LockBlock(GenericFile *pGF, DWORD relativeBlock, DWORD flags, RequestHandle *pRH, DWORD headerSize);
		Error UnlockBlock(void);

		int	GetUserCount(void) { return(userCount); }
		DWORD	GetRelativeBlockNum(void) { return relativeBlockNum; };

		void	AddUser(void) { userCount++; }
		BOOL	IsLocked(void) { return locked; }
		Error SubtractUser(void)
			{
			if (--userCount < 0)
				{
				userCount++;
				GNRAISE(GNR_OBJECT_NOT_ALLOCATED);
				}
			else
				GNRAISE_OK;
			}

		void Invalidate(void);
	};

////////////////////////////////////////////////////////////////////
//
//  Drive Block Pool Class
//
////////////////////////////////////////////////////////////////////

class DriveBlockPool
	{
	private:
		int		usedIndex;
		int		freeIndex;
		int		usedCount;
	public:
		DriveBlockNode		*blockArray;
		int					arraySize;
		int					maxBlocksPerFrame;
		int					lastRequestIndex;
		int					lastRequestCount;

		DriveBlockPool(void);

		~DriveBlockPool(void);

		void Cleanup(void);

		BOOL ResizeNeeded(int	maxLockedFrames, int maxFrameSize, int dataSize);

		Error Initialize(int	maxLockedFrames, int maxFrameSize, int dataSize);

		int GetUsedCount(void) { return usedCount; }

#ifdef _DEBUG
		int GetUsedIndex(void) { return usedIndex; }
		int GetFreeIndex(void) { return freeIndex; }
		DriveBlockNode		*DebugGetBlockAbsolute(int offset);
#endif
		DriveBlockNode		*GetUsedBlock(int offset);
		DriveBlockNode		*GetUsedBlockInReverse(int offset);

		DriveBlockNode	*GetContiguousFreeBlocks(int count=1);

		Error	UnGetContiguousBlocks(DriveBlockNode *ptr, int count=1);

		Error	ReleaseContiguousBlocks(DriveBlockNode *ptr, int count=1);

		void Invalidate(void); // must release in the proper order
	};


////////////////////////////////////////////////////////////////////
//
//  AVF Frame Segment Node Class
//
////////////////////////////////////////////////////////////////////

class AVFFrameSegmentNode
	{
	public:
		MPEGDataSizePair 		data;
		DriveBlockNode			*pBlockNode;

		AVFFrameSegmentNode(void);
		~AVFFrameSegmentNode(void);

		Error Initialize(DriveBlockNode *pBlockNode, int timestamp);
		void SetFrameSegmentOffsetAndSize(DWORD _offset, DWORD _size);
		void AdjustSegmentSize(DWORD _size);
		void Invalidate(void);
	};

////////////////////////////////////////////////////////////////////
//
//  AVF Frame Segment Pool Class
//
////////////////////////////////////////////////////////////////////

class AVFFrameSegmentPool
	{
	public:
		AVFFrameSegmentNode	*segmentArray;
		int		arraySize;
		int		usedIndex;
		int		usedCount;
		int		freeIndex;
		int		maxSegmentsPerFrame;
		int		lastRequestIndex;
		int		lastRequestCount;

		AVFFrameSegmentPool(void);
		~AVFFrameSegmentPool(void);
		void Cleanup(void);

		BOOL		ResizeNeeded(int maxLockedFrames, int maxFrameSize, int dataSize);
		Error		Initialize(int	maxLockedFrames, int maxFrameSize, int dataSize);
	};

////////////////////////////////////////////////////////////////////
//
//  AVFFrame Classes
//
////////////////////////////////////////////////////////////////////

class AVFFrame
	{
	private:
		int								arraySize;
		int								actualSegments;
		DWORD								frameNum;
		BOOL								isDummy;
		DWORD								startTimestamp;
		DWORD								startBlock;
		DWORD								blockOffset;
	public:
		AVFFrameSegmentNode			*segmentArray;
		DWORD								bytesPerSecond; // this might change for each frame
		// DWORD							byteOffsetInFile;
		DWORD								frameByteOffsetInFile;
		HBPTR								pDetails;	// attach subclass data here for now

		AVFFrame();
		~AVFFrame();

		Error Initialize(AVFFrameSegmentNode *pSegmentArray, int segmentCount);

		Error AddNewSegment(DriveBlockNode *pBlockNode, int timestamp, DWORD offset, DWORD size);

		AVFFrameSegmentNode	*GetNextFreeSegment(void);

		MPEGDataSizePair	*GetSegmentDataSizePair(int segment);

		DWORD	GetStartTimestamp(void) { return startTimestamp; }
		void	SetStartTimestamp(DWORD timestamp) { startTimestamp = timestamp; }
		int	GetActualSegmentCount(void) { return actualSegments; }
		void	ResetActualSegmentCount(void) { actualSegments = 0; }	// Used only with dummyScanFrame!
		int	GetFrameSize(void);
		int	GetFrameNum(void) { return frameNum; }
		DWORD GetBytesPerSecond(void) { return bytesPerSecond; }
		BOOL	IsDummy(void) { return isDummy; }
		void	SetStartBlockAndOffset(DWORD blockNum, DWORD offset)	// used for dummy frames in DetermineDuration()
			{
			startBlock = blockNum;
			blockOffset = offset;
			}
		Error GetStartBlock(DWORD &block);
		Error GetStartOffset(DWORD &offset);
		void	SetFrameNum(DWORD frameNum);
		void	Invalidate(void);
#ifdef _DEBUG
		BOOL DebugIntegrityCheck(BYTE firstByte);
#endif
	};

////////////////////////////////////////////////////////////////////
//
//  AVF Frame Pool Class
//
////////////////////////////////////////////////////////////////////

class AVFFramePool
	{
	private:
		int		usedIndex;
		int		freeIndex;
		int		usedCount;
		int		lastRequestIndex;
		int		lastRequestCount;
	protected:
		AVFFrameSegmentPool	segmentList;
	public:
		AVFFrame	*frameArray;
		int		arraySize;
		int		maxSegmentsPerFrame;

		AVFFramePool(void);

		~AVFFramePool(void);

		void Cleanup(void);

		BOOL	ResizeNeeded(int maxLockedFrames, int maxFrameSize, int dataSize);
		Error	Initialize(int	maxLockedFrames, int maxFrameSize, int dataSize);

		Error AttachSubClassFrameData(HBPTR ptr, int elementSize);
		Error InvalidateSubClassFrameData(void);

		int	GetLockedFrameCount(void);
		int	GetAvailableFrameCount(void);

		Error ReverseLastSeveralFrames(int n);	// this is used during reverse playback

		AVFFrame	*GetLockedFrame(int offset);
		// AVFFrame	*GetLockedFrameInReverse(int offset);

		AVFFrame	*GetContiguousFreeFrames(int count=1); // count should remain 1

		Error	ReleaseContiguousFrames(AVFFrame *ptr, int count=1);

		Error	UnGetContiguousFrames(AVFFrame *ptr, int count=1);

		DWORD LastFrameNumberRead(void);

		void Invalidate(void);
#ifdef _DEBUG
		void DumpLockedFrameList(void);
#endif
	};

////////////////////////////////////////////////////////////////////
//
//  AVFFrameLocator Classes
//
////////////////////////////////////////////////////////////////////

class AVFFrameLocator
	{
	private:
		int								frameNum;
		DWORD								size;
	public:
		DWORD								bufferedByteCount;
		DWORD								milliSec;	// from beginning of file
		DWORD								seconds;
		DWORD								bytesPerSecond;
		DWORD								nextFrameBeginningOffset;
		DWORD								bytesFromBeginning;

		AVFFrameLocator();
		~AVFFrameLocator();

		Error Initialize(AVFFrame *pFrame, DWORD sentBytes, DWORD frameBeginSeconds);

		DWORD	GetFrameSize(void) { return size; }
		int	GetFrameNum(void) { return frameNum; }
	};

////////////////////////////////////////////////////////////////////
//
//  AVF Frame Locator Pool Class
//
////////////////////////////////////////////////////////////////////

class AVFFrameLocatorPool
	{
	private:
		int		usedIndex;
		int		freeIndex;
		int		usedCount;
		int		lastRequestIndex;
		int		lastRequestCount;
		DWORD		totalBufferedBytes;
		DWORD		currentSeconds;
	public:
		AVFFrameLocator	*frameLocatorArray;
		int					arraySize;

		AVFFrameLocatorPool(void);

		~AVFFrameLocatorPool(void);

		void Cleanup(void);

		BOOL	ResizeNeeded(int	maxLockedFrames);
		Error	Initialize(int	maxLockedFrames);

		int	GetFrameLocatorCount(void);

		void	SetBufferedByteCount(DWORD count) { totalBufferedBytes = count; }
		DWORD	GetBufferedByteCount(void) { return totalBufferedBytes; }
		void	AddToBufferedByteCount(DWORD count) { totalBufferedBytes += count; }

		void	SetCurrentSeconds(DWORD sec) { currentSeconds = sec; }
		DWORD	GetCurrentSeconds(void) { return currentSeconds; }

		AVFFrameLocator	*GetFrameLocator(int offset);

		AVFFrameLocator	*GetFreeFrameLocators(int count=1); // count should remain 1

		Error	ReleaseFrameLocators(AVFFrameLocator *ptr, int count=1);

		Error	UnGetFrameLocators(AVFFrameLocator *ptr, int count=1);

		void Invalidate(void);
	};

////////////////////////////////////////////////////////////////////
//
//  Drive Block Check Point Node Class
//
////////////////////////////////////////////////////////////////////

class DriveBlockCheckPointNode
	{
	public:
		// DWORD		checkPointNum;
		DWORD		frameNum;
		DWORD		blockNum;
		DWORD		offset;
		DWORD		timestamp;
		DWORD		frameByteOffset;
	};

////////////////////////////////////////////////////////////////////
//
//  Drive Block Check Point List Class
//
////////////////////////////////////////////////////////////////////

class DriveBlockCheckPointList
	{
	public:
		DriveBlockCheckPointNode	*checkPointArray;
		int								arraySize;
		int								actualCheckPoints;
		BOOL								enabled;
		DWORD								blocksPerCheckPoint;
		DriveBlockCheckPointList(void);
		~DriveBlockCheckPointList(void);

		Error Initialize(int	checkPointsPerFile);
		BOOL	ResizeNeeded(int checkPoints);

		void	EnableCheckPointing(void) { enabled = TRUE; }
		void	DisableCheckPointing(void) { enabled = FALSE; actualCheckPoints = 0; }
		BOOL	CheckPointingIsEnabled(void) { return(enabled); }

		void	AddCheckPoint(int index, DWORD frameNum, DWORD blockNum,
								  DWORD offset, DWORD timestamp, DWORD fileOffset);
		// void	InsertAt(int index, DWORD blockNum, DWORD frameNum, DWORD offset, DWORD timestamp, DWORD fileOffset);

		DriveBlockCheckPointNode *GetFrameCheckPoint(DWORD frameNum);
		DriveBlockCheckPointNode *GetFrameCheckPointTimestamp(DWORD milliSec);
		DWORD GetLastCheckPointTimeStamp(void);
		DWORD GetLastCheckPointFrameNum(void);
		void	Invalidate(void);
		void	Cleanup(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\Config\DDPXBox.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DVDPLD32: Entry Point For XBox
//
////////////////////////////////////////////////////////////////////

#include "driver/dvdpldrv/common/dvdpld32.h"
#include "library/common/profiles.h"
#include "library/hardware/drives/generic/drivetable.h"

////////////////////////////////////////////////////////////////////
//
//  Helper Functions
//
////////////////////////////////////////////////////////////////////
//
// Tells us what kind of entry it is
//

enum SetupEntryType
	{
	SET_VALUE,
	SET_SECTION,
	SET_END
	};

//
// One entry of the setup array
//

struct SetupEntry
	{
	char				* name;
	SetupEntryType	type;
	DWORD				value;
	};


static SetupEntry config[] =
	{
		{"$", SET_SECTION, 0},

			{"DRIVE", SET_SECTION, 0},
			{"", SET_END, 0},

		{"", SET_END, 0},
	};

static DWORD CalculateID(BOOL section, KernelString name)
	{
	DWORD temp = 0;

	if (name.Length() > 0)
		{
		for (int i = 0; i < name.Length(); i++)
			{
			temp ^= name[i];
			temp = (temp << 3) | (temp >> 29);	// The first 10 characters count
			}

		return (section ? (temp |= 1) : (temp &= ~1));
		}
	else
		return 0;
	}

//
//  Parse Setup
//

static void ParseSetup(SetupEntry * & sentry, ProfileEntry * pentry, int & num)
	{
	int snum;

	num = 0;
	pentry->id = CalculateID(TRUE, sentry->name);
	num++;
	sentry++;
	while (sentry->type != SET_END)
		{
		if (sentry->type == SET_VALUE)
			{
			pentry[num].id = CalculateID(FALSE, sentry->name);
			pentry[num].value = sentry->value;
			num++;
			sentry++;
			}
		else
			{
			ParseSetup(sentry, pentry + num, snum);
			num += snum;
			}
		}
	pentry->value = num;

	sentry++;
	}

////////////////////////////////////////////////////////////////////
//
//  DDP_Initialize
//
////////////////////////////////////////////////////////////////////

DLLCALL Error WINAPI DDP_Initialize(void)
	{
	GenericProfile * profile;
	DriveTable * driveTable;
	int num;
	Error err;

	static ProfileEntry	pentry[200];

	SetupEntry	*	se = config;

	ParseSetup(se, pentry, num);

	profile = new StaticProfile(pentry);

	if (!profile)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	driveTable = new W2KDriveTable();
	if (IS_ERROR(err = driveTable->Init(profile)))
		{
		delete driveTable;
		driveTable = NULL;
		GNRAISE(err);
		}

	//
	//  Perform general initializations
	//

	GNREASSERT(DDP_Init(new WinPortServer(), profile, driveTable,
							  new DVDVideoDiskPlayerFactory(),
							  new DVDAudioDiskPlayerFactory(),
							  new VCDDiskPlayerFactory(),
							  new CDDADiskPlayerFactory(),
							  new AVFDiskPlayerFactory(),
							  new DVDFileSystemFactory(),
							  new FileSystemFactory(),
							  new FileSystemFactory(),
							  new FileSystemFactory(),
							  new FileSystemFactory()));

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\Config\DDPXBox.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  DDP Layer Include File For XBox
//
////////////////////////////////////////////////////////////////////

#ifndef DDPXBOX_H
#define DDPXBOX_H

#include "boards/generic/vdgendrv.h"
#include "driver/dvdpldrv/Common/dvdpld32.h"

////////////////////////////////////////////////////////////////////
//
//  Function Declarations
//
////////////////////////////////////////////////////////////////////

Error WINAPI DDP_Initialize(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\AVF\AVFStreamServer.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:       Driver/Dvdpldrv/Common/AVF/AVFStreamServer.h
// AUTHOR:     Sam Frantz
// COPYRIGHT:  (c) 2000 Ravisent Technologies, Inc.
// CREATED:    3-SEP-2000
//
// PURPOSE:    Generic stream server for audio and video files.
//
// HISTORY:

#ifndef AVFSTREAMSERVER_H
#define AVFSTREAMSERVER_H

class AVFStreamServer;

#include "Library/Common/Prelude.h"
#include "Library/Common/WinPorts.h"
#include "Library/Common/KrnlSync.h"
#include "Driver/Dvdpldrv/Common/Breakpoint.h"
#include "Driver/Dvdpldrv/Common/DVDTime.h"
#include "Library/Files/GenericFile.h"
#include "Driver/Dvdpldrv/Common/AVF/AVFile.h"
#include "Library/Lowlevel/Timer.h"

#ifndef _DEBUG_SHELL
#include "Driver/Dvdpldrv/Common/AVF/AVFPlayer.h"
#endif
#ifdef _DEBUG_SHELL
#define _DEBUG_LIST
#include "Library/Support/Shell/ShellToolKit.h"
#else
#include <stdio.h>
#endif // _DEBUG_SHELL

// #define _DEBUG_BUFFER_PERFORMANCE_TEST
#ifdef _DEBUG_BUFFER_PERFORMANCE_TEST
typedef struct
	{
	int	framesRead;
	int	framesQueued;
	int	bytesSent;
	DWORD	framesSent;
	DWORD	startMilliTicks;
	DWORD	endMilliTicks;
	} DebugRefillStats;
#define DEBUG_MAX_REFILLS_PER_TRANSFER	20 // for sizing only
#define DEBUG_MAX_LOOPS_PER_PRINT		50 // see AVFileManager::GetNumberOfRefillsPerTransfer()
#endif

//
//  Defines
//

#define AVF_MAX_TRANSFER_NUM	5
#define CDDA_SIGNAL_TIME_NUM	2		// Number of supported signal times

#define AVF_CALLBACK_DISTANCE	24000		// 1 sec at 192kBpS
#define AVF_CALLBACK_POSITION_UNDEFINED	0xffffffff
#define AVF_MAX_CONSECUTIVE_IDENTICAL_ERRORS		2 // nudge after this many errors on same frame

#define DEFAULT_MIN_AUDIO_SCAN_BITRATE	192
	// when bitReservoirInUse == FALSE and scanIsAudible the above comes into play

////////////////////////////////////////////////////////////////////
//
//  AVFBreakLocation class
//
////////////////////////////////////////////////////////////////////

class AVFStillLocation
	{
	public:
		DWORD		milliSec;		// time of the still loc
		BOOL		valid;			// Position is valid
		BOOL		upcoming;		// We are reaching still loc
		DWORD		callbackPos;	// Callback at that position
		DWORD		deferMilliSec;		// Defer location for cancelled breakpoint
		BOOL		buffered;		// required data has been sent to the player

		AVFStillLocation(void) { valid = FALSE; upcoming = FALSE; buffered = FALSE; }
		Error SetStillLocation(DWORD ms);
		void SetStillLocationUpcoming(void);
		void SetStillLocationBuffered(void) { buffered = TRUE; }
		// void ResetAtStillLocation(void) { buffered = FALSE; upcoming = FALSE; }
		void SetStillPosition(DWORD pos) { callbackPos = pos; }
		DWORD GetStillPosition(void) { return callbackPos; }
		BOOL IsStillLocationValid(void) { return valid; }
		BOOL IsStillLocationBuffered(void) { return buffered; }
		BOOL IsStillLocationUpcoming(void);
		Error ClearStillLocation(void);
		void Invalidate(void) { valid = FALSE; upcoming = FALSE; buffered = FALSE; }
	};

////////////////////////////////////////////////////////////////////
//
//  AVFStreamServer Class
//
////////////////////////////////////////////////////////////////////

class AVFStreamServer : protected WinPort, virtual protected ERSBreakpointControl
	{
	protected:
		AVFileManager			avFile;		// the currently-playing file handler
		AVFPlayer		* player;
		GenericProfile * profile;

		DVDPlayerMode	mode;							// The mode the player is currently in (Please use Set Method to change)
		VDLocalMutex	serverLock;					// Save the stream server

		//
		//  Playback related variables
		//

		AVFFrame							*pCurrentFrame;
		AVFFrameLocator				*pCurrentFrameLocator;
		AVFFrameSegmentNode			*pCurrentFrameSegment;

		DWORD			currentFrameNum;				// the frame currently being sent
		DWORD			lastScanFrameBuffered;		// the lowest frame number in frame buffer
		DWORD			currentSegmentNum;			// each frame may consist of multiple segments
		DWORD			currentSegmentSendOffset;	// offset within the frame segment
		BOOL			needToDequeueNextFrame;		// need to dequeue next frame in TransferBuffer()
		BOOL			cancelled;						// Set to TRUE by CancelData, prevents callback from using old data


		BOOL	isFinalBuffer;					// Set if buffer is the last to play
		BOOL	completeDataCalled;			// Ensures there are no end-of-file hangs
		BOOL	isMovingBackward;				// backward play or backward scan modes only
		BOOL	isBeginningOfScan;			// comes into play when isFinalBuffer is TRUE, at begin of scan
		BOOL	isBeginningOfResume;			// comes into play when isFinalBuffer is TRUE, at begin of resume
		BOOL	totalBufferedBytes;			// used during scan modes
		BOOL	abortScan;						// for handling odd error conditions during scan
		BOOL	scanIsAudible;					// from profile settings
		WORD	scanSpeed;						// scanSpeed = 1 => double speed playback
		DWORD	elapsedSeconds;				// needed for GetCurrentLocation()
		DWORD	elapsedMillisec;				// needed for GetCurrentLocation()
		DWORD minFreeReverseScanBuffer;		// no disk reads will occur unless room for this many frames
		DWORD reverseScanFrameSequenceLen;	// this many frames will be played sequentially
		DWORD forwardScanFrameSequenceLen;	// this many frames will be played sequentially
		DWORD maxRefillsPerTransfer;			// set by filter, see GetNumberOfRefillsPerTransfer()
		DWORD maxFramesLockedPerRefill;		// set by filter, see GetMaxFramesToLockEachRefill()
		DWORD minFramesLockedPerReverseRefill; // one half of maxFramesLockedPerRefill
		DWORD	minAudioScanBitrate;			// when bitReservoirInUse == FALSE and scanIsAudible
		DWORD	frameMilliSec;

		DWORD			errorFrameNum;
		int			errorFrameNumCount;
		void		ResetNeedToNudgeNudgeTargetFrameNum(void);	// helps get past bad disk sectors
		BOOL		NeedToNudgeTargetFrameNumOnError(DWORD num); // helps get past bad disk sectors
		DWORD	totalSentBytes; // how many bytes were sent to the decoder

#ifdef _DEBUG_BUFFER_PERFORMANCE_TEST
		DWORD	totalSentBytes; // how many bytes were sent to the decoder
		DebugRefillStats refillStats[DEBUG_MAX_LOOPS_PER_PRINT][DEBUG_MAX_REFILLS_PER_TRANSFER];
		int	debugRefillIndex, debugLoopNum;
#endif
		//
		//  Break Location Handling
		//

		GenericFileSystemIterator	*gfsiStill;	// need to save this for the StopStillPhase()
		AVFileManager	*pInfoFile;					// passed down from AVFDiskPlayer
		DWORD	timeBaseMillisec;				// Base for current playback time, for StopStillPhase()
		AVFStillLocation	stillLocation;
		AVFFilterType		fileType;

		//
		//  Breakpoint handling
		//

		ERSBreakpoint	currentBreakpoint;
		BOOL				currentBreakpointValid;

		ERSBreakpoint	lastBreakpoint;		// The last breakpoint reached
		ERSPlaybackDir	lastBreakpointDir;	// The direction in which we were playing then

		void	SetCurrentBreakpoint(DWORD time, BOOL playForward);
		virtual	void	SetBreakpointActiveCallback(ERSBreakpoint bp, BOOL excl);
		virtual	void	StartBreakpointStillCallback(void);
		virtual Error SetBreakpoint(WORD title, WORD ptt, DVDTime time, DWORD flags, DWORD & id);
		virtual Error ClearBreakpoint(DWORD id);

		Error	SetStillLocation(DWORD time);
		Error	ClearStillLocation(void);
		Error	StartStillPhase(void);

		//
		//  Signal Time Handling
		//

		struct tagSignalTime
			{
			DWORD	milliSec;
			BOOL	valid;
			} signalTime;

		Error		SetSignalTime(DWORD milliSec);
		DWORD		GetSignalTime(void);
		Error		ClearSignalTime(void);
		BOOL		SignalTimeReached(DWORD playbackMillisec, BOOL playForward);
		void		SignalTimeCallback(void);
		BOOL		StillLocationReached(DWORD playbackMilliSec, BOOL playForward);

		//
		//  Playback functions
		//

		Error TransferBuffer(void);
		Error	RefillBuffer(void);
		void	InvalidateAllBuffers(void);

		Error	FlushBuffer(void);
		Error	CancelData(void);
		BOOL	BufferEmpty(void);
		void	SetIsMovingBackward(BOOL backwd) { isMovingBackward = backwd; }
		BOOL	IsMovingBackward(void) { return isMovingBackward; }
		BOOL	IsMovingForward(void) { return !isMovingBackward; }
		// Error GetPlaybackTime(DVDTime & time) {GNREASSERT(player->GetPlaybackTime(time)); GNRAISE_OK;}

		void SetPlaybackMode(DVDPlayerMode newMode)	// Use this to change playback mode with event sending
			{
			if (mode != newMode)
				{
				SendEvent(DNE_PLAYBACK_MODE_CHANGE, newMode);
				mode = newMode;
				}
			}

		Error SetCallbackPosition(DWORD position);
		virtual void PlaybackCompleted(void) = 0;
		DWORD	GetElapsedSeconds(void) { return elapsedSeconds; }
		DWORD	GetElapsedMillisec(void) { return elapsedMillisec; }
		void	SetElapsedSeconds(DWORD sec);
		void	SetElapsedMillisec(DWORD ms);
		DWORD GetNumberOfRefillsPerTransfer(void) { return maxRefillsPerTransfer; }
		void SetNumberOfRefillsPerTransfer(int num) { maxRefillsPerTransfer = num; }
		DWORD GetMaxFramesToLockEachRefill(void) { return maxFramesLockedPerRefill; }
		void SetMaxFramesToLockEachRefill(int num) { maxFramesLockedPerRefill = num; }
		DWORD	GetTotalBufferedBytes(void) { return totalSentBytes; } // how many bytes were sent to the decoder
		void AddToTotalBufferedBytes(DWORD num) { totalSentBytes += num; }
		void ClearTotalBufferedBytes(void) { totalSentBytes = 0; }
		// DWORD GetMinFramesToLockEachReverseRefill(void) { return minFramesLockedPerReverseRefill; }
		// void SetMinFramesToLockEachReverseRefill(int num) { minFramesLockedPerReverseRefill = num; }

	public:

		AVFStreamServer(WinPortServer * server, UnitSet units, EventDispatcher* pEventDispatcher);
		~AVFStreamServer(void);

		// must be called before InitializeDataStructures()
		virtual Error Init(WinPortServer * server, GenericFileSystem * avffs, GenericProfile * profile);

		//
		//  Data source handling
		//

		Error OpenFile(GenericFileSystemIterator * gfsi);
		Error CloseFile(void);

		Error Cleanup(void);

		//
		//  WinPort methods
		//

		void Message(WPARAM wParam, LPARAM dParam);

		//
		//  Playback methods
		//

		void SetInfoFile(AVFileManager * pFile);
		Error StartPlayback(GenericFileSystemIterator * gfsi,
								  BOOL pauseAtStart = FALSE, DVDTime *pTime = (DVDTime *) NULL);
		Error StopPlayback(BOOL aborted = FALSE);
		Error StartForwardScan(WORD speed);
		Error StartBackwardScan(WORD speed);
		Error StopScan(void);
		Error PausePlayback(void);
		Error ResumePlayback(void);
		virtual Error StopStillPhase(void);

		//
		//  Inquiry (inquisition) methods
		//

		BOOL IsPlaying(void);											// Paused counts as playing
		WORD GetScanSpeed(void) { return scanSpeed; }
		Error GetCurrentProgramTime(DVDTime &pgcTime);
		AVFFilterType GetFileType(void) { return fileType; }
		virtual Error GetCurrentBitrate(DWORD & bitrate);

		Error GetCodingMode(DVDAudioCodingMode &codingMode);
		Error GetSampleRate(DWORD &samplesPerSecond);
		Error GetNumberOfAudioChannels(WORD &channels);
		DWORD GetNumberOfUnplayedBytesInDecoderBuffer(void);
		DWORD GetBufferedFrameCount(void);
		DWORD GetFrameMillisec(void);
		BOOL IsFrameBufferHalfFull(void);
		BOOL IsFrameBufferQuarterFull(void);
		BOOL IsFrameBufferThreeQuartersFull(void);

		virtual DVDPlayerMode InternalGetMode(void);

		//
		// Transfer methods (called by AVFPlayer)
		//

		Error PerformTransfer(int maxTransferNum = 0); // was AVF_MAX_TRANSFER_NUM;
      void	PlayerCallback(DWORD signalPosition, BOOL calculateOnly=FALSE);
#ifdef _DEBUG
		void DebugDumpPlayerMode(void);
#endif
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\Config\DiskPlayerFactory.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Disk Player Factory Classes
//
////////////////////////////////////////////////////////////////////

#include "DiskPlayerFactory.h"

////////////////////////////////////////////////////////////////////
//
//  DVDDiskPlayer Factory Classes
//
////////////////////////////////////////////////////////////////////

//
//  Base Class
//

Error DVDDiskPlayerFactory::CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile,
															DVDDiskType diskType, DVDFileSystem * dvdfs, BYTE region,
															CDDiskPlayerClass * & player)
	{
	GNRAISE(GNR_DISK_TYPE_NOT_SUPPORTED);
	}

Error DVDDiskPlayerFactory::CreateDVDDisk(DVDDisk * & dvdDisk)
	{
	GNRAISE(GNR_DISK_TYPE_NOT_SUPPORTED);
	}

////////////////////////////////////////////////////////////////////
//
//  VCDDiskPlayer Factory
//
////////////////////////////////////////////////////////////////////

//
//  Base Class
//

Error VCDDiskPlayerFactory::CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile,
															DVDDiskType diskType, VCDFileSystem * vcdfs, CDDiskPlayerClass * & player)
	{
	GNRAISE(GNR_DISK_TYPE_NOT_SUPPORTED);
	}

////////////////////////////////////////////////////////////////////
//
//  CDDADiskPlayer Factory
//
////////////////////////////////////////////////////////////////////

//
//  Base Class
//

Error CDDADiskPlayerFactory::CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile,
															 DVDDiskType diskType, CDDAFileSystem * cddafs, CDDiskPlayerClass * & player)
	{
	GNRAISE(GNR_DISK_TYPE_NOT_SUPPORTED);
	}

////////////////////////////////////////////////////////////////////
//
//  AVFDiskPlayer Factory
//
////////////////////////////////////////////////////////////////////

//
//  Base Class
//

Error AVFDiskPlayerFactory::CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile,
															DVDDiskType diskType, GenericFileSystem * gfs, CDDiskPlayerClass * & player)
	{
	GNRAISE(GNR_DISK_TYPE_NOT_SUPPORTED);
	}

Error AVFDiskPlayerFactory::CreateMP3Player(WinPortServer * server, GenericProfile * profile, DVDDiskType diskType,
														  GenericFileSystem * gfs)
	{
	GNRAISE(GNR_DISK_TYPE_NOT_SUPPORTED);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\Config\DiskPlayerFactory.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Disk Player Factory Classes
//
////////////////////////////////////////////////////////////////////

#ifndef DISKPLAYERFACTORY_H
#define DISKPLAYERFACTORY_H

class DVDDiskPlayerFactory;
class VCDDiskPlayerFactory;
class CDDADiskPlayerFactory;
class AVFDiskPlayerFactory;

class DVDFileSystem;
class VCDFileSystem;
class CDDAFileSystem;

class DVDDisk;
class DVDGenericCPBI;
#include "driver/dvdpldrv/Common/CDDiskPlayer.h"

#include "boards/generic/vdgendrv.h"

////////////////////////////////////////////////////////////////////
//
//  DVDDiskPlayer Factory Classes
//
////////////////////////////////////////////////////////////////////

//
//  Base class that only returns errors
//

class DVDDiskPlayerFactory
	{
	public:
		virtual Error CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile, DVDDiskType type,
												 DVDFileSystem * dvdfs, BYTE region, CDDiskPlayerClass * & player);
		virtual Error CreateDVDDisk(DVDDisk * & dvdDisk);
	};

////////////////////////////////////////////////////////////////////
//
//  VCDDiskPlayer Factory
//
////////////////////////////////////////////////////////////////////

//
//  Base class that only returns errors
//

class VCDDiskPlayerFactory
	{
	public:
		virtual Error CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile, DVDDiskType type,
												 VCDFileSystem * vcdfs, CDDiskPlayerClass * & player);
	};

////////////////////////////////////////////////////////////////////
//
//  CDDADiskPlayer Factory
//
////////////////////////////////////////////////////////////////////

//
//  Base class that only returns errors
//

class CDDADiskPlayerFactory
	{
	public:
		virtual Error CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile, DVDDiskType type,
												 CDDAFileSystem * cddafs, CDDiskPlayerClass * & player);
	};

////////////////////////////////////////////////////////////////////
//
//  AVFDiskPlayer Factory
//
////////////////////////////////////////////////////////////////////

//
//  Base class that only returns errors
//

class AVFDiskPlayerFactory
	{
	public:
		virtual Error CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile, DVDDiskType type,
												 GenericFileSystem * gfs, CDDiskPlayerClass * & player);
		virtual Error CreateMP3Player(WinPortServer * server, GenericProfile * profile, DVDDiskType type, GenericFileSystem * gfs);
	};

//
//  Further AVF factories that only create subsets of all supported file types should be created here!!!
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\AVF\MPEGAudioFilter.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:       Driver/Dvdpldrv/Common/AVF/MPEGAudioFilter.h
// AUTHOR:     Sam Frantz
// COPYRIGHT:  (c) 2000 Ravisent Technologies, Inc.
// CREATED:    23-OCT-2000
//
// PURPOSE:    MPEG audio specific file parser for audio and video files
//
// HISTORY:

#ifndef MPEGAUDIOFILTER_H
#define MPEGAUDIOFILTER_H

#include "Driver/Dvdpldrv/Common/AVF/AVFFilter.h"
#include "Driver/Dvdpldrv/Common/AVF/MPEGAudioHeader.h"

#define MPEG_AUDIO_MAX_LOCKED_FRAMES				50 // 20 is OK for 320 kbps, need more
																	// for lower bitrates
#define MPEG_AUDIO_MAX_CHECKPOINTS					200
#define MPEG_AUDIO_MAX_FRAME_SIZE					6913
	// worst case for padded 384 kbps layer 2 @ 8 kHz
	// ((144 * (384000)) / 8000) + 1;

#define MPEG_AUDIO_MAX_FRAMES_PER_REFILL			40 // don't have to fill the queue each time
#define MPEG_AUDIO_NUM_REFILLS_PER_TRANSFER		5 // don't have to fill the queue each time

#define MPEG_AUDIO_MAX_BLOCKS_WITH_NO_HEADER		12	// this does not count any headers
	// e.g. ID3v2 can be 64K long at the beginning of a file

////////////////////////////////////////////////////////////////////
//
//  MPEG Audio Frame Header List Class
//
////////////////////////////////////////////////////////////////////

class MPEGAudioFrameHeaderList
	{
	public:
		MPEGAudioFrameHeader	*pHeaderArray;
		int						arraySize;
		MPEGAudioFrameHeaderList(void);
		~MPEGAudioFrameHeaderList(void);
		void Cleanup(void);
		Error Initialize(int	maxLockedFrames);
	};

////////////////////////////////////////////////////////////////////
//
//  MPEG Audio Filter Class
//
////////////////////////////////////////////////////////////////////

class MPEGAudioFilter : public AVFFilter
	{
	private:
		// Parse state information (defined in MpegAudioHeader.h)
		MPEGAudioParseState			parseState;		// also includes non-audio frame info
		// DWORD								optimizedStartBlock;
		// DWORD								optimizedStartBlockOffset;
		BOOL							nonAudioInfoIsAvailable; // non-audio info
		BOOL							nonAudioInfoReadAttempted; // only check once per file

		Error LoadFirstFrameInfo(MPEGAudioFrameHeader *pHeader, BOOL forceVBR=FALSE);
		void InvalidateFirstFrameInfo(void);
		Error	ID3v1ByteFilter(BYTE b, DWORD &bytesToSkip, MPEGNonAudioFrameType &type,
						 			 BOOL &frameDone, MPEGNonAudioParseMode mode);

		// virtual Error InitializeDataStructures(int maxLockedFrames, int maxFrameSize);

	public:
		MPEGAudioFilter(void);
		virtual ~MPEGAudioFilter(void);

		MPEGAudioFrameHeaderList	frameHeaderList;
		Error FindNextFrame(DriveBlockNode *pBlockNode, AVFFrame *pFrame, BOOL lastBlockInFile);
		virtual Error DetermineDuration(void);
		virtual BOOL NeedToDampVolumeDuringScan(DWORD minBitrate);
		DWORD CalculateLengthInSeconds(void);
		Error LoadID3v1Info(void);
		virtual Error OpenFileInitialization(GenericFile * gf,
									AVFileSizeAttributes *pSizeInfo,
									AVFInfo *pInfo = (AVFInfo *) NULL,
									BOOL streamingIsEnabled = FALSE);
		DWORD GetBytesPerSecond(void);
		BOOL IsVariableBitRate(void);
		BOOL	IsInfoAvailable(void) { return nonAudioInfoIsAvailable; }
		virtual void SetNewFile(void);
		Error ReadFileInfo(AVFInfo * appFileInfo);

		virtual void Cleanup(void);
		virtual void Invalidate(void);

#ifdef _DEBUG
		void DebugDumpParseState(MPEGAudioParseState &parseState);
		void DebugDumpHeaderInfo(MPEGAudioFrameHeader *pHeader);
		void DebugDumpID3v1Info(void);
#endif

		void InitFirstFrameInFile(void);
		void InitNewFrameSameBlock(void);
		void InitSameFrameNewBlock(void);
		void InitNewFrameNewBlock(void);

		virtual int GetMaxLockedFrames(void) { return MPEG_AUDIO_MAX_LOCKED_FRAMES; }
		virtual int GetNumberOfCheckpoints(void) { return MPEG_AUDIO_MAX_CHECKPOINTS; }
		virtual int GetMaxFrameSize(void) { return MPEG_AUDIO_MAX_FRAME_SIZE; }
		virtual int GetMaxFramesToLockEachRefill(void) { return MPEG_AUDIO_MAX_FRAMES_PER_REFILL; }
		virtual int GetNumberOfRefillsPerTransfer(void) {return MPEG_AUDIO_NUM_REFILLS_PER_TRANSFER; }
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\Config\dvdDiskPlayerFactory.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef DVDDISKPLAYERFACTORY_H
#define DVDDISKPLAYERFACTORY_H

#include "DiskPlayerFactory.h"

//
//  This one collects common things of Video/Audio DVD. It should not be instantiated, only its derived classes.
//

class DVDDiskPlayerFactoryCommon : public DVDDiskPlayerFactory
	{
	public:
		virtual Error CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile, DVDDiskType type,
												 DVDFileSystem * dvdfs, BYTE region, CDDiskPlayerClass * & player);
	};

//
//  DVD Video Disk Player Factory
//

class DVDVideoDiskPlayerFactory : public DVDDiskPlayerFactoryCommon
	{
	public:
		virtual Error CreateDVDDisk(DVDDisk * & dvdDisk);
	};

//
//  DVD Audio Disk Player Factory
//

class DVDAudioDiskPlayerFactory : public DVDDiskPlayerFactoryCommon
	{
	public:
		virtual Error CreateDVDDisk(DVDDisk * & dvdDisk);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\Config\DVDDiskPlayerFactory.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "DVDDiskPlayerFactory.h"
#include "driver/dvdpldrv/Common/DVDDiskPlayer.h"

//
//  Common DVD Disk Player Factory
//

Error DVDDiskPlayerFactoryCommon::CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile,
																	DVDDiskType diskType, DVDFileSystem * dvdfs, BYTE region,
																	CDDiskPlayerClass * & player)
	{
	Error err;

	//
	//  Create Disk Player
	//

	player = new DVDDiskPlayerClass(server, units, this);
	if (!player)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	//
	//  Initialize player
	//

	if (IS_ERROR(err = ((DVDDiskPlayerClass*)player)->Init(server, profile, diskType, dvdfs, region)))
		delete player;

	GNRAISE(err);
	}

//
//  DVD Video Player Factory
//

Error DVDVideoDiskPlayerFactory::CreateDVDDisk(DVDDisk * & dvdDisk)
	{
	dvdDisk = new DVDVideoDisk(this);
	if (dvdDisk)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  DVD Audio Player Factory
//

Error DVDAudioDiskPlayerFactory::CreateDVDDisk(DVDDisk * & dvdDisk)
	{
	dvdDisk = new DVDAudioDisk(this);
	if (dvdDisk)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\Config\FileSystemFactory.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Operating System Specific File System Factories
//
////////////////////////////////////////////////////////////////////

#include "FileSystemFactory.h"

////////////////////////////////////////////////////////////////////
//
//  Base Class For File System Factories
//
////////////////////////////////////////////////////////////////////

//
//  Default implementation
//

Error FileSystemFactory::CreateFileSystem(RootIterator * rit, GenericProfile * profile, GenericFileSystem * & gfs)
	{

	GNRAISE(GNR_DISK_TYPE_NOT_SUPPORTED);
	}

//
//  DVD File System Factory
//

Error DVDFileSystemFactory::CreateFileSystem(RootIterator * rit, GenericProfile * profile, GenericFileSystem * & gfs)
	{
	Error err;

	gfs = new DVDFileSystem(NULL); //Remember to set EventDispatcher for this file system (here we have to pass NULL)
	if (!gfs)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	if (IS_ERROR(err = gfs->Init(rit, NULL, profile)))
		delete gfs;

	GNRAISE(err);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\Config\FileSystemFactory.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  File System Factories
//
////////////////////////////////////////////////////////////////////

#ifndef FILESYSTEMFACTORY_H
#define FILESYSTEMFACTORY_H

#include "driver/dvdpldrv/Common/DVDFile.h"

class FileSystemFactory
	{
	public:
		virtual Error CreateFileSystem(RootIterator * rit, GenericProfile * profile, GenericFileSystem * & gfs);
	};

class DVDFileSystemFactory : public FileSystemFactory
	{
	public:
		virtual Error CreateFileSystem(RootIterator * rit, GenericProfile * profile, GenericFileSystem * & gfs);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\Config\VCDDiskPlayerFactory.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef VCDDISKPLAYERFACTORY_H
#define VCDDISKPLAYERFACTORY_H

#include "DiskPlayerFactory.h"

class FullVCDDiskPlayerFactory : public VCDDiskPlayerFactory
	{
	public:
		virtual Error CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile, DVDDiskType type,
												 VCDFileSystem * vcdfs, CDDiskPlayerClass * & player);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\Config\VCDDiskPlayerFactory.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "VCDDiskPlayerFactory.h"
#include "driver/dvdpldrv/Common/VCDDiskPlayer.h"

//
//  Real Factory
//

Error FullVCDDiskPlayerFactory::CreateDiskPlayer(WinPortServer * server, UnitSet units, GenericProfile * profile,
																 DVDDiskType diskType, VCDFileSystem * vcdfs, CDDiskPlayerClass * & player)
	{
	Error err;

	//
	//  Create Disk Player
	//

	player = new VCDDiskPlayerClass(server, units);
	if (!player)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);

	//
	//  Initialize player
	//

	if (IS_ERROR(err = ((VCDDiskPlayerClass*)player)->Init(server, profile, diskType, vcdfs)))
		delete player;

	GNRAISE(err);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\AVF\MPEGAudioHeader.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:       Driver/Dvdpldrv/Common/MPEGAudioHeader.h
// AUTHOR:     Sam Frantz
// COPYRIGHT:  (c) 2000 Ravisent Technologies, Inc.
// CREATED:    3-SEP-2000
//
// PURPOSE:    Common MPEG audio data types.
//
// HISTORY:

#ifndef MPEGAUDIOHEADER_H
#define MPEGAUDIONEADER_H

#include "Library/Common/Prelude.h"
#include "Library/Common/Gnerrors.h"
#include "Driver/Dvdpldrv/Common/AVF/MPEGAudioTypes.h"
#include "Driver/Dvdpldrv/Common/DVDTime.h"

// #define ONLY_EXTERNAL_VISIBLE
// #include "Library/Hardware/Mpegdec/Generic/Mpegdec.h"

#define MPEG_BITRATE_INDEX_BAD	(0x0F)
#define MPEG_BITRATE_INDEX_FREE	(0x00)	// also bad!
#define MPEG_SAMPLE_RATE_INDEX_BAD	(0x03)
#define MPEG_AUDIO_FRAME_HEADER_LEN		(4)

// operates upon first byte in header
#define IS_MPEG_FRAMEHEADER_SYNC_BYTE0(b)		(b == 0xFF)

// operates upon second byte in header
#define IS_MPEG_FRAMEHEADER_SYNC_BYTE1(b)		((b & 0xE0) == 0xE0)
#define MPEG_VERSION_FROM_BYTE1(b)				((MPEGAudioVersion)((b & 0x18) >> 3))
#define MPEG_LAYER_FROM_BYTE1(b)		((MPEGAudioLayerDescription)(4-((b & 0x06)>>1))) // 4 == RESERVED
#define IS_MPEG_CRC_PROTECTED_BYTE1(b)			((b & 0x01) == 0x00)

// operates upon third byte in header
#define MPEG_BITRATE_INDEX_FROM_BYTE2(b)		((b & 0xF0) >> 4)
#define MPEG_SAMPLE_RATE_INDEX_FROM_BYTE2(b)	((b & 0x0C) >> 2)
#define IS_MPEG_FRAME_PADDED_BYTE2(b)			((b & 0x02) == 0x02)
#define IS_MPEG_PRIVATE_BIT_SET_BYTE2(b)		((b & 0x01) == 0x01)

// operates upon fourth byte in header
#define MPEG_CHANNEL_MODE_FROM_BYTE3(b)		((MPEGAudioChannelMode)((b & 0xC0) >> 6))
#define MPEG_LAYER_I_AND_II_JOINT_STEREO_MODE_EXT_FROM_BYTE3(b) \
							((MPEGAudioJointStereoModeExtLayerIAndII)((b & 0x30) >> 4))
#define IS_MP3_INTENSITY_STEREO_BYTE3(b)		((b & 0x10) == 0x10)
#define IS_MP3_MS_STEREO_BYTE3(b)				((b & 0x20) == 0x20)
#define IS_MPEG_COPYRIGHTED_BYTE3(b)			((b & 0x08) == 0x08)
#define IS_MPEG_ORIGINAL_MEDIA_BYTE3(b)		((b & 0x04) == 0x04)
#define MPEG_EMPHASIS_MODE_FROM_BYTE3(b)		((MPEGAudioEmphasisMode)(b & 0x03))

// ID3V1 parsing macros
#define IS_MPEG_ID3V1_ID_BYTE0(b)				(b == 0x54)		// T as in TAG
#define IS_MPEG_ID3V1_ID_BYTE1(b)				(b == 0x41)		// A as in TAG
#define IS_MPEG_ID3V1_ID_BYTE2(b)				(b == 0x47)		// G as in TAG

#define MPEG_ID3V1_ID_LEN							(3)
#define MPEG_ID3V1_TITLE_LEN						(30)
#define MPEG_ID3V1_ARTIST_LEN						(30)
#define MPEG_ID3V1_ALBUM_LEN						(30)
#define MPEG_ID3V1_YEAR_LEN						(4)
#define MPEG_ID3V1_COMMENT_LEN					(29)	// tricky, ID3v1.1 allows track# as char 30

#define MPEG_ID3V1_TITLE_START					(MPEG_ID3V1_ID_LEN)
#define MPEG_ID3V1_ARTIST_START					(MPEG_ID3V1_TITLE_START+MPEG_ID3V1_TITLE_LEN)
#define MPEG_ID3V1_ALBUM_START					(MPEG_ID3V1_ARTIST_START+MPEG_ID3V1_ARTIST_LEN)
#define MPEG_ID3V1_YEAR_START						(MPEG_ID3V1_ALBUM_START+MPEG_ID3V1_ALBUM_LEN)
#define MPEG_ID3V1_COMMENT_START					(MPEG_ID3V1_YEAR_START+MPEG_ID3V1_YEAR_LEN)
#define MPEG_ID3V1_TRACKNUM_BYTE					(MPEG_ID3V1_COMMENT_START+MPEG_ID3V1_COMMENT_LEN)
#define MPEG_ID3V1_GENRE_BYTE						(MPEG_ID3V1_TRACKNUM_BYTE+1)
#define MPEG_ID3V1_FRAME_BYTES					(MPEG_ID3V1_GENRE_BYTE+1)	// 128
#define MPEG_ID3V1_FRAME_SKIP_BYTES				(MPEG_ID3V1_FRAME_BYTES - MPEG_ID3V1_ID_LEN)


// ID3V2 parsing macros
#define IS_MPEG_ID3V2_ID_BYTE0(b)		(b == 0x49)		// I as in TAG
#define IS_MPEG_ID3V2_ID_BYTE1(b)		(b == 0x44)		// D as in TAG
#define IS_MPEG_ID3V2_ID_BYTE2(b)		(b == 0x33)		// 3 as in TAG
#define MPEG_ID3V2_ID_LEN					(3)
#define MPEG_ID3V2_HEADER_BYTES			(10)	// plus some extra stuff
#define MPEG_ID3V2_FLAG_ZERO_LEN			(3)
#define MPEG_ID3V2_TAG_SIZE(a,b,c,d)	(a*2097152 + b*16384 + c*128 + d)
#define ID3V2_FOOTER_PRESENT_MASK		(0x10)

typedef struct
	{
	char		id[MPEG_ID3V2_ID_LEN+1];	// must be 'ID3'
	BYTE		majorVersion;
	BYTE		minorVersion;
	BYTE		flags;
	BYTE		zeros[MPEG_ID3V2_FLAG_ZERO_LEN]; // NOT null-terminated
	BYTE		sizeA;	// use MPEG_ID3V2_TAG_SIZE macro to get actual size
	BYTE		sizeB;
	BYTE		sizeC;
	BYTE		sizeD;
	BOOL		footerPresent;
	DWORD		totalTagSize; // does not take into account footer presence
	} MPEGAudioID3V2Header;

// VBR header parsing macros
#define IS_MPEG_VBR_ID_BYTE0(b)				(b == 0x58)		// X as in Xing
#define IS_MPEG_VBR_ID_BYTE1(b)				(b == 0x69)		// i as in Xing
#define IS_MPEG_VBR_ID_BYTE2(b)				(b == 0x6E)		// n as in Xing
#define IS_MPEG_VBR_ID_BYTE3(b)				(b == 0x67)		// g as in Xing

#define IS_VBR_HEADER(p)  (IS_MPEG_VBR_ID_BYTE0(p[0]) && IS_MPEG_VBR_ID_BYTE1(p[1]) && \
								   IS_MPEG_VBR_ID_BYTE2(p[2]) && IS_MPEG_VBR_ID_BYTE3(p[3]))

#define MPEG1_MONO_VBR_OFFSET				(18)
#define MPEG1_STEREO_VBR_OFFSET			(33)
#define MPEG2_MONO_VBR_OFFSET				(10)
#define MPEG2_STEREO_VBR_OFFSET			(18)

#define MPEG_VBR_ID_LEN						(4)
#define MPEG_VBR_FLAG_BYTES				(4)
#define MPEG_VBR_FRAMECOUNT_BYTES		(4)
#define MPEG_VBR_FILESIZE_BYTES			(4)
#define MPEG_VBR_TOC_BYTES					(100)
#define MPEG_VBR_SCALE_BYTES				(4)

#define MPEG_VBR_FRAMES_FLAG			(0x0001)
#define MPEG_VBR_BYTES_FLAG			(0x0002)
#define MPEG_VBR_TOC_FLAG				(0x0004)
#define MPEG_VBR_SCALE_FLAG			(0x0008)

#define MPEG_VBR_FLAGS_START				(MPEG_VBR_ID_LEN)
#define MPEG_VBR_FRAMECOUNT_START		(MPEG_VBR_FLAGS_START+MPEG_VBR_FLAG_BYTES)
#define MPEG_VBR_FILESIZE_START			(MPEG_VBR_FRAMECOUNT_START+MPEG_VBR_FRAMECOUNT_BYTES)
#define MPEG_VBR_TOC_START					(MPEG_VBR_FILESIZE_START+MPEG_VBR_FILESIZE_BYTES)
#define MPEG_VBR_SCALE_START				(MPEG_VBR_TOC_START+MPEG_VBR_TOC_BYTES)
#define MPEG_VBR_FRAME_BYTES				(MPEG_VBR_SCALE_START+MPEG_VBR_SCALE_BYTES)	// 120
#define MPEG_VBR_FRAME_SKIP_BYTES		(MPEG_VBR_FRAME_BYTES - MPEG_VBR_ID_LEN)

#define BIG_ENDIAN_DWORD(p)	((p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3])

typedef struct
	{
	DWORD		flags;
	DWORD		frames;	// use macro to get actual frame count
	DWORD		fileSize;	// use macro to get actual file size
	BYTE		toc[MPEG_VBR_TOC_BYTES];				// table of contents, for searching
	DWORD		scale;
	} MPEGAudioVBRHeader;

#define MPEG_AUDIO_UNKNOWN_TAG_ID_SIZE	4	// max(MPEG_ID3V1_ID_LEN, MPEG_ID3V2_ID_LEN, MPEG_VBR_ID_LEN)
enum MPEGNonAudioFrameType
	{
	MPEG_NONAUDIO_FRAME_NONE		= 0,
	MPEG_NONAUDIO_ID3V1_FRAME		= 1,
	MPEG_NONAUDIO_ID3V2_FRAME		= 2,
	MPEG_NONAUDIO_VBR_FRAME			= 3,
	MPEG_NONAUDIO_LYRICS3_FRAME	= 4
	};

enum MPEGNonAudioParseMode
	{
	MPEG_NONAUDIO_PARSE_QUICK		= 0,
	MPEG_NONAUDIO_PARSE_FULL		= 1
	};

enum MPEGAudioFileParseState
	{
	MP3PS_BEGINNING_OF_FILE = 0,
	MP3PS_BEGINNING_FRAME_SEARCH = 1,
	MP3PS_AFTER_FIRST_HEADER_BYTE = 2,
	MP3PS_AFTER_SECOND_HEADER_BYTE = 3,
	MP3PS_AFTER_THIRD_HEADER_BYTE = 4,
	MP3PS_BEFORE_CRC_BYTE0 = 5, // if CRC not used go straight to "AFTER_HEADER"
	MP3PS_BEFORE_CRC_BYTE1 = 6, // if CRC not used go straight to "AFTER_HEADER"
	MP3PS_AFTER_HEADER = 7,
	MP3PS_IN_DATA = 8,
	MP3PS_AFTER_DATA = 9,
	// new states required by ID3v2 tags
	MP3PS_AFTER_FIRST_ID3V2_HEADER_BYTE = 10,
	MP3PS_AFTER_SECOND_ID3V2_HEADER_BYTE = 11,
	MP3PS_AFTER_THIRD_ID3V2_HEADER_BYTE = 12,
	MP3PS_AFTER_ID3V2_MAJOR_VERSION_BYTE = 13,
	MP3PS_AFTER_ID3V2_MINOR_VERSION_BYTE = 14,
	MP3PS_AFTER_ID3V2_FLAGS_BYTE = 15,
	MP3PS_AFTER_FIRST_ID3V2_SIZE_BYTE = 16,
	MP3PS_AFTER_SECOND_ID3V2_SIZE_BYTE = 17,
	MP3PS_AFTER_THIRD_ID3V2_SIZE_BYTE = 18
	};

//
// class MPEGNonAudioFrame
//

class MPEGNonAudioFrame
	{
	public:
		MPEGAudioID3V2Header			id3v2Frame;
		MPEGAudioVBRHeader			vbrFrame;
		BOOL								id3v2FrameAvailable;
		BOOL								vbrFrameAvailable;
		MPEGNonAudioFrame(void);
		~MPEGNonAudioFrame(void);
		void Cleanup(void);
	};

//
// class MPEGAudioFrameHeader
//

class MPEGAudioFrameHeader
	{
	public:
		BYTE	header[4];
		// data is accessed directly
		MPEGAudioVersion				mpegVersion;
		MPEGAudioLayerDescription	mpegLayer;
		BOOL								hasCRC;
		BOOL								validCRC;
		WORD								actualCRC;
		BYTE								bitrateIndex;
		WORD								bitrate;
		BYTE								sampleRateIndex;
		WORD								sampleRate;
		WORD								frameLength;
		BOOL								privateBit;
		MPEGAudioChannelMode								channelMode;
		MPEGAudioJointStereoModeExtLayerIAndII		modeExtension;
		BOOL								copyrighted;
		BOOL								originalMedia;
		MPEGAudioEmphasisMode		emphasisMode;
		BOOL								validHeader;
		BOOL								bitrateSwitchingInUse;
		BOOL								bitReservoirInUse;
		BOOL								frameIsPadded;
		WORD								padBytesSlotSize;
		BOOL								intensityStereo;
		BOOL								msStereo;
		BOOL								headerBytesLoaded;
		static const WORD				v1L1Bitrate[15];
		static const WORD				v1L2Bitrate[15];
		static const WORD				v1L3Bitrate[15];
		static const WORD				v2L1Bitrate[15];
		static const WORD				v2L2or3Bitrate[15];
		static const WORD				ver1SampleRate[3];
		static const WORD				ver2SampleRate[3];
		static const WORD				ver25SampleRate[3];
		static DWORD					halfBitRate;	// for calculation efficiency

		// member functions
		MPEGAudioFrameHeader(void) { validHeader = FALSE; headerBytesLoaded = FALSE; validCRC = FALSE; }
		void LoadHeader(BYTE first, BYTE second, BYTE third, BYTE fourth)
			{
			header[0] = first;
			header[1] = second;
			header[2] = third;
			header[3] = fourth;
			headerBytesLoaded = TRUE;
			validHeader = FALSE;
			validCRC = FALSE;
			}
		Error LoadHeader(BYTE *buffer)
			{
			if (buffer != (BYTE *) NULL)
				{
				header[0] = buffer[0];
				header[1] = buffer[1];
				header[2] = buffer[2];
				header[3] = buffer[3];
				headerBytesLoaded = TRUE;
				validHeader = FALSE;
				validCRC = FALSE;
				GNRAISE_OK;
				}
			else
				GNRAISE(GNR_OBJECT_EMPTY);
			}
		Error ParseHeader(const MPEGAudioFrameInfo *pMpegInfo = NULL);
		Error VerifyByte0(BYTE header_0);
		Error VerifyByte1(BYTE header_1);
		Error VerifyByte2(BYTE header_2);
		Error VerifyByte3(BYTE header_3);
		BYTE * GetHeaderPtr(void) { return &header[0]; }
		void SetCRC(BYTE byte0, BYTE byte1)
			{
			actualCRC = (byte0 << 8) + byte1;
			if (hasCRC)
				validCRC = TRUE;
			}
		DWORD	CalculateMilliSeconds(DWORD dataSize);

		Error	ValidateTagHeaderChar (BYTE b, int num, BOOL &matches);

		void InvalidateHeader(void) { validHeader = FALSE; headerBytesLoaded = FALSE; validCRC = FALSE; }
	};

//
// class MPEGNonAudioParseState
//

class MPEGNonAudioParseState
	{
	public:
		MPEGNonAudioFrame				info;		// this contains the actual data

		char								nonAudioFrameHeader[MPEG_AUDIO_UNKNOWN_TAG_ID_SIZE];
		char								yearStr[MPEG_ID3V1_YEAR_LEN+1];

		DWORD								nonAudioFrameHeaderCount;

		BOOL								inNonAudioFrame;

		MPEGNonAudioFrameType		currentFrameType;

		BOOL								id3v1FrameBeingBuilt;
		BOOL								id3v2FrameBeingBuilt;
		BOOL								vbrFrameBeingBuilt;

		DWORD								id3v1FrameOffset;
		DWORD								id3v2FrameOffset;
		DWORD								vbrFrameOffset;

		DWORD								nonAudioFrameParseOffset;
		DWORD								nonAudioFrameParseFieldOffset;
		DWORD								nonAudioFrameParseHeaderSize;

		MPEGNonAudioParseState(void);
		~MPEGNonAudioParseState(void);
		void Cleanup(void);
		Error ParseVBRHeader(BYTE *pVBR);
		void ResetByteParser(void);
	};

//
//	This is local to the MPEG Audio Filter
//

class MPEGAudioParseState
	{
	public:
		// File parse data
		MPEGAudioFileParseState		state;
		MPEGNonAudioParseState		nonAudio;
		DWORD								dataBytesRead;

		MPEGAudioParseState(void);
		~MPEGAudioParseState(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\dvdpldrv\Common\AVF\MPEGAudioTypes.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:       Driver/Dvdpldrv/Common/MPEGAudioTypes.h
// AUTHOR:     Sam Frantz
// COPYRIGHT:  (c) 2000 Ravisent Technologies, Inc.
// CREATED:    6-NOV-2000
//
// PURPOSE:    Common MPEG audio data types.
//
// HISTORY:

#ifndef MPEGAUDIOTYPES_H
#define MPEGAUDIOTYPES_H

enum MPEGAudioVersion
	{
	MPEG_AUDIO_VERSION_2_5 = 0,
	MPEG_AUDIO_VERSION_RESERVED = 1,
	MPEG_AUDIO_VERSION_2 = 2,
	MPEG_AUDIO_VERSION_1	= 3
	};

// MPEGAudioLayer is defined in "library\hardware\mpegdec\generic\mpegdec.h" as:
//
// enum MPEGAudioLayer
//        {
//        MPAUDLAYER_1,
//        MPAUDLAYER_2,
//        MPAUDLAYER_3                            // = MP3
//        };

enum MPEGAudioLayerDescription
	{
	MPEG_AUDIO_LAYER_1 = 1,
	MPEG_AUDIO_LAYER_2 = 2,
	MPEG_AUDIO_LAYER_3 = 3, // = MP3
	MPEG_AUDIO_LAYER_RESERVED = 4
	};

enum MPEGAudioChannelMode
	{
	MPEG_AUDIO_MODE_STEREO = 0,
	MPEG_AUDIO_MODE_JOINT_STEREO = 1,
	MPEG_AUDIO_MODE_DUAL_CHANNEL = 2,
	MPEG_AUDIO_MODE_SINGLE_CHANNEL = 3
	};

enum MPEGAudioJointStereoModeExtLayerIAndII
	{
	MPEG_AUDIO_INTENSITY_STEREO_BANDS_4_TO_31 = 0,
	MPEG_AUDIO_INTENSITY_STEREO_BANDS_8_TO_31 = 1,
	MPEG_AUDIO_INTENSITY_STEREO_BANDS_12_TO_31 = 2,
	MPEG_AUDIO_INTENSITY_STEREO_BANDS_16_TO_31 = 3
	};

enum MPEGAudioEmphasisMode
	{
	MPEG_AUDIO_EMPHASIS_NONE = 0,
	MPEG_AUDIO_EMPHASIS_50_15_MS = 1,
	MPEG_AUDIO_EMPHASIS_RESERVED = 2,
	MPEG_AUDIO_EMPHASIS_CCIT_J17 = 3
	};

#define MPEG_ID3V1_STRING_LEN		32	// 30 + 1 terminator + 1 padding byte

typedef struct
	{
	char		title[MPEG_ID3V1_STRING_LEN];
	char		artist[MPEG_ID3V1_STRING_LEN];
	char		album[MPEG_ID3V1_STRING_LEN];
	char		comment[MPEG_ID3V1_STRING_LEN];
	WORD		year;			// or NULL
	BYTE		trackNum;	// or NULL
	BYTE		genreCode;	// this is a joke
	} MPEGAudioID3V1Tag;

typedef struct
	{
	MPEGAudioVersion				mpegVersion;
	MPEGAudioLayerDescription	mpegLayer;
	DWORD								bitrate;
	DWORD								sampleRate;
	DWORD								frameLength;
	BOOL								privateBit;
	MPEGAudioChannelMode								channelMode;
	MPEGAudioJointStereoModeExtLayerIAndII		modeExtension;
	BOOL								copyrighted;
	BOOL								originalMedia;
	MPEGAudioEmphasisMode		emphasisMode;
	BOOL								bitrateSwitchingInUse;
	BOOL								bitReservoirInUse;
	BOOL								intensityStereo;
	BOOL								msStereo;
	} MPEGAudioFrameInfo;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\AC3Decoder\AC3Decoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef AC3DECODER_H
#define AC3DECODER_H

#include "..\common\StreamTiming.h"
#include "..\audio\PCMWaveOut.h"
#include "..\audio\AudioBitStream.h"
#include "library\common\profiles.h"
#include "library\hardware\audio\generic\ac3setup.h"

#define HIGH_PRECISION_FFT	0

//#define DOLBY_TEST_MODE		0

#if HIGH_PRECISION_FFT
typedef	double	fftreal;
#else
typedef	float		fftreal;
#endif

struct complex {fftreal r; fftreal i;};

#define COMP_MODE_CUSTOM_A		0
#define COMP_MODE_CUSTOM_B		1
#define COMP_MODE_LINE			2
#define COMP_MODE_RF			3

#define	MAX_AC3_CHANNELS	6
#define	MAX_CPLSUBND	18
#define	MAX_CPLGRPS		100
#define	MAX_CHGRPS		100

#define AC3_BLOCK_TO_ZERO_ON_SWITCH	(32)

#define	M3DB	0.707106781

class AC3Decoder
	{
	protected:
		AudioBitStream	*	strm;
		PCMWaveOut     *	pcmWaveOut;
		GenericProfile *	globalProfile;
		GenericProfile	*	profile;

	private:
		fftreal mant1lt[32][4];
		fftreal mant2lt[128][4];
		fftreal mant4lt[128][2];
		char	exp5lt[128][4];

	protected:
		int		zeroBlocks;
		WORD	syncword;
		WORD	crc1;
		BYTE	fscod;
		BYTE	frmsizecod;
		BYTE	lastfscod;

		int		frameSize;
		__int64	frameStart;

		BYTE	bsid;
		BYTE	bsmod;
		BYTE	acmod;

		BYTE	nfchans;

		BYTE	cmixlev;
		BYTE	surmixlev;
		BYTE	dsurmod;
		bool	lfeon;
		BYTE	dialnorm;
		bool	compre;
		BYTE	compr;
		bool	langcode;
		BYTE	langcod;
		bool	audprodie;
		BYTE	mixlevel;
		BYTE	roomtyp;
		BYTE	dialnorm2;
		bool	compr2e;
		BYTE	compr2;
		bool	lngcod2e;
		BYTE	langcod2;
		bool	audprodi2e;
		BYTE	mixlevel2;
		BYTE	roomtyp2;
		bool	copyrightb;
		bool	origbs;
		bool	timecod1e;
		WORD	timecod1;
		bool	timecod2e;
		WORD	timecod2;

		bool	addbsie;
		BYTE	addbsil;

		bool	blksw[MAX_AC3_CHANNELS];
		bool	dithflag[MAX_AC3_CHANNELS];
		short	dithReg;

		bool	dynrnge;
		BYTE	dynrng;
		bool	dynrng2e;
		BYTE	dynrng2;

		bool	cplstre;
		bool	cplinu;

		bool	chincpl[MAX_AC3_CHANNELS];
		bool	phsflginu;
		BYTE	cplbegf;
		BYTE	cplendf;

		BYTE	ncplsubnd;

		bool	cplbndstrc[MAX_CPLSUBND];

		bool	cplcoe[MAX_AC3_CHANNELS];
		BYTE	mstrcplco[MAX_AC3_CHANNELS];

		BYTE	ncplbnd;

		BYTE	cplcoexp[MAX_AC3_CHANNELS][MAX_CPLSUBND];
		BYTE	cplcomant[MAX_AC3_CHANNELS][MAX_CPLSUBND];
		fftreal cplco[MAX_AC3_CHANNELS][MAX_CPLSUBND];

		bool	phsflg[MAX_CPLSUBND];

		bool	rematstr;

		bool	rematflg[4];

		BYTE	cplexpstr;
		bool	newcplexps;
		BYTE	chexpstr[MAX_AC3_CHANNELS];
		bool	newchexps[MAX_AC3_CHANNELS];
		BYTE	lfeexpstr;
		bool	newlfeexps;
		BYTE	chbwcod[MAX_AC3_CHANNELS];

		BYTE	cplabsexp;
		BYTE	ncplgrps;
		WORD	cplstrtmant;
		WORD	cplendmant;
		WORD	ncplmant;
		BYTE	cplgexps[MAX_CPLGRPS];
		BYTE	cplexps[256];
		WORD	strtmant[MAX_AC3_CHANNELS];
		WORD	endmant[MAX_AC3_CHANNELS];
		WORD	nchmant[MAX_AC3_CHANNELS];
		BYTE	nchgrps[MAX_AC3_CHANNELS];
		BYTE	gexps[MAX_AC3_CHANNELS][MAX_CHGRPS+1];
		BYTE	exps[MAX_AC3_CHANNELS][256];
		BYTE	gainrng[MAX_AC3_CHANNELS];
		WORD	lfestrtmant;
		WORD	lfeendmant;
		BYTE	nlfegrps;
		BYTE	lfegexps[3];
		BYTE	lfeexps[256];
		WORD	nlfemant;

		bool	baie;
		BYTE	sdcycod;
		BYTE	fdcycod;
		BYTE	sgaincod;
		BYTE	dbpbcod;
		BYTE	floorcod;

		bool	snroffste;
		BYTE	csnroffst;
		BYTE	cplfsnroffst;
		BYTE	cplfgaincod;
		bool	nosnroffst;

		BYTE	fsnroffst[MAX_AC3_CHANNELS];
		BYTE	fgaincod[MAX_AC3_CHANNELS];

		BYTE	lfefsnroffst;
		BYTE	lfefgaincod;

		bool	cplleake;
		BYTE	cplfleak;
		BYTE	cplsleak;

		bool	deltbaie;

		BYTE	cpldeltbae;
		BYTE	deltbae[MAX_AC3_CHANNELS];

		BYTE	cpldeltnseg;

		BYTE	cpldeltoffst[8];
		BYTE	cpldeltlen[8];
		BYTE	cpldeltba[8];

		BYTE	deltnseg[MAX_AC3_CHANNELS];
		BYTE	deltoffst[MAX_AC3_CHANNELS][8];
		BYTE	deltlen[MAX_AC3_CHANNELS][8];
		BYTE	deltba[MAX_AC3_CHANNELS][8];

		BYTE	cplbap[256];
		BYTE	chbap[MAX_AC3_CHANNELS][256];
		BYTE	lfebap[256];

//		fftreal	chcoeff[MAX_AC3_CHANNELS][256];

		PadOn16Byte	pad0;

		fftreal	cplcoeff[256];
		fftreal	lfecoeff[256];

		fftreal	chpostfft[MAX_AC3_CHANNELS][512];
		fftreal lfepostfft[512];

		fftreal overlap[6][256];
		fftreal ac3WindowTable2[256*2];

		short	leftRightBuffer[6*256*2];
		short	encodedBuffer[6*256*2];

		AC3DynamicRange		drc;
		AC3DualModeConfig	dualMode;
		AC3KaraokeConfig	karaoke;
		bool				ac3DigitalOutput;

		bool	skiple;
		WORD	skipl;

		int	sampleRate;
		int	outNum;

		bool	downmixActive;
		int		hdr, ldr;
		int		compressionMode;
		bool	useDialNorm;
		bool	surroundDownmix, surroundDownmixProfile, enableLFE;

		bool UnpackExponents(int ngrps, BYTE * gexp, BYTE expstr, BYTE absexp, BYTE * exp);

		void CalculateBitAllocation(
										int start,
										int end,
										int fgaincod,
										int fsnroffst,
										BYTE * exp,
										int fastleak,
										int slowleak,
										BYTE deltbae,
										WORD deltnseg,
										BYTE * deltoffst,
										BYTE * deltba,
										BYTE * deltlen,
										BYTE * bap,
										bool lfe);

		int mant1Num, mant2Num, mant4Num;

		fftreal mant1Val[3], mant2Val[3], mant4Val[2];

		void InitParseMantissa(void);

		fftreal GetDitherValue(void);
		fftreal GetDitheredMantissa(int exp);

		fftreal GetMantissa(int size, int exp, bool dither);

		void GetMantissas(int num, fftreal * dst, BYTE * bap, BYTE * exps, bool dither);

		void UncoupleChannel(int ch);

		void RematrixChannels(void);

		void TransformChannels(void);

		int leftChannelIndex, rightChannelIndex;

		fftreal leftMultiplier, rightMultiplier;
		fftreal cmix, smix;

		bool channelPremixed[MAX_AC3_CHANNELS];

		void PreDownmixChannels(void);

		fftreal CalcCompression(int cVal, int hscl, int lscl);

		void DynamicRangeCompression(void);

		void PostDownmixChannels(void);

		void InitWindow(void);
		void WindowChannels(short * leftRightBuffer);

		void WindowChannel(fftreal * src, fftreal * overlap, fftreal mul, short * dst);
		void WindowChannel(fftreal * src, fftreal * overlap, fftreal * dst);
		void WindowChannelInterleaved(fftreal * src, fftreal * overlap, fftreal * dst, fftreal mul=1.0);

		bool ParseAudblk(int blknum);

		void StartParse(void);

		bool ParseSyncInfo(void);

		bool ParseBSI(void);

		int	lastTime;

		int	currentDataTime;

		bool	hurryUp;
		int	recoverPhase;

		int	lastLeft, lastRight;

		TimingSlave	*	timingSlave;

		void MuteAudioBuffer(void);
		void UnmuteAudioBuffer(void);
		bool CheckCRCAndFrameAC3DigitalOutput(void);
		void InitLocalsNewStream(void);

	public:
		AC3Decoder(AudioBitStream	*	strm,
			        PCMWaveOut		*	pcmWaveOut,
					  TimingSlave		*	timingSlave,
					  GenericProfile			*	globalProfile,
					  GenericProfile			*	profile);

		virtual ~AC3Decoder(void);

		void ParseSyncFrame(void);

		void SkipSyncFrame(void);

		void BeginStreaming(void);

		void StartStreaming(int playbackSpeed);

		void StopStreaming(void);

		void EndStreaming(bool fullReset);

		void DetachStreaming(void);
		void AttachStreaming(void);

		void SetDigitalOut(AudioTypeConfig ac3AudioType);
		void GetDigitalOut(AudioTypeConfig & ac3AudioType);
		void SetAudioOutConfig(AC3SpeakerConfig spkCfg, AC3DualModeConfig dualModeCfg, AC3KaraokeConfig karaokeCfg);
		void SetDolbyTestMode(AC3OperationalMode op, WORD hf, WORD lf, AC3DialogNorm dn);
		void GetDolbyTestMode(AC3OperationalMode &op, WORD &hf, WORD &lf, AC3DialogNorm &dn);

		void SetAC3Config(AC3DynamicRange dr, BOOL enableLFE);
		void GetAC3Config(AC3DynamicRange &dr, BOOL &enableLFE);

	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\AC3Decoder\AC3Decoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "AC3Decoder.h"
#include "math.h"
#include <memory.h>
#include "library\common\vddebug.h"
#include "..\common\TimedFibers.h"

#define BITSTREAM_CHECK		1
#define PCM_CLIPPING		1
#define DUMP_FFT_DATA		0
#define USE_SIMPLE_DOWNMIX	0
#define USE_DITHERING		1
#define DUMP_ERRORS			0
#define USE_PCM_DITHERING	0
#define DUMP_COMPRESSION	0
#define USE_TRIANGLE_DITHER	1
#define USE_SIMD_WINDOWING	1

#include "AC3Tables.h"

#define chcoeff	chpostfft
//#define lfecoeff	lfepostfft

#if DUMP_FFT_DATA
#include <stdio.h>
FILE * dfile;
#endif

int FrameCnt;

//#define UFDB(x) ((fftreal)(pow(1.258925412, (fftreal)x / 2)))
#define UFDB(x) ((fftreal)(pow(1.258925412, (fftreal)x * 1.00343331887 / 2)))

static fftreal NegativeUDB[32] =
	{
	UFDB(-31), UFDB(-30), UFDB(-29), UFDB(-28), UFDB(-27), UFDB(-26), UFDB(-25), UFDB(-24),
	UFDB(-23), UFDB(-22), UFDB(-21), UFDB(-20), UFDB(-19), UFDB(-18), UFDB(-17), UFDB(-16),
	UFDB(-15), UFDB(-14), UFDB(-13), UFDB(-12), UFDB(-11), UFDB(-10), UFDB(- 9), UFDB(- 8),
	UFDB(- 7), UFDB(- 6), UFDB(- 5), UFDB(- 4), UFDB(- 3), UFDB(- 2), UFDB(- 1), 1.0
	};

static const int Plus11DBCompr = 7509;

complex cossintab64[64];
complex xcossin512[128];
complex xcossin256[64];

static const double pi =  3.14159265359;

double xcos1(int k, int n)
	{
	return -cos(2*pi*(8*k+1)/(8*n));
	}

double xsin1(int k, int n)
	{
	return -sin(2*pi*(8*k+1)/(8*n));
	}

double xcos2(int k, int n)
	{
	return -cos(2*pi*(8*k+1)/(4*n));
	}

double xsin2(int k, int n)
	{
	return -sin(2*pi*(8*k+1)/(4*n));
	}

static void InitIFFT(void)
	{
	int i;
	double w;

	for(i=0; i<64; i++)
		{
		w = 2 * pi * i / 128;
		cossintab64[i].r = (fftreal)cos(w);
		cossintab64[i].i = (fftreal)sin(w);
		}

	for(i=0; i<128; i++)
		{
		xcossin512[i].r = (fftreal)xcos1(i, 512);
		xcossin512[i].i = (fftreal)xsin1(i, 512);
		}

	for(i=0; i<64; i++)
		{
		xcossin256[i].r = (fftreal)xcos2(i, 512);
		xcossin256[i].i = (fftreal)xsin2(i, 512);
		}
	}


static inline short MKShort(unsigned char high, unsigned char low)
	{
	return ((short)high << 8) | (short)low;
	}


AC3Decoder::AC3Decoder(AudioBitStream * strm,
							  PCMWaveOut * pcmWaveOut,
							  TimingSlave * timingSlave,
							  GenericProfile			*	globalProfile,
							  GenericProfile			*	profile)
	{
#pragma warning(disable : 4244 4305)
	static fftreal valtab1[] = {-2./3., 0., 2./3.};
	static fftreal valtab2[] = {-4./5., -2./5., 0., 2./5., 4./5.};
	static fftreal valtab4[] = {-10./11., -8./11., -6./11., -4./11., -2./11., 0., 2./11., 4./11., 6./11., 8./11., 10./11.};
#pragma warning(default : 4244 4305)

	this->strm = strm;
	this->pcmWaveOut = pcmWaveOut;
	this->timingSlave = timingSlave;
	this->globalProfile = globalProfile;
	this->profile = profile;

	int i;

	for(i=0; i<27; i++)
		{
		mant1lt[i][0] = valtab1[i / 9];
		mant1lt[i][1] = valtab1[i / 3 % 3];
		mant1lt[i][2] = valtab1[i % 3];
		}

	for(i=28; i<32; i++)
		{
		mant1lt[i][0] = 0;
		mant1lt[i][1] = 0;
		mant1lt[i][2] = 0;
		}

	for(i=0; i<128; i++)
		{
		if (i < 125)
			{
			mant2lt[i][0] = valtab2[i / 25];
			mant2lt[i][1] = valtab2[i / 5 % 5];
			mant2lt[i][2] = valtab2[i % 5];
			}
		else
			{
			mant2lt[i][0] = 0;
			mant2lt[i][1] = 0;
			mant2lt[i][2] = 0;
			}
		if (i < 121)
			{
			mant4lt[i][0] = valtab4[i / 11];
			mant4lt[i][1] = valtab4[i % 11];
			}
		else
			{
			mant4lt[i][0] = 0;
			mant4lt[i][1] = 0;
			}
		if (i < 125)
			{
			exp5lt[i][0] = i / 25 - 2;
			exp5lt[i][1] = i / 5 % 5 - 2;
			exp5lt[i][2] = i % 5 - 2;
			}
		else
			{
			exp5lt[i][0] = 0;
			exp5lt[i][1] = 0;
			exp5lt[i][2] = 0;
			}
		}

	InitIFFT();
	InitWindow();

	lastfscod = 0xff;

	ac3DigitalOutput = false;

	globalProfile->Read("AudioDecoder", "UseLFE", enableLFE, FALSE);

	SetAC3Config(AC3DYNRG_COMPRESSED, enableLFE);
	SetAudioOutConfig(AC3SC_20_SURROUND_COMPATIBLE, AC3DMDM_STEREO, AC3KARA_AWARE);

	frameSize = 0;

#if DUMP_FFT_DATA
//	dfile = fopen("f:\\ac3\\dmp.txt", "w");
	dfile = fopen("D:\\dmp.txt", "w");
#endif
	}

static inline fftreal ShiftFP(fftreal f, int n)
	{
	static fftreal mulh[] =
		{1. / (1 <<  0), 1. / (1 <<  1), 1. / (1 <<  2), 1. / (1 <<  3),
		 1. / (1 <<  4), 1. / (1 <<  5), 1. / (1 <<  6), 1. / (1 <<  7),
		 1. / (1 <<  8), 1. / (1 <<  9), 1. / (1 << 10), 1. / (1 << 11),
		 1. / (1 << 12), 1. / (1 << 13), 1. / (1 << 14), 1. / (1 << 15),
		 1. / (1 << 16), 1. / (1 << 17), 1. / (1 << 18), 1. / (1 << 19),
		 1. / (1 << 20), 1. / (1 << 21), 1. / (1 << 22), 1. / (1 << 23),
		 1. / (1 << 24), 1. / (1 << 25), 1. / (1 << 26), 1. / (1 << 27),
		 1. / (1 << 28), 1. / (1 << 29), 1. / (1 << 30), 1. / (1 << 16) / (1 << 15),
		 1. / (1 << 16) / (1 << 16),
		 1. / (1 << 16) / (1 << 17),
		 1. / (1 << 16) / (1 << 18),
		 1. / (1 << 16) / (1 << 19),
		 1. / (1 << 16) / (1 << 20),
		 1. / (1 << 16) / (1 << 21),
		 1. / (1 << 16) / (1 << 22),
		 1. / (1 << 16) / (1 << 23),
		 1. / (1 << 16) / (1 << 24),
		 1. / (1 << 16) / (1 << 25),
		 1. / (1 << 16) / (1 << 26),
		 1. / (1 << 16) / (1 << 27),
		 1. / (1 << 16) / (1 << 28),
		 1. / (1 << 16) / (1 << 29),
		 1. / (1 << 16) / (1 << 30),
		 1. / (1 << 16) / (1 << 16) / (1 << 15),

		 1. / (1 << 16) / (1 << 16) / (1 << 16),
		 1. / (1 << 16) / (1 << 16) / (1 << 17),
		 1. / (1 << 16) / (1 << 16) / (1 << 18),
		 1. / (1 << 16) / (1 << 16) / (1 << 19),
		 1. / (1 << 16) / (1 << 16) / (1 << 20),
		 1. / (1 << 16) / (1 << 16) / (1 << 21),
		 1. / (1 << 16) / (1 << 16) / (1 << 22),
		 1. / (1 << 16) / (1 << 16) / (1 << 23),
		 1. / (1 << 16) / (1 << 16) / (1 << 24),
		 1. / (1 << 16) / (1 << 16) / (1 << 25),
		 1. / (1 << 16) / (1 << 16) / (1 << 26),
		 1. / (1 << 16) / (1 << 16) / (1 << 27),
		 1. / (1 << 16) / (1 << 16) / (1 << 28),
		 1. / (1 << 16) / (1 << 16) / (1 << 29),
		 1. / (1 << 16) / (1 << 16) / (1 << 30),
		 1. / (1 << 16) / (1 << 16) / (1 << 16) / (1 << 15)
		};

	return f * mulh[n];
	}


void AC3Decoder::StartParse(void)
	{
	int i, ch;

//#define START_CLEAR	syncword
//#define END_CLEAR		skiple

//	memset(&(this->START_CLEAR), 0, ((BYTE *)&(this->END_CLEAR)) - (BYTE *)&(this->START_CLEAR));

	for(ch = 0; ch< MAX_AC3_CHANNELS; ch++)
		for(i=0; i<256; i++)
			{
			overlap[ch][i] = 0;
			}


	for(ch = 0; ch < MAX_AC3_CHANNELS; ch++)
		for(i=0; i<256; i++)
			chcoeff[ch][i] = 0;

	for(i=0; i<256; i++)
		lfecoeff[i] = 0;

	dithReg = 1;
	}

static inline void MixChannels(fftreal * dst, fftreal * src, int num)
	{
	int i;

	for(i=0; i<num; i++)
		{
		*dst++ += *src++ * (fftreal)M3DB;
		}
	}

static inline void FMixChannels(fftreal * dst, fftreal * src, int num, fftreal f)
	{
	int i;

	for(i=0; i<num; i++)
		{
		*dst++ += *src++ * f;
		}
	}

static inline void AddChannels(fftreal * dst, fftreal * src, int num)
	{
	int i;

	for(i=0; i<num; i++)
		{
		*dst++ += *src++;
		}
	}

static inline void MulChannel(fftreal * dst, fftreal val, int num)
	{
	int i;

	for(i=0; i<num; i++)
		{
		*dst++ *= val;
		}
	}

static inline void MulChannels(fftreal * dst, fftreal * src, int num)
	{
	int i;

	for(i=0; i<num; i++)
		{
		*dst++ *= *src++;
		}
	}

static inline void IMixChannels(fftreal * dst, fftreal * src, int num)
	{
	int i;

	for(i=0; i<num; i++)
		{
		*dst++ -= *src++ * (fftreal)M3DB;
		}
	}

static const bool chp = true;

static const fftreal cmixs[] = {(fftreal)M3DB, (fftreal)0.594603557, (fftreal)0.500, (fftreal)0.594603557};
static const fftreal smixs[] = {(fftreal)M3DB, (fftreal)0.500, (fftreal)0.000, (fftreal)0.500};

void AC3Decoder::PreDownmixChannels(void)
	{
		{
		switch (acmod)
			{
			case 0:
				switch (dualMode)
					{
					case AC3DMDM_CHANNEL1:
						leftChannelIndex = 0;
						rightChannelIndex = 0;
						leftMultiplier = (fftreal)M3DB;
						rightMultiplier = (fftreal)M3DB;
						break;
					case AC3DMDM_CHANNEL2:
						leftChannelIndex = 1;
						rightChannelIndex = 1;
						leftMultiplier = (fftreal)M3DB;
						rightMultiplier = (fftreal)M3DB;
						break;
					case AC3DMDM_MIX:
						leftChannelIndex = 0;
						rightChannelIndex = 1;
						leftMultiplier = 0.5;
						rightMultiplier = 0.5;
						break;
					default:
					case AC3DMDM_STEREO:
						leftChannelIndex = 0;
						rightChannelIndex = 1;
						leftMultiplier = 1.0;
						rightMultiplier = 1.0;
						break;
					}
				break;
			case 2:
				leftChannelIndex = 0;
				rightChannelIndex = 1;
				leftMultiplier = 1.0;
				rightMultiplier = 1.0;
				break;
			case 1:
				leftChannelIndex = 0;
				rightChannelIndex = 0;
				leftMultiplier = (fftreal)M3DB;
				rightMultiplier = (fftreal)M3DB;
				break;
			case 3:
				channelPremixed[1] = TRUE;
				leftChannelIndex = 0;
				rightChannelIndex = 2;

				if (surroundDownmix)
					{
					leftMultiplier = (fftreal)(1./(1. + M3DB));
					rightMultiplier = (fftreal)(1./(1. + M3DB));
					if (blksw[0] == blksw[1])
						MixChannels(chcoeff[0], chcoeff[1], 256);
					else
						channelPremixed[1] = FALSE;
					if (chp && blksw[1] == blksw[2])
						MixChannels(chcoeff[2], chcoeff[1], 256);
					else
						channelPremixed[1] = FALSE;
					}
				else
					{
					cmix = cmixs[cmixlev];
					leftMultiplier = rightMultiplier = (fftreal)1./ ((fftreal)1. + cmix);

					if (chp && blksw[0] == blksw[1])
						FMixChannels(chcoeff[0], chcoeff[1], 256, cmix);
					else
						channelPremixed[1] = FALSE;

					if (chp && blksw[1] == blksw[2])
						FMixChannels(chcoeff[2], chcoeff[1], 256, cmix);
					else
						channelPremixed[1] = FALSE;
					}

	#if USE_SIMPLE_DOWNMIX
				leftMultiplier = rightMultiplier = 0.291703308;
	#endif
				break;
			case 4:
				leftChannelIndex = 0;
				rightChannelIndex = 1;

				if (surroundDownmix)
					{
					leftMultiplier = (fftreal)(1./(1. + M3DB));
					rightMultiplier = (fftreal)(1./(1. + M3DB));

					if (chp && blksw[0] == blksw[2] && blksw[1] == blksw[2])
						{
						IMixChannels(chcoeff[0], chcoeff[2], 256);
						MixChannels(chcoeff[1], chcoeff[2], 256);
						channelPremixed[2] = TRUE;
						}
					else
						channelPremixed[2] = FALSE;

					}
				else
					{
					smix = smixs[surmixlev] * (fftreal)M3DB;
					leftMultiplier = rightMultiplier = (fftreal)1./ ((fftreal)1. + smix);

					if (chp && blksw[0] == blksw[2] && blksw[1] == blksw[2])
						{
						FMixChannels(chcoeff[0], chcoeff[2], 256, smix);
						FMixChannels(chcoeff[1], chcoeff[2], 256, smix);
						channelPremixed[2] = TRUE;
						}
					else
						channelPremixed[2] = FALSE;
					}

	#if USE_SIMPLE_DOWNMIX
				leftMultiplier = rightMultiplier = 0.291703308;
	#endif
				break;
			case 5:
				leftChannelIndex = 0;
				rightChannelIndex = 2;

				if (surroundDownmix)
					{
					leftMultiplier = (fftreal)(1./(1. + 2 * M3DB));
					rightMultiplier = (fftreal)(1./(1. + 2 * M3DB));

					if (chp && blksw[0] == blksw[1] && blksw[2] == blksw[1])
						{
						MixChannels(chcoeff[0], chcoeff[1], 256);
						MixChannels(chcoeff[2], chcoeff[1], 256);
						channelPremixed[1] = TRUE;
						}
					else
						channelPremixed[1] = FALSE;

					if (chp && blksw[0] == blksw[3] && blksw[2] == blksw[3])
						{
						IMixChannels(chcoeff[0], chcoeff[3], 256);
						MixChannels(chcoeff[2], chcoeff[3], 256);
						channelPremixed[3] = TRUE;
						}
					else
						channelPremixed[3] = FALSE;
					}
				else
					{
					cmix = cmixs[cmixlev];
					smix = smixs[surmixlev] * (fftreal)M3DB;
					leftMultiplier = rightMultiplier = (fftreal)1./ ((fftreal)1. + cmix + smix);

					if (chp && blksw[0] == blksw[1] && blksw[1] == blksw[2])
						{
						FMixChannels(chcoeff[0], chcoeff[1], 256, cmix);
						FMixChannels(chcoeff[2], chcoeff[1], 256, cmix);
						channelPremixed[1] = TRUE;
						}
					else
						channelPremixed[1] = FALSE;

					if (chp && blksw[0] == blksw[3] && blksw[3] == blksw[2])
						{
						FMixChannels(chcoeff[0], chcoeff[3], 256, smix);
						FMixChannels(chcoeff[2], chcoeff[3], 256, smix);
						channelPremixed[3] = TRUE;
						}
					else
						channelPremixed[3] = FALSE;
					}

	#if USE_SIMPLE_DOWNMIX
				leftMultiplier = rightMultiplier = 0.291703308;
	#endif
				break;
			case 6:
				leftChannelIndex = 0;
				rightChannelIndex = 1;

				if (surroundDownmix)
					{
					leftMultiplier = (fftreal)(1./(1. + 2 * M3DB));
					rightMultiplier = (fftreal)(1./(1. + 2 * M3DB));

					if (chp && blksw[2] == blksw[3])
						{
						AddChannels(chcoeff[2], chcoeff[3], 256);
						channelPremixed[3] = TRUE;

						if (blksw[0] == blksw[2] && blksw[1] == blksw[2])
							{
							IMixChannels(chcoeff[0], chcoeff[2], 256);
							MixChannels(chcoeff[1], chcoeff[2], 256);
							channelPremixed[2] = TRUE;
							}
						else
							channelPremixed[2] = FALSE;
						}
					else
						{
						channelPremixed[2] = FALSE;
						channelPremixed[3] = FALSE;
						}

					}
				else
					{
					smix = smixs[surmixlev];
					leftMultiplier = rightMultiplier = (fftreal)1./ ((fftreal)1. + smix);

					if (chp && blksw[0] == blksw[2])
						{
						FMixChannels(chcoeff[0], chcoeff[2], 256, smix);
						channelPremixed[2] = TRUE;
						}
					else
						channelPremixed[2] = FALSE;

					if (chp && blksw[1] == blksw[3])
						{
						FMixChannels(chcoeff[1], chcoeff[3], 256, smix);
						channelPremixed[3] = TRUE;
						}
					else
						channelPremixed[3] = FALSE;

					}

	#if USE_SIMPLE_DOWNMIX
				leftMultiplier = rightMultiplier = 0.291703308;
	#endif
				break;
			case 7:
				channelPremixed[1] = TRUE;
				channelPremixed[3] = TRUE;
				channelPremixed[4] = TRUE;

				leftChannelIndex = 0;
				rightChannelIndex = 2;

				if (surroundDownmix)
					{
					leftMultiplier = (fftreal)(1./(1. + 3. * M3DB)); // / 1.09835964;
					rightMultiplier = (fftreal)(1./(1. + 3. * M3DB)); // / 1.09835964;

					if (chp && blksw[0] == blksw[1] &&
						 blksw[0] == blksw[2] &&
						 blksw[0] == blksw[3] &&
						 blksw[0] == blksw[4])
						{
						fftreal c, s;
						int i;
						for(i=0; i<256; i++)
							{
							c = chcoeff[1][i];
							s = chcoeff[3][i] + chcoeff[4][i];
							chcoeff[0][i] += (fftreal)M3DB * (c - s);
							chcoeff[2][i] += (fftreal)M3DB * (c + s);
							}
						}
					else
						{
						if (chp && blksw[0] == blksw[1])
							MixChannels(chcoeff[0], chcoeff[1], 256);
						else
							channelPremixed[1] = FALSE;

						if (chp && blksw[1] == blksw[2])
							MixChannels(chcoeff[2], chcoeff[1], 256);
						else
							channelPremixed[1] = FALSE;

						if (chp && blksw[3] == blksw[4])
							{
							AddChannels(chcoeff[3], chcoeff[4], 256);

							if (blksw[0] == blksw[3])
								IMixChannels(chcoeff[0], chcoeff[3], 256);
							else
								channelPremixed[3] = FALSE;

							if (blksw[2] == blksw[3])
								MixChannels(chcoeff[2], chcoeff[3], 256);
							else
								channelPremixed[3] = FALSE;
							}
						else
							{
							channelPremixed[3] = FALSE;
							channelPremixed[4] = FALSE;
							}
						}
					}
				else
					{
					cmix = cmixs[cmixlev];
					smix = smixs[surmixlev];
					leftMultiplier = rightMultiplier = (fftreal)1./ ((fftreal)1. + cmix + smix);

					if (chp && blksw[0] == blksw[1])
						FMixChannels(chcoeff[0], chcoeff[1], 256, cmix);
					else
						channelPremixed[1] = FALSE;

					if (chp && blksw[1] == blksw[2])
						FMixChannels(chcoeff[2], chcoeff[1], 256, cmix);
					else
						channelPremixed[1] = FALSE;

					if (chp && blksw[0] == blksw[3])
						FMixChannels(chcoeff[0], chcoeff[3], 256, smix);
					else
						channelPremixed[3] = FALSE;

					if (chp && blksw[2] == blksw[4])
						FMixChannels(chcoeff[2], chcoeff[4], 256, smix);
					else
						channelPremixed[4] = FALSE;
					}

	#if USE_SIMPLE_DOWNMIX
				leftMultiplier = rightMultiplier = 0.291703308;
	#endif
				break;
			}

		channelPremixed[leftChannelIndex] = FALSE;
		channelPremixed[rightChannelIndex] = FALSE;

		downmixActive = leftMultiplier < 1.0 && acmod > 2 ;

		if (acmod > 2)
			{
			leftMultiplier = 1.0;
			rightMultiplier = 1.0;
			}
		}
	}

fftreal AC3Decoder::CalcCompression(int cVal, int hscl, int lscl)
	{
	fftreal mul, dmul;

	dmul = NegativeUDB[dialnorm];

	if (cVal < 0)
		{
		cVal = (cVal * hscl) >> 8;
		mul = (fftreal)(0x1000 | (cVal & 0xfff)) / 0x2000;
		if (cVal < 0)
			mul /= (fftreal)(1 << (15 - ((WORD)cVal >> 12)));
		else
			mul *= (fftreal)(2 << (cVal >> 12));
		}
	else
		{
		cVal = (cVal * lscl) >> 8;
		mul = (fftreal)(0x1000 | (cVal & 0xfff)) / 0x2000;
		mul *= (fftreal)(2 << (cVal >> 12));
		}

	if (useDialNorm) mul *= dmul;

	return mul;
	}


void AC3Decoder::DynamicRangeCompression(void)
	{
	fftreal mul;

	if (dynrng || dialnorm != 31 && useDialNorm ||  compressionMode != COMP_MODE_LINE)
		{
		int iCompr = (short)(dynrng << 8) >> 1;
		int hscl = 256;
		int lscl = 256;

		switch (compressionMode)
			{
			case COMP_MODE_CUSTOM_A:
			case COMP_MODE_CUSTOM_B:
				// must apply scaling before -11db
				if (iCompr<0)
					iCompr = (iCompr * hdr) >> 8;
				else
					iCompr = (iCompr * ldr) >> 8;

				if (downmixActive || (bsmod == 7 && acmod >= 2))
					iCompr -= Plus11DBCompr;
				break;

			case COMP_MODE_LINE:
				lscl = ldr;
				if (!downmixActive)
					hscl = hdr;
				break;

			case COMP_MODE_RF:
				if (compre)
					{
					if (compr)
						iCompr = (short)(compr << 8);

					if (drc != AC3DYNRG_MINIMUM)
						iCompr += Plus11DBCompr;
					}
				else
					if (downmixActive || (bsmod == 7 && acmod >= 2))
						iCompr -= Plus11DBCompr;
				break;

			}

			mul = CalcCompression(iCompr, hscl, lscl);

#if DUMP_COMPRESSION
			{
			char buffer[100];
			wsprintf(buffer, "CE %d CP %2x DR %2x DN %2x M %d.%2d ", compre, compr, dynrng, dialnorm, (int)(mul), (int)(mul * 100) % 100);
			OutputDebugString(buffer);
			}
#endif

		leftMultiplier *= mul;
		rightMultiplier *= mul;
		}
	}


void AC3Decoder::PostDownmixChannels(void)
	{
	switch (acmod)
		{
		case 0:
			switch (dualMode)
				{
				case AC3DMDM_MIX:
					AddChannels(chpostfft[0], chpostfft[1], 512);
					memcpy(chpostfft[1], chpostfft[0], 512*sizeof(fftreal));
					break;
				default:
				case AC3DMDM_CHANNEL1:
				case AC3DMDM_CHANNEL2:
				case AC3DMDM_STEREO:
					break;
				}
			break;
		case 1:
		case 2:
			break;
		case 3:
			if (surroundDownmix)
				{
				if (blksw[0] != blksw[1] || !chp)
					MixChannels(chpostfft[0], chpostfft[1], 512);
				if (blksw[1] != blksw[2] || !chp)
					MixChannels(chpostfft[2], chpostfft[1], 512);
				}
			else
				{
				if (blksw[0] != blksw[1] || !chp)
					FMixChannels(chpostfft[0], chpostfft[1], 512, cmix);
				if (blksw[1] != blksw[2] || !chp)
					FMixChannels(chpostfft[2], chpostfft[1], 512, cmix);
				}
			break;
		case 4:
			if (surroundDownmix)
				{
				if (blksw[0] != blksw[2] || blksw[1] != blksw[2] || !chp)
					{
					IMixChannels(chpostfft[0], chpostfft[2], 512);
					MixChannels(chpostfft[1], chpostfft[2], 512);
					}
				}
			else
				{
				if (blksw[0] != blksw[2] || blksw[1] != blksw[2] || !chp)
					{
					FMixChannels(chpostfft[0], chpostfft[2], 512, smix);
					FMixChannels(chpostfft[1], chpostfft[2], 512, smix);
					}
				}
			break;
		case 5:
			if (surroundDownmix)
				{
				if (blksw[0] != blksw[1] || blksw[2] != blksw[1] || !chp)
					{
					MixChannels(chpostfft[0], chpostfft[1], 512);
					MixChannels(chpostfft[2], chpostfft[1], 512);
					}

				if (blksw[0] != blksw[3] || blksw[2] != blksw[3] || !chp)
					{
					IMixChannels(chpostfft[0], chpostfft[3], 512);
					MixChannels(chpostfft[2], chpostfft[3], 512);
					}
				}
			else
				{
				if (blksw[0] != blksw[1] || blksw[1] != blksw[2] || !chp)
					{
					FMixChannels(chpostfft[0], chpostfft[1], 512, cmix);
					FMixChannels(chpostfft[2], chpostfft[1], 512, cmix);
					}

				if (blksw[0] != blksw[3] || blksw[3] != blksw[2] || !chp)
					{
					FMixChannels(chpostfft[0], chpostfft[3], 512, smix);
					FMixChannels(chpostfft[2], chpostfft[3], 512, smix);
					}
				}
			break;
		case 6:
			if (surroundDownmix)
				{
				if (blksw[2] != blksw[3] || !chp)
					{
					AddChannels(chpostfft[2], chpostfft[3], 512);
					}

				if (blksw[0] != blksw[2] || blksw[1] != blksw[2] || !chp)
					{
					IMixChannels(chpostfft[0], chpostfft[2], 512);
					MixChannels(chpostfft[1], chpostfft[2], 512);
					}
				}
			else
				{
				if (blksw[0] != blksw[2] || !chp)
					{
					FMixChannels(chpostfft[0], chpostfft[2], 512, smix);
					}

				if (blksw[1] != blksw[3] || !chp)
					{
					FMixChannels(chpostfft[1], chpostfft[3], 512, smix);
					}
				}
			break;
		case 7:
			if (surroundDownmix)
				{
				if (!chp || blksw[0] != blksw[1] || !chp)
					MixChannels(chpostfft[0], chpostfft[1], 512);

				if (!chp || blksw[1] != blksw[2] || !chp)
					MixChannels(chpostfft[2], chpostfft[1], 512);

				if (!chp || blksw[3] != blksw[4] || !chp)
					{
					AddChannels(chpostfft[3], chpostfft[4], 512);
					IMixChannels(chpostfft[0], chpostfft[3], 512);
					MixChannels(chpostfft[2], chpostfft[3], 512);
					}
				else
					{
					if (blksw[0] != blksw[3] || !chp)
						IMixChannels(chpostfft[0], chpostfft[3], 512);

					if (blksw[2] != blksw[3] || !chp)
						MixChannels(chpostfft[2], chpostfft[3], 512);
					}
				}
			else
				{
				if (!chp || blksw[0] != blksw[1] || !chp)
					FMixChannels(chpostfft[0], chpostfft[1], 512, cmix);

				if (!chp || blksw[1] != blksw[2] || !chp)
					FMixChannels(chpostfft[2], chpostfft[1], 512, cmix);

				if (!chp || blksw[0] != blksw[3] || !chp)
					FMixChannels(chpostfft[0], chpostfft[3], 512, smix);

				if (!chp || blksw[2] != blksw[4] || !chp)
					FMixChannels(chpostfft[2], chpostfft[4], 512, smix);
				}
			break;
		}
	if (lfeon && enableLFE)
		{
		FMixChannels(chpostfft[0], lfepostfft, 512, (fftreal)3.16);
		FMixChannels(chpostfft[2], lfepostfft, 512, (fftreal)3.16);
		}
	}



static inline int ScaleToInt(fftreal val, fftreal smul)
	{
	int tmp;
	fftreal ftmp = (fftreal)((val * smul) + 0.5);

	if (ftmp < -32767.0) tmp = -32768;
	else if (ftmp > 32768.0) tmp = 32768;
	else
		{
		tmp = (int)ftmp;
		if ((fftreal)tmp > ftmp) tmp--;
		}

	if (tmp < -32768)
		return -32768;
	else if (tmp > 32767)
		return 32767;
	else
		return tmp;
	}


void AC3Decoder::InitWindow(void)
	{
	int i;

	// added scaling from fftreal to word into window (*32768.0)
	for(i=0; i<256; i++)
		{
		ac3WindowTable2[i] = (fftreal) (2.0 * AC3WindowTable[i] * 32768.0);
		ac3WindowTable2[511-i] = (fftreal) (2.0 * AC3WindowTable[i] * 32768.0);
		}
	}

void AC3Decoder::WindowChannels(short * leftRightBuffer)
	{
	fftreal lm, rm;

	lm = leftMultiplier;
	rm = rightMultiplier;


#if USE_SIMD_WINDOWING
	fftreal * op = &(overlap[0][0]);
	fftreal * lp = &(chpostfft[leftChannelIndex][0]);
	fftreal * rp = &(chpostfft[rightChannelIndex][0]);
	fftreal * wp = &(ac3WindowTable2[0]);
	short * lrp = leftRightBuffer;

	_asm
		{
		mov	esi, [lp]
		mov	edi, [rp]
		mov	edx, [lrp]
		mov	ebx, [wp]
		mov	ecx, [op]
		mov	eax, -256

		movss		xmm7, [lm]
		movss		xmm6, [rm]
		shufps		xmm7, xmm7, 00000000b				// lm, lm		lm, lm
		shufps		xmm6, xmm6, 00000000b				// rm, rm		rm, rm

loop1:
		movaps		xmm0, [esi + eax*4 + 4*256]			// chpostfft[leftChannelIndex][0,1,2,3
		movaps		xmm1, [edi + eax*4 + 4*256]			// chpostfft[rightChannelIndex][0....
		mulps		xmm0, xmm7							// leftIndex][0...] * lm
		movaps		xmm4, [ebx + eax*4 + 4*256]			// ac3WindowTable2[0]
		mulps		xmm1, xmm6							// rightIndex][0...] * rm

		mulps		xmm0, xmm4							// ac3WindowTable2[0] * leftIndex[0]*lm
		mulps		xmm1, xmm4							// ac3WindowTable2[0] * rightIndex[0]*lm

		addps		xmm0, [ecx + eax*4 + 4*256]			// overlap[0][0] + ac3WindowTable2[0] * leftIndex[0]*lm
		addps		xmm1, [ecx + eax*4 + 4*256 + 4*256] // overlap[1][0] + ac3WindowTable2[0] * rightIndex[0]*lm

		movaps		xmm2, [esi + eax*4 + 4*256 + 4*256] // chpostfft[leftChannelIndex][256,,,,
		movaps		xmm3, [edi + eax*4 + 4*256 + 4*256] // chpostfft[rightChannelIndex][256,,,,
		mulps		xmm2, xmm7							// leftIndex][256] * lm
		movaps		xmm4, [ebx + eax*4 + 4*256 + 4*256]	// ac3WindowTable2[256]
		mulps		xmm3, xmm6							// rightIndex][256] * rm

		mulps		xmm2, xmm4							// ac3WindowTable2[256] * leftIndex][256] * lm
		mulps		xmm3, xmm4							// ac3WindowTable2[256] * leftIndex][256] * lm

		movaps		[ecx + eax*4 + 4*256], xmm2			// save  overlap[0][0]
		movaps		[ecx + eax*4 + 4*256 + 4*256], xmm3	// save  overlap[1][0]

		movaps		xmm3, xmm0							// l3, l2, l1, l0
		unpcklps	xmm0, xmm1							// r1, l1, r0, l0
		unpckhps	xmm3, xmm1							// r3, l3, r2, l2

		cvtps2pi	mm0, xmm0							// r0		l0
		shufps		xmm0, xmm0, 00001110b				// xx,xx	r1, l1
		cvtps2pi	mm2, xmm3							// r2		l2
		shufps		xmm3, xmm3, 00001110b				// xx,xx	r3, l3
		cvtps2pi	mm1, xmm0							// r1		l1
		cvtps2pi	mm3, xmm3							// r3		l3

		add			eax, 4
		packssdw	mm0, mm1							// r1, l1, r0 , l0
		packssdw	mm2, mm3							// r3, l3, r2 , l2

		movq		[edx + eax*4 + 0 - 4*4 + 4*256], mm0// save l0, r0, l1, r1
		movq		[edx + eax*4 + 8 - 4*4 + 4*256], mm2// save l2, r2, l3, r3

		jl			loop1
		emms
		}

#else
	int i;

	for(i=0; i<256; i++)
		{
		leftRightBuffer[2*i+0] =(short) ScaleToInt(chpostfft[leftChannelIndex][i] *  ac3WindowTable2[i] * lm + overlap[0][i], 1.0);
		leftRightBuffer[2*i+1] =(short) ScaleToInt(chpostfft[rightChannelIndex][i] *  ac3WindowTable2[i] * rm + overlap[1][i], 1.0);
		overlap[0][i] = chpostfft[leftChannelIndex][256+i] * ac3WindowTable2[256+i] * lm;
		overlap[1][i] = chpostfft[rightChannelIndex][256+i] * ac3WindowTable2[256+i] * rm;
		}

#endif
	}


void AC3Decoder::UncoupleChannel(int ch)
	{
	int bnd, sbnd, bin;
	fftreal temp;

	if (cplinu)
		{
		if (chincpl[ch])
			{
			for(sbnd = cplbegf; sbnd < 3 + cplendf; sbnd++)
				{
				for(bin = 0; bin < 12; bin++)
					{
					if (dithflag[ch] && cplbap[sbnd * 12 + bin + 37] == 0)
						{
						chcoeff[ch][sbnd * 12 + bin + 37] = GetDitheredMantissa(cplexps[sbnd * 12 + bin + 37]) * cplco[ch][sbnd] * 8;
						}
					else
						{
						chcoeff[ch][sbnd * 12 + bin + 37] = cplcoeff[sbnd * 12 + bin + 37] * cplco[ch][sbnd] * 8;
						}
					}
				}
			}
		}
	}

static void RematrixBand(int start, int end, fftreal * ch0, fftreal * ch1)
	{
	int i;
	fftreal a0, a1;

	for(i=start; i<end; i++)
		{
		a0 = ch0[i] + ch1[i];
		a1 = ch0[i] - ch1[i];
		ch0[i] = a0; ch1[i] = a1;
		}
	}



void AC3Decoder::RematrixChannels(void)
{
	int maxbnd;

	if (acmod == 0x02)
	{
		if (!cplinu)
			{
			maxbnd = min(endmant[0], endmant[1]);
			if (rematflg[0]) RematrixBand(13, min( 25, maxbnd), chcoeff[0],chcoeff[1]);
			if (rematflg[1]) RematrixBand(25, min( 37, maxbnd), chcoeff[0],chcoeff[1]);
			if (rematflg[2]) RematrixBand(37, min( 61, maxbnd), chcoeff[0],chcoeff[1]);
			if (rematflg[3]) RematrixBand(61, min(253, maxbnd), chcoeff[0],chcoeff[1]);
			}
		else if (cplbegf > 2)
			{
			if (rematflg[0]) RematrixBand(13,  25, chcoeff[0], chcoeff[1]);
			if (rematflg[1]) RematrixBand(25,  37, chcoeff[0], chcoeff[1]);
			if (rematflg[2]) RematrixBand(37,  61, chcoeff[0], chcoeff[1]);
			if (rematflg[3]) RematrixBand(61, 37 + cplbegf * 12, chcoeff[0], chcoeff[1]);
			}
		else if (cplbegf > 0)
			{
			if (rematflg[0]) RematrixBand(13,  25, chcoeff[0], chcoeff[1]);
			if (rematflg[1]) RematrixBand(25,  37, chcoeff[0], chcoeff[1]);
			if (rematflg[2]) RematrixBand(37, 37 + cplbegf * 12, chcoeff[0], chcoeff[1]);
			}
		else
			{
			if (rematflg[0]) RematrixBand(13,  25, chcoeff[0], chcoeff[1]);
			if (rematflg[1]) RematrixBand(25,  37, chcoeff[0], chcoeff[1]);
			}
		}
	}


void AC3Decoder::InitParseMantissa(void)
	{
	mant1Num = mant2Num = mant4Num = 0;
	}



#define		DITHMULT	47989

inline fftreal AC3Decoder::GetDitherValue(void)
	{
#if USE_DITHERING
	int rnd0;

	dithReg = (short)((DITHMULT * dithReg) & 0xffff);
	rnd0 = dithReg;

#if USE_TRIANGLE_DITHER
	dithReg = (short)((DITHMULT * dithReg) & 0xffff);
	rnd0 = ((rnd0 + dithReg)/2);
#endif

#if DUMP_FFT_DATA
	fprintf(dfile, "Dither %f\n", (double)((fftreal)rnd0 * (fftreal)M3DB/32768.0));
#endif

	return ((fftreal)(rnd0<<16) * (fftreal)M3DB);

#else
	return 0.;
#endif //USE_DITHERING
	}

inline fftreal AC3Decoder::GetDitheredMantissa(int exp)
	{
	return ShiftFP(GetDitherValue(), 31+exp);
	}


inline fftreal AC3Decoder::GetMantissa(int size, int exp, bool dither)
	{
	int val, bits;
	static int rnd0, rnd1, rnd2;

#pragma warning(disable : 4244 4305)
	static int bittab[]   = {0, 0, 0, 3,  0,  4,  5,  6,   7,   8,   9,   10,   11,   12,    14,    16};
	static fftreal valtab3[] = {-6./7., -4./7., -2./7., 0., 2./7., 4./7., 6./7.};
	static fftreal valtab5[] = {-14./15., -12./15., -10./15., -8./15., -6./15., -4./15., -2./15., 0.,
		                         2./15., 4./15., 6./15., 8./15., 10./15., 12./15., 14./15.};
	switch (size)
		{
		case 0:
			if (dither)
				return GetDitheredMantissa(exp);
			else
				return 0;
			break;
		case 1:
			if (!mant1Num)
				{
				val = strm->Get5Bits();
				mant1Val[0] = mant1lt[val][0];
				mant1Val[1] = mant1lt[val][1];
				mant1Val[2] = mant1lt[val][2];

				mant1Num = 2;

				return ShiftFP(mant1Val[0], exp);
				}
			else
				{
				mant1Num--;
				return ShiftFP(mant1Val[2 - mant1Num], exp);
				}
			break;
		case 2:
			if (!mant2Num)
				{
				val = strm->Get7Bits();
				mant2Val[0] = mant2lt[val][0];
				mant2Val[1] = mant2lt[val][1];
				mant2Val[2] = mant2lt[val][2];

				mant2Num = 2;

				return ShiftFP(mant2Val[0], exp);
				}
			else
				{
				mant2Num--;
				return ShiftFP(mant2Val[2 - mant2Num], exp);
				}
			break;
		case 3:
			val = strm->Get3Bits();
			return ShiftFP(valtab3[val], exp);
			break;
		case 4:
			if (!mant4Num)
				{
				val = strm->Get7Bits();
				mant4Val[0] = mant4lt[val][0];
				mant4Val[1] = mant4lt[val][1];

				mant4Num = 1;

				return ShiftFP(mant4Val[0], exp);
				}
			else
				{
				mant4Num = 0;

				return ShiftFP(mant4Val[1], exp);
				}
			break;
		case 5:
			val = strm->Get4Bits();
			return ShiftFP(valtab5[val], exp);
			break;
		default:
			bits = bittab[size];
			val = strm->GetHBits(bits);

			return ShiftFP((fftreal)val, 31+exp);
		}
	}

void AC3Decoder::GetMantissas(int num, fftreal * dst, BYTE * bap, BYTE * exps, bool dither)
	{
	int i;

#if DUMP_FFT_DATA
	fprintf(dfile, "At Get Mantissa %08x\n", (int)(strm->CurrentLocation()));
	for(i=0; i<num; i++)
		fprintf(dfile, "%3d : BA %x EX %d\n", i, bap[i], exps[i]);
	fprintf(dfile, "\n");
#endif

	for(i=0; i<num; i++)
		dst[i] = GetMantissa(bap[i], exps[i], dither);
	}



static inline int logadd(int a, int b)
	{
	static BYTE latab[] = {0x40, 0x3f, 0x3e, 0x3d, 0x3c, 0x3b, 0x3a, 0x39, 0x38, 0x37,
		                    0x36, 0x35, 0x34, 0x34, 0x33, 0x32, 0x31, 0x30, 0x2f, 0x2f,
								  0x2e, 0x2d, 0x2c, 0x2c, 0x2b, 0x2a, 0x29, 0x29, 0x28, 0x27,
								  0x26, 0x26, 0x25, 0x24, 0x24, 0x23, 0x23, 0x22, 0x21, 0x21,
								  0x20, 0x20, 0x1f, 0x1e, 0x1e, 0x1d, 0x1d, 0x1c, 0x1c, 0x1b,
								  0x1b, 0x1a, 0x1a, 0x19, 0x19, 0x18, 0x18, 0x17, 0x17, 0x16,
								  0x16, 0x15, 0x15, 0x15, 0x14, 0x14, 0x13, 0x13, 0x13, 0x12,
								  0x12, 0x12, 0x11, 0x11, 0x11, 0x10, 0x10, 0x10, 0x0f, 0x0f,
								  0x0f, 0x0e, 0x0e, 0x0e, 0x0d, 0x0d, 0x0d, 0x0d, 0x0c, 0x0c,
								  0x0c, 0x0c, 0x0b, 0x0b, 0x0b, 0x0b, 0x0a, 0x0a, 0x0a, 0x0a,
								  0x0a, 0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x08, 0x08, 0x08,
								  0x08, 0x08, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x06, 0x06,
								  0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x05, 0x05, 0x05, 0x05,
								  0x05, 0x05, 0x05, 0x05, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
								  0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03,
								  0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02,
								  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
								  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01,
								  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
								  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
								  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
								  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
								  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
								  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
								  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
								  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

	int c;

	if (a >= b)
		{
		c = (a - b) >> 1;
		if (c > 255) c = 255;

		return a + latab[c];
		}
	else
		{
		c = (b - a) >> 1;
		if (c > 255) c = 255;

		return b + latab[c];
		}
	}

#define SUBS(x, y) ((x) > (y) ? (x) - (y) : 0)

static inline int calc_lowcomp(int a, int b0, int b1, int bin)
	{
	if (bin < 7)
		{
		if ((b0 + 256) == b1)
			a = 384;
		else if (b0 > b1)
			a = SUBS(a, 64);
		}
	else if (bin < 20)
		{
		if ((b0 + 256) == b1)
			a = 320;
		else if (b0 > b1)
			a = SUBS(a, 64);
		}
	else
		{
		a = SUBS(a, 128);
		}

	return a;
	}

void AC3Decoder::CalculateBitAllocation(
										int start,
										int end,
										int fgaincod,
										int fsnroffst,
										BYTE * exp,
										int fastleak,
										int slowleak,
										BYTE deltbae,
										WORD deltnseg,
										BYTE * deltoffst,
										BYTE * deltba,
										BYTE * deltlen,
										BYTE * bap,
										bool lfe)
	{
	static BYTE slowdec[] = {0x0f, 0x11, 0x13, 0x15};
	static BYTE fastdec[] = {0x3f, 0x53, 0x67, 0x7b};
	static WORD slowgain[] = {0x540, 0x4d8, 0x478, 0x410};
	static WORD dbpbtab[] = {0x000, 0x700, 0x900, 0xb00};
	static short floortab[] = {0x2f0, 0x2b0, 0x270, 0x230, 0x1f0, 0x170, 0x0f0, (short)0xf800};
	static WORD fastgain[] = {0x080, 0x100, 0x180, 0x200, 0x280, 0x300, 0x380, 0x400};
	static BYTE bndtab[] = {   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
									  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
									  20,  21,  22,  23,  24,  25,  26,  27,  28,  31,
									  34,  37,  40,  43,  46,  49,  55,  61,  67,  73,
									  79,  85,  97, 109, 121, 133, 157, 181, 205, 229, 255};
	static BYTE bndsz[]  = {   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
		                        1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
										1,   1,   1,   1,   1,   1,   1,   1,   3,   3,
										3,   3,   3,   3,   3,   6,   6,   6,   6,   6,
										6,  12,  12,  12,  12,  24,  24,  24,  24,  24, 0};
	static BYTE masktab[] = {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
		                       10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
									  20, 21, 22, 23, 24, 25, 26, 27, 28, 28,
									  28, 29, 29, 29, 30, 30, 30, 31, 31, 31,
									  32, 32, 32, 33, 33, 33, 34, 34, 34, 35,
									  35, 35, 35, 35, 35, 36, 36, 36, 36, 36,
									  36, 37, 37, 37, 37, 37, 37, 38, 38, 38,
									  38, 38, 38, 39, 39, 39, 39, 39, 39, 40,
									  40, 40, 40, 40, 40, 41, 41, 41, 41, 41,
									  41, 41, 41, 41, 41, 41, 41, 42, 42, 42,
									  42, 42, 42, 42, 42, 42, 42, 42, 42, 43,
									  43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
									  43, 44, 44, 44, 44, 44, 44, 44, 44, 44,
									  44, 44, 44, 45, 45, 45, 45, 45, 45, 45,
									  45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
									  45, 45, 45, 45, 45, 45, 45, 46, 46, 46,
									  46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
									  46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
									  46, 47, 47, 47, 47, 47, 47, 47, 47, 47,
									  47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
									  47, 47, 47, 47, 47, 48, 48, 48, 48, 48,
									  48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
									  48, 48, 48, 48, 48, 48, 48, 48, 48, 49,
									  49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
									  49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
									  49, 49, 49,  0,  0,  0};
	static WORD hth[3][50] = {{0x4d0, 0x4d0, 0x440, 0x400, 0x3e0, 0x3c0, 0x3b0, 0x3b0, 0x3a0, 0x3a0,
		                        0x3a0, 0x3a0, 0x3a0, 0x390, 0x390, 0x390, 0x380, 0x380, 0x370, 0x370,
										0x360, 0x360, 0x350, 0x350, 0x340, 0x340, 0x330, 0x320, 0x310, 0x300,
										0x2f0, 0x2f0, 0x2f0, 0x2f0, 0x300, 0x310, 0x340, 0x390, 0x3e0, 0x420,
										0x460, 0x490, 0x4a0, 0x460, 0x440, 0x440, 0x520, 0x800, 0x840, 0x840},
		                       {0x4f0, 0x4f0, 0x460, 0x410, 0x3e0, 0x3d0, 0x3c0, 0x3b0, 0x3b0, 0x3a0,
									   0x3a0, 0x3a0, 0x3a0, 0x3a0, 0x390, 0x390, 0x390, 0x380, 0x380, 0x380,
										0x370, 0x370, 0x360, 0x360, 0x350, 0x350, 0x340, 0x340, 0x320, 0x310,
										0x300, 0x2f0, 0x2f0, 0x2f0, 0x2f0, 0x300, 0x320, 0x350, 0x390, 0x3e0,
										0x420, 0x450, 0x4a0, 0x490, 0x460, 0x440, 0x480, 0x630, 0x840, 0x840},
		                       {0x580, 0x580, 0x4b0, 0x450, 0x420, 0x3f0, 0x3e0, 0x3d0, 0x3c0, 0x3b0,
									   0x3b0, 0x3b0, 0x3a0, 0x3a0, 0x3a0, 0x3a0, 0x3a0, 0x3a0, 0x3a0, 0x3a0,
										0x390, 0x390, 0x390, 0x390, 0x380, 0x380, 0x380, 0x370, 0x360, 0x350,
										0x340, 0x330, 0x320, 0x310, 0x300, 0x2f0, 0x2f0, 0x2f0, 0x300, 0x310,
										0x330, 0x350, 0x3c0, 0x410, 0x470, 0x4a0, 0x460, 0x440, 0x450, 0x4e0}};
	static BYTE baptab[] = { 0,  1,  1,  1,  1,  1,  2,  2,  3,  3,
		                      3,  4,  4,  5,  5,  6,  6,  6,  6,  7,
									 7,  7,  7,  8,  8,  8,  8,  9,  9,  9,
									 9, 10, 10, 10, 10, 11, 11, 11, 11, 12,
									12, 12, 12, 13, 13, 13, 13, 14, 14, 14,
									14, 14, 14, 14, 14, 15, 15, 15, 15, 15,
									15, 15, 15, 15};

	int sdecay = slowdec[sdcycod];
	int fdecay = fastdec[fdcycod];
	int sgain = slowgain[sgaincod];
	int dbknee = dbpbtab[dbpbcod];
	int floor = floortab[floorcod];

	int fgain = fastgain[fgaincod];
	int lowcomp = 0;

	int snroffset = (((csnroffst - 15) << 4) + fsnroffst) << 2;

	int psd[256], bndpsd[256], excite[256], mask[256];

	int bin, i, j, k, n, t;
	int bndstrt, bndend, begin;

	for(bin = start; bin < end; bin++)
		{
		psd[bin] = 3072 - (exp[bin] << 7);
		}

	j = start;
	k = masktab[start];
	do {
		bndpsd[k] = psd[j];
		j++;
		n = min(bndtab[k+1], end);
		for(i = j; i < n; i++)
			{
			bndpsd[k] = logadd(bndpsd[k], psd[j]);
			j++;
			}
		k++;
		} while (end > bndtab[k]);

	bndstrt = masktab[start];
	bndend = masktab[end-1] + 1;
	if (bndstrt == 0)
		{
		lowcomp = calc_lowcomp(lowcomp, bndpsd[0], bndpsd[1], 0);
		excite[0] = bndpsd[0] - fgain - lowcomp;
		lowcomp = calc_lowcomp(lowcomp, bndpsd[1], bndpsd[2], 1);
		excite[1] = bndpsd[1] - fgain - lowcomp;
		begin = 7;
		for(bin = 2; bin < 7; bin++)
			{
			if (bin < 6 || !lfe)
				lowcomp = calc_lowcomp(lowcomp, bndpsd[bin], bndpsd[bin+1], bin);
			fastleak = bndpsd[bin] - fgain;
			slowleak = bndpsd[bin] - sgain;
			excite[bin] = fastleak - lowcomp;
			if (bin < 6 && bndpsd[bin] <= bndpsd[bin+1])
				{
				begin = bin + 1;
				break;
				}
			}
		n = min(bndend, 22);
		for(bin = begin; bin < n; bin++)
			{
			if (bin < 6 || !lfe)
				lowcomp = calc_lowcomp(lowcomp, bndpsd[bin], bndpsd[bin+1], bin);
			fastleak -= fdecay;
			fastleak = max(fastleak, bndpsd[bin] - fgain);
			slowleak -= sdecay;
			slowleak = max(slowleak, bndpsd[bin] - sgain);
			excite[bin] = max(fastleak - lowcomp, slowleak);
			}
		begin = 22;
		}
	else
		{
		begin = bndstrt;
		}

	for(bin = begin; bin < bndend; bin++)
		{
		fastleak -= fdecay;
		fastleak = max(fastleak, bndpsd[bin] - fgain);
		slowleak -= sdecay;
		slowleak = max(slowleak, bndpsd[bin] - sgain);
		excite[bin] = max(fastleak, slowleak);
		}

	for(bin = bndstrt; bin < bndend; bin++)
		{
#if DUMP_FFT_DATA
		fprintf(dfile, "Excite %3d %04x\n", bin, excite[bin]);
#endif
		if (bndpsd[bin] < dbknee)
			{
			excite[bin] += (dbknee - bndpsd[bin]) >> 2;
			}
		mask[bin] = max(excite[bin], hth[fscod][bin]);
		}

	int delta, seg;
	WORD band;

	if (deltbae == 0 || deltbae == 1)
		{
		band = masktab[start];
		for(seg = 0; seg < deltnseg; seg++)
			{
			band += deltoffst[seg];
			if (deltba[seg] >= 4)
				delta = ((int)deltba[seg] - 3) << 7;
			else
				delta = ((int)deltba[seg] - 4) << 7;
			n = deltlen[seg];
#if DUMP_FFT_DATA
			fprintf(dfile, "Deltba Deltoffst %d Band %d Len %d Delta %d Deltba %d\n", deltoffst[seg], band, n, delta, deltba[seg]);
#endif
			for(k = 0; k < n; k++)
				{
#if DUMP_FFT_DATA
			fprintf(dfile, "at %d mask %04x", band, (int)(mask[band]));
#endif
				mask[band] += delta;
#if DUMP_FFT_DATA
			fprintf(dfile, " to %04x\n", (int)(mask[band]));
#endif
				band++;
				}
			}
		}

	int address;

	i = start;
	j = masktab[start];
	do {
		t = mask[j];
		t -= snroffset;
		t -= floor;
		if (t < 0) t = 0;
		t &= 0x1fe0;
		t += floor;

		if (nosnroffst) t = 0x1fe0;

#if DUMP_FFT_DATA
		fprintf(dfile, "Mask %3d %04x\n", j, t);
#endif
		n = bndtab[j] + bndsz[j];
		if (n > end) n = end;
		for(k= i; k < n; k++)
			{
			address = (psd[i] - t) >> 5;
			if (address < 0)
				bap[i] = baptab[0];
			else if (address > 63)
				bap[i] = baptab[63];
			else
				bap[i] = baptab[address];

			i++;
			}
		j++;
		} while (end > n);
	}

bool AC3Decoder::UnpackExponents(int ngrps, BYTE * gexp, BYTE expstr, BYTE absexp, BYTE * exp)
	{
	int grp, i, j, grpsize;
	BYTE expacc;
	BYTE prevexp, prevexp1, prevexp2;

	grpsize = 1 << (expstr - 1);
	prevexp = absexp;
	exp[0] = absexp;
	i = 0;
	for(grp = 0; grp < ngrps; grp++)
		{
		expacc = gexp[grp];
		prevexp1 = prevexp  + exp5lt[expacc][0];
		prevexp2 = prevexp1 + exp5lt[expacc][1];
		prevexp  = prevexp2 + exp5lt[expacc][2];

#if BITSTREAM_CHECK
		if ((prevexp1 | prevexp2 | prevexp) & ~31)
			{
#if DUMP_ERRORS
			OutputDebugString("UnpackExponent failed\n");
#endif
					//
			return FALSE;
			}
#endif

		for(j = 1; j <= grpsize; j++)
			{
			exp[i +               j] = prevexp1;
			exp[i +     grpsize + j] = prevexp2;
			exp[i + 2 * grpsize + j] = prevexp;
			}
		i += 3 * grpsize;
		}

	return TRUE;
	}

bool AC3Decoder::ParseSyncInfo(void)
	{
	int newFrameSize;

	static int frameSizes[4][40] = {

		{  64 * 16,   64 * 16,   80 * 16,   80 * 16,	  96 * 16,   96 * 16,  112 * 16,  112 * 16,
		  128 * 16,  128 * 16,  160 * 16,  160 * 16,	 192 * 16,  192 * 16,  224 * 16,  224 * 16,
		  256 * 16,  256 * 16,  320 * 16,  320 * 16,	 384 * 16,  384 * 16,  448 * 16,  448 * 16,
		  512 * 16,  512 * 16,  640 * 16,  640 * 16,  768 * 16,  768 * 16,  896 * 16,  896 * 16,
		 1024 * 16, 1024 * 16, 1152 * 16, 1152 * 16, 1280 * 16, 1280 * 16,         0,         0},

		{  69 * 16,   70 * 16,   87 * 16,   88 * 16,  104 * 16,  105 * 16,  121 * 16,  122 * 16,
		  139 * 16,  140 * 16,  174 * 16,  175 * 16,  208 * 16,  209 * 16,  243 * 16,  244 * 16,
		  278 * 16,  279 * 16,  348 * 16,  349 * 16,  417 * 16,  418 * 16,  487 * 16,  488 * 16,
		  557 * 16,  558 * 16,  696 * 16,  697 * 16,  835 * 16,  836 * 16,  975 * 16,  976 * 16,
       1114 * 16, 1115 * 16, 1253 * 16, 1254 * 16, 1393 * 16, 1394 * 16,         0,         0},

		{  96 * 16,   96 * 16,  120 * 16,  120 * 16,  144 * 16,  144 * 16,  168 * 16,  168 * 16,
		  192 * 16,  192 * 16,  240 * 16,  240 * 16,  288 * 16,  288 * 16,  336 * 16,  336 * 16,
		  384 * 16,  384 * 16,  480 * 16,  480 * 16,  576 * 16,  576 * 16,  672 * 16,  672 * 16,
		  768 * 16,  768 * 16,  960 * 16,  960 * 16, 1152 * 16, 1152 * 16, 1344 * 16, 1344 * 16,
       1536 * 16, 1536 * 16, 1728 * 16, 1728 * 16, 1920 * 16, 1920 * 16,         0,         0}

		};

	strm->ByteAllign();
	if (!strm->RefillBuffer(64 * 16)) return FALSE;

	while (strm->AvailBits() >= 64 * 16 && (syncword = (WORD)(strm->PeekBits(16))) != 0x0b77)
		{
		strm->Advance(8);
		if (!strm->RefillBuffer(64 * 16)) return FALSE;
		}

	frameStart = strm->CurrentLocation();

	if (syncword != 0x0b77)
		{
		strm->Advance(strm->AvailBits());

		return FALSE;
		}

	strm->Advance(16);

	crc1 = (WORD)(strm->GetBits(16));
#if DUMP_FFT_DATA
	fprintf(dfile, "CRC1 : %04x\n", crc1);
#endif
	fscod = (BYTE)(strm->GetBits(2));
	frmsizecod = (BYTE)(strm->GetBits(6));

	frmsizecod = min(39, frmsizecod);
	newFrameSize = frameSizes[fscod][frmsizecod];
	if (!newFrameSize) return FALSE;

	if (!strm->RefillBuffer(newFrameSize - 40)) return FALSE;

	if (newFrameSize - 40 <= strm->AvailBits())
		{
		frameSize = newFrameSize;

		return TRUE;
		}
	else
		{
		return FALSE;
		}
	}

bool AC3Decoder::ParseBSI(void)
	{
	static BYTE NFCHANS[] = {2, 1, 2, 3, 3, 4, 4, 5};

	bsid = (BYTE)(strm->GetBits(5));
	if (bsid > 8)
		return FALSE;
	bsmod = (BYTE)(strm->GetBits(3));
	acmod = (BYTE)(strm->GetBits(3));

	nfchans = NFCHANS[acmod];

	if ((acmod & 0x1) && (acmod != 0x1)) cmixlev = (BYTE)(strm->GetBits(2));
	if (acmod & 0x4) surmixlev = (BYTE)(strm->GetBits(2));
	if (acmod == 0x02) dsurmod = (BYTE)(strm->GetBits(2));

	lfeon = strm->GetBool();
	dialnorm = (BYTE)(strm->GetBits(5));
	if (dialnorm == 0) dialnorm = 31;
	compre = strm->GetBool();
	if (compre) compr = (BYTE)(strm->GetBits(8));
	langcode = strm->GetBool();
	if (langcode) langcod = (BYTE)(strm->GetBits(8));
	audprodie = strm->GetBool();
	if (audprodie)
		{
		mixlevel = (BYTE)(strm->GetBits(5));
		roomtyp = (BYTE)(strm->GetBits(2));
		}

	if (acmod == 0)
		{
		dialnorm2 = (BYTE)(strm->GetBits(5));
		if (dialnorm != dialnorm2)
			DP("dialnorm %d != dialnorm2 %d", dialnorm, dialnorm2);
		compr2e = strm->GetBool();
		if (compre != compr2e)
			DP("compre %d != compr2e %d", compre, compr2e);
		if (compr2e)
			{
			compr2 = (BYTE)(strm->GetBits(8));
			if (compr != compr2)
				DP("compr %d != compr2 %d", compr, compr2);
			}

		lngcod2e = strm->GetBool();
		if (lngcod2e) langcod2 = (BYTE)(strm->GetBits(8));
		audprodi2e = strm->GetBool();
		if (audprodi2e)
			{
			mixlevel2 = (BYTE)(strm->GetBits(5));
			roomtyp2 = (BYTE)(strm->GetBits(2));
			}
		}

	copyrightb = strm->GetBool();
	origbs = strm->GetBool();
	timecod1e = strm->GetBool();
	if (timecod1e) timecod1 = (WORD)(strm->GetBits(14));
	timecod2e = strm->GetBool();
	if (timecod2e) timecod2 = (WORD)(strm->GetBits(14));
	addbsie = strm->GetBool();
	if (addbsie)
		{
		addbsil = (BYTE)(strm->GetBits(6));
		strm->Advance((addbsil + 1) * 8);
		}

//	DP("bsmod %d, acmod %d, cmixlev %d, surmixlev %d", bsmod, acmod, cmixlev, surmixlev);
	surroundDownmix = surroundDownmixProfile;

	if (bsmod == 7 && acmod > 1 && karaoke != AC3KARA_OFF)
		{
		// karaoke mode && aware or capable
		// force karoke aware decoding (Lt/Rt)
		surroundDownmix =FALSE;

		switch (karaoke)
			{
			case AC3KARA_CAPABLE_BOTH_VOCAL:
				surmixlev = 0;
				break;

			case AC3KARA_CAPABLE_NO_VOCAL:
				surmixlev = 2;
				break;

			default:
				break;
			}

		}

	return TRUE;
	}

bool AC3Decoder::ParseAudblk(int blknum)
	{
#if DUMP_FFT_DATA
	int	i;
#endif
	int ch, bnd, grp, seg, bin, num;
	BYTE b;
	bool prevcplinu;
	BYTE prevcplbegf, prevcplendf;

#if DUMP_FFT_DATA
		fprintf(dfile, "At block switch %08x\n", (int)(strm->CurrentLocation()));
#endif

	for(ch = 0; ch < nfchans; ch++) blksw[ch]    = strm->GetBool();
	for(ch = 0; ch < nfchans; ch++) dithflag[ch] = strm->GetBool();

	dynrnge = strm->GetBool();
	if (dynrnge) dynrng = (BYTE)(strm->GetBits(8));

	if (acmod == 0)
		{
		dynrng2e = strm->GetBool();
		if (dynrng2e) dynrng2 = (BYTE)(strm->GetBits(8));
		}

	prevcplbegf = cplbegf;
	prevcplendf = cplendf;
	prevcplinu = cplinu;

	cplstre = strm->GetBool();
	if (cplstre)
		{
		cplinu = strm->GetBool();
#if DUMP_FFT_DATA
		fprintf(dfile, "CLPINU %d\n", cplinu);
#endif
		if (cplinu)
			{
			for(ch = 0; ch < nfchans; ch++) chincpl[ch] = strm->GetBool();
			if (acmod == 0x2) phsflginu = strm->GetBool();
			cplbegf = (BYTE)(strm->GetBits(4));
			cplendf = (BYTE)(strm->GetBits(4));

			ncplsubnd = 3 + cplendf - cplbegf;
			for(bnd = 1; bnd < ncplsubnd; bnd++) cplbndstrc[bnd] = strm->GetBool();
#if DUMP_FFT_DATA
			for(ch = 0; ch < nfchans; ch++)
				fprintf(dfile, "CHINCPL (%d) %d\n", ch, chincpl[ch]);
			fprintf(dfile, "CPLBEGF %d CPLENDF %d\n", cplbegf, cplendf);
			for(bnd = 1; bnd < ncplsubnd; bnd++)
				fprintf(dfile, "cplbndstrc (%d) %d\n", bnd, cplbndstrc[bnd]);
#endif
			}
		}
#if BITSTREAM_CHECK
	else if (!blknum)
		{
		// BITSTREAM ERROR :
		//
#if DUMP_ERRORS
		OutputDebugString("(blknum == 0) && (cplstre == 0)\n");
#endif
		//
		return FALSE;
		}
#endif

	if (cplinu)
		{
#if BITSTREAM_CHECK
		if (cplbegf > cplendf + 2)
			{
			// BITSTREAM ERROR :
			//
#if DUMP_ERRORS
			OutputDebugString("(cplinu == 1) && (cplbegf > cplendf + 2)\n");
#endif
			//
			return FALSE;
			}
#endif

		ncplbnd = 1;
		for(bnd = 1; bnd < ncplsubnd; bnd++) if (cplbndstrc[bnd] == 0) ncplbnd++;
		num = 0;

		for(ch = 0; ch < nfchans; ch++)
			{
			if (chincpl[ch])
				{
				num++;
				cplcoe[ch] = strm->GetBool();
#if DUMP_FFT_DATA
				fprintf(dfile, "cplcoe (%d) %d\n", ch, cplcoe[ch]);
#endif
				if (cplcoe[ch])
					{
					mstrcplco[ch] = (BYTE)(strm->GetBits(2));
#if DUMP_FFT_DATA
					fprintf(dfile, "mstrcplco (%d) %d\n", ch, mstrcplco[ch]);
#endif
					for(bnd = 0; bnd < ncplbnd; bnd++)
						{
						cplcoexp[ch][bnd] = (BYTE)(strm->GetBits(4));
						cplcomant[ch][bnd] = (BYTE)(strm->GetBits(4));
#if DUMP_FFT_DATA
						fprintf(dfile, "cplcoexp, mant (%d.%d) %x %x\n", ch, bnd, cplcoexp[ch][bnd], cplcomant[ch][bnd]);
#endif
						}

					int sbnd;
					fftreal temp;

					bnd = 0;
					for(sbnd = cplbegf; sbnd < 3 + cplendf; sbnd++)
						{
						if (cplcoexp[ch][bnd] == 15)
							temp = (fftreal)cplcomant[ch][bnd] * (fftreal)(1. / 16.);
						else
							temp = (fftreal)(cplcomant[ch][bnd] + 16) * (fftreal)(1. / 32);

						cplco[ch][sbnd] = temp / (1 << (cplcoexp[ch][bnd] + 3 * mstrcplco[ch]));

						if (sbnd < 2 + cplendf && !cplbndstrc[sbnd - cplbegf + 1]) bnd++;
						}
					}
#if BITSTREAM_CHECK
				else if (blknum == 0 || prevcplinu == 0)
					{
					// BITSTREAM ERROR :
					//
#if DUMP_ERRORS
					OutputDebugString("(cplinu == 1) &&\n");
					OutputDebugString("(blknum == 0 || prevcplinu == 0) &&\n");
					OutputDebugString("(chincpl[n] == 1) && (cplcoe[n] == 0)\n");
#endif
					//
					return FALSE;
					}
#endif
				}
			}
#if BITSTREAM_CHECK
		if (!num)
			{
			// BITSTREAM ERROR :
			//
#if DUMP_ERRORS
			OutputDebugString("(cplinu == 1) && (no channels in coupling)\n");
#endif
			//
			return FALSE;
			}
#endif
		if (acmod == 0x2 && phsflginu && (cplcoe[0] || cplcoe[1]))
			{
			for(bnd = 0; bnd < ncplbnd; bnd++)
				{
				phsflg[bnd] = strm->GetBool();
				}

			int sbnd;

			bnd = 0;
			for(sbnd = cplbegf; sbnd < 3 + cplendf; sbnd++)
				{
				if (phsflg[bnd])
				cplco[1][sbnd] = -cplco[1][sbnd];

				if (sbnd < 2 + cplendf && !cplbndstrc[sbnd - cplbegf + 1]) bnd++;
				}
			}
		}

	if (acmod == 0x2)
		{
		rematstr = strm->GetBool();
		if (rematstr)
			{
			if (cplbegf > 2 || cplinu == 0)
				{
				for(bnd = 0; bnd < 4; bnd++) rematflg[bnd] = strm->GetBool();
				}
			else if (cplbegf > 0 && cplbegf <= 2 && cplinu)
				{
				for(bnd = 0; bnd < 3; bnd++) rematflg[bnd] = strm->GetBool();
				}
			else if (cplbegf == 0 && cplinu)
				{
				for(bnd = 0; bnd < 2; bnd++) rematflg[bnd] = strm->GetBool();
				}
			}
#if BITSTREAM_CHECK
		else if (blknum == 0)
			{
			// BITSTREAM ERROR :
			//
#if DUMP_ERRORS
			OutputDebugString("(blknum == 0) && (acmod == 2) && (rematstr == 0)\n");
#endif
			//
			return FALSE;
			}
#endif
		}

	if (cplinu)
		{
		b = (BYTE)(strm->GetBits(2));
#if DUMP_FFT_DATA
		fprintf(dfile, "cplexps %d\n", b);
#endif
		newcplexps = b != 0;
		if (newcplexps)
			cplexpstr = b;
#if BITSTREAM_CHECK
		else if (blknum == 0 || prevcplinu == 0)
			{
			// BITSTREAM ERROR :
			//
#if DUMP_ERRORS
			OutputDebugString("(cplinu == 1) &&\n");
			OutputDebugString("(blknum == 0 || prevcplinu == 0) &&\n");
			OutputDebugString("(cplexpstr == 0)\n");
#endif
			//
			return FALSE;
			}
#endif
		}
	for(ch = 0; ch < nfchans; ch++)
		{
		b = (BYTE)(strm->GetBits(2));
#if DUMP_FFT_DATA
		fprintf(dfile, "CHEXPS %d\n", b);
#endif
		newchexps[ch] = b != 0;
		if (newchexps[ch]) chexpstr[ch] = b;
		}
	if (lfeon)
		{
		b = (BYTE)(strm->GetBit());
		newlfeexps = b != 0;
		if (newlfeexps) lfeexpstr = b;
		}
	for(ch = 0; ch < nfchans; ch++)
		{
		if (newchexps[ch] != 0)
			{
			if (!(cplinu && chincpl[ch]))
				{
				chbwcod[ch] = (BYTE)(strm->GetBits(6));
#if DUMP_FFT_DATA
				fprintf(dfile, "CHBWCOD (%d) %02x\n", ch, chbwcod[ch]);
#endif
				}
			}
#if BITSTREAM_CHECK
		if ((cplinu == 0 || chincpl[ch] == 0) && chbwcod[ch] > 60)
			{
			// BITSTREAM ERROR :
			//
#if DUMP_ERRORS
			OutputDebugString("(chincpl[n] == 0) && (chbwcod[n] > 60)\n");
#endif
			//
			return FALSE;
			}
#endif
		}

	if (cplinu)
		{
		cplstrtmant = (cplbegf * 12) + 37;
		cplendmant = (cplendf + 3) * 12 + 37;
		ncplgrps = (cplendmant - cplstrtmant) / (3 << (cplexpstr - 1));

		if (newcplexps)
			{
			cplabsexp = (BYTE)(strm->GetBits(4));
			for(grp = 0; grp < ncplgrps; grp++)
				{
				cplgexps[grp] = (BYTE)(strm->GetBits(7));
				if (cplgexps[grp] >= 125)
					{
#if BITSTREAM_CHECK
					// BITSTREAM ERROR :
					//
#if DUMP_ERRORS
					OutputDebugString("(cplgexps[grp] >= 125)\n");
#endif
					//
					return FALSE;
#endif
					}
				}
			}
#if BITSTREAM_CHECK
		else if (cplbegf != prevcplbegf || cplendf != prevcplendf)
			{
			// BITSTREAM ERROR :
			//
#if DUMP_ERRORS
			OutputDebugString("(cplinu == 1) &&\n");
			OutputDebugString("(cplbegf != previous cplbegf || cplendf != previous cplendf) &&\n");
			OutputDebugString("(cplexpstr == 0)\n");
#endif
			//
			return FALSE;
			}
#endif
		if (newcplexps || cplstre)
			{
			if (!UnpackExponents(ncplgrps, cplgexps, cplexpstr, cplabsexp << 1, cplexps + cplstrtmant - 1)) return FALSE;
			}
		}

	for(ch = 0; ch < nfchans; ch++)
		{
		strtmant[ch] = 0;
		endmant[ch] = (cplinu && chincpl[ch]) ? cplstrtmant : (chbwcod[ch] + 12) * 3 + 37;

		switch (chexpstr[ch])
			{
			case 1:
				nchgrps[ch] = (endmant[ch] - 1) / 3;
				break;
			case 2:
				nchgrps[ch] = (endmant[ch] - 1 + 3) / 6;
				break;
			case 3:
				nchgrps[ch] = (endmant[ch] - 1 + 9) / 12;
				break;
			}

		if (newchexps[ch])
			{
			gexps[ch][0] = (BYTE)(strm->GetBits(4));

			for(grp = 1; grp <= nchgrps[ch]; grp++) gexps[ch][grp] = (BYTE)(strm->GetBits(7));
			gainrng[ch] = (BYTE)(strm->GetBits(2));
#if DUMP_FFT_DATA
			for(grp = 0; grp <= nchgrps[ch]; grp++)
				fprintf(dfile, "CHGRPS (%d, %d) %02x\n", ch, grp, (int)(gexps[ch][grp]));
#endif
			}
#if BITSTREAM_CHECK
		else if (blknum == 0)
			{
			// BITSTREAM ERROR :
			//
			// (blknum == 0) && (chexpstr[n] == 0)
			//
#if DUMP_ERRORS
			OutputDebugString("(blknum == 0) && (chexpstr[n] == 0)\n");
#endif
			return FALSE;
			}
		else if (cplinu && cplbegf != prevcplbegf && chincpl[ch])
			{
			// BITSTREAM ERROR :
			//
			// (cplinu == 1) && (cplbegf != previous cplbegf) &&
			// (chincpl[n] == 1) && (chexpstr[n] == 0)
			//
#if DUMP_ERRORS
			OutputDebugString("(cplinu ==1 ) && (cplbegf != previous cplbegf) &&\n");
			OutputDebugString("(chincpl[n] ==1) && (chexpstr[n] == 0) &&\n");
#endif
			//
			return FALSE;
			}
#endif

		if (newchexps[ch] || cplstre)
			{
			if (!UnpackExponents(nchgrps[ch], gexps[ch] + 1, chexpstr[ch], gexps[ch][0], exps[ch])) return FALSE;
#if DUMP_FFT_DATA
			fprintf(dfile, "Unpack exponents %d\n", ch);
			for(i=0; i<255; i++)
				{
				fprintf(dfile, "%3d : %02x\n", i, exps[ch][i]);
				}
			fprintf(dfile, "\n");
#endif
			}
		}

	if (lfeon)
		{
		lfestrtmant = 0; lfeendmant = 7;
		nlfegrps = 2;
		if (newlfeexps)
			{
			lfegexps[0] = (BYTE)(strm->GetBits(4));
			for(grp = 1; grp <= nlfegrps; grp++) lfegexps[grp] = (BYTE)(strm->GetBits(7));
			if (!UnpackExponents(nlfegrps, lfegexps + 1, 1, lfegexps[0], lfeexps)) return FALSE;
			}
#if BITSTREAM_CHECK
		else if (blknum == 0)
			{
			// BITSTREAM ERROR :
			//
			// (blknum == 0) && (lfeon == 1) && (lfeexpstr == 0)
#if DUMP_ERRORS
			OutputDebugString("(blknum == 0) && (lfeon == 1) && (lfeexpstr == 0)\n");
#endif
			//
			return FALSE;
			}
#endif
		}

	baie = strm->GetBool();
	if (baie)
		{
		sdcycod = (BYTE)(strm->GetBits(2));
		fdcycod = (BYTE)(strm->GetBits(2));
		sgaincod = (BYTE)(strm->GetBits(2));
		dbpbcod = (BYTE)(strm->GetBits(2));
		floorcod = (BYTE)(strm->GetBits(3));
		}
#if BITSTREAM_CHECK
	else if (blknum == 0)
		{
		// BITSTREAM ERROR :
		//
		// (blknum == 0) && (baie == 0)
#if DUMP_ERRORS
			OutputDebugString("(blknum == 0) && (baie == 0)\n");
#endif
		//
		return FALSE;
		}
#endif

	snroffste = strm->GetBool();
	if (snroffste)
		{
		csnroffst = (BYTE)(strm->GetBits(6));
		nosnroffst = csnroffst == 0;

		if (cplinu)
			{
			cplfsnroffst = (BYTE)(strm->GetBits(4));
			cplfgaincod = (BYTE)(strm->GetBits(3));
			if (cplfsnroffst != 0) nosnroffst = false;
			}
		for(ch = 0; ch < nfchans; ch++)
			{
			fsnroffst[ch] = (BYTE)(strm->GetBits(4));
			fgaincod[ch] = (BYTE)(strm->GetBits(3));
			if (fsnroffst[ch] != 0) nosnroffst = false;
			}
		if (lfeon)
			{
			lfefsnroffst = (BYTE)(strm->GetBits(4));
			lfefgaincod = (BYTE)(strm->GetBits(3));
			if (lfefsnroffst != 0) nosnroffst = false;
			}
		}
#if BITSTREAM_CHECK
	else if (blknum == 0)
		{
		// BITSTREAM ERROR :
		//
		// (blknum == 0) && (snroffste == 0)
		//
#if DUMP_ERRORS
			OutputDebugString("(blknum == 0) && (snroffste == 0)\n");
#endif
		return FALSE;
		}
#endif

	if (cplinu)
		{
		cplleake = strm->GetBool();
		if (cplleake)
			{
			cplfleak = (BYTE)(strm->GetBits(3));
			cplsleak = (BYTE)(strm->GetBits(3));
			}
#if BITSTREAM_CHECK
		else if (blknum == 0)
			{
			// BITSTREAM ERROR :
			//
			// (blknum == 0) && (baie == 0)
#if DUMP_ERRORS
			OutputDebugString("(blknum == 0) && (baie == 0)\n");
#endif
			//
			return FALSE;
			}
#endif
		}

	deltbaie = strm->GetBool();
	if (deltbaie)
		{
		if (cplinu) cpldeltbae = (BYTE)(strm->GetBits(2));
		for(ch = 0; ch < nfchans; ch++) deltbae[ch] = (BYTE)(strm->GetBits(2));
		if (cplinu)
			{
			if (cpldeltbae == 1)
				{
				num = 0;
				cpldeltnseg = (BYTE)(strm->GetBits(3)) + 1;
				for(seg = 0; seg < cpldeltnseg; seg++)
					{
					num += cpldeltoffst[seg] = (BYTE)(strm->GetBits(5));
					num += cpldeltlen[seg] = (BYTE)(strm->GetBits(4));
					cpldeltba[seg] = (BYTE)(strm->GetBits(3));
					}
#if BITSTREAM_CHECK
				if (num > 50)
					{
					// BITSTREAM ERROR :
					//
#if DUMP_ERRORS
					OutputDebugString("(sum of cpldeltoffst > 50)\n");
#endif
					return FALSE;
					}
#endif
				}
			}
		for(ch = 0; ch < nfchans; ch++)
			{
			if (deltbae[ch] == 1)
				{
				num = 0;
				deltnseg[ch] = (BYTE)(strm->GetBits(3)) + 1;
				for(seg = 0; seg < deltnseg[ch]; seg++)
					{
					num += deltoffst[ch][seg] = (BYTE)(strm->GetBits(5));
					num += deltlen[ch][seg] = (BYTE)(strm->GetBits(4));
					deltba[ch][seg] = (BYTE)(strm->GetBits(3));
					}
#if BITSTREAM_CHECK
				if (num > 50)
					{
					// BITSTREAM ERROR :
					//
#if DUMP_ERRORS
					OutputDebugString("(sum of deltoffst > 50)\n");
#endif
					return FALSE;
					}
#endif
				}
			}
		}

	skiple = strm->GetBool();
	if (skiple)
		{
		skipl = (WORD)(strm->GetBits(9));
		strm->Advance(skipl * 8);
#if DUMP_FFT_DATA
		fprintf(dfile, "Skipl %d\n", skipl);
		fprintf(dfile, "Fixed data boundary %08x\n", (int)(strm->CurrentLocation()));
#endif
		}

	if (cplinu)
		{
		ncplmant = cplendmant - cplstrtmant;
		if (newcplexps || cplstre || cplleake || (deltbaie && cpldeltbae) || baie || snroffste)
			CalculateBitAllocation(cplstrtmant, cplendmant, cplfgaincod, cplfsnroffst, cplexps,
										  ((WORD)cplfleak << 8) + 768, ((WORD)cplsleak << 8) + 768,
										  cpldeltbae, cpldeltnseg, cpldeltoffst, cpldeltba, cpldeltlen, cplbap, FALSE);
		}
	for(ch = 0; ch < nfchans; ch++)
		{
		nchmant[ch] = endmant[ch] - strtmant[ch];
		if (newchexps[ch] || cplstre || (deltbaie && deltbae[ch]) || baie || snroffste)
			CalculateBitAllocation(strtmant[ch], endmant[ch], fgaincod[ch], fsnroffst[ch], exps[ch],
										  0, 0,
										  deltbae[ch], deltnseg[ch], deltoffst[ch], deltba[ch], deltlen[ch], chbap[ch], FALSE);
		}
	if (lfeon)
		{
		nlfemant = lfeendmant - lfestrtmant;
		if (newlfeexps || baie || snroffste)
			CalculateBitAllocation(lfestrtmant, lfeendmant, lfefgaincod, lfefsnroffst, lfeexps,
										  0, 0,
										  2, 0, NULL, NULL, NULL, lfebap, TRUE);
		}

	InitParseMantissa();

	ch = 0;
	do {
		GetMantissas(nchmant[ch], chcoeff[ch], chbap[ch], exps[ch], dithflag[ch]);
		ch++;
		} while (!(cplinu && chincpl[ch-1]) && ch < nfchans);
	if (cplinu)
		{
		GetMantissas(ncplmant, cplcoeff+cplstrtmant, cplbap+cplstrtmant, cplexps+cplstrtmant, FALSE);
		if (chincpl[ch-1]) UncoupleChannel(ch-1);

//		for(bin = cplstrtmant; bin < cplendmant; bin++) cplcoeff[bin] = ShiftFP(GetMantissa(cplbap[bin]), cplexps[bin]);
		}
	while (ch < nfchans)
		{
		GetMantissas(nchmant[ch], chcoeff[ch], chbap[ch], exps[ch], dithflag[ch]);
		if (cplinu && chincpl[ch])
			UncoupleChannel(ch);
		ch++;
		}
	if (lfeon)
		{
		GetMantissas(nlfemant, lfecoeff, lfebap, lfeexps, FALSE);
		}

	for (ch = 0; ch < nfchans; ch ++)
		{
		if (cplinu && chincpl[ch])
			{
			for(bin = cplendmant; bin < 256; bin++) chcoeff[ch][bin] = 0.0;
			}
		else
			{
			for(bin = endmant[ch]; bin < 256; bin++) chcoeff[ch][bin] = 0.0;
			}
		}

	return TRUE;
	}

static inline void IFFT(complex * x, complex * y, int n, complex * fm)
	{
	int m, i, j, r, nm, is, n2, n4, n6, n8;
	fftreal wr, wi;
	fftreal sr, si;
	fftreal yr0, yi0, yr1, yi1, yr2, yi2, yr3, yi3;

	n2 = n >> 1;
	n4 = n >> 2;
	n8 = n >> 3;
	n6 = n2 + n4;

	j = 0;
	for(i=0; i<n; i+=4)
		{
		yr0 = x[j+0].r + x[j+n2].r;
		yi0 = x[j+0].i + x[j+n2].i;
		yr1 = x[j+0].r - x[j+n2].r;
		yi1 = x[j+0].i - x[j+n2].i;
		yr2 = x[j+n4].r + x[j+n6].r;
		yi2 = x[j+n4].i + x[j+n6].i;
		yr3 = x[j+n4].r - x[j+n6].r;
		yi3 = x[j+n4].i - x[j+n6].i;

		y[i+0].r = yr0 + yr2;
		y[i+0].i = yi0 + yi2;
		y[i+1].r = yr1 - yi3;
		y[i+1].i = yi1 + yr3;
		y[i+2].r = yr0 - yr2;
		y[i+2].i = yi0 - yi2;
		y[i+3].r = yr1 + yi3;
		y[i+3].i = yi1 - yr3;

		m = n8;
		while (m && (j & m))
			{
			j -= m;
			m >>= 1;
			}
		j += m;
		}

	nm = 8;
	r = 16;
	while (n > nm)
		{
		m = 0;
		is = nm >> 1;
		for(i=0; i <is; i++)
			{
			wr = cossintab64[m].r; wi = cossintab64[m].i;
			m += r;

			for(j=i; j<n; j+=nm)
				{
				sr = y[j+is].r * wr - y[j+is].i * wi;
				si = y[j+is].r * wi + y[j+is].i * wr;
				y[j+is].r = y[j].r - sr;
				y[j+is].i = y[j].i - si;
				y[j].r += sr;
				y[j].i += si;
				}
			}
		nm <<= 1;
		r >>= 1;
		}

	m = 0;
	is = nm >> 1;
	for(i=0; i <is; i++)
		{
		wr = cossintab64[m].r; wi = cossintab64[m].i;
		m += r;

		sr = y[i+is].r * wr - y[i+is].i * wi;
		si = y[i+is].r * wi + y[i+is].i * wr;

		yr0 = y[i].r - sr;
		yi0 = y[i].i - si;
		yr1 = y[i].r + sr;
		yi1 = y[i].i + si;

		y[i+is].r = yi0 * fm[i+is].i - yr0 * fm[i+is].r;
		y[i+is].i = yi0 * fm[i+is].r + yr0 * fm[i+is].i;

		y[i   ].r = yi1 * fm[i   ].i - yr1 * fm[i   ].r;
		y[i   ].i = yi1 * fm[i   ].r + yr1 * fm[i   ].i;
		}

	}


#define abs(x) ((x) > 0 ? (x) : -(x))

static inline void InverseFFT512(fftreal * x, fftreal * y)
	{
	static const int n = 512;


	complex z[n/4];
	complex zz[n/4];

	int k, l;

	for(k=0; k<n/4; k++)
		{
		l = 2 * k;

		z[k].r = x[n/2-l-1] * xcossin512[k].r - x[    l  ] * xcossin512[k].i;
		z[k].i = x[    l  ] * xcossin512[k].r + x[n/2-l-1] * xcossin512[k].i;
		}

	IFFT(z, zz, n / 4, xcossin512);


	for(l=0; l<n/8; l++)
		{
		k = l * 2;

		// tzr = zz[l].r * xcossin512[l].r - zz[l].i * xcossin512[l].i;
		// tzi = zz[l].i * xcossin512[l].r + zz[l].r * xcossin512[l].i;

		y[    n/4+k  ] =  zz[l].r;;
		y[    n/4-k-1] = -zz[l].r;;
		y[n/2+n/4+k  ] =  zz[l].i;
		y[n/2+n/4-k-1] =  zz[l].i;

		// tzr = zz[n/8+l].r * xcossin512[n/8+l].r - zz[n/8+l].i * xcossin512[n/8+l].i;
		// tzi = zz[n/8+l].i * xcossin512[n/8+l].r + zz[n/8+l].r * xcossin512[n/8+l].i;

		y[    k  ] = -zz[n/8+l].i;
		y[n/2-k-1] =  zz[n/8+l].i;
		y[n/2+k  ] =  zz[n/8+l].r;
		y[n  -k-1] =  zz[n/8+l].r;
		}


	}

static inline void InverseFFT256(fftreal * x, fftreal * y)
	{

	static const int n = 512;

	int k, l;

	complex z[2][n/8];
	complex zz[2][n/8];
	for(k=0; k<n/8; k++)
		{
		l = 2 * k;

		z[0][k].r = x[2*(n/4-l-1)]   * xcossin256[k].r - x[2*(    l  )]   * xcossin256[k].i;
		z[0][k].i = x[2*(    l  )]   * xcossin256[k].r + x[2*(n/4-l-1)]   * xcossin256[k].i;

		z[1][k].r = x[2*(n/4-l-1)+1] * xcossin256[k].r - x[2*(    l  )+1] * xcossin256[k].i;
		z[1][k].i = x[2*(    l  )+1] * xcossin256[k].r + x[2*(n/4-l-1)+1] * xcossin256[k].i;
		}
	IFFT(z[0], zz[0], n / 8, xcossin256);
	IFFT(z[1], zz[1], n / 8, xcossin256);
	for(l=0; l<n/8; l++)
		{
		k = l * 2;

		y[k]         = -zz[0][l].i;
		y[k+1]       = -zz[0][n/8-l-1].r;
		y[n/4+k]     =  zz[0][l].r;
		y[n/4+k+1]   =  zz[0][n/8-l-1].i;
		y[n/2+k]     =  zz[1][l].r;
		y[n/2+k+1]   =  zz[1][n/8-l-1].i;
		y[3*n/4+k]   =  zz[1][l].i;
		y[3*n/4+k+1] =  zz[1][n/8-l-1].r;

		}
	}

void AC3Decoder::TransformChannels(void)
	{
	int ch;
	for(ch = 0; ch < nfchans; ch++)
		{
		if (!channelPremixed[ch])
			{
			if (blksw[ch])
				InverseFFT256(chcoeff[ch], chpostfft[ch]);
			else
				InverseFFT512(chcoeff[ch], chpostfft[ch]);
			}
		}
	if (lfeon && enableLFE)
		{
		InverseFFT512(lfecoeff, lfepostfft);
		}
	}

void AC3Decoder::MuteAudioBuffer(void)
	{
	int i;

	for(i=0; i<256 * 6; i++)
		{
		leftRightBuffer[2*i+0] = lastLeft * (256 * 6 - i) / (256 * 6);
		leftRightBuffer[2*i+1] = lastRight * (255  * 6 - i) / (256 * 6);
		}
	for(i=0; i<256; i++)
		{
		overlap[0][i] = 0;
		overlap[1][i] = 0;
		}
	}

void AC3Decoder::UnmuteAudioBuffer(void)
	{
	int i;

	lastLeft = leftRightBuffer[2 * 256 * 6 - 2];
	lastRight = leftRightBuffer[2 * 256 * 6 - 1];

	for(i=0; i<256 * 6; i++)
		{
		leftRightBuffer[2*i+0] = lastLeft * i / (256 * 6);
		leftRightBuffer[2*i+1] = lastRight * i / (256 * 6);
		}
	}


bool AC3Decoder::CheckCRCAndFrameAC3DigitalOutput(void)
	{
	static WORD crctab[256] =
	{	0x0000, 0x8005, 0x800f, 0x000a, 0x801b, 0x001e, 0x0014, 0x8011,
		0x8033, 0x0036, 0x003c, 0x8039, 0x0028, 0x802d, 0x8027, 0x0022,
		0x8063, 0x0066, 0x006c, 0x8069, 0x0078, 0x807d, 0x8077, 0x0072,
		0x0050, 0x8055, 0x805f, 0x005a, 0x804b, 0x004e, 0x0044, 0x8041,
		0x80c3, 0x00c6, 0x00cc, 0x80c9, 0x00d8, 0x80dd, 0x80d7, 0x00d2,
		0x00f0, 0x80f5, 0x80ff, 0x00fa, 0x80eb, 0x00ee, 0x00e4, 0x80e1,
		0x00a0, 0x80a5, 0x80af, 0x00aa, 0x80bb, 0x00be, 0x00b4, 0x80b1,
		0x8093, 0x0096, 0x009c, 0x8099, 0x0088, 0x808d, 0x8087, 0x0082,
		0x8183, 0x0186, 0x018c, 0x8189, 0x0198, 0x819d, 0x8197, 0x0192,
		0x01b0, 0x81b5, 0x81bf, 0x01ba, 0x81ab, 0x01ae, 0x01a4, 0x81a1,
		0x01e0, 0x81e5, 0x81ef, 0x01ea, 0x81fb, 0x01fe, 0x01f4, 0x81f1,
		0x81d3, 0x01d6, 0x01dc, 0x81d9, 0x01c8, 0x81cd, 0x81c7, 0x01c2,
		0x0140, 0x8145, 0x814f, 0x014a, 0x815b, 0x015e, 0x0154, 0x8151,
		0x8173, 0x0176, 0x017c, 0x8179, 0x0168, 0x816d, 0x8167, 0x0162,
		0x8123, 0x0126, 0x012c, 0x8129, 0x0138, 0x813d, 0x8137, 0x0132,
		0x0110, 0x8115, 0x811f, 0x011a, 0x810b, 0x010e, 0x0104, 0x8101,
		0x8303, 0x0306, 0x030c, 0x8309, 0x0318, 0x831d, 0x8317, 0x0312,
		0x0330, 0x8335, 0x833f, 0x033a, 0x832b, 0x032e, 0x0324, 0x8321,
		0x0360, 0x8365, 0x836f, 0x036a, 0x837b, 0x037e, 0x0374, 0x8371,
		0x8353, 0x0356, 0x035c, 0x8359, 0x0348, 0x834d, 0x8347, 0x0342,
		0x03c0, 0x83c5, 0x83cf, 0x03ca, 0x83db, 0x03de, 0x03d4, 0x83d1,
		0x83f3, 0x03f6, 0x03fc, 0x83f9, 0x03e8, 0x83ed, 0x83e7, 0x03e2,
		0x83a3, 0x03a6, 0x03ac, 0x83a9, 0x03b8, 0x83bd, 0x83b7, 0x03b2,
		0x0390, 0x8395, 0x839f, 0x039a, 0x838b, 0x038e, 0x0384, 0x8381,
		0x0280, 0x8285, 0x828f, 0x028a, 0x829b, 0x029e, 0x0294, 0x8291,
		0x82b3, 0x02b6, 0x02bc, 0x82b9, 0x02a8, 0x82ad, 0x82a7, 0x02a2,
		0x82e3, 0x02e6, 0x02ec, 0x82e9, 0x02f8, 0x82fd, 0x82f7, 0x02f2,
		0x02d0, 0x82d5, 0x82df, 0x02da, 0x82cb, 0x02ce, 0x02c4, 0x82c1,
		0x8243, 0x0246, 0x024c, 0x8249, 0x0258, 0x825d, 0x8257, 0x0252,
		0x0270, 0x8275, 0x827f, 0x027a, 0x826b, 0x026e, 0x0264, 0x8261,
		0x0220, 0x8225, 0x822f, 0x022a, 0x823b, 0x023e, 0x0234, 0x8231,
		0x8213, 0x0216, 0x021c, 0x8219, 0x0208, 0x820d, 0x8207, 0x0202 };


	WORD w;
	int i;
	__int64 loc;
	BYTE * dptr = (BYTE *)&encodedBuffer;

	loc = strm->CurrentLocation();
	strm->SetCurrentLocation(frameStart);

	*dptr++ = 0x72;
	*dptr++ = 0xf8;
	*dptr++ = 0x1f;
	*dptr++ = 0x4e;
	*dptr++ = 0x01;
	*dptr++ = 0x00;
	*dptr++ = frameSize & 0xff;
	*dptr++ = frameSize >> 8;

	WORD crcVerify1 = 0;
	WORD crcVerify2 = 0;
	int crcLength = (frameSize >> 5) + (frameSize >> 7);

	// sync word
	w = (WORD)(strm->GetBits(16));
	*dptr++ = w & 0xff;
	*dptr++ = w >> 8;

	// first 5/8
	for (i=1; i<crcLength; i++)
		{
		w = (WORD)(strm->GetBits(16));
		*dptr++ = w & 0xff;
		*dptr++ = w >> 8;

		crcVerify1 = (WORD)(((crcVerify1 << 8) & 0xff00) ^ (BYTE)( w >> 8 ) ^ crctab[(crcVerify1 >> 8) & 0xff]);
		crcVerify1 = (WORD)(((crcVerify1 << 8) & 0xff00) ^ (BYTE)(w & 0xff) ^ crctab[(crcVerify1 >> 8) & 0xff]);
		}

	// last 3/8
	for (; i<frameSize/16; i++)
		{
		w = (WORD)(strm->GetBits(16));
		*dptr++ = w & 0xff;
		*dptr++ = w >> 8;

		crcVerify2 = (WORD)(((crcVerify2 << 8) & 0xff00) ^ (BYTE)( w >> 8 ) ^ crctab[(crcVerify2 >> 8) & 0xff]);
		crcVerify2 = (WORD)(((crcVerify2 << 8) & 0xff00) ^ (BYTE)(w & 0xff) ^ crctab[(crcVerify2 >> 8) & 0xff]);
		}

	i = 6144 - 8 - (frameSize>>3);
	ZeroMemory(dptr, i);
	strm->SetCurrentLocation(loc);

	if(crcVerify1 || crcVerify2)
		{
		DP("CRC error in first 5/8s of frame crc val 0x%04x\n", crcVerify1);
		DP("CRC error in remaining 3/8s of frame crc val 0x%04x\n", crcVerify2);
		return false;
		}

	return true;
	}



void AC3Decoder::ParseSyncFrame(void)
	{
	bool frameOk;
	int blk, ch, time;
	__int64 frameEnd;

	do {
		time = strm->GetCurrentTimeStamp();

		if (!ParseSyncInfo()) return;

		if (!strm->RefillBuffer(frameSize + 64)) return;

		frameEnd = frameStart + frameSize;

		frameOk = PeekWordAt((int)(frameEnd - strm->CurrentLocation())) == 0x0b77;

		if (frameOk)
			{
			frameOk = CheckCRCAndFrameAC3DigitalOutput();
			}
		else
			{
			DP("Next AC3 sync frame not found frameStart %d frameEnd %d",frameStart, frameEnd);
			}

		} while (!frameOk);


	if (time != INVALID_TIME_STAMP && time != lastTime)
		{
		lastTime = time;
		currentDataTime = time;
		time -= pcmWaveOut->GetBufferDelayTime();
		if (time >= 0 && timingSlave)
			{
			timingSlave->UpdateTimer(time);
			}
		}

	if (lastfscod != fscod)
		{
		switch (fscod)
			{
			default:
				DP("ERROR: fscod reversed ???");
			case 0:
				sampleRate = 48000;
				break;
			case 1:
				sampleRate = 44100;
				break;
			case 2:
				sampleRate = 32000;
				break;
			}
		// does nothing on Xbox
		pcmWaveOut->SetSampleRate(sampleRate);
		lastfscod = fscod;
		}


#if DUMP_FFT_DATA
	fprintf(dfile, "FRAME AT %08lx to %08lx\n", (int)frameStart / 8, (int)frameEnd / 8);
#endif

	dynrng = 0;
	compr = 0;

	if (ParseBSI())
		{
		cpldeltbae = 2;
		cpldeltnseg = 0;
		for(ch = 0; ch < nfchans; ch++)
			{
			deltbae[ch] = 2;
			deltnseg[ch] = 0;
			}

		outNum = 0;

		for(blk = 0; blk < 6; blk++)
			{
#if DUMP_FFT_DATA
			fprintf(dfile, "BLOCK NO %d \n\n", blk);
#endif


			if (ParseAudblk(blk))
				{
#if DUMP_COMPRESSION
					{
					char buffer[100];
					int time = (blk + 6 * FrameCnt) * 16 / 3;
					wsprintf(buffer, "At %02d:%02d:%02d,%04d ",
						time / 3600000, time / 60000 % 60, time / 1000 % 60, time % 1000);
					OutputDebugString(buffer);
					}
#endif
				RematrixChannels();
				PreDownmixChannels();
				DynamicRangeCompression();
				TransformChannels();
				PostDownmixChannels();
				WindowChannels(leftRightBuffer+outNum);
				outNum += 512;

#if DUMP_COMPRESSION
					{
					int i;
					int max = 0, min = 0;
					for(i=0; i<512; i++)
						{
						if (leftRightBuffer[512*blk+i] > max) max = leftRightBuffer[512*blk+i];
						if (leftRightBuffer[512*blk+i] < min) min = leftRightBuffer[512*blk+i];
						}
					if (-min > max) max = -min;

					char buffer[100];
					wsprintf(buffer, "%5d\n", max);
					OutputDebugString(buffer);
					}
#endif

				}
			else
				{
#if DUMP_ERRORS
					{
					char buffer[100];
					wsprintf(buffer, "AC3 error in Frame %d Block %d At %08lx\n", FrameCnt, blk, (int)(frameStart / 8));
					OutputDebugString(buffer);
					}
#endif
				recoverPhase = 8;

				break;
				}

			if (!hurryUp) YieldTimedFiber(0);
			}

		}
	else
		{
		recoverPhase = 8;
		}

	if (strm->CurrentLocation() > frameEnd)
		{
		recoverPhase = 8;
		}

	if (recoverPhase > 1)
		{
		MuteAudioBuffer();
		recoverPhase--;
		}
	else if (recoverPhase == 1)
		{
		UnmuteAudioBuffer();
		recoverPhase--;
		}

#if DUMP_ERRORS
		{
		int i;

		for(i=2; i<256*6*2-2; i++)
			{
			if (leftRightBuffer[i] == -32768)
				{
				char buffer[100];
				wsprintf(buffer, "Missed AC3 error in Frame %d Block %d At %08lx (%08lx)\n", FrameCnt, i / 512, (int)(frameStart / 8), (int)((strm->CurrentLocation() / 8)));
				OutputDebugString(buffer);
				}
			}
		}
#endif

	if (ac3DigitalOutput)
		{
		if (zeroBlocks)
			{
			ZeroMemory(encodedBuffer, sizeof(encodedBuffer));
			zeroBlocks--;
			}
		pcmWaveOut->AddPCMDigData(leftRightBuffer, encodedBuffer, outNum>>1, currentDataTime);
		}
	else
		{
		pcmWaveOut->AddPCMData(leftRightBuffer, outNum>>1, currentDataTime);
		}
	currentDataTime += (1000 * (outNum>>1)) / sampleRate;
	lastLeft = leftRightBuffer[outNum - 2];
	lastRight = leftRightBuffer[outNum - 1];

	if (!hurryUp) YieldTimedFiber(0);


	strm->Advance((int)(frameEnd - strm->CurrentLocation()));

	FrameCnt++;
	}

void AC3Decoder::SkipSyncFrame(void)
	{
	if (!strm->RefillBuffer()) return;

	ParseSyncInfo();
	ParseBSI();
	}

AC3Decoder::~AC3Decoder(void)
	{
#if DUMP_FFT_DATA
	fclose(dfile);
#endif
	}

void AC3Decoder::InitLocalsNewStream(void)
	{
	StartParse();
	hurryUp = FALSE;
	FrameCnt = 0;
	recoverPhase = 0;

	lastLeft = 0;
	lastRight = 0;
	lastTime = -1;
	zeroBlocks = 0;
	}

void AC3Decoder::BeginStreaming(void)
	{
	pcmWaveOut->BeginStreaming();
	InitLocalsNewStream();
	}

void AC3Decoder::StartStreaming(int playbackSpeed)
	{
	pcmWaveOut->StartStreaming(playbackSpeed);
	}

void AC3Decoder::StopStreaming(void)
	{
	pcmWaveOut->StopStreaming();
	}

void AC3Decoder::EndStreaming(bool fullReset)
	{
	pcmWaveOut->EndStreaming(fullReset);
	}

void AC3Decoder::DetachStreaming(void)
	{
	pcmWaveOut->DetachStreaming();
	}

void AC3Decoder::AttachStreaming(void)
	{
	pcmWaveOut->AttachStreaming();
	InitLocalsNewStream();

	// audio trash avoidance; zero the first "few" blocks so they don't get decoded as pcm
	// this number is dependent on the AudioOuputDevice delay in setting spdifDatamode
	zeroBlocks = AC3_BLOCK_TO_ZERO_ON_SWITCH;
	}


void AC3Decoder::SetDigitalOut(AudioTypeConfig ac3AudioType)
	{
	if (pcmWaveOut->SupportsSPDIFDataOut())
		{
		ac3DigitalOutput = ac3AudioType.config.spdifOutMode == SPDIFOM_DEFAULT;
		if(ac3DigitalOutput)
			{
			zeroBlocks = AC3_BLOCK_TO_ZERO_ON_SWITCH;
			}
		}
	else
		{
		ac3DigitalOutput = false;
		}
	}

void AC3Decoder::GetDigitalOut(AudioTypeConfig & ac3AudioType)
	{
	ac3AudioType.config.spdifOutMode = ac3DigitalOutput ? SPDIFOM_DEFAULT : SPDIFOM_DECOMPRESSED;
	}

void AC3Decoder::SetAudioOutConfig(AC3SpeakerConfig spkCfg, AC3DualModeConfig dualModeCfg, AC3KaraokeConfig karaokeCfg)
	{
	// Use Lo/Ro for mono and stereo
	surroundDownmixProfile = (spkCfg == AC3SC_20_SURROUND_COMPATIBLE) ? TRUE : FALSE;
	dualMode = dualModeCfg;
	karaoke = karaokeCfg;
	}

void AC3Decoder::SetDolbyTestMode(AC3OperationalMode op, WORD hf, WORD lf, AC3DialogNorm dn)
	{
	hf = hf > 10000 ? 10000 : hf;
	lf = lf > 10000 ? 10000 : lf;

	ldr = (int)lf * 256/10000;
	hdr = (int)hf * 256/10000;

	useDialNorm = (dn == AC3DNORM_ON);

	switch (op)
		{
		default:
			DP("SetDolbyTestMode compression mode Unknown %d", op);
		case AC3OPMODE_LINE:
			compressionMode = COMP_MODE_LINE;
			if (ldr == 256 && hdr == 256)
				drc = AC3DYNRG_COMPRESSED;
			else if (ldr == 0 && hdr == 0)
				drc = AC3DYNRG_MAXIMUM;
			else
				drc = (AC3DynamicRange)-1;
			break;

		case AC3OPMODE_RF:
			compressionMode = COMP_MODE_RF;
			if (ldr == 256 && hdr == 256)
				drc = AC3DYNRG_TV;
			else
				drc = (AC3DynamicRange)-1;
			break;

		case AC3OPMODE_CUSTOM_0:
			compressionMode = COMP_MODE_CUSTOM_A;
			useDialNorm = FALSE;
			break;

		case AC3OPMODE_CUSTOM_1:
			compressionMode = COMP_MODE_CUSTOM_B;
			drc = (AC3DynamicRange)-1;
			useDialNorm = TRUE;
			break;
		}

	if (!useDialNorm)
		drc = (AC3DynamicRange)-1;

	}


void AC3Decoder::GetDolbyTestMode(AC3OperationalMode &op, WORD &hf, WORD &lf, AC3DialogNorm &dn)
	{
	hf = (WORD)(hdr * 10000/256);
	lf = (WORD)(ldr * 10000/256);

	dn = (useDialNorm ? AC3DNORM_ON: AC3DNORM_OFF);

	switch (compressionMode)
		{
		default:
			DP("GetDolbyTestMode compression mode Unknown %d", compressionMode);
		case COMP_MODE_LINE:
			op = AC3OPMODE_LINE;
			break;

		case COMP_MODE_RF:
			op = AC3OPMODE_RF;
			break;

		case COMP_MODE_CUSTOM_A:
			op = AC3OPMODE_CUSTOM_0;
			break;

		case COMP_MODE_CUSTOM_B:
			op = AC3OPMODE_CUSTOM_1;
			break;
		}
	}


void AC3Decoder::SetAC3Config(AC3DynamicRange dr, BOOL enableLFE)
	{
	this->enableLFE = enableLFE == TRUE;
	drc = dr;
	useDialNorm = TRUE;

	switch (dr)
		{
		default:
			DP("SetAC3Config AC3DynamicRange Unknown %d", dr);
			drc = AC3DYNRG_COMPRESSED ;
		case AC3DYNRG_COMPRESSED:
			compressionMode = COMP_MODE_LINE;
			ldr = 256;
			hdr = 256;
			break;

		case AC3DYNRG_MAXIMUM:
			compressionMode = COMP_MODE_LINE;
			ldr = 0;
			hdr = 0;
			break;

		// the difference is drc is checked in RF mode
		case AC3DYNRG_MINIMUM:
		case AC3DYNRG_TV:
			compressionMode = COMP_MODE_RF;
			ldr = 256;
			hdr = 256;
			break;
		}


	}


void AC3Decoder::GetAC3Config(AC3DynamicRange &dr, BOOL &enableLFE)
	{
	enableLFE = (BOOL)this->enableLFE;
	dr = drc;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\AC3Decoder\AC3StreamDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef AC3STREAMDECODER_H
#define AC3STREAMDECODER_H

#include "AC3Decoder.h"
#include "..\audio\AudioStreamDecoder.h"
#include "..\common\TimedFibers.h"

enum	ByteOrder
	{
	BO_UNKNOWN,
	BO_FORWARD,
	BO_REVERSE
	};

class AC3StreamDecoder : public AudioStreamDecoder,
                         protected AC3Decoder,
								 private TimedFiber
	{
	protected:
		bool								lowPriority;
		bool								streaming;
		ByteOrder							byteOrder;

		StreamFlipCopy * wordCopySwap;
		StreamFlipCopy * streamFlipCopy;

		class Supervisor : public TimedFiber
			{
			protected:
				AC3StreamDecoder * decoder;
			public:
				Supervisor(AC3StreamDecoder * decoder);
				void FiberRoutine(void);
			} supervisor;

		void FiberRoutine(void);
		void SupervisorFiberRoutine(void);
		void InitLocalsNewStream(void);
		void ClosingCurrentStream(void);


		friend class AC3StreamDecoder::Supervisor;
	public:
		AC3StreamDecoder(PCMWaveOut * pcmWaveOut, TimingSlave * timingSlave, GenericProfile * globalProfile, GenericProfile * profile, StreamFlipCopy * streamFlipCopy);
		~AC3StreamDecoder(void);

		void BeginStreaming(void);
		void StartStreaming(int playbackSpeed);
		void StopStreaming(void);
		void EndStreaming(bool fullReset);
		void DetachStreaming(void);
		void AttachStreaming(void);
		DWORD SendData(BYTE * ptr, DWORD num);

		void CompleteData(void);

		void SetAudioOutConfig(AC3SpeakerConfig spkCfg, AC3DualModeConfig dualModeCfg, AC3KaraokeConfig karaokeCfg)
			{AC3Decoder::SetAudioOutConfig(spkCfg, dualModeCfg, karaokeCfg);}

		void SetDolbyTestMode(AC3OperationalMode op, WORD hf, WORD lf, AC3DialogNorm dn)
			{AC3Decoder::SetDolbyTestMode(op, hf, lf, dn);}

		void GetDolbyTestMode(AC3OperationalMode &op, WORD &hf, WORD &lf, AC3DialogNorm &dn)
			{AC3Decoder::GetDolbyTestMode(op, hf, lf, dn);}

//		void SetAC3Config(AC3SpeakerConfig spkCfg, AC3DynamicRange dr, BOOL enableLFE)
//			{AC3Decoder::SetAC3Config(spkCfg, dr, enableLFE);}
//
//		void GetAC3Config(AC3SpeakerConfig &spkCfg, AC3DynamicRange &dr, BOOL &enableLFE)
//			{AC3Decoder::GetAC3Config(spkCfg, dr, enableLFE);}

	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\DVDStreamDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef DVDSTREAMDECODER_H
#define DVDSTREAMDECODER_H

#include "mpegdecoder\MPEGVideoStreamDecoder.h"
#include "ac3decoder\AC3StreamDecoder.h"
#include "LPCMDecoder\LPCMStreamDecoder.h"
#include "MPEGAudioDecoder\MPEGAudioStreamDecoder.h"
#include "spudecoder\SPUStreamDecoder.h"
#include "common\TimedFibers.h"
#include "audio\DTSStreamDecoder.h"
#include "closedcaption\ClosedCaptionDecoder.h"
#include "library\hardware\mpeg2dec\generic\mp2eldec.h"

enum DVDStreamType
	{
	DVST_ELEMENTARY_AUDIO_STREAM,
	DVST_ELEMENTARY_VIDEO_STREAM,
	DVST_PROGRAM_STREAM
	};

enum DVDSplitStreamType
	{
	DVSST_DVD_ENCRYPTED,
	DVSST_PROGRAM,
	DVSST_PES,
	DVSST_ELEMENTARY
	};

enum DVDElementaryStreamType
	{
	DVEST_VIDEO,
	DVEST_AUDIO,
	DVEST_SUBPICTURE,
	DVEST_MULTIPLEXED
	};

class DVDStreamDecoder;

class GenericDecryptor
	{
	public:
		virtual void DecryptBlock(BYTE * block, BYTE * target) = 0;
	};

class EmbeddedMPEGVideoStreamDecoder : public MPEGVideoStreamDecoder
	{
	protected:
		DVDStreamDecoder	*	dvdDecoder;
	public:
		EmbeddedMPEGVideoStreamDecoder(GenericPictureDisplay * display,
										GenericSliceParser * highQualitySliceParser,
			                            GenericSliceParser * lowQualitySliceParser,
										DVDStreamDecoder * dvdDecoder,
										GenericProfile * globalProfile,
										GenericProfile * profile,
										StreamFlipCopy * streamFlipCopy);
		void RefillRequest(void);
		void StreamCompleted(void);
		void ScanCompleted(void);
	};

class EmbeddedAC3StreamDecoder : public AC3StreamDecoder
	{
	protected:
		DVDStreamDecoder	*	dvdDecoder;
	public:
		EmbeddedAC3StreamDecoder(PCMWaveOut * pcmWaveOut,
									TimingSlave * timingSlave,
									DVDStreamDecoder * dvdDecoder,
									GenericProfile * globalProfile,
									GenericProfile * profile,
									StreamFlipCopy * streamFlipCopy);
		void RefillRequest(void);
		void StreamCompleted(void);

		void SetDigitalOut(AudioTypeConfig ac3AudioType)
			{AC3StreamDecoder::SetDigitalOut(ac3AudioType);}
		void GetDigitalOut(AudioTypeConfig & ac3AudioType)
			{AC3StreamDecoder::GetDigitalOut(ac3AudioType);}

		void SetAC3Config(AC3DynamicRange dr, BOOL enableLFE)
			{AC3StreamDecoder::SetAC3Config(dr, enableLFE);}
		void GetAC3Config(AC3DynamicRange &dr, BOOL &enableLFE)
			{AC3StreamDecoder::GetAC3Config(dr, enableLFE);}

		void SetDolbyTestMode(AC3OperationalMode op, WORD hf, WORD lf, AC3DialogNorm dn)
			{AC3StreamDecoder::SetDolbyTestMode(op, hf, lf, dn);}
		void GetDolbyTestMode(AC3OperationalMode &op, WORD &hf, WORD &lf, AC3DialogNorm &dn)
			{AC3StreamDecoder::GetDolbyTestMode(op, hf, lf, dn);}
	};


class EmbeddedDTSStreamDecoder : public DTSStreamDecoder
	{
	protected:
		DVDStreamDecoder	*	dvdDecoder;
	public:
		EmbeddedDTSStreamDecoder(PCMWaveOut * pcmWaveOut,
									TimingSlave * timingSlave,
									DVDStreamDecoder * dvdDecoder,
									GenericProfile * globalProfile,
									GenericProfile * profile,
									StreamFlipCopy * streamFlipCopy);
		void RefillRequest(void);
		void StreamCompleted(void);
		void SetDigitalOut(AudioTypeConfig ac3AudioType)
			{DTSStreamDecoder::SetDigitalOut(ac3AudioType);}
		void GetDigitalOut(AudioTypeConfig & ac3AudioType)
			{DTSStreamDecoder::GetDigitalOut(ac3AudioType);}
	};


class EmbeddedMPEGAudioStreamDecoder : public MPEGAudioStreamDecoder
	{
	protected:
		DVDStreamDecoder	*	dvdDecoder;
	public:
		EmbeddedMPEGAudioStreamDecoder(PCMWaveOut * pcmWaveOut,
										TimingSlave * timingSlave,
										DVDStreamDecoder * dvdDecoder,
										GenericProfile * globalProfile,
										GenericProfile * profile,
										StreamFlipCopy * streamFlipCopy);
		void RefillRequest(void);
		void StreamCompleted(void);
	};

class EmbeddedLPCMStreamDecoder : public LPCMStreamDecoder
	{
	protected:
		DVDStreamDecoder	*	dvdDecoder;
	public:
		EmbeddedLPCMStreamDecoder(PCMWaveOut * pcmWaveOut,
									TimingSlave * timingSlave,
									DVDStreamDecoder * dvdDecoder,
									StreamFlipCopy * streamFlipCopy);
		void RefillRequest(void);
		void StreamCompleted(void);
	};

class EmbeddedSPUStreamDecoder : public SPUStreamDecoder
	{
	protected:
		DVDStreamDecoder	*	dvdDecoder;
	public:
		EmbeddedSPUStreamDecoder(SPUDisplay * display,
			                      DVDStreamDecoder * dvdDecoder);

		void RefillRequest(void);
	};

class DVDPositionTracker
	{
	protected:
		struct Track
			{
			__int64	mux, elem;
			} * track;

		int first, last, num, mask, prev;

	public:
		DVDPositionTracker(int num);
		~DVDPositionTracker(void);

		void Flush(void);

		void AddTrack(__int64 mux, __int64 elem);
		__int64 MuxToElem(__int64 mux);
		__int64 ElemToMux(__int64 elem);
	};

class DVDStreamDecoder : private TimedFiber
	{
	friend class EmbeddedMPEGVideoStreamDecoder;
	friend class EmbeddedAC3StreamDecoder;
	friend class EmbeddedDTSStreamDecoder;
	friend class EmbeddedMPEGAudioStreamDecoder;
	friend class EmbeddedSPUStreamDecoder;
	friend class EmbeddedLPCMStreamDecoder;
	protected:
		BYTE						videoStreamID;
		BYTE						audioStreamID;
		BYTE						ac3StreamID;
		BYTE						dtsStreamID;
		BYTE						spuStreamID;
		BYTE						lpcmStreamID;

		bool						streamingCompleted;
		bool						terminate;
		bool						hurryUp;
		bool						initialAudioPacket;

		bool						dataCompleted, splitCompletion;
		bool						highQuality;

		TimedFiberEvent				bufferMonitorEvent;
		TimedFiberMutex			lock;

		MPEG2AudioType				audioType;
		int							samplesPerSecond;
		int							bitsPerSample;
		int							channels;

		DVDStreamType				streamType;

		enum PESState {idle, videoData, audioData, audioHeaderMpeg, audioDataMpeg, spuData};
		struct MPEParse
			{
			int						pesRest, pesSkip, pesOffset;
			PESState				pesState;
			int						endPTM, ptsOffset;

			BYTE					decBuffer[1920];
			bool					encryptedBlock;
			DVDSplitStreamType		streamType;
			bool					completing, completed;

			struct
				{
				int			state;

				WORD		cnt;
				DWORD		length;
				BYTE		high, low;
				BYTE		headerLength, headerRest;
				BYTE		streamID;
				BYTE		flags, xflags;
				BYTE		ptss[5];
				DWORD		pts;
				bool		ptsValid;
				DWORD		dts;
				bool		dtsValid;

				bool		mpeg2;
  				} mpparse;

			volatile MPEGDataSizePair	*	pendingPairs;
			volatile BYTE				*	pendingData;
			volatile DWORD					pendingNum;
			volatile int					pendingTimeStamp;
			HANDLE							dataEvent;

			} mpeparse[4];


		bool								streaming, running, deferedRunning;
		VideoPlaybackMode					playbackMode;
		int									initialVideoTime;
		int									playbackSpeed;
		int									playbackTimeOffset;
		int									initTimeStamp;

		PCMWaveOut							pcmWaveOut;

		GenericAudioPlaybackDevice		*	audioPlaybackDevice;
		EmbeddedMPEGVideoStreamDecoder		videoDecoder;
		EmbeddedAC3StreamDecoder			ac3Decoder;
		EmbeddedDTSStreamDecoder			dtsDecoder;
		EmbeddedMPEGAudioStreamDecoder		mpegAudioDecoder;
		EmbeddedLPCMStreamDecoder			lpcmDecoder;
		EmbeddedSPUStreamDecoder			spuDecoder;
		GenericPictureDisplay			*	display;

		AudioStreamDecoder				*	audioDecoder;
		ClosedCaptionDecoder			*	ccDecoder;

		DVDPositionTracker					audioTracker;
		DVDPositionTracker					videoTracker;

		GenericDecryptor				*	decryptor;
		HANDLE								cinemSupDriver;

		DWORD								lastCheckTime;
		__int64								lastCheckValue;

		void InternalAdvance(MPEParse * mp, int by, BYTE * & ptr, DWORD & num);
		BYTE InternalGetData(MPEParse * mp, int at, BYTE * ptr);

		DWORD InternalSendData(BYTE * ptr, DWORD num);
		DWORD InternalSendDataSplit(DVDElementaryStreamType type, BYTE * ptr, DWORD num, int timeStamp);

		class Supervisor : public TimedFiber
			{
			protected:
				DVDStreamDecoder * decoder;
			public:
				Supervisor(DVDStreamDecoder * decoder);
				void FiberRoutine(void);
			} supervisor;

		friend class DVDStreamDecoder::Supervisor;

		void FiberRoutine(void);
		void SupervisorFiberRoutine(void);

		__int64	audioInputPos, videoInputPos, spuInputPos, streamInputPos, streamInputOffset;
		int		vobuInputPos;
		__int64	signalPos;
		int previousRefillRequestTime;

		virtual void SignalReached(__int64 signalPos) {}
		virtual void StreamCompleted(DVDElementaryStreamType type) {}

		__int64 InternalCurrentLocation(void);
		void InternalRefillRequest(void);

		void FlushBuffer(void);
		void CheckSignal(void);
		void ScanCompleted(void);

		bool EnoughStreamsCompleteToStart(void);
		void DeferedStartStreaming(void);
		void ShutDownSupervisor(void);
	public:
		DVDStreamDecoder(GenericPictureDisplay * display,
							  GenericSliceParser * highQualitySliceParser,
			              GenericSliceParser * lowQualitySliceParser,
							  GenericAudioPlaybackDevice * audioPlaybackDevice,
							  SPUDisplay * spuDisplay,
							  GenericProfile * globalProfile,
							  GenericProfile * profile,
							  ClosedCaptionDecoder * ccDecoder,
							  StreamFlipCopy * streamFlipCopy,
							  GenericDecryptor * decryptor = NULL);
		~DVDStreamDecoder(void);

		void SetStreamID(BYTE videoStreamID, BYTE ac3StreamID, BYTE audioStreamID, BYTE lpcmStreamID, BYTE spuStreamID, BYTE dtsStreamID);

		void SetAudioCodingMode(MPEG2AudioType type, int samplesPerSecond, int bitsPerSample, int channels);
		void SetAudioOutConfig(AC3SpeakerConfig spkCfg, AC3DualModeConfig dualModeCfg, AC3KaraokeConfig karaokeCfg);
//#if DOLBY_TEST_MODE
//		void SetDolbyTestMode(AC3OperationalMode op, WORD hf, WORD lf, AC3DialogNorm dn);
//		void GetDolbyTestMode(AC3OperationalMode &op, WORD &hf, WORD &lf, AC3DialogNorm &dn);
//#endif DOLBY_TEST_MODE
//		void SetAC3Config(AC3DynamicRange dr, BOOL enableLFE);
//		void GetAC3Config(AC3DynamicRange &dr, BOOL &enableLFE);

		void SetLine21Decoder(Line21Decoder * line21Decoder) {videoDecoder.SetLine21Decoder(line21Decoder);}

		void SetStreamType(DVDStreamType streamType) {this->streamType = streamType;}

		void BeginStreaming(VideoPlaybackMode playbackMode, bool highQuality, __int64 start = 0);
		void StartStreaming(int playbackSpeed);
		void StopStreaming(void);
		void EndStreaming(bool fullReset);

		void AdvanceFrame(void);
		void AdvanceTrickFrame(int by);
		void EnableSPU(bool enable);
		void SetDVDDemux(bool dvdDemux);
		void SetSplitStreamType(DVDElementaryStreamType type, DVDSplitStreamType streamType);

		DWORD SendData(BYTE * ptr, DWORD num);
		DWORD SendDataSplit(DVDElementaryStreamType type, BYTE * ptr, DWORD num, int timeStamp);
		DWORD SendDataMultiple(MPEGDataSizePair * data, DWORD size);
		DWORD SendDataSplitMultiple(DVDElementaryStreamType type, MPEGDataSizePair * data, DWORD size);
		void CompleteData(void);
		void CompleteDataSplit(DVDElementaryStreamType type);
		void RestartDataSplit(DVDElementaryStreamType type);

		__int64 CurrentLocation(void);
		__int64 CurrentInputLocation(void) {return streamInputPos + streamInputOffset;}
		int CurrentPlaybackTime(void);

		void SetSignalPosition(__int64 pos);
		DWORD VideoSegmentRequested(void);
		void SetFirstVideoSegment(DWORD seg);
		void SetLastVideoSegment(DWORD seg);

		virtual void RefillRequest(void) = 0;

		bool StreamingCompleted(void) {return streamingCompleted;}
		void SetErrorMessenger(ASyncErrorMessenger * errorMessenger)
			{
			display->SetErrorMessenger(errorMessenger);
			videoDecoder.SetErrorMessenger(errorMessenger);
			}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\DVDStreamDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "DVDStreamDecoder.h"
#include "library\common\vddebug.h"
#include "common\PerformanceMonitor.h"

#define AUDIO_DUMP						0
#define VIDEO_DUMP						0
#define INDUCE_ERRORS_IN_BITSTREAM	0
#define DUMP_STREAM_EVENTS				0

#if DUMP_STREAM_EVENTS
void DTE(char * p)
	{
	char buffer[100];
	wsprintf(buffer, "%8d %s\n", GetInternalTime(), p);
	OutputDebugString(buffer);
	}
#else
void DTE(char * p)
	{
	}
#endif

//
// MPEG 2 program stream demultiplexing
//
// see ISO/IEC 13818-1
//

// ProgramStream 		::=	{PackHeader Packet}
// PackHeader		   ::=   PackStartCode:32 01:2 SCR:42 ProgramMuxRate:22 pad:5 PackStuffingLength::3 PackStuffingByte::x
// 								SystemHeader {PESPacket}
// SystemHeader		::=	SystemHeaderStartCode:32 HeaderLength:16 RateBound:22 AudioBound:6 FixedFlag:1 CSPSFlag:1
// 								AudioLockFlag:1 VideoLockFlag:1 VideoBound:5 NLoop:24*n
// NLoop					::=	StreamID:8 11:2 BufferBoundScale:1 BufferSizeBound:13
//
// PESPacket			::=	PacketStartCodePrefix:24 StreamID:8 PESPacketLength:16 OptionalPESHeader PESDataBytes
// OptionalPESHeader	::=	10:2 PESScramblingControl:2 PESPriority:1 DataAlignmentIndicator:1 Copyright:1
// 								OriginalOrCopy:1 SevenFlags:8 PESHeaderDataLength:8 OptionalFields1 Stuffing:8*n
// OptionalFields1	::=	PTS_DTS:33 ESCR:42 ESRate:22 DSMTrickMode:8 AdditionalCopyInfo:7 PreviousOESCRC:16 PESExtension
// PESExtension		::=	FiveFlags:5 OptionalFields2
// OptionalFields2	::=	PESPrivateData:128 PackHeaderField:8 ProgramPacketSeqCntr:8 PSTDBuffer:16
// 								PESExtensionFieldLength:7 PESExtensionField
// ProgramStreamMap	::=	PacketStartCodePrefix:24 MapStreamID:8 ProgramStreamMapLength:16

//
// 0 : 0
// 1 : 1
// # : Value
// X : Don't care
//

#define M0	1
#define M1	1
#define MX	0
#define V0	0
#define V1	1
#define VX	0

#define MKBCX(name, val) static const WORD B##name	= val;
#define MKBC(a7,a6,a5,a4,a3,a2,a1,a0) MKBCX(a7##a6##a5##a4##a3##a2##a1##a0, \
	(V##a7<<7) | (V##a6<<6) | (V##a5<<5) | (V##a4<<4) | (V##a3<<3) | (V##a2<<2) | (V##a1<<1) | V##a0 |	\
	(M##a7<<15) | (M##a6<<14) | (M##a5<<13) | (M##a4<<12) | (M##a3<<11) | (M##a2<<10) | (M##a1<<9) | (M##a0 << 8))

MKBC(0,0,0,0,0,0,0,0)
MKBC(0,0,0,0,0,0,0,1)
MKBC(0,0,0,0,1,1,1,1)
MKBC(0,0,0,1,X,X,X,1)
MKBC(0,0,1,0,X,X,X,1)
MKBC(0,0,1,1,X,X,X,1)
MKBC(0,1,X,X,X,1,X,X)
MKBC(0,1,X,X,X,X,X,X)
MKBC(1,0,1,1,1,0,0,1)
MKBC(1,0,1,1,1,0,1,0)
MKBC(1,0,1,1,1,0,1,1)
MKBC(1,0,X,X,X,X,X,X)
MKBC(1,1,X,X,X,X,X,X)
MKBC(1,1,1,1,1,1,1,1)
MKBC(1,X,X,X,X,X,X,X)
MKBC(X,1,X,X,X,X,X,X)
MKBC(X,X,1,X,X,X,X,X)
MKBC(X,X,X,1,X,X,X,X)
MKBC(X,X,X,X,1,X,X,X)
MKBC(X,X,X,X,X,1,X,X)
MKBC(X,X,X,X,X,X,1,X)
MKBC(X,X,X,X,X,X,1,1)
MKBC(X,X,X,X,X,X,X,1)
MKBC(X,X,X,X,X,X,X,X)


enum MPEG2ProgramParse {
	PROGSTRM_INITIAL,             //
	PROGSTRM_FINAL,					//

	PROGSTRM_PACKSTART0,          // 00000000
	PROGSTRM_PACKSTART1,				// 00000000
	PROGSTRM_PACKSTART2,				// 00000000
	PROGSTRM_PACKSTART3,				// 10111010 goto PACKHEADER_BYTE0
											// 10111001 goto PROGSTRM_FINAL

	MP1PACKHDR_BYTE1,					// ######## SysClockRef [29..22]
	MP1PACKHDR_BYTE2,					// #######  SysClockRef [21..15]
	                              //        1
	MP1PACKHDR_BYTE3,					// ######## SysClockRef [14..7]
	MP1PACKHDR_BYTE4,					// #######  SysClockRef [6..0]
											//        1
	MP1PACKHDR_BYTE5,					// 1
											//  ####### MuxRate[21..15]
	MP1PACKHDR_BYTE6,					// ######## MuxRate[14..7]
	MP1PACKHDR_BYTE7,					// #######  MuxRate[6..0]
											//        1
											// goto PESPACKET_STARTCODEPREFIX0

	PACKHEADER_BYTE0,					// if (01XXXXXX)
											//	01
											//   ###    SysClockRef [32..30]
											//      1
											//       ## SysClockRef [29..28]
											// mpeg2 = TRUE;
											// goto PACKHEADER_BYTE1
											// else if (0010XXXX)
											// 0010
											//     ###  SysClockRef [32..30]
											//        1
											// goto MP1PACKHDR_BYE1

	PACKHEADER_BYTE1,					// ######## SysClockRef [27..20]
	PACKHEADER_BYTE2,					// #####    SysClockRef [19..15]
	                              //      1
	                              //       ## SysClockRef [14..13]
	PACKHEADER_BYTE3,					// ######## SysClockRef [12..5]
	PACKHEADER_BYTE4,					// #####    SysClockRef [4..0]
											//      1
											//       ## SysClockRefExt [8..7]
	PACKHEADER_BYTE5,					// #######  SysClockRefExt [6..0]
											//        1
	PACKHEADER_BYTE6,					// ######## MuxRate[21..14]
	PACKHEADER_BYTE7,					// ######## MuxRate[13..6]
	PACKHEADER_BYTE8,					// ######   MuxRate[5..0]
											//       11
	PACKHEADER_BYTE9,					// XXXXX
											//      ### PackStuffingLength
	PACKHEADER_STUFFING,				// XXXXXXXX times PackStuffingLength
											// goto PESPACKET_STARTCODEPREFIX0

   SYSTEMHEADER_LENGTH0,			// ########
   SYSTEMHEADER_LENGTH1,			// ########
   SYSTEMHEADER_BYTE0,				// 1
   										//  ####### RateBound[21..15]
   SYSTEMHEADER_BYTE1,				// ######## RateBound[14..7]
   SYSTEMHEADER_BYTE2,				// #######  RateBound[6..0]
   										//        1
   SYSTEMHEADER_BYTE3,				// ######   AudioBound
   										//       #  FixedFlag
											//        # CSPSFlag
	SYSTEMHEADER_BYTE4,				// #        SystemAudioLockFlag
											//  #       SystemVideoLockFlag
											//   1      MarkerBit
											//    ##### VideoBound
	SYSTEMHEADER_BYTE5,				// #        PacketRateRestrictionBit
											//  XXXXXXX
	SYSTEMHEADER_BYTE6,				// 00000000 goto PESPACKET_STARTCODEPREFIX1
											// 1####### StreamID
	SYSTEMHEADER_STREAM0,			// 11
											//   #      PSTDBufferBoundScale
											//    ##### PSTDBufferSizeBound [12..8]
	SYSTEMHEADER_STREAM1,			// ######## PSTDBufferSizeBound [7..0]
											// goto SYSTEMHEADER_BYTE6

	PESPACKET_STARTCODEPREFIX0,	// 00000000
	PESPACKET_STARTCODEPREFIX1,	// 00000000
	PESPACKET_STARTCODEPREFIX2,	// 00000001
	PESPACKET_STREAMID,				// 10111011 goto SYSTEMHEADER_LENGTH0
											// 10111010 goto PACKHEADER_BYTE0
											// 10111001 goto PROGSTRM_FINAL
											// else
											// ######## streamID
	PESPACKET_LENGTH0,				// ########
	PESPACKET_LENGTH1,				// ########
											// if streamID != 10111101 &&
											//    streamID != videoStreamID && streamID != audioStreamID goto PESPACKET_SKIP
											// mpeg2 goto PESPACKET_HEADER0

	MP1PACKET_HEADER0,				// if (11111111) goto MP1PACKET_HEADER0
											// if (01XXXXXX) goto MP1PACKET_HEADER1
											// if (0010XXXX)
											// 0010
											//     ###  PTS[32..30]
											//        1 goto MP1PACKET_HEADER2
											// if (0011XXXX)
											// 0011
											//		 ###  PTS[32..30]
											//        1 goto MP1PACKET_HEADER6
											//	else
											// 00001111
											// goto MP1PACKET_DATA
	MP1PACKET_HEADER1,				// XXXXXXXX	goto MP1PACKET_HEADER0
	MP1PACKET_HEADER2,				// ######## PTS[29..22]
	MP1PACKET_HEADER3,				// #######  PTS[21..15]
											//        1
	MP1PACKET_HEADER4,				// ######## PTS[14..7]
	MP1PACKET_HEADER5,				// #######  PTS[6..0]
											//        1
											// goto MP1PACKET_DATA
	MP1PACKET_HEADER6,				// ######## PTS[29..22]
	MP1PACKET_HEADER7,				// #######  PTS[21..15]
											//        1
	MP1PACKET_HEADER8,				// ######## PTS[14..7]
	MP1PACKET_HEADER9,				// #######  PTS[6..0]
											//        1
	MP1PACKET_HEADER10,				// 0001
											//     ###  DTS[32..30]
											//        1
	MP1PACKET_HEADER11,				// ######## DTS[29..22]
	MP1PACKET_HEADER12,				// #######  DTS[21..15]
											//        1
	MP1PACKET_HEADER13,           // ######## DTS[14..7]
	MP1PACKET_HEADER14,           // #######  DTS[6..0]
	                              //        1
	                              // goto MP1PACKET_DATA

	PESPACKET_HEADER0,				// 10
											//   ##     Scrambling control
											//     #    Priority
											//      #   Data alignment
											//       #  Copyright
											//        # OriginalOrCopy
	PESPACKET_HEADER1,				// ##       PTSDTSFlags
											//   #      ESCRFlag
											//    #     ESRateFlag
											//     #    DSMTrickModeFlag
											//      #   AdditionalCopyInfoFlag
											//       #  PESCRCFlag
											//        # PESExtensionFlag
	PESPACKET_HEADER2,				// ######## PESHeaderDataLength

// if PTSDTSFlags == 10

	PESPACKET_HEADER3,				// 0010
											//     ###  PTS[32..30]
											//        1
	PESPACKET_HEADER4,				// ######## PTS[22..29]
	PESPACKET_HEADER5,				// #######  PTS[15..21]
											//        1
	PESPACKET_HEADER6,				// ######## PTS[14..7]
	PESPACKET_HEADER7,				// #######  PTS[0..6]
											//        1

// if PTSDTSFlags == 11

	PESPACKET_HEADER8,				// 0011
											//     ###	PTS[32..30]
											//        1
	PESPACKET_HEADER9, 				// ######## PTS[22..29]
	PESPACKET_HEADER10,				// #######  PTS[15..21]
											//        1
	PESPACKET_HEADER11,				// ######## PTS[14..7]
	PESPACKET_HEADER12,				// #######  PTS[0..6]
											//        1
	PESPACKET_HEADER13,				// 0001
											//     ###  DST[32..30]
											//        1
	PESPACKET_HEADER14,				// ######## DTS[22..29]
	PESPACKET_HEADER15,				// #######  DTS[15..21]
											//        1
	PESPACKET_HEADER16,				// ######## DTS[14..7]
	PESPACKET_HEADER17,				// #######  DTS[0..6]
											//        1

// if ESCRFlag

	PESPACKET_HEADER18,				// XX
											//   ###    ESCR[32..30]
											//      1
											//       ## ESCR[29..28]
	PESPACKET_HEADER19,				// ######## ESCR[27..20]
	PESPACKET_HEADER20,				// #####    ESCR[19..15]
											//      1
// PESPACKET_HEADER21 intentionaly left blank
	PESPACKET_HEADER22,				// ######## ESCR[12..5]
	PESPACKET_HEADER23,				// #####    ESCR[4..0]
											//      1
											//       ## ESCRX[8..7]
	PESPACKET_HEADER24,				// #######  ESCRX[6..0]
											//        1

// if ESRateFlag

	PESPACKET_HEADER25,				// 1
											//  ####### ESRATE[14..21]
	PESPACKET_HEADER26,				// ######## ESRATE[14..7]
	PESPACKET_HEADER27,				// #######  ESRATE[6..0]
											//        1

// if DSMTrickModeFlag

	PESPACKET_HEADER28,				// ###      TrickModeControl

											//    ##    FieldID
											//      #   IntraSlizeRefresh
											//       ## FrequencyTruncation
											//    ##### RepCntrl
											//    ##    FieldID
											//      ### Reserved

// if AdditionalCopyInfoFlag

	PESPACKET_HEADER29,				// 1
											//  ####### AdditionalCopyInfo


// if PESCRCFlag

	PESPACKET_HEADER30,				// ######## CRC[15..8]
	PESPACKET_HEADER31,				// ######## CRC[7..0]

// if PESExtensionFlag

	PESPACKET_HEADER32,				// #        PESPrivateDataFlag
											//  #       PackHeaderFieldFlag
											//   #      ProgramPacketSequenceCounterFlag
											//    #     PSTDBufferFlag
											//     XXX
											//        # PESExtensionFlag2

	// if PESPrivateDataFlag

	PESPACKET_PRIVATEDATA,			// label,,, :-)
	PESPACKET_PRIVATESKIP,			// XXXXXXXX times 32

	// if PackHeaderFieldFlag

	PESPACKET_PACKFIELDLENGTH,		// XXXXXXXX PackFieldLength

	PESPACKET_PACKHEDADER,			// ######## times PackFieldLength

	// if ProgramPacketSequenceCounterFlag

	PESPACKET_HEADER33,				// 1
											//  ####### ProgramPacketSequenceCounter
	PESPACKET_HEADER34,				// 1
											//  #       MPEG12Identifier
											//   ###### OriginalStuffLength

	// if PSTDBufferFlag

	PESPACKET_HEADER35,				// 01
											//   #      PSTDBufferScale
											//    ##### PSTDBufferSize[13..8]
	PESPACKET_HEADER36,				// ######## PSTDBufferSize[7..0]

	// if PESExtensionFlag2

	PESPACKET_HEADER37,				// 1
											//  ####### PESExtensionFieldLength
	PESPACKET_EXTENSIONFIELD,		// XXXXXXXX times PESExtensionFieldLength

	PESPACKET_STUFFING,				// XXXXXXXX times rest of PESHeaderDataLength

	PESPACKET_DATA,					// XXXXXXXX times PESPacketLength - 3 - PESHeaderDataLength
											// goto PESPACKET_STARTCODEPREFIX0
	MP1PACKET_DATA,					// ....
	PESPACKET_VIDEO,					// ######## times PESPacketlength - 3 - PESHeaderDataLength
											// goto PESPACKET_STARTCODEPREFIX1
	PESPACKET_AUDIO,					// ######## times PESPacketLength - 3 - PESHeaderDataLength
											// goto PESPACKET_STARTCODEPREFIX2
	PESPACKET_SKIP,					// ######## times PESPacketLength
	PESPACKET_PRIVATE,				// if ######## != AC3 GOTO PESPACKET_SKIP

	PESPACKET_AC3_SKIP0,				// 2*XXXXXXXX
	PESPACKET_AC3_SKIP1,				// 2*XXXXXXXX
	PESPACKET_AC3_SKIP2,				// 2*XXXXXXXX
	PESPACKET_AC3_SKIP3,				// 2*XXXXXXXX
	PESPACKET_AC3,						// ######## times PESPacketLength - 4 - PESHeaderDataLength
											// goto PESPACKET_STARTCODEPREFIX2

	PESPACKET_LPCM_SKIP0,			// 2*XXXXXXXX
	PESPACKET_LPCM_SKIP1,			// 2*XXXXXXXX
	PESPACKET_LPCM_SKIP2,			// 2*XXXXXXXX
	PESPACKET_LPCM_SKIP3,			// 2*XXXXXXXX
	PESPACKET_LPCM,					// ######## times PESPacketLength - 4 - PESHeaderDataLength
											// goto PESPACKET_STARTCODEPREFIX2

	PESPACKET_SUBPICTURE,			// ######## times PESPacketLength - 4 - PESHeaderDataLength
	PROGSTRM_RECOVER1,            // if !00000000 GOTO PROGSTRM_RECOVER1
	PROGSTRM_RECOVER2,            // if !00000000 GOTO PROGSTRM_RECOVER1
	PROGSTRM_RECOVER3,				// if !00000001 GOTO PROGSTRM_RECOVER1
	PROGSTRM_RECOVER4,				//	if !10111010 GOTO PROGSTRM_RECOVER1 else GOTO PACKHEADER_BYTE0

	DVDSTRM_PACKETSTART,
	DVDSTRM_VIDEOPACKET,
	DVDSTRM_VIDEOPESPACKET,
	DVDSTRM_AUDIOPACKET,
	DVDSTRM_AUDIOPESPACKET,
	DVDSTRM_AC3PACKET,
	DVDSTRM_AC3PESPACKET,
	DVDSTRM_LPCMPACKET,
	DVDSTRM_LPCMPESPACKET,
	DVDSTRM_SPUPACKET,
	DVDSTRM_SPUPESPACKET,
	DVDSTRM_STUFFING
	};

////////////////////////////////////////////////////////////////////
//
//  DVD Position Tracker
//
////////////////////////////////////////////////////////////////////

DVDPositionTracker::DVDPositionTracker(int num)
	{
	int i;

	i = 0;
	while (num)
		{
		i++;
		num >>= 1;
		}

	this->num = 1 << i;
	this->mask = this->num - 1;

	track = new Track[this->num];
	first = last = prev = 0;
	}

DVDPositionTracker::~DVDPositionTracker(void)
	{
	delete[] track;
	}

void DVDPositionTracker::Flush(void)
	{
	first = last = prev = 0;
	}

void DVDPositionTracker::AddTrack(__int64 mux, __int64 elem)
	{
	int prev = (last + num - 1) & mask;

	if (last == first || mux - track[prev].mux > 10000 || elem - track[prev].elem > 9000)
		{
		int next = (last + 1) & mask;
		track[last].mux = mux;
		track[last].elem = elem;
		if (first == next) first = (first+1) % num;
		last = next;
		}
	}

__int64 DVDPositionTracker::MuxToElem(__int64 mux)
	{
	int i = first;
	__int64 elem = 0;

	while (i != last && track[i].mux <= mux) {elem = track[i].elem; i = (i+1) & mask;}

	return elem;
	}

__int64 DVDPositionTracker::ElemToMux(__int64 elem)
	{
	int i = prev;
	__int64 mux = 0;
	__int64 pred = 0;

	if (i < first && i >= last)
		i = first;
	else if (track[i].elem >= elem)
		i = first;

	mux = track[i].mux;

	while (i != last && track[i].elem < elem)
		{
		pred = track[i].elem;
		mux = track[i].mux;
		i = (i+1) & mask;
		}

	if (i == last)
		return -1;
	else if (i != first)
		{
		prev = (i - 1) & mask;
		if (track[i].elem == pred)
			return mux;
		else
			return mux + (int)(elem - pred) * (int)(track[i].mux - mux) / (int)(track[i].elem - pred);
		}
	else
		return track[i].mux;
	}

////////////////////////////////////////////////////////////////////
//
//  Embedded MPEG Video Stream Decoder
//
////////////////////////////////////////////////////////////////////

EmbeddedMPEGVideoStreamDecoder::EmbeddedMPEGVideoStreamDecoder
                              (GenericPictureDisplay * display,
								GenericSliceParser * highQualitySliceParser,
			                    GenericSliceParser * lowQualitySliceParser,
								DVDStreamDecoder * dvdDecoder,
								GenericProfile * globalProfile,
								GenericProfile * profile,
								StreamFlipCopy * streamFlipCopy)
								: MPEGVideoStreamDecoder(display, highQualitySliceParser, lowQualitySliceParser, globalProfile, profile, streamFlipCopy)
	{
	this->dvdDecoder = dvdDecoder;
	}

void EmbeddedMPEGVideoStreamDecoder::RefillRequest(void)
	{
	dvdDecoder->InternalRefillRequest();
	}

void EmbeddedMPEGVideoStreamDecoder::StreamCompleted(void)
	{
	dvdDecoder->CheckSignal();
	}

void EmbeddedMPEGVideoStreamDecoder::ScanCompleted(void)
	{
	dvdDecoder->ScanCompleted();
	}

////////////////////////////////////////////////////////////////////
//
//  Embedded AC3 Stream Decoder
//
////////////////////////////////////////////////////////////////////

EmbeddedAC3StreamDecoder::EmbeddedAC3StreamDecoder(PCMWaveOut * pcmWaveOut,
													TimingSlave * timingSlave,
										            DVDStreamDecoder * dvdDecoder,
													GenericProfile * globalProfile,
													GenericProfile * profile,
													StreamFlipCopy * streamFlipCopy)
													: AC3StreamDecoder(pcmWaveOut, timingSlave, globalProfile, profile, streamFlipCopy)
	{
	this->dvdDecoder = dvdDecoder;
	}

void EmbeddedAC3StreamDecoder::RefillRequest(void)
	{
	dvdDecoder->InternalRefillRequest();
	}

void EmbeddedAC3StreamDecoder::StreamCompleted(void)
	{
	dvdDecoder->CheckSignal();
	}

////////////////////////////////////////////////////////////////////
//
//  Embedded DTS Stream Decoder
//
////////////////////////////////////////////////////////////////////

EmbeddedDTSStreamDecoder::EmbeddedDTSStreamDecoder(PCMWaveOut * pcmWaveOut,
														TimingSlave * timingSlave,
														DVDStreamDecoder * dvdDecoder,
														GenericProfile * globalProfile,
														GenericProfile * profile,
														StreamFlipCopy * streamFlipCopy)
														: DTSStreamDecoder(pcmWaveOut, timingSlave, globalProfile, profile, streamFlipCopy)
	{
	this->dvdDecoder = dvdDecoder;
	}

void EmbeddedDTSStreamDecoder::RefillRequest(void)
	{
	dvdDecoder->InternalRefillRequest();
	}

void EmbeddedDTSStreamDecoder::StreamCompleted(void)
	{
	dvdDecoder->CheckSignal();
	}


////////////////////////////////////////////////////////////////////
//
//  Embedded MPEG Audio Stream Decoder
//
////////////////////////////////////////////////////////////////////

EmbeddedMPEGAudioStreamDecoder::EmbeddedMPEGAudioStreamDecoder(PCMWaveOut * pcmWaveOut,
																TimingSlave * timingSlave,
																DVDStreamDecoder * dvdDecoder,
																GenericProfile * globalProfile,
																GenericProfile * profile,
																StreamFlipCopy * streamFlipCopy)
																: MPEGAudioStreamDecoder(pcmWaveOut, timingSlave, globalProfile, profile, streamFlipCopy)
	{
	this->dvdDecoder = dvdDecoder;
	}

void EmbeddedMPEGAudioStreamDecoder::RefillRequest(void)
	{
	dvdDecoder->InternalRefillRequest();
	}

void EmbeddedMPEGAudioStreamDecoder::StreamCompleted(void)
	{
	dvdDecoder->CheckSignal();
	}

////////////////////////////////////////////////////////////////////
//
//  Embedded LPCM Stream Decoder
//
////////////////////////////////////////////////////////////////////

EmbeddedLPCMStreamDecoder::EmbeddedLPCMStreamDecoder(PCMWaveOut * pcmWaveOut,
														TimingSlave * timingSlave,
														DVDStreamDecoder * dvdDecoder,
														StreamFlipCopy * streamFlipCopy)
														: LPCMStreamDecoder(pcmWaveOut, timingSlave, streamFlipCopy)
	{
	this->dvdDecoder = dvdDecoder;
	}

void EmbeddedLPCMStreamDecoder::RefillRequest(void)
	{
	dvdDecoder->InternalRefillRequest();
	}

void EmbeddedLPCMStreamDecoder::StreamCompleted(void)
	{
	dvdDecoder->CheckSignal();
	}

////////////////////////////////////////////////////////////////////
//
//  Embedded SPU Stream Decoder
//
////////////////////////////////////////////////////////////////////

EmbeddedSPUStreamDecoder::EmbeddedSPUStreamDecoder(SPUDisplay * display,
													DVDStreamDecoder * dvdDecoder)
													: SPUStreamDecoder(display)
	{
	this->dvdDecoder = dvdDecoder;
	}

void EmbeddedSPUStreamDecoder::RefillRequest(void)
	{
	dvdDecoder->InternalRefillRequest();
	}

////////////////////////////////////////////////////////////////////
//
//  DVD Stream Decoder
//
////////////////////////////////////////////////////////////////////

#if AUDIO_DUMP
static HANDLE audioStream;
#endif
#if VIDEO_DUMP
static HANDLE videoStream;
static int videoStreamCount;
#endif

//
//  Constructor
//

#pragma warning(disable : 4355)
#pragma warning(disable : 4786)

DVDStreamDecoder::DVDStreamDecoder(GenericPictureDisplay * display,
						GenericSliceParser * highQualitySliceParser,
						GenericSliceParser * lowQualitySliceParser,
						GenericAudioPlaybackDevice * audioPlaybackDevice,
						SPUDisplay * spuDisplay,
						GenericProfile * globalProfile,
						GenericProfile * profile,
						ClosedCaptionDecoder * ccDecoder,
						StreamFlipCopy * streamFlipCopy,
						GenericDecryptor * decryptor)
					  : pcmWaveOut(globalProfile, profile, audioPlaybackDevice, display),
						videoDecoder(display, highQualitySliceParser, lowQualitySliceParser, this, globalProfile, profile, streamFlipCopy),
						ac3Decoder(&pcmWaveOut, display, this, globalProfile, profile, streamFlipCopy),
					    dtsDecoder(&pcmWaveOut, display, this, globalProfile, profile, streamFlipCopy),
					    mpegAudioDecoder(&pcmWaveOut, display, this, globalProfile, profile, streamFlipCopy),
						lpcmDecoder(&pcmWaveOut, display, this, streamFlipCopy),
						spuDecoder(spuDisplay, this),
						audioTracker(128),
						videoTracker(256),
						bufferMonitorEvent(FALSE, TRUE),
						supervisor(this),
						TimedFiber(3)
	{
	int i;

	this->decryptor = decryptor;
	this->display = display;
	this->audioPlaybackDevice = audioPlaybackDevice;
	this->ccDecoder = ccDecoder;

	videoStreamID = 0xe0;
	ac3StreamID = 0x80;
	dtsStreamID = 0x88;
	audioStreamID = 0xc0;
	spuStreamID = 0x20;
	lpcmStreamID = 0xa0;

	audioType = MP2AUDTYP_LPCM;
	audioDecoder = &lpcmDecoder;
	samplesPerSecond = 48000;
	bitsPerSample = 16;
	channels = 2;
	initialAudioPacket = TRUE;
	deferedRunning = FALSE;

	streamType = DVST_PROGRAM_STREAM;

	FlushBuffer();

	streaming = FALSE;
	terminate = FALSE;

	for(i=0; i<4; i++)
		{
		mpeparse[i].streamType = DVSST_PROGRAM;
		mpeparse[i].dataEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
		}


#if AUDIO_DUMP
	audioStream = ::CreateFile("f:\\ac3\\strm.ac3",
							  GENERIC_WRITE,
							  FILE_SHARE_WRITE,
							  NULL,
							  CREATE_ALWAYS,
							  FILE_ATTRIBUTE_NORMAL,
							  NULL);
#endif
#if VIDEO_DUMP
		{
		char buffer[100];
		videoStreamCount = 0;
		wsprintf(buffer, "c:\\videodump\\strm%03d.mpg", videoStreamCount);

		videoStream = ::CreateFile(buffer,
								  GENERIC_WRITE,
								  FILE_SHARE_WRITE,
								  NULL,
								  CREATE_ALWAYS,
								  FILE_ATTRIBUTE_NORMAL,
								  NULL);
		}
#endif

	int type;

	for(type=0; type<4; type++)
		{
		mpeparse[type].pendingData = NULL;
		mpeparse[type].pendingPairs = NULL;
		}

	StartFiber();
	supervisor.StartFiber();

	cinemSupDriver = CreateFile("\\\\.\\CINEMSUP.SYS", 0, 0, NULL, OPEN_EXISTING,
						0, 0);

	if (cinemSupDriver == INVALID_HANDLE_VALUE) cinemSupDriver = NULL;
	}
#pragma warning(default : 4355)

//
//  Shut Down Supervisor
//

void DVDStreamDecoder::ShutDownSupervisor(void)
	{
	terminate = TRUE;
	bufferMonitorEvent.SetEvent();
	CompleteFiber();
	supervisor.CompleteFiber();
	}

//
//  Destructor
//

DVDStreamDecoder::~DVDStreamDecoder(void)
	{
	int i;

	ShutDownSupervisor();

	for(i=0; i<4; i++)
		::CloseHandle(mpeparse[i].dataEvent);
#if AUDIO_DUMP
	::CloseHandle(audioStream);
#endif
#if VIDEO_DUMP
	::CloseHandle(videoStream);
#endif

	if (cinemSupDriver) CloseHandle(cinemSupDriver);

	}

//
//  Set IDs of different streams
//

void DVDStreamDecoder::SetStreamID(BYTE videoStreamID, BYTE ac3StreamID, BYTE audioStreamID, BYTE lpcmStreamID, BYTE spuStreamID, BYTE dtsStreamID)
	{
	this->videoStreamID = videoStreamID;
	this->ac3StreamID = ac3StreamID;
	this->audioStreamID = audioStreamID;
	this->spuStreamID = spuStreamID;
	this->lpcmStreamID = lpcmStreamID;
	this->dtsStreamID = dtsStreamID;
	}

//
//  Set audio coding mode
//

void DVDStreamDecoder::SetAudioCodingMode(MPEG2AudioType type, int samplesPerSecond, int bitsPerSample, int channels)
	{
	bool forceStartStop = (type == MP2AUDTYP_LPCM) && (this->samplesPerSecond != samplesPerSecond);

	this->samplesPerSecond = samplesPerSecond;
	this->bitsPerSample = bitsPerSample;
	this->channels = channels;

	// treat mpeg2 as mpeg1 for now
	if (type == MP2AUDTYP_MPEG2)
		{
		type = MP2AUDTYP_MPEG;
		}

	if (!streaming)
		{
		audioType = type;

		switch (audioType)
			{
			case MP2AUDTYP_AC3:
				audioDecoder = &ac3Decoder;
				break;
			case MP2AUDTYP_DTS:
				audioDecoder = &dtsDecoder;
				break;
			case MP2AUDTYP_LPCM:
				audioDecoder = &lpcmDecoder;
				break;
			case MP2AUDTYP_MPEG:
				audioDecoder = &mpegAudioDecoder;
				break;
			default:
				DP("UNKNOWN AudioType %d", audioType);
				break;
			}
		}
	else
		{
		if (type != audioType || forceStartStop)
			{
//			if (running)
//				{
//				audioDecoder->StopStreaming();
//				}
			audioDecoder->DetachStreaming();

			audioType = type;

			switch (audioType)
				{
				case MP2AUDTYP_AC3:
					audioDecoder = &ac3Decoder;
					break;
				case MP2AUDTYP_DTS:
					audioDecoder = &dtsDecoder;
					break;
				case MP2AUDTYP_LPCM:
					audioDecoder = &lpcmDecoder;
					break;
				case MP2AUDTYP_MPEG:
					audioDecoder = &mpegAudioDecoder;
					break;
				default:
					DP("UNKNOWN AudioType %d", audioType);
					break;
				}

			audioDecoder->SetAudioCodingMode(samplesPerSecond, bitsPerSample, channels);

			audioDecoder->AttachStreaming();
//			if (running)
//				{
//				audioDecoder->StartStreaming(playbackSpeed);
//				}
			}
		else
			{
			audioDecoder->SetAudioCodingMode(samplesPerSecond, bitsPerSample, channels);
			}
		}
	}

//
//  Set audio Output Config
//

void DVDStreamDecoder::SetAudioOutConfig(AC3SpeakerConfig spkCfg, AC3DualModeConfig dualModeCfg, AC3KaraokeConfig karaokeCfg)
	{
	pcmWaveOut.SetAudioOutConfig(spkCfg, dualModeCfg, karaokeCfg);
	ac3Decoder.SetAudioOutConfig(spkCfg, dualModeCfg, karaokeCfg);
	lpcmDecoder.SetAudioOutConfig(spkCfg, dualModeCfg, karaokeCfg);
	mpegAudioDecoder.SetAudioOutConfig(spkCfg, dualModeCfg, karaokeCfg);
	}

//
//  Begin Streaming
//

void DVDStreamDecoder::BeginStreaming(VideoPlaybackMode playbackMode, bool highQuality, __int64 start)
	{
	this->playbackMode = playbackMode;
	this->highQuality = highQuality;

#if DUMP_STREAM_EVENTS>=1
	char buffer[100];
	wsprintf(buffer, "BeginStreaming mode %d", playbackMode);
	DTE(buffer);
#endif

	terminate = FALSE;
	signalPos = 0;
	streamInputOffset = start;
	streamingCompleted = FALSE;
	previousRefillRequestTime = 0;
	lastCheckTime = 0;
	initialVideoTime = -1;
	running = FALSE;
	splitCompletion = FALSE;
	deferedRunning = FALSE;
	initTimeStamp = 0;

	switch (streamType)
		{
		case DVST_PROGRAM_STREAM:
			audioDecoder->SetAudioCodingMode(samplesPerSecond, bitsPerSample, channels);

			videoDecoder.BeginStreaming(playbackMode, highQuality);
			if (playbackMode == VDPM_PLAY_FORWARD)
				{
				audioDecoder->BeginStreaming();
				spuDecoder.BeginStreaming(highQuality);
				if (ccDecoder) ccDecoder->BeginStreaming();
				}
			break;
		case DVST_ELEMENTARY_AUDIO_STREAM:
			audioDecoder->SetAudioCodingMode(samplesPerSecond, bitsPerSample, channels);
			audioDecoder->BeginStreaming();
			break;
		case DVST_ELEMENTARY_VIDEO_STREAM:
			videoDecoder.BeginStreaming(playbackMode, highQuality);
			break;
		}

	streaming = TRUE;

#if DUMP_STREAM_EVENTS>=1
	DTE("BeginStreaming done");
#endif
	}

//
//  Test if there are enough streams to start
//

bool DVDStreamDecoder::EnoughStreamsCompleteToStart(void)
	{
	return dataCompleted ||
		    mpeparse[DVEST_VIDEO].completed        ||
		    mpeparse[DVEST_VIDEO].completing       ||
			 mpeparse[DVEST_AUDIO].completed        ||
		    mpeparse[DVEST_AUDIO].completing       ||
			 mpeparse[DVEST_MULTIPLEXED].completed  ||
		    mpeparse[DVEST_MULTIPLEXED].completing ||
			 videoDecoder.EnoughDataToStart();
	}

//
//  Defered Start Streaming
//

void DVDStreamDecoder::DeferedStartStreaming(void)
	{
	lock.Enter();
	if (deferedRunning && !running)
		{
		switch (streamType)
			{
			case DVST_PROGRAM_STREAM:
				{
				if (playbackMode == VDPM_PLAY_FORWARD)
					{
					audioDecoder->StartStreaming(playbackSpeed);
					spuDecoder.StartStreaming(playbackSpeed);
					}
				videoDecoder.StartStreaming(playbackSpeed);

				if (ccDecoder)
				    {
				    if(playbackSpeed <= 0x10000)
				        {

                        // Playing speed is 1x (or less). It's OK to activate closed caption.
                        
				        ccDecoder->StartStreaming();
				        }
				    else
				        {

                        // Playing at higher speed (probably 2x) therefore we will not activate
                        // closed caption because it causes hiccups on the playback. We will,
                        // however, call Reset to remove any remaining captions.
				            
				        ccDecoder->Reset();
				        }
				    }

				}
				break;
			case DVST_ELEMENTARY_AUDIO_STREAM:
				audioDecoder->StartStreaming(playbackSpeed);
				break;
			case DVST_ELEMENTARY_VIDEO_STREAM:
				videoDecoder.StartStreaming(playbackSpeed);
				break;
			}

		running = TRUE;
		deferedRunning = FALSE;
		}
	lock.Leave();
	}

//
//  Start Streaming
//

void DVDStreamDecoder::StartStreaming(int playbackSpeed)
	{
#if DUMP_STREAM_EVENTS>=1
	char buffer[100];
	wsprintf(buffer, "StartStreaming %x (D %d)", playbackSpeed, streamInputPos);
	DTE(buffer);
#endif

	streamingCompleted = FALSE;
	this->playbackSpeed = playbackSpeed;

	deferedRunning = TRUE;

	if (streamInputPos > 500000 || audioInputPos > 100000 || spuInputPos > 50000 || EnoughStreamsCompleteToStart() || streamType != DVST_PROGRAM_STREAM || vobuInputPos > 2)
		DeferedStartStreaming();

#if DUMP_STREAM_EVENTS>=1
	DTE("StartStreaming done");
#endif
	}

//
//  Stop Streaming
//

void DVDStreamDecoder::StopStreaming(void)
	{
#if DUMP_STREAM_EVENTS>=1
	DTE("StopStreaming");
#endif

	if (running)
		{
		switch (streamType)
			{
			case DVST_PROGRAM_STREAM:
				videoDecoder.StopStreaming();
				if (playbackMode == VDPM_PLAY_FORWARD)
					{
					audioDecoder->StopStreaming();
					spuDecoder.StopStreaming();
					if (ccDecoder && (playbackSpeed <= 0x10000) ) ccDecoder->StopStreaming();
					}
				break;
			case DVST_ELEMENTARY_AUDIO_STREAM:
				audioDecoder->StopStreaming();
				break;
			case DVST_ELEMENTARY_VIDEO_STREAM:
				videoDecoder.StopStreaming();
				break;
			}

		running = FALSE;
		}
	else if (deferedRunning)
		{
		deferedRunning = FALSE;
		}

#if DUMP_STREAM_EVENTS>=1
	DTE("StopStreaming done");
#endif
	}

//
//  End Streaming
//

void DVDStreamDecoder::EndStreaming(bool fullReset)
	{
#if DUMP_STREAM_EVENTS>=1
	DTE("EndStreaming");
#endif

	if (streaming)
		{
		switch (streamType)
			{
			case DVST_PROGRAM_STREAM:
				videoDecoder.EndStreaming(fullReset);
				if (playbackMode == VDPM_PLAY_FORWARD)
					{
					audioDecoder->EndStreaming(fullReset);
					spuDecoder.EndStreaming(fullReset);
					if (ccDecoder) ccDecoder->EndStreaming();
					}
				break;
			case DVST_ELEMENTARY_AUDIO_STREAM:
				audioDecoder->EndStreaming(fullReset);
				break;
			case DVST_ELEMENTARY_VIDEO_STREAM:
				videoDecoder.EndStreaming(fullReset);
				break;
			}

		streaming = FALSE;
		FlushBuffer();
#if VIDEO_DUMP
		{
		if (videoStream) ::CloseHandle(videoStream);
		char buffer[100];
		videoStreamCount++;
		wsprintf(buffer, "c:\\videodump\\strm%03d.mpg", videoStreamCount);

		videoStream = ::CreateFile(buffer,
								  GENERIC_WRITE,
								  FILE_SHARE_WRITE,
								  NULL,
								  CREATE_ALWAYS,
								  FILE_ATTRIBUTE_NORMAL,
								  NULL);
		}
#endif
		}

#if DUMP_STREAM_EVENTS>=1
	DTE("EndStreaming Done");
#endif
	}

//
//  Advance Frame
//

void DVDStreamDecoder::AdvanceFrame()
	{
	videoDecoder.AdvanceFrame();
	audioDecoder->AdvanceFrame();
	}

//
//  Advance Trick Frame
//

void DVDStreamDecoder::AdvanceTrickFrame(int by)
	{
	videoDecoder.AdvanceTrickFrame(by);
	}

//
//  Enable SPU
//

void DVDStreamDecoder::EnableSPU(bool enable)
	{
	spuDecoder.EnableSPU(enable);
	}

//
//  Flush Buffer
//

void DVDStreamDecoder::FlushBuffer(void)
	{
	int i;

	for(i=0; i<4; i++)
		{
		mpeparse[i].pesState = idle;
		mpeparse[i].endPTM = 0;
		mpeparse[i].ptsOffset = 0;
		mpeparse[i].mpparse.state = PROGSTRM_INITIAL;
		mpeparse[i].mpparse.mpeg2 = FALSE;

		mpeparse[i].mpparse.ptsValid = FALSE;
		mpeparse[i].mpparse.dtsValid = FALSE;
		mpeparse[i].pendingData = NULL;
		mpeparse[i].pendingPairs = NULL;

		mpeparse[i].completing = FALSE;
		mpeparse[i].completed = FALSE;

		::SetEvent(mpeparse[i].dataEvent);
		}

	videoDecoder.FlushBuffer();
//	if (!scanning)
		{
		audioDecoder->FlushBuffer();
		spuDecoder.FlushBuffer();
		audioTracker.Flush();
		initialAudioPacket = TRUE;
		}

	videoTracker.Flush();
	audioInputPos = videoInputPos = spuInputPos = 0;
	vobuInputPos = 0;
	streamInputPos = 0;
	streamInputOffset = 0;
	lastCheckTime = 0;

	splitCompletion = FALSE;
	dataCompleted = FALSE;
	}

//
//  Internal current location
//

__int64 DVDStreamDecoder::InternalCurrentLocation(void)
	{
	__int64 videoPos, audioPos;

	if (streamingCompleted)
		{
		return streamInputPos;
		}
	else
		{
		switch (streamType)
			{
			case DVST_PROGRAM_STREAM:

				if (videoDecoder.StreamingCompleted())
					videoPos = -1;
				else
					videoPos = videoTracker.ElemToMux(videoDecoder.CurrentLocation() >> 3);

				if (playbackMode == VDPM_PLAY_FORWARD)
					{
					if (audioDecoder->StreamingCompleted())
						audioPos = -1;
					else
						audioPos = audioTracker.ElemToMux(audioDecoder->CurrentPlaybackLocation() >> 3);
					}
				else
					audioPos = -1;

				if (videoPos == -1 && audioPos == -1)
					{
					return streamInputPos + streamInputOffset;
					}
				else if (videoPos == -1)
					return audioPos + streamInputOffset;
				else
					return videoPos + streamInputOffset;
				break;
			case DVST_ELEMENTARY_AUDIO_STREAM:
				audioPos = audioDecoder->CurrentPlaybackLocation() >> 3;
				if (audioPos == -1)
					return streamInputPos + streamInputOffset;
				else
					return audioPos + streamInputOffset;
				break;
			case DVST_ELEMENTARY_VIDEO_STREAM:
				videoPos = videoDecoder.CurrentLocation() >> 3;
				if (videoPos == -1)
					return streamInputPos + streamInputOffset;
				else
					return videoPos + streamInputOffset;
				break;
			}
		}

	return 0;
	}

//
//  Current Location
//

__int64 DVDStreamDecoder::CurrentLocation(void)
	{
	DWORD time;

	time = GetInternalTime();
	if (!lastCheckTime || (time > lastCheckTime + 100))
		{
		lastCheckTime = time;
		lastCheckValue = InternalCurrentLocation();
		CheckSignal();
		}

	return lastCheckValue;
	}

//
//  Video Segment Requested
//

DWORD DVDStreamDecoder::VideoSegmentRequested(void)
	{
	return videoDecoder.VideoSegmentRequested();
	}

//
//  Set First Video Segment
//

void DVDStreamDecoder::SetFirstVideoSegment(DWORD seg)
	{
	videoDecoder.SetFirstVideoSegment(seg);
	}

//
//  Set Last Video Segment
//

void DVDStreamDecoder::SetLastVideoSegment(DWORD seg)
	{
	videoDecoder.SetLastVideoSegment(seg);
	}

//
//  Current Playback Time
//

int DVDStreamDecoder::CurrentPlaybackTime(void)
	{
	int time = display->CurrentTime();
#if DUMP_STREAM_EVENTS>=2
	char buffer[100];
	wsprintf(buffer, "Get Time %d", time);
	DTE(buffer);
#endif
	return time;
	}

//
//  Internal Refill Request
//

void DVDStreamDecoder::InternalRefillRequest(void)
	{
	bufferMonitorEvent.SetEvent();
	}

DWORD DVDStreamDecoder::SendDataMultiple(MPEGDataSizePair * data, DWORD size)
	{
	return SendDataSplitMultiple(DVEST_MULTIPLEXED, data, size);
	}

DWORD DVDStreamDecoder::SendDataSplitMultiple(DVDElementaryStreamType type, MPEGDataSizePair * data, DWORD num)
	{
	bool space;
	MPEParse * mp = mpeparse + type;

#if DUMP_STREAM_EVENTS>=2
		{
		char buffer[100];
		wsprintf(buffer, "SendData (%d) : %d at (%d)", type, num, display->CurrentTime());
		DTE(buffer);
		}
#endif

	if (streaming)
		{
		if(!running)
			{
			if (streamInputPos > 500000 || audioInputPos > 100000 || spuInputPos > 50000 || vobuInputPos > 2) DeferedStartStreaming();
			}

		if (num)
			{
			switch (streamType)
				{
				case DVST_PROGRAM_STREAM:
					switch(type)
						{
						case DVEST_VIDEO:
							space = videoDecoder.AvailBufferSpace() > (int)(num * 8);
							if (playbackMode == VDPM_PLAY_FORWARD && initialVideoTime >= 0 && initialAudioPacket && videoDecoder.AvailBits() > 256000 * 8)
								{
#if DUMP_STREAM_EVENTS>=2
		{
		char buffer[100];
		wsprintf(buffer, "SetVideoStartTime %d VideoBits %d", initialVideoTime, (DWORD)(videoDecoder.AvailBits()));
		DTE(buffer);
		}
#endif
								display->SetVideoStartTiming(initialVideoTime);
								initialVideoTime = -2;
								}
							break;
						case DVEST_AUDIO:
							space = audioDecoder->AvailBufferSpace() > (int)(num * 8);
							break;
						case DVEST_SUBPICTURE:
							space = spuDecoder.AvailBufferSpace() > (int)(num * 8);
							break;
						case DVEST_MULTIPLEXED:
							space = videoDecoder.AvailBufferSpace() > 65536 * 8 &&
										(playbackMode != VDPM_PLAY_FORWARD || audioDecoder->AvailBufferSpace() > 8192 * 8);
							break;
						}
					break;
				case DVST_ELEMENTARY_AUDIO_STREAM:
					space = audioDecoder->AvailBufferSpace() > 8192 * 8;
					break;
				case DVST_ELEMENTARY_VIDEO_STREAM:
					space = videoDecoder.AvailBufferSpace() > 65536 * 8;
					break;
				}

#if DUMP_STREAM_EVENTS>=3
		{
		char buffer[100];
		wsprintf(buffer, "SendData (%d) : space %d", space);
		DTE(buffer);
		}
#endif

			if (space)
				{
				::ResetEvent(mpeparse[type].dataEvent);
				mpeparse[type].pendingNum = num;
				mpeparse[type].pendingPairs = data;
				mpeparse[type].pendingTimeStamp = -1;
				bufferMonitorEvent.SetEvent();
				while (mpeparse[type].pendingPairs)
					{
					::WaitForSingleObject(mpeparse[type].dataEvent, INFINITE);
					}

#if DUMP_STREAM_EVENTS>=3
		{
		char buffer[100];
		wsprintf(buffer, "SendData (%d) : result %d", type, mpeparse[type].pendingNum);
		DTE(buffer);
		}
#endif
				return mpeparse[type].pendingNum;
				}
			else
				{
				if (playbackMode == VDPM_PLAY_FORWARD)
					{
					if (initialVideoTime >= 0 && initialAudioPacket)
						{
						display->SetVideoStartTiming(initialVideoTime);
						initialVideoTime = -2;
						}
					}

				if (type == DVEST_MULTIPLEXED) DeferedStartStreaming();

				return 0;
				}
			}
		else
			return 0;
		}
	else
		return 0;
	}

//
//  Send Data
//

DWORD DVDStreamDecoder::SendData(BYTE * ptr, DWORD num)
	{
	return SendDataSplit(DVEST_MULTIPLEXED, ptr, num, -1);
	}

//
//  Send Data Split
//

#include <stdio.h>

DWORD DVDStreamDecoder::SendDataSplit(DVDElementaryStreamType type, BYTE * ptr, DWORD num, int timeStamp)
	{
	bool space;
	MPEParse * mp = mpeparse + type;

#if DUMP_STREAM_EVENTS>=2
		{
		char buffer[100];
		wsprintf(buffer, "SendData (%d) : %d at %d (%d)", type, num, timeStamp, display->CurrentTime());
		DTE(buffer);
		}
#endif

	if (streaming)
		{
		if(!running)
			{
			if (streamInputPos > 500000 || audioInputPos > 100000 || spuInputPos > 50000 || vobuInputPos > 2) DeferedStartStreaming();
			else if (type == DVEST_VIDEO && initialVideoTime >=0 && timeStamp >= 0 && timeStamp >= initialVideoTime + 500) DeferedStartStreaming();
			else
				{
				if (!streamInputPos)
					{
					initTimeStamp = timeStamp;
					}
				else if ((timeStamp - initTimeStamp) > 500)
					{
					PMMSG("diff in TimeStamps forced DfrdStrtStrmng\n");
					DeferedStartStreaming();
					}
				}
			}

		if (num)
			{
			if (mp->streamType == DVSST_ELEMENTARY)
				{
	//			SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
				int done;

				switch (type)
					{
					case DVEST_VIDEO:
						if (initialVideoTime == -1) initialVideoTime = timeStamp;
						if (timeStamp >= 0) videoDecoder.AddTimeStamp(timeStamp);
						videoTracker.AddTrack(streamInputPos, videoInputPos);
						done = videoDecoder.SendData(ptr, num);
						streamInputPos += done;
						videoInputPos += done;
						break;
					case DVEST_AUDIO:
						if (timeStamp >= 0) audioDecoder->AddTimeStamp(timeStamp);
						audioTracker.AddTrack(streamInputPos, audioInputPos);
						done =  audioDecoder->SendData(ptr, num);
						streamInputPos += done;
						audioInputPos += done;
						break;
					case DVEST_SUBPICTURE:
						if (timeStamp >= 0) spuDecoder.AddTimeStamp(timeStamp);
						done =  spuDecoder.SendData(ptr, num);
						streamInputPos += done;
						spuInputPos += done;
						break;
					default:
						done = num;
					}

				return done;
				}

			switch (streamType)
				{
				case DVST_PROGRAM_STREAM:
					switch(type)
						{
						case DVEST_VIDEO:
							space = videoDecoder.AvailBufferSpace() > (int)(num * 8);
							if (playbackMode == VDPM_PLAY_FORWARD && initialVideoTime >= 0 && initialAudioPacket && videoDecoder.AvailBits() > 256000 * 8)
								{
								display->SetVideoStartTiming(initialVideoTime);
								initialVideoTime = -2;
								}
							break;
						case DVEST_AUDIO:
							space = audioDecoder->AvailBufferSpace() > (int)(num * 8);

							//
							// Startup delay for audio gap
							//
							if (initialVideoTime == -2 && initialAudioPacket && timeStamp >= 0 &&
								 timeStamp > display->CurrentTime() + 100)
								{
								return 0;
								}
							// add workaround for 96k perfomance problem
							else if (num == 2048 && space && (ptr[20] & 0x30) == 0 && audioType == MP2AUDTYP_LPCM && samplesPerSecond == 96000)
								{
								return InternalSendDataSplit(type, ptr, num, timeStamp);
								}

							break;
						case DVEST_SUBPICTURE:
							space = spuDecoder.AvailBufferSpace() > (int)(num * 8);
							break;
						case DVEST_MULTIPLEXED:
							space = videoDecoder.AvailBufferSpace() > 65536 * 8 &&
										(playbackMode != VDPM_PLAY_FORWARD || audioDecoder->AvailBufferSpace() > 8192 * 8);
							break;
						}
					break;
				case DVST_ELEMENTARY_AUDIO_STREAM:
					space = audioDecoder->AvailBufferSpace() > 8192 * 8;
					break;
				case DVST_ELEMENTARY_VIDEO_STREAM:
					space = videoDecoder.AvailBufferSpace() > 65536 * 8;
					break;
				}

#if DUMP_STREAM_EVENTS>=3
		{
		char buffer[100];
		wsprintf(buffer, "SendData (%d) : space %d", space);
		DTE(buffer);
		}
#endif

			if (space)
				{
				::ResetEvent(mpeparse[type].dataEvent);
				mpeparse[type].pendingNum = num;
				mpeparse[type].pendingData = ptr;
				mpeparse[type].pendingTimeStamp = timeStamp;
				bufferMonitorEvent.SetEvent();
				while (mpeparse[type].pendingData)
					{
					::WaitForSingleObject(mpeparse[type].dataEvent, INFINITE);
					}

#if DUMP_STREAM_EVENTS>=3
		{
		char buffer[100];
		wsprintf(buffer, "SendData (%d) : result %d", type, mpeparse[type].pendingNum);
		DTE(buffer);
		}
#endif
				return mpeparse[type].pendingNum;
				}
			else
				{
				if (playbackMode == VDPM_PLAY_FORWARD)
					{
					if (initialVideoTime >= 0 && initialAudioPacket)
						{
						display->SetVideoStartTiming(initialVideoTime);
						initialVideoTime = -2;
						}
					}

				if (type == DVEST_MULTIPLEXED) DeferedStartStreaming();

				return 0;
				}
			}
		else
			return 0;
		}
	else
		return 0;
	}

//
//  DVD Stream Decoder Supervisor Constructor
//

DVDStreamDecoder::Supervisor::Supervisor(DVDStreamDecoder * decoder)
	: TimedFiber(1)
	{
	this->decoder = decoder;
	}

//
//  Supervisor Supervisor Fiber Routine
//

void DVDStreamDecoder::Supervisor::FiberRoutine(void)
	{
	SetFiberPriority(3);
	decoder->SupervisorFiberRoutine();
	}

//
//  Supervisor Fiber Routine
//

void DVDStreamDecoder::SupervisorFiberRoutine(void)
	{
	int videoAvail, audioAvail;

	while (!terminate)
		{
		switch (streamType)
			{
			case DVST_PROGRAM_STREAM:
				videoAvail = videoDecoder.AvailBufferSpace();
				perfmon.videoBitBufferFill = perfmon.videoBitBufferSize - videoAvail;
				audioAvail = audioDecoder->AvailBufferSpace();
				perfmon.audioBitBufferFill = perfmon.audioBitBufferSize - audioAvail;
				perfmon.audioSampleBufferSize = 4500;
				audioAvail = audioDecoder->TotalAudioBufferTime();
				perfmon.audioSampleBufferFill = audioAvail;

				if (!dataCompleted)
					{
					if (videoAvail > 6 * 65536 * 8 || audioAvail < 600)
						{
						SetFiberPriority(3);
						hurryUp = TRUE;
						}
					else if (videoAvail > 4 * 65536 * 8 || audioAvail < 1000)
						{
						SetFiberPriority(2);
						}
					}
				break;
			case DVST_ELEMENTARY_VIDEO_STREAM:
				videoAvail = videoDecoder.AvailBufferSpace();
				perfmon.videoBitBufferFill = perfmon.videoBitBufferSize - videoAvail;
				if (!dataCompleted)
					{
					if (videoAvail > 6 * 65536 * 8)
						{
						SetFiberPriority(3);
						hurryUp = TRUE;
						}
					else if (videoAvail > 4 * 65536 * 8)
						{
						SetFiberPriority(2);
						}
					}
				break;
			case DVST_ELEMENTARY_AUDIO_STREAM:
				audioAvail = audioDecoder->AvailBufferSpace();
				perfmon.audioBitBufferFill = perfmon.audioBitBufferSize - audioAvail;
				perfmon.audioSampleBufferSize = 4500;
				audioAvail = audioDecoder->TotalAudioBufferTime();
				perfmon.audioSampleBufferFill = audioAvail;
				break;
			}

		YieldTimedFiber(100);
		}
	}

//
//  Flush Debug Registers
//

static void __stdcall FlushDebugRegister(void * data)
	{
	__asm
		{
		mov	eax, dr7
		and	eax, 0xffffff00
		mov	dr7, eax
		xor	eax, eax
		mov	dr0, eax
		mov	dr1, eax
		mov	dr2, eax
		mov	dr3, eax
		}
	}

//
//  Fiber Routine
//

typedef void (__stdcall * Ring0Call)(void *);

void DVDStreamDecoder::FiberRoutine(void)
	{
	int videoAvail, audioAvail;
	int previousRequest;
	DWORD done;
	int type;

	previousRequest = GetInternalTime();

	while (!terminate)
		{
		bufferMonitorEvent.Wait(100);

		if (streaming) CheckSignal();

		switch (streamType)
			{
			case DVST_PROGRAM_STREAM:
#if PROTECTED
				{
				struct ProcCall pc;

				pc.call = FlushDebugRegister;
				pc.data = NULL;

				BEGIN_IOCTL_CALL(TEST)
					in.call = &pc;
					DO_IOCTL_WITH_DRIVER(TEST, cinemSupDriver);
				END_IOCTL_CALL
				}
#endif
				videoAvail = videoDecoder.AvailBufferSpace();
				audioAvail = audioDecoder->TotalAudioBufferTime();
				if (!dataCompleted)
					{
					if (videoAvail > 6 * 65536 * 8 || audioAvail < 600)
						{
						SetFiberPriority(3);
						hurryUp = TRUE;
						}
					else if (videoAvail > 4 * 65536 * 8 || audioAvail < 1000)
						{
						SetFiberPriority(2);
						}
					else
						{
						SetFiberPriority(1);
						}
					}
				else
					{
					SetFiberPriority(1);
					}
#if DUMP_STREAM_EVENTS>=4
	char buffer[100];
	wsprintf(buffer, "DemuxFiber video : %d audio : %d times %d / %d", videoAvail, audioAvail, previousRequest, GetInternalTime());
	DTE(buffer);
#endif

				for(type=0; type<4; type++)
					{
					if (mpeparse[type].pendingData)
						{
						done = InternalSendDataSplit((DVDElementaryStreamType)type, ((BYTE *)(mpeparse[type].pendingData)), mpeparse[type].pendingNum, mpeparse[type].pendingTimeStamp);
						}
					else if (mpeparse[type].pendingPairs)
						{
						DWORD res;
						DWORD num = mpeparse[type].pendingNum;
						volatile MPEGDataSizePair * data = mpeparse[type].pendingPairs;

						done = 0;
						while (done < num)
							{
							res = InternalSendDataSplit((DVDElementaryStreamType)type, (BYTE *)(data->data), data->size, data->timeStamp);

							done += res;
							if (res != data->size) break;

							data++;
							}
						}
					else
						continue;

					if (done != mpeparse[type].pendingNum)
						{
						SetFiberPriority(1);
						hurryUp = FALSE;
						}

					mpeparse[type].pendingNum = done;
					mpeparse[type].pendingData = NULL;
					mpeparse[type].pendingPairs = NULL;
					::SetEvent(mpeparse[type].dataEvent);
					if (hurryUp)
						{
//						Sleep(0);
						YieldTimedFiber(1);
//						DP("Force Sleep");
						}
					}

				if (streaming && videoAvail > 2 * 65536 * 8 &&
							(playbackMode != VDPM_PLAY_FORWARD || audioDecoder->AvailBufferSpace() > 8192 * 8) &&
							previousRequest + 200 < GetInternalTime())
					{
					RefillRequest();
					previousRequest = GetInternalTime();
					}
				break;
			case DVST_ELEMENTARY_AUDIO_STREAM:
				if (mpeparse[DVEST_MULTIPLEXED].pendingData)
					{
					done = audioDecoder->SendData(((BYTE *)(mpeparse[DVEST_MULTIPLEXED].pendingData)), mpeparse[DVEST_MULTIPLEXED].pendingNum);

#if AUDIO_DUMP
					DWORD dummy;
					::WriteFile(audioStream, (void *)(mpeparse[DVEST_MULTIPLEXED].pendingData), done, &dummy, NULL);
#endif
						streamInputPos += done;

					if (done != mpeparse[DVEST_MULTIPLEXED].pendingNum)
						{
						SetFiberPriority(1);
						hurryUp = FALSE;
						}

					mpeparse[DVEST_MULTIPLEXED].pendingNum = done;
					mpeparse[DVEST_MULTIPLEXED].pendingData = NULL;
					::SetEvent(mpeparse[DVEST_MULTIPLEXED].dataEvent);
					YieldTimedFiber(1);
					}

				if (streaming && audioDecoder->AvailBufferSpace() > 8192 * 8 &&
							previousRequest + 200 < GetInternalTime())
					{
					RefillRequest();
					previousRequest = GetInternalTime();
					}
				break;
			case DVST_ELEMENTARY_VIDEO_STREAM:
				videoAvail = videoDecoder.AvailBufferSpace();

				if (mpeparse[DVEST_MULTIPLEXED].pendingData)
					{
					done = videoDecoder.SendData(((BYTE *)(mpeparse[DVEST_MULTIPLEXED].pendingData)), mpeparse[DVEST_MULTIPLEXED].pendingNum);
					streamInputPos += done;

					if (done != mpeparse[DVEST_MULTIPLEXED].pendingNum)
						{
						SetFiberPriority(1);
						hurryUp = FALSE;
						}

					mpeparse[DVEST_MULTIPLEXED].pendingNum = done;
					mpeparse[DVEST_MULTIPLEXED].pendingData = NULL;
					::SetEvent(mpeparse[DVEST_MULTIPLEXED].dataEvent);
					YieldTimedFiber(1);
					}

				if (streaming && videoAvail > 2 * 65536 * 8 &&
							previousRequest + 200 < GetInternalTime())
					{
					RefillRequest();
					previousRequest = GetInternalTime();
					}
				break;
			}

		}
	}

//
//  Check Signal
//

void DVDStreamDecoder::CheckSignal(void)
	{
	__int64 pos;
	bool completed;

	lock.Enter();

	if (!streamingCompleted)
		{
		pos = InternalCurrentLocation();

		if (signalPos > 0 && pos >= signalPos)
			{
			pos = signalPos;
			signalPos = 0;

			SignalReached(pos);
			}

		if (playbackMode != VDPM_SCANNING && playbackMode != VDPM_TRICKPLAY)
			{
			if (splitCompletion)
				{
				if (videoDecoder.StreamingCompleted())
					{
					if (mpeparse[DVEST_VIDEO].completing && !mpeparse[DVEST_VIDEO].completed)
						{
						mpeparse[DVEST_VIDEO].completed = TRUE;
#if DUMP_STREAM_EVENTS>=1
						DTE("Completion message 0");
#endif
						StreamCompleted(DVEST_VIDEO);
						}
					}
				if (audioDecoder->StreamingCompleted())
					{
					if (mpeparse[DVEST_AUDIO].completing && !mpeparse[DVEST_AUDIO].completed)
						{
						mpeparse[DVEST_AUDIO].completed = TRUE;
#if DUMP_STREAM_EVENTS>=1
						DTE("Completion message 1");
#endif
						StreamCompleted(DVEST_AUDIO);
						}
					}
				if (spuDecoder.StreamingCompleted())
					{
					if (mpeparse[DVEST_SUBPICTURE].completing && !mpeparse[DVEST_SUBPICTURE].completed)
						{
						mpeparse[DVEST_SUBPICTURE].completed = TRUE;
#if DUMP_STREAM_EVENTS>=1
						DTE("Completion message 2");
#endif
						StreamCompleted(DVEST_SUBPICTURE);
						}
					}
				}
			else if (dataCompleted)
				{
				switch (streamType)
					{
					case DVST_PROGRAM_STREAM:
						completed = videoDecoder.StreamingCompleted() &&
										 (playbackMode != VDPM_PLAY_FORWARD || audioDecoder->StreamingCompleted());
						break;
					case DVST_ELEMENTARY_AUDIO_STREAM:
						completed = audioDecoder->StreamingCompleted();
						break;
					case DVST_ELEMENTARY_VIDEO_STREAM:
						completed = videoDecoder.StreamingCompleted();
						break;
					}

				if (completed)
					{
					if (signalPos > 0 && signalPos <= streamInputPos + streamInputOffset)
						{
						pos = signalPos;
						signalPos = 0;

						SignalReached(pos);
						}

#if DUMP_STREAM_EVENTS>=1
					DTE("Completed");
#endif

					streamingCompleted = TRUE;
					StreamCompleted(DVEST_MULTIPLEXED);
					}
				}
			}
		}

	lock.Leave();
	}

//
//  Scan Completed
//

void DVDStreamDecoder::ScanCompleted(void)
	{
	bool split;

	if (playbackMode == VDPM_SCANNING && !terminate)
		{
		split = splitCompletion;

		FlushBuffer();

		if (split)
			{
#if DUMP_STREAM_EVENTS>=1
			DTE("Scan Completion message 0");
#endif
			StreamCompleted(DVEST_VIDEO);
			}
		else
			{
#if DUMP_STREAM_EVENTS>=1
			DTE("Scan Completion message");
#endif
			StreamCompleted(DVEST_MULTIPLEXED);
			}
		}
	}

//
//  Set Signal Position
//

void DVDStreamDecoder::SetSignalPosition(__int64 pos)
	{
	signalPos = pos;
	CheckSignal();
	}

//
//  Some Defines For Splitting
//

#define STREAMERROR	{GOTO(PROGSTRM_RECOVER1);}

#define CHECK(b, check)			(((b) & HIBYTE(check)) == LOBYTE(check))
#define BLOCK(x)					{x}

#define CONSUME(b)				BLOCK(if (rest) {b = *p++; rest--;} else {streamInputPos += size; return size;})
#define CONSUMEIF(b, check)	BLOCK(if (rest) {if (!CHECK(*p, check)) STREAMERROR else {b = *p++; rest--;}} else {streamInputPos += size; return size;})
#define REJECT						BLOCK(STREAMERROR;)
#define SKIP(n) 					BLOCK(if (rest>=(DWORD)n) {rest-=(DWORD)n; p+=n;} else {(DWORD &)n-=rest; streamInputPos += size; return size;})
#define PROCEED					BLOCK(mp->mpparse.state++;)
#define GOTO(s)   				BLOCK(mp->mpparse.state = s; break;)
#define ACCEPT(check)			BLOCK(if (rest) {if (!CHECK(*p, check)) STREAMERROR else {p++; rest--; mp->mpparse.state++;}} else {streamInputPos += size; return size;})
#define ACCEPTNGO(check, s)	BLOCK(if (rest) {if (!CHECK(*p, check)) STREAMERROR else {p++; rest--; mp->mpparse.state=s;break;}} else {streamInputPos += size; return size;})

//
//  Internal Advance
//

void DVDStreamDecoder::InternalAdvance(MPEParse * mp, int by, BYTE * & ptr, DWORD & num)
	{
	mp->pesOffset += by;
	ptr += by;
	num -= by;
	streamInputPos += by;
	}

//
//  Internal Get Data
//

BYTE DVDStreamDecoder::InternalGetData(MPEParse * mp, int at, BYTE * ptr)
	{
	if (!(mp->encryptedBlock) || mp->pesOffset + at < 128)
		return ptr[at];
	else
		return mp->decBuffer[mp->pesOffset + at - 128];
	}

//
//  Internal Send Data
//

DWORD DVDStreamDecoder::InternalSendData(BYTE * ptr, DWORD num)
	{
	return InternalSendDataSplit(DVEST_MULTIPLEXED, ptr, num, -1);
	}

//
//  Set DVD Demux
//

void DVDStreamDecoder::SetDVDDemux(bool dvdDemux)
	{
	if (dvdDemux)
		mpeparse[DVEST_MULTIPLEXED].streamType = DVSST_DVD_ENCRYPTED;
	else
		mpeparse[DVEST_MULTIPLEXED].streamType = DVSST_PROGRAM;
	}

//
//  Set Split Stream Type
//

void DVDStreamDecoder::SetSplitStreamType(DVDElementaryStreamType type, DVDSplitStreamType streamType)
	{
	mpeparse[type].streamType = streamType;
	}

//
//  Internal Send Data Split
//

DWORD DVDStreamDecoder::InternalSendDataSplit(DVDElementaryStreamType type, BYTE * ptr, DWORD num, int externalTimeStamp)
	{
	MPEParse * mp = mpeparse + type;
	int timeStamp;

	switch (mp->streamType)
		{
		case DVSST_DVD_ENCRYPTED:
			{
			int done, initial;
			DWORD pts;
			int startPTM;
			bool	skipPacket;
			BYTE	*	bptr;
			BYTE h, x;

			initial = num;

			while (num)
				{
				switch (mp->pesState)
					{
					case idle:
						if (ptr[0] != 0x00 || ptr[1] != 0x00 ||
							 ptr[2] != 0x01 || ptr[3] != 0xba)
							{
#if DUMP_STREAM_EVENTS>=1
							::DTE("Error in bitstream");
#endif
							while (num >= 2048 && (ptr[0] != 0x00 || ptr[1] != 0x00 || ptr[2] != 0x01 || ptr[3] != 0xba))
								{
								num--;
								ptr++;
								streamInputPos++;
								}

							if (num < 2048)
								{
								streamInputPos += num;

								return initial;
								}
							}

	#if INDUCE_ERRORS_IN_BITSTREAM
							{
							static DWORD s0 = 0x1341231;
							static DWORD s1 = 0x4123534;

							s0 = s0 * 32142 + 523153;
							s1 = s1 * 532123 + 2134;

							s0 ^= s1 >> 16;
							s1 ^= s0 >> 27;

							if ((s0 & 0xf) == 0)
								{
								::OutputDebugString("E");
								ptr[(s1 >> 8) & 0x07ff] = s1 & 0xff;
								}
							}
	#endif

						bptr = ptr;
						mp->pesRest = ((int)ptr[18] << 8) + (int)ptr[19];
						if (mp->pesRest > 2048 - 20)
							{
#if DUMP_STREAM_EVENTS>=1
							::DTE("Error in bitstream");
#endif
							ptr += 2048;
							num -= 2048;
							streamInputPos += 2048;

							continue;
							}

						if (ptr[17] == 0xbb)
							{
							startPTM = ((DWORD)(ptr[57]) << 23) |
										  ((DWORD)(ptr[58]) << 15) |
										  ((DWORD)(ptr[59]) <<  7) |
										  ((DWORD)(ptr[60]) >>  1);
							mp->ptsOffset += mp->endPTM - startPTM;
							mp->endPTM   = ((DWORD)(ptr[61]) << 23) |
										  ((DWORD)(ptr[62]) << 15) |
										  ((DWORD)(ptr[63]) <<  7) |
										  ((DWORD)(ptr[64]) >>  1);

							ptr += 2048;
							num -= 2048;
							streamInputPos += 2048;
							if (playbackMode == VDPM_PLAY_BACKWARD)
								{
								BYTE EOS[] = {0x00, 0x00, 0x01, 0xb7};
								videoDecoder.SendData(EOS, 4);
								}
							vobuInputPos++;
							}
						else
							{
							skipPacket = FALSE;

							if (externalTimeStamp >= 0)
								{
								timeStamp = externalTimeStamp;
								externalTimeStamp = -2;
								}
							else if (ptr[21] & 0xc0 && externalTimeStamp == -1)
								{
								pts = ((DWORD)((ptr[23] >> 1) & 0x07) << 29) |
										((DWORD)( ptr[24]				   ) << 21) |
										((DWORD)((ptr[25] >> 1) & 0x7f) << 14) |
										((DWORD)( ptr[26]             ) <<  6) |
										((DWORD)((ptr[27] >> 2) & 0x3f));

								timeStamp = pts / 45 + mp->ptsOffset / 45;

								if (timeStamp < 0 && playbackMode != VDPM_TRICKPLAY)
									{
									skipPacket = TRUE;
									}

								}
							else
								timeStamp = -1;
#if DUMP_STREAM_EVENTS>=2
							if (timeStamp >= 0)
								{
								char buffer[100];
								wsprintf(buffer, "TIME %d (%02x): %8d", type, ptr[17], timeStamp);
								DTE(buffer);
								}
#endif
							if (skipPacket)
								{
								ptr += 2048;
								num -= 2048;
								streamInputPos += 2048;
								}
							else if (ptr[17] == videoStreamID)
								{
								mp->pesOffset = ptr[22];
								mp->pesRest -= (mp->pesOffset+3);
								mp->pesOffset += 23;
								mp->pesSkip = 2048 - mp->pesRest - mp->pesOffset;
								ptr += mp->pesOffset; num -= mp->pesOffset;
								mp->pesState = videoData;
								if (initialVideoTime == -1 && timeStamp >= 0) initialVideoTime = timeStamp;
								if (timeStamp >= 0) videoDecoder.AddTimeStamp(timeStamp);
								videoTracker.AddTrack(streamInputPos, videoInputPos);
								streamInputPos += mp->pesOffset;
								videoInputPos += mp->pesRest;
								}
							else if (playbackMode == VDPM_PLAY_FORWARD && audioType == MP2AUDTYP_MPEG && (ptr[17] & 0xef) == audioStreamID && (!initialAudioPacket || timeStamp >= 0))
								{
								mp->pesState = audioHeaderMpeg;
								mp->pesOffset = 14;
								if (timeStamp >= 0) audioDecoder->AddTimeStamp(timeStamp);
								audioTracker.AddTrack(streamInputPos, audioInputPos);
								streamInputPos += mp->pesOffset;
								ptr += mp->pesOffset; num -= mp->pesOffset;

								initialAudioPacket = FALSE;
								}
							else if (playbackMode == VDPM_PLAY_FORWARD && audioType == MP2AUDTYP_AC3 && ptr[17] == 0xbd && ptr[23 + ptr[22]] == ac3StreamID)
								{
								mp->pesOffset = ptr[22] + 4;
								mp->pesRest -= (mp->pesOffset+3);
								mp->pesOffset += 23;
								if (initialAudioPacket)
									{
									int delta = (ptr[mp->pesOffset - 2] << 8) + ptr[mp->pesOffset - 1] - 1;
									mp->pesOffset += delta;
									mp->pesRest -= delta;
									initialAudioPacket = FALSE;
									}

								mp->pesSkip = 2048 - mp->pesRest - mp->pesOffset;

								ptr += mp->pesOffset; num -= mp->pesOffset;

								mp->pesState = audioData;
								if (timeStamp >= 0) audioDecoder->AddTimeStamp(timeStamp);
								audioTracker.AddTrack(streamInputPos, audioInputPos);
								streamInputPos += mp->pesOffset;
								audioInputPos += mp->pesRest;
								}
							else if (playbackMode == VDPM_PLAY_FORWARD && audioType == MP2AUDTYP_DTS && ptr[17] == 0xbd && ptr[23 + ptr[22]] == dtsStreamID)
								{
								mp->pesOffset = ptr[22] + 4;
								mp->pesRest -= (mp->pesOffset+3);
								mp->pesOffset += 23;
								if (initialAudioPacket)
									{
//                     Spec outlines that this will always be set to 0001.  There are titles authored
//                     in error with bytes set to 0000, ignoring these bytes will avoid the issue.
//									int delta = (ptr[mp->pesOffset - 2] << 8) + ptr[mp->pesOffset - 1] - 1;
//									mp->pesOffset += delta;
//									mp->pesRest -= delta;
									initialAudioPacket = FALSE;
									}

								mp->pesSkip = 2048 - mp->pesRest - mp->pesOffset;

								ptr += mp->pesOffset; num -= mp->pesOffset;

								mp->pesState = audioData;
								if (timeStamp >= 0) audioDecoder->AddTimeStamp(timeStamp);
								audioTracker.AddTrack(streamInputPos, audioInputPos);
								streamInputPos += mp->pesOffset;
								audioInputPos += mp->pesRest;
								}
							else if (playbackMode == VDPM_PLAY_FORWARD && audioType == MP2AUDTYP_LPCM && ptr[17] == 0xbd && ptr[23 + ptr[22]] == lpcmStreamID)
								{
								mp->pesOffset = ptr[22] + 7;
								mp->pesRest -= (mp->pesOffset+3);
								mp->pesOffset += 23;
								mp->pesSkip = 2048 - mp->pesRest - mp->pesOffset;
								ptr += mp->pesOffset; num -= mp->pesOffset;
								mp->pesState = audioData;
								if (timeStamp >= 0) lpcmDecoder.AddTimeStamp(timeStamp);
								audioTracker.AddTrack(streamInputPos, audioInputPos);
								streamInputPos += mp->pesOffset;
								audioInputPos += mp->pesRest;

								initialAudioPacket = FALSE;
		#if AUDIO_DUMP
								DWORD dummy;
								::WriteFile(audioStream, ptr, mp->pesRest, &dummy, NULL);
		#endif
								}
							else if (playbackMode == VDPM_PLAY_FORWARD && ptr[17] == 0xbd && ptr[23 + ptr[22]] == spuStreamID)
								{
								mp->pesOffset = ptr[22] + 1;
								mp->pesRest -= (mp->pesOffset+3);
								mp->pesOffset += 23;
								mp->pesSkip = 2048 - mp->pesRest - mp->pesOffset;
								ptr += mp->pesOffset; num -= mp->pesOffset;
								mp->pesState = spuData;
								if (timeStamp >= 0) spuDecoder.AddTimeStamp(timeStamp);
		//						audioTracker.AddTrack(streamInputPos, videoInputPos);
								streamInputPos += mp->pesOffset;
								spuInputPos += mp->pesRest;
								}
							else
								{
								ptr += 2048;
								num -= 2048;
								streamInputPos += 2048;
								}

							if (mp->pesState != idle && mp->pesOffset + mp->pesRest > 128 && bptr[20] & 0x30)
								{
								if (decryptor) decryptor->DecryptBlock(bptr, mp->decBuffer);
#if VIDEO_DUMP==2
								if (mp->pesState == videoData)
									{
									DWORD dummy;
									::WriteFile(videoStream, bptr, 128, &dummy, NULL);
									::WriteFile(videoStream, mp->decBuffer, 2048 - 128, &dummy, NULL);
									}
#endif

								mp->encryptedBlock = TRUE;
								}
							else
								{
#if VIDEO_DUMP==2
								if (mp->pesState == videoData)
									{
									DWORD dummy;
									::WriteFile(videoStream, bptr, 2048, &dummy, NULL);
									}
#endif

								mp->encryptedBlock = FALSE;
								}
							}
						break;
					case videoData:
						if (mp->encryptedBlock)
							{
							if (mp->pesOffset < 128)
								{
								done = videoDecoder.SendData(ptr, 128 - mp->pesOffset);
#if VIDEO_DUMP==1
								DWORD dummy;
								::WriteFile(videoStream, ptr, done, &dummy, NULL);
#endif

								mp->pesRest -= done;
								mp->pesOffset += done;
								ptr += done;
								num -= done;
								streamInputPos += done;
								if (mp->pesOffset < 128) return initial - num;
								}

							done = videoDecoder.SendData(mp->decBuffer +(mp->pesOffset - 128), mp->pesRest);
#if VIDEO_DUMP==1
							DWORD dummy;
							::WriteFile(videoStream, mp->decBuffer +(mp->pesOffset - 128), done, &dummy, NULL);
#endif
							}
						else
							{
							done = videoDecoder.SendData(ptr, mp->pesRest);
#if VIDEO_DUMP==1
							DWORD dummy;
							::WriteFile(videoStream, ptr, done, &dummy, NULL);
#endif
							}

						mp->pesRest -= done;
						mp->pesOffset += done;
						ptr += done;
						num -= done;
						streamInputPos += done;
						if (mp->pesRest) return initial - num;
						ptr += mp->pesSkip;
						num -= mp->pesSkip;
						streamInputPos += mp->pesSkip;
						mp->pesState = idle;
						break;
					case audioHeaderMpeg:

						if (mp->pesOffset < 2040)
							{
							h = InternalGetData(mp, 3, ptr);
							mp->pesRest = ((int)(InternalGetData(mp, 4, ptr)) << 8) + (int)(InternalGetData(mp, 5, ptr));
							x = InternalGetData(mp, 8, ptr);
							InternalAdvance(mp, 9 + x, ptr, num);
							mp->pesRest -= 3 + x;
							if (h == audioStreamID)
								{
								audioInputPos += mp->pesRest;
								mp->pesState = audioDataMpeg;
								}
							else
								{
								InternalAdvance(mp, mp->pesRest, ptr, num);
								}
							}
						else
							{
							InternalAdvance(mp, 2048 - mp->pesOffset, ptr, num);
							mp->pesState = idle;
							}
						break;
					case audioDataMpeg:
						if (mp->encryptedBlock)
							{
							if (mp->pesOffset < 128)
								{
								done = audioDecoder->SendData(ptr, 128 - mp->pesOffset);
								mp->pesRest -= done;
								mp->pesOffset += done;
								ptr += done;
								num -= done;
								streamInputPos += done;
								if (mp->pesOffset < 128) return initial - num;
								}

							done = audioDecoder->SendData(mp->decBuffer + (mp->pesOffset - 128), mp->pesRest);
							}
						else
							{
							done = audioDecoder->SendData(ptr, mp->pesRest);
							}

						mp->pesRest -= done;
						mp->pesOffset += done;
						ptr += done;
						num -= done;
						streamInputPos += done;
						if (mp->pesRest) return initial - num;
						mp->pesState = audioHeaderMpeg;
						break;
					case audioData:
						if (mp->encryptedBlock)
							{
							if (mp->pesOffset < 128)
								{
								done = audioDecoder->SendData(ptr, 128 - mp->pesOffset);
		#if AUDIO_DUMP
								DWORD dummy;
								::WriteFile(audioStream, ptr, done, &dummy, NULL);
		#endif
								mp->pesRest -= done;
								mp->pesOffset += done;
								ptr += done;
								num -= done;
								streamInputPos += done;
								if (mp->pesOffset < 128) return initial - num;
								}

							done = audioDecoder->SendData(mp->decBuffer + (mp->pesOffset - 128), mp->pesRest);
	#if AUDIO_DUMP
							DWORD dummy;
							::WriteFile(audioStream, mp->decBuffer +(mp->pesOffset - 128), done, &dummy, NULL);
	#endif
							}
						else
							{
							done = audioDecoder->SendData(ptr, mp->pesRest);
	#if AUDIO_DUMP
							DWORD dummy;
							::WriteFile(audioStream, ptr, done, &dummy, NULL);
	#endif
							}

						mp->pesRest -= done;
						mp->pesOffset += done;
						ptr += done;
						num -= done;
						streamInputPos += done;
						if (mp->pesRest) return initial - num;

						ptr += mp->pesSkip;
						num -= mp->pesSkip;
						streamInputPos += mp->pesSkip;
						mp->pesState = idle;
						break;
					case spuData:
						if (mp->encryptedBlock)
							{
							if (mp->pesOffset < 128)
								{
								done = spuDecoder.SendData(ptr, 128 - mp->pesOffset);
								mp->pesRest -= done;
								mp->pesOffset += done;
								ptr += done;
								num -= done;
								streamInputPos += done;
								if (mp->pesOffset < 128) return initial - num;
								}

							done = spuDecoder.SendData(mp->decBuffer + (mp->pesOffset - 128), mp->pesRest);
							}
						else
							{
							done = spuDecoder.SendData(ptr, mp->pesRest);
							}

						mp->pesRest -= done;
						mp->pesOffset += done;
						ptr += done;
						num -= done;
						streamInputPos += done;
						if (mp->pesRest) return initial - num;
						ptr += mp->pesSkip;
						num -= mp->pesSkip;
						streamInputPos += mp->pesSkip;
						mp->pesState = idle;
						break;
					}

				if (!hurryUp) YieldTimedFiber(-1);
				else YieldTimedFiber(0);
				}

			return initial;
			}
		case DVSST_PES:
		case DVSST_PROGRAM:
			{
			BYTE	b;
			DWORD size = num;
			DWORD rest = size, done;
			BYTE * p = ptr;

			while (rest)
				{
				switch ((MPEG2ProgramParse) (mp->mpparse.state))
					{
					case PROGSTRM_INITIAL:           //
						if (mp->streamType == DVSST_PROGRAM)
							{
							GOTO(PROGSTRM_PACKSTART0);
							}
						else
							{
							mp->mpparse.mpeg2 = TRUE;
							GOTO(PESPACKET_STARTCODEPREFIX0);
							}
					case PROGSTRM_FINAL:					//
						if (rest) REJECT
						else
							{
							streamInputPos += size;
							return size;
							}

					case MP1PACKHDR_BYTE1:					// ######## SysClockRef [29..22]
						CONSUME(b);
						PROCEED;
					case MP1PACKHDR_BYTE2:					// #######  SysClockRef [21..15]
		                              					//        1
						CONSUMEIF(b, BXXXXXXX1);
						PROCEED;
					case MP1PACKHDR_BYTE3:					// ######## SysClockRef [14..7]
						CONSUME(b);
						PROCEED;
					case MP1PACKHDR_BYTE4:					// #######  SysClockRef [6..0]
																	//        1
						CONSUMEIF(b, BXXXXXXX1);
						PROCEED;
					case MP1PACKHDR_BYTE5:					// 1
																	//  ####### MuxRate[21..15]
						CONSUMEIF(b, B1XXXXXXX);
						PROCEED;
					case MP1PACKHDR_BYTE6:					// ######## MuxRate[14..7]
						CONSUME(b);
						PROCEED;
					case MP1PACKHDR_BYTE7:					// #######  MuxRate[6..0]
																	//        1
																	// goto PESPACKET_STARTCODEPREFIX0
						CONSUMEIF(b, BXXXXXXX1);
						GOTO(PESPACKET_STARTCODEPREFIX0);

					case PROGSTRM_PACKSTART0:        // 00000000
						ACCEPT(B00000000);
					case PROGSTRM_PACKSTART1:			// 00000000
						ACCEPT(B00000000);
					case PROGSTRM_PACKSTART2:			// 00000001
						ACCEPT(B00000001);
					case PROGSTRM_PACKSTART3:			// 10111010 goto PACKHEADER_BYTE0
																// 10111001 goto PROGSTRM_FINAL
						CONSUME(b);
						if      (CHECK(b, B10111010)) GOTO(PACKHEADER_BYTE0)
						else if (CHECK(b, B10111001)) GOTO(PROGSTRM_FINAL)
						else REJECT;

					case PACKHEADER_BYTE0:				// if (01XXXXXX)
																//	01
																//   ###    SysClockRef [32..30]
																//      1
																//       ## SysClockRef [29..28]
																// mpeg2 = TRUE;
																// goto PACKHEADER_BYTE1
																// else if (0010XXXX)
																// 0010
																//     ###  SysClockRef [32..30]
																//        1
																// goto MP1PACKHDR_BYE1
						CONSUME(b);
						//if (CHECK(b, B01XXX1XX)) // Workaround for Optibase clips
						if (CHECK(b, B01XXXXXX))
							{
							mp->mpparse.mpeg2 = TRUE;
							}
						else if (CHECK(b, B0010XXX1))
							{
							mp->mpparse.mpeg2 = FALSE;
							GOTO(MP1PACKHDR_BYTE1);
							}
						else
							REJECT;

						PROCEED;
					case PACKHEADER_BYTE1:				// ######## SysClockRef [27..20]
						CONSUME(b);
						PROCEED;
					case PACKHEADER_BYTE2:				// #####    SysClockRef [19..15]
			                              			//      1
			                              			//       ## SysClockRef [14..13]
						CONSUMEIF(b, BXXXXX1XX);
						PROCEED;
					case PACKHEADER_BYTE3:				// ######## SysClockRef [12..5]
						CONSUME(b);
						PROCEED;
					case PACKHEADER_BYTE4:				// #####    SysClockRef [4..0]
																//      1
																//       ## SysClockRefExt [8..7]
						CONSUMEIF(b, BXXXXX1XX);
						PROCEED;
					case PACKHEADER_BYTE5:				// #######  SysClockRefExt [6..0]
																//        1
						CONSUMEIF(b, BXXXXXXX1);
						PROCEED;
					case PACKHEADER_BYTE6:				// ######## MuxRate[21..14]
						ACCEPT(BXXXXXXXX);
					case PACKHEADER_BYTE7:				// ######## MuxRate[13..6]
						ACCEPT(BXXXXXXXX);
					case PACKHEADER_BYTE8:				// ######   MuxRate[5..0]
																//       11
						ACCEPT(BXXXXXX11);
					case PACKHEADER_BYTE9:				// XXXXX
																//      ### PackStuffingLength
						CONSUME(b);
						mp->mpparse.cnt = XTBFB(0, 3, b);
						PROCEED;
					case PACKHEADER_STUFFING:			// XXXXXXXX times PackStuffingLength
																// goto PESPACKET_STARTCODEPREFIX0
						SKIP(mp->mpparse.cnt);
						GOTO(PESPACKET_STARTCODEPREFIX0);

		   		case SYSTEMHEADER_LENGTH0:			// ########
		   			CONSUME(mp->mpparse.high);
		   			PROCEED;
		   		case SYSTEMHEADER_LENGTH1:			// ########
		   			CONSUME(mp->mpparse.low);
		   			mp->mpparse.length = MAKEWORD(mp->mpparse.low, mp->mpparse.high);
		   			PROCEED;
		   		case SYSTEMHEADER_BYTE0:			// 1
		   													//  ####### RateBound[21..15]
		   			ACCEPT(B1XXXXXXX);
		   		case SYSTEMHEADER_BYTE1:			// ######## RateBound[14..7]
		   			ACCEPT(BXXXXXXXX);
		   		case SYSTEMHEADER_BYTE2:			// #######  RateBound[6..0]
		   													//        1
		   			ACCEPT(BXXXXXXX1);
		   		case SYSTEMHEADER_BYTE3:			// ######   AudioBound
		   													//       #  FixedFlag
																//        # CSPSFlag
						ACCEPT(BXXXXXXXX);
					case SYSTEMHEADER_BYTE4:			// #        SystemAudioLockFlag
																//  #       SystemVideoLockFlag
																//   1      MarkerBit
																//    ##### VideoBound
						ACCEPT(BXX1XXXXX);
					case SYSTEMHEADER_BYTE5:			// #        PacketRateRestrictionBit
																//  XXXXXXX
						ACCEPT(BXXXXXXXX);
					case SYSTEMHEADER_BYTE6:			// 00000000 goto PESPACKET_STARTCODEPREFIX1
																// 1####### StreamID
						CONSUME(b);
						if (!b) GOTO(PESPACKET_STARTCODEPREFIX1);
						mp->mpparse.streamID = b;
						PROCEED;
					case SYSTEMHEADER_STREAM0:			// 11
																//   #      PSTDBufferBoundScale
																//    ##### PSTDBufferSizeBound [12..8]
						ACCEPT(B11XXXXXX);
					case SYSTEMHEADER_STREAM1:			// ######## PSTDBufferSizeBound [7..0]
																// goto SYSTEMHEADER_BYTE6
						ACCEPTNGO(BXXXXXXXX, SYSTEMHEADER_BYTE6);

					case PESPACKET_STARTCODEPREFIX0:	// 00000000
						ACCEPT(B00000000);
					case PESPACKET_STARTCODEPREFIX1:	// 00000000
						ACCEPT(B00000000);
					case PESPACKET_STARTCODEPREFIX2:	// 00000001
						ACCEPT(B00000001);
					case PESPACKET_STREAMID:			// 10111011 goto SYSTEMHEADER_LENGTH0
																// 10111010 goto PACKHEADER_BYTE0
																// 10111001 goto PROGSTRM_FINAL
																// else
																// ######## streamID
						CONSUME(b);
						if      (CHECK(b, B10111011)) GOTO(SYSTEMHEADER_LENGTH0)
						else if (CHECK(b, B10111010)) GOTO(PACKHEADER_BYTE0)
						else if (CHECK(b, B10111001)) GOTO(PROGSTRM_FINAL)
						mp->mpparse.streamID = b;
						mp->mpparse.ptsValid = FALSE;
						mp->mpparse.dtsValid = FALSE;
						PROCEED;
					case PESPACKET_LENGTH0:				// ########
						CONSUME(mp->mpparse.high);
						PROCEED;
					case PESPACKET_LENGTH1:				// ########
																// if streamID != 10111101 &&
																//    streamID != videoStreamID && streamID != audioStreamID goto PESPACKET_SKIP
																// mpeg2 goto PESPACKET_HEADER0
						CONSUME(mp->mpparse.low);
						mp->mpparse.length = MAKEWORD(mp->mpparse.low, mp->mpparse.high);

						if (mp->mpparse.streamID == videoStreamID ||
							 mp->mpparse.streamID == audioStreamID ||
							 mp->mpparse.streamID == 0xBD)
							{
							if (mp->mpparse.mpeg2)
								{
								GOTO(PESPACKET_HEADER0);
								}
							else
								PROCEED;
							}
						else
							GOTO(PESPACKET_SKIP);

					case MP1PACKET_HEADER0:				// if (11111111) goto MP1PACKET_HEADER0
																// if (01XXXXXX) goto MP1PACKET_HEADER1
																// if (0010XXXX)
																// 0010
																//     ###  PTS[32..30]
																//        1 goto MP1PACKET_HEADER2
																// if (0011XXXX)
																// 0011
																//		 ###  PTS[32..30]
																//        1 goto MP1PACKET_HEADER6
																//	else
																// 00001111
																// goto MP1PACKET_DATA
						CONSUME(b);
						mp->mpparse.length--;
						if (CHECK(b, B11111111))
							{
							GOTO(MP1PACKET_HEADER0);
							}
						else if (CHECK(b, B01XXXXXX))
							{
							GOTO(MP1PACKET_HEADER1);
							}
						else if (CHECK(b, B0010XXX1))
							{
							mp->mpparse.ptss[0] = b;
							GOTO(MP1PACKET_HEADER2);
							}
						else if (CHECK(b, B0011XXX1))
							{
							mp->mpparse.ptss[0] = b;
							GOTO(MP1PACKET_HEADER6);
							}
						else if (CHECK(b, B00001111))
							{
							GOTO(MP1PACKET_DATA);
							}
						else
							REJECT;

					case MP1PACKET_HEADER1:				// XXXXXXXX	goto MP1PACKET_HEADER0
						CONSUME(b);
						mp->mpparse.length--;
						GOTO(MP1PACKET_HEADER0);

					case MP1PACKET_HEADER2:				// ######## PTS[29..22]
						CONSUME(mp->mpparse.ptss[1]);
						mp->mpparse.length--;
						PROCEED;
					case MP1PACKET_HEADER3:				// #######  PTS[21..15]
																//        1
						CONSUMEIF(mp->mpparse.ptss[2], BXXXXXXX1);
						mp->mpparse.length--;
						PROCEED;
					case MP1PACKET_HEADER4:				// ######## PTS[14..7]
						CONSUME(mp->mpparse.ptss[3]);
						mp->mpparse.length--;
						PROCEED;
					case MP1PACKET_HEADER5:				// #######  PTS[6..0]
																//        1
																// goto MP1PACKET_DATA
						CONSUMEIF(mp->mpparse.ptss[4], BXXXXXXX1);
						mp->mpparse.length--;
						mp->mpparse.pts = MKBF(29, 3, XTBFB(1, 3, mp->mpparse.ptss[0])) |
										  MKBF(21, 8,             mp->mpparse.ptss[1]) |
										  MKBF(14, 7, XTBFB(1, 7, mp->mpparse.ptss[2])) |
										  MKBF(6, 8,              mp->mpparse.ptss[3]) |
										  MKBF(0, 6,  XTBFB(2, 6, mp->mpparse.ptss[4]));
						mp->mpparse.ptsValid = TRUE;
						GOTO(MP1PACKET_DATA);

					case MP1PACKET_HEADER6:				// ######## PTS[29..22]
						CONSUME(mp->mpparse.ptss[1]);
						mp->mpparse.length--;
						PROCEED;
					case MP1PACKET_HEADER7:				// #######  PTS[21..15]
																//        1
						CONSUMEIF(mp->mpparse.ptss[2], BXXXXXXX1);
						mp->mpparse.length--;
						PROCEED;
					case MP1PACKET_HEADER8:				// ######## PTS[14..7]
						CONSUME(mp->mpparse.ptss[3]);
						mp->mpparse.length--;
						PROCEED;
					case MP1PACKET_HEADER9:				// #######  PTS[6..0]
																//        1
						CONSUMEIF(mp->mpparse.ptss[4], BXXXXXXX1);
						mp->mpparse.length--;
						mp->mpparse.pts = MKBF(29, 3, XTBFB(1, 3, mp->mpparse.ptss[0])) |
										  MKBF(21, 8,             mp->mpparse.ptss[1]) |
										  MKBF(14, 7, XTBFB(1, 7, mp->mpparse.ptss[2])) |
										  MKBF(6, 8,              mp->mpparse.ptss[3]) |
										  MKBF(0, 6,  XTBFB(2, 6, mp->mpparse.ptss[4]));
						mp->mpparse.ptsValid = TRUE;

						PROCEED;
					case MP1PACKET_HEADER10:			// 0001
																//     ###  DTS[32..30]
																//        1
						CONSUMEIF(mp->mpparse.ptss[0], B0001XXX1);
						mp->mpparse.length--;
						PROCEED;
					case MP1PACKET_HEADER11:			// ######## DTS[29..22]
						CONSUME(mp->mpparse.ptss[1]);
						mp->mpparse.length--;
						PROCEED;
					case MP1PACKET_HEADER12:			// #######  DTS[21..15]
																//        1
						CONSUMEIF(mp->mpparse.ptss[2], BXXXXXXX1);
						mp->mpparse.length--;
						PROCEED;
					case MP1PACKET_HEADER13:         // ######## DTS[14..7]
						CONSUME(mp->mpparse.ptss[3]);
						mp->mpparse.length--;
						PROCEED;
					case MP1PACKET_HEADER14:         // #######  DTS[6..0]
		                              				//        1
		                              				// goto MP1PACKET_DATA
						CONSUMEIF(mp->mpparse.ptss[4], BXXXXXXX1);
						mp->mpparse.length--;
						mp->mpparse.dts = MKBF(29, 3, XTBFB(1, 3, mp->mpparse.ptss[0])) |
										  MKBF(21, 8,             mp->mpparse.ptss[1]) |
										  MKBF(14, 7, XTBFB(1, 7, mp->mpparse.ptss[2])) |
										  MKBF(6, 8,              mp->mpparse.ptss[3]) |
										  MKBF(0, 6,  XTBFB(2, 6, mp->mpparse.ptss[4]));

						mp->mpparse.dtsValid = TRUE;
						GOTO(MP1PACKET_DATA);

					case PESPACKET_HEADER0:				// 10
																//   ##     Scrambling control
																//     #    Priority
																//      #   Data alignment
																//       #  Copyright
																//        # OriginalOrCopy
						ACCEPT(B10XXXXXX);
					case PESPACKET_HEADER1:				// ##       PTSDTSFlags
																//   #      ESCRFlag
																//    #     ESRateFlag
																//     #    DSMTrickModeFlag
																//      #   AdditionalCopyInfoFlag
																//       #  PESCRCFlag
																//        # PESExtensionFlag
						CONSUME(mp->mpparse.flags);
						PROCEED;
					case PESPACKET_HEADER2:				// ######## PESHeaderDataLength
						CONSUME(mp->mpparse.headerLength);
						mp->mpparse.headerRest = mp->mpparse.headerLength;
						PROCEED;

			// if PTSDTSFlags == 10

					case PESPACKET_HEADER3:				// 0010
																//     ###  PTS[32..30]
																//        1
						if (!CHECK(mp->mpparse.flags, B10XXXXXX)) GOTO(PESPACKET_HEADER8);
						CONSUMEIF(mp->mpparse.ptss[0], B0010XXX1);
						mp->mpparse.headerRest--;
						PROCEED;
					case PESPACKET_HEADER4:				// ######## PTS[22..29]
						CONSUME(mp->mpparse.ptss[1]);
						mp->mpparse.headerRest--;
						PROCEED;
					case PESPACKET_HEADER5:				// #######  PTS[15..21]
																//        1
						CONSUMEIF(mp->mpparse.ptss[2], BXXXXXXX1);
						mp->mpparse.headerRest--;
						PROCEED;
					case PESPACKET_HEADER6:				// ######## PTS[14..7]
						CONSUME(mp->mpparse.ptss[3]);
						mp->mpparse.headerRest--;
						PROCEED;
					case PESPACKET_HEADER7:				// #######  PTS[0..6]
																//        1
						CONSUMEIF(mp->mpparse.ptss[4], BXXXXXXX1);
						mp->mpparse.headerRest--;

						mp->mpparse.pts = MKBF(29, 3, XTBFB(1, 3, mp->mpparse.ptss[0])) |
										  MKBF(21, 8,             mp->mpparse.ptss[1]) |
										  MKBF(14, 7, XTBFB(1, 7, mp->mpparse.ptss[2])) |
										  MKBF(6, 8,              mp->mpparse.ptss[3]) |
										  MKBF(0, 6,  XTBFB(2, 6, mp->mpparse.ptss[4]));
						mp->mpparse.ptsValid = TRUE;

						GOTO(PESPACKET_HEADER18);

			// if PTSDTSFlags == 11

					case PESPACKET_HEADER8:				// 0011
																//     ###	PTS[32..30]
																//        1
						if (!CHECK(mp->mpparse.flags, B11XXXXXX)) GOTO(PESPACKET_HEADER18);

						CONSUMEIF(mp->mpparse.ptss[0], B0011XXX1);
						mp->mpparse.headerRest--;
						PROCEED;
					case PESPACKET_HEADER9: 			// ######## PTS[22..29]
						CONSUME(mp->mpparse.ptss[1]);
						mp->mpparse.headerRest--;
						PROCEED;
					case PESPACKET_HEADER10:			// #######  PTS[15..21]
																//        1
						CONSUMEIF(mp->mpparse.ptss[2], BXXXXXXX1);
						mp->mpparse.headerRest--;
						PROCEED;
					case PESPACKET_HEADER11:			// ######## PTS[14..7]
						CONSUME(mp->mpparse.ptss[3]);
						mp->mpparse.headerRest--;
						PROCEED;
					case PESPACKET_HEADER12:			// #######  PTS[0..6]
																//        1
						CONSUMEIF(mp->mpparse.ptss[4], BXXXXXXX1);
						mp->mpparse.headerRest--;

						mp->mpparse.pts = MKBF(29, 3, XTBFB(1, 3, mp->mpparse.ptss[0])) |
										  MKBF(21, 8, mp->mpparse.ptss[1]) |
										  MKBF(14, 7, XTBFB(1, 7, mp->mpparse.ptss[2])) |
										  MKBF(6, 8,  mp->mpparse.ptss[3]) |
										  MKBF(0, 6,  XTBFB(2, 6, mp->mpparse.ptss[4]));
						mp->mpparse.ptsValid = TRUE;

						PROCEED;
					case PESPACKET_HEADER13:			// 0001
																//     ###  DTS[32..30]
																//        1
						CONSUMEIF(mp->mpparse.ptss[0], B0001XXX1);
						mp->mpparse.headerRest--;
						PROCEED;
					case PESPACKET_HEADER14:			// ######## DTS[22..29]
						CONSUME(mp->mpparse.ptss[1]);
						mp->mpparse.headerRest--;
						PROCEED;
					case PESPACKET_HEADER15:			// #######  DTS[15..21]
																//        1
						CONSUMEIF(mp->mpparse.ptss[2], BXXXXXXX1);
						mp->mpparse.headerRest--;
						PROCEED;
					case PESPACKET_HEADER16:			// ######## DTS[14..7]
						CONSUME(mp->mpparse.ptss[3]);
						mp->mpparse.headerRest--;
						PROCEED;
					case PESPACKET_HEADER17:			// #######  DTS[0..6]
																//        1
						CONSUMEIF(mp->mpparse.ptss[4], BXXXXXXX1);
						mp->mpparse.headerRest--;

						mp->mpparse.dts = MKBF(29, 3, XTBFB(1, 3, mp->mpparse.ptss[0])) |
										  MKBF(21, 8, mp->mpparse.ptss[1]) |
										  MKBF(14, 7, XTBFB(1, 7, mp->mpparse.ptss[2])) |
										  MKBF(6, 8,  mp->mpparse.ptss[3]) |
										  MKBF(0, 6,  XTBFB(2, 6, mp->mpparse.ptss[4]));
						mp->mpparse.dtsValid = TRUE;

						PROCEED;

			// if ESCRFlag

					case PESPACKET_HEADER18:			// XX
																//   ###    ESCR[32..30]
																//      1
																//       ## ESCR[29..28]
						if (!CHECK(mp->mpparse.flags, BXX1XXXXX)) GOTO(PESPACKET_HEADER25);

						ACCEPT(BXXXXX1XX);
						mp->mpparse.headerRest--;

					case PESPACKET_HEADER19:			// ######## ESCR[27..20]
						ACCEPT(BXXXXXXXX);
						mp->mpparse.headerRest--;

					case PESPACKET_HEADER20:			// #####    ESCR[19..15]
																//      1
																//       ## ESCR[14..13]
						ACCEPT(BXXXXX1XX);
						mp->mpparse.headerRest--;

					case PESPACKET_HEADER22:			// ######## ESCR[12..5]
						ACCEPT(BXXXXXXXX);
						mp->mpparse.headerRest--;

					case PESPACKET_HEADER23:			// #####    ESCR[4..0]
																//      1
																//       ## ESCRX[8..7]
						ACCEPT(BXXXXX1XX);
						mp->mpparse.headerRest--;

					case PESPACKET_HEADER24:			// #######  ESCRX[6..0]
																//        1
						ACCEPT(BXXXXXXX1);
						mp->mpparse.headerRest--;


			// if ESRateFlag

					case PESPACKET_HEADER25:			// 1
																//  ####### ESRATE[14..21]
						if (!CHECK(mp->mpparse.flags, BXXX1XXXX)) GOTO(PESPACKET_HEADER28);
						ACCEPT(B1XXXXXXX);
						mp->mpparse.headerRest--;

					case PESPACKET_HEADER26:			// ######## ESRATE[14..7]
						ACCEPT(BXXXXXXXX);
						mp->mpparse.headerRest--;

					case PESPACKET_HEADER27:			// #######  ESRATE[6..0]
																//        1
						ACCEPT(BXXXXXXX1);
						mp->mpparse.headerRest--;


			// if DSMTrickModeFlag

					case PESPACKET_HEADER28:			// ###      TrickModeControl
																//    ##    FieldID
																//      #   IntraSlizeRefresh
																//       ## FrequencyTruncation
																//    ##### RepCntrl
																//    ##    FieldID
																//      ### Reserved
						if (!CHECK(mp->mpparse.flags, BXXXX1XXX)) GOTO(PESPACKET_HEADER29)
						ACCEPT(BXXXXXXXX);
						mp->mpparse.headerRest--;

			// if AdditionalCopyInfoFlag

					case PESPACKET_HEADER29:			// 1
																//  ####### AdditionalCopyInfo

						if (!CHECK(mp->mpparse.flags, BXXXXX1XX)) GOTO(PESPACKET_HEADER30)
						ACCEPT(B1XXXXXXX);
						mp->mpparse.headerRest--;

			// if PESCRCFlag

					case PESPACKET_HEADER30:			// ######## CRC[15..8]
						if (!CHECK(mp->mpparse.flags, BXXXXXX1X)) GOTO(PESPACKET_HEADER32);
						ACCEPT(BXXXXXXXX);
						mp->mpparse.headerRest--;

					case PESPACKET_HEADER31:			// ######## CRC[7..0]
						ACCEPT(BXXXXXXXX);
						mp->mpparse.headerRest--;

			// if PESExtensionFlag

					case PESPACKET_HEADER32:			// #        PESPrivateDataFlag
																//  #       PackHeaderFieldFlag
																//   #      ProgramPacketSequenceCounterFlag
																//    #     PSTDBufferFlag
																//     XXX
																//        # PESExtensionFlag2
						if (!CHECK(mp->mpparse.flags, BXXXXXXX1)) GOTO(PESPACKET_STUFFING);
						CONSUME(mp->mpparse.xflags);
						mp->mpparse.headerRest--;
						PROCEED;

				// if PESPrivateDataFlag

					case PESPACKET_PRIVATEDATA:		// XXXXXXXX times 32
						if (!CHECK(mp->mpparse.xflags, B1XXXXXXX)) GOTO(PESPACKET_PACKFIELDLENGTH);
						mp->mpparse.low = 32;
						PROCEED;

					case PESPACKET_PRIVATESKIP:		// XXXXXXXX times 32
						SKIP(mp->mpparse.low);
						mp->mpparse.headerRest-=32;

						PROCEED;

				// if PackHeaderFieldFlag

					case PESPACKET_PACKFIELDLENGTH:	// XXXXXXXX PackFieldLength
						if (!CHECK(mp->mpparse.xflags, BX1XXXXXX)) GOTO(PESPACKET_HEADER33);

						CONSUME(mp->mpparse.low);
						mp->mpparse.headerRest--;

						PROCEED;
					case PESPACKET_PACKHEDADER:		// ######## times PackFieldLength
						SKIP(mp->mpparse.low);
						mp->mpparse.headerRest-=mp->mpparse.low;

						PROCEED;

				// if ProgramPacketSequenceCounterFlag

					case PESPACKET_HEADER33:			// 1
																//  ####### ProgramPacketSequenceCounter
						if (!CHECK(mp->mpparse.xflags, BXX1XXXXX)) GOTO(PESPACKET_HEADER35);

						ACCEPT(B1XXXXXXX);
						mp->mpparse.headerRest--;

						PROCEED;
					case PESPACKET_HEADER34:			// 1
																//  #       MPEG12Identifier
																//   ###### OriginalStuffLength
						ACCEPT(B1XXXXXXX);
						mp->mpparse.headerRest--;

				// if PSTDBufferFlag

			   		PROCEED;
					case PESPACKET_HEADER35:			// 01
																//   #      PSTDBufferScale
																//    ##### PSTDBufferSize[13..8]
						if (!CHECK(mp->mpparse.xflags, BXXX1XXXX)) GOTO(PESPACKET_HEADER37);
						ACCEPT(B01XXXXXX);
						mp->mpparse.headerRest--;
						PROCEED;

					case PESPACKET_HEADER36:			// ######## PSTDBufferSize[7..0]
						ACCEPT(BXXXXXXXX);
						mp->mpparse.headerRest--;

				// if PESExtensionFlag2

						PROCEED;

					case PESPACKET_HEADER37:			// 1
																//  ####### PESExtensionFieldLength
						if (!CHECK(mp->mpparse.xflags, BXXXXXXX1)) GOTO(PESPACKET_STUFFING);
						CONSUMEIF(b, B1XXXXXXX);
						mp->mpparse.headerRest--;
						mp->mpparse.low = XTBFB(0, 7, b);
						PROCEED;

					case PESPACKET_EXTENSIONFIELD:	// XXXXXXXX times PESExtensionFieldLength
						SKIP(mp->mpparse.low);
						mp->mpparse.headerRest-=mp->mpparse.low;
						PROCEED;

					case PESPACKET_STUFFING:			// XXXXXXXX times rest of PESHeaderDataLength
						SKIP(mp->mpparse.headerRest);
						PROCEED;
					case PESPACKET_DATA:					// XXXXXXXX times PESPacketLength - 3 - PESHeaderDataLength
																// goto PESPACKET_STARTCODEPREFIX0
						mp->mpparse.length-=mp->mpparse.headerLength+3;
						if      (mp->mpparse.streamID == videoStreamID)
							{
							videoTracker.AddTrack(streamInputPos + size - rest, videoInputPos);
							GOTO(PESPACKET_VIDEO);
							}
						else if (mp->mpparse.streamID == audioStreamID)
							{
							audioTracker.AddTrack(streamInputPos + size - rest, audioInputPos);
							GOTO(PESPACKET_AUDIO);
							}
						else if (mp->mpparse.streamID == 0xBD)
							{
							GOTO(PESPACKET_PRIVATE);
							}

						SKIP(mp->mpparse.length);
						GOTO(PESPACKET_STARTCODEPREFIX0);
					case MP1PACKET_DATA:
						if      (mp->mpparse.streamID == videoStreamID)
							{
							videoTracker.AddTrack(streamInputPos + size - rest, videoInputPos);
							GOTO(PESPACKET_VIDEO);
							}
						else if (mp->mpparse.streamID == audioStreamID)
							{
							audioTracker.AddTrack(streamInputPos + size - rest, audioInputPos);
							GOTO(PESPACKET_AUDIO);
							}

						SKIP(mp->mpparse.length);
						GOTO(PESPACKET_STARTCODEPREFIX0);
					case PESPACKET_VIDEO:				// ######## times PESPacketlength - 3 - PESHeaderDataLength
																// goto PESPACKET_STARTCODEPREFIX0
						if (mp->mpparse.ptsValid)
							{
							timeStamp = mp->mpparse.pts / 45;

							if (initialVideoTime == -1) initialVideoTime = timeStamp;

							videoDecoder.AddTimeStamp(timeStamp);
							mp->mpparse.ptsValid = FALSE;
							}

						if (mp->mpparse.length >= rest)
							{
							done = videoDecoder.SendData(p, rest);
							videoInputPos += done;
							mp->mpparse.length-=done;
							rest-=done;
							streamInputPos += size-rest;
							return size-rest;
							}
						else
							{
							done = videoDecoder.SendData(p, mp->mpparse.length);
							videoInputPos += done;
							mp->mpparse.length-=done;
							rest-=done;
							if (mp->mpparse.length)
								{
								streamInputPos += size-rest;
								return size-rest;
								}
							p+=done;
							}

						GOTO(PESPACKET_STARTCODEPREFIX0);
					case PESPACKET_AUDIO:				// ######## times PESPacketLength - 3 - PESHeaderDataLength
																// goto PESPACKET_STARTCODEPREFIX0
						// For MPEG audio in non-DVD sources.
						initialAudioPacket = FALSE;
						if (mp->mpparse.ptsValid)
							{
							audioDecoder->AddTimeStamp(mp->mpparse.pts / 45);
							mp->mpparse.ptsValid = FALSE;
							}

						if (mp->mpparse.length >= rest)
							{
							done = audioDecoder->SendData(p, rest);
							audioInputPos += done;
							mp->mpparse.length-=done;
							rest-=done;
							streamInputPos += size-rest;
							return size-rest;
							}
						else
							{
							done = audioDecoder->SendData(p, mp->mpparse.length);
							audioInputPos += done;
							mp->mpparse.length-=done;
							rest-=done;
							if (mp->mpparse.length)
								{
								streamInputPos += size-rest;
								return size-rest;
								}
							p+=done;
							}

						GOTO(PESPACKET_STARTCODEPREFIX0);
					case PESPACKET_SKIP:					// ######## times PESPacketLength
						SKIP(mp->mpparse.length);
						GOTO(PESPACKET_STARTCODEPREFIX0);

					case PESPACKET_PRIVATE:				// if ######## != AC3 GOTO PESPACKET_SKIP
						CONSUME(b);
						mp->mpparse.length--;

						if (b == spuStreamID)
							{
							GOTO(PESPACKET_SUBPICTURE);
							}

						if (b == lpcmStreamID && audioType == MP2AUDTYP_LPCM)
							{
							audioTracker.AddTrack(streamInputPos + size - rest, audioInputPos);

							GOTO(PESPACKET_LPCM_SKIP0);
							}

						if (b != ac3StreamID || audioType != MP2AUDTYP_AC3)
							{
							GOTO(PESPACKET_SKIP);
							}

						audioTracker.AddTrack(streamInputPos + size - rest, audioInputPos);
						PROCEED;
					case PESPACKET_AC3_SKIP0:			// 2*XXXXXXXX
						CONSUME(b);
						mp->mpparse.length--;
						PROCEED;
					case PESPACKET_AC3_SKIP1:			// 2*XXXXXXXX
						CONSUME(mp->mpparse.high);
						mp->mpparse.length--;
						PROCEED;
					case PESPACKET_AC3_SKIP2:			// 2*XXXXXXXX
						CONSUME(mp->mpparse.low);
						mp->mpparse.length--;
						if (!initialAudioPacket) GOTO(PESPACKET_AC3);

						if (mp->mpparse.low == 0 && mp->mpparse.high == 0)
							{
							GOTO(PESPACKET_STARTCODEPREFIX0);
							}
						else
							{
							mp->mpparse.headerRest = MAKEWORD(mp->mpparse.low, mp->mpparse.high)-1;
							mp->mpparse.length-=mp->mpparse.headerRest;
							initialAudioPacket = FALSE;
							PROCEED;
							}
					case PESPACKET_AC3_SKIP3:			// 2*XXXXXXXX
						SKIP(mp->mpparse.headerRest);
						PROCEED;
					case PESPACKET_AC3:					// ######## times PESPacketLength - 4 - PESHeaderDataLength
																// goto PESPACKET_STARTCODEPREFIX2
						if (mp->mpparse.ptsValid)
							{
							audioDecoder->AddTimeStamp(mp->mpparse.pts / 45);
							mp->mpparse.ptsValid = FALSE;
							}

						if (mp->mpparse.length >= rest)
							{
							done = audioDecoder->SendData(p, rest);
							audioInputPos += done;
							mp->mpparse.length-=done;
							rest-=done;
							streamInputPos += size-rest;
							return size-rest;
							}
						else
							{
							done = audioDecoder->SendData(p, mp->mpparse.length);
							audioInputPos += done;
							mp->mpparse.length-=done;
							rest-=done;
							if (mp->mpparse.length)
								{
								streamInputPos += size-rest;
								return size-rest;
								}
							p+=done;
							}

						GOTO(PESPACKET_STARTCODEPREFIX0);

					case PESPACKET_SUBPICTURE:			// ######## times PESPacketLength - 4 - PESHeaderDataLength
																// goto PESPACKET_STARTCODEPREFIX2
						if (mp->mpparse.ptsValid)
							{
							spuDecoder.AddTimeStamp(mp->mpparse.pts / 45);
							mp->mpparse.ptsValid = FALSE;
							}

						if (mp->mpparse.length >= rest)
							{
							done = spuDecoder.SendData(p, rest);
							mp->mpparse.length-=done;
							rest-=done;
							streamInputPos += size-rest;
							return size-rest;
							}
						else
							{
							done = spuDecoder.SendData(p, mp->mpparse.length);
							mp->mpparse.length-=done;
							rest-=done;
							if (mp->mpparse.length)
								{
								streamInputPos += size-rest;
								return size-rest;
								}
							p+=done;
							}

						GOTO(PESPACKET_STARTCODEPREFIX0);

					case PESPACKET_LPCM_SKIP0:			// 2*XXXXXXXX
						CONSUME(b);
						mp->mpparse.length--;
						PROCEED;
					case PESPACKET_LPCM_SKIP1:			// 2*XXXXXXXX
						CONSUME(mp->mpparse.high);
						mp->mpparse.length--;
						PROCEED;
					case PESPACKET_LPCM_SKIP2:			// 2*XXXXXXXX
						CONSUME(mp->mpparse.low);
						mp->mpparse.length--;
						if (!initialAudioPacket)
							{
							mp->mpparse.headerRest = 3;
							mp->mpparse.length-=mp->mpparse.headerRest;
							PROCEED;
							}
						else
							{
							if (mp->mpparse.low == 0 && mp->mpparse.high == 0)
								{
								GOTO(PESPACKET_STARTCODEPREFIX0);
								}
							else
								{
								mp->mpparse.headerRest = MAKEWORD(mp->mpparse.low, mp->mpparse.high)-1;
								mp->mpparse.length-=mp->mpparse.headerRest;
								initialAudioPacket = FALSE;
								PROCEED;
								}
							}
					case PESPACKET_LPCM_SKIP3:			// 2*XXXXXXXX
						SKIP(mp->mpparse.headerRest);
						PROCEED;
					case PESPACKET_LPCM:					// ######## times PESPacketLength - 4 - PESHeaderDataLength
																// goto PESPACKET_STARTCODEPREFIX2
						if (mp->mpparse.ptsValid)
							{
							lpcmDecoder.AddTimeStamp(mp->mpparse.pts / 45);
							mp->mpparse.ptsValid = FALSE;
							}

						if (mp->mpparse.length >= rest)
							{
							done = audioDecoder->SendData(p, rest);
							audioInputPos += done;
							mp->mpparse.length-=done;
							rest-=done;
							streamInputPos += size-rest;
							return size-rest;
							}
						else
							{
							done = audioDecoder->SendData(p, mp->mpparse.length);
							audioInputPos += done;
							mp->mpparse.length-=done;
							rest-=done;
							if (mp->mpparse.length)
								{
								streamInputPos += size-rest;
								return size-rest;
								}
							p+=done;
							}

						GOTO(PESPACKET_STARTCODEPREFIX0);

					case PROGSTRM_RECOVER1:          // if !00000000 GOTO PROGSTRM_RECOVER1
						CONSUME(b);
						if (!CHECK(b, B00000000)) GOTO(PROGSTRM_RECOVER1);
						PROCEED;
					case PROGSTRM_RECOVER2:          // if !00000000 GOTO PROGSTRM_RECOVER1
						CONSUME(b);
						if (!CHECK(b, B00000000)) GOTO(PROGSTRM_RECOVER1);
						PROCEED;
					case PROGSTRM_RECOVER3:				// if !00000001 GOTO PROGSTRM_RECOVER1
						CONSUME(b);
						if (CHECK(b, B00000000)) GOTO(PROGSTRM_RECOVER3);
						if (!CHECK(b, B00000001)) GOTO(PROGSTRM_RECOVER1);
						PROCEED;
					case PROGSTRM_RECOVER4:				//	if !10111010 GOTO PROGSTRM_RECOVER1 else GOTO PACKHEADER_BYTE0
						if (mp->streamType == DVSST_PROGRAM)
							{
							GOTO(PROGSTRM_PACKSTART3);
							}
						else
							{
							GOTO(PESPACKET_STREAMID);
							}
					default:
						REJECT;
					}
				}

			streamInputPos += size;
			return size;
			}
		case DVSST_ELEMENTARY:
			{
			int done;

			switch (type)
				{
				case DVEST_VIDEO:
					if (initialVideoTime == -1) initialVideoTime = externalTimeStamp;
					if (externalTimeStamp >= 0) videoDecoder.AddTimeStamp(externalTimeStamp);
					videoTracker.AddTrack(streamInputPos, videoInputPos);
					done = videoDecoder.SendData(ptr, num);
#if VIDEO_DUMP
					DWORD dummy;
					::WriteFile(videoStream, ptr, done, &dummy, NULL);
#endif
					streamInputPos += done;
					videoInputPos += done;
					break;
				case DVEST_AUDIO:
					if (externalTimeStamp >= 0) audioDecoder->AddTimeStamp(externalTimeStamp);
					audioTracker.AddTrack(streamInputPos, videoInputPos);
					done =  audioDecoder->SendData(ptr, num);
					streamInputPos += done;
					audioInputPos += done;
					break;
				case DVEST_SUBPICTURE:
					if (externalTimeStamp >= 0) spuDecoder.AddTimeStamp(externalTimeStamp);
					done =  spuDecoder.SendData(ptr, num);
					streamInputPos += done;
					break;
				default:
					done = num;
				}

			return done;
			}
		}

	return 0;
	}

//
//  Complete Data
//

void DVDStreamDecoder::CompleteData(void)
	{
#if DUMP_STREAM_EVENTS>=1
	DTE("CompleteData");
#endif

	BYTE EOS[] = {0x00, 0x00, 0x01, 0xb7, 0x00, 0x00, 0x00, 0x00};

	dataCompleted = TRUE;
	splitCompletion = FALSE;

	switch (streamType)
		{
		case DVST_PROGRAM_STREAM:
			if (playbackMode == VDPM_SCANNING || playbackMode == VDPM_TRICKPLAY)
				{
				videoDecoder.SendData(EOS, 8);
				}
			videoDecoder.CompleteData();
			if (playbackMode == VDPM_PLAY_FORWARD)
				{
				if (initialVideoTime >= 0 && initialAudioPacket)
					{
					display->SetVideoStartTiming(initialVideoTime);
					initialVideoTime = -1;
					}

				audioDecoder->CompleteData();
				spuDecoder.CompleteData();
				}
			break;
		case DVST_ELEMENTARY_AUDIO_STREAM:
			audioDecoder->CompleteData();
			break;
		case DVST_ELEMENTARY_VIDEO_STREAM:
			videoDecoder.CompleteData();
			break;
		}

	DeferedStartStreaming();
	}

//
//  Complete Data Split
//

void DVDStreamDecoder::CompleteDataSplit(DVDElementaryStreamType type)
	{
#if DUMP_STREAM_EVENTS>=1
		{
		char buffer[100];
		wsprintf(buffer, "Enter CompleteDataSplit %d", type);
		DTE(buffer);
		}
#endif

	mpeparse[type].completing = TRUE;
	mpeparse[type].completed = FALSE;

	switch (type)
		{
		case DVEST_VIDEO:
			splitCompletion = TRUE;
			videoDecoder.CompleteData();
			if (playbackMode == VDPM_PLAY_FORWARD)
				{
				if (initialVideoTime >= 0 && initialAudioPacket)
					{
					display->SetVideoStartTiming(initialVideoTime);
					initialVideoTime = -1;
					}
				}
			break;
		case DVEST_AUDIO:
			splitCompletion = TRUE;
			audioDecoder->CompleteData();
			break;
		case DVEST_SUBPICTURE:
			splitCompletion = TRUE;
			spuDecoder.CompleteData();
			break;
		case DVEST_MULTIPLEXED:
			CompleteData();
			break;
		}

	if (streamInputPos > 500000 || audioInputPos > 100000 || EnoughStreamsCompleteToStart()) DeferedStartStreaming();

#if DUMP_STREAM_EVENTS>=1
		{
		char buffer[100];
		wsprintf(buffer, "Leave CompleteDataSplit %d", type);
		DTE(buffer);
		}
#endif
	}

//
//  Restart Data Split
//

void DVDStreamDecoder::RestartDataSplit(DVDElementaryStreamType type)
	{
#if DUMP_STREAM_EVENTS>=1
		{
		char buffer[100];
		wsprintf(buffer, "Enter RestartDataSplit %d", type);
		DTE(buffer);
		}
#endif
	DeferedStartStreaming();

	switch (type)
		{
		case DVEST_VIDEO:
			DP("VD SV");
			videoDecoder.StopStreaming();
			DP("VD ES");
			videoDecoder.EndStreaming(FALSE);
			DP("VD DONE");
			break;
		case DVEST_AUDIO:
			audioDecoder->StopStreaming();
			audioDecoder->EndStreaming(FALSE);
			break;
		case DVEST_SUBPICTURE:
			spuDecoder.StopStreaming();
			spuDecoder.EndStreaming(FALSE);
			break;
		case DVEST_MULTIPLEXED:
			break;
		}

	mpeparse[type].completing = FALSE;
	mpeparse[type].completed = FALSE;

	mpeparse[type].pesState = idle;
	mpeparse[type].endPTM = 0;
	mpeparse[type].ptsOffset = 0;
	mpeparse[type].mpparse.state = PROGSTRM_INITIAL;
	mpeparse[type].mpparse.mpeg2 = FALSE;

	mpeparse[type].mpparse.ptsValid = FALSE;
	mpeparse[type].mpparse.dtsValid = FALSE;
	mpeparse[type].pendingData = NULL;

	switch (type)
		{
#if VIDEO_DUMP
		{
		if (videoStream) ::CloseHandle(videoStream);
		char buffer[100];
		videoStreamCount++;
		wsprintf(buffer, "c:\\videodump\\strm%03d.mpg", videoStreamCount);

		videoStream = ::CreateFile(buffer,
								  GENERIC_WRITE,
								  FILE_SHARE_WRITE,
								  NULL,
								  CREATE_ALWAYS,
								  FILE_ATTRIBUTE_NORMAL,
								  NULL);
		}
#endif
		case DVEST_VIDEO:
			videoDecoder.FlushBuffer();
			videoTracker.Flush();
			videoInputPos = 0;
			initialVideoTime = -1;
			videoDecoder.BeginStreaming(playbackMode, highQuality);
			videoDecoder.StartStreaming(playbackSpeed);

			// Hack for MS Navigator, in case video data discontinuity arrives
			// after spu data for this frame
			spuDecoder.VideoDisplayBeginStreaming();
			break;
		case DVEST_AUDIO:
			audioDecoder->FlushBuffer();
			audioTracker.Flush();
			audioInputPos = 0;
			initialAudioPacket = TRUE;
			audioDecoder->BeginStreaming();
			audioDecoder->StartStreaming(playbackSpeed);
			break;
		case DVEST_SUBPICTURE:
			spuDecoder.FlushBuffer();
			spuDecoder.BeginStreaming(highQuality);
			spuDecoder.StartStreaming(playbackSpeed);
			break;
		}
#if DUMP_STREAM_EVENTS>=1
		{
		char buffer[100];
		wsprintf(buffer, "Leave RestartDataSplit %d", type);
		DTE(buffer);
		}
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\AC3Decoder\AC3StreamDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "AC3StreamDecoder.h"
#include "library\common\vddebug.h"

#pragma warning(disable : 4355)
AC3StreamDecoder::AC3StreamDecoder(PCMWaveOut * pcmWaveOut, TimingSlave * timingSlave, GenericProfile * globalProfile, GenericProfile * profile, StreamFlipCopy * streamFlipCopy)
									: AC3Decoder(this, pcmWaveOut, timingSlave, globalProfile, profile),
									  AudioStreamDecoder(pcmWaveOut, streamFlipCopy),
									  supervisor(this),
									  TimedFiber(2)
	{
	streaming = FALSE;
	frameDuration = 32;
	this->streamFlipCopy = streamFlipCopy;
	wordCopySwap = new StreamFlipWordCopy;
	}
#pragma warning(default : 4355)

AC3StreamDecoder::~AC3StreamDecoder(void)
	{
	if (streaming) EndStreaming(TRUE);
	delete wordCopySwap;
	}

void AC3StreamDecoder::FiberRoutine(void)
	{
	int buffer;

	while (strm->RefillBuffer(40))//12288))
		{
		ParseSyncFrame();

		if (!avgFrameSize)
			avgFrameSize = frameSize;
		else
			avgFrameSize = (avgFrameSize * 7 + frameSize) >> 3;

		buffer = AudioStreamDecoder::pcmWaveOut->GetBufferDelayTime();

		if (hurryUp && buffer > 400)
			{
			hurryUp = FALSE;

			SetFiberPriority(2);
			}
		else if (!hurryUp && buffer < 300)
			{
			hurryUp = TRUE;
			lowPriority = FALSE;

			SetFiberPriority(3);
			}
		else if (lowPriority && buffer < 500)
			{
			lowPriority = FALSE;

			SetFiberPriority(2);
			}
		else if (!lowPriority && buffer > 600)
			{
			lowPriority = TRUE;
			hurryUp = FALSE;

			SetFiberPriority(1);
			}

		if (!hurryUp) YieldFiber(0);
		else YieldFiber(-1);
		}

	if (!terminate)
		{
		AudioStreamDecoder::pcmWaveOut->CompleteStreaming();

		AudioStreamDecoder::pcmWaveOut->WaitForCompletion();
		}

	streamingCompleted = TRUE;
	StreamCompleted();
	}

AC3StreamDecoder::Supervisor::Supervisor(AC3StreamDecoder * decoder)
	: TimedFiber(4)
	{
	this->decoder = decoder;
	}

void AC3StreamDecoder::Supervisor::FiberRoutine(void)
	{
	SetFiberPriority(3);
	decoder->SupervisorFiberRoutine();
	}

void AC3StreamDecoder::SupervisorFiberRoutine(void)
	{
	int buffer;

	while (!terminate)
		{
		buffer = AudioStreamDecoder::pcmWaveOut->GetBufferDelayTime();

		if (hurryUp && buffer > 400)
			{
			hurryUp = FALSE;

			SetFiberPriority(2);
			}
		else if (!hurryUp && buffer < 300)
			{
			hurryUp = TRUE;
			lowPriority = FALSE;

			SetFiberPriority(3);
			}
		else if (lowPriority && buffer < 500)
			{
			lowPriority = FALSE;

			SetFiberPriority(2);
			}
		else if (!lowPriority && buffer > 600)
			{
			lowPriority = TRUE;
			hurryUp = FALSE;

			SetFiberPriority(1);
			}

		YieldTimedFiber(100);
		}
	}


void AC3StreamDecoder::InitLocalsNewStream(void)
	{
	SetFiberPriority(3);
	lowPriority = FALSE;
	streaming = TRUE;
	avgFrameSize = 0;
	byteOrder = BO_UNKNOWN;
	AudioStreamDecoder::SetStreamFlipCopy(streamFlipCopy);
	supervisor.StartFiber();
	StartFiber();
	}

void AC3StreamDecoder::ClosingCurrentStream(void)
	{
	CompleteFiber();
	supervisor.CompleteFiber();
	FlushBuffer();
	streaming = FALSE;
	}

void AC3StreamDecoder::BeginStreaming(void)
	{
	AudioStreamDecoder::BeginStreaming();
	AC3Decoder::BeginStreaming();
	InitLocalsNewStream();
	}

void AC3StreamDecoder::StartStreaming(int playbackSpeed)
	{
	AC3Decoder::StartStreaming(playbackSpeed);
	AudioStreamDecoder::StartStreaming(playbackSpeed);
	}

void AC3StreamDecoder::StopStreaming(void)
	{
	AC3Decoder::StopStreaming();
	AudioStreamDecoder::StopStreaming();
	}

void AC3StreamDecoder::EndStreaming(bool fullReset)
	{
	if (streaming)
		{
		AudioStreamDecoder::EndStreaming(fullReset);
		AC3Decoder::EndStreaming(fullReset);
		ClosingCurrentStream();
		}
	}

void AC3StreamDecoder::DetachStreaming(void)
	{
	if (streaming)
		{
		AudioStreamDecoder::DetachStreaming();
		AC3Decoder::DetachStreaming();
		ClosingCurrentStream();
		}
	}

void AC3StreamDecoder::AttachStreaming(void)
	{
	AudioStreamDecoder::AttachStreaming();
	AC3Decoder::AttachStreaming();
	InitLocalsNewStream();
	}

void AC3StreamDecoder::CompleteData(void)
	{
	BYTE fakeheader[] = {0x0b, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

	if (!completing)
		{
		BYTE revfakeheader[] = {0x77, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
		if (byteOrder == BO_REVERSE)
			{
			AddData(revfakeheader, 8);
			}
		else
			{
			AddData(fakeheader, 8);
			}
		StuffBuffer();						// Fill up to next DWORD
		completing = TRUE;
		bufferRefillEvent.SetEvent();
		}
	}

//
//  Send Data
//
DWORD AC3StreamDecoder::SendData(BYTE * ptr, DWORD num)
	{
	// check byte order for AC3 file playback.  This is not a complete solution for
	// all AC3 decoding cases.

	// do the most common path first
	if (byteOrder != BO_UNKNOWN)
		{
		return(AudioStreamDecoder::SendData(ptr, num));
		}

	else
		{
		byteOrder = BO_FORWARD;
		if (ptr[0] == 0x0b && ptr[1] == 0x77)
			{
//			DP("AC3 Stream Forward");
			}

		else if (ptr[0] == 0x77 && ptr[1] == 0x0b)
			{
			byteOrder = BO_REVERSE;
			AudioStreamDecoder::SetStreamFlipCopy(wordCopySwap);
//			DP("AC3 Stream Reversed");
			}
		return(AudioStreamDecoder::SendData(ptr, num));
		}

	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\AC3Decoder\AC3Tables.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef AC3TABLES_H
#define AC3TABLES_H

#pragma warning(disable : 4244 4305)

fftreal AC3WindowTable[] =
{	0.00013599222102497970, 0.00024390075569190740,
	0.00036650249012168420, 0.00050775455634249020,
	0.00067003741545111320, 0.00085540018968976050,
	0.00106582120878971700, 0.00130328810777037200,
	0.00156982798766209500, 0.00186752016070029800,
	0.00219850172477049000, 0.00256496979050667600,
	0.00296918196552255300, 0.00341345583164787600,
	0.00390016777773989800, 0.00443175137772520200,
	0.00501069541836261300, 0.00563954163710084100,
	0.00632088220659456300, 0.00705735698917348000,
	0.00785165057699395300, 0.00870648912923880700,
	0.00962463701522140900, 0.01060889327084518000,
	0.01166208787513903000, 0.01278707785327832000,
	0.01398674321245617000, 0.01526398271709502000,
	0.01662170951012335000, 0.01806284658734745000,
	0.01959032213229660000, 0.02120706471929521000,
	0.02291599839290348000, 0.02472003763226172000,
	0.02662208220926438000, 0.02862501194987473000,
	0.03073168140826510000, 0.03294491446382805000,
	0.03526749885144791000, 0.03770218063574844000,
	0.04025165864033783000, 0.04291857884335669000,
	0.04570552875089542000, 0.04861503176008421000,
	0.05164954152386971000, 0.05481143632967689000,
	0.05810301350431179000, 0.06152648385758921000,
	0.06508396617726904000, 0.06877748178795473000,
	0.07260894918664700000, 0.07658017876765444000,
	0.08069286764954062000, 0.08494859461673288000,
	0.08934881518833321000, 0.09389485682655344000,
	0.09858791429704832000, 0.10342904519323890000,
	0.10841916563650530000, 0.11355904616388530000,
	0.11884930781463720000, 0.12429041842672210000,
	0.12988268915392190000, 0.13562627121394420000,
	0.14152115287747020000, 0.14756715670767640000,
	0.15376393705931050000, 0.16011097784592470000,
	0.16660759058336360000, 0.17325291271707610000,
	0.18004590624027020000, 0.18698535660935180000,
	0.19406987196249550000, 0.20129788264657720000,
	0.20866764105706680000, 0.21617722179482510000,
	0.22382452214308330000, 0.23160726286720280000,
	0.23952298933911760000, 0.24756907298765980000,
	0.25574271307525080000, 0.26404093880072350000,
	0.27246061172731150000, 0.28099842853410780000,
	0.28965092408856810000, 0.29841447483689030000,
	0.30728530250837750000, 0.31625947812915590000,
	0.32533292633989470000, 0.33450143001145930000,
	0.34376063515171320000, 0.35310605609598990000,
	0.36253308097306210000, 0.37203697743776400000,
	0.38161289866076330000, 0.39125588956533360000,
	0.40096089330035910000, 0.41072275793819400000,
	0.42053624338542490000, 0.43039602849401680000,
	0.44029671835979840000, 0.45023285179472930000,
	0.46019890895891440000, 0.47018931913787830000,
	0.48019846865019380000, 0.49022070887016580000,
	0.50025036434991710000, 0.51028174102489790000,
	0.52030913448655070000, 0.53032683830560710000,
	0.54032915238927760000, 0.55031039135540850000,
	0.56026489290654190000, 0.57018702618670230000,
	0.58007120010366910000, 0.58991187159946430000,
	0.59970355385179350000, 0.60944082438922710000,
	0.61911833310300200000, 0.62873081013844550000,
	0.63827307364919760000, 0.64774003739761270000,
	0.65712671818496890000, 0.66642824309540150000,
	0.67563985653780090000, 0.68475692707028180000,
	0.69377495399222980000, 0.70268957368937430000,
	0.71149656571781540000, 0.72019185861343900000,
	0.72877153541371600000, 0.73723183887945320000,
	0.74556917640469600000, 0.75378012460362260000,
	0.76186143356396490000, 0.76981003075720330000,
	0.77762302459652930000, 0.78529770763434710000,
	0.79283155939189220000, 0.80022224881437120000,
	0.80746763634588940000, 0.81456577561931090000,
	0.82151491475710000000, 0.82831349728011890000,
	0.83496016262230000000, 0.84145374625007490000,
	0.84779327938641900000, 0.85397798834036520000,
	0.86000729344384020000, 0.86588080759869920000,
	0.87159833443784910000, 0.87715986610538050000,
	0.88256558066166320000, 0.88781583912038040000,
	0.89291118212551570000, 0.89785232627731880000,
	0.90264016011729620000, 0.90727573978326750000,
	0.91176028434651850000, 0.91609517084404420000,
	0.92028192901981940000, 0.92432223578994920000,
	0.92821790944743860000, 0.93197090362316550000,
	0.93558330102045760000, 0.93905730694143010000,
	0.94239524262396900000, 0.94559953840889810000,
	0.94867272675748120000, 0.95161743513994920000,
	0.95443637881622230000, 0.95713235353039820000,
	0.95970822814090870000, 0.96216693720849690000,
	0.96451147356432880000, 0.96674488088063350000,
	0.96887024626625370000, 0.97089069290937860000,
	0.97280937278953210000, 0.97462945948058680000,
	0.97635414106617660000, 0.97798661318838080000,
	0.97953007224995660000, 0.98098770878969780000,
	0.98236270104970590000, 0.98365820875247110000,
	0.98487736710468150000, 0.98602328104361040000,
	0.98709901974078680000, 0.98810761137642330000,
	0.98905203819678400000, 0.98993523186531360000,
	0.99076006911693930000, 0.99152936772349120000,
	0.99224588277669910000, 0.99291230329369070000,
	0.99353124914838440000, 0.99410526833061520000,
	0.99463683453329610000, 0.99512834506638300000,
	0.99558211909491500000, 0.99600039619692990000,
	0.99638533523564190000, 0.99673901353889730000,
	0.99706342637763750000, 0.99736048673386460000,
	0.99763202534747640000, 0.99787979103028050000,
	0.99810545123454870000, 0.99831059286262110000,
	0.99849672330332570000, 0.99866527168034350000,
	0.99881759029713050000, 0.99895495626259410000,
	0.99907857328143460000, 0.99918957359287030000,
	0.99928902004140410000, 0.99937790826331730000,
	0.99945716897272360000, 0.99952767033125260000,
	0.99959022038576870000, 0.99964556955895290000,
	0.99969441317807690000, 0.99973739402788000000,
	0.99977510491409590000, 0.99980809122488750000,
	0.99983685347818720000, 0.99986184984374770000,
	0.99988349862952150000, 0.99990218072284900000,
	0.99991824197780000000, 0.99993199554089310000,
	0.99994372410829590000, 0.99995368210848910000,
	0.99996209780523300000, 0.99996917531652780000,
	0.99997509654607260000, 0.99998002302452540000,
	0.99998409765861940000, 0.99998744638691550000,
	0.99999017974164430000, 0.99999239431672950000,
	0.99999417414267240000, 0.99999559196951250000,
	0.99999671045957640000, 0.99999758329216290000,
	0.99999825618270430000, 0.99999876781928550000,
	0.99999915071969350000, 0.99999943201241430000,
	0.99999963414519090000, 0.99999977552490580000,
	0.99999987109264700000, 0.99999993283796020000,
	0.99999997025621030000, 0.99999999075305790000 };

#pragma warning(default : 4244 4305)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\Ac97PlaybackDevice.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "Ac97PlaybackDevice.h"
#include "..\common\PerformanceMonitor.h"
#include <math.h>
#include "library\common\vddebug.h"

#define AUDIO_DUMP					0
#define	DEBUG_QUEUE					0
#define USE_CPU_CLK_FOR_LOCATION	0
#define DEBUG_LOCATION				0
#define DEBUG_CONTROL				0

#if USE_CPU_CLK_FOR_LOCATION
	int mSecPlayTimeStart;
#endif

#if AUDIO_DUMP
static HANDLE audioStream;
static int audioStreamCount;
#endif

#if DEBUG_LOCATION
static int timeOfLastLoc;
#endif

#if !SILVER
// keep packet event signalling from occuring twice in dup packet mode
void CALLBACK DummyAc97Callback (LPVOID pvStreamContext, LPVOID pvPacketContext, DWORD dwStatus)
	{
	}
#endif

// Description	: This is a thread we use to process notify events from the DS buffer
// Return		: DWORD WINAPI - returns when we are done with DS buffer object
// Argument		: LPVOID param - passed in from CreateThread (this), allows us to call methods
DWORD WINAPI ThreadProcessDSSNotify( LPVOID param )
{
	Ac97PlaybackDevice * dso = (Ac97PlaybackDevice *) param;
	dso->BufferCallbackThread();
	dso->callBackThreadID = NULL;
	return 0;
}

void Ac97PlaybackDevice::BufferCallbackThread(void)
	{
	while(TRUE)
		{
		DWORD   dwEvent;
		dwEvent = WaitForMultipleObjects(numBuffers+1, pBufferEvents, FALSE, INFINITE);
		dwEvent -= WAIT_OBJECT_0;

		// events during flush, can come back in any order (not in posted order)
		if(dwEvent < (DWORD)numBuffers)
			{
#if DEBUG_QUEUE
			DP("Packet Done %d bufCompletedSize %d bufStatus %x", dwEvent, bufCompletedSize[dwEvent], bufStatus[dwEvent]);
#endif
			bufCompletedSize[dwEvent] = 0;
			bufStatus[dwEvent] = XMEDIAPACKET_STATUS_SUCCESS;
			DoCallback();
			bufsPosted--;
			}

		// if we get the last event it's the stop signal
		else if( dwEvent == numBuffers )
			{
			break;
			}
		}
	}


Error Ac97PlaybackDevice::AllocateBufferCallback(void)
	{
	int i;

	pBufferEvents = new HANDLE [numBuffers+1];

	// allocate buffer events
	for (i=0; i<numBuffers+1; i++)
		{
		pBufferEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (NULL == pBufferEvents[i])
			{
			GNRAISE(GNR_NOT_ENOUGH_MEMORY);
			}
		}

	if (NULL ==(hNotifyThread = CreateThread(NULL, 0, ThreadProcessDSSNotify, this, 0, &callBackThreadID)))
		{
		DP("CreateThread Error");
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}

	if (NULL == SetThreadPriority(hNotifyThread, THREAD_PRIORITY_TIME_CRITICAL))
		{
		DP("SetPriorityClass Error");
		//Not a real error
		}

	return S_OK;
	}


void Ac97PlaybackDevice::ReleaseBufferCallback(void)
	{
	if (hNotifyThread)
		{
		SetEvent(pBufferEvents[numBuffers]);
		while (callBackThreadID)
			{
			Sleep(1);
			}
		CloseHandle(hNotifyThread);
		hNotifyThread = NULL;
		}

	if (pBufferEvents)
		{
		for(int i=0; i<numBuffers+1; i++)
			{
			if (pBufferEvents[i]==NULL) break;
			if (CloseHandle(pBufferEvents[i]) == NULL)  break;
			}

		delete[] pBufferEvents;
		}

	}


void Ac97PlaybackDevice::ResetRenderPosition(void)
	{
#if DEBUG_CONTROL
		DP("ResetRenderPosition");
#endif

	if (pAnaRender)
		{
		lastRenderPosition =0;
		bytesWrittenToRender = 0;
		}
	}

Error Ac97PlaybackDevice::OpenDevice(void)
	{
	HRESULT hr;
	int i;

	if (pAnaRender)
		{
		CloseDevice();
		}

#ifdef SILVER

	WAVEFORMATEX	wformat = {WAVE_FORMAT_PCM, 2, sampleRate, sampleRate * 4, 4, 16, 0};
	DSSTREAMDESC    dssd;

	ZeroMemory(&dssd, sizeof(dssd));
	dssd.dwFlags				= DSBCAPS_CTRLVOLUME | DSSTREAMCAPS_ACCURATENOTIFY;
	dssd.dwMaxAttachedPackets	= numBuffers;
	dssd.lpwfxFormat			= &wformat;
	hr = DirectSoundCreateStream(&dssd, &pAnaRender);
	if(FAILED(hr)) GNRAISE(GNR_NO_AUDIO_HARDWARE);

	hr = DirectSoundCreateStream(&dssd, &pDigRender);
	if(FAILED(hr)) GNRAISE(GNR_NO_AUDIO_HARDWARE);
	pDigRender->SetVolume(-10000);

	PMMSGX("DirectSoundCreateStream sample rate %dHz\n", sampleRate);

#else

    hr = Ac97CreateMediaObject(DSAC97_CHANNEL_ANALOG, NULL, NULL, &pAnaRender);
	if(FAILED(hr)) GNRAISE(GNR_NO_AUDIO_HARDWARE);

    hr = Ac97CreateMediaObject(DSAC97_CHANNEL_DIGITAL, NULL, NULL, &pDigRender);
	if(FAILED(hr)) GNRAISE(GNR_NO_AUDIO_HARDWARE);

	spdifDeviceMode = false;
	hr = SetSPDIFDeviceOut(spdifDeviceMode);
	if(FAILED(hr)) GNRAISE(GNR_NO_AUDIO_HARDWARE);

	PMMSGX("Ac97CreateMediaObject\n");

#endif // SILVER


	bufsPosted = 0;

	GNRAISE_OK;
	}


void Ac97PlaybackDevice::CloseDevice(void)
	{
	int i;

	playState = PS_NONE;

	if (pAnaRender)
		{
		WaitForRendererCompletionTimout(5000);

		pDigRender->Release();
		pDigRender = NULL;
		pAnaRender->Release();
		pAnaRender = NULL;
		}
	}


Error Ac97PlaybackDevice::AllocateAudioBuffers(void)
	{
	int i;

	xmpAna = new XMEDIAPACKET[numBuffers];
	xmpDig = new XMEDIAPACKET[numBuffers];
	bufMemAna = new short *[numBuffers];
	bufMemDig = new short *[numBuffers];
	bufStatus = new DWORD[numBuffers];
	bufCompletedSize = new DWORD[numBuffers];
	bufSPDIFData = new bool [numBuffers];
	bufSingleBuffer = new bool [numBuffers];

	ZeroMemory(xmpAna, sizeof(XMEDIAPACKET) * numBuffers);
	ZeroMemory(xmpDig, sizeof(XMEDIAPACKET) * numBuffers);

	for(i=0; i<numBuffers; i++)
		{
//		bufMemAna[i] = new short[bufferCount * 2];
//		bufMemDig[i] = new short[bufferCount * 2];
        bufMemAna[i] = (short*) XPhysicalAlloc( sizeof( short ) * bufferCount * 2, MAXULONG_PTR, 0, PAGE_READWRITE | PAGE_NOCACHE );
        bufMemDig[i] = (short*) XPhysicalAlloc( sizeof( short ) * bufferCount * 2, MAXULONG_PTR, 0, PAGE_READWRITE | PAGE_NOCACHE );
		xmpAna[i].pvBuffer = (char *)bufMemAna[i];
		xmpDig[i].pvBuffer = (char *)bufMemDig[i];
		xmpAna[i].dwMaxSize = 4 * bufferCount;
		xmpAna[i].pdwStatus = &bufStatus[i];
		bufStatus[i] = XMEDIAPACKET_STATUS_SUCCESS;
		xmpAna[i].pdwCompletedSize  = &bufCompletedSize[i];
		bufCompletedSize[i] = 0;
		xmpAna[i].hCompletionEvent = pBufferEvents[i];
		bufSPDIFData[i] = false;
		bufSingleBuffer[i] = false;
		}

	GNRAISE_OK;
	}

void Ac97PlaybackDevice::ReleaseAudioBuffers(void)
	{
	int i;

	for(i = 0;i<numBuffers; i++)
		{
//	    delete[] bufMemAna[i];
//	    delete[] bufMemDig[i];
        XPhysicalFree( bufMemAna[i] );
        XPhysicalFree( bufMemDig[i] );
		}

	delete[] xmpAna;
	delete[] xmpDig;
	delete[] bufMemAna;
	delete[] bufMemDig;
	delete[] bufStatus;
	delete[] bufCompletedSize;
	delete[] bufSPDIFData;
	delete[] bufSingleBuffer;
}


Ac97PlaybackDevice::Ac97PlaybackDevice(GenericProfile * globalProfile, GenericProfile * profile, int numBuffers, int bufferSize)
	{
	this->numBuffers = numBuffers;
	bufferCount = bufferSize;			// bufferCount = number of audio frames (Left/Right word pairs)
	bufferUsed = 0;

	playState = PS_NONE;
	bufsPosted = 0;

	fillBuffer = 0;
	inputByteCount = 0;
	callback = NULL;
	pAnaRender = NULL;
	pDigRender =NULL;
	spdifDataMode = false;

	dropping = FALSE;
	sampleRate = 48000;

	if (FAILED(AllocateBufferCallback()))
		DP("AllocateBufferCallback FAILED");

	if (FAILED(AllocateAudioBuffers()))
		DP("AllocateAudioBuffers FALIED");

	if (FAILED(OpenDevice()))
		{
		DP("Ac97PlaybackDevice::Ac97PlaybackDevice OpenDevice() FAILED");
		PMMSGX("Ac97PlaybackDevice::Ac97PlaybackDevice OpenDevice() FAILED");
		XASSERT(NULL);
		}


//#if AUDIO_DUMP
//	audioStream = ::CreateFile("f:\\ac3\\strm.pcm",
//							  GENERIC_WRITE,
//							  FILE_SHARE_WRITE,
//							  NULL,
//							  CREATE_ALWAYS,
//							  FILE_ATTRIBUTE_NORMAL,
//							  NULL);
//#endif
	}

Ac97PlaybackDevice::~Ac97PlaybackDevice(void)
	{
	CloseDevice();

	ReleaseBufferCallback();

	ReleaseAudioBuffers();

//#if AUDIO_DUMP
//	::CloseHandle(audioStream);
//#endif
	}


void Ac97PlaybackDevice::DumpQueue(void)
	{
	while (bufferWaitQ.size())
		{
		bufStatus[bufferWaitQ.front()] = XMEDIAPACKET_STATUS_SUCCESS;
#if DEBUG_QUEUE
		DP("DumpQueue bufferWaitQ.pop(%d)", bufferWaitQ.front());
#endif
		bufferWaitQ.pop();
		}
	}

DWORD Ac97PlaybackDevice::GetCurrentRenderPosition(void)
	{
	DWORD rPos;

	pAnaRender->GetCurrentPosition(&rPos);

	if (rPos < lastRenderPosition)
		{
		DP("rPos < lastRenderPosition,  rPos %d  lastRenderPosition %d delta",rPos, lastRenderPosition, lastRenderPosition-rPos);

		int i;
		for (i=0; i<5; i++)
			{
			pAnaRender->GetCurrentPosition(&rPos);
			if (rPos >= lastRenderPosition)
				{
				DP("rPos %d is now good retry %d",rPos, i);
				break;
				}
			Sleep(1);
			}
		}

	if (rPos > bytesWrittenToRender)
		{
		if (bytesWrittenToRender)
			{
			DP("rPos %d > bytesWrittenToRender %d", rPos , bytesWrittenToRender);
			}
		rPos = bytesWrittenToRender;
		}

	if (rPos < lastRenderPosition)
		{
		DP("lastRenderPosition %d, rPos %d, diff %d, bytesWrittenToRender %d ",
			lastRenderPosition, rPos, lastRenderPosition-rPos, bytesWrittenToRender);

		// render has run out of data and reset counter to zero so
		// account for byte which were rendered but won't show up in the position
#if DEBUG_CONTROL
		DP("GetCurrentRenderPosition ->Flush");
#endif
		dropByteCount += bytesWrittenToRender;
		if(pDigRender)
			pDigRender->Flush();
		pAnaRender->Flush();
		WaitForRendererCompletionTimout(100);
		ResetRenderPosition();
		}

	lastRenderPosition = rPos;

	return rPos;
	}


void Ac97PlaybackDevice::WriteBufferFromQueue(void)
	{

	if (playState == PS_START && !dropping)
		{
		while (bufferWaitQ.size())
			{
			int j, i = bufferWaitQ.front();

			xmpDig[i].dwMaxSize = xmpAna[i].dwMaxSize;
			if (bufSingleBuffer[i])
				{
				xmpDig[i].pvBuffer = (char *)bufMemAna[i];
				}
			else
				{
				xmpDig[i].pvBuffer = (char *)bufMemDig[i];
				}

			// there seems to be a long enough delay to set this here instead of in callback
			if (bufSPDIFData[i] != spdifDeviceMode)
				{
				SetSPDIFDeviceOut(bufSPDIFData[i]);
				}

			pDigRender->Process(&xmpDig[i], NULL);
			pAnaRender->Process(&xmpAna[i], NULL);
			bufsPosted++;
			// now that data is safely written check to see if we ran out of data
			bytesWrittenToRender += xmpAna[i].dwMaxSize;
#if DEBUG_QUEUE
			DP("bufferWaitQ.pop(%d)",i);
#endif
			bufferWaitQ.pop();
			}
		}
	}

Error Ac97PlaybackDevice::WriteBuffer(int buffer)
	{
	if (!xmpAna[buffer].dwMaxSize)
		{
#if DEBUG_CONTROL
		DP("Trying to write Zero length!!!");
#endif
		return(S_OK);
		}

	bufStatus[buffer] = XMEDIAPACKET_STATUS_PENDING;
	bufSPDIFData[buffer] = spdifDataMode;
//	DP("bufSPDIFData[%d] = %d", buffer, bufSPDIFData[buffer]);

#if DEBUG_QUEUE
	DP("bufferWaitQ.push(%d)",buffer);
#endif
	bufferWaitQ.push(buffer);
	WriteBufferFromQueue();

	return (S_OK);
	}


void Ac97PlaybackDevice::BeginStreaming(GenericAudioPlaybackCallback * callback)
	{
	lock.Enter();
#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::BeginStreaming");
#endif

#if DEBUG_LOCATION
	timeOfLastLoc = 0;
#endif

	this->callback = callback;

	running = FALSE;
	terminate = FALSE;
	bufferUsed = 0;
	fillBuffer = 0;
	dropping = FALSE;

	inputByteCount = 0;
	dropByteCount = 0;
	ResetRenderPosition();

	trashDataSent = 0;
	trashPlayTimeStart = 0;
	playState = PS_BEGIN;


	XASSERT(!bufsPosted);
	bufsPosted = 0;

#if AUDIO_DUMP
	char	buf[80];
	wsprintf(buf,"D:\\Dump\\dsdump%d.pcm", audioStreamCount++);

	audioStream = ::CreateFile(buf, // D:\ is actually XE:\ //
							  GENERIC_WRITE,
							  FILE_SHARE_WRITE,
							  NULL,
							  CREATE_ALWAYS,
							  FILE_ATTRIBUTE_NORMAL,
							  NULL);

	if(audioStream == INVALID_HANDLE_VALUE)
		{
		int err = ::GetLastError();
		}
#endif


	lock.Leave();
	}

void Ac97PlaybackDevice::StartStreaming(void)
	{
	lock.Enter();
#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::StartStreaming+");
#endif

	playState = PS_START;

	running = TRUE;
	if (pAnaRender)
		{
		WriteBufferFromQueue();
		}
	else
		trashPlayTimeStart = GetInternalTime() - trashPlayTimeStart;

#if USE_CPU_CLK_FOR_LOCATION
	mSecPlayTimeStart = GetInternalTime();
#endif

#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::StartStreaming-");
#endif
	lock.Leave();
	}


void Ac97PlaybackDevice::ReQueueFlushedBuffers(DWORD flushPos)
	{
	int buf, bufCnt, bytes;

	bytes = inputByteCount - flushPos;

	if (bytes > numBuffers * bufferCount * 4)
		{
		DP("ReQueueFlushedBuffers() bytes impossibly large %d", bytes);
		// this is an error, for now just plop down in the middle of the buffer
		bytes = numBuffers * bufferCount * 4 - bufferCount*2;
		}

#if DEBUG_CONTROL
	DP("ReQueueFlushedBuffers() bytes %d", bytes);
#endif

	if (!bytes || bytes < 0)
		return;


	bytes &= ~3;

#if DEBUG_CONTROL
	DP("inputByteCount %d flushPos %d, bytes %d, fillBuffer %d",inputByteCount, flushPos, bytes, fillBuffer);
#endif

	if (fillBuffer)
		{
		xmpAna[bufferUsed].dwMaxSize = fillBuffer;
		fillBuffer = 0;
		bufferUsed = (bufferUsed + 1) % numBuffers;
		}

	buf = bufferUsed;
	bufCnt = 0;

	while (bytes > 0)
		{
		buf = (buf + (numBuffers - 1)) % numBuffers;
		bytes -= xmpAna[buf].dwMaxSize;
		bufCnt++;
		}
	bytes =- bytes;	//create buffer pointer

#if DEBUG_QUEUE
	DP("Was in buffer %d",buf);
#endif

	if (bytes)
		{
		LPBYTE lpDst;
		lpDst = (LPBYTE)xmpAna[buf].pvBuffer;
		memcpy(lpDst, lpDst+bytes, xmpAna[buf].dwMaxSize-bytes);
		lpDst = (LPBYTE)xmpDig[buf].pvBuffer;
		memcpy(lpDst, lpDst+bytes, xmpAna[buf].dwMaxSize-bytes);
		xmpAna[buf].dwMaxSize = xmpAna[buf].dwMaxSize-bytes;
		}

	while (bufCnt)
		{
		WriteBuffer(buf);
		buf = (buf + 1) % numBuffers;
		bufCnt--;
		}
	}


bool Ac97PlaybackDevice::WaitForRendererCompletionTimout(int timeout)
	{
#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::WaitForRendererCompletionTimout+");
#endif

	timeout += GetInternalTime();

	if (pAnaRender)
		{
		while (bufsPosted && GetInternalTime() < timeout)
			{
#if DEBUG_CONTROL
			DP("WaitForRendererCompletionTimout Yield");
#endif
			YieldTimedFiber(20);
			}
		}

#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::WaitForRendererCompletionTimout-");
#endif
	XASSERT(bufsPosted==0);

	return (bufsPosted==0);
	}


void Ac97PlaybackDevice::FlushAndRequeueUnPlayedData(void)
	{
	DWORD flushPos;

	flushPos = CurrentLocation() * 4;
#if DEBUG_CONTROL
	DP("->Flush");
#endif
	if(pDigRender)
		pDigRender->Flush();
	pAnaRender->Flush();
	WaitForRendererCompletionTimout(100);
	ResetRenderPosition();
	dropByteCount = flushPos;
	ReQueueFlushedBuffers(flushPos);
	}


void Ac97PlaybackDevice::StopStreaming(void)
	{
	lock.Enter();
#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::StopStreaming");
#endif

	playState = PS_STOP;

	if (pAnaRender)
		{
		if (!dropping)
			{
			FlushAndRequeueUnPlayedData();
			}
		}
	else
		{
		trashPlayTimeStart = GetInternalTime() - trashPlayTimeStart;
		}

	running = FALSE;

	lock.Leave();
	}


void Ac97PlaybackDevice::EndStreaming(bool fullReset)
	{
	int i;
	lock.Enter();
#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::EndStreaming+");
#endif

	playState = PS_END;

	FlushAndRequeueUnPlayedData();
	DumpQueue();

	this->callback = NULL;
	terminate = TRUE;

#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::EndStreaming-");
#endif

#if AUDIO_DUMP
	::CloseHandle(audioStream);
#endif

	lock.Leave();
	}




void Ac97PlaybackDevice::DoneStreaming(void)
	{
	lock.Enter();
#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::DoneStreaming+");
#endif

//	playState = PS_DONE;  // continue normal posting of data (PS_START state)

	if (fillBuffer && pAnaRender)
		{
		xmpAna[bufferUsed].dwMaxSize = fillBuffer;
		if (!dropping)
			WriteBuffer(bufferUsed);
		else
			bufStatus[bufferUsed] = XMEDIAPACKET_STATUS_PENDING;
		fillBuffer = 0;
		bufferUsed = (bufferUsed + 1) % numBuffers;
		}

#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::DoneStreaming-");
#endif
	lock.Leave();
	}


bool Ac97PlaybackDevice::IsBufferDone(int id)
	{
	return !pAnaRender || ((DWORD)bufStatus[id] == XMEDIAPACKET_STATUS_SUCCESS);
	}



bool Ac97PlaybackDevice::GetBuffer(int requestSize, short * & buffer, int & size)
	{
	short * bufTemp;
	bool ret = GetBuffers(requestSize, buffer, bufTemp, size);
	bufSingleBuffer[bufferUsed] = true;
	return ret;
	}

bool Ac97PlaybackDevice::GetBuffers(int requestSize, short * & bufA, short * & bufD, int & size)
	{
	static short trash[512];

	lock.Enter();

	bufSingleBuffer[bufferUsed] = false;

	if (!terminate)
		{
		if (pAnaRender)
			{
			if (IsBufferDone(bufferUsed))
				{
				size = 4 * bufferCount - fillBuffer;
				bufA = (short *)((char *)bufMemAna[bufferUsed] + fillBuffer);
				bufD = (short *)((char *)bufMemDig[bufferUsed] + fillBuffer);

				lock.Leave();

				return TRUE;
				}
			else
				{
				lock.Leave();

				return FALSE;
				}
			}
		else
			{
			bufA = trash;
			bufD = trash;
			size = sizeof(trash);

			lock.Leave();

			return TRUE;
			}
		}
	else
		{
		lock.Leave();

		return FALSE;
		}
	}




void Ac97PlaybackDevice::PostBuffer(int usedSize)
	{
	lock.Enter();

	if (pAnaRender)
		{
		inputByteCount += usedSize;
		fillBuffer += usedSize;

		if (fillBuffer == 4 * bufferCount)
			{
			if (terminate)
				{
				lock.Leave();
				return;
				}

#if AUDIO_DUMP
			DWORD dummy;
			::WriteFile(audioStream, bufMemAna[bufferUsed], fillBuffer, &dummy, NULL);
#endif

			xmpAna[bufferUsed].dwMaxSize = fillBuffer;

			if (!dropping)
				{
				WriteBuffer(bufferUsed);
				}
			else
				{
				bufStatus[bufferUsed] = XMEDIAPACKET_STATUS_PENDING;
				}

			fillBuffer = 0;
			bufferUsed = (bufferUsed + 1) % numBuffers;
			}
		}
	else
		{
		trashDataSent += usedSize;
		}

	lock.Leave();
	}

int Ac97PlaybackDevice::CurrentLocation(void)
	{
	DWORD outputByteCount;

#if DEBUG_LOCATION
	bool showLoc = false;

	if (GetInternalTime() > timeOfLastLoc+200)
		{
		showLoc = true;
		timeOfLastLoc = GetInternalTime();
		}
#endif

	if (pAnaRender)
		{
		if (inputByteCount)
			{
			if (dropping)
				{
#if DEBUG_LOCATION
				if (showLoc)
					DP("CurrentLocation %d", dropByteCount >> 2);
#endif
				return dropByteCount >> 2;
				}
			else
				{
				int i;

#if USE_CPU_CLK_FOR_LOCATION
				outputByteCount = (GetInternalTime() - mSecPlayTimeStart) * 192;
#else
				outputByteCount = GetCurrentRenderPosition();
//chzTest
//				static int posAdd = 0;
//				if (outputByteCount)
//					{
//					outputByteCount += posAdd;
//					}

				if (outputByteCount > (DWORD)inputByteCount)
					{
					DP("outputByteCount %d > inputByteCount %d", outputByteCount , inputByteCount);
					outputByteCount = inputByteCount;
					}
#endif

#if DEBUG_LOCATION
				if (showLoc)
					DP("CurrentLocation %d, outputByteCount %d, dropByteCount %d, inputByteCount %d",
						(outputByteCount + dropByteCount)/4, outputByteCount, dropByteCount, inputByteCount);
#endif
				return ((outputByteCount + dropByteCount) >> 2);
				}
			}
		else
			return 0;
		}
	else
		{
		int time;

		if (running)
			time = GetInternalTime() - trashPlayTimeStart;
		else
			time = trashPlayTimeStart;

#if DEBUG_LOCATION
		if (showLoc)
			DP("CurrentLocation %d", ScaleDWord(time, 1000, sampleRate));
#endif
		return ScaleDWord(time, 1000, sampleRate);
		}
	}

int Ac97PlaybackDevice::AvailBufferSpace(void)
	{
	if (pAnaRender)
		return numBuffers * bufferCount - (inputByteCount >> 2) + CurrentLocation();
	else
		return 4096;
	}


bool Ac97PlaybackDevice::WaitForCompletionTimeout(int timeout)
	{
	int i;

#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::WaitForCompletionTimeout+");
#endif

	timeout += GetInternalTime();

	if (pAnaRender)
		{
		for(i=0; i<numBuffers; i++)
			{
			while (!IsBufferDone(i) && GetInternalTime() < timeout)
				{
				YieldTimedFiber(20);
				}

			if (!IsBufferDone(i))
				{
				DP("Ac97PlaybackDevice::WaitForCompletionTimeout- ret FALSE");
				return FALSE;
				}
			}
		}

#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::WaitForCompletionTimeout-");
#endif
	return TRUE;
	}

void Ac97PlaybackDevice::WaitForCompletion(void)
	{
	int i;

#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::WaitForCompletion+");
#endif

	if (pAnaRender)
		{
		for(i=0; i<numBuffers; i++)
			{
			while (!IsBufferDone(i))
				YieldTimedFiber(100);
			}
		}

#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::WaitForCompletion-");
#endif
	}

bool Ac97PlaybackDevice::IsCompleted(void)
	{
	int i;

	if (pAnaRender)
		{
		for(i=0; i<numBuffers; i++)
			{
			if (!IsBufferDone(i)) return FALSE;
			}
		}

	return TRUE;
	}

bool Ac97PlaybackDevice::EnterDropDataMode(void)
	{
	lock.Enter();
#if DEBUG_CONTROL
	DP("EnterDropDataMode+");
#endif

	if (!terminate && !running && pAnaRender)
		{
		DoneStreaming();

		if (!IsCompleted())
			{
			dropByteCount = CurrentLocation() * 4;
			dropping = TRUE;

			if (bufsPosted)
				{
				FlushAndRequeueUnPlayedData();
				}

			DumpQueue();
			ResetRenderPosition();

			bufferDropped = bufferUsed;
			dropBuffer = inputByteCount - dropByteCount;

			do {
				bufferDropped = (bufferDropped + (numBuffers - 1)) % numBuffers;
				dropBuffer -= xmpAna[bufferDropped].dwMaxSize;
				bufStatus[bufferDropped] = XMEDIAPACKET_STATUS_PENDING;

				} while (dropBuffer > 0);

			dropBuffer = - dropBuffer;

			if (dropByteCount & 3)
				{
				dropBuffer += 4 - (dropByteCount & 3);
				dropByteCount += 4 - (dropByteCount & 3);
				}

#if DEBUG_CONTROL
			DP("EnterDropDataMode dropBuffer=%d, bufferDropped=%d bufferUsed=%d inputByteCount=%d dropByteCount=%d",
				dropBuffer, bufferDropped, bufferUsed, inputByteCount, dropByteCount);
#endif
			}
		else
			{
			// nothing posted in render or queued
			ResetRenderPosition();

			bufferDropped = bufferUsed;
			dropBuffer = 0;

			dropByteCount = CurrentLocation() * 4;
			dropping = TRUE;
			}

		lock.Leave();
#if DEBUG_CONTROL
			DP("EnterDropDataMode-");
#endif
		return TRUE;
		}
	else
		{
		lock.Leave();
#if DEBUG_CONTROL
			DP("EnterDropDataMode-");
#endif
		return FALSE;
		}
	}

void Ac97PlaybackDevice::LeaveDropDataMode(void)
	{
	lock.Enter();
	int pos, max;

#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::LeaveDropDataMode+");
#endif

	if (dropping)
		{
		DoneStreaming();

		max = numBuffers;
		pos = 0;
		while (max && !IsBufferDone(bufferDropped))
			{
			if (dropBuffer)
				{
				LPBYTE p;
				p = (BYTE *)bufMemAna[bufferDropped];
				memcpy(p, p + dropBuffer,  xmpAna[bufferDropped].dwMaxSize - dropBuffer);
				p = (BYTE *)bufMemDig[bufferDropped];
				memcpy(p, p + dropBuffer,  xmpAna[bufferDropped].dwMaxSize - dropBuffer);
				xmpAna[bufferDropped].dwMaxSize -= dropBuffer;
				dropBuffer = 0;
				}
			bufStatus[bufferDropped] = XMEDIAPACKET_STATUS_SUCCESS;
			WriteBuffer(bufferDropped);
			pos += xmpAna[bufferDropped].dwMaxSize;
			bufferDropped = (bufferDropped + 1) % numBuffers;
			max--;
			}

		dropping = FALSE;
		}

#if DEBUG_CONTROL
	DP("Ac97PlaybackDevice::LeaveDropDataMode-");
#endif
	lock.Leave();
	}


void Ac97PlaybackDevice::DropData(int bytes)
	{
	lock.Enter();

	if (dropping)
		{

		if (dropByteCount + bytes > inputByteCount)
			{
#if DEBUG_CONTROL
			DP("dropByteCount+bytes %d > inputByteCount %d", dropByteCount+bytes, inputByteCount);
#endif
			bytes = inputByteCount - dropByteCount;
			}

		bytes &= ~3;

		dropByteCount += bytes;
		dropBuffer += bytes;

		while (!IsBufferDone(bufferDropped) && dropBuffer >= (int)(xmpAna[bufferDropped].dwMaxSize))
			{
			dropBuffer -= xmpAna[bufferDropped].dwMaxSize;
			bufStatus[bufferDropped] = XMEDIAPACKET_STATUS_SUCCESS;
			bufferDropped = (bufferDropped + 1) % numBuffers;

			if (callback) callback->WaveDataRequest();

#if DEBUG_CONTROL
			DP("DropData bufferDropped=%d bufferUsed=%d inputByteCount=%d dropByteCount=%d dropByteCount-dropBuffer %d",
				bufferDropped, bufferUsed, inputByteCount, dropByteCount, dropByteCount-dropBuffer);
#endif
			}

		}

	lock.Leave();
	}


void Ac97PlaybackDevice::DoCallback(void)
	{
	if (!dropping)
		{
		if (callback)
			callback->WaveDataRequest();
		}
	}

Error Ac97PlaybackDevice::SetCopyProtectionLevel(SPDIFCopyMode sCopyMode)
	{
	spdifCopyMode = sCopyMode;
#if DEBUG_CONTROL
	DP("Setting spdifCopyMode %d", spdifCopyMode);
#endif
	GNRAISE_OK;
	}


Error Ac97PlaybackDevice::SetSPDIFDeviceOut(bool data)
	{
	Error hr;

	hr = pDigRender->SetMode(data ? DSAC97_MODE_ENCODED : DSAC97_MODE_PCM);
	spdifDeviceMode = data;
	return hr;
	}

Error Ac97PlaybackDevice::SetSPDIFDataOut(bool enable)
	{
	Error hr = S_OK;

	if (enable != spdifDataMode)
		{
#if DEBUG_CONTROL
		DP("SetSPDIFDataOut(%d), spdifDataMode %d", enable, spdifDataMode);
#endif

		if (!bufsPosted && bufferWaitQ.empty())
			{
#if DEBUG_CONTROL
			DP("bufsPosted %d, bufferWaitQ.empty() %d", bufsPosted, bufferWaitQ.empty());
#endif
			hr = SetSPDIFDeviceOut(enable);
			}
		else
			{
			// we aren't really done but we will have a new data type
			// so write the current buffer
			DoneStreaming();
#if DEBUG_CONTROL
			DP("SetSPDIFDataOut(%d) delayed, bufferUsed %d(new data in this buffer)",enable, bufferUsed);
#endif
			}
		spdifDataMode = enable;
		}

	return hr;
	}


bool Ac97PlaybackDevice::SupportsSPDIFDataOut(void)
	{
	return (XGetAudioFlags() & (DSSPEAKER_ENABLE_AC3 | DSSPEAKER_ENABLE_DTS)) != 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\AudioBitStream.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef AUDIOBITSTREAM_H
#define AUDIOBITSTREAM_H

#include "driver\SoftwareCinemaster\Common\Prelude.h"
#include "..\common\bitstreams.h"

#define AUDIO_STREAM_BUFFER_SIZE	(1 << 15)
#define AUDIO_STREAM_BUFFER_MASK	(AUDIO_STREAM_BUFFER_SIZE * 32 - 1)

extern DWORD AudioStreamBuffer[AUDIO_STREAM_BUFFER_SIZE+1];
extern int ABSBits;

class AudioBitStream	: public BitStream
	{
	public:
		AudioBitStream(StreamFlipCopy * streamFlipCopy);

		virtual ~AudioBitStream(void);

		WORD GetWord(void);

		WORD PeekWordAt(int bitoffset);

		DWORD GetHBits(int num);

		DWORD GetBits(int num);

		DWORD Get3Bits(void);

		DWORD Get4Bits(void);

		DWORD Get5Bits(void);

		DWORD Get7Bits(void);

		DWORD GetBit(void);

		bool GetBool(void);

		DWORD PeekBits(int num);

		DWORD PeekBit(void);

		bool PeekBool(void);

		void Advance(int bits);
	};

inline void AudioBitStream::Advance(int bits)
	{
	ABSBits += bits;
	}

#pragma warning(disable : 4035)

inline WORD PeekWordAt(int bitoffset)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [ABSBits]
		add	eax, [bitoffset]

		mov	edx, eax
		and	eax, AUDIO_STREAM_BUFFER_MASK

		shr	eax, 5
		mov	ecx, edx

		mov	edx, [AudioStreamBuffer + 4 + eax * 4]
		mov	eax, [AudioStreamBuffer +     eax * 4]

		shld	eax, edx, cl

		shr	eax, 32-16
		}
#else
	DWORD pos = ABSBits + bitoffset;
	DWORD * p = AudioStreamBuffer + ((pos & AUDIO_STREAM_BUFFER_MASK) >> 5);
	DWORD res = SHLD64(p[0], p[1], pos & 31);

	return (WORD)(res >> 16);
#endif
	}

inline DWORD AudioBitStream::PeekBits(int num)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [ABSBits]
		mov	ecx, [num]

		and	eax, AUDIO_STREAM_BUFFER_MASK
		mov	ch, 32

		sub	ch, cl
		mov	cl, al

		shr	eax, 5

		mov	edx, [AudioStreamBuffer + 4 + eax * 4]
		mov	eax, [AudioStreamBuffer +     eax * 4]

		shld	eax, edx, cl

		mov	cl, ch

		shr	eax, cl
		}
#else
	DWORD * p = AudioStreamBuffer + ((ABSBits & AUDIO_STREAM_BUFFER_MASK) >> 5);
	DWORD res = SHLD64(p[0], p[1], ABSBits & 31);

	return res >> (32 - num);
#endif
	}

inline DWORD AudioBitStream::GetBits(int num)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [ABSBits]
		mov	ecx, [num]

		mov	edx, eax
		and	eax, AUDIO_STREAM_BUFFER_MASK

		add	edx, ecx
		mov	ch, 32

		sub	ch, cl
		mov	cl, al

		shr	eax, 5
		mov	[ABSBits], edx

		mov	edx, [AudioStreamBuffer + 4 + eax * 4]
		mov	eax, [AudioStreamBuffer +     eax * 4]

		shld	eax, edx, cl

		mov	cl, ch

		shr	eax, cl
		}
#else
	DWORD res = PeekBits(num);

	ABSBits += num;

	return res;
#endif
	}

inline WORD AudioBitStream::GetWord(void)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [ABSBits]

		mov	edx, eax
		and	eax, AUDIO_STREAM_BUFFER_MASK

		mov	ecx, edx
		add	edx, 16

		shr	eax, 5
		mov	[ABSBits], edx

		mov	edx, [AudioStreamBuffer + 4 + eax * 4]
		mov	eax, [AudioStreamBuffer +     eax * 4]

		shld	eax, edx, cl

		shr	eax, 32-16
		}
#else
	return (WORD)GetBits(16);
#endif
	}

inline DWORD AudioBitStream::Get3Bits(void)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [ABSBits]

		mov	edx, eax
		and	eax, AUDIO_STREAM_BUFFER_MASK

		mov	ecx, edx
		add	edx, 3

		shr	eax, 5
		mov	[ABSBits], edx

		mov	edx, [AudioStreamBuffer + 4 + eax * 4]
		mov	eax, [AudioStreamBuffer +     eax * 4]

		shld	eax, edx, cl

		shr	eax, 32-3
		}
#else
	return GetBits(3);
#endif
	}

inline DWORD AudioBitStream::Get4Bits(void)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [ABSBits]

		mov	edx, eax
		and	eax, AUDIO_STREAM_BUFFER_MASK

		mov	ecx, edx
		add	edx, 4

		shr	eax, 5
		mov	[ABSBits], edx

		mov	edx, [AudioStreamBuffer + 4 + eax * 4]
		mov	eax, [AudioStreamBuffer +     eax * 4]

		shld	eax, edx, cl

		shr	eax, 32-4
		}
#else
	return GetBits(4);
#endif
	}

inline DWORD AudioBitStream::Get5Bits(void)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [ABSBits]

		mov	edx, eax
		and	eax, AUDIO_STREAM_BUFFER_MASK

		mov	ecx, edx
		add	edx, 5

		shr	eax, 5
		mov	[ABSBits], edx

		mov	edx, [AudioStreamBuffer + 4 + eax * 4]
		mov	eax, [AudioStreamBuffer +     eax * 4]

		shld	eax, edx, cl

		shr	eax, 32-5
		}
#else
	return GetBits(5);
#endif
	}

inline DWORD AudioBitStream::Get7Bits(void)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [ABSBits]

		mov	edx, eax
		and	eax, AUDIO_STREAM_BUFFER_MASK

		mov	ecx, edx
		add	edx, 7

		shr	eax, 5
		mov	[ABSBits], edx

		mov	edx, [AudioStreamBuffer + 4 + eax * 4]
		mov	eax, [AudioStreamBuffer +     eax * 4]

		shld	eax, edx, cl

		shr	eax, 32-7
		}
#else
	return GetBits(7);
#endif
	}

extern int highmask32[33];

inline DWORD AudioBitStream::GetHBits(int num)
	{
#if _M_IX86
	__asm
		{
		mov	ecx, [ABSBits]
		mov	eax, AUDIO_STREAM_BUFFER_MASK

		and	eax, ecx
		mov	edx, [num]

		shr	eax, 5
		mov	ebx, [highmask32 + 4 * edx]

		add	edx, ecx

		mov	[ABSBits], edx

		mov	edx, [AudioStreamBuffer + 4 + eax * 4]
		mov	eax, [AudioStreamBuffer +     eax * 4]

		shld	eax, edx, cl

		and	eax, ebx
		}
#else
	return GetBits(num) << (32 - num);
#endif
	}

inline DWORD AudioBitStream::GetBit(void)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [ABSBits]
		mov	cl, 31

		mov	edx, eax
		and	eax, AUDIO_STREAM_BUFFER_MASK

		shr	eax, 5
		sub	cl, dl

		mov	eax, [AudioStreamBuffer + eax * 4]
		inc	edx

		shr	eax, cl

		and	eax, 1
		mov	[ABSBits], edx
		}
#else
	return GetBits(1);
#endif
	}

inline DWORD AudioBitStream::PeekBit(void)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [ABSBits]
		mov	cl, 31

		sub	cl, al
		and	eax, AUDIO_STREAM_BUFFER_MASK

		shr	eax, 5

		mov	eax, [AudioStreamBuffer + eax * 4]

		shr	eax, cl

		and	eax, 1
		}
#else
	return PeekBits(1);
#endif
	}

inline bool AudioBitStream::GetBool(void)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [ABSBits]
		mov	cl, 31

		mov	edx, eax
		and	eax, AUDIO_STREAM_BUFFER_MASK

		shr	eax, 5
		sub	cl, dl

		mov	eax, [AudioStreamBuffer + eax * 4]
		inc	edx

		shr	eax, cl

		and	eax, 1
		mov	[ABSBits], edx
		}
#else
	return GetBits(1);
#endif
	}

inline bool AudioBitStream::PeekBool(void)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [ABSBits]
		mov	cl, 31

		sub	cl, al
		and	eax, AUDIO_STREAM_BUFFER_MASK

		shr	eax, 5

		mov	eax, [AudioStreamBuffer + eax * 4]

		shr	eax, cl

		and	eax, 1
		}
#else
	return PeekBits(1);
#endif
	}

#pragma warning(default : 4035)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\Ac97PlaybackDevice.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#ifndef Ac97PlaybackDevice_H
#define Ac97PlaybackDevice_H

#include "AudioPlaybackDevice.h"
#include <queue>

#if _DEBUG
	#define XASSERT(x) if( !(x) ) _asm int 3;
#else
	#define XASSERT(x)
#endif

enum PLAY_STATE
	{
	PS_NONE,
	PS_BEGIN,
	PS_START,
	PS_DONE,
	PS_STOP,
	PS_END
	};


class Ac97PlaybackDevice : public GenericAudioPlaybackDevice
	{
	protected:
		XMEDIAPACKET	  * xmpAna, * xmpDig;
		short			 ** bufMemAna, ** bufMemDig;
		DWORD			  * bufCompletedSize;
		DWORD			  * volatile bufStatus;
		bool			  * bufSPDIFData;
		bool			  * bufSingleBuffer;
		DWORD				lastRenderPosition;
		DWORD				bytesWrittenToRender;



		LPAC97MEDIAOBJECT	pAnaRender;
		LPAC97MEDIAOBJECT	pDigRender;
		HANDLE			  * pBufferEvents;
		HANDLE				hNotifyThread;
		DWORD				callBackThreadID;
		PLAY_STATE			playState;
		std::queue <int>	bufferWaitQ;
		int	volatile		bufsPosted;
		int					numBuffers;
		int					bufferCount;
		int					bufferUsed, bufferDropped;
		int					fillBuffer, dropBuffer;
		int					inputByteCount, dropByteCount;
		int					trashDataSent, trashPlayTimeStart;
		int					sampleRate;
		bool				running, terminate, dropping;
		TimedFiberMutex		lock;

		SPDIFCopyMode		spdifCopyMode;
		bool				spdifDeviceMode, spdifDataMode;


		GenericAudioPlaybackCallback * callback;

		friend DWORD WINAPI ThreadProcessDSSNotify(LPVOID);
		void BufferCallbackThread(void);

		Error AllocateBufferCallback(void);
		void ReleaseBufferCallback(void);
		Error AllocateAudioBuffers(void);
		void ReleaseAudioBuffers(void);
		void ResetRenderPosition(void);
		Error OpenDevice(void);
		void CloseDevice(void);

		DWORD GetCurrentRenderPosition(void);
		void FlushAndRequeueUnPlayedData(void);
//		void ReQueueFlushedBuffers(void);
		void ReQueueFlushedBuffers(DWORD flushPos);
		bool WaitForRendererCompletionTimout(int timeout);
		void DumpQueue(void);
		void WriteBufferFromQueue(void);
		Error WriteBuffer(int buffer);

		bool IsBufferDone(int id);
		bool WaitForCompletionTimeout(int timeout);

		void DoCallback(void);
		bool DSndSetSpeed(DWORD dwNewFrequency);
		void ResampleBlock(short * src, short * dst, int sourceNum, int destNum, int & sourceDone, int & destDone);
		void ResampleBlock(short * src, int sourceNum, int & sourceDone);
		void ProcessResampleBuffer(void);
		bool BuffersInQueue(void);

		Error SetSPDIFDeviceOut(bool enable);
		void PostBuffer(int usedSize);

	public:
		Ac97PlaybackDevice(GenericProfile * globalProfile, GenericProfile * profile, int numBuffers, int bufferSize);
		~Ac97PlaybackDevice(void);

		bool SupportsSPDIFDataOut(void);
		bool SupportsVolumeControl(void) {return FALSE;}

		void BeginStreaming(GenericAudioPlaybackCallback * callback);
		void StartStreaming(void);
		void StopStreaming(void);
		void EndStreaming(bool fullReset);
		void DoneStreaming(void);

		bool GetBuffer(int requestSize, short * & buffer, int & size);
		bool GetBuffers(int requestSize, short * & bufA, short * & bufD, int & size);
		void PostBuffer(int usedSize, int time) {PostBuffer(usedSize);}

		int CurrentLocation(void);
		int AvailBufferSpace(void);

		int GetSamplingFrequency(void) {return sampleRate;}
		bool SetPlaybackRate(DWORD rate){return FALSE;}

		void WaitForCompletion(void);
		bool IsCompleted(void);
		Error CheckHardwareResources(void) {if (pAnaRender == NULL) GNRAISE(GNR_NO_AUDIO_HARDWARE); else GNRAISE_OK;}

		bool EnterDropDataMode(void);
		void LeaveDropDataMode(void);
		void DropData(int bytes);

		DWORD GetVolume(void){return 0xffffffff;}
		void SetVolume(DWORD volume) {;}

		Error SetCopyProtectionLevel(SPDIFCopyMode sCopyMode);
		Error SetSPDIFDataOut(bool enable);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\AudioBitStream.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "AudioBitStream.h"

int highmask32[33] = {0x00000000, 0x80000000, 0xc0000000, 0xe0000000,
		                 0xf0000000, 0xf8000000, 0xfc000000, 0xfe000000,
		                 0xff000000, 0xff800000, 0xffc00000, 0xffe00000,
		                 0xfff00000, 0xfff80000, 0xfffc0000, 0xfffe0000,
		                 0xffff0000, 0xffff8000, 0xffffc000, 0xffffe000,
		                 0xfffff000, 0xfffff800, 0xfffffc00, 0xfffffe00,
		                 0xffffff00, 0xffffff80, 0xffffffc0, 0xffffffe0,
		                 0xfffffff0, 0xfffffff8, 0xfffffffc, 0xfffffffe,
							  0xffffffff};

DWORD		AudioStreamBuffer[AUDIO_STREAM_BUFFER_SIZE+1];
int		ABSBits;

AudioBitStream::AudioBitStream(StreamFlipCopy * streamFlipCopy)
	: BitStream(AudioStreamBuffer, AUDIO_STREAM_BUFFER_SIZE, ABSBits, streamFlipCopy)
	{
	}

AudioBitStream::~AudioBitStream(void)
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\AudioStreamDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef AUDIOSTREAMDECODER_H
#define AUDIOSTREAMDECODER_H

#include "AudioBitStream.h"
#include "PCMWaveOut.h"
#include "..\common\TimedFibers.h"
#include "library\hardware\audio\generic\ac3setup.h"

class AudioStreamDecoder : public AudioBitStream
	{
	protected:
		PCMWaveOut					*	pcmWaveOut;

		TimedFiberEvent				bufferRefillEvent;

		int								requestedBits;
		int								avgFrameSize, frameDuration;

		bool								completing;
		bool								terminate;
		bool								streamingCompleted;

		bool InternalIsBufferComplete(void);
		bool InternalRefillBuffer(int requestBits, bool lowDataPanic);
	public:
		AudioStreamDecoder(PCMWaveOut * pcmWaveOut, StreamFlipCopy * streamFlipCopy);
		virtual ~AudioStreamDecoder(void);

		virtual void SetAudioCodingMode(int samplesPerSecond, int bitsPerSample, int channels) {}

		virtual void SetAudioOutConfig(AC3SpeakerConfig spkCfg, AC3DualModeConfig dualModeCfg, AC3KaraokeConfig karaokeCfg) {}

		virtual void AdvanceFrame(void) {pcmWaveOut->AdvanceFrame();}

		virtual void BeginStreaming(void);
		virtual void StartStreaming(int playbackSpeed);
		virtual void StopStreaming(void);
		virtual void EndStreaming(bool fullReset);
		virtual void DetachStreaming(void);
		virtual void AttachStreaming(void);

		virtual bool StreamingCompleted(void);

		virtual DWORD SendData(BYTE * ptr, DWORD num);
		virtual void CompleteData(void);

		virtual void RefillRequest(void) = 0;
		virtual void StreamCompleted(void) {}

		virtual __int64 CurrentPlaybackLocation(void);

		virtual int TotalAudioBufferTime(void);

	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\AudioPlaybackDevice.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "AudioPlaybackDevice.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\AudioTransformations.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "AudioTransformations.h"
//#include "..\common\amd3dx.h"
#include "driver\SoftwareCinemaster\Common\Prelude.h"


static MMXDWORD<2>	xorLo1HiMinus1 = {0x00000000, 0x80000000};
static MMXDWORD<2>	xorLoMinus1Hi1 = {0x80000000, 0x00000000};

extern complex cossintab64[64];
extern complex xcossin512[128];
extern complex xcossin256[64];
extern fftreal ac3WindowTable2[256];

#pragma warning(disable : 4799)

static inline void IFFT(complex * x, complex * y, int n, complex * fm)
	{
	int m, i, j, r, nm, is, n2, n4, n6, n8;
	fftreal wr, wi;
	fftreal sr, si;
	fftreal yr0, yi0, yr1, yi1, yr2, yi2, yr3, yi3;

	n2 = n >> 1;
	n4 = n >> 2;
	n8 = n >> 3;
	n6 = n2 + n4;

	j = 0;
	for(i=0; i<n; i+=4)
		{
		yr0 = x[j+0].r + x[j+n2].r;
		yi0 = x[j+0].i + x[j+n2].i;
		yr1 = x[j+0].r - x[j+n2].r;
		yi1 = x[j+0].i - x[j+n2].i;
		yr2 = x[j+n4].r + x[j+n6].r;
		yi2 = x[j+n4].i + x[j+n6].i;
		yr3 = x[j+n4].r - x[j+n6].r;
		yi3 = x[j+n4].i - x[j+n6].i;

		y[i+0].r = yr0 + yr2;
		y[i+0].i = yi0 + yi2;
		y[i+1].r = yr1 - yi3;
		y[i+1].i = yi1 + yr3;
		y[i+2].r = yr0 - yr2;
		y[i+2].i = yi0 - yi2;
		y[i+3].r = yr1 + yi3;
		y[i+3].i = yi1 - yr3;

		m = n8;
		while (m && (j & m))
			{
			j -= m;
			m >>= 1;
			}
		j += m;
		}

	nm = 8;
	r = 16;
	while (n > nm)
		{
		m = 0;
		is = nm >> 1;
		for(i=0; i <is; i++)
			{
			wr = cossintab64[m].r; wi = cossintab64[m].i;
			m += r;

			for(j=i; j<n; j+=nm)
				{
				sr = y[j+is].r * wr - y[j+is].i * wi;
				si = y[j+is].r * wi + y[j+is].i * wr;
				y[j+is].r = y[j].r - sr;
				y[j+is].i = y[j].i - si;
				y[j].r += sr;
				y[j].i += si;
				}
			}
		nm <<= 1;
		r >>= 1;
		}

	m = 0;
	is = nm >> 1;
	for(i=0; i <is; i++)
		{
		wr = cossintab64[m].r; wi = cossintab64[m].i;
		m += r;

		sr = y[i+is].r * wr - y[i+is].i * wi;
		si = y[i+is].r * wi + y[i+is].i * wr;

		yr0 = y[i].r - sr;
		yi0 = y[i].i - si;
		yr1 = y[i].r + sr;
		yi1 = y[i].i + si;

		y[i+is].r = yi0 * fm[i+is].i - yr0 * fm[i+is].r;
		y[i+is].i = yi0 * fm[i+is].r + yr0 * fm[i+is].i;

		y[i   ].r = yi1 * fm[i   ].i - yr1 * fm[i   ].r;
		y[i   ].i = yi1 * fm[i   ].r + yr1 * fm[i   ].i;
		}

	}


static inline void InverseFFT512(fftreal * x, fftreal * y)
	{
	static const int n = 512;


	complex z[n/4];
	complex zz[n/4];
	int k, l;

	for(k=0; k<n/4; k++)
		{
		l = 2 * k;

		z[k].r = x[n/2-l-1] * xcossin512[k].r - x[    l  ] * xcossin512[k].i;
		z[k].i = x[    l  ] * xcossin512[k].r + x[n/2-l-1] * xcossin512[k].i;
		}


	IFFT(z, zz, n / 4, xcossin512);



	for(l=0; l<n/8; l++)
		{
		k = l * 2;

		// tzr = zz[l].r * xcossin512[l].r - zz[l].i * xcossin512[l].i;
		// tzi = zz[l].i * xcossin512[l].r + zz[l].r * xcossin512[l].i;

		y[    n/4+k  ] =  zz[l].r;;
		y[    n/4-k-1] = -zz[l].r;;
		y[n/2+n/4+k  ] =  zz[l].i;
		y[n/2+n/4-k-1] =  zz[l].i;

		// tzr = zz[n/8+l].r * xcossin512[n/8+l].r - zz[n/8+l].i * xcossin512[n/8+l].i;
		// tzi = zz[n/8+l].i * xcossin512[n/8+l].r + zz[n/8+l].r * xcossin512[n/8+l].i;

		y[    k  ] = -zz[n/8+l].i;
		y[n/2-k-1] =  zz[n/8+l].i;
		y[n/2+k  ] =  zz[n/8+l].r;
		y[n  -k-1] =  zz[n/8+l].r;
		}


	}





static inline void InverseFFT256(fftreal * x, fftreal * y)
	{

	static const int n = 512;

	int k, l;

	complex z[2][n/8];
	complex zz[2][n/8];
	for(k=0; k<n/8; k++)
		{
		l = 2 * k;

		z[0][k].r = x[2*(n/4-l-1)]   * xcossin256[k].r - x[2*(    l  )]   * xcossin256[k].i;
		z[0][k].i = x[2*(    l  )]   * xcossin256[k].r + x[2*(n/4-l-1)]   * xcossin256[k].i;

		z[1][k].r = x[2*(n/4-l-1)+1] * xcossin256[k].r - x[2*(    l  )+1] * xcossin256[k].i;
		z[1][k].i = x[2*(    l  )+1] * xcossin256[k].r + x[2*(n/4-l-1)+1] * xcossin256[k].i;
		}
	IFFT(z[0], zz[0], n / 8, xcossin256);
	IFFT(z[1], zz[1], n / 8, xcossin256);
	for(l=0; l<n/8; l++)
		{
		k = l * 2;

		y[k]         = -zz[0][l].i;
		y[k+1]       = -zz[0][n/8-l-1].r;
		y[n/4+k]     =  zz[0][l].r;
		y[n/4+k+1]   =  zz[0][n/8-l-1].i;
		y[n/2+k]     =  zz[1][l].r;
		y[n/2+k+1]   =  zz[1][n/8-l-1].i;
		y[3*n/4+k]   =  zz[1][l].i;
		y[3*n/4+k+1] =  zz[1][n/8-l-1].r;

		}
	}



void NormalTransformChannels::AC3TransformChannels(fftreal * chcoeff, fftreal * chpostfft, bool split)
	{
	if(split)
		InverseFFT256(chcoeff, chpostfft);
	else
		InverseFFT512(chcoeff, chpostfft);
	}



#pragma warning(default : 4799)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\AudioPlaybackDevice.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef AUDIOPLAYBACKDEVICE_H
#define AUDIOPLAYBACKDEVICE_H

#include "driver\SoftwareCinemaster\Common\Prelude.h"
#include "..\common\TimedFibers.h"
#include "library\common\profiles.h"
#define VIONA_VERSION	1
#define ONLY_EXTERNAL_VISIBLE
#include "library\hardware\mpeg2dec\generic\mp2eldec.h"
#include "library\hardware\audio\generic\aucodecs.h"

	//
	// Generic callback for buffer completion information
	//
class GenericAudioPlaybackCallback
	{
	public:
		virtual void WaveDataRequest(void) = 0;
	};

	//
	// Generic definition of a playback device for Audio data.
	//
class GenericAudioPlaybackDevice
	{
	public:
		virtual ~GenericAudioPlaybackDevice(void) {}

			//
			// Begin a session with audio streaming.  Has to be called prior
			// to sending any data to the streaming device.
			//
			// IN  : callback      : This callback will be called, whenever a
			//                       buffer finishes playback.
			//
		virtual void BeginStreaming(GenericAudioPlaybackCallback * callback) = 0;

			//
			// Start actual playback.  When this function is called, data is
			// typically already added to the buffer.  The playback should start
			// immediately with this call.  All long time operations have to
			// be done by BeginStreaming.
			//
		virtual void StartStreaming(void) = 0;

			//
			// Stop playback.  Playback may be resumed with StartPlayback at the
			// same location where it was stopped.  This function is called for
			// pause, or before EndStreaming.
			//
		virtual void StopStreaming(void) = 0;

			//
			// End playback.  All pending data is to be discarded.
			//
		virtual void EndStreaming(bool fullReset) = 0;

			//
			// Inform the playback device that very likely no more data is to
			// be expected, and all pending data in not yet full buffers, shall
			// be sent off to the audio hardware for playback.
			//
			// IN  : fullReset : TRUE, if there is likely a pause before the next
			//                   BeginStreaming
			//
		virtual void DoneStreaming(void) = 0;

			//
			// This function will not return before all pending data is played,
			// or EndStreaming is called.
			// It can be implemented as polling loop with calling Yield.
			//
		virtual void WaitForCompletion(void) = 0;

			//
			// Check whether the playback is completed (all data is sent to
			// the hardware, and the hardware is finished playing).
			//
		virtual bool IsCompleted(void) = 0;


			//
			// Request buffer space to fill with new audio data.
			//
			// IN  : requestSize : Requested size of buffer space to fill in
			//                     bytes.  This parameter may be ignored by
			//                     the playback device.
			// OUT : buffer      : Pointer to buffer space for filling with
			//                     audio data by decoder.
			// OUT : size        : Actual size of buffer in bytes.
			// RETURN            : TRUE, if buffer space was available.
			//
		virtual bool GetBuffer(int requestSize, short * & buffer, int & size) = 0;

			//
			// Request buffer space to fill with new audio data.
			//
			// IN  : requestSize : Requested size of buffer space to fill in
			//                     bytes.  This parameter may be ignored by
			//                     the playback device.
			// OUT : bufA		 : Pointer to buffer space for filling with analog
			//                     audio data by decoder.
			// OUT : bufA		 : Pointer to buffer space for filling with digital
			//                     audio data by decoder.
			// OUT : size        : Actual size of buffer in bytes.
			// RETURN            : TRUE, if buffer space was available.
			//
		virtual bool GetBuffers(int requestSize, short * & bufA, short * & bufD, int & size) = 0;

			//
			// Return buffer space that was requested with GetBuffer back to
			// the playback device.
			//
			// IN  : usedSize    : Actually used size of buffer in bytes.
			//
		virtual void PostBuffer(int usedSize, int time) = 0;

			//
			// Returns the current playback location since the last call to
			// BeginStreaming in stereo samples
			//
		virtual int CurrentLocation(void) = 0;

			//
			// Returns the available buffer space in stereo samples.
			//
		virtual int AvailBufferSpace(void) = 0;

			//
			// Returns the current sampling rate
			//
		virtual int GetSamplingFrequency(void) = 0;

			//
			// Returns the current volume, HIWORD left, LOWORD right
			//
		virtual DWORD GetVolume(void) = 0;

			//
			// Sets the current volume
			//
		virtual void SetVolume(DWORD volume) = 0;

			//
			// Attempts to change the playback rate on the fly.
			//
			// IN  : rate      : Requested playback rate, 0x10000 is normal
			//                   playback speed.
			// RETURN          : Returns TRUE on success
			//
		virtual bool SetPlaybackRate(DWORD rate) = 0;

			//
			// Returns TRUE, if this playback device is functional
			//
		virtual Error CheckHardwareResources(void) = 0;

			//
			// Sets the Sample Rate
			//
		virtual Error SetSampleRate(int newSampleRate) {GNRAISE(GNR_AUDIO_TYPE_NOT_SUPPORTED);}

			//
			// Sets the copy protection mode for SPDIF
			//
		virtual Error SetCopyProtectionLevel(SPDIFCopyMode sCopyMode) {GNRAISE(GNR_NO_SPDIF_HARDWARE);}

			//
			// Checks whether this playback device supports SPDIF data output
			//
		virtual bool SupportsSPDIFDataOut(void) {return FALSE;}

			//
			// Sets the playback device to SPDIF data output mode
			//
		virtual Error SetSPDIFDataOut(bool enable) {if (enable) GNRAISE(GNR_NO_SPDIF_HARDWARE); else GNRAISE_OK;}

			//
			// Checks whether this device supports volume control
			//
		virtual bool SupportsVolumeControl(void) {return TRUE;}

			//
			// Requests the device to enter DropDataMode.  In this mode, no
			// playback is happening.  This function is called only in stop
			// state.  Instead of playing the data, the data is to be dropped
			// by the device on calls of DropData.  This function is used for
			// single step and slow motion playback.
			//
		virtual bool EnterDropDataMode(void) {return FALSE;}

			//
			// Requests the device to return to normal playback.
			//
		virtual void LeaveDropDataMode(void) {}

			//
			// Requests the device to drop a number of bytes out of the decoder
			// buffer.
			//
		virtual void DropData(int bytes) {}

			//
			// Requests the device to enter ResampleMode.  In this mode, the audio
			// data is played with a different speed.  This function is only called
			// in stop state, and used for smooth slow motion or fast forward.
			//
			// IN  : speed     : Requested playback speed, 0x10000 is normal
			//                   playback speed.
			// RETURN          : Returns TRUE on success
			//
		virtual bool EnterResampleMode(DWORD speed) {return FALSE;}

			//
			// Request the device to leave the ResampleMode, and return to normal
			// playback mode.
			//
		virtual void LeaveResampleMode(void) {}

	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\AudioStreamDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "AudioStreamDecoder.h"
#include "library\common\vddebug.h"

//
//  Constructor
//

AudioStreamDecoder::AudioStreamDecoder(PCMWaveOut * pcmWaveOut, StreamFlipCopy * streamFlipCopy)
	: bufferRefillEvent(FALSE, TRUE), AudioBitStream(streamFlipCopy)
	{
	this->pcmWaveOut = pcmWaveOut;

	//	bufferRefillEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	avgFrameSize = 0;
	}

//
//  Destructor
//

AudioStreamDecoder::~AudioStreamDecoder(void)
	{
//	CloseHandle(bufferRefillEvent);
//	DeleteCriticalSection(&lock);
	}

//
//  Begin Streaming
//

void AudioStreamDecoder::BeginStreaming(void)
	{
	terminate = FALSE;
	completing = FALSE;
	streamingCompleted = FALSE;
	}

void AudioStreamDecoder::DetachStreaming(void)
	{
	terminate = TRUE;
	bufferRefillEvent.SetEvent();
	}

void AudioStreamDecoder::AttachStreaming(void)
	{
	terminate = FALSE;
	completing = FALSE;
	streamingCompleted = FALSE;
	}

//
// Start Streaming
//

void AudioStreamDecoder::StartStreaming(int playbackSpeed)
	{
	}

//
//  Stop Streaming
//

void AudioStreamDecoder::StopStreaming(void)
	{
	}

//
//  End Streaming
//

void AudioStreamDecoder::EndStreaming(bool fullReset)
	{
	terminate = TRUE;
	bufferRefillEvent.SetEvent();
	}

//
//  Send Data
//

DWORD AudioStreamDecoder::SendData(BYTE * ptr, DWORD num)
	{
	DWORD done;

	done = AddData(ptr, num);

	if (AvailBits() >= requestedBits) bufferRefillEvent.SetEvent();

	return done;
	}

//
//  Complete Data
//

void AudioStreamDecoder::CompleteData(void)
	{
	if (!completing)
		{
		StuffBuffer();						// Fill up to next DWORD
		completing = TRUE;
		bufferRefillEvent.SetEvent();
		}
	}

//
//  Internal Is Buffer Complete
//

bool AudioStreamDecoder::InternalIsBufferComplete(void)
	{
	return completing;
	}

//
//  Internal Refill Buffer
//

bool AudioStreamDecoder::InternalRefillBuffer(int requestBits, bool lowDataPanic)
	{
	requestedBits = requestBits;

	//
	//  Repeat requesting data as long we do not want to terminate and do not have enough data
	//

	while (!terminate && !completing && requestBits > AvailBits())
		{
		RefillRequest();

		bufferRefillEvent.Wait(100);
		}

	if (!terminate && !completing && AvailBits() < 8 * AUDIO_STREAM_BUFFER_SIZE) RefillRequest();

	return !terminate && (completing && AvailBits() > 0 || AvailBits() >= requestBits);
	}

//
//  Streaming Completed
//

bool AudioStreamDecoder::StreamingCompleted(void)
	{
	return streamingCompleted;// && pcmWaveOut->GetBufferDelayTime() < 200;
	}

//
//  Current Playback Location
//

__int64 AudioStreamDecoder::CurrentPlaybackLocation(void)
	{
	__int64 pos = CurrentLocation();
	int delta;

	if (avgFrameSize && !terminate)
		{
		delta = pcmWaveOut->GetBufferDelayTime();

		if (delta < 0x100000 && avgFrameSize)
			delta = ScaleLong(delta, frameDuration, avgFrameSize);
		else
			delta = 0;

		if (pos < delta)
			return 0;
		else
			return pos - delta;
		}
	else
		return pos;
	}

//
//  Total Audio Buffer Time
//

int AudioStreamDecoder::TotalAudioBufferTime(void)
	{
	if (avgFrameSize)
		return pcmWaveOut->GetBufferDelayTime() + ScaleLong(AvailBits(), avgFrameSize, frameDuration);
	else
		return pcmWaveOut->GetBufferDelayTime();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\AudioTransformations.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef AUDIOTRANSFORMATIONS_H
#define AUDIOTRANSFORMATIONS_H

#include <xtl.h>

#define HIGH_PRECISION_FFT	0

#if HIGH_PRECISION_FFT
typedef	double	fftreal;
#else
typedef	float		fftreal;
#endif

struct complex {fftreal r; fftreal i;};

class AudioTransformation
	{
//	protected:

	public:
		AudioTransformation(void) {}
		virtual ~AudioTransformation(void){}
		virtual void AC3TransformChannels(fftreal * chcoeff, fftreal * chpostfft, bool split){}
	};

class NormalTransformChannels : public AudioTransformation
	{
//	protected:

	public:
		NormalTransformChannels(void){}
		~NormalTransformChannels(void){}
		void AC3TransformChannels(fftreal * chcoeff, fftreal * chpostfft, bool split);
	};

class AMD3DNowTransformChannels : public NormalTransformChannels
	{
//	protected:

	public:
		AMD3DNowTransformChannels(void){}
		~AMD3DNowTransformChannels(void){}
		virtual void AC3TransformChannels(fftreal * chcoeff, fftreal * chpostfft, bool split);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\DTSDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef DTSDECODER_H
#define DTSDECODER_H

#include "..\common\StreamTiming.h"
#include "..\audio\PCMWaveOut.h"
#include "..\audio\AudioBitStream.h"
#include "library\common\profiles.h"
#include "library\hardware\audio\generic\AC3setup.h"

class DTSDecoder
	{
	protected:
		AudioBitStream	*	strm;
		PCMWaveOut		*	pcmWaveOut;
		GenericProfile	*	globalProfile;
		GenericProfile	*	profile;

	private:

	protected:
		DWORD	syncword;
		int		numPCMSamplePairs;
		BYTE	dtsType;

		int		frameSize;
		__int64	frameStart;

		int		FrameCnt;

		short	leftRightBuffer[2048*2];
		short	encodedBuffer[2048*2];

		bool				dtsDigitalOutput;

		bool ParseSyncInfo(void);

		bool ParseBSI(void);

		int	lastTime;

		int	currentDataTime;

		bool	hurryUp;

		TimingSlave	*	timingSlave;

		void FrameDTSDigitalOutput(void);
		void InitLocalsNewStream(void);

	public:
		DTSDecoder(AudioBitStream	*	strm,
					PCMWaveOut		*	pcmWaveOut,
					TimingSlave		*	timingSlave,
					GenericProfile	*	globalProfile,
					GenericProfile	*	profile);

		virtual ~DTSDecoder(void);

		void ParseSyncFrame(void);

		void BeginStreaming(void);

		void StartStreaming(int playbackSpeed);

		void StopStreaming(void);

		void EndStreaming(bool fullReset);

		void DetachStreaming(void);
		void AttachStreaming(void);

		void SetDigitalOut(AudioTypeConfig dtsAudioType);
		void GetDigitalOut(AudioTypeConfig & dtsAudioType);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\DTSDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "DTSDecoder.h"
#include "math.h"
#include <memory.h>
#include "library\common\vddebug.h"
#include "..\common\TimedFibers.h"


#if DUMP_FFT_DATA
#include <stdio.h>
FILE * dfile;
#endif

DTSDecoder::DTSDecoder(AudioBitStream * strm,
						PCMWaveOut * pcmWaveOut,
						TimingSlave * timingSlave,
						GenericProfile			*	globalProfile,
						GenericProfile			*	profile)
	{

	this->strm = strm;
	this->pcmWaveOut = pcmWaveOut;
	this->timingSlave = timingSlave;
	this->globalProfile = globalProfile;
	this->profile = profile;

	dtsDigitalOutput = false;
	frameSize = 0;

	ZeroMemory(leftRightBuffer, sizeof(leftRightBuffer));

#if DUMP_FFT_DATA
	dfile = fopen("f:\\DTS\\dmp.txt", "w");
#endif
	}


bool DTSDecoder::ParseSyncInfo(void)
	{
	int newFrameSize;

	strm->ByteAllign();
	strm->PeekBits(8);
	if (!strm->RefillBuffer(95 * 8)) return FALSE;

	while (strm->AvailBits() >= 95 * 8 && (syncword = (DWORD)(strm->PeekBits(32))) != 0x7ffe8001)
		{
		strm->Advance(8);
		if (!strm->RefillBuffer(95 * 8)) return FALSE;
		}

	if (syncword != 0x7ffe8001)
		{
		DP("Strange DTS syncword failure");
		strm->Advance(strm->AvailBits());
		return FALSE;
		}

	frameStart = strm->CurrentLocation();

	strm->Advance(32);

	WORD w3f, ftype, shrt, cpf, nblks, fsize;

	w3f = (WORD)(strm->PeekBits(6));
	ftype = (WORD)(strm->GetBits(1));
	shrt = (WORD)(strm->GetBits(5));
	cpf = (WORD)(strm->GetBits(1));

	nblks = (WORD)(strm->GetBits(7));
	fsize = (WORD)(strm->GetBits(14));

	if (fsize < 94) return FALSE;
	if (fsize > 8193) return FALSE;

	numPCMSamplePairs = (nblks+1) * 32;  //number of audio l/r pairs (*4=bytes)
	switch (numPCMSamplePairs)
		{
		default:
			DP("DTS numPCMSamplePairs unknown %d", numPCMSamplePairs);
		case 2048:
			dtsType = 0x0d; //type III
			break;
		case 1024:
			dtsType = 0x0c; //type II
			break;
		case 512:
			dtsType = 0x0b; //type I
			break;
		}

	newFrameSize = (fsize+1) * 8;

	//chztbd - should add in aux data size

	if (!strm->RefillBuffer(newFrameSize - 66)) return FALSE;

	if (newFrameSize - 66 <= strm->AvailBits())
		{
		frameSize = newFrameSize;

		return TRUE;
		}
	else
		{
		return FALSE;
		}
	}


void DTSDecoder::FrameDTSDigitalOutput(void)
	{
	int i;
	BYTE * dptr = (BYTE *)&encodedBuffer;

	strm->SetCurrentLocation(frameStart);

	//Pa
	*dptr++ = 0x72;
	*dptr++ = 0xf8;
	//Pb
	*dptr++ = 0x1f;
	*dptr++ = 0x4e;
	//Pc
	*dptr++ = dtsType;
	*dptr++ = 0x00;
	//Pd
	*dptr++ = frameSize & 0xff;
	*dptr++ = frameSize >> 8;


	for (i=0; i<frameSize; i+=16)
		{
		WORD w;
		w = (WORD)(strm->GetBits(16));
		*dptr++ = w & 0xff;
		*dptr++ = w >> 8;
		}

	i = (numPCMSamplePairs*4) - 8 - (frameSize>>3);
	memset(dptr, 0, i);
	}



void DTSDecoder::ParseSyncFrame(void)
	{
	int blk, ch, time;
	__int64 frameEnd;

	do {
		time = strm->GetCurrentTimeStamp();

		if (!ParseSyncInfo()) return;

		if (!strm->RefillBuffer(frameSize + 66)) return;

		frameEnd = frameStart + frameSize;

		} while (PeekWordAt((int)(frameEnd - strm->CurrentLocation())) != 0x7ffe);

	if (time != INVALID_TIME_STAMP && time != lastTime)
		{
		lastTime = time;
		currentDataTime = time;
		time -= pcmWaveOut->GetBufferDelayTime();
		if (time >= 0 && timingSlave)
			{
			timingSlave->UpdateTimer(time);
			}
		}

#if DUMP_FFT_DATA
	fprintf(dfile, "FRAME AT %08lx to %08lx\n", (int)frameStart / 8, (int)frameEnd / 8);
#endif

	if (dtsDigitalOutput)
		{
		FrameDTSDigitalOutput();
		pcmWaveOut->AddPCMDigData(leftRightBuffer, encodedBuffer, numPCMSamplePairs, currentDataTime);
		}
	else
		{
		pcmWaveOut->AddPCMData(leftRightBuffer, numPCMSamplePairs, currentDataTime);
		}

	currentDataTime += (1000 * (numPCMSamplePairs)) / 48000;

	if (!hurryUp) YieldTimedFiber(0);


	strm->Advance((int)(frameEnd - strm->CurrentLocation()));

	FrameCnt++;
	}


DTSDecoder::~DTSDecoder(void)
	{
#if DUMP_FFT_DATA
	fclose(dfile);
#endif
	}

void DTSDecoder::InitLocalsNewStream(void)
	{
	hurryUp = FALSE;
	FrameCnt = 0;
	}

void DTSDecoder::BeginStreaming(void)
	{
	pcmWaveOut->BeginStreaming();
	InitLocalsNewStream();
	}

void DTSDecoder::StartStreaming(int playbackSpeed)
	{
	pcmWaveOut->StartStreaming(playbackSpeed);
	}

void DTSDecoder::StopStreaming(void)
	{
	pcmWaveOut->StopStreaming();
	}

void DTSDecoder::EndStreaming(bool fullReset)
	{
	pcmWaveOut->EndStreaming(fullReset);
	}

void DTSDecoder::DetachStreaming(void)
	{
	pcmWaveOut->DetachStreaming();
	}

void DTSDecoder::AttachStreaming(void)
	{
	pcmWaveOut->AttachStreaming();
	InitLocalsNewStream();
	}


void DTSDecoder::SetDigitalOut(AudioTypeConfig dtsAudioType)
	{
	if (pcmWaveOut->SupportsSPDIFDataOut())
		{
		dtsDigitalOutput = dtsAudioType.config.spdifOutMode == SPDIFOM_DEFAULT;
		}
	else
		{
		dtsDigitalOutput = false;
		}

	}

void DTSDecoder::GetDigitalOut(AudioTypeConfig & dtsAudioType)
	{
	dtsAudioType.config.spdifOutMode = dtsDigitalOutput ? SPDIFOM_DEFAULT : SPDIFOM_DECOMPRESSED;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\DTSStreamDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "DTSStreamDecoder.h"
#include "library\common\vddebug.h"

#pragma warning(disable : 4355)
DTSStreamDecoder::DTSStreamDecoder(PCMWaveOut * pcmWaveOut, TimingSlave * timingSlave, GenericProfile * globalProfile, GenericProfile * profile, StreamFlipCopy * streamFlipCopy)
									: DTSDecoder(this, pcmWaveOut, timingSlave, globalProfile, profile),
									  AudioStreamDecoder(pcmWaveOut, streamFlipCopy),
									  supervisor(this),
									  TimedFiber(14)
	{
	streaming = FALSE;
	frameDuration = 32;
//	this->streamFlipCopy = streamFlipCopy;
	}
#pragma warning(default : 4355)

DTSStreamDecoder::~DTSStreamDecoder(void)
	{
	if (streaming) EndStreaming(TRUE);
	}

void DTSStreamDecoder::FiberRoutine(void)
	{
	int buffer;

	while (strm->RefillBuffer(40))//12288))
		{
		ParseSyncFrame();

		if (!avgFrameSize)
			avgFrameSize = frameSize;
		else
			avgFrameSize = (avgFrameSize * 7 + frameSize) >> 3;

		buffer = AudioStreamDecoder::pcmWaveOut->GetBufferDelayTime();

		if (hurryUp && buffer > 400)
			{
			hurryUp = FALSE;

			SetFiberPriority(2);
			}
		else if (!hurryUp && buffer < 300)
			{
			hurryUp = TRUE;
			lowPriority = FALSE;

			SetFiberPriority(3);
			}
		else if (lowPriority && buffer < 500)
			{
			lowPriority = FALSE;

			SetFiberPriority(2);
			}
		else if (!lowPriority && buffer > 600)
			{
			lowPriority = TRUE;
			hurryUp = FALSE;

			SetFiberPriority(1);
			}

		if (!hurryUp) YieldFiber(0);
		else YieldFiber(-1);
		}

	if (!terminate)
		{
		AudioStreamDecoder::pcmWaveOut->CompleteStreaming();

		AudioStreamDecoder::pcmWaveOut->WaitForCompletion();
		}

	streamingCompleted = TRUE;
	StreamCompleted();
	}

DTSStreamDecoder::Supervisor::Supervisor(DTSStreamDecoder * decoder)
	: TimedFiber(4)
	{
	this->decoder = decoder;
	}

void DTSStreamDecoder::Supervisor::FiberRoutine(void)
	{
	SetFiberPriority(3);
	decoder->SupervisorFiberRoutine();
	}

void DTSStreamDecoder::SupervisorFiberRoutine(void)
	{
	int buffer;

	while (!terminate)
		{
		buffer = AudioStreamDecoder::pcmWaveOut->GetBufferDelayTime();

		if (hurryUp && buffer > 400)
			{
			hurryUp = FALSE;

			SetFiberPriority(2);
			}
		else if (!hurryUp && buffer < 300)
			{
			hurryUp = TRUE;
			lowPriority = FALSE;

			SetFiberPriority(3);
			}
		else if (lowPriority && buffer < 500)
			{
			lowPriority = FALSE;

			SetFiberPriority(2);
			}
		else if (!lowPriority && buffer > 600)
			{
			lowPriority = TRUE;
			hurryUp = FALSE;

			SetFiberPriority(1);
			}

		YieldTimedFiber(100);
		}
	}

void DTSStreamDecoder::InitLocalsNewStream(void)
	{
	SetFiberPriority(3);
	lowPriority = FALSE;
	streaming = TRUE;
	avgFrameSize = 0;

	supervisor.StartFiber();
	StartFiber();
	}

void DTSStreamDecoder::ClosingCurrentStream(void)
	{
	CompleteFiber();
	supervisor.CompleteFiber();
	FlushBuffer();
	streaming = FALSE;
	}

void DTSStreamDecoder::BeginStreaming(void)
	{
	AudioStreamDecoder::BeginStreaming();
	DTSDecoder::BeginStreaming();
	InitLocalsNewStream();
	}

void DTSStreamDecoder::StartStreaming(int playbackSpeed)
	{
	DTSDecoder::StartStreaming(playbackSpeed);
	AudioStreamDecoder::StartStreaming(playbackSpeed);
	}

void DTSStreamDecoder::StopStreaming(void)
	{
	DTSDecoder::StopStreaming();
	AudioStreamDecoder::StopStreaming();
	}

void DTSStreamDecoder::EndStreaming(bool fullReset)
	{
	if (streaming)
		{
		AudioStreamDecoder::EndStreaming(fullReset);
		DTSDecoder::EndStreaming(fullReset);
		ClosingCurrentStream();
		}
	}

void DTSStreamDecoder::DetachStreaming(void)
	{
	if (streaming)
		{
		AudioStreamDecoder::DetachStreaming();
		DTSDecoder::DetachStreaming();
		ClosingCurrentStream();
		}
	}

void DTSStreamDecoder::AttachStreaming(void)
	{
	AudioStreamDecoder::AttachStreaming();
	DTSDecoder::AttachStreaming();
	InitLocalsNewStream();
	}

void DTSStreamDecoder::CompleteData(void)
	{
	BYTE fakeheader[] = {0x7f, 0xfe, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00};

	if (!completing)
		{
		AddData(fakeheader, 8);
		StuffBuffer();						// Fill up to next DWORD
		completing = TRUE;
		bufferRefillEvent.SetEvent();
		}
	}

//
//  Send Data
//
DWORD DTSStreamDecoder::SendData(BYTE * ptr, DWORD num)
	{
	return(AudioStreamDecoder::SendData(ptr, num));
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\DTSStreamDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef DTSSTREAMDECODER_H
#define DTSSTREAMDECODER_H

#include "DTSDecoder.h"
#include "..\audio\AudioStreamDecoder.h"
#include "..\common\TimedFibers.h"

class DTSStreamDecoder : public AudioStreamDecoder,
							protected DTSDecoder,
							private TimedFiber
	{
	protected:
		bool								lowPriority;
		bool								streaming;

		StreamFlipCopy * streamFlipCopy;

		class Supervisor : public TimedFiber
			{
			protected:
				DTSStreamDecoder * decoder;
			public:
				Supervisor(DTSStreamDecoder * decoder);
				void FiberRoutine(void);
			} supervisor;

		void FiberRoutine(void);
		void SupervisorFiberRoutine(void);
		void InitLocalsNewStream(void);
		void ClosingCurrentStream(void);

		friend class DTSStreamDecoder::Supervisor;
	public:
		DTSStreamDecoder(PCMWaveOut * pcmWaveOut, TimingSlave * timingSlave, GenericProfile * globalProfile, GenericProfile * profile, StreamFlipCopy * streamFlipCopy);
		~DTSStreamDecoder(void);

		void BeginStreaming(void);
		void StartStreaming(int playbackSpeed);
		void StopStreaming(void);
		void EndStreaming(bool fullReset);
		void DetachStreaming(void);
		void AttachStreaming(void);
		DWORD SendData(BYTE * ptr, DWORD num);

		void CompleteData(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\PCMWaveOut.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "PCMWaveOut.h"
#include "..\common\TimedFibers.h"
#include "..\common\PerformanceMonitor.h"
#include "library\common\vddebug.h"

#define AUDIO_DUMP					1
#define EXT_NAME_FOR_PCM_AUDIO_DUMP	1

#if AUDIO_DUMP
static HANDLE audioStream;
static int audioStreamCount;
#endif

void PCMWaveOut::WaveDataRequest(void)
	{
	event.SetEvent();
	}

PCMWaveOut::PCMWaveOut(GenericProfile * globalProfile, GenericProfile * profile, GenericAudioPlaybackDevice * device, TimingSlave * timingSlave)
	: event(FALSE, TRUE), fiberEvent(FALSE, TRUE), TimedFiber(5)
	{
	this->globalProfile = globalProfile;
	this->profile = profile;
	this->device = device;
	this->timingSlave = timingSlave;

	monoOutput = false;
	inputByteCount = 0;
	running = FALSE;

	sampleRate = device->GetSamplingFrequency();
	SetSampleRate(sampleRate);

	maxAudioBuffer = device->AvailBufferSpace();
	threadRunning = FALSE;

//#if AUDIO_DUMP
//	audioStream = ::CreateFile("f:\\ac3\\strm.pcm",
//							  GENERIC_WRITE,
//							  FILE_SHARE_WRITE,
//							  NULL,
//							  CREATE_ALWAYS,
//							  FILE_ATTRIBUTE_NORMAL,
//							  NULL);

//	if(audioStream == INVALID_HANDLE_VALUE)
//		{
//		int err = ::GetLastError();
//		}
//
//#endif
	}

void PCMWaveOut::SetSampleRate(int rate)
	{
	if (rate != 48000)
		{
		DP("SetSampleRate = %d ", rate);
		PMMSGX("SetSampleRate = %d \n", rate);
		}
	}

PCMWaveOut::~PCMWaveOut(void)
	{
//#if AUDIO_DUMP
//	::CloseHandle(audioStream);
//#endif
	}

#define	WORD_M3DB_DIV2	(WORD)(0.707106781 * 32768.0/2)

MMXShort<4> MMX_WORD_M3DB_DIV2 = {WORD_M3DB_DIV2, WORD_M3DB_DIV2, WORD_M3DB_DIV2, WORD_M3DB_DIV2};

inline void MonoMixMoveBuffer(short * sdp, short * ssp, int numSamplePairs)
	{
	if (!numSamplePairs)
		{
		return;
		}
// mmx mix move is slighty better in release build and much better in debug....
//	short * wSp = (short*)sap;
//	short * wDp = (short*)dp;
//
//	for(int i=0; i<max; i++)
//		{
//		*wDp = (*wSp + *(wSp+1)) * 0.707106781 ;
//		*(wDp+1) = *wDp;
//		wDp += 2;
//		wSp += 2;
//		}

	__asm
		{
		mov			ecx, [numSamplePairs]
		mov			esi, [ssp]
		mov			edi, [sdp]
		mov			eax, ecx
		and			eax, 1
		shr			ecx, 1
		movq		mm7, MMX_WORD_M3DB_DIV2
		jz			noQuad
loop1:
												//   hi			  low
		movq		mm0, [esi]					// r1, l1		r0, l0
		add			esi, 8
		pmaddwd		mm0, mm7					// .7r1+.7l1	.7r0+.7l0
		add			edi, 8
		psrad		mm0, 16-2					// int*int correction + .707*32768.0/2 correction
		packssdw	mm0, mm0					// y1 y0		y1 y0 (saturation)
		pshufw		mm0, mm0, 01010000b			// y1 y1		y0 y0
		dec			ecx
		movq		[edi-8], mm0
		jg			loop1

noQuad:
		cmp			eax, 1
		jl			done
		movd		mm0, [esi]					// xx, xx		r0, l0
		pmaddwd		mm0, mm7					// xx, xx		.7r0+.7l0
		psrad		mm0, 16-2					// int*int correction + .707*32768.0/2 correction
		packssdw	mm0, mm0					// y1 y0		y1 y0 (saturation)
		pshufw		mm0, mm0, 01010000b			// xx xx		y0 y0
		movd		[edi], mm0
done:
		emms
		}
	}



// num = short pairs (*4 = bytes)
void PCMWaveOut::AddPCMData(short * leftRight, int num, int time)
	{
	device->SetSPDIFDataOut(false);
	AddDualData(leftRight, NULL, num, time);
	}

//void PCMWaveOut::AddPCMDualData(short * leftRight, short * leftRight1, int num, int time)
//	{
//	device->SetSPDIFDataOut(false);
//	AddDualData(leftRight, leftRight1, num, time);
//	}

void PCMWaveOut::AddPCMDigData(short * leftRightAna, short * leftRightDig, int num, int time)
	{
	device->SetSPDIFDataOut(true);
	AddDualData(leftRightAna, leftRightDig, num, time);
	}

void PCMWaveOut::AddDualData(short * leftRight, short * leftRightDig, int num, int time)
	{
	int max;
	DWORD * dp, * sap, * sdp;
	DWORD * xp;
	short * anaBufBase, *digBufBase=NULL;
	int bufferSize, bufferFilled;
	int lastTime = 0;
	bool ret;

	sap = (DWORD *)leftRight;
	sdp = (DWORD *)leftRightDig;
	while (num)
		{
		ret = false;
		while (!detaching && !terminate && !ret)
			{
			if (leftRightDig)
				ret = device->GetBuffers(2 * num, anaBufBase, digBufBase, bufferSize);
			else
				ret = device->GetBuffer(2 * num, anaBufBase, bufferSize);

			if (!ret)
				event.WaitForever();
			}

		if (terminate || detaching) return;

		bufferSize >>= 2;

		dp = (DWORD *)anaBufBase;
		xp = dp + bufferSize;

		max = xp - dp;
		if (max > num) max = num;

		if (monoOutput)
			{
			MonoMixMoveBuffer((short *)dp, (short *)sap, max);
			}
		else
			{
			memcpy(dp, sap, max * 4);
			}

		if (digBufBase)
			memcpy(digBufBase, sdp, max * 4);
		num -= max;
		bufferFilled = max;
		inputByteCount += 4 * max;
		sap += max;
		sdp += max;

#if AUDIO_DUMP
		if (audioStream && audioStream != INVALID_HANDLE_VALUE)
			{
			DWORD dummy;
			if (!monoOutput)
				::WriteFile(audioStream, dp, 4 * bufferFilled, &dummy, NULL);
			else
				{
				short tmp[8192];
				for(int i=0; i< bufferFilled; i++)
					{
					tmp[i] = *((short *)dp + 2*i);
					}
					::WriteFile(audioStream, tmp, 2 * bufferFilled, &dummy, NULL);
				}
			}
#endif

		device->PostBuffer(4 * bufferFilled, time);

		lastTime = time;
		time += (int)((float)1000.0*bufferFilled/(float)sampleRate);
		}
	}


void PCMWaveOut::CompleteStreaming(void)
	{
	device->DoneStreaming();
	}

void PCMWaveOut::WaitForCompletion(void)
	{
	device->WaitForCompletion();
	}

int PCMWaveOut::GetBufferDelayTime()
	{
	int outputByteCount;

	if (inputByteCount)
		{
		outputByteCount = device->CurrentLocation() * 4;

		if (sampleRate)
			return ScaleDWord(inputByteCount - outputByteCount, sampleRate, 250);
		else
			return 0;
		}
	else
		return 0;
	}

int PCMWaveOut::GetOutputPosition(void)
	{
	int outputByteCount;

	if (inputByteCount)
		{
		outputByteCount = device->CurrentLocation() * 4;

		if (sampleRate)
			return ScaleDWord(outputByteCount, sampleRate, 250);
		else
			return 0;
		}
	else
		return 0;
	}

void PCMWaveOut::FiberRoutine(void)
	{
	int time, position, target, bufData, delta;

	while (threadRunning)
		{
		if (dropping)
			YieldFiber(10);
		else
			YieldFiber(30);

		if (advanceFrame)
			{
			time = timingSlave->CurrentTime() - dataDropStartTime;
			}
		else
			{
			time = GetInternalTime() - dataDropStartTime;
			}

		if (!threadRunning)
			break;

		position = GetOutputPosition() - dataDropStartPosition;
		target = ScaleLong(time, 0x10000, playbackSpeed);
		if (target > position)
			{
			if (dropping)
				{
				bufData = (maxAudioBuffer - device->AvailBufferSpace()) * 4;
				delta = (target - position) * sampleRate / 250;

				// -delta means (target - position) is really big so clamp it
				if (delta < 0 || delta > bufData)
					delta = bufData;

				device->DropData(delta);
				}
			else
				{
				device->StartStreaming();
				fiberEvent.Wait(target - position);
				device->StopStreaming();
				}
			}
		}
	}


#if EXT_NAME_FOR_PCM_AUDIO_DUMP

#ifndef DLLCALL
#define DLLCALL __declspec(dllexport)
#endif

extern "C" {
DLLCALL Error WINAPI DEBUG_SetAC3DebugName(char * name);
			}

DLLCALL Error WINAPI DEBUG_SetAC3DebugName(char * name)
	{
	if (name)
		{
		audioStream = ::CreateFile(name, // D:\ is actually XE:\ //
								  GENERIC_WRITE,
								  FILE_SHARE_WRITE,
								  NULL,
								  CREATE_ALWAYS,
								  FILE_ATTRIBUTE_NORMAL,
								  NULL);

		if(audioStream == INVALID_HANDLE_VALUE)
			{
			int err = ::GetLastError();
			}
		}
	else
		{
		audioStream = INVALID_HANDLE_VALUE;
		}
	return S_OK;
	}

#endif



void PCMWaveOut::BeginStreaming(void)
	{
	int i;

	detaching = FALSE;
	running = FALSE;
	threadRunning = FALSE;
	terminate = FALSE;
	dropping = FALSE;
//	resampling = FALSE;
	advanceFrame = false;

	inputByteCount = 0;
	outputByteCount = 0;

	playbackSpeed = 0x10000;
	SetFiberPriority(2);

	device->BeginStreaming(this);

#if AUDIO_DUMP && !EXT_NAME_FOR_PCM_AUDIO_DUMP
	char	buf[80];
	wsprintf(buf,"D:\\Dump\\Pcm%d.pcm", audioStreamCount++);

	audioStream = ::CreateFile(buf, // D:\ is actually XE:\ //
							  GENERIC_WRITE,
							  FILE_SHARE_WRITE,
							  NULL,
							  CREATE_ALWAYS,
							  FILE_ATTRIBUTE_NORMAL,
							  NULL);

	if(audioStream == INVALID_HANDLE_VALUE)
		{
		int err = ::GetLastError();
		}
#endif

	}

void PCMWaveOut::AdvanceFrame(void)
	{
	if (!advanceFrame)
		{
		StopStreaming();
		advanceFrame = true;

		if (device->EnterDropDataMode())
			{
			dropping = TRUE;
			threadRunning = TRUE;

			device->StartStreaming();

			dataDropStartTime = timingSlave->CurrentTime();
			dataDropStartPosition = GetOutputPosition();

			StartFiber();
			}
		else
			{
			threadRunning = TRUE;
			dataDropStartTime = timingSlave->CurrentTime();
			dataDropStartPosition = GetOutputPosition();

			StartFiber();
			}
		}
	}


void PCMWaveOut::StartStreaming(int playbackSpeed)
	{
	if (advanceFrame)
		{
		advanceFrame = false;
		StopStreaming();
		}

	running = TRUE;
	this->playbackSpeed = playbackSpeed;

	if (playbackSpeed == 0x10000 || device->SetPlaybackRate(playbackSpeed))
		{
		device->StartStreaming();
		}
//	else if (device->EnterResampleMode(playbackSpeed))
//		{
//		resampling = TRUE;
//		device->StartStreaming();
//		}
	else if (device->EnterDropDataMode())
		{
		dropping = TRUE;
		threadRunning = TRUE;

		device->StartStreaming();

		dataDropStartTime = GetInternalTime();
		dataDropStartPosition = GetOutputPosition();

		StartFiber();
		}
	else
		{
		threadRunning = TRUE;
		dataDropStartTime = GetInternalTime();
		dataDropStartPosition = GetOutputPosition();

		StartFiber();
		}
	}

void PCMWaveOut::StopStreaming(void)
	{
	if (dropping)
		{
		threadRunning = FALSE;
		fiberEvent.SetEvent();
		CompleteFiber();

		device->StopStreaming();

		device->LeaveDropDataMode();
		dropping = FALSE;
		}
	else if (threadRunning)
		{
		threadRunning = FALSE;
		fiberEvent.SetEvent();
		CompleteFiber();
		}
//	else if (resampling)
//		{
//		resampling = FALSE;
//		device->StopStreaming();
//		device->LeaveResampleMode();
//		}
	else
		{
		device->SetPlaybackRate(0x10000);
		device->StopStreaming();
		}
	running = FALSE;
	}

void PCMWaveOut::EndStreaming(bool fullReset)
	{
	if (advanceFrame)
		{
		advanceFrame = false;
		StopStreaming();
		}

	terminate = TRUE;
	inputByteCount = 0;
	device->EndStreaming(fullReset);
	WaitForCompletion();
	event.SetEvent();

#if AUDIO_DUMP
	if (audioStream != INVALID_HANDLE_VALUE)
		{
		::CloseHandle(audioStream);
		audioStream = INVALID_HANDLE_VALUE;
		}
#endif
	}

void PCMWaveOut::DetachStreaming(void)
	{
	detaching = TRUE;
	event.SetEvent();
	}

void PCMWaveOut::AttachStreaming(void)
	{
	detaching = FALSE;
	}

void PCMWaveOut::SetSPDIFDataOut(bool enable)
	{
	device->SetSPDIFDataOut(enable);
	}

//void PCMWaveOut::GetSPDIFDataOut(bool &enable)
//	{
//	device->GetSPDIFDataOut(enable);
//	}

void PCMWaveOut::SetAudioOutConfig(AC3SpeakerConfig spkCfg, AC3DualModeConfig dualModeCfg, AC3KaraokeConfig karaokeCfg)
	{
	monoOutput = (spkCfg == AC3SC_10);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\cinemast\XboxProfile.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef XBOXPROFILE_H
#define XBOXPROFILE_H

#include "library\common\profiles.h"
#include "..\AC3Decoder\AC3Decoder.h"
#include "..\Video\XBoxDisplay.h"

#define XBOX_CONFIG														\
	{																	\
	{"$", SET_SECTION, 0},												\
																		\
		{"DRIVE", SET_SECTION, 0},										\
		{"", SET_END, 0},												\
																		\
		{"Display", SET_SECTION, 0},									\
			{"EnforceFlipSync", SET_VALUE, FALSE},						\
			{"MaxPrimaryDecodeWidth", SET_VALUE, 1600},					\
			{"AlwaysNeedsColorkey", SET_VALUE, FALSE},					\
			{"InvertFlipOddEven", SET_VALUE, FALSE},					\
			{"BobWeaveSwitchDelay", SET_VALUE, FALSE},					\
			{"IgnoreDownscalingCaps", SET_VALUE, FALSE},				\
			{"HasDownscalingBob", SET_VALUE, TRUE},						\
			{"FrameFreezeForFieldContent", SET_VALUE, false},			\
			{"SyncWithScreenRefresh", SET_VALUE, false},				\
			{"DisableNoSysLock", SET_VALUE, false},						\
			{"SurfaceFlipMode", SET_VALUE, 0xFFFFFFFF},					\
		{"", SET_END, 0},												\
																		\
		{"VideoDecoder", SET_SECTION, 0},								\
			{"PerformanceClass", SET_VALUE, 0xffffffff},				\
			{"HardwareOptimization", SET_VALUE, 0},						\
			{"BobWeave", SET_VALUE, 4},									\
			{"PullDownReconstruction", SET_VALUE, TRUE},				\
			{"AlwaysHurryUp", SET_VALUE, FALSE},						\
			{"FrameDropIncrement", SET_VALUE, 0},						\
		{"", SET_END, 0},												\
																		\
		{"Scheduler", SET_SECTION, 0},									\
			{"STCDivider", SET_VALUE, 0},								\
			{"MinSleepTime", SET_VALUE, 0},								\
			{"BufferSleepTime", SET_VALUE, 4},							\
			{"MaxSleepSkew", SET_VALUE, 2},								\
			{"DynamicSleepAdjust", SET_VALUE, TRUE},					\
			{"TimeSource", SET_VALUE, FALSE},							\
		{"", SET_END, 0},												\
																		\
		{"AudioDecoder", SET_SECTION, 0},								\
			{"dualModeConfig", SET_VALUE, AC3DMDM_DEFAULT},				\
			{"karaokeConfig", SET_VALUE, AC3KARA_AWARE},				\
			{"UseLFE", SET_VALUE, FALSE},								\
		{"", SET_END, 0},												\
																		\
		{"Regionalization", SET_SECTION, 0},							\
			{"Changes", SET_VALUE, 0},									\
			{"regionMagic", SET_VALUE, RegionCodes[0]},					\
			{"RegionOverride", SET_VALUE, 0},							\
		{"", SET_END, 0},												\
																		\
		{"VIDEODECODER", SET_SECTION, 0},								\
		{"", SET_END, 0},												\
																		\
	{"", SET_END, 0},													\
	}																	\


enum SetupEntryType
	{
	SET_VALUE,
	SET_SECTION,
	SET_END
	};


// One entry of the setup array
struct SetupEntry
	{
	char    * name;
	SetupEntryType type;
	DWORD    value;
	};



SetupEntry config[] = XBOX_CONFIG;



static DWORD CalculateID(BOOL section, KernelString name)
	{
	DWORD temp = 0;

	if (name.Length() > 0)
		{
		for (int i = 0; i < name.Length(); i++)
			{
			temp ^= name[i];
			temp = (temp << 3) | (temp >> 29); // The first 10 characters count
			}

		return (section ? (temp |= 1) : (temp &= ~1));
		}
	else
		return 0;
	}


void ParseSetup(SetupEntry * & sentry, ProfileEntry * pentry, int & num)
	{
	int snum;

	num = 0;
	pentry->id = CalculateID(TRUE, sentry->name);
	num++;
	sentry++;
	while (sentry->type != SET_END)
		{
		if (sentry->type == SET_VALUE)
			{
			pentry[num].id = CalculateID(FALSE, sentry->name);
			pentry[num].value = sentry->value;
			num++;
			sentry++;
			}
		else
			{
			ParseSetup(sentry, pentry + num, snum);
			num += snum;
			}
		}
	pentry->value = num;

	sentry++;
	}


class XboxProfile :public StaticProfile
	{
	private:
		ProfileEntry profileEntry[60];	//currently have 50

	public:
		XboxProfile::XboxProfile() : StaticProfile((const ProfileEntry*)&profileEntry)
			{
			int num = 0;
			SetupEntry * se = config;

			ParseSetup(se, &profileEntry[0], num);
			}

	};





#endif XBOXPROFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\cinemast\Cinmst32.cpp ===
//depot/xbox-aug01-final/private/ui/dvd/driver/softwarecinemaster/cinemast/Cinmst32.cpp#3 - edit change 19203 (text)
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#define VIONA_VERSION			1
#undef ONLY_EXTERNAL_VISIBLE

#include "library\common\prelude.h"
#include "driver\SoftwareCinemaster\Common\Prelude.h"
#include "library\common\gnerrors.h"
#include "library\common\tags.h"
#include "library\common\tagunits.h"
#include "library\common\hooks.h"
#include "library\common\profiles.h"
#include "library\common\vddebug.h"
#include "library\common\winports.h"



#define ONLY_EXTERNAL_VISIBLE	1

#include "library\hardware\videodma\generic\pip.h"
#include "library\hardware\mpeg2dec\generic\mpeg2dec.h"
#include "library\hardware\video\generic\videnc.h"
#include "library\common\virtunit.h"

#include "..\MPEGDecoder\Mp2HuffTables.h"
#include "..\MPEGDecoder\Huffdec.h"
#include "..\MPEGDecoder\SliceParser.h"
#include "..\MPEGDecoder\FastMMXSliceDecoder.h"
#include "..\MPEGDecoder\QFastISSEMotionComp.h"
#include "..\Video\XBoxDisplay.h"
#include "..\DVDStreamDecoder.h"
#include "..\decryptionlib\decryptionlib.h"
#include "..\common\TimedFibers.h"
//#include "..\common\CPUDetection.h"
#include <math.h>
#include <stdio.h>
#include "..\common\PerformanceMonitor.h"
#include "..\Video\MacrovisionEncoder.h"
#include "..\Audio\Ac97PlaybackDevice.h"

#include "..\ClosedCaption\ClosedCaptionDecoder.h"

#include "CinemLib.h"

#if _DEBUG
#include <crtdbg.h>
#endif


//
//  Region Codes
//

static const int RegionCodes[] =
	{
	0x43241234,
	0x24534251,
	0x23423142,
	0x35235353,

	0x43271234,
	0x24574251,
	0x23473142,
	0x35275353
	};


// have include this low to pick up region codes (this forces the code into the .h as well)
#include "XboxProfile.h"



__declspec( dllexport) void * thk_ThunkData32;

#define PCICB_INVERT		(1 << 0)
#define PCICB_AND			(1 << 1)
#define PCICB_OR			(1 << 2)
#define PCICB_ID			(1 << 3)

struct PCICheckBlock
	{
	public:
		DWORD		com;
		WORD		p0, p1, p2, p3;
	};

#define WINDOWS_MAJOR_VERSION ((DWORD)(LOBYTE(LOWORD(::GetVersion()))))

#pragma warning(disable : 4786)
////////////////////////////////////////////////////////////////////
//
//  Unit Set Class
//
////////////////////////////////////////////////////////////////////
typedef class UnitSetClass : public DVDStreamDecoder, public ASyncErrorMessenger
	{
	public:
      GenericDirectXDisplay *			directXDisplay;
		GenericPictureDisplay *			display;
		SPUDisplay						spuDisplay;
		GenericProfile *				profile, * globalProfile;

		GenericSliceParser *			highQualitySliceDecoder;
		GenericSliceParser *			lowQualitySliceDecoder;
		GenericAudioPlaybackDevice *	audioPlaybackDevice;
		AuthenticatingDecryptor	*		decryptor;
		MacrovisionEncoder *			macrocoder;
		ClosedCaptionDecoder *			ccDecoder;
		StreamFlipCopy *				streamFlipCopy;

		int								referenceCount;
		DWORD							colorControl;

		WORD							buttonLeft, buttonTop, buttonWidth, buttonHeight;
		DWORD							buttonSelect, buttonActive;
		SPUButtonState					buttonState;

		GenericMsgPort *				msgPort;
		HWND							msgWindow;
		WORD							refillMsg, signalMsg, doneMsg, errorMsg;

		WORD							timeoutMsg;

		HWND							hwnd;
		DWORD							positionScale;
		DWORD							signalPosition;

		BOOL							refillMsgPending;
		BOOL							mpeg2, stillFrameSequence;

		BOOL							active, seeking, paused, stopped, scanning, trickplay;
		BOOL							pipEnabled;
		BOOL							spuEnabled;
		BOOL							dvdDemux;
		BOOL							ccEnabled;

		BYTE							videoStreamID, dtsStreamID, ac3StreamID, audioStreamID, lpcmStreamID, spuStreamID;
		MPEG2AudioType					audioType;
		BOOL							audioAC3, audioLPCM;
		MPEGStreamType					streamType;
		MPEG2SplitStreamType			splitStreamType[4];
		MPEG2PresentationMode			presentationMode;

		AC3OperationalMode				ac3OperationalMode;
		WORD							ac3HighScaleFactor;
		WORD							ac3LowScaleFactor;
		AC3DynamicRange					ac3DynamicRange;
		AC3DialogNorm					ac3DialogNorm;
		BOOL							enableLFE;

		AC3KaraokeConfig				karaokeCfg;
		AC3DualModeConfig				dualModeCfg;
		AC3SpeakerConfig				spkCfg;

		WORD							bitsPerSample;
		WORD							channels;
		WORD							samplesPerSecond;

		WORD							brightness;
		WORD							redBrightness, greenBrightness, blueBrightness;
		WORD							contrast, saturation;
		BOOL							colorEnable;
		DWORD							colorKeyColor;

		WORD							cropLeft, cropTop, cropRight, cropBottom;

		DWORD							firstStreamSegment;
		DWORD							lastStreamSegment;

		int								copyProtectionLevel;
		VideoCopyMode                   eCGMSMode;
		    
		SPDIFCopyMode					spdifCopyMode;
		bool							timedFibersNormalSpeedPriority;

		int								d3AudioEnabled;		// C++ is not three dimensional


		UnitSetClass(GenericSliceParser * highQualitySliceDecoder,
						 GenericSliceParser * lowQualitySliceDecoder,
						 GenericAudioPlaybackDevice * audioPlaybackDevice,
						 GenericDirectXDisplay	*	display,
				 		 MacrovisionEncoder	*	macrocoder,
						 GenericProfile * profile,
						 GenericProfile * globalProfile,
						 ClosedCaptionDecoder * ccDecoder,
						 HINSTANCE hinst,
						 StreamFlipCopy * streamFlipCopy);


		~UnitSetClass();

		Error Initialize(void);

		Error ActivateUnits();
		Error PassivateUnits();
		Error ConfigureUnits(TAG __far * tags);

		void PostErrorMessage(Error err);
		void RefillRequest(void);
		void SignalReached(__int64 signalPos);
		void StreamCompleted(DVDElementaryStreamType type);

		void UpdateBrightness(void);
		void UpdateContrast(void);
		void UpdateSaturation(void);

		Error CheckHardwareResources(void)
			{
			GNREASSERT(audioPlaybackDevice->CheckHardwareResources());
			GNREASSERT(display->CheckHardwareResources());
			GNRAISE_OK;
			}

		Error DoMPEGCommand(MPEGCommand com, long param);

	} * UnitSet;
#pragma warning(default : 4786)

#pragma data_seg(".sdata")
int globalOpenCount = 0;
#pragma data_seg()

static BOOL allowCSS	= TRUE;
static BOOL allowCSSMsg = FALSE;
static BoardVersionInfo		boardVersionInfo;
#define allowMultiInstance 0

static bool primaryUnit = TRUE;

////////////////////////////////////////////////////////////////////
//
//   Board Class
//
////////////////////////////////////////////////////////////////////

class Board
	{
	public:
		HINSTANCE						hinst;
		GenericProfile				*	profile, * globalProfile;
		HANDLE							cinemSupDriver;
		int								regionCount;
		BYTE								regionCode;

	   Board(HINSTANCE hinst);
	   ~Board(void);

		Error BeginInitialize(void);
		Error CompleteInitialize(void);
		Error Initialize(void);
		Error Reconfigure(void);
		Error Destroy(void);
		BOOL CheckRegionCodeValid(BYTE regionSet);
		UnitSet CreateUnitSet(void);
		};

//
//  Create Board
//

Board * CreateBoard(HINSTANCE hinst)
	{
	return new Board(hinst);
	}

//
//  VDR Interface Declaration
//

typedef class __far VDRHandleStruct {} * VDRHandle;

#ifndef DLLCALL
#define DLLCALL __declspec(dllexport)
#endif

extern "C" {

DLLCALL Error WINAPI VDR_OpenDriver(TCHAR __far * name, DWORD boardID, VDRHandle __far & handle);

DLLCALL Error WINAPI VDR_CloseDriver(VDRHandle handle);

DLLCALL DWORD WINAPI VDR_AvailUnits(VDRHandle handle);

DLLCALL Error WINAPI VDR_OpenUnits(VDRHandle handle, DWORD requnits, UnitSet __far & units);

DLLCALL Error WINAPI VDR_OpenSubUnits(UnitSet parent, DWORD requnits, UnitSet __far &units);

DLLCALL Error WINAPI VDR_CloseUnits(UnitSet units);

DLLCALL Error WINAPI VDR_ReconfigureDriver(VDRHandle handle);


DLLCALL Error WINAPI VDR_ConfigureUnits(UnitSet units, TAG __far * tags);

inline Error __cdecl VDR_ConfigureUnitsTags(UnitSet units, TAG tags, ...) {return VDR_ConfigureUnits(units, &tags);}

DLLCALL Error WINAPI VDR_T_ConfigureUnitsSet(UnitSet units, TAG __far * tags);

DLLCALL Error WINAPI VDR_T_ConfigureUnitsGet(UnitSet units, DWORD id, void * ref);

DLLCALL Error WINAPI VDR_LockUnits(UnitSet units);

DLLCALL Error WINAPI VDR_UnlockUnits(UnitSet units);


DLLCALL Error WINAPI VDR_ActivateUnits(UnitSet units);

DLLCALL Error WINAPI VDR_PassivateUnits(UnitSet units);

DLLCALL Error WINAPI VDR_EnablePIP(UnitSet units, BOOL enable);

DLLCALL Error WINAPI VDR_UpdatePIP(UnitSet units);

DLLCALL Error WINAPI VDR_GrabFrame(UnitSet units, FPTR base,
                            WORD width, WORD height,
                            WORD stride,
                            GrabFormat fmt);

DLLCALL DWORD WINAPI VDR_SendMPEGData(UnitSet units, HPTR data, DWORD size);

DLLCALL DWORD WINAPI VDR_SendMPEGDataMultiple(UnitSet units, MPEGDataSizePair * data, DWORD size);

DLLCALL DWORD WINAPI VDR_SendMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType, HPTR data, DWORD size, int timeStamp);

DLLCALL DWORD WINAPI VDR_SendMPEGDataSplitMultiple(UnitSet units, MPEGElementaryStreamType streamType, MPEGDataSizePair * data, DWORD size, int timeStamp);

DLLCALL void WINAPI VDR_CompleteMPEGData(UnitSet units);

DLLCALL void WINAPI VDR_CompleteMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType);

DLLCALL void WINAPI VDR_RestartMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType);

DLLCALL Error WINAPI VDR_SendMPEGCommand(UnitSet units, MPEGCommand com, long param, DWORD __far &tag);

DLLCALL Error WINAPI VDR_DoMPEGCommand(UnitSet units, MPEGCommand com, long param);

DLLCALL Error WINAPI VDR_CompleteMPEGCommand(UnitSet units, DWORD tag);

DLLCALL BOOL WINAPI VDR_MPEGCommandPending(UnitSet units, DWORD tag);

DLLCALL DWORD WINAPI VDR_CurrentMPEGLocation(UnitSet units);

DLLCALL DWORD WINAPI VDR_CurrentMPEGTransferLocation(UnitSet units);

DLLCALL MPEGState WINAPI VDR_CurrentMPEGState(UnitSet units);

DLLCALL Error WINAPI VDR_InstallMPEGWinHooks(UnitSet units, HWND hwnd, WORD refillMsg, WORD signalMsg, WORD doneMsg);

DLLCALL Error WINAPI VDR_RemoveMPEGWinHooks(UnitSet units);

DLLCALL Error WINAPI VDR_InstallMessagePort(UnitSet units, GenericMsgPort * port);

DLLCALL Error WINAPI VDR_RemoveMessagePort(UnitSet units);

DLLCALL Error WINAPI VDR_CompleteMPEGRefillMessage(UnitSet units);

DLLCALL Error WINAPI VDR_DoAuthenticationCommand(UnitSet units, MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key);

DLLCALL BOOL WINAPI VDR_CheckRegionCodeValid(UnitSet units, BYTE regionSet);

DLLCALL void WINAPI VDR_ReadPerformanceMonitor(PerformanceMonitor & pmon);

	}


Board 		*	board;
HINSTANCE		DriverInstance;
int				OpenCount;

//
//  Board Class
//

Board::Board(HINSTANCE hinst)
	{
	this->hinst = hinst;

	regionCode = 0;
	}

Board::~Board(void)
	{
	}

Error Board::Destroy(void)
	{
	FinishTimedFiberScheduler();

	if (globalProfile != profile) delete globalProfile;
	delete profile;

	GNRAISE_OK;
	}

Error Board::Reconfigure(void)
	{
	GNRAISE_OK;
	}


#define PROFILENAME	"Software CineMaster"

Error Board::BeginInitialize(void)
	{
	PMMSG("BeginInitialize+\n");



//		profile = new NullProfile();
		profile = new XboxProfile();

		globalProfile = profile;


	PMMSG("BI3\n");

	InitializeTimedFiberScheduler(globalProfile, profile);

	PMMSG("BeginInitialize-\n");

	GNRAISE_OK;
	}

Error Board::CompleteInitialize(void)
	{
	GNRAISE_OK;
	}

Error Board::Initialize(void)
	{
	GNRAISE_OK;
	}

////////////////////////////////////////////////////////////////////
//
//  Unit Set Class
//
////////////////////////////////////////////////////////////////////

//#define NUM_PCM_BUFFERS		4
#define NUM_PCM_BUFFERS		24




//
//  Create Unit Set (Direct X)
//

UnitSet Board::CreateUnitSet(void)
	{
	int videoDecoderPerformanceClass;
	BOOL hardwareOptimization;
//	GenericDirectXDisplay	*	display;
	XBoxDisplay	*	display;
	UnitSet							units;
	int								pcmBufferSize, numPCMBuffers;

	GenericAudioPlaybackDevice * audioPlaybackDevice;
	MacrovisionEncoder	*	macrocoder;
	ClosedCaptionDecoder	*	ccDecoder;
	StreamFlipCopy * streamFlipCopy;

	PMMSG("CreateUnitSet+\n");

//	CPUInformation	cpuInfo;
//	cpuInfo.ProfileCPU();
//	cpuInfo.PerformanceLevel();

//	bool spdifDataEnabled;
//	CPUType cpuType = DetectCPU();

	//PMMSGX("Detected %s\n", CPUName[cpuType]);

	profile->Read("VideoDecoder", "PerformanceClass", videoDecoderPerformanceClass, 0xffffffff);
	profile->Read("VideoDecoder", "HardwareOptimization", hardwareOptimization, 0);


	macrocoder = new WindowsMacrovisionEncoder();

	if (!macrocoder->Initialize())
		{
		delete macrocoder;
		macrocoder = NULL;
		}


	//
	//  Set up audio decoder
	//

	globalProfile->Read("AudioDecoder", "AudioPCMBufferSize", pcmBufferSize, 4096);
	globalProfile->Write("AudioDecoder", "AudioPCMBufferSize", pcmBufferSize);
	numPCMBuffers = pcmBufferSize * 48 / 8192;
	if (numPCMBuffers < 4) numPCMBuffers = 4;

	audioPlaybackDevice = new Ac97PlaybackDevice(globalProfile, profile, numPCMBuffers, 8192);

	if (!primaryUnit && videoDecoderPerformanceClass > 2) videoDecoderPerformanceClass = 2;

	videoDecoderPerformanceClass = 2;

	streamFlipCopy = new XMMXStreamFlipCopy();

	switch (videoDecoderPerformanceClass)
		{

		default:
		case 2: // Eight Bits
			{
			GenericSliceParser * dec = NULL;

			display = new XBoxDisplay(hinst, profile, globalProfile);

			PMMSG("Using ISSE optimized MotionComp version\n");
			PMMSG("Using XMMX optimized IDCT version\n");
			PMMSG("Using XMMX optimized YUV-Converter\n");
			dec = new QFastMMXSliceDecoder(NULL, new FastISSEMotionComp, new GenericXMMXMacroBlockIDCTDecoder, new XMMXYUVVideoConverter);

			ccDecoder = new ClosedCaptionDecoder((GenericDirectXDisplay *)display);

			units = new UnitSetClass(dec, dec,
											audioPlaybackDevice,
											(GenericDirectXDisplay *)display,
											macrocoder,
											profile, globalProfile,
											ccDecoder,
											hinst, streamFlipCopy);
			}
			break;

		}

	units->timedFibersNormalSpeedPriority = TRUE;
	units->SetLine21Decoder(ccDecoder);

	if (units) units->SetErrorMessenger(units);

	PMMSG("CreateUnitSet-\n");

	return units;
	}

////////////////////////////////////////////////////////////////////
//
//  Unit Set Class
//
////////////////////////////////////////////////////////////////////

//
//  Initialize
//

Error UnitSetClass::Initialize(void)
	{
	referenceCount = 1;

	active = FALSE;
	msgWindow = NULL;
	msgPort = NULL;
	hwnd = NULL;
	positionScale = MP2SR_SCALE_BYTES;
	refillMsgPending = FALSE;

#if AC3DISABLED
	audioAC3  = FALSE;
	audioType = MP2AUDTYP_MPEG;
#else
	audioAC3  = TRUE;
	audioType = MP2AUDTYP_AC3;
#endif

	timeoutMsg = 0xffff;

	audioLPCM = FALSE;
	videoStreamID = 0xe0;
	audioStreamID = 0xc0;
	ac3StreamID = 0x80;
	dtsStreamID = 0x88;
	lpcmStreamID = 0xa0;
	spuStreamID = 0x20;
	samplesPerSecond = 48000;
	bitsPerSample = 16;
	channels = 2;
	dualModeCfg = AC3DMDM_DEFAULT;
	karaokeCfg = AC3KARA_AWARE;
	spkCfg = AC3SC_20_SURROUND_COMPATIBLE;

	ac3Decoder.GetDolbyTestMode(ac3OperationalMode, ac3HighScaleFactor, ac3LowScaleFactor, ac3DialogNorm);
	ac3Decoder.GetAC3Config(ac3DynamicRange, enableLFE);

	mpeg2 = FALSE;
	stillFrameSequence = FALSE;
	pipEnabled = FALSE;
	ccEnabled = FALSE;

	streamType = multiplexed;
	splitStreamType[0] = MP2SST_PROGRAM;
	splitStreamType[1] = MP2SST_PROGRAM;
	splitStreamType[2] = MP2SST_PROGRAM;
	splitStreamType[3] = MP2SST_PROGRAM;

	brightness = 5000;
	redBrightness = 5000;
	greenBrightness = 5000;
	blueBrightness = 5000;
	contrast = 5000;
	saturation = 5000;
	colorEnable = TRUE;
	colorKeyColor = 0x0c000c;
	colorControl = highQualitySliceDecoder->QueryColorControl() &
						lowQualitySliceDecoder->QueryColorControl();

	UpdateBrightness();
	UpdateContrast();
	UpdateSaturation();

	spuEnabled = TRUE;

	cropLeft = cropTop = cropRight = cropBottom = 0;

	//
	// Setup Karaoke/Dual mode
	//
	int i;
	globalProfile->Read("AudioDecoder", "dualModeConfig", i, dualModeCfg);
	dualModeCfg = (AC3DualModeConfig) i;
	globalProfile->Read("AudioDecoder", "karaokeConfig", i, karaokeCfg);
	karaokeCfg = (AC3KaraokeConfig) i;
	SetAudioOutConfig(spkCfg, dualModeCfg, karaokeCfg);

	spdifCopyMode = SPDIFCM_NO_COPIES;


	if (allowMultiInstance && !primaryUnit)
		GNRAISE_OK;
	else
		return CheckHardwareResources();
	}

#pragma warning(disable : 4786)

//
//  Constructor
//

UnitSetClass::UnitSetClass(GenericSliceParser * highQualitySliceDecoder,
									GenericSliceParser * lowQualitySliceDecoder,
						 GenericAudioPlaybackDevice * audioPlaybackDevice,
						 GenericDirectXDisplay * display,
				 		 MacrovisionEncoder	*	macrocoder,
						 GenericProfile * profile,
						 GenericProfile * globalProfile,
						 ClosedCaptionDecoder * ccDecoder,
						 HINSTANCE hinst, StreamFlipCopy * streamFlipCopy)
						 : spuDisplay(display, highQualitySliceDecoder, lowQualitySliceDecoder),
						 DVDStreamDecoder(display, highQualitySliceDecoder,lowQualitySliceDecoder, audioPlaybackDevice, &spuDisplay, globalProfile, profile, ccDecoder, streamFlipCopy, decryptor = (allowCSS ? CreateDecryptor() : NULL))
	{
	this->highQualitySliceDecoder = highQualitySliceDecoder;
	this->lowQualitySliceDecoder = lowQualitySliceDecoder;
	this->audioPlaybackDevice = audioPlaybackDevice;
	this->display = display;
	this->directXDisplay = display;
	this->profile = profile;
	this->globalProfile = globalProfile;
	this->macrocoder = macrocoder;
	this->ccDecoder = ccDecoder;
	this->streamFlipCopy = streamFlipCopy;

	if (macrocoder) display->SetMacrovisionEncoder(macrocoder);

	dvdDemux = false;

	}

#pragma warning(default : 4786)

//
//  Destructor
//

UnitSetClass::~UnitSetClass()
	{
	ShutDownSupervisor();

	if (display && !(display->IsDecoder()))
		{
		if (highQualitySliceDecoder && highQualitySliceDecoder != lowQualitySliceDecoder)
			delete highQualitySliceDecoder;
		if (lowQualitySliceDecoder)
			delete lowQualitySliceDecoder;
		}
	if (streamFlipCopy) delete streamFlipCopy;
	if (audioPlaybackDevice) delete audioPlaybackDevice;
	if (display) delete display;
	if (macrocoder) delete macrocoder;
	if (decryptor) delete decryptor;
	if (ccDecoder) delete ccDecoder;
	}

//
//  Refill Request
//

void UnitSetClass::PostErrorMessage(Error err)
	{
	}

//
//  Refill Request
//

void UnitSetClass::RefillRequest(void)
	{
	if (!refillMsgPending)
		{
		refillMsgPending = TRUE;
		if (msgPort)
			msgPort->SendMessage(refillMsg, 0);
		}
	}

//
//  Signal Reached
//

void UnitSetClass::SignalReached(__int64 signalPos)
	{
	if (msgPort)
		msgPort->SendMessage(signalMsg, (int)(signalPos  * positionScale / MP2SR_SCALE_BYTES));
	}

//
//  Stream Completed
//

void UnitSetClass::StreamCompleted(DVDElementaryStreamType type)
	{
	if (active && !seeking && /*!paused &&*/ !stopped)
		{
		if (msgPort)
			msgPort->SendMessage(doneMsg, type);

		}
	}

//
//  Avtivate Units
//

UnitSetClass * cus;

Error UnitSetClass::ActivateUnits()
	{
	cus = this;

	if (!active)
		{
		SetStreamID(videoStreamID, ac3StreamID, audioStreamID, lpcmStreamID, spuStreamID, dtsStreamID);
		SetAudioCodingMode(audioType,
								 samplesPerSecond == 30464 ? 96000 : samplesPerSecond,
								 bitsPerSample,
								 channels);

		active = TRUE;
		seeking = FALSE;
		paused = FALSE;
		stopped = TRUE;
		scanning = FALSE;
		trickplay = FALSE;
		refillMsgPending = FALSE;

		if (directXDisplay) directXDisplay->EnableDisplay(pipEnabled != 0);

		BeginStreaming(VDPM_PLAY_FORWARD, !mpeg2 || stillFrameSequence, 0);
		}

	GNRAISE_OK;
	}

//
//  Passivate Units
//

Error UnitSetClass::PassivateUnits()
	{
	cus = NULL;

	if (active)
		{
		if (!seeking)
			{
			if (!paused && !stopped)
				{
				StopStreaming();
				}
			EndStreaming(TRUE);
			}

		if (directXDisplay) directXDisplay->EnableDisplay(FALSE);
		if (display) display->HideDisplay();
		active = FALSE;
		}

	GNRAISE_OK;
	}

//
//  Process MPEG command
//

Error UnitSetClass::DoMPEGCommand(MPEGCommand com, long param)
	{
	switch (com)
		{
		case mpc_play:
			if (!seeking)
				{
				if (stopped)
					Sleep(100);
				else if (paused)
					Sleep(50);
				else
					StopStreaming();

//				param = 100;
				//				if (param != 1000) param = 1500;

//chzhack tmp fix for playback speeds 1.0 - 2.0
				if (param > 1000)
					SetTimedFiberPriorities(FALSE);
				else
					SetTimedFiberPriorities(timedFibersNormalSpeedPriority);

				paused = FALSE;
				stopped = FALSE;

				StartStreaming(ScaleLong(param, 1000, 0x10000));
				}
			break;
		case mpc_cue:
		case mpc_seek:
			if (!seeking)
				{
				seeking = TRUE;
				scanning = FALSE;
				trickplay = FALSE;
				if (!paused && !stopped)
					{
					StopStreaming();
					}
				EndStreaming(FALSE);
				}
			break;
		case mpc_stepkey:
		case mpc_step:
			if (trickplay)
				AdvanceTrickFrame(param);
			else if (paused && !seeking)
				AdvanceFrame();
			break;
		case mpc_stop:
			if (!paused && !stopped)
				StopStreaming();

			paused = FALSE;
			stopped = TRUE;
			break;
		case mpc_freeze:
			if (!paused && !stopped)
				StopStreaming();

			paused = TRUE;
			stopped = FALSE;
			break;
		case mpc_resync:
		case mpc_resyncue:
			if (seeking)
				{
				SetStreamID(videoStreamID, ac3StreamID, audioStreamID, lpcmStreamID, spuStreamID, dtsStreamID);
				BeginStreaming(VDPM_PLAY_FORWARD, !mpeg2 || stillFrameSequence, (__int64)param * MP2SR_SCALE_BYTES / positionScale);
				seeking = FALSE;
				paused = TRUE;
				stopped = FALSE;
				}
			break;
		case mpc_reverse:
			if (seeking)
				{
				SetStreamID(videoStreamID, ac3StreamID, audioStreamID, lpcmStreamID, spuStreamID, dtsStreamID);
				BeginStreaming(VDPM_PLAY_BACKWARD, !mpeg2 || stillFrameSequence, (__int64)param * MP2SR_SCALE_BYTES / positionScale);
				seeking = FALSE;
				paused = TRUE;
				stopped = FALSE;
				}
			break;
		case mpc_scan:
			if (seeking)
				{
				SetStreamID(videoStreamID, ac3StreamID, audioStreamID, lpcmStreamID, spuStreamID, dtsStreamID);
				BeginStreaming(VDPM_SCANNING, !mpeg2, param);
				StartStreaming(0x10000);
				trickplay = FALSE;
				seeking = FALSE;
				paused = FALSE;
				stopped = FALSE;
				scanning = TRUE;
				}
			break;
		case mpc_trickplay:
			if (seeking)
				{
				SetStreamID(videoStreamID, ac3StreamID, audioStreamID, lpcmStreamID, spuStreamID, dtsStreamID);
				BeginStreaming(VDPM_TRICKPLAY, !mpeg2, param);
				StartStreaming(0x10000);
				trickplay = TRUE;
				seeking = FALSE;
				paused = FALSE;
				stopped = FALSE;
				scanning = FALSE;
				}
			break;
		case mpc_seekaudio:
			break;
		case mpc_resyncaudio:
			break;
		}

	GNRAISE_OK;
	}


//
//  Configure Units
//

Error UnitSetClass::ConfigureUnits(TAG __far * tags)
	{
	TAG	__far	*	tp;
	DWORD				temp;
	BOOL				audioCodingModeChanged, audioOutConfigChanged, ac3ConfigChanged;
	BOOL				ac3TestModeChanged;
	BOOL				croppingRectChanged, buttonRectChanged;
	BOOL				regionChanged;
//	BYTE				regionCode;
	int				regionCount;

	short destLeft, destTop, destWidth, destHeight;

	display->GetDisplayLeft(destLeft);
	display->GetDisplayTop(destTop);
	display->GetDisplayWidth(destWidth);
	display->GetDisplayHeight(destHeight);

	tp = tags;

	while (tp->id)
		{
		if (TAG_TYPE(tp->id) == TAG_QRY) QRY_TAG(tp) = FALSE;
		tp++;
		}

	audioOutConfigChanged		= FALSE;
	audioCodingModeChanged		= FALSE;
	croppingRectChanged			= FALSE;
	regionChanged				= FALSE;
	buttonRectChanged			= FALSE;
	ac3TestModeChanged			= FALSE;
	ac3ConfigChanged			= FALSE;

		{
		PARSE_TAGS_START(tags)
			GETSET(MPEG2_POSITION_SCALE, positionScale);
			GETSETDV(MPEG_SIGNAL_POSITION, signalPosition, SetSignalPosition((__int64)signalPosition * MP2SR_SCALE_BYTES / positionScale));
			GETSETDV(MPEG_VIDEO_STREAMID, videoStreamID, SetStreamID(videoStreamID, ac3StreamID, audioStreamID, lpcmStreamID, spuStreamID, dtsStreamID));
			GETSETDV(MPEG_AUDIO_STREAMID, audioStreamID, SetStreamID(videoStreamID, ac3StreamID, audioStreamID, lpcmStreamID, spuStreamID, dtsStreamID));
			GETSETDV(MPEG2_AUDIO_AC3_STREAMID, ac3StreamID, SetStreamID(videoStreamID, ac3StreamID, audioStreamID, lpcmStreamID, spuStreamID, dtsStreamID));
			GETSETDV(MPEG2_AUDIO_LPCM_STREAMID, lpcmStreamID, SetStreamID(videoStreamID, ac3StreamID, audioStreamID, lpcmStreamID, spuStreamID, dtsStreamID));
			GETSETDV(MPEG2_AUDIO_DTS_STREAMID, dtsStreamID, SetStreamID(videoStreamID, ac3StreamID, audioStreamID, lpcmStreamID, spuStreamID, dtsStreamID));
			GETSETDV(MPEG2_SPU_STREAMID, spuStreamID, SetStreamID(videoStreamID, ac3StreamID, audioStreamID, lpcmStreamID, spuStreamID, dtsStreamID));
			GETSETDV(MPEG2_SPU_PALETTE_ENTRY, temp, spuDisplay.SetPalette((int)XTBF(0, 8, temp), (int)XTBF(24, 8, temp), (int)XTBF(16, 8, temp), (int)XTBF(8, 8, temp)));

 			GETSETDV(MPEG2_AUDIO_TYPE, audioType, audioCodingModeChanged = TRUE);

			GETSETDV(MPEG2_AC3_DUAL_MODE_CONFIG, dualModeCfg, audioOutConfigChanged = TRUE);
			GETSETDV(MPEG2_AC3_KARAOKE_CONFIG, karaokeCfg, audioOutConfigChanged = TRUE);
			GETSETDV(MPEG2_AC3_SPEAKER_CONFIG, spkCfg, audioOutConfigChanged = TRUE);

			GETSETDV(MPEG2_AC3_DYNAMIC_RANGE, ac3DynamicRange, ac3ConfigChanged = TRUE);
			GETSETDV(MPEG2_DECODE_LFE, enableLFE, ac3ConfigChanged = TRUE);
			GETSETDV(MPEG2_AC3_DIALOG_NORM, ac3DialogNorm, ac3TestModeChanged = TRUE);
			GETSETDV(MPEG2_AC3_OPERATIONAL_MODE, ac3OperationalMode, ac3TestModeChanged = TRUE);
			GETSETDV(MPEG2_AC3_HIGH_DYNAMIC_RANGE, ac3HighScaleFactor, ac3TestModeChanged = TRUE);
			GETSETDV(MPEG2_AC3_LOW_DYNAMIC_RANGE, ac3LowScaleFactor, ac3TestModeChanged = TRUE);
			GETDSETD(MPEG2_AC3_AUDIO_TYPE_CONFIG, ac3Decoder.GetDigitalOut, ac3Decoder.SetDigitalOut);
			GETDSETD(MPEG2_DTS_AUDIO_TYPE_CONFIG, dtsDecoder.GetDigitalOut, dtsDecoder.SetDigitalOut);

			GETSETDV(MPEG2_LPCM_BITSPERSAMPLE, bitsPerSample, audioCodingModeChanged = TRUE);
			GETSETDV(MPEG2_LPCM_CHANNELS, channels, audioCodingModeChanged = TRUE);
			GETSETDV(MPEG_AUDIO_SAMPLERATE, samplesPerSecond, audioCodingModeChanged = TRUE);

			GETSET(MPEG2_CODING_STANDARD, mpeg2);
			GETSET(MPEG2_STILL_FRAME_SEQUENCE, stillFrameSequence);
			GETSETDV(MPEG2_DVD_STREAM_DEMUX, dvdDemux, SetDVDDemux(dvdDemux != 0));
			GETSETDV(MPEG_STREAM_TYPE, streamType, SetStreamType((DVDStreamType)streamType));
			GETONLY(MPEG_CURRENT_STREAM_SEGMENT, VideoSegmentRequested());
			GETSETDV(MPEG_FIRST_STREAM_SEGMENT, firstStreamSegment, SetFirstVideoSegment(firstStreamSegment));
			GETSETDV(MPEG_LAST_STREAM_SEGMENT, lastStreamSegment, SetLastVideoSegment(lastStreamSegment));

			GETSETDV(MPEG2_SPU_BUTTON_STATE, buttonState, spuDisplay.SetButtonState((XSPUButtonState)buttonState));
			GETSETDV(MPEG2_SPU_BUTTON_LEFT, buttonLeft, buttonRectChanged = TRUE);
			GETSETDV(MPEG2_SPU_BUTTON_TOP, buttonTop, buttonRectChanged = TRUE);
			GETSETDV(MPEG2_SPU_BUTTON_WIDTH, buttonWidth, buttonRectChanged = TRUE);
			GETSETDV(MPEG2_SPU_BUTTON_HEIGHT, buttonHeight, buttonRectChanged = TRUE);

			GETSETDV(MPEG2_SPU_BUTTON_SELECT_COLOR, buttonSelect, spuDisplay.SetButtonColors(buttonSelect, buttonActive));
			GETSETDV(MPEG2_SPU_BUTTON_ACTIVE_COLOR, buttonActive, spuDisplay.SetButtonColors(buttonSelect, buttonActive));
			GETSETDV(MPEG2_SPU_ENABLE, spuEnabled, EnableSPU(spuEnabled != 0));

			GETSETDV(MPEG2_PRESENTATION_MODE, presentationMode, display->SetDisplayPresentationMode((PictureDisplayPresentationMode)presentationMode));

//			GETINQUIRE(PIP_DISPLAY_LEFT,   display->GetDisplayLeft(data););
//			GETINQUIRE(PIP_DISPLAY_TOP,    display->GetDisplayTop(data););
//			GETINQUIRE(PIP_DISPLAY_WIDTH,  display->GetDisplayWidth(data););
//			GETINQUIRE(PIP_DISPLAY_HEIGHT, display->GetDisplayHeight(data););

			GETINQUIRE(MPEG_DISPLAY_WIDTH, data = (TTYPE_MPEG_DISPLAY_WIDTH)videoDecoder.DecodeWidth(););
			GETINQUIRE(MPEG_DISPLAY_HEIGHT, data = (TTYPE_MPEG_DISPLAY_HEIGHT)videoDecoder.DecodeHeight(););
			GETONLY(MPEG_SUPPORTS_HIRES_STILL, TRUE);

//			GETONLY(PIP_DEST_LEFT,   destLeft);
//			GETONLY(PIP_DEST_TOP,    destTop);
//			GETONLY(PIP_DEST_WIDTH,  destWidth);
//			GETONLY(PIP_DEST_HEIGHT, destHeight);
//			GETSETDV(PIP_SOURCE_CROP_LEFT, cropLeft, croppingRectChanged = TRUE);
//			GETSETDV(PIP_SOURCE_CROP_TOP, cropTop, croppingRectChanged = TRUE);
//			GETSETDV(PIP_SOURCE_CROP_RIGHT, cropRight, croppingRectChanged = TRUE);
//			GETSETDV(PIP_SOURCE_CROP_BOTTOM, cropBottom, croppingRectChanged = TRUE);


			GETSETDV(ENC_COPY_PROTECTION, copyProtectionLevel, (display->SetMacrovisionLevel(copyProtectionLevel), ccDecoder->SetMacrovisionLevel(copyProtectionLevel)));
			GETSETDV(MPEG2_SPDIF_COPY_MODE, spdifCopyMode, audioPlaybackDevice->SetCopyProtectionLevel(spdifCopyMode));
            GETSETDV(ENC_COPY_MODE, eCGMSMode, (display->SetCGMSMode(eCGMSMode), ccDecoder->SetCGMSMode(eCGMSMode)));

			GETINQUIRE(PIP_COLORCONTROL, data = (WORD)colorControl;);

			GETINQUIRE(MPEG2_CURRENT_PLAYBACK_TIME, data = CurrentPlaybackTime(););

			GETSETDV(PIP_BRIGHTNESS, brightness, UpdateBrightness());
			GETSETDV(PIP_RED_BRIGHTNESS, redBrightness, UpdateBrightness());
			GETSETDV(PIP_GREEN_BRIGHTNESS, greenBrightness, UpdateBrightness());
			GETSETDV(PIP_BLUE_BRIGHTNESS, blueBrightness, UpdateBrightness());

			GETSETDV(PIP_CONTRAST, contrast, UpdateContrast());
			GETSETDV(PIP_SATURATION, saturation, UpdateSaturation());

			GETSET(PIP_COLORENABLE, colorEnable);
//			GETONLY(PIP_COLORKEYED, TRUE);
			GETONLY(PIP_COLORKEYED, directXDisplay->overlayAvailable);

			GETSETDV(MPEG2_VIDEO_SPLIT_STREAM_TYPE,	 splitStreamType[DVEST_VIDEO],		SetSplitStreamType(DVEST_VIDEO,      (DVDSplitStreamType)splitStreamType[DVEST_VIDEO]));
			GETSETDV(MPEG2_AUDIO_SPLIT_STREAM_TYPE,	 splitStreamType[DVEST_AUDIO],		SetSplitStreamType(DVEST_AUDIO,		 (DVDSplitStreamType)splitStreamType[DVEST_AUDIO]));
			GETSETDV(MPEG2_SPU_SPLIT_STREAM_TYPE,		 splitStreamType[DVEST_SUBPICTURE], SetSplitStreamType(DVEST_SUBPICTURE, (DVDSplitStreamType)splitStreamType[DVEST_SUBPICTURE]));

			GETONLY(BOARD_VERSION, boardVersionInfo);
			GETINQUIRE(BOARD_REGION_COUNT, 10;);
			GETSETDV(BOARD_REGION_CODE, board->regionCode, regionChanged = TRUE);

//	GETSETDV(MPEG2_CC_ENABLE, ccEnabled, ccDisplay->EnableDisplay(ccEnabled != 0));

			GETSET(MPEG2_TIMEOUT_MSG,	timeoutMsg);
			GETSET(MPEG2_ERROR_MSG,		errorMsg);
			GETSET(MPEG2_REFILL_MSG,	refillMsg);
			GETSET(MPEG2_DONE_MSG,		doneMsg);
			GETSET(MPEG2_SIGNAL_MSG,	signalMsg);
		PARSE_TAGS_END;
		}


	if (directXDisplay)
		{
		BOOL changed = FALSE;
		int left, top, width, height;
		int destLeft, destTop, destWidth, destHeight;
		BOOL sourceAdapt = directXDisplay->sourceAdapt;
		//BOOL clientAdapt = directXDisplay->clientAdapt;

		short outputLeft, outputTop, outputWidth, outputHeight;


		left = directXDisplay->sourceLeft;
		top = directXDisplay->sourceTop;
		width = directXDisplay->sourceWidth;
		height = directXDisplay->sourceHeight;

		destLeft = directXDisplay->destLeft;
		destTop = directXDisplay->destTop;
		destWidth = directXDisplay->destWidth;
		destHeight = directXDisplay->destHeight;

		outputLeft = (short)directXDisplay->outputLeft;
		outputTop = (short)directXDisplay->outputTop;
		outputWidth = (short)directXDisplay->outputWidth;
		outputHeight = (short)directXDisplay->outputHeight;


		PARSE_TAGS_START(tags)
//			GETSETDV(PIP_WINDOW,	hwnd, directXDisplay->SetWindow(hwnd));

			GETSETC(PIP_DISPLAY_LEFT, outputLeft);
			GETSETC(PIP_DISPLAY_TOP, outputTop);
			GETSETC(PIP_DISPLAY_HEIGHT, outputHeight);
			GETSETC(PIP_DISPLAY_WIDTH, outputWidth);

			GETSETC(PIP_SOURCE_LEFT, left);
			GETSETC(PIP_SOURCE_TOP, top);
			GETSETC(PIP_SOURCE_WIDTH, width);
			GETSETC(PIP_SOURCE_HEIGHT, height);
			GETSETC(PIP_ADAPT_SOURCE_SIZE, sourceAdapt);
			GETSETC(PIP_DEST_LEFT, destLeft);
			GETSETC(PIP_DEST_TOP, destTop);
			GETSETC(PIP_DEST_HEIGHT, destHeight);
			GETSETC(PIP_DEST_WIDTH, destWidth);

			//GETSETC(PIP_ADAPT_CLIENT_SIZE, clientAdapt);
			GETSETDV(PIP_COLORKEY_COLOR, colorKeyColor, directXDisplay->SetColorKeyColor(colorKeyColor));
		PARSE_TAGS_END;

		if (changed)
			{
			directXDisplay->SetSourceRectangle(sourceAdapt != 0, (WORD)left, (WORD)top, (WORD)width, (WORD)height);
			directXDisplay->SetDestRectangle(sourceAdapt != 0, (WORD)destLeft, (WORD)destTop, (WORD)destWidth, (WORD)destHeight);
			directXDisplay->SetOutputRectangle(outputLeft, outputTop, outputWidth, outputHeight);
			}

		}

	if (audioCodingModeChanged)
		{
#if AC3DISABLED
		if (audioType = MP2AUDTYP_AC3)
			audioType = MP2AUDTYP_MPEG;
#endif

		SetAudioCodingMode(audioType,
								 samplesPerSecond == 30464 ? 96000 : samplesPerSecond,
								 bitsPerSample,
								 channels);
		}

	if (audioOutConfigChanged)
		{
		SetAudioOutConfig(spkCfg, dualModeCfg, karaokeCfg);
		}

	if (ac3TestModeChanged)
		{
		ac3Decoder.SetDolbyTestMode(ac3OperationalMode, ac3HighScaleFactor, ac3LowScaleFactor, ac3DialogNorm);
		ac3Decoder.GetDolbyTestMode(ac3OperationalMode, ac3HighScaleFactor, ac3LowScaleFactor, ac3DialogNorm);
		ac3Decoder.GetAC3Config(ac3DynamicRange, enableLFE);
		}

	if (ac3ConfigChanged)
		{
		ac3Decoder.SetAC3Config(ac3DynamicRange, enableLFE);
		ac3Decoder.GetAC3Config(ac3DynamicRange, enableLFE);
		ac3Decoder.GetDolbyTestMode(ac3OperationalMode, ac3HighScaleFactor, ac3LowScaleFactor, ac3DialogNorm);
		}

	if (croppingRectChanged)
		{
		display->SetCropRectangle(cropLeft, cropTop, cropRight, cropBottom);
		}

	if (buttonRectChanged)
		{
		spuDisplay.SetButtonPosition(buttonLeft, buttonTop, buttonWidth, buttonHeight);
		}


	GNRAISE_OK;
	}


//
//  Update Brightness
//

void UnitSetClass::UpdateBrightness(void)
	{
	int y, u, v;

	y = brightness;
	u = blueBrightness - greenBrightness;
	v = redBrightness - greenBrightness;

	y = (y * 64) / 10000 + 96; if (y < 64) y = 64; else if (y > 192) y = 192;
	u = 128 + (u * 64) / 10000; if (u < 64) u = 64; else if (u > 192) u = 192;
	v = 128 + (v * 64) / 10000; if (v < 64) v = 64; else if (v > 192) v = 192;

	lowQualitySliceDecoder->SetBrightness(y, u, v);
	highQualitySliceDecoder->SetBrightness(y, u, v);
	}

//
//  Update Contrast
//

void UnitSetClass::UpdateContrast(void)
	{
	int c;

	c = contrast * 64 / 10000 + 96;

	lowQualitySliceDecoder->SetContrast(c);
	highQualitySliceDecoder->SetContrast(c);
	}

//
//  Update Saturation
//

void UnitSetClass::UpdateSaturation(void)
	{
	int c;

	c = saturation * 64 / 10000 + 96;

	lowQualitySliceDecoder->SetSaturation(c);
	highQualitySliceDecoder->SetSaturation(c);
	}


//
//  Watermarks
//

static const DWORD WaterMark0[] =
	{
	0x47110815, 0x47110816, 0x47110817, 0x47110818,
	0x47110819, 0x4711081a, 0x4711081b, 0x4711081c
	};

static const DWORD WaterMark1[] =
	{
	0x47110815, 0x47110816, 0x47110817, 0x47110818,
	0x47110819, 0x4711081a, 0x4711081b, 0x4711081c
	};

static const DWORD WaterMark2[] =
	{
	0x47110815, 0x47110816, 0x47110817, 0x47110818,
	0x47110819, 0x4711081a, 0x4711081b, 0x4711081c
	};

static const DWORD WaterMark3[] =
	{
	0x47110815, 0x47110816, 0x47110817, 0x47110818,
	0x47110819, 0x4711081a, 0x4711081b, 0x4711081c
	};

static const DWORD WaterMark4[] =
	{
	0x47110815, 0x47110816, 0x47110817, 0x47110818,
	0x47110819, 0x4711081a, 0x4711081b, 0x4711081c
	};

static const DWORD WaterMark5[] =
	{
	0x47110815, 0x47110816, 0x47110817, 0x47110818,
	0x47110819, 0x4711081a, 0x4711081b, 0x4711081c
	};

static const DWORD WaterMark6[] =
	{
	0x47110815, 0x47110816, 0x47110817, 0x47110818,
	0x47110819, 0x4711081a, 0x4711081b, 0x4711081c
	};

static const DWORD WaterMark7[] =
	{
	0x47110815, 0x47110816, 0x47110817, 0x47110818,
	0x47110819, 0x4711081a, 0x4711081b, 0x4711081c
	};

static const DWORD * WaterMarkArray[] =
	{
	WaterMark7,
	WaterMark6,
	WaterMark3,
	WaterMark2,
	WaterMark4,
	WaterMark5,
	WaterMark1,
	WaterMark0
	};

static const struct
	{
	DWORD mark0[8];
	PCICheckBlock check[256];
	} checkBlock =
	{0x67823bcd, 0x1983541a, 0xcfe73621, 0xfb18cf32, 0x67823bcd, 0x1983541a, 0xcfe73621, 0xfb18cf32, { 0, 0}};

static inline BOOL CheckPCIBlock(HANDLE kDriver)
	{
	return TRUE;
	}

static DWORD seed;

#if PROTECTED
extern DWORD * CheckSum1;

static inline BOOL CheckCode(void)
	{
	DWORD * p = (DWORD *)(CheckSum1[0] ^ CheckSum1[4]);
	DWORD num = (CheckSum1[1] ^ CheckSum1[5]);
	DWORD sum = (CheckSum1[2] ^ CheckSum1[6]);
	DWORD res = (CheckSum1[3] ^ CheckSum1[7]);
	DWORD cnt;

	for(cnt = 0; cnt<num; cnt+=4)
		{
		sum = _rotl(sum, 1) + *p++;
		}

	return res == sum;
	}
#endif

#pragma warning(disable : 4731)
static inline void CheckWatermark(int a, int b)
	{
	}

#pragma warning(default : 4731)



extern "C" {BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD  fdwReason, LPVOID lpvReserved);}

//
//  VDR Open Driver
//

DLLCALL Error WINAPI VDR_OpenDriver(TCHAR __far * name, DWORD boardID, VDRHandle __far & handle)
	{
	if (boardID == 0)
		{


		DllMain(NULL, DLL_PROCESS_ATTACH, NULL);

		PMMSG("OpenDriver+\n");


		if (!OpenCount && globalOpenCount)
			{

			if (allowMultiInstance)
				primaryUnit = FALSE;
			else
				{
				handle = NULL;

				GNRAISE(GNR_OBJECT_IN_USE);
				}
			}

		globalOpenCount++;

		handle = (VDRHandle) 1;

		PMMSG("Ravisent Software Cinemaster DVD Decoder\n");


#if _DEBUG
		PMMSGX("DEBUG Version %04d \n",CinemLibVersion);
#else
		PMMSGX("Version %04d \n", CinemLibVersion);
#endif


		PMMSG("-----------------------------------------\n");

#if PROTECTED
#endif

		OpenCount++;

		PMMSG("OpenDriver-\n");

		GNRAISE_OK;
		}
	else if (boardID == 0x47110815)
		{
		int i, j;

		j = GetTickCount() & 7;

		for(i=0; i<8; i++)
			{
			DWORD d = WaterMarkArray[j][i];
			d = (d & 0xff) ^ ((d >> 8) & 0xff) ^ ((d >> 16) & 0xff) ^ (d >> 24);
			name[i] = (char)d;
			}
		name[8] = 0;

		handle = NULL;

		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_UNITS_BUSY);
	}

//
//  VDR Close Driver
//

DLLCALL Error WINAPI VDR_CloseDriver(VDRHandle handle)
	{
	if (OpenCount) globalOpenCount--;
	OpenCount--;

	if (!OpenCount)
		{
		if (board)
			{
			board->Destroy();
			delete board;
			}
		board = NULL;
		}

	GNRAISE_OK;
	}

//
//  VDR Reconfigure Driver
//

DLLCALL Error WINAPI VDR_ReconfigureDriver(VDRHandle handle)
	{
	if (board)
		{
		GNREASSERT(board->Reconfigure());
		}

	GNRAISE_OK;
	}

//
//  VDR Avail Units
//

DLLCALL DWORD WINAPI VDR_AvailUnits(VDRHandle handle)
	{
	DWORD units = MPEG_DECODER_UNIT | PIP_UNIT;

	return units;
	}

//
//  VDR Open Units
//

DLLCALL Error WINAPI VDR_OpenUnits(VDRHandle handle, DWORD requnits, UnitSet __far & units)
	{
	Error err = GNR_OK;

	PMMSG("OpenUnits++\n");

	CheckWatermark(2, 6);

	if (handle && OpenCount)
		{
		if (!board)
			{
			board = CreateBoard(DriverInstance);

			if (IS_ERROR(err = board->BeginInitialize()) ||
				 IS_ERROR(err = board->Initialize())      ||
				 IS_ERROR(err = board->CompleteInitialize()))
				{
				delete board;
				board = NULL;

				PMMSGX("OpenUnits Err %08lx\n", err);

				GNRAISE(err);
				}
			}

		units = board->CreateUnitSet();

		if (!units)
			{
			err = GNR_OBJECT_IN_USE;
			}
		else if (IS_ERROR(err = units->Initialize()))
			{
			delete units;
			units = NULL;
			}
		}
	else
		err = GNR_OBJECT_NOT_FOUND;

	PMMSGX("OpenUnits Err %08lx\n", err);

	GNRAISE(err);
	}

//
//  VDR Open SUb Units
//

DLLCALL Error WINAPI VDR_OpenSubUnits(UnitSet parent, DWORD requnits, UnitSet __far &units)
	{
	parent->referenceCount++;
	units = parent;

	GNRAISE_OK;
	}

//
//  VDR Close Units
//

DLLCALL Error WINAPI VDR_CloseUnits(UnitSet units)
	{
	CheckWatermark(3, 0);

	if (units)
		{
		units->referenceCount--;
		if (!units->referenceCount)
			{
			units->PassivateUnits();
			delete units;
			}
		}

	GNRAISE_OK;
	}

//
//  VDR Configure Units
//

DLLCALL Error WINAPI VDR_ConfigureUnits(UnitSet units, TAG __far * tags)
	{
	Error err;

	if (!units && cus) units = cus;

	if (units)
		{
		err = units->ConfigureUnits(tags);

		return err;
		}
	else
		GNRAISE(GNR_OBJECT_NOT_ALLOCATED);
	}

//
//  VDR Configure T Units Set
//

DLLCALL Error WINAPI VDR_T_ConfigureUnitsSet(UnitSet units, TAG __far * tags)
	{
	return VDR_ConfigureUnits(units, tags);
	}

//
//  VDR Configure T Units Get
//

DLLCALL Error WINAPI VDR_T_ConfigureUnitsGet(UnitSet units, DWORD id, void * ref)
	{
	TAG t[2];

	t[0].id = id;
	t[0].data = (DWORD)ref;
	t[1] = TAGDONE;

	return VDR_ConfigureUnits(units, t);
	}

//
//  VDR Lock Units
//

DLLCALL Error WINAPI VDR_LockUnits(UnitSet units)
	{
	GNRAISE_OK;
	}

//
//  VDR_UnlockUnits
//

DLLCALL Error WINAPI VDR_UnlockUnits(UnitSet units)
	{
	GNRAISE_OK;
	}

//
//  VDR Activate Units
//

DLLCALL Error WINAPI VDR_ActivateUnits(UnitSet units)
	{
	if (units)
		units->ActivateUnits();

	GNRAISE_OK;
	}

//
//  VDR Passivate Units
//

DLLCALL Error WINAPI VDR_PassivateUnits(UnitSet units)
	{
	if (units)
		units->PassivateUnits();

	GNRAISE_OK;
	}

//
//  VDR Enable PIP
//

DLLCALL Error WINAPI VDR_EnablePIP(UnitSet units, BOOL enable)
	{
	CheckWatermark(2, 5);

	if (units->pipEnabled != enable)
		{
		units->pipEnabled = enable;
		if (units->active)
			{
			if (units->directXDisplay)
				units->directXDisplay->EnableDisplay(enable != 0);
			}
		}

	GNRAISE_OK;
	}

//
//  VDR Update PIP
//

DLLCALL Error WINAPI VDR_UpdatePIP(UnitSet units)
	{
	if (units && units->active)
		if (units->directXDisplay)
			units->directXDisplay->UpdateDisplay();

	GNRAISE_OK;
	}

//
//  VDR Grab Frame
//

DLLCALL Error WINAPI VDR_GrabFrame(UnitSet units, FPTR base,
                            WORD width, WORD height,
                            WORD stride,
                            GrabFormat fmt)
	{
	GNRAISE_OK;
	}

//
//  VDR Send MPEG Data
//

DLLCALL DWORD WINAPI VDR_SendMPEGData(UnitSet units, HPTR data, DWORD size)
	{
	return units->SendData((BYTE *)data, size);
	}

DLLCALL DWORD	WINAPI VDR_SendMPEGDataMultiple(UnitSet units, MPEGDataSizePair * data, DWORD size)
	{
	return units->SendDataMultiple(data, size);
	}

//
//  VDR Send MPEG Data Split
//

DLLCALL DWORD WINAPI VDR_SendMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType, HPTR data, DWORD size, int timeStamp)
	{
	return units->SendDataSplit((DVDElementaryStreamType)streamType, (BYTE *)data, size, timeStamp);
	}

DLLCALL DWORD WINAPI VDR_SendMPEGDataSplitMultiple(UnitSet units, MPEGElementaryStreamType streamType, MPEGDataSizePair * data, DWORD size)
	{
	return units->SendDataSplitMultiple((DVDElementaryStreamType)streamType, data, size);
	}

//
//  VDR Complete MPEG Data
//

DLLCALL void WINAPI VDR_CompleteMPEGData(UnitSet units)
	{
	units->CompleteData();
	}

//
//  VDR Complete MPEG Data Split
//

DLLCALL void WINAPI VDR_CompleteMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType)
	{
	units->CompleteDataSplit((DVDElementaryStreamType)streamType);
	}

//
//  VDR Restart MPEG Data Split
//

DLLCALL void WINAPI VDR_RestartMPEGDataSplit(UnitSet units, MPEGElementaryStreamType streamType)
	{
	units->RestartDataSplit((DVDElementaryStreamType)streamType);
	}

//
//  VDR MPEG Command Pending
//

DLLCALL BOOL WINAPI VDR_MPEGCommandPending(UnitSet units, DWORD tag)
	{
	return FALSE;
	}

//
//  VDR Send MPEG Command
//

DLLCALL Error WINAPI VDR_SendMPEGCommand(UnitSet units, MPEGCommand com, long param, DWORD __far &tag)
	{
	tag = 0;
	return VDR_DoMPEGCommand(units, com, param);
	}

//
//  VDR Do Command
//

DLLCALL Error WINAPI VDR_DoMPEGCommand(UnitSet units, MPEGCommand com, long param)
	{
	CheckWatermark(7, 1);

	if (units->active)
		{
		return units->DoMPEGCommand(com, param);
		}

	GNRAISE_OK;
	}

//
//  VDR Complete MPEG Command
//

DLLCALL Error WINAPI VDR_CompleteMPEGCommand(UnitSet units, DWORD tag)
	{
	GNRAISE_OK;
	}

//
//  VDR Current MPEG Location
//

DLLCALL DWORD WINAPI VDR_CurrentMPEGLocation(UnitSet units)
	{
	return (DWORD)(units->CurrentLocation() * units->positionScale / MP2SR_SCALE_BYTES);
	}

//
//  VDR Current MPEG Transfer Location
//

DLLCALL DWORD WINAPI VDR_CurrentMPEGTransferLocation(UnitSet units)
	{
	return (DWORD)(units->CurrentInputLocation());
	}

//
//  VDR Current MPEG State
//

DLLCALL MPEGState WINAPI VDR_CurrentMPEGState(UnitSet units)
	{
	if (!units->active)
		return mps_preempted;
	else if (units->seeking)
		return mps_seeking;
	else if (units->paused)
		return mps_frozen;
	else if (units->stopped)
		return mps_stopped;
	else if (units->scanning)
		return mps_scanning;
	else if (units->trickplay)
		return mps_trickplaying;
	else if (units->StreamingCompleted())
		return mps_stopped;
	else
		return mps_playing;
	}

//
//  VDR Install MPEG Win Hooks
//

DLLCALL Error WINAPI VDR_InstallMPEGWinHooks(UnitSet units, HWND hwnd, WORD refillMsg, WORD signalMsg, WORD doneMsg)
	{
	if (units)
		{
		units->msgWindow = hwnd;
		units->refillMsg = refillMsg;
		units->signalMsg = signalMsg;
		units->doneMsg = doneMsg;

		if (refillMsg == 0x1000 && signalMsg == 0x1001 && doneMsg == 0x1003)
			units->errorMsg = 0x1002;
		else
			units->errorMsg = 0;

		units->refillMsgPending = FALSE;
		}

	GNRAISE_OK;
	}

//
//  VDR Remove MPEG Win Hooks
//

DLLCALL Error WINAPI VDR_RemoveMPEGWinHooks(UnitSet units)
	{
	if (units)
		{
		units->msgWindow = NULL;
		}

	GNRAISE_OK;
	}

//
//  VDR Complete MPEG Refill Message
//

DLLCALL Error WINAPI VDR_CompleteMPEGRefillMessage(UnitSet units)
	{
	if (units)
		units->refillMsgPending = FALSE;

	GNRAISE_OK;
	}

DLLCALL Error WINAPI VDR_InstallMessagePort(UnitSet units, GenericMsgPort * port)
	{
	if (units)
		{
		units->msgPort = port;
		}

	GNRAISE_OK;
	}

DLLCALL Error WINAPI VDR_RemoveMessagePort(UnitSet units)
	{
	if (units)
		{
		units->msgPort = NULL;
		}

	GNRAISE_OK;
	}


//
//  VDR Do Authentication Command
//

DLLCALL Error WINAPI VDR_DoAuthenticationCommand(UnitSet units, MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key)
	{
	CheckWatermark(4, 2);

	if (allowCSS)
		return units->decryptor->DoAuthenticationCommand(com, sector, key);
	else
		GNRAISE(GNR_CSS_NOT_SUPPORTED);
	}

//
//  VDR Performance Monitor
//

DLLCALL void WINAPI VDR_ReadPerformanceMonitor(PerformanceMonitor & pmon)
	{
	pmon = perfmon;
	perfmon.maxFrameSkew = 0;
	}

//
//  VDR Check Region Code Valid
//

DLLCALL BOOL WINAPI VDR_CheckRegionCodeValid(UnitSet units, BYTE regionSet)
	{
	int regionMagic, changes;
	int i;

	CheckWatermark(0, 3);

	if (board)
		{
		return (~regionSet & (1 << (board->regionCode - 1)) & 0xff) != 0;
		}

	return FALSE;
	}


extern "C" {


//
//  Dll Main
//

#if _DEBUG
_CrtMemState memstate;
#endif

BOOL WINAPI DllMain(HINSTANCE hDLLInst,
	                 DWORD  fdwReason,
		              LPVOID lpvReserved)
	{
#if PROTECTED
	if ((DWORD)hDLLInst != 0x4b000000 || !CheckCode())
		return FALSE;
#endif

	DriverInstance = hDLLInst;

	switch (fdwReason)
		{
		case DLL_PROCESS_ATTACH:
			seed = ::GetTickCount() ^ 0x2412341;

			InitFrameStoreScalerTables();

			dctCoefficientZeroFirst.Merge(dctCoefficientZero);

			dctCoefficientZeroFirst.BuildExtDCTTable();
			dctCoefficientZero.BuildExtDCTTable();
			dctCoefficientOne.BuildExtDCTTable();

			dctCoefficientZeroFirst.BuildFlatDCTTable();
			dctCoefficientZero.BuildFlatDCTTable();
			dctCoefficientOne.BuildFlatDCTTable();

			motionCodes.PrepareByteTable(2);

			codedBlockPattern420.BuildExtPatternTable();

			macroBlockAddressIncrement.Secure();

			iFrameMacroBlockType.Secure();;
			bFrameMacroBlockType.Secure();;
			pFrameMacroBlockType.Secure();;

			iFieldMacroBlockType.Secure();;
			bFieldMacroBlockType.Secure();;
			pFieldMacroBlockType.Secure();;

			iFrameMacroBlockTypeFPFD.Secure();;
			bFrameMacroBlockTypeFPFD.Secure();;
			pFrameMacroBlockTypeFPFD.Secure();;

			codedBlockPattern420.Secure();;
			dmtVector.Secure();;
			dctDCSizeLuminance.Secure();;
			dctDCSizeChrominance.Secure();;
			dctCoefficientZeroFirst.Secure();;
			dctCoefficientZero.Secure();;
			dctCoefficientOne.Secure();;

			perfmon.videoBitBufferSize = VIDEO_STREAM_BUFFER_SIZE * 32;
			perfmon.audioBitBufferSize = AUDIO_STREAM_BUFFER_SIZE * 32;

			InitDecryption();
#if _DEBUG
			_CrtMemCheckpoint(&memstate);
#endif

			break;

		case DLL_PROCESS_DETACH:
#if _DEBUG
			_CrtMemDumpAllObjectsSince(&memstate );
#endif

			break;

		case DLL_THREAD_ATTACH:
			break;

		case DLL_THREAD_DETACH:
			break;
		}

	return TRUE;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\ClosedCaption\ClosedCaptionDecoder.h ===
//depot/xbox-aug01-final/private/ui/dvd/driver/softwarecinemaster/ClosedCaption/ClosedCaptionDecoder.h#4 - edit change 19203 (text)
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef CLOSEDCAPTIONDECODER_H
#define CLOSEDCAPTIONDECODER_H

#include "..\video\XBoxDisplay.h"
#include "..\MPEGDecoder\MPEGUserDataDecoder.h"

#define LINE21_FIELD_XDS 0
#define LINE21_FIELD_CLOSEDCAPTION 1

class ClosedCaptionDecoder : public Line21Decoder, protected TimingClient, protected TimedFiber
	{
	protected:
		TimedFiberEvent			event;
		TimedFiberMutex			lock;
		TimingSlave				*	timer;

		struct CCDataBuffer
			{
            bool field;
			int	displayTime;
			BYTE	data[128];
			int	size, pos;
			};


		CCDataBuffer				buffer[64];
		int							first, last;
		volatile bool				streaming, running, terminate;
		bool						cc_ok;

		int iMacrovisionLevel;
		VideoCopyMode eCGMSMode;
		int iNextCGMSPacket;


		bool DecodeCCCommand(bool initial, BYTE cc0, BYTE cc1);

		void FiberRoutine(void);

		void SendLine21Data(int displayTime, BYTE * data, int size);
		bool NeedsPureData(void) {return true;}

        void SendCGMSPacket();
		void SendLine21DataEx(bool field, int displayTime, BYTE * data, int size);
        

	public:
		ClosedCaptionDecoder(TimingSlave * timer);
		~ClosedCaptionDecoder(void);

		void BeginStreaming(void);
		void EndStreaming(void);
		void StartStreaming(void);
		void StopStreaming(void);
		void Reset();

		void SetMacrovisionLevel(int iMacrovisionLevel) ;

		void SetCGMSMode(VideoCopyMode eCGMSMode) ;

	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\cinemast\CinemLib.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef CINEMLIB_H
#define CINEMLIB_H

// change this (decimal)
#define CinemLibVersion 9

#endif CINEMLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\ClosedCaption\ClosedCaptionDecoder.cpp ===
//depot/xbox-aug01-final/private/ui/dvd/driver/softwarecinemaster/ClosedCaption/ClosedCaptionDecoder.cpp#4 - edit change 19203 (text)
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "ClosedCaptionDecoder.h"
#include "library\common\vddebug.h"

#define		DISABLE_CC		0
#define		TIME_CC			1

extern "C"
{
void    WINAPI D3DDevice_EnableCC(BOOL Enable);
void    WINAPI D3DDevice_SendCC(BOOL Field, BYTE cc1, BYTE cc2);
void    WINAPI D3DDevice_GetCCStatus(BOOL *pField1, BOOL *pField2);
};

// Interval between CGMS XDS packets

#define     CGMS_XDS_PACKET_INTERVAL    1000

bool ClosedCaptionDecoder::DecodeCCCommand(bool initial, BYTE cc0, BYTE cc1)
	{

	// wmp - very temp - disable sending cc.
#if DISABLE_CC
	return true;
#else

	int field1, field2;
	int timeout;

	if ((initial == LINE21_FIELD_CLOSEDCAPTION) && (cc0 == 0x80) && (cc1 == 0x80))
		return true;

	timeout = timer->CurrentTime() + 200;

    do
	    {
        D3DDevice_GetCCStatus(&field1, &field2);
 		if ((!field1) || (!field2))
			{
			lock.Leave();
			YieldTimedFiber(2);
			lock.Enter();
			}
        }
        while ((!field1 || !field2) && running && (cc_ok = (timeout > (timer->CurrentTime()))) );

	if (!cc_ok)
		DP("CC Status timed out");

//	char buffer[100];
//	wsprintf(buffer, "cc0:%x %c   cc1:%x %c\n", cc0, cc0, cc1, cc1);
//	OutputDebugString(buffer);


    D3DDevice_SendCC(initial, cc0, cc1);

	return true;
#endif DISABLE_CC
	}

void ClosedCaptionDecoder::FiberRoutine(void)
	{
	int time;

	lock.Enter();
	while (!terminate)
		{
		if (running && first != last && cc_ok)
			{
			if (buffer[first].pos != buffer[first].size)
				{
				time = timer->CurrentTime() + 300;
				while (first != last && time > buffer[first].displayTime && running)
					{
#if TIME_CC && _DEBUG
					int t1 = timeGetTime();
#endif
					DecodeCCCommand(buffer[first].field, buffer[first].data[buffer[first].pos], buffer[first].data[buffer[first].pos + 1]);
#if TIME_CC && _DEBUG
					int t2 = timeGetTime();
					if (t2 - t1 > 100)
						DP("ERROR CC took to long %d", t2-t1);
#endif

					buffer[first].pos += 2;
					buffer[first].displayTime += 16;

					if (buffer[first].pos == buffer[first].size)
						{
						first = (first + 1) & 63;
						}
					}

				}
			else
				{
				first = (first + 1) & 63;
				}

			if (first != last)
				{
				lock.Leave();
				Wait(&event, buffer[first].displayTime, FALSE);
				lock.Enter();
				}
			}
		else
			{
			lock.Leave();
			event.Wait(CGMS_XDS_PACKET_INTERVAL);
			lock.Enter();
			}

        // We're required to periodically send a Copy Generation Management System (CGMS)
        // packet through line 21. The priority, however, is the caption data. If the channel
        // is completely available, send the packet.

        if( first == last &&
            (!iNextCGMSPacket || 
            timer->CurrentTime() > iNextCGMSPacket))
            {

            // Send packet

            lock.Leave();
            SendCGMSPacket();
            lock.Enter();

            // Schedule next packet
            
            iNextCGMSPacket = timer->CurrentTime() + CGMS_XDS_PACKET_INTERVAL;
            }
        
		}
	lock.Leave();
	}

void ClosedCaptionDecoder::SendLine21Data(int displayTime, BYTE * data, int size)
	{
	lock.Enter();
	if (streaming && size)
		{
        buffer[last].field = LINE21_FIELD_CLOSEDCAPTION;
		buffer[last].displayTime = displayTime;
		buffer[last].size = size;
		buffer[last].pos = 0;

		memcpy(buffer[last].data, data, size);

		last = (last + 1) & 63;
		event.SetEvent();
		}
	lock.Leave();
	}

void ClosedCaptionDecoder::SendLine21DataEx(bool field, int displayTime, BYTE * data, int size)
	{
	lock.Enter();
	if (streaming && size)
		{
        buffer[last].field = field;
		buffer[last].displayTime = displayTime;
		buffer[last].size = size;
		buffer[last].pos = 0;

		memcpy(buffer[last].data, data, size);

		last = (last + 1) & 63;
		event.SetEvent();
		}
	lock.Leave();
	}


ClosedCaptionDecoder::ClosedCaptionDecoder(TimingSlave * timer)
	: TimedFiber(9), TimingClient(timer), event(FALSE, TRUE)
	{
	this->timer = timer;
	terminate = false;
	streaming = true;
	running = false;
	first = last = 0;
	iMacrovisionLevel = 0;
	eCGMSMode = VCPMD_COPYING_PERMITTED;
	iNextCGMSPacket = 0;
	}

ClosedCaptionDecoder::~ClosedCaptionDecoder(void)
	{
	}

void ClosedCaptionDecoder::BeginStreaming(void)
	{
	if (!streaming)
		{
		cc_ok = true;
#if !DISABLE_CC
		D3DDevice_EnableCC(TRUE);
#endif DISABLE_CC
		terminate = false;
		streaming = true;
		running = false;
		first = last = 0;
    	iNextCGMSPacket = 0;
		StartFiber();
		}
	}

void ClosedCaptionDecoder::EndStreaming(void)
	{
	if (streaming)
		{
		terminate = true;
		event.SetEvent();
		CompleteFiber();
		streaming = false;
        
        Reset();
		}
	}

void ClosedCaptionDecoder::StartStreaming(void)
	{
	cc_ok = true;
	running = true;
	iNextCGMSPacket = 0;
	event.SetEvent();
	}

void ClosedCaptionDecoder::StopStreaming(void)
	{
	running = false;
	}

void ClosedCaptionDecoder::Reset()
    {
#if !DISABLE_CC
    	int field1, field2;
    	int timeout;

    	timeout = timer->CurrentTime() + 200;

        do
    		{
    		D3DDevice_GetCCStatus(&field1, &field2);
    			if ((!field1) || (!field2))
    			{
    			YieldTimedFiber(2);
    			}
    		}
    		while ((!field1 || !field2) && running && (cc_ok = (timeout > (timer->CurrentTime()))) );

    	if (!cc_ok)
    		DP("CC Status timed out");

    	// clear CC data
        D3DDevice_SendCC(LINE21_FIELD_CLOSEDCAPTION, 0x94, 0x2c);

    	D3DDevice_EnableCC(FALSE);
#endif DISABLE_CC
    }    

//
// ClosedCaptionDecoder::SendCGMSPacket
// Parameters: none
// Retuns: void
// Sends a Copy Generation Management System packet through line 21
//
void ClosedCaptionDecoder::SendCGMSPacket()
    {

    __declspec(align(1)) struct
        {
        BYTE bPacketStartCode;
        BYTE bPacketType;

        union
            {
            BYTE bCGMSInfo;

            struct 
                {
                unsigned char uAnalogSource : 1;
                unsigned char uMacrovisionLevel : 2;
                unsigned char uCGMSLevel : 2;
                unsigned char uBit5 : 1;
                unsigned char uBit6 : 1;
                unsigned char uBit7 : 1;
                } info;
            };

        BYTE bPlaceHolder;

        BYTE bPacketEndCode;
        BYTE bCheckSum;
        } CGMSPacket;

    CGMSPacket.bPacketStartCode = 0x01;
    CGMSPacket.bPacketType = 0x08;
    CGMSPacket.info.uAnalogSource = 0;
    CGMSPacket.info.uMacrovisionLevel = iMacrovisionLevel;

    switch(eCGMSMode)
        {

        case VCPMD_ONE_COPY_PERMITTED:

            // One generation of copies may be made

            CGMSPacket.info.uCGMSLevel = 2;
            break;

        case VCPMD_NO_COPYING_PERMITTED:

            // No copying is permitted

            CGMSPacket.info.uCGMSLevel = 3;
            break;
        

        case VCPMD_COPYING_PERMITTED:
        default:

              // Copying is permitted without restriction

              CGMSPacket.info.uCGMSLevel = 0;
              break;
        }

    // The rest of the bits by the spec

    CGMSPacket.info.uBit5 = 0;
    CGMSPacket.info.uBit6 = 1;
    CGMSPacket.info.uBit7 = 0;

    CGMSPacket.bPlaceHolder = 0;
    CGMSPacket.bPacketEndCode = 0x0F;

    // Extracted from the spec:
    // "The Checksum Data Byte represents the 7-bit binary number necessary for the sum 
    // of the Start and Type characters, all of the following informational characters 
    // plus the End and Checksum characters to equal zero (i.e. the twos complement of 
    // the sum of the information characters plus the Start, Type and End characters)" 

    CGMSPacket.bCheckSum = ((CGMSPacket.bPacketStartCode + CGMSPacket.bPacketType + 
        +CGMSPacket.bCGMSInfo + CGMSPacket.bPacketEndCode) ^ 0x7F) + 1;

    // The packet is formed. Send it to line 21.

    SendLine21DataEx(LINE21_FIELD_XDS, timer->CurrentTime(), (BYTE*)&CGMSPacket, sizeof(CGMSPacket));

/*
    BYTE* pBytes = (BYTE*) &CGMSPacket;

    DP("Sending CGMS packet, size=%d -- %x, %x, %x, %x, %x, %x", sizeof(CGMSPacket),
        pBytes[0], pBytes[1], pBytes[2], pBytes[3], pBytes[4], pBytes[5]);
*/       

    }
    
// ClosedCaptionDecoder::SetMacrovisionLevel
// Parameters:
//   iMacrovisionLevel - New macrovision level
// Returns: void
// This function is called to notify this object that the 
// macrovision level has changed (for the CGMS packet).

void ClosedCaptionDecoder::SetMacrovisionLevel(int iMacrovisionLevel) 
    { 
    if(this->iMacrovisionLevel != iMacrovisionLevel)
        {

        // New macrovision level

	    this->iMacrovisionLevel = iMacrovisionLevel; 

        // Send the CGMS packet as soon as possible
        
	    this->iNextCGMSPacket = 0;
        }
    }

// ClosedCaptionDecoder::SetCGMSMode
// Parameters:
//   eCGMSMode - New CGMS mode
// Returns: void
// This function is called to notify this object that the 
// CGMS mode has changed (for the CGMS packet).

void ClosedCaptionDecoder::SetCGMSMode(VideoCopyMode eCGMSMode) 
    { 
    if(this->eCGMSMode != eCGMSMode)
        {

        // New CGMS mode

	    this->eCGMSMode = eCGMSMode; 

        // Send the CGMS packet as soon as possible

	    this->iNextCGMSPacket = 0;
	    }
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Audio\PCMWaveOut.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef PCMWAVEOUT_H
#define PCMWAVEOUT_H

#include "driver\SoftwareCinemaster\Common\Prelude.h"
#include "..\common\TimedFibers.h"
#include "library\common\profiles.h"
#include "AudioPlaybackDevice.h"
#include "..\common\StreamTiming.h"


class PCMWaveOut : private TimedFiber, GenericAudioPlaybackCallback
	{
	protected:
		GenericProfile		*	globalProfile;
		GenericProfile		*	profile;

		int					sampleRate;
		int					inputByteCount, outputByteCount;
		int					playbackSpeed;
		TimedFiberEvent		event;
		int					downMixLevel, userDownMixLevel;

		bool				advanceFrame;
		bool				terminate, threadRunning, running, dropping, detaching;
		bool				monoOutput;
//		bool				resampling;

		int					dataDropStartTime, dataDropStartPosition;
		int					maxAudioBuffer;

		TimingSlave		*	timingSlave;

		TimedFiberEvent	fiberEvent;
		GenericAudioPlaybackDevice * device;

		void FiberRoutine(void);

		void WaveDataRequest(void);

		int GetOutputPosition(void);

		void AddDualData(short * leftRightAna, short * leftRightDig, int num, int time);


	public:
		PCMWaveOut(GenericProfile * globalProfile, GenericProfile * profile, GenericAudioPlaybackDevice * device, TimingSlave * timingSlave);
		~PCMWaveOut(void);


		void AddPCMData(short * leftRight, int num, int time);
//		void AddPCMDualData(short * leftRight, short * leftRight1, int num, int time);
		void AddPCMDigData(short * leftRightAna, short * leftRightDig, int num, int time);
		void WaitForCompletion(void);

		void BeginStreaming(void);
		void StartStreaming(int playbackSpeed);
		void StopStreaming(void);
		void EndStreaming(bool fullReset);
		void CompleteStreaming(void);
		void DetachStreaming(void);
		void AttachStreaming(void);

		void AdvanceFrame(void);

		int GetBufferDelayTime();

		void SetSampleRate(int rate);

		bool SupportsSPDIFDataOut(void) {return device->SupportsSPDIFDataOut();}

		void SetSPDIFDataOut(bool enable);
//		void GetSPDIFDataOut(bool &enable);
		void SetAudioOutConfig(AC3SpeakerConfig spkCfg, AC3DualModeConfig dualModeCfg, AC3KaraokeConfig karaokeCfg);

		Error CheckHardwareResources(void) {return device->CheckHardwareResources();}
		bool SupportsVolumeControl(void) {return device->SupportsVolumeControl();}
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Common\BitStreams.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "BitStreams.h"
#include "library\common\vddebug.h"

#define CHECK_BUFFER_ENCRYPTION	0
#define DO_BUFFER_ENCRYPTION		0

void StreamFlipCopy::SwapMemory(DWORD * p, int num)
	{
	__asm
		{
		mov	ecx, [num]
		mov	eax, [p]
		test	ecx, ecx
		je		none
loop1:
		mov	edx, [eax]
		add	eax, 4

		bswap	edx

		dec	ecx
		mov	[eax-4], edx

		jne	loop1
none:
		}
	}

static void SwapDW(DWORD & dw)
	{

	__asm
		{
		mov	eax, [dw]
		mov	edx, [eax]
		bswap	edx
		mov	[eax], edx
		}
	}

#pragma warning (disable : 4799)

#include "..\common\katmaimacros.h"

void MMXStreamFlipCopy::CopySwapMemory(BYTE * d, BYTE * s, int num)
	{
	int startAllignment, startRest;
	int sourceAllignment;
	int finalRest;
	int sll, slr;

	startAllignment = (int)d & 7;

	if (startAllignment)
		{
		startRest = 8 - startAllignment;
		if (num >= startRest)
			{
			memcpy(d, s, startRest);
			SwapDW(((DWORD *)(d - startAllignment))[1]);
			if (startRest > 4)
				{
				SwapDW(((DWORD *)(d - startAllignment))[0]);
				}
			d += startRest;
			s += startRest;
			num -= startRest;
			}
		else if (num > 0)
			{
			memcpy(d, s, num);
			if (startRest > 4 && startRest - num <= 4)
				{
				SwapDW(((DWORD *)(d  - startAllignment))[0]);
				}
			num = 0;
			}
		}

	if (num > 0)
		{
		sourceAllignment = (int)s & 7;
		finalRest = num & 7;
		num = num >> 3;

		if (num > 0)
			{
			if (sourceAllignment) // source not alligned
				{
				s -= sourceAllignment;

				slr = sourceAllignment * 8;
				sll = 64 - slr;

				__asm
					{
					mov			ecx, [num]
					mov			edi, [d]
					mov			eax, [s]
					movq			mm0, [eax]
					movd			mm6, [sll]
					movd			mm7, [slr]
					movq			mm2, [eax+8]
					add			eax, 16
					psrlq			mm0, mm7

					movq			mm3, mm2
					psllq			mm2, mm6

					sub			ecx, 1
					je				done

	loop1:
					por			mm0, mm2

					movq			mm1, mm0
					pslld			mm0, 16

					psrld			mm1, 16
					movq			mm2, [eax]
					por			mm1, mm0

					movq			mm4, mm1
					psllw			mm1, 8
					add			eax, 8

					psrlw			mm4, 8
					dec			ecx

					movq			mm0, mm3
					por			mm1, mm4

					psrlq			mm0, mm7
					movq			mm3, mm2

					movq			[edi], mm1
					psllq			mm2, mm6

					lea			edi, [edi + 8]
					jne			loop1
	done:
					por			mm0, mm2

					movq			mm1, mm0
					pslld			mm0, 16

					psrld			mm1, 16

					por			mm1, mm0

					movq			mm4, mm1
					psllw			mm1, 8

					psrlw			mm4, 8

					por			mm1, mm4
					movq			[edi], mm1
					}
				}
			else // source perfectly alligned
				{
				__asm
					{
					mov			ecx, [num]
					mov			edi, [d]
					mov			esi, [s]
	loop2:
					movq			mm0, [esi]

					movq			mm1, mm0
					pslld			mm0, 16

					psrld			mm1, 16

					por			mm0, mm1

					movq			mm1, mm0
					psllw			mm0, 8

					psrlw			mm1, 8

					por			mm0, mm1

					movq			[edi], mm0

					add			esi, 8
					add			edi, 8

					sub			ecx, 1
					jne			loop2
					}
				}

			s += 8 * num + sourceAllignment;
			d += 8 * num;
			}

		if (finalRest)
			{
			memcpy(d, s, finalRest);
			if (finalRest >= 4)
				{
				SwapDW(((DWORD *)d)[0]);
				}
			}
		}
	}

void XMMXStreamFlipCopy::CopySwapMemory(BYTE * d, BYTE * s, int num)
	{
	int startAllignment, startRest;
	int sourceAllignment;
	int finalRest;
	int sll, slr;

	startAllignment = (int)d & 7;

	if (startAllignment)
		{
		startRest = 8 - startAllignment;
		if (num >= startRest)
			{
			memcpy(d, s, startRest);
			SwapDW(((DWORD *)(d - startAllignment))[1]);
			if (startRest > 4)
				{
				SwapDW(((DWORD *)(d - startAllignment))[0]);
				}
			d += startRest;
			s += startRest;
			num -= startRest;
			}
		else if (num > 0)
			{
			memcpy(d, s, num);
			if (startRest > 4 && startRest - num <= 4)
				{
				SwapDW(((DWORD *)(d  - startAllignment))[0]);
				}
			num = 0;
			}
		}

	if (num > 0)
		{
		sourceAllignment = (int)s & 7;
		finalRest = num & 7;
		num = num >> 3;

		if (num > 0)
			{
			if (sourceAllignment) // source not alligned
				{
				s -= sourceAllignment;

				slr = sourceAllignment * 8;
				sll = 64 - slr;

				__asm
					{
					mov			ecx, [num]
					mov			edi, [d]
					mov			eax, [s]
					movq			mm0, [eax]
					movd			mm6, [sll]
					movd			mm7, [slr]
					movq			mm2, [eax+8]
					add			eax, 16
					psrlq			mm0, mm7

					movq			mm3, mm2
					psllq			mm2, mm6

					sub			ecx, 1
					je				done

	loop1:
					prefetch_REGpOFF8	(1, eax, 32)
					por			mm0, mm2

					movq			mm1, mm0
					pslld			mm0, 16

					psrld			mm1, 16
					movq			mm2, [eax]
					por			mm1, mm0

					movq			mm4, mm1
					psllw			mm1, 8
					add			eax, 8

					psrlw			mm4, 8
					dec			ecx

					movq			mm0, mm3
					por			mm1, mm4

					psrlq			mm0, mm7
					movq			mm3, mm2

					movntq		(mm1, edi)
					psllq			mm2, mm6

					lea			edi, [edi + 8]
					jne			loop1
	done:
					por			mm0, mm2

					movq			mm1, mm0
					pslld			mm0, 16

					psrld			mm1, 16

					por			mm1, mm0

					movq			mm4, mm1
					psllw			mm1, 8

					psrlw			mm4, 8

					por			mm1, mm4
					movq			[edi], mm1
					}
				}
			else // source perfectly alligned
				{
				__asm
					{
					mov			ecx, [num]
					mov			edi, [d]
					mov			esi, [s]
	loop2:
					movq			mm0, [esi]

					movq			mm1, mm0
					pslld			mm0, 16

					psrld			mm1, 16

					por			mm0, mm1

					movq			mm1, mm0
					psllw			mm0, 8

					psrlw			mm1, 8

					por			mm0, mm1

					movq			[edi], mm0

					add			esi, 8
					add			edi, 8

					sub			ecx, 1
					jne			loop2
					}
				}

			s += 8 * num + sourceAllignment;
			d += 8 * num;
			}

		if (finalRest)
			{
			memcpy(d, s, finalRest);
			if (finalRest >= 4)
				{
				SwapDW(((DWORD *)d)[0]);
				}
			}
		}
	}

void StreamFlipWordCopy::SwapMemory(DWORD *p, int num)
	{
	__asm
		{
		mov	ecx, [num]
		mov	eax, [p]
		test	ecx, ecx
		je		none
loop1:
		mov	edx, [eax]
		add	eax, 4

		ror	edx, 16

		dec	ecx
		mov	[eax-4], edx

		jne	loop1
none:
		}

	}


static void SwapWordDW(DWORD & dw)
	{

	__asm
		{
		mov	eax, [dw]
		mov	edx, [eax]
		ror	edx, 16
		mov	[eax], edx
		}
	}


void StreamFlipWordCopy::CopySwapMemory(BYTE * d, BYTE * s, int num)
	{
	int startAllignment, startRest;
	int sourceAllignment;
	int finalRest;
	int sll, slr;

	startAllignment = (int)d & 7;

	if (startAllignment)
		{
		startRest = 8 - startAllignment;
		if (num >= startRest)
			{
			memcpy(d, s, startRest);
			SwapWordDW(((DWORD *)(d - startAllignment))[1]);
			if (startRest > 4)
				{
				SwapWordDW(((DWORD *)(d - startAllignment))[0]);
				}
			d += startRest;
			s += startRest;
			num -= startRest;
			}
		else if (num > 0)
			{
			memcpy(d, s, num);
			if (startRest > 4 && startRest - num <= 4)
				{
				SwapWordDW(((DWORD *)(d  - startAllignment))[0]);
				}
			num = 0;
			}
		}

	if (num > 0)
		{
		sourceAllignment = (int)s & 7;
		finalRest = num & 7;
		num = num >> 3;

		if (num > 0)
			{
			if (sourceAllignment) // source not alligned
				{
				// not using that often so unalligned penalty not so big
				s -= sourceAllignment;

				slr = sourceAllignment * 8;
				sll = 64 - slr;

				__asm
					{
					mov			ecx, [num]
					mov			edi, [d]
					mov			eax, [s]
					movq			mm0, [eax]
					movd			mm6, [sll]
					movd			mm7, [slr]
					movq			mm2, [eax+8]
					add			eax, 16
					psrlq			mm0, mm7

					movq			mm3, mm2
					psllq			mm2, mm6

					sub			ecx, 1
					je				done

	loop1:
					por			mm0, mm2

					movq			mm1, mm0
					pslld			mm0, 16

					psrld			mm1, 16
					movq			mm2, [eax]
					por			mm1, mm0

					add			eax, 8

					dec			ecx

					movq			mm0, mm3

					psrlq			mm0, mm7
					movq			mm3, mm2

					movq			[edi], mm1
					psllq			mm2, mm6

					lea			edi, [edi + 8]
					jne			loop1
	done:
					por			mm0, mm2

					movq			mm1, mm0
					pslld			mm0, 16

					psrld			mm1, 16

					por			mm1, mm0

					movq			[edi], mm1
					}
				}
			else // source perfectly alligned
				{
				__asm
					{
					mov			esi, [s]
					mov			ecx, [num]
					mov			edi, [d]
	loop2:
					movq			mm0, [esi]

					movq			mm1, mm0
					psrld			mm0, 16
					pslld			mm1, 16
					por			mm0, mm1

					movq			[edi], mm0

					add			esi, 8
					add			edi, 8

					sub			ecx, 1
					jne			loop2
					}
				}

			s += 8 * num + sourceAllignment;
			d += 8 * num;
			}

		if (finalRest)
			{
			memcpy(d, s, finalRest);
			if (finalRest >= 4)
				{
				SwapWordDW(((DWORD *)d)[0]);
				}
			}
		}

	}

#pragma warning (default : 4799)


static void SwapMemory(DWORD * p, int num)
	{
	__asm
		{
		mov	ecx, [num]
		mov	eax, [p]
		test	ecx, ecx
		je		none
loop1:
		mov	edx, [eax]
		add	eax, 4

		bswap	edx

		dec	ecx
		mov	[eax-4], edx

		jne	loop1
none:
		}
	}

BitStream::BitStream(DWORD * buffer, int size, int & mbsbits, StreamFlipCopy * streamFlipCopy, bool allTimeStamps) : bsbits(mbsbits)
	{
	this->buffer = buffer;
	this->size = size;

	mask = (32 * size) - 1;

	::InitializeCriticalSection(&lock);

#if CHECK_BUFFER_ENCRYPTION
	check = new bool[size * 4];
#endif

	if (allTimeStamps)
		minPTSDistance = 1;
	else
		minPTSDistance = 32 * size / NUM_TIME_STAMPS;

	last = 1;
	FlushBuffer();

	this->streamFlipCopy = streamFlipCopy;
	}

BitStream::~BitStream(void)
	{
//	::DeleteCriticalSection(&lock);
	DeleteCriticalSection(&lock);
	}

bool BitStream::IsBufferUnderflow(void)
	{
	int bits = bsbits;

	first = ((bits & mask) >> 5) << 2;

	if (first > last)
		return bufferStart == 0;
	else
		return FALSE;
	}

__int64 BitStream::CurrentLocation(void)
	{
	int bits = bsbits;

	first = ((bits & mask) >> 5) << 2;

	if (first > last)
		return bufferStart + (bits & mask) - size * 32;
	else
		return bufferStart + (bits & mask);
	}

__int64 BitStream::CurrentInputLocation(void)
	{
	return bufferStart + last * 8;
	}

bool BitStream::SetCurrentLocation(__int64 pos)
	{
	int ffirst;

	::EnterCriticalSection(&lock);

	ffirst = ((bsbits & mask) >> 5) << 2;

	lastAvail = size * 32;


	if (pos >= bufferStart)
		{
		pos -= bufferStart;

		bsbits = (int)(pos - bufferStart);
		}
	else
		{
		pos -= bufferStart - size * 32;

		bsbits = (int)(pos + size * 32 - bufferStart);
		}


	first = ((bsbits & mask) >> 5) << 2;
	::LeaveCriticalSection(&lock);

	return TRUE;
	}

bool BitStream::SetFillLocation(__int64 pos)
	{
	int llast;

	::EnterCriticalSection(&lock);

	lastAvail = size * 32;
	llast = last;

	if (pos >= bufferStart)
		{
		last = (int)(pos - bufferStart + 7)	>> 3;
		scrambleIn = (last & ~3);
		if (scrambleOut > last && scrambleOut <= llast)
			scrambleOut = scrambleIn;
		}
	else
		{
		bufferStart -= size * 32;

		last = (int)(pos - bufferStart + 7)	>> 3;
		scrambleIn = (last & ~3);
		if (scrambleOut < llast || scrambleOut >= last)
			scrambleOut = scrambleIn;
		}

	::LeaveCriticalSection(&lock);

	return TRUE;
	}

void BitStream::MarkResetPosition(void)
	{
	int bits = bsbits;

	first = ((bits & mask) >> 5) << 2;
	resetPosition = first;
	validResetPosition = true;
	}

void BitStream::RemoveResetPosition(void)
	{
	validResetPosition = false;
	}


void BitStream::AddTimeStamp(int stamp)
	{
	__int64 pos = CurrentInputLocation();

	if (!firstStamp ||
		 pos > prevPTSPosition + minPTSDistance ||
		 stamp > prevPTSStamp + 400)
		{
		int next = (firstStamp + 1) % NUM_TIME_STAMPS;

		if (next == lastStamp)
			lastStamp = (lastStamp + 1) % NUM_TIME_STAMPS;

		stamps[firstStamp].pos = pos;
		stamps[firstStamp].time = stamp;

		firstStamp = next;

		prevPTSPosition = pos;
		prevPTSStamp = stamp;
		}
	}

int BitStream::GetCurrentTimeStamp(void)
	{
	__int64 pos;
	int p, pp;

	pos = CurrentLocation();
	p = lastStamp;
	pp = -1;

	while (p != firstStamp && pos >= stamps[p].pos)
		{
		pp = p;
		p = (p + 1) % NUM_TIME_STAMPS;
		}

	if (pp < 0)
		return INVALID_TIME_STAMP;
	else
		{
		return stamps[pp].time;
		}
	}

int BitStream::GetTimeOfCurrentLocation(void)
	{
	__int64 pos;
	int p, pp;

	pos =  CurrentLocation();
	p =  lastStamp;
	pp = -1;

	while (p !=  firstStamp && pos >=  stamps[p].pos)
		{
		pp = p;
		p = (p + 1) % NUM_TIME_STAMPS;
		}

	if (pp < 0)
		{
//		return INVALID_TIME_STAMP;
		return (0);
		}
	else if(p == firstStamp)
		{
		return stamps[pp].time;
		}
	else
		{
		//crude interpolation of time
		__int64 deltaPos = stamps[p].pos - stamps[pp].pos;
		int deltaTime = stamps[p].time - stamps[pp].time;
		int retTime = stamps[pp].time + ScaleDWord((DWORD)(pos - stamps[pp].pos), (DWORD)deltaPos, deltaTime);
//		DP("returning 0x%08x :: pp 0x%03x - fStmp 0x%04x lStmp 0x%04x",retTime, pp, firstStamp, lastStamp);
		return (retTime);
		}
	}

int BitStream::AddData(BYTE * ptr, int num)
	{
	int done;

	::EnterCriticalSection(&lock);

	if (validResetPosition)
		first = resetPosition;
	else
		first = ((bsbits & mask) >> 5) << 2;

	if (first > last)
		{
		done = first-last-4;
		if (done > 0)
			{
			if (done > num) done = num;
			streamFlipCopy->CopySwapMemory((BYTE *)buffer + last, ptr, done);
			last += done;
			}
		else
			done = 0;
		}
	else if (first)
		{
		done = size * 4 - last;
		if (done)
			{
			if (done > num) done = num;
			streamFlipCopy->CopySwapMemory((BYTE *)buffer + last, ptr, done);
			last += done;
			}
		if (done < num)
			{
			ptr += done;
			num -= done;
			if (num > first-4) num = first-4;
			if (num > 0)
				{
				bufferStart += size * 32;

				streamFlipCopy->CopySwapMemory((BYTE *)buffer, ptr, num);
				last = num;
				done += num;
				}
			}
		else if (last == size * 4)
			{
			bufferStart += size * 32;
			last = 0;
			}
		}
	else
		{
		done = size * 4 - last - 4;
		if (done > 0)
			{
			if (done > num) done = num;
			streamFlipCopy->CopySwapMemory((BYTE *)buffer + last, ptr, done);
			last += done;
			}
		else
			done = 0;
		}

	buffer[size] = buffer[0];
	lastAvail = size * 32;

	ScrambleBuffer();

	::LeaveCriticalSection(&lock);

	return done;
	}

void BitStream::StuffBuffer(void)
	{
	::EnterCriticalSection(&lock);

	streamFlipCopy->SwapMemory(buffer + (last >> 2), ((last + 3) >> 2) - (last >> 2));
	buffer[size] = buffer[0];

	::LeaveCriticalSection(&lock);
	}

int BitStream::AvailBits(void)
	{
	int avail;

	::EnterCriticalSection(&lock);

	first = ((bsbits & mask) >> 5) << 2;

	if (first > last)
		avail = (size * 4 - (first - last)) * 8;
	else
		avail = (last - first) * 8;

	avail -= (bsbits & 0x1f);

	if (avail > lastAvail) avail = 0;
	else lastAvail = avail;

	::LeaveCriticalSection(&lock);

	return avail;
	}

int BitStream::AvailBufferSpace(void)
	{
	return size * 32 - AvailBits();
	}

void BitStream::ByteAllign(void)
	{
	bsbits += -bsbits & 7;
	}

#define SCRAMBLESTEP		2048

void BitStream::FlushBuffer(void)
	{
	int i;

	::EnterCriticalSection(&lock);

	if (bufferStart)
		{
		for(i=0; i<size; i+=4)
			{
			buffer[i+0] = 0x55555555;
			buffer[i+1] = 0x55555556;
			buffer[i+2] = 0x00000000;
			buffer[i+3] = 0x000001b7;
			}
		}
	else if (last)
		{
		last = (last + 3) >> 2;
		for(i=0; i<last; i+=4)
			{
			buffer[i+0] = 0x55555555;
			buffer[i+1] = 0x55555556;
			buffer[i+2] = 0x00000000;
			buffer[i+3] = 0x000001b7;
			}
		}

	first = last = 0;
	bsbits = 0;
	firstStamp = lastStamp = 0;
	lastAvail = size * 32;
	bufferStart = 0;
	scrambleIn = scrambleOut = 0;
	validResetPosition = false;

#if CHECK_BUFFER_ENCRYPTION
	for(i=0; i<size*4; i++)
		{
		check[i] = false;
		}
#endif

	::LeaveCriticalSection(&lock);
	}

bool BitStream::HasBufferEnoughData(int requestBits)
	{
	if (AvailBits() >= requestBits)
		return true;
	else
		return InternalIsBufferComplete();
	}

bool BitStream::RefillBuffer(int requestBits, bool lowDataPanic)
	{
	if (InternalRefillBuffer(requestBits, lowDataPanic))
		{
		DescrambleBuffer(requestBits);

		return TRUE;
		}
	else
		return FALSE;
	}

void BitStream::ScrambleBuffer(void)
	{
#if DO_BUFFER_ENCRYPTION
	int next;

	next = (scrambleIn + SCRAMBLESTEP - 1)  & ~(SCRAMBLESTEP - 1);

	if (scrambleIn > last)
		{
		while (next < size * 4)
			{
			((BYTE *)buffer)[next] ^= 0xaa;
#if CHECK_BUFFER_ENCRYPTION
			if (check[next]) __asm int 3
			check[next] = true;
#endif
			next += SCRAMBLESTEP;
			}
		next = 0;
		}

	while (next < (last & ~3))
		{
		((BYTE *)buffer)[next] ^= 0xaa;
#if CHECK_BUFFER_ENCRYPTION
		if (check[next]) __asm int 3
		check[next] = true;
#endif
		next += SCRAMBLESTEP;
		}

	scrambleIn = (last & ~3);
#endif
	}

void BitStream::DescrambleBuffer(int requestBits)
	{
#if DO_BUFFER_ENCRYPTION
	int next;

	::EnterCriticalSection(&lock);

	first = ((bsbits & mask) >> 5) << 2;

	int final = first + ((requestBits + 7) >> 3);

	if (scrambleOut < first)
		{
#if CHECK_BUFFER_ENCRYPTION
		if (scrambleOut > last || first < last) __asm int 3
#endif
		final -= size * 4;
		}

	if (last >= scrambleOut)
		{
		if (final > (last & ~3)) final = (last & ~3);
		}
	else
		{
		if (final > (last & ~3) + size * 4) final = (last & ~3) + size * 4;
		}

	if (scrambleOut < final)
		{
		next = (scrambleOut + SCRAMBLESTEP - 1)  & ~(SCRAMBLESTEP - 1);

		if (final > size * 4)
			{
			while (next < size * 4)
				{
				((BYTE *)buffer)[next] ^= 0xaa;
#if CHECK_BUFFER_ENCRYPTION
				if (!check[next]) __asm int 3
				check[next] = false;
#endif
				next += SCRAMBLESTEP;
				}
			next = 0;
			final -= size * 4;
			}

		while (next < final)
			{
			((BYTE *)buffer)[next] ^= 0xaa;
#if CHECK_BUFFER_ENCRYPTION
			if (!check[next]) __asm int 3
			check[next] = false;
#endif
			next += SCRAMBLESTEP;
			}

		scrambleOut = final;

		buffer[size] = buffer[0];
		}

	::LeaveCriticalSection(&lock);
#endif
	}

void BitStream::SetStreamFlipCopy(StreamFlipCopy * streamFlipCopy)
	{
	if (streamFlipCopy)
		this->streamFlipCopy = streamFlipCopy;
	}

void BitStream::GetStreamFlipCopy(StreamFlipCopy * & streamFlipCopy)
	{
	streamFlipCopy = this->streamFlipCopy;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Common\AsyncErrorMessages.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef ASYNCERRORMESSAGES_H
#define ASYNCERRORMESSAGES_H

#include "library\common\prelude.h"

class ASyncErrorMessenger
	{
	public:
		virtual void PostErrorMessage(Error err) = 0;
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Common\KATMAIMacros.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// ************************************************************************************
// *
// *	INTEL KATMAI ISSE EXTENSION MACROS
// *
// *	FILE:			KatmaiMacros
// *	CONTEXT:		header file containing preprocessor macros
// *	PURPOSE:		preprocessor macros for generation of ISSE instructions
// *	START:		Friday, 23. July 1999
// *
// *	AUTHOR:		Roland Schaufler
// *	COPYRIGHT:	VIONA Development GmbH
// *
// ************************************************************************************
//
// THIS FILE IS COPYRIGHT OF VIONA DEVELOPMENT GMBH AND IS NOT LICENSED TO THE PUBLIC
//
// This file depends on the file "MMXExtensionMacros.h" and will not compile without it.
// All register definitions are missing here...
//
// As it is not possible to overload a macro and to use it with different parameters
// every single addressing mode which is needed has to be "hard-coded". The convention used
// herefore is the following:
//
// instruction			meaning
// Suffix
// -------------------------------------------------------
// --						reg, reg
// MEM					reg, [base]
// IMM8					reg, [base + immediate8]  (this one is not used)
//	IMM32					reg, [base + immediate32] (this one is used rather!)
// SIB					reg, [base + scale*index]
//	STR					[base], reg  (memory store)
//
// explicite store or load instructions contain no extra suffixes
//

#include "MMXExtensionMacros.h"


#ifndef KATMAI_MACROS_H
#define KATMAI_MACROS_H

// streaming SIMD MMX registers
#define Register_xmm0 0
#define Register_xmm1 1
#define Register_xmm2 2
#define Register_xmm3 3
#define Register_xmm4 4
#define Register_xmm5 5
#define Register_xmm6 6
#define Register_xmm7 7

// specials for ModR/M bytes: Mod
#define Mod_none   0
#define Mod_disp8	 1
#define Mod_disp32 2
#define Mod_reg    3

// specials for ModR/M bytes: R/M
#define Register_SIB    4
#define Register_disp32	5

// specials for SIB bytes
#define Register_noindx 4
#define Register_nobase 5

//////////////////////////////////////////////////////////////////////////////////////////////
// Macros only for use within other Macros
//////////////////////////////////////////////////////////////////////////////////////////////

#define START2	_asm _emit 0x0F _asm _emit
#define START3	_asm _emit 0xF3 _asm _emit 0x0F _asm _emit

//////////////////////////////////////////////////////////////////////////////////////////////

#define BLOCK2(opcode, mod, rm, dest)									\
	}																				\
   START2 opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm																			\
		{

#define BLOCK2IMM8(opcode, mod, rm, dest, imm8)						\
	}																				\
   START2 opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm _emit imm8															\
	_asm																			\
		{

#define BLOCK2IMM32(opcode, mod, rm, dest, imm32)					\
	}																				\
   START2 opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm _emit BYTE0(imm32)													\
	_asm _emit BYTE1(imm32)													\
	_asm _emit BYTE2(imm32)													\
	_asm _emit BYTE3(imm32)													\
	_asm																			\
		{

//////////////////////////////////////////////////////////////////////////////////////////////

#define BLOCK3(opcode, mod, rm, dest)									\
	}																				\
   START3 opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm																			\
		{

#define BLOCK3IMM8(opcode, mod, rm, dest, imm8)						\
	}																				\
   START3 opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm _emit imm8															\
	_asm																			\
		{

#define BLOCK3IMM32(opcode, mod, rm, dest, imm32)					\
	}																				\
   START3 opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm _emit BYTE0(imm32)													\
	_asm _emit BYTE1(imm32)													\
	_asm _emit BYTE2(imm32)													\
	_asm _emit BYTE3(imm32)													\
	_asm																			\
		{

//////////////////////////////////////////////////////////////////////////////////////////////

#define BLOCK2SIB(opcode, mod, rm, dest, scale, index, base)	\
	}																				\
   START2 opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm _emit SIBBYTE(scale, index, base)								\
	_asm																			\
		{

#define BLOCK2SIBIMM8(opc, mod, rm, dst, scal, ind, bas, imm8)	\
	}																				\
   START2 opc																	\
	_asm _emit MODRMBYTE(mod, rm, dst)									\
	_asm _emit SIBBYTE(scal, ind, bas)									\
	_asm _emit imm8															\
	_asm																			\
		{

#define BLOCK2SIBIMM32(opc, mod, rm, dest, scale, ind, base)	\
	}																				\
   START2 opc																	\
	_asm _emit MODRMBYTE(mod, rm, dest)									\
	_asm _emit SIBBYTE(scale, ind, base)								\
	_asm _emit BYTE0(imm32)													\
	_asm _emit BYTE1(imm32)													\
	_asm _emit BYTE2(imm32)													\
	_asm _emit BYTE3(imm32)													\
	_asm																			\
		{

//////////////////////////////////////////////////////////////////////////////////////////////
// KATMAI STREAMING SIMD INSTRUCTIONS
//////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////
// **** 2 BYTE OPCODES
// **** REGISTER to REGISTER
//////////////////////////////////////////////////////////////////////////////////////////////
#define addps(dest, src)					BLOCK2(0x58, reg, src, dest)
#define andnps(dest, src)					BLOCK2(0x55, reg, src, dest)
#define andps(dest, src)					BLOCK2(0x54, reg, src, dest)
#define comiss(dest, src)					BLOCK2(0x2F, reg, src, dest)
#define cvtpi2ps(dest, src)				BLOCK2(0x2A, reg, src, dest)
#define cvtps2pi(dest, src)				BLOCK2(0x2D, reg, src, dest)
#define cvttps2pi(dest, src)				BLOCK2(0x2C, reg, src, dest)
#define divps(dest, src)					BLOCK2(0x5E, reg, src, dest)
#define maxps(dest, src)					BLOCK2(0x5F, reg, src, dest)
#define minps(dest, src)					BLOCK2(0x5D, reg, src, dest)
#define movaps(dest, src)					BLOCK2(0x28, reg, src, dest)
#define movmskps(dest, src)				BLOCK2(0x50, reg, src, dest)
#define movups(dest, src)					BLOCK2(0x10, reg, src, dest)
#define mulps(dest, src)					BLOCK2(0x59, reg, src, dest)
#define orps(dest, src)						BLOCK2(0x56, reg, src, dest)
#define rcpps(dest, src)					BLOCK2(0x53, reg, src, dest)
#define rsqrtps(dest, src)					BLOCK2(0x52, reg, src, dest)
#define sqrtps(dest, src)					BLOCK2(0x51, reg, src, dest)
#define subps(dest, src)					BLOCK2(0x5C, reg, src, dest)
#define ucomiss(dest, src)					BLOCK2(0x2E, reg, src, dest)
#define unpckhps(dest, src)				BLOCK2(0x15, reg, src, dest)
#define unpcklps(dest, src)				BLOCK2(0x14, reg, src, dest)
#define xorps(dest, src)					BLOCK2(0x57, reg, src, dest)

//////////////////////////////////////////////////////////////////////////////////////////////
// **** 3 Byte opcodes
// **** REGISTER to REGISTER
//////////////////////////////////////////////////////////////////////////////////////////////
#define rcpss(dest, src)					BLOCK3(0x53, reg, src, dest)
#define rsqrtss(dest, src)					BLOCK3(0x52, reg, src, dest)
#define addss(dest, src)					BLOCK3(0x58, reg, src, dest)
#define cvtsi2ss(dest, src)				BLOCK3(0x2A, reg, src, dest)
#define cvtss2si(dest, src)				BLOCK3(0x2D, reg, src, dest)
#define cvttss2si(dest, src)				BLOCK3(0x2C, reg, src, dest)
#define divss(dest, src)					BLOCK3(0x5E, reg, src, dest)
#define maxss(dest, src)					BLOCK3(0x5F, reg, src, dest)
#define minss(dest, src)					BLOCK3(0x5D, reg, src, dest)
#define movss(dest, src)					BLOCK3(0x10, reg, src, dest)
#define mulss(dest, src)					BLOCK3(0x59, reg, src, dest)
#define rcpss(dest, src)					BLOCK3(0x53, reg, src, dest)
#define rsqrtss(dest, src)					BLOCK3(0x52, reg, src, dest)
#define sqrtss(dest, src)					BLOCK3(0x51, reg, src, dest)
#define subss(dest, src)					BLOCK3(0x5C, reg, src, dest)

//////////////////////////////////////////////////////////////////////////////////////////////
// **** 2 BYTE OPCODES
// **** REGISTER to REGISTER plus IMMEDIATE8
//////////////////////////////////////////////////////////////////////////////////////////////
#define cmpps(dest, src, imm8)         BLOCK2IMM8(0xC2, reg, src, dest, imm8)
#define shufps(dest, src, imm8)        BLOCK2IMM8(0xC6, reg, src, dest, imm8)

//////////////////////////////////////////////////////////////////////////////////////////////
// **** 2 Byte opcodes
// **** MEMORY	to REGISTER
//////////////////////////////////////////////////////////////////////////////////////////////
// **** MEMORY to REGISTER
#define movapsMEM(dest, src)              BLOCK2(0x28, none, src, dest)           // src = single INTEGER Register
#define movhps(dest, src)              BLOCK2(0x16, none, src, dest)           // src = single INTEGER Register
#define movlps(dest, src)              BLOCK2(0x12, none, src, dest)           // src = single INTEGER Register
#define xorpsMEM(dest, src)				BLOCK2(0x57, none, src, dest)
#define cvtpi2psMEM(dest, src)			BLOCK2(0x2A, none, src, dest)
// **** MEMORY to REGISTER	+ offset8
#define movhpsIMM08(dest, src, imm8)   BLOCK2IMM8(0x16, none, src, dest, imm8)  // src = single INTEGER Register
#define movlpsIMM08(dest, src, imm8)   BLOCK2IMM8(0x12, none, src, dest, imm8)  // src = single INTEGER Register
// **** MEMORY to REGISTER	+ offset32
#define movhpsIMM32(dest, src, imm32)  BLOCK2IMM32(0x16, none, src, dest, imm32) // src = single INTEGER Register
#define movlpsIMM32(dest, src, imm32)  BLOCK2IMM32(0x12, none, src, dest, imm32) // src = single INTEGER Register
// **** MEMORY to REGISTER	complex adress (base + index)
#define movhpsSIB(dest, scale, index, base)  BLOCK2SIB(0x16, none, SIB, dest, scale, index, base)
#define movlpsSIB(dest, scale, index, base)  BLOCK2SIB(0x12, none, SIB, dest, scale, index, base)
// **** MEMORY to REGISTER	complex adress (base + index), offset8
#define movhpsSIBIMM8(dest, scale, index, base, imm8) BLOCK2SIBIMM8(0x16, disp8, SIB, dest, scale, index, base. imm8)
#define movlpsSIBIMM8(dest, scale, index, base, imm8) BLOCK2SIBIMM8(0x12, disp8, SIB, dest, scale, index, base. imm8)
// **** MEMORY to REGISTER	complex adress (base + index), offset32
#define movhpsSIBIMM32(dest, scale, index, base, imm32) BLOCK2SIBIMM32(0x16, disp32, SIB, dest, scale, index, base. imm32)
#define movlpsSIBIMM32(dest, scale, index, base, imm32) BLOCK2SIBIMM32(0x12, disp32, SIB, dest, scale, index, base. imm32)


//////////////////////////////////////////////////////////////////////////////////////////////
// **** 2 Byte opcodes
// **** REGISTER to MEMORY
//////////////////////////////////////////////////////////////////////////////////////////////
// **** REGISTER to MEMORY
#define movapsSTR(dest, src)              BLOCK2(0x29, none, src, dest)           // src = single INTEGER Register
#define movhpsSTR(dest, src)              BLOCK2(0x17, none, src, dest)           // src = single INTEGER Register
#define movlpsSTR(dest, src)              BLOCK2(0x13, none, src, dest)           // src = single INTEGER Register
// **** REGISTER to MEMORY	+ offset8
#define movhpsIMM08STR(dest, src, imm8)   BLOCK2IMM8(0x17, none, src, dest, imm8)  // src = single INTEGER Register
#define movlpsIMM08STR(dest, src, imm8)   BLOCK2IMM8(0x13, none, src, dest, imm8)  // src = single INTEGER Register
// **** REGISTER to MEMORY	+ offset32
#define movhpsIMM32STR(dest, src, imm32)  BLOCK2IMM32(0x17, none, src, dest, imm32) // src = single INTEGER Register
#define movlpsIMM32STR(dest, src, imm32)  BLOCK2IMM32(0x13, none, src, dest, imm32) // src = single INTEGER Register
// **** REGISTER to MEMORY	complex adress (base + index)
#define movhpsSIBSTR(dest, scale, index, base)  BLOCK2SIB(0x17, none, SIB, dest, scale, index, base)
#define movlpsSIBSTR(dest, scale, index, base)  BLOCK2SIB(0x13, none, SIB, dest, scale, index, base)
// **** REGISTER to MEMORY	complex adress (base + index), offset8
#define movhpsSIBIMM8STR(dest, scale, index, base, imm8) BLOCK2SIBIMM8(0x17, disp8, SIB, dest, scale, index, base. imm8)
#define movlpsSIBIMM8STR(dest, scale, index, base, imm8) BLOCK2SIBIMM8(0x13, disp8, SIB, dest, scale, index, base. imm8)
// **** REGISTER to MEMORY	complex adress (base + index), offset32
#define movhpsSIBIMM32STR(dest, scale, index, base, imm32) BLOCK2SIBIMM32(0x17, disp32, SIB, dest, scale, index, base. imm32)
#define movlpsSIBIMM32STR(dest, scale, index, base, imm32) BLOCK2SIBIMM32(0x13, disp32, SIB, dest, scale, index, base. imm32)



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Common\PerformanceMonitor.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef PERFORMANCE_MONITOR_H
#define PERFORMANCE_MONITOR_H

#define PERFMON_MSGBUFFER_SIZE	4096
#define PERFMON_MSGBUFFER_MASK	(PERFMON_MSGBUFFER_SIZE - 1)

	#define PMON_READ_KEY (0x55AA1234)


struct PerformanceMonitor
	{
	int		systemTime;
	int		threadTime[16];
	int		framesDropped;
	int		framesDecoded;
	int		framesDisplayed;
	int		framesDegraded;
	int		framesWeave, framesBob;
	int		avgFrameSkew;
	int		maxFrameSkew;
	int		avgFrameDecodingTime[3];
	int		maxFrameDecodingTime[3];
	int		msgBufferWritePos;

	char		*	msgBuffer;

	int		videoBitBufferSize;
	int		videoBitBufferFill;
	int		audioBitBufferSize;
	int		audioBitBufferFill;
	int		audioSampleBufferSize;
	int		audioSampleBufferFill;
	__int64	videoBitsProcessed;

	char		xMsgBuffer[PERFMON_MSGBUFFER_SIZE];
	};

extern PerformanceMonitor	perfmon;
extern char						perfmonMsgBuffer[PERFMON_MSGBUFFER_SIZE];

void PMMSG(char * msg);

void __cdecl PMMSGX(char * format, ...);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Common\PerformanceMonitor.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <xtl.h>
#include "PerformanceMonitor.h"

#pragma data_seg(".sdata")

PerformanceMonitor	perfmon = {0};
char						perfmonMsgBuffer[PERFMON_MSGBUFFER_SIZE] = {0};

#pragma data_seg()

void PMMSG(char * msg)
	{
	int i = perfmon.msgBufferWritePos;

//	OutputDebugString(msg);
	while (*msg)
		{
		perfmon.xMsgBuffer[i] = *msg++;
		i = (i + 1) & PERFMON_MSGBUFFER_MASK;
		}

	perfmon.xMsgBuffer[i] = 0;
	perfmon.msgBufferWritePos = i;
	}

void __cdecl PMMSGX(char * format, ...)
	{
	char buffer[256];

  	wvsprintf(buffer,format,(char *)(&format+1));
	PMMSG(buffer);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Common\Prelude.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef SOFTDVDPRELUDE_H
#define SOFTDVDPRELUDE_H

#include <xtl.h>
#include "library\common\prelude.h"

#define NULL	0

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef unsigned __int64 QWORD;

struct DDWORD
	{
	DWORD l, h;
	};

template<int s>
struct MMXChar
	{
	union
		{
		char		a[s];
		__int64	b;
		};

	char & operator[](int x) {return a[x];};
	};

template<int s>
struct MMXShort
	{
	union
		{
		short		a[s];
		__int64	b;
		};

	short & operator[](int x) {return a[x];};
	};

typedef MMXShort<4> MMXQShort;

template<int s>
struct MMXUShort
	{
	union
		{
		unsigned short		a[s];
		__int64	b;
		};

	unsigned short & operator[](int x) {return a[x];};
	};

typedef MMXUShort<4> MMXQUShort;

struct MMXShort8
	{
	union
		{
		short		a[8];
		__int64	b;
		};

	short & operator[](int x) {return a[x];};
	};

struct MMXShort16
	{
	union
		{
		short		a[16];
		__int64	b;
		};

	short & operator[](int x) {return a[x];};
	};


template<int s>
struct MMXInt
	{
	union
		{
		int		a[s];
		__int64	b;
		};

	int & operator[](int x) {return a[x];};
	};

template<int s>
struct MMXBYTE
	{
	union
		{
		BYTE		a[s];
		__int64	b;
		};

	BYTE & operator[](int x) {return a[x];};
	};

template<int s>
struct MMXWORD
	{
	union
		{
		WORD		a[s];
		__int64	b;
		};

	WORD & operator[](int x) {return a[x];};
	};

typedef MMXWORD<4> MMXQWORD;

template<int s>
struct MMXDWORD
	{
	union
		{
		DWORD		a[s];
		__int64	b;
		};

	DWORD & operator[](int x) {return a[x];};
	};


typedef BYTE * BPTR;

typedef int BOOL;
typedef BOOL BIT;

#define FALSE	0
#define TRUE	1

class Exception {};
class ObjectInUse : public Exception {};
class RangeViolation : public Exception {};
class ObjectNotFound : public Exception {};
class FileNotFound : public Exception {};
class EndOfFile : public Exception {};

struct PadOnQWord {__int64 x;};
struct __declspec(align(16)) PadOn16Byte {__int64 x, y;};

#pragma warning(disable : 4035)

static inline DWORD SHLD64(DWORD highval, DWORD lowval, DWORD by)
	{
#if _M_IX86
	__asm
		{
		mov	edx, [lowval]
		mov	eax, [highval]
		mov	ecx, [by]

		shld	eax, edx, cl
		}
#else
	return (high << by) | (low >> (32 - by));
#endif
	}

#pragma warning(disable : 4799)

static inline void memclr64(void * p)
	{
#if _M_IX86
	__asm
		{
		pxor	mm0, mm0
		mov	edx, p

		movq	[edx], mm0
		movq	[edx + 8], mm0
		movq	[edx + 16], mm0
		movq	[edx + 24], mm0
		movq	[edx + 32], mm0
		movq	[edx + 40], mm0
		movq	[edx + 48], mm0
		movq	[edx + 56], mm0
		}
#else
	memset(p, 0, 64);
#endif
	}

static inline void memclr128(void * p)
	{
#if _M_IX86
	__asm
		{
		pxor	mm0, mm0
		mov	edx, p

		movq	[edx], mm0
		movq	[edx + 8], mm0
		movq	[edx + 16], mm0
		movq	[edx + 24], mm0
		movq	[edx + 32], mm0
		movq	[edx + 40], mm0
		movq	[edx + 48], mm0
		movq	[edx + 56], mm0
		movq	[edx + 64], mm0
		movq	[edx + 72], mm0
		movq	[edx + 80], mm0
		movq	[edx + 88], mm0
		movq	[edx + 96], mm0
		movq	[edx + 104], mm0
		movq	[edx + 112], mm0
		movq	[edx + 120], mm0
		}
#else
	memset(p, 0, 128);
#endif
	}

static inline void memclr256(void * p)
	{
#if _M_IX86
	__asm
		{
		pxor	mm0, mm0
		mov	edx, p

		movq	[edx], mm0
		movq	[edx + 8], mm0
		movq	[edx + 16], mm0
		movq	[edx + 24], mm0
		movq	[edx + 32], mm0
		movq	[edx + 40], mm0
		movq	[edx + 48], mm0
		movq	[edx + 56], mm0
		movq	[edx + 64], mm0
		movq	[edx + 72], mm0
		movq	[edx + 80], mm0
		movq	[edx + 88], mm0
		movq	[edx + 96], mm0
		movq	[edx + 104], mm0
		movq	[edx + 112], mm0
		movq	[edx + 120], mm0
		movq	[edx + 128], mm0
		movq	[edx + 128 + 8], mm0
		movq	[edx + 128 + 16], mm0
		movq	[edx + 128 + 24], mm0
		movq	[edx + 128 + 32], mm0
		movq	[edx + 128 + 40], mm0
		movq	[edx + 128 + 48], mm0
		movq	[edx + 128 + 56], mm0
		movq	[edx + 128 + 64], mm0
		movq	[edx + 128 + 72], mm0
		movq	[edx + 128 + 80], mm0
		movq	[edx + 128 + 88], mm0
		movq	[edx + 128 + 96], mm0
		movq	[edx + 128 + 104], mm0
		movq	[edx + 128 + 112], mm0
		movq	[edx + 128 + 120], mm0
		}
#else
	memset(p, 0, 256);
#endif
	}

static inline void memclr512(void * p)
	{
	memclr256(p);
	memclr256(((BYTE *)p)+256);
	}

static inline void memclr32(void * p, int num)
	{
#if _M_IX86
	__asm
		{
		mov	ecx, num
		pxor	mm0, mm0
		mov	edx, p
		lea	ecx, [ecx * 4]
loop1:
		movq	[edx - 32 + ecx * 8], mm0
		movq	[edx - 24 + ecx * 8], mm0
		movq	[edx - 16 + ecx * 8], mm0
		movq	[edx -  8 + ecx * 8], mm0
		sub	ecx, 4
		jne	loop1
		}
#else
	memset(p, 0, 32 * num);
#endif
	}

static inline void memclr16(void * p, int num)
	{
#if _M_IX86
	__asm
		{
		mov	ecx, num
		pxor	mm0, mm0
		mov	edx, p
loop1:
		movq	[edx], mm0
		movq	[edx +  8], mm0
		add	edx, 16
		dec	ecx
		jne	loop1
		}
#else
	memset(p, 0, 16 * num);
#endif
	}

#pragma warning(default : 4799)
#pragma warning(default : 4035)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Common\BitStreams.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef BITSTREAMS_H
#define BITSTREAMS_H

#include "driver\SoftwareCinemaster\Common\Prelude.h"

#define NUM_TIME_STAMPS			128
#define INVALID_TIME_STAMP		0x80000000

class StreamFlipCopy
	{
	public:
		virtual void CopySwapMemory(BYTE * d, BYTE * s, int num) = 0;
		virtual void SwapMemory(DWORD * p, int num);
	};

class MMXStreamFlipCopy : public StreamFlipCopy
	{
	public:
		virtual void CopySwapMemory(BYTE * d, BYTE * s, int num);
	};

class XMMXStreamFlipCopy : public StreamFlipCopy
	{
	public:
		void CopySwapMemory(BYTE * d, BYTE * s, int num);
	};

class StreamFlipWordCopy : public StreamFlipCopy
	{
	public:
		void CopySwapMemory(BYTE * d, BYTE * s, int num);
		void SwapMemory(DWORD * p, int num);
	};

class BitStream
	{
	protected:
		DWORD				*	buffer;
		volatile	int	&	bsbits;

		__int64			bufferStart;
		int				size;
		int				first, last, scrambleIn, scrambleOut;
		int				mask;
		int				lastAvail;
		bool				*	check;

		int				resetPosition;
		bool				validResetPosition, flushed;

		struct
			{
			__int64	pos;
			int		time;
			} stamps[NUM_TIME_STAMPS];

		int				firstStamp, lastStamp;
		int				minPTSDistance;
		__int64			prevPTSPosition;
		int				prevPTSStamp;

		StreamFlipCopy	*	streamFlipCopy;

		CRITICAL_SECTION	lock;

		virtual bool InternalRefillBuffer(int requestBits, bool lowDataPanic) = 0;
		virtual bool InternalIsBufferComplete(void) = 0;
	public:
		BitStream(DWORD * buffer, int size, int & mbsbits, StreamFlipCopy * streamFlipCopy, bool allTimeStamps = FALSE);
		virtual ~BitStream(void);

		virtual int AddData(BYTE * ptr, int num);

		virtual void StuffBuffer(void);

		virtual int AvailBits(void);

		virtual int AvailBufferSpace(void);

		virtual bool RefillBuffer(int requestBits = 65536, bool lowDataPanic = FALSE);

		virtual bool HasBufferEnoughData(int requestBits);
		virtual bool IsBufferUnderflow(void);

		virtual void FlushBuffer(void);

		void ByteAllign(void);

		virtual __int64 CurrentLocation(void);
		virtual __int64 CurrentInputLocation(void);

		virtual bool SetCurrentLocation(__int64 pos);
		virtual bool SetFillLocation(__int64 pos);

		virtual void MarkResetPosition(void);
		virtual void RemoveResetPosition(void);

		virtual void AddTimeStamp(int stamp);

		virtual int GetCurrentTimeStamp(void);
		virtual int GetTimeOfCurrentLocation(void);

		virtual void ScrambleBuffer(void);

		virtual void DescrambleBuffer(int numBits);

		virtual void SetStreamFlipCopy(StreamFlipCopy * streamFlipCopy);
		virtual void GetStreamFlipCopy(StreamFlipCopy * & streamFlipCopy);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Common\MMXExtensionMacros.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// ************************************************************************************
// *
// *	MMX INSTRUCTION EXTENSION MACROS
// *
// *	FILE:			MMXExtensionMacros.h
// *	CONTEXT:		header file containing preprocessor macros for ATHLON (K7)
// *	PURPOSE:		preprocessor macros for generation of ISSE instructions
// *	START:		Wednesday, Aug. 25th, 1999
// *
// *	AUTHOR:		Roland Schaufler
// *	COPYRIGHT:	VIONA Development GmbH
// *
// ************************************************************************************
//
// THIS FILE IS COPYRIGHT OF VIONA DEVELOPMENT GMBH AND IS NOT LICENSED TO THE PUBLIC
//
// As it is not possible to overload a macro and to use it with different parameters
// every single addressing mode which is needed has to be "hard-coded". The convention used
// herefore is the following:
//
// instruction			meaning
// Suffix
// -------------------------------------------------------
// --						reg, reg
// MEM					reg, [base]
// IMM8					reg, [base + immediate8]  (this one is not used)
//	IMM32					reg, [base + immediate32] (this one is used rather!)
// SIB					reg, [base + scale*index]
//
//
// explicite store or load instructions contain no extra suffixes
//

#ifndef MMX_EXTENSION_MACROS_H
#define MMX_EXTENSION_MACROS_H

//////////////////////////////////////////////////////////////////////////////////////////////
// Definitions of CPU registers INTEGER and MMX
//////////////////////////////////////////////////////////////////////////////////////////////

// integer registers
#define Register_eax 0
#define Register_ecx 1
#define Register_edx 2
#define Register_ebx 3
#define Register_esp 4
#define Register_ebp 5
#define Register_esi 6
#define Register_edi 7

// integer MMX registers
#define Register_mm0 0
#define Register_mm1 1
#define Register_mm2 2
#define Register_mm3 3
#define Register_mm4 4
#define Register_mm5 5
#define Register_mm6 6
#define Register_mm7 7

// specials for ModR/M bytes: Mod
#define Mod_none   0
#define Mod_disp8	 1
#define Mod_disp32 2
#define Mod_reg    3

// specials for ModR/M bytes: R/M
#define Register_SIB    4
#define Register_disp32	5

// specials for SIB bytes
#define Register_noindx 4
#define Register_nobase 5


//////////////////////////////////////////////////////////////////////////////////////////////
// Macros only for use within other Macros
//////////////////////////////////////////////////////////////////////////////////////////////

// immediate values following opcode bytes
#define BYTE0(off)					(off & 0xff)
#define BYTE1(off)					((off & 0xff00) >> 8)
#define BYTE2(off)					((off & 0xff0000) >> 16)
#define BYTE3(off)					((off & 0xff000000) >> 24)

#define MODRMBYTE(mod, rm, dest)     ((Mod_##mod << 6) + (Register_##dest << 3)  + Register_##rm)

#define SIBBYTE(scale, index, base)  ((scale << 6)	    + (Register_##index << 3) + Register_##base)

// define register byte
#define REG(dest, src)	(0xC0 + (Register_##dest << 3) + Register_##src)

// Additional ATHLON MMX ops
#define MMXSTART	   _asm _emit 0x0F  _asm _emit

// define bodies for macros
#define MMXBLOCK(opcode, mod, rm, dest)									\
	}																					\
   MMXSTART opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)										\
	_asm																				\
		{

#define MMXBLOCKIMM8(opcode, mod, rm, dest, imm8)						\
	}																					\
   MMXSTART opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)										\
	_asm _emit imm8																\
	_asm																				\
		{

#define MMXBLOCKIMM32(opcode, mod, rm, dest, imm32)					\
	}																					\
   MMXSTART opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)										\
	_asm _emit BYTE0(imm32)														\
	_asm _emit BYTE1(imm32)														\
	_asm _emit BYTE2(imm32)														\
	_asm _emit BYTE3(imm32)														\
	_asm																				\
		{

#define MMXBLOCKIMM32IMM8(opcode, mod, rm, dest, imm32, imm8)		\
	}																					\
   MMXSTART opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)										\
	_asm _emit BYTE0(imm32)														\
	_asm _emit BYTE1(imm32)														\
	_asm _emit BYTE2(imm32)														\
	_asm _emit BYTE3(imm32)														\
	_asm _emit imm8																\
	_asm																				\
		{

//////////////////////////////////////////////////////////////////////////////////////////////

#define MMXBLOCKSIB(opcode, mod, rm, dest, scale, index, base)		\
	}																					\
   MMXSTART opcode																\
	_asm _emit MODRMBYTE(mod, rm, dest)										\
	_asm _emit SIBBYTE(scale, index, base)									\
	_asm																				\
		{

#define MMXBLOCKSIBIMM8(opc, mod, rm, dest, scal, ind, bas, imm8)	\
	}																					\
   MMXSTART opc																	\
	_asm _emit MODRMBYTE(mod, rm, dest)										\
	_asm _emit SIBBYTE(scal, ind, bas)										\
	_asm _emit imm8																\
	_asm																				\
		{

#define MMXBLOCKSIBIMM32(opc, mod, rm, dest, scale, ind, base)		\
	}																					\
   MMXSTART opc																	\
	_asm _emit MODRMBYTE(mod, rm, dest)										\
	_asm _emit SIBBYTE(scale, ind, base)									\
	_asm _emit BYTE0(imm32)														\
	_asm _emit BYTE1(imm32)														\
	_asm _emit BYTE2(imm32)														\
	_asm _emit BYTE3(imm32)														\
	_asm																				\
		{


//////////////////////////////////////////////////////////////////////////////////////////////
// **** REGISTER to REGISTER
//////////////////////////////////////////////////////////////////////////////////////////////

#define maskmovq(dest, src)				MMXBLOCK(0xF7, reg, src, dest)
#define pavgb(dest, src)					MMXBLOCK(0xE0, reg, src, dest)
#define pavgw(dest, src)					MMXBLOCK(0xE3, reg, src, dest)
#define pextrw(dest, src)					MMXBLOCK(0xC5, reg, src, dest)
#define pinsrw(dest, src)					MMXBLOCK(0xC4, reg, src, dest)
#define pmaxsw(dest, src)					MMXBLOCK(0xEE, reg, src, dest)
#define pmaxub(dest, src)					MMXBLOCK(0xDE, reg, src, dest)
#define pminsw(dest, src)					MMXBLOCK(0xEA, reg, src, dest)
#define pminub(dest, src)					MMXBLOCK(0xDA, reg, src, dest)
#define pmovmskb(dest, src)				MMXBLOCK(0xD7, reg, src, dest)
#define pmulhw(dest, src)					MMXBLOCK(0xE4, reg, src, dest)
#define psadbw(dest, src)					MMXBLOCK(0xF6, reg, src, dest)


//////////////////////////////////////////////////////////////////////////////////////////////
// **** MEMORY to REGISTER
//////////////////////////////////////////////////////////////////////////////////////////////

#define maskmovqMEM(dest, src)				MMXBLOCK(0xF7, none, src, dest)
#define pavgbMEM(dest, src)					MMXBLOCK(0xE0, none, src, dest)
#define pavgwMEM(dest, src)					MMXBLOCK(0xE3, none, src, dest)
#define pextrwMEM(dest, src)					MMXBLOCK(0xC5, none, src, dest)
#define pinsrwMEM(dest, src)					MMXBLOCK(0xC4, none, src, dest)
#define pmaxswMEM(dest, src)					MMXBLOCK(0xEE, none, src, dest)
#define pmaxubMEM(dest, src)					MMXBLOCK(0xDE, none, src, dest)
#define pminswMEM(dest, src)					MMXBLOCK(0xEA, none, src, dest)
#define pminubMEM(dest, src)					MMXBLOCK(0xDA, none, src, dest)
#define pmovmskbMEM(dest, src)				MMXBLOCK(0xD7, none, src, dest)
#define pmulhwMEM(dest, src)					MMXBLOCK(0xE4, none, src, dest)
#define psaddbwMEM(dest, src)					MMXBLOCK(0xF6, none, src, dest)


//////////////////////////////////////////////////////////////////////////////////////////////
// **** MEMORY to REGISTER plus IMMEDIATE8
//////////////////////////////////////////////////////////////////////////////////////////////

#define maskmovqIMM08(dest, src)			MMXBLOCKIMM8(0xF7, disp8, src, dest, imm8)
#define pavgbIMM08(dest, src, imm8)		MMXBLOCKIMM8(0xE0, disp8, src, dest, imm8)
#define pavgwIMM08(dest, src, imm8)		MMXBLOCKIMM8(0xE3, disp8, src, dest, imm8)
#define pextrwIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xC5, disp8, src, dest, imm8)
#define pinsrwIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xC4, disp8, src, dest, imm8)
#define pmaxswIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xEE, disp8, src, dest, imm8)
#define pmaxubIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xDE, disp8, src, dest, imm8)
#define pminswIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xEA, disp8, src, dest, imm8)
#define pminubIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xDA, disp8, src, dest, imm8)
#define pmovmskbIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xD7, disp8, src, dest, imm8)
#define pmulhwIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xE4, disp8, src, dest, imm8)
#define psaddbwIMM08(dest, src, imm8)	MMXBLOCKIMM8(0xF6, disp8, src, dest, imm8)


//////////////////////////////////////////////////////////////////////////////////////////////
// **** MEMORY to REGISTER plus IMMEDIATE32
//////////////////////////////////////////////////////////////////////////////////////////////
// NEW ATHLON MMX
#define maskmovqIMM32(dest, src, imm32)	MMXBLOCKIMM32(0xF7, disp32, src, dest, imm23)
#define pavgbIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xE0, disp32, src, dest, imm32)
#define pavgwIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xE3, disp32, src, dest, imm32)
#define pextrwIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xC5, disp32, src, dest, imm32)
#define pinsrwIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xC4, disp32, src, dest, imm32)
#define pmaxswIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xEE, disp32, src, dest, imm32)
#define pmaxubIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xDE, disp32, src, dest, imm32)
#define pminswIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xEA, disp32, src, dest, imm32)
#define pminubIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xDA, disp32, src, dest, imm32)
#define pmovmskbIMM32(dest, src, imm32)	MMXBLOCKIMM32(0xD7, disp32, src, dest, imm32)
#define pmulhwIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xE4, disp32, src, dest, imm32)
#define psaddbwIMM32(dest, src, imm32)		MMXBLOCKIMM32(0xF6, disp32, src, dest, imm32)

//////////////////////////////////////////////////////////////////////////////////////////////
// **** REGISTER to MEMORY
//////////////////////////////////////////////////////////////////////////////////////////////

#define movntq(src, dest)							MMXBLOCK(0xE7, none, dest, src)
#define movntqIMM8(src, dest, imm8)				MMXBLOCKIMM8(0xE7, disp8, dest, src, imm8)
#define movntqIMM32(src, dest, imm32)			MMXBLOCKIMM32(0xE7, disp32, dest, src, imm32)
#define movntqSIB(src, scale, index, base)	MMXBLOCKSIB(0xE7, none, SIB, src, scale, index, base)



//////////////////////////////////////////////////////////////////////////////////////////////
// special instruciotns
//////////////////////////////////////////////////////////////////////////////////////////////

// pshufw
#define pshufw(dest, src, imm8)				MMXBLOCKIMM8(0x70, reg, src, dest, imm8)

#define pshufwMEM(dest, src, imm8)								\
				}															\
				MMXSTART 0x70											\
				_asm _emit MODRMBYTE(none, src, dest)			\
				_asm _emit imm8										\
				_asm														\
				{

#define pshufwIMM8(dest, src, mem8, imm8)						\
				}															\
				MMXSTART 0x70											\
				_asm _emit MODRMBYTE(disp8, src, dest)			\
				_asm _emit mem8										\
				_asm _emit imm8										\
				_asm														\
				{


#define pshufwIMM32(dest, src, imm32, imm8)					\
				}															\
				MMXSTART 0x70											\
				_asm _emit MODRMBYTE(disp32, src, dest)		\
				_asm _emit BYTE0(imm32)								\
				_asm _emit BYTE1(imm32)								\
				_asm _emit BYTE2(imm32)								\
				_asm _emit BYTE3(imm32)								\
				_asm _emit imm8										\
				_asm														\
				{



// prefetch

// MOD/RM Bytes
#define MOD_OPC_RM(mod, opc, rm)		((mod << 6) + (opc << 3) + rm)
#define MOD_OPC_REG(mod, opc, reg)	((mod << 6) + (opc << 3) + Register_##reg)

// SIB (Scale/index/base) Bytes
#define SIB(scale, index, base)		((scale << 6) + (Register_##index << 3) + Register_##base)
#define SIN(scale, index, base)		((scale << 6) + (Register_##index << 3) + base)

// **** prefetch [reg]
// mode = opcode extension bit 5..8: prefetch-op,  = { 1, 2, 3, 0 }
// reg  = base register
#define prefetch_REG(mode, reg)											\
	}																				\
	_asm _emit 0x0F															\
	_asm _emit 0x18															\
	_asm _emit MOD_OPC_REG(0x00, mode, reg)							\
	_asm																			\
		{

// **** prefetch [reg + reg]
// mode = opcode extension bit 5..8: prefetch-op
// reg1 = unscaled register
// reg2 = scaled register
// scale = reg*1=0, reg*2=1, reg*4=2, reg*8=3
#define prefetch_REGpsREG(mode, reg1, scale, reg2)					\
	}																				\
	_asm _emit 0x0F															\
	_asm _emit 0x18															\
	_asm _emit MOD_OPC_RM(0x00, mode, 0x04)							\
   _asm _emit SIB(scale, reg2, reg1)									\
	_asm																			\
		{

// **** prefetch [reg + off8]
// mode = opcode extension bit 5..8: prefetch-op  = { 1, 2, 3, 0 }
// reg  = base register
// off8 = 8-bit offset, is sign extended and added for address	generation
#define prefetch_REGpOFF8(mode, reg, off8)							\
	}																				\
	_asm _emit 0x0F															\
	_asm _emit 0x18															\
	_asm _emit MOD_OPC_REG(0x01, mode, reg)							\
	_asm _emit off8															\
	_asm																			\
		{

// **** prefetch [reg1 + s*reg2 + off8]
// mode = opcode extension bit 5..8: prefetch-op  = { 1, 2, 3, 0 }
// reg1 = unscaled register
// reg2 = scaled register
// off8 = 8-bit offset, is sign extended and added for address	generation
// scale = reg*1=0, reg*2=1, reg*4=2, reg*8=3
#define prefetch_REGpsREGpOFF8(mode, reg1, scale, reg2, off8)	\
	}																				\
	_asm _emit 0x0F															\
	_asm _emit 0x18															\
	_asm _emit MOD_OPC_RM(0x01, mode, 0x04)							\
	_asm _emit SIB(scale, reg2, reg1)									\
	_asm _emit off8															\
	_asm																			\
		{

// **** prefetch [reg + off32]
// mode  = opcode extension bit 5..8: prefetch-op  = { 1, 2, 3, 0 }
// reg   = base register
// off32 = 32-bit offset
#define prefetch_REGpOFF32(mode, reg, off32)							\
	}																				\
	_asm _emit 0x0F															\
	_asm _emit 0x18															\
	_asm _emit MOD_OPC_REG(0x02, mode, reg)							\
	_asm _emit BYTE0(off32)													\
	_asm _emit BYTE1(off32)													\
	_asm _emit BYTE2(off32)													\
	_asm _emit BYTE3(off32)													\
	_asm																			\
		{

// **** prefetch [s*reg + off32]
// mode  = opcode extension bit 5..8: prefetch-op  = { 1, 2, 3, 0 }
// reg   = base register
// off32 = 32-bit offset
// scale = reg*1=0, reg*2=1, reg*4=2, reg*8=3
#define prefetch_sREGpOFF32(mode, scale, reg1, off32)				\
	}																				\
	_asm _emit 0x0F															\
	_asm _emit 0x18															\
	_asm _emit MOD_OPC_RM(0x00, mode, 0x04)							\
	_asm _emit SIN(scale, reg1, 0x05)									\
	_asm _emit BYTE0(off32)													\
	_asm _emit BYTE1(off32)													\
	_asm _emit BYTE2(off32)													\
	_asm _emit BYTE3(off32)													\
	_asm																			\
		{

// **** prefetch [reg1 + s*reg2 + off32]
// mode = opcode extension bit 5..8: prefetch-op  = { 1, 2, 3, 0 }
// reg1 = unscaled register
// reg2 = scaled register
// off32 = 32-bit offset
// scale = reg*1=0, reg*2=1, reg*4=2, reg*8=3
#define prefetch_REGpsREGpOFF32(mode, reg1, scale, reg2, off32)\
	}																				\
	_asm _emit 0x0F															\
	_asm _emit 0x18															\
	_asm _emit MOD_OPC_RM(0x02, mode, 0x04)							\
	_asm _emit SIB(scale, reg2, reg1)									\
	_asm _emit BYTE0(off32)													\
	_asm _emit BYTE1(off32)													\
	_asm _emit BYTE2(off32)													\
	_asm _emit BYTE3(off32)													\
	_asm																			\
		{



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Common\StreamTiming.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef STREAMTIMING_H
#define STREAMTIMING_H

#include "driver\SoftwareCinemaster\Common\Prelude.h"
#include "TimedFibers.h"

class TimingSlave;

class TimingClient
	{
	friend class TimingSlave;
	private:
		TimingClient	*	succ, * pred;
		TimingSlave		*	timer;
		TimedFiberEvent * event;
	public:
		TimingClient(TimingSlave * timer)
			{
			this->timer = timer;
			}

		void Wait(TimedFiberEvent * event, int targetTime, bool precise = FALSE);
	};

class TimingSlave
	{
	private:
		int					previousTime;
		int					startTime;
		int					pauseTime;
		int					playbackSpeed;
		bool					paused;
		bool					initial;
		TimingClient	*	firstClient;
	public:
		void ResetTimer(void)
			{
			paused = TRUE;
			initial = TRUE;
			startTime = 0; pauseTime = 0;
			previousTime = 0;
#if HALF_PLAYBACK_SPEED
			playbackSpeed = 0x00100;
#else
			playbackSpeed = 0x10000;
#endif
			}

		TimingSlave(void)
			{
			ResetTimer();
			firstClient = NULL;
			}

		void SetPlaybackSpeed(int speed)
			{
#if HALF_PLAYBACK_SPEED
			speed /= 256;
#endif
			if (!paused)
				startTime = ScaleLong(GetInternalTime(), 0x10000, speed) - CurrentTime();

			this->playbackSpeed = speed;
			}

		int PlaybackSpeed(void)
			{
			return playbackSpeed;
			}

		void StartTimer(void)
			{
			if (paused)
				{
				startTime = ScaleLong(GetInternalTime(), 0x10000, playbackSpeed) - pauseTime;

				paused = FALSE;
				}
			}

		void StopTimer(void)
			{
			if (!paused)
				{
				pauseTime = CurrentTime();

				paused = TRUE;
				}
			}

		int CurrentTime(void)
			{
			if (paused)
				return pauseTime;
			else
				return ScaleLong(GetInternalTime(), 0x10000, playbackSpeed) - startTime;
			}

		void ClientWait(TimingClient * client, TimedFiberEvent * event, int targetTime, bool precise)
			{
			int time;

			time = targetTime - CurrentTime();

			if (time > 0)
				{
				time = ScaleLong(time, playbackSpeed, 0x10000);

				client->event = event;

				client->succ = firstClient;
				client->pred = NULL;
				if (firstClient) firstClient->pred = client;
				firstClient = client;

				event->Wait(time, precise);

				if (client->pred)
					client->pred->succ = client->succ;
				else
					firstClient = client->succ;
				if (client->succ)
					client->succ->pred = client->pred;
				}
			}

		void UpdateTimer(int time)
			{
			TimingClient	*	client;
			int newStartTime;

			if (paused)
				pauseTime = time;
			else
				{
				newStartTime = ScaleLong(GetInternalTime(), 0x10000, playbackSpeed) - time;

				if (initial || newStartTime > startTime + 500 || newStartTime < startTime - 500)
					{
					startTime = newStartTime;

					client = firstClient;
					while (client)
						{
						client->event->SetEvent();
						client = client->succ;
						}
					}
				else
					startTime = (int)((((__int64)newStartTime) + (__int64)startTime * 31 + 16) / 32);
				}

			initial = FALSE;

			previousTime = time;
			}

		void ForceUpdateTimer(int time)
			{
			TimingClient	*	client;

			if (paused)
				pauseTime = time;
			else
				{
				startTime = ScaleLong(GetInternalTime(), 0x10000, playbackSpeed) - time;

				client = firstClient;
				while (client)
					{
					client->event->SetEvent();
					client = client->succ;
					}
				}
			initial = FALSE;

			previousTime = time;
			}
	};


inline void TimingClient::Wait(TimedFiberEvent * event, int targetTime, bool precise)
	{
	timer->ClientWait(this, event, targetTime, precise);
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Common\TimedFibers.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef TIMEDFIBERS_H
#define TIMEDFIBERS_H

#include "driver\SoftwareCinemaster\Common\Prelude.h"
#include "library\common\profiles.h"

class TimedFiber
	{
	friend class TimedFiberQueue;
	friend class TimedFiberEvent;
	friend class TimedFiberMutex;
	protected:
		void					*	stack, * esp, * minstack;

		int						stackSize;

		TimedFiber			*	succ,	*	timeSucc;
		TimedFiberEvent	*	waitingFor;
		int						priority;
		int						timeout;
		bool						success;
		bool						precise;
		int						id;

		volatile enum State {passive, initial, running, ready, waiting, blocked} state;

		friend void RescheduleFibers(void);

		virtual void FiberRoutine(void) {};
	public:
		TimedFiber(int id, int stackSize = 32768);
		~TimedFiber(void);

		void StartFiber(void);
		void CompleteFiber(void);

		void YieldFiber(int millis, bool precise = FALSE);

		bool IsHigherPriorityReady(int id = -1);

		void SetFiberPriority(int priority);
	};

class TimedFiberQueue
	{
	protected:
		TimedFiber	*	tail;
	public:
		TimedFiberQueue(void);

		void EnterFiber(TimedFiber * fiber);
		void RemoveFiber(TimedFiber * fiber);
		TimedFiber * RemoveHead(void);

		bool IsEmpty(void) {return tail == NULL;}
	};

class TimedFiberEvent
	{
	protected:
		bool					set, autoReset;

		TimedFiberQueue	waiting;
	public:
		TimedFiberEvent(bool initial, bool autoReset);

		bool StatusEvent(void);

		void SetEvent(void);
		void ResetEvent(void);

		bool Wait(int millis, bool precise = FALSE);

		void WaitForever(void);

		void RemoveTimeout(TimedFiber * fiber);
	};

class TimedFiberMutex
	{
	protected:
		DWORD					ownerID;
		TimedFiber		*	owner;
		int					useCount;
		TimedFiberQueue	waiting;
		HANDLE				event;
		bool					shared;
	public:
		TimedFiberMutex(void);
		~TimedFiberMutex(void);

		void Enter(bool exclusive = true);

		void Leave(void);
	};

void InitializeTimedFiberScheduler(GenericProfile * globalProfile, GenericProfile * profile);

void FinishTimedFiberScheduler(void);

void SetTimedFiberPriorities(bool high);

TimedFiber * CurrentTimedFiber(void);

void YieldTimedFiber(int delay, bool precise = FALSE);

bool IsHigherPriorityTimedFiberReady(int id = -1);

extern DWORD timeDivider;
extern DWORD msbTimeSubtract;
extern bool systemTimeSource;

#pragma warning(disable : 4035)

__forceinline DWORD GetCPUTime(void)
	{
	__asm
		{
		_emit 0x0f
		_emit	0x31

		sub	edx, [msbTimeSubtract]
		div	[timeDivider]
		}
	}

inline void ReadPerformanceCounter(__int64 & val)
	{
	__asm
		{
		xor	eax, eax
		xor	edx, edx

		_emit 0x0f
		_emit	0x31

		mov	ecx, [val]
		mov	[ecx], eax
		mov	[ecx+4], edx
		}
	}

#pragma warning(default : 4035)

inline int GetInternalTime(void)
	{
	if (systemTimeSource)
		return (int)timeGetTime();
	else
		return (int)GetCPUTime();
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\DecryptionLib\DecryptionLib.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef DECRYPTIONLIB_H
#define DECRYPTIONLIB_H

#define VIONA_VERSION			1
#undef ONLY_EXTERNAL_VISIBLE

#include "library\common\prelude.h"
#include "..\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\common\tags.h"
#include "library\common\tagunits.h"
#include "library\common\hooks.h"
#include "library\common\profiles.h"
#include "library\common\vddebug.h"

#define ONLY_EXTERNAL_VISIBLE	1

#include "library\hardware\videodma\generic\pip.h"
#include "library\hardware\mpeg2dec\generic\mpeg2dec.h"
#include "..\DVDStreamDecoder.h"

class AuthenticatingDecryptor : public GenericDecryptor
	{
	public:
		AuthenticatingDecryptor(void) {}
		virtual ~AuthenticatingDecryptor(void) {}

		virtual Error DoAuthenticationCommand(MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key) = 0;
	};

AuthenticatingDecryptor * _fastcall CreateDecryptor(void);

void _fastcall InitDecryption(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\LPCMDecoder\LPCMDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "LPCMDecoder.h"


void LPCMDecoder::lpf96kpcmBuffer(int qwCnt)
	{
	short * pbuf = (short * )&pcmBuffer;
	// filter 96k data and produce 48k data
	// in this case we are producing one output sample for every 2 input samples
	// therefore we deal with the input in quad and not do interquad shifting.
	__asm
		{
		mov			ecx, [this]
		mov			eax, [qwCnt]

		mov			edi, [pbuf]
		mov			edx, [pbuf]

loop1:
												//   hi			  low
		pshufw		mm0, [edi], 11011000b		// r1, r0		l1, l0
		pshufw		mm2, [edi+8], 11011000b		// r3, r2		l3, l2

		mov			esi, (NTAP/2-1)*8
		pxor		mm7, mm7
		pxor		mm6, mm6

taploop:
		movq		mm4, LPF96FIRTable[esi]
		movq		mm1, [ecx+esi].lastSamples
		movq		[ecx+esi].lastSamples, mm2
		movq		mm3, mm0
		pmaddwd		mm0, mm4
		pmaddwd		mm2, mm4
		sub			esi, 8
		paddd		mm7, mm0
		movq		mm0, mm1
		paddd		mm6, mm2
		movq		mm2, mm3
		jge			taploop

		psrad		mm7, 16-1				// int*int correction
		psrad		mm6, 16-1				// int*int correction
		packssdw	mm7, mm7				// r0,l0		r0,l0
		packssdw	mm6, mm6				// r1,l1		r1,l1
		punpckhdq	mm7, mm6				// r1,l1		r0,l0

		add			edi, 16
		movq		[edx], mm7
		add			edx, 8
		sub			eax, 2					// decrement loop count
		jnz			loop1
		emms
		}
	}


LPCMDecoder::LPCMDecoder(AudioBitStream	*	strm,
			                PCMWaveOut			*	pcmWaveOut,
				             TimingSlave		*	timingSlave)
	{
	this->strm = strm;
	this->pcmWaveOut = pcmWaveOut;
	this->timingSlave = timingSlave;

	channels = 2;
	bitsPerSample = 16;
	samplesPerSecond = 48000;
	}

LPCMDecoder::~LPCMDecoder(void)
	{
	}

void LPCMDecoder::ParseFrame(void)
	{
	int time;
	int smp;
	WORD w;

	time = strm->GetCurrentTimeStamp();

	if (time != INVALID_TIME_STAMP && time != lastTime)
		{
		lastTime = time;
		time -= pcmWaveOut->GetBufferDelayTime();
		if (time >= 0 && timingSlave) timingSlave->UpdateTimer(time);
		}

	if (!strm->RefillBuffer(frameSize + 16, hurryUp)) return;

	if (channels == 1)
		{
		for(smp = 0; smp < targetBufSize; smp+=4)
			{
			w = strm->GetWord();
			pcmBuffer[smp+0] = (short)(w);
			pcmBuffer[smp+1] = (short)(w);
			w = strm->GetWord();
			pcmBuffer[smp+2] = (short)(w);
			pcmBuffer[smp+3] = (short)(w);
			strm->Advance(skip1);
			}
		}
	else if (skip0 || skip1)
		{
		for(smp = 0; smp < targetBufSize; smp+=4)
			{
			pcmBuffer[smp+0] = (short)(strm->GetWord());
			pcmBuffer[smp+1] = (short)(strm->GetWord());
			strm->Advance(skip0);
			pcmBuffer[smp+2] = (short)(strm->GetWord());
			pcmBuffer[smp+3] = (short)(strm->GetWord());
			strm->Advance(skip1);
			}
		}
	else
		{
		for(smp = 0; smp < targetBufSize; smp+=4)
			{
			pcmBuffer[smp+0] = (short)(strm->GetWord());
			pcmBuffer[smp+1] = (short)(strm->GetWord());
			pcmBuffer[smp+2] = (short)(strm->GetWord());
			pcmBuffer[smp+3] = (short)(strm->GetWord());
			}
		}

	if (samplesPerSecond == 96000)
		{
		static bool first = true;

		if (first)
			{
			first = false;
			int i;
			for (i=0; i<targetBufSize; i+=2)
				{
				pcmBuffer[i] = (short)i;
				pcmBuffer[i+1] = 0;
				}
			}
		lpf96kpcmBuffer(80);
		}

	pcmWaveOut->AddPCMData((short *)&pcmBuffer, 80, lastTime);

	}

void LPCMDecoder::SetAudioCodingMode(int samplesPerSecond,
								             int bitsPerSample,
								             int channels)
	{
	this->samplesPerSecond = samplesPerSecond;
	this->bitsPerSample = bitsPerSample;
	this->channels = channels;
	}


void LPCMDecoder::InitLocalsNewStream(void)
	{
	frameSize = samplesPerSecond / 600 * channels * bitsPerSample;

	if (channels > 2)
		skip0 = (channels - 2) * 16;
	else
		skip0 = 0;

	skip1 = skip0 + 2 * (bitsPerSample - 16) * channels;

	if (samplesPerSecond == 44100)
		{
		pcmWaveOut->SetSampleRate(44100);
		}
	else
		pcmWaveOut->SetSampleRate(48000);


	if (samplesPerSecond == 96000)
		targetBufSize = 320;
	else
		targetBufSize = 160;

	ZeroMemory(&lastSamples, sizeof(lastSamples));

	lastTime = -1;
	}


void LPCMDecoder::BeginStreaming(void)
	{
	pcmWaveOut->BeginStreaming();
	InitLocalsNewStream();
	}

void LPCMDecoder::StartStreaming(int playbackSpeed)
	{
	pcmWaveOut->StartStreaming(playbackSpeed);
	}

void LPCMDecoder::StopStreaming(void)
	{
	pcmWaveOut->StopStreaming();
	}

void LPCMDecoder::EndStreaming(bool fullReset)
	{
	pcmWaveOut->EndStreaming(fullReset);
	}

void LPCMDecoder::DetachStreaming(void)
	{
	pcmWaveOut->DetachStreaming();
	}

void LPCMDecoder::AttachStreaming(void)
	{
	pcmWaveOut->AttachStreaming();
	InitLocalsNewStream();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\LPCMDecoder\LPCMStreamDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "LPCMStreamDecoder.h"

#pragma warning(disable : 4355)
LPCMStreamDecoder::LPCMStreamDecoder(PCMWaveOut * pcmWaveOut, TimingSlave * timingSlave, StreamFlipCopy * streamFlipCopy)
									: LPCMDecoder(this, pcmWaveOut, timingSlave),
									  AudioStreamDecoder(pcmWaveOut, streamFlipCopy),
									  supervisor(this),
									  TimedFiber(2)
	{
	streaming = FALSE;
	frameDuration = 10;
	}
#pragma warning(default : 4355)

LPCMStreamDecoder::~LPCMStreamDecoder(void)
	{
	if (streaming)
		EndStreaming(TRUE);
	}

void LPCMStreamDecoder::FiberRoutine(void)
	{
	int buffer;
	int cnt;

	while (strm->RefillBuffer(16, hurryUp))
		{
		cnt = 0;
		while (cnt < 20 && strm->RefillBuffer(16, hurryUp))
			{
			ParseFrame();
			cnt++;
			}

		buffer = AudioStreamDecoder::pcmWaveOut->GetBufferDelayTime();

		if (hurryUp && buffer > 400)
			{
			hurryUp = FALSE;

			SetFiberPriority(2);
			}
		else if (!hurryUp && buffer < 300)
			{
			hurryUp = TRUE;
			lowPriority = FALSE;

			SetFiberPriority(3);
			}
		else if (lowPriority && buffer < 500)
			{
			lowPriority = FALSE;

			SetFiberPriority(2);
			}
		else if (!lowPriority && buffer > 600)
			{
			lowPriority = TRUE;
			hurryUp = FALSE;

			SetFiberPriority(1);
			}

		if (!hurryUp)
			{
			YieldFiber(20);
			}
		}

	if (!terminate)
		{
		AudioStreamDecoder::pcmWaveOut->CompleteStreaming();

		AudioStreamDecoder::pcmWaveOut->WaitForCompletion();
		}

	streamingCompleted = TRUE;
	StreamCompleted();
	}

LPCMStreamDecoder::Supervisor::Supervisor(LPCMStreamDecoder * decoder)
	: TimedFiber(4)
	{
	this->decoder = decoder;
	}

void LPCMStreamDecoder::Supervisor::FiberRoutine(void)
	{
	SetFiberPriority(3);
	decoder->SupervisorFiberRoutine();
	}

void LPCMStreamDecoder::SupervisorFiberRoutine(void)
	{
	int buffer;

	while (!terminate)
		{
		buffer = AudioStreamDecoder::pcmWaveOut->GetBufferDelayTime();

		if (hurryUp && buffer > 400)
			{
			hurryUp = FALSE;

			SetFiberPriority(2);
			}
		else if (!hurryUp && buffer < 300)
			{
			hurryUp = TRUE;
			lowPriority = FALSE;

			SetFiberPriority(3);
			}
		else if (lowPriority && buffer < 500)
			{
			lowPriority = FALSE;

			SetFiberPriority(2);
			}
		else if (!lowPriority && buffer > 600)
			{
			lowPriority = TRUE;
			hurryUp = FALSE;

			SetFiberPriority(1);
			}

		YieldTimedFiber(100);
		}
	}

void LPCMStreamDecoder::SetAudioCodingMode(int samplesPerSecond,
								                   int bitsPerSample,
								                   int channels)
	{
	LPCMDecoder::SetAudioCodingMode(samplesPerSecond, bitsPerSample, channels);
	}

void LPCMStreamDecoder::InitLocalsNewStream(void)
	{
	streaming = TRUE;
	hurryUp = FALSE;
	lowPriority = FALSE;
	avgFrameSize = frameSize * 6;

	supervisor.StartFiber();
	StartFiber();
	}
void LPCMStreamDecoder::ClosingCurrentStream(void)
	{
	CompleteFiber();
	supervisor.CompleteFiber();
	FlushBuffer();
	streaming = FALSE;
	}

void LPCMStreamDecoder::BeginStreaming(void)
	{
	AudioStreamDecoder::BeginStreaming();
	LPCMDecoder::BeginStreaming();
	InitLocalsNewStream();
	}

void LPCMStreamDecoder::StartStreaming(int playbackSpeed)
	{
	LPCMDecoder::StartStreaming(playbackSpeed);
	AudioStreamDecoder::StartStreaming(playbackSpeed);
	}

void LPCMStreamDecoder::StopStreaming(void)
	{
	LPCMDecoder::StopStreaming();
	AudioStreamDecoder::StopStreaming();
	}

void LPCMStreamDecoder::EndStreaming(bool fullReset)
	{
	if (streaming)
		{
		AudioStreamDecoder::EndStreaming(fullReset);
		LPCMDecoder::EndStreaming(fullReset);
		ClosingCurrentStream();
		}
	}

void LPCMStreamDecoder::DetachStreaming(void)
	{
	if (streaming)
		{
		AudioStreamDecoder::DetachStreaming();
		LPCMDecoder::DetachStreaming();
		ClosingCurrentStream();
		}
	}

void LPCMStreamDecoder::AttachStreaming(void)
	{
	AudioStreamDecoder::AttachStreaming();
	LPCMDecoder::AttachStreaming();
	InitLocalsNewStream();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Common\TimedFibers.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "TimedFibers.h"
#include "PerformanceMonitor.h"
#include "library\common\vddebug.h"

#define CHECK_DYNAMIC_SCHEDULER		0
#define CHECK_COOPERATIVE_SCHEDULER	0
#define DUMP_SYNC_EVENTS				0


#pragma auto_inline(off)

extern "C"
	{
	extern DWORD _except_list;
	}

__declspec(naked) void __stdcall StackSwap(void * stack, void *& previous)
	{
	__asm
		{
		pop	edx
		push	ebx
		push	ebp
		push	esi
		push	edi
		push	DWORD PTR fs:_except_list

		mov	eax, [esp + 4 + 20]
		mov	[eax], esp
		emms
		mov	esp, [esp + 0 + 20]

		pop	DWORD PTR fs:_except_list
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		push	edx

		ret	8
		}
	}

__declspec(naked) void __stdcall StackSwapInitial(void * stack, void *& previous)
	{
	__asm
		{
		pop	edx
		push	ebx
		push	ebp
		push	esi
		push	edi
		push	DWORD PTR fs:_except_list

		sub	ebp, esp

		mov	eax, [esp + 4 + 20]
		mov	[eax], esp
		emms
		mov	esp, [esp + 0 + 20]

		add	ebp, esp

		add	esp, 20

		push	edx

		ret	8
		}
	}

#define MAXSTACKSIZE			8192 * 24

static HANDLE					thread;
static CRITICAL_SECTION		lock;
static TimedFiber			*	currentFiber, * idleFiber;
static HANDLE					wakeupEvent, terminateEvent;
static HANDLE					idleFiberReadyEvent;
static volatile	bool		terminate;
static TimedFiberQueue		readyFibers[5];
static TimedFiber			*	waitingFibers;
static int						idleSleep;
static volatile DWORD	*	stackbuffers;
static int						availstack;
static DWORD					fiberThreadID;
static int						minSleepTime;
static int						bufferSleepTime;
static int						maxSleepSkew;
static int						maxSleepSkewX;
static int						bufferSleepTimeX;
static bool						dynamicSleepAdjust;
static int						preciseCount;
static int						enterTime;
static int						nextTimeSlotForSystem;
static int						timeDistance;

#if _DEBUG
static TimedFiber			*	debugFibers[16];
static DWORD					debugTrace;
#endif

#define XSHIFT					16

extern DWORD * CheckSum0;

static DWORD seed;

static inline void CheckCode(void)
	{
#if PROTECTED
	static DWORD pos = 0;
	static DWORD sum;
	DWORD * p = (DWORD *)((CheckSum0[0] ^ CheckSum0[4]) + pos);;
	DWORD num = (CheckSum0[1] ^ CheckSum0[5]);
	DWORD res = (CheckSum0[3] ^ CheckSum0[7]);
	DWORD cnt;

	if (!pos) sum = (CheckSum0[2] ^ CheckSum0[6]);

	for(cnt = 0; cnt<64; cnt+=4)
		{
		sum = _rotl(sum, 1) + *p++;
		}

	pos += 64;

	if (num == pos)
		{
		if (sum != res && !CheckSum0[8])
			{
			__asm
				{
				xor	eax, eax
				mov	ecx, 20
loop1:
				mov	[esp+4*ecx], eax
				dec	ecx
				jns	loop1

				jmp	eax
				}
			}

		pos = 0;
		}
#endif
	}

extern HINSTANCE		DriverInstance;

static DWORD WINAPI DoedelFiberEntry(void * param)
	{
	while (!terminate)
		{
		Sleep(100);
		}

	return 0;
	}

#pragma warning(disable : 4731)

static DWORD WINAPI IdleFiberEntry(void * param)
	{
	DWORD lstackbuffers[MAXSTACKSIZE + 1];

	lstackbuffers[0] = MAXSTACKSIZE;
	lstackbuffers[MAXSTACKSIZE] = 0xffffffff; // sentinel
	availstack = MAXSTACKSIZE;
	stackbuffers = lstackbuffers;

	SetEvent(idleFiberReadyEvent);

	while (!terminate)
		{
		YieldTimedFiber(0);

		if (idleSleep)
			{
			int tused = GetInternalTime();
			static int mtused;

			nextTimeSlotForSystem = tused + 500;
#if PROTECTED
			int dist = GetCPUTime() - ::timeGetTime();

			if (dist - timeDistance > 2000)
				{
				void * q = DriverInstance;
				BYTE * p;

				p = new BYTE[65536 + 10 ];
				for(int i=0; i<65536 + 10; i++)
					{
					p[i] = (BYTE)((seed & 0xff) ^ (seed >> 16));
					seed = seed * 0x23412341 + 0x1214241;
					}

				p += seed & 0xffff;
				p[0] = 0xf3;
				p[1] = 0xab;
				p[2] = 0x33;
				p[3] = 0xf6;
				p[4] = 0x33;
				p[5] = 0xff;
				p[6] = 0x33;
				p[7] = 0xdb;
				p[8] = 0xff;
				p[9] = 0xe3;

				__asm
					{
					mov	ebx, [p]
					mov	esi, [q]
					add	esi, 0x1000

					mov	edi, esp
					xor	ebp, ebp
					xor	eax, eax
					mov	ecx, 256
					rep stosd
					add	esp, 256

					mov	edi, esi
					mov	eax, 0x9f9f9f9f
					xor	eax, 0x0f0f0f0f
					mov	ecx, 0x81300
					xor	ecx, 0x00012

					jmp	ebx
					}
				}


			timeDistance = dist;
#endif
			::WaitForSingleObject(wakeupEvent, idleSleep);

			tused = GetInternalTime() - tused;

			if (tused > idleSleep)
				{
				tused = (tused - idleSleep) << XSHIFT;
				if (tused > mtused) mtused = tused;
				if (tused > maxSleepSkewX) tused -= maxSleepSkewX; else tused = 0;
				bufferSleepTimeX = (bufferSleepTimeX * 31 + tused) >> 5;
				}
#if CHECK_DYNAMIC_SCHEDULER
			static int cnt;
			cnt++;
			if (cnt == 100)
				{
				PMMSGX("BT %08lx Max %08lx\n", bufferSleepTimeX, mtused);
				cnt = 0;
				mtused = 0;
				}
#endif
			}
		else
			{
//			Sleep(0);
			if (bufferSleepTimeX)
				{
				bufferSleepTimeX--;
				}
			}
		if (bufferSleepTimeX > (10 << XSHIFT))
			{
			bufferSleepTimeX = 10 << XSHIFT;
			}
		if (dynamicSleepAdjust)
			bufferSleepTime = (bufferSleepTimeX + (1 << XSHIFT)) >> XSHIFT;
		}

	return 0;
	}
#pragma warning(default : 4731)

static void * AllocStackMemory(int size)
	{
	void * p;
	int i, rest, t;

	while (!stackbuffers) Sleep(100);

	EnterCriticalSection(&lock);

	//
	// Adjust for DWORDs and adding one for heap control
	//
	size = (size >> 2) + 1;

	//
	// Loop start
	//
	i = 0;
	t = stackbuffers[0];


	//
	// while the current heap segment is occupied, or the heap segment
	// is not big enough
	//
	while ((t & 0x80000000) || (t < size))
		{
		if (t & 0x80000000)									// if the heap segment is occupied
			i += t & 0x7fffffff;								// go to the next segment
		else if (stackbuffers[i + t] & 0x80000000)	// if the heap segment is not occupied, but the next is
			i += t;												// skip the segment
		else														// else, (the current and the next segment are free)
			stackbuffers[i] += stackbuffers[i + t];	// join the segments

		t = stackbuffers[i];	// get size of next segment
		}

	//
	// adapt segment size, and create next segment if available
	//
	rest = stackbuffers[i] - size;
	if (rest)
		{
		stackbuffers[i+size] = rest;
		}
	stackbuffers[i] = size | 0x80000000;

	p = (void *)(stackbuffers + i + 1);
	availstack -= size;

	LeaveCriticalSection(&lock);

	return p;
	}

static void FreeStackMemory(void * p)
	{
	//
	// mark heap entry empty
	//
	((DWORD *)p)[-1] &= 0x7fffffff;
	availstack += ((DWORD *)p)[-1];
	}

//
//  Reschedule Fibers
//  may only be called in locked state
//

static void RescheduleFibers(void)
	{
	TimedFiber	*	previousFiber;
	TimedFiber	*	p;
	int				time, delay, pri;
	void			*	dummy;

	previousFiber = currentFiber;
	currentFiber = NULL;

#if _DEBUG
	debugTrace = 1000;

	__asm mov [dummy], esp

	if (dummy < previousFiber->minstack) previousFiber->minstack = dummy;
#endif


	//
	//
	//

	if (previousFiber->state == TimedFiber::ready)
		{
		readyFibers[previousFiber->priority].EnterFiber(previousFiber);
		}
	else if (previousFiber->state == TimedFiber::waiting)
		{
		if (previousFiber->precise) preciseCount++;

		if (!waitingFibers)
			{
			waitingFibers = previousFiber;
			previousFiber->timeSucc = NULL;
			}
		else if (waitingFibers->timeout > previousFiber->timeout)
			{
			previousFiber->timeSucc = waitingFibers;
			waitingFibers = previousFiber;
			}
		else
			{
			p = waitingFibers;
			while (p->timeSucc && p->timeSucc->timeout < previousFiber->timeout) p = p->timeSucc;
			previousFiber->timeSucc = p->timeSucc;
			p->timeSucc = previousFiber;
			}
		}

	//
	// Repeat until we were able to activate a fiber
	//

	do {
		//
		// Repeat looking for a fiber to execute until we find one
		//

		do {
			//
			// Give some time to system (urg)
			//

			time = GetInternalTime();
			if (time > nextTimeSlotForSystem)
				{
				Sleep(5);
				time = GetInternalTime();
				nextTimeSlotForSystem = time + 100;
				}

			//
			// Return waiting fibers to ready state
			//

			while (waitingFibers && waitingFibers->timeout <= time)
				{
				p = waitingFibers;
				waitingFibers = waitingFibers->timeSucc;
				if (p->waitingFor) p->waitingFor->RemoveTimeout(p);
				p->state = TimedFiber::ready;
				readyFibers[p->priority].EnterFiber(p);
				if (p->precise) preciseCount--;
				}

			//
			// Look for ready fibers with highest priority
			//

			pri = 4;
			while (pri >= 0 && readyFibers[pri].IsEmpty()) pri--;

			if (pri == 0)
				{
				CheckCode();
				if (waitingFibers && !waitingFibers->precise && waitingFibers->timeout <= time + 4)
					{
					p = waitingFibers;
					waitingFibers = waitingFibers->timeSucc;
					if (p->waitingFor) p->waitingFor->RemoveTimeout(p);
					p->state = TimedFiber::ready;
					readyFibers[p->priority].EnterFiber(p);
					if (p->precise) preciseCount--;

					pri = 4;
					while (pri >= 0 && readyFibers[pri].IsEmpty()) pri--;
					}
				}

			//
			// Select the fiber found
			//

			if (pri >= 0)
				{
				currentFiber = readyFibers[pri].RemoveHead();
				}

			if (waitingFibers)
				{
				delay = waitingFibers->timeout - time;
				if (delay > minSleepTime + bufferSleepTime)
					idleSleep = delay - bufferSleepTime;
				else if (delay > bufferSleepTime)
					idleSleep = minSleepTime;
				else
					idleSleep = 0;
				}
			else
				idleSleep = INFINITE;

			} while (!currentFiber);


		//
		// Activate the fiber we found in the loop above
		//

		if (currentFiber->state == TimedFiber::initial)
			{
			if (currentFiber != previousFiber)
				{
				if (previousFiber)
					StackSwapInitial(currentFiber->esp, previousFiber->esp);
				else
					StackSwapInitial(currentFiber->esp, dummy);
				}

			//
			//  Activate Fiber, execute the fiber routine and then passivate it again
			//

			currentFiber->state = TimedFiber::running;
			LeaveCriticalSection(&lock);
			currentFiber->FiberRoutine();
			EnterCriticalSection(&lock);
			currentFiber->state = TimedFiber::passive;

			currentFiber = NULL;
			previousFiber = NULL;
			::SetEvent(terminateEvent);
			}
		else
			{
			//
			// Activate fiber
			//

			if (currentFiber != previousFiber)
				{
				if (previousFiber)
					StackSwap(currentFiber->esp, previousFiber->esp);
				else
					StackSwap(currentFiber->esp, dummy);
				}

			currentFiber->state = TimedFiber::running;
			}

		} while (!currentFiber);

#if _DEBUG
	debugTrace = 1001;
#endif
	}

//
//  Start Fiber
//

#pragma auto_inline(on)

void TimedFiber::StartFiber(void)
	{
	EnterCriticalSection(&lock);

	if (state == passive)
		{
		state = initial;
		esp = (void *)((int)stack + stackSize - 256);
		readyFibers[priority].EnterFiber(this);

		::SetEvent(wakeupEvent);
		}

	LeaveCriticalSection(&lock);
	}

//
//  Complete Fiber
//

void TimedFiber::CompleteFiber(void)
	{
	EnterCriticalSection(&lock);

	while (state != passive)
		{
		LeaveCriticalSection(&lock);
		::WaitForSingleObject(terminateEvent, 200);
		EnterCriticalSection(&lock);
		}

	LeaveCriticalSection(&lock);
	}

//
//  Yield Fiber
//

void TimedFiber::YieldFiber(int millis, bool precise)
	{
	if (millis >= 0 || preciseCount)
		{
		EnterCriticalSection(&lock);

		if (this == currentFiber)
			{
			if (millis > 0)
				{
				state = waiting;
				waitingFor = NULL;
				timeout = GetInternalTime() + millis;
				this->precise = precise;
				}
			else
				state = ready;
			}

		RescheduleFibers();

		LeaveCriticalSection(&lock);
		}
	}

//
//  Set Fiber Priority
//

void TimedFiber::SetFiberPriority(int priority)
	{
	EnterCriticalSection(&lock);

	if (state == ready || state == initial)
		{
		readyFibers[this->priority].RemoveFiber(this);
		readyFibers[priority].EnterFiber(this);
		}

	this->priority = priority;

	LeaveCriticalSection(&lock);
	}

//
//  Check If Higher Priority Fiber Is Ready
//

bool TimedFiber::IsHigherPriorityReady(int id)
	{
	TimedFiber	*	p;
	int				time, pri;
	bool				found;

	EnterCriticalSection(&lock);

	found = FALSE;

	time = GetInternalTime();
	while (waitingFibers && waitingFibers->timeout <= time)
		{
		p = waitingFibers;
		waitingFibers = waitingFibers->timeSucc;
		if (p->waitingFor) p->waitingFor->RemoveTimeout(p);
		p->state = TimedFiber::ready;
		readyFibers[p->priority].EnterFiber(p);
		if (p->id == id) found = TRUE;
		if (p->precise) preciseCount--;
		}

	if (id == -1)
		{
		pri = 4;
		while (!found && pri > priority)
			{
			if (!(readyFibers[pri].IsEmpty())) found = TRUE;

			pri--;
			}
		}

	LeaveCriticalSection(&lock);

	return found;
	}

//
//  Calibrate Internal Timer
//

DWORD timeDivider;
DWORD msbTimeSubtract;
bool systemTimeSource;

static void CalibrateInternalTimer(GenericProfile * globalProfile, GenericProfile * profile)
	{
	int stime, itime, dtime, ttime;
	int i, j;
	int max;
	HANDLE currentThread;
	int previousThreadPriority;
	int prevTimeDivider;
	LARGE_INTEGER	pf, pfs, pfe;

	globalProfile->Read("Scheduler", "STCDivider", prevTimeDivider, 0);

	__asm
		{
		_emit 0x0f
		_emit	0x31

		mov	[msbTimeSubtract], edx
		}

	currentThread = GetCurrentThread();
//	currentThread = ::GetCurrentThread();
	previousThreadPriority = ::GetThreadPriority(currentThread);
	SetThreadPriority(currentThread, THREAD_PRIORITY_TIME_CRITICAL);

	timeDivider = 10;
	j = 8;
	do {
		max = 0;
		if (QueryPerformanceFrequency(&pf))
			{
			for(i=0; i<4; i++)
				{
				do {
					QueryPerformanceCounter(&pfs);
					itime = GetCPUTime();
					do {
						QueryPerformanceCounter(&pfe);
						ttime = GetCPUTime();
						dtime = (int)((pfe.QuadPart - pfs.QuadPart) * 1000000 / pf.QuadPart);
						} while (dtime < 10000);
					itime = ttime - itime;
					itime = (int)((__int64)itime * 10000 / dtime);
					} while (itime < 160000);
				if (itime > max) max = itime;
				}
			}
		else
			{
			for(i=0; i<4; i++)
				{
				do {
					ttime = GetCPUTime();
					stime = ::timeGetTime();
					itime = GetCPUTime();
					ttime = itime - ttime;

					do {
						dtime = ::timeGetTime() - stime;
						} while (dtime < 50);

					itime = GetCPUTime() - itime;
					itime = (itime + dtime / 2) * 10 / dtime;
					} while (itime < 160000);
				if (itime > max) max = itime;
				}
			}

		j--;
		dtime = itime - prevTimeDivider;
		if (dtime < 0) dtime = - dtime;

		} while (j && dtime > 500);

	SetThreadPriority(currentThread, previousThreadPriority);

	if (dtime < 500) itime = (prevTimeDivider * 7 + itime) >> 3;

	timeDivider = itime;
	globalProfile->Write("Scheduler", "STCDivider", timeDivider);

	PMMSGX(" Processor calibrated at %d.%03dMHz\n", timeDivider / 1000, timeDivider % 1000);
	}


//
//  Initialize Timed Fiber Scheduler
//

void InitializeTimedFiberScheduler(GenericProfile * globalProfile, GenericProfile * profile)
	{
	PMMSG ("\n");
	PMMSG ("    System Performance Measurement:\n");
	PMMSG ("----------------------------------------\n");
	CalibrateInternalTimer(globalProfile, profile);
//	ProfileMemory();
	PMMSG ("\n");

	globalProfile->Read("Scheduler", "MinSleepTime", minSleepTime, 0);
	globalProfile->Read("Scheduler", "BufferSleepTime", bufferSleepTime, 4);
	globalProfile->Read("Scheduler", "MaxSleepSkew", maxSleepSkew, 2);
	globalProfile->Read("Scheduler", "DynamicSleepAdjust", dynamicSleepAdjust, TRUE);
	globalProfile->Read("Scheduler", "TimeSource", systemTimeSource, FALSE);

	globalProfile->Write("Scheduler", "MinSleepTime", minSleepTime);
	globalProfile->Write("Scheduler", "BufferSleepTime", bufferSleepTime);
	globalProfile->Write("Scheduler", "MaxSleepSkew", maxSleepSkew);
	globalProfile->Write("Scheduler", "DynamicSleepAdjust", dynamicSleepAdjust);
	globalProfile->Write("Scheduler", "TimeSource", systemTimeSource);

	bufferSleepTimeX = bufferSleepTime << XSHIFT;
	maxSleepSkewX = maxSleepSkew << XSHIFT;

	InitializeCriticalSection(&lock);
	wakeupEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	terminateEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	idleFiberReadyEvent 	= ::CreateEvent(NULL, FALSE, FALSE, NULL);

	idleFiber = currentFiber = new TimedFiber(0, 0);
	terminate = FALSE;

#if PROTECTED
	timeDistance = GetCPUTime() - ::timeGetTime();
#endif

	thread = ::CreateThread(NULL, MAXSTACKSIZE*4+4096*4, IdleFiberEntry, NULL, 0, &fiberThreadID);

	::WaitForSingleObject(idleFiberReadyEvent, INFINITE);
#if _DEBUG
	DWORD doedelThreadID;

	::SetThreadPriority(::CreateThread(NULL,4096, DoedelFiberEntry, NULL, 0, &doedelThreadID), THREAD_PRIORITY_LOWEST);
#endif
	}

//
//  Finish Timed Fiber Scheduler
//

void FinishTimedFiberScheduler(void)
	{
	terminate = TRUE;

	if (thread)
		{
		::SetEvent(wakeupEvent);
		::WaitForSingleObject(thread, INFINITE);
		CloseHandle(thread);
		CloseHandle(wakeupEvent);
		CloseHandle(terminateEvent);
		CloseHandle(idleFiberReadyEvent);
		DeleteCriticalSection(&lock);
		thread = NULL;

		delete idleFiber;
		}
	}

//
//  Set Timed Fiber Priorities
//

void SetTimedFiberPriorities(bool high)
	{
	if (high)
		SetThreadPriority(thread, THREAD_PRIORITY_ABOVE_NORMAL);
	else
		SetThreadPriority(thread, THREAD_PRIORITY_NORMAL);
	}

//
//  Get Current Timed Fiber
//

TimedFiber * CurrentTimedFiber(void)
	{
	return currentFiber;
	}

//
//  Yield Timed Fiber
//

void YieldTimedFiber(int delay, bool precise)
	{
	if (GetCurrentThreadId() == fiberThreadID)
		currentFiber->YieldFiber(delay, precise);
	else
		Sleep(delay);
	}

//
//  Check if Higher Priority Fiber Is Ready
//

bool IsHigherPriorityTimedFiberReady(int id)
	{
	return currentFiber->IsHigherPriorityReady(id);
	}

//
//  Constructor
//

TimedFiber::TimedFiber(int id, int stackSize)
	{
	this->stackSize = stackSize;
	this->id = id;

#if _DEBUG
	debugFibers[id] = this;
#endif

	if (stackSize)
		{
		stack = AllocStackMemory(stackSize);
		minstack = (BYTE *)stack + stackSize;
		state = passive;
		priority = 2;
		}
	else
		{
		stack = NULL;
		state = running;
		priority = 0;
		}
	}

//
//  Destructor
//

TimedFiber::~TimedFiber(void)
	{
	if (thread) CompleteFiber();
	if (stack)
		{
//		DP("Minstack of %d is %d", id, (BYTE *)stack + stackSize - (BYTE *)minstack);

		FreeStackMemory(stack);
		}
	}

////////////////////////////////////////////////////////////////////
//
//  Timed Fiber Queue
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

TimedFiberQueue::TimedFiberQueue(void)
	{
	tail = NULL;
	}

//
//  Enter Fiber
//

void TimedFiberQueue::EnterFiber(TimedFiber * fiber)
	{
	if (!tail)
		{
		tail = fiber;
		fiber->succ = fiber;
		}
	else
		{
		fiber->succ = tail->succ;
		tail->succ = fiber;
		tail = fiber;
		}
	}

//
//  Remove Fiber
//

void TimedFiberQueue::RemoveFiber(TimedFiber * fiber)
	{
	TimedFiber * p, *pp;

	if (tail)
		{
		if (tail == fiber)
			{
			if (tail->succ == tail)
				{
				tail = NULL;
				}
			else
				{
				p = tail;
				while (p->succ != tail) p = p->succ;
				p->succ = tail->succ;
				tail = p;
				}
			}
		else
			{
			pp = tail;
			p = tail->succ;
			while (p != fiber && p != tail)
				{
				pp = p;
				p = p->succ;
				}

			if (p == fiber)
				{
				pp->succ = p->succ;
				}
			}
		}
	}

//
//  Remove Head
//

TimedFiber * TimedFiberQueue::RemoveHead(void)
	{
	TimedFiber * fiber;

	if (tail)
		{
		fiber = tail->succ;

		if (fiber == tail)
			tail = NULL;
		else
			tail->succ = fiber->succ;

		return fiber;
		}
	else
		return NULL;
	}

////////////////////////////////////////////////////////////////////
//
//  Timed Fiber Event
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

TimedFiberEvent::TimedFiberEvent(bool initial, bool autoReset)
	{
	set = initial;
	this->autoReset = autoReset;
	}

//
//  Status Event
//

bool TimedFiberEvent::StatusEvent(void)
	{
	return set;
	}

//
//  Set Event
//

void TimedFiberEvent::SetEvent(void)
	{
	TimedFiber * fiber, * p;

	EnterCriticalSection(&lock);

	if (!set)
		{
		set = TRUE;

		while (set && !(waiting.IsEmpty()))
			{
			fiber = waiting.RemoveHead();
			readyFibers[fiber->priority].EnterFiber(fiber);
			if (fiber->state == TimedFiber::waiting)
				{
				fiber->success = TRUE;
				if (fiber == waitingFibers)
					waitingFibers = waitingFibers->timeSucc;
				else
					{
					p = waitingFibers;
					while (p->timeSucc != fiber) p = p->timeSucc;
					p->timeSucc = fiber->timeSucc;
					}
				if (fiber->precise) preciseCount--;
				}
			fiber->state = TimedFiber::ready;
			if (autoReset) set = FALSE;
			::SetEvent(wakeupEvent);
			}
		}

	LeaveCriticalSection(&lock);
	}

//
//  Reset Event
//

void TimedFiberEvent::ResetEvent(void)
	{
	set = FALSE;
	}

//
//  Wait
//

bool TimedFiberEvent::Wait(int millis, bool precise)
	{
	bool success;

	EnterCriticalSection(&lock);

	if (!set)
		{
		if (millis)
			{
			currentFiber->state = TimedFiber::waiting;
			currentFiber->timeout = GetInternalTime() + millis;
			currentFiber->waitingFor = this;
			currentFiber->precise = precise;
			waiting.EnterFiber(currentFiber);

			RescheduleFibers();

			success = currentFiber->success;
			}
		else
			success = FALSE;

		}
	else if (autoReset)
		{
		set = FALSE;
		success = TRUE;
		}

	LeaveCriticalSection(&lock);

	return success;
	}

//
//  Wait Forever
//

void TimedFiberEvent::WaitForever(void)
	{
	EnterCriticalSection(&lock);

	if (!set)
		{
		currentFiber->state = TimedFiber::blocked;
		waiting.EnterFiber(currentFiber);

		RescheduleFibers();
		}
	else if (autoReset)
		{
		set = FALSE;
		}

	LeaveCriticalSection(&lock);
	}

//
//  Remove Timeout
//

void TimedFiberEvent::RemoveTimeout(TimedFiber * fiber)
	{
	fiber->success = FALSE;
	waiting.RemoveFiber(fiber);
	}

////////////////////////////////////////////////////////////////////
//
//  Timed Fiber Mutex
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

TimedFiberMutex::TimedFiberMutex(void)
	{
	owner = NULL;
	ownerID = NULL;
	useCount = 0;
	event = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	shared = false;
	}

//
//  Destructor
//

TimedFiberMutex::~TimedFiberMutex(void)
	{
	CloseHandle(event);
	}

//
//  Enter
//

void TimedFiberMutex::Enter(bool exclusive)
	{
	DWORD		id;

	id = GetCurrentThreadId();

	for(;;)
		{
		EnterCriticalSection(&lock);
		if (shared)
			{
			if (!exclusive)
				{
				useCount++;
				LeaveCriticalSection(&lock);
				return;
				}
			else if (id == fiberThreadID)
				{
				currentFiber->state = TimedFiber::blocked;
				waiting.EnterFiber(currentFiber);
				RescheduleFibers();
				LeaveCriticalSection(&lock);
				continue;
				}
			}
		else if (ownerID)
			{
			if (id == fiberThreadID)
				{
				if (ownerID == fiberThreadID && owner == currentFiber)
					{
					useCount++;
					LeaveCriticalSection(&lock);
					return;
					}
				else
					{
					currentFiber->state = TimedFiber::blocked;
					waiting.EnterFiber(currentFiber);
					RescheduleFibers();
					LeaveCriticalSection(&lock);
					continue;
					}
				}
			else if (ownerID == id)
				{
				useCount++;
				LeaveCriticalSection(&lock);
				return;
				}
			}
		else
			{
			if (exclusive)
				{
				ownerID = id;

				if (id == fiberThreadID)
					owner = currentFiber;
				}
			else
				shared = true;

			useCount = 1;

			LeaveCriticalSection(&lock);
			return;
			}

		LeaveCriticalSection(&lock);
		::WaitForSingleObject(event, INFINITE);
		}
	}

//
//  Leave
//

void TimedFiberMutex::Leave(void)
	{
	DWORD		id;
	TimedFiber * fiber;

	id = GetCurrentThreadId();

	EnterCriticalSection(&lock);

	if (id == ownerID || shared)
		{
		useCount--;
		if (useCount == 0)
			{
			ownerID = NULL;
			owner = NULL;
			shared = false;

			if (!(waiting.IsEmpty()))
				{
				fiber = waiting.RemoveHead();
				fiber->state = TimedFiber::ready;
				readyFibers[fiber->priority].EnterFiber(fiber);
				}

			::SetEvent(event);
			::SetEvent(wakeupEvent);
			}
		}
	else
		OutputDebugString("Invalid MUTEX release\n");

	LeaveCriticalSection(&lock);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\LPCMDecoder\LPCMDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef LPCMDECODER_H
#define LPCMDECODER_H

#include "..\common\StreamTiming.h"
#include "..\audio\PCMWaveOut.h"
#include "..\audio\AudioBitStream.h"

// NTAP must be even
#define NTAP 36

// table layout
//  coef0,		coef1	(left0  left1)
//  coef0,		coef1	(right0 right1)
//	coef2,		coef3	.....
//	coef2,		coef3	.....
static MMXShort<NTAP*2> LPF96FIRTable =
	{
         11,          22,
         11,          22,
        -68,        -348,
        -68,        -348,
       -617,        -423,
       -617,        -423,
        252,         585,
        252,         585,
        -81,        -885,
        -81,        -885,
       -303,        1206,
       -303,        1206,
       1055,       -1489,
       1055,       -1489,
      -2662,        1684,
      -2662,        1684,
       9555,       13580,
       9555,       13580,
       9555,        1684,
       9555,        1684,
      -2662,       -1489,
      -2662,       -1489,
       1055,        1206,
       1055,        1206,
       -303,        -885,
       -303,        -885,
        -81,         585,
        -81,         585,
        252,        -423,
        252,        -423,
       -617,        -348,
       -617,        -348,
        -68,          22,
        -68,          22,
         11, 		   0,
         11, 		   0
	};


class LPCMDecoder
	{
	protected:
		MMXShort<NTAP*2>		lastSamples;
		MMXShort<160*2>			pcmBuffer;

		AudioBitStream		*	strm;
		PCMWaveOut			*	pcmWaveOut;
		TimingSlave			*	timingSlave;
		bool					hurryUp;

		int						lastTime;
		int						frameSize;

		int						channels;
		int						bitsPerSample;
		int						samplesPerSecond;

		int						skip0, skip1;
		int						targetBufSize;

		void	lpf96kpcmBuffer(int qwCnt);
		void	InitLocalsNewStream(void);


	public:
		LPCMDecoder(AudioBitStream  *	strm,
			        PCMWaveOut		*	pcmWaveOut,
					TimingSlave		*	timingSlave);

		virtual ~LPCMDecoder(void);

		void ParseFrame(void);

		void SetAudioCodingMode(int samplesPerSecond,
										int bitsPerSample,
										int channels);

		void BeginStreaming(void);

		void StartStreaming(int playbackSpeed);

		void StopStreaming(void);

		void EndStreaming(bool fullReset);

		void DetachStreaming(void);
		void AttachStreaming(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\LPCMDecoder\LPCMStreamDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef LPCMSTREAMDECODER_H
#define LPCMSTREAMDECODER_H

#include "LPCMDecoder.h"
#include "..\audio\AudioStreamDecoder.h"
#include "..\common\TimedFibers.h"

class LPCMStreamDecoder : public AudioStreamDecoder,
                          protected LPCMDecoder,
								  private TimedFiber
	{
	protected:
		bool		streaming;
		bool		lowPriority;

		class Supervisor : public TimedFiber
			{
			protected:
				LPCMStreamDecoder * decoder;
			public:
				Supervisor(LPCMStreamDecoder * decoder);
				void FiberRoutine(void);
			} supervisor;

		void FiberRoutine(void);
		void SupervisorFiberRoutine(void);
		void InitLocalsNewStream(void);
		void ClosingCurrentStream(void);

		friend class LPCMStreamDecoder::Supervisor;
	public:
		LPCMStreamDecoder(PCMWaveOut * pcmWaveOut, TimingSlave * timingSlave, StreamFlipCopy * streamFlipCopy);
		~LPCMStreamDecoder(void);

		void SetAudioCodingMode(int samplesPerSecond,
										int bitsPerSample,
										int channels);

		void BeginStreaming(void);
		void StartStreaming(int playbackSpeed);
		void StopStreaming(void);
		void EndStreaming(bool fullReset);
		void DetachStreaming(void);
		void AttachStreaming(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGAudioDecoder\MPEGAudioDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef MPEGAUDIODECODER_H
#define MPEGAUDIODECODER_H

#include "..\common\StreamTiming.h"
#include "..\audio\PCMWaveOut.h"
#include "..\audio\AudioBitStream.h"
#include "library\hardware\audio\generic\ac3setup.h"

#define MAX_SBLIMIT	32
#define MAX_MPEG_CHANNELS	2

class MPEGAudioDecoder
	{
	protected:
		AudioBitStream	*	strm;
		PCMWaveOut		*	pcmWaveOut;
		TimingSlave		*	timingSlave;
		GenericProfile *	globalProfile;
		GenericProfile	*	profile;

	private:
		float					nik2[128];
		PadOnQWord			pad0;
		short					shortWindowConsts[128][4];
	protected:
		//
		// header
		//
		WORD		syncword;
		BIT		id;
		BYTE		layer;
		BYTE		protection;

		int		frameSize;
		__int64	frameStart;

		BYTE		bitrate_index;
		BYTE		sampling_frequency;
		BIT		private_bit;
		BYTE		mode;
		BYTE		mode_extension;
		BIT		copyright;
		BIT		original;
		BYTE		emphasis;

		BYTE		sblimit;
		//
		// error check
		//
		WORD		crc;

		//
		// audio data
		//
		BYTE		baps[MAX_MPEG_CHANNELS][MAX_SBLIMIT];
		BYTE		scfsi[MAX_MPEG_CHANNELS][MAX_SBLIMIT];
		BYTE		scalefactor[MAX_MPEG_CHANNELS][MAX_SBLIMIT][3];
		float		sample[MAX_MPEG_CHANNELS][3][MAX_SBLIMIT];

		int		filterBase;
		int		nchannels;
		short		ivbuffer[MAX_MPEG_CHANNELS][1024];
		float		vbuffer[MAX_MPEG_CHANNELS][1024];


		void SynthesisFilter(void);

		bool ParseHeader(void);

		void ParseErrorCheck(void);

		void ParseAudioData(void);

		void ParseAncillaryData(void);

		void InitLocalsNewStream(void);

		int	lastTime;
		int time;
		bool	hurryUp;
		AC3DualModeConfig dualMode;

	public:
		MPEGAudioDecoder(AudioBitStream	*	strm,
			              PCMWaveOut		*	pcmWaveOut,
					        TimingSlave		*	timingSlave,
							  GenericProfile	*	globalProfile,
					        GenericProfile	*	profile);

		virtual ~MPEGAudioDecoder(void);

		void ParseFrame(void);

		void BeginStreaming(void);

		void StartStreaming(int playbackSpeed);

		void StopStreaming(void);

		void EndStreaming(bool fullReset);

		void DetachStreaming(void);
		void AttachStreaming(void);

		void SetAudioOutConfig(AC3SpeakerConfig spkCfg, AC3DualModeConfig dualModeCfg, AC3KaraokeConfig karaokeCfg);

	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGAudioDecoder\MPEGAudioDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "MPEGAudioDecoder.h"
#include "MPEGAudioTables.h"

#include <math.h>
#define MEASURE_FILTER_TIME	0

static const double pi =  3.14159265359;

bool MPEGAudioDecoder::ParseHeader(void)
	{
	static const int LayerIBitrate[] = {0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448};
	static const int LayerIIBitrate[] = {0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384};
	static const int SamplingFrequency[] = {44100, 48000, 32000, 0};

	DWORD w;

	do	{
		if (!strm->RefillBuffer(4000)) return FALSE;

		w = strm->PeekBits(16);
		syncword = (WORD)XTBF(4, 12, w);
		id = XTBF(3, w);
		layer = (BYTE)XTBF(1, 2, w);
		protection = (BYTE)XTBF(0, 1, w);

		while (syncword != 0xfff || id == 0 || layer == 0)
			{
			strm->Advance(8);

			w = strm->PeekBits(16);
			syncword = (WORD)XTBF(4, 12, w);
			id = XTBF(3, w);
			layer = (BYTE)XTBF(1, 2, w);
			protection = (BYTE)XTBF(0, 1, w);
			}

		frameStart = strm->CurrentLocation();

		strm->Advance(16);

		bitrate_index = (BYTE)strm->GetBits(4);
		sampling_frequency = (BYTE)strm->GetBits(2);
		strm->Advance(1);
		private_bit = strm->GetBit();
		mode = (BYTE)strm->GetBits(2);
		mode_extension = (BYTE)strm->GetBits(2);
		copyright = strm->GetBit();
		original = strm->GetBit();
		emphasis = (BYTE)strm->GetBits(2);

		} while (id == 0 || layer == 0 ||
			      bitrate_index == 15 || bitrate_index == 0 ||
					sampling_frequency == 3 || emphasis == 2);

	switch (layer)
		{
		case 3: // Layer I
			frameSize = 384 * LayerIBitrate[bitrate_index] * 1000 / SamplingFrequency[sampling_frequency];
			break;
		case 2: // Layer II
			frameSize = 1152 * LayerIIBitrate[bitrate_index] * 1000 / SamplingFrequency[sampling_frequency];
			break;
		}

	pcmWaveOut->SetSampleRate(SamplingFrequency[sampling_frequency]);

	return TRUE;
	}

void MPEGAudioDecoder::ParseErrorCheck(void)
	{
	if (!protection)
		crc = (WORD)(strm->GetBits(16));
	}

void MPEGAudioDecoder::ParseAudioData(void)
	{
#pragma warning(disable : 4244 4305)
	static const float CT[] = {1.33333333333 / 2, 1.60000000000 / 4, 1.14285714286 / 4, 1.77777777777 / 8,
		                        1.06666666666 / 8, 1.03225806452 / 16, 1.01587301587 / 32, 1.00787401575 / 64,
								      1.00392156863 / 128, 1.00195694716 / 256, 1.00097751711 / 512, 1.00048851979 / 1024,
								      1.00024420024 / 2048, 1.00012208522 / 4096, 1.00006103888 / 8192, 1.00003051851 / 16384,
								      1.00001525902 / 32768};
#pragma warning(default : 4244 4305)

	static const int DT[] = {-1, -2, -3, -4, -7, -15, -31, -63, -127, -255, -511, -1023,
								    -2047, -4095, -8191, -16383, -32767};


	int nblut;
	int channel_bitrate;
	int bap;
	int ch, sb, gr, bound;
	unsigned int group;
	float m, m0, m1;


	switch (layer)
		{
		case 3: // Layer I
			break;
		case 2: // Layer II
			switch (mode)
				{
				case 3: // single chanel
					channel_bitrate = bitrate_index;
					nchannels = 1;
					nblut = LayerIIBalLut[sampling_frequency][channel_bitrate];
					sblimit = (BYTE)LayerIISBLimit[nblut];
					bound = sblimit;
					break;
				case 0:
				case 2:
					channel_bitrate = LayerIIHalfBitrate[bitrate_index];
					nchannels = 2;
					nblut = LayerIIBalLut[sampling_frequency][channel_bitrate];
					sblimit = (BYTE)LayerIISBLimit[nblut];
					bound = sblimit;
					break;
				case 1:
					channel_bitrate = LayerIIHalfBitrate[bitrate_index];
					nchannels = 2;
					nblut = LayerIIBalLut[sampling_frequency][channel_bitrate];
					sblimit = (BYTE)LayerIISBLimit[nblut];
					bound = 4 * mode_extension + 4;
					break;
				}

			for(sb = 0; sb < bound; sb++)
				{
				for(ch = 0; ch < nchannels; ch++)
					{
					baps[ch][sb] = (BYTE)LayerIIBapTab[nblut][sb][strm->GetBits(LayerIINBalTab[nblut][sb])];
					}
				}
			for(sb = bound; sb < sblimit; sb++)
				{
				baps[1][sb] = baps[0][sb] = (BYTE)LayerIIBapTab[nblut][sb][strm->GetBits(LayerIINBalTab[nblut][sb])];
				}

			for(sb = 0; sb < sblimit; sb++)
				{
				for(ch = 0; ch < nchannels; ch++)
					{
					if (baps[ch][sb]) scfsi[ch][sb] = (BYTE)(strm->GetBits(2));
					}
				}

			for(sb = 0; sb < sblimit; sb++)
				{
				for(ch = 0; ch < nchannels; ch++)
					{
					if (baps[ch][sb])
						{
						switch (scfsi[ch][sb])
							{
							case 0:
								scalefactor[ch][sb][0] = (BYTE)(strm->GetBits(6));
								scalefactor[ch][sb][1] = (BYTE)(strm->GetBits(6));
								scalefactor[ch][sb][2] = (BYTE)(strm->GetBits(6));
								break;
							case 1:
								scalefactor[ch][sb][0] =
								scalefactor[ch][sb][1] = (BYTE)(strm->GetBits(6));
								scalefactor[ch][sb][2] = (BYTE)(strm->GetBits(6));
								break;
							case 2:
								scalefactor[ch][sb][0] =
								scalefactor[ch][sb][1] =
								scalefactor[ch][sb][2] = (BYTE)(strm->GetBits(6));
								break;
							case 3:
								scalefactor[ch][sb][0] = (BYTE)(strm->GetBits(6));
								scalefactor[ch][sb][1] =
								scalefactor[ch][sb][2] = (BYTE)(strm->GetBits(6));
								break;
							}
						}
					else
						{
						sample[ch][0][sb] = 0;
						sample[ch][1][sb] = 0;
						sample[ch][2][sb] = 0;
						}
					}
				}

			for(sb = sblimit; sb < 32; sb++)
				{
				for(ch = 0; ch < nchannels; ch++)
					{
					sample[ch][0][sb] = 0;
					sample[ch][1][sb] = 0;
					sample[ch][2][sb] = 0;
					}
				}

			for(gr = 0; gr < 12; gr++)
				{
				for(sb = 0; sb < bound; sb++)
					{
					for(ch = 0; ch < nchannels; ch++)
						{
						if (baps[ch][sb])
							{
							bap = baps[ch][sb];
							m = CT[bap-1] * LayerIIScaleFactors[scalefactor[ch][sb][gr >> 2]];

							switch (bap)
								{
								case 1:
									group = strm->GetBits(5);
									sample[ch][0][sb] = (float)((int)(group     % 3) + DT[0]) * m;
									sample[ch][1][sb] = (float)((int)(group / 3 % 3) + DT[0]) * m;
									sample[ch][2][sb] = (float)((int)(group / 9    ) + DT[0]) * m;
									break;
								case 2:
									group = strm->GetBits(7);
									sample[ch][0][sb] = (float)((int)(group      % 5) + DT[1]) * m;
									sample[ch][1][sb] = (float)((int)(group /  5 % 5) + DT[1]) * m;
									sample[ch][2][sb] = (float)((int)(group / 25    ) + DT[1]) * m;
									break;
								case 3:
									group = strm->GetBits(9);
									sample[ch][0][sb] = (float)((int)( group >> 6     ) + DT[2]) * m;
									sample[ch][1][sb] = (float)((int)((group >> 3) & 7) + DT[2]) * m;
									sample[ch][2][sb] = (float)((int)( group       & 7) + DT[2]) * m;
									break;
								case 4:
									group = strm->GetBits(10);
									sample[ch][0][sb] = (float)((int)(group      % 9) + DT[3]) * m;
									sample[ch][1][sb] = (float)((int)(group /  9 % 9) + DT[3]) * m;
									sample[ch][2][sb] = (float)((int)(group / 81    ) + DT[3]) * m;
									break;
								case 5:
									group = strm->GetBits(12);
									sample[ch][0][sb] = (float)((int)( group >> 8      ) + DT[4]) * m;
									sample[ch][1][sb] = (float)((int)((group >> 4) & 15) + DT[4]) * m;
									sample[ch][2][sb] = (float)((int)( group       & 15) + DT[4]) * m;
									break;
								case 6:
									group = strm->GetBits(15);
									sample[ch][0][sb] = (float)((int)( group >> 10      ) + DT[5]) * m;
									sample[ch][1][sb] = (float)((int)((group >>  5) & 31) + DT[5]) * m;
									sample[ch][2][sb] = (float)((int)( group        & 31) + DT[5]) * m;
									break;
								case 7:
									group = strm->GetBits(18);
									sample[ch][0][sb] = (float)((int)( group >> 12      ) + DT[6]) * m;
									sample[ch][1][sb] = (float)((int)((group >>  6) & 63) + DT[6]) * m;
									sample[ch][2][sb] = (float)((int)( group        & 63) + DT[6]) * m;
									break;
								default:
									sample[ch][0][sb] = (float)((int)(strm->GetBits(bap-1)) + DT[bap-1]) * m;
									sample[ch][1][sb] = (float)((int)(strm->GetBits(bap-1)) + DT[bap-1]) * m;
									sample[ch][2][sb] = (float)((int)(strm->GetBits(bap-1)) + DT[bap-1]) * m;
									break;
								}
							}
						}
					}
				for(sb = bound; sb < sblimit; sb++)
					{
					if (baps[0][sb])
						{
						bap = baps[0][sb];
						m0 = CT[bap-1] * LayerIIScaleFactors[scalefactor[0][sb][gr >> 2]];
						m1 = CT[bap-1] * LayerIIScaleFactors[scalefactor[1][sb][gr >> 2]];

						switch (bap)
							{
							case 1:
								group = strm->GetBits(5);
								m = (float)((int)(group     % 3) + DT[0]);
								sample[0][0][sb] = m * m0; sample[1][0][sb] = m * m1;
								m = (float)((int)(group / 3 % 3) + DT[0]);
								sample[0][1][sb] = m * m0; sample[1][1][sb] = m * m1;
								m = (float)((int)(group / 9    ) + DT[0]);
								sample[0][2][sb] = m * m0; sample[1][2][sb] = m * m1;
								break;
							case 2:
								group = strm->GetBits(7);
								m = (float)((int)(group      % 5) + DT[1]);
								sample[0][0][sb] = m * m0; sample[1][0][sb] = m * m1;
								m = (float)((int)(group /  5 % 5) + DT[1]);
								sample[0][1][sb] = m * m0; sample[1][1][sb] = m * m1;
								m = (float)((int)(group / 25    ) + DT[1]);
								sample[0][2][sb] = m * m0; sample[1][2][sb] = m * m1;
								break;
							case 3:
								group = strm->GetBits(9);
								m = (float)((int)( group >> 6     ) + DT[2]);
								sample[0][0][sb] = m * m0; sample[1][0][sb] = m * m1;
								m = (float)((int)((group >> 3) & 7) + DT[2]);
								sample[0][1][sb] = m * m0; sample[1][1][sb] = m * m1;
								m = (float)((int)( group       & 7) + DT[2]);
								sample[0][2][sb] = m * m0; sample[1][2][sb] = m * m1;
								break;
							case 4:
								group = strm->GetBits(10);
								m = (float)((int)(group      % 9) + DT[3]);
								sample[0][0][sb] = m * m0; sample[1][0][sb] = m * m1;
								m = (float)((int)(group /  9 % 9) + DT[3]);
								sample[0][1][sb] = m * m0; sample[1][1][sb] = m * m1;
								m = (float)((int)(group / 81    ) + DT[3]);
								sample[0][2][sb] = m * m0; sample[1][2][sb] = m * m1;
								break;
							case 5:
								group = strm->GetBits(12);
								m = (float)((int)( group >> 8      ) + DT[4]);
								sample[0][0][sb] = m * m0; sample[1][0][sb] = m * m1;
								m = (float)((int)((group >> 4) & 15) + DT[4]);
								sample[0][1][sb] = m * m0; sample[1][1][sb] = m * m1;
								m = (float)((int)( group       & 15) + DT[4]);
								sample[0][2][sb] = m * m0; sample[1][2][sb] = m * m1;
								break;
							case 6:
								group = strm->GetBits(15);
								m = (float)((int)( group >> 10      ) + DT[5]);
								sample[0][0][sb] = m * m0; sample[1][0][sb] = m * m1;
								m = (float)((int)((group >>  5) & 31) + DT[5]);
								sample[0][1][sb] = m * m0; sample[1][1][sb] = m * m1;
								m = (float)((int)( group        & 31) + DT[5]);
								sample[0][2][sb] = m * m0; sample[1][2][sb] = m * m1;
								break;
							case 7:
								group = strm->GetBits(18);
								m = (float)((int)( group >> 12      ) + DT[6]);
								sample[0][0][sb] = m * m0; sample[1][0][sb] = m * m1;
								m = (float)((int)((group >>  6) & 63) + DT[6]);
								sample[0][1][sb] = m * m0; sample[1][1][sb] = m * m1;
								m = (float)((int)( group        & 63) + DT[6]);
								sample[0][2][sb] = m * m0; sample[1][2][sb] = m * m1;
								break;
							default:
								m = (float)((int)(strm->GetBits(bap-1)) + DT[bap-1]);
								sample[0][0][sb] = m * m0; sample[1][0][sb] = m * m1;
								m = (float)((int)(strm->GetBits(bap-1)) + DT[bap-1]);
								sample[0][1][sb] = m * m0; sample[1][1][sb] = m * m1;
								m = (float)((int)(strm->GetBits(bap-1)) + DT[bap-1]);
								sample[0][2][sb] = m * m0; sample[1][2][sb] = m * m1;
								break;
							}
						}
					}
				SynthesisFilter();
				if (!hurryUp) YieldTimedFiber(0);
				}
			break;
		case 1: // Layer III
			break;
		}
	}

void MPEGAudioDecoder::ParseAncillaryData(void)
	{
	int skip;

	skip = (int)(strm->CurrentLocation() - frameStart);
	if (skip < (frameSize & ~7)) strm->Advance((frameSize & ~7) - skip);

	strm->ByteAllign();
	while (strm->RefillBuffer(4000) && strm->PeekBits(12) != 0xfff)
		{
		strm->Advance(8);
		}
	}

static inline int FF2I(float val)
	{
	int tmp;

	__asm
		{
		fld	[val]
		fistp	[tmp]
		}

	return tmp;
	}

static inline int FF2I2(float m1, float n1, float m2, float n2)
	{
	int tmp;

	__asm
		{
		fld		[m1]
		fmul		[n1]
		fld		[m2]
		fmul		[n2]
		faddp		st(1), st
		fistp		[tmp]
		}

	return tmp;
	}

void MPEGAudioDecoder::SynthesisFilter(void)
	{
	float s, t;
	int i, j, k, gr, ch;
	short samples[3][32][2], msum[2];
	float dif[16], sum[16];

	int tt, ss;

#if MEASURE_FILTER_TIME
	static __int64 lockSumTime;
	static int lockCount;
	__int64 t1, t2;

	ReadPerformanceCounter(t1);
#endif

	for(gr = 0; gr < 3; gr++)
		{
		filterBase = (filterBase - 64) & 1023;

		for(ch = 0; ch < nchannels; ch++)
			{
			for(i = 0; i < 16; i++)
				{
				sum[i] = sample[ch][gr][i] + sample[ch][gr][31-i];
				dif[i] = sample[ch][gr][i] - sample[ch][gr][31-i];
				}

			for(i = 0; i < 16; i+=2)
				{
				s = t = 0;
				for(k = 0; k < 16; k++)
					{
					t += nik2[(17 + i) * (2 * k + 1) & 127] * dif[k];
					s += nik2[(49 + i) * (2 * k + 1) & 127] * dif[k];
					}

				tt = FF2I(t); ss = FF2I(s);

				ivbuffer[ch][filterBase + i+1] = (short)tt;
				ivbuffer[ch][filterBase + 31-i] = -tt;
				ivbuffer[ch][filterBase + 33+i] = (short)ss;
				ivbuffer[ch][filterBase + 63-i] = (short)ss;
				}

			for(i = 0; i < 8; i++)
				{
				dif[i] = sum[i] - sum[15-i];
				sum[i] = sum[i] + sum[15-i];
				}

			for(i = 0; i < 16; i+=4)
				{
				s = t = 0;
				for(k = 0; k < 8; k++)
					{
					s += nik2[(18 + i) * (2 * k + 1) & 127] * dif[k];
					t += nik2[(50 + i) * (2 * k + 1) & 127] * dif[k];
					}

				tt = FF2I(t); ss = FF2I(s);

				ivbuffer[ch][filterBase + i+2] = (short)ss;
				ivbuffer[ch][filterBase + 30-i] = -ss;
				ivbuffer[ch][filterBase + i+34] = (short)tt;
				ivbuffer[ch][filterBase + 62-i] = (short)tt;
				}

			dif[0] = sum[0] - sum[7]; dif[1] = sum[1] - sum[6];
			dif[2] = sum[2] - sum[5]; dif[3] = sum[3] - sum[4];
			sum[0] = sum[0] + sum[7]; sum[1] = sum[1] + sum[6];
			sum[2] = sum[2] + sum[5]; sum[3] = sum[3] + sum[4];

			s = nik2[20 * (2 * 0 + 1) & 127] * dif[0] + nik2[20 * (2 * 1 + 1) & 127] * dif[1] +
				 nik2[20 * (2 * 2 + 1) & 127] * dif[2] + nik2[20 * (2 * 3 + 1) & 127] * dif[3];
			t = nik2[52 * (2 * 0 + 1) & 127] * dif[0] + nik2[52 * (2 * 1 + 1) & 127] * dif[1] +
				 nik2[52 * (2 * 2 + 1) & 127] * dif[2] + nik2[52 * (2 * 3 + 1) & 127] * dif[3];

			tt = FF2I(t); ss = FF2I(s);

			ivbuffer[ch][filterBase + 4] = (short)ss;
			ivbuffer[ch][filterBase + 28] = -ss;
			ivbuffer[ch][filterBase + 36] = (short)tt;
			ivbuffer[ch][filterBase + 60] = (short)tt;

			s = nik2[28 * (2 * 0 + 1) & 127] * dif[0] + nik2[28 * (2 * 1 + 1) & 127] * dif[1] +
				 nik2[28 * (2 * 2 + 1) & 127] * dif[2] + nik2[28 * (2 * 3 + 1) & 127] * dif[3];
			t = nik2[60 * (2 * 0 + 1) & 127] * dif[0] + nik2[60 * (2 * 1 + 1) & 127] * dif[1] +
				 nik2[60 * (2 * 2 + 1) & 127] * dif[2] + nik2[60 * (2 * 3 + 1) & 127] * dif[3];

			tt = FF2I(t); ss = FF2I(s);

			ivbuffer[ch][filterBase + 12] = (short)ss;
			ivbuffer[ch][filterBase + 20] = -ss;
			ivbuffer[ch][filterBase + 44] = (short)tt;
			ivbuffer[ch][filterBase + 52] = (short)tt;

			dif[0] = sum[0] - sum[3]; dif[1] = sum[1] - sum[2];
			sum[0] = sum[0] + sum[3]; sum[1] = sum[1] + sum[2];

//			ss = FF2I2(nik2[24 * (2 * 0 + 1) & 127], dif[0], nik2[24 * (2 * 1 + 1) & 127], dif[1]);
//			tt = FF2I2(nik2[56 * (2 * 0 + 1) & 127], dif[0], nik2[56 * (2 * 1 + 1) & 127], dif[1]);

			s = nik2[24 * (2 * 0 + 1) & 127] * dif[0] + nik2[24 * (2 * 1 + 1) & 127] * dif[1];
			t = nik2[56 * (2 * 0 + 1) & 127] * dif[0] + nik2[56 * (2 * 1 + 1) & 127] * dif[1];

			tt = FF2I(t); ss = FF2I(s);

			ivbuffer[ch][filterBase +  8] =  (short)ss;
			ivbuffer[ch][filterBase + 24] = -ss;
			ivbuffer[ch][filterBase + 40] =  (short)tt;
			ivbuffer[ch][filterBase + 56] =  (short)tt;

			ss = FF2I((sum[0] - sum[1]) * nik2[(16 + 0) & 127]);
			tt = FF2I((sum[0] + sum[1]) * nik2[(16 + 48) & 127]);

			ivbuffer[ch][filterBase +  0] = (short)ss;
			ivbuffer[ch][filterBase + 16] = 0;
			ivbuffer[ch][filterBase + 32] = -ss;
			ivbuffer[ch][filterBase + 48] = (short)tt;


//			ivbuffer[ch][filterBase +  0] = nik2[(16 +  0) & 127] * sum[0] + nik2[(16 +  0) * 3 & 127] * sum[1];
//			ivbuffer[ch][filterBase + 16] = nik2[(16 + 16) & 127] * sum[0] + nik2[(16 + 16) * 3 & 127] * sum[1];
//			ivbuffer[ch][filterBase + 32] = nik2[(16 + 32) & 127] * sum[0] + nik2[(16 + 32) * 3 & 127] * sum[1];
//			ivbuffer[ch][filterBase + 48] = nik2[(16 + 48) & 127] * sum[0] + nik2[(16 + 48) * 3 & 127] * sum[1];

			short * p = ivbuffer[ch];
			static MMXDWORD<2> synFilterRoundVal = {0x00200000, 0x00200000};

			for(j = 0; j < 32; j+=2)
				{
				__asm
					{
					mov			esi, [this]

//					pxor			mm0, mm0
					movq			mm0, [synFilterRoundVal]

					mov			edx, [j]
					shl			edx, 5
					lea			edx, [esi + edx].shortWindowConsts

					mov			eax, [esi].filterBase
					add			eax, [j]
					mov			edi, [p]
					lea			ebx, [eax + 96]
					and			ebx, 1023

//					mov			ecx, 8
//loop1:
					// offset 0
					movd			mm2, [edi + eax*2]
					movd			mm3, [edi + ebx*2]
					movq			mm1, [edx]
					punpcklwd	mm2, mm3
					pmaddwd		mm1, mm2
					paddd			mm0, mm1

					add			eax, 128 * 7
					add			ebx, 128 * 7
					and			eax, 1023
					and			ebx, 1023

					// offset 7
					movd			mm2, [edi + eax*2]
					movd			mm3, [edi + ebx*2]
					movq			mm1, [edx + 7 * 8]
					punpcklwd	mm2, mm3
					pmaddwd		mm1, mm2
					paddd			mm0, mm1

					sub			eax, 128
					sub			ebx, 128
					and			eax, 1023
					and			ebx, 1023

					psrad			mm0, 4

					// offset 6
					movd			mm2, [edi + eax*2]
					movd			mm3, [edi + ebx*2]
					movq			mm1, [edx + 6 * 8]
					punpcklwd	mm2, mm3
					pmaddwd		mm1, mm2
					paddd			mm0, mm1

					sub			eax, 128 * 5
					sub			ebx, 128 * 5
					and			eax, 1023
					and			ebx, 1023

					// offset 1
					movd			mm2, [edi + eax*2]
					movd			mm3, [edi + ebx*2]
					movq			mm1, [edx + 1 * 8]
					punpcklwd	mm2, mm3
					pmaddwd		mm1, mm2
					paddd			mm0, mm1

					add			eax, 128
					add			ebx, 128
					and			eax, 1023
					and			ebx, 1023

					psrad			mm0, 2

					// offset 2
					movd			mm2, [edi + eax*2]
					movd			mm3, [edi + ebx*2]
					movq			mm1, [edx + 2 * 8]
					punpcklwd	mm2, mm3
					pmaddwd		mm1, mm2
					paddd			mm0, mm1

					add			eax, 128 * 3
					add			ebx, 128 * 3
					and			eax, 1023
					and			ebx, 1023

					// offset 5
					movd			mm2, [edi + eax*2]
					movd			mm3, [edi + ebx*2]
					movq			mm1, [edx + 5 * 8]
					punpcklwd	mm2, mm3
					pmaddwd		mm1, mm2
					paddd			mm0, mm1

					sub			eax, 128
					sub			ebx, 128
					and			eax, 1023
					and			ebx, 1023

					psrad			mm0, 3

					// offset 4
					movd			mm2, [edi + eax*2]
					movd			mm3, [edi + ebx*2]
					movq			mm1, [edx + 4 * 8]
					punpcklwd	mm2, mm3
					pmaddwd		mm1, mm2
					paddd			mm0, mm1

					sub			eax, 128
					sub			ebx, 128
					and			eax, 1023
					and			ebx, 1023

					// offset 3
					movd			mm2, [edi + eax*2]
					movd			mm3, [edi + ebx*2]
					movq			mm1, [edx + 3 * 8]
					punpcklwd	mm2, mm3
					pmaddwd		mm1, mm2
					paddd			mm0, mm1


//					add			edx, 8
//					sub			ecx, 1
//					jne			loop1

					psrad			mm0, 13
					packssdw		mm0, mm1

					movd			[msum], mm0

					}

				samples[gr][j][ch] = msum[0];
				samples[gr][j+1][ch] = msum[1];

				}

			__asm {emms}
			}

		for(ch = nchannels; ch < 2; ch ++)
			{
			for(j=0; j<32; j++)
				samples[gr][j][ch] = samples[gr][j][0];
			}
		}

		if (mode == 2)
			{
			// dual channel mode
			short * sp, * dp;

			switch (dualMode)
				{
				case AC3DMDM_CHANNEL1:
					sp = &samples[0][0][0];
					dp = &samples[0][0][1];
					for(j=0; j<32*3; j++)
						{
						*dp = *sp;
						dp += 2;
						sp += 2;
						}
					break;
				case AC3DMDM_CHANNEL2:
					sp = &samples[0][0][1];
					dp = &samples[0][0][0];
					for(j=0; j<32*3; j++)
						{
						*dp = *sp;
						dp += 2;
						sp += 2;
						}
					break;
				case AC3DMDM_MIX:
					sp = &samples[0][0][0];
					dp = &samples[0][0][1];
					for(j=0; j<32*3; j++)
						{
						*dp = (*dp + *sp)/2;
						*sp = *dp;
						dp += 2;
						sp += 2;
						}
					break;
				default:
				case AC3DMDM_STEREO:
					break;
				}
			}

#if MEASURE_FILTER_TIME
		ReadPerformanceCounter(t2);

		lockSumTime += t2 - t1;
		lockCount++;

		if (!(lockCount & 255))
			{
			char buffer[100];
			wsprintf(buffer, "Filter %d : %d\n", lockCount, (int)(lockSumTime / lockCount));
			OutputDebugString(buffer);
			}
#endif

	pcmWaveOut->AddPCMData(samples[0][0], 32 * 3, lastTime);
	}

void MPEGAudioDecoder::ParseFrame(void)
	{

	time = strm->GetCurrentTimeStamp();

	if (!ParseHeader()) return;

	if (!strm->RefillBuffer(frameSize + 4)) return;

	if (strm->AvailBits() >= frameSize - 32)
		{
		if (time != INVALID_TIME_STAMP && time != lastTime)
			{
			lastTime = time;
			time -= pcmWaveOut->GetBufferDelayTime();
			if (time >= 0 && timingSlave)
				{
				timingSlave->UpdateTimer(time);
				}
			}

		ParseErrorCheck();
		ParseAudioData();
		ParseAncillaryData();
		}
	else
		strm->Advance(strm->AvailBits());
	}

#include <stdio.h>
MPEGAudioDecoder::MPEGAudioDecoder(AudioBitStream	*	strm,
			                          PCMWaveOut		*	pcmWaveOut,
					                    TimingSlave		*	timingSlave,
											  GenericProfile	*	globalProfile,
					                    GenericProfile	*	profile)
	{
	int i, j;

	this->strm = strm;
	this->pcmWaveOut = pcmWaveOut;
	this->timingSlave = timingSlave;
	this->globalProfile = globalProfile;
	this->profile = profile;

	dualMode = AC3DMDM_STEREO;

	static int shortWindowShift[] = {9, 5, 3, 0, 0, 3, 5, 9};


	for(i=0; i<128; i++) nik2[i] = (float)(16384.*cos(i * pi / 64.));

	for(j = 0; j < 32; j+=2)
		{
		for(i = 0; i < 8; i++)
			{
			shortWindowConsts[4*j+i][0] = (short)(floor(LayerIIWindowFactors[i*64+   j  ] * 16384 * (1 << shortWindowShift[i])+ 0.5));
			shortWindowConsts[4*j+i][1] = (short)(floor(LayerIIWindowFactors[i*64+32+j  ] * 16384 * (1 << shortWindowShift[i])+ 0.5));
			shortWindowConsts[4*j+i][2] = (short)(floor(LayerIIWindowFactors[i*64+   j+1] * 16384 * (1 << shortWindowShift[i])+ 0.5));
			shortWindowConsts[4*j+i][3] = (short)(floor(LayerIIWindowFactors[i*64+32+j+1] * 16384 * (1 << shortWindowShift[i])+ 0.5));
			}
		}
	}

MPEGAudioDecoder::~MPEGAudioDecoder(void)
	{
	}

void MPEGAudioDecoder::InitLocalsNewStream(void)
	{
	int i, j;
	for(j = 0; j < 2; j++)
		{
		for(i = 0; i < 1024; i++)
			{
			vbuffer[j][i] = 0;
			ivbuffer[j][i] = 0;
			}
		}

	filterBase = 0;

	hurryUp = FALSE;

	time = 0;
	lastTime = -1;
	}

void MPEGAudioDecoder::BeginStreaming(void)
	{
	pcmWaveOut->BeginStreaming();
	InitLocalsNewStream();
	}

void MPEGAudioDecoder::StartStreaming(int playbackSpeed)
	{
	pcmWaveOut->StartStreaming(playbackSpeed);
	}

void MPEGAudioDecoder::StopStreaming(void)
	{
	pcmWaveOut->StopStreaming();
	}

void MPEGAudioDecoder::EndStreaming(bool fullReset)
	{
	pcmWaveOut->EndStreaming(fullReset);
	}

void MPEGAudioDecoder::DetachStreaming(void)
	{
	pcmWaveOut->DetachStreaming();
	}

void MPEGAudioDecoder::AttachStreaming(void)
	{
	pcmWaveOut->AttachStreaming();
	InitLocalsNewStream();
	}

void MPEGAudioDecoder::SetAudioOutConfig(AC3SpeakerConfig spkCfg, AC3DualModeConfig dualModeCfg, AC3KaraokeConfig karaokeCfg)
	{
	dualMode = dualModeCfg;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGAudioDecoder\MPEGAudioStreamDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef MPEGAUDIOSTREAMDECODER_H
#define MPEGAUDIOSTREAMDECODER_H

#include "MPEGAudioDecoder.h"
#include "..\audio\AudioStreamDecoder.h"
#include "..\common\TimedFibers.h"

class MPEGAudioStreamDecoder : public AudioStreamDecoder,
                         protected MPEGAudioDecoder,
								 private TimedFiber
	{
	protected:
		bool								lowPriority;
		bool								streaming;

		class Supervisor : public TimedFiber
			{
			protected:
				MPEGAudioStreamDecoder * decoder;
			public:
				Supervisor(MPEGAudioStreamDecoder * decoder);
				void FiberRoutine(void);
			} supervisor;

		void FiberRoutine(void);
		void SupervisorFiberRoutine(void);
		void InitLocalsNewStream(void);
		void ClosingCurrentStream(void);

		friend class MPEGAudioStreamDecoder::Supervisor;
	public:
		MPEGAudioStreamDecoder(PCMWaveOut * pcmWaveOut, TimingSlave * timingSlave, GenericProfile * globalProfile, GenericProfile * profile, StreamFlipCopy * streamFlipCopy);
		~MPEGAudioStreamDecoder(void);

		void BeginStreaming(void);
		void StartStreaming(int playbackSpeed);
		void StopStreaming(void);
		void EndStreaming(bool fullReset);
		void DetachStreaming(void);
		void AttachStreaming(void);

		void SetAudioOutConfig(AC3SpeakerConfig spkCfg, AC3DualModeConfig dualModeCfg, AC3KaraokeConfig karaokeCfg)
			{MPEGAudioDecoder::SetAudioOutConfig(spkCfg, dualModeCfg, karaokeCfg);}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGAudioDecoder\MPEGAudioStreamDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "MPEGAudioStreamDecoder.h"


#pragma warning(disable : 4355)
MPEGAudioStreamDecoder::MPEGAudioStreamDecoder(PCMWaveOut * pcmWaveOut, TimingSlave * timingSlave, GenericProfile * globalProfile, GenericProfile * profile, StreamFlipCopy * streamFlipCopy)
									: MPEGAudioDecoder(this, pcmWaveOut, timingSlave, globalProfile, profile),
									  AudioStreamDecoder(pcmWaveOut, streamFlipCopy),
									  supervisor(this),
									  TimedFiber(2)
	{
	streaming = FALSE;
	frameDuration = 24;
	}
#pragma warning(default : 4355)

MPEGAudioStreamDecoder::~MPEGAudioStreamDecoder(void)
	{
	if (streaming) EndStreaming(TRUE);
	}

void MPEGAudioStreamDecoder::FiberRoutine(void)
	{
	int buffer;

	while (strm->RefillBuffer(12288))
		{
		ParseFrame();

		if (!avgFrameSize)
			avgFrameSize = frameSize;
		else
			avgFrameSize = (avgFrameSize * 7 + frameSize) >> 3;

		buffer = AudioStreamDecoder::pcmWaveOut->GetBufferDelayTime();

		if (hurryUp && buffer > 400)
			{
			hurryUp = FALSE;

			SetFiberPriority(2);
			}
		else if (!hurryUp && buffer < 300)
			{
			hurryUp = TRUE;
			lowPriority = FALSE;

			SetFiberPriority(3);
			}
		else if (lowPriority && buffer < 500)
			{
			lowPriority = FALSE;

			SetFiberPriority(2);
			}
		else if (!lowPriority && buffer > 600)
			{
			lowPriority = TRUE;
			hurryUp = FALSE;

			SetFiberPriority(1);
			}

		if (!hurryUp) YieldFiber(0);
		else YieldFiber(-1);
		}

	if (!terminate)
		{
		AudioStreamDecoder::pcmWaveOut->CompleteStreaming();

		AudioStreamDecoder::pcmWaveOut->WaitForCompletion();
		}

	streamingCompleted = TRUE;
	StreamCompleted();
	}

MPEGAudioStreamDecoder::Supervisor::Supervisor(MPEGAudioStreamDecoder * decoder)
	: TimedFiber(4)
	{
	this->decoder = decoder;
	}

void MPEGAudioStreamDecoder::Supervisor::FiberRoutine(void)
	{
	SetFiberPriority(3);
	decoder->SupervisorFiberRoutine();
	}

void MPEGAudioStreamDecoder::SupervisorFiberRoutine(void)
	{
	int buffer;

	while (!terminate)
		{
		buffer = AudioStreamDecoder::pcmWaveOut->GetBufferDelayTime();

		if (hurryUp && buffer > 400)
			{
			hurryUp = FALSE;

			SetFiberPriority(2);
			}
		else if (!hurryUp && buffer < 300)
			{
			hurryUp = TRUE;
			lowPriority = FALSE;

			SetFiberPriority(3);
			}
		else if (lowPriority && buffer < 500)
			{
			lowPriority = FALSE;

			SetFiberPriority(2);
			}
		else if (!lowPriority && buffer > 600)
			{
			lowPriority = TRUE;
			hurryUp = FALSE;

			SetFiberPriority(1);
			}

		YieldTimedFiber(100);
		}
	}

void MPEGAudioStreamDecoder::InitLocalsNewStream(void)
	{
	SetFiberPriority(3);
	lowPriority = FALSE;
	streaming = TRUE;
	avgFrameSize = 0;
	supervisor.StartFiber();
	StartFiber();
	}

void MPEGAudioStreamDecoder::ClosingCurrentStream(void)
	{
	CompleteFiber();
	supervisor.CompleteFiber();
	FlushBuffer();
	streaming = FALSE;
	}

void MPEGAudioStreamDecoder::BeginStreaming(void)
	{
	AudioStreamDecoder::BeginStreaming();
	MPEGAudioDecoder::BeginStreaming();
	InitLocalsNewStream();
	}

void MPEGAudioStreamDecoder::StartStreaming(int playbackSpeed)
	{
	MPEGAudioDecoder::StartStreaming(playbackSpeed);
	AudioStreamDecoder::StartStreaming(playbackSpeed);
	}

void MPEGAudioStreamDecoder::StopStreaming(void)
	{
	MPEGAudioDecoder::StopStreaming();
	AudioStreamDecoder::StopStreaming();
	}

void MPEGAudioStreamDecoder::EndStreaming(bool fullReset)
	{
	if (streaming)
		{
		AudioStreamDecoder::EndStreaming(fullReset);
		MPEGAudioDecoder::EndStreaming(fullReset);
		ClosingCurrentStream();
		}
	}

void MPEGAudioStreamDecoder::DetachStreaming(void)
	{
	if (streaming)
		{
		AudioStreamDecoder::DetachStreaming();
		MPEGAudioDecoder::DetachStreaming();
		ClosingCurrentStream();
		}
	}

void MPEGAudioStreamDecoder::AttachStreaming(void)
	{
	AudioStreamDecoder::AttachStreaming();
	MPEGAudioDecoder::AttachStreaming();
	InitLocalsNewStream();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\FastMMXSliceDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//#include "QFastMMXMotionComp.h"
#include "FastMMXSliceDecoder.h"

#pragma warning(disable : 4799)

static void CopyYUV(BYTE * src, BYTE * dst, int stride, int height)
	{
	__asm
		{
		mov		eax, [src]
		mov		ebx, [dst]

		movq		mm0, [eax]

		mov		ecx, [height]

		mov		edx, [stride]
		sub		ecx, 1

		movq		mm1, [eax+8]
loop1:
		movq		[ebx], mm0

		movq		mm0, [eax+32]

		add		eax, 32
		sub		ecx, 1

		movq		[ebx+8], mm1

		movq		mm1, [eax+8]

		lea		ebx, [ebx + edx]
		jne		loop1

		movq		[ebx], mm0

		movq		[ebx+8], mm1
		}
	}

static inline void CopyUV(BYTE * src, BYTE * dst, int stride)
	{
	__asm
		{
		mov			edx, [src]
		mov			ebx, [dst]
		mov			eax, [stride]
		mov			ecx, 4
loop1:
		movq			mm0, [edx+0]

		movq			mm2, [edx+8]
		movq			mm1, mm0

		movq			mm4, [edx+32]
		punpcklbw	mm0, mm2

		movq			mm6, [edx+40]
		punpckhbw	mm1, mm2

		movq			mm5, mm4
		sub			ecx, 1

		movq			[ebx+0], mm0
		punpcklbw	mm4, mm6

		movq			[ebx+8], mm1
		punpckhbw	mm5, mm6

		movq			[ebx+eax], mm4

		movq			[ebx+eax+8], mm5

		lea			edx, [edx + 64]
		lea			ebx, [ebx + 2*eax]
		jne			loop1
		}
	}

static void ICopyYUV(BYTE * src, BYTE * dst, int stride, int height)
	{
	__asm
		{
		mov		eax, [src]
		mov		ebx, [dst]

		movq		mm0, [eax]

		mov		ecx, [height]

		mov		edx, [stride]
		sub		ecx, 1

		movq		mm1, [eax+16]
loop1:
		movq		[ebx], mm0

		movq		mm0, [eax+32]

		add		eax, 32
		sub		ecx, 1

		movq		[ebx+8], mm1

		movq		mm1, [eax+16]

		lea		ebx, [ebx + edx]
		jne		loop1

		movq		[ebx], mm0

		movq		[ebx+8], mm1
		}
	}

static inline void ICopyUV(BYTE * src, BYTE * dst, int stride)
	{
	__asm
		{
		mov			edx, [src]
		mov			ebx, [dst]
		mov			eax, [stride]
		mov			ecx, 4
loop1:
		movq			mm0, [edx+0]

		movq			mm2, [edx+16]
		movq			mm1, mm0

		movq			mm4, [edx+32]
		punpcklbw	mm0, mm2

		movq			mm6, [edx+48]
		punpckhbw	mm1, mm2

		movq			mm5, mm4
		sub			ecx, 1

		movq			[ebx+0], mm0
		punpcklbw	mm4, mm6

		movq			[ebx+8], mm1
		punpckhbw	mm5, mm6

		movq			[ebx+eax], mm4

		movq			[ebx+eax+8], mm5

		lea			edx, [edx + 64]
		lea			ebx, [ebx + 2*eax]
		jne			loop1
		}
	}

static void MergeUV(BYTE * src)
	{
	__asm
		{
		mov	edx, [src]
		mov	ecx, 4
loop1:
		movq			mm0, [edx+0]

		movq			mm2, [edx+8]
		movq			mm1, mm0

		movq			mm4, [edx+32]
		punpcklbw	mm0, mm2

		movq			mm6, [edx+40]
		punpckhbw	mm1, mm2

		movq			mm5, mm4
		sub			ecx, 1

		movq			[edx+0], mm0
		punpcklbw	mm4, mm6

		movq			[edx+8], mm1
		punpckhbw	mm5, mm6

		movq			[edx+32], mm4

		movq			[edx+40], mm5

		lea			edx, [edx + 64]
		jne			loop1
		}
	}

static void MergeUV(short * src)
	{
	__asm
		{
		mov	edx, [src]
		mov	ecx, 8
loop1:
		movq			mm0, [edx+0]

		movq			mm2, [edx+16]
		movq			mm1, mm0

		movq			mm4, [edx+8]
		punpcklwd	mm0, mm2

		movq			mm6, [edx+24]
		punpckhwd	mm1, mm2

		movq			mm5, mm4
		sub			ecx, 1

		movq			[edx+0], mm0
		punpcklwd	mm4, mm6

		movq			[edx+8], mm1
		punpckhwd	mm5, mm6

		movq			[edx+16], mm4

		movq			[edx+24], mm5

		lea			edx, [edx + 32]
		jne			loop1
		}
	}

static inline int DIV2(int x)
	{
	return (x - (x >> 31)) >> 1;
	}

static inline void DirectMCopyYUV(BYTE * yp, BYTE * uvp, BYTE * fp, int stride)
	{
	__asm
		{
		mov	eax, [yp]
		mov	ebx, [uvp]
		mov	edi, [fp]
		mov	edx, [stride]
		mov	ecx, 8
loop1:
		movq			mm0, [eax]

		movq			mm2, [ebx]

		movq			mm6, [ebx+16]
		movq			mm7, mm2

		punpcklbw	mm2, mm6

		punpckhbw	mm7, mm6

		movq			mm3, [eax+32]

		movq			mm1, mm2
		movq			mm2, mm0

		punpcklbw	mm0, mm1

		movq			mm5, mm3
		punpckhbw	mm2, mm1

		movq			[edi], mm0

		punpcklbw	mm3, mm1

		movq			[edi+8], mm2

		punpckhbw	mm5, mm1

		movq			mm0, [eax+16]

		movq			mm4, [eax+48]

		movq			mm2, mm0

		punpcklbw	mm0, mm7

		movq			mm6, mm4
		punpckhbw	mm2, mm7

		movq			[edi+16], mm0

		punpcklbw	mm4, mm7
		lea			ebx, [ebx+32]

		movq			[edi+24], mm2

		punpckhbw	mm6, mm7
		sub			ecx, 1

		movq			[edi+edx], mm3

		movq			[edi+edx+8], mm5

		movq			[edi+edx+16], mm4

		lea			eax, [eax+64]

		movq			[edi+edx+24], mm5

		lea			edi, [edi+2*edx]
		jne			loop1
		}
	}

static inline void DirectMCopyYUV(BYTE * yp, BYTE * uvp, BYTE * fp, BYTE * ifp, int stride)
	{
	__asm
		{
		mov	eax, [yp]
		mov	ebx, [uvp]
		mov	edi, [fp]
		mov	esi, [ifp]
		mov	edx, [stride]
		mov	ecx, 8
loop1:
		movq			mm1, [ebx]
		movq			mm6, [ebx+16]
		movq			mm7, mm1
		punpcklbw	mm1, mm6
		punpckhbw	mm7, mm6
		sub			ecx, 2

		movq			mm0, [eax]
		movq			mm2, mm0
		punpcklbw	mm0, mm1
		punpckhbw	mm2, mm1
		movq			[edi], mm0

		movq			mm6, [eax+16]
		movq			[edi+8], mm2
		movq			mm2, mm6
		punpcklbw	mm6, mm7
		punpckhbw	mm2, mm7
		movq			[edi+16], mm6
		movq			[edi+24], mm2

		movq			mm0, [eax+64]
		movq			mm2, mm0
		punpcklbw	mm0, mm1
		punpckhbw	mm2, mm1
		movq			[edi+edx], mm0

		movq			mm6, [eax+64+16]
		movq			[edi+edx+8], mm2
		movq			mm2, mm6
		punpcklbw	mm6, mm7
		punpckhbw	mm2, mm7
		movq			[edi+edx+16], mm6

		movq			mm1, [ebx+32]
		movq			mm6, [ebx+48]
		movq			mm7, mm1
		punpcklbw	mm1, mm6
		punpckhbw	mm7, mm6

		movq			mm3, [eax+32]
		movq			[edi+edx+24], mm2
		movq			mm5, mm3
		punpcklbw	mm3, mm1
		punpckhbw	mm5, mm1
		movq			[esi], mm3
		movq			[esi+8], mm5

		movq			mm4, [eax+48]
		movq			mm0, mm4
		punpcklbw	mm4, mm7
		punpckhbw	mm0, mm7
		movq			[esi+16], mm4

		movq			mm3, [eax+64+32]
		movq			[esi+24], mm0
		movq			mm5, mm3
		punpcklbw	mm3, mm1
		punpckhbw	mm5, mm1
		movq			[esi+edx], mm3

		movq			mm4, [eax+64+48]
		movq			[esi+edx+8], mm5
		movq			mm0, mm4
		punpcklbw	mm4, mm7
		punpckhbw	mm0, mm7
		movq			[esi+edx+16], mm4

		lea			ebx, [ebx+64]
		lea			eax, [eax+128]
		lea			edi, [edi+2*edx]

		movq			[esi+edx+24], mm0
		lea			esi, [esi+2*edx]

		jne			loop1
		}
	}

static inline void DirectMSCopyYUV(BYTE * fp, int stride, BYTE * yd, BYTE * uvd, int slstride, int height)
	{
	__asm
		{
		mov         edx, [uvd]
		mov			edi, [slstride]

		mov         ecx, [yd]
		mov         ebx, [fp]

		mov			esi, height
		mov         eax, [stride]

loop1:
		movq        mm6, [edx]

		movq        mm0, [8+edx]
		movq        mm5, mm6

		movq        mm4, [ecx]
		punpcklbw   mm6, mm0

		punpckhbw   mm5, mm0

		movq        [edx], mm6

		movq        [8+edx], mm5
		movq        mm0, mm4

		punpcklbw   mm4, mm6

		punpckhbw   mm0, mm6

		movq        mm2, [8+ecx]

		movq        [ebx], mm4
		movq        mm4, mm2

		movq        [8+ebx], mm0

		movq        mm3, [ecx+edi]
		punpcklbw   mm2, mm5

		punpckhbw   mm4, mm5

		movq        [16+ebx], mm2

		movq        [24+ebx], mm4

		movq        mm0, mm3

		punpcklbw   mm3, mm6

		punpckhbw   mm0, mm6

		movq        mm1, [ecx+edi+8]

		lea         edx, [edx+edi]

		sub         esi, 1

		movq        mm6, mm1

		movq        [ebx+eax], mm3
		punpcklbw   mm1, mm5

		movq        [8+ebx+eax], mm0

		punpckhbw   mm6, mm5
		lea         ecx, [ecx+2*edi]

		movq        [16+ebx+eax], mm1

		movq        [24+ebx+eax], mm6

		lea         ebx, [ebx+2*eax]

		jne         loop1

		}
	}

static inline void MSCopyYUV(BYTE * yd, BYTE * uvd, int slstride)
	{
	__asm
		{
//MMSSTART

		mov         edx, [uvd]
		mov			edi, [slstride]

		mov         ecx, [yd]
		mov			esi, 8

loop1:
		movq        mm6, [edx]

		movq        mm0, [8+edx]

		movq        mm5, mm6

		punpckhbw   mm5, mm0

		punpcklbw   mm6, mm0

		movq        [edx], mm6

		movq        [8+edx], mm5

		lea         ecx, [ecx+2*edi]

		lea         edx, [edx+edi]

		sub         esi, 1
		jne         loop1

//MMSEND
		}
	}

//////////////////////////////////////////////////////

void QFastMMXSliceDecoder::ClearBlocks(void)
	{
	if ((codedBlockPattern & 0x3c) != 0x00 && (codedBlockPattern & 0x3c) != 0x3c)
		memclr512(&mby);
	if ((codedBlockPattern & 0x03) != 0x00 && (codedBlockPattern & 0x03) != 0x03)
		memclr256(&mbuv);
	}

void QFastMMXSliceDecoder::ParseIntraMacroblock(int mx, int my)
	{
	BPTR yc, uvc;
	int stride;

	codedBlockPattern = 0x3f;

	if (directAccess)
		{
		BYTE * fbp = this->fbp+2*mx;

		if (!needsFrameData)
			{
			ParseIntraBlocks();

			if (ifbp)
				{
				BYTE * ifbp = this->ifbp+2*mx;

				DirectMCopyYUV((BYTE *)&(mby[0][0]), (BYTE *)&(mbuv[0][0]), fbp, ifbp, fbstride);
				}
			else
				{
				DirectMCopyYUV((BYTE *)&(mby[0][0]), (BYTE *)&(mbuv[0][0]), fbp, fbstride);
				}
			}
		else
			{
			if (pictureStructure == PS_FRAME_PICTURE)
				curFrame->GetMPP(mx, my, yc, uvc, stride);
			else
				curFrame->GetIMPP(currentFieldID, mx, my, yc, uvc, stride);

			iyuvbpoffset[0] = (int)yc;
			iyuvbpoffset[1] = (int)uvc;
			iyuvbpoffset[2] = (int)uvc;

			ParseIntraBlocks();

			if (ifbp)
				{
				BYTE * ifbp = this->ifbp+2*mx;

				DirectMSCopyYUV(fbp, fbstride, yc, uvc, stride * 2, 4);
				DirectMSCopyYUV(ifbp, fbstride, yc + stride, uvc + stride, stride * 2, 4);
				}
			else
				DirectMSCopyYUV(fbp, fbstride, yc, uvc, stride, 8);
			}
		}
	else
		{
		if (pictureStructure == PS_FRAME_PICTURE)
			curFrame->GetMPP(mx, my, yc, uvc, stride);
		else
			curFrame->GetIMPP(currentFieldID, mx, my, yc, uvc, stride);

		if (!needsFrameData)
			{
			ParseIntraBlocks();

			ICopyYUV((BYTE *)&(mby[0][0]), yc, stride, 16);
			ICopyUV((BYTE *)&(mbuv[0][0]), uvc, stride);
			}
		else
			{
			iyuvbpoffset[0] = (int)yc;
			iyuvbpoffset[1] = (int)uvc;
			iyuvbpoffset[2] = (int)uvc;

			ParseIntraBlocks();

			MSCopyYUV(yc, uvc, stride);
			}
		}

	}

void QFastMMXSliceDecoder::MotionCompensation(int mx, int my, bool copyY, bool copyUV)
	{
	int px[2], sx[2];
	int py[2], sy[2];
	int cpx[2], csx[2];
	int cpy[2], csy[2];
	BPTR yp, uvp;
	BPTR ys, uvs;
	BPTR yc, uvc;
	int stride;

	BYTE * fbp = this->fbp+2*mx;

//if (!copyUV) MergeUV(&(mbuv[0][0]));


	if (directAccess && ifbp)
		{

		int ifbpdist = ifbp - this->fbp;

		curFrame->GetMPP(mx, my, yc, uvc, stride);

		if (predictionType == PT_FRAME_BASED)
			{
			if (IS_MACROBLOCK_MOTION_BACKWARD(macroblockType))
				{
				sx[0] = (mx * 2 + vectors[0][1][0]) & motionVectorMask;
				sy[0] = (my * 2 + vectors[0][1][1]) & motionVectorMask;
				csx[0] = mx + DIV2(vectors[0][1][0]);
				csy[0] = my + DIV2(vectors[0][1][1]);

				if (succFrame->GetYPP(sx[0] >> 1, sy[0] >> 1, ys))
					{
					succFrame->GetUVPP(csx[0] >> 1, csy[0] >> 1, uvs);

					if (IS_MACROBLOCK_MOTION_FORWARD(macroblockType))
						{
						px[0] = (mx * 2 + vectors[0][0][0]) & motionVectorMask;
						py[0] = (my * 2 + vectors[0][0][1]) & motionVectorMask;
						cpx[0] = mx + DIV2(vectors[0][0][0]);
						cpy[0] = my + DIV2(vectors[0][0][1]);

						if (predFrame->GetYPP(px[0] >> 1, py[0] >> 1, yp))
							{
							predFrame->GetUVPP(cpx[0] >> 1, cpy[0] >> 1, uvp);

							if (needsFrameData)
								{
								motionComp->SBiMotionCompensationUV(
										cpy[0], cpx[0], csy[0], csx[0],
										uvp, uvs, stride, copyUV,
										uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
								motionComp->ISDBiMotionCompensationY(
										py[0], px[0], sy[0], sx[0],
										yp, ys, stride, copyY,
										yc, &(mby[0][0]), 32, &(mby[16][0]),
										uvc, fbp, fbstride, ifbpdist);
								}
							else
								{
								motionComp->BiMotionCompensationUV(
										cpy[0], cpx[0], csy[0], csx[0],
										uvp, uvs, stride, copyUV,
										&(mbuv[0][0]), 32, &(mbuv[8][0]));
								motionComp->IDBiMotionCompensationY(
										py[0], px[0], sy[0], sx[0],
										yp, ys, stride, copyY,
										&(mby[0][0]), 32, &(mby[16][0]),
										(BYTE *)&(mbuv[0][0]), fbp, fbstride, ifbpdist);
								}
							}
						else
							errorInSlice = true;
						}
					else
						{
						if (needsFrameData)
							{
							motionComp->SMotionCompensationUV(
									csy[0], csx[0],
									uvs, stride, copyUV,
									uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
							motionComp->ISDMotionCompensationY(
									sy[0], sx[0],
									ys, stride, copyY,
									yc, &(mby[0][0]), 32, &(mby[16][0]),
									uvc, fbp, fbstride, ifbpdist);
							}
						else
							{
							motionComp->MotionCompensationUV(
									csy[0], csx[0],
									uvs, stride, copyUV,
									&(mbuv[0][0]), 32, &(mbuv[8][0]));
							motionComp->IDMotionCompensationY(
									sy[0], sx[0],
									ys, stride, copyY,
									&(mby[0][0]), 32, &(mby[16][0]),
									(BYTE *)&(mbuv[0][0]), fbp, fbstride, ifbpdist);
							}
						}
					}
				else
					errorInSlice = true;
				}
			else
				{
				px[0] = (mx * 2 + vectors[0][0][0]) & motionVectorMask;
				py[0] = (my * 2 + vectors[0][0][1]) & motionVectorMask;
				cpx[0] = mx + DIV2(vectors[0][0][0]);
				cpy[0] = my + DIV2(vectors[0][0][1]);

				if (predFrame->GetYPP(px[0] >> 1, py[0] >> 1, yp))
					{
					predFrame->GetUVPP(cpx[0] >> 1, cpy[0] >> 1, uvp);

					if (needsFrameData)
						{
						motionComp->SMotionCompensationUV(
								cpy[0], cpx[0],
								uvp, stride, copyUV,
								uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
						motionComp->ISDMotionCompensationY(
								py[0], px[0],
								yp, stride, copyY,
								yc, &(mby[0][0]), 32, &(mby[16][0]),
								uvc, fbp, fbstride, ifbpdist);
						}
					else
						{
						motionComp->MotionCompensationUV(
								cpy[0], cpx[0],
								uvp, stride, copyUV,
								&(mbuv[0][0]), 32, &(mbuv[8][0]));
						motionComp->IDMotionCompensationY(
								py[0], px[0],
								yp, stride, copyY,
								&(mby[0][0]), 32, &(mby[16][0]),
								(BYTE *)&(mbuv[0][0]), fbp, fbstride, ifbpdist);
						}
					}
				else
					errorInSlice = true;
				}
			}
		else if (predictionType == PT_DUAL_PRIME)
			{
			sx[0] = mx * 2 + vectors[0][0][0];
			sy[0] = my     + vectors[0][0][1];
			csx[0] = mx        + DIV2(vectors[0][0][0]);
			csy[0] = (my >> 1) + DIV2(vectors[0][0][1]);

			px[0] = mx * 2 + vectors[2][0][0];
			py[0] = my     + vectors[2][0][1];
			px[1] = mx * 2 + vectors[3][0][0];
			py[1] = my     + vectors[3][0][1];
			cpx[0] = mx        + DIV2(vectors[2][0][0]);
			cpy[0] = (my >> 1) + DIV2(vectors[2][0][1]);
			cpx[1] = mx        + DIV2(vectors[3][0][0]);
			cpy[1] = (my >> 1) + DIV2(vectors[3][0][1]);

			if (predFrame->GetYPPF(FALSE, sx[0] >> 1, sy[0] >> 1, ys) &&
				 predFrame->GetYPPF(TRUE, px[0] >> 1, py[0] >> 1, yp))
				{
				predFrame->GetUVPPF(FALSE, csx[0] >> 1, csy[0] >> 1, uvs);
				predFrame->GetUVPPF(TRUE, cpx[0] >> 1, cpy[0] >> 1, uvp);

				if (needsFrameData)
					{
					motionComp->SBiMotionCompensationUV(
							cpy[0], cpx[0], csy[0], csx[0],
							uvp, uvs, 2 * stride, copyUV,
							uvc, &(mbuv[0][0]), 64, &(mbuv[8][0]));
					motionComp->SDBiMotionCompensationY(
							py[0], px[0], sy[0], sx[0],
							yp, ys, 2 * stride, copyY,
							yc, &(mby[0][0]), 64, &(mby[16][0]),
							uvc, fbp, fbstride);
					}
				else
					{
					motionComp->BiMotionCompensationUV(
							cpy[0], cpx[0], csy[0], csx[0],
							uvp, uvs, 2 * stride, copyUV,
							&(mbuv[0][0]), 64, &(mbuv[8][0]));
					motionComp->DBiMotionCompensationY(
							py[0], px[0], sy[0], sx[0],
							yp, ys, 2 * stride, copyY,
							&(mby[0][0]), 64, &(mby[16][0]),
							(BYTE *)&(mbuv[0][0]), fbp, fbstride);
					}
				}
			else
				errorInSlice = true;

			if (predFrame->GetYPPF(TRUE, sx[0] >> 1, sy[0] >> 1, ys) &&
			    predFrame->GetYPPF(FALSE, px[1] >> 1, py[1] >> 1, yp))
				{
				predFrame->GetUVPPF(TRUE, csx[0] >> 1, csy[0] >> 1, uvs);
				predFrame->GetUVPPF(FALSE, cpx[1] >> 1, cpy[1] >> 1, uvp);

				if (needsFrameData)
					{
					motionComp->SBiMotionCompensationUV(
							cpy[1], cpx[1], csy[0], csx[0],
							uvp, uvs, 2 * stride, copyUV,
							uvc + stride, &(mbuv[1][0]), 64, &(mbuv[9][0]));
					motionComp->SDBiMotionCompensationY(
							py[1], px[1], sy[0], sx[0],
							yp, ys, 2 * stride, copyY,
							yc + stride, &(mby[1][0]), 64, &(mby[17][0]),
							uvc + stride, fbp + ifbpdist, fbstride);
					}
				else
					{
					motionComp->BiMotionCompensationUV(
							cpy[1], cpx[1], csy[0], csx[0],
							uvp, uvs, 2 * stride, copyUV,
							&(mbuv[1][0]), 64, &(mbuv[9][0]));
					motionComp->DBiMotionCompensationY(
							py[1], px[1], sy[0], sx[0],
							yp, ys, 2 * stride, copyY,
							&(mby[1][0]), 64, &(mby[17][0]),
							(BYTE *)&(mbuv[1][0]), fbp + ifbpdist, fbstride);
					}
				}
			else
				errorInSlice = true;
			}
		else
			{
			if (IS_MACROBLOCK_MOTION_BACKWARD(macroblockType))
				{
				sx[0] = (mx * 2 + vectors[0][1][0]) & motionVectorMask;
				sy[0] = (my     + vectors[0][1][1]) & motionVectorMask;
				sx[1] = (mx * 2 + vectors[1][1][0]) & motionVectorMask;
				sy[1] = (my     + vectors[1][1][1]) & motionVectorMask;
				csx[0] = mx        + DIV2(vectors[0][1][0]);
				csy[0] = (my >> 1) + DIV2(vectors[0][1][1]);
				csx[1] = mx        + DIV2(vectors[1][1][0]);
				csy[1] = (my >> 1) + DIV2(vectors[1][1][1]);

				if (IS_MACROBLOCK_MOTION_FORWARD(macroblockType))
					{
					px[0] = (mx * 2 + vectors[0][0][0]) & motionVectorMask;
					py[0] = (my     + vectors[0][0][1]) & motionVectorMask;
					px[1] = (mx * 2 + vectors[1][0][0]) & motionVectorMask;
					py[1] = (my     + vectors[1][0][1]) & motionVectorMask;
					cpx[0] = mx        + DIV2(vectors[0][0][0]);
					cpy[0] = (my >> 1) + DIV2(vectors[0][0][1]);
					cpx[1] = mx        + DIV2(vectors[1][0][0]);
					cpy[1] = (my >> 1) + DIV2(vectors[1][0][1]);

					if (predFrame->GetYPPF(motionVerticalFieldSelect[0][0], px[0] >> 1, py[0] >> 1, yp) &&
						 succFrame->GetYPPF(motionVerticalFieldSelect[0][1], sx[0] >> 1, sy[0] >> 1, ys))
						{
						predFrame->GetUVPPF(motionVerticalFieldSelect[0][0], cpx[0] >> 1, cpy[0] >> 1, uvp);
						succFrame->GetUVPPF(motionVerticalFieldSelect[0][1], csx[0] >> 1, csy[0] >> 1, uvs);

						if (needsFrameData)
							{
							motionComp->SBiMotionCompensationUV(
									cpy[0], cpx[0], csy[0], csx[0],
									uvp, uvs, 2 * stride, copyUV,
									uvc, &(mbuv[0][0]), 64, &(mbuv[8][0]));
							motionComp->SDBiMotionCompensationY(
									py[0], px[0], sy[0], sx[0],
									yp, ys, 2 * stride, copyY,
									yc, &(mby[0][0]), 64, &(mby[16][0]),
									uvc, fbp, fbstride);
							}
						else
							{
							motionComp->BiMotionCompensationUV(
									cpy[0], cpx[0], csy[0], csx[0],
									uvp, uvs, 2 * stride, copyUV,
									&(mbuv[0][0]), 64, &(mbuv[8][0]));
							motionComp->DBiMotionCompensationY(
									py[0], px[0], sy[0], sx[0],
									yp, ys, 2 * stride, copyY,
									&(mby[0][0]), 64, &(mby[16][0]),
									(BYTE *)&(mbuv[0][0]), fbp, fbstride);
							}
						}
					else
						errorInSlice = true;

					if (predFrame->GetYPPF(motionVerticalFieldSelect[1][0], px[1] >> 1, py[1] >> 1, yp) &&
						 succFrame->GetYPPF(motionVerticalFieldSelect[1][1], sx[1] >> 1, sy[1] >> 1, ys))
						{
						predFrame->GetUVPPF(motionVerticalFieldSelect[1][0], cpx[1] >> 1, cpy[1] >> 1, uvp);
						succFrame->GetUVPPF(motionVerticalFieldSelect[1][1], csx[1] >> 1, csy[1] >> 1, uvs);

						if (needsFrameData)
							{
							motionComp->SBiMotionCompensationUV(
									cpy[1], cpx[1], csy[1], csx[1],
									uvp, uvs, 2 * stride, copyUV,
									uvc + stride, &(mbuv[1][0]), 64, &(mbuv[9][0]));
							motionComp->SDBiMotionCompensationY(
									py[1], px[1], sy[1], sx[1],
									yp, ys, 2 * stride, copyY,
									yc + stride, &(mby[1][0]), 64, &(mby[17][0]),
									uvc + stride, fbp + ifbpdist, fbstride);
							}
						else
							{
							motionComp->BiMotionCompensationUV(
									cpy[1], cpx[1], csy[1], csx[1],
									uvp, uvs, 2 * stride, copyUV,
									&(mbuv[1][0]), 64, &(mbuv[9][0]));
							motionComp->DBiMotionCompensationY(
									py[1], px[1], sy[1], sx[1],
									yp, ys, 2 * stride, copyY,
									&(mby[1][0]), 64, &(mby[17][0]),
									(BYTE *)&(mbuv[1][0]), fbp + ifbpdist, fbstride);
							}
						}
					else
						errorInSlice = true;
					}
				else
					{
					if (succFrame->GetYPPF(motionVerticalFieldSelect[0][1], sx[0] >> 1, sy[0] >> 1, ys))
						{
						succFrame->GetUVPPF(motionVerticalFieldSelect[0][1], csx[0] >> 1, csy[0] >> 1, uvs);

						if (needsFrameData)
							{
							motionComp->SMotionCompensationUV(
									csy[0], csx[0],
									uvs, 2 * stride, copyUV,
									uvc, &(mbuv[0][0]), 64, &(mbuv[8][0]));
							motionComp->SDMotionCompensationY(
									sy[0], sx[0],
									ys, 2 * stride, copyY,
									yc, &(mby[0][0]), 64, &(mby[16][0]),
									uvc, fbp, fbstride);
							}
						else
							{
							motionComp->MotionCompensationUV(
									csy[0], csx[0],
									uvs, 2 * stride, copyUV,
									&(mbuv[0][0]), 64, &(mbuv[8][0]));
							motionComp->DMotionCompensationY(
									sy[0], sx[0],
									ys, 2 * stride, copyY,
									&(mby[0][0]), 64, &(mby[16][0]),
									(BYTE *)&(mbuv[0][0]), fbp, fbstride);
							}
						}
					else
						errorInSlice = true;

					if (succFrame->GetYPPF(motionVerticalFieldSelect[1][1], sx[1] >> 1, sy[1] >> 1, ys))
						{
						succFrame->GetUVPPF(motionVerticalFieldSelect[1][1], csx[1] >> 1, csy[1] >> 1, uvs);

						if (needsFrameData)
							{
							motionComp->SMotionCompensationUV(
									csy[1], csx[1],
									uvs, 2 * stride, copyUV,
									uvc + stride, &(mbuv[1][0]), 64, &(mbuv[9][0]));
							motionComp->SDMotionCompensationY(
									sy[1], sx[1],
									ys, 2 * stride, copyY,
									yc + stride, &(mby[1][0]), 64, &(mby[17][0]),
									uvc + stride, fbp + ifbpdist, fbstride);
							}
						else
							{
							motionComp->MotionCompensationUV(
									csy[1], csx[1],
									uvs, 2 * stride, copyUV,
									&(mbuv[1][0]), 64, &(mbuv[9][0]));
							motionComp->DMotionCompensationY(
									sy[1], sx[1],
									ys, 2 * stride, copyY,
									&(mby[1][0]), 64, &(mby[17][0]),
									(BYTE *)&(mbuv[1][0]), fbp + ifbpdist, fbstride);
							}
						}
					else
						errorInSlice = true;
					}
				}
			else
				{
				px[0] = (mx * 2 + vectors[0][0][0]) & motionVectorMask;
				py[0] = (my +     vectors[0][0][1]) & motionVectorMask;
				px[1] = (mx * 2 + vectors[1][0][0]) & motionVectorMask;
				py[1] = (my +     vectors[1][0][1]) & motionVectorMask;
				cpx[0] = mx        + DIV2(vectors[0][0][0]);
				cpy[0] = (my >> 1) + DIV2(vectors[0][0][1]);
				cpx[1] = mx        + DIV2(vectors[1][0][0]);
				cpy[1] = (my >> 1) + DIV2(vectors[1][0][1]);

				if (predFrame->GetYPPF(motionVerticalFieldSelect[0][0], px[0] >> 1, py[0] >> 1, yp))
					{
					predFrame->GetUVPPF(motionVerticalFieldSelect[0][0], cpx[0] >> 1, cpy[0] >> 1, uvp);

					if (needsFrameData)
						{
						motionComp->SMotionCompensationUV(
								cpy[0], cpx[0],
								uvp, 2 * stride, copyUV,
								uvc, &(mbuv[0][0]), 64, &(mbuv[8][0]));
						motionComp->SDMotionCompensationY(
								py[0], px[0],
								yp, 2 * stride, copyY,
								yc, &(mby[0][0]), 64, &(mby[16][0]),
								uvc, fbp, fbstride);
						}
					else
						{
						motionComp->MotionCompensationUV(
								cpy[0], cpx[0],
								uvp, 2 * stride, copyUV,
								&(mbuv[0][0]), 64, &(mbuv[8][0]));
						motionComp->DMotionCompensationY(
								py[0], px[0],
								yp, 2 * stride, copyY,
								&(mby[0][0]), 64, &(mby[16][0]),
								(BYTE *)&(mbuv[0][0]), fbp, fbstride);
						}
					}
				else
					errorInSlice = true;

				if (predFrame->GetYPPF(motionVerticalFieldSelect[1][0], px[1] >> 1, py[1] >> 1, yp))
					{
					predFrame->GetUVPPF(motionVerticalFieldSelect[1][0], cpx[1] >> 1, cpy[1] >> 1, uvp);

					if (needsFrameData)
						{
						motionComp->SMotionCompensationUV(
								cpy[1], cpx[1],
								uvp, 2 * stride, copyUV,
								uvc + stride, &(mbuv[1][0]), 64, &(mbuv[9][0]));
						motionComp->SDMotionCompensationY(
								py[1], px[1],
								yp, 2 * stride, copyY,
								yc + stride, &(mby[1][0]), 64, &(mby[17][0]),
								uvc + stride, fbp + ifbpdist, fbstride);
						}
					else
						{
						motionComp->MotionCompensationUV(
								cpy[1], cpx[1],
								uvp, 2 * stride, copyUV,
								&(mbuv[1][0]), 64, &(mbuv[9][0]));
						motionComp->DMotionCompensationY(
								py[1], px[1],
								yp, 2 * stride, copyY,
								&(mby[1][0]), 64, &(mby[17][0]),
								(BYTE *)&(mbuv[1][0]), fbp + ifbpdist, fbstride);
						}
					}
				else
					errorInSlice = true;
				}
			}
		}
	else if (pictureStruc