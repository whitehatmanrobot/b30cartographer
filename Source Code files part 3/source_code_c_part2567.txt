MUS_OBJ_VERSION | DMUS_OBJ_NAME );
	
	memcpy( &pDMObjectDesc->guidObject, &pBand->m_guidBand, sizeof(GUID) );
	memcpy( &pDMObjectDesc->guidClass, &CLSID_DirectMusicBand, sizeof(CLSID) );
	pDMObjectDesc->vVersion.dwVersionMS = pBand->m_Version.dwVersionMS;
	pDMObjectDesc->vVersion.dwVersionLS = pBand->m_Version.dwVersionLS;
	MultiByteToWideChar( CP_ACP, 0, pBand->m_csName, -1, pDMObjectDesc->wszName, DMUS_MAX_NAME );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandDocType::GetObjectRiffId

HRESULT CBandDocType::GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pckid == NULL
	||  pfccType == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Band Node
	if( IsEqualGUID ( guidNodeId, GUID_BandNode ) ) 
	{
		*pckid = FOURCC_RIFF;
		*pfccType = DMUS_FOURCC_BAND_FORM;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CBandDocType::GetObjectExt

HRESULT CBandDocType::GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt )
{
#ifndef DMP_XBOX
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrExt == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Band Node
	if( IsEqualGUID ( guidNodeId, GUID_BandNode ) ) 
	{
		if( ftFileType == FT_DESIGN )
		{
			CString strExt = ".bnp";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}

		if( ftFileType == FT_RUNTIME )
		{
			CString strExt = ".bnd";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}
	}
#endif

	return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandDlg.cpp ===
// BandDlg.cpp : implementation file
//

#include "stdafx.h"
#include "BandEditorDLL.h"
#include "Band.h"
#include "BandCtl.h"
#include "BandDlg.h"
#include "DlgDLS.h"
#include "DLSDesigner.h"
#include "PChannelList.h"
#include "AddRemoveDlg.h"
#include "PChannelPropPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "resource.cpp"
#include "resourcemaps.h"

CString CBandDlg::m_arrIntervals[12];
CString CBandDlg::m_arrNotes[12];

#define MIDI_CCHANGE    0xB0

/////////////////////////////////////////////////////////////////////////////
// CBandDlg

IMPLEMENT_DYNCREATE(CBandDlg, CFormView)


/////////////////////////////////////////////////////////////////////////////
// CBandDlg::CBandDlg

CBandDlg::CBandDlg()
	: CFormView(CBandDlg::IDD)
{
	//{{AFX_DATA_INIT(CBandDlg)
	//}}AFX_DATA_INIT

	m_pBandCtrl = NULL;
	m_dwRef = 1;
	m_dwCookie = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CBandDlg::~CBandDlg

CBandDlg::~CBandDlg()
{
}


void CBandDlg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBandDlg)
	DDX_Control(pDX, IDC_GRID, m_MixGrid);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CBandDlg, CFormView)
	//{{AFX_MSG_MAP(CBandDlg)
	ON_WM_DESTROY()
	ON_WM_SETCURSOR()
	ON_WM_CTLCOLOR()
	ON_WM_CONTEXTMENU()
	ON_LBN_SELCHANGE(IDC_PCHANNEL_LIST, OnSelchangePchannelList)
	ON_COMMAND(IDM_PROPERTIES, OnProperties)
	ON_WM_VKEYTOITEM()
	ON_LBN_DBLCLK(IDC_PCHANNEL_LIST, OnDblClkPChannelList)
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBandDlg diagnostics

#ifdef _DEBUG
void CBandDlg::AssertValid() const
{
	CFormView::AssertValid();
}

void CBandDlg::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CBandDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CBandDlg::OnInitialUpdate

void CBandDlg::OnInitialUpdate() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CFormView::OnInitialUpdate();

	LoadIntervals();
	LoadNotes();

	m_PChannelList.SubclassDlgItem(IDC_PCHANNEL_LIST, this);
	m_PChannelList.SetBandDialog(this);

	RemoveAndAddAllButtonsToGrid();

	RefreshDisplay();

}

/////////////////////////////////////////////////////////////////////////////
// CBandDlg::Create

BOOL CBandDlg::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pBandDo = new CUndoMan;

	RegisterMidi();

	return CFormView::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
}


/////////////////////////////////////////////////////////////////////////////
// CBandDlg::OnDestroy

void CBandDlg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	delete m_pBandDo;

	UnRegisterMidi();

	CFormView::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CBandDlg::OnSetCursor

BOOL CBandDlg::OnSetCursor( CWnd* pWnd, UINT nHitTest, UINT message ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HCURSOR hCursor;

	// Cursor in border of controls or window in menu mode
	if( message == 0 )
	{
		hCursor = ::LoadCursor( NULL, IDC_ARROW );
		if( hCursor )
		{
			::SetCursor( hCursor );
		}
		return TRUE;
	}
	
	return CFormView::OnSetCursor(pWnd, nHitTest, message);
}


// all popup menu choices get funneled through this function
BOOL CBandDlg::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdConductor* pIC = m_pBandCtrl->m_pComponent->m_pIConductor;

	// Check if not a menu message
	if( lParam )  
		return CFormView::OnCommand(wParam, lParam);

	WORD wCommand = LOWORD(wParam);

	if(wCommand == IDM_ADDRMV_PCHANNEL)
	{
		CPtrList* pInstrumentList = (CPtrList*)m_pBandCtrl->m_pBand->GetInstrumentList();
		ASSERT(pInstrumentList);
		CAddRemoveDlg addRemoveDlg;
		addRemoveDlg.SetBandDialog(this);
		addRemoveDlg.SetInstrumentList(pInstrumentList);
		addRemoveDlg.DoModal();
	}
	if(wCommand == ID_INSERT_PCHANNEL)
	{
		// Limit the PChannels to 999
		CBand* pBand = GetBand();
		ASSERT(pBand);

		int nPChannels = pBand->GetInstrumentCount();
		if(nPChannels < 999)
		{

			SaveStateForUndo("Insert PChannel");

			CInstrumentListItem* pInstrumentItem = m_pBandCtrl->m_pBand->InsertIntoInstrumentList(); // Start from the beginning
			ASSERT(pInstrumentItem);
			CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
			ASSERT(pInstrument);
			pInstrument->Send(m_pBandCtrl->m_pBand, DM_PATCH_CHANGE);
			AddPChannel(-1, pInstrumentItem);
			AddToGrid(pInstrumentItem);
			m_pBandCtrl->m_pBand->SetModifiedFlag( TRUE );

			pInstrument->SendBandUpdate(pBand);

		}
	}
	
	if(wCommand == ID_DELETE_PCHANNEL)
	{
		OnDeleteCommand();
	}

	if(wCommand == ID_EDIT_SELECTALL)
	{
		SelectAllPChannels();
	}

	return CFormView::OnCommand(wParam, lParam);
}


BEGIN_EVENTSINK_MAP(CBandDlg, CFormView)
    //{{AFX_EVENTSINK_MAP(CBandDlg)
	ON_EVENT(CBandDlg, IDC_GRID, 1 /* CursorOver */, OnCursorOverGrid, VTS_I4)
	ON_EVENT(CBandDlg, IDC_GRID, 2 /* Move */, OnMoveGrid, VTS_I4 VTS_I2 VTS_I2)
	ON_EVENT(CBandDlg, IDC_GRID, 3 /* Update */, OnUpdateGrid, VTS_UNKNOWN VTS_BOOL VTS_BOOL)
	ON_EVENT(CBandDlg, IDC_GRID, 4 /* SelectPChannel */, OnSelectPChannelGrid, VTS_I4 VTS_BOOL VTS_BOOL)
	ON_EVENT(CBandDlg, IDC_GRID, 5 /* SaveUndoState */, OnSaveUndoStateGrid, VTS_NONE)
	ON_EVENT(CBandDlg, IDC_GRID, 6 /* DisplayStatus */, OnDisplayStatusGrid, VTS_I2)
	ON_EVENT(CBandDlg, IDC_GRID, 7 /* RightClick */, OnRightClickGrid, VTS_I2 VTS_I2)
	ON_EVENT(CBandDlg, IDC_GRID, 8 /* DeleteChannel */, OnDeleteChannelGrid, VTS_NONE)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void CBandDlg::OnMoveGrid(long nId, short nPan, short nVolume) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CString str;
	BSTR bstr;

	str = GetPanVolumeText(nPan, nVolume);

	bstr = str.AllocSysString();
	m_pBandCtrl->m_pComponent->m_pIFramework->SetStatusBarPaneText( m_pBandCtrl->m_hKeyStatusBar, 0, bstr, TRUE );
}

void CBandDlg::OnUpdateGrid(LPUNKNOWN pIBandPChannel, BOOL bCTRLDown, BOOL bRefreshUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*)pIBandPChannel;
	CDMInstrument* pInstrument = NULL;

	if(pInstrumentItem)
	{
		pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);
		if(pInstrument)
		{
			m_pBandCtrl->m_pBand->SetModifiedFlag( TRUE );
		}
	}
	else
	{
		m_PChannelList.SetSel(-1, FALSE);
		m_pBandCtrl->m_pBand->UnselectAllInstruments();
		m_PChannelList.Invalidate();
		UpdateCommonPropertiesObject();
		RefreshPChannelPropertyPage();
	}

	// Show the selected items.
	if(pInstrument && bRefreshUI)
	{
		m_PChannelList.Invalidate();
		UpdateCommonPropertiesObject();
		RefreshPChannelPropertyPage();
	}
}

void CBandDlg::DisplayStatus(long nChannel)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CString str;
	BSTR bstr;
	CString csFormatStr;

	CCommonInstrumentPropertyObject& commonInstrumentObject = CInstrumentListItem::m_CommonPropertyObject;

	if(nChannel >= 0)
	{
		CDMInstrument* pInstrument = m_pBandCtrl->m_pBand->GetInstrumentFromList(nChannel);
		ASSERT(pInstrument);

		// update the pan/vol status pane
		short nPan = pInstrument->bPan;
		short nVolume = pInstrument->bVolume;
		
		str = GetPanVolumeText(nPan, nVolume);
	}
	else
		str = GetPanVolumeText(short(commonInstrumentObject.GetPan()), short(commonInstrumentObject.GetVolume()));

	bstr = str.AllocSysString();
	m_pBandCtrl->m_pComponent->m_pIFramework->SetStatusBarPaneText( m_pBandCtrl->m_hKeyStatusBar, 0, bstr, TRUE );
}


void CBandDlg::PopulatePChannelList()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CBand* pBand = m_pBandCtrl->m_pBand;
	
	CPtrList* pList = (CPtrList*)pBand->GetInstrumentList();
	POSITION position = pList->GetHeadPosition();

	int nCount = 0;
	while(position)
	{
		CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*)pList->GetNext(position);
		ASSERT(pInstrumentItem);
		if(pInstrumentItem)
		{
			AddPChannel(nCount, pInstrumentItem);
			nCount++;
		}
	}
}

void CBandDlg::UpdatePChannelChanges(bool bResetChannelList, bool fChangeToBandProperties)
{
	if(!bResetChannelList)
	{
		RefreshSelectedItems();
	}
	else
	{
		RefreshPChannelList();
	}

	UpdateCommonPropertiesObject();

	RefreshPChannelPropertyPage(fChangeToBandProperties);
}


void CBandDlg::UpdateGridControls()
{
	// update controls in the display
	int nNumberOfInstruments = m_pBandCtrl->m_pBand->m_lstInstruments.GetCount();
	for( int i = 0; i < nNumberOfInstruments; i++ )
	{
		CDMInstrument* pInstrument = m_pBandCtrl->m_pBand->GetInstrumentByIndex(i);
		ASSERT(pInstrument);
		
		m_MixGrid.UpdateButton( pInstrument->dwPChannel);
		m_MixGrid.SetEnabled( pInstrument->dwPChannel, (pInstrument->dwFlags & DMUS_IO_INST_PATCH));
	}
}

void CBandDlg::RefreshSelectedItems()
{
	CBand* pBand = GetBand();
	ASSERT(pBand);
	if(pBand == NULL)
	{
		return;
	}

	int nSelectedChannels = pBand->GetNumberOfSelectedInstruments();
	if(nSelectedChannels == 0)
	{
		return;
	}

	CInstrumentListItem** ppInstrumentsArray = new CInstrumentListItem*[nSelectedChannels];
	ASSERT(ppInstrumentsArray);
	if(ppInstrumentsArray == NULL)
	{
		return;
	}
	pBand->GetSelectedInstruments(ppInstrumentsArray);

	for(int nCount = 0; nCount < nSelectedChannels; nCount++)
	{
		CInstrumentListItem* pInstrumentItem = ppInstrumentsArray[nCount];
		ASSERT(pInstrumentItem);
		if(pInstrumentItem)
		{
			CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
			ASSERT(pInstrument);
			if(pInstrument)
			{
				m_MixGrid.UpdateButton( pInstrument->dwPChannel);
				m_MixGrid.SetEnabled(pInstrument->dwPChannel, (pInstrument->dwFlags & DMUS_IO_INST_PATCH));
			}
		}
	}

	delete[] ppInstrumentsArray;

	m_PChannelList.Invalidate();
}


void CBandDlg::RefreshPChannelList()
{
	// Remove everything from the list and repopulate it.
	m_PChannelList.ResetContent();
	PopulatePChannelList();

	// Show the selected items.
	SetSelectedPChannels();
}


void CBandDlg::SetSelectedPChannels()
{
	int nPChannels = m_PChannelList.GetCount();

	for(int nCount = 0; nCount < nPChannels; nCount++)
	{
		CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*) m_PChannelList.GetItemDataPtr(nCount);
		ASSERT(pInstrumentItem);
		if(pInstrumentItem->IsSelected()) 
			m_PChannelList.SetSel(nCount); 
	}
}

CString CBandDlg::FormatForDisplay(CDMInstrument* pInstrument)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString sPChannelNumber;
	sPChannelNumber.Format("%d", pInstrument->dwPChannel + 1);

	CString sPChannelName("");

	CString sInstrumentName;

	sInstrumentName = CBandDlg::GetPatchName(m_pBandCtrl->m_pComponent, pInstrument);

	CString sOctave = GetOctave(pInstrument);
	
	return sPChannelNumber + "\t" + sPChannelName + "\t" + sInstrumentName + "\t" + sOctave;
}

void CBandDlg::UpdatePChannelList()
{
	int nItemCount = m_PChannelList.GetCount();
	
	while(nItemCount)
	{
		nItemCount = m_PChannelList.DeleteString(0);
	}

	PopulatePChannelList();
}



CString CBandDlg::GetPatchName(CBandComponent* pComponent, CDMInstrument* pInstrument)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	BInstr* pbi = NULL;
	CString str ="";

	ASSERT(pInstrument);
	if(pInstrument == NULL)
		return str;

	ASSERT(pComponent);
	if(pComponent == NULL)
		return str;

	// Check if it's a drum track
	if(pInstrument->IsDrums())
		pbi =  &abiDrums[0];
	else
		pbi = &abiGS[0];

	DWORD dwPatch = pInstrument->dwPatch;
	
	if( pComponent->IsGM(dwPatch >> 8, dwPatch & 0x7F ) )
	{
		// find the patch in the instrument database
		while( pbi->nStringId != IDS_PGMEND )
		{
			if( pbi->bPatch == (dwPatch & 0x7F)  &&
				pbi->bMSB   == MSB(dwPatch)  &&
				pbi->bLSB   == LSB(dwPatch) )
			{
				// update the program button label
				str = *pbi->pstrName;
				if( pbi->bMSB != 0  ||  pbi->bLSB != 0 )
				{
					str += " (GS)";
				}
				
				return str;
			}
			pbi++;
		}	
	}
	BOOL fGotName = FALSE;
	signed char szName[200];

	dwPatch = pInstrument->dwPatch;
	if (pInstrument->m_pDMReference)
	{
		IDMUSProdReferenceNode*  pDLSRef = pInstrument->m_pDMReference;
		IDLSQueryInstruments *pDLSQuery;
		pDLSRef->QueryInterface(IID_IDLSQueryInstruments,(void **)&pDLSQuery);
		if (pDLSQuery)
		{
			fGotName = pDLSQuery->GetInstrumentName((BYTE)MSB(dwPatch), (BYTE)LSB(dwPatch),	
													(BYTE)(dwPatch & 0x7F),	pInstrument->IsDrums(),	
													szName, 200 );
			pDLSQuery->Release();
		}
	}

	if( fGotName )
	{
		str = (char *) szName;
		str += " (DLS)";
	}
	else  
	{
		// Set the Collection reference to NULL since 
		// no collection with this MSB, LSB and Patch were found
		pInstrument->SetDLSCollection(NULL);

		dwPatch = pInstrument->dwPatch;
		str.Format( "DLS %d,%d,%d",
			MSB(dwPatch),
			LSB(dwPatch),
			dwPatch & 0x7F );
	}
	return str;
}



CString CBandDlg::GetOctave(CDMInstrument* pInstrument)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CString str;

	if( pInstrument->nTranspose == 0 )  
		str = "--";
	else  
	{
		if( pInstrument->nTranspose > 0 )
			str.Format( "+%1d", pInstrument->nTranspose / 12 );
		else  
			str.Format( "%1d", pInstrument->nTranspose / 12 );
	}	

	return str;
}

void CBandDlg::GetItemRect( UINT id, CRect *prectRel, BOOL bInvalidate )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CWnd  *wnd;
	CRect  rectDlg, rectBtnScreen, rectBtnClient, rectRel;

	// get the dialog window rectangle
	GetWindowRect( &rectDlg );

	// get the item's window handle and rectangles
	wnd = GetDlgItem( id );

	if( !wnd )
	{
		return;
	}

	wnd->GetWindowRect( &rectBtnScreen );
	wnd->GetClientRect( &rectBtnClient );

	// math to get the item coordinates relative to the dialog area
	rectRel.left = rectBtnScreen.left - rectDlg.left;
	rectRel.top = rectBtnScreen.top - rectDlg.top;
	rectRel.right = rectRel.left + rectBtnClient.right;
	rectRel.bottom = rectRel.top + rectBtnClient.bottom;

	// copy it
	if( prectRel )  {
		prectRel->left = rectRel.left;
		prectRel->top = rectRel.top;
		prectRel->right = rectRel.right;
		prectRel->bottom = rectRel.bottom;
	}

	// invalidate it
	if( bInvalidate )  {
		rectRel.right += 2;
		rectRel.bottom += 2;
		InvalidateRect( &rectRel );
}	}


// Called from the CPChannelList class to update the status bar and grid on Mouse move
void CBandDlg::EnableGridButtonAndUpdateStatus(int nChannel, bool bShowSelected)
{
	if(bShowSelected)
	{
		m_MixGrid.BringToFront(nChannel);
		DisplayStatus(nChannel);
	}

	m_MixGrid.SelectButton(nChannel, bShowSelected);
}

// Called on an event fron the CGridCtrl class
void CBandDlg::OnCursorOverGrid(long nId) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_nTrackEdit = nId;
	DisplayStatus(nId - 1); // ID of a button in the grid is already +1
}

void  CBandDlg::RefreshDisplay()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Set the dialog for the common property object
	CInstrumentListItem::m_CommonPropertyObject.SetBandDialog(this);

	UpdateGridControls();

	RefreshPChannelList();

	UpdateCommonPropertiesObject();

	RefreshPChannelPropertyPage();

}


HBRUSH CBandDlg::OnCtlColor( CDC* pDC, CWnd* pWnd, UINT nCtlColor ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	pDC->SetTextColor( RGB(0,0,0) );

	HBRUSH hbr = CFormView::OnCtlColor( pDC, pWnd, nCtlColor );
	
	if( nCtlColor == CTLCOLOR_STATIC )
	{
		int nID = pWnd->GetDlgCtrlID();

		if( nID >= IDC_NAME1
		&&  nID <= IDC_NAME16 )
		{
			CDMInstrument* pInstrument = m_pBandCtrl->m_pBand->GetInstrumentFromList(nID - IDC_NAME1);
			ASSERT(pInstrument);

			if( !(pInstrument->dwFlags & DMUS_IO_INST_PATCH) )
			{
				pDC->SetTextColor( ::GetSysColor(COLOR_BTNSHADOW) );
			}
		}
	}

	return hbr;
}

void CBandDlg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pWnd != NULL );
	
	if( pWnd->GetDlgCtrlID() == IDC_PCHANNEL_LIST)
	{
		int nSelectedChannels = GetBand()->GetNumberOfSelectedInstruments();
	
		CMenu menu;
		m_PChannelList.SetFocus(); 

		if( menu.LoadMenu(IDR_PCHANNELLIST_MENU))
		{
			CMenu* pPopup = menu.GetSubMenu(0 );
			if(nSelectedChannels == 0)
			{
				menu.EnableMenuItem(ID_DELETE_PCHANNEL, MF_GRAYED);
				menu.EnableMenuItem(IDM_PROPERTIES, MF_GRAYED);
			}
			pPopup->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this );
		}
	}
}

void CBandDlg::OnSelchangePchannelList() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// This notification is received everytime the user navigates with the arrow key,
	// regradless of whether the selection has changed or not.
	// So we go and get the selected items every time and keep the list updated.

	CInstrumentListItem* pInstrumentItem = NULL;
	CDMInstrument* pInstrument = NULL;
	int nChannels = m_PChannelList.GetCount();
	bool bShowStatusForMultipleChannels = false;

	for(int nCount=0; nCount < nChannels; nCount++)
	{

		int nSelected = m_PChannelList.GetSel(nCount);
		
		pInstrumentItem = (CInstrumentListItem*)m_PChannelList.GetItemDataPtr(nCount);
		ASSERT(pInstrumentItem);

		pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);
		
		if( nSelected > 0 && nSelected != LB_ERR)
		{
			pInstrumentItem->SetSelected(true);
			if(m_PChannelList.GetSelCount() > 1)
			{
				m_MixGrid.BringToFront(pInstrument->dwPChannel);
				m_MixGrid.SelectButton(pInstrument->dwPChannel, true);
				bShowStatusForMultipleChannels = true;
			}
			else
			{
				EnableGridButtonAndUpdateStatus(pInstrument->dwPChannel, true);
			}
		}
		else
		{
			pInstrumentItem->SetSelected(false);
			RECT itemRect;
			m_PChannelList.GetItemRect(nCount, &itemRect);
			m_PChannelList.InvalidateRect(&itemRect);
			EnableGridButtonAndUpdateStatus(pInstrument->dwPChannel, false);
		}
	}

	SendAllNotesOffIfNotPlaying();

	UpdateCommonPropertiesObject();

	RefreshPChannelPropertyPage();
	
	if(bShowStatusForMultipleChannels)
		DisplayStatus(-1);
}


void CBandDlg::OnDblClkPChannelList() 
{
	OnProperties();
}


void CBandDlg::OnProperties() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CInstrumentListItem::m_CommonPropertyObject.OnShowProperties();
}

void CBandDlg::UpdateCommonPropertiesObject()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	int nSelectedChannels = m_pBandCtrl->m_pBand->GetNumberOfSelectedInstruments();

	CInstrumentListItem::m_CommonPropertyObject.SetSelectedChannels(nSelectedChannels);
	
	// Do nothing if nothing is selected
	if(nSelectedChannels == 0)
		return;
	
	CInstrumentListItem** ppInstrumentsArray = new CInstrumentListItem* [nSelectedChannels];
	ASSERT(ppInstrumentsArray);

	m_pBandCtrl->m_pBand->GetSelectedInstruments(ppInstrumentsArray);

	// Reset the common properties values so we can diff for the common values again
	CInstrumentListItem::m_CommonPropertyObject.SetReset(true);
	for(int nCount=0; nCount < nSelectedChannels; nCount++)
	{
			ppInstrumentsArray[nCount]->m_CommonPropertyObject.SetProperties(this, ppInstrumentsArray[nCount]->GetInstrument());
			ppInstrumentsArray[nCount]->m_CommonPropertyObject.SetReset(false);
	}
	
	delete[] ppInstrumentsArray;	
}


/////////////////////////////////////////////////////////////////////////////
// CBandDlg::RefreshPChannelPropertyPage	

void CBandDlg::RefreshPChannelPropertyPage( bool fChangeToBandProperties )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdFramework* pFramework = m_pBandCtrl->m_pComponent->m_pIFramework;
	ASSERT(pFramework);


	if( pFramework )
	{
		IDMUSProdPropSheet* pIPropSheet;

		// Get IDMUSProdPropSheet interface
		if( SUCCEEDED ( pFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() == S_OK && pIPropSheet->IsEqualPageManagerObject(&(CInstrumentListItem::m_CommonPropertyObject)) != S_OK)
			{
				if( fChangeToBandProperties )
				{
					CInstrumentListItem::m_CommonPropertyObject.OnShowProperties();
				}
			}
			else if( pIPropSheet->IsShowing() == S_OK)
			{
				CWnd* pWnd = GetFocus();
				pIPropSheet->RefreshActivePageByObject(&(CInstrumentListItem::m_CommonPropertyObject));
				if(pWnd)
					pWnd->SetFocus();
			}

			RELEASE(pIPropSheet);
		}
	}
}

CBand* CBandDlg::GetBand()
{
	return m_pBandCtrl->m_pBand;
}


int CBandDlg::OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT nIndex) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch(nKey)
	{
		/*case VK_INSERT :
		{
			InsertPChannel();
			break;
		}*/
		case VK_DELETE :
		{
			OnDeleteCommand();
			
			break;
		}
		
		case 'a':
		case 'A':
		{
			if(GetKeyState(VK_CONTROL))
			{
				SelectAllPChannels();
			}
			break;
		}

		default:
		{
			break;
		}
	}
	
	return CFormView::OnVKeyToItem(nKey, pListBox, nIndex);
}

void CBandDlg::InsertPChannel()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Limit the PChannels to 999
	CBand* pBand = GetBand();
	ASSERT(pBand);

	int nPChannels = pBand->GetInstrumentCount();
	if(nPChannels < 999)
	{

		SaveStateForUndo("Insert PChannel");

		CInstrumentListItem* pInstrumentItem = m_pBandCtrl->m_pBand->InsertIntoInstrumentList(); // Start from the beginning
		ASSERT(pInstrumentItem);
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);
		pInstrument->Send(m_pBandCtrl->m_pBand, DM_PATCH_CHANGE);
		AddPChannel(-1, pInstrumentItem);
		AddToGrid(pInstrumentItem);
		m_pBandCtrl->m_pBand->SetModifiedFlag( TRUE );
		pInstrument->SendBandUpdate(pBand);
	}
}

void CBandDlg::AddPChannel(int nIndex, CInstrumentListItem* pInstrumentItem)
{
	CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
	ASSERT(pInstrument);

	CString sInstrumentDetails = FormatForDisplay(pInstrument);

	// Find a good place for this instrument
	int nChannels = m_PChannelList.GetCount();
	for(int nCount=0; nCount<nChannels && nIndex < 0; nCount++)
	{
		CInstrumentListItem* pItemInList = (CInstrumentListItem*)m_PChannelList.GetItemDataPtr(nCount);
		ASSERT(pItemInList);
		CDMInstrument* pInstInList = pItemInList->GetInstrument();
		ASSERT(pInstInList);

		if(pInstInList->dwPChannel > pInstrument->dwPChannel)
		{
			if(nCount > 0)
				nIndex = nCount;
			else
				nIndex = 0;

			break;
		}
	}

	int nInsertionIndex = m_PChannelList.InsertString(nIndex, sInstrumentDetails);
	ASSERT( nInsertionIndex != LB_ERR);

	int nErrorCode = m_PChannelList.SetItemDataPtr(nInsertionIndex, pInstrumentItem);
	
	ASSERT( nErrorCode != LB_ERR);
}

void CBandDlg::AddToGrid(CInstrumentListItem* pInstrumentItem)
{
	ASSERT(pInstrumentItem);
	CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
	ASSERT(pInstrument);

	// Every tenth channel in the group of 16 instruments is the drumkit
	if(pInstrument->dwPChannel != 9 && (pInstrument->dwPChannel)%16 != 9)
	{
		m_MixGrid.AddButton((LPUNKNOWN)pInstrumentItem);
		m_MixGrid.SetEnabled(pInstrument->dwPChannel, (pInstrument->dwFlags & DMUS_IO_INST_PATCH));
	}
	else
	{
		// Drums
		m_MixGrid.AddButton((LPUNKNOWN)pInstrumentItem);
		m_MixGrid.SetEnabled(pInstrument->dwPChannel, (pInstrument->dwFlags & DMUS_IO_INST_PATCH));
	}
}

void CBandDlg::DeleteSelectedPChannels()
{
	ASSERT(m_pBandCtrl);
	if(m_pBandCtrl == NULL)
	{
		return;
	}

	CBand* pBand = m_pBandCtrl->m_pBand;
	ASSERT(pBand);
	if(pBand == NULL)
	{
		return;
	}

	SendAllNotesOffIfNotPlaying();

	int nSelectedChannels = pBand->GetNumberOfSelectedInstruments();
		
	CInstrumentListItem** ppInstrumentsArray = new CInstrumentListItem* [nSelectedChannels];
	ASSERT(ppInstrumentsArray);
	pBand->GetSelectedInstruments(ppInstrumentsArray);

	for(int nCount=0; nCount < nSelectedChannels; nCount++)
	{
		CInstrumentListItem* pInstrumentItem = ppInstrumentsArray[nCount];
		ASSERT(pInstrumentItem);

		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);

		m_MixGrid.RemoveButton((long)pInstrument->dwPChannel);
	}
	m_PChannelList.ResetContent();
	for(nCount=0; nCount < nSelectedChannels; nCount++)
	{
		CInstrumentListItem* pInstrumentItem = ppInstrumentsArray[nCount];
		ASSERT(pInstrumentItem);

		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);
		
		CBand* pBand = GetBand();
		ASSERT(pBand);
		pInstrument->Send(pBand, DM_PATCH_CHANGE);
		pBand->DeleteFromInstrumentList(pInstrumentItem);
	}
	
	RefreshDisplay();
	int nChannelCount = m_PChannelList.GetCount();
	if(nChannelCount > 0)
	{
		CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*)m_PChannelList.GetItemDataPtr(0);
		ASSERT(pInstrumentItem);
		if(pInstrumentItem)
		{
			pInstrumentItem->SetSelected(true);
			m_PChannelList.SetCurSel(0);
		}
	}

	delete[] ppInstrumentsArray;	

	// sync the band
	pBand->NotifyEveryone(GUID_BAND_ChangeNotifyMsg);
}

void CBandDlg::ChangePChannelNumber(CDMInstrument* pInstrument, DWORD newPChannel)
{
	if(pInstrument->dwPChannel == newPChannel)
		return;
	
	m_PChannelList.ResetContent();
	m_MixGrid.RemoveButton((long)pInstrument->dwPChannel);
	CInstrumentListItem* pInstrumentItem = GetBand()->ChangePChannelNumber(pInstrument->dwPChannel, newPChannel);
	ASSERT(pInstrumentItem);
	AddToGrid(pInstrumentItem);
	
	CString sDisplayString = FormatForDisplay(pInstrument);
	m_PChannelList.SelectString(0, sDisplayString);
}


void CBandDlg::LoadIntervals()
{
	for(int nCount = 0; nCount < 12; nCount++)
	{
		m_arrIntervals[nCount].LoadString(IDS_NO_TRANSPOSE + nCount);
	}
}

CString CBandDlg::GetInterval(int nTranspose)
{
	if(nTranspose >= 11)
	{
		nTranspose = 11;
	}
	
	if(nTranspose <= -11)
	{
		nTranspose = -11;
	}

	CString sTranspose = "";
	int nIndex = nTranspose;
	if( nIndex < 0)
	{
		sTranspose = "-";
			nIndex = -nIndex;
	}
	else if(nIndex > 0)
	{
		sTranspose = "+";
	}

	sTranspose += m_arrIntervals[nIndex];

	return sTranspose;
}


bool CBandDlg::GetTransposeValue(CString sTransposeString, LPINT pnTranspose)
{
	ASSERT(pnTranspose);
	if(pnTranspose == NULL)
	{
		return false;
	}

	bool bNegative = false;

	if(sTransposeString.GetAt(0) == '-')
	{
		bNegative = true;
		sTransposeString = sTransposeString.Right(sTransposeString.GetLength() - 1);
	}
	else if(sTransposeString.GetAt(0) == '+')
	{
		sTransposeString = sTransposeString.Right(sTransposeString.GetLength() - 1);
	}


	if(sTransposeString.GetLength() < 3 && _ttol(sTransposeString) > 0 && _ttol(sTransposeString) <= 12)
	{
		if(bNegative)
			*pnTranspose = 0 - _ttol(sTransposeString);
		else
			*pnTranspose = _ttol(sTransposeString);

		return true;
	}

	int nCount;
	for(nCount = 0; nCount < 12; nCount++)
	{
		if(m_arrIntervals[nCount].CompareNoCase(sTransposeString) == 0)
			break;
	}

	if(nCount == 12)
		return false;

	
	if(bNegative)
		*pnTranspose = 0 - nCount;
	else
		*pnTranspose = nCount;

	return true;
}

CString CBandDlg::GetPanVolumeText(short nPan, short nVolume)
{
	CString sPan;
	if(nPan >= 0)
	{
		if(nPan > 63)
			sPan.Format("Pan R%d", nPan - 63);
		else if(nPan < 63)
			sPan.Format("Pan L%d", 63 - nPan);
		else if(nPan == 63)
			sPan.Format("Pan Mid");
	}
	else
		sPan = "-- ";
	
	// update the status bar
	CString sVolume;
	if(nVolume >= 0)
		sVolume.Format(" Vol %d", nVolume);
	else
		sVolume = " --";
	
	return sPan + sVolume;
}

void CBandDlg::LoadNotes()
{
	for(int nNote = 0; nNote < 12; nNote++)
	{
		m_arrNotes[nNote].LoadString(IDS_NOTE_C + nNote);
	}
}

HRESULT CBandDlg::GetNoteValue(CString sNoteText, LPINT pnNote)
{
	ASSERT(pnNote);
	if(pnNote == NULL)
	{
		return E_POINTER;
	}

	// Take out the white spaces
	sNoteText.TrimLeft();
	sNoteText.TrimRight();

	bool bSyntaxOK = false;
	UINT nNoteIndex = 0;

	CString sRemaining = sNoteText;
	
	// If it's the note in numbers we just return what we have
	bool bAllDigits = true;
	for(int nChar = 0; nChar < sRemaining.GetLength(); nChar++)
	{
		if(_istdigit(sRemaining.GetAt(nChar)) == 0)
		{
			bAllDigits = false;
			break;
		}
	}

	if(bAllDigits)
	{
		*pnNote = atoi(sRemaining);
		return S_OK;
	}

	// Has to be a number or alphabet
	if(isalnum(sNoteText.GetAt(0)) == false)
	{
		return E_FAIL;
	}

	if(isdigit(sNoteText.GetAt(0)))
	{
		bSyntaxOK = true;
	}

	CString sFirstChar = sNoteText.GetAt(0);
	for(int nNote = 0; (nNote < 12 && bSyntaxOK == false); nNote++)
	{
		if(sFirstChar.CompareNoCase(m_arrNotes[nNote]) == 0)
		{
			nNoteIndex = nNote;
			bSyntaxOK = true;
			sRemaining = sNoteText.Right(sNoteText.GetLength() - 1);
			break;
		}
	}

	if(!bSyntaxOK)
	{
		return E_FAIL;
	}

	if(sRemaining.IsEmpty())
	{
		*pnNote = nNoteIndex;
	}

	// Sharp or a flat?
	TCHAR tchSecond = sRemaining.GetAt(0);
	if(tchSecond != '#' && (tchSecond != 'b' || tchSecond != 'B') && _istalpha(tchSecond))
	{
		return E_FAIL;
	}

	if(tchSecond == '#')
	{
		nNoteIndex++;
		CString sTemp = sRemaining.Right(sRemaining.GetLength() - 1);
		sRemaining = sTemp;
	}
	else if(tchSecond == 'b' || tchSecond == 'B')
	{
		nNoteIndex--;
		CString sTemp = sRemaining.Right(sRemaining.GetLength() - 1);
		sRemaining = sTemp;
	}

	// Do we have an octave?
	if(!sRemaining.IsEmpty())
	{
		// Check if all characters are digits...
		for(int nChar = 0; nChar < sRemaining.GetLength(); nChar++)
		{
			if(_istdigit(sRemaining.GetAt(nChar)) == 0)
			{
				return E_FAIL;
			}
		}

		int nOctave = atoi(sRemaining) * 12;
		nNoteIndex += nOctave;
	}

	*pnNote = nNoteIndex;
	return S_OK;
}


CString	CBandDlg::GetNoteText(UINT nNote)
{
	CString sOctave = "";
	int nOctave = nNote / 12;
	sOctave.Format("%d", nOctave);
	nNote -= nOctave * 12;

	CString sNote = m_arrNotes[nNote];
	CString sNoteText = sNote + sOctave;
	return sNoteText;
}



void CBandDlg::OnDeleteCommand()
{
	ASSERT(m_pBandCtrl);
	if(m_pBandCtrl == NULL)
	{
		return;
	}

	CBand* pBand = m_pBandCtrl->m_pBand;
	ASSERT(pBand);
	if(pBand == NULL)
	{
		return;
	}

	int nSelectedChannels = pBand->GetNumberOfSelectedInstruments();
	if(nSelectedChannels == 0)
	{
		return;
	}

	CWnd* pLastFocusWnd = GetFocus();
	if( AfxMessageBox( IDS_REMOVEWARNING, MB_YESNO ) == IDYES )
	{
		SaveStateForUndo("Delete PChannel");

		int nChannelCount = m_PChannelList.GetCount();
				
		if(nChannelCount > 0)
		{
			DeleteSelectedPChannels();
			pBand->SetModifiedFlag( TRUE );
		}
	}
	if(pLastFocusWnd)
	{
		pLastFocusWnd->SetFocus();
	}
}


void CBandDlg::RemoveAndAddAllButtonsToGrid()
{
	m_MixGrid.RemoveAllButtons();
	
	CPtrList* plstInstruments = &(m_pBandCtrl->m_pBand->m_lstInstruments);
	POSITION position  = plstInstruments->GetHeadPosition();
	while(position)
	{
		CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*)plstInstruments->GetNext(position);
		ASSERT(pInstrumentItem);
		AddToGrid(pInstrumentItem);
	}
}


void CBandDlg::SaveStateForUndo(char* szStateName)
{
	// save the state for undo
	IPersistStream *pIPStream;
	m_pBandCtrl->m_pBand->QueryInterface( IID_IPersistStream, (void **) &pIPStream );
	if( pIPStream )
	{
		m_pBandCtrl->m_pBand->m_bInUndoRedo = true;
		m_pBandDo->SaveState( pIPStream, szStateName);
		m_pBandCtrl->m_pBand->m_bInUndoRedo = false;
		pIPStream->Release();
	}	
}

void CBandDlg::OnSelectPChannelGrid(long nId, BOOL bSelection, BOOL bCtrlDown) 
{

}

void CBandDlg::OnSaveUndoStateGrid() 
{
	SaveStateForUndo("Pan/Volume Changes");
}

void CBandDlg::OnDisplayStatusGrid(short nId) 
{
	DisplayStatus(nId);
}

void CBandDlg::SelectAllPChannels()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pBandCtrl);
	if(m_pBandCtrl == NULL)
	{
		return;
	}

	CBand* pBand = m_pBandCtrl->m_pBand;
	ASSERT(pBand);
	if(pBand == NULL)
	{
		return;
	}

	pBand->SelectAllInstruments();
	int nItemCount = m_PChannelList.GetCount();
	for(int nIndex = 0; nIndex < nItemCount; nIndex++)
	{
		m_PChannelList.SetSel(nIndex);
	}

	OnSelchangePchannelList();
}

void CBandDlg::RegisterMidi() 
{
	ASSERT(m_pBandCtrl->m_pComponent);
	if(m_pBandCtrl->m_pComponent == NULL)
	{
		return;
	}

	if( m_dwCookie == 0 )
	{
		REGISTER_MIDI_IN(m_pBandCtrl->m_pComponent->m_pIConductor, m_dwCookie)
	}
}

void CBandDlg::UnRegisterMidi()
{
	ASSERT(m_pBandCtrl->m_pComponent);
	if(m_pBandCtrl->m_pComponent == NULL)
	{
		return;
	}

	SendAllNotesOffIfNotPlaying();

	if( m_dwCookie != 0 )
	{
		UNREGISTER_MIDI_IN(m_pBandCtrl->m_pComponent->m_pIConductor, m_dwCookie)
		m_dwCookie = 0;
	}
}

bool CBandDlg::IsMidiRegistered()
{
	if(m_dwCookie == 0)
		return false;
	else
		return true;
}


// =====================================================================
// OnMidiMsg
//  This is received when user hits a key in the midi keybd.
// RegisterMidi() should have been called for this to work.
// =====================================================================
HRESULT CBandDlg::OnMidiMsg(REFERENCE_TIME dwTime, BYTE bStatus, BYTE bData1, BYTE bData2)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(m_pBandCtrl->m_pComponent);
	if(m_pBandCtrl->m_pComponent == NULL)
	{
		return E_FAIL;
	}

	ASSERT(m_pBandCtrl->m_pComponent->m_pIConductor);
	if(m_pBandCtrl->m_pComponent->m_pIConductor == NULL)
	{
		return E_FAIL;
	}

	PlayMIDIEvent(bStatus & 0xF0, bData1, bData2);
	return S_OK;
}


HRESULT CBandDlg::PlayMIDIEvent(BYTE bStatus, BYTE bData1, BYTE bData2)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if(m_PChannelList.GetSelCount() == 0)
	{
		return E_FAIL;
	}

	CBandComponent* pComponent = m_pBandCtrl->m_pComponent;

	IDirectMusicPerformance* pIDMPerformance = pComponent->m_pIDMPerformance;
	ASSERT(pIDMPerformance != NULL);
	if (pIDMPerformance == NULL )
	{
		return E_UNEXPECTED;
	}

	HRESULT hr = E_FAIL;
	
	int nIndex = 0;
	int nFirstInstrument = m_PChannelList.GetSelItems(1, &nIndex);
	CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*)m_PChannelList.GetItemDataPtr(nIndex);
	ASSERT(pInstrumentItem);
	if(pInstrumentItem == NULL)
	{
		return E_FAIL;
	}

	CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
	ASSERT(pInstrument);
	if(pInstrument == NULL)
	{
		return E_FAIL;
	}

	REFERENCE_TIME rtNow;
	pIDMPerformance->GetLatencyTime(&rtNow);
	MUSIC_TIME mtLatency;
	pIDMPerformance->ReferenceToMusicTime( rtNow, &mtLatency );

	// If there currently is no primary segment playing, send down the selected patch
	IDirectMusicSegmentState *pSegState;
	if( FAILED( pIDMPerformance->GetSegmentState( &pSegState, mtLatency ) ) )
	{
		if( pInstrument->dwFlags & DMUS_IO_INST_PATCH )
		{
			DMUS_PATCH_PMSG *pPatchEvent;
			hr = pIDMPerformance->AllocPMsg( sizeof(DMUS_PATCH_PMSG), (DMUS_PMSG **)&pPatchEvent );
			if( FAILED( hr ) )
			{
				return hr;
			}

			ZeroMemory( pPatchEvent, sizeof(DMUS_PATCH_PMSG) );
			// PMSG fields
			pPatchEvent->dwSize = sizeof(DMUS_PATCH_PMSG);
			pIDMPerformance->GetLatencyTime( &pPatchEvent->rtTime );
		//	pPatchEvent->mtTime = 0;
			pPatchEvent->dwFlags = DMUS_PMSGF_REFTIME;
			pPatchEvent->dwPChannel = pInstrument->dwPChannel;
			pPatchEvent->dwVirtualTrackID = 1;
		//	pPatchEvent->pTool = NULL;
		//	pPatchEvent->pGraph = NULL;
			pPatchEvent->dwType = DMUS_PMSGT_PATCH;
		//	pPatchEvent->punkUser = 0;

			// PATCH fields
			const DWORD dwPatch = pInstrument->dwPatch;
			pPatchEvent->byInstrument = BYTE(dwPatch & 0x7f);
			pPatchEvent->byMSB = BYTE((dwPatch >> 16) & 0x7f);
			pPatchEvent->byLSB = BYTE((dwPatch >> 8) & 0x7f);
		//	pPatchEvent->byPad[0] = 0;

			pComponent->SendPMsg( (DMUS_PMSG *)pPatchEvent );
		}

		if( pInstrument->dwFlags & DMUS_IO_INST_PAN )
		{
			DMUS_MIDI_PMSG* pDMMidiEvent = NULL;
			hr = pIDMPerformance->AllocPMsg(sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG**)&pDMMidiEvent);
			if(FAILED(hr))
			{
				return hr;
			}

			ZeroMemory( pDMMidiEvent, sizeof(DMUS_MIDI_PMSG) );

			pDMMidiEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
			pDMMidiEvent->bStatus = MIDI_CONTROL_CHANGE;
			pDMMidiEvent->bByte1 = MIDI_CC_PAN;
			pDMMidiEvent->bByte2 = pInstrument->bPan;
			pIDMPerformance->GetLatencyTime(&pDMMidiEvent->rtTime);
			pDMMidiEvent->dwFlags = DMUS_PMSGF_REFTIME;
			pDMMidiEvent->dwPChannel = pInstrument->dwPChannel;
			pDMMidiEvent->dwVirtualTrackID = 1;
			pDMMidiEvent->dwType = DMUS_PMSGT_MIDI;

			// This converts the PChannel, using the performance's default audiopath
			pComponent->SendPMsg( (DMUS_PMSG *)pDMMidiEvent);
		}

		if( pInstrument->dwFlags & DMUS_IO_INST_VOLUME )
		{
			DMUS_MIDI_PMSG* pDMMidiEvent = NULL;
			hr = pIDMPerformance->AllocPMsg(sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG**)&pDMMidiEvent);
			if(FAILED(hr))
			{
				return hr;
			}

			ZeroMemory( pDMMidiEvent, sizeof(DMUS_MIDI_PMSG) );

			pDMMidiEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
			pDMMidiEvent->bStatus = MIDI_CONTROL_CHANGE;
			pDMMidiEvent->bByte1 = MIDI_CC_VOLUME;
			pDMMidiEvent->bByte2 = pInstrument->bVolume;
			pIDMPerformance->GetLatencyTime(&pDMMidiEvent->rtTime);
			pDMMidiEvent->dwFlags = DMUS_PMSGF_REFTIME;
			pDMMidiEvent->dwPChannel = pInstrument->dwPChannel;
			pDMMidiEvent->dwVirtualTrackID = 1;
			pDMMidiEvent->dwType = DMUS_PMSGT_MIDI;

			// This converts the PChannel, using the performance's default audiopath
			pComponent->SendPMsg( (DMUS_PMSG *)pDMMidiEvent);
		}

		if( pInstrument->dwFlags & DMUS_IO_INST_TRANSPOSE )
		{
			DMUS_TRANSPOSE_PMSG* pTransposeEvent = NULL;
			hr = pIDMPerformance->AllocPMsg(sizeof(DMUS_TRANSPOSE_PMSG), (DMUS_PMSG**)&pTransposeEvent);
			if(FAILED(hr))
			{
				return hr;
			}

			ZeroMemory( pTransposeEvent, sizeof(DMUS_TRANSPOSE_PMSG) );

			pTransposeEvent->dwSize = sizeof(DMUS_TRANSPOSE_PMSG);
			pTransposeEvent->nTranspose = pInstrument->nTranspose;
			pIDMPerformance->GetLatencyTime(&pTransposeEvent->rtTime);
			pTransposeEvent->dwFlags = DMUS_PMSGF_REFTIME;
			pTransposeEvent->dwPChannel = pInstrument->dwPChannel;
			pTransposeEvent->dwVirtualTrackID = 1;
			pTransposeEvent->dwType = DMUS_PMSGT_TRANSPOSE;

			// This converts the PChannel, using the performance's default audiopath
			pComponent->SendPMsg( (DMUS_PMSG *)pTransposeEvent);
		}

		if( pInstrument->dwFlags & DMUS_IO_INST_PITCHBENDRANGE )
		{
			//pInstrument->nPitchBendRange
			DMUS_CURVE_PMSG* pCurveEvent = NULL;
			hr = pIDMPerformance->AllocPMsg(sizeof(DMUS_CURVE_PMSG), (DMUS_PMSG**)&pCurveEvent);
			if(FAILED(hr))
			{
				return hr;
			}

			ZeroMemory( pCurveEvent, sizeof(DMUS_CURVE_PMSG) );

			pCurveEvent->dwSize = sizeof(DMUS_CURVE_PMSG);
			pIDMPerformance->GetLatencyTime(&pCurveEvent->rtTime);
			pCurveEvent->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_DX8;
			pCurveEvent->dwPChannel = pInstrument->dwPChannel;
			pCurveEvent->dwVirtualTrackID = 1;
			pCurveEvent->dwType = DMUS_PMSGT_CURVE;

			pCurveEvent->mtDuration = 1;
			pCurveEvent->nStartValue = pInstrument->nPitchBendRange << 7;
			pCurveEvent->nEndValue = pInstrument->nPitchBendRange << 7;
			pCurveEvent->bType = DMUS_CURVET_RPNCURVE;
			pCurveEvent->bCurveShape = DMUS_CURVES_INSTANT;
			pCurveEvent->wParamType = 0; // Pitchbend range

			IDirectMusicGraph *pDMGraph = NULL;
			
			hr = pIDMPerformance->QueryInterface( IID_IDirectMusicGraph, (void**) &pDMGraph );
			if ( FAILED( hr ) )
			{
				pIDMPerformance->FreePMsg( (DMUS_PMSG*)pCurveEvent );
				return hr;
			}

			// Initializes a few other DMUS_PMSG members
			pDMGraph->StampPMsg( (DMUS_PMSG*)pCurveEvent );
			pDMGraph->Release();

			// This converts the PChannel, using the performance's default audiopath
			pComponent->SendPMsg( (DMUS_PMSG *)pCurveEvent);
		}
	}
	else
	{
		pSegState->Release();
		//pSegState = NULL;
	}
	
	DMUS_MIDI_PMSG* pDMMidiEvent = NULL;
	hr = pIDMPerformance->AllocPMsg(sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG**)&pDMMidiEvent);
	if(FAILED(hr))
	{
		return hr;
	}

	ZeroMemory( pDMMidiEvent, sizeof(DMUS_MIDI_PMSG) );

	pDMMidiEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
	pDMMidiEvent->bStatus = bStatus;
	pDMMidiEvent->bByte1 = bData1;
	pDMMidiEvent->bByte2 = bData2;
	pIDMPerformance->GetLatencyTime(&rtNow);
	pDMMidiEvent->rtTime = 5000 + rtNow; // Add 0.5ms
	pDMMidiEvent->dwFlags = DMUS_PMSGF_REFTIME;
	pDMMidiEvent->dwPChannel = pInstrument->dwPChannel;
	pDMMidiEvent->dwVirtualTrackID = 1;
	pDMMidiEvent->dwType = DMUS_PMSGT_MIDI;

	// This converts the PChannel, using the performance's default audiopath
	return pComponent->SendPMsg( (DMUS_PMSG *)pDMMidiEvent);
}


HRESULT CBandDlg::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if(::IsEqualIID(riid, IID_IDMUSProdMidiInCPt)
	|| ::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = (IDMUSProdMidiInCPt *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CBandDlg::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CBandDlg::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT(m_dwRef != 0);

	AfxOleUnlockApp();
    --m_dwRef;

    if(m_dwRef == 0)
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

void CBandDlg::OnRightClickGrid(short nX, short nY) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CBand* pBand = GetBand();
	ASSERT(pBand);
	if(pBand == NULL)
	{
		return;
	}

	int nSelectedChannels = pBand->GetNumberOfSelectedInstruments();

	CMenu menu;
	if( menu.LoadMenu(IDR_PCHANNELLIST_MENU))
	{
		CMenu* pPopup = menu.GetSubMenu(0 );
		if(nSelectedChannels == 0)
		{
			menu.EnableMenuItem(ID_DELETE_PCHANNEL, MF_GRAYED);
			menu.EnableMenuItem(IDM_PROPERTIES, MF_GRAYED);
		}
		pPopup->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON, nX, nY, this );
	}
}

void CBandDlg::OnDeleteChannelGrid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	OnDeleteCommand();
}

void CBandDlg::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default
	
	CFormView::OnKeyDown(nChar, nRepCnt, nFlags);
}

void SendAllNotesOff( DWORD dwPChannel, IDirectMusicPerformance *pIDirectMusicPerformance )
{
	ASSERT( pIDirectMusicPerformance );

	IDirectMusicPerformance8 *pDMPerf8;
	if( SUCCEEDED( pIDirectMusicPerformance->QueryInterface( IID_IDirectMusicPerformance8, (void **)&pDMPerf8 ) ) )
	{
		IDirectMusicAudioPath *pDMAudioPath;
		if( SUCCEEDED( pDMPerf8->GetDefaultAudioPath( &pDMAudioPath ) ) )
		{
			pDMAudioPath->ConvertPChannel( dwPChannel, &dwPChannel );
			pDMAudioPath->Release();
		}
		pDMPerf8->Release();
	}

	DMUS_MIDI_PMSG *pDMMIDIEvent = NULL;
	if( SUCCEEDED( pIDirectMusicPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG **)&pDMMIDIEvent ) ) )
	{
		ZeroMemory( pDMMIDIEvent, sizeof(DMUS_MIDI_PMSG) );
		// PMSG fields
		pDMMIDIEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
		pDMMIDIEvent->dwFlags = DMUS_PMSGF_REFTIME;
		pDMMIDIEvent->dwPChannel = dwPChannel;
		pDMMIDIEvent->dwVirtualTrackID = 1;
		pDMMIDIEvent->dwType = DMUS_PMSGT_MIDI;

		// DMMIDIEvent fields
		pDMMIDIEvent->bStatus = MIDI_CCHANGE;
		// Send Reset All Controllers (121)
		pDMMIDIEvent->bByte1 = 121;

		pIDirectMusicPerformance->SendPMsg( (DMUS_PMSG *)pDMMIDIEvent );
		// The playback engine will release the event

		if( SUCCEEDED( pIDirectMusicPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG **)&pDMMIDIEvent ) ) )
		{
			ZeroMemory( pDMMIDIEvent, sizeof(DMUS_MIDI_PMSG) );
			// PMSG fields
			pDMMIDIEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
			pDMMIDIEvent->dwFlags = DMUS_PMSGF_REFTIME;
			pDMMIDIEvent->dwPChannel = dwPChannel;
			pDMMIDIEvent->dwVirtualTrackID = 1;
			pDMMIDIEvent->dwType = DMUS_PMSGT_MIDI;

			// DMMIDIEvent fields
			pDMMIDIEvent->bStatus = MIDI_CCHANGE;
			// Send All Notes Off (123)
			pDMMIDIEvent->bByte1 = 123;

			pIDirectMusicPerformance->SendPMsg( (DMUS_PMSG *)pDMMIDIEvent );
			// The playback engine will release the event
		}
	}
}

void CBandDlg::SendAllNotesOffIfNotPlaying( void )
{
	if( m_pBandCtrl
	&&	m_pBandCtrl->m_pBand
	&&	m_pBandCtrl->m_pComponent
	&&	m_pBandCtrl->m_pComponent->m_pIDMPerformance )
	{
		// If we're not playing, send all notes off to the performance engine
		IDirectMusicSegmentState *pIDirectMusicSegmentState = NULL;
		MUSIC_TIME mtNow;
		if( SUCCEEDED( m_pBandCtrl->m_pComponent->m_pIDMPerformance->GetTime( NULL, &mtNow ) )
		&&	FAILED( m_pBandCtrl->m_pComponent->m_pIDMPerformance->GetSegmentState( &pIDirectMusicSegmentState, mtNow ) ) )
		{
			int iPChannel;
			CPtrList* pList = (CPtrList*)m_pBandCtrl->m_pBand->GetInstrumentList();
			POSITION position = pList->GetHeadPosition();
			while(position)
			{
				CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*)pList->GetNext(position);
				if( SUCCEEDED( pInstrumentItem->GetPChannelNumber( &iPChannel ) ) )
				{
					SendAllNotesOff( iPChannel, m_pBandCtrl->m_pComponent->m_pIDMPerformance );
				}
			}
		}
		if( pIDirectMusicSegmentState )
		{
			pIDirectMusicSegmentState->Release();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandDocType.h ===
#ifndef __BANDDOCTYPE_H__
#define __BANDDOCTYPE_H__

// BandDocType.h : header file
//


class CBandDocType : public IDMUSProdDocType8
{
public:
    CBandDocType( CBandComponent* pComponent );
	~CBandDocType();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IBandDocType functions
    HRESULT STDMETHODCALLTYPE GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE DoesExtensionMatch( BSTR bstrExt );
    HRESULT STDMETHODCALLTYPE DoesIdMatch( REFGUID rguid );
    HRESULT STDMETHODCALLTYPE AllocNode( REFGUID rguid, IDMUSProdNode** ppINode );

    HRESULT STDMETHODCALLTYPE OnFileNew(IDMUSProdProject* pITargetProject,
										IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileOpen(IStream* pIStream, IDMUSProdProject* pITargetProject,
										 IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE IsFileTypeExtension( FileType ftFileType, BSTR bstrExt );   

    // IDMUSProdDocType8 functions
    HRESULT STDMETHODCALLTYPE GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc );
    HRESULT STDMETHODCALLTYPE GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType );
    HRESULT STDMETHODCALLTYPE GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt );

private:
    CBandDocType();

private:
    DWORD			m_dwRef;
	CBandComponent* m_pComponent;
};

#endif // __BANDDOCTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandEditorDLL.cpp ===
// BandEditorDLL.cpp : Implementation of CBandEditorApp and DLL registration.

#include "stdafx.h"

#include <winver.h>
#include <initguid.h>
#include "PChannelName.h"
#include "BandEditorDLL.h"
#include "BandComponent.h"

#include "StyleDesigner.h"
#include "DLSDesigner.h"
#include "dmusici.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CBandEditorApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xd824b383, 0x804f, 0x11d0, { 0x89, 0xac, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CBandEditorApp::InitInstance - DLL initialization

BOOL CBandEditorApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		AfxEnableControlContainer();
	}

	m_pClipboardObject = NULL;
	m_pIClipboardDataObject = NULL;

	m_pIFramework = NULL;
	m_pIPageManager = NULL;

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CBandEditorApp::ExitInstance - DLL termination

int CBandEditorApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// CBandEditorApp::GetHelpFileName

BOOL CBandEditorApp::GetHelpFileName( CString& strHelpFileName )
{
	TCHAR achHelpFileName[FILENAME_MAX];
	TCHAR achDrive[_MAX_DRIVE];
	TCHAR achDir[_MAX_DIR];
	TCHAR achFName[_MAX_FNAME];
	TCHAR achExt[_MAX_EXT];

	if( GetModuleFileName(NULL, achHelpFileName, FILENAME_MAX) > 0 )
	{
		_tsplitpath( achHelpFileName, achDrive, achDir, achFName, NULL );
		::LoadString( theApp.m_hInstance, IDS_HELP_FILE_EXT, achExt, _MAX_EXT );
		_tmakepath( achHelpFileName, achDrive, achDir, achFName, achExt );

		strHelpFileName = achHelpFileName;
		return TRUE;
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CBandEditorApp::PutDataInClipboard

BOOL CBandEditorApp::PutDataInClipboard( IDataObject* pIDataObject, void* pObject )
{
	if( pIDataObject )
	{
		if( ::OleSetClipboard( pIDataObject ) == S_OK )
		{
			if( m_pIClipboardDataObject )
			{
				m_pIClipboardDataObject->Release();
				m_pIClipboardDataObject = NULL;
			}

			m_pIClipboardDataObject = pIDataObject;
			m_pIClipboardDataObject->AddRef();

			m_pClipboardObject = pObject;

			return TRUE;
		}
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CBandEditorApp::FlushClipboard

void CBandEditorApp::FlushClipboard( void* pClipboardObject )
{
	if( m_pClipboardObject == pClipboardObject )
	{
		ASSERT( m_pIClipboardDataObject != NULL );

		if( ::OleIsCurrentClipboard( m_pIClipboardDataObject ) == S_OK )
		{
			::OleFlushClipboard();
		}

		if( m_pIClipboardDataObject )
		{
			m_pIClipboardDataObject->Release();
			m_pIClipboardDataObject = NULL;
		}

		m_pClipboardObject = NULL;
	}
}


////////////////////////////////////////////////////////////////////////////
// CBandEditorApp::SetNodePointers  (used by all components)

void CBandEditorApp::SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode )
{
	HRESULT hr;
    IDMUSProdNode* pIChild;
    IDMUSProdNode* pINextChild;

	ASSERT( pINode != NULL );
	ASSERT( pIDocRootNode != NULL );

	pINode->SetDocRootNode( pIDocRootNode );    
	pINode->SetParentNode( pIParentNode );    

	hr = pINode->GetFirstChild( &pINextChild );

	while( SUCCEEDED( hr )  &&  pINextChild )
	{
		pIChild = pINextChild;

		SetNodePointers( pIChild, pIDocRootNode, pINode );

		hr = pINode->GetNextChild( pIChild, &pINextChild );
		pIChild->Release();
	}
}


////////////////////////////////////////////////////////////////////////////
// CBandEditorApp::GetFileVersion

BOOL CBandEditorApp::GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	DWORD dwBufferSize;
	DWORD dwReserved;
	
	dwBufferSize = GetFileVersionInfoSize( szExeName, &dwReserved );
	if( dwBufferSize > 0 )
	{
		void* pBuffer;

		pBuffer = (void *)malloc( dwBufferSize );
		if( pBuffer )
		{
			CString strTheFileVersion;
			VS_FIXEDFILEINFO* pFixedInfo;
			UINT nInfoSize;

			GetFileVersionInfo( szExeName, dwReserved, dwBufferSize, pBuffer );
			VerQueryValue( pBuffer, _T("\\"), (void **)&pFixedInfo, &nInfoSize );

			WORD wVer1 = HIWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer2 = LOWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer3 = HIWORD( pFixedInfo->dwFileVersionLS );
			WORD wVer4 = LOWORD( pFixedInfo->dwFileVersionLS );

			strTheFileVersion.Format( _T("%u.%u.%u.%u"), wVer1, wVer2, wVer3, wVer4 );

			_tcsncpy( szFileVersion, strTheFileVersion, nFileVersionSize );

			free( pBuffer );
			return TRUE;
		}
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegDWORD - Writes a DWORD to system registry 

static BOOL SetRegDWORD( HKEY hKey, LPCTSTR lpSubKey,
						 LPTSTR lpValueName, LPDWORD lpDWORD, BOOL fOverWrite )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	DWORD dwType;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{

		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, NULL, &dwType, NULL, NULL );

		if( (lResult != ERROR_SUCCESS)
		||  (dwType != REG_DWORD)
		||  (fOverWrite == TRUE) )
		{
			dwCbData = sizeof( DWORD );
			lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_DWORD, (LPBYTE)lpDWORD, dwCbData);

			if( lResult == ERROR_SUCCESS )
			{
				fSuccess = TRUE;
			}
		}
		else
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DMUSProducer components

static BOOL RegisterComponents( void )
{
    LPOLESTR psz1;
    LPOLESTR psz2;
    LPOLESTR psz3;
    LPOLESTR psz4;
	TCHAR    szRegPath[MAX_BUFFER];
    TCHAR    szOCXPath[MAX_BUFFER];
    TCHAR    szOCXLongPath[MAX_BUFFER];
    TCHAR    szGuid1[MID_BUFFER];
    TCHAR    szGuid2[MID_BUFFER];
    TCHAR    szGuid3[MID_BUFFER];
    TCHAR    szGuid4[MID_BUFFER];
    CString  strName;
	DWORD    dwSkip = 0;
    
	GetModuleFileName( theApp.m_hInstance, szOCXLongPath, MAX_BUFFER ); 
	// This needs to be the short name, since the AfxRegister... functions
	// use the short name. (Except for AfxOleRegisterTypeLib()).
	// The type library is still using the long filename, hopefully that's ok.
	GetShortPathName( szOCXLongPath, szOCXPath, MAX_BUFFER);

// Register Band Editor Component
	if( SUCCEEDED( StringFromIID(CLSID_BandEditor, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_BAND_COMPONENT_NAME );

		_tcscpy( szRegPath, _T("CLSID") );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T("ThreadingModel"), _T("Apartment"))) )
		{
			return FALSE;
		}
	}
	if( SUCCEEDED( StringFromIID(CLSID_BandComponent, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_BAND_COMPONENT_NAME );

		_tcscpy( szRegPath, _T("CLSID") );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T("ThreadingModel"), _T("Apartment"))) )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
		||  !(SetRegDWORD(HKEY_LOCAL_MACHINE, szRegPath, _T("Skip"), &dwSkip, FALSE)) )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_BandNode, &psz1) ) 
		&&  SUCCEEDED( StringFromIID(GUID_BandRefNode, &psz2) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_BandComponent, &psz3) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_DirectMusicBand, &psz4) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
			CoTaskMemFree( psz1 );
			WideCharToMultiByte( CP_ACP, 0, psz2, -1, szGuid2, sizeof(szGuid2), NULL, NULL );
			CoTaskMemFree( psz2 );
			WideCharToMultiByte( CP_ACP, 0, psz3, -1, szGuid3, sizeof(szGuid3), NULL, NULL );
			CoTaskMemFree( psz3 );
			WideCharToMultiByte( CP_ACP, 0, psz4, -1, szGuid4, sizeof(szGuid4), NULL, NULL );
			CoTaskMemFree( psz4 );
			strName.LoadString( IDS_BAND_OBJECT_TEXT );

			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
			_tcscat( szRegPath, szGuid1 );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("RefNode"), szGuid2)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("Component"), szGuid3)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("DMObject"), szGuid4)) )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR    szGuid[MID_BUFFER];
	
	if( SUCCEEDED( StringFromIID(CLSID_BandEditor, &psz) ) )
    {
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	if( SUCCEEDED( StringFromIID(CLSID_BandComponent, &psz) ) )
    {
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_BandNode, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );

			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
			_tcscat( szRegPath, szGuid );
			if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	if( !COleObjectFactoryEx::UpdateRegistryAll(TRUE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);
	*/

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return AfxDllCanUnloadNow();
}


//////////////////////////////////////////////////////////////////////////////
// CClassFactory
//
// Class factory object for creating any object implemented by this DLL.
//

typedef  HRESULT (__stdcall CreateInstanceFunc) (IUnknown *punkOuter,
    REFIID riid, void **ppv);

class CClassFactory : public IClassFactory
{
///// IUnknown implementation
protected:
    ULONG	m_dwRef;         // interface reference count
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
    {
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IClassFactory))
        {
            *ppv = (LPVOID) this;
            AddRef();
            return NOERROR;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_dwRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if (--m_dwRef == 0L)
        {
            delete this;
            return 0;
        }
        else
            return m_dwRef;
    }

///// IClassFactory implementation
protected:
    CreateInstanceFunc *m_pfunc;    // function that creates an object instance
public:
    STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID *ppv)
    {
        return (*m_pfunc)(punkOuter, riid, ppv);
    }
    STDMETHODIMP LockServer(BOOL fLock)
    {
        if( fLock )
        {
            AfxOleLockApp();
        }
        else
        {
            AfxOleUnlockApp();
        }

        return NOERROR;
    }

///// Construction
    CClassFactory(CreateInstanceFunc *pfunc) : m_pfunc(pfunc)
	{
		m_dwRef = 0;
	}
};

//////////////////////////////////////////////////////////////////////////////
// CREATE_INSTANCE macro
//

#define CREATE_INSTANCE( cls ) STDAPI cls##_CreateInstance( LPUNKNOWN /*punkOuter*/, REFIID riid, LPVOID *ppv ) \
{ \
    HRESULT   hrReturn; \
    cls* pthis; \
    pthis = new cls; \
    if( pthis == NULL ) \
    { \
        return E_OUTOFMEMORY; \
    } \
    hrReturn = pthis->QueryInterface( riid, ppv ); \
    if( FAILED( hrReturn ) ) \
    { \
        delete pthis; \
        *ppv = NULL; \
    } \
    return hrReturn; \
}

CREATE_INSTANCE( CBandComponent )


/////////////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*ppv = NULL;

    // this DLL can only create class factory objects that support
    // IUnknown and IClassFactory
    if( !IsEqualIID(riid, IID_IUnknown)
    &&  !IsEqualIID(riid, IID_IClassFactory) )
	{
        return E_NOINTERFACE;
	}

// point <pfunc> to a function that can create a new object instance
    CreateInstanceFunc *pfunc;

    if( IsEqualCLSID(rclsid, CLSID_BandComponent) )
	{
        pfunc = CBandComponent_CreateInstance;
		if( ( *ppv = static_cast<void*>( static_cast<IClassFactory *>( new CClassFactory( pfunc ) ) ) ) == NULL )
		{
			return E_OUTOFMEMORY;
		}
	    static_cast<IUnknown*>( *ppv )->AddRef();
	}
    else if( IsEqualCLSID(rclsid, CLSID_BandEditor)
		 ||  IsEqualCLSID(rclsid, CLSID_BandPropPage) )
	{
		AfxDllGetClassObject( rclsid, riid, ppv );
		if( *ppv == NULL )
		{
			return E_OUTOFMEMORY;
		}
	}
    else
	{
        return E_FAIL;
	}

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandDlg.h ===
#ifndef __BANDDLG_H__
#define __BANDDLG_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// BandDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CBandDlg form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "UndoMan.h"
#include "PChannelList.h"
#include "grid.h"

// instrument information structure
struct BInstr  {
	UINT      nStringId;
	BYTE      bPatch;
	BYTE      bMSB;
	BYTE      bLSB;
	CString  *pstrName;
};

class CBandCtrl;
class CDMInstrument;
class CInstrumentListItem;
class CBandComponent;

class CBandDlg : public CFormView, public IDMUSProdMidiInCPt
{
	friend class CBandCtrl;
	friend class CBand;
	friend class CPChannelPropPage;
	friend class CPChannelList;

public:
	CBandDlg();
	virtual ~CBandDlg();

	// IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	HRESULT STDMETHODCALLTYPE OnMidiMsg(REFERENCE_TIME dwTime, BYTE bStatus, BYTE bData1, BYTE bData2);

	void	RegisterMidi();
	void	UnRegisterMidi();
	bool	IsMidiRegistered();
	HRESULT PlayMIDIEvent(BYTE bStatus, BYTE bData1, BYTE bData2);

	void	EnableGridButtonAndUpdateStatus(int nChannel, bool bSelection);
	static CString GetPatchName(CBandComponent* pComponent, CDMInstrument* pInstrument);
	CBand*	GetBand();

	void	RefreshPChannelList();
	void	RefreshPChannelPropertyPage(bool fChangeToBandProperties = true);
	void	UpdatePChannelChanges(bool bResetChannelList = false, bool fChangeToBandProperties = true);
	void	ChangePChannelNumber(CDMInstrument* pInstrument, DWORD newPChannel);
	void	DisplayStatus(long nChannel);

	static bool		GetTransposeValue(CString sTransposeString, LPINT pnTranspose);
	static CString	GetInterval(int nTranspose);

	static HRESULT	GetNoteValue(CString sNoteText, LPINT pnNote);
	static CString	GetNoteText(UINT nNote);
		
protected:
	DECLARE_DYNCREATE(CBandDlg)

// Form Data
public:
	//{{AFX_DATA(CBandDlg)
	enum { IDD = IDD_DLG_BAND };
	CPChannelList	m_PChannelList;
	CGrid	m_MixGrid;
	//}}AFX_DATA

// Attributes
public:
	CBandCtrl* m_pBandCtrl;
	static CString m_arrIntervals[12];
	static CString m_arrNotes[12];

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBandDlg)
	public:
	virtual void OnInitialUpdate();
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CBandDlg)
	afx_msg void OnDestroy();
	afx_msg void OnCursorOverGrid(long nId);
	afx_msg void OnMoveGrid(long nId, short nPan, short nVolume);
	afx_msg void OnUpdateGrid(LPUNKNOWN pIBandPChannel, BOOL bCTRLDown, BOOL bRefreshUI = TRUE);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSelchangePchannelList();
	afx_msg void OnProperties();
	afx_msg int OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT nIndex);
	afx_msg void OnDblClkPChannelList();
	afx_msg void OnSelectPChannelGrid(long nId, BOOL bSelection, BOOL bCtrlDown);
	afx_msg void OnSaveUndoStateGrid();
	afx_msg void OnDisplayStatusGrid(short nId);
	afx_msg void OnRightClickGrid(short nX, short nY);
	afx_msg void OnDeleteChannelGrid();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	DWORD		m_dwCookie;
	long		m_nTrackEdit;
	BOOL		m_fEditChange;
	DWORD		m_dwRef;
	CUndoMan	*m_pBandDo;

	void	LoadIntervals();
	void	LoadNotes();
	CString GetOctave(CDMInstrument* pInstrument);
	CString FormatForDisplay(CDMInstrument* pInstrument);

	void RemoveAndAddAllButtonsToGrid();
	void UpdateGridControls();
	void RefreshSelectedItems();
	void UpdateCommonPropertiesObject();

	void PopulatePChannelList();
	void UpdatePChannelList();
	void SetSelectedPChannels();
	void GetItemRect( UINT id, CRect *prectRel, BOOL bInvalidate = FALSE );

	CString GetPanVolumeText(short nPan, short nVolume);
	
	void InsertPChannel();
	void AddPChannel(int nIndex, CInstrumentListItem* pInstrumentItem);
	void OnDeleteCommand();
	void DeleteSelectedPChannels();
	void AddToGrid(CInstrumentListItem* pInstrumentItem);
	void SendAllNotesOffIfNotPlaying( void );

public:
	void RefreshDisplay();
	void SelectAllPChannels();
	// Undo Manager
	void SaveStateForUndo(char* szStateName);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __BANDDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandEditorGuids.c ===
// BandEditorGuids.c : Contains GUIDs not found in MIDL generated BandEditor_i.c
//

#ifdef __cplusplus
extern "C"{
#endif 

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;

#endif /* GUID_DEFINED */


const GUID CLSID_BandComponent = {0x44207724,0x487B,0x11d0,{0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29}};

const GUID GUID_BandNode = {0x52D58461,0xA517,0x11D0,{0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29}};

const GUID GUID_BandRefNode = {0xb33aedb0,0x81af,0x11d3,{0xb4,0x73,0x00,0x10,0x5a,0x27,0x96,0xde}};

const GUID BAND_NameChange = {0x11c4f3c0,0x8f54,0x11d1,{0x8a,0xc1,0x44,0x45,0x53,0x54,0x00,0x00}};

const GUID BAND_ValidateNameChange = {0x5b67e200,0x5784,0x11d2,{0x89,0xb7,0x0,0xc0,0x4f,0xd9,0x12,0xc8}};

const GUID GUID_BAND_ChangeNotifyMsg = {0x4cf096e0,0xe056,0x11d1,{0xb9,0x87,0x0,0x60,0x97,0xb0,0x10,0x78}};

const GUID GUID_BAND_ActivateNotifyMsg = {0x60833ec0,0xf55e,0x11d1,{0x89,0xb2,0x0,0xc0,0x4f,0xd9,0x12,0xc8}};

const GUID GUID_BAND_UpdatePerformanceMsg = {0x4cf096e1,0xe056,0x11d1,{0xb9,0x87,0x0,0x60,0x97,0xb0,0x10,0x78}};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandPpg.cpp ===
// BandPpg.cpp : Implementation of the CBandPropPage property page class.

#include "stdafx.h"
#include "BandEditorDLL.h"
#include "BandPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CBandPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CBandPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CBandPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



// Band Editor Property Page  {3BD2BA12-46E7-11D0-89AC-00A0C9054129}
const CLSID CLSID_BandPropPage = 
{ 0x3bd2ba12, 0x46e7, 0x11d0, { 0x89, 0xac, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };

/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CBandPropPage, "STYLEDESIGNER.BandPropPage.1",
	0x3bd2ba12, 0x46e7, 0x11d0, 0x89, 0xac, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// CBandPropPage::CBandPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CBandPropPage

BOOL CBandPropPage::CBandPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_BAND_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CBandPropPage::CBandPropPage - Constructor

CBandPropPage::CBandPropPage() :
	COlePropertyPage(IDD, IDS_BAND_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CBandPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CBandPropPage::DoDataExchange - Moves data between page and properties

void CBandPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CBandPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CBandPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandEditorDLL.h ===
#if !defined(AFX_BANDEDITOR_H__D824B38C_804F_11D0_89AC_00A0C9054129__INCLUDED_)
#define AFX_BANDEDITOR_H__D824B38C_804F_11D0_89AC_00A0C9054129__INCLUDED_

// BandEditorDLL.h : main header file for BANDEDITOR.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols
#include "BandEditor.h"
#include "DMUSProd.h"
#include "Conductor.h"		// Conductor interface and CLSID
#include "StyleRiffId.h"	// Style file RIFF chunk id's
#include "DllBasePropPageManager.h"
#include "DllJazzDataObject.h"


/////////////////////////////////////////////////////////////////////////////
// DLL defines
//

#define SMALL_BUFFER	32
#define MID_BUFFER		100
#define MAX_BUFFER		256
#define TOOLBAR_HEIGHT	30
#define WM_MYPROPVERB	WM_USER+1267 

#define NBR_IMA_INSTRUMENTS			16

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0


/////////////////////////////////////////////////////////////////////////////
// DLL externs
//

#ifdef __cplusplus
extern "C"{
#endif 

extern const CLSID CLSID_BandPropPage;

#ifdef __cplusplus
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CBandEditorApp : See BandEditor.cpp for implementation.

class CBandEditorApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
	BOOL GetHelpFileName( CString& strHelpFileName );
	void SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode );
	BOOL GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize );
	BOOL PutDataInClipboard( IDataObject* pIDataObject, void* pClipboardObject );
	void FlushClipboard( void* pClipboardObject );

private:
	IDataObject*	m_pIClipboardDataObject;	// Data copied into clipboard
	void*			m_pClipboardObject;			// Object responsible for data copied into clipboard

public:
	IDMUSProdFramework*			m_pIFramework;
	IDMUSProdPropPageManager*	m_pIPageManager;
};

extern CBandEditorApp NEAR theApp;

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_BANDEDITOR_H__D824B38C_804F_11D0_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\DlgDLS.h ===
#if !defined(AFX_DLGDLS_H__D1868D61_9F84_11D0_8C10_00A0C92E1CAC__INCLUDED_)
#define AFX_DLGDLS_H__D1868D61_9F84_11D0_8C10_00A0C92E1CAC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgDLS.h : header file
//
/////////////////////////////////////////////////////////////////////////////
// Collections List Item Struct
typedef struct _CollectionListItem
{
	CString									csCollectionName;
	interface IDMUSProdReferenceNode*		pRefNode;
} COLLECTION_LISTITEM;

/////////////////////////////////////////////////////////////////////////////
// Instruments List Item struct
typedef struct _InstrumentListItem
{
	DWORD dwParams;
	CString sInstrumentName;
}INSTRUMENT_LISTITEM;

/////////////////////////////////////////////////////////////////////////////
// CDlgDLS dialog
class CDlgDLS : public CDialog
{
// Construction
public:
	CDlgDLS(CWnd* pParent = NULL);   // standard constructor
	~CDlgDLS();
// Dialog Data
	//{{AFX_DATA(CDlgDLS)
	enum { IDD = IDD_DLS };
	CListBox	m_cList;
	CComboBox	m_DLS_Combo;
	int		m_nLSB;
	int		m_nMSB;
	int		m_nPC;
	//}}AFX_DATA

	long					m_nTrack;
	CString					m_csCurrentCollection;
	IDMUSProdReferenceNode*	m_pICurrentRefNode;
	int						m_nLastSelectedCollection;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgDLS)
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgDLS)
	afx_msg void OnDblclkDlslist();
	afx_msg void OnSelchangeDlslist();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeCollectionsCombo();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	IDMUSProdReferenceNode* CreateReferenceNode(IDMUSProdNode* pCollectionDocRoot);
	void GetCurrentCollection(); 
	void InitCollectionList();
	void InitCollectionCombo();
	void InitInstrumentList();
	void CleanInstrumentList();
	void SortInstrumentsAndAddToList();
	void QuickSort(POSITION position, int nElems);
	void swap(POSITION& position1, POSITION& position2);

#ifdef _DEBUG
	void _PrintTrace(POSITION startPosition, int nElems); 
#endif

// Attributes
private:
	CTypedPtrList<CPtrList, COLLECTION_LISTITEM*>	m_CollectionList;
	CTypedPtrList<CPtrList, INSTRUMENT_LISTITEM*>	m_InstrumentList;
	IDMUSProdFramework*								m_pIFramework;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGDLS_H__D1868D61_9F84_11D0_8C10_00A0C92E1CAC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandPpg.h ===
#if !defined(BANDPPG_H__3BD2BA34_46E7_11D0_89AC_00A0C9054129__INCLUDED_)
#define BANDPPG_H__3BD2BA34_46E7_11D0_89AC_00A0C9054129__INCLUDED_

// BandPpg.h : Declaration of the CBandPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CBandPropPage : See BandPpg.cpp.cpp for implementation.

class CBandPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CBandPropPage)
	DECLARE_OLECREATE_EX(CBandPropPage)

// Constructor
public:
	CBandPropPage();

// Dialog Data
	//{{AFX_DATA(CBandPropPage)
	enum { IDD = IDD_PROPPAGE_BAND };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CBandPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(BANDPPG_H__3BD2BA34_46E7_11D0_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandRef.h ===
#ifndef __BANDREF_H__
#define __BANDREF_H__

// BandRef.h : header file
//

#include "BandComponent.h"
#include "BandDocType.h"
#include "RiffStrm.h"

class CBandRef : public IDMUSProdNode, public IDMUSProdReferenceNode
{
public:
    CBandRef( CBandComponent* pComponent );
	~CBandRef();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IDMUSProdReferenceNode functions
	HRESULT STDMETHODCALLTYPE GetReferencedFile( IDMUSProdNode** ppIDocRootNode );
	HRESULT STDMETHODCALLTYPE SetReferencedFile( IDMUSProdNode* pIDocRootNode );

	//Additional functions

public:
	CBand*				m_pBand;		// BandRef refers to this Band

private:
    DWORD				m_dwRef;
	CBandComponent*		m_pComponent;
	IDMUSProdNode*		m_pIDocRootNode;
	IDMUSProdNode*	    m_pIParentNode;
};

#endif // __BANDREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\DlgDLS.cpp ===
// DlgDLS.cpp : implementation file
//

#include "stdafx.h"
#include "bandeditordll.h"
#include "BandDlg.h"
#include "DlgDLS.h"
#include "DLSDesigner.h"
#include "Band.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgDLS dialog

CDlgDLS::CDlgDLS(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgDLS::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgDLS)
	m_nLSB = 0;
	m_nMSB = 0;
	m_nPC = 0;
	//}}AFX_DATA_INIT
	m_pIFramework = theApp.m_pIFramework;
	m_pICurrentRefNode = NULL;

	// Init the collection list now...
	// Don't do this in the init dialog since the 
	// loading of DLS collections may throw up other
	// modal dialogs resulting in problematic behaviour...
	InitCollectionList();
}

CDlgDLS::~CDlgDLS()
{
	if( m_pICurrentRefNode )
	{
		m_pICurrentRefNode->Release();
		m_pICurrentRefNode = NULL;
	}

	COLLECTION_LISTITEM*	pNextItem;
	
	while ( !m_CollectionList.IsEmpty() )
	{
		pNextItem = m_CollectionList.RemoveHead();
		pNextItem->pRefNode->Release();
		delete pNextItem;
	}

	CleanInstrumentList();

}

void CDlgDLS::CleanInstrumentList()
{
	INSTRUMENT_LISTITEM* pInstrument = NULL;
	while(!m_InstrumentList.IsEmpty())
	{
		pInstrument = m_InstrumentList.RemoveHead();
		if(pInstrument)
			delete pInstrument;
	}
}

void CDlgDLS::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgDLS)
	DDX_Control(pDX, IDC_DLSLIST, m_cList);
	DDX_Control(pDX, IDC_COLLECTIONS_COMBO, m_DLS_Combo);
	DDX_Text(pDX, IDC_DLSLSB, m_nLSB);
	DDV_MinMaxInt(pDX, m_nLSB, 0, 127);
	DDX_Text(pDX, IDC_DLSMSB, m_nMSB);
	DDX_Text(pDX, IDC_DLSPC, m_nPC);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgDLS, CDialog)
	//{{AFX_MSG_MAP(CDlgDLS)
	ON_LBN_DBLCLK(IDC_DLSLIST, OnDblclkDlslist)
	ON_LBN_SELCHANGE(IDC_DLSLIST, OnSelchangeDlslist)
	ON_CBN_SELCHANGE(IDC_COLLECTIONS_COMBO, OnSelchangeCollectionsCombo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgDLS message handlers

//To Do: correct this
void CDlgDLS::OnDblclkDlslist() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	DWORD dwData = m_cList.GetItemData( m_cList.GetCurSel() );
	m_nMSB = (dwData >> 16) & 0x7F;
	m_nLSB = (dwData >> 8) & 0x7F;
	m_nPC = dwData & 0x7F;
	EndDialog( IDOK );
}

void CDlgDLS::GetCurrentCollection() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Set current collection
	int nCurSel = m_DLS_Combo.GetCurSel();
	if( nCurSel != CB_ERR )
	{
		IDMUSProdReferenceNode* pIRefNode;
		
		// Current Collection RefNode
		pIRefNode = (IDMUSProdReferenceNode *)m_DLS_Combo.GetItemDataPtr( nCurSel );
		if( pIRefNode != m_pICurrentRefNode )
		{
			if( m_pICurrentRefNode )
			{
				m_pICurrentRefNode->Release();
			}
			m_pICurrentRefNode = pIRefNode;
			if( m_pICurrentRefNode )
			{
				m_pICurrentRefNode->AddRef();
			}
		}

		// Current Collection name
		m_DLS_Combo.GetLBText( nCurSel, m_csCurrentCollection );
	}
}

void CDlgDLS::OnSelchangeDlslist() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Update Collection
	GetCurrentCollection();

	// Update instrument
	if(m_cList.GetCurSel() != LB_ERR)
	{
		DWORD dwData = m_cList.GetItemData( m_cList.GetCurSel() );
		m_nMSB = (dwData >> 16) & 0x7F;
		m_nLSB = (dwData >> 8) & 0x7F;
		m_nPC = dwData & 0x7F;
		UpdateData( FALSE );
	}
}

BOOL CDlgDLS::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Fill the list box with the instruments in the current collection
	CDialog::OnInitDialog();

	m_cList.ResetContent();
    static int tabstops[1] = { 12*4 };
    m_cList.SetTabStops(1,tabstops);

	InitCollectionCombo();
	InitInstrumentList();
	
	
	return TRUE;  
}

void CDlgDLS::InitCollectionList()
{
	IDMUSProdDocType*		pIDocType;
	IDMUSProdProject*		pIProject;
	GUID					guidProject;
	IDMUSProdNode*			pIDocRootNode;
	IDMUSProdProject*		pINextProject;
	IDMUSProdNode*			pIFileNode;
	IDMUSProdNode*			pINextFileNode;
	IDMUSProdNode*			pIReturnNode=NULL;
	DMUSProdListInfo		ListInfo;
	CString					csCollectionName;
	COLLECTION_LISTITEM*	pNewItem=NULL;


	HRESULT hr = m_pIFramework->FindDocTypeByNodeId( GUID_CollectionNode, &pIDocType );
	if (SUCCEEDED(hr))
	{
		hr = m_pIFramework->GetFirstProject( &pINextProject );
		while( SUCCEEDED( hr )  &&  pINextProject )
		{
			pIProject = pINextProject;
			pIProject->GetGUID(&guidProject);

			HRESULT hr = pIProject->GetFirstFileByDocType( pIDocType, &pINextFileNode );

			while( hr == S_OK )
			{
				pIFileNode = pINextFileNode;
				ZeroMemory( &ListInfo, sizeof(ListInfo) );
				ListInfo.wSize = sizeof(ListInfo);
				if( SUCCEEDED ( pIFileNode->GetNodeListInfo ( &ListInfo ) ) )
				{
					if( ListInfo.bstrName )
					{
						csCollectionName = ListInfo.bstrName;
						::SysFreeString( ListInfo.bstrName );
					}

					if( ListInfo.bstrDescriptor )
					{
						::SysFreeString( ListInfo.bstrDescriptor );
					}

					GUID guidFile;
					if( SUCCEEDED(m_pIFramework->GetNodeFileGUID( pIFileNode, &guidFile ) ) )
					{
						if ( SUCCEEDED(m_pIFramework->FindDocRootNodeByFileGUID( guidFile, &pIDocRootNode ) ) )
						{
							pNewItem = new COLLECTION_LISTITEM;
							pNewItem->csCollectionName = csCollectionName;
							pNewItem->pRefNode = CreateReferenceNode(pIDocRootNode);
							m_CollectionList.AddTail(pNewItem);
							pIDocRootNode->Release();
						}
					}
				}
				hr = pIProject->GetNextFileByDocType( pIFileNode, &pINextFileNode );
				pIFileNode->Release();
			}
			hr = m_pIFramework->GetNextProject( pIProject, &pINextProject );
			pIProject->Release();
		}
		pIDocType->Release();
	}//FindDocTypeByNodeId
}

void CDlgDLS::InitInstrumentList()
{
	IDLSQueryInstruments*					pIDLSQuery;
	IDMUSProdReferenceNode*					pIRefNode;
	int										iComboIndex;
	
	if ( m_CollectionList.IsEmpty() )
	{
		return;
	}
	m_cList.ResetContent();
	iComboIndex = m_DLS_Combo.GetCurSel();
	pIRefNode = (IDMUSProdReferenceNode*) m_DLS_Combo.GetItemDataPtr(iComboIndex);
	if ( SUCCEEDED(pIRefNode->QueryInterface(IID_IDLSQueryInstruments,(void**)&pIDLSQuery)) )
	{	
		if( SUCCEEDED(pIDLSQuery->ResetInstrumentList()) )
		{
			BYTE bMSB, bLSB, bPC;
			BOOL fDrums = FALSE;
			signed char szName[200];

			// Clear the list
			CleanInstrumentList();

			while( pIDLSQuery->GetNextInstrument( &bMSB, &bLSB, &bPC, &fDrums, szName, 200 ) )
			{
				// only display drums for the drum track
				if( (fDrums  &&  (m_nTrack == 9 || m_nTrack%16 == 9))  ||  (!fDrums  &&  (m_nTrack != 9 && m_nTrack%16 != 9)) )
				{
					INSTRUMENT_LISTITEM* pInstrument = new INSTRUMENT_LISTITEM;
					pInstrument->dwParams = (DWORD) (bMSB << 16 | bLSB << 8 | bPC);
					pInstrument->sInstrumentName.Format("%d,%d,%d\t%s", (long)bMSB, (long)bLSB, (long)bPC, szName); 
					m_InstrumentList.AddTail(pInstrument);
				}	
			}	

			SortInstrumentsAndAddToList();
		}
		pIDLSQuery->Release();
		// find the instrument in the list by its number and select it
		char szFind[32];
		sprintf( szFind, "%d,%d,%d\t", m_nMSB, m_nLSB, m_nPC );
		if( CB_ERR == m_cList.SelectString( -1, szFind ) )
		{
			m_cList.SetCurSel( -1 );
		}
	}
}

// Quicksort the instrument list
void CDlgDLS::SortInstrumentsAndAddToList()
{
	POSITION position = m_InstrumentList.GetHeadPosition();
	int nElems = m_InstrumentList.GetCount();

	QuickSort(position, nElems);

	// Reset the instrument list
	m_cList.ResetContent();

	position = m_InstrumentList.GetHeadPosition();
	while(position)
	{
		INSTRUMENT_LISTITEM* pInstrument = (INSTRUMENT_LISTITEM*)m_InstrumentList.GetNext(position);
		ASSERT(pInstrument);
		if(pInstrument == NULL)
			return;

		m_cList.SetItemData(m_cList.AddString(pInstrument->sInstrumentName), pInstrument->dwParams);
	}
}


// Implements classic QuickSort
void CDlgDLS::QuickSort(POSITION position, int nElems)
{
	// Nothing to do?
	if(nElems <= 1)
		return;

	// Get a pivot position
	POSITION pivotPosition = position;
	for(int nCount = 0; nCount < nElems/2; nCount++)
		m_InstrumentList.GetNext(pivotPosition);

	// Swap the pivot to the start of this list
	swap(position, pivotPosition);
	
	POSITION lastPosition = position;
	POSITION indexPosition = position;
	
	// Start with index = 1 (we swapped the pivot to 0)
	m_InstrumentList.GetNext(indexPosition);

	INSTRUMENT_LISTITEM* pInstrument0 = (INSTRUMENT_LISTITEM*)m_InstrumentList.GetAt(position);
	ASSERT(pInstrument0);
	if(pInstrument0 == NULL)
		return;

	int nPC0 = pInstrument0->dwParams & 0x7F;
	int nMSB0 = (pInstrument0->dwParams >> 16) & 0x7F;
	int nLSB0 = (pInstrument0->dwParams >> 8) & 0x7F;

	for(int nIndex = 1; nIndex < nElems && indexPosition != NULL; nIndex++)
	{
		// Remember the old position as GetNext will auto-increment the position
		POSITION oldPosition = indexPosition;
		
		INSTRUMENT_LISTITEM* pInstrument1 = (INSTRUMENT_LISTITEM*)m_InstrumentList.GetNext(indexPosition);
		ASSERT(pInstrument1);
		if(pInstrument1 == NULL)
			return;

		int nPC1 = pInstrument1->dwParams & 0x7F;
		int nMSB1 = (pInstrument1->dwParams >> 16) & 0x7F;
		int nLSB1 = (pInstrument1->dwParams >> 8) & 0x7F;

		// Patch sorts first, MSB sorts second and LSB sorts last
		if((nPC1 < nPC0) || (nPC1 == nPC0 && nMSB1 < nMSB0) || 
		   (nPC1 == nPC0 && nMSB1 == nMSB0 && nLSB1 < nLSB0))
		{
			m_InstrumentList.GetNext(lastPosition);
			swap(lastPosition, oldPosition);
		}
	}

	// Reset the pivot element
	swap(position, lastPosition);

	int nPartitionElems = 0;
	POSITION tempPosition = position;
	while(tempPosition != lastPosition)
	{
		nPartitionElems++;
		m_InstrumentList.GetNext(tempPosition);
	}

	// Recursively sort the subarrays
	QuickSort(position, nPartitionElems);

	// sort starting from last position + 1
	m_InstrumentList.GetNext(lastPosition);
	QuickSort(lastPosition, nElems - nPartitionElems - 1);
}

#ifdef _DEBUG
void CDlgDLS::_PrintTrace(POSITION startPosition, int nElems)
{
	TRACE("================\n");
	for(int nIndex = 0; nIndex < nElems; nIndex++)
	{
		INSTRUMENT_LISTITEM* pInstrument = (INSTRUMENT_LISTITEM*)m_InstrumentList.GetNext(startPosition);
		int nPC = pInstrument->dwParams & 0x7F;

		TRACE("PC = %d\n", nPC);
	}
	TRACE("================\n");
}
#endif



void CDlgDLS::swap(POSITION& position1, POSITION& position2)
{
	ASSERT(position1);
	ASSERT(position2);

	INSTRUMENT_LISTITEM* pTempInstrument = (INSTRUMENT_LISTITEM*)m_InstrumentList.GetAt(position1);
	ASSERT(pTempInstrument);
	if(pTempInstrument == NULL)
		return;

	m_InstrumentList.SetAt(position1, m_InstrumentList.GetAt(position2));
	m_InstrumentList.SetAt(position2, pTempInstrument);
}


void CDlgDLS::InitCollectionCombo()
{
	COLLECTION_LISTITEM*	pNextItem;
	POSITION				posIndex=NULL;
	int						iComboIndex;
	int						iCurrentCollection=0;
	
	if ( m_CollectionList.IsEmpty() )
	{
		return;
	}

	posIndex = m_CollectionList.GetHeadPosition();
	m_DLS_Combo.ResetContent();
	while(posIndex)
	{
		pNextItem = m_CollectionList.GetNext(posIndex);
		iComboIndex = m_DLS_Combo.AddString(pNextItem->csCollectionName);
		m_DLS_Combo.SetItemDataPtr(iComboIndex, pNextItem->pRefNode);
	}

	iCurrentCollection = m_DLS_Combo.FindStringExact( -1, m_csCurrentCollection );
	if( iCurrentCollection == CB_ERR )
	{
		iCurrentCollection = 0;
		m_nLastSelectedCollection = -1;
	}
	if(m_nLastSelectedCollection == -1)
		m_DLS_Combo.SetCurSel(iCurrentCollection);
	else
		m_DLS_Combo.SetCurSel(m_nLastSelectedCollection);

	m_DLS_Combo.SetTopIndex(iCurrentCollection);
}

IDMUSProdReferenceNode* CDlgDLS::CreateReferenceNode(IDMUSProdNode * pCollectionDocRoot)
{
	HRESULT						hr;
	IDMUSProdNode*				pINode;
	IDMUSProdComponent*			pIComponent;
	IDMUSProdReferenceNode*		pIRefNode;
	bool						bCollectionFound=false;


	// Allocate a new reference node
	hr = m_pIFramework->FindComponent( CLSID_DLSComponent,  &pIComponent );
	if(FAILED(hr))
	{
		return NULL;
	}

	hr = pIComponent->AllocReferenceNode(GUID_CollectionRefNode, &pINode);
	pIComponent->Release();
	if(FAILED(hr))
	{
		return NULL;
	}

	hr = pINode->QueryInterface(IID_IDMUSProdReferenceNode, (void**)&pIRefNode);
	pINode->Release();
	if (FAILED(hr))
	{
		TRACE("Failed query for Reference interface\n");
		return NULL;
	}
	
	hr = pIRefNode->SetReferencedFile(pCollectionDocRoot);
	if (FAILED(hr))
	{
		TRACE("Failed to SetReferencedFile\n");
		pIRefNode->Release();
		return NULL;
	}
	return pIRefNode;
}

void CDlgDLS::OnSelchangeCollectionsCombo() 
{
	// Update Collection
	GetCurrentCollection();

	m_nLastSelectedCollection = m_DLS_Combo.GetCurSel();

	// Rebuild instrument list
	InitInstrumentList();
}

void CDlgDLS::OnOK() 
{
	UpdateData(TRUE);

	int nCollections = m_DLS_Combo.GetCount();

	// Don't try to look for a collection that has this MSB, LSB and Patch...
	// ...if there are no collections...duh!
	if(nCollections == CB_ERR || nCollections == 0)
		EndDialog(IDOK);

	BOOL bFound = FALSE;
	IDMUSProdReferenceNode* pIRefNode = NULL;
	IDLSQueryInstruments*	pIDLSQuery = NULL;
	for(int nCollectionCount = 0; nCollectionCount < nCollections; nCollectionCount++)
	{
		pIRefNode = (IDMUSProdReferenceNode *)m_DLS_Combo.GetItemDataPtr(nCollectionCount);

		if (SUCCEEDED(pIRefNode->QueryInterface(IID_IDLSQueryInstruments,(void**)&pIDLSQuery)))
		{
			signed char sInstrumentName[DMUS_MAX_NAME];

			bFound = pIDLSQuery->GetInstrumentName(BYTE(m_nMSB), BYTE(m_nLSB), BYTE(m_nPC), false, sInstrumentName, DMUS_MAX_NAME);
			// Look for Drums
			if(!bFound)
				bFound = pIDLSQuery->GetInstrumentName(BYTE(m_nMSB), BYTE(m_nLSB), BYTE(m_nPC), true, sInstrumentName, DMUS_MAX_NAME);

			if(bFound)
			{
				pIDLSQuery->Release();
				break;
			}
			
			pIDLSQuery->Release();
		}
		
	}

	if(bFound)
	{
		m_DLS_Combo.SetCurSel(nCollectionCount);
		InitInstrumentList();
		OnSelchangeDlslist();
	}

	EndDialog(IDOK);
	//CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\grid.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "grid.h"

/////////////////////////////////////////////////////////////////////////////
// CGrid

IMPLEMENT_DYNCREATE(CGrid, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CGrid properties

/////////////////////////////////////////////////////////////////////////////
// CGrid operations

void CGrid::BringToFront(long nId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 nId);
}

void CGrid::MoveButton(long nId, short nPan, short nVolume)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	static BYTE parms[] =
		VTS_I4 VTS_I2 VTS_I2;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 nId, nPan, nVolume);
}

void CGrid::RemoveButton(long nId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		nId);
}

void CGrid::RemoveAllButtons()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CGrid::SelectButton(long nId, BOOL bSelection)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	static BYTE parms[] = VTS_I4 VTS_BOOL;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_EMPTY, NULL, parms, nId, bSelection);
}

void CGrid::SetEnabled(long nId, BOOL bEnable)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	static BYTE parms[] = VTS_I4 VTS_BOOL;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, parms, nId, bEnable);
}


BOOL CGrid::AddButton(LPUNKNOWN pIUnknown)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	BOOL result;
	static BYTE parms[] =
		VTS_UNKNOWN;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		pIUnknown);
	return result;
}

void CGrid::UpdateButton(long nId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		nId);
}

void CGrid::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\BandRef.cpp ===
// BandRef.cpp : implementation file
//

#include "stdafx.h"
#include "BandEditorDLL.h"

#include "Band.h"
#include "BandRef.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CBandRef constructor/destructor

CBandRef::CBandRef( CBandComponent* pComponent )
{
	ASSERT( pComponent != NULL );

	m_pComponent = pComponent;
	m_pComponent->AddRef();

    m_dwRef = 0;
	AddRef();

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pBand = NULL;
}

CBandRef::~CBandRef()
{
	RELEASE( m_pBand );
	RELEASE( m_pComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IUnknown implementation

HRESULT CBandRef::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdReferenceNode) )
    {
        AddRef();
        *ppvObj = (IDMUSProdReferenceNode *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CBandRef::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CBandRef::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::GetNodeImageIndex

HRESULT CBandRef::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );

	return( m_pComponent->GetBandRefImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::GetFirstChild

HRESULT CBandRef::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(ppIFirstChildNode);

    return E_NOTIMPL;	// BandRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::GetNextChild

HRESULT CBandRef::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(ppINextChildNode);

    return E_NOTIMPL;	// BandRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::GetComponent

HRESULT CBandRef::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );

	return m_pComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::GetDocRootNode

HRESULT CBandRef::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::SetDocRootNode

HRESULT CBandRef::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::GetParentNode

HRESULT CBandRef::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::SetParentNode

HRESULT CBandRef::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::GetNodeId

HRESULT CBandRef::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_BandRefNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::GetNodeName

HRESULT CBandRef::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pBand == NULL )
	{
		TCHAR achNoBand[MID_BUFFER];

		::LoadString( theApp.m_hInstance, IDS_NO_BAND, achNoBand, MID_BUFFER );
		CString strNoBand = achNoBand;
		*pbstrName = strNoBand.AllocSysString();
		return S_OK;
	}

    return m_pBand->GetNodeName( pbstrName );
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::GetNodeNameMaxLength

HRESULT CBandRef::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a BandRef node

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::ValidateNodeName

HRESULT CBandRef::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a BandRef node
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::SetNodeName

HRESULT CBandRef::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a BandRef node
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::GetNodeListInfo

HRESULT CBandRef::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pBand == NULL )
	{
		return E_FAIL;
	}

    return m_pBand->GetNodeListInfo( pListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::GetEditorClsId

HRESULT CBandRef::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pBand == NULL )
	{
		return E_FAIL;
	}

    *pClsId = CLSID_BandEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::GetEditorTitle

HRESULT CBandRef::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pBand == NULL )
	{
		return E_FAIL;
	}

    return m_pBand->GetEditorTitle( pbstrTitle );
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::GetEditorWindow

HRESULT CBandRef::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pBand == NULL )
	{
		return E_FAIL;
	}

    return m_pBand->GetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::SetEditorWindow

HRESULT CBandRef::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pBand == NULL )
	{
		return E_FAIL;
	}

    return m_pBand->SetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::UseOpenCloseImages

HRESULT CBandRef::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::GetRightClickMenuId

HRESULT CBandRef::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_BANDREF_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::OnRightClickMenuInit

HRESULT CBandRef::OnRightClickMenuInit( HMENU hMenu )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hMenu);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::OnRightClickMenuSelect

HRESULT CBandRef::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( lCommandId )
	{
		case IDM_PROPERTIES:
			if( m_pBand )
			{
				return m_pBand->OnRightClickMenuSelect( lCommandId );
			}
			break;

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::DeleteChildNode

HRESULT CBandRef::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// BandRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::InsertChildNode

HRESULT CBandRef::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// BandRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::DeleteNode

HRESULT CBandRef::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_FAIL;		// Cannot delete BandRef node?????
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::OnNodeSelChanged

HRESULT CBandRef::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::CreateDataObject

HRESULT CBandRef::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	if( m_pBand )
	{
		// Let Band create data object
		return m_pBand->CreateDataObject( ppIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::CanCut

HRESULT CBandRef::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::CanCopy

HRESULT CBandRef::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if( m_pBand )
	{
		return S_OK;	// Will copy the Band
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::CanDelete

HRESULT CBandRef::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	return m_pIParentNode->CanDeleteChildNode( this );
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::CanDeleteChildNode

HRESULT CBandRef::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Band Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::CanPasteFromData

HRESULT CBandRef::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Band
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfBand );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent decide whether it wants to paste a Band
		return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
	}

	if( m_pBand )
	{
		// Let Band decide what can be dropped
		return m_pBand->CanPasteFromData( pIDataObject, pfWillSetReference );
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::PasteFromData

HRESULT CBandRef::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Band
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfBand );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent handle pasting of Band
		return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
	}

	if( m_pBand )
	{
		// Let Band handle paste
		return m_pBand->PasteFromData( pIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::CanChildPasteFromData

HRESULT CBandRef::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	return E_NOTIMPL;			// Band Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::ChildPasteFromData

HRESULT CBandRef::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;			// Band Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdNode::GetObject

HRESULT CBandRef::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rclsid);
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(ppvObject);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdReferenceNode implementation

/////////////////////////////////////////////////////////////////////////////
// CBandRef IDMUSProdReferenceNode::GetReferencedFile

HRESULT CBandRef::GetReferencedFile( IDMUSProdNode** ppIDocRootNode )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( m_pBand )
	{
		m_pBand->AddRef();
		*ppIDocRootNode = m_pBand;
		return S_OK;
	}

    return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef::IDMUSProdReferenceNode::SetReferencedFile

HRESULT CBandRef::SetReferencedFile( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDocRootNode )
	{
		// Make sure method was passed a DocRootNode
		IDMUSProdNode* pINode;
		if( FAILED ( pIDocRootNode->GetDocRootNode ( &pINode ) ) )
		{
			pINode = NULL;
		}
		if( pIDocRootNode != pINode )
		{
			RELEASE( pINode );
			return E_INVALIDARG;
		}
		RELEASE( pINode );

		// Make sure method was passed a Band Node
		GUID guidNodeId;
		if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
		{
			if( !( IsEqualGUID ( guidNodeId, GUID_BandNode ) ) )
			{
				return E_INVALIDARG;
			}
		}
	}

	// Release previous DocRoot Node
	RELEASE( m_pBand );

	// Link to new DocRoot Node
	if( pIDocRootNode )
	{
		m_pBand = (CBand *)pIDocRootNode;
		m_pBand->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandRef Additional functions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\grid.h ===
#if !defined(AFX_GRID_H__F7E32C81_A0F0_11D0_8C10_00A0C92E1CAC__INCLUDED_)
#define AFX_GRID_H__F7E32C81_A0F0_11D0_8C10_00A0C92E1CAC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CGrid wrapper class

class CGrid : public CWnd
{
protected:
	DECLARE_DYNCREATE(CGrid)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xeab0cd46, 0x9459, 0x11d0, { 0x8c, 0x10, 0x0, 0xa0, 0xc9, 0x2e, 0x1c, 0xac } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
	void BringToFront(long nId);
	void MoveButton(long nId, short nPan, short nVolume);
	BOOL AddButton(LPUNKNOWN pIUnknown);
	void UpdateButton(long nPChannel);
	void RemoveButton(long nId);
	void RemoveAllButtons();
	void SelectButton(long nId, BOOL bSelection);
	void SetEnabled(long nID, BOOL bEnable);
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GRID_H__F7E32C81_A0F0_11D0_8C10_00A0C92E1CAC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\IMABand.h ===
///////////////////////////////////////////////////////////////////////////////////////////
//
//	IMABand.h
//	Data structures for IMA Band files
//	Created 3/20/98 Eric Whitcombe
//
///////////////////////////////////////////////////////////////////////////////////////////

#ifndef __IMA_BAND_H__
#define __IMA_BAND_H__

typedef struct _rIMAInstrument
{
public:
	BYTE         m_bMSB;
	BYTE         m_bLSB;
	BYTE         m_bPatch;
	BOOL         m_fDLS;
	BYTE         m_bPan;
	BYTE         m_bVolume;
	signed char  m_chOctave;
} IMA_INSTRUMENT, *PIMAINSTRUMENT;

// IO Structs

#pragma pack(2)

#define FOURCC_BAND_FORM        mmioFOURCC('A','A','B','N')
#define FOURCC_BAND             mmioFOURCC('b','a','n','d')
#define IMA_DRUM_TRACK			(5)  // zero based track 6

typedef struct ioBand
{
    wchar_t wstrName[20]; // Band name
    BYTE    abPatch[16];  // GM
    BYTE    abVolume[16];
    BYTE    abPan[16];
    signed char achOctave[16];
    char    fDefault;    // This band is the style's default band
    char    chPad;
    WORD    awDLSBank[16];  // if GM bit set use abPatch
	                        // if GS bit set, use this plus abDLSPatch
	                        // else use both as a DLS
    BYTE    abDLSPatch[16];
    GUID    guidCollection;
    char    szCollection[32];           // this only needs to be single-wide chars
} ioIMABand;

#pragma pack()



#endif //__IMA_BAND_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\PChannelList.h ===
#if !defined(AFX_PCHANNELLIST_H__D9BCBB12_2834_11D2_9A65_006097B01078__INCLUDED_)
#define AFX_PCHANNELLIST_H__D9BCBB12_2834_11D2_9A65_006097B01078__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PChannelList.h : header file
//


class CBandDlg;
class CDMInstrument;
/////////////////////////////////////////////////////////////////////////////
// CPChannelList window

class CPChannelList : public CListBox
{
// Construction
public:
	CPChannelList();

// Attributes
public:
	CBandDlg* m_pBandDlg;

// Operations
public:
	void SetBandDialog(CBandDlg* pBandDlg);
	
	CString GetPChannelName(CDMInstrument* pInstrument);
	
	bool TestIfIgnore(CDMInstrument* pInstrument, DWORD dwTestFlag);

	void SelectPChannelFromPoint(CPoint point, bool bSelect);

	void DrawListItemText(CDC* pDC, LPDRAWITEMSTRUCT lpDrawItemStruct, 
						  int nLeftOffset, int nRightOffset, 
						  CRect& originalRect, CString& sText, 
						  bool bDisabled, CFont* pNormalFont, 
						  CFont* pBoldFont);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPChannelList)
	public:
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CPChannelList();

	

	// Generated message map functions
protected:
	//{{AFX_MSG(CPChannelList)
	afx_msg void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PCHANNELLIST_H__D9BCBB12_2834_11D2_9A65_006097B01078__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\PChannelList.cpp ===
// PChannelList.cpp : implementation file
//

#include "stdafx.h"
#include "bandeditordll.h"
#include "Band.h"
#include "BandCtl.h"
#include "BandDlg.h"
#include "PChannelList.h"
#include "PChannelName.h"
#include "PChannelPropPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CPChannelList

CPChannelList::CPChannelList()
{
	m_pBandDlg = NULL;
}

CPChannelList::~CPChannelList()
{
}


BEGIN_MESSAGE_MAP(CPChannelList, CListBox)
	//{{AFX_MSG_MAP(CPChannelList)
	ON_WM_DRAWITEM_REFLECT()
	ON_WM_MOUSEMOVE()
	ON_WM_RBUTTONDOWN()
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPChannelList message handlers

void CPChannelList::SetBandDialog(CBandDlg* pBandDlg)
{
	m_pBandDlg = pBandDlg;
}


void CPChannelList::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get the Instrument
	CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*)lpDrawItemStruct->itemData; 
	if(!pInstrumentItem)
		return;
	ASSERT( pInstrumentItem);
	CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
	ASSERT(pInstrument);

	CString sDrawString;
	CString sInstrumentName = CBandDlg::GetPatchName(m_pBandDlg->GetBand()->m_pComponent, pInstrument);

	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);

	// if we're drawing a real item and the item is to be completely
	// draw or drawn as if it is selected, then ...

	if (((LONG)(lpDrawItemStruct->itemID) >= 0) &&
		(lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)))
	{
		bool bSelected = false; // Flag to mark item selection
		bool bDisabled = false; // Flag to check for ignore flags
		
		CFont  boldFont;
		CFont* pNormalFont = GetFont();

		LOGFONT lfBold;
		pNormalFont->GetLogFont(&lfBold); 

		lfBold.lfWeight = 600;
		boldFont.CreateFontIndirect(&lfBold);

		// set up the color and the background color

		COLORREF disabledUnselectedTextColor = ::GetSysColor(COLOR_GRAYTEXT);
		COLORREF disabledSelectedTextColor = ::GetSysColor(COLOR_3DHILIGHT);
		COLORREF disabledTextColor = disabledUnselectedTextColor;

		COLORREF newTextColor = ::GetSysColor(COLOR_WINDOWTEXT) ;
		COLORREF oldTextColor = pDC->SetTextColor(newTextColor);

		COLORREF newBkColor = ::GetSysColor(COLOR_WINDOW);
		COLORREF oldBkColor = pDC->SetBkColor(newBkColor);

		if (newTextColor == newBkColor)
			newTextColor = RGB(0xC0, 0xC0, 0xC0);   // dark gray

		// if the item is selected, we need to paint a selected background
		// draw it!
		CRect rect = CRect(lpDrawItemStruct->rcItem);

		if ((lpDrawItemStruct->itemState & ODS_SELECTED) != 0 || pInstrumentItem->IsSelected())
		{
			bSelected = true;

			disabledTextColor = disabledSelectedTextColor;
			if(GetFocus() == this)
				pDC->SetBkColor(::GetSysColor(COLOR_HIGHLIGHT));
			else
				pDC->SetBkColor(::GetSysColor(COLOR_INACTIVECAPTION));

			newTextColor = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
			pDC->SetTextColor(newTextColor);
		}
		
		if(bSelected)
		{
			CBrush brush;
			if(GetFocus() == this)
				brush.CreateSolidBrush(::GetSysColor(COLOR_HIGHLIGHT));
			else
				brush.CreateSolidBrush(::GetSysColor(COLOR_INACTIVECAPTION));

			CBrush* pOldBrush = pDC->SelectObject(&brush);
			pDC->FillRect(&rect, &brush);
			pDC->SelectObject(pOldBrush);
		}
		else
		{
			CBrush brush;
			brush.CreateSolidBrush(::GetSysColor(COLOR_WINDOW));
			CBrush* pOldBrush = pDC->SelectObject(&brush);
			pDC->FillRect(&rect, &brush);
			pDC->SelectObject(pOldBrush);
		}


		// PCh#
		sDrawString.Format("%d", pInstrument->dwPChannel+1);
		DrawListItemText(pDC, lpDrawItemStruct, 0, 5, rect, sDrawString, bDisabled, pNormalFont, &boldFont);	

		// PCh Name
		sDrawString = GetPChannelName(pInstrument);
		DrawListItemText(pDC, lpDrawItemStruct, 5, 21, rect, sDrawString, bDisabled, pNormalFont, &boldFont);	

		// Instrument Name
		if(!TestIfIgnore(pInstrument, DMUS_IO_INST_PATCH))
		{
			bDisabled = true;
			pDC->SetTextColor(disabledTextColor);
		}
		else
		{
			bDisabled = false;
			pDC->SetTextColor(newTextColor);
		}
		DrawListItemText(pDC, lpDrawItemStruct, 21, 37, rect, sInstrumentName, bDisabled, pNormalFont, &boldFont);	

		// Octave
		int nOctave = (pInstrument->nTranspose)/12;
		
		if(nOctave > 0)
			sDrawString.Format("+%d", nOctave);
		else
			sDrawString.Format("%d", nOctave);

		if(!TestIfIgnore(pInstrument, DMUS_IO_INST_TRANSPOSE))
		{
			bDisabled = true;
			pDC->SetTextColor(disabledTextColor);
		}
		else
		{
			bDisabled = false;
			pDC->SetTextColor(newTextColor);
		}
		DrawListItemText(pDC, lpDrawItemStruct, 37, 41, rect, sDrawString, bDisabled, pNormalFont, &boldFont);	

		// Tranpose
		sDrawString = CBandDlg::GetInterval(pInstrument->nTranspose - nOctave*12);
		if(!TestIfIgnore(pInstrument, DMUS_IO_INST_TRANSPOSE))
		{
			bDisabled = true;
			pDC->SetTextColor(disabledTextColor);
		}
		else
		{
			bDisabled = false;
			pDC->SetTextColor(newTextColor);
		}
		DrawListItemText(pDC, lpDrawItemStruct, 41, 48, rect, sDrawString, bDisabled, pNormalFont, &boldFont);	

		
		// Find out where this priority range falls
		int nCount = 0;
		while(pInstrument->dwChannelPriority < dwaPriorityLevels[nCount] && nCount < PRIORITY_LEVELS)
			nCount++;

		sDrawString.LoadString(arrPriorityLevelNames[nCount]);
		if(!TestIfIgnore(pInstrument, DMUS_IO_INST_CHANNEL_PRIORITY))
		{
			bDisabled = true;
			pDC->SetTextColor(disabledTextColor);
		}
		else
		{
			bDisabled = false;
			pDC->SetTextColor(newTextColor);
		}
		DrawListItemText(pDC, lpDrawItemStruct, 47, 55, rect, sDrawString, bDisabled, pNormalFont, &boldFont);	

		// restore the old objects in the DC

		pDC->SetTextColor(oldTextColor);
		pDC->SetBkColor(oldBkColor);
	}

	// if the item is focused, draw the focus rectangle

	if ((lpDrawItemStruct->itemAction & ODA_FOCUS) != 0)
		pDC->DrawFocusRect(&(lpDrawItemStruct->rcItem));
}

CString CPChannelList::GetPChannelName(CDMInstrument* pInstrument)
{
	ASSERT(m_pBandDlg);

	// Get the project that this band belongs to...
	CBand* pBand  = m_pBandDlg->GetBand();
	IDMUSProdProject* pIProject = NULL;
	IDMUSProdNode* pIDocRootNode = NULL;

	if(FAILED(pBand->GetDocRootNode(&pIDocRootNode)))
		return ("");


	pBand->m_pComponent->m_pIFramework->FindProject(pIDocRootNode, &pIProject);

	ASSERT(pIProject);
	
	IDMUSProdPChannelName* pIPChannelName = NULL;

	WCHAR pszPChannelName[DMUS_MAX_NAME];

	if(pIProject->QueryInterface(IID_IDMUSProdPChannelName, (void**)&pIPChannelName) == S_OK)
		pIPChannelName->GetPChannelName(pInstrument->dwPChannel, pszPChannelName);
	else
		wcscpy(pszPChannelName, (wchar_t*)"");

	if(pIPChannelName)
		RELEASE(pIPChannelName);
	if(pIProject)
		RELEASE(pIProject);
	if(pIDocRootNode)
		RELEASE(pIDocRootNode);

	return CString(pszPChannelName);
}
	

void CPChannelList::DrawListItemText(CDC* pDC, LPDRAWITEMSTRUCT lpDrawItemStruct, 
									  int nLeftOffset, int nRightOffset, 
									  CRect& originalRect, CString& sText, 
									  bool bDisabled, CFont* pNormalFont, CFont* pBoldFont)
{
	CFont* pOldFont = pDC->SelectObject(pBoldFont);
	
	CRect tempRect;
	TEXTMETRIC textMetrics;
	pDC->GetTextMetrics(&textMetrics);

	tempRect.SetRect(originalRect.left + textMetrics.tmAveCharWidth * nLeftOffset, originalRect.top, 
					 originalRect.left + textMetrics.tmAveCharWidth * nRightOffset, originalRect.bottom);

	if(bDisabled)
		pDC->SelectObject(pNormalFont);

	pDC->ExtTextOut(tempRect.left,
		tempRect.top, ETO_OPAQUE,
		&(tempRect),
		sText,
		lstrlen(sText), NULL);

	// The default font is bold...
	// The TextMetrics are always calculated on the default font 
	// for correct placement of strings
	pDC->SelectObject(pOldFont);
}

bool CPChannelList::TestIfIgnore(CDMInstrument* pInstrument, DWORD dwTestFlag)
{
	if(pInstrument->dwFlags & dwTestFlag)
		return true;
	else
		return false;
}



void CPChannelList::OnMouseMove(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWnd* pWnd = GetFocus();

	if(m_pBandDlg->m_pBandCtrl && m_pBandDlg->m_pBandCtrl->IsChild(pWnd) == false)
		return;

	SelectPChannelFromPoint(point, false);

	CListBox::OnMouseMove(nFlags, point);
}


void CPChannelList::SelectPChannelFromPoint(CPoint point, bool bSelect)
{
	// Do nothing if items are selected
	int nSelectionCount = GetSelCount();
	
	ASSERT(m_pBandDlg);

	//	GetThe item nearest to this point
	BOOL bOutside;
	UINT nIndex = ItemFromPoint(point, bOutside);

	if(!bOutside)
	{

		CInstrumentListItem* pInstrumentItem = (CInstrumentListItem*)GetItemDataPtr(nIndex); 
		ASSERT( pInstrumentItem);
		if(pInstrumentItem == NULL)
			return;
		
		CDMInstrument* pInstrument = pInstrumentItem->GetInstrument();
		ASSERT(pInstrument);
		if(pInstrument == NULL)
			return;

		if(bSelect)
		{
			pInstrumentItem->SetSelected(true);
			SetSel(nIndex);
			m_pBandDlg->EnableGridButtonAndUpdateStatus(pInstrument->dwPChannel, true);
			m_pBandDlg->UpdateCommonPropertiesObject();
			m_pBandDlg->RefreshPChannelPropertyPage();
		}
		else if(nSelectionCount == 0)
			m_pBandDlg->DisplayStatus(pInstrument->dwPChannel);

	}
}


int CPChannelList::CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct) 
{
	CInstrumentListItem* pInstrumentItem1 = (CInstrumentListItem*) lpCompareItemStruct->itemData1;
	CInstrumentListItem* pInstrumentItem2 = (CInstrumentListItem*) lpCompareItemStruct->itemData2;

	// Any of the instruments are NULL we return.... 
	if(pInstrumentItem1 == NULL || pInstrumentItem2 == NULL || lpCompareItemStruct->itemID1 > 999 || lpCompareItemStruct->itemID2 > 999)
		return 0;

	CDMInstrument* pInstrument1 = pInstrumentItem1->GetInstrument();
	CDMInstrument* pInstrument2 = pInstrumentItem2->GetInstrument();

	ASSERT(pInstrument1);
	ASSERT(pInstrument2);


	if(pInstrument1->dwPChannel < pInstrument2->dwPChannel)
		return -1; // return -1 = item 1 sorts before item 2

	else if(pInstrument1->dwPChannel > pInstrument2->dwPChannel)
		return 1;  // return 1 = item 1 sorts after item 2

	else 
		return 0;  // return 0 = item 1 and item 2 sort the same
}

void CPChannelList::OnRButtonDown(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	//	GetThe item nearest to this point
	BOOL bOutside;
	UINT nIndex = ItemFromPoint(point, bOutside);
	
	if(bOutside)
		return;

	if(!(nFlags & MK_CONTROL) && GetSel(nIndex) == 0)
	{
		m_pBandDlg->GetBand()->UnselectAllInstruments();
		m_pBandDlg->UpdateGridControls();
		m_pBandDlg->UpdateCommonPropertiesObject();
		m_pBandDlg->RefreshPChannelPropertyPage();
		Invalidate();
		SetSel(-1, FALSE);
	}

	SelectPChannelFromPoint(point, true);
	
	CListBox::OnRButtonDown(nFlags, point);
}

void CPChannelList::OnKillFocus(CWnd* pNewWnd) 
{
	CListBox::OnKillFocus(pNewWnd);
	
	Invalidate();
}


void CPChannelList::OnSetFocus(CWnd* pOldWnd) 
{
	CListBox::OnSetFocus(pOldWnd);
	
	Invalidate();
}

void CPChannelList::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	if(nChar == VK_INSERT)
	{
		m_pBandDlg->InsertPChannel();
	}
	
	CListBox::OnKeyDown(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\PChannelPropPage.h ===
#if !defined(AFX_PCHANNELPROPPAGE_H__D5C695D2_2636_11D2_9A65_006097B01078__INCLUDED_)
#define AFX_PCHANNELPROPPAGE_H__D5C695D2_2636_11D2_9A65_006097B01078__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PChannelPropPage.h : header file
//


#define PRIORITY_LEVELS	4
static UINT arrPriorityLevelNames[PRIORITY_LEVELS] = { IDS_CRITICAL_VOICE_PRIORITY, IDS_HIGH_VOICE_PRIORITY,
													   IDS_STANDARD_VOICE_PRIORITY, IDS_LOW_VOICE_PRIORITY };
				

class CPChannelPropPageManager;
class CCommonInstrumentPropertyObject;

/////////////////////////////////////////////////////////////////////////////
// CPChannelPropPage dialog

class CPChannelPropPage : public CPropertyPage
{

// Construction
public:
	CPChannelPropPage(CPChannelPropPageManager* pPageManager);
	~CPChannelPropPage();
	
	void SetPChannel(CCommonInstrumentPropertyObject* pCommonInstrumentObject);

// Dialog Data
	//{{AFX_DATA(CPChannelPropPage)
	enum { IDD = IDD_TAB_PCHANNEL };
	CSpinButtonCtrl	m_PChNumberSpin;
	CButton	m_IgnorePitchBendRange;
	CSpinButtonCtrl	m_PBTransposeSpin;
	CEdit	m_PBTransposeEdit;
	CSpinButtonCtrl	m_PBOctaveSpin;
	CEdit	m_PBOctaveEdit;
	CStatic	m_InstrumentInfoStatic;
	CComboBox	m_PriorityCombo;
	CButton	m_SoundCanvasCheck;
	CButton	m_IgnoreNoteRange;
	CSpinButtonCtrl	m_HighNoteSpin;
	CEdit	m_HighNoteEdit;
	CSpinButtonCtrl	m_LowNoteSpin;
	CEdit	m_LowNoteEdit;
	CSpinButtonCtrl	m_VolumeSpin;
	CEdit			m_VolumeEdit;
	CSpinButtonCtrl	m_TransposeSpin;
	CEdit			m_TransposeEdit;
	CSpinButtonCtrl	m_PrioritySpin;
	CEdit			m_PriorityEdit;
	CEdit			m_PChNumberEdit;
	CEdit			m_PChNameEdit;
	CSpinButtonCtrl	m_PanSpin;
	CEdit			m_PanEdit;
	CEdit			m_OctaveEdit;
	CSpinButtonCtrl	m_OctaveSpin;
	CButton			m_SelectInstrument;
	CButton			m_IgnoreVolume;
	CButton			m_IgnorePriority;
	CButton			m_IgnorePan;
	CButton			m_IgnoreOctaveTranspose;
	CButton			m_IgnoreInstrument;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPChannelPropPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

//Attributes
public:
	static HMENU  m_hmenuPatch;
	static HMENU  m_hmenuDrums;
	static void CreatePatchPopupMenu();

protected:
		CCommonInstrumentPropertyObject* m_pCommonInstrumentObject;
		CPChannelPropPageManager* m_pPageManager;

// Implementation
protected:
	void LoadIntervals();
	void InitPriorityCombo();

	void EnableItem(int nID, BOOL fEnable);
	void CheckForIgnores(CCommonInstrumentPropertyObject* pCommonInstrumentObject);
	void CheckAndEnableControl(int nCheckState, CWnd& control);
	void EnableControls(BOOL fEnable);
	void UpdateControls(CCommonInstrumentPropertyObject* pCommonInstrumentObject);
	CString GetPanString(BYTE bPan);
	int GetPanValue(CString sPanString);
	void SetPriorityLevel(DWORD lPriorityLevel, DWORD dwPriorityOffset);

	
	// Generated message map functions
	//{{AFX_MSG(CPChannelPropPage)
	afx_msg void OnInstrumentButton();
	afx_msg void OnIgnoreInstrumentCheck();
	afx_msg void OnIgnoreOctavetransposeCheck();
	afx_msg void OnIgnorePanCheck();
	afx_msg void OnIgnorePriorityCheck();
	afx_msg void OnIgnoreVolumeCheck();
	afx_msg void OnDeltaposPanSpin(NMHDR* pNMHDR, LRESULT* pResult);
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusOctaveEdit();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillfocusPanEdit();
	afx_msg void OnKillfocusTransposeEdit();
	afx_msg void OnKillfocusVolumeEdit();
	afx_msg void OnKillfocusPriorityEdit();
	afx_msg void OnDeltaposVolumeSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposTransposeSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposOctaveSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposPrioritySpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnIgnoreNoteRangeCheck();
	afx_msg void OnKillfocusHighNoteEdit();
	afx_msg void OnKillfocusLowNoteEdit();
	afx_msg void OnDeltaposLowNoteSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposHighNoteSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnUseSoundcanvasCheck();
	afx_msg void OnSelchangePriorityCombo();
	afx_msg void OnChangePchannelNameEdit();
	afx_msg void OnIgnorePitchBendRangeCheck();
	afx_msg void OnKillfocusPitchBendOctaveEdit();
	afx_msg void OnDeltaposPitchBendOctaveSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusPitchBendTransposeEdit();
	afx_msg void OnDeltaposPitchBendTransposeSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposPChannelNumberSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusPChannelNumberEdit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

	bool m_fInChange;
	BOOL m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PCHANNELPROPPAGE_H__D5C695D2_2636_11D2_9A65_006097B01078__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\PChannelPropPageMgr.cpp ===
// PChannelPropPageMgr.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "BandEditorDLL.h"
#include "Band.h"
#include "BandDlg.h"
#include "DllBasePropPageManager.h"
#include "PCHannelPropPage.h"
#include "PChannelPropPageMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////
// CPChannelPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPChannelPropPageManager::CPChannelPropPageManager()
{
	m_pPChannelTab = NULL;
	m_GUIDManager = GUID_PChannelPropPageManager;
}

CPChannelPropPageManager::~CPChannelPropPageManager()
{
	if( m_pPChannelTab )
	{
		delete m_pPChannelTab;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelPropPageManager::RemoveCurrentObject

void CPChannelPropPageManager::RemoveCurrentObject( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CPChannelPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;
	CString strPChannel;
	strPChannel.LoadString( IDS_PCHANNEL_TEXT );

	CString strTitle = strPChannel;
	
	CBand* pBand = CInstrumentListItem::m_CommonPropertyObject.GetBandDialog()->GetBand();
	ASSERT(pBand);

	
	// Format title
	CString sBandName = "";
	BSTR bstrBandName;
	if(SUCCEEDED(pBand->GetNodeName(&bstrBandName)))
	{
		sBandName = bstrBandName;
		::SysFreeString(bstrBandName);
	}

	strTitle = sBandName + _T(": ") + strPChannel;
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}

	

/////////////////////////////////////////////////////////////////////////////
// CPChannelPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CPChannelPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add Band tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	if(m_pPChannelTab == NULL)
	{
		m_pPChannelTab = new CPChannelPropPage( this );
	}
	if( m_pPChannelTab )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pPChannelTab->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CPChannelPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDllBasePropPageManager::OnRemoveFromPropertySheet();

	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CPChannelPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CCommonInstrumentPropertyObject* pCommonInstrumentObject;
	
	if(m_pIPropPageObject == NULL)
	/*||(m_pIPropPageObject->GetData((void **)&pCommonInstrumentObject) != S_OK))*/
	{
		pCommonInstrumentObject = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pCommonInstrumentObject) ) )
	{
		return E_FAIL;
	}

	// Make sure changes to current Band are processed in OnKillFocus
	// messages before setting the new Band
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pPChannelTab->GetParent();

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	// Set Property tabs to display the new PChannel
	m_pPChannelTab->SetPChannel(pCommonInstrumentObject);
	
	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPChannelPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CPChannelPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( IsEqualObject( pINewPropPageObject ) != S_OK )
	{
		RemoveCurrentObject();

		m_pIPropPageObject = pINewPropPageObject;
//		m_pIPropPageObject->AddRef();		intentionally missing

		if( m_pIPropSheet )
		{
			m_pIPropSheet->RefreshTitle();
		}
	}

	RefreshData();

	return S_OK;
}
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\PChannelPropPageMgr.h ===
#ifndef __PCHANNELPROPPAGEMGR_H__
#define __PCHANNELPROPPAGEMGR_H__

//////////////////////////////////////////////////////////////////////
//  CBandPropPageManager

// {86E67810-2736-11d2-9A65-006097B01078}
static const GUID GUID_PChannelPropPageManager = 
{ 0x86e67810, 0x2736, 0x11d2, { 0x9a, 0x65, 0x0, 0x60, 0x97, 0xb0, 0x10, 0x78 } };

class CPChannelPropPageManager : public CDllBasePropPageManager 
{
friend class CPChannelPropPage;

public:
	CPChannelPropPageManager();
	virtual ~CPChannelPropPageManager();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();
	HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
	CPChannelPropPage*	m_pPChannelTab;
};

#endif // __PCHANNELPROPPAGEMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\PChannelPropPage.cpp ===
// PChannelPropPage.cpp : implementation file
//

#include "stdafx.h"
#include "bandeditordll.h"
#include "Band.h" 
#include "BandDlg.h"
#include "PChannelPropPage.h"
#include "PChannelPropPageMgr.h"
#include "PChannelName.h"
#include "resourcemaps.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern const UINT aidGroupFirstInstr[];
extern const UINT aidGroupName[];
extern BInstr abiGS[];
extern BInstr abiDrums[];

static const TCHAR achUnknown[11] = "----------";

// menu static member variables -- shared by all editor instances
HMENU CPChannelPropPage::m_hmenuPatch;
HMENU CPChannelPropPage::m_hmenuDrums;


/////////////////////////////////////////////////////////////////////////////
// CPChannelPropPage property page constructor

CPChannelPropPage::CPChannelPropPage(CPChannelPropPageManager* pPChannelPropPageManager) : CPropertyPage(CPChannelPropPage::IDD)
{
	//{{AFX_DATA_INIT(CPChannelPropPage)
	//}}AFX_DATA_INIT

	ASSERT(pPChannelPropPageManager);

	m_pCommonInstrumentObject= NULL;
	m_pPageManager = pPChannelPropPageManager;
	m_fNeedToDetach = FALSE;
}


CPChannelPropPage::~CPChannelPropPage()
{
}

/**
	Creates the Popup Menu for instrument selection. 
*/
void CPChannelPropPage::CreatePatchPopupMenu()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Do nothing if we already have valid menu handles
	if(::IsMenu(m_hmenuPatch) && ::IsMenu(m_hmenuDrums))
		return;

	HMENU     hmenu, hmenuGM, hmenuGS, hmenuDrums;
	char      buf[64];
	short     i;
	BInstr   *pbi;
	BOOL      fKeepGS;

	// Create the patch select popup menu
	m_hmenuPatch = CreatePopupMenu();
	hmenu = CreatePopupMenu();
	AppendMenu( m_hmenuPatch, MF_POPUP, (unsigned int) hmenu, "NULL" );
	hmenuGM = NULL;
	hmenuGS = NULL;

	pbi = &abiGS[0];
	i = 0;
#ifndef DMP_XBOX
	while( pbi->nStringId != IDS_PGMEND )
	{
		// Create a menu for GM and a submenu for GS
		if( hmenuGM == NULL )
		{
			fKeepGS = FALSE;
			hmenuGM = CreatePopupMenu();
			hmenuGS = CreatePopupMenu();
			AppendMenu( hmenuGM, MF_POPUP, (unsigned int) hmenuGS, "GS" );
			AppendMenu( hmenuGM, MF_SEPARATOR, 0, NULL );
		}

		// Append items to the correct menu
		if( pbi->bMSB == 0  &&  pbi->bLSB == 0 )
		{
			AppendMenu( hmenuGM, MF_STRING, pbi->nStringId, *pbi->pstrName );
		}
		else  {
			AppendMenu( hmenuGS, MF_STRING, pbi->nStringId, *pbi->pstrName );
			fKeepGS = TRUE;
		}

		// Next instrument
		pbi++;

		// Is this the first instrument in a new group?
		if( pbi->nStringId == aidGroupFirstInstr[i + 1] )
		{
			// Remove the GS menu and separator if no items were inserted
			if( !fKeepGS )  {
				RemoveMenu( hmenuGM, 0, MF_BYPOSITION );
				RemoveMenu( hmenuGM, 0, MF_BYPOSITION );
			}

			// Load the group name and append it to the main popup
			LoadString( theApp.m_hInstance, aidGroupName[i], buf, sizeof(buf) - 1 );
			AppendMenu( GetSubMenu( m_hmenuPatch, 0 ), MF_POPUP, (unsigned int) hmenuGM, buf );
			hmenuGM = NULL;
			i++;
		}
	}
#endif // DMP_XBOX

	// DLS menu item
	LoadString( theApp.m_hInstance, IDS_DLS, buf, sizeof(buf) - 1 );
	AppendMenu( GetSubMenu( m_hmenuPatch, 0 ), MF_SEPARATOR, 0, NULL );
	AppendMenu( GetSubMenu( m_hmenuPatch, 0 ), MF_STRING, IDS_DLS, buf );

	// Create the drums select popup menu
	m_hmenuDrums = CreatePopupMenu();
	hmenuDrums = CreatePopupMenu();
	AppendMenu( m_hmenuDrums, MF_POPUP, (unsigned int) hmenuDrums, "NULL" );
	pbi = &abiDrums[0];
	i = 0;
#ifndef DMP_XBOX
	while( pbi->nStringId != IDS_PGMEND )
	{
		AppendMenu( hmenuDrums, MF_STRING, pbi->nStringId, *pbi->pstrName );
		pbi++;
	}
#endif // DMP_XBOX
	LoadString( theApp.m_hInstance, IDS_DLS, buf, sizeof(buf) - 1 );
	AppendMenu( GetSubMenu( m_hmenuDrums, 0 ), MF_SEPARATOR, 0, NULL );
	AppendMenu( GetSubMenu( m_hmenuDrums, 0 ), MF_STRING, IDS_DLS, buf );
}


/**

  This method is called from OnShowProperties to set the 
  common property object for the property page, for each PChannel. 

*/
void CPChannelPropPage::SetPChannel(CCommonInstrumentPropertyObject* pCommonInstrumentObject)
{
	m_pCommonInstrumentObject = pCommonInstrumentObject;

	UpdateControls(pCommonInstrumentObject);
}

/////////////////////////////////////////////////////////////////////////////
// CPChannelPropPage::EnableItem

void CPChannelPropPage::EnableItem(int nID, BOOL fEnable)
{
	CWnd* pWnd = GetDlgItem( nID );

	if( pWnd )
	{
		if( fEnable == FALSE )
		{
			pWnd->SetWindowText( achUnknown );
		}
		pWnd->EnableWindow( fEnable );
	}
}


/**
  Enables/disables controls in the property page.
*/
void CPChannelPropPage::EnableControls(BOOL fEnable)
{
	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;

	EnableItem(IDC_PCHANNEL_NUMBER_EDIT, fEnable);

	if(pCommonPropertyObject->GetPChannelNumber() == -1)
	{
		// Can't edit this field when multiple PChannels are selected
		EnableItem(IDC_PCHANNEL_NAME_EDIT, FALSE);
	}
	else
	{
		EnableItem(IDC_PCHANNEL_NAME_EDIT, fEnable);
	}

	m_SelectInstrument.EnableWindow(fEnable);

	EnableItem(IDC_PRIORITY_EDIT, fEnable);
	m_PrioritySpin.EnableWindow(fEnable);

	EnableItem(IDC_OCTAVE_EDIT, fEnable);
	m_OctaveSpin.EnableWindow(fEnable);

	EnableItem(IDC_TRANSPOSE_EDIT, fEnable);
	m_TransposeSpin.EnableWindow(fEnable);

	EnableItem(IDC_PBOCTAVE_EDIT, fEnable);
	m_PBOctaveSpin.EnableWindow(fEnable);

	EnableItem(IDC_PBTRANSPOSE_EDIT, fEnable);
	m_PBTransposeSpin.EnableWindow(fEnable);

	EnableItem(IDC_VOLUME_EDIT, fEnable);
	m_VolumeSpin.EnableWindow(fEnable);

	EnableItem(IDC_PAN_EDIT, fEnable);
	m_PanSpin.EnableWindow(fEnable);

	EnableItem(IDC_LOWNOTE_EDIT, fEnable);
	m_LowNoteSpin.EnableWindow(fEnable);

	EnableItem(IDC_HIGHNOTE_EDIT, fEnable);
	m_HighNoteSpin.EnableWindow(fEnable);

	EnableItem(IDC_PRIORITY_EDIT, fEnable);
	m_PrioritySpin.EnableWindow(fEnable);
	m_PriorityCombo.EnableWindow(fEnable);

	m_IgnoreInstrument.EnableWindow(fEnable);
	m_IgnoreOctaveTranspose.EnableWindow(fEnable);
	m_IgnorePitchBendRange.EnableWindow(fEnable);
	m_IgnoreVolume.EnableWindow(fEnable);
	m_IgnorePan.EnableWindow(fEnable);
	m_IgnorePriority.EnableWindow(fEnable);
    m_IgnoreNoteRange.EnableWindow(fEnable);

	m_SoundCanvasCheck.EnableWindow(fEnable);
}


/**
  Checks if any of the ignores have been previously set and 
  disables or enables controls accordingly. 
*/
void CPChannelPropPage::CheckForIgnores(CCommonInstrumentPropertyObject* pCommonInstrumentObject)
{
	m_IgnoreInstrument.SetCheck(pCommonInstrumentObject->m_nIgnoreInstrument);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnoreInstrument, m_SelectInstrument);

	m_IgnoreOctaveTranspose.SetCheck(pCommonInstrumentObject->m_nIgnoreOctaveTranspose);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnoreOctaveTranspose, m_OctaveEdit);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnoreOctaveTranspose, m_TransposeEdit);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnoreOctaveTranspose, m_OctaveSpin);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnoreOctaveTranspose, m_TransposeSpin);

	m_IgnorePitchBendRange.SetCheck(pCommonInstrumentObject->m_nIgnorePitchBendRange);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnorePitchBendRange, m_PBOctaveEdit);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnorePitchBendRange, m_PBTransposeEdit);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnorePitchBendRange, m_PBOctaveSpin);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnorePitchBendRange, m_PBTransposeSpin);

	m_IgnoreVolume.SetCheck(pCommonInstrumentObject->m_nIgnoreVolume);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnoreVolume, m_VolumeEdit);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnoreVolume, m_VolumeSpin);

	m_IgnorePan.SetCheck(pCommonInstrumentObject->m_nIgnorePan);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnorePan, m_PanEdit);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnorePan, m_PanSpin);

	m_IgnorePriority.SetCheck(pCommonInstrumentObject->m_nIgnorePriority);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnorePriority, m_PriorityCombo);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnorePriority, m_PriorityEdit);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnorePriority, m_PrioritySpin);

	m_IgnoreNoteRange.SetCheck(pCommonInstrumentObject->m_nIgnoreNoteRange);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnoreNoteRange, m_LowNoteEdit);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnoreNoteRange, m_LowNoteSpin);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnoreNoteRange, m_HighNoteEdit);
	CheckAndEnableControl(pCommonInstrumentObject->m_nIgnoreNoteRange, m_HighNoteSpin);
}


/**
  Enbales/disables the passed control based on the check state.
*/
void CPChannelPropPage::CheckAndEnableControl(int nCheckState, CWnd& control)
{
	bool bEnable = false;
	if(nCheckState == IGNORE_OFF)
		bEnable = true;

	control.EnableWindow(bEnable);
}
	


/**
  Updates all the controls with values set in the passed common property object.
  In case of multiple selections the Edit controls will show the indeterminate state
  if the values for each PChannel are different.
*/
void CPChannelPropPage::UpdateControls(CCommonInstrumentPropertyObject*	pCommonInstrumentObject)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Do nothing when no property object or no channels selected
	if( pCommonInstrumentObject == NULL || pCommonInstrumentObject->GetNumberOfChannels() == 0)
	{
		EnableControls( FALSE );
		return;
	}

	EnableControls( TRUE );

	// Limit size of text
	m_PriorityEdit.LimitText( 5 );

	CheckForIgnores(pCommonInstrumentObject);

	CString sWindowText;

	int nSelectedChannels = pCommonInstrumentObject->GetNumberOfChannels();

	if(nSelectedChannels != 1)
	{
		m_PChNumberEdit.EnableWindow(FALSE);
		m_PChNumberSpin.EnableWindow(FALSE);
		m_PChNumberSpin.Invalidate();
	}
	else
	{
		m_PChNumberEdit.EnableWindow(TRUE);
		m_PChNumberSpin.EnableWindow(TRUE);
		m_PChNumberSpin.Invalidate();
	}

	// Set PCh#
	if(pCommonInstrumentObject->GetPChannelNumber() != -1)
	{
		DWORD dwPChannel =pCommonInstrumentObject->GetPChannelNumber();
		sWindowText.Format("%d",  dwPChannel + 1);
		m_PChNumberEdit.SetWindowText(sWindowText);
		m_PChNumberSpin.SetPos(dwPChannel);
	}
	else
	{
		m_PChNumberEdit.SetWindowText(achUnknown);
	}

	// Set PCh Name
	if(pCommonInstrumentObject->GetPChannelNumber() != -1)
	{
		m_PChNameEdit.SetWindowText(pCommonInstrumentObject->GetPChannelName());
	}
	else
	{
		m_PChNameEdit.SetWindowText(achUnknown);
	}

	// Set Instrument
	m_SelectInstrument.SetWindowText(pCommonInstrumentObject->GetInstrument());

	// Set the instrument Info
	m_InstrumentInfoStatic.SetWindowText(pCommonInstrumentObject->m_sInstrumentInfo);

	// Set Octave
	if(pCommonInstrumentObject->GetOctave() != -12)
	{
		m_OctaveSpin.SetPos(pCommonInstrumentObject->GetOctave());
		if(pCommonInstrumentObject->GetOctave() > 0)
		{
			sWindowText.Format("+%d",pCommonInstrumentObject->GetOctave());
		}
		else
		{
			sWindowText.Format("%d",pCommonInstrumentObject->GetOctave());
		}
	}
	else
	{
		m_OctaveSpin.SetPos(0);
		sWindowText = achUnknown;
	}
	m_OctaveEdit.SetWindowText(sWindowText);

	// Set Transpose
	if(pCommonInstrumentObject->GetTranspose() != -12 )
	{
		m_TransposeSpin.SetPos(pCommonInstrumentObject->GetTranspose());
		sWindowText = CBandDlg::GetInterval(pCommonInstrumentObject->GetTranspose());
	}
	else
	{
		m_OctaveSpin.SetPos(0);
		sWindowText = achUnknown;
	}
	m_TransposeEdit.SetWindowText(sWindowText);


	// Set Pitch Bend Octave
	if(pCommonInstrumentObject->GetPitchBendOctave() != -12)
	{
		m_PBOctaveSpin.SetPos(pCommonInstrumentObject->GetPitchBendOctave());
		if(pCommonInstrumentObject->GetPitchBendOctave() > 0)
		{
			sWindowText.Format("+%d",pCommonInstrumentObject->GetPitchBendOctave());
		}
		else
		{
			sWindowText.Format("%d",pCommonInstrumentObject->GetPitchBendOctave());
		}
	}
	else
	{
		m_PBOctaveSpin.SetPos(0);
		sWindowText = achUnknown;
	}
	m_PBOctaveEdit.SetWindowText(sWindowText);

	// Set Pitch Bend Interval
	if(pCommonInstrumentObject->GetPitchBendTranspose() != -12 )
	{
		m_PBTransposeSpin.SetPos(pCommonInstrumentObject->GetPitchBendTranspose());
		sWindowText = CBandDlg::GetInterval(pCommonInstrumentObject->GetPitchBendTranspose());
	}
	else
	{
		m_PBOctaveSpin.SetPos(0);
		sWindowText = achUnknown;
	}
	m_PBTransposeEdit.SetWindowText(sWindowText);

	// Set Volume
	if(pCommonInstrumentObject->GetVolume() != -1)
	{
		m_VolumeSpin.SetPos(pCommonInstrumentObject->GetVolume());
		sWindowText.Format("%d", pCommonInstrumentObject->GetVolume());
	}
	else
	{
		m_VolumeSpin.SetPos(0);
		sWindowText = achUnknown;
	}
	m_VolumeEdit.SetWindowText(sWindowText);

	// Set Pan
	if(pCommonInstrumentObject->GetPan() != -1)
	{
		m_PanSpin.SetPos(pCommonInstrumentObject->GetPan());
		sWindowText = GetPanString(BYTE(pCommonInstrumentObject->GetPan()));
	}
	else
	{
		m_PanSpin.SetPos(64); // Balanced
		sWindowText = achUnknown;
	}
	m_PanEdit.SetWindowText(sWindowText);

	// Set Note Range
	if(pCommonInstrumentObject->GetLowNote() != -1)
	{
		m_LowNoteSpin.SetPos(pCommonInstrumentObject->GetLowNote());
		sWindowText = CBandDlg::GetNoteText(pCommonInstrumentObject->GetLowNote());
	}
	else
	{
		m_LowNoteSpin.SetPos(0);
		sWindowText = achUnknown;
	}
	m_LowNoteEdit.SetWindowText(sWindowText);

	if(pCommonInstrumentObject->GetHighNote() != -1)
	{
		m_HighNoteSpin.SetPos(pCommonInstrumentObject->GetHighNote());
		sWindowText = CBandDlg::GetNoteText(pCommonInstrumentObject->GetHighNote());
	}
	else
	{
		m_HighNoteSpin.SetPos(127);
		sWindowText = achUnknown;
	}
	m_HighNoteEdit.SetWindowText(sWindowText);

	// Set Priority Level
	DWORD dwPriorityLevel = 0xFFFFFFFF;
	DWORD dwPriorityOffset = 0xFFFFFFFF;
	pCommonInstrumentObject->GetPriority(dwPriorityLevel, dwPriorityOffset);
	SetPriorityLevel(dwPriorityLevel, dwPriorityOffset);

	// Set SoundCanvas Check
	m_SoundCanvasCheck.SetCheck(pCommonInstrumentObject->GetSoundCanvas());
}

void CPChannelPropPage::SetPriorityLevel(DWORD dwPriorityLevel, DWORD dwPriorityOffset)
{
	// Find out where this priority range falls
	int nCount = 0;
	while(dwPriorityLevel < dwaPriorityLevels[nCount] && nCount < PRIORITY_LEVELS)
		nCount++;

	if(CInstrumentListItem::m_CommonPropertyObject.m_nChannels <= 1)
	{
		m_PriorityCombo.SetCurSel(nCount);

		CString sOffset;
		sOffset.Format("%d", dwPriorityOffset);

		m_PrioritySpin.SetPos(dwPriorityOffset);
		m_PriorityEdit.SetWindowText(sOffset);
	}
	else
	{
		if(dwPriorityLevel == 0xFFFFFFFF)
		{
			int nUnknownStrIndex = m_PriorityCombo.FindStringExact(-1, achUnknown);
			if(nUnknownStrIndex == CB_ERR)
				m_PriorityCombo.AddString(achUnknown);
			m_PriorityCombo.SelectString(-1, achUnknown);
		}
		else
		{
			int nUnknownStrIndex = m_PriorityCombo.FindStringExact(-1, achUnknown);
			if(nUnknownStrIndex == CB_ERR)
				m_PriorityCombo.DeleteString(nUnknownStrIndex);
			m_PriorityCombo.SetCurSel(nCount);
		}

		if(dwPriorityOffset == 0xFFFFFFFF)
		{
			m_PriorityEdit.SetWindowText(achUnknown);
		}
		else
		{
			CString sOffset;
			sOffset.Format("%d", dwPriorityOffset);

			m_PrioritySpin.SetPos(dwPriorityOffset);
			m_PriorityEdit.SetWindowText(sOffset);
		}
	}
}



/**
	Gets the String to be displayed for a Pan value. 
	(0 is extreme Left, 64 Mid and 128 extreme Right)
*/
CString CPChannelPropPage::GetPanString(BYTE bPan)
{
	CString sPanString;
	if(bPan < 63)
		sPanString.Format("L%d", 63 - bPan); 
	else if(bPan > 63)
		sPanString.Format("R%d", bPan - 63);
	else if(bPan == 63)
		sPanString.Format("Mid");
	else
		sPanString.Format("---");

	return sPanString;
}


void CPChannelPropPage::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPChannelPropPage)
	DDX_Control(pDX, IDC_PCHANNEL_NUMBER_SPIN, m_PChNumberSpin);
	DDX_Control(pDX, IDC_IGNORE_PBRANGE_CHECK, m_IgnorePitchBendRange);
	DDX_Control(pDX, IDC_PBTRANSPOSE_SPIN, m_PBTransposeSpin);
	DDX_Control(pDX, IDC_PBTRANSPOSE_EDIT, m_PBTransposeEdit);
	DDX_Control(pDX, IDC_PBOCTAVE_SPIN, m_PBOctaveSpin);
	DDX_Control(pDX, IDC_PBOCTAVE_EDIT, m_PBOctaveEdit);
	DDX_Control(pDX, IDC_INSTRUMENT_INFO_STATIC, m_InstrumentInfoStatic);
	DDX_Control(pDX, IDC_PRIORITY_COMBO, m_PriorityCombo);
	DDX_Control(pDX, IDC_USE_SOUNDCANVAS_CHECK, m_SoundCanvasCheck);
	DDX_Control(pDX, IDC_IGNORE_NOTERANGE_CHECK, m_IgnoreNoteRange);
	DDX_Control(pDX, IDC_HIGHNOTE_SPIN, m_HighNoteSpin);
	DDX_Control(pDX, IDC_HIGHNOTE_EDIT, m_HighNoteEdit);
	DDX_Control(pDX, IDC_LOWNOTE_SPIN, m_LowNoteSpin);
	DDX_Control(pDX, IDC_LOWNOTE_EDIT, m_LowNoteEdit);
	DDX_Control(pDX, IDC_VOLUME_SPIN, m_VolumeSpin);
	DDX_Control(pDX, IDC_VOLUME_EDIT, m_VolumeEdit);
	DDX_Control(pDX, IDC_TRANSPOSE_SPIN, m_TransposeSpin);
	DDX_Control(pDX, IDC_TRANSPOSE_EDIT, m_TransposeEdit);
	DDX_Control(pDX, IDC_PRIORITY_SPIN, m_PrioritySpin);
	DDX_Control(pDX, IDC_PRIORITY_EDIT, m_PriorityEdit);
	DDX_Control(pDX, IDC_PCHANNEL_NUMBER_EDIT, m_PChNumberEdit);
	DDX_Control(pDX, IDC_PCHANNEL_NAME_EDIT, m_PChNameEdit);
	DDX_Control(pDX, IDC_PAN_SPIN, m_PanSpin);
	DDX_Control(pDX, IDC_PAN_EDIT, m_PanEdit);
	DDX_Control(pDX, IDC_OCTAVE_EDIT, m_OctaveEdit);
	DDX_Control(pDX, IDC_OCTAVE_SPIN, m_OctaveSpin);
	DDX_Control(pDX, IDC_INSTRUMENT_BUTTON, m_SelectInstrument);
	DDX_Control(pDX, IDC_IGNORE_VOLUME_CHECK, m_IgnoreVolume);
	DDX_Control(pDX, IDC_IGNORE_PRIORITY_CHECK, m_IgnorePriority);
	DDX_Control(pDX, IDC_IGNORE_PAN_CHECK, m_IgnorePan);
	DDX_Control(pDX, IDC_IGNORE_OCTAVETRANSPOSE_CHECK, m_IgnoreOctaveTranspose);
	DDX_Control(pDX, IDC_IGNORE_INSTRUMENT_CHECK, m_IgnoreInstrument);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPChannelPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CPChannelPropPage)
	ON_BN_CLICKED(IDC_INSTRUMENT_BUTTON, OnInstrumentButton)
	ON_BN_CLICKED(IDC_IGNORE_INSTRUMENT_CHECK, OnIgnoreInstrumentCheck)
	ON_BN_CLICKED(IDC_IGNORE_OCTAVETRANSPOSE_CHECK, OnIgnoreOctavetransposeCheck)
	ON_BN_CLICKED(IDC_IGNORE_PAN_CHECK, OnIgnorePanCheck)
	ON_BN_CLICKED(IDC_IGNORE_PRIORITY_CHECK, OnIgnorePriorityCheck)
	ON_BN_CLICKED(IDC_IGNORE_VOLUME_CHECK, OnIgnoreVolumeCheck)
	ON_NOTIFY(UDN_DELTAPOS, IDC_PAN_SPIN, OnDeltaposPanSpin)
	ON_EN_KILLFOCUS(IDC_OCTAVE_EDIT, OnKillfocusOctaveEdit)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_PAN_EDIT, OnKillfocusPanEdit)
	ON_EN_KILLFOCUS(IDC_TRANSPOSE_EDIT, OnKillfocusTransposeEdit)
	ON_EN_KILLFOCUS(IDC_VOLUME_EDIT, OnKillfocusVolumeEdit)
	ON_EN_KILLFOCUS(IDC_PRIORITY_EDIT, OnKillfocusPriorityEdit)
	ON_NOTIFY(UDN_DELTAPOS, IDC_VOLUME_SPIN, OnDeltaposVolumeSpin)
	ON_NOTIFY(UDN_DELTAPOS, IDC_TRANSPOSE_SPIN, OnDeltaposTransposeSpin)
	ON_NOTIFY(UDN_DELTAPOS, IDC_OCTAVE_SPIN, OnDeltaposOctaveSpin)
	ON_NOTIFY(UDN_DELTAPOS, IDC_PRIORITY_SPIN, OnDeltaposPrioritySpin)
	ON_BN_CLICKED(IDC_IGNORE_NOTERANGE_CHECK, OnIgnoreNoteRangeCheck)
	ON_EN_KILLFOCUS(IDC_HIGHNOTE_EDIT, OnKillfocusHighNoteEdit)
	ON_EN_KILLFOCUS(IDC_LOWNOTE_EDIT, OnKillfocusLowNoteEdit)
	ON_NOTIFY(UDN_DELTAPOS, IDC_LOWNOTE_SPIN, OnDeltaposLowNoteSpin)
	ON_NOTIFY(UDN_DELTAPOS, IDC_HIGHNOTE_SPIN, OnDeltaposHighNoteSpin)
	ON_BN_CLICKED(IDC_USE_SOUNDCANVAS_CHECK, OnUseSoundcanvasCheck)
	ON_CBN_SELCHANGE(IDC_PRIORITY_COMBO, OnSelchangePriorityCombo)
	ON_EN_CHANGE(IDC_PCHANNEL_NAME_EDIT, OnChangePchannelNameEdit)
	ON_BN_CLICKED(IDC_IGNORE_PBRANGE_CHECK, OnIgnorePitchBendRangeCheck)
	ON_EN_KILLFOCUS(IDC_PBOCTAVE_EDIT, OnKillfocusPitchBendOctaveEdit)
	ON_NOTIFY(UDN_DELTAPOS, IDC_PBOCTAVE_SPIN, OnDeltaposPitchBendOctaveSpin)
	ON_EN_KILLFOCUS(IDC_PBTRANSPOSE_EDIT, OnKillfocusPitchBendTransposeEdit)
	ON_NOTIFY(UDN_DELTAPOS, IDC_PBTRANSPOSE_SPIN, OnDeltaposPitchBendTransposeSpin)
	ON_NOTIFY(UDN_DELTAPOS, IDC_PCHANNEL_NUMBER_SPIN, OnDeltaposPChannelNumberSpin)
	ON_EN_KILLFOCUS(IDC_PCHANNEL_NUMBER_EDIT, OnKillfocusPChannelNumberEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPChannelPropPage message handlers
void CPChannelPropPage::OnInstrumentButton() 
{
	// Show the Instruments popup here
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	CRect  rect;
	m_SelectInstrument.GetWindowRect( &rect );
	
	int nChannel = CInstrumentListItem::m_CommonPropertyObject.GetPChannelNumber();
	
	HMENU hmenu = m_hmenuDrums;

	if(nChannel != 9 && nChannel%16 != 9)
		hmenu = m_hmenuPatch;

	TrackPopupMenu( GetSubMenu( hmenu, 0 ), TPM_LEFTALIGN | TPM_VCENTERALIGN | TPM_LEFTBUTTON,
								rect.left, rect.bottom, 0, m_hWnd, NULL );
}

void CPChannelPropPage::OnIgnoreInstrumentCheck() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();
	ASSERT(pBandDlg);

	int nState = m_IgnoreInstrument.GetCheck();
	
	if( nState == 1)
	{
		m_SelectInstrument.EnableWindow(true);
		CInstrumentListItem::m_CommonPropertyObject.SetIgnoreInstrument(IGNORE_OFF);
		CInstrumentListItem::m_CommonPropertyObject.SetIgnoreOctaveTranspose(IGNORE_OFF);
		CInstrumentListItem::m_CommonPropertyObject.m_dwChanged = IGNORE_OCTAVETRANSPOSE_CHANGED;
	}
	else if(nState == 0)
	{
		CInstrumentListItem::m_CommonPropertyObject.SetIgnoreInstrument(IGNORE_ON);
		m_SelectInstrument.EnableWindow(false);
	}
	else
	{
		CInstrumentListItem::m_CommonPropertyObject.SetIgnoreInstrument(IGNORE_UNDT);
		m_SelectInstrument.EnableWindow(false);
	}

	// save the state for undo
	pBandDlg->SaveStateForUndo("Use Instrument Patch Change");

	CInstrumentListItem::m_CommonPropertyObject.m_dwChanged |= IGNORE_INSTRUMENT_CHANGED;
	m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
}

void CPChannelPropPage::OnIgnoreOctavetransposeCheck() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();
	ASSERT(pBandDlg);


	int nState = m_IgnoreOctaveTranspose.GetCheck();
	
	if( nState == 1)
	{
		m_OctaveEdit.EnableWindow(true);
		m_TransposeEdit.EnableWindow(true);

		m_OctaveSpin.EnableWindow(true);
		m_TransposeSpin.EnableWindow(true);

		CInstrumentListItem::m_CommonPropertyObject.SetIgnoreOctaveTranspose(IGNORE_OFF);
	}
	else if(nState == 0)
	{
		m_OctaveEdit.EnableWindow(false);
		m_TransposeEdit.EnableWindow(false);

		m_OctaveSpin.EnableWindow(false);
		m_TransposeSpin.EnableWindow(false);

		CInstrumentListItem::m_CommonPropertyObject.SetIgnoreOctaveTranspose(IGNORE_ON);
	}
	else
	{
		CInstrumentListItem::m_CommonPropertyObject.SetIgnoreOctaveTranspose(IGNORE_UNDT);
		
		m_OctaveEdit.EnableWindow(false);
		m_TransposeEdit.EnableWindow(false);

		m_OctaveSpin.EnableWindow(false);
		m_TransposeSpin.EnableWindow(false);
	}

	// save the state for undo
	pBandDlg->SaveStateForUndo("Use Octave/Transpose");


	CInstrumentListItem::m_CommonPropertyObject.m_dwChanged = IGNORE_OCTAVETRANSPOSE_CHANGED;
	m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
}

void CPChannelPropPage::OnIgnorePanCheck() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();
	ASSERT(pBandDlg);


	int nState = m_IgnorePan.GetCheck();
	
	if( nState == 1)
	{
		m_PanEdit.EnableWindow(true);
		m_PanSpin.EnableWindow(true);
		CInstrumentListItem::m_CommonPropertyObject.SetIgnorePan(IGNORE_OFF);
	}
	else if(nState == 0)
	{
		m_PanEdit.EnableWindow(false);
		m_PanSpin.EnableWindow(false);
		CInstrumentListItem::m_CommonPropertyObject.SetIgnorePan(IGNORE_ON);
	}
	else
	{
		m_PanEdit.EnableWindow(false);
		m_PanSpin.EnableWindow(false);
		CInstrumentListItem::m_CommonPropertyObject.SetIgnorePan(IGNORE_UNDT);
	}

	// save the state for undo
	pBandDlg->SaveStateForUndo("Use Pan");

	CInstrumentListItem::m_CommonPropertyObject.m_dwChanged = IGNORE_PAN_CHANGED;
	m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
}

void CPChannelPropPage::OnIgnorePriorityCheck() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();
	ASSERT(pBandDlg);

	int nState = m_IgnorePriority.GetCheck();
	
	if( nState == 1)
	{
		m_PriorityEdit.EnableWindow(true);
		m_PrioritySpin.EnableWindow(true);
		CInstrumentListItem::m_CommonPropertyObject.SetIgnorePriority(IGNORE_OFF);
	}
	else if(nState == 0)
	{
		m_PriorityEdit.EnableWindow(false);
		m_PrioritySpin.EnableWindow(false);
		CInstrumentListItem::m_CommonPropertyObject.SetIgnorePriority(IGNORE_ON);
	}
	else 
	{
		m_PriorityEdit.EnableWindow(false);
		m_PrioritySpin.EnableWindow(false);
		CInstrumentListItem::m_CommonPropertyObject.SetIgnorePriority(IGNORE_UNDT);
	}

	// Save the state for undo
	pBandDlg->SaveStateForUndo("Use Priority");

	CInstrumentListItem::m_CommonPropertyObject.m_dwChanged = IGNORE_PRIORITY_CHANGED;
	m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
}

void CPChannelPropPage::OnIgnoreVolumeCheck() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();
	ASSERT(pBandDlg);

	int nState = m_IgnoreVolume.GetCheck();
	
	if( nState == 1)
	{
		m_VolumeEdit.EnableWindow(true);
		m_VolumeSpin.EnableWindow(true);
		CInstrumentListItem::m_CommonPropertyObject.SetIgnoreVolume(IGNORE_OFF);
	}
	else if(nState == 0)
	{
		m_VolumeEdit.EnableWindow(false);
		m_VolumeSpin.EnableWindow(false);
		CInstrumentListItem::m_CommonPropertyObject.SetIgnoreVolume(IGNORE_ON);
	}
	else 
	{
		m_VolumeEdit.EnableWindow(false);
		m_VolumeSpin.EnableWindow(false);
		CInstrumentListItem::m_CommonPropertyObject.SetIgnoreVolume(IGNORE_UNDT);
	}

	// Save the state for undo
	pBandDlg->SaveStateForUndo("Use Volume");

	CInstrumentListItem::m_CommonPropertyObject.m_dwChanged = IGNORE_VOLUME_CHANGED;
	m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
}

void CPChannelPropPage::OnIgnoreNoteRangeCheck() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();
	ASSERT(pBandDlg);


	CInstrumentListItem::m_CommonPropertyObject.m_dwChanged = IGNORE_NOTERANGE_CHANGED;

	int nState = m_IgnoreNoteRange.GetCheck();
	
	if( nState == 1)
	{
		m_LowNoteEdit.EnableWindow(true);
		m_LowNoteSpin.EnableWindow(true);
		m_HighNoteEdit.EnableWindow(true);
		m_HighNoteSpin.EnableWindow(true);
		CInstrumentListItem::m_CommonPropertyObject.SetIgnoreNoteRange(IGNORE_OFF);
        CInstrumentListItem::m_CommonPropertyObject.m_dwChanged |= NOTERANGE_CHANGED;
	}
	else if(nState == 0)
	{
		m_LowNoteEdit.EnableWindow(false);
		m_LowNoteSpin.EnableWindow(false);
		m_HighNoteEdit.EnableWindow(false);
		m_HighNoteSpin.EnableWindow(false);
		CInstrumentListItem::m_CommonPropertyObject.SetIgnoreNoteRange(IGNORE_ON);
	}
	else 
	{
		m_LowNoteEdit.EnableWindow(false);
		m_LowNoteSpin.EnableWindow(false);
		m_HighNoteEdit.EnableWindow(false);
		m_HighNoteSpin.EnableWindow(false);
		CInstrumentListItem::m_CommonPropertyObject.SetIgnoreNoteRange(IGNORE_UNDT);
	}

	// Save the state for undo
	pBandDlg->SaveStateForUndo("Use Note Range");

	m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
}

BOOL CPChannelPropPage::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();

	m_PChNumberSpin.SetRange(0, 998);
	
	m_PanSpin.SetRange(0, 127);
	m_PanEdit.LimitText(3);
	
	m_VolumeSpin.SetRange(0, 127);
	m_VolumeEdit.LimitText(3);
	
	m_OctaveSpin.SetRange(-4, 4);
	m_OctaveEdit.LimitText(2);

	m_PBOctaveSpin.SetRange(0, 10);
	m_PBOctaveEdit.LimitText(2);

	m_TransposeSpin.SetRange(-11, 11);
	m_PBTransposeSpin.SetRange(-11, 11);

	m_LowNoteSpin.SetRange(0, 127);
	m_HighNoteSpin.SetRange(0, 127);

	InitPriorityCombo();
	m_PrioritySpin.SetRange(UD_MINVAL, UD_MAXVAL);

	m_fInChange = false;

	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPChannelPropPage::InitPriorityCombo()
{
	CString sPriorityString;
	for(int nCount = 0 ; nCount < PRIORITY_LEVELS; nCount++)
	{
		 sPriorityString.LoadString(arrPriorityLevelNames[nCount]);
		 int nInsertionIndex = m_PriorityCombo.InsertString(nCount, sPriorityString);
		 m_PriorityCombo.SetItemData(nInsertionIndex, dwaPriorityLevels[nCount]);
	}
}


// Handle the instrument popup menu commands in here
BOOL CPChannelPropPage::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// not a menu message
	if( lParam )  
		return CPropertyPage::OnCommand(wParam, lParam);

	//
	// This is very similar to CBand::OnContextCommand - please try to keep them in sync!
	//

	CBandDlg* pBandDlg = CInstrumentListItem::m_CommonPropertyObject.GetBandDialog();
	ASSERT(pBandDlg);

	CBand* pBand = pBandDlg->GetBand();
	ASSERT(pBand);
	
	// check for program changes
	BInstr  *pbi;

	pbi = &abiGS[0];
	int nCount = 0;
	while( pbi->nStringId != IDS_PGMEND )
	{
		if( pbi->nStringId == wParam )
		{
			// Save the state for undo
			pBandDlg->SaveStateForUndo("Program Change");

			CString sName = *pbi->pstrName;
			m_SelectInstrument.SetWindowText(sName);

			CInstrumentListItem::m_CommonPropertyObject.SetPatch(pbi->bPatch);
			CInstrumentListItem::m_CommonPropertyObject.SetInstrument(sName);
			CInstrumentListItem::m_CommonPropertyObject.m_dwChanged = INSTRUMENT_CHANGED;
			CInstrumentListItem::m_CommonPropertyObject.m_nABIIndex = nCount;
			m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);

			//return CPropertyPage::OnCommand(wParam, lParam);
			return 1;
		}
		pbi++;
		nCount++;
	}

	// check for drum program changes
	pbi = &abiDrums[0];
	nCount = 0;
	while( pbi->nStringId != IDS_PGMEND )
	{
		if( pbi->nStringId == wParam )
		{
			// Save the state for undo
			pBandDlg->SaveStateForUndo("Program Change");

			CString sName = *pbi->pstrName;
			m_SelectInstrument.SetWindowText(sName);

			CInstrumentListItem::m_CommonPropertyObject.SetPatch(pbi->bPatch);
			CInstrumentListItem::m_CommonPropertyObject.SetInstrument(sName);
			CInstrumentListItem::m_CommonPropertyObject.m_dwChanged = INSTRUMENT_CHANGED;
			CInstrumentListItem::m_CommonPropertyObject.m_dwInstrumentChangeID = DRUMS_REQUEST;
			CInstrumentListItem::m_CommonPropertyObject.m_nABIIndex = nCount;

			m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);

			//return CPropertyPage::OnCommand(wParam, lParam);
			return 1;
		}
		pbi++;
		nCount++;
	}

	// Check if it's other DLS request
	if( wParam == IDS_DLS )
	{
		// Save the state for undo
		pBandDlg->SaveStateForUndo("Program Change");

		CInstrumentListItem::m_CommonPropertyObject.m_dwInstrumentChangeID = DLS_REQUEST;
		CInstrumentListItem::m_CommonPropertyObject.m_dwChanged = INSTRUMENT_CHANGED;

		m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
		return 1;
	}

	return CPropertyPage::OnCommand(wParam, lParam);
}
	

int CPChannelPropPage::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}
	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	
	return 0;
}

void CPChannelPropPage::OnDestroy() 
{

	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();

}

BOOL CPChannelPropPage::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_PanSpin.SetPos(0);
	m_VolumeSpin.SetPos(0);
	m_OctaveSpin.SetPos(0);
	m_TransposeSpin.SetPos(0);

	// Update controls
	m_pPageManager->RefreshData();

	return CPropertyPage::OnSetActive();
}

void CPChannelPropPage::OnKillfocusOctaveEdit() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();

	ASSERT(pBandDlg);

	// Get the octave from the edit control and set it
	CString sOctaveString;
	m_OctaveEdit.GetWindowText(sOctaveString);
	int nOctaveValue = atoi(LPCTSTR(sOctaveString));

	if(nOctaveValue >= -4 && nOctaveValue <= 4)
		m_OctaveSpin.SetPos(nOctaveValue);

	int nChangedOctave = LOWORD(m_OctaveSpin.GetPos());
	if(nChangedOctave > 4)
		nChangedOctave = nChangedOctave - 65536;

	CString sTransposeString;
	m_TransposeEdit.GetWindowText(sTransposeString);
	int nTranspose = 0; 
	if(CBandDlg::GetTransposeValue(sTransposeString, &nTranspose))
		m_TransposeSpin.SetPos(nTranspose);

	nTranspose = LOWORD(m_TransposeSpin.GetPos());
	if(nTranspose > 11)
		nTranspose = nTranspose - 65536;

	CString sOctave;
	if(nChangedOctave > 0)
		sOctave.Format("+%d", nChangedOctave);
	else if(nChangedOctave <= 0)
		sOctave.Format("%d", nChangedOctave);
	m_OctaveEdit.SetWindowText(sOctave);


	CString sTranspose = CBandDlg::GetInterval(nTranspose);
	m_TransposeEdit.SetWindowText(sTranspose);

	int nOctaveTranspose = (nChangedOctave * 12) + nTranspose;

	if(nOctaveTranspose > 60)
		nOctaveTranspose = nOctaveTranspose - 65536;
	
	if(pCommonPropertyObject->GetOctaveTranspose() != nOctaveTranspose)
	{
		CUndoMan* pUndoMan = pBandDlg->m_pBandDo;

		// Save the state for undo
		pBandDlg->SaveStateForUndo("Transpose");

 		pCommonPropertyObject->m_dwChanged = OCTAVE_CHANGED;
		pCommonPropertyObject->SetReset(true);
		pCommonPropertyObject->SetOctaveTranspose(short(nOctaveTranspose));
		m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
	}
}



void CPChannelPropPage::OnKillfocusPanEdit() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();

	ASSERT(pBandDlg);

	// Get the string and parse it for the correct Pan value
	CString sPanString;
	m_PanEdit.GetWindowText(sPanString);
	int nPanValue = GetPanValue(sPanString);
	
	if(nPanValue != -1)
		m_PanSpin.SetPos(nPanValue);

	int nPan = LOWORD(m_PanSpin.GetPos());
	CString sNewPanValue = GetPanString(BYTE(nPan));
	m_PanEdit.SetWindowText(sNewPanValue);
	
	if(pCommonPropertyObject->m_nPan != nPan)
	{
		CUndoMan* pUndoMan = pBandDlg->m_pBandDo;

		// Save the state for undo
		pBandDlg->SaveStateForUndo("Pan");

		pCommonPropertyObject->m_dwChanged = PAN_CHANGED;
		pCommonPropertyObject->m_nPan = nPan;
		m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
	}
}

int CPChannelPropPage::GetPanValue(CString sPanString)
{
	if(sPanString.CompareNoCase("Mid") == 0)
		return 63;

	int nPanValue =  0;
	int nLength = sPanString.GetLength();
	CString sBalance = sPanString.Left(1);
	CString sValue = sPanString.Right(nLength - 1);
	
	nPanValue = atoi(LPCTSTR(sValue));
	
		
	if(sBalance.CompareNoCase("R") == 0)
		return 63 + nPanValue;
	else if(sBalance.CompareNoCase("L") == 0)
		return 63 - nPanValue;
	else
		return -1;
}


void CPChannelPropPage::OnKillfocusTransposeEdit() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Get the transpose from the edit control and set it
	
	CString sTransposeString;
	m_TransposeEdit.GetWindowText(sTransposeString);

	int nTransposeValue; 

	if(CBandDlg::GetTransposeValue(sTransposeString, &nTransposeValue))
		m_TransposeSpin.SetPos(nTransposeValue);

	OnKillfocusOctaveEdit();
}


void CPChannelPropPage::OnKillfocusVolumeEdit() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();

	ASSERT(pBandDlg);

	CString sVolumeString;
	m_VolumeEdit.GetWindowText(sVolumeString);
	int nVolumeValue = atoi(LPCTSTR(sVolumeString));

	if(nVolumeValue >= 0 && nVolumeValue  <= 128)
		m_VolumeSpin.SetPos(nVolumeValue );

	int nVolume = LOWORD(m_VolumeSpin.GetPos());
	CString sNewVolumeValue;
	sNewVolumeValue.Format("%d", nVolume);
	m_VolumeEdit.SetWindowText(sNewVolumeValue);

	if(pCommonPropertyObject->m_nVolume != nVolume)
	{
		CUndoMan* pUndoMan = pBandDlg->m_pBandDo;

		// Save the state for undo
		pBandDlg->SaveStateForUndo("Volume");

		pCommonPropertyObject->m_dwChanged = VOLUME_CHANGED;
		pCommonPropertyObject->m_nVolume = nVolume;
		m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
	}
}

void CPChannelPropPage::OnKillfocusPriorityEdit() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();
	ASSERT(pBandDlg);

	bool bPreserveOffset = false;
	int nPriorityOffset = 0;


	CString sPriorityString;
	m_PriorityEdit.GetWindowText(sPriorityString);
	if(sPriorityString != achUnknown)
	{
		nPriorityOffset = atoi(LPCTSTR(sPriorityString));
		if(nPriorityOffset >= UD_MINVAL && nPriorityOffset <= UD_MAXVAL)
			m_PrioritySpin.SetPos(nPriorityOffset);
		
		nPriorityOffset = LOWORD(m_PrioritySpin.GetPos());
	}
	else
	{
		bPreserveOffset = true;
	}

	// Get the current Selection from the Priority ComboBox.
	int nCurLevelIndex = m_PriorityCombo.GetCurSel();
	DWORD dwPriority = m_PriorityCombo.GetItemData(nCurLevelIndex);
	dwPriority |= nPriorityOffset;

	if(pCommonPropertyObject->m_dwPriority != dwPriority)
	{
		CUndoMan* pUndoMan = pBandDlg->m_pBandDo;

		// Save the state for undo
		pBandDlg->SaveStateForUndo("Priority");

		pCommonPropertyObject->m_dwChanged = PRIORITY_CHANGED;
		//pCommonPropertyObject->m_dwPriority = dwPriority;
		pCommonPropertyObject->SetReset(true);
		pCommonPropertyObject->SetPriority(dwPriority, bPreserveOffset);
		m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
	}
}

void CPChannelPropPage::OnKillfocusLowNoteEdit() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();

	ASSERT(pBandDlg);

	CString sLowNoteString;
	m_LowNoteEdit.GetWindowText(sLowNoteString);
	
	int nLowNoteValue = pCommonPropertyObject->m_nLowNote;
	if(FAILED(pBandDlg->GetNoteValue(sLowNoteString, &nLowNoteValue)))
	{
		nLowNoteValue = pCommonPropertyObject->m_nLowNote;
	}

	int nHighNote = LOWORD(m_HighNoteSpin.GetPos());
	if(nLowNoteValue < 0)
	{
		nLowNoteValue = 0;
	}
	else if(nLowNoteValue > nHighNote)
	{
        nLowNoteValue = nHighNote;
	}

    m_LowNoteSpin.SetPos(nLowNoteValue);
	sLowNoteString = pBandDlg->GetNoteText(nLowNoteValue);
	m_LowNoteEdit.SetWindowText(sLowNoteString);

	short nLowNote = LOWORD(m_LowNoteSpin.GetPos());

	if(pCommonPropertyObject->m_nLowNote != nLowNote)
	{
		CUndoMan* pUndoMan = pBandDlg->m_pBandDo;

		// Save the state for undo
		pBandDlg->SaveStateForUndo("LowNote");

		pCommonPropertyObject->m_dwChanged = NOTERANGE_CHANGED;
		pCommonPropertyObject->m_nLowNote = nLowNote;
		m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
	}
}

void CPChannelPropPage::OnKillfocusHighNoteEdit() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();

	ASSERT(pBandDlg);

	CString sHighNoteString;
	m_HighNoteEdit.GetWindowText(sHighNoteString);

	int nHighNoteValue = pCommonPropertyObject->m_nHighNote;
	if(FAILED(pBandDlg->GetNoteValue(sHighNoteString, &nHighNoteValue)))
	{
		nHighNoteValue = pCommonPropertyObject->m_nHighNote;
	}

	int nLowNote = LOWORD(m_LowNoteSpin.GetPos());
	if(nHighNoteValue < nLowNote)
	{
		nHighNoteValue = nLowNote;
	}
	else if(nHighNoteValue > 127)
	{
        nHighNoteValue = 127;
	}

    m_HighNoteSpin.SetPos(nHighNoteValue );

	sHighNoteString = pBandDlg->GetNoteText(nHighNoteValue);
	m_HighNoteEdit.SetWindowText(sHighNoteString);

	short nHighNote = LOWORD(m_HighNoteSpin.GetPos());

	if(pCommonPropertyObject->m_nHighNote != nHighNote)
	{
		CUndoMan* pUndoMan = pBandDlg->m_pBandDo;

		// Save the state for undo
		pBandDlg->SaveStateForUndo("HighNote");

		pCommonPropertyObject->m_dwChanged = NOTERANGE_CHANGED;
		pCommonPropertyObject->m_nHighNote = nHighNote;
		m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
	}
}

void CPChannelPropPage::OnDeltaposVolumeSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	int iCurrentPosition = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	if(iCurrentPosition + iDelta > 127)
	{
		iCurrentPosition = 127;
		iDelta = 0;
	}
	if(iCurrentPosition + iDelta < 0)
	{
		iCurrentPosition = 0;
		iDelta = 0;
	}

	if(!(iCurrentPosition == 127 && iDelta > 0) && !(iCurrentPosition == 0 && iDelta < 0))
	{
		CString sNewVolumeValue;
		sNewVolumeValue.Format("%d", iCurrentPosition + iDelta);
		m_VolumeEdit.SetWindowText(sNewVolumeValue);

		OnKillfocusVolumeEdit();
	}

	*pResult = 1;
}

void CPChannelPropPage::OnDeltaposPanSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int iCurrentPosition = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	if(iCurrentPosition + iDelta > 127)
	{
		iCurrentPosition = 127;
		iDelta = 0;
	}
	if(iCurrentPosition + iDelta < 0)
	{
		iCurrentPosition = 0;
		iDelta = 0;
	}

	if(!(iCurrentPosition == 127 && iDelta > 0) && !(iCurrentPosition == 0 && iDelta < 0))
	{
		CString sNewPanValue = GetPanString(iCurrentPosition + iDelta);
		m_PanEdit.SetWindowText(sNewPanValue);

		OnKillfocusPanEdit();
	}

	*pResult = 1;
}


void CPChannelPropPage::OnDeltaposTransposeSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int iCurPos = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	if(!(iCurPos == 11 && iDelta > 0) && !(iCurPos == -11 && iDelta < 0))
	{
		CString sTranspose = CBandDlg::GetInterval(iCurPos + iDelta);
		m_TransposeEdit.SetWindowText(sTranspose);
		m_TransposeSpin.SetPos(iCurPos + iDelta);
		OnKillfocusOctaveEdit();
	}

	*pResult = 1;
}


void CPChannelPropPage::OnDeltaposOctaveSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	int iCurPos = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	if(!(iCurPos == 4 && iDelta > 0) && !(iCurPos == -4 && iDelta < 0))
	{
		CString sOctave;
		int nChangedOctave = iCurPos + iDelta;
		if(nChangedOctave > 0)
			sOctave.Format("+%d", nChangedOctave);
		else if(nChangedOctave <= 0)
			sOctave.Format("%d", nChangedOctave);
		m_OctaveEdit.SetWindowText(sOctave);
		OnKillfocusOctaveEdit();
	}
	*pResult = 1;
}

void CPChannelPropPage::OnDeltaposPrioritySpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int iCurPos = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	int nPriorityOffset = iCurPos + iDelta;

	if(nPriorityOffset >= UD_MINVAL && nPriorityOffset <= UD_MAXVAL)
	{

		CString sPriorityOffset;
		sPriorityOffset.Format("%d", nPriorityOffset);
		m_PriorityEdit.SetWindowText(sPriorityOffset);
		
		OnKillfocusPriorityEdit();
	}
	*pResult = 1;
}

void CPChannelPropPage::OnDeltaposLowNoteSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	int iCurrentPosition = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	if(!(iCurrentPosition == 127 && iDelta > 0) && !(iCurrentPosition == 0 && iDelta < 0))
	{
		CString sNewLowNoteValue;
		sNewLowNoteValue.Format("%d", iCurrentPosition + iDelta);
		m_LowNoteEdit.SetWindowText(sNewLowNoteValue);

		OnKillfocusLowNoteEdit();
	}

	*pResult = 1;
}

void CPChannelPropPage::OnDeltaposHighNoteSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	int iCurrentPosition = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	if(!(iCurrentPosition == 127 && iDelta > 0) && !(iCurrentPosition == 0 && iDelta < 0))
	{
		CString sNewHighNoteValue;
		sNewHighNoteValue.Format("%d", iCurrentPosition + iDelta);
		m_HighNoteEdit.SetWindowText(sNewHighNoteValue);

		OnKillfocusHighNoteEdit();
	}

	*pResult = 1;
}

BOOL CPChannelPropPage::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					/*if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_NAME: 
								m_editName.SetWindowText( m_pBand->m_csName );
								break;
						}
					}*/
					return TRUE;
				}

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_VOLUME_EDIT: 
								OnKillfocusVolumeEdit();
								break;

							case IDC_PAN_EDIT: 
								OnKillfocusPanEdit();
								break;

							case IDC_OCTAVE_EDIT: 
								OnKillfocusOctaveEdit();
								break;

							case IDC_TRANSPOSE_EDIT: 
								OnKillfocusTransposeEdit();
								break;

							case IDC_PRIORITY_EDIT: 
								OnKillfocusPriorityEdit();
								break;
						}

						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}

	return CPropertyPage::PreTranslateMessage(pMsg);
}


/**

  If checked - The user is saying use the Roland SoundCanvas (TM) set for this patch

*/ 
void CPChannelPropPage::OnUseSoundcanvasCheck() 
{
	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();
	ASSERT(pBandDlg);

	int nState = m_SoundCanvasCheck.GetCheck();
	
	if(nState == 1)
		CInstrumentListItem::m_CommonPropertyObject.SetSoundCanvas(true);
	else 
	{
		m_SoundCanvasCheck.SetCheck(0);
		CInstrumentListItem::m_CommonPropertyObject.SetSoundCanvas(false);
	}

	// Save the state for undo
	pBandDlg->SaveStateForUndo("Always Use Default GM Set");

	CInstrumentListItem::m_CommonPropertyObject.m_dwChanged = SOUNDCANVAS_CHANGED;
	m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
}

void CPChannelPropPage::OnSelchangePriorityCombo() 
{
	OnKillfocusPriorityEdit();
}

void CPChannelPropPage::OnChangePchannelNameEdit() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();

	ASSERT(pBandDlg);

	// Get the string 
	CString sPChNameString;
	m_PChNameEdit.GetWindowText( sPChNameString );

	// Strip leading and trailing spaces
	sPChNameString.TrimRight();
	sPChNameString.TrimLeft();

	// Get the PChannel
	int nPChannelNumber = pCommonPropertyObject->GetPChannelNumber();

	if( nPChannelNumber == -1								// multiple items selected
	||  pCommonPropertyObject->GetNumberOfChannels() == 0 )	// no items selected
	{
//		CString strOrigPChName = pCommonPropertyObject->GetPChannelName();

		// Reset PChannel name
//		if( strOrigPChName.Compare( sPChNameString ) != 0 )
//		{
//			m_PChNameEdit.SetWindowText( strOrigPChName );
//		}
		return;
	}
	else
	{
		if( sPChNameString.Compare(achUnknown) == 0 )	// edit control string equals achUnknown
		{
			return;
		}
	}

	CBand* pBand  = pBandDlg->GetBand();
	IDMUSProdProject* pIProject;
	IDMUSProdPChannelName* pIPChannelName;

	// Get the Project that this Band belongs to...
	IDMUSProdNode* pIDocRootNode;
	if( SUCCEEDED ( pBand->GetDocRootNode( &pIDocRootNode ) ) )
	{
		if( SUCCEEDED ( pBand->m_pComponent->m_pIFramework->FindProject( pIDocRootNode, &pIProject) ) )
		{
			ASSERT(pIProject);

			// Query for an IDMUSProdPChannelName interface on the Project
			if( SUCCEEDED( pIProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&pIPChannelName ) ) )
			{
				// Found the interface, update the PChannel name 
				WCHAR wstrText[MAX_PATH];

				if( SUCCEEDED ( pIPChannelName->GetPChannelName( nPChannelNumber, wstrText ) ) )
				{
					CString strOrigPChName = wstrText;

					if( strOrigPChName.Compare( sPChNameString ) != 0 )
					{
						// Convert the name to wide characters
						MultiByteToWideChar( CP_ACP, 0, sPChNameString, -1, wstrText, MAX_PATH );

						pIPChannelName->SetPChannelName( nPChannelNumber, wstrText );
						pCommonPropertyObject->SetPChannelName( sPChNameString );
					}
				}

				RELEASE( pIPChannelName );
			}

			RELEASE( pIProject );
		}

		RELEASE( pIDocRootNode );
	}
}

void CPChannelPropPage::OnIgnorePitchBendRangeCheck() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();
	ASSERT(pBandDlg);


	int nState = m_IgnorePitchBendRange.GetCheck();
	
	if( nState == 1)
	{
		m_PBOctaveEdit.EnableWindow(true);
		m_PBTransposeEdit.EnableWindow(true);

		m_PBOctaveSpin.EnableWindow(true);
		m_PBTransposeSpin.EnableWindow(true);

		CInstrumentListItem::m_CommonPropertyObject.SetIgnorePitchBendRange(IGNORE_OFF);
	}
	else if(nState == 0)
	{
		m_PBOctaveEdit.EnableWindow(false);
		m_PBTransposeEdit.EnableWindow(false);

		m_PBOctaveSpin.EnableWindow(false);
		m_PBTransposeSpin.EnableWindow(false);

		CInstrumentListItem::m_CommonPropertyObject.SetIgnorePitchBendRange(IGNORE_ON);
	}
	else
	{
		CInstrumentListItem::m_CommonPropertyObject.SetIgnorePitchBendRange(IGNORE_UNDT);
		
		m_PBOctaveEdit.EnableWindow(false);
		m_PBTransposeEdit.EnableWindow(false);

		m_PBOctaveSpin.EnableWindow(false);
		m_PBTransposeSpin.EnableWindow(false);
	}

	// save the state for undo
	pBandDlg->SaveStateForUndo("Use Pitch Bend Range");


	CInstrumentListItem::m_CommonPropertyObject.m_dwChanged = IGNORE_PITCHBEND_CHANGED;
	m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
}

void CPChannelPropPage::OnKillfocusPitchBendOctaveEdit() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();

	ASSERT(pBandDlg);

	// Get the octave from the edit control and set it
	CString sOctaveString;
	m_PBOctaveEdit.GetWindowText(sOctaveString);
	int nOctaveValue = atoi(LPCTSTR(sOctaveString));

	if(nOctaveValue >= 0 && nOctaveValue <= 10)
	{
		m_PBOctaveSpin.SetPos(nOctaveValue);
	}

	int nChangedOctave = LOWORD(m_PBOctaveSpin.GetPos());
	if(nChangedOctave > 10)
	{
		nChangedOctave = nChangedOctave - 65536;
	}

	CString sTransposeString;
	m_PBTransposeEdit.GetWindowText(sTransposeString);
	int nTranspose = 0; 
	if(CBandDlg::GetTransposeValue(sTransposeString, &nTranspose))
	{
		m_PBTransposeSpin.SetPos(nTranspose);
	}

	nTranspose = LOWORD(m_PBTransposeSpin.GetPos());
	if(nTranspose > 11)
	{
		nTranspose = nTranspose - 65536;
	}

	CString sOctave;
	if(nChangedOctave > 0)
	{
		sOctave.Format("+%d", nChangedOctave);
	}
	else if(nChangedOctave <= 0)
	{
		sOctave.Format("%d", nChangedOctave);
	}
	m_PBOctaveEdit.SetWindowText(sOctave);


	CString sTranspose = CBandDlg::GetInterval(nTranspose);
	m_PBTransposeEdit.SetWindowText(sTranspose);

	int nPitchBendRange = (nChangedOctave * 12) + nTranspose;

	if(nPitchBendRange > 127)
	{
		nPitchBendRange = nPitchBendRange - 65536;
	}
	
	if(pCommonPropertyObject->GetPitchBendRange() != nPitchBendRange)
	{
		CUndoMan* pUndoMan = pBandDlg->m_pBandDo;

		// Save the state for undo
		pBandDlg->SaveStateForUndo("Pitch Bend Range");

 		pCommonPropertyObject->m_dwChanged = PITCHBEND_CHANGED;
		pCommonPropertyObject->SetReset(true);
		pCommonPropertyObject->SetPitchBendRange(short(nPitchBendRange));
		m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
	}
}

void CPChannelPropPage::OnDeltaposPitchBendOctaveSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	int iCurPos = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	if(!(iCurPos == 10 && iDelta > 0) && !(iCurPos == -10 && iDelta < 0))
	{
		CString sOctave;
		int nChangedOctave = iCurPos + iDelta;
		if(nChangedOctave > 0)
		{
			sOctave.Format("+%d", nChangedOctave);
		}
		else if(nChangedOctave <= 0)
		{
			sOctave.Format("%d", nChangedOctave);
		}
		m_PBOctaveEdit.SetWindowText(sOctave);
		OnKillfocusPitchBendOctaveEdit();
	}
	*pResult = 1;
}

void CPChannelPropPage::OnKillfocusPitchBendTransposeEdit() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Get the transpose from the edit control and set it
	
	CString sTransposeString;
	m_PBTransposeEdit.GetWindowText(sTransposeString);

	int nTransposeValue; 

	if(CBandDlg::GetTransposeValue(sTransposeString, &nTransposeValue))
	{
		m_PBTransposeSpin.SetPos(nTransposeValue);
	}

	OnKillfocusPitchBendOctaveEdit();
}

void CPChannelPropPage::OnDeltaposPitchBendTransposeSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	int iCurPos = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	if(!(iCurPos == 11 && iDelta > 0) && !(iCurPos == -11 && iDelta < 0))
	{
		CString sTranspose = CBandDlg::GetInterval(iCurPos + iDelta);
		m_PBTransposeEdit.SetWindowText(sTranspose);
		m_PBTransposeSpin.SetPos(iCurPos + iDelta);
		OnKillfocusPitchBendOctaveEdit();
	}

	*pResult = 1;
}

void CPChannelPropPage::OnDeltaposPChannelNumberSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();
	ASSERT(pBandDlg);
	if(pBandDlg == NULL)
	{
		return;
	}

	CBand* pBand = pBandDlg->GetBand();
	ASSERT(pBand);
	if(pBand == NULL)
	{
		return;
	}

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	
	int iCurPos = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	DWORD dwNextPChannel = iCurPos;

	if(iDelta > 0)
	{
		dwNextPChannel = pBand->GetNextAvailablePChannel(iCurPos);
	}
	else if(iDelta < 0)
	{
		dwNextPChannel = pBand->GetLastAvailablePChannel(iCurPos + 1);
		if(dwNextPChannel == DWORD(iCurPos + 1))
		{
			*pResult = 1;
			return;
		}
	}

	CString sNewPChNumber;
	sNewPChNumber.Format("%d", dwNextPChannel + 1);
	m_PChNumberEdit.SetWindowText(sNewPChNumber);
	OnKillfocusPChannelNumberEdit();
	
	*pResult = 1;
}

void CPChannelPropPage::OnKillfocusPChannelNumberEdit() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CCommonInstrumentPropertyObject* pCommonPropertyObject = &CInstrumentListItem::m_CommonPropertyObject;
	CBandDlg* pBandDlg = pCommonPropertyObject->GetBandDialog();
	ASSERT(pBandDlg);
	if(pBandDlg == NULL)
	{
		return;
	}

	CBand* pBand = pBandDlg->GetBand();
	ASSERT(pBand);
	if(pBand == NULL)
	{
		return;
	}


	DWORD dwOldPChNumber = pCommonPropertyObject->GetPChannelNumber();
	
	CString sNewPChNumber;
	m_PChNumberEdit.GetWindowText(sNewPChNumber);
	
	DWORD dwNewPChNumber = atoi((LPCSTR)sNewPChNumber) - 1;
	if(dwNewPChNumber == dwOldPChNumber)
	{
		// PChannel Number hasn't changed
		return;
	}

	// Check if this PChannel is free
	if(pBand->IsPChannelFree(dwNewPChNumber) && dwNewPChNumber <= 998)
	{
		m_PChNumberSpin.SetPos(dwNewPChNumber);

		CUndoMan* pUndoMan = pBandDlg->m_pBandDo;

		// Save the state for undo
		pBandDlg->SaveStateForUndo("PChannel Number");

		pCommonPropertyObject->m_dwChanged = PCHANNEL_CHANGED;
		pCommonPropertyObject->m_nPChannelNumber = dwNewPChNumber;
		m_pPageManager->m_pIPropPageObject->SetData(&CInstrumentListItem::m_CommonPropertyObject);
	}
	else
	{
		CString sOldPChNumber;
		sOldPChNumber.Format("%d", dwOldPChNumber + 1);
		m_PChNumberEdit.SetWindowText(sOldPChNumber);
		m_PChNumberSpin.SetPos(dwOldPChNumber);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BandEditorDLL.rc
//
#define IDS_BAND                        1
#define IDD_ABOUTBOX_BAND               1
#define IDB_BAND                        1
#define IDI_ABOUTDLL                    1
#define IDS_BAND_PPG                    2
#define IDS_DLS                         3
#define IDS_PGMEND                      4
#define IDM_CREATE_FILE                 104
#define IDS_REMOVEWARNING               106
#define IDS_CONFIRM                     107
#define IDS_ZERO_CHANNELS               112
#define IDS_PCHANNEL_TEXT               113
#define IDS_NO_TRANSPOSE                114
#define IDS_MINOR_SECOND                115
#define IDS_MAJOR_SECOND                116
#define IDS_MINOR_THIRD                 117
#define IDS_MAJOR_THIRD                 118
#define IDS_PERFECT_FOURTH              119
#define IDS_FLAT_FIFTH                  120
#define IDS_PERFECT_FIFTH               121
#define IDS_MINOR_SIXTH                 122
#define IDS_MAJOR_SIXTH                 123
#define IDS_MINOR_SEVENTH               124
#define IDS_MAJOR_SEVENTH               125
#define IDS_CRITICAL_VOICE_PRIORITY     126
#define IDS_HIGH_VOICE_PRIORITY         127
#define IDS_STANDARD_VOICE_PRIORITY     128
#define IDS_LOW_VOICE_PRIORITY          129
#define IDS_PERSIST_VOICE_PRIORITY      130
#define IDS_STRING131                   131
#define IDS_BAND_PPG_CAPTION            200
#define IDD_PROPPAGE_BAND               200
#define IDD_DLG_BAND                    201
#define IDC_GRIDCTRL1                   201
#define IDC_GRID                        201
#define IDC_CHANNEL_LIST                201
#define IDC_PCHANNEL_EDIT               202
#define IDC_PGM1                        203
#define IDC_PCHANNEL_SPIN               203
#define IDB_UBASS                       204
#define IDC_ADD_BTN                     204
#define IDD_ADDREMOVE                   204
#define IDB_UDRUMS                      205
#define IDC_REMOVE_BTN                  205
#define IDB_UGTR                        206
#define IDB_UKYBD                       207
#define IDC_SEND_BAND                   208
#define IDS_BAND_FOLDER_NAME            208
#define IDB_USAX                        208
#define IDS_BAND_COMPONENT_NAME         209
#define IDB_UVIOLN                      209
#define IDR_BAND_DOCTYPE                210
#define IDR_GMGS                        210
#define IDR_INSTR                       210
#define IDR_OCTAVE                      211
#define IDC_GS1                         212
#define IDD_DLS                         213
#define IDC_DLS                         214
#define IDR_PCHANNELLIST_MENU           214
#define IDC_OCT1                        215
#define IDD_TAB_PCHANNEL                215
#define IDC_CHANNEL                     216
#define IDR_ACCELERATOR1                216
#define IDC_PAN                         217
#define IDC_VOLUME                      218
#define IDI_BAND_DOCTYPE_SEL            220
#define IDS_ERR_MISSING_CONDUCTOR       221
#define IDS_STATUS_FORMAT               222
#define IDM_BAND_NODE_RMENU             223
#define IDC_DLSLIST                     223
#define IDS_BAND_OBJECT_TEXT            223
#define IDC_DLSMSB                      224
#define IDC_NAME                        224
#define IDI_BANDREF_NODE                224
#define IDS_NO_BAND                     224
#define IDI_FOLDER                      225
#define IDS_ERR_MISSING_BAND            225
#define IDC_DLSLSB                      225
#define IDI_FOLDER_SEL                  226
#define IDC_DLSPC                       226
#define IDS_ERR_REGISTER_CF             226
#define IDS_ERR_MEMORY                  227
#define IDI_BANDREF_NODE_SEL            227
#define IDS_ERR_ADD_DOCTYPE             228
#define IDS_ERR_ADD_IMAGELIST           229
#define IDS_ERR_ADD_CLIPFORMAT          230
#define IDM_BANDS_NODE_RMENU            231
#define IDS_FILE_OPEN_DLS               231
#define IDD_TAB_BAND                    232
#define IDS_FILE_OPEN_ANY_DLS           232
#define IDS_BAND_TEXT                   233
#define IDC_LENGTH                      233
#define IDS_UNDO_ACCEL                  234
#define IDC_COLLECTIONS_COMBO           235
#define IDS_REDO_ACCEL                  235
#define IDS_UNDO                        236
#define IDC_PCHANNEL_LIST               236
#define IDS_REDO                        237
#define IDC_PCH_NUMBER_STATIC           237
#define IDC_PCH_NAME_STATIC             238
#define IDC_PCHANNEL_NUMBER_STATIC      238
#define IDS_UNKNOWN                     238
#define IDC_INSTRUMENT_STATIC           239
#define IDC_PCHANNEL_NUMBER_EDIT        239
#define IDS_GM                          239
#define IDR_BAND_EDITOR                 240
#define IDC_OCTAVE_STATIC               240
#define IDS_GS                          240
#define IDC_TRANSPOSE_STATIC            241
#define IDC_PCHANNEL_NAME_STATIC        241
#define IDM_BAND_DOCROOT_RMENU          241
#define IDS_MOTIF_TEXT                  241
#define IDC_VOLUME_STATIC               242
#define IDC_PCHANNEL_NAME_EDIT          242
#define IDM_BANDREF_NODE_RMENU          242
#define IDS_XBOX_ERROR_NO_COLLECTION    242
#define IDC_PAN_STATIC                  243
#define IDC_PCHINSTRUMENT_STATIC        243
#define IDS_XBOX_ERROR_PATCH            243
#define IDC_PRIORITY_STATIC             244
#define IDC_INSTRUMENT_BUTTON           244
#define IDD_DLG_GUID                    244
#define IDC_IGNORE_INSTRUMENT_CHECK     245
#define IDC_OCTAVE_EDIT                 246
#define IDC_OCTAVE_SPIN                 247
#define IDC_PCHOCTAVE_STATIC            248
#define IDC_IGNORE_OCTAVETRANSPOSE_CHECK 249
#define IDC_TRANSPOSE_EDIT              250
#define IDC_TRANSPOSE_SPIN              251
#define IDC_PCHTRANSPOSE_STATIC         252
#define IDC_USE_SOUNDCANVAS_CHECK       253
#define IDC_IGNORE_PRIORITY_CHECK       254
#define IDC_PRIORITY_EDIT               255
#define IDC_PRIORITY_SPIN               256
#define IDC_PCHPRIORITY_STATIC          257
#define IDC_PCHTRANSPOSE_STATIC2        257
#define IDC_VOLUME_EDIT                 258
#define IDC_VOLUME_SPIN                 259
#define IDC_PCHVOLUME_STATIC            260
#define IDC_IGNORE_PAN_CHECK            261
#define IDC_PAN_EDIT                    262
#define IDC_PAN_SPIN                    263
#define IDC_PCHPAN_STATIC               264
#define IDC_IGNORE_VOLUME_CHECK         265
#define IDC_IGNORE_NOTERANGE_CHECK      266
#define IDC_LOWNOTE_EDIT                267
#define IDC_LOWNOTE_SPIN                268
#define IDC_PCHLOWNOTE_STATIC           269
#define IDC_IGNORE_PBRANGE_CHECK        269
#define IDC_HIGHNOTE_EDIT               270
#define IDC_HIGHNOTE_SPIN               271
#define IDC_PCHHIGHNOTE_STATIC          272
#define IDC_PBOCTAVE_EDIT               272
#define IDC_PRIORITY_COMBO              273
#define IDC_PBOCTAVE_SPIN               274
#define IDC_PBTRANSPOSE_EDIT            275
#define IDC_PBTRANSPOSE_SPIN            276
#define IDC_INSTRUMENT_INFO_STATIC      282
#define IDC_PCHANNEL_NUMBER_SPIN        283
#define IDS_HELP_FILE_EXT               300
#define IDS_NOTE_C                      301
#define IDS_NOTE_CSHARP                 302
#define IDS_NOTE_D                      303
#define IDS_NOTE_DSHARP                 304
#define IDC_EDIT_GUID                   305
#define IDS_NOTE_E                      305
#define IDC_NEW_GUID                    306
#define IDS_NOTE_F                      306
#define IDS_NOTE_FSHARP                 307
#define IDS_NOTE_G                      308
#define IDS_NOTE_GSHARP                 309
#define IDS_NOTE_A                      310
#define IDS_NOTE_ASHARP                 311
#define IDS_NOTE_B                      312
#define IDC_PGM2                        336
#define IDC_BUTTON6                     337
#define IDC_BUTTON7                     338
#define IDC_BUTTON8                     339
#define IDC_OCT2                        339
#define IDC_PGM3                        340
#define IDC_BUTTON10                    341
#define IDC_BUTTON11                    342
#define IDC_BUTTON12                    343
#define IDC_OCT3                        343
#define IDC_PGM4                        344
#define IDC_BUTTON14                    345
#define IDC_BUTTON15                    346
#define IDC_BUTTON16                    347
#define IDC_OCT4                        347
#define IDC_PGM5                        348
#define IDC_BUTTON18                    349
#define IDC_BUTTON19                    350
#define IDC_BUTTON20                    351
#define IDC_OCT5                        351
#define IDC_PGM6                        352
#define IDC_BUTTON22                    353
#define IDC_BUTTON23                    354
#define IDC_BUTTON24                    355
#define IDC_OCT6                        355
#define IDC_PGM7                        356
#define IDC_BUTTON26                    357
#define IDC_BUTTON27                    358
#define IDC_BUTTON28                    359
#define IDC_OCT7                        359
#define IDC_PGM8                        360
#define IDC_BUTTON30                    361
#define IDC_BUTTON31                    362
#define IDC_BUTTON32                    363
#define IDC_OCT8                        363
#define IDC_PGM9                        364
#define IDC_BUTTON34                    365
#define IDC_BUTTON35                    366
#define IDC_BUTTON36                    367
#define IDC_OCT9                        367
#define IDC_PGM10                       368
#define IDC_BUTTON38                    369
#define IDC_BUTTON39                    370
#define IDC_BUTTON40                    371
#define IDC_OCT10                       371
#define IDC_PGM11                       372
#define IDC_BUTTON42                    373
#define IDC_BUTTON43                    374
#define IDC_BUTTON44                    375
#define IDC_OCT11                       375
#define IDC_PGM12                       376
#define IDC_BUTTON46                    377
#define IDC_BUTTON47                    378
#define IDC_BUTTON48                    379
#define IDC_OCT12                       379
#define IDC_PGM13                       380
#define IDC_BUTTON50                    381
#define IDC_BUTTON51                    382
#define IDC_BUTTON52                    383
#define IDC_OCT13                       383
#define IDC_PGM14                       384
#define IDC_BUTTON54                    385
#define IDC_BUTTON55                    386
#define IDC_BUTTON56                    387
#define IDC_OCT14                       387
#define IDC_PGM15                       388
#define IDC_BUTTON58                    389
#define IDC_BUTTON59                    390
#define IDC_BUTTON60                    391
#define IDC_OCT15                       391
#define IDC_PGM16                       392
#define IDC_BUTTON62                    393
#define IDC_BUTTON63                    394
#define IDC_BUTTON64                    395
#define IDC_OCT16                       395
#define IDR_BANDMENU                    444
#define IDC_FILE_VERSION                1031
#define IDC_NAME1                       3001
#define IDC_NAME2                       3002
#define IDC_NAME3                       3003
#define IDC_NAME4                       3004
#define IDC_NAME5                       3005
#define IDC_NAME6                       3006
#define IDC_NAME7                       3007
#define IDC_NAME8                       3008
#define IDC_NAME9                       3009
#define IDC_NAME10                      3010
#define IDC_NAME11                      3011
#define IDC_NAME12                      3012
#define IDC_NAME13                      3013
#define IDC_NAME14                      3014
#define IDC_NAME15                      3015
#define IDC_NAME16                      3016
#define ID__PIANO                       32768
#define ID_P_PIANO2                     32768
#define IDM_DELETE                      32773
#define IDM_RENAME                      32774
#define IDM_PROPERTIES                  32775
#define ID_VIBES_TUBULARBELLS           32776
#define ID_CP_TUBULARBELLS              32776
#define ID_EDIT_DELETE                  32777
#define ID_EDIT_PROPERTIES              32778
#define ID_EDIT_SELECTALL               32779
#define ID_PIANO_RHODESPIANO            32780
#define ID_P_EPIANO1                    32780
#define ID_STYLE_SPECIALSTUFF           32781
#define ID_PIANO_CHORUSEDPIANO          32781
#define ID_P_EPIANO2                    32781
#define ID_PIANO_HARPSICHORD            32782
#define ID_P_HARPSICHORD                32782
#define ID_PIANO_CLAVINET               32783
#define ID_P_CLAV                       32783
#define IDM_NEW_BAND                    32784
#define ID_PIANO_ACOUSTICGRANDPIANO     32784
#define ID_P_PIANO1                     32784
#define ID_VIBES_DULCIMER               32790
#define ID_CP_DULCIMER                  32790
#define ID_ORGAN_HAMMONDORGAN           32792
#define ID_ORGAN_PERCUSSIVEORGAN        32793
#define ID_ORGAN_ROCKORGAN              32794
#define ID_ORGAN_CHURCHORGAN            32795
#define ID_ORGAN_REEDORGAN              32796
#define ID_ORGAN_ACCORDION              32797
#define ID_ORGAN_HARMONICA              32798
#define ID_ORGAN_TANGOACCORDION         32799
#define ID_UP4OCTAVES                   32800
#define ID_UP3OCTAVES                   32801
#define ID_UP2OCTAVES                   32802
#define ID_UP1OCTAVE                    32803
#define ID_NOCHANGE                     32804
#define ID_DOWN1OCTAVE                  32805
#define ID_DOWN2OCTAVES                 32806
#define ID_DOWN3OCTAVES                 32807
#define ID_DOWN4OCTAVES                 32808
#define ID_OPEN_BANDEDITOR              32810
#define ID_INSERT_NEWINSTRUMENT         32811
#define ID_LOCATE_BAND                  32812
#define ID_P_PIANO1W                    32815
#define ID_P_PIANO1D                    32816
#define ID_P_PIANO2W                    32817
#define ID_P_PIANO3W                    32818
#define ID_P_HONKYTONKW                 32819
#define ID_P_DETUNEDEP1                 32820
#define ID_P_EPIANO1W                   32821
#define ID_P_60SEPIANO                  32822
#define ID_P_DETUNEDEP2                 32823
#define ID_P_EPIANO2W                   32824
#define ID_P_COUPLEDHPS                 32825
#define ID_P_HARPSIW                    32826
#define ID_P_HARPSIO                    32827
#define IDM_CUT                         32828
#define IDM_COPY                        32829
#define IDM_PASTE                       32830
#define IDM_HELP_FINDER                 32831
#define IDM_ADDRMV_PCHANNEL             32834
#define ID_INSERT_PCHANNEL              32836
#define ID_DELETE_PCHANNEL              32837
#define ID_VIBES_CELESTA                33770
#define ID_CP_CELESTA                   33770
#define ID_VIBES_GLOCKENSPIEL           33771
#define ID_CP_GLOCKENSPIEL              33771
#define ID_VIBES_MUSICBOX               33772
#define ID_CP_MUSICBOX                  33772
#define ID_VIBES_VIBRAPHONE             33773
#define ID_CP_VIBRAPHONE                33773
#define ID_VIBES_MARIMBA                33774
#define ID_CP_MARIMBA                   33774
#define ID_VIBES_XYLOPHONE              33775
#define ID_CP_XYLOPHONE                 33775
#define ID_PIANO_ELECTRICGRANDPIANO     33778
#define ID_P_PIANO3                     33778
#define ID_PIANO_HONKYTONKPIANO         33779
#define ID_P_HONKYTONK                  33779
#define IDS_ERR_INVALIDARG              57645
#define IDS_SAVE_TEXT                   57646
#define IDS_SAVE_AS_TEXT                57647
#define IDS_REVERT_TEXT                 57648
#define IDS_BAND_COMP_FOLDER_NAME       57650
#define IDS_PGM000                      57651
#define IDS_PGM008                      57652
#define IDS_PGM0016                     57653
#define IDS_PGM010                      57654
#define IDS_PGM018                      57655
#define IDS_PGM020                      57656
#define IDS_PGM028                      57657
#define IDS_PGM030                      57658
#define IDS_PGM038                      57659
#define IDS_PGM040                      57660
#define IDS_PGM048                      57661
#define IDS_PGM0416                     57662
#define IDS_PGM0424                     57663
#define IDS_PGM050                      57664
#define IDS_PGM058                      57665
#define IDS_PGM0516                     57666
#define IDS_PGM060                      57667
#define IDS_PGM068                      57668
#define IDS_PGM0616                     57669
#define IDS_PGM0624                     57670
#define IDS_PGM070                      57671
#define IDS_TN1                         57672
#define IDS_TN2                         57673
#define IDS_TN3                         57674
#define IDS_TN4                         57675
#define IDS_TN5                         57676
#define IDS_TN6                         57677
#define IDS_TN7                         57678
#define IDS_TN8                         57679
#define IDS_TN9                         57680
#define IDS_TN10                        57681
#define IDS_TN11                        57682
#define IDS_TN12                        57683
#define IDS_TN13                        57684
#define IDS_TN14                        57685
#define IDS_TN15                        57686
#define IDS_TN16                        57687
#define IDS_GRP1                        57688
#define IDS_GRP2                        57689
#define IDS_GRP3                        57690
#define IDS_GRP4                        57691
#define IDS_GRP5                        57692
#define IDS_GRP6                        57693
#define IDS_GRP7                        57694
#define IDS_GRP8                        57695
#define IDS_GRP9                        57696
#define IDS_GRP10                       57697
#define IDS_GRP11                       57698
#define IDS_GRP12                       57699
#define IDS_GRP13                       57700
#define IDS_GRP14                       57701
#define IDS_GRP15                       57702
#define IDS_GRP16                       57703
#define IDS_PGM080                      57704
#define IDS_PGM090                      57705
#define IDS_PGM0A0                      57706
#define IDS_PGM0B0                      57707
#define IDS_PGM0B8                      57708
#define IDS_PGM0C0                      57709
#define IDS_PGM0C8                      57710
#define IDS_PGM0D0                      57711
#define IDS_PGM0E0                      57712
#define IDS_PGM0E8                      57713
#define IDS_PGM0E9                      57714
#define IDS_PGM0F0                      57715
#define IDS_PGM100                      57716
#define IDS_PGM108                      57717
#define IDS_PGM1016                     57718
#define IDS_PGM1032                     57719
#define IDS_PGM110                      57720
#define IDS_PGM118                      57721
#define IDS_PGM1132                     57722
#define IDS_PGM120                      57723
#define IDS_PGM130                      57724
#define IDS_PGM138                      57725
#define IDS_PGM1316                     57726
#define IDS_PGM140                      57727
#define IDS_PGM150                      57728
#define IDS_PGM158                      57729
#define IDS_PGM160                      57730
#define IDS_PGM170                      57731
#define IDS_PGM180                      57732
#define IDS_PGM188                      57733
#define IDS_PGM1816                     57734
#define IDS_PGM1832                     57735
#define IDS_PGM190                      57736
#define IDS_PGM198                      57737
#define IDS_PGM1916                     57738
#define IDS_PGM1A0                      57739
#define IDS_PGM1A8                      57740
#define IDS_PGM1B0                      57741
#define IDS_PGM1B8                      57742
#define IDS_PGM1C0                      57743
#define IDS_PGM1C8                      57744
#define IDS_PGM1C16                     57745
#define IDS_PGM1D0                      57746
#define IDS_PGM1E0                      57747
#define IDS_PGM1E8                      57748
#define IDS_PGM1F0                      57749
#define IDS_PGM1F8                      57750
#define IDS_PGM200                      57751
#define IDS_PGM210                      57752
#define IDS_PGM220                      57753
#define IDS_PGM230                      57754
#define IDS_PGM240                      57755
#define IDS_PGM250                      57756
#define IDS_PGM260                      57757
#define IDS_PGM261                      57758
#define IDS_PGM268                      57759
#define IDS_PGM270                      57760
#define IDS_PGM278                      57761
#define IDS_PGM2716                     57762
#define IDS_PGM280                      57763
#define IDS_PGM288                      57764
#define IDS_PGM290                      57765
#define IDS_PGM2A0                      57766
#define IDS_PGM2B0                      57767
#define IDS_PGM2C0                      57768
#define IDS_PGM2D0                      57769
#define IDS_PGM2E0                      57770
#define IDS_PGM2F0                      57771
#define IDS_PGM300                      57772
#define IDS_PGM308                      57773
#define IDS_PGM310                      57774
#define IDS_PGM320                      57775
#define IDS_PGM328                      57776
#define IDS_PGM330                      57777
#define IDS_PGM340                      57778
#define IDS_PGM3432                     57779
#define IDS_PGM350                      57780
#define IDS_PGM360                      57781
#define IDS_PGM370                      57782
#define IDS_PGM380                      57783
#define IDS_PGM390                      57784
#define IDS_PGM391                      57785
#define IDS_PGM3A0                      57786
#define IDS_PGM3B0                      57787
#define IDS_PGM3C0                      57788
#define IDS_PGM3C1                      57789
#define IDS_PGM3D0                      57790
#define IDS_PGM3D8                      57791
#define IDS_PGM3E0                      57792
#define IDS_PGM3E8                      57793
#define IDS_PGM3E16                     57794
#define IDS_PGM3F0                      57795
#define IDS_PGM3F8                      57796
#define IDS_PGM3F16                     57797
#define IDS_PGM400                      57798
#define IDS_PGM410                      57799
#define IDS_PGM418                      57800
#define IDS_BAND_VERSION_TEXT           57800
#define IDS_PGM420                      57801
#define IDS_PGM428                      57802
#define IDS_PGM430                      57803
#define IDS_PGM440                      57804
#define IDS_PGM450                      57805
#define IDS_PGM460                      57806
#define IDS_PGM470                      57807
#define IDS_PGM478                      57808
#define IDS_PGM480                      57809
#define IDS_PGM490                      57810
#define IDS_PGM4A0                      57811
#define IDS_PGM4B0                      57812
#define IDS_PGM4C0                      57813
#define IDS_PGM4D0                      57814
#define IDS_PGM4E0                      57815
#define IDS_PGM4F0                      57816
#define IDS_PGM500                      57817
#define IDS_PGM501                      57818
#define IDS_PGM508                      57819
#define IDS_PGM510                      57820
#define IDS_PGM511                      57821
#define IDS_PGM518                      57822
#define IDS_PGM520                      57823
#define IDS_PGM530                      57824
#define IDS_PGM540                      57825
#define IDS_PGM550                      57826
#define IDS_PGM560                      57827
#define IDS_PGM570                      57828
#define IDS_PGM580                      57829
#define IDS_PGM590                      57830
#define IDS_PGM5A0                      57831
#define IDS_PGM5B0                      57832
#define IDS_PGM5C0                      57833
#define IDS_PGM5D0                      57834
#define IDS_PGM5E0                      57835
#define IDS_PGM5F0                      57836
#define IDS_PGM600                      57837
#define IDS_PGM610                      57838
#define IDS_PGM620                      57839
#define IDS_PGM621                      57840
#define IDS_PGM630                      57841
#define IDS_PGM640                      57842
#define IDS_PGM650                      57843
#define IDS_PGM660                      57844
#define IDS_PGM661                      57845
#define IDS_PGM662                      57846
#define IDS_PGM670                      57847
#define IDS_PGM680                      57848
#define IDS_PGM681                      57849
#define IDS_PGM690                      57850
#define IDS_PGM6A0                      57851
#define IDS_PGM6B0                      57852
#define IDS_PGM6B8                      57853
#define IDS_PGM6C0                      57854
#define IDS_PGM6D0                      57855
#define IDS_PGM6E0                      57856
#define IDS_PGM6F0                      57857
#define IDS_PGM700                      57858
#define IDS_PGM710                      57859
#define IDS_PGM720                      57860
#define IDS_PGM730                      57861
#define IDS_PGM738                      57862
#define IDS_PGM740                      57863
#define IDS_PGM748                      57864
#define IDS_PGM750                      57865
#define IDS_PGM758                      57866
#define IDS_PGM760                      57867
#define IDS_PGM768                      57868
#define IDS_PGM769                      57869
#define IDS_PGM770                      57870
#define IDS_PGM780                      57871
#define IDS_PGM781                      57872
#define IDS_PGM782                      57873
#define IDS_PGM790                      57874
#define IDS_PGM791                      57875
#define IDS_PGM7A0                      57876
#define IDS_PGM7A1                      57877
#define IDS_PGM7A2                      57878
#define IDS_PGM7A3                      57879
#define IDS_PGM7A4                      57880
#define IDS_PGM7A5                      57881
#define IDS_PGM7B0                      57882
#define IDS_PGM7B1                      57883
#define IDS_PGM7B2                      57884
#define IDS_PGM7B3                      57885
#define IDS_PGM7C0                      57886
#define IDS_PGM7C1                      57887
#define IDS_PGM7C2                      57888
#define IDS_PGM7C3                      57889
#define IDS_PGM7C4                      57890
#define IDS_PGM7C5                      57891
#define IDS_PGM7D0                      57892
#define IDS_PGM7D1                      57893
#define IDS_PGM7D2                      57894
#define IDS_PGM7D3                      57895
#define IDS_PGM7D4                      57896
#define IDS_PGM7D5                      57897
#define IDS_PGM7D6                      57898
#define IDS_PGM7D7                      57899
#define IDS_PGM7D8                      57900
#define IDS_PGM7D9                      57901
#define IDS_PGM7E0                      57902
#define IDS_PGM7E1                      57903
#define IDS_PGM7E2                      57904
#define IDS_PGM7E3                      57905
#define IDS_PGM7E4                      57906
#define IDS_PGM7E5                      57907
#define IDS_PGM7F0                      57908
#define IDS_PGM7F1                      57909
#define IDS_PGM7F2                      57910
#define IDS_PGM7F3                      57911
#define IDS_DRM000                      57912
#define IDS_DRM080                      57913
#define IDS_DRM100                      57914
#define IDS_DRM180                      57915
#define IDS_DRM190                      57916
#define IDS_DRM200                      57917
#define IDS_DRM280                      57918
#define IDS_DRM300                      57919
#define IDS_DRM380                      57920

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        228
#define _APS_NEXT_COMMAND_VALUE         32838
#define _APS_NEXT_CONTROL_VALUE         284
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\TabBand.h ===
#if !defined(AFX_TABBAND_H__E6072F43_0C3B_11D2_89B3_00C04FD912C8__INCLUDED_)
#define AFX_TABBAND_H__E6072F43_0C3B_11D2_89B3_00C04FD912C8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabBand.h : header file
//

class CBandPropPageManager;

/////////////////////////////////////////////////////////////////////////////
// CTabBand dialog

class CTabBand : public CPropertyPage
{
// Construction
public:
	CTabBand( CBandPropPageManager* pBandPropPageManager );
	virtual ~CTabBand();
	void SetBand( CBand* pBand);

// Dialog Data
	//{{AFX_DATA(CTabBand)
	enum { IDD = IDD_TAB_BAND };
	CEdit	m_editName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabBand)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CBand*					m_pBand;
	CBandPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CTabBand)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusName();
	afx_msg void OnEditGuid();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABBAND_H__E6072F43_0C3B_11D2_89B3_00C04FD912C8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\ResourceMaps.h ===
const UINT aidGroupFirstInstr[] = {
	IDS_PGM000,  // Piano
	IDS_PGM080,  // Chrom. Perc.
	IDS_PGM100,  // Organ
	IDS_PGM180,  // Guitar
	IDS_PGM200,  // Bass
	IDS_PGM280,  // Orchestral
	IDS_PGM300,  // Ensemble
	IDS_PGM380,  // Brass
	IDS_PGM400,  // Reed
	IDS_PGM480,  // Pipe
	IDS_PGM500,  // Synth Lead
	IDS_PGM580,  // Synth Pad
	IDS_PGM600,  // Synth SFX
	IDS_PGM680,  // Ethnic Misc.
	IDS_PGM700,  // Percussive
	IDS_PGM780,  // SFX
	IDS_PGMEND
};

const UINT aidGroupName[] = {
	IDS_GRP1, IDS_GRP2, IDS_GRP3, IDS_GRP4, IDS_GRP5, IDS_GRP6, IDS_GRP7, IDS_GRP8,
	IDS_GRP9, IDS_GRP10, IDS_GRP11, IDS_GRP12, IDS_GRP13, IDS_GRP14, IDS_GRP15, IDS_GRP16
};

const UINT aidIntervals[] = {
	IDS_NO_TRANSPOSE, IDS_MINOR_SECOND, IDS_MAJOR_SECOND, IDS_MINOR_THIRD, IDS_MAJOR_THIRD,
	IDS_PERFECT_FOURTH, IDS_FLAT_FIFTH, IDS_PERFECT_FIFTH, IDS_MINOR_SIXTH, IDS_MAJOR_SIXTH,
	IDS_MINOR_SEVENTH, IDS_MAJOR_SEVENTH
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\TabBand.cpp ===
// TabBand.cpp : implementation file
//

#include "stdafx.h"
#include "BandEditorDLL.h"
#include "Band.h"
#include "TabBand.h"
#include <guiddlg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabBand property page

CTabBand::CTabBand( CBandPropPageManager* pBandPropPageManager ) : CPropertyPage(CTabBand::IDD)
{
	//{{AFX_DATA_INIT(CTabBand)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	
	ASSERT( pBandPropPageManager != NULL );

	m_pBand = NULL;
	m_pPageManager = pBandPropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabBand::~CTabBand()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabBand::SetBand

void CTabBand::SetBand( CBand* pBand )
{
	m_pBand = pBand;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBand::EnableControls

void CTabBand::EnableControls( BOOL fEnable ) 
{
	m_editName.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabBand::UpdateControls

void CTabBand::UpdateControls()
{
	// Make sure controls have been created
	if( ::IsWindow(m_editName.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editName.LimitText( DMUS_MAX_NAME );

	if( m_pBand )
	{
		EnableControls( TRUE );

		// Set name
		m_editName.SetWindowText( m_pBand->m_csName );
	}
	else
	{
		m_editName.SetWindowText( _T("") );
		
		EnableControls( FALSE );
	}
}

void CTabBand::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabBand)
	DDX_Control(pDX, IDC_NAME, m_editName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabBand, CPropertyPage)
	//{{AFX_MSG_MAP(CTabBand)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_NAME, OnKillFocusName)
	ON_BN_CLICKED(IDC_EDIT_GUID, OnEditGuid)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabBand message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabBand::OnSetActive

BOOL CTabBand::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBand::OnCreate

int CTabBand::OnCreate( LPCREATESTRUCT lpCreateStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabBand::OnDestroy

void CTabBand::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBand::OnKillFocusName

void CTabBand::OnKillFocusName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pIFramework != NULL );

	if( m_pBand )
	{
		CString strName;

		m_editName.GetWindowText( strName );

		// Strip leading and trailing spaces
		strName.TrimRight();
		strName.TrimLeft();

		if( strName.IsEmpty() )
		{
			m_editName.SetWindowText( m_pBand->m_csName );
		}
		else
		{
			if( strName.Compare( m_pBand->m_csName ) != 0 )
			{
				HRESULT hr = S_OK;
				BSTR bstrName;

				if( m_pBand->m_pIDocRootNode
				&&  m_pBand->m_pIDocRootNode != m_pBand )
				{
					bstrName = strName.AllocSysString();
					hr = m_pBand->ValidateNodeName( bstrName );
				}
				
				if( hr == S_OK )
				{
					bstrName = strName.AllocSysString();
					m_pBand->SetNodeName( bstrName );
					theApp.m_pIFramework->RefreshNode( m_pBand );
				}
				else
				{
					m_editName.SetWindowText( m_pBand->m_csName );
					m_editName.SetFocus();
				}
			}
		}
	}
}

void CTabBand::OnEditGuid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pBand )
	{
		CGuidDlg dlg;
		memcpy( &dlg.m_guid, &m_pBand->m_guidBand, sizeof(GUID) );
		if( dlg.DoModal() == IDOK )
		{
			//m_pBand->m_pUndoMgr->SaveState( m_pBand, theApp.m_hInstance, IDS_UNDO_BAND_GUID );
			memcpy( &m_pBand->m_guidBand, &dlg.m_guid, sizeof(GUID) );
			m_pBand->SetModifiedFlag( TRUE );

			// Notify connected nodes that Band GUID has changed
			theApp.m_pIFramework->NotifyNodes( m_pBand, DOCROOT_GuidChange, NULL );
		}
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\StdAfx.h ===
#if !defined(AFX_STDAFX_H__D824B38A_804F_11D0_89AC_00A0C9054129__INCLUDED_)
#define AFX_STDAFX_H__D824B38A_804F_11D0_89AC_00A0C9054129__INCLUDED_

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxcmn.h>
#include <htmlhelp.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D824B38A_804F_11D0_89AC_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\UndoMan.cpp ===
// CUndoNode implementation file

#include "stdafx.h"
#include "BandEditorDLL.h"
#include "UndoMan.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CUndoNode::CUndoNode()
{
	// initialize member variables
	m_pPrev = NULL;
	m_pNext = NULL;
	m_pIMemStream = NULL;
	m_nUndoLevel = DEFAULT_UNDO_LEVEL;
}
CUndoNode::~CUndoNode()
{
	// release the memory stream
	if( m_pIMemStream )  {
		m_pIMemStream->Release();
}	}

CUndoNode  *CUndoNode::SaveState( IPersistStream *pIPStream, char *pszText )
{
	CUndoNode  *pDel, *pPrev;
	short n;

	// delete all redo nodes from this point
	while( m_pNext )
	{
		pDel = m_pNext;
		m_pNext = m_pNext->m_pNext;
		delete pDel;
	}

	// scan the list backward until no more nodes or undo level is reached
	pPrev = m_pPrev;
	n = 0;
	while( pPrev  &&  n < m_nUndoLevel )
	{
		pPrev = pPrev->m_pPrev;
		n++;
	}
	// terminate the new head
	if( pPrev )  
	{
		if( pPrev->m_pNext )  
			pPrev->m_pNext->m_pPrev = NULL;
	}

	// delete oldest undo nodes past max level
	while( pPrev )
	{
		pDel = pPrev;
		pPrev = pPrev->m_pPrev;
		delete pDel;
	}

	// create a new node
	m_pNext = new CUndoNode;

	if( m_pNext )
	{
		// attach the new node to the list
		m_pNext->m_pPrev = this;
		m_pNext->m_pNext = NULL;

		// copy the text string
		lstrcpyn( m_pNext->m_szMenuText, pszText, sizeof(m_szMenuText) - 1 );

		// set the undo level to the same
		m_pNext->m_nUndoLevel = m_nUndoLevel;

		// create a memory stream
		if( SUCCEEDED ( theApp.m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &m_pNext->m_pIMemStream ) ) )
		{
			// write the current data to it, leave it dirty
			pIPStream->Save( m_pNext->m_pIMemStream, FALSE );
			return m_pNext;
		}
		delete m_pNext;
	}
	return this;
}

CUndoNode  *CUndoNode::Undo( IPersistStream *pIPStream )
{
	// check for valid undo
	if( m_pPrev == NULL )  
		return this;

	// save the current state if there is no redo
	if( m_pNext == NULL )
		SaveState( pIPStream, "!" );

	// rewind the memory stream and load it
	LARGE_INTEGER largeint;
	largeint.LowPart = 0;
	largeint.HighPart = 0;
	m_pIMemStream->Seek( largeint, STREAM_SEEK_SET, NULL );
	if( SUCCEEDED(pIPStream->Load( m_pIMemStream )) )
	{
		// return the previous node
		return m_pPrev;
	}
	return this;
}

CUndoNode  *CUndoNode::Redo( IPersistStream *pIPStream )
{
	// check for a valid redo node
	ASSERT(pIPStream);

	if( m_pNext == NULL )  
		return this;
	if( m_pNext->m_pNext == NULL )  
		return this;

	LARGE_INTEGER largeint;
	largeint.LowPart = 0;
	largeint.HighPart = 0;

	// must skip next, which is the action we just undid
	m_pNext->m_pNext->m_pIMemStream->Seek( largeint, STREAM_SEEK_SET, NULL );
	if( SUCCEEDED(pIPStream->Load( m_pNext->m_pNext->m_pIMemStream )) )
	{
		// return the next node
		return m_pNext;
	}
	return this;
}

BOOL  CUndoNode::GetUndo( char *pszText, int nMaxCount )
{
	// nothing to undo
	if( m_pPrev == NULL )
		return FALSE;

	// copy the undo text
	lstrcpyn( pszText, m_szMenuText, nMaxCount );
	return TRUE;
}

BOOL  CUndoNode::GetRedo( char *pszText, int nMaxCount )
{
	if( m_pNext )
	{
		// check the next of next for validity
		if( m_pNext->m_pNext )  
		{
			lstrcpyn( pszText, m_pNext->m_szMenuText, nMaxCount );
			return TRUE;
		}	
	}
	// nothing to redo
	return FALSE;
}

void  CUndoNode::Destroy()
{
	CUndoNode  *pDel;

	// delete all redo nodes from this
	while( m_pNext )
	{
		pDel = m_pNext;
		m_pNext = m_pNext->m_pNext;
		delete pDel;
	}

	// delete all undo nodes from this
	while( m_pPrev )
	{
		pDel = m_pPrev;
		m_pPrev = m_pPrev->m_pPrev;
		delete pDel;
	}
	delete this;
}

void  CUndoNode::SetUndoLevel( long nUndoLevel )
{
	CUndoNode  *pScan = m_pNext;

	// set level for all redo nodes from this
	while( pScan )  
	{
		pScan->m_nUndoLevel = nUndoLevel;
		pScan = pScan->m_pNext;
	}
	// set level for all undo nodes from this
	pScan = m_pPrev;
	while( pScan )  
	{
		pScan->m_nUndoLevel = nUndoLevel;
		pScan = pScan->m_pPrev;
	}
	m_nUndoLevel = nUndoLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\UndoMan.h ===
// Standard Jazz Undo Manager Class - header file

#define MENU_TEXT_SIZE  32
#define DEFAULT_UNDO_LEVEL  8

class CUndoNode
{
private:
	// The UndoMan class forms a double linked list that grows and shrinks
	// from both sides.  Only a pointer to the current node is necessary
	// for the app to maintain.  Prev of the current node are undo items.
	// Next of the current node are redo items.
	CUndoNode  *m_pNext;
	CUndoNode  *m_pPrev;

	// Each node maintains an memory stream with the actual state data and
	// a short text string identifying the operation that the data being
	// stored would undo.  This text is usually displayed in the edit menu
	// with the Undo and Redo items as a confirmation to the user.
	IStream  *m_pIMemStream;
	char  m_szMenuText[MENU_TEXT_SIZE];
	long  m_nUndoLevel;

public:
	CUndoNode();
	~CUndoNode();

	// These functions return a pointer to the new current node.  The current
	// node pointer must be assigned the return value for the class to work
	// properly.
	CUndoNode  *SaveState( IPersistStream *pIPStream, char *psz );
	CUndoNode  *Undo( IPersistStream *pIPStream );
	CUndoNode  *Redo( IPersistStream *pIPStream );

	// GetUndo and GetRedo return FALSE if the operation is not possible, and
	// in this case, nothing is copied into pszText.
	BOOL  GetUndo( char *pszText, int nMaxCount );
	BOOL  GetRedo( char *pszText, int nMaxCount );

	// Destroy is a convenience function to delete all undo and redo nodes.
	void  Destroy();
	void  SetUndoLevel( long nUndoLevel );
};

// CUndoMan is a wrapper class to hide the current node pointer.
class CUndoMan
{
private:
	CUndoNode  *m_pCurrentNode;

public:
	CUndoMan()  {
		m_pCurrentNode = new CUndoNode;
	}
	~CUndoMan()  {
		m_pCurrentNode->Destroy();
	}
	inline void SaveState( IPersistStream *pIPStream, char *psz )  {
		m_pCurrentNode = m_pCurrentNode->SaveState( pIPStream, psz );
	}
	inline void Undo( IPersistStream *pIPStream )  {
		m_pCurrentNode = m_pCurrentNode->Undo( pIPStream );
	}
	inline void Redo( IPersistStream *pIPStream )  {
		m_pCurrentNode = m_pCurrentNode->Redo( pIPStream );
	}
	inline BOOL  GetUndo( char *pszText, int nMaxCount )  {
		return m_pCurrentNode->GetUndo( pszText, nMaxCount );
	}
	inline BOOL  GetRedo( char *pszText, int nMaxCount )  {
		return m_pCurrentNode->GetRedo( pszText, nMaxCount );
	}
	inline void  SetUndoLevel( long nUndoLevel )  {
		m_pCurrentNode->SetUndoLevel( nUndoLevel );
}	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandEditor\resource.cpp ===
// database of GM/GS instrument patches
//
// typedef struct _BEINSTR  {
//     UINT      nStringId;
//     BYTE      bPatch;
//     BYTE      bMSB;
//     BYTE      bLSB;
//     CString  *pstrName;
// } BEINSTR;

BInstr abiGS[] = {
	IDS_PGM000,  0x00,  0, 0, NULL,  // Piano
	IDS_PGM008,  0x00,  8, 0, NULL,
	IDS_PGM0016, 0x00, 16, 0, NULL,
	IDS_PGM010,  0x01,  0, 0, NULL,
	IDS_PGM018,  0x01,  8, 0, NULL,
	IDS_PGM020,  0x02,  0, 0, NULL,
	IDS_PGM028,  0x02,  8, 0, NULL,
	IDS_PGM030,  0x03,  0, 0, NULL,
	IDS_PGM038,  0x03,  8, 0, NULL,
	IDS_PGM040,  0x04,  0, 0, NULL,
	IDS_PGM048,  0x04,  8, 0, NULL,
	IDS_PGM0416, 0x04, 16, 0, NULL,
	IDS_PGM0424, 0x04, 24, 0, NULL,
	IDS_PGM050,  0x05,  0, 0, NULL,
	IDS_PGM058,  0x05,  8, 0, NULL,
	IDS_PGM0516, 0x05, 16, 0, NULL,
	IDS_PGM060,  0x06,  0, 0, NULL,
	IDS_PGM068,  0x06,  8, 0, NULL,
	IDS_PGM0616, 0x06, 16, 0, NULL,
	IDS_PGM0624, 0x06, 24, 0, NULL,
	IDS_PGM070,  0x07,  0, 0, NULL,

	IDS_PGM080,  0x08,  0, 0, NULL,  // Chrom. Perc.
	IDS_PGM090,  0x09,  0, 0, NULL,
	IDS_PGM0A0,  0x0A,  0, 0, NULL,
	IDS_PGM0B0,  0x0B,  0, 0, NULL,
	IDS_PGM0B8,  0x0B,  8, 0, NULL,
	IDS_PGM0C0,  0x0C,  0, 0, NULL,
	IDS_PGM0C8,  0x0C,  8, 0, NULL,
	IDS_PGM0D0,  0x0D,  0, 0, NULL,
	IDS_PGM0E0,  0x0E,  0, 0, NULL,
	IDS_PGM0E8,  0x0E,  8, 0, NULL,
	IDS_PGM0E9,  0x0E,  9, 0, NULL,
	IDS_PGM0F0,  0x0F,  0, 0, NULL,

	IDS_PGM100,  0x10,  0, 0, NULL,  // Organ
	IDS_PGM108,  0x10,  8, 0, NULL,
	IDS_PGM1016, 0x10, 16, 0, NULL,
	IDS_PGM1032, 0x10, 32, 0, NULL,
	IDS_PGM110,  0x11,  0, 0, NULL,
	IDS_PGM118,  0x11,  8, 0, NULL,
	IDS_PGM1132, 0x11, 32, 0, NULL,
	IDS_PGM120,  0x12,  0, 0, NULL,
	IDS_PGM130,  0x13,  0, 0, NULL,
	IDS_PGM138,  0x13,  8, 0, NULL,
	IDS_PGM1316, 0x13, 16, 0, NULL,
	IDS_PGM140,  0x14,  0, 0, NULL,
	IDS_PGM150,  0x15,  0, 0, NULL,
	IDS_PGM158,  0x15,  8, 0, NULL,
	IDS_PGM160,  0x16,  0, 0, NULL,
	IDS_PGM170,  0x17,  0, 0, NULL,

	IDS_PGM180,  0x18,  0, 0, NULL,  // Guitar
	IDS_PGM188,  0x18,  8, 0, NULL,
	IDS_PGM1816, 0x18, 16, 0, NULL,
	IDS_PGM1832, 0x18, 32, 0, NULL,
	IDS_PGM190,  0x19,  0, 0, NULL,
	IDS_PGM198,  0x19,  8, 0, NULL,
	IDS_PGM1916, 0x19, 16, 0, NULL,
	IDS_PGM1A0,  0x1A,  0, 0, NULL,
	IDS_PGM1A8,  0x1A,  8, 0, NULL,
	IDS_PGM1B0,  0x1B,  0, 0, NULL,
	IDS_PGM1B8,  0x1B,  8, 0, NULL,
	IDS_PGM1C0,  0x1C,  0, 0, NULL,
	IDS_PGM1C8,  0x1C,  8, 0, NULL,
	IDS_PGM1C16, 0x1C, 16, 0, NULL,
	IDS_PGM1D0,  0x1D,  0, 0, NULL,
	IDS_PGM1E0,  0x1E,  0, 0, NULL,
	IDS_PGM1E8,  0x1E,  8, 0, NULL,
	IDS_PGM1F0,  0x1F,  0, 0, NULL,
	IDS_PGM1F8,  0x1F,  8, 0, NULL,

	IDS_PGM200,  0x20,  0, 0, NULL,  // Bass
	IDS_PGM210,  0x21,  0, 0, NULL,
	IDS_PGM220,  0x22,  0, 0, NULL,
	IDS_PGM230,  0x23,  0, 0, NULL,
	IDS_PGM240,  0x24,  0, 0, NULL,
	IDS_PGM250,  0x25,  0, 0, NULL,
	IDS_PGM260,  0x26,  0, 0, NULL,
	IDS_PGM261,  0x26,  1, 0, NULL,
	IDS_PGM268,  0x26,  8, 0, NULL,
	IDS_PGM270,  0x27,  0, 0, NULL,
	IDS_PGM278,  0x27,  8, 0, NULL,
	IDS_PGM2716, 0x27, 16, 0, NULL,

	IDS_PGM280,  0x28,  0, 0, NULL,  // Orchestral
	IDS_PGM288,  0x28,  8, 0, NULL,
	IDS_PGM290,  0x29,  0, 0, NULL,
	IDS_PGM2A0,  0x2A,  0, 0, NULL,
	IDS_PGM2B0,  0x2B,  0, 0, NULL,
	IDS_PGM2C0,  0x2C,  0, 0, NULL,
	IDS_PGM2D0,  0x2D,  0, 0, NULL,
	IDS_PGM2E0,  0x2E,  0, 0, NULL,
	IDS_PGM2F0,  0x2F,  0, 0, NULL,

	IDS_PGM300,  0x30,  0, 0, NULL,  // Ensemble
	IDS_PGM308,  0x30,  8, 0, NULL,
	IDS_PGM310,  0x31,  0, 0, NULL,
	IDS_PGM320,  0x32,  0, 0, NULL,
	IDS_PGM328,  0x32,  8, 0, NULL,
	IDS_PGM330,  0x33,  0, 0, NULL,
	IDS_PGM340,  0x34,  0, 0, NULL,
	IDS_PGM3432, 0x34, 32, 0, NULL,
	IDS_PGM350,  0x35,  0, 0, NULL,
	IDS_PGM360,  0x36,  0, 0, NULL,
	IDS_PGM370,  0x37,  0, 0, NULL,

	IDS_PGM380,  0x38,  0, 0, NULL,  // Brass
	IDS_PGM390,  0x39,  0, 0, NULL,
	IDS_PGM391,  0x39,  1, 0, NULL,
	IDS_PGM3A0,  0x3A,  0, 0, NULL,
	IDS_PGM3B0,  0x3B,  0, 0, NULL,
	IDS_PGM3C0,  0x3C,  0, 0, NULL,
	IDS_PGM3C1,  0x3C,  1, 0, NULL,
	IDS_PGM3D0,  0x3D,  0, 0, NULL,
	IDS_PGM3D8,  0x3D,  8, 0, NULL,
	IDS_PGM3E0,  0x3E,  0, 0, NULL,
	IDS_PGM3E8,  0x3E,  8, 0, NULL,
	IDS_PGM3E16, 0x3E, 16, 0, NULL,
	IDS_PGM3F0,  0x3F,  0, 0, NULL,
	IDS_PGM3F8,  0x3F,  8, 0, NULL,
	IDS_PGM3F16, 0x3F, 16, 0, NULL,

	IDS_PGM400,  0x40,  0, 0, NULL,  // Reed
	IDS_PGM410,  0x41,  0, 0, NULL,
	IDS_PGM420,  0x42,  0, 0, NULL,
	IDS_PGM430,  0x43,  0, 0, NULL,
	IDS_PGM440,  0x44,  0, 0, NULL,
	IDS_PGM450,  0x45,  0, 0, NULL,
	IDS_PGM460,  0x46,  0, 0, NULL,
	IDS_PGM470,  0x47,  0, 0, NULL,

	IDS_PGM480,  0x48,  0, 0, NULL,  // Pipe
	IDS_PGM490,  0x49,  0, 0, NULL,
	IDS_PGM4A0,  0x4A,  0, 0, NULL,
	IDS_PGM4B0,  0x4B,  0, 0, NULL,
	IDS_PGM4C0,  0x4C,  0, 0, NULL,
	IDS_PGM4D0,  0x4D,  0, 0, NULL,
	IDS_PGM4E0,  0x4E,  0, 0, NULL,
	IDS_PGM4F0,  0x4F,  0, 0, NULL,

	IDS_PGM500,  0x50,  0, 0, NULL,  // Synth Lead
	IDS_PGM501,  0x50,  1, 0, NULL,
	IDS_PGM508,  0x50,  8, 0, NULL,
	IDS_PGM510,  0x51,  0, 0, NULL,
	IDS_PGM511,  0x51,  1, 0, NULL,
	IDS_PGM518,  0x51,  8, 0, NULL,
	IDS_PGM520,  0x52,  0, 0, NULL,
	IDS_PGM530,  0x53,  0, 0, NULL,
	IDS_PGM540,  0x54,  0, 0, NULL,
	IDS_PGM550,  0x55,  0, 0, NULL,
	IDS_PGM560,  0x56,  0, 0, NULL,
	IDS_PGM570,  0x57,  0, 0, NULL,

	IDS_PGM580,  0x58,  0, 0, NULL,  // Synth Pad
	IDS_PGM590,  0x59,  0, 0, NULL,
	IDS_PGM5A0,  0x5A,  0, 0, NULL,
	IDS_PGM5B0,  0x5B,  0, 0, NULL,
	IDS_PGM5C0,  0x5C,  0, 0, NULL,
	IDS_PGM5D0,  0x5D,  0, 0, NULL,
	IDS_PGM5E0,  0x5E,  0, 0, NULL,
	IDS_PGM5F0,  0x5F,  0, 0, NULL,

	IDS_PGM600,  0x60,  0, 0, NULL,  // Synth SFX
	IDS_PGM610,  0x61,  0, 0, NULL,
	IDS_PGM620,  0x62,  0, 0, NULL,
	IDS_PGM621,  0x62,  1, 0, NULL,
	IDS_PGM630,  0x63,  0, 0, NULL,
	IDS_PGM640,  0x64,  0, 0, NULL,
	IDS_PGM650,  0x65,  0, 0, NULL,
	IDS_PGM660,  0x66,  0, 0, NULL,
	IDS_PGM661,  0x66,  1, 0, NULL,
	IDS_PGM662,  0x66,  2, 0, NULL,
	IDS_PGM670,  0x67,  0, 0, NULL,

	IDS_PGM680,  0x68,  0, 0, NULL,  // Ethnic Misc.
	IDS_PGM681,  0x68,  1, 0, NULL,
	IDS_PGM690,  0x69,  0, 0, NULL,
	IDS_PGM6A0,  0x6A,  0, 0, NULL,
	IDS_PGM6B0,  0x6B,  0, 0, NULL,
	IDS_PGM6B8,  0x6B,  8, 0, NULL,
	IDS_PGM6C0,  0x6C,  0, 0, NULL,
	IDS_PGM6D0,  0x6D,  0, 0, NULL,
	IDS_PGM6E0,  0x6E,  0, 0, NULL,
	IDS_PGM6F0,  0x6F,  0, 0, NULL,

	IDS_PGM700,  0x70,  0, 0, NULL,  // Percussive
	IDS_PGM710,  0x71,  0, 0, NULL,
	IDS_PGM720,  0x72,  0, 0, NULL,
	IDS_PGM730,  0x73,  0, 0, NULL,
	IDS_PGM738,  0x73,  8, 0, NULL,
	IDS_PGM740,  0x74,  0, 0, NULL,
	IDS_PGM748,  0x74,  8, 0, NULL,
	IDS_PGM750,  0x75,  0, 0, NULL,
	IDS_PGM758,  0x75,  8, 0, NULL,
	IDS_PGM760,  0x76,  0, 0, NULL,
	IDS_PGM768,  0x76,  8, 0, NULL,
	IDS_PGM769,  0x76,  9, 0, NULL,
	IDS_PGM770,  0x77,  0, 0, NULL,

	IDS_PGM780,  0x78,  0, 0, NULL,  // SFX
	IDS_PGM781,  0x78,  1, 0, NULL,
	IDS_PGM782,  0x78,  2, 0, NULL,
	IDS_PGM790,  0x79,  0, 0, NULL,
	IDS_PGM791,  0x79,  1, 0, NULL,
	IDS_PGM7A0,  0x7A,  0, 0, NULL,
	IDS_PGM7A1,  0x7A,  1, 0, NULL,
	IDS_PGM7A2,  0x7A,  2, 0, NULL,
	IDS_PGM7A3,  0x7A,  3, 0, NULL,
	IDS_PGM7A4,  0x7A,  4, 0, NULL,
	IDS_PGM7A5,  0x7A,  5, 0, NULL,
	IDS_PGM7B0,  0x7B,  0, 0, NULL,
	IDS_PGM7B1,  0x7B,  1, 0, NULL,
	IDS_PGM7B2,  0x7B,  2, 0, NULL,
	IDS_PGM7B3,  0x7B,  3, 0, NULL,
	IDS_PGM7C0,  0x7C,  0, 0, NULL,
	IDS_PGM7C1,  0x7C,  1, 0, NULL,
	IDS_PGM7C2,  0x7C,  2, 0, NULL,
	IDS_PGM7C3,  0x7C,  3, 0, NULL,
	IDS_PGM7C4,  0x7C,  4, 0, NULL,
	IDS_PGM7C5,  0x7C,  5, 0, NULL,
	IDS_PGM7D0,  0x7D,  0, 0, NULL,
	IDS_PGM7D1,  0x7D,  1, 0, NULL,
	IDS_PGM7D2,  0x7D,  2, 0, NULL,
	IDS_PGM7D3,  0x7D,  3, 0, NULL,
	IDS_PGM7D4,  0x7D,  4, 0, NULL,
	IDS_PGM7D5,  0x7D,  5, 0, NULL,
	IDS_PGM7D6,  0x7D,  6, 0, NULL,
	IDS_PGM7D7,  0x7D,  7, 0, NULL,
	IDS_PGM7D8,  0x7D,  8, 0, NULL,
	IDS_PGM7D9,  0x7D,  9, 0, NULL,
	IDS_PGM7E0,  0x7E,  0, 0, NULL,
	IDS_PGM7E1,  0x7E,  1, 0, NULL,
	IDS_PGM7E2,  0x7E,  2, 0, NULL,
	IDS_PGM7E3,  0x7E,  3, 0, NULL,
	IDS_PGM7E4,  0x7E,  4, 0, NULL,
	IDS_PGM7E5,  0x7E,  5, 0, NULL,
	IDS_PGM7F0,  0x7F,  0, 0, NULL,
	IDS_PGM7F1,  0x7F,  1, 0, NULL,
	IDS_PGM7F2,  0x7F,  2, 0, NULL,
	IDS_PGM7F3,  0x7F,  3, 0, NULL,

	IDS_PGMEND,     0,  0, 0, NULL   // end of instrument list
};

BInstr abiDrums[] = {
	IDS_DRM000,  0x00,  0, 0, NULL,
	IDS_DRM080,  0x08,  0, 0, NULL,
	IDS_DRM100,  0x10,  0, 0, NULL,
	IDS_DRM180,  0x18,  0, 0, NULL,
	IDS_DRM190,  0x19,  0, 0, NULL,
	IDS_DRM200,  0x20,  0, 0, NULL,
	IDS_DRM280,  0x28,  0, 0, NULL,
	IDS_DRM300,  0x30,  0, 0, NULL,
	IDS_DRM380,  0x38,  0, 0, NULL,

	IDS_PGMEND,     0,  0, 0, NULL   // end of drums list
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandStripMgr\BandIO.h ===
#ifndef __BANDIO_H_
#define __BANDIO_H_

#include "PropBand.h"
#include <dmusici.h>

// Flags for SetTimePhysical()
#define STP_LOGICAL_NO_ACTION				1
#define STP_LOGICAL_SET_DEFAULT				2
#define STP_LOGICAL_ADJUST					3
#define STP_LOGICAL_RECALC_MEASURE_BEAT		4
#define STP_LOGICAL_FROM_BEAT_OFFSET		5

class CBandStrip;

class CBandItem : public CPropBand
{
public:
	CBandItem(CBandStrip* pBandStrip);
	~CBandItem();

	BOOL	After(const CBandItem& Band);
	BOOL	Before(const CBandItem& Band);
	void	SetSelectFlag( BOOL fSelected );
	HRESULT	SetTimePhysical( MUSIC_TIME mtTimePhysical, short nAction );
	HRESULT	SetTimeLogical( MUSIC_TIME mtTimeLogical );

//	Used to track the selection of the band in display.
	BOOL			m_fSelected;		// This band is currently selected.
	CBandStrip*		m_pBandStrip;
};

#endif // __BANDIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandStripMgr\BandMgr.cpp ===
// BandMgr.cpp : implementation file
//

/*--------------
@doc BANDSAMPLE
--------------*/

#include "stdafx.h"
#include "BandIO.h"
#include "BandMgr.h"
#include "DLLJazzDataObject.h"
#include "PropPageMgr.h"
#include <dmusici.h>
#include <dmusicf.h>
#include <mmreg.h>
#include <RiffStrm.h>
#include <DMUSProd.h>
#include <DMPPrivate.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CBandMgr constructor/destructor 

CBandMgr::CBandMgr()
{
	// Initialize all our pointers to NULL
	m_pTimeline = NULL;
	m_pDMProdFramework = NULL;
	m_pDMProdSegmentNode = NULL;
	m_pIPerformance = NULL;
	m_pPropPageMgr = NULL;
	m_pCopyDataObject = NULL;
	m_pBandStrip = NULL;
	m_pIDMTrack = NULL;
	m_pSegmentState = NULL;
	m_pBandItemForEditBandButton = NULL;
	m_dwPChannelForEditBandButton = 0;
	m_fNoUpdateSegment = false;

	// Initially we don't need to be saved
	m_fDirty = FALSE;

	// Initialize autodownload to FALSE
	m_bAutoDownload = FALSE;

	// By default, belong to Group 1 only
	m_dwGroupBits = 1;
	m_dwOldGroupBits = 1;

	// Initialize the track flags
	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;
	m_dwProducerOnlyFlags = 0;

	// Create a BandStrip
	m_pBandStrip = new CBandStrip(this);
	ASSERT( m_pBandStrip );
}

CBandMgr::~CBandMgr()
{
	// Clean up our references
	RELEASE(m_pSegmentState);
	RELEASE(m_pDMProdFramework);
	RELEASE(m_pIPerformance);

	// No Release!
	/*
	if( m_pDMProdSegmentNode )
	{
		m_pDMProdSegmentNode->Release();
		m_pDMProdSegmentNode = NULL;
	}
	*/

	ASSERT( m_pTimeline == NULL );

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
		m_pPropPageMgr = NULL;
	}
	if( m_pIDMTrack )
	{
		m_pIDMTrack->Release();
		m_pIDMTrack = NULL;
	}
	if( m_pBandStrip )
	{
		m_pBandStrip->Release();
		m_pBandStrip = NULL;
	}

	// If we have an object on the clipboard, make sure it doesn't have any references
	// back to us.
	if( m_pCopyDataObject )
	{
		if( S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}

	// Delete all the bands in m_lstBands
	EmptyBandList();
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr IBandMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CBandMgr::IsMeasureBeatOpen

HRESULT STDMETHODCALLTYPE CBandMgr::IsMeasureBeatOpen( DWORD dwMeasure, BYTE bBeat )
{
	HRESULT hr = S_FALSE;
	CBandItem* pBandItem;
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		pBandItem = m_lstBands.GetNext( pos );
		ASSERT( pBandItem );
		if( pBandItem->m_dwMeasure > dwMeasure )
		{
			pos = NULL;
		}
		else if( pBandItem->m_dwMeasure == dwMeasure &&
				 pBandItem->m_bBeat == bBeat )
		{
			hr = S_OK;
			pos = NULL;
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr IDMUSProdStripMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CBandMgr::ClocksToMeasureBeatTick

HRESULT CBandMgr::ClocksToMeasureBeatTick( MUSIC_TIME mtTime, long* plMeasure, long* plBeat, long* plTick )
{
	ASSERT( plMeasure != NULL );
	ASSERT( plBeat != NULL );
	ASSERT( plTick != NULL );
	
	long lMeasure = -1;
	long lBeat = -1;
	long lTick = -1;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		if( mtTime < 0 )
		{
			lMeasure = 0;
			lBeat = 0;
			lTick = mtTime;
		}
		else
		{
			hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
			if( SUCCEEDED ( hr ) )
			{
				long lClocks;

				hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
				if( SUCCEEDED ( hr ) )
				{
					lTick = mtTime - lClocks;

					// Try and preserve negative tick offsets
					if( lTick > 0 )
					{
						long lNewClocks;
						long lClocksPerBeat;

						hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat+1, &lNewClocks );
						if( SUCCEEDED ( hr ) )
						{
							lClocksPerBeat = lNewClocks - lClocks;

							if( lTick >= (lClocksPerBeat >> 1) )
							{
								// Get max clock
								VARIANT var;
								m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
								MUSIC_TIME mtMaxTimelineLength = V_I4( &var );

								if( lNewClocks < mtMaxTimelineLength )
								{
									lTick -= lClocksPerBeat;

									hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lNewClocks, &lMeasure, &lBeat );
								}
							}
						}
					}
				}
			}
		}
	}

	*plMeasure = lMeasure;
	*plBeat = lBeat;
	*plTick	= lTick;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// CBandMgr::MeasureBeatTickToClocks

HRESULT CBandMgr::MeasureBeatTickToClocks( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmtTime )
{
	ASSERT( pmtTime != NULL );

	MUSIC_TIME mtTime = -1;
	long lClocks;

	HRESULT hr = S_OK;

	if( m_pTimeline == NULL )
	{
		hr = S_FALSE;
	}
	else
	{
		hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
		if( SUCCEEDED ( hr ) )
		{
			mtTime = lClocks + lTick;
		}
	}

	*pmtTime = mtTime;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetFirstValidBand

POSITION GetFirstValidBand( POSITION pos, const CTypedPtrList<CPtrList, CBandItem*> &lstBands )
{
	CBandItem* pBandItem;
	POSITION posToReturn;

	while( pos )
	{
		posToReturn = pos;
		pBandItem = lstBands.GetNext( pos );

		if( pBandItem->m_pIBandNode )
		{
			return posToReturn;
		}
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// GetBandForPChannelAndTime

bool GetBandForPChannelAndTime( const CTypedPtrList<CPtrList, CBandItem*> &lstBands, DWORD dwPChannel, MUSIC_TIME mtTime, CBandItem **ppBandItem, CBandItem **ppBandItemNext )
{
	if( ppBandItem )
	{
		*ppBandItem = NULL;
	}

	if( ppBandItemNext )
	{
		*ppBandItemNext = NULL;
	}

	// Search through Band list for first "real" Band
	POSITION pos = lstBands.GetHeadPosition();
	pos = GetFirstValidBand( pos, lstBands );

	// Now, find the first "real" band that plays on the given PChannel
	IDMUSProdBandEdit8 *pIDMUSProdBandEdit8;
	bool fFoundPatch = false;
	DWORD dwTempPatch;
	while( pos )
	{
		// Get a pointer to each band item
		CBandItem* pBandItem = lstBands.GetNext( pos );

		// Check if the item exists, and is before or at mtTime
		if( pBandItem->m_pIBandNode
		&&	pBandItem->m_mtTimePhysical <= mtTime
		&&	SUCCEEDED( pBandItem->m_pIBandNode->QueryInterface( IID_IDMUSProdBandEdit8, (void **)&pIDMUSProdBandEdit8 ) ) )
		{
			// Check if the PChannel we're looking for exists
			if( SUCCEEDED( pIDMUSProdBandEdit8->GetPatchForPChannel( dwPChannel, &dwTempPatch ) ) )
			{
				fFoundPatch = true;
				if( ppBandItem )
				{
					*ppBandItem = pBandItem;
				}
			}
			pIDMUSProdBandEdit8->Release();
		}

		// Check if this item is after mtTime, and either we've not found an item, or ppBandItemNext is NULL
		if( mtTime < pBandItem->m_mtTimePhysical
		&&	(!fFoundPatch || !ppBandItemNext) )
		{
			// Break out of the loop
			break;
		}


		// Set next
		// TODO: JD - I'm not sure this check is necessary (i.e., can we assume that if
		// mtTime < pBandItem->m_mtTimePhysical, then ppBandItemNext is valid?)
		if( ppBandItemNext )
		{
			// Check for an item after mtTime
			if( pBandItem->m_pIBandNode
			&&	mtTime < pBandItem->m_mtTimePhysical
			&&	pBandItem->m_mtTimePhysical < mtTime
			&&	SUCCEEDED( pBandItem->m_pIBandNode->QueryInterface( IID_IDMUSProdBandEdit8, (void **)&pIDMUSProdBandEdit8 ) ) )
			{
				// Check if the PChannel we're looking for exists
				if( SUCCEEDED( pIDMUSProdBandEdit8->GetPatchForPChannel( dwPChannel, &dwTempPatch ) ) )
				{
					*ppBandItemNext = pBandItem;
					pIDMUSProdBandEdit8->Release();
					break;
				}
				pIDMUSProdBandEdit8->Release();
			}
		}

		// Get the next "real" Band
		pos = GetFirstValidBand( pos, lstBands );
	}

	return fFoundPatch;
}

/////////////////////////////////////////////////////////////////////////////
// CBandMgr::GetParam

HRESULT STDMETHODCALLTYPE CBandMgr::GetParam(
		/* [in] */	REFGUID 	guidType,
		/* [in] */	MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME* pmtNext,
		/* [out] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pData != NULL );
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		BSTR bstr;
		CString str;
		str.LoadString(m_pBandStrip->m_nLastEdit);
		try
		{
			bstr = str.AllocSysString();
		}
		catch(CMemoryException*)
		{
			return E_OUTOFMEMORY;
		}
		*(BSTR*)pData = bstr;
		return S_OK;
	}

	else if( ::IsEqualGUID( guidType, GUID_BandNode ) )
	{
		*(IDMUSProdNode**) pData = NULL;

		// Initialize pmtNext
		if( pmtNext )
		{
			*pmtNext = 0;
		}

		// Search through Band list for first "real" Band
		POSITION pos = m_lstBands.GetHeadPosition();
		pos = GetFirstValidBand( pos, m_lstBands );
		if( pos == NULL )
		{
			// No valid Bands in this track.
			return DMUS_E_NOT_FOUND;
		}

		// Initialize Previous Band Item
		CBandItem* pPrevious = m_lstBands.GetAt( pos );

		// Search through Band list for "real" Bands
		CBandItem* pBandItem = NULL;
		while( pos )
		{
			pBandItem = m_lstBands.GetNext( pos );
			ASSERT( pBandItem->m_pIBandNode );

			if( mtTime < pBandItem->m_mtTimePhysical )
			{
				// Set next	
				if( pmtNext )
				{
					*pmtNext = pBandItem->m_mtTimePhysical - mtTime;
				}
				break;
			}

			pPrevious = pBandItem;

			// Get the next "real" Band
			pos = GetFirstValidBand( pos, m_lstBands );
		}

		// We should have found a valid Band
		ASSERT( pPrevious );
		pPrevious->m_pIBandNode->AddRef();

		*(IDMUSProdNode**) pData = pPrevious->m_pIBandNode;
		return S_OK;
	}

	else if( ::IsEqualGUID( guidType, GUID_BandInterfaceForPChannel )
		 ||  ::IsEqualGUID( guidType, GUID_BandStrip_InstrumentItem )
		 ||  ::IsEqualGUID( guidType, GUID_BandMgrEditForPChannel ) )
	{
		DWORD dwPChannel = 0;
		if( ::IsEqualGUID( guidType, GUID_BandInterfaceForPChannel )
		||	::IsEqualGUID( guidType, GUID_BandMgrEditForPChannel ) )
		{
			DMUSPROD_INTERFACEFORPCHANNEL *pDMUSPROD_INTERFACEFORPCHANNEL = (DMUSPROD_INTERFACEFORPCHANNEL *)pData;
			dwPChannel = pDMUSPROD_INTERFACEFORPCHANNEL->dwPChannel;
			pDMUSPROD_INTERFACEFORPCHANNEL->punkInterface = NULL;
		}
		else
		{
			BandStrip_InstrumentItem *pBandStrip_InstrumentItem = (BandStrip_InstrumentItem *)pData;
			dwPChannel = pBandStrip_InstrumentItem->dwPChannel;
		}

		// Initialize pmtNext
		if( pmtNext )
		{
			*pmtNext = 0;
		}

		// Search through Band list for first "real" Band
		POSITION pos = m_lstBands.GetHeadPosition();
		pos = GetFirstValidBand( pos, m_lstBands );

		// Now, find the first "real" band that plays on the given PChannel
		IDMUSProdBandEdit8 *pIDMUSProdBandEdit8 = NULL;
		bool fFoundPatch = false;
		DWORD dwTempPatch;
		while( pos )
		{
			// Get a pointer to each band item
			CBandItem* pBandItem = m_lstBands.GetNext( pos );

			// Check if the item exists, and is before or at mtTime
			if( pBandItem->m_pIBandNode
			&&	pBandItem->m_mtTimePhysical <= mtTime
			&&	SUCCEEDED( pBandItem->m_pIBandNode->QueryInterface( IID_IDMUSProdBandEdit8, (void **)&pIDMUSProdBandEdit8 ) ) )
			{
				// Check if the PChannel we're looking for exists
				if( SUCCEEDED( pIDMUSProdBandEdit8->GetPatchForPChannel( dwPChannel, &dwTempPatch ) ) )
				{
					fFoundPatch = true;
					if( ::IsEqualGUID( guidType, GUID_BandInterfaceForPChannel ) )
					{
						DMUSPROD_INTERFACEFORPCHANNEL *pDMUSPROD_INTERFACEFORPCHANNEL = (DMUSPROD_INTERFACEFORPCHANNEL *)pData;
						pDMUSPROD_INTERFACEFORPCHANNEL->punkInterface = pBandItem->m_pIBandNode;
						pDMUSPROD_INTERFACEFORPCHANNEL->punkInterface->AddRef();
					}
					else if( ::IsEqualGUID( guidType, GUID_BandMgrEditForPChannel ) )
					{
						DMUSPROD_INTERFACEFORPCHANNEL *pDMUSPROD_INTERFACEFORPCHANNEL = (DMUSPROD_INTERFACEFORPCHANNEL *)pData;
						pDMUSPROD_INTERFACEFORPCHANNEL->punkInterface = static_cast<IDMUSProdBandMgrEdit *>(this);
						pDMUSPROD_INTERFACEFORPCHANNEL->punkInterface->AddRef();
					}
					else
					{
						BandStrip_InstrumentItem *pBandStrip_InstrumentItem = (BandStrip_InstrumentItem *)pData;
						pBandStrip_InstrumentItem->dwPatch = dwTempPatch;
						pBandStrip_InstrumentItem->lPhysicalTime = pBandItem->m_mtTimePhysical;
					}
				}
				pIDMUSProdBandEdit8->Release();
			}

			// Check if this item is after mtTime, and either we've not found an item, or pmtNext is NULL
			if( mtTime < pBandItem->m_mtTimePhysical
			&&	(!fFoundPatch || !pmtNext) )
			{
				// Break out of the loop
				break;
			}


			// Set next
			// TODO: JD - I'm not sure this check is necessary (i.e., can we assume that if
			// mtTime < pBandItem->m_mtTimePhysical, then pmtNext is valid?)
			if( pmtNext )
			{
				// Check for an item after mtTime
				if( pBandItem->m_pIBandNode
				&&	mtTime < pBandItem->m_mtTimePhysical
				&&	pBandItem->m_mtTimePhysical < mtTime
				&&	SUCCEEDED( pBandItem->m_pIBandNode->QueryInterface( IID_IDMUSProdBandEdit8, (void **)&pIDMUSProdBandEdit8 ) ) )
				{
					// Check if the PChannel we're looking for exists
					if( SUCCEEDED( pIDMUSProdBandEdit8->GetPatchForPChannel( dwPChannel, &dwTempPatch ) ) )
					{
						*pmtNext = pBandItem->m_mtTimePhysical - mtTime;
						pIDMUSProdBandEdit8->Release();
						break;
					}
					pIDMUSProdBandEdit8->Release();
				}
			}

			// Get the next "real" Band
			pos = GetFirstValidBand( pos, m_lstBands );
		}

		if( !fFoundPatch )
		{
			// No valid patch before mtTime
			return DMUS_E_NOT_FOUND;
		}

		return S_OK;
	}

	if( ::IsEqualGUID( guidType, GUID_Segment_ReferencedNodes ) )
	{
		DMUSProdReferencedNodes *pDMUSProdReferencedNodes = (DMUSProdReferencedNodes *)pData;

		// Search through Band list for first "real" Band
		POSITION pos = m_lstBands.GetHeadPosition();
		pos = GetFirstValidBand( pos, m_lstBands );
		if( pos == NULL )
		{
			// No valid Bands in this track.
			pDMUSProdReferencedNodes->dwArraySize = 0;
			return S_OK;
		}

		// Index into pDMUSProdReferencedNodes->apIDMUSProdNode to start writing the nodes at
		// Doubles as the count of nodes that we've written into the array
		DWORD dwIndex = 0;

		// Search through Band list for "real" Bands
		while( pos )
		{
			CBandItem* pBandItem = m_lstBands.GetNext( pos );
			ASSERT( pBandItem->m_pIBandNode );

			// Query the band node for its referenced DLS collections
			IDMUSProdGetReferencedNodes *pIDMUSProdGetReferencedNodes;
			if( pBandItem->m_pIBandNode
			&&	SUCCEEDED( pBandItem->m_pIBandNode->QueryInterface( IID_IDMUSProdGetReferencedNodes, (void **)&pIDMUSProdGetReferencedNodes ) ) )
			{
				// If we have an array of nodes, and we haven't filled it yet
				if( pDMUSProdReferencedNodes->apIDMUSProdNode
				&&	pDMUSProdReferencedNodes->dwArraySize > dwIndex )
				{
					// Calculate the size left in the array
					DWORD dwSize = pDMUSProdReferencedNodes->dwArraySize - dwIndex;

					// Ask the band node to fill in the array
					HRESULT hr = pIDMUSProdGetReferencedNodes->GetReferencedNodes( &dwSize, &(pDMUSProdReferencedNodes->apIDMUSProdNode[dwIndex]), pDMUSProdReferencedNodes->dwErrorLength, pDMUSProdReferencedNodes->wcstrErrorText );

					// If successful, increment dwIndex
					if( SUCCEEDED(hr) )
					{
						dwIndex += dwSize;
					}
				}
				else
				{
					// Ask the band node how many array items it required
					DWORD dwSize = 0;
					HRESULT hr = pIDMUSProdGetReferencedNodes->GetReferencedNodes( &dwSize, NULL, pDMUSProdReferencedNodes->dwErrorLength, pDMUSProdReferencedNodes->wcstrErrorText );

					// If successful, increment dwIndex
					if( SUCCEEDED(hr) )
					{
						dwIndex += dwSize;
					}
				}
				pIDMUSProdGetReferencedNodes->Release();
			}

			// Get the next "real" Band
			pos = GetFirstValidBand( pos, m_lstBands );
		}

		HRESULT hr = pDMUSProdReferencedNodes->apIDMUSProdNode && (pDMUSProdReferencedNodes->dwArraySize < dwIndex) ? S_FALSE : S_OK;

		// Store the number of nodes we returned (or that we require)
		pDMUSProdReferencedNodes->dwArraySize = dwIndex;

		return hr;
	}
	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::SetParam

HRESULT STDMETHODCALLTYPE CBandMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	UNREFERENCED_PARAMETER(mtTime);
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		m_pDMProdSegmentNode = reinterpret_cast<IDMUSProdNode*>(pData);
		// No addref!
		//m_pDMProdSegmentNode->AddRef();
		return S_OK;
	}

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::IsParamSupported

HRESULT STDMETHODCALLTYPE CBandMgr::IsParamSupported(
		/* [in] */ REFGUID		guidType)
{
	if( ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR )
	||	::IsEqualGUID( guidType, GUID_DocRootNode )
	||	::IsEqualGUID( guidType, GUID_BandStrip_InstrumentItem ) // Signifies a Band instrument in the track
	||  ::IsEqualGUID( guidType, GUID_BandNode ) 				 // Signifies a Band in the track
	||	::IsEqualGUID( guidType, GUID_BandInterfaceForPChannel ) // Signifies a Band in the track on a given PChannel
	||	::IsEqualGUID( guidType, GUID_BandMgrEditForPChannel )	 // Signifies the BandMgr, if there is a Band in the track on a given PChannel
	||  ::IsEqualGUID( guidType, GUID_IDirectMusicBand )		 // Signifies a Band track
	||	::IsEqualGUID( guidType, GUID_Segment_ReferencedNodes ) )

	{
		return S_OK;
	}
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CBandMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = E_FAIL;

	if( !(dwGroupBits & m_dwGroupBits) )
	{
		return E_INVALIDARG;
	}

	// TimeSig change
	if( ::IsEqualGUID( rguidType, GUID_TimeSignature ) )
	{
		// Update the m_mtTime value of all Bands
		if( RecomputeBandTimes() )
		{
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->RefreshData();
			}
			OnDataChanged();
		}

		// Redraw our strip
		m_pTimeline->StripInvalidateRect( m_pBandStrip, NULL, TRUE );
		return S_OK;
	}

	// All Tracks Added
	if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		// Fix measure/beat of all Bands
		RecomputeBandMeasureBeats();

		// Redraw our strip
		m_pTimeline->StripInvalidateRect( m_pBandStrip, NULL, TRUE );
		return S_OK;
	}

	// New Style just added to Style strip
	if( ::IsEqualGUID( rguidType, GUID_Segment_NewStyleSelected ) )
	{
		MUSIC_TIME* pmtTime = (MUSIC_TIME *)pData;
		IDMUSProdNode* pIStyleNode;
		IDMUSProdNode* pIDefaultBandNode;
		IDMUSProdStyleInfo* pIStyleInfo;

		// Use dwGroupBits handed to this method
		// dwGroupBits contains GroupBits of the Style track that sent the notification
		if( SUCCEEDED ( m_pTimeline->GetParam( GUID_StyleNode, dwGroupBits, 0, 
											   *pmtTime, NULL, (void *)&pIStyleNode ) ) )
		{
			if( SUCCEEDED ( pIStyleNode->QueryInterface( IID_IDMUSProdStyleInfo, (void**)&pIStyleInfo ) ) )
			{
				IUnknown *punkBandNode;

				if( SUCCEEDED ( pIStyleInfo->GetDefaultBand( &punkBandNode ) ) )
				{
					if( SUCCEEDED ( punkBandNode->QueryInterface( IID_IDMUSProdNode, (void**)&pIDefaultBandNode ) ) )
					{
						m_pBandStrip->AddBandNode( pIDefaultBandNode, ((*pmtTime) - 1) );
						RELEASE( pIDefaultBandNode );
					}
					RELEASE( punkBandNode );
				}
				RELEASE( pIStyleInfo );
			}
			RELEASE( pIStyleNode );
		}
		OnDataChanged();

		// Redraw our strip
		m_pTimeline->StripInvalidateRect( m_pBandStrip, NULL, TRUE );
		return S_OK;
	}

	if( ::IsEqualGUID(rguidType, GUID_Segment_Start) )
	{
		RELEASE(m_pSegmentState);

		if( pData )
		{
			static_cast<IUnknown *>(pData)->QueryInterface( IID_IDirectMusicSegmentState8, (void **)&m_pSegmentState );
		}

		UpdateBandNodesWithAudiopath();

		return S_OK;
	}

	if( ::IsEqualGUID(rguidType, GUID_Segment_Stop) )
	{
		RELEASE(m_pSegmentState);
		UpdateBandNodesWithAudiopath();
		return S_OK;
	}

	if( ::IsEqualGUID(rguidType, GUID_Segment_FrameworkMsg) )
	{
		DMUSProdFrameworkMsg* pFrameworkMsg =  (DMUSProdFrameworkMsg *)pData;
		ASSERT( pFrameworkMsg != NULL );

		IDMUSProdNode* pINode = NULL;

		if( pFrameworkMsg->punkIDMUSProdNode )
		{
			if( FAILED ( pFrameworkMsg->punkIDMUSProdNode->QueryInterface( IID_IDMUSProdNode, (void**)&pINode ) ) )
			{
				pINode = NULL;
			}
		}

		// Validate Band name change
		if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, BAND_ValidateNameChange) )  
		{
			// Any name is ok
			hr = S_OK;
		}

		// Band name change
		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, BAND_NameChange) )  
		{
			if( pINode )
			{
				BOOL fUpdate = FALSE;

				POSITION pos = m_lstBands.GetHeadPosition();
				while( pos )
				{
					CBandItem* pBandItem = m_lstBands.GetNext( pos );

					if( pBandItem->m_pIBandNode == pINode )
					{
						BSTR bstrBandName;
						if( SUCCEEDED ( pBandItem->m_pIBandNode->GetNodeName( &bstrBandName ) ) )
						{
							CString strNewName = bstrBandName; 
							::SysFreeString( bstrBandName );

							if( pBandItem->m_strText.Compare( strNewName ) != 0 )
							{
								pBandItem->m_strText = strNewName;
								fUpdate = TRUE;
							}
						}
					}
				}

				if( fUpdate )
				{
					// Redraw our strip
					m_pTimeline->StripInvalidateRect( m_pBandStrip, NULL, TRUE );

					if( !m_fNoUpdateSegment )
					{
						// Get state of TP_FREEZE_UNDO
						BOOL fFreezeUndo = FALSE;
						VARIANT var;
						if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
						{
							fFreezeUndo = V_BOOL(&var);
						}

						// If TP_FREEZE_UNDO is set, set it to FALSE
						if( fFreezeUndo )
						{
							// Need to clear TP_FREEZE_UNDO or the segment will not add an undo state for us
							var.vt = VT_BOOL;
							V_BOOL(&var) = FALSE;
							m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
						}

						// Set the undo string
						if( m_pBandStrip )
						{
							m_pBandStrip->m_nLastEdit = IDS_UNDO_BANDNAME;
						}

						// Let our hosting editor know about the changes
						m_pTimeline->OnDataChanged( (IBandMgr*)this );

						if( fFreezeUndo )
						{
							// Need to set TP_FREEZE_UNDO back to its original setting
							var.vt = VT_BOOL;
							V_BOOL(&var) = TRUE;
							m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
						}
					}

					SyncWithDirectMusic();
					m_fDirty = TRUE;
					hr = S_OK;
				}
			}
		}

		// Band change
		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, GUID_BAND_ChangeNotifyMsg) )  
		{
			if( pINode )
			{
				// Find which band changed
				BOOL fFound = FALSE;
				POSITION pos = m_lstBands.GetHeadPosition();
				while( pos && !fFound )
				{
					CBandItem* pBandItem = m_lstBands.GetNext( pos );
					ASSERT( pBandItem );
					if( pBandItem && (pBandItem->m_pIBandNode == pINode) )
					{
						// This band changed
						fFound = TRUE;
						// Found the band - don't update
						hr = S_FALSE;

						// Validate our performance and segment state pointers
						if( m_pIPerformance && m_pSegmentState )
						{
							// Get the current segment
							IDirectMusicSegment *pSegment;
							if( SUCCEEDED( m_pSegmentState->GetSegment( &pSegment ) ) )
							{
								// Check if our track is in the currenly playing segment
								DWORD dwGroupBits;
								if( SUCCEEDED( pSegment->GetTrackGroup( m_pIDMTrack, &dwGroupBits ) ) )
								{
									// The segment we're in is currently playing - get the current offset
									MUSIC_TIME mtSeek;
									if( SUCCEEDED( m_pSegmentState->GetSeek( &mtSeek ) ) )
									{
										// If this band played before the current offset
										if( pBandItem->m_mtTimePhysical < mtSeek )
										{
											// if there is a next band
											if( pos )
											{
												// Check if the next band is also before the current offset
												pBandItem = m_lstBands.GetNext( pos );
												while( pos && !pBandItem->m_pIBandNode )
												{
													pBandItem = m_lstBands.GetNext( pos );
												}
												if( !pBandItem->m_pIBandNode || (pBandItem->m_mtTimePhysical > mtSeek) )
												{
													// No next band, or next band after the current offset - send band
													// change messages
													hr = S_OK;
												}
											}
											else
											{
												// No next band - do update
												hr = S_OK;
											}
										}
									}
								}
								pSegment->Release();
							}
						}
						else
						{
							// Found the band - do update
							hr = S_OK;
						}
					}
				}

				if( fFound )
				{
					if( !m_fNoUpdateSegment )
					{
						// Set the undo string
						if( m_pBandStrip )
						{
							m_pBandStrip->m_nLastEdit = IDS_UNDO_BANDCHANGE;
						}

						// Get state of TP_FREEZE_UNDO
						BOOL fFreezeUndo = FALSE;
						VARIANT var;
						if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
						{
							fFreezeUndo = V_BOOL(&var);
						}

						// If TP_FREEZE_UNDO is set, set it to FALSE
						if( fFreezeUndo )
						{
							// Need to clear TP_FREEZE_UNDO or the segment will not add an undo state for us
							var.vt = VT_BOOL;
							V_BOOL(&var) = FALSE;
							m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
						}

						// Let our hosting editor know about the changes
						m_pTimeline->OnDataChanged( (IBandMgr*)this );

						if( fFreezeUndo )
						{
							// Need to set TP_FREEZE_UNDO back to its original setting
							var.vt = VT_BOOL;
							V_BOOL(&var) = TRUE;
							m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
						}
					}

					// Sequence strip will need to repaint FBar to catch latest DLS region wave names
					m_pTimeline->NotifyStripMgrs( GUID_Segment_BandTrackChange, m_dwGroupBits, NULL );

					SyncWithDirectMusic();
					m_fDirty = TRUE;
				}
			}
		}

		if( pINode )
		{
			pINode->Release();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::GetStripMgrProperty

HRESULT STDMETHODCALLTYPE CBandMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pDMProdFramework )
		{
			return m_pDMProdFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackHeader->guidClassID = CLSID_DirectMusicBandTrack;
			pioTrackHeader->dwPosition = 0;
			pioTrackHeader->dwGroup = m_dwGroupBits;
			pioTrackHeader->ckid = NULL;
			pioTrackHeader->fccType = DMUS_FOURCC_BANDTRACK_FORM;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER_MASK:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = TRACKCONFIG_VALID_MASK;
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( pVariant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			pioProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CBandMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}

		// If we were previously attached to a timeline, remove our PropPageObject and strip from it
		if( m_pTimeline )
		{
			if( V_UNKNOWN( &variant ) == NULL )
			{
				if( m_pDMProdFramework )
				{
					// Editor is closing, so close all open Band windows
					POSITION pos = m_lstBands.GetHeadPosition();
					while( pos )
					{
						CBandItem* pBandItem = m_lstBands.GetNext( pos );

						if( pBandItem->m_pIBandNode )
						{
							m_pDMProdFramework->CloseEditor( pBandItem->m_pIBandNode );
						}
					}
				}
			}

			m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->Release();
				m_pPropPageMgr = NULL;
			}
			if ( m_pBandStrip )
			{
				if (!V_UNKNOWN( &variant ) && m_pBandStrip->m_pStripNode) // the strip is being removed, so release its strip node.
				{
					m_pBandStrip->m_pStripNode->Release();
					m_pBandStrip->m_pStripNode = NULL;
				}
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)m_pBandStrip);
				m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pBandStrip );
			}
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_FrameworkMsg, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_NewStyleSelected, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Start, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Stop, m_dwOldGroupBits );
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}

		if( V_UNKNOWN( &variant ) )
		{
			if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
			{
				return E_FAIL;
			}
			else
			{
				// Add the strip to the timeline
				m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pBandStrip, CLSID_DirectMusicBandTrack, m_dwGroupBits, 0 );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_FrameworkMsg, m_dwGroupBits);
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_NewStyleSelected, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Start, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Stop, m_dwGroupBits );

				// Set notifications for all Bands
				POSITION pos = m_lstBands.GetHeadPosition();
				while( pos )
				{
					CBandItem* pBandItem = m_lstBands.GetNext( pos );

					if( m_pBandStrip->m_pStripNode
					&&  pBandItem->m_pIBandNode )
					{
						m_pDMProdFramework->AddToNotifyList(pBandItem->m_pIBandNode, m_pBandStrip->m_pStripNode);
					}
				}
			}
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
		}
		if( V_UNKNOWN( &variant ) )
		{
			V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack );
		}
		else
		{
			m_pIDMTrack = NULL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pDMProdFramework )
		{
			m_pDMProdFramework->Release();
			m_pDMProdFramework = NULL;
		}
		if( V_UNKNOWN( &variant )
		&&	SUCCEEDED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMProdFramework) )
		&&	(m_pDMProdFramework != NULL) )
		{
			IDMUSProdComponent* pIComponent;
			if( SUCCEEDED( m_pDMProdFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ) )
			{
				IDMUSProdConductor *pIConductor;
				if( SUCCEEDED( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pIConductor ) ) )
				{
					IUnknown *punkPerformance;
					if( SUCCEEDED( pIConductor->GetPerformanceEngine( &punkPerformance ) ) )
					{
						punkPerformance->QueryInterface( IID_IDirectMusicPerformance, (void**)&m_pIPerformance );
						punkPerformance->Release();
					}
					pIConductor->Release();
				}
				pIComponent->Release();
			}
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}
			m_dwGroupBits = pioTrackHeader->dwGroup;
			m_dwOldGroupBits = pioTrackHeader->dwGroup;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
		}
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( &variant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			m_dwProducerOnlyFlags = pioProducerOnlyChunk->dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CBandMgr::GetClassID

HRESULT CBandMgr::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pClsId == NULL )
	{
		return E_POINTER;
	}

	// return our CLSID
	memcpy( pClsId, &CLSID_BandMgr, sizeof( CLSID ) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CBandMgr::IsDirty

HRESULT CBandMgr::IsDirty()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( m_fDirty )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::Load

HRESULT CBandMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Check for Direct Music format
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Remove all existing bands
	EmptyBandList();

	MMCKINFO ckMain;

	ckMain.fccType = DMUS_FOURCC_BANDTRACK_FORM;
	hr = pIRiffStream->Descend(&ckMain, NULL, MMIO_FINDRIFF);

	if(FAILED(hr))
	{
		pIRiffStream->Release();
		return hr;
	}
	
//	DWORD cbRead;
//	DWORD cbSize;
	
	MMCKINFO ckNext;
	
	ckNext.ckid = 0;
	ckNext.fccType = 0;
		
	while(pIRiffStream->Descend(&ckNext, &ckMain, 0) == 0)
	{
		switch(ckNext.ckid)
		{
			// For now, just ignore this chunk
//			case DMUS_FOURCC_BANDTRACK_CHUNK:
//				DMUS_IO_BAND_TRACK_HEADER ioDMBndTrkHdr;
//				cbSize = min(sizeof(DMUS_IO_BAND_TRACK_HEADER), ckNext.cksize);
//				hr = pIStream->Read(&ioDMBndTrkHdr, cbSize, &cbRead);
//				if(SUCCEEDED(hr) && cbRead == cbSize)
//				{
//					m_bAutoDownload = ioDMBndTrkHdr.bAutoDownload ? true : false;
//
//				}
//				else
//				{
//					hr = E_FAIL;
//				}
//				break;

			case FOURCC_LIST:
				switch(ckNext.fccType)
				{
					case  DMUS_FOURCC_BANDS_LIST:
						BOOL fChanged;
						hr = BuildDirectMusicBandList(pIStream, pIRiffStream, ckNext, fChanged);
						break;

					default:
						break;
				}
			default:
				break;

		}
    
		if(SUCCEEDED(hr) && pIRiffStream->Ascend(&ckNext, 0) == 0)
		{
			ckNext.ckid = 0;
			ckNext.fccType = 0;
		}
	}

	pIRiffStream->Release();
	
	if (SUCCEEDED( hr) )
	{
		hr = SyncWithDirectMusic();
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandMgr::BuildDirectMusicBandList

HRESULT CBandMgr::BuildDirectMusicBandList(IStream* pIStream,
										   IDMUSProdRIFFStream *pIDirectMusicStream,
										   MMCKINFO& ckParent,
										   BOOL& fChanged,
										   bool fPaste,
										   MUSIC_TIME mtPasteTime)
{
	ASSERT(pIDirectMusicStream);
	ASSERT(pIStream);
	HRESULT hr;

	MMCKINFO ckMain;
	MMCKINFO ck;

	if( fPaste )
	{
		DWORD dwCurrentFilePos = StreamTell( pIStream );

		MUSIC_TIME mtAdjustment = 0;

		ASSERT( m_pTimeline != NULL );
		if( m_pTimeline )
		{
			// Get Timeline length
			VARIANT var;
			m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
			MUSIC_TIME mtMaxTimelineLength = V_I4( &var );
			mtMaxTimelineLength--;

			// Get start clock for the last beat in the timeline;
			long lMeasure;
			long lBeat;
			m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtMaxTimelineLength, &lMeasure, &lBeat );
			m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &mtMaxTimelineLength );
	
			ckMain.ckid = 0;
			ckMain.fccType = 0;

			// Determine new paste time to enforce boundaries
			while ( pIDirectMusicStream->Descend( &ckMain, &ckParent, 0 ) == 0  )
			{
				if( ckMain.ckid == FOURCC_LIST
				&&  ckMain.fccType == DMUS_FOURCC_BAND_LIST )
				{
					while( pIDirectMusicStream->Descend( &ck, &ckMain, 0 ) == 0 )
					{
						switch( ck.ckid )
						{
							case DMUS_FOURCC_BANDITEM_CHUNK2:
							{
								DMUS_IO_BAND_ITEM_HEADER2 ioDMBndItemHdr2;
								DWORD cbRead;
								DWORD cbSize;
								
								cbSize = min( sizeof(DMUS_IO_BAND_ITEM_HEADER2), ck.cksize );
								hr = pIStream->Read( &ioDMBndItemHdr2, cbSize, &cbRead );
								if( FAILED(hr) || cbRead != cbSize ) 
								{
									pIDirectMusicStream->Ascend( &ck, 0 );
									goto ON_END;
								}

								MUSIC_TIME mtTime = ioDMBndItemHdr2.lBandTimePhysical;

								// Adjust mtTime so that Tick offset remains unchanged after the paste
								if( mtTime < 0 )
								{
									long lClocksPerBeat;

									m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, 0, 1, &lClocksPerBeat );
									MUSIC_TIME mtMod = mtTime % lClocksPerBeat;
									mtTime = mtTime - mtMod;
									if( mtMod <= -(lClocksPerBeat >> 1) )
									{
										mtTime -= lClocksPerBeat;
									}
								}
								else
								{
									m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
									m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &mtTime );
								}

								mtTime += mtPasteTime;
								if( mtTime < 0 )
								{
									mtTime = 0 - mtTime;
									if( mtTime > mtAdjustment )
									{
										mtAdjustment = mtTime;
									}
								}
								else if( mtTime >= mtMaxTimelineLength )
								{
									mtTime = mtMaxTimelineLength - mtTime;
									if( mtTime < mtAdjustment )
									{
										mtAdjustment = mtTime;
									}
								}
							}
							break;

							case DMUS_FOURCC_BANDITEM_CHUNK:
							{
								DMUS_IO_BAND_ITEM_HEADER ioDMBndItemHdr;
								DWORD cbRead;
								DWORD cbSize;
								
								cbSize = min( sizeof(DMUS_IO_BAND_ITEM_HEADER), ck.cksize );
								hr = pIStream->Read( &ioDMBndItemHdr, cbSize, &cbRead );
								if( FAILED(hr) || cbRead != cbSize ) 
								{
									pIDirectMusicStream->Ascend( &ck, 0 );
									goto ON_END;
								}

								MUSIC_TIME mtTime = ioDMBndItemHdr.lBandTime;

								// Adjust mtTime so that Tick offset remains unchanged after the paste
								if( mtTime < 0 )
								{
									long lClocksPerBeat;

									m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, 0, 1, &lClocksPerBeat );
									MUSIC_TIME mtMod = mtTime % lClocksPerBeat;
									mtTime = mtTime - mtMod;
									if( mtMod <= -(lClocksPerBeat >> 1) )
									{
										mtTime -= lClocksPerBeat;
									}
								}
								else
								{
									m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
									m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &mtTime );
								}

								mtTime += mtPasteTime;
								if( mtTime < 0 )
								{
									mtTime = 0 - mtTime;
									if( mtTime > mtAdjustment )
									{
										mtAdjustment = mtTime;
									}
								}
								else if( mtTime >= mtMaxTimelineLength )
								{
									mtTime = mtMaxTimelineLength - mtTime;
									if( mtTime < mtAdjustment )
									{
										mtAdjustment = mtTime;
									}
								}
							}
							break;
						}

						pIDirectMusicStream->Ascend( &ck, 0 );
					}

					pIDirectMusicStream->Ascend( &ckMain, 0 );
				}

				pIDirectMusicStream->Ascend( &ckMain, 0 );
			}
		}

		// New paste time which will enforce strip boundaries
		mtPasteTime += mtAdjustment;

		// Restore our position back to the start of the Bands
		StreamSeek( pIStream, dwCurrentFilePos, STREAM_SEEK_SET );
	}

	ckMain.ckid = 0;
	ckMain.fccType = 0;
    
	while( pIDirectMusicStream->Descend(&ckMain, &ckParent, 0) == 0 )
	{
		switch(ckMain.ckid)
		{
			case FOURCC_LIST :
				switch(ckMain.fccType)
				{
					case DMUS_FOURCC_BAND_LIST:
						hr = ExtractBand( pIStream, pIDirectMusicStream, ckMain, fPaste, mtPasteTime );
						if( SUCCEEDED( hr ) )
						{
							fChanged = TRUE;
						}
						break;
					
					default:
						break;

				}
				break;

			default:
				break;

		}
    
		if(SUCCEEDED(hr) && pIDirectMusicStream->Ascend(&ckMain, 0) == 0)
		{
			ckMain.ckid = 0;
			ckMain.fccType = 0;
		}
	}

ON_END:
	return hr;
}


//////////////////////////////////////////////////////////////////////
// CBandMgr::ExtractBand

HRESULT CBandMgr::ExtractBand(IStream* pStream, 
								 IDMUSProdRIFFStream *pIDirectMusicStream, 
								 MMCKINFO& ckParent,
								 bool fPaste,
								 MUSIC_TIME mtPasteTime)
{
	ASSERT(pIDirectMusicStream);
	ASSERT(pStream);
	
	MMCKINFO ckNext;
	ckNext.ckid = 0;
	ckNext.fccType = 0;
	
	DWORD cbRead;    
	DWORD cbSize;

	BOOL fInsertedItem = FALSE; // Set to true when the pItem is inserted in the band list

	CBandItem *pItem = new CBandItem(m_pBandStrip);
	if(pItem == NULL)
	{
		return E_OUTOFMEMORY;
	}
	pItem->m_strText.Empty();

	HRESULT	hr;
	long lMeasure = 0;
	long lBeat = 0;
	long lTick = 0;

	while(pIDirectMusicStream->Descend(&ckNext, &ckParent, 0) == 0)
	{
		switch(ckNext.ckid)
		{
			case DMUS_FOURCC_BANDITEM_CHUNK2:
				DMUS_IO_BAND_ITEM_HEADER2 ioDMBndItemHdr2;
				cbSize = min(sizeof(DMUS_IO_BAND_ITEM_HEADER2), ckNext.cksize);
				hr = pStream->Read(&ioDMBndItemHdr2, cbSize, &cbRead);
				if(SUCCEEDED(hr) && cbRead == cbSize)
				{
					pItem->m_mtTimePhysical = ioDMBndItemHdr2.lBandTimePhysical;
					pItem->m_mtTimeLogical = ioDMBndItemHdr2.lBandTimeLogical;
					if( fPaste )
					{
						pItem->SetTimePhysical( (pItem->m_mtTimePhysical + mtPasteTime), STP_LOGICAL_FROM_BEAT_OFFSET );
						if( pItem->m_mtTimePhysical < -MAX_TICK )
						{
							CleanUpPropBand( pItem );
							delete pItem;
							return S_OK;
						}
					}
					else
					{
						pItem->SetTimePhysical( ioDMBndItemHdr2.lBandTimePhysical, STP_LOGICAL_RECALC_MEASURE_BEAT );
					}
				}
				else if(SUCCEEDED(hr))
				{
					hr = E_FAIL;
				}
				break;
			
			case DMUS_FOURCC_BANDITEM_CHUNK:
				ASSERT( fPaste == FALSE );	// Paste should always use DMUS_FOURCC_BANDITEM_CHUNK2
				DMUS_IO_BAND_ITEM_HEADER ioDMBndItemHdr;
				cbSize = min(sizeof(DMUS_IO_BAND_ITEM_HEADER), ckNext.cksize);
				hr = pStream->Read(&ioDMBndItemHdr, cbSize, &cbRead);
				if(SUCCEEDED(hr) && cbRead == cbSize)
				{
					pItem->m_mtTimePhysical = ioDMBndItemHdr.lBandTime;
					pItem->m_mtTimeLogical = ioDMBndItemHdr.lBandTime;
				}
				else if(SUCCEEDED(hr))
				{
					hr = E_FAIL;
				}
				break;
			
			case FOURCC_RIFF:
				switch(ckNext.fccType)
				{
					case DMUS_FOURCC_BAND_FORM:
						LARGE_INTEGER li;
						ULARGE_INTEGER ul;

						li.HighPart = 0;
						li.LowPart = 0;

						hr = pStream->Seek(li, STREAM_SEEK_CUR, &ul);

						if(SUCCEEDED(hr))
						{
							li.HighPart = 0;
							li.LowPart = ul.LowPart - sizeof(FOURCC) * 2 - sizeof(DWORD);

							hr = pStream->Seek(li, STREAM_SEEK_SET, &ul);
						}
						
						if(SUCCEEDED(hr))
						{
							IDMUSProdComponent* pIComponent = NULL;
							hr = m_pDMProdFramework->FindComponent(CLSID_BandComponent, &pIComponent);
							if(SUCCEEDED(hr))
							{
								IDMUSProdRIFFExt* pRiff = NULL;
								hr = pIComponent->QueryInterface(IID_IDMUSProdRIFFExt, (void**)&pRiff);
								if( SUCCEEDED( hr ) )
								{
									IDMUSProdNode* pNode = NULL;
									hr = pRiff->LoadRIFFChunk(pStream, &pNode);
									pRiff->Release();
									if (SUCCEEDED(hr))
									{
										pItem->m_pIBandNode = pNode;
										// BUGBUG error checking; cleanup!
										BSTR bstrName;
										pItem->m_pIBandNode->GetNodeName( &bstrName );
										pItem->m_strText = bstrName;
										if( fPaste )
										{
											pItem->SetSelectFlag( TRUE );
										}
										if (m_pBandStrip->m_pStripNode)
										{
											m_pDMProdFramework->AddToNotifyList(pItem->m_pIBandNode, m_pBandStrip->m_pStripNode);
										}
										ASSERT( !fInsertedItem );
										InsertByAscendingTime( pItem, fPaste );
										fInsertedItem = TRUE;
										SysFreeString(bstrName);
									}
								}
								pIComponent->Release();
							}

						}					
						break;

					default:
						break;
				}
				break;
			default:
				break;

		}
    
		if( SUCCEEDED(hr) && pIDirectMusicStream->Ascend(&ckNext, 0) == 0 )
		{
			ckNext.ckid = 0;
			ckNext.fccType = 0;
		}
	}

	if( !fInsertedItem )
	{
		delete pItem;
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBandMgr::Save

HRESULT CBandMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo	StreamInfo;//Added ECW 4/24/98
	FileType ftFileType = FT_DESIGN;	// Default to FT_DESIGN so clipboard
										// gets proper DLS file ref chunk
										// when Band is saved
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// We only support saving to a design-time stream (GUID_CurrentVersion) or a DirectMusic
	// stream that will be loaded into a DirectMusicBandTrack (GUID_DirectMusicObject)
	if( !::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) &&
		!::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
	{
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Alloc an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

    MMCKINFO ckMain;

	// If the Band list isn't empty, save it
	//if ( !m_lstBands.IsEmpty() )
	{
		// Create a RIFF chunk to store the Band data
		ckMain.fccType = DMUS_FOURCC_BANDTRACK_FORM;
		if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
		SaveBandWrapper(pIStream, pIRiffStream);

		// Ascend out of the Band RIFF chunk.
		pIRiffStream->Ascend( &ckMain, 0 );
	}
	m_fDirty = FALSE;

ON_ERROR:
	pIRiffStream->Release();
    return hr;
}

HRESULT CBandMgr::SaveBandWrapper( IStream* pIStream, IDMUSProdRIFFStream* pIRiffStream )
{
    MMCKINFO ckList;
	HRESULT hr = S_OK;
//	DWORD				dwByteCount;

	// For now, do not write this chunk
	//if (m_bAutoDownload)
//	{
//		// Band track header
//		MMCKINFO ckTrackHeader;
//		ckTrackHeader.ckid = DMUS_FOURCC_BANDTRACK_CHUNK;
//		if( FAILED( pIRiffStream->CreateChunk( &ckTrackHeader, 0 ) ) )
//		{
//			hr = E_FAIL;
//			goto ON_ERR;
//		}
//
//		DMUS_IO_BAND_TRACK_HEADER oBandTrackHeader;
//		oBandTrackHeader.bAutoDownload = m_bAutoDownload ? TRUE : FALSE;
//
//		hr = pIStream->Write( &oBandTrackHeader, sizeof(oBandTrackHeader), &dwByteCount );
//		if( FAILED(hr) || dwByteCount != sizeof(oBandTrackHeader) )
//		{
//			hr = E_FAIL;
//			goto ON_ERR;
//		}
//
//		if( pIRiffStream->Ascend( &ckTrackHeader, 0 ) != 0 )
//		{
//			hr = E_FAIL;
//			goto ON_ERR;
//		}
//	}
	//else
	if ( !m_lstBands.IsEmpty() )
	{
		// Create a LIST chunk to wrap the Bands
		ckList.fccType = DMUS_FOURCC_BANDS_LIST;
		if( pIRiffStream->CreateChunk( &ckList, MMIO_CREATELIST ) != 0 )
		{
			return E_FAIL;
		}

		POSITION pos = m_lstBands.GetHeadPosition();
		while( pos )
		{
			CBandItem* pBandItem;
			pBandItem = m_lstBands.GetNext( pos );
			ASSERT( pBandItem );
			if( pBandItem && pBandItem->m_pIBandNode )
			{
				// Store each Band in its own chunk.
				SaveBand( pIStream, pIRiffStream, pBandItem, 0, 0 );
			}
		}

		// Ascend out of the Band LIST chunk.
		pIRiffStream->Ascend( &ckList, 0 );
	}

//ON_ERR:
    return hr;
}

HRESULT CBandMgr::SaveBand( IStream* pIStream, IDMUSProdRIFFStream* pIRiffStream,
						    CBandItem* pBandItem, MUSIC_TIME mtOffset, short nReason )
{
    MMCKINFO ckList;
	HRESULT hr = S_OK;

	// Create a LIST chunk for the Band
	ckList.fccType = DMUS_FOURCC_BAND_LIST;
	if( pIRiffStream->CreateChunk( &ckList, MMIO_CREATELIST ) != 0 )
	{
		return E_FAIL;
	}

	// Write 'bd2h-ck'
	MMCKINFO ck;
	ck.ckid = DMUS_FOURCC_BANDITEM_CHUNK2;
	if( FAILED( pIRiffStream->CreateChunk( &ck, 0 ) ) )
	{
		return E_FAIL;
	}
	{
		DWORD dwByteCount;
		DMUS_IO_BAND_ITEM_HEADER2 header2;

		header2.lBandTimePhysical = pBandItem->m_mtTimePhysical - mtOffset;

		if( nReason == SSB_COPY
		||  nReason == SSB_DRAG )
		{
			long lMeasure, lBeat, lTick;

			// Snap physical time to number of beats
			long lPhysicalBeats;
			ClocksToMeasureBeatTick( pBandItem->m_mtTimePhysical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pTimeline, m_dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Convert logical time to number of beats
			long lLogicalBeats;
			ClocksToMeasureBeatTick( pBandItem->m_mtTimeLogical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pTimeline, m_dwGroupBits, 0, lMeasure, lBeat, lLogicalBeats );

			// Use lBandTimeLogical to store beat difference between physical and logical times
			header2.lBandTimeLogical = lLogicalBeats - lPhysicalBeats;
		}
		else
		{
			header2.lBandTimeLogical = pBandItem->m_mtTimeLogical;
		}

		hr = pIStream->Write(&header2, sizeof(header2), &dwByteCount);
		if(FAILED(hr) || dwByteCount != sizeof(header2))
		{
			return E_FAIL;
		}

		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
			return E_FAIL;
		}

		// now I need to save the band; I should be able to call the band node's save method.
		IPersistStream* pStream = NULL;
		hr = pBandItem->m_pIBandNode->QueryInterface(IID_IPersistStream, (void**)&pStream);
		if (SUCCEEDED(hr))
		{
			hr = pStream->Save(pIStream, FALSE); // BUGBUG is FALSE ok here?
			pStream->Release();
		}
	}

	// Ascend out of the Band LIST chunk.
	pIRiffStream->Ascend( &ckList, 0 );

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::CleanUpPropBand

void CBandMgr::CleanUpPropBand( CPropBand* pPropBand )
{
	ASSERT( pPropBand != NULL );

	// Close Band editor
	if( pPropBand->m_pIBandNode )
	{
		if( m_pDMProdFramework  )
		{
			m_pDMProdFramework->CloseEditor( pPropBand->m_pIBandNode );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::CreateBand

HRESULT CBandMgr::CreateBand( DWORD dwMeasure, BYTE bBeat, CBandStrip* pBandStrip, CBandItem*& rpBand )
{

	rpBand = NULL;
	HRESULT hr = S_OK;

	if (!m_pTimeline) return E_FAIL;

	rpBand = new CBandItem(pBandStrip);
	if(rpBand == NULL)
	{
		hr =  E_OUTOFMEMORY;
	}
	else
	{
		long lClocks;
		MeasureBeatTickToClocks( dwMeasure, bBeat, 0, &lClocks );
		rpBand->SetTimePhysical( lClocks, STP_LOGICAL_SET_DEFAULT );
		rpBand->m_strText.Empty();
		rpBand->m_strText = "";
		rpBand->m_pIBandNode = NULL;
		AddBand(rpBand);
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::CreateBand

HRESULT CBandMgr::CreateBand( long lXPos, CBandStrip* pBandStrip, CBandItem*& rpBand )
{

	rpBand = NULL;
	HRESULT hr = S_OK;

	if (!m_pTimeline) return E_FAIL;

	rpBand = new CBandItem(pBandStrip);
	if(rpBand == NULL)
	{
		hr =  E_OUTOFMEMORY;
	}
	else
	{
		long lMeasure = 0;
		long lBeat = 0;
		hr = m_pTimeline->PositionToMeasureBeat( m_dwGroupBits, 0, lXPos, &lMeasure, &lBeat );
		ASSERT(SUCCEEDED(hr));

		long lClocks;
		MeasureBeatTickToClocks( lMeasure, lBeat, 0, &lClocks );
		rpBand->SetTimePhysical( lClocks, STP_LOGICAL_SET_DEFAULT );
		rpBand->m_strText.Empty();
		rpBand->m_strText = "";
		rpBand->m_pIBandNode = NULL;
		AddBand(rpBand);
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CBandMgr::GetSizeMax

HRESULT CBandMgr::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	// Compute size of stream needed to persist ourself into.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CBandMgr::GetData

// This method is called by CBandPropPageMgr to get data to send to the
// Band property page.
// The CBandStrip::GetData() method is called by CBandStripPropPageMgr
// to get the strip's properties (Group Bits, etc.)
HRESULT STDMETHODCALLTYPE CBandMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( ppData == NULL )
	{
		return E_INVALIDARG;
	}

	// Return a pointer to the currently selected band.
	BOOL fMultipleSelect = FALSE;
	CBandItem* pFirstBandItem = NULL;

	CBandItem* pBandItem;
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		pBandItem = m_lstBands.GetNext( pos );
		if( pBandItem->m_fSelected
		&&  pBandItem->m_strText.IsEmpty() == FALSE )
		{
			pFirstBandItem = pBandItem;
			while( pos )
			{
				pBandItem = m_lstBands.GetNext( pos );
				if( pBandItem->m_fSelected
				&&  pBandItem->m_strText.IsEmpty() == FALSE )
				{
					fMultipleSelect = TRUE;
					pos = NULL;
					break;
				}
			}
			break;
		}
	}

	*ppData = NULL;
	HRESULT hr = E_FAIL;

	// Multiple Bands selected
	if( fMultipleSelect )
	{
		CPropBand* pPropBand = new CPropBand;
		if( pPropBand )
		{
			pPropBand->m_dwMeasure = 0xFFFFFFFF;		// Signifies multiple Bands selected
			*ppData = pPropBand;
			hr = S_OK;
		}
	}

	// One Band selected
	else if( pFirstBandItem )
	{
		CPropBand* pPropBand = new CPropBand( pFirstBandItem );
		if( pPropBand )
		{
			*ppData = pPropBand;
			hr = S_OK;
		}
	}

	// Nothing selected
	else
	{
		*ppData = NULL;
		hr = S_OK;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::ForceBoundaries

HRESULT CBandMgr::ForceBoundaries( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmtTime )
{
	// Get length of segment
	MUSIC_TIME mtMaxTimelineLength;
	VARIANT var;
	m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	mtMaxTimelineLength = V_I4( &var );

	// Get maximum number of measures, beats
	long lMaxMeasure;
	long lMaxBeat;
	long lMaxTick;
	long lClocks;
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtMaxTimelineLength - 1, &lMaxMeasure, &lMaxBeat );
	lMaxMeasure = max( 0, lMaxMeasure );
	lMaxBeat = max( 0, lMaxBeat );
	MeasureBeatTickToClocks( lMaxMeasure, lMaxBeat, 0, &lClocks );
	lMaxTick = mtMaxTimelineLength - lClocks; 

	// Force boundaries 
	MUSIC_TIME mtTime;
	MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );
	ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick );


	// Enforce measure boundary
	if( lMeasure > lMaxMeasure )
	{
		lMeasure = lMaxMeasure;
		lBeat = lMaxBeat;
	}

	// Enforce beat boundary (must catch incomplete last measures - happens when importing MIDI files)
	if( lMeasure == lMaxMeasure 
	&&  lBeat > lMaxBeat )
	{
		lBeat = lMaxBeat;
	}

	// Enforce tick boundary (must catch incomplete last beats - happens when importing MIDI files)
	if( lMeasure == lMaxMeasure 
	&&  lBeat == lMaxBeat 
	&&  lTick > lMaxTick )
	{
		lTick = lMaxTick;
	}
	if( lTick < -MAX_TICK )
	{
		lTick = -MAX_TICK;
	}

	// Make sure mtTime matches adjusted measure, tick
	MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );
	*pmtTime = mtTime;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::GetGroupBits

DWORD CBandMgr::GetGroupBits( void )
{
	return m_dwGroupBits;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::IsRefTimeTrack

bool CBandMgr::IsRefTimeTrack( void )
{
	return (m_dwTrackExtrasFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME) ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::SetData

// This method is called by CBandPropPageMgr in response to user actions
// in the Band Property page.  It changes the currenly selected Band. 
HRESULT STDMETHODCALLTYPE CBandMgr::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pData == NULL )
	{
		return E_INVALIDARG;
	}

	// Return a pointer to the currently selected band.
	CBandItem* pBandItem;
	pBandItem = FirstSelectedRealBand();

	if( pBandItem )
	{
		CPropBand *pPropBand;
		pPropBand = new CPropBand( pBandItem );

		if( pPropBand )
		{
			CPropBand* pBand = (CPropBand*)pData;

			bool fChanged = false;

			// m_mtTimePhysical
			if( pBand->m_dwMeasure != pBandItem->m_dwMeasure
			||  pBand->m_bBeat != pBandItem->m_bBeat
			||  pBand->m_lTick != pBandItem->m_lTick )
			{
				char chBeat = pBand->m_bBeat;	// May contain negative number
		
				MUSIC_TIME mtNewTimePhysical;
				if( SUCCEEDED ( ForceBoundaries( pBand->m_dwMeasure, chBeat, pBand->m_lTick, &mtNewTimePhysical ) ) )
				{
					if( mtNewTimePhysical != pBandItem->m_mtTimePhysical )
					{
						m_pBandStrip->m_nLastEdit = IDS_UNDO_MOVE;
						pBandItem->SetTimePhysical( mtNewTimePhysical, STP_LOGICAL_ADJUST );

						POSITION pos = m_lstBands.Find( pBandItem );
						ASSERT( pos != NULL );
						if( pos )
						{
							m_lstBands.RemoveAt( pos );
							InsertByAscendingTime( pBandItem, FALSE );
						}

						fChanged = true;
					}
				}
			}

			// m_mtTimeLogical
			else if( pBand->m_lLogicalMeasure != pBandItem->m_lLogicalMeasure
				 ||  pBand->m_lLogicalBeat != pBandItem->m_lLogicalBeat )
			{
				MUSIC_TIME mtNewTimeLogical;
				if( SUCCEEDED ( ForceBoundaries( pBand->m_lLogicalMeasure, pBand->m_lLogicalBeat, 0, &mtNewTimeLogical ) ) )
				{
					if( mtNewTimeLogical != pBandItem->m_mtTimeLogical )
					{
						m_pBandStrip->m_nLastEdit = IDS_UNDO_LOGICAL_TIME;
						pBandItem->SetTimeLogical( mtNewTimeLogical );

						fChanged = true;
					}
				}
			}

			// m_strName
			else if( pBand->m_strText.Compare( pBandItem->m_strText ) != 0 )
			{
				m_pBandStrip->m_nLastEdit = IDS_UNDO_BANDNAME;
				pBand->ApplyToBandItem( pBandItem );

				if( pBandItem->m_pIBandNode )
				{
					BSTR bstrBandName = pBandItem->m_strText.AllocSysString();
					pBandItem->m_pIBandNode->SetNodeName( bstrBandName );
					m_pDMProdFramework->RefreshNode( pBandItem->m_pIBandNode );
				}

				fChanged = true;
			}

			if( fChanged )
			{
				// Redraw the band strip
				m_pTimeline->StripInvalidateRect( m_pBandStrip, NULL, TRUE );

				// Let our hosting editor know about the changes
				m_pTimeline->OnDataChanged( (IBandMgr*)this );

				// Sequence strip will need to repaint FBar to catch latest DLS region wave names
				m_pTimeline->NotifyStripMgrs( GUID_Segment_BandTrackChange, m_dwGroupBits, NULL );

				// Update the property page
				if( m_pPropPageMgr )
				{
					m_pPropPageMgr->RefreshData();
				}

				SyncWithDirectMusic();
			}

			// pPropBand is a temp work field that has pointer
			// to the exact same m_pIBandNode interface as pBandItem.
			// Clean up pPropBand->m_pIBandNode now so that
			// CleanUpPropBand() does not close the Band editor
			if( pPropBand->m_pIBandNode )
			{
				pPropBand->m_pIBandNode->Release();
				pPropBand->m_pIBandNode = NULL;
			}
			CleanUpPropBand( pPropBand );
			delete pPropBand;
			return S_OK;
		}
		else
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CBandMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	// If we don't have a property page manager yet, create one.
	if( m_pPropPageMgr == NULL )
	{
		CBandPropPageMgr* pPPM = new CBandPropPageMgr( this );
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		
		m_pPropPageMgr->SetObject( this );
		
		// Remove the reference created by the contrustor, leaving the one created by QueryInterface.
		// If QueryInterface failed, this will delete m_pPropPageMgr.
		m_pPropPageMgr->Release();

		if( FAILED(hr) )
		{
			return hr;
		}
	}

	// Set the displayed property page to our property page
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr IDMUSProdBandMgrEdit implementation

/////////////////////////////////////////////////////////////////////////////
// CBandMgr::DisplayEditBandButton

HRESULT CBandMgr::DisplayEditBandButton( DWORD dwPChannel, LONG lXPos, 
									   LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTimeline && m_pBandStrip )
	{
		// Get 'now'
		MUSIC_TIME mtNow;
		if( FAILED( m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtNow ) ) )
		{
			return E_UNEXPECTED;
		}

		// Load the menu
		HMENU hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_BANDMENU) );
		HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

		// Get the band item to modify
		m_pBandItemForEditBandButton = NULL;
		m_dwPChannelForEditBandButton = dwPChannel;
		GetBandForPChannelAndTime( m_lstBands, dwPChannel, mtNow, &m_pBandItemForEditBandButton, NULL );

		// Enable the "New Instrument" item if this is true
		bool fEnableNewInstrument = true;

		// Look for a band at exactly tick -1 of the current beat
		long lMeasure, lBeat, lTmpTime;
		if( m_pBandItemForEditBandButton
		&&	SUCCEEDED( m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtNow, &lMeasure, &lBeat ) )
		&&	SUCCEEDED( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &lTmpTime ) ) )
		{
			lTmpTime--;

			// If we found a band that's after tick -1 of this beat, but before mtNow
			if( m_pBandItemForEditBandButton
			&&	m_pBandItemForEditBandButton->m_mtTimePhysical > lTmpTime )
			{
				// Disable the 'Insert New Instrument' option
				fEnableNewInstrument = false;
			}
		}

		::EnableMenuItem( hMenuPopup, ID_OPEN_BANDEDITOR, m_pBandItemForEditBandButton ? MF_ENABLED : MF_GRAYED );
		::EnableMenuItem( hMenuPopup, ID_LOCATE_BAND, m_pBandItemForEditBandButton ? MF_ENABLED : MF_GRAYED );
		::EnableMenuItem( hMenuPopup, ID_INSERT_NEWINSTRUMENT, fEnableNewInstrument ? MF_ENABLED : MF_GRAYED );

		// Display the menu
		m_pTimeline->TrackPopupMenu( hMenuPopup, lXPos, lYPos, m_pBandStrip, FALSE );

		// Cleanup
		::DestroyMenu( hMenu );

		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::AddBand

HRESULT STDMETHODCALLTYPE CBandMgr::AddBand( CBandItem* pBand )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	InsertByAscendingTime(pBand, FALSE);
	hr = SyncWithDirectMusic();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::SyncWithDirectMusic

HRESULT CBandMgr::SyncWithDirectMusic(  )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	// 1. persist the strip as a band track to a stream
	IStream* pIMemStream = NULL;
	IPersistStream* pIPersistStream = NULL;
	hr = m_pDMProdFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream );
	if( SUCCEEDED ( hr ) )
	{
		{
			StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
			hr = Save(pIMemStream, FALSE);
			if ( SUCCEEDED( hr ) )
			{
				// 2. load the stream into m_pIDMTrack
				hr = m_pIDMTrack->QueryInterface(IID_IPersistStream, (void**)&pIPersistStream);
				if ( SUCCEEDED( hr ) )
				{
					StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
					hr = pIPersistStream->Load(pIMemStream);

					if( m_pDMProdSegmentNode )
					{
						IDirectMusicSegment *pSegment;
						if( SUCCEEDED( m_pDMProdSegmentNode->GetObject(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&pSegment ) ) )
						{
							m_pIDMTrack->Init( pSegment );
							pSegment->Release();
						}
					}

					pIPersistStream->Release();
				}
			}
		}
		pIMemStream->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::OnRemoveFromPageManager

HRESULT STDMETHODCALLTYPE CBandMgr::OnRemoveFromPageManager( void)
{
	// If you want to do something special when your property page is no longer
	// displayed, do it here.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CBandMgr::OnDataChanged

HRESULT STDMETHODCALLTYPE CBandMgr::OnDataChanged( void)
{
	ASSERT( m_pTimeline );
	if ( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Let our hosting editor know about the change
	m_pTimeline->OnDataChanged( (IBandMgr*)this );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::DeleteSelectedBands

HRESULT CBandMgr::DeleteSelectedBands()
{
	CBandItem* pBandItem;
	POSITION pos2, pos1 = m_lstBands.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		pBandItem = m_lstBands.GetNext( pos1 );
		ASSERT( pBandItem );
		if ( pBandItem )
		{
			if ( pBandItem->m_fSelected )
			{
				m_lstBands.RemoveAt( pos2 );
				CleanUpPropBand( pBandItem );
				delete pBandItem;
			}
		}
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::SaveSelectedBands

HRESULT CBandMgr::SaveSelectedBands(LPSTREAM pIStream, MUSIC_TIME mtOffset, short nReason)
{
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// If the Band list has anything in it, look for selected Bands
	if ( !m_lstBands.IsEmpty() )
	{
		POSITION pos;
		MMCKINFO ckMain;

		// Create a LIST chunk to wrap the Bands
		ckMain.fccType = DMUS_FOURCC_BANDS_LIST;
		if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATELIST ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}


		pos = m_lstBands.GetHeadPosition();
		while( pos )
		{
			CBandItem* pBandItem;
			pBandItem = m_lstBands.GetNext( pos );
			ASSERT( pBandItem );
			if( pBandItem
			&&  pBandItem->m_pIBandNode
			&&  pBandItem->m_fSelected )
			{
				// Store each Band in its own chunk.
				hr = SaveBand( pIStream, pIRiffStream, pBandItem, mtOffset, nReason );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
			}
		}
		pIRiffStream->Ascend( &ckMain, 0 );
	}
	else
	{
		hr = S_FALSE; // Nothing in the list
	}

ON_ERROR:
	pIRiffStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::MarkSelectedBands

// marks m_dwUndermined field CBandItems in list
void CBandMgr::MarkSelectedBands( DWORD dwFlags )
{
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pBandItem;
		pBandItem = m_lstBands.GetNext( pos );
		ASSERT( pBandItem );
		if ( pBandItem )
		{
			if ( pBandItem->m_fSelected )
			{
				pBandItem->m_dwBits |= dwFlags;
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::DeleteMarked

// deletes bands marked by given flag
void CBandMgr::DeleteMarked( DWORD dwFlags )
{
	CBandItem* pBandItem;
	POSITION pos2, pos1 = m_lstBands.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		pBandItem = m_lstBands.GetNext( pos1 );
		ASSERT( pBandItem );
		if ( pBandItem )
		{
			if ( (pBandItem->m_dwBits & dwFlags) || !pBandItem->m_pIBandNode )
			{
				m_lstBands.RemoveAt( pos2 );
				CleanUpPropBand( pBandItem );
				delete pBandItem;
			}
		}
	}

	// Update the property page
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::UnMarkBands

// unmarks flag m_dwUndermined field CBandItems in list
void CBandMgr::UnMarkBands( DWORD dwFlags )
{
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pBandItem;
		pBandItem = m_lstBands.GetNext( pos );
		ASSERT( pBandItem );
		if ( pBandItem )
		{
			pBandItem->m_dwBits &= ~dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::UnselectAllKeepBits

void CBandMgr::UnselectAllKeepBits()
{
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pBandItem = m_lstBands.GetNext( pos );

		ASSERT( pBandItem );
		if( pBandItem )
		{
			pBandItem->m_fSelected = FALSE;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::UnselectAll

void CBandMgr::UnselectAll()
{
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pBandItem = m_lstBands.GetNext( pos );

		ASSERT( pBandItem );
		if ( pBandItem )
		{
			pBandItem->SetSelectFlag( FALSE );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::SelectAll

void CBandMgr::SelectAll()
{
	// UnselectAll to ensure only real bands are selected
	UnselectAll();
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pBandItem = m_lstBands.GetNext( pos );

		ASSERT( pBandItem );
		if ( pBandItem && pBandItem->m_pIBandNode )
		{
			pBandItem->SetSelectFlag( TRUE );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::IsSelected()

BOOL CBandMgr::IsSelected()
{
	// If anything real is selected, return TRUE.
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pBandItem = m_lstBands.GetNext( pos );

		ASSERT( pBandItem );
		if ( pBandItem )
		{
			if ( pBandItem->m_pIBandNode && pBandItem->m_fSelected )
			{
				return TRUE;
			}
		}
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CBandMgr::FirstSelectedBand

CBandItem* CBandMgr::FirstSelectedBand()
{
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pBandItem;
		pBandItem = m_lstBands.GetNext( pos );
		ASSERT( pBandItem );
		if ( pBandItem )
		{
			if ( pBandItem->m_fSelected )
			{
				return pBandItem;
			}
		}
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CBandMgr::FirstSelectedRealBand

CBandItem* CBandMgr::FirstSelectedRealBand()
{
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pBandItem = m_lstBands.GetNext( pos );

		if( pBandItem->m_fSelected
		&&  pBandItem->m_pIBandNode )
		{
			return pBandItem;
		}
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CBandMgr::CurrentlySelectedBand

CBandItem* CBandMgr::CurrentlySelectedBand()
{
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pBandItem;
		pBandItem = m_lstBands.GetNext( pos );
		ASSERT( pBandItem );
		if ( pBandItem )
		{
			if ( pBandItem->m_fSelected  && (pBandItem->m_dwBits & UD_CURRENTSELECTION))
			{
				return pBandItem;
			}
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::FindBand

CBandItem* CBandMgr::FindBand( long lMeasure, long lBeat ) const
{
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pBandItem = m_lstBands.GetNext( pos );

		if( pBandItem->m_dwMeasure == (DWORD)lMeasure
		&&  pBandItem->m_bBeat == (unsigned)lBeat )
		{
			return pBandItem;
		}
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::FindBandAtTime

CBandItem* CBandMgr::FindBandAtTime( MUSIC_TIME mtTime ) const
{
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pBandItem = m_lstBands.GetNext( pos );

		if( pBandItem->m_mtTimePhysical == mtTime )
		{
			return pBandItem;
		}
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::CreateUniqueName

BSTR CBandMgr::CreateUniqueName()
{
	// Get "Band" text
	CString strBand;
	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( _Module.GetModuleInstance() );
	strBand.LoadString( IDS_BAND_TEXT );
	AfxSetResourceHandle( hInstance );

	int n = 0;
	POSITION pos = m_lstBands.GetHeadPosition();
	while (pos)
	{
		CBandItem* pBandItem;
		pBandItem = m_lstBands.GetNext( pos );
		ASSERT( pBandItem );
		if ( pBandItem && pBandItem->m_pIBandNode )
		{
			n++;
		}
	}
	char szNum[4];
	CString strName;
	bool fUnique = false;
	while (!fUnique)
	{
		_itoa(n, szNum, 10);
		strName = strBand + szNum;
		fUnique = true;
		POSITION pos = m_lstBands.GetHeadPosition();
		while( pos )
		{
			CBandItem* pBandItem;
			pBandItem = m_lstBands.GetNext( pos );
			ASSERT( pBandItem );
			if ( pBandItem && pBandItem->m_pIBandNode )
			{
				if ( strName == pBandItem->m_strText )
				{
					fUnique = false;
					break;
				}
			}
		}
		n++;
	}
	return strName.AllocSysString();
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::SelectSegment

BOOL CBandMgr::SelectSegment(long lBeginTime, long lEndTime)
{
	ASSERT(m_pTimeline);
	if( !m_pTimeline )
	{
		return FALSE;
	}

	BOOL result = FALSE;
	if( lBeginTime == -1)
	{
		// till we implement m_lShiftFromMeasure (see CommandMgr::SelectSegment),
		// just set it to beginning
		lBeginTime = 0;
	}

	long lBeginMeas, lBeginBeat, lEndMeas, lEndBeat;
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lBeginTime, &lBeginMeas, &lBeginBeat );
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lEndTime, &lEndMeas, &lEndBeat );

	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pBandItem;
		pBandItem = m_lstBands.GetNext( pos );
		ASSERT( pBandItem );
		if ( pBandItem )
		{
			pBandItem->SetSelectFlag( FALSE );
			if( (unsigned)lBeginMeas < (signed)pBandItem->m_dwMeasure && (signed)pBandItem->m_dwMeasure < lEndMeas )
			{
				pBandItem->SetSelectFlag( TRUE );
				result = TRUE;
			}
			else if( lBeginMeas == (signed)pBandItem->m_dwMeasure )
			{
				if( lEndMeas == (signed)pBandItem->m_dwMeasure )
				{
					if( lBeginBeat <= pBandItem->m_bBeat && pBandItem->m_bBeat <= lEndBeat )
					{
						pBandItem->SetSelectFlag( TRUE );
						result = TRUE;
					}
				}
				else
				{
					if( lBeginBeat <= pBandItem->m_bBeat )
					{
						pBandItem->SetSelectFlag( TRUE );
						result = TRUE;
					}
				}
			}
			else if( lEndMeas == (signed)pBandItem->m_dwMeasure )
			{
				if( pBandItem->m_bBeat <= lEndBeat )
				{
					pBandItem->SetSelectFlag( TRUE );
					result = TRUE;
				}
			}
		}
	}
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::EmptyBandList

void CBandMgr::EmptyBandList(void)
{
	if( !m_lstBands.IsEmpty() )
	{
		CBandItem *pBandItem;
		while ( !m_lstBands.IsEmpty() )
		{
			pBandItem = m_lstBands.RemoveHead();
			CleanUpPropBand( pBandItem );
			delete pBandItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::InsertByAscendingTime

void CBandMgr::InsertByAscendingTime( CBandItem *pBand, BOOL fPaste )
{
	ASSERT( pBand );
	if ( pBand == NULL )
	{
		return;
	}

	CBandItem* pBandItem;
	POSITION posCurrent, posNext = m_lstBands.GetHeadPosition();
	while( posNext )
	{
		posCurrent = posNext;
		pBandItem = m_lstBands.GetNext( posNext );
		ASSERT( pBandItem );
		if( pBandItem )
		{
			if( fPaste )
			{
				if( pBandItem->m_mtTimePhysical == pBand->m_mtTimePhysical )
				{
					// replace item
					m_lstBands.InsertBefore( posCurrent, pBand );
					m_lstBands.RemoveAt( posCurrent );
					CleanUpPropBand( pBandItem );
					delete pBandItem;
					return;
				}
			}
			if( pBandItem->m_mtTimePhysical > pBand->m_mtTimePhysical )
			{
				// insert before posCurrent (which is the position of pBandItem)
				m_lstBands.InsertBefore( posCurrent, pBand );
				return;
			}
		}
	}
	// insert at end of list
	m_lstBands.AddTail( pBand );
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::RemoveItem

BOOL CBandMgr::RemoveItem( CBandItem* pItem )
{
	POSITION pos2;
	POSITION pos1 = m_lstBands.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		CBandItem* pAt = m_lstBands.GetNext( pos1 );
		if ( pAt == pItem )
		{
			m_lstBands.RemoveAt( pos2 );
			CleanUpPropBand( pAt );
			delete pAt;
			return TRUE;
		}
	}
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::RecomputeBandMeasureBeats

void CBandMgr::RecomputeBandMeasureBeats()
{
	// Recompute measure/beat of all Bands
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pBandItem = m_lstBands.GetNext( pos );

		pBandItem->SetTimePhysical( pBandItem->m_mtTimePhysical, STP_LOGICAL_ADJUST );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::GetNextGreatestUniqueTime

MUSIC_TIME CBandMgr::GetNextGreatestUniqueTime( long lMeasure, long lBeat, long lTick )
{
	DMUS_TIMESIGNATURE dmTimeSig;
	MUSIC_TIME mtTime;

	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pBandItem = m_lstBands.GetNext( pos );

		if( pBandItem->m_dwMeasure > (DWORD)lMeasure )
		{
			break;
		}

		MeasureBeatTickToClocks( pBandItem->m_dwMeasure, 0, 0, &mtTime );
		m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, mtTime, NULL, &dmTimeSig );
		if( pBandItem->m_bBeat > dmTimeSig.bBeatsPerMeasure )
		{
			break;
		}

		if( pBandItem->m_dwMeasure == (DWORD)lMeasure
		&&  pBandItem->m_bBeat == (unsigned)lBeat )
		{
			lTick = pBandItem->m_lTick + 1;

			// Take care of measure/beat rollover
			MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );  
			ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick );  
		}
	}

	MeasureBeatTickToClocks( lMeasure, lBeat, lTick, &mtTime );  
	return mtTime;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::RecomputeBandTimes

BOOL CBandMgr::RecomputeBandTimes()
{
	CBandItem* pBandItem;
	MUSIC_TIME mtTime;
	long lMeasure;
	long lBeat;
	long lTick;
	POSITION pos2;

	BOOL fChanged = FALSE;

	// For all items, call SetPropBandTime to update their m_mtTime member
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		pos2 = pos;
		pBandItem = m_lstBands.GetNext( pos );

		if( !pBandItem->m_pIBandNode )
		{
			m_lstBands.RemoveAt( pos2 );
			delete pBandItem;
		}
		// 26731: Need to skip items that have invalid measure and beat values.
		// This should only happen when this method is called before the AllTrackAdded
		// notification (which updates the measure and beat values to valid ones) was received.
		else if( (signed(pBandItem->m_dwMeasure) >= 0) && (signed(pBandItem->m_bBeat) >= 0) )
		{
			MeasureBeatTickToClocks( pBandItem->m_dwMeasure, pBandItem->m_bBeat, pBandItem->m_lTick, &mtTime );  
			ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick ); 

			if( pBandItem->m_mtTimePhysical != mtTime
			||	pBandItem->m_dwMeasure != (DWORD)lMeasure
			||	pBandItem->m_bBeat != (BYTE)lBeat
			||	pBandItem->m_lTick != lTick )
			{
				m_lstBands.RemoveAt( pos2 );

				if( pBandItem->m_dwMeasure != (DWORD)lMeasure )
				{
					// This would happen when moving from 7/4 to 4/4, for example
					// Bands on beat 7 would end up on next measure's beat 3
					while( pBandItem->m_dwMeasure != (DWORD)lMeasure )
					{
						// Keep moving back a beat until the measure does not change
						MeasureBeatTickToClocks( lMeasure, --lBeat, lTick, &mtTime );  
						ClocksToMeasureBeatTick( mtTime, &lMeasure, &lBeat, &lTick ); 
					}
				}

				mtTime = GetNextGreatestUniqueTime( lMeasure, lBeat, lTick ); 
				pBandItem->SetTimePhysical( mtTime, STP_LOGICAL_ADJUST );
				fChanged = TRUE;

				InsertByAscendingTime( pBandItem, FALSE );
			}
			else
			{
				// Recompute logical time measure/beat
				pBandItem->SetTimeLogical( pBandItem->m_mtTimeLogical );
			}
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::GetBoundariesOfSelectedBands

void CBandMgr::GetBoundariesOfSelectedBands( long *plStart, long *plEnd )
{
	ASSERT( plStart );
	ASSERT( plEnd );

	MUSIC_TIME mtTime;

	long lEnd = -MAX_TICK + -1;
	BOOL fSetStart = FALSE;

	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pItem = m_lstBands.GetNext( pos );

		if( pItem->m_fSelected )
		{
			MeasureBeatTickToClocks( pItem->m_dwMeasure, pItem->m_bBeat, 0, &mtTime );

			if( lEnd < mtTime )
			{
				lEnd = mtTime;
			}
			if( !fSetStart )
			{
				fSetStart = TRUE;
				*plStart = mtTime;
			}
		}
	}

	if( lEnd >= 0 )
	{
		if( lEnd <= *plStart )
		{
			lEnd = *plStart + 1;
		}
		*plEnd = lEnd;
	}
	else
	{
		*plStart = -1;
		*plEnd = -1;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::DeleteBetweenTimes

BOOL CBandMgr::DeleteBetweenTimes( long lStart, long lEnd )
{
	BOOL fChanged = FALSE;

	// Iterate through the list
	POSITION pos2, pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		// Save the current position
		pos2 = pos;
		CBandItem* pItem = m_lstBands.GetNext( pos );

		MUSIC_TIME mtTime;
		MeasureBeatTickToClocks( pItem->m_dwMeasure, pItem->m_bBeat, 0, &mtTime );

		// If the Band occurs between lStart and lEnd, delete it
		if( (mtTime >= lStart) && (mtTime <= lEnd) ) 
		{
			m_lstBands.RemoveAt( pos2 );
			CleanUpPropBand( pItem );
			delete pItem;
			fChanged = TRUE;
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::CanCycle

BOOL CBandMgr::CanCycle( long lXPos  )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	long lMeasure;
	long lBeat;
	HRESULT hr = m_pTimeline->PositionToMeasureBeat( m_dwGroupBits, 0, lXPos, &lMeasure, &lBeat );

	if( SUCCEEDED ( hr ) ) 
	{
		int nCount = 0;
		CBandItem* pBandItem;

		POSITION pos = m_lstBands.GetHeadPosition();
		while( pos )
		{
			pBandItem = m_lstBands.GetNext( pos );

			if( pBandItem->m_dwMeasure == (DWORD)lMeasure
			&&  pBandItem->m_bBeat == (unsigned)lBeat
			&&  pBandItem->m_strText.IsEmpty() == FALSE )
			{
				if( ++nCount > 1 )
				{
					return TRUE;
				}
			}

			if( pBandItem->m_dwMeasure > (DWORD)lMeasure )
			{
				break;
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::CycleBands

HRESULT CBandMgr::CycleBands( long lXPos  )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	long lMeasure;
	long lBeat;
	HRESULT hr = m_pTimeline->PositionToMeasureBeat( m_dwGroupBits, 0, lXPos, &lMeasure, &lBeat );

	if( SUCCEEDED ( hr ) ) 
	{
		CBandItem* pFirstBandItem = NULL;
		CBandItem* pSecondBandItem = NULL;
		CBandItem* pBandItem;

		hr = E_FAIL;

		POSITION pos = m_lstBands.GetHeadPosition();
		while( pos )
		{
			pBandItem = m_lstBands.GetNext( pos );

			if( pBandItem->m_dwMeasure == (DWORD)lMeasure
			&&  pBandItem->m_bBeat == (unsigned)lBeat
			&&  pBandItem->m_strText.IsEmpty() == FALSE )
			{
				if( pFirstBandItem == NULL )
				{
					pFirstBandItem = pBandItem;
				}
				else if( pSecondBandItem == NULL )
				{
					pSecondBandItem = pBandItem;
				}

				if( pBandItem->m_wFlags & BF_TOPBAND )
				{
					if( pos )
					{
						// Cycle to next Band if on same measure/beat
						CBandItem* pNextBandItem = m_lstBands.GetNext( pos );

						if( pNextBandItem->m_dwMeasure == (DWORD)lMeasure
						&&  pNextBandItem->m_bBeat == (unsigned)lBeat
						&&  pNextBandItem->m_strText.IsEmpty() == FALSE )
						{
							UnselectAll();
							pBandItem->m_wFlags &= ~BF_TOPBAND;
							pNextBandItem->SetSelectFlag( TRUE );
							pNextBandItem->m_wFlags |= BF_TOPBAND;
							hr = S_OK;
							break;
						}
					}

					// Cycle to first Band on same measure/beat
					UnselectAll();
					pBandItem->m_wFlags &= ~BF_TOPBAND;
					pFirstBandItem->SetSelectFlag( TRUE );
					pFirstBandItem->m_wFlags |= BF_TOPBAND;
					hr = S_OK;
					break;
				}
			}

			if( pBandItem->m_dwMeasure > (DWORD)lMeasure
			||  pos == NULL )
			{
				UnselectAll();
				if( pSecondBandItem )
				{
					pSecondBandItem->SetSelectFlag( TRUE );
					pSecondBandItem->m_wFlags |= BF_TOPBAND;
					hr = S_OK;
				}
				else if( pFirstBandItem )
				{
					pFirstBandItem->SetSelectFlag( TRUE );
					pFirstBandItem->m_wFlags |= BF_TOPBAND;
					hr = S_OK;
				}
				break;
			}
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		// Redraw the band strip
		m_pTimeline->StripInvalidateRect( m_pBandStrip, NULL, TRUE );

		// Update the property page
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::SetDocRootForAllBands

void CBandMgr::SetDocRootForAllBands()
{
	if( m_pBandStrip )
	{
		POSITION pos = m_lstBands.GetHeadPosition();
		while( pos )
		{
			CBandItem* pBandItem = m_lstBands.GetNext( pos );
			if( pBandItem->m_pIBandNode )
			{
				pBandItem->m_pIBandNode->SetDocRootNode( m_pBandStrip->m_pStripNode );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// MeasureBeatToBeats

HRESULT MeasureBeatToBeats( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lMeasure, long lBeat, long &lNumBeats )
{
	// Validate parameters
	ASSERT( pITimeline );
	ASSERT( dwGroupBits );
	ASSERT( lMeasure >= 0 );
	ASSERT( lBeat >= 0 );

	if( NULL == pITimeline )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	// Initialize variables
	HRESULT hr;
	DMUS_TIMESIGNATURE TimeSig;
	MUSIC_TIME mtTSCur = 0, mtTSNext = 1;

	// Initialize value to return
	lNumBeats = 0;

	// Loop until lMeasure is zero
	do
	{
		// Get the time signature at mtTSCur
		hr = pITimeline->GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, mtTSCur, &mtTSNext, &TimeSig );
		if ( FAILED( hr ) )
		{
			return E_UNEXPECTED;
		}

		// Check if this time signature is valid forever
		if( mtTSNext == 0 )
		{
			// Just compute the number of beats to add and break out of the loop
			lNumBeats += lMeasure * TimeSig.bBeatsPerMeasure;
			break;
		}
		else
		{
			// Compute the number of clocks in a measure
			long lMeasureClocks = TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );

			// Compute the number of measures until the next time signature
			long lTmpMeasures = mtTSNext / lMeasureClocks;

			// If we won't reach the next time signature
			if( lMeasure <= lTmpMeasures )
			{
				// Just compute the number of beats to add and break out of the loop
				lNumBeats += lMeasure * TimeSig.bBeatsPerMeasure;
				break;
			}
			else
			{
				// Compute when to look for the next time signature
				mtTSCur += lMeasureClocks * lTmpMeasures;

				// Compute the number of beats to add
				lNumBeats += lTmpMeasures * TimeSig.bBeatsPerMeasure;

				// Update the number of measures we have left to traverse
				lMeasure -= lTmpMeasures;
			}
		}
	}
	while( lMeasure > 0 );

	// We've compute all the beats from the lMeasure paramter - now just add lBeat
	lNumBeats += lBeat;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// BeatsToMeasureBeat

HRESULT BeatsToMeasureBeat( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lNumBeats, long &lMeasure, long &lBeat )
{
	// Validate parameters
	ASSERT( pITimeline );
	ASSERT( dwGroupBits );
	ASSERT( lNumBeats >= 0 );

	if( NULL == pITimeline )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	// Initialize variables
	DMUS_TIMESIGNATURE TimeSig;
	MUSIC_TIME mtTSCur = 0, mtTSNext;
	lBeat = 0;
	lMeasure = 0;

	do
	{
		// Try and get the current time signature
		if ( FAILED( pITimeline->GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, mtTSCur, &mtTSNext, &TimeSig ) ) )
		{
			return E_UNEXPECTED;
		}

		// If there is no next time signature, do the math to find how many more measures to add
		if( mtTSNext == 0 )
		{
			lMeasure += lNumBeats / TimeSig.bBeatsPerMeasure;
			lNumBeats %= TimeSig.bBeatsPerMeasure;
			break;
		}
		// Otherwise it's more complicated
		else
		{
			// Compute the number of clocks in a beat
			long lBeatClocks = NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );

			// If the next time signature is after the time we're looking for
			if( lNumBeats < mtTSNext / lBeatClocks )
			{
				// Add the number of complete measures between here and there
				lMeasure += lNumBeats / TimeSig.bBeatsPerMeasure;

				// lNumBeats now stores an offset from the beginning of the measure
				lNumBeats %= TimeSig.bBeatsPerMeasure;
				break;
			}
			// The next time signature is before the time we're looking for
			else
			{
				// Compute how many complete measures there are between now and the next Time signature
				long lMeasureDiff= mtTSNext / (TimeSig.bBeatsPerMeasure * lBeatClocks);

				// Add them to lMeasure
				lMeasure += lMeasureDiff;

				// Subtract off the number of beats between mtTSCur and mtTSNext
				lNumBeats -= lMeasureDiff * TimeSig.bBeatsPerMeasure;

				// Change lMeasureDiff from measures to clocks
				lMeasureDiff *= TimeSig.bBeatsPerMeasure * lBeatClocks;

				// Add the clocks of the measures between mtTSCur and mtTSNext to mtTSCur
				mtTSCur += lMeasureDiff;
			}
		}
	}
	// While the beats left is greater than 0
	while ( lNumBeats > 0 );

	// Any leftover beats are assigned to lBeat
	lBeat = lNumBeats;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandMgr::UpdateBandNodesWithAudiopath

void CBandMgr::UpdateBandNodesWithAudiopath( void )
{
	IUnknown *punkAudiopath = NULL;
	if( m_pSegmentState )
	{
		m_pSegmentState->GetObjectInPath( 0, DMUS_PATH_AUDIOPATH, 0, GUID_NULL, 0, IID_IUnknown, (void **)&punkAudiopath );
	}

	IDMUSProdBandEdit8a *pIDMUSProdBandEdit8a;
	POSITION pos = m_lstBands.GetHeadPosition();
	while( pos )
	{
		CBandItem* pBandItem = m_lstBands.GetNext( pos );

		if( pBandItem->m_pIBandNode
		&&	SUCCEEDED( pBandItem->m_pIBandNode->QueryInterface( IID_IDMUSProdBandEdit8a, (void **)&pIDMUSProdBandEdit8a ) ) )
		{
			pIDMUSProdBandEdit8a->SetAudiopath( punkAudiopath );
			pIDMUSProdBandEdit8a->Release();
		}
	}

	if( punkAudiopath )
	{
		punkAudiopath->Release();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandStripMgr\BandIO.cpp ===
#include "stdafx.h"
#include "BandIO.h"
#include "BandMgr.h"



CBandItem::CBandItem( CBandStrip* pBandStrip )
{
	m_fSelected = FALSE;
	m_pBandStrip = pBandStrip;
}

CBandItem::~CBandItem()
{
	// Must happen in CBanditem class - not CPropBand class
	// DeleteNode should only be called when CBandItem is deleted
	if( m_pIBandNode )
	{
		m_pIBandNode->DeleteNode( FALSE );
	}
}

BOOL CBandItem::After(const CBandItem& Band)
{
	if( m_mtTimePhysical > Band.m_mtTimePhysical )
	{
		return TRUE;
	}
	else if( m_dwMeasure > Band.m_dwMeasure )
	{
		return TRUE;
	}
	else if( m_dwMeasure == Band.m_dwMeasure )
	{
		if( m_bBeat > Band.m_bBeat )
		{
			return TRUE;
		}
		else if( m_bBeat == Band.m_bBeat )
		{
			if( m_lTick > Band.m_lTick )
			{
				return TRUE;
			}
		}
	}
	return FALSE;
}

BOOL CBandItem::Before(const CBandItem& Band)
{
	if( m_mtTimePhysical < Band.m_mtTimePhysical )
	{
		return TRUE;
	}
	if( m_dwMeasure < Band.m_dwMeasure )
	{
		return TRUE;
	}
	else if( m_dwMeasure == Band.m_dwMeasure )
	{
		if( m_bBeat < Band.m_bBeat )
		{
			return TRUE;
		}
		else if( m_bBeat == Band.m_bBeat )
		{
			if( m_lTick < Band.m_lTick )
			{
				return TRUE;
			}
		}
	}
	return FALSE;
}
	
void CBandItem::SetSelectFlag( BOOL fSelected )
{
	m_fSelected = fSelected;
	m_dwBits = 0;
}
	
HRESULT CBandItem::SetTimePhysical( MUSIC_TIME mtTimePhysical, short nAction )
{
	// Set item's physical time
	MUSIC_TIME mtOrigTimePhysical = m_mtTimePhysical;
	m_mtTimePhysical = mtTimePhysical;

	if( m_pBandStrip == NULL
	||  m_pBandStrip->m_pBandMgr == NULL 
	||  m_pBandStrip->m_pBandMgr->m_pTimeline == NULL )
	{
		if( nAction == STP_LOGICAL_NO_ACTION 
		||  nAction == STP_LOGICAL_RECALC_MEASURE_BEAT )
		{
			return S_OK;
		}
		else
		{
			ASSERT( 0 );
			return E_UNEXPECTED;
		}
	}

	// Set item's measure, beat, tick
	long lMeasure, lBeat, lTick;
	m_pBandStrip->m_pBandMgr->ClocksToMeasureBeatTick( m_mtTimePhysical, &lMeasure, &lBeat, &lTick );
	m_dwMeasure = lMeasure;
	m_bBeat = (BYTE)lBeat;
	m_lTick = lTick;

	// Set item's logical time
	switch( nAction )
	{
		case STP_LOGICAL_NO_ACTION:
			// Nothing to do
			break;

		case STP_LOGICAL_RECALC_MEASURE_BEAT:
			// Simply recalc item's logical measure/beat
			m_pBandStrip->m_pBandMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			break;

		case STP_LOGICAL_SET_DEFAULT:
			m_pBandStrip->m_pBandMgr->ClocksToMeasureBeatTick( m_mtTimePhysical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			m_pBandStrip->m_pBandMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &m_mtTimeLogical );
			break;

		case STP_LOGICAL_FROM_BEAT_OFFSET:
		{
			// Get track GroupBits
			DWORD dwGroupBits = m_pBandStrip->m_pBandMgr->GetGroupBits();

			// Snap new physical time to number of beats
			long lPhysicalBeats;
			m_pBandStrip->m_pBandMgr->ClocksToMeasureBeatTick( m_mtTimePhysical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pBandStrip->m_pBandMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Set item's new logical time
			long lNewLogicalBeats = lPhysicalBeats + m_mtTimeLogical;	// m_mtTimeLogical stores beat offset
			if( lNewLogicalBeats < 0 )
			{
				lNewLogicalBeats = 0;
			}
			BeatsToMeasureBeat( m_pBandStrip->m_pBandMgr->m_pTimeline, dwGroupBits, 0, lNewLogicalBeats, lMeasure, lBeat );
			m_pBandStrip->m_pBandMgr->ForceBoundaries( lMeasure, lBeat, 0, &m_mtTimeLogical );
			m_pBandStrip->m_pBandMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			m_pBandStrip->m_pBandMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &m_mtTimeLogical );
			break;
		}

		case STP_LOGICAL_ADJUST:
		{
			// Get track GroupBits
			DWORD dwGroupBits = m_pBandStrip->m_pBandMgr->GetGroupBits();

			// Snap original physical time to number of beats
			long lPhysicalBeats;
			m_pBandStrip->m_pBandMgr->ClocksToMeasureBeatTick( mtOrigTimePhysical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pBandStrip->m_pBandMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Convert logical time to number of beats
			long lLogicalBeats;
			m_pBandStrip->m_pBandMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pBandStrip->m_pBandMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lLogicalBeats );

			// Compute difference between original physical time and original logical time
			long lBeatDiff = lLogicalBeats - lPhysicalBeats;

			// Snap new physical time to number of beats
			m_pBandStrip->m_pBandMgr->ClocksToMeasureBeatTick( m_mtTimePhysical, &lMeasure, &lBeat, &lTick );
			MeasureBeatToBeats( m_pBandStrip->m_pBandMgr->m_pTimeline, dwGroupBits, 0, lMeasure, lBeat, lPhysicalBeats );

			// Set item's new logical time
			long lNewLogicalBeats = lPhysicalBeats + lBeatDiff;
			if( lNewLogicalBeats < 0 )
			{
				lNewLogicalBeats = 0;
			}
			BeatsToMeasureBeat( m_pBandStrip->m_pBandMgr->m_pTimeline, dwGroupBits, 0, lNewLogicalBeats, lMeasure, lBeat );
			m_pBandStrip->m_pBandMgr->ForceBoundaries( lMeasure, lBeat, 0, &m_mtTimeLogical );
			m_pBandStrip->m_pBandMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
			m_pBandStrip->m_pBandMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &m_mtTimeLogical );
			break;
		}

		default:
			ASSERT( 0 );	// Should not happen!
			break;
	}

	// Make sure item's logical time is not less than zero
	if( m_mtTimeLogical < 0 )
	{
		ASSERT( 0 );
		m_mtTimeLogical = 0;
	}
	ASSERT( m_lLogicalMeasure >= 0 );
	ASSERT( m_lLogicalBeat >= 0 );

	return S_OK;
}
	
HRESULT CBandItem::SetTimeLogical( MUSIC_TIME mtTimeLogical )
{
	// Make sure item's logical time is not less than zero
	if( mtTimeLogical < 0 )
	{
		ASSERT( 0 );
		mtTimeLogical = 0;
	}

	// Set item's logical time
	m_mtTimeLogical = mtTimeLogical;

	if( m_pBandStrip == NULL
	||  m_pBandStrip->m_pBandMgr == NULL 
	||  m_pBandStrip->m_pBandMgr->m_pTimeline == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Set item's logical measure, beat
	long lTick;
	m_pBandStrip->m_pBandMgr->ClocksToMeasureBeatTick( m_mtTimeLogical, &m_lLogicalMeasure, &m_lLogicalBeat, &lTick );
	m_pBandStrip->m_pBandMgr->MeasureBeatTickToClocks( m_lLogicalMeasure, m_lLogicalBeat, 0, &m_mtTimeLogical );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandStripMgr\BandStripMgr.cpp ===
// BandStripMgr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f BandStripMgrps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "BandStripMgr.h"
#include <AFXCTL.H>

#include <initguid.h>
#include "BandMgr.h"
#include <SegmentGuids.h>
#include <dmusici.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_BandMgr, CBandMgr)
END_OBJECT_MAP()

class CBandStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CBandStripMgrApp theApp;

BOOL CBandStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	return CWinApp::InitInstance();
}

int CBandStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DMUSProducer strip managers

static BOOL RegisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[256];
	TCHAR	 szStripManager[32];
	TCHAR	 szUserName[32];
    TCHAR    szEditorGuid[100];
	TCHAR	 szTrackGuid[100];
    CString  strTrackName, strEditorName;
    TCHAR    szComponentPath[256];
    
	_tcscpy( szStripManager, _T("StripManager") );
	_tcscpy( szUserName, _T("UserName") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
	
    if( SUCCEEDED( StringFromIID(CLSID_BandMgr, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorGuid, sizeof(szEditorGuid), NULL, NULL );
        CoTaskMemFree( psz );
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicBandTrack, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackGuid, sizeof(szTrackGuid), NULL, NULL );
			CoTaskMemFree( psz );

			strTrackName.LoadString( IDS_TRACK_NAME );
			_tcscpy( szRegPath, szComponentPath );
			_tcscat( szRegPath, szTrackGuid );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szStripManager, szEditorGuid)) )
			{
				return FALSE;
			}
			strEditorName.LoadString( IDS_EDITOR_NAME );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szUserName, strEditorName)) )
			{
				return FALSE;
			}
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[255];
	TCHAR    szGuid[100];
	
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicBandTrack, &psz) ) )
   	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_BANDSTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandStripMgr\PropBand.h ===
#ifndef __PROPBAND_H_
#define __PROPBAND_H_

#include <dmusprod.h>
#include <dmusici.h>

#define MAX_TICK (DMUS_PPQ << 1)

class CBandItem;

class CPropBand 
{
public:
				CPropBand( );
				CPropBand( const CBandItem *pBandItem );
				~CPropBand( );
	void		ApplyToBandItem( CBandItem *pBandItem ) const;

	long			m_mtTimePhysical;	// Time of measure/beat/tick
    DWORD			m_dwMeasure;		// What measure this band falls on
    BYTE			m_bBeat;			// What beat this band falls on
	long			m_lTick;			// What tick this band falls on

	long			m_mtTimeLogical;	// Time of measure/beat 
	long			m_lLogicalMeasure;	// What measure this band belongs to
	long			m_lLogicalBeat;		// What beat this band belongs to
	
	DWORD			m_dwBits;			// Various bits used for selection
	WORD			m_wFlags;			// Various flags
	CString			m_strText;			// Text contained in this band event
	IDMUSProdNode*	m_pIBandNode;
};

// m_dwBits
#define UD_DRAGSELECT		0x0001
#define UD_CURRENTSELECTION 0x0002
#define UD_COPYSELECT		0x0004

// m_wFlags
#define BF_TOPBAND			0x0001

#endif // __PROPBAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandStripMgr\BandMgr.h ===
// BandMgr.h : Declaration of the CBandMgr

#ifndef __BANDMGR_H_
#define __BANDMGR_H_

#include "resource.h"		// main symbols
#include "BandStripMgr.h"
#include "timeline.h"
#include "PropBand.h"
#include <DMUSProd.h>
#include <afxtempl.h>
#include <BandEditor.h>
#include <mmsystem.h>

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0
#define NOTE_TO_CLOCKS(note, ppq) ( (ppq)*4 /(note) )
#define CF_BANDTRACK "DMUSProd v.1 Band Track"

#define TRACKCONFIG_VALID_MASK (  DMUS_TRACKCONFIG_CONTROL_ENABLED | DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)

// Used by SaveSelectedBands()
#define SSB_COPY	1
#define SSB_DRAG	2

//class CBandComponent;
class CBandStrip;
class CBandItem;
interface IDirectMusicTrack;
interface IDMUSProdRIFFStream;
interface IDirectMusicPerformance;

HRESULT MeasureBeatToBeats( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lMeasure, long lBeat, long &lNumBeats );
HRESULT BeatsToMeasureBeat( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lNumBeats, long &lMeasure, long &lBeat );
POSITION GetFirstValidBand( POSITION pos, const CTypedPtrList<CPtrList, CBandItem*> &lstBands );
bool GetBandForPChannelAndTime( const CTypedPtrList<CPtrList, CBandItem*> &lstBands, DWORD dwPChannel, MUSIC_TIME mtTime, CBandItem **ppBandItem, CBandItem **ppBandItemNext );
/////////////////////////////////////////////////////////////////////////////
// CBandMgr
class ATL_NO_VTABLE CBandMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CBandMgr, &CLSID_BandMgr>,
	public IBandMgr,
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdBandMgrEdit,
	public IDMUSProdPropPageObject
{
friend CBandStrip;

public:
	CBandMgr();
	~CBandMgr();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_BANDMGR)

BEGIN_COM_MAP(CBandMgr)
	COM_INTERFACE_ENTRY_IID(IID_IBandMgr,IBandMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY_IID(IID_IDMUSProdBandMgrEdit,IDMUSProdBandMgrEdit)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr methods
	HRESULT STDMETHODCALLTYPE IsParamSupported( REFGUID guidType );
	HRESULT STDMETHODCALLTYPE GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );
	HRESULT STDMETHODCALLTYPE SetParam( REFGUID guidType, MUSIC_TIME mtTime, void* pData );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT* pVariant );
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// IBandMgr methods
	HRESULT STDMETHODCALLTYPE IsMeasureBeatOpen( DWORD dwMeasure, BYTE bBeat );

// IPersist methods
	STDMETHOD(GetClassID)( CLSID* pClsId );

// IPersistStream methods
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
	STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdBandMgrEdit methods
    HRESULT STDMETHODCALLTYPE DisplayEditBandButton( DWORD dwPChannel, LONG lXPos, LONG lYPos );

// IDMUSProdPropPageObject methods
	HRESULT STDMETHODCALLTYPE GetData( void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

protected:
	HRESULT STDMETHODCALLTYPE OnDataChanged();
	BSTR	CreateUniqueName();
	void	EmptyBandList();
	void	InsertByAscendingTime(CBandItem *pBand, BOOL fPaste);
	void	RecomputeBandMeasureBeats();
	BOOL	RecomputeBandTimes();
	void	SetDocRootForAllBands();

	BOOL	SelectSegment(long begintime, long endtime);

protected:
	CTypedPtrList<CPtrList, CBandItem*> m_lstBands;
	IDMUSProdFramework* 		m_pDMProdFramework;
	IDMUSProdNode*				m_pDMProdSegmentNode;
	IDMUSProdPropPageManager*	m_pPropPageMgr;
	IDataObject*				m_pCopyDataObject;
	DWORD						m_dwGroupBits;
	DWORD						m_dwOldGroupBits;
	DWORD						m_dwTrackExtrasFlags;
	DWORD						m_dwProducerOnlyFlags;
	IDirectMusicTrack*			m_pIDMTrack;
	BOOL						m_fDirty;
	bool						m_bAutoDownload;
	IDirectMusicPerformance*	m_pIPerformance;
	CBandStrip*					m_pBandStrip;
	CBandItem*					m_pBandItemForEditBandButton;
	DWORD						m_dwPChannelForEditBandButton;
	bool						m_fNoUpdateSegment;
	IDirectMusicSegmentState8*	m_pSegmentState;

public:
	IDMUSProdTimeline*			m_pTimeline;

protected:
	void CleanUpPropBand( CPropBand* pPropBand );
	HRESULT CreateBand( DWORD dwMeasure, BYTE bBeat, CBandStrip* pBandStrip, CBandItem*& rpBand );
	HRESULT CreateBand( long lXPos, CBandStrip* pBandStrip, CBandItem*& rpBand );
	HRESULT SaveBandWrapper( IStream* pIStream, IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveBand( IStream* pIStream, IDMUSProdRIFFStream* pIRiffStream, CBandItem* pBandItem, MUSIC_TIME mtOffset, short nReason );
	HRESULT BuildDirectMusicBandList(IStream* pStream,
										      IDMUSProdRIFFStream *pIDirectMusicStream,
										      MMCKINFO& ckParent,
											  BOOL& fChanged,
											  bool fPaste = false,
											  MUSIC_TIME mtPasteTime = 0);
	HRESULT ExtractBand(IStream* pStream, 
								 IDMUSProdRIFFStream *pIDirectMusicStream, 
								 MMCKINFO& ckParent,
								 bool fPaste = false,
								 MUSIC_TIME mtPasteTime = 0);
	HRESULT DeleteSelectedBands();
	HRESULT SaveSelectedBands(LPSTREAM pIStream, MUSIC_TIME mtOffset, short nReason);

// general helpers
	void MarkSelectedBands(DWORD flags);
	void UnMarkBands(DWORD flags);
	void DeleteMarked(DWORD flags);
	void UnselectAllKeepBits();
	void UnselectAll();
	void SelectAll();
	BOOL RemoveItem( CBandItem* pItem );
	BOOL CanCycle( long lXPos );
	HRESULT CycleBands( long lXPos );
	void UpdateBandNodesWithAudiopath( void );

public:
// general helpers
	HRESULT ClocksToMeasureBeatTick( MUSIC_TIME mtTime, long* plMeasure, long* plBeat, long* plTick );
	HRESULT MeasureBeatTickToClocks( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmtTime );
	HRESULT ForceBoundaries( long lMeasure, long lBeat, long lTick, MUSIC_TIME* pmtTime );
	DWORD	GetGroupBits();
	bool    IsRefTimeTrack();

protected:
// Misc
	BOOL	IsSelected();	// returns if one or more bands are selected.
	CBandItem* FirstSelectedBand();
	CBandItem* FirstSelectedRealBand();
	CBandItem* CurrentlySelectedBand();
	HRESULT STDMETHODCALLTYPE AddBand(  CBandItem* pBand  );
	CBandItem* FindBand(long lMeasure, long lBeat) const;
	CBandItem* FindBandAtTime(MUSIC_TIME mtTime) const;
	HRESULT SyncWithDirectMusic();
	void GetBoundariesOfSelectedBands( long *plStart, long *plEnd );
	BOOL DeleteBetweenTimes( long lStart, long lEnd );
	MUSIC_TIME GetNextGreatestUniqueTime( long lMeasure, long lBeat, long lTick );
};


class CBandStrip :
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdTimelineEdit,
	public IDropSource,
	public IDropTarget,
	public IDMUSProdPropPageObject
{
friend CBandMgr;

public:
	CBandStrip( CBandMgr* pBandMgr );
	~CBandStrip();

public:
// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

// IDMUSProdStrip
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit
	HRESULT STDMETHODCALLTYPE Cut( IDMUSProdTimelineDataObject *pIDataObject );
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject *pIDataObject );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDropSource
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );

// IDropSource helpers
	CImageList* CreateDragImage();
	HRESULT 	CreateDataObject(IDataObject**, long position);

// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

// IDropTarget helpers
	CWnd*	GetTimelineCWnd();
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteReplace( long firstMeasure, long firstBeat, long lastMeasure, long lastBeat);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pIDataObject, MUSIC_TIME mtPasteTime, BOOL bDropNotEditPaste, BOOL &fChanged);

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

// Misc. functions
	HRESULT AddBandNode( IDMUSProdNode* pIBandNode, MUSIC_TIME mtTime );
	HRESULT RightClickMenuCanSelectAll();
	void OnDragRMenuMove(  );
	void OnDragRMenuCopy(  );
	void OnDragRMenuCancel(  );
	IDMUSProdNode* GetStripNode() { return m_pStripNode; }
	IDMUSProdFramework* GetFramework()
	{ 
		return (m_pBandMgr) ? m_pBandMgr->m_pDMProdFramework : NULL;
	}

protected:
// Internal message handlers
	HRESULT OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	BOOL DoDragDrop();

	long				m_cRef;
	LONG				m_lBeginSelect;
	LONG				m_lEndSelect;
	IDMUSProdStripMgr*	m_pStripMgr;
	BOOL				m_bGutterSelected;	// whether the gutter select is selected
	BOOL				m_bSelecting;
	BOOL				m_bContextMenuPaste;

private:
	HRESULT		SelectRange(CBandItem* pBand);
	HRESULT		ShowPropertySheet(IDMUSProdTimeline*);
	void		UnselectGutterRange( void );
	CBandItem*  GetBandFromPoint( long lPos );
	CBandItem*  GetTopBandFromMeasureBeat( DWORD dwMeasure, BYTE bBeat );
	long		GetBeatWidth( DWORD dwMeasure );
	LONG		m_lXPos;				// used for temp storage of xpos when doing mouse edits

	IDataObject*m_pISourceDataObject;	// Object being dragged 
	IDataObject*m_pITargetDataObject;
	short		m_nStripIsDragDropSource;	
	DWORD		m_dwStartDragButton;	// Mouse button that initiated drag operation
	DWORD		m_dwOverDragButton; 	// Mouse button stored in IDropTarget::DragOver
	DWORD		m_dwOverDragEffect; 	// Drag effects stored in IDropTarget::DragOver
	CImageList* m_pDragImage;			// Image used for drag operation feedback
	DWORD		m_dwDragRMenuEffect;	// Result from drag context menu
	UINT		m_cfBand;				// Clipboard format
	UINT		m_cfBandTrack;			// Clipboard format
	LONG		m_lStartDragPosition;	// xpos where drag was started
	UINT		m_nLastEdit;			// resource id of last edit
	BOOL		m_fShowBandProps;		// if TRUE, show Band property page, else show group property page
	BOOL		m_fPropPageActive;		// TRUE if our property page is active
	BOOL		m_fSingleSelect;		
	IDMUSProdPropPageManager*	m_pPropPageMgr;
	IDMUSProdNode* m_pStripNode;

public:
	CBandMgr*	m_pBandMgr;
};
#endif //__BANDMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandStripMgr\BandStrip.cpp ===
// BandStrip.cpp : Implementation of CBandStrip
#include "stdafx.h"
#include "BandIO.h"
#include "BandStripMgr.h"
#include "BandMgr.h"
#include "PropPageMgr.h"
#include "DLLJazzDataObject.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include <SegmentGuids.h>
#include <RiffStrm.h>
#include <dmusicf.h>
#include "musictimeconverter.h"
#include "SegmentIO.h"
#include "GrayOutRect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define STRIP_HEIGHT 20

//BEGIN_MESSAGE_MAP(CBandStrip)
//	//{{AFX_MSG_MAP(CBandStrip)
//	ON_WM_SIZE()
//	ON_WM_DESTROY()
//	ON_COMMAND(IDM_DRAG_MOVE, OnDragRMenuMove)
//	ON_COMMAND(IDM_DRAG_COPY, OnDragRMenuCopy)
//	ON_COMMAND(IDM_DRAG_CANCEL, OnDragRMenuCancel)
//	ON_WM_DROPFILES()
//	//}}AFX_MSG_MAP
//END_MESSAGE_MAP()

void SendAudiopathToNode( IDMUSProdNode* pIBandNode, IDirectMusicSegmentState8 *pSegmentState8 )
{
	if( pIBandNode == NULL )
	{
		return;
	}

	IUnknown *punkAudiopath = NULL;
	if( pSegmentState8 )
	{
		pSegmentState8->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_AUDIOPATH, 0, GUID_NULL, 0, IID_IUnknown, (void **)&punkAudiopath );
	}

	IDMUSProdBandEdit8a *pIDMUSProdBandEdit8a;
	if( SUCCEEDED( pIBandNode->QueryInterface( IID_IDMUSProdBandEdit8a, (void **)&pIDMUSProdBandEdit8a ) ) )
	{
		pIDMUSProdBandEdit8a->SetAudiopath( punkAudiopath );
		pIDMUSProdBandEdit8a->Release();
	}

	if( punkAudiopath )
	{
		punkAudiopath->Release();
	}
}

CString GetName(DWORD dwGroupBits, CString strName)
{
	CString strText, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}

	return strText + CString(": ") + strName;
}

void CBandStrip::OnDragRMenuMove(  )
{
	m_dwDragRMenuEffect = DROPEFFECT_MOVE;
}

void CBandStrip::OnDragRMenuCopy(  )
{
	m_dwDragRMenuEffect = DROPEFFECT_COPY;
}

void CBandStrip::OnDragRMenuCancel(  )
{
	m_dwDragRMenuEffect = DROPEFFECT_NONE;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip constructor/destructor

CBandStrip::CBandStrip( CBandMgr* pBandMgr )
{
	ASSERT( pBandMgr );
	if ( pBandMgr == NULL )
	{
		return;
	}

	m_pBandMgr = pBandMgr;
	m_pStripMgr = (IDMUSProdStripMgr*)pBandMgr;
	//m_pStripMgr->AddRef();

	// initialize our reference count
	m_cRef = 0;
	AddRef();

	m_lXPos = -1;
	m_bGutterSelected = FALSE;
	m_bSelecting = FALSE;
	m_bContextMenuPaste = FALSE;
	m_lBeginSelect = 0;
	m_lEndSelect = 0;
	m_pISourceDataObject = NULL;
	m_pITargetDataObject = NULL;
	m_nStripIsDragDropSource = 0;
	m_dwStartDragButton = 0;
	m_lStartDragPosition = 0;
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;
	m_pDragImage = NULL;
	m_dwDragRMenuEffect = DROPEFFECT_NONE;
	m_nLastEdit = 0;
	m_fShowBandProps = FALSE;
	m_fPropPageActive = FALSE;
	m_fSingleSelect = FALSE;
	m_pPropPageMgr = NULL;
	m_pStripNode = NULL;
}

CBandStrip::~CBandStrip()
{
	ASSERT( m_pStripMgr );
	if ( m_pStripMgr )
	{
		//m_pStripMgr->Release();
		m_pStripMgr = NULL;
		m_pBandMgr = NULL;
	}

	RELEASE( m_pISourceDataObject );
	RELEASE( m_pITargetDataObject );
	RELEASE( m_pPropPageMgr );
	RELEASE( m_pStripNode );
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CBandStrip::QueryInterface

STDMETHODIMP CBandStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	ASSERT( ppv );
	if ( ppv == NULL )
	{
		return E_INVALIDARG;
	}

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip*) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
        *ppv = (IUnknown *) (IDMUSProdStripFunctionBar *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdPropPageObject))
	{
        *ppv = (IUnknown *) (IDMUSProdPropPageObject *) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdTimelineEdit ))
	{
		*ppv = (IDMUSProdTimelineEdit*) this;
	}
	else if( IsEqualIID( riid, IID_IDropSource ))
	{
		*ppv = (IDropSource*) this;
	}
	else if( IsEqualIID( riid, IID_IDropTarget ))
	{
		*ppv = (IDropTarget*) this;
	}
	else
	{
		return E_NOTIMPL;
	}

    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::AddRef

STDMETHODIMP_(ULONG) CBandStrip::AddRef(void)
{
	return ++m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::Release

STDMETHODIMP_(ULONG) CBandStrip::Release(void)
{
	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::GetBeatWidth

long CBandStrip::GetBeatWidth( DWORD dwMeasure )
{
	ASSERT( m_pBandMgr->m_pTimeline != NULL );

	// Determine width of a beat
	long lBeatBeginPosition = 0;
	m_pBandMgr->m_pTimeline->MeasureBeatToPosition( m_pBandMgr->m_dwGroupBits, 0,
												    dwMeasure, 0, &lBeatBeginPosition );

	long lBeatEndPosition = 0;
	m_pBandMgr->m_pTimeline->MeasureBeatToPosition( m_pBandMgr->m_dwGroupBits, 0,
													dwMeasure, 1, &lBeatEndPosition );
	
	return (lBeatEndPosition - lBeatBeginPosition);
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// CBandStrip::Draw

bool IsRealBand(CBandItem* pBand)
{
	ASSERT(pBand);
	if(!pBand)
		return false;
	return (pBand->m_strText.IsEmpty() == FALSE) ? true : false;
}

HRESULT	STDMETHODCALLTYPE CBandStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CDC	dc;

	bool fUseGutterSelectRange = m_bGutterSelected && m_lBeginSelect != m_lEndSelect;

	// Get a pointer to the Timeline
	if( m_pBandMgr->m_pTimeline )
	{
		// Draw Measure and Beat lines in our strip
		m_pBandMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, m_pBandMgr->m_dwGroupBits, 0, lXOffset );

		// Attach to our device context
		if( dc.Attach(hDC) )
		{
			CRect	rectClip, rectHighlight;
			long	lPosition;
			CBandItem* pBandItem;
			CBandItem* pTopBandItem;
			CBandItem* pNextBandItem;
			DWORD dwCurrentMeasure = 0xFFFFFFFF;
			BYTE bCurrentBeat = 0xFF;
			CSize	csize;
			POSITION posNext;
			POSITION pos;

			// ghost band vars
			CBandItem*	pGhostBand = NULL;
			long lFirstVisibleMeasure, lPartialVisibleMeasure;
			long lFirstVisibleBeat, lPartialVisibleBeat;
			long lClocks;
			RECT rectGhost;
			CString strGhost;
			bool bUseItalicsForGhost = false;
			bool bGhostBandCovered = false;	// indicates real band covering ghost band

			// Get clip box
			dc.GetClipBox( &rectClip );
			rectHighlight.top = 0;
			rectHighlight.bottom = STRIP_HEIGHT;
			rectGhost.top = 0;
			rectGhost.bottom = STRIP_HEIGHT;

			// Create Italics font
			BOOL fHaveItalics = FALSE;
			CFont fontItalics;
			CFont* pFont;
			LOGFONT logfont;
			pFont = dc.GetCurrentFont();
			if( pFont )
			{
				pFont->GetLogFont( &logfont );
				logfont.lfItalic = TRUE;
				if( fontItalics.CreateFontIndirect( &logfont ) )
				{
					fHaveItalics = TRUE;
				}
			}

			// find first visible measure/beat for ghosting bands
			m_pBandMgr->m_pTimeline->GetMarkerTime(MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lClocks);
			CMusicTimeConverter cmtFirstVisible(lClocks);
			cmtFirstVisible.GetMeasureBeat(lPartialVisibleMeasure, lPartialVisibleBeat,
											m_pBandMgr->m_pTimeline, m_pBandMgr->m_dwGroupBits);
			CMusicTimeConverter cmtNearestMeasureBeat(lPartialVisibleMeasure, lPartialVisibleBeat, 
											m_pBandMgr->m_pTimeline, m_pBandMgr->m_dwGroupBits);
			if(cmtNearestMeasureBeat.Time() < cmtFirstVisible.Time())
			{
				// round up
				cmtNearestMeasureBeat.AddOffset(0, 1, m_pBandMgr->m_pTimeline, m_pBandMgr->m_dwGroupBits);
				cmtNearestMeasureBeat.GetMeasureBeat(lFirstVisibleMeasure, lFirstVisibleBeat, 
													m_pBandMgr->m_pTimeline, m_pBandMgr->m_dwGroupBits);
			}
			else
			{
				lFirstVisibleMeasure = lPartialVisibleMeasure;
				lFirstVisibleBeat = lPartialVisibleBeat;
			}

			// find nearest band before first visible measure/beat
			pos = m_pBandMgr->m_lstBands.GetHeadPosition();
			while( pos )
			{
				pBandItem = m_pBandMgr->m_lstBands.GetNext(pos);
				if(pBandItem->m_dwMeasure > (DWORD)lFirstVisibleMeasure
					|| ((pBandItem->m_dwMeasure == (DWORD)lFirstVisibleMeasure) && (pBandItem->m_bBeat >= (DWORD)lFirstVisibleBeat)))
				{
					break;
				}
//				else
//				{
					// we may override this later
//					bUseItalicsForGhost = false;
//				}
				m_pBandMgr->m_pTimeline->MeasureBeatToPosition( m_pBandMgr->m_dwGroupBits, 0, 
									pBandItem->m_dwMeasure, pBandItem->m_bBeat, &lPosition );
				lPosition++;
				
				if( pBandItem->m_dwMeasure != dwCurrentMeasure
				||  pBandItem->m_bBeat != bCurrentBeat )
				{
					dwCurrentMeasure = pBandItem->m_dwMeasure;
					bCurrentBeat = pBandItem->m_bBeat;

					pTopBandItem = GetTopBandFromMeasureBeat( dwCurrentMeasure, bCurrentBeat );
					if(pTopBandItem)
					{
						if(IsRealBand(pTopBandItem))
						{
							bUseItalicsForGhost = false;	// may be overridden later
							pGhostBand = pTopBandItem;
							if(pTopBandItem != pBandItem && IsRealBand(pBandItem))
							{
								bUseItalicsForGhost = true;
							}
							else
							{
								// either pBandItem is the top band of many or it is a singleton
								// in either case we must get to the end of list of measure/beat
								// coincident bands
								posNext = pos;
								while(posNext)
								{
									pNextBandItem = m_pBandMgr->m_lstBands.GetNext(posNext);
									if(pNextBandItem->m_dwMeasure != dwCurrentMeasure
										|| pNextBandItem->m_bBeat != bCurrentBeat)
									{
										//end of measure/beat coincident bands
										posNext = NULL;
									}
									else
									{
										if(pNextBandItem != pTopBandItem
											&& IsRealBand(pNextBandItem))
										{
											bUseItalicsForGhost = true;
										}
									}
								}
							}
						}
					}
				}
			}

			if(pGhostBand)
			{
				// get rect of ghost band's text, we may have to truncate it if it covers real band
				m_pBandMgr->m_pTimeline->MeasureBeatToPosition( m_pBandMgr->m_dwGroupBits, 0, 
									lFirstVisibleMeasure, lFirstVisibleBeat, &lPosition );
				lPosition++;
				CSize csize;
				csize = dc.GetTextExtent(pGhostBand->m_strText);
				rectGhost.left = lPosition-lXOffset;
				rectGhost.right = rectGhost.left + csize.cx;
			}

			// we'll draw the ghost after checking whether or not band covers it

			// Draw the names of all Bands in the strip
			dwCurrentMeasure = 0xFFFFFFFF;
			bCurrentBeat = 0xFF;
			pos = m_pBandMgr->m_lstBands.GetHeadPosition();
			while( pos )
			{
				pBandItem = m_pBandMgr->m_lstBands.GetNext( pos );

				m_pBandMgr->m_pTimeline->MeasureBeatToPosition( m_pBandMgr->m_dwGroupBits, 0, 
									pBandItem->m_dwMeasure, pBandItem->m_bBeat, &lPosition );
				lPosition++;
				
				if( pBandItem->m_dwMeasure != dwCurrentMeasure
				||  pBandItem->m_bBeat != bCurrentBeat )
				{
					dwCurrentMeasure = pBandItem->m_dwMeasure;
					bCurrentBeat = pBandItem->m_bBeat;

					pTopBandItem = GetTopBandFromMeasureBeat( dwCurrentMeasure, bCurrentBeat );
					ASSERT( pTopBandItem != NULL );		// Should never be NULL!
					if( pTopBandItem )
					{
						CFont* pFontOld = NULL;
						if( fHaveItalics )
						{
							if( pTopBandItem->m_strText.IsEmpty() == FALSE )
							{
								if( pTopBandItem != pBandItem
								&&  pBandItem->m_strText.IsEmpty() == FALSE )
								{
									pFontOld = dc.SelectObject( &fontItalics );
								}
								else
								{
									posNext = pos;
									while( posNext )
									{
										pNextBandItem = m_pBandMgr->m_lstBands.GetNext( posNext );

										if( pNextBandItem->m_dwMeasure != dwCurrentMeasure
										||  pNextBandItem->m_bBeat != bCurrentBeat )
										{
											posNext = NULL;
										}
										else
										{
											if( pNextBandItem != pTopBandItem
											&&  pNextBandItem->m_strText.IsEmpty() == FALSE )
											{
												pFontOld = dc.SelectObject( &fontItalics );
												posNext = NULL;
											}
										}
									}
								}
							}
						}

						// Determine width of a beat
						long lBeatLength = GetBeatWidth( pTopBandItem->m_dwMeasure );

						// Find extent of text
						csize = dc.GetTextExtent( pTopBandItem->m_strText );
						if( csize.cx < lBeatLength )
						{
							csize.cx = lBeatLength;
						}
						long lExtent = lPosition + csize.cx;

						// Truncate if next Band covers part of text
						POSITION pos2 = pos;
						CBandItem* pTempBand;
						bool fDone = false;
						while( pos2 && !fDone )
						{
							pTempBand = m_pBandMgr->m_lstBands.GetNext( pos2 );

							if( pTempBand->m_strText.IsEmpty() == FALSE )
							{
								if( pTempBand->m_dwMeasure != dwCurrentMeasure
								||  pTempBand->m_bBeat != bCurrentBeat )
								{
									long lRPos;
									m_pBandMgr->m_pTimeline->MeasureBeatToPosition( m_pBandMgr->m_dwGroupBits, 0, 
										pTempBand->m_dwMeasure, pTempBand->m_bBeat, &lRPos );
									if( lRPos <= lExtent )
									{
										lExtent = lRPos;
									}
									fDone = true;
								}
							}
						}


						rectHighlight.left = lPosition - lXOffset;
						rectHighlight.right = lExtent - lXOffset;

						// truncate ghost band if necessary
						if(pGhostBand)
						{
							bool b1 = pTopBandItem->m_dwMeasure == (DWORD)lFirstVisibleMeasure
								 && pTopBandItem->m_bBeat == lFirstVisibleBeat;
							bool b2 = pTopBandItem->m_dwMeasure == (DWORD)lPartialVisibleMeasure
									&& rectHighlight.right > LeftMargin(m_pBandMgr->m_pTimeline) - lXOffset;
							if(b1 || b2)
							{
								bGhostBandCovered = true;
							}
							else if(rectHighlight.left > rectGhost.left
										&& rectHighlight.left < rectGhost.right)
							{
								rectGhost.right = rectHighlight.left;
							}

						}


						dc.DrawText( pTopBandItem->m_strText, rectHighlight, (DT_LEFT | DT_NOPREFIX) );
						
						if( pFontOld )
						{
							dc.SelectObject( pFontOld );
						}
					}
				}
				
				if( lPosition - lXOffset > rectClip.right )
				{
					break;
				}
			}

			// finally draw ghost band
			if(pGhostBand && !bGhostBandCovered)
			{
				CFont* pOldFont = 0;
				if(bUseItalicsForGhost && fHaveItalics)
				{
					pOldFont = dc.SelectObject(&fontItalics);
				}
				COLORREF cr = dc.SetTextColor(RGB(168,168,168));
				dc.DrawText( pGhostBand->m_strText, &rectGhost, (DT_LEFT | DT_NOPREFIX) );

				if(pOldFont)
				{
					dc.SelectObject (pOldFont);
				}
				dc.SetTextColor(cr);
			}

			// Make sure the names of selected Bands are shown in their entirety
			DWORD dwLastMeasure = 0xFFFFFFFF;
			BYTE bLastBeat = 0xFF;
			dwCurrentMeasure = 0xFFFFFFFF;
			bCurrentBeat = 0xFF;
			pos = m_pBandMgr->m_lstBands.GetHeadPosition();
			while( pos )
			{
				pBandItem = m_pBandMgr->m_lstBands.GetNext( pos );

				m_pBandMgr->m_pTimeline->MeasureBeatToPosition( m_pBandMgr->m_dwGroupBits, 0, pBandItem->m_dwMeasure, pBandItem->m_bBeat, &lPosition );

				if( pBandItem->m_fSelected )
				{
					if( pBandItem->m_dwMeasure != dwCurrentMeasure
					||  pBandItem->m_bBeat != bCurrentBeat )
					{
						dwCurrentMeasure = pBandItem->m_dwMeasure;
						bCurrentBeat = pBandItem->m_bBeat;

						pTopBandItem = GetTopBandFromMeasureBeat( dwCurrentMeasure, bCurrentBeat );
						ASSERT( pTopBandItem != NULL );		// Should never be NULL!
						if( pTopBandItem )
						{
							CFont* pFontOld = NULL;
							if( fHaveItalics )
							{
								if( pTopBandItem->m_strText.IsEmpty() == FALSE )
								{
									if( pTopBandItem != pBandItem
									&&  pBandItem->m_strText.IsEmpty() == FALSE )
									{
										pFontOld = dc.SelectObject( &fontItalics );
									}
									else if( dwLastMeasure == pBandItem->m_dwMeasure
										 &&  bLastBeat == pBandItem->m_bBeat )
									{
										pFontOld = dc.SelectObject( &fontItalics );
									}
									else
									{
										posNext = pos;
										while( posNext )
										{
											pNextBandItem = m_pBandMgr->m_lstBands.GetNext( posNext );

											if( pNextBandItem->m_dwMeasure != dwCurrentMeasure
											||  pNextBandItem->m_bBeat != bCurrentBeat )
											{
												posNext = NULL;
											}
											else
											{
												if( pNextBandItem != pTopBandItem
												&&  pNextBandItem->m_strText.IsEmpty() == FALSE )
												{
													pFontOld = dc.SelectObject( &fontItalics );
													posNext = NULL;
												}
											}
										}
									}
								}
							}

							if( pTopBandItem != pBandItem )
							{
								if( pTopBandItem->m_fSelected == FALSE )
								{
									pTopBandItem = pBandItem;
								}

								pBandItem->m_wFlags &= ~BF_TOPBAND;
								pTopBandItem->m_wFlags |= BF_TOPBAND;
							}

							// Determine width of a beat
							long lBeatLength = GetBeatWidth( pTopBandItem->m_dwMeasure );

							// find extent of text
							csize = dc.GetTextExtent( pTopBandItem->m_strText );
							if( csize.cx < lBeatLength )
							{
								csize.cx = lBeatLength;
							}
							long lExtent = lPosition + csize.cx;

							// truncate if a selected Band covers part of text
							POSITION pos2 = pos;
							CBandItem* pTempBand;
							bool fDone = false;
							while( pos2 && !fDone )
							{
								pTempBand = m_pBandMgr->m_lstBands.GetNext( pos2 );

								if( pTempBand->m_dwMeasure != dwCurrentMeasure
								||  pTempBand->m_bBeat != bCurrentBeat )
								{
									if( pTempBand->m_fSelected)
									{	
										long lRPos;
										m_pBandMgr->m_pTimeline->MeasureBeatToPosition( m_pBandMgr->m_dwGroupBits, 0, pTempBand->m_dwMeasure, pTempBand->m_bBeat, &lRPos );
										if( lRPos <= lExtent )
										{
											lExtent = lRPos;
										}
										fDone = true;
									}
								}
							}

							if( !fUseGutterSelectRange )
							{
								rectHighlight.left = lPosition - lXOffset;
								rectHighlight.right = lExtent - lXOffset;
								dc.DrawText( pTopBandItem->m_strText, rectHighlight, (DT_LEFT | DT_NOPREFIX) );
								GrayOutRect( dc.m_hDC, rectHighlight );
							}

							if( pFontOld )
							{
								dc.SelectObject( pFontOld );
							}
						}
					}
				}
			
				if( lPosition - lXOffset > rectClip.right )
				{
					break;
				}

				if( pBandItem->m_strText.IsEmpty() == FALSE )
				{
					dwLastMeasure = pBandItem->m_dwMeasure;
					bLastBeat = pBandItem->m_bBeat;
				}
			}

			// Highlight the selected range if there is one.
			if( fUseGutterSelectRange )
			{
				long lBeginSelect = m_lBeginSelect > m_lEndSelect ? m_lEndSelect : m_lBeginSelect;
				long lEndSelect = m_lBeginSelect > m_lEndSelect ? m_lBeginSelect : m_lEndSelect;

				long lMeasure;
				long lBeat;
				long lClocks;

				m_pBandMgr->m_pTimeline->ClocksToMeasureBeat( m_pBandMgr->m_dwGroupBits, 0, lBeginSelect, &lMeasure, &lBeat );
				m_pBandMgr->m_pTimeline->MeasureBeatToClocks( m_pBandMgr->m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
				m_pBandMgr->m_pTimeline->ClocksToPosition( lClocks, &(rectHighlight.left));

				m_pBandMgr->m_pTimeline->ClocksToMeasureBeat( m_pBandMgr->m_dwGroupBits, 0, lEndSelect, &lMeasure, &lBeat );
				m_pBandMgr->m_pTimeline->MeasureBeatToClocks( m_pBandMgr->m_dwGroupBits, 0, lMeasure, (lBeat + 1), &lClocks );
				m_pBandMgr->m_pTimeline->ClocksToPosition( (lClocks - 1), &(rectHighlight.right));

				rectHighlight.left -= lXOffset;
				rectHighlight.right -= lXOffset;

				// Invert it
				GrayOutRect( dc.m_hDC, rectHighlight );
			}

			if( fHaveItalics )
			{
				fontItalics.DeleteObject();
			}

			dc.Detach();
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CBandStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case SP_RESIZEABLE:
		// We are not resizable
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_GUTTERSELECTABLE:
		// We support gutter selection
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;

	case SP_MINMAXABLE:
		// We don't support Minimize/maximize
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_DEFAULTHEIGHT:
	case SP_MAXHEIGHT:
	case SP_MINHEIGHT:
		// Our height is 20 pixels
		pvar->vt = VT_INT;
		V_INT(pvar) = STRIP_HEIGHT;
		break;

	case SP_NAME:
		{
			// Get "Bands" text
			CString strBands;
			HINSTANCE hInstance = AfxGetResourceHandle();
			AfxSetResourceHandle( _Module.GetModuleInstance() );
			strBands.LoadString( IDS_BANDS_TEXT );
			AfxSetResourceHandle( hInstance );

			BSTR bstr;
			CString str = GetName(m_pBandMgr->m_dwGroupBits, strBands);

			pvar->vt = VT_BSTR; 
			try
			{
				bstr = str.AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR(pvar) = bstr;
		}
		break;

	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		if( m_pBandMgr )
		{
			m_pBandMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		}
		else
		{
			V_UNKNOWN(pvar) = NULL;
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::SetStripProperty

HRESULT STDMETHODCALLTYPE CBandStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	switch( sp )
	{
	case SP_BEGINSELECT:
	case SP_ENDSELECT:
		if( var.vt != VT_I4)
		{
			return E_FAIL;
		}
		if( sp == SP_BEGINSELECT )
		{
			m_lBeginSelect = V_I4( &var );
		}
		else
		{
			m_lEndSelect = V_I4( &var );
		}

		if( m_bSelecting )
		{
			break;
		}

		if( m_lBeginSelect == m_lEndSelect )
		{	
			m_pBandMgr->UnselectAll();
			m_pBandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			break;
		}
		if( m_bGutterSelected )
		{
			m_pBandMgr->UnselectAll();
			m_pBandMgr->SelectSegment( m_lBeginSelect, m_lEndSelect );
		}
		else
		{
			m_pBandMgr->UnselectAll();
		}
		m_pBandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

		// Update the property page
		if( m_pBandMgr->m_pPropPageMgr != NULL )
		{
			m_pBandMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	case SP_GUTTERSELECT:
		m_bGutterSelected = V_BOOL(&var);

		if( m_lBeginSelect == m_lEndSelect )
		{	
			m_pBandMgr->UnselectAll();
			m_pBandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			break;
		}
		if( m_bGutterSelected )
		{
			m_pBandMgr->UnselectAll();
			m_pBandMgr->SelectSegment( m_lBeginSelect, m_lEndSelect );
		}
		else
		{
			m_pBandMgr->UnselectAll();
		}
		m_pBandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

		// Update the property page
		if( m_pBandMgr->m_pPropPageMgr != NULL )
		{
			m_pBandMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::GetTopBandFromMeasureBeat

CBandItem *CBandStrip::GetTopBandFromMeasureBeat( DWORD dwMeasure, BYTE bBeat )
{
	CBandItem* pTheBandItem = NULL;
	CBandItem* pFirstBandItem = NULL;
	CBandItem* pBandItem;

	POSITION pos = m_pBandMgr->m_lstBands.GetHeadPosition();
	while( pos )
	{
		pBandItem = m_pBandMgr->m_lstBands.GetNext( pos );

		if( pBandItem->m_dwMeasure == dwMeasure
		&&  pBandItem->m_bBeat == bBeat )
		{
			if( pFirstBandItem == NULL )
			{
				pFirstBandItem = pBandItem;
			}
			else
			{
				if( pFirstBandItem->m_strText.IsEmpty() )
				{
					pFirstBandItem = pBandItem;
				}
			}

			if( pBandItem->m_wFlags & BF_TOPBAND )
			{
				pTheBandItem = pBandItem;
				break;
			}
		}

		if( pBandItem->m_dwMeasure > dwMeasure )
		{
			break;
		}
	}

	if( pTheBandItem == NULL )
	{
		pTheBandItem = pFirstBandItem;
	}

	return pTheBandItem;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::GetBandFromPoint

CBandItem *CBandStrip::GetBandFromPoint( long lPos )
{
	CBandItem*		pBandReturn = NULL;

	if( m_pBandMgr->m_pTimeline != NULL )
	{
		CBandItem* pBandItem = NULL;
		long lMeasure, lBeat;
		if( SUCCEEDED( m_pBandMgr->m_pTimeline->PositionToMeasureBeat( m_pBandMgr->m_dwGroupBits, 0, lPos, &lMeasure, &lBeat ) ) )
		{
			 //BUGBUG: validate range of lBeat
			pBandReturn = GetTopBandFromMeasureBeat( lMeasure, (BYTE)lBeat );
		}
	}
	return pBandReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CBandStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Process the window message
	HRESULT hr = S_OK;
	CBandItem* pBand = NULL;
	if( m_pBandMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		// Save the position of the click
		m_lXPos = lXPos;
		m_fShowBandProps = TRUE;
		hr = OnLButtonDown( wParam, lParam, lXPos, lYPos );
		break;

	case WM_LBUTTONDBLCLK:
		{
			long lMeasure;
			long lBeat;
			hr = m_pBandMgr->m_pTimeline->PositionToMeasureBeat( m_pBandMgr->m_dwGroupBits, 0, m_lXPos, &lMeasure, &lBeat );
			// use the measure and beat to get a band item
			CBandItem* pTopBandItem = GetTopBandFromMeasureBeat( (DWORD)lMeasure, (BYTE)lBeat );
			if( pTopBandItem
			&&  pTopBandItem->m_pIBandNode )
			{
				hr = pTopBandItem->m_pIBandNode->SetDocRootNode( m_pStripNode );
				hr = m_pBandMgr->m_pDMProdFramework->OpenEditor( pTopBandItem->m_pIBandNode );
			}
		}
		break;

	case WM_MOUSEMOVE:
		if( m_dwStartDragButton )
		{
			m_nStripIsDragDropSource = 1;
	
			if( DoDragDrop() )
			{
				// Redraw the strip and refresh the Band property page
				m_pBandMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
				m_pBandMgr->OnShowProperties();
				if( m_pBandMgr->m_pPropPageMgr )
				{
					m_pBandMgr->m_pPropPageMgr->RefreshData();
				}
			}

			m_dwStartDragButton = 0;
			m_nStripIsDragDropSource = 0;
		}
		break;

	case WM_RBUTTONDOWN:
	{
		ASSERT( m_pBandMgr != NULL );
		ASSERT( m_pBandMgr->m_pTimeline != NULL );

		// Save the position of the click so we know where to insert a Band. if Insert is selected.
		m_lXPos = lXPos;

		// Get Timeline length
		VARIANT var;
		m_pBandMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
		long lTimelineLength = V_I4( &var );

		// Exit if user clicked past end of Strip
		long lClock;
		m_pBandMgr->m_pTimeline->PositionToClocks( lXPos, &lClock );
		if( lClock >= lTimelineLength )
		{
			break;
		}

		// Make sure everything on the timeline is deselected first.
		UnselectGutterRange();

		pBand = GetBandFromPoint( lXPos );
		if (!pBand)
		{
			// no band, so create one with an empty band node.
			m_pBandMgr->UnselectAll();
			// now, create the band node and insert it into the band manager's list
			hr = m_pBandMgr->CreateBand( lXPos, this, pBand);
			if (SUCCEEDED(hr))
			{
				pBand->SetSelectFlag( TRUE );
			}

			m_pBandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*) this, NULL, TRUE );
		}
		else if( m_pBandMgr->IsSelected() == FALSE )
		{
			m_pBandMgr->UnselectAll();
			// Select the item at the mouse click (if there is one).
			// Different from commands, which select empty measures.
			pBand->SetSelectFlag( TRUE );
			m_pBandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*) this, NULL, TRUE );
		}
		else if( !( wParam & ( MK_SHIFT | MK_CONTROL )))
		{
			// Make sure this band is selected.  If it isn't, make it the only one selected
			if( !pBand->m_fSelected)
			{
				m_pBandMgr->UnselectAll();
				pBand->SetSelectFlag( TRUE );
			}
			m_pBandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*) this, NULL, TRUE );
		}

		m_fShowBandProps = TRUE;
		m_pBandMgr->OnShowProperties(); 
		break;
	}

	case WM_RBUTTONUP:
	{
		// Get the item at the mouse click.
		// Display a right-click context menu.
		POINT pt;
		BOOL	bResult;
		// Get the cursor position (To put the menu there)
		bResult = GetCursorPos( &pt );
		ASSERT( bResult );
		if( !bResult )
		{
			hr = E_UNEXPECTED;
			break;
		}

		// Save the position of the click so we know where to insert a Band. if Insert is selected.
		m_lXPos = lXPos;

		HMENU hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_EDIT_RMENU) );
		HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

		::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED :
				MF_GRAYED );
		::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED :
				MF_GRAYED );
		::EnableMenuItem( hMenuPopup, 2, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION :
				MF_GRAYED | MF_BYPOSITION );
		::EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ? MF_ENABLED :
				MF_GRAYED );
		::EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED :
				MF_GRAYED );
		::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( RightClickMenuCanSelectAll() == S_OK ) ? MF_ENABLED :
				MF_GRAYED );
		::EnableMenuItem( hMenuPopup, ID_VIEW_PROPERTIES, MF_ENABLED );
		::EnableMenuItem( hMenuPopup, IDM_CYCLE_BANDS, ( m_pBandMgr->CanCycle(m_lXPos) == TRUE ) ? MF_ENABLED :
				MF_GRAYED );

		m_pBandMgr->m_pTimeline->TrackPopupMenu(hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE);
		::DestroyMenu( hMenu );

		hr = S_OK;
		break;
	}

	case WM_COMMAND:
		// We should only get this message in response to a selection in the right-click context menu.
		WORD wNotifyCode;
		WORD wID;

		wNotifyCode	= HIWORD( wParam );	// notification code 
		wID			= LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
		case ID_VIEW_PROPERTIES:
			hr = ShowPropertySheet(m_pBandMgr->m_pTimeline);
			if( m_fShowBandProps )
			{
				// Change to the Band property page
				m_pBandMgr->OnShowProperties();
			}
			else
			{
				// Change to our property page
				OnShowProperties();
			}
			break;
		case ID_EDIT_CUT:
			hr = Cut( NULL );
			break;
		case ID_EDIT_COPY:
			hr = Copy( NULL );
			break;
		case ID_EDIT_DELETE:
			hr = Delete();
			break;
		case ID_EDIT_PASTE:
			if( m_lXPos >= 0 )
			{
				m_bContextMenuPaste = TRUE;
			}
			hr = Paste( NULL );
			m_bContextMenuPaste = FALSE;
			break;
		case ID_EDIT_INSERT:
			hr = Insert();
			break;
		case ID_EDIT_SELECT_ALL:
			hr = SelectAll();
			break;
		case IDM_CYCLE_BANDS:
			hr = m_pBandMgr->CycleBands( m_lXPos );
			break;
		case IDM_DRAG_MOVE:
			OnDragRMenuMove();
			break;
		case IDM_DRAG_COPY:
			OnDragRMenuCopy();
			break;
		case IDM_DRAG_CANCEL:
			OnDragRMenuCancel();
			break;
		case ID_OPEN_BANDEDITOR:
			if( m_pBandMgr->m_pBandItemForEditBandButton
			&&  m_pBandMgr->m_pBandItemForEditBandButton->m_pIBandNode )
			{
				// Select just this band
				m_pBandMgr->UnselectAll();
				m_pBandMgr->m_pBandItemForEditBandButton->m_fSelected = true;

				hr = m_pBandMgr->m_pBandItemForEditBandButton->m_pIBandNode->SetDocRootNode( m_pStripNode );
				hr = m_pBandMgr->m_pDMProdFramework->OpenEditor( m_pBandMgr->m_pBandItemForEditBandButton->m_pIBandNode );
			}
			break;
		case ID_LOCATE_BAND:
			if( m_pBandMgr->m_pBandItemForEditBandButton
			&&  m_pBandMgr->m_pBandItemForEditBandButton->m_pIBandNode )
			{
				// Select just this band
				m_pBandMgr->UnselectAll();
				m_pBandMgr->m_pBandItemForEditBandButton->SetSelectFlag( TRUE );
				m_pBandMgr->UnMarkBands( UD_CURRENTSELECTION );
				m_pBandMgr->m_pBandItemForEditBandButton->m_dwBits |= UD_CURRENTSELECTION;
				m_fSingleSelect = FALSE;

				// Center the display horizontally on this band
				long lLeftDisplay, lRightDisplay;
				m_pBandMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );
				m_pBandMgr->m_pTimeline->GetMarkerTime( MARKER_RIGHTDISPLAY, TIMETYPE_CLOCKS, &lRightDisplay );

				lLeftDisplay = m_pBandMgr->m_pBandItemForEditBandButton->m_mtTimeLogical - ((lRightDisplay - lLeftDisplay) / 2);
				m_pBandMgr->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );

				VARIANT var;
				var.vt = VT_I4;
				V_I4(&var) = lLeftDisplay;
				m_pBandMgr->m_pTimeline->SetTimelineProperty( TP_HORIZONTAL_SCROLL, var );

				// Activate this strip
				var.vt = VT_UNKNOWN;
				V_UNKNOWN(&var) = static_cast<IDMUSProdStrip*>(this);
				V_UNKNOWN(&var)->AddRef();
				m_pBandMgr->m_pTimeline->SetTimelineProperty( TP_ACTIVESTRIP, var );

				// Display this strip at the top of the display
				var.vt = VT_UNKNOWN;
				V_UNKNOWN(&var) = static_cast<IDMUSProdStrip*>(this);
				V_UNKNOWN(&var)->AddRef();
				m_pBandMgr->m_pTimeline->SetTimelineProperty( TP_TOP_STRIP, var );

				// Redraw the strip and refresh the Band property page
				m_pBandMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
				m_pBandMgr->OnShowProperties();
				if( m_pBandMgr->m_pPropPageMgr )
				{
					m_pBandMgr->m_pPropPageMgr->RefreshData();
				}
			}
			break;
		case ID_INSERT_NEWINSTRUMENT:
			{
				// Get 'now'
				MUSIC_TIME mtNow;
				if( FAILED( m_pBandMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtNow ) ) )
				{
					return E_UNEXPECTED;
				}

				// Look for a band at exactly tick -1 of the current beat
				CBandItem *pBand = NULL;
				long lMeasure, lBeat, lTmpTime = mtNow;
				if( SUCCEEDED( m_pBandMgr->m_pTimeline->ClocksToMeasureBeat( m_pBandMgr->m_dwGroupBits, 0, mtNow, &lMeasure, &lBeat ) )
				&&	SUCCEEDED( m_pBandMgr->m_pTimeline->MeasureBeatToClocks( m_pBandMgr->m_dwGroupBits, 0, lMeasure, lBeat, &lTmpTime ) ) )
				{
					lTmpTime--;

					// Try and find a band exactly at lTimeTime
					pBand = m_pBandMgr->FindBandAtTime( lTmpTime );
				}

				// If we found a real band
				if( pBand
				&&	pBand->m_pIBandNode )
				{
					// Just insert the instrument
					IDMUSProdBandEdit8a *pIDMUSProdBandEdit8a;
					if( SUCCEEDED( pBand->m_pIBandNode->QueryInterface( IID_IDMUSProdBandEdit8a, (void **)&pIDMUSProdBandEdit8a ) ) )
					{
						m_pBandMgr->m_fNoUpdateSegment = true;
						pIDMUSProdBandEdit8a->InsertPChannel( m_pBandMgr->m_dwPChannelForEditBandButton, FALSE );
						m_pBandMgr->m_fNoUpdateSegment = true;
						pIDMUSProdBandEdit8a->Release();

						m_nLastEdit = IDS_INSERT_INSTRUMENT;
						m_pBandMgr->OnDataChanged();
						// Sequence strip will need to repaint FBar to catch latest DLS region wave names
						m_pBandMgr->m_pTimeline->NotifyStripMgrs( GUID_Segment_BandTrackChange, m_pBandMgr->m_dwGroupBits, NULL );
					}
				}
				else
				{
					// Otherwise, create a new band node
					bool fNewBand = false;
					if (!pBand)
					{
						pBand = new CBandItem(this);
						fNewBand = true;
					}
					if(pBand != NULL)
					{
						HINSTANCE hInstance = AfxGetResourceHandle();
						AfxSetResourceHandle( _Module.GetModuleInstance() );
						pBand->m_strText.LoadString( IDS_EMPTY_TEXT );
						AfxSetResourceHandle( hInstance );

						pBand->SetTimePhysical( lTmpTime, STP_LOGICAL_SET_DEFAULT );
						// Don't select the band
						//pBand->SetSelectFlag( TRUE );
						m_pBandMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

						IDMUSProdDocType* pIDocType;
						ASSERT( pBand->m_pIBandNode == NULL );
						hr = m_pBandMgr->m_pDMProdFramework->FindDocTypeByNodeId( GUID_BandNode, &pIDocType );
						if( SUCCEEDED ( hr ) )
						{
							hr = pIDocType->AllocNode( GUID_BandNode, &pBand->m_pIBandNode );
							pIDocType->Release();
							pIDocType = NULL;
						}
							
						if( SUCCEEDED ( hr ) )
						{
							BSTR bstrBandName = m_pBandMgr->CreateUniqueName();
							pBand->m_strText = bstrBandName;
							pBand->m_pIBandNode->SetNodeName( bstrBandName );
							hr = pBand->m_pIBandNode->SetDocRootNode( m_pStripNode );
							m_pBandMgr->m_pDMProdFramework->AddToNotifyList( pBand->m_pIBandNode, m_pStripNode );
							SendAudiopathToNode( pBand->m_pIBandNode, m_pBandMgr->m_pSegmentState );
						}

						// Open property page
						m_fShowBandProps = TRUE;
						//ShowPropertySheet( m_pBandMgr->m_pTimeline );
						// Change to the Band property page
						//m_pBandMgr->OnShowProperties();
						
						if( fNewBand )
						{
							m_pBandMgr->AddBand( pBand );
						}

						if( pBand->m_pIBandNode )
						{
							BSTR bstrName;
							pBand->m_pIBandNode->GetNodeName( &bstrName );
							pBand->m_strText = bstrName;
							SysFreeString(bstrName);

							// Insert the instrument
							IDMUSProdBandEdit8a *pIDMUSProdBandEdit8a;
							if( SUCCEEDED( pBand->m_pIBandNode->QueryInterface( IID_IDMUSProdBandEdit8a, (void **)&pIDMUSProdBandEdit8a ) ) )
							{
								m_pBandMgr->m_fNoUpdateSegment = true;
								pIDMUSProdBandEdit8a->InsertPChannel( m_pBandMgr->m_dwPChannelForEditBandButton, TRUE );
								m_pBandMgr->m_fNoUpdateSegment = false;

								pIDMUSProdBandEdit8a->Release();
							}
						}

						m_nLastEdit = IDS_INSERT;
						m_pBandMgr->OnDataChanged();
						// Sequence strip will need to repaint FBar to catch latest DLS region wave names
						m_pBandMgr->m_pTimeline->NotifyStripMgrs( GUID_Segment_BandTrackChange, m_pBandMgr->m_dwGroupBits, NULL );
					}
				}
			}
			break;
		default:
			break;
		}
		break;

	case WM_LBUTTONUP:
		if( m_fSingleSelect )
		{
			CBandItem* pBand = GetBandFromPoint( lXPos );
			if( pBand
			&&  pBand->m_pIBandNode)
			{
				m_pBandMgr->UnselectAll();
				pBand->SetSelectFlag( TRUE );
				m_pBandMgr->UnMarkBands( UD_CURRENTSELECTION );
				pBand->m_dwBits |= UD_CURRENTSELECTION;

				// Redraw the strip and refresh the Band property page
				m_pBandMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
				m_pBandMgr->OnShowProperties();
				if( m_pBandMgr->m_pPropPageMgr )
				{
					m_pBandMgr->m_pPropPageMgr->RefreshData();
				}
			}
			m_fSingleSelect = FALSE;
		}
		m_lXPos = lXPos;
		hr = S_OK;
		break;

	case WM_CREATE:
		m_bGutterSelected = FALSE;
		
		m_cfBand = RegisterClipboardFormat( CF_BAND );
		m_cfBandTrack = RegisterClipboardFormat( CF_BANDTRACK );
		if( m_pBandMgr->m_pTimeline )
		{
			IUnknown* punk = NULL;
			VARIANT var;
			HRESULT hr = m_pBandMgr->m_pTimeline->GetTimelineProperty(TP_TIMELINECALLBACK, &var);
			punk = V_UNKNOWN(&var);
			hr = punk->QueryInterface(IID_IDMUSProdNode, (void**)&m_pStripNode);
			RELEASE( punk );

			// Update all bands to use this DocRootNode
			m_pBandMgr->SetDocRootForAllBands();

			// Get Left and right selection boundaries
			m_pBandMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lBeginSelect );
			m_pBandMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lEndSelect );

			m_pBandMgr->SyncWithDirectMusic();
		}
		break;

	default:
		break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CBandStrip::FBDraw

HRESULT CBandStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::FBOnWMMessage

HRESULT CBandStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Process the window message
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		m_fShowBandProps = FALSE;
		OnShowProperties();
		break;
	case WM_RBUTTONUP:
	{
		m_fShowBandProps = FALSE;
		OnShowProperties();
		m_lXPos = -1;

		// Display a right-click context menu.
		POINT pt;
		// Get the cursor position (To put the menu there)
		if( !GetCursorPos( &pt ) )
		{
			hr = E_UNEXPECTED;
			break;
		}

		if( m_pBandMgr->m_pTimeline )
		{
			HMENU hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_EDIT_RMENU) );
			HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

			::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			::EnableMenuItem( hMenuPopup, 2, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION :
					MF_GRAYED | MF_BYPOSITION );
			::EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( RightClickMenuCanSelectAll() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_VIEW_PROPERTIES, MF_ENABLED );
			::EnableMenuItem( hMenuPopup, IDM_CYCLE_BANDS, MF_GRAYED );

			m_pBandMgr->m_pTimeline->TrackPopupMenu(hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE);
			::DestroyMenu( hMenu );
		}
		break;
	}

	default:
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CBandStrip::Cut

HRESULT CBandStrip::Cut( IDMUSProdTimelineDataObject *pIDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr;

	hr = CanCut();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	// Cut is simply a Copy followed by a Delete.
	hr = Copy(pIDataObject);
	if( SUCCEEDED( hr ))
	{
		hr = Delete();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::Copy

HRESULT CBandStrip::Copy( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;
	IStream*			pStreamCopy;

	hr = CanCopy();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pBandMgr != NULL );
	if( m_pBandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfBandTrack == 0 )
	{
		m_cfBandTrack = RegisterClipboardFormat( CF_BANDTRACK );
		if( m_cfBandTrack == 0 )
		{
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected commands in.
	if( FAILED( m_pBandMgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pStreamCopy) ) )
	{
		return E_OUTOFMEMORY;
	}

	m_pBandMgr->MarkSelectedBands(UD_COPYSELECT);

	MUSIC_TIME mtTime;
	if( pITimelineDataObject )
	{
		// Get clock from pITimelineDataObject
		if( FAILED( pITimelineDataObject->GetBoundaries( &mtTime, NULL ) ) )
		{
			return E_UNEXPECTED;
		}

		// Adjust to measure/beat boundary
		long lMeasure, lBeat;
		m_pBandMgr->m_pTimeline->ClocksToMeasureBeat( m_pBandMgr->m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
		m_pBandMgr->m_pTimeline->MeasureBeatToClocks( m_pBandMgr->m_dwGroupBits, 0, lMeasure, lBeat, &mtTime );
	}
	else
	{
		// Get clock of first selected Band's measure/beat
		CBandItem* pBandAtDragPoint = m_pBandMgr->FirstSelectedBand();
		ASSERT( pBandAtDragPoint != NULL );
		if( pBandAtDragPoint == NULL )
		{
			return E_UNEXPECTED;
		}
		m_pBandMgr->MeasureBeatTickToClocks( pBandAtDragPoint->m_dwMeasure, pBandAtDragPoint->m_bBeat, 0, &mtTime );  
	}

	// Save the Bands into the stream.
	hr = m_pBandMgr->SaveSelectedBands( pStreamCopy, mtTime, SSB_COPY );
	if( FAILED( hr ))
	{
		RELEASE( pStreamCopy );
		return E_UNEXPECTED;
	}

	if(pITimelineDataObject != NULL)
	{
		// add the stream to the passed IDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfBandTrack, pStreamCopy );
		RELEASE( pStreamCopy );
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			return E_FAIL;
		}
	}
	// Otherwise, add it to the clipboard
	else
	{
		// There is no existing data object, so just create a new one
		hr = m_pBandMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		ASSERT( hr == S_OK );
		if( hr != S_OK )
		{
			return E_FAIL;
		}

		// Set the start and edit time of this copy
		long lStartTime, lEndTime;
		m_pBandMgr->GetBoundariesOfSelectedBands( &lStartTime, &lEndTime );
		hr = pITimelineDataObject->SetBoundaries( lStartTime, lEndTime );

		// add the stream to the DataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfBandTrack, pStreamCopy );

		// Release the IStream we copied into
		RELEASE( pStreamCopy );

		// Exit with an error if we failed to add the stream
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			RELEASE( pITimelineDataObject );
			return E_FAIL;
		}

		// get the IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export( &pIDataObject );

		// Release the IDMUSProdTimelineDataObject
		RELEASE( pITimelineDataObject );

		// Exit if the export failed
		if( FAILED(hr) )
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );

		// Exit if we failed to set the clipboard with our data
		if( hr != S_OK )
		{
			// Release the IDataObject
			RELEASE( pIDataObject );
			return E_FAIL;
		}

		// If we already have a CopyDataObject, release it
		RELEASE( m_pBandMgr->m_pCopyDataObject);

		// Set m_pCopyDataObject to the object we just copied to the clipboard
		m_pBandMgr->m_pCopyDataObject = pIDataObject;

		// Not needed - Object was AddRef()'d when it was exported from the IDMUSProdTimelineDataObject
		// m_pBandMgr->m_pCopyDataObject->AddRef();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::PasteAt

HRESULT CBandStrip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, MUSIC_TIME mtPasteTime, BOOL fDropNotEditPaste, BOOL &fChanged)
{
	if( pITimelineDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Make sure everything in other strip is deselected first.
	if( fDropNotEditPaste == FALSE )
	{
		UnselectGutterRange();
	}

	// Keep paste on a measure/beat boundary
	long lMeasure;
	long lBeat;
	long lTick;

	m_pBandMgr->ClocksToMeasureBeatTick( mtPasteTime, &lMeasure, &lBeat, &lTick );
	if( lTick < 0 )
	{
		// Use previous beat
		lBeat--;
		if( lBeat < 0 )
		{
			MUSIC_TIME mtTime1;
			MUSIC_TIME mtTime2;

			lMeasure--;
			if( lMeasure < 0 )
			{
				m_pBandMgr->MeasureBeatTickToClocks( 0, 0, 0, &mtTime1 );
				m_pBandMgr->MeasureBeatTickToClocks( 0, 1, 0, &mtTime2 );
			}
			else
			{
				m_pBandMgr->MeasureBeatTickToClocks( lMeasure, 0, 0, &mtTime1 );
				m_pBandMgr->MeasureBeatTickToClocks( lMeasure, 1, 0, &mtTime2 );
			}
			long lClocksPerBeat = mtTime2 - mtTime1;
			m_pBandMgr->ClocksToMeasureBeatTick( mtPasteTime - lClocksPerBeat, &lMeasure, &lBeat, &lTick );
		}
	}
	m_pBandMgr->MeasureBeatTickToClocks( lMeasure, lBeat, 0, &mtPasteTime );

	// Don't bother to do anything if user simply moved cursor within same beat in same strip
	if( fDropNotEditPaste )
	{
		if( m_nStripIsDragDropSource )
		{
			long lSourceMeasure;
			long lSourceBeat;
			if( SUCCEEDED ( m_pBandMgr->m_pTimeline->PositionToMeasureBeat( m_pBandMgr->m_dwGroupBits,
																			0,
																			m_lStartDragPosition,
																			&lSourceMeasure,
																			&lSourceBeat ) ) )
			{
				if( lSourceMeasure == lMeasure
				&&  lSourceBeat == lBeat )
				{
					return S_FALSE;
				}
			}
		}
	}

	IPersistStream *pIPS = NULL;
	IDMUSProdComponent* pIComponent = NULL;
	IDMUSProdRIFFStream* pIRiffStream = NULL;
	HRESULT hr = E_FAIL;

	if( pITimelineDataObject->IsClipFormatAvailable( m_cfBandTrack ) == S_OK )
	{
		IStream* pIStream;
		
		if( m_nStripIsDragDropSource )
		{
			m_pBandMgr->UnselectAllKeepBits();
		}
		else
		{
			m_pBandMgr->UnselectAll();
		}

		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfBandTrack, &pIStream)))
		{
			// Check for RIFF format
			if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
			{
				goto Leave;
			}

			MMCKINFO ck;
			ck.fccType = DMUS_FOURCC_BANDS_LIST;
			if ( pIRiffStream->Descend( &ck, NULL, MMIO_FINDLIST ) == 0 )
			{
				if (SUCCEEDED(m_pBandMgr->BuildDirectMusicBandList(pIStream, pIRiffStream, ck, fChanged, true, mtPasteTime) ) )
				{
					m_pBandMgr->UnMarkBands(UD_COPYSELECT);
					hr = S_OK;
				}
				pIRiffStream->Ascend( &ck, 0 );
			}
		}
	}
	else if( pITimelineDataObject->IsClipFormatAvailable( m_cfBand ) == S_OK )
	{
		IStream* pIStream;
		
		if( m_nStripIsDragDropSource )
		{
			m_pBandMgr->UnselectAllKeepBits();
		}
		else
		{
			m_pBandMgr->UnselectAll();
		}

		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfBand, &pIStream)))
		{
			CBandItem *pItem = new CBandItem(m_pBandMgr->m_pBandStrip);
			if(pItem == NULL)
			{
				return E_OUTOFMEMORY;
			}
			pItem->m_strText.Empty();

			m_pBandMgr->ClocksToMeasureBeatTick( mtPasteTime, &lMeasure, &lBeat, &lTick );
			m_pBandMgr->MeasureBeatTickToClocks( lMeasure, lBeat, -1, &mtPasteTime );  
			pItem->SetTimePhysical( mtPasteTime, STP_LOGICAL_SET_DEFAULT );
			
			// load stream into current band
			hr = m_pBandMgr->m_pDMProdFramework->FindComponent(CLSID_BandComponent, &pIComponent);
			if(SUCCEEDED(hr))
			{
				IDMUSProdRIFFExt* pRiff = NULL;
				hr = pIComponent->QueryInterface(IID_IDMUSProdRIFFExt, (void**)&pRiff);
				if( SUCCEEDED( hr ) )
				{
					IDMUSProdNode* pNode = NULL;
					hr = pRiff->LoadRIFFChunk(pIStream, &pNode);
					RELEASE( pRiff );
					if (SUCCEEDED(hr))
					{
						pItem->m_pIBandNode = pNode;
						BSTR bstrName;
						pItem->m_pIBandNode->GetNodeName( &bstrName );
						pItem->m_strText = bstrName;
						if (m_pBandMgr->m_pBandStrip->m_pStripNode)
						{
							m_pBandMgr->m_pDMProdFramework->AddToNotifyList(
								pItem->m_pIBandNode, m_pBandMgr->m_pBandStrip->m_pStripNode);
						}
						m_pBandMgr->InsertByAscendingTime( pItem, TRUE );
						fChanged = TRUE;
						pItem->SetSelectFlag( TRUE );
						SysFreeString(bstrName);
						hr = S_OK;
					}
				}
				RELEASE( pIComponent );
			}
		}
	}

Leave:
	RELEASE( pIPS );
	RELEASE( pIRiffStream );
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::Paste

HRESULT CBandStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT				hr;
	
	// Make sure we can paste
	hr = CanPaste( pITimelineDataObject );
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pBandMgr != NULL );
	if( m_pBandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pBandMgr->m_pTimeline != NULL );
	if( m_pBandMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfBandTrack == 0 )
	{
		m_cfBandTrack = RegisterClipboardFormat( CF_BANDTRACK );
		if( m_cfBandTrack == 0 )
		{
			return E_FAIL;
		}
	}
	
	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pBandMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			RELEASE( pIDataObject );
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		RELEASE( pIDataObject );
		if( FAILED(hr) )
		{
			RELEASE( pITimelineDataObject );
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}

	// Determine paste measure/beat
	MUSIC_TIME mtTime;
	long lMeasure, lBeat;
	if( m_bContextMenuPaste )
	{
		m_pBandMgr->m_pTimeline->PositionToClocks( m_lXPos, &mtTime );
	}
	else
	{
		if( FAILED( m_pBandMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime ) ) )
		{
			RELEASE( pITimelineDataObject );
			return E_FAIL;
		}
	}
	m_pBandMgr->m_pTimeline->ClocksToMeasureBeat( m_pBandMgr->m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
	m_pBandMgr->m_pTimeline->MeasureBeatToClocks( m_pBandMgr->m_dwGroupBits, 0, lMeasure, lBeat, &mtTime );

	// Get the paste type
	TIMELINE_PASTE_TYPE tlPasteType;
	if( FAILED( m_pBandMgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
	{
		RELEASE( pITimelineDataObject );
		return E_FAIL;
	}

	BOOL fChanged = FALSE;

	if( tlPasteType == TL_PASTE_OVERWRITE )
	{
		long lStart, lEnd, lDiff;
		if( SUCCEEDED( pITimelineDataObject->GetBoundaries( &lStart, &lEnd ) ) )
		{
			ASSERT( lStart < lEnd );

			lDiff = lEnd - lStart;
			lStart = mtTime;
			lEnd = lStart + lDiff;

			fChanged = m_pBandMgr->DeleteBetweenTimes( lStart, lEnd );
		}
	}

	// Now, do the paste operation
	hr = PasteAt(pITimelineDataObject, mtTime, false, fChanged);
	RELEASE( pITimelineDataObject );

	// If successful and something changed, redraw our strip
	if( SUCCEEDED(hr) && fChanged )
	{
		// Set the last edit type
		m_nLastEdit = IDS_PASTE;

		// Update our hosting editor.
		m_pBandMgr->OnDataChanged();

		// Redraw our strip
		m_pBandMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

		// Update the property page
		if( m_pBandMgr->m_pPropPageMgr != NULL )
		{
			m_pBandMgr->m_pPropPageMgr->RefreshData();
		}

		m_pBandMgr->SyncWithDirectMusic();

		// Sequence strip will need to repaint FBar to catch latest DLS region wave names
		m_pBandMgr->m_pTimeline->NotifyStripMgrs( GUID_Segment_BandTrackChange, m_pBandMgr->m_dwGroupBits, NULL );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::Insert

HRESULT CBandStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Make sure everything on the timeline is deselected first.
	UnselectGutterRange();
	m_pBandMgr->UnselectAll();

	// BUGBUG: Need to fix this.  Should use m_lXPos if it's valid, otherwise use the time cursor.
	HRESULT hr = S_OK;
	long	lMeasure, lBeat;
	CBandItem* pBand = NULL;
	bool fNewBand = false;
	if( m_pBandMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}
	hr = m_pBandMgr->m_pTimeline->PositionToMeasureBeat( m_pBandMgr->m_dwGroupBits, 0, m_lXPos, &lMeasure, &lBeat );
	ASSERT( SUCCEEDED( hr ));

	pBand = GetBandFromPoint( m_lXPos );
	if (!pBand || pBand->m_pIBandNode)
	{
		pBand = new CBandItem(this);
		fNewBand = true;
	}
	if(pBand == NULL)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		HINSTANCE hInstance = AfxGetResourceHandle();
		AfxSetResourceHandle( _Module.GetModuleInstance() );
		pBand->m_strText.LoadString( IDS_EMPTY_TEXT );
		AfxSetResourceHandle( hInstance );

		MUSIC_TIME mtTime;
		m_pBandMgr->MeasureBeatTickToClocks( lMeasure, lBeat, -1, &mtTime );
		pBand->SetTimePhysical( mtTime, STP_LOGICAL_SET_DEFAULT );
		pBand->SetSelectFlag( TRUE );
		m_pBandMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

		IDMUSProdDocType* pIDocType;
		ASSERT( pBand->m_pIBandNode == NULL );
		hr = m_pBandMgr->m_pDMProdFramework->FindDocTypeByNodeId( GUID_BandNode, &pIDocType );
		if( SUCCEEDED ( hr ) )
		{
			hr = pIDocType->AllocNode( GUID_BandNode, &pBand->m_pIBandNode );
			pIDocType->Release();
			pIDocType = NULL;
		}
			
		if( SUCCEEDED ( hr ) )
		{
			BSTR bstrBandName = m_pBandMgr->CreateUniqueName();
			pBand->m_strText = bstrBandName;
			pBand->m_pIBandNode->SetNodeName( bstrBandName );
			hr = pBand->m_pIBandNode->SetDocRootNode( m_pStripNode );
			m_pBandMgr->m_pDMProdFramework->AddToNotifyList( pBand->m_pIBandNode, m_pStripNode );
			SendAudiopathToNode( pBand->m_pIBandNode, m_pBandMgr->m_pSegmentState );
		}

		// Open property page
		m_fShowBandProps = TRUE;
		ShowPropertySheet( m_pBandMgr->m_pTimeline );
		// Change to the Band property page
		m_pBandMgr->OnShowProperties();
		
		if( fNewBand )
		{
			m_pBandMgr->AddBand( pBand );
		}

		if( pBand->m_pIBandNode )
		{
			BSTR bstrName;
			pBand->m_pIBandNode->GetNodeName( &bstrName );
			pBand->m_strText = bstrName;
			SysFreeString(bstrName);
		}
		
		m_nLastEdit = IDS_INSERT;
		m_pBandMgr->OnDataChanged();
		// Sequence strip will need to repaint FBar to catch latest DLS region wave names
		m_pBandMgr->m_pTimeline->NotifyStripMgrs( GUID_Segment_BandTrackChange, m_pBandMgr->m_dwGroupBits, NULL );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::Delete

HRESULT CBandStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	/* This may be part of a cut operation.  You can cut empty space, but you can't delete it.
	HRESULT hr = CanDelete();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}
	*/

	ASSERT( m_pBandMgr != NULL );
	if( m_pBandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pBandMgr->m_pTimeline != NULL );
	if( m_pBandMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_pBandMgr->DeleteSelectedBands();
	m_pBandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	if( m_pBandMgr->m_pPropPageMgr )
	{
		m_pBandMgr->m_pPropPageMgr->RefreshData();
	}

	m_pBandMgr->SyncWithDirectMusic();
	m_nLastEdit = IDS_DELETE;
	m_pBandMgr->OnDataChanged();

	// Sequence strip will need to repaint FBar to catch latest DLS region wave names
	m_pBandMgr->m_pTimeline->NotifyStripMgrs( GUID_Segment_BandTrackChange, m_pBandMgr->m_dwGroupBits, NULL );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::SelectAll

HRESULT CBandStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	ASSERT( m_pBandMgr != NULL );
	if( m_pBandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pBandMgr->m_pTimeline != NULL );
	if( m_pBandMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_pBandMgr->SelectAll();

	m_pBandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::CanCut

HRESULT CBandStrip::CanCut( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pBandMgr != NULL );
	if( m_pBandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can cut even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pBandMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pBandMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pBandMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	if( CanCopy() == S_OK && CanDelete() == S_OK )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::CanCopy

HRESULT CBandStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pBandMgr != NULL );
	if( m_pBandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can copy even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pBandMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pBandMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pBandMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	return m_pBandMgr->IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::CanPaste

HRESULT CBandStrip::CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;

	ASSERT( m_pBandMgr != NULL );
	if( m_pBandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfBandTrack == 0 )
	{
		m_cfBandTrack = RegisterClipboardFormat( CF_BANDTRACK );
		if( m_cfBandTrack == 0 )
		{
			return E_FAIL;
		}
	}

	// If pITimelineDataObject != NULL, check it.
	if( pITimelineDataObject != NULL )
	{
		hr = pITimelineDataObject->IsClipFormatAvailable( m_cfBandTrack );
		if( hr != S_OK )
		{
			hr = pITimelineDataObject->IsClipFormatAvailable( m_cfBand );
		}
	}
	// Otherwise, check the clipboard
	else
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		if( SUCCEEDED( OleGetClipboard(&pIDataObject) ) )
		{
			// Create a new TimelineDataObject
			IDMUSProdTimelineDataObject *pITimelineDataObject;
			if( SUCCEEDED( m_pBandMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
			{
				// Insert the IDataObject into the TimelineDataObject
				if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
				{
					hr = pITimelineDataObject->IsClipFormatAvailable(m_cfBandTrack);
					if( hr != S_OK )
					{
						hr = pITimelineDataObject->IsClipFormatAvailable(m_cfBand);
					}
				}
				RELEASE( pITimelineDataObject );
			}
			RELEASE( pIDataObject );
		}
	}
	if (hr == S_OK)
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::CanInsert

HRESULT CBandStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pBandMgr != NULL );
	ASSERT( m_pBandMgr->m_pTimeline != NULL );

	// Get Timeline length
	VARIANT var;
	m_pBandMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineLength = V_I4( &var );

	// Get clock at XPos
	long lClock;
	m_pBandMgr->m_pTimeline->PositionToClocks( m_lXPos, &lClock );

	// Make sure XPos is within strip
	if( lClock > 0 
	&&  lClock < lTimelineLength )
	{
		// User clicked within boundaries of strip
		long lMeasure;
		long lBeat;

		if( SUCCEEDED ( m_pBandMgr->m_pTimeline->PositionToMeasureBeat( m_pBandMgr->m_dwGroupBits,
																		0,
																		m_lXPos,
																		&lMeasure,
																		&lBeat ) ) )
		{
			CPropBand* pBand = GetBandFromPoint( m_lXPos );
			if( pBand == NULL
			||  pBand->m_pIBandNode == NULL )
			{
				return S_OK;
			}
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::CanDelete

HRESULT CBandStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	//CPropBand* pBand;
	//pBand = GetBandFromPoint( m_lXPos );
	//return (pBand != NULL && pBand->m_pIBandNode != NULL) ? S_OK : S_FALSE;
	return m_pBandMgr->IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::RightClickMenuCanSelectAll

HRESULT CBandStrip::RightClickMenuCanSelectAll( void )
{
	CBandItem* pBandItem;

	POSITION pos = m_pBandMgr->m_lstBands.GetHeadPosition();
	while( pos )
	{
		pBandItem = m_pBandMgr->m_lstBands.GetNext( pos );

		if( pBandItem->m_pIBandNode )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::CanSelectAll

HRESULT CBandStrip::CanSelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Always enable when gutter is selected
	if( m_bGutterSelected )
	{
		return S_OK;
	}

	CBandItem* pBandItem;

	POSITION pos = m_pBandMgr->m_lstBands.GetHeadPosition();
	while( pos )
	{
		pBandItem = m_pBandMgr->m_lstBands.GetNext( pos );

		if( pBandItem->m_pIBandNode )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}


// IDropSource Methods

/////////////////////////////////////////////////////////////////////////////
// CBandStrip::QueryContinueDrag

HRESULT CBandStrip::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton & MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton & MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::GiveFeedback

HRESULT CBandStrip::GiveFeedback( DWORD dwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pDragImage )
	{
		CPoint pt;

		GetCursorPos( &pt );

		// Move the drag image
		m_pDragImage->DragMove( pt );
	}

	return DRAGDROP_S_USEDEFAULTCURSORS;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::CreateDragImage

CImageList* CBandStrip::CreateDragImage()
{
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::CreateDataObject

HRESULT	CBandStrip::CreateDataObject(IDataObject** ppIDataObject, long lPosition)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Convert lPosition from pixels to clocks
	long lMeasure, lBeat;
	if( FAILED( m_pBandMgr->m_pTimeline->PositionToMeasureBeat( m_pBandMgr->m_dwGroupBits, 0, lPosition, &lMeasure, &lBeat ) ) )
	{
		return E_UNEXPECTED;
	}
	long lClocks;
	if( FAILED( m_pBandMgr->m_pTimeline->MeasureBeatToClocks( m_pBandMgr->m_dwGroupBits, 0, lMeasure, lBeat, &lClocks ) ) )
	{
		return E_UNEXPECTED;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Selected Bands into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( m_pBandMgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		// mark the bands as being dragged: this used later for deleting bands in drag move
		m_pBandMgr->MarkSelectedBands(UD_DRAGSELECT);
		if( SUCCEEDED ( m_pBandMgr->SaveSelectedBands( pIStream, lClocks, SSB_DRAG ) ) )
		{
			// Place CF_BANDTRACK into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_cfBandTrack, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}


	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	return hr;

}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CBandStrip::DragEnter

HRESULT CBandStrip::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pIDataObject != NULL );
	ASSERT( m_pITargetDataObject == NULL );

	// Store IDataObject associated with current drag-drop operation
	m_pITargetDataObject = pIDataObject;
	m_pITargetDataObject->AddRef();

	if( m_pDragImage )
	{
		CPoint point( pt.x, pt.y );

		CWnd *pWnd = GetTimelineCWnd();
		if( pWnd )
		{
			// Show the feedback image
			m_pDragImage->DragEnter( pWnd->GetDesktopWindow(), point );
		}
	}

	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::DragOver

HRESULT CBandStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if(m_pITargetDataObject == NULL)
		ASSERT( m_pITargetDataObject != NULL );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragShowNolock( FALSE );
	}

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	if( CanPasteFromData( m_pITargetDataObject ) == S_OK )
	{
		BOOL fCF_BAND = FALSE;

		// Does m_pITargetDataObject contain format CF_BAND?
		CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
		if( pDataObject )
		{
			if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( m_pITargetDataObject, m_cfBand ) ) )
			{
				fCF_BAND = TRUE;
			}
			RELEASE( pDataObject );
		}

		// Can only copy CF_BAND data!
		if( fCF_BAND )
		{
			dwEffect = DROPEFFECT_COPY;
		}
		else
		{
			if( grfKeyState & MK_RBUTTON )
			{
				dwEffect = *pdwEffect;
			}
			else
			{
				if( grfKeyState & MK_CONTROL )
				{
					dwEffect = DROPEFFECT_COPY;
				}
				else
				{
					if( *pdwEffect & DROPEFFECT_COPY
					&&  *pdwEffect & DROPEFFECT_MOVE )
					{
						dwEffect = DROPEFFECT_MOVE;
					}
					else
					{
						dwEffect = *pdwEffect;
					}
				}
			}
		}
	}

	if( m_pDragImage )
	{
		// Show the feedback image
		m_pDragImage->DragShowNolock( TRUE );
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::DragLeave

HRESULT CBandStrip::DragLeave( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Release IDataObject
	RELEASE( m_pITargetDataObject );

	if( m_pDragImage )
	{
		CWnd *pWnd = GetTimelineCWnd();
		if( pWnd )
		{
			// Hide the feedback image
			m_pDragImage->DragLeave( pWnd->GetDesktopWindow() );
		}
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::Drop

HRESULT CBandStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pITargetDataObject != NULL );
	ASSERT( m_pITargetDataObject == pIDataObject );

	if( m_pDragImage )
	{
		CWnd *pWnd = GetTimelineCWnd();
		if( pWnd )
		{
			// Hide the feedback image
			m_pDragImage->DragLeave( pWnd->GetDesktopWindow() );
		}
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;
		
		// Display arrow cursor
		::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
	
		// Prepare context menu
		hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Get a window to attach menu to
			CWnd* pWnd = GetTimelineCWnd();
			if( pWnd )
			{
				// Display and track menu
				CPoint point( pt.x, pt.y );
				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, pWnd->GetSafeHwnd(), NULL );
				DestroyMenu( hMenu );

				// Need to process WM_COMMAND from TrackPopupMenu
				MSG msg;
				while( ::PeekMessage( &msg, pWnd->GetSafeHwnd(), NULL, NULL, PM_REMOVE) )
				{
					if( msg.message == WM_COMMAND )
					{
						OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
					}
					else
					{
						TranslateMessage( &msg );
						DispatchMessage( &msg );
					}
				}

				// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
				m_dwOverDragEffect = m_dwDragRMenuEffect;
				m_dwDragRMenuEffect = DROPEFFECT_NONE;
			}
		}
	}

	// Paste data
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pBandMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				MUSIC_TIME mtTime;
				if( SUCCEEDED( m_pBandMgr->m_pTimeline->PositionToClocks( pt.x, &mtTime ) ) )
				{
					BOOL fChanged = FALSE;
					hr = PasteAt( pITimelineDataObject, mtTime, true, fChanged );
					if( hr == S_OK )
					{
						*pdwEffect = m_dwOverDragEffect;

						// If we pasted anything
						if( fChanged )
						{
							if( m_nStripIsDragDropSource )
							{
								// Drag/drop Target and Source are the same Band strip
								m_nStripIsDragDropSource = 2;
							}
							else
							{
								// Set the last edit type
								m_nLastEdit = IDS_PASTE;

								// Update our hosting editor.
								m_pBandMgr->OnDataChanged();

								// Redraw our strip
								m_pBandMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

								// Update the property page
								if( m_pBandMgr->m_pPropPageMgr != NULL )
								{
									m_pBandMgr->m_pPropPageMgr->RefreshData();
								}

								m_pBandMgr->SyncWithDirectMusic();

								// Sequence strip will need to repaint FBar to catch latest DLS region wave names
								m_pBandMgr->m_pTimeline->NotifyStripMgrs( GUID_Segment_BandTrackChange, m_pBandMgr->m_dwGroupBits, NULL );
							}
						}
					}
					else if( hr == S_FALSE )
					{
						*pdwEffect = DROPEFFECT_NONE;
					}
				}
			}
			RELEASE( pITimelineDataObject );
		}
	}

	// Cleanup
	DragLeave();

	return hr;
}


// IDropTarget helpers

/////////////////////////////////////////////////////////////////////////////
// CBandStrip::GetTimelineCWnd

CWnd* CBandStrip::GetTimelineCWnd()
{
	CDC cDC;
	VARIANT vt;
	vt.vt = VT_I4;

	CWnd* pWnd = 0;

	// Get the DC of our Strip
	if( m_pBandMgr->m_pTimeline )
	{
		if( SUCCEEDED(m_pBandMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GET_HDC, &vt )) )
		{
			if( cDC.Attach( (HDC)(vt.lVal) ) != 0 )
			{
				pWnd = cDC.GetWindow();
				cDC.Detach();
			}
			if( pWnd )
			{
				::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(vt.lVal) );
			}
			else
			{
				::ReleaseDC( NULL, (HDC)(vt.lVal) );
			}
		}
	}
	return pWnd;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::CanPasteFromData

HRESULT CBandStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfBandTrack ) ) ||
		SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfBand ) ))
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CBandStrip::GetData

HRESULT CBandStrip::GetData( void **ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (ppData == NULL) || (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	// Check which property page is requesting the data
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		// Copy our groupbits to the location pointed to by ppData
		PPGTrackParams *pPPGTrackParams = static_cast<PPGTrackParams *>(*ppData);
		pPPGTrackParams->dwGroupBits = m_pBandMgr->m_dwGroupBits;
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		// Copy our track setting to the location pointed to by ppData
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);
		pPPGTrackFlagsParams->dwTrackExtrasFlags = m_pBandMgr->m_dwTrackExtrasFlags;
		pPPGTrackFlagsParams->dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
		pPPGTrackFlagsParams->dwProducerOnlyFlags = m_pBandMgr->m_dwProducerOnlyFlags;
		pPPGTrackFlagsParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;
		break;
	}
	default:
		ASSERT(FALSE);
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::SetData

HRESULT CBandStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pData == NULL )
	{
		return E_INVALIDARG;
	}

	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		PPGTrackParams *pPPGTrackParams = reinterpret_cast<PPGTrackParams *>(pData);

		// Update our group bits setting, if necessary
		if( pPPGTrackParams->dwGroupBits != m_pBandMgr->m_dwGroupBits )
		{
			DWORD dwOrigGroupBits = m_pBandMgr->m_dwGroupBits; 
			m_pBandMgr->m_dwGroupBits = pPPGTrackParams->dwGroupBits;

			// Time signature may have changed
			m_pBandMgr->OnUpdate( GUID_TimeSignature, m_pBandMgr->m_dwGroupBits, NULL );

			m_nLastEdit = IDS_UNDO_TRACKGROUP;
			m_pBandMgr->m_pTimeline->OnDataChanged( (IBandMgr*)m_pBandMgr );
			m_pBandMgr->m_dwOldGroupBits = pPPGTrackParams->dwGroupBits;

			// Sequence strip will need to repaint FBar to catch latest DLS region wave names
			m_pBandMgr->m_pTimeline->NotifyStripMgrs( GUID_Segment_BandTrackChange, 
													 (dwOrigGroupBits | m_pBandMgr->m_dwGroupBits),
													  NULL );
		}
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);

		// Update our track extras flags, if necessary
		if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pBandMgr->m_dwTrackExtrasFlags )
		{
			m_pBandMgr->m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;

			// Notify our editor that we've changed
			m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
			m_pBandMgr->m_pTimeline->OnDataChanged( (IBandMgr*)m_pBandMgr );
		}
		// Update our Producer-specific flags, if necessary
		else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_pBandMgr->m_dwProducerOnlyFlags )
		{
			m_pBandMgr->m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;

			// Notify our editor that we've changed
			m_nLastEdit = IDS_UNDO_PRODUCERONLY;
			m_pBandMgr->m_pTimeline->OnDataChanged( (IBandMgr*)m_pBandMgr );
		}
		break;
	}
	default:
		ASSERT(FALSE);
		return E_INVALIDARG;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::OnShowProperties

HRESULT CBandStrip::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to the Timeline
	if( m_pBandMgr->m_pTimeline == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the Framework from the timeline
	IDMUSProdFramework* pIFramework = NULL;
	VARIANT var;
	m_pBandMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	pIFramework = (IDMUSProdFramework*) V_UNKNOWN(&var);
	if (pIFramework == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}


	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	RELEASE( pIFramework );
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		RELEASE( pIPropSheet );
		return S_OK;
	}

	// If our property page is already displayed, exit
	if(m_fPropPageActive)
	{
		ASSERT( m_pPropPageMgr != NULL );
		pIPropSheet->Release();
		return S_OK;
	}

	// Get a reference to our property page manager
	HRESULT hr = S_OK;
	if( m_pPropPageMgr == NULL )
	{
		CGroupBitsPropPageMgr* pPPM = new CGroupBitsPropPageMgr;
		if( NULL == pPPM )
		{
			hr = E_OUTOFMEMORY;
			goto EXIT;
		}
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		m_pPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
		if( FAILED(hr) )
		{
			goto EXIT;
		}
	}

	// Set the property page to refer to the Group bits property page.
	short nActiveTab;
	nActiveTab = CGroupBitsPropPageMgr::sm_nActiveTab;
	m_pBandMgr->m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	m_fPropPageActive = TRUE;
	pIPropSheet->SetActivePage( nActiveTab ); 

EXIT:
	// release our reference to the property sheet
	pIPropSheet->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::OnRemoveFromPageManager

HRESULT CBandStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject(NULL);
	}
	m_fPropPageActive = FALSE;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::ShowPropertySheet

HRESULT CBandStrip::ShowPropertySheet(IDMUSProdTimeline* pTimeline)
{
	HRESULT hr = S_OK;

	// Get a pointer to the property sheet and show it
	VARIANT			var;
	LPUNKNOWN		punk;
	IDMUSProdPropSheet*	pIPropSheet;
	pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	if( var.vt == VT_UNKNOWN )
	{
		punk = V_UNKNOWN( &var );
		if( punk )
		{
			hr = punk->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
			ASSERT( SUCCEEDED( hr ));
			if( FAILED( hr ))
			{
				hr = E_UNEXPECTED;
			}
			else
			{
				pIPropSheet->Show( TRUE );
				RELEASE( pIPropSheet );
			}
			RELEASE( punk );
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::DoDragDrop

BOOL CBandStrip::DoDragDrop( void )
{
	// Drag drop will capture mouse, so release it from timeline
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	m_pBandMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Query ourself for our IDropSource interface
	IDropSource* pIDropSource;
	if( FAILED ( QueryInterface(IID_IDropSource, (void**)&pIDropSource) ) )
	{
		return FALSE;
	}

	DWORD dwEffect = DROPEFFECT_NONE;

	// Create a data object from the selected style references
	HRESULT hr = CreateDataObject( &m_pISourceDataObject, m_lStartDragPosition );
	if( SUCCEEDED( hr ) )
	{
		// Create an image to use when dragging style references
		m_pDragImage = CreateDragImage();
		if( m_pDragImage )
		{
			m_pDragImage->BeginDrag( 0, CPoint(8,12) );
		}

		// We can always copy style references.
		DWORD dwOKDragEffects = DROPEFFECT_COPY;
		if( CanCut() == S_OK )
		{
			// If we can Cut(), allow the user to move the style references as well.
			dwOKDragEffects |= DROPEFFECT_MOVE;
		}

		// Do the Drag/Drop.
		hr = ::DoDragDrop( m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect );

		if( m_pDragImage )
		{
			m_pDragImage->EndDrag();
			delete m_pDragImage;
			m_pDragImage = NULL;
		}

		switch( hr )
		{
			case DRAGDROP_S_DROP:
				if( dwEffect & DROPEFFECT_MOVE )
				{
					m_pBandMgr->DeleteMarked( UD_DRAGSELECT );
				}
				break;

			default:
				dwEffect = DROPEFFECT_NONE;
				break;
		}
		hr = S_OK;
		RELEASE( m_pISourceDataObject );
	}

	RELEASE( pIDropSource );

	m_pBandMgr->UnMarkBands(UD_DRAGSELECT);
	m_pBandMgr->SyncWithDirectMusic();

	if( dwEffect != DROPEFFECT_NONE )
	{
		if( m_nStripIsDragDropSource == 2 )
		{
			// Drag/drop target and source are the same Band strip
			if( dwEffect == DROPEFFECT_MOVE )
			{
				m_nLastEdit = IDS_UNDO_MOVE;
				m_pBandMgr->OnDataChanged();
				// Sequence strip will need to repaint FBar to catch latest DLS region wave names
				m_pBandMgr->m_pTimeline->NotifyStripMgrs( GUID_Segment_BandTrackChange, m_pBandMgr->m_dwGroupBits, NULL );
			}
			else
			{
				m_nLastEdit = IDS_PASTE;
				m_pBandMgr->OnDataChanged();
				// Sequence strip will need to repaint FBar to catch latest DLS region wave names
				m_pBandMgr->m_pTimeline->NotifyStripMgrs( GUID_Segment_BandTrackChange, m_pBandMgr->m_dwGroupBits, NULL );
			}
		}
		else
		{
			if( dwEffect == DROPEFFECT_MOVE )
			{
				m_nLastEdit = IDS_DELETE;
				m_pBandMgr->OnDataChanged();
				// Sequence strip will need to repaint FBar to catch latest DLS region wave names
				m_pBandMgr->m_pTimeline->NotifyStripMgrs( GUID_Segment_BandTrackChange, m_pBandMgr->m_dwGroupBits, NULL );
			}
			else
			{
				m_pBandMgr->UnselectAll();
			}
		}
	}

	if( dwEffect == DROPEFFECT_NONE )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::OnLButtonDown

HRESULT CBandStrip::OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	ASSERT( m_pBandMgr != NULL );
	ASSERT( m_pBandMgr->m_pTimeline != NULL );

	m_fSingleSelect = FALSE;

	// If we're already dragging, just return
	if( m_pDragImage )
	{
		return S_OK;
	}

	// Get Timeline length
	VARIANT var;
	m_pBandMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineLength = V_I4( &var );

	// Exit if user clicked past end of Strip
	long lClock;
	m_pBandMgr->m_pTimeline->PositionToClocks( lXPos, &lClock );
	if( lClock >= lTimelineLength )
	{
		return S_OK;
	}
	
	// Unselect items in other strips
	UnselectGutterRange();

	HRESULT hr = S_OK;

	// Capture mouse so we get the WM_LBUTTONUP message as well.
	// The timeline will release the capture when it receives the
	// WM_LBUTTONUP message.
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pBandMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// See if there is a band under the cursor.
	CBandItem* pBand = GetBandFromPoint( lXPos );
	if( pBand
	&&  pBand->m_pIBandNode)
	{
		// There is a "real" Band on this beat
		if( wParam & MK_CONTROL )
		{
			if( pBand->m_fSelected )
			{
				// Do drag/drop
				m_dwStartDragButton = (unsigned long)wParam;
				m_lStartDragPosition = lXPos;
				m_nStripIsDragDropSource = 1;
		
				BOOL fDrop = DoDragDrop();

				m_dwStartDragButton = 0;
				m_nStripIsDragDropSource = 0;

				if( !fDrop )
				{
					pBand->SetSelectFlag( !pBand->m_fSelected );
					m_pBandMgr->UnMarkBands( UD_CURRENTSELECTION );
					pBand->m_dwBits |= UD_CURRENTSELECTION;
				}
			}
			else
			{
				pBand->SetSelectFlag( !pBand->m_fSelected );
				if( pBand->m_fSelected )
				{
					// Set fields to initiate drag/drop on next mousemove
					m_dwStartDragButton = (unsigned long)wParam;
					m_lStartDragPosition = lXPos;
				}
				m_pBandMgr->UnMarkBands( UD_CURRENTSELECTION );
				pBand->m_dwBits |= UD_CURRENTSELECTION;
			}
		}
		else if( wParam & MK_SHIFT )
		{
			pBand->SetSelectFlag( TRUE );
			SelectRange( pBand );
		}
		else
		{
			if( pBand->m_fSelected == FALSE )
			{
				m_pBandMgr->UnselectAll();
				pBand->SetSelectFlag( TRUE );
				m_pBandMgr->UnMarkBands( UD_CURRENTSELECTION );
				pBand->m_dwBits |= UD_CURRENTSELECTION;
			}
			else
			{
				m_fSingleSelect = TRUE;
			}
			
			// Set fields to initiate drag/drop on next mousemove
			m_dwStartDragButton = (unsigned long)wParam;
			m_lStartDragPosition = lXPos;
		}
	}
	else
	{
		// There is not a "real" Band on this measure
		hr = S_OK;
		if( pBand == NULL )
		{
			// Create a "fake" Band
			hr = m_pBandMgr->CreateBand( lXPos, this, pBand );
		}

		if( SUCCEEDED ( hr ) )
		{
			if( wParam & MK_CONTROL )
			{
				pBand->SetSelectFlag( !pBand->m_fSelected );
				m_pBandMgr->UnMarkBands( UD_CURRENTSELECTION );
				pBand->m_dwBits |= UD_CURRENTSELECTION;
			}
			else if( wParam & MK_SHIFT )
			{
				pBand->SetSelectFlag( TRUE );
				SelectRange( pBand );
			}
			else
			{
				// Click on empty space deselects all
				m_pBandMgr->UnselectAll();

				pBand->SetSelectFlag( TRUE );
				m_pBandMgr->UnMarkBands( UD_CURRENTSELECTION );
				pBand->m_dwBits |= UD_CURRENTSELECTION;
			}
		}
	}

	// Redraw the strip and refresh the Band property page
	m_pBandMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
	m_pBandMgr->OnShowProperties();
	if( m_pBandMgr->m_pPropPageMgr )
	{
		m_pBandMgr->m_pPropPageMgr->RefreshData();
	}

	return hr;
}

// CBandStrip::SelectRange()

HRESULT CBandStrip::SelectRange(CBandItem* pBand)
{
	HRESULT hr = S_OK;
	// select inclusive, find band to start from
	CBandItem* pCurrent = m_pBandMgr->CurrentlySelectedBand();

	// find measure and beat for band to start from and band to end at
	BYTE bEarlyBeat = (pCurrent) ? pCurrent->m_bBeat : 0;
	DWORD dwEarlyMeasure = (pCurrent) ? pCurrent->m_dwMeasure : 0;
	BYTE bLateBeat = pBand->m_bBeat;
	DWORD dwLateMeasure = pBand->m_dwMeasure;

	// if the order is backwards, swap
	if ( dwLateMeasure < dwEarlyMeasure ||
		 (dwLateMeasure == dwEarlyMeasure && bLateBeat < bEarlyBeat) )
	{
		BYTE bTemp = bEarlyBeat;
		bEarlyBeat = bLateBeat;
		bLateBeat = bTemp;
		DWORD dwTemp = dwEarlyMeasure;
		dwEarlyMeasure = dwLateMeasure;
		dwLateMeasure = dwTemp;
	}

	// add empty empty bands to fill in gaps
	BYTE bCurrentBeat = bEarlyBeat;
	DWORD dwCurrentMeasure = dwEarlyMeasure;
	CBandItem* pBandItem = NULL;
	while( dwCurrentMeasure <= dwLateMeasure &&
		   ( bCurrentBeat <= bLateBeat || dwCurrentMeasure < dwLateMeasure ) )
	{
		long lCheckClocks, lCheckMeasure, lCheckBeat;
		m_pBandMgr->m_pTimeline->MeasureBeatToClocks( m_pBandMgr->m_dwGroupBits, 0, dwCurrentMeasure, bCurrentBeat, &lCheckClocks );
		m_pBandMgr->m_pTimeline->ClocksToMeasureBeat( m_pBandMgr->m_dwGroupBits, 0, lCheckClocks, &lCheckMeasure, &lCheckBeat );
		if( lCheckMeasure == (long) dwCurrentMeasure
		||  lCheckBeat == (long) bCurrentBeat )
		{
			// We don't want to create bands on invalidate beats
			// when range crosses time sig changes
			if ( !m_pBandMgr->FindBand(dwCurrentMeasure, (long) bCurrentBeat) )
			{
				pBandItem = NULL;
				hr = m_pBandMgr->CreateBand(dwCurrentMeasure, bCurrentBeat, this, pBandItem);
			}
		}

		bCurrentBeat++;
		DMUS_TIMESIGNATURE TS;
		long lClocks = 0;
		m_pBandMgr->m_pTimeline->MeasureBeatToClocks( 
				m_pBandMgr->m_dwGroupBits, 
				0, 
				dwCurrentMeasure, 
				(long) bCurrentBeat, 
				&lClocks );
		hr = m_pBandMgr->m_pTimeline->GetParam(
			GUID_TimeSignature, 
			m_pBandMgr->m_dwGroupBits, 
			0, 
			lClocks, 
			NULL, 
			(void*) &TS);
		ASSERT(SUCCEEDED(hr));
		BYTE bBeats = 4;  // assume 4/4 if the above call fails
		if (SUCCEEDED(hr))
		{
			bBeats = TS.bBeatsPerMeasure;
		}
		if (bCurrentBeat >= bBeats) // BUGBUG need timesig here!
		{
			bCurrentBeat = 0;
			dwCurrentMeasure++;
		}
	}
	m_pBandMgr->UnselectAllKeepBits();

	// select all bands in the range (can't simply select bands in the
	// above loop, because there may be multiple bands at the same
	// measure/beat)
	POSITION pos = m_pBandMgr->m_lstBands.GetHeadPosition();
	pBandItem = NULL;
	while( pos )
	{
		pBandItem = m_pBandMgr->m_lstBands.GetNext( pos );
		ASSERT( pBandItem );
		if( pBandItem->m_dwMeasure >= dwEarlyMeasure &&
			pBandItem->m_dwMeasure <= dwLateMeasure &&
			( pBandItem->m_dwMeasure != dwEarlyMeasure || 
			  pBandItem->m_bBeat >= bEarlyBeat) &&
			( pBandItem->m_dwMeasure != dwLateMeasure || 
			  pBandItem->m_bBeat <= bLateBeat) )
		{
			pBandItem->m_fSelected = TRUE;
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBandStrip::UnselectGutterRange

void CBandStrip::UnselectGutterRange( void )
{
	ASSERT( m_pBandMgr->m_pTimeline != NULL );

	// Make sure everything on the timeline is deselected.
	m_bSelecting = TRUE;
	m_pBandMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pBandMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_bSelecting = FALSE;
}
	

/////////////////////////////////////////////////////////////////////////////
// CBandStrip::AddBandNode

HRESULT CBandStrip::AddBandNode( IDMUSProdNode* pIBandNode, MUSIC_TIME mtTime )
{
	// Only called in response to the GUID_Segment_NewStyleSelected notification.
	// Note that due to bug 28541, we now append a "1" to the end of the band name.

	CBandItem* pBand = new CBandItem( this );
	if( pBand == NULL )
	{
		return E_OUTOFMEMORY;
	}

	pBand->SetTimePhysical( mtTime, STP_LOGICAL_SET_DEFAULT );

	HRESULT hr = E_FAIL;

	IDMUSProdDocType* pIDocType;
	IPersistStream* pIBandNodePS;
	IPersistStream* pIPS;
	IStream* pIMemStream;
	BSTR bstrName;

	if( SUCCEEDED ( m_pBandMgr->m_pDMProdFramework->FindDocTypeByNodeId( GUID_BandNode, &pIDocType ) ) )
	{
		if( SUCCEEDED ( pIDocType->AllocNode( GUID_BandNode, &pBand->m_pIBandNode ) ) )
		{
			if( SUCCEEDED ( pIBandNode->QueryInterface( IID_IPersistStream, (void**)&pIBandNodePS ) ) )
			{
				if( SUCCEEDED ( m_pBandMgr->m_pDMProdFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pIMemStream ) ) )
				{
					if( SUCCEEDED ( pIBandNodePS->Save( pIMemStream, FALSE ) ) )
					{
						StreamSeek( pIMemStream, 0, STREAM_SEEK_SET ); //seek to beginning

						if( SUCCEEDED ( pBand->m_pIBandNode->QueryInterface( IID_IPersistStream, (void**)&pIPS ) ) )
						{
							if( SUCCEEDED ( pIPS->Load( pIMemStream ) ) )
							{
								// Set  name of Band
								pBand->m_pIBandNode->GetNodeName( &bstrName );
								pBand->m_strText = bstrName;
								pBand->m_strText += _T("1");
								SysFreeString( bstrName );

								// Set Band's DocRoot node
								hr = pBand->m_pIBandNode->SetDocRootNode( m_pStripNode );

								// Set notifications
								m_pBandMgr->m_pDMProdFramework->AddToNotifyList( pBand->m_pIBandNode, m_pStripNode );

								// Hook it up with our audiopath
								SendAudiopathToNode( pBand->m_pIBandNode, m_pBandMgr->m_pSegmentState );

								// Everything is ok
								hr = S_OK;
							}

							RELEASE( pIPS );
						}
					}
				
					RELEASE( pIMemStream );
				}

				RELEASE( pIBandNodePS );
			}
		}

		RELEASE( pIDocType );
	}
		
	if( SUCCEEDED ( hr ) )
	{
		m_pBandMgr->InsertByAscendingTime( pBand, TRUE );
		m_pBandMgr->SyncWithDirectMusic();
	}
	else
	{
		delete pBand;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandStripMgr\PropBand.cpp ===
#include "stdafx.h"
#include "PropBand.h"
#include "BandIO.h"

CPropBand::CPropBand()
{
	m_mtTimePhysical = 0;
	m_mtTimeLogical = 0;
	m_dwMeasure = 0;
	m_bBeat = 0;
	m_lTick = 0;
	m_lLogicalMeasure = 0;
	m_lLogicalBeat = 0;
	m_strText.Empty();
	m_dwBits = 0;
	m_wFlags = 0;
	m_pIBandNode = NULL;
}


CPropBand::CPropBand(const CBandItem *pBandItem)
{
	m_mtTimePhysical = pBandItem->m_mtTimePhysical;
	m_mtTimeLogical = pBandItem->m_mtTimeLogical;
	m_dwMeasure = pBandItem->m_dwMeasure;
	m_bBeat = pBandItem->m_bBeat;
	m_lTick = pBandItem->m_lTick;
	m_lLogicalMeasure = pBandItem->m_lLogicalMeasure;
	m_lLogicalBeat = pBandItem->m_lLogicalBeat;
	m_strText = pBandItem->m_strText;
	m_dwBits = 0;
	m_wFlags = 0;

	m_pIBandNode = pBandItem->m_pIBandNode;
	if( m_pIBandNode )
	{
		m_pIBandNode->AddRef();
	}
}

CPropBand::~CPropBand()
{
	if( m_pIBandNode )
	{
		m_pIBandNode->Release();
	}
}

void CPropBand::ApplyToBandItem( CBandItem *pBandItem ) const
{
	ASSERT( pBandItem != NULL );
	if( pBandItem == NULL )
	{
		return;
	}

	pBandItem->m_mtTimePhysical = m_mtTimePhysical;
	pBandItem->m_mtTimeLogical = m_mtTimeLogical;
	pBandItem->m_dwMeasure = m_dwMeasure;
	pBandItem->m_bBeat = m_bBeat;
	pBandItem->m_lTick = m_lTick;
	pBandItem->m_lLogicalMeasure = m_lLogicalMeasure;
	pBandItem->m_lLogicalBeat = m_lLogicalBeat;
	pBandItem->m_strText = m_strText;

	if( pBandItem->m_pIBandNode )
	{
		pBandItem->m_pIBandNode->Release();
	}
	pBandItem->m_pIBandNode = m_pIBandNode;
	if( pBandItem->m_pIBandNode )
	{
		pBandItem->m_pIBandNode->AddRef();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandStripMgr\PropPageBand.cpp ===
// PropPageBand.cpp : implementation file
//

#include "stdafx.h"
#include <DMUSProd.h>
#include <Conductor.h>
#include "BandMgr.h"
#include "PropBand.h"
#include "PropPageMgr.h"
#include "PropPageBand.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CBandPropPageMgr constructor/destructor

CBandPropPageMgr::CBandPropPageMgr( CBandMgr* pBandMgr )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pBandMgr != NULL );
	m_pBandMgr = pBandMgr;

	m_pPropPageBand = NULL;
	
	CStaticPropPageManager::CStaticPropPageManager();
}

CBandPropPageMgr::~CBandPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageBand )
	{
		delete m_pPropPageBand;
		m_pPropPageBand = NULL;
	}
	CStaticPropPageManager::~CStaticPropPageManager();
}


/////////////////////////////////////////////////////////////////////////////
// CBandPropPageMgr IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CBandPropPageMgr::QueryInterface

HRESULT STDMETHODCALLTYPE CBandPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Just call the base class implementation
	return CStaticPropPageManager::QueryInterface( riid, ppv );
};


/////////////////////////////////////////////////////////////////////////////
// CBandPropPageMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CBandPropPageMgr::GetPropertySheetTitle

HRESULT STDMETHODCALLTYPE CBandPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;

	// Get and store the title.
	strTitle.LoadString( IDS_PROPPAGE_BAND );
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CBandPropPageMgr::GetPropertySheetPages

HRESULT STDMETHODCALLTYPE CBandPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add Band tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	if(!m_pPropPageBand)
		m_pPropPageBand = new PropPageBand();

	if( m_pPropPageBand )
	{
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pPropPageBand->m_psp, sizeof(PROPSHEETPAGE) );

		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		m_pPropPageBand->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CBandPropPageMgr::RefreshData

HRESULT STDMETHODCALLTYPE CBandPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropBand* pBand = NULL;
	HRESULT hr = S_OK;

	if( m_pIPropPageObject == NULL )
	{
		pBand = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pBand ) ) )
	{
		pBand = NULL;
		hr = E_FAIL;
	}

	if( m_pPropPageBand )
	{
		m_pPropPageBand->m_fMultipleBandsSelected = FALSE;
		m_pPropPageBand->m_fHaveData = FALSE;

		if( pBand )
		{
			if( pBand->m_dwMeasure == 0xFFFFFFFF )
			{
				m_pPropPageBand->m_fMultipleBandsSelected = TRUE;
			}
			else
			{
				m_pPropPageBand->m_fHaveData = TRUE;
			}
			m_pPropPageBand->CopyDataToBand( pBand );
		}
		else
		{
			CPropBand Band;
			m_pPropPageBand->CopyDataToBand( &Band );
		}

		m_pPropPageBand->UpdateControls();
	}

	if( pBand )
	{
		delete pBand;
	}

	return hr;
};

void CBandPropPageMgr::UpdateObjectWithBandData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pIPropPageObject != NULL );

	CPropBand Band;

	// Populate the Band structure
	m_pPropPageBand->GetDataFromBand( &Band );

	// Send the new data to the PropPageObject
	m_pIPropPageObject->SetData( (void *)&Band );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageBand property page

IMPLEMENT_DYNCREATE(PropPageBand, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// PropPageBand constructor/destructor

PropPageBand::PropPageBand(): CPropertyPage(PropPageBand::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_BAND_PROPPAGE);
	//{{AFX_DATA_INIT(PropPageBand)
	//}}AFX_DATA_INIT
	m_pPropPageMgr = NULL;
	m_fHaveData = FALSE;
	m_fMultipleBandsSelected = FALSE;
	m_fNeedToDetach = FALSE;
	m_pBand = new CPropBand;
}

PropPageBand::~PropPageBand()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	if( m_pBand )
	{
		delete m_pBand;
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageBand::DoDataExchange

void PropPageBand::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(PropPageBand)
	DDX_Control(pDX, IDC_SPIN_BELONGS_MEASURE, m_spinLogicalMeasure);
	DDX_Control(pDX, IDC_SPIN_BELONGS_BEAT, m_spinLogicalBeat);
	DDX_Control(pDX, IDC_EDIT_BELONGS_MEASURE, m_editLogicalMeasure);
	DDX_Control(pDX, IDC_EDIT_BELONGS_BEAT, m_editLogicalBeat);
	DDX_Control(pDX, IDC_EDIT_BEAT, m_editBeat);
	DDX_Control(pDX, IDC_EDIT_BAND, m_editBand);
	DDX_Control(pDX, IDC_EDIT_MEASURE, m_editMeasure);
	DDX_Control(pDX, IDC_EDIT_TICK, m_editTick);
	DDX_Control(pDX, IDC_SPIN_TICK, m_spinTick);
	DDX_Control(pDX, IDC_SPIN_MEASURE, m_spinMeasure);
	DDX_Control(pDX, IDC_SPIN_BEAT, m_spinBeat);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPageBand, CPropertyPage)
	//{{AFX_MSG_MAP(PropPageBand)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BEAT, OnDeltaposSpinBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MEASURE, OnDeltaposSpinMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_TICK, OnDeltaposSpinTick)
	ON_EN_KILLFOCUS(IDC_EDIT_BEAT, OnKillfocusEditBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_BAND, OnKillfocusEditBand)
	ON_EN_KILLFOCUS(IDC_EDIT_MEASURE, OnKillfocusEditMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_TICK, OnKillfocusEditTick)
	ON_WM_KILLFOCUS()
	ON_EN_KILLFOCUS(IDC_EDIT_BELONGS_BEAT, OnKillFocusEditLogicalBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_BELONGS_MEASURE, OnKillFocusEditLogicalMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BELONGS_BEAT, OnDeltaPosSpinLogicalBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BELONGS_MEASURE, OnDeltaPosSpinLogicalMeasure)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPageBand custom functions

/////////////////////////////////////////////////////////////////////////////
// PropPageBand::UpdateControls

void PropPageBand::UpdateControls( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Controls not created yet
	if( IsWindow( m_hWnd ) == 0 )
	{
		return;
	}

	ASSERT( m_pBand );
	if( m_pBand == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.

	// Set enable state of controls
	EnableControls( m_fHaveData );

	// Band name
	CString strTemp;
	CString strBandName;
	if( m_fMultipleBandsSelected )
	{
		strBandName.LoadString( IDS_MULTIPLE_SELECT );
	}
	else
	{
		if( m_fHaveData )
		{
			strBandName = m_pBand->m_strText;
		}
	}
	m_editBand.GetWindowText( strTemp );
	if( strBandName != strTemp )
	{
		m_editBand.SetWindowText( strBandName );
	}

	if( m_fHaveData == FALSE )
	{
		return;
	}

	// Measure
	if( m_pBand->m_dwMeasure != (DWORD)(m_spinMeasure.GetPos() - 1) )
	{
		m_spinMeasure.SetPos( m_pBand->m_dwMeasure + 1 );
	}

	// Beat
	if( m_pBand->m_bBeat != (m_spinBeat.GetPos() - 1) )
	{
		m_spinBeat.SetPos( m_pBand->m_bBeat + 1 );
	}

	// Tick
	if( m_pBand->m_lTick != m_spinTick.GetPos() )
	{
		m_spinTick.SetPos( m_pBand->m_lTick );
	}

	// Logical Measure
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pBandMgr
	&&  m_pPropPageMgr->m_pBandMgr->IsRefTimeTrack() == false )
	{
		if( m_pBand->m_lLogicalMeasure != (m_spinLogicalMeasure.GetPos() - 1) )
		{
			m_spinLogicalMeasure.SetPos( m_pBand->m_lLogicalMeasure + 1 );
		}

		// Logical Beat
		if( m_pBand->m_lLogicalBeat != (m_spinLogicalBeat.GetPos() - 1) )
		{
			m_spinLogicalBeat.SetPos( m_pBand->m_lLogicalBeat + 1 );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageBand message handlers

/////////////////////////////////////////////////////////////////////////////
// PropPageBand::OnCreate

int PropPageBand::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// PropPageBand::OnDestroy

void PropPageBand::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// PropPageBand::OnInitDialog

BOOL PropPageBand::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();

	m_editBand.LimitText( DMUS_MAX_NAME );
	
	m_spinMeasure.SetRange( 1, 32767 );
	m_editMeasure.LimitText( 5 );

	m_spinBeat.SetRange( 1, 256 );
	m_editBeat.LimitText( 3 );
	
	m_spinTick.SetRange( -MAX_TICK, MAX_TICK );
	m_editTick.LimitText( 5 );
	
	m_spinLogicalMeasure.SetRange( 1, 32767 );
	m_editLogicalMeasure.LimitText( 5 );

	m_spinLogicalBeat.SetRange( 1, 256 );
	m_editLogicalBeat.LimitText( 3 );

	// Update the dialog
	UpdateControls();

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

BEGIN_EVENTSINK_MAP(PropPageBand, CPropertyPage)
    //{{AFX_EVENTSINK_MAP(PropPageBand)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void PropPageBand::OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fHaveData )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Need to do this in case the user clicked the spin control immediately after
		// typing in a value
		OnKillfocusEditBeat();

		int nNewValue = m_pBand->m_bBeat + pNMUpDown->iDelta;

		if( nNewValue != m_pBand->m_bBeat )
		{
			m_pBand->m_bBeat = (BYTE)nNewValue;
			m_pPropPageMgr->UpdateObjectWithBandData();
		}
	}

	*pResult = 1;
}

void PropPageBand::OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fHaveData )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Need to do this in case the user clicked the spin control immediately after
		// typing in a value
		OnKillfocusEditMeasure();

		int nNewValue = LOWORD(m_spinMeasure.GetPos()) + pNMUpDown->iDelta;
		if( nNewValue < 1 )
		{
			nNewValue = 1;
		}
		else if( nNewValue > 32767 )
		{
			nNewValue = 32767;
		}
		nNewValue--;

		if( (DWORD)nNewValue != m_pBand->m_dwMeasure )
		{
			m_pBand->m_dwMeasure = nNewValue;
			m_pPropPageMgr->UpdateObjectWithBandData();
		}
	}

	*pResult = 1;
}

void PropPageBand::OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fHaveData )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Need to do this in case the user clicked the spin control immediately after
		// typing in a value
		OnKillfocusEditTick();

		int nNewValue = m_pBand->m_lTick + pNMUpDown->iDelta;
		if( nNewValue < -MAX_TICK )
		{
			nNewValue = -MAX_TICK;
		}

		if( nNewValue != m_pBand->m_lTick )
		{
			m_pBand->m_lTick = nNewValue;
			m_pPropPageMgr->UpdateObjectWithBandData();
		}
	}

	*pResult = 1;
}

void PropPageBand::OnDeltaPosSpinLogicalBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fHaveData )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Need to do this in case the user clicked the spin control immediately after
		// typing in a value
		OnKillFocusEditLogicalBeat();

		int nNewValue = m_pBand->m_lLogicalBeat + pNMUpDown->iDelta;

		if( nNewValue != m_pBand->m_lLogicalBeat )
		{
			m_pBand->m_lLogicalBeat = nNewValue;
			m_pPropPageMgr->UpdateObjectWithBandData();
		}
	}

	*pResult = 1;
}

void PropPageBand::OnDeltaPosSpinLogicalMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fHaveData )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Need to do this in case the user clicked the spin control immediately after
		// typing in a value
		OnKillFocusEditLogicalMeasure();

		int nNewValue = LOWORD(m_spinLogicalMeasure.GetPos()) + pNMUpDown->iDelta;
		if( nNewValue < 1 )
		{
			nNewValue = 1;
		}
		else if( nNewValue > 32767 )
		{
			nNewValue = 32767;
		}
		nNewValue--;

		if( nNewValue != m_pBand->m_lLogicalMeasure )
		{
			m_pBand->m_lLogicalMeasure = nNewValue;
			m_pPropPageMgr->UpdateObjectWithBandData();
		}
	}

	*pResult = 1;
}

void PropPageBand::OnKillFocusEditLogicalBeat() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewLogicalBeat;

	m_editLogicalBeat.GetWindowText( strNewLogicalBeat );

	// Strip leading and trailing spaces
	strNewLogicalBeat.TrimRight();
	strNewLogicalBeat.TrimLeft();

	if( strNewLogicalBeat.IsEmpty() )
	{
		m_spinLogicalBeat.SetPos( m_pBand->m_lLogicalBeat + 1 );
	}
	else
	{
		int iNewLogicalBeat = _ttoi( strNewLogicalBeat );
		if( iNewLogicalBeat > 256 )
		{
			iNewLogicalBeat = 256;
		}
		else if( iNewLogicalBeat < 1 )
		{
			iNewLogicalBeat = 1;
		}

		m_spinLogicalBeat.SetPos( iNewLogicalBeat );

		iNewLogicalBeat--;
		if( iNewLogicalBeat != m_pBand->m_lLogicalBeat )
		{
			m_pBand->m_lLogicalBeat = iNewLogicalBeat;
			m_pPropPageMgr->UpdateObjectWithBandData();
		}
	}
}

void PropPageBand::OnKillFocusEditLogicalMeasure() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewLogicalMeasure;

	m_editLogicalMeasure.GetWindowText( strNewLogicalMeasure );

	// Strip leading and trailing spaces
	strNewLogicalMeasure.TrimRight();
	strNewLogicalMeasure.TrimLeft();

	if( strNewLogicalMeasure.IsEmpty() )
	{
		m_spinLogicalMeasure.SetPos( m_pBand->m_lLogicalMeasure + 1 );
	}
	else
	{
		int iNewLogicalMeasure = _ttoi( strNewLogicalMeasure );
		if( iNewLogicalMeasure > 32767 )
		{
			iNewLogicalMeasure = 32767;
		}
		else if( iNewLogicalMeasure < 1 )
		{
			iNewLogicalMeasure = 1;
		}

		m_spinLogicalMeasure.SetPos( iNewLogicalMeasure );
		
		iNewLogicalMeasure--;
		if( iNewLogicalMeasure != m_pBand->m_lLogicalMeasure )
		{
			m_pBand->m_lLogicalMeasure = iNewLogicalMeasure;
			m_pPropPageMgr->UpdateObjectWithBandData();
		}
	}
}

void PropPageBand::OnKillfocusEditBeat() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewBeat;

	m_editBeat.GetWindowText( strNewBeat );

	// Strip leading and trailing spaces
	strNewBeat.TrimRight();
	strNewBeat.TrimLeft();

	if( strNewBeat.IsEmpty() )
	{
		m_spinBeat.SetPos( m_pBand->m_bBeat + 1 );
	}
	else
	{
		int iNewBeat = _ttoi( strNewBeat );
		if( iNewBeat > 256 )
		{
			iNewBeat = 256;
		}
		else if( iNewBeat < 1 )
		{
			iNewBeat = 1;
		}

		m_spinBeat.SetPos( iNewBeat );

		iNewBeat--;
		if( iNewBeat != m_pBand->m_bBeat )
		{
			m_pBand->m_bBeat = (BYTE)iNewBeat;
			m_pPropPageMgr->UpdateObjectWithBandData();
		}
	}
}

void PropPageBand::OnKillfocusEditMeasure() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewMeasure;

	m_editMeasure.GetWindowText( strNewMeasure );

	// Strip leading and trailing spaces
	strNewMeasure.TrimRight();
	strNewMeasure.TrimLeft();

	if( strNewMeasure.IsEmpty() )
	{
		m_spinMeasure.SetPos( m_pBand->m_dwMeasure + 1 );
	}
	else
	{
		int iNewMeasure = _ttoi( strNewMeasure );
		if( iNewMeasure > 32767 )
		{
			iNewMeasure = 32767;
		}
		else if( iNewMeasure < 1 )
		{
			iNewMeasure = 1;
		}

		m_spinMeasure.SetPos( iNewMeasure );
		
		iNewMeasure--;
		if( (DWORD)iNewMeasure != m_pBand->m_dwMeasure )
		{
			m_pBand->m_dwMeasure = iNewMeasure;
			m_pPropPageMgr->UpdateObjectWithBandData();
		}
	}
}

void PropPageBand::OnKillfocusEditTick() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewTick;

	m_editTick.GetWindowText( strNewTick );

	// Strip leading and trailing spaces
	strNewTick.TrimRight();
	strNewTick.TrimLeft();

	if( strNewTick.IsEmpty() )
	{
		m_spinTick.SetPos( m_pBand->m_lTick );
	}
	else
	{
		CString strMinus;
		strMinus.LoadString( IDS_MINUS_SIGN );

		CString strLeftChar = strNewTick.Left( 1 );
		CString strRightChars = strNewTick.Right( strNewTick.GetLength() - 1 );

		int iNewTick;

		// 1st char of '-' means negative number
		if( strMinus.CompareNoCase( strLeftChar ) == 0 )
		{
			iNewTick = _ttoi( strRightChars );
			iNewTick *= -1;
		}
		else
		{
			iNewTick = _ttoi( strNewTick );
		}
			
		if( iNewTick > MAX_TICK )
		{
			iNewTick = MAX_TICK;
		}
		else if( iNewTick < -MAX_TICK )
		{
			iNewTick = -MAX_TICK;
		}

		m_spinTick.SetPos( iNewTick );

		if( iNewTick != m_pBand->m_lTick )
		{
			m_pBand->m_lTick = iNewTick;
			m_pPropPageMgr->UpdateObjectWithBandData();
		}
	}
}

void PropPageBand::OnKillfocusEditBand() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strText;
	m_editBand.GetWindowText( strText );

	// Strip leading and trailing spaces
	strText.TrimRight();
	strText.TrimLeft();

	if( strText.IsEmpty() )
	{
		m_editBand.SetWindowText( m_pBand->m_strText );
	}
	else
	{
		if( strText != m_pBand->m_strText )
		{
			m_pBand->m_strText = strText;
			m_pPropPageMgr->UpdateObjectWithBandData();
		}
	}
}

BOOL PropPageBand::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}
	
	return CPropertyPage::OnSetActive();
}

void PropPageBand::EnableControls( BOOL fEnable )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		return;
	}

	m_spinMeasure.EnableWindow( fEnable );
	m_spinBeat.EnableWindow( fEnable );
	m_spinTick.EnableWindow( fEnable );
	m_editMeasure.EnableWindow( fEnable );
	m_editBeat.EnableWindow( fEnable );
	m_editTick.EnableWindow( fEnable );
	m_editBand.EnableWindow( fEnable );

	if( fEnable == FALSE )
	{
		m_editMeasure.SetWindowText( NULL );
		m_editBeat.SetWindowText( NULL );
		m_editTick.SetWindowText( NULL );
	}

	BOOL fEnableBelongsTo = FALSE;
	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pBandMgr
	&&  m_pPropPageMgr->m_pBandMgr->IsRefTimeTrack() == false )
	{
		fEnableBelongsTo = fEnable;
	}

	m_spinLogicalMeasure.EnableWindow( fEnableBelongsTo );
	m_spinLogicalBeat.EnableWindow( fEnableBelongsTo );
	m_editLogicalMeasure.EnableWindow( fEnableBelongsTo );
	m_editLogicalBeat.EnableWindow( fEnableBelongsTo );

	if( fEnableBelongsTo == FALSE )
	{
		m_editLogicalMeasure.SetWindowText( NULL );
		m_editLogicalBeat.SetWindowText( NULL );
	}
}

void PropPageBand::CopyDataToBand( CPropBand* pBand )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pBand != NULL );

	m_pBand->m_mtTimePhysical  = pBand->m_mtTimePhysical;
	m_pBand->m_mtTimeLogical   = pBand->m_mtTimeLogical;
	m_pBand->m_dwMeasure	   = pBand->m_dwMeasure;
	m_pBand->m_bBeat		   = pBand->m_bBeat;
	m_pBand->m_lTick		   = pBand->m_lTick;
	m_pBand->m_lLogicalMeasure = pBand->m_lLogicalMeasure;
	m_pBand->m_lLogicalBeat	   = pBand->m_lLogicalBeat;
	m_pBand->m_dwBits		   = pBand->m_dwBits;
	m_pBand->m_wFlags		   = pBand->m_wFlags;
	m_pBand->m_strText		   = pBand->m_strText;

	if( m_pBand->m_pIBandNode )
	{
		m_pBand->m_pIBandNode->Release();
		m_pBand->m_pIBandNode = NULL;
	}
	m_pBand->m_pIBandNode = pBand->m_pIBandNode;
	if( m_pBand->m_pIBandNode )
	{
		m_pBand->m_pIBandNode->AddRef();
	}
}

void PropPageBand::GetDataFromBand( CPropBand* pBand )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pBand != NULL );

	pBand->m_mtTimePhysical	 = m_pBand->m_mtTimePhysical;
	pBand->m_mtTimeLogical	 = m_pBand->m_mtTimeLogical;
	pBand->m_dwMeasure		 = m_pBand->m_dwMeasure;
	pBand->m_bBeat			 = m_pBand->m_bBeat;
	pBand->m_lTick			 = m_pBand->m_lTick;
	pBand->m_lLogicalMeasure = m_pBand->m_lLogicalMeasure;
	pBand->m_lLogicalBeat	 = m_pBand->m_lLogicalBeat;
	pBand->m_dwBits			 = m_pBand->m_dwBits;
	pBand->m_wFlags			 = m_pBand->m_wFlags;
	pBand->m_strText		 = m_pBand->m_strText;

	if( pBand->m_pIBandNode )
	{
		pBand->m_pIBandNode->Release();
		pBand->m_pIBandNode = NULL;
	}
	pBand->m_pIBandNode = m_pBand->m_pIBandNode;
	if( pBand->m_pIBandNode )
	{
		pBand->m_pIBandNode->AddRef();
	}
}

BOOL PropPageBand::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !m_fHaveData )
	{
		return CPropertyPage::PreTranslateMessage( pMsg );
	}

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_EDIT_BAND: 
								m_editBand.SetWindowText( m_pBand->m_strText );
								break;

							case IDC_EDIT_MEASURE: 
								m_spinMeasure.SetPos( m_pBand->m_dwMeasure + 1 );
								break;

							case IDC_EDIT_BEAT:
								m_spinBeat.SetPos( m_pBand->m_bBeat + 1 );
								break;

							case IDC_EDIT_TICK:
								m_spinTick.SetPos( m_pBand->m_lTick );
								break;

							case IDC_EDIT_BELONGS_MEASURE: 
								m_spinLogicalMeasure.SetPos( m_pBand->m_lLogicalMeasure + 1 );
								break;

							case IDC_EDIT_BELONGS_BEAT:
								m_spinLogicalBeat.SetPos( m_pBand->m_lLogicalBeat + 1 );
								break;
						}
					}
					return TRUE;
				}

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandStripMgr\PropPageMgr.h ===
// PropPageMgr.h : Handles the property pages

#ifndef __PROPPAGEMGR_H_
#define __PROPPAGEMGR_H_

#include <staticproppagemanager.h>

class PropPageBand;
class CBandMgr;

class CBandPropPageMgr : CStaticPropPageManager
{
	friend PropPageBand;
public:
	CBandPropPageMgr( CBandMgr* pBandMgr );
	~CBandPropPageMgr();

	// IUnknown methods
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );

	// IDMUSProdPropPageManager methods
	HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
	HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE RefreshData();

	// Additional methods
	void UpdateObjectWithBandData();

private:
	PropPageBand*	m_pPropPageBand;
	CBandMgr*		m_pBandMgr;
};

#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BandStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_BAND               101
#define IDR_BANDMGR                     102
#define IDS_DELETE                      102
#define IDS_PASTE                       103
#define IDS_INSERT                      104
#define IDS_TRACK_NAME                  105
#define IDD_BAND_PROPPAGE_OLD           105
#define IDS_EDITOR_NAME                 106
#define IDD_BAND_PROPPAGE               106
#define IDS_PROPPAGE_GROUP_BITS         107
#define IDS_MULTIPLE_SELECT             108
#define IDS_UNDO_BANDNAME               109
#define IDS_UNDO_MOVE                   110
#define IDS_UNDO_TRACKGROUP             111
#define IDS_MINUS_SIGN                  112
#define IDS_EMPTY_TEXT                  113
#define IDS_BANDS_TEXT                  114
#define IDS_BAND_TEXT                   115
#define IDS_UNDO_LOGICAL_TIME           116
#define IDS_INSERT_INSTRUMENT           117
#define IDS_UNDO_BANDCHANGE             118
#define IDR_EDIT_RMENU                  201
#define IDI_BANDTRUCK                   210
#define IDC_EDIT_BAND                   223
#define IDC_EDIT_MEASURE                224
#define IDC_EDIT_BEAT                   225
#define IDC_EDIT_TICK                   226
#define IDC_EDIT_BELONGS_MEASURE        227
#define IDC_EDIT_TIME                   228
#define IDC_EDIT_BELONGS_BEAT           228
#define IDC_SPIN_MEASURE                229
#define IDC_SPIN_BEAT                   230
#define IDC_SPIN_TICK                   231
#define IDC_SPIN_BELONGS_MEASURE        232
#define IDC_SPIN_BELONGS_BEAT           233
#define IDM_DRAG_RMENU                  243
#define IDR_BANDMENU                    444
#define ID_VIEW_PROPERTIES              32768
#define IDM_CYCLE_BANDS                 32769
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define ID_EDIT_PASTE_MERGE             32797
#define ID_EDIT_PASTE_OVERWRITE         32798
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808
#define ID_OPEN_BANDEDITOR              32810
#define ID_INSERT_NEWINSTRUMENT         32811
#define ID_LOCATE_BAND                  32812
#define ID_EDIT_DELETE_TRACK            32900
#define ID_EDIT_ADD_TRACK               32901
#define IDS_UNDO_TRACKEXTRAS            57718
#define IDS_UNDO_PRODUCERONLY           57719

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        212
#define _APS_NEXT_COMMAND_VALUE         32770
#define _APS_NEXT_CONTROL_VALUE         231
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandStripMgr\PropPageBand.h ===
#if !defined(AFX_PROPPAGEBAND_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_PROPPAGEBAND_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"

class CBandPropPageMgr;

// PropPageBand.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// PropPageBand dialog
class CBandPropPageMgr;

class PropPageBand : public CPropertyPage
{
	friend CBandPropPageMgr;
	DECLARE_DYNCREATE(PropPageBand)

// Construction
public:
	PropPageBand();
	~PropPageBand();

// Dialog Data
	//{{AFX_DATA(PropPageBand)
	enum { IDD = IDD_BAND_PROPPAGE };
	CSpinButtonCtrl	m_spinLogicalMeasure;
	CSpinButtonCtrl	m_spinLogicalBeat;
	CEdit	m_editLogicalMeasure;
	CEdit	m_editLogicalBeat;
	CEdit	m_editBeat;
	CEdit	m_editBand;
	CEdit	m_editMeasure;
	CEdit	m_editTick;
	CSpinButtonCtrl	m_spinTick;
	CSpinButtonCtrl	m_spinMeasure;
	CSpinButtonCtrl	m_spinBeat;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPageBand)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(PropPageBand)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditBeat();
	afx_msg void OnKillfocusEditBand();
	afx_msg void OnKillfocusEditMeasure();
	afx_msg void OnKillfocusEditTick();
	afx_msg void OnKillFocusEditLogicalBeat();
	afx_msg void OnKillFocusEditLogicalMeasure();
	afx_msg void OnDeltaPosSpinLogicalBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinLogicalMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void CopyDataToBand( CPropBand* pBand );
	void GetDataFromBand( CPropBand* pBand );

protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();

private:
	CPropBand*				m_pBand;
	CBandPropPageMgr*		m_pPropPageMgr;
	BOOL					m_fHaveData;
	BOOL					m_fMultipleBandsSelected;
	BOOL					m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGEBAND_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\BandStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\Chord.cpp ===
//	chord.cpp

#include "stdafx.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stddef.h>
#include <ctype.h>
#include <time.h>
#include "chord.h"
#include "chordio.h"
#include "propchord.h"
#include "..\shared\RiffStrm.h"
#include "ChordMapStripMgr.h"


ChordChangeCallback::~ChordChangeCallback()
{
	if(m_pChordEntry)delete m_pChordEntry;
}

HRESULT ChordChangeCallback::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    if(::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    if(::IsEqualIID(riid, IID_ChordChangeCallback))
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG ChordChangeCallback::AddRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));	
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG ChordChangeCallback::Release()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}



HRESULT PreEditNotification::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    if(::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

	if(::IsEqualIID(riid, IID_PreEditNotification))
	{
		AddRef();
		*ppvObj = this;
		return S_OK;
	}


    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG PreEditNotification::AddRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));	
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG PreEditNotification::Release()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

HRESULT CheckForOrphansNotification::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    if(::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

	if(::IsEqualIID(riid, IID_CheckForOrphansNotification))
	{
		AddRef();
		*ppvObj = this;
		return S_OK;
	}


    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CheckForOrphansNotification::AddRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));	
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CheckForOrphansNotification::Release()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

ULONG ZoomChangeNotification::AddRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));	
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG ZoomChangeNotification::Release()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/*
#ifndef CHORDMAP
#pragma pack(6)
#endif
*/

DWORD OldChordEntry::SizeExtendedChordEntry()
{
	return sizeof(OldChordEntry);
}
DWORD OldChordEntry::SizeSmallChordEntry()
{
	return SizeExtendedChordEntry() - 5*sizeof(short);
}
DWORD OldChordEntry::SizeChordSelection()
{
	return SizeExtendedChordEntry() - (5*sizeof(short) + sizeof(short) + sizeof(DWORD));
}

DMChord::DMChord()
{
	m_dwChordPattern = 0x91;
	m_bChordRoot = 12;
	m_bScaleRoot = 0;
	m_bFlat = FALSE;
	m_bBits = 3 | CHORD_INVERT | CHORD_SIMPLE;
	m_wFlags =0;
	m_dwScalePattern = 0xAB5AB5;
	m_dwLevels = ~(unsigned)0;	// all levels
	m_bInUse = false;
	m_dwInvertPattern = ~(unsigned)0;
}

int DMChord::BassNote()
{
	int retval = -1;
	for(int i = 0; i < 24; i++)
	{
		if(m_dwChordPattern & (1 << i))
		{
			retval = i;
			break;
		}
	}
	return retval;
}

int DMChord::Third(int* bass)
{
	int third = -1;
	int bassnote = BassNote();

	if(bassnote != third)
	{
		for(int i = bassnote + 1; i < 24; i++)
		{
			if(m_dwChordPattern & (1 << i))
			{
					third = i;
					break;
			}
		}
	}

	if(bass)
	{
		*bass = bassnote;
	}
	return third;
}

int DMChord::Fifth(int* bass, int* third)
{
	int fifth = -1;
	int thirdnote = Third(bass);

	if(thirdnote != fifth)
	{
		for(int i = thirdnote+1; i < 24; i++)
		{
			if(m_dwChordPattern & (1 << i))
			{
					fifth = i;
					break;
			}
		}
	}

	if(third)
	{
		*third = thirdnote;
	}
	return fifth;
}

int DMChord::Seventh(int* bass, int* third, int* fifth)
{
	int seventh = -1;
	int fifthnote = Fifth(bass, third);

	if(fifthnote != seventh)
	{
		for(int i = fifthnote+1; i < 24; i++)
		{
			if(m_dwChordPattern & (1 << i))
			{
				seventh = i;
				break;
			}
		}
	}

	if(fifth)
	{
		*fifth = fifthnote;
	}
	return seventh;
}

void DMChord::ChordNotes(int& bass, int& third, int& fifth, int& seventh)
{
	seventh = Seventh(&bass, &third, &fifth);
}

int DMChord::NoteCount()
{
	int count  = 0;
	for(int i = 0; i < 24; i++)
	{
		if(m_dwChordPattern & (1 << i))
		{
			++count;
		}
	}
	return count;
}

DMPolyChord::DMPolyChord()
{
	strcpy(m_szName, _T("M"));
	m_dwTime = 0;
	m_nMeasure = 0;
	m_bBeat = 0;
	m_bRootIndex = 0;
	m_keydown = false;
	InitLevels();
}

DMPolyChord::DMPolyChord(const DMPolyChord& poly)
{
	memcpy(this, &poly, sizeof(DMPolyChord));
}

DMPolyChord& DMPolyChord::operator = (const DMPolyChord& poly)
{
	memcpy(this, &poly, sizeof(DMPolyChord));
	return *this;
}

void DMPolyChord::Load(OldChordEntry& oce)
{
	m_dwTime = oce.time;
	m_nMeasure = oce.measure;
	m_bBeat = oce.beat;
	strcpy(m_szName, _T(oce.name));
	m_keydown = oce.keydown ? true : false;
	m_bRootIndex = 0;
	DMChord* pChord = 0;

	// old chords are single level, bottom 4 notes = level 1 (bass), top 4 notes = level two (upper).
	DWORD bass = 0, upper = 0;
	DWORD cbass = 4, cupper = 4;
	int bits = sizeof(DWORD) * 8;	// should be 32
	for(int j = 0; j < sizeof(DWORD)*8; j++)
	{
		if( (oce.pattern & (1 << j)) && cbass > 0)
		{
			--cbass;
			bass |= (1 << j);
		}
		if( (oce.pattern & (1 << (bits - 1 - j))) && cupper > 0)
		{
			--cupper;
			upper |= 1 << (bits - 1 - j);
		}
	}

	// now fill in rest of chord information
	for(int i = 0; i < MAX_POLY; i++)
	{
		pChord = (*this)[i];
		pChord->ChordRoot() = oce.root;
//		pChord->ScaleRoot() = oce.root;
		pChord->ScaleRoot() = 0;
		switch(i)
		{
		case 0:	// bass chord
			pChord->ChordPattern() = bass;
			pChord->InUse() = true;
			break;
		case 1: // upper chord
			pChord->ChordPattern() = upper;
			break;
		default:	// rest of the levels
			pChord->ChordPattern() = oce.pattern;
			break;
		}
		pChord->ScalePattern() = oce.scalepattern;
		pChord->Flags() = oce.varflags;
		pChord->UseFlat() = oce.flat;
		pChord->Bits() = oce.bits;
		pChord->InUse() = false;
	}
	InitLevels();
}

void DMPolyChord::Save(OldChordEntry& oce)
{
	oce.time = m_dwTime;
	oce.measure = m_nMeasure;
	oce.beat = m_bBeat;

	ASSERT(sizeof(m_szName) == sizeof(oce.name));	// catch wide char conversion

	strcpy(oce.name, m_szName);
	oce.keydown = m_keydown;
	DMChord* pChord = SubChord(m_bRootIndex);
	oce.root = pChord->ChordRoot();
	oce.pattern = pChord->ChordPattern();
	oce.varflags = pChord->Flags();
	oce.flat = pChord->UseFlat();
	oce.bits = pChord->Bits();
	oce.scalepattern = pChord->ScalePattern();
	oce.melodypattern = 0;
	oce.inscale = InScale(oce.root, oce.pattern, oce.scalepattern);
}

	// mass copy functions, from base to other subchords
void DMPolyChord::PropagateChordPattern()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].ChordPattern() = m_Chords[root].ChordPattern();
	}
}

void DMPolyChord::PropagateScalePattern()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].ScalePattern() = m_Chords[root].ScalePattern();
	}
}

void DMPolyChord::PropagateInvertPattern()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].InvertPattern() = m_Chords[root].InvertPattern();
	}
}

void DMPolyChord::PropagateLevels()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].Levels() = m_Chords[root].Levels();
	}
}

void DMPolyChord::PropagateFlags()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].Flags() = m_Chords[root].Flags();
	}
}

void DMPolyChord::PropagateChordRoot()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].ChordRoot() = m_Chords[root].ChordRoot();
	}
}

void DMPolyChord::PropagateScaleRoot()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].ScaleRoot() = m_Chords[root].ScaleRoot();
	}
}

void DMPolyChord::PropagateUseFlat()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].UseFlat() = m_Chords[root].UseFlat();
	}
}

void DMPolyChord::PropagateBits()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].Bits() = m_Chords[root].Bits();
	}
}
void DMPolyChord::PropagateInUse()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].InUse() = m_Chords[root].InUse();
	}
}

void DMPolyChord::PropagateAll()
{
	PropagateChordPattern();
	PropagateScalePattern();
	PropagateInvertPattern();
	PropagateLevels();
	PropagateFlags();
	PropagateChordRoot();
	PropagateScaleRoot();
	PropagateUseFlat();
	PropagateBits();
	PropagateInUse();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

void swaplong(char data[])
{
    char temp;
    temp = data[0];
    data[0] = data[3];
    data[3] = temp;
    temp = data[1];
    data[1] = data[2];
    data[2] = temp;
}

void WriteID( IStream *pIStream, DWORD id )
{
	pIStream->Write( &id, 4, NULL );
}

void WriteSize( IStream *pIStream, long size )
{
	swaplong((char *)&size);
	pIStream->Write( &size, 4, NULL );
}

long ReadID( IStream *pIStream )
{
	DWORD	dwTemp;
	long	lID;
	
	pIStream->Read( &lID, 4, &dwTemp );
	return lID;
}

long ReadSize( IStream *pIStream )
{
    long	lTemp,
			lSize;
	
	pIStream->Read( &lSize, 4, (DWORD*)&lTemp );
	swaplong( (char*)&lSize );

	return lSize;
}


void ChordSelection::SetBits(int nSubChord)

{
	if(nSubChord >= MAX_POLY)
	{
		return;	// out of range
	}

	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		LONG    i ;
		short   count = 0 ;

		for( i=0L ;  i<32L ;  i++ ) {
			if( m_Chords[k].ChordPattern() & (1L << i) )
				count++ ;
		}
		
		if( !m_Chords[k].Bits() ) {
			m_Chords[k].Bits() |= CHORD_INVERT ;
			if( count > 3 )
				m_Chords[k].Bits() |= CHORD_FOUR ;
			if( m_Chords[k].ChordPattern() & (15L << 18L) )
				m_Chords[k].Bits() |= CHORD_UPPER ;
		}
		m_Chords[k].Bits() &= ~CHORD_COUNT ;
		m_Chords[k].Bits() |= count ;
	}
}

void ChordSelection::SetChordPattern(DWORD dwPattern, int nSubChord)
{
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		m_Chords[k].ChordPattern() = dwPattern;
	}
}

void ChordSelection::SetScalePattern(DWORD dwPattern, int nSubChord)
{
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		m_Chords[k].ScalePattern() = dwPattern;
	}
}

void ChordSelection::SetChordRoot(BYTE root, int nSubChord)
{
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		m_Chords[k].ChordRoot() = root;
	}
}

void ChordSelection::SetScaleRoot(BYTE root, int nSubChord)
{
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		m_Chords[k].ScaleRoot() = root;
	}
}

void ChordSelection::SetUseFlats(BYTE bFlat, int nSubChord)
{
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		m_Chords[k].ScaleRoot() = bFlat;
	}
}


ChordSelection::ChordSelection()
{
}

BOOL ChordSelection::Equals(ChordSelection *second, int nSubChord)

{
	if(nSubChord >= MAX_POLY)
	{
		return FALSE;	// out of range
	}

	BOOL bMatch = TRUE;
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int i = nBegin; bMatch && i < nEnd; i++)
	{
		if(!m_Chords[i].InUse())
		{
			// dont match empty chords
			continue;
		}
		char a = m_Chords[i].ChordRoot();
		char b = second->m_Chords[i].ChordRoot();
		while (a > 11) a -= 12;
		while (b > 11) b -= 12;
		bMatch = ((m_Chords[i].ChordPattern() == second->m_Chords[i].ChordPattern()) && (a == b));
	}
	return bMatch;
}


static char *convert[] = {"C","C#","D","D#","E","F","F#","G","G#","A","A#","B"};
static char *flatconvert[] = {"C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"};

void ChordSelection::RootToString(char *string)
{
	int nSubChord = (int)m_bRootIndex;
	char note = (char)( m_Chords[nSubChord].ChordRoot() % 12 );
	if( m_Chords[nSubChord].UseFlat() )
		wsprintf( string,"%d %s",1 + (m_Chords[nSubChord].ChordRoot() / 12), (LPSTR)flatconvert[note] ) ;
	else
		wsprintf( string,"%d %s",1 + (m_Chords[nSubChord].ChordRoot() / 12), (LPSTR)convert[note] ) ;
}

void ChordSelection::GetName(char *string)
{
	char root[20];
	RootToString(root);
	wsprintf(string,"%s %s",root,m_szName);
}



ChordPalette::ChordPalette()
{
	ASSERT(FALSE);	// make sure we don't call this
	InitChords(TRUE,FALSE,FALSE,FALSE);
}

static void autochord(ChordSelection *pchord, short type, short index, int nSubChord)

{


	static long chordpatternarray[8] = {
		0x91,0x89,0x49,0x891,0x491,0x489,0x249,0x449
	};
	static char *namearray[8] = {
		"M","m","o","M7","7","m7","o7",""
	};
	char maj3table[12] = { 0,0,1,0,1,0,0,0,0,1,0,2 } ;
	char min3table[12] = { 1,0,2,0,2,1,2,0,0,2,0,2 } ;
	char maj4table[12] = { 3,6,5,6,5,3,6,4,6,5,3,6 } ;
	char min4table[12] = { 1,3,6,0,6,5,6,4,3,7,4,6 } ;
	static long  scalearray[4] = {0xAB5AB5, //Maj3 
												0x9AD9AD, // min3
												0xAB5AB4, // Maj4
												0x9AD9AD }; // min4

	
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? DMPolyChord::MAX_POLY : nSubChord + 1;
	ChordSelection& chord = *pchord;
	for( int i = nBegin; i < nEnd; i++)
	{
		chord[i]->ScalePattern() = scalearray[type];
		if( type == 0 ) {        // major triads.
			index = maj3table[index];
		}
		else if( type == 1 ) {        // minor triads.
			index = min3table[index];
		}
		else if( type == 2 ) {        // major sevenths.
			index = maj4table[index];
		}
		else 
		{ 
			index = min4table[index];
		}
		strcpy(chord.Name(),namearray[index]);
		chord[i]->ChordPattern() = chordpatternarray[index];
	}
}  

void ChordPalette::InitChords(BOOL major,BOOL allnotes,BOOL fat,BOOL flat)

{
	short key;
	short index;
	short type;
	long pattern;
	if (fat) type = 2;
	else type = 0;
	if (major) 
	{
		pattern = 0xAB5AB5; 
	}
	else
	{
		pattern = 0x9AD9AD; 
		type++;
	}
	for( key = 0;  key < 24;  key++ ) 
	{
		index = (short)(key % 12);
		if( pattern & (1 << index)) 
		{
			autochord(&m_chords[key], type, index, DMPolyChord::ALL ) ;
		}
		else if (allnotes) 
		{
			autochord(&m_chords[key], type, index, DMPolyChord::ALL ) ;
		}
		else  {
			*m_chords[key].Name() = 0;
			m_chords[key].SetChordPattern(1, DMPolyChord::ALL);
		}
		m_chords[key].SetChordRoot((char) key, DMPolyChord::ALL);
		m_chords[key].SetScaleRoot(0, DMPolyChord::ALL);
		m_chords[key].SetUseFlats((char) flat, DMPolyChord::ALL);
		m_chords[key].SetBits(DMPolyChord::ALL);
	}
} 

ChordEntry::ChordEntry()
{
	DWListItem();
	m_nid = 0;
	m_dwflags = 0;
	m_parent = 0;
	m_page = 0;
	m_nextchordlist.RemoveAll();
}   

void ChordEntry::LoadSmall(OldChordEntry& oce)
{
	m_nid = oce.nid;
	m_dwflags = oce.dwflags;
	m_chordsel.Load(oce);
}

void ChordEntry::LoadExtended(OldChordEntry& oce)
{
	m_page = oce.page;
	memcpy(&m_rect, &oce.rect, sizeof(m_rect));
	LoadSmall(oce);
}

void ChordEntry::LoadFromPropChord(CPropChord& chord)
{
	dynamic_cast<DMPolyChord&>(const_cast<ChordEntry*>(this)->m_chordsel) = chord;
	m_dwflags = 0;
}

void ChordEntry::SaveToPropChord(CPropChord& chord)
{
	dynamic_cast<DMPolyChord&>(chord) = dynamic_cast<DMPolyChord&>(const_cast<ChordEntry*>(this)->m_chordsel);
}

void ChordEntry::LoadFromChordItem(CChordItem& chord)
{
	m_chordsel.KeyDown() = chord.IsSelected() ? true : false;
	LoadFromPropChord(dynamic_cast<CPropChord&>(chord));
	if(chord.IsSignPost())
	{
/*
		if(chord.Measure() == 0)
		{
			m_dwflags |= CE_START;
		}
		else
		{
			m_dwflags |= CE_END;
		}
*/
		if(chord.IsBegSignPost())
		{
			m_dwflags |= CE_START;
		}
		if(chord.IsEndSignPost())
		{
			m_dwflags |= CE_END;
		}
	}
}


void ChordEntry::SaveSmall(OldChordEntry& oce)
{
	oce.nid = m_nid;
	oce.dwflags = m_dwflags;
	m_chordsel.Save(oce);
}

void ChordEntry::SaveExtended(OldChordEntry& oce)
{
	oce.page = m_page;
	memcpy(&oce.rect, &m_rect, sizeof(m_rect));
	SaveSmall(oce);
}

void ChordEntry::Debug()

{
	NextChord *pnext = m_nextchordlist.GetHead();
	TRACE("ChordEntry %ls: \n",m_chordsel.Name());
	for (;pnext;)
	{
		pnext->Debug();
		pnext = pnext->GetNext();
	}
}

void ChordEntry::AssignParents()

{
	NextChord *pnext = m_nextchordlist.GetHead();
	for (;pnext;)
	{
		pnext->m_parent = this;
		pnext = pnext->GetNext();
	}
}

ChordEntry::~ChordEntry()

{
	m_nextchordlist.ClearList();
}

void ChordSelection::SaveFile(char * /*filename*/)

{
	ASSERT(FALSE);
}

void ChordSelection::LoadFile(char * /*filename*/)

{
	ASSERT(FALSE);
}


void ChordEntry::CleanupNexts()

{
	NextChord *pnext = m_nextchordlist.GetHead();
	BOOL gotone = 0;
	CRect rect( m_rect.left, m_rect.top, m_rect.right, m_rect.bottom );
	rect.left += NEXT_INDENT;
	rect.bottom = rect.top;
	rect.top -= NEXT_HEIGHT;  
	for (;pnext;pnext = pnext->GetNext())
	{
		if (pnext->m_nextchord == NULL) gotone = TRUE;
		pnext->m_rect.left = (short)rect.left;
		pnext->m_rect.top = (short)rect.top;
		pnext->m_rect.right = (short)rect.right;
		pnext->m_rect.bottom = (short)rect.bottom;
		rect.bottom -= NEXT_HEIGHT;
		rect.top -= NEXT_HEIGHT;
	}
	if (gotone) return;
	pnext = new NextChord;
	if (pnext)
	{
		m_nextchordlist.AddTail(pnext);
		pnext->m_rect.left = (short)rect.left;
		pnext->m_rect.top = (short)rect.top;
		pnext->m_rect.right = (short)rect.right;
		pnext->m_rect.bottom = (short)rect.bottom;
		pnext->m_parent = this;
	}
}

void ChordEntry::Draw(CDC *pDC,short page)

{ 
	CPen *pOldPen;
	CPen pen;
	CBrush brush;
	CFont font;
	CFont *oldfont;
	NextChord *pnext;
	char string[50];
	if (page & m_page)
	{
		pnext = m_nextchordlist.GetHead();
		for (;pnext;pnext = pnext->GetNext())
		{
			pnext->Draw(pDC,page);
		}
		if (m_dwflags & CE_SELECTED) 
		{
			if (!pen.CreatePen(PS_SOLID,1,RGB(0xFF,0,0))) return; 
		} 
		else if (m_dwflags & CE_PATH)
		{ 
			if (!pen.CreatePen(PS_SOLID,1,RGB(0,0,0xFF))) return;   
		}
		else if (m_dwflags & CE_TREE)
		{ 
			if (!pen.CreatePen(PS_SOLID,1,RGB(0x77,0,0x77))) return;   
		}
		else 
		{ 
			if (!pen.CreatePen(PS_SOLID,1,RGB(0,0,0))) return;   
		}
		pOldPen = pDC->SelectObject(&pen);
		pDC->MoveTo(m_rect.left,m_rect.top);
		pDC->LineTo(m_rect.right,m_rect.top);
		pDC->LineTo(m_rect.right,m_rect.bottom);
		pDC->LineTo(m_rect.left,m_rect.bottom);
		pDC->LineTo(m_rect.left,m_rect.top);
		if (font.CreateFont(14,0,0,0,0,0,0,0,0,0,0,0,0,0))
		{
			oldfont = pDC->SelectObject(&font);
			strcpy(string, m_chordsel.Name());
			pDC->TextOut(m_rect.left + 4,m_rect.bottom - 2,string,strlen(string)); 
			pDC->SelectObject(oldfont);
		}      
	//	if (brush.CreateSolidBrush(RGB(0,0,0xFF)))
	//	{
	//		CBrush *pOldBrush;
	//		pOldBrush = pDC->SelectObject(&brush);
			if (m_dwflags & CE_MEASURE)
				pDC->Ellipse(m_rect.right - 14,m_rect.bottom - 4,
							m_rect.right - 4,m_rect.bottom - 14);  
			if (m_dwflags & CE_START)  
			{
				pDC->MoveTo(m_rect.left,(m_rect.top + m_rect.bottom) >> 1);
				pDC->LineTo(m_rect.left + CENTER_Y,m_rect.top); 
			}
			if (m_dwflags & CE_END)  
			{
				pDC->MoveTo(m_rect.right,(m_rect.top + m_rect.bottom) >> 1);
				pDC->LineTo(m_rect.right - CENTER_Y,m_rect.top); 
			}
	//		pDC->SelectObject(pOldBrush);
	//	}
		pDC->SelectObject(pOldPen);
	}
}

void NextChord::Draw(CDC *pDC,short page)

{ 
	CPen *pOldPen;
	CPen pen;
	CBrush brush;
	CFont font;
	CFont *oldfont;
	short cx,cy;
	if (m_dwflags & NC_SELECTED) 
	{
		if (!pen.CreatePen(PS_SOLID,1,RGB(0xFF,0,0))) return; 
	} 
	else if (m_dwflags & NC_TREE) 
	{
		if (!pen.CreatePen(PS_SOLID,1,RGB(0x77,0,0x77))) return; 
	} 
	else 
	{ 
		if (!pen.CreatePen(PS_SOLID,1,RGB(0,0,0))) return;   
	}
	pOldPen = pDC->SelectObject(&pen);
	pDC->MoveTo(m_rect.right,m_rect.bottom);
	pDC->LineTo(m_rect.right,m_rect.top);
	pDC->LineTo(m_rect.left,m_rect.top);
	pDC->LineTo(m_rect.left,m_rect.bottom);
	if (m_nextchord)
	{
		cx = (short)(m_rect.right - 6);
		cy = (short)((m_rect.top + m_rect.bottom) >> 1);
		pDC->Ellipse(cx - 3,cy - 3,cx + 3, cy + 3);
		if (m_nextchord->m_page & page)
		{
			pDC->MoveTo(cx,cy);
			pDC->LineTo(m_nextchord->m_rect.left,
				(m_nextchord->m_rect.top + m_nextchord->m_rect.bottom) >> 1); 
		}
		if (brush.CreateSolidBrush(RGB(0,0,0)))
		{
			CBrush *pOldBrush; 
			short w = (short)(m_nweight * (m_rect.right - m_rect.left - (CHORD_WIDTH >> 1)));
			w /= 101;
			pOldBrush = pDC->SelectObject(&brush);
			pDC->Rectangle(m_rect.left + 3,m_rect.top + 3,
				m_rect.left + 3 + w,m_rect.bottom - 3);
			pDC->SelectObject(pOldBrush);
		}		
		if (font.CreateFont(10,0,0,0,0,0,0,0,0,0,0,0,0,0))
		{
			char string[20];
			oldfont = pDC->SelectObject(&font);
			wsprintf(string,"%d:%d",m_nminbeats,m_nmaxbeats);
			cx = (short)(m_rect.right - (CHORD_WIDTH >> 1) + 3);
			pDC->TextOut(cx,m_rect.bottom - 2,string,strlen(string)); 
			pDC->SelectObject(oldfont);
		} 
	}        
	pDC->SelectObject(pOldPen);
}

void NextChord::Debug()

{
	TRACE("NextChord: Flags: %lx, ",m_dwflags);
	if (m_nextchord) TRACE("Connecting to %ls\n",m_nextchord->m_chordsel.Name());
	else TRACE("No connection\n");
}

NextChord::NextChord()

{
	DWListItem();
	m_nextchord = NULL;
	m_nid = 0;
	m_dwflags = 0; 
	m_nweight = 50;
	m_nminbeats = 1;
	m_nmaxbeats = 12; 
	m_parent = 0;
}



long totalnext = 0;

void NextList::Save( IStream *pIStream, BOOL bSmall )
{
	NextChord *pnext = GetHead();
	long size;
	if( bSmall )
	{
		size = SmallNextChordFileSize; 
		WriteID( pIStream, ID_NEXTLIST );
	}
	else
	{
	    size = NextChordFileSize;
		WriteID( pIStream, ID_ENEXTLIST );
	}
	WriteSize( pIStream, Size(bSmall) );
	WriteSize( pIStream, size );
	for (;pnext;pnext = pnext->GetNext())
	{
		if( bSmall )
		{
			if (!pnext->m_nextchord) continue;
		}
		pIStream->Write( (void *)&pnext->m_dwflags, (short)size, NULL );
		totalnext++;
	}
}

long NextList::Size(BOOL bSmall)

{
	NextChord *pnext = GetHead();
	long size = 4;
	if( bSmall )
	{
		for (;pnext;pnext = pnext->GetNext())
		{
			if (pnext->m_nextchord) size += SmallNextChordFileSize;
		}
	}
	else size += (GetCount() * NextChordFileSize);
	return(size);
}

void NextList::Load( IStream *pIStream,long lsize)

{
	long lrecordsize = ReadSize( pIStream );
	lsize -= 4;
	ClearList();
	for (;lsize > 0;)
	{
		NextChord *pnext = new NextChord;
		if (pnext)
		{
			pIStream->Read( &pnext->m_dwflags, NextChordFileSize, NULL );
			pnext->SetNext(NULL);
			AddTail(pnext);
		}
		else
		{
			StreamSeek( pIStream, lrecordsize, STREAM_SEEK_CUR );
		}
		lsize -= lrecordsize;
	}
}

void NextList::ClearList()

{
	NextChord *pnext = GetHead();
	for (;pnext;)
	{
		NextChord *next = pnext->GetNext();
		delete pnext;
		pnext = next;	
	}
	RemoveAll();
}

SmallChordEntry::SmallChordEntry(const SmallChordEntry& sce)
	: m_chordsel(sce.m_chordsel), m_dwflags(sce.m_dwflags), m_nid(sce.m_nid)
{

}

void ChordEntry::CopyNextList(ChordEntry& sce, bool bCopyOnlySelected)
{
	for(NextChord* pnc = const_cast<NextList&>(sce.m_nextchordlist).GetHead();	pnc; pnc = pnc->GetNext())
	{
		
		if(!bCopyOnlySelected	// unconditional copy
				||  pnc->m_nextchord == NULL // always copy "extra" null next chord
				|| pnc->m_nextchord->m_chordsel.KeyDown()	// connected to chord is also selected
			
		   )
		   
		{
			NextChord* pnc1 = new NextChord(*pnc);
			pnc1->m_parent = this;	// copy the next list, but make parent the target chord
			m_nextchordlist.AddTail(pnc1);
		}
	}
}

ChordEntry::ChordEntry(const ChordEntry& ce)
	:SmallChordEntry(ce), m_page(ce.m_page), m_parent(ce.m_parent)
{
	memcpy(&m_rect, &(ce.m_rect), sizeof(m_rect));
	memcpy(&m_lastrect, &(ce.m_lastrect), sizeof(m_lastrect));
}

void ChordEntry::Save( IStream *pIStream, BOOL bSmall )
{
	OldChordEntry oce;
	if (bSmall)
	{
		WriteID( pIStream, ID_CHORDENTRY );
		WriteSize( pIStream, Size(bSmall) );
		WriteSize( pIStream, SmallChordEntryFileSize );
		SaveSmall(oce);
		pIStream->Write( &oce, SmallChordEntryFileSize, NULL ); 
	}
	else 
	{
		WriteID( pIStream, ID_ECHORDENTRY );
		WriteSize( pIStream, Size(bSmall) );
		WriteSize( pIStream, ChordEntryFileSize );
		SaveExtended(oce);
		pIStream->Write( &oce, ChordEntryFileSize, NULL );
	}
	m_nextchordlist.Save( pIStream,bSmall );
}


long ChordEntry::Size(BOOL bSmall, long version)
{
	if(version == ID_DMCHORDENTRY)
	{
		ASSERT(FALSE);	// not implemented yet
		return 0;
	}
	else
	{
		long lsize = 0; 
		lsize += 4;						// Size of record field. 
		if (bSmall) lsize += SmallChordEntryFileSize;
		else lsize += (ChordEntryFileSize);  
		lsize += (m_nextchordlist.Size(bSmall) + 8);
		return(lsize);
	}
}

ChordEntry *ChordEntry::Load( IStream *pIStream,long lfilesize, long id)

{
	ChordEntry *pchord = new ChordEntry;
	long lrecordsize = ReadSize( pIStream );
	lfilesize -= 4;
	if (pchord)
	{
		if(id == ID_DMCHORDENTRY)
		{
			ASSERT(FALSE);	// not implemented
		}
		else
		{
			OldChordEntry oce;
			pIStream->Read( &oce, lrecordsize, NULL );
			if(id == ID_ECHORDENTRY)
			{
				pchord->LoadExtended(oce);
			}
			else
			{
				pchord->LoadSmall(oce);
			}
			lfilesize -= lrecordsize;
			pchord->m_nextchordlist.RemoveAll();
			for (;lfilesize > 0;)
			{
				long dwid = ReadID( pIStream );
				lrecordsize = ReadSize( pIStream );
				lfilesize -= 8;
				if (dwid == ID_ENEXTLIST)
				{
					pchord->m_nextchordlist.Load(pIStream,lrecordsize);
				}
				else if (dwid == ID_NEXTLIST)
				{
					pchord->m_nextchordlist.Load(pIStream,lrecordsize);
				}
				else
				{
					StreamSeek( pIStream, lrecordsize, STREAM_SEEK_CUR );
				}
				lfilesize -= lrecordsize;
			}
		}
		if (lfilesize) TRACE("ERROR: Chord read leaves filesize at %ld\n",
			lfilesize);
	}
	else
	{
		StreamSeek( pIStream, lfilesize, STREAM_SEEK_CUR );
	}
	return(pchord);		
}

void ChordEntryList::ClearList()
{
	ChordEntry* pChord;
	while( pChord = RemoveHead() )
	{
		delete pChord;
	}
}

void Personality::SaveRef( IStream *pIStream,BOOL bSmall)

{ 
	if (bSmall) WriteID( pIStream, ID_PERSONREF ); 
	else WriteID( pIStream, ID_EPERSONREF );
	strcpy(m_personref.m_name,m_name);  
	if (bSmall) m_personref.m_isdefault = (char) (CM_DEFAULT & m_dwflags);
	else m_personref.m_isdefault = (char)((CM_DEFAULT | CM_EMBED) & m_dwflags);
	pIStream->Write( &m_personref, sizeof(PersonalityRef), NULL );
}

static char drivename[_MAX_DRIVE];
static char dirname[_MAX_DIR];

void SignPost::Save( IStream *pIStream )

{
	WriteID( pIStream, ID_SIGNPOST );
	WriteSize( pIStream, Size() );
	OldChordEntry oce;

	WriteSize( pIStream, 0L);	// must write space for signpost's DWListItem pointer

	WriteSize( pIStream, 0L);	// must write space for chord's DWListItem pointer
	m_chord.Save(oce);
	DWORD size = OldChordEntry::SizeChordSelection();
	pIStream->Write(&oce, size, NULL);
	WriteSize( pIStream, 0L); // must write space for pointer
	m_cadence[0].Save(oce);
	pIStream->Write(&oce, size, NULL);
	WriteSize( pIStream, 0L); // must write space for pointer
	m_cadence[1].Save(oce);
	pIStream->Write(&oce, size, NULL);

    pIStream->Write( &m_chords, sizeof(DWORD)*3, NULL );
}

long SignPost::Size(long version)
{
	if(version == ID_DMSIGNPOST)
	{
		ASSERT(FALSE); // not implemented
		return 0;
	}
	else
	{
		long size = OldChordEntry::SizeChordSelection()*(MAX_CADENCE+1);
		size += 3*sizeof(DWORD);
		size += 4*sizeof(void *);
		return size;
	}
}

SignPost *SignPost::Load( IStream *pIStream,long /*lfilesize*/)

{
    SignPost *psignpost = new SignPost;
	ReadSize(pIStream);	// move past sizeof(DWListItem) == sizeof(pointer)
	/*
	long id = ReadID(pIStream);
	ReadSize(pIStream);	// move past size record
	if(id == ID_DMSIGNPOST)
	{
		ASSERT(FALSE);	// not implemented
	}
	*/
	OldChordEntry oce;
	DWORD size = OldChordEntry::SizeChordSelection();
	ReadSize(pIStream);	// move past sizeof(DWListItem) == sizeof(pointer)
	pIStream->Read( &oce, size, NULL);
	psignpost->m_chord.Load(oce);
	ReadSize(pIStream);	// move past sizeof(DWListItem) == sizeof(pointer)
	pIStream->Read( &oce, size, NULL);
	psignpost->m_cadence[0].Load(oce);
	ReadSize(pIStream);	// move past sizeof(DWListItem) == sizeof(pointer)
	pIStream->Read( &oce, size, NULL);
	psignpost->m_cadence[1].Load(oce);
    pIStream->Read( &(psignpost->m_chords), sizeof(DWORD)*3, NULL );
    return(psignpost);      
}

PlayChord::PlayChord()
{
    m_pchord = NULL;
    m_pnext = NULL;
    m_dwflags = 0;
//  m_time = 0;
    m_beat = 0;
    m_measure = 0;
}

/*
static void setdirname(char *fullpath)
{ 
	_splitpath(fullpath,drivename,dirname,NULL,NULL);
}
*/
/*
static void getdirname(char *path)

{
	_makepath(path,drivename,dirname,NULL,NULL);
}
*/

Personality * Personality::LoadRef( IStream* /*pIStream*/,long /*lsize*/,BOOL /*bSmall*/)

{
/*
//	char filename[9];
	char fullfile[200];
	char dirname[120];
	PersonalityRef personref;

	pfile->ReadRecord(&personref,sizeof(PersonalityRef),lsize);
	getdirname(dirname);
    if (bSmall) wsprintf(fullfile,"%s%s.per",dirname,personref.m_filename);
    else wsprintf(fullfile,"%s%s.cmp",dirname,personref.m_filename);

	MyFile file ;
	unsigned long size, id ;
	Personality *pcmap = NULL;

TRACE("Loading Personality from file %s\n",fullfile);
	if(file.Open(fullfile, CFile::modeRead ))
	{
	    id = file.ReadID();
    	size = file.ReadSize();
	    if (!bSmall && (id == ID_EPERSONALITY))
    	{
			pcmap = Personality::Load(&file,size);
		}
		else if (bSmall && (id == ID_PERSONALITY))
		{
			pcmap = Personality::Load(&file,size);
		}
		file.Close();
	}
	if (pcmap) 
	{
		pcmap->m_personref = personref;
		pcmap->m_dwflags &= ~(CM_EMBED | CM_DEFAULT);
		pcmap->m_dwflags |= personref.m_isdefault;
	}
	return(pcmap);
*/
	return NULL;
}

void Personality::Save( IStream *pIStream, long version )
// only save personality, not contained objects
{
	if(version == ID_DMPERSONALITY)
	{
		ASSERT(FALSE);	// not implemented
	}
	else
	{
		WriteSize(pIStream, 0);	// Personality is a DWListItem, write out "pointer"
		pIStream->Write(&m_chordlist, sizeof(m_chordlist), NULL);	// m_chordlist
		pIStream->Write(&m_signpostlist, sizeof(m_signpostlist), NULL);
		pIStream->Write(&m_scalepattern, sizeof(m_scalepattern), NULL);
		pIStream->Write(&m_name, sizeof(m_name), NULL);
		pIStream->Write(&m_description, sizeof(m_description), NULL);
		pIStream->Write(&m_username, sizeof(m_username), NULL);
	
		m_chordpalette.Save(pIStream);

		pIStream->Write( &m_dwflags, sizeof(m_dwflags), NULL );
		pIStream->Write( &m_playlist, sizeof(m_playlist), NULL);
		pIStream->Write( &m_pfirstchord, sizeof(m_pfirstchord), NULL);
		pIStream->Write( &m_personref, sizeof(m_personref), NULL);
		pIStream->Write( &m_cx, sizeof(m_cx), NULL);
		pIStream->Write( &m_cy, sizeof(m_cy), NULL);
	}
}


void Personality::Load( IStream *pIStream,long /*lfilesize*/, long version)
// load only personality, not contained objects
{
	if(version == ID_DMPERSONALITY)
	{
		ASSERT(FALSE);	// not implemented
	}
	// else
	DWORD size;
	ReadSize(pIStream);	// Personality is a DWListItem, read past the pointer
	pIStream->Read(&m_chordlist, sizeof(m_chordlist), &size);	// m_chordlist
	pIStream->Read(&m_signpostlist, sizeof(m_signpostlist), &size);
	pIStream->Read(&m_scalepattern, sizeof(m_scalepattern), &size);
	pIStream->Read(&m_name, sizeof(m_name), &size);
	pIStream->Read(&m_description, sizeof(m_description), &size);
	pIStream->Read(&m_username, sizeof(m_username), &size);

	m_chordpalette.Load(pIStream);

	pIStream->Read( &m_dwflags, sizeof(m_dwflags), NULL );
	pIStream->Read( &m_playlist, sizeof(m_playlist), NULL);
	pIStream->Read( &m_pfirstchord, sizeof(m_pfirstchord), NULL);
	pIStream->Read( &m_personref, sizeof(m_personref), NULL);
	pIStream->Read( &m_cx, sizeof(m_cx), NULL);
	pIStream->Read( &m_cy, sizeof(m_cy), NULL);

//		pIStream->Read(pcmap,lrecordsize,NULL);
	m_pfirstchord = NULL;
	m_playlist.RemoveAll();
	m_chordlist.RemoveAll();
	m_signpostlist.RemoveAll();
}
	
	
long Personality::TotalSize(BOOL bSmall, long version)

{
	ChordEntry *pchord;
	long lsize = 0; 
	lsize += 4;						// Size of record field.

	if(version == ID_DMPERSONALITY)
	{
		ASSERT(FALSE);	// not implemented
		return 0;
	}
	else
	{
		lsize += PersonalitySize();	    	// Size of record.

		pchord = m_chordlist.GetHead();
		for(;pchord;pchord = pchord->GetNext())
		{       
			lsize += (pchord->Size(bSmall) + 8);
		}
		SignPost *psign;
		psign = m_signpostlist.GetHead();
		for(;psign;psign = psign->GetNext())
		{       
			lsize += (psign->Size() + 8);
		}
		return(lsize);
	}
}

long Personality::PersonalitySize(long version)
{
	if(version == ID_DMPERSONALITY)
	{
		return sizeof(Personality);
	}
	else
	{
		long size = sizeof(Personality) - sizeof(ChordPalette);
		size += (OldChordEntry::SizeChordSelection() + sizeof(void *)) * 24;
		return size;
	}
}


BOOL Personality::LoadFile(char* /*filename*/)

{
/*	MyFile file ;
	unsigned long size, id ;
	Personality *pcmap;

	if(file.Open(filename, CFile::modeRead ))
	{
	    id = file.ReadID();
    	size = file.ReadSize();
	    if (id == ID_EPERSONALITY)
    	{
			pcmap = Personality::Load(&file,size);
			if (pcmap)
			{
				Personality temp;
				temp = *this;
				*this = *pcmap;
				AssignParents();
				*pcmap = temp;
				delete pcmap;
				file.Close();
				_splitpath(filename,NULL,NULL,m_personref.m_filename,NULL);
				memset(&temp,0,sizeof(Personality));
				return(TRUE);
			}
		}
		file.Close();
	}
	return(FALSE);
*/
	return TRUE;
}

BOOL Personality::SaveFile(char* /*filename*/, BOOL /*bSmall*/)

{
/*
	MyFile file ;
	if(file.Open(filename, CFile::modeCreate |
	  	CFile::modeReadWrite | CFile::shareExclusive))
	{
		Save(&file,bSmall);
		file.Close();
		return(TRUE);
	}
	return(FALSE);
*/
	return TRUE;
}

BOOL ChordPalette::LoadFile(char* /*filename*/)

{
/*
	MyFile file;
	
	if (file.Open(filename, CFile::modeRead ))
	{
	    long id = file.ReadID();
    	long size = file.ReadSize();
	    if (id == ID_CHORDPALETTE)
    	{
			file.ReadRecord(this,sizeof(ChordPalette),size);
			file.Close();
			return(TRUE);
		}
		file.Close();
	}
	return(FALSE);                                    
*/
	return TRUE;
}

BOOL ChordPalette::SaveFile(char* /*filename*/)

{
/*
	MyFile file ;

	if(file.Open(filename, CFile::modeCreate |
	  	CFile::modeReadWrite | CFile::shareExclusive))
	{
		file.WriteID(ID_CHORDPALETTE);
		file.WriteRecord(this,sizeof(ChordPalette));
		file.Close();
		return(TRUE);
	}
	return(FALSE);
*/
	return TRUE;
}

void Personality::InsertChords(short leftedge,DWORD flags)

{
	CRect rect;
	ChordEntryList list;
	ChordEntry *pchord;
   	rect.left = leftedge;
   	rect.right = rect.left + CHORD_WIDTH;
   	rect.bottom = -20;
   	rect.top = rect.bottom - CHORD_HEIGHT;
	BuildNeededChords(&list,flags);
	m_chordlist.Cat(list.GetHead());
	pchord = list.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		pchord->m_rect.top = (short)rect.top;
		pchord->m_rect.left = (short)rect.left;
		pchord->m_rect.right = (short)rect.right;
		pchord->m_rect.bottom = (short)rect.bottom;
		pchord->m_dwflags |= flags;  
		rect.bottom -= (CHORD_HEIGHT * 4);
		rect.top -= (CHORD_HEIGHT * 4);
		pchord->m_parent = this;
		pchord->CleanupNexts(); 
	}
	AssignIDs();
}


static BOOL inchordlist(ChordEntry *plist,ChordSelection *pchord,DWORD flags)

{
	for (;plist;plist = plist->GetNext())
	{
		if (pchord->Equals(&plist->m_chordsel, DMPolyChord::ALL) && (plist->m_dwflags & flags))
		{
			return(TRUE);
		}
	}
	return(FALSE);			
}

static void addchordtolist(ChordEntryList *list,ChordSelection *chord,DWORD flags)

{
	ChordEntry *pchord = new ChordEntry;
	if (pchord)
	{
		pchord->m_chordsel = *chord;
		pchord->m_dwflags = flags;
		list->AddTail(pchord);
	}
}

static void maybeputinlist(
	ChordEntryList *newlist,ChordEntryList *oldlist,
	ChordSelection *pcsel,DWORD flags)

{
	if (!inchordlist(newlist->GetHead(),pcsel,flags))
	{
		if (!inchordlist(oldlist->GetHead(),pcsel,flags))
		{
			addchordtolist(newlist,pcsel,flags);
		}
	}
}

void Personality::BuildNeededChords(ChordEntryList *list,DWORD flags)

{
	SignPost *psign = m_signpostlist.GetHead();
	for (;psign;psign = psign->GetNext())
	{
		maybeputinlist(list,&m_chordlist,&psign->m_chord,flags);
		if (flags & CE_END)
		{
			if (psign->m_dwflags & SPOST_CADENCE1)
			{
				maybeputinlist(list,&m_chordlist,&psign->m_cadence[0],flags);
			}
			else if (psign->m_dwflags & SPOST_CADENCE2)
			{
				maybeputinlist(list,&m_chordlist,&psign->m_cadence[1],flags);
			}
		}
	}
} 

Personality::Personality()

{
	static short count = 1;
	m_chordlist.RemoveAll();
	m_playlist.RemoveAll(); 
	m_signpostlist.RemoveAll();
	m_scalepattern = 0xAB5AB5; 
	m_description[0] = 0; 
	m_personref.m_stylename[0] = 0;
	wsprintf(m_name,"Personality %d",count++);
				
}

void PlayList::ClearList()

{
	PlayChord *pnext = GetHead();
	for (;pnext;)
	{
		PlayChord *next = pnext->GetNext();
		delete pnext;
		pnext = next;	
	}
	RemoveAll();
}

SignPost::SignPost()
{
    m_chords = SP_A | SP_B | SP_C;
    m_dwflags = SPOST_CADENCE1 | SPOST_CADENCE2;
    m_tempflags = 0;
}

BOOL Personality::PlayStop()

{
	m_playlist.ClearList();
	return(TRUE);
}

void Personality::AssignIDs()

{
	ChordEntry *pchord = m_chordlist.GetHead();   
	for (;pchord;pchord = pchord->GetNext())
	{ 
		if (!pchord->m_nid) 
		{
			short scan = 1;
			for (scan = 1;;scan++)
			{
				ChordEntry *pscan = m_chordlist.GetHead();   
				for (;pscan;pscan = pscan->GetNext())
				{
					if (pscan->m_nid == scan) break;
				}
				if (!pscan) break;
			}
			pchord->m_nid = scan;
		}
	}
}

void Personality::ResolveConnections()

{
	ChordEntry *pchord = m_chordlist.GetHead();   
	for (;pchord;pchord = pchord->GetNext())
	{
		NextChord *pnext = pchord->m_nextchordlist.GetHead();
		for (;pnext;pnext = pnext->GetNext())
		{
			pnext->m_nextchord = NULL;
		} 
	}
	pchord = m_chordlist.GetHead();   
	for (;pchord;pchord = pchord->GetNext())
	{
		NextChord *pnext = pchord->m_nextchordlist.GetHead();
		for (;pnext;pnext = pnext->GetNext())
		{
			if (pnext->m_nid)
			{
				ChordEntry *pconnect = m_chordlist.GetHead();   
				for (;pconnect;pconnect = pconnect->GetNext())
				{
                	if (pconnect->m_nid == pnext->m_nid) break;
                }
				pnext->m_nextchord = pconnect;
			}
		} 
	}
}

Personality::~Personality()

{
	ChordEntry *pchord = m_chordlist.GetHead();
	SignPost *psignpost = m_signpostlist.GetHead();
	PlayStop(); 
	for (;pchord;)
	{
		ChordEntry *next = pchord->GetNext();
		delete pchord;
		pchord = next;	
	}
	m_chordlist.RemoveAll();
	for (;psignpost;)
	{
		SignPost *next = psignpost->GetNext();
		delete psignpost;
		psignpost = next;	
	}
	m_signpostlist.RemoveAll();
}

void Personality::Debug()

{
	ChordEntry *pchord = m_chordlist.GetHead(); 
	TRACE("Chord List:\n");
	for (;pchord;pchord = pchord->GetNext())
	{
		pchord->Debug();
	}
/*	TRACE("Play List:\n");
	NextChord *pnext = (NextChord *) m_playlist.GetHead();
	for (;pnext;pnext = (NextChord *) pnext->GetNext())
	{
		pnext->Debug();
	}  */
}

void Personality::AssignParents()

{
	ChordEntry *pchord = m_chordlist.GetHead(); 
	for (;pchord;pchord = pchord->GetNext())
	{
		pchord->m_parent = this;
		pchord->AssignParents();
	}
/*	NextChord *pnext = (NextChord *) m_playlist.GetHead();
	for (;pnext;pnext = (NextChord *) pnext->GetNext())
	{
		pnext->m_parent = NULL;
	}  */
}

void Personality::Draw(CDC *pDC,short page)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		pchord->Draw(pDC,page);
	}
}   

BOOL Personality::IsValidChord(ChordEntry *ptest)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord == ptest) return(TRUE);
	}
	return (FALSE);
	
}

BOOL Personality::IsValidNext(NextChord *ptest)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		NextChord *pnext = pchord->m_nextchordlist.GetHead();
		for (;pnext;pnext = pnext->GetNext())
		{
			if (pnext == ptest) return(TRUE);
		}
	}
	return (FALSE);
}

void Personality::ClearChordFlags(unsigned long flag)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		pchord->m_dwflags &= ~flag;
	}
}

void Personality::ClearNextFlags(unsigned long flag)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		NextChord *pscan = pchord->m_nextchordlist.GetHead();
		for (;pscan;pscan = pscan->GetNext())
		{
			pscan->m_dwflags &= ~flag;
		}
	}
}


void ChordEntry::MarkTree()

{
	m_dwflags |= CE_TREE;
	NextChord *pscan = m_nextchordlist.GetHead();
	for (;pscan;pscan = pscan->GetNext())
	{
		pscan->MarkTree();
	}
}

void NextChord::MarkTree()

{
	m_dwflags |= NC_TREE;
	if (m_nextchord) m_nextchord->MarkTree();
}

void Personality::MarkTree(ChordEntry *pchord)

{
//	ClearNextFlags(NC_TREE);
//	ClearChordFlags(CE_TREE);
	if (pchord)
	{
		pchord->MarkTree();
	}
}

ChordEntry *Personality::FindXYChord(CPoint point,short page)

{
	CRect crTemp;
	ChordEntry *pchord = m_chordlist.GetHead();

	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord->m_page & page)
//		if (findall || (pchord->m_dwflags & (CE_TREE | CE_END)))
		{
			crTemp.left = pchord->m_rect.left;
			crTemp.right = pchord->m_rect.right;
			crTemp.top = pchord->m_rect.top;
			crTemp.bottom = pchord->m_rect.bottom;
//			if (pchord->m_rect.PtInRect(point)) break;
			if (crTemp.PtInRect(point)) break;
		}
	}
	return (pchord);
}

NextChord *Personality::FindXYNext(CPoint point,short page)

{
	CRect crTemp;

	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord->m_page & page)
//		if (findall || (pchord->m_dwflags & (CE_TREE | CE_END)))
		{
			NextChord *pnext = (NextChord *) pchord->m_nextchordlist.GetHead();
			for (;pnext;pnext = (NextChord *) pnext->GetNext())
			{
				crTemp.SetRect( pnext->m_rect.left, pnext->m_rect.top,
								pnext->m_rect.right, pnext->m_rect.bottom );
//				if (findall || (pnext->m_dwflags & NC_TREE))
//				{
//					if (pnext->m_rect.PtInRect(point)) return(pnext);  
					if (crTemp.PtInRect(point)) return(pnext);  
//				}
			}   
		}
	}
	return (NULL);
}   

BOOL Personality::CalcViewSize()

{
    CRect rect;
    CSize size;
    rect.SetRectEmpty(); 
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
//		rect |= pchord->m_rect;
		rect.left |= pchord->m_rect.left;
  		rect.right |= pchord->m_rect.right;
  		rect.bottom |= pchord->m_rect.bottom;  
  		rect.top |= pchord->m_rect.top;  
    }
    size.cx = rect.Width(); + CHORD_WIDTH;
    size.cy = rect.Height() + CHORD_HEIGHT + (4 * NEXT_HEIGHT);
    if (size.cx == m_cx || size.cy == m_cy) return(FALSE);
    //m_size = size;
    return(TRUE);
}

BOOL Personality::GetChord(ChordSelection *pcsel,DWORD flag,short index)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord->m_dwflags & flag)
		{
			if (!index) 
			{
				*pcsel = pchord->m_chordsel; 
				return(TRUE);
			}
			index--;
		}
	}
	return(FALSE);
}

short Personality::GetChordIndex(ChordSelection *pcsel,DWORD flag)

{
	short index = 0;
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord->m_dwflags & flag)
		{
			if (pcsel->Equals(&pchord->m_chordsel, DMPolyChord::ALL)) return(index); 
			index++;
		}
	}
	return(0);
}

short Personality::GetChordCount(DWORD flag)

{
	short count = 0;
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord->m_dwflags & flag) count++;
	}
	return(count);
}

Instruments::Instruments()

{
	static unsigned char defaults[16] = { 73,48,25,0,32,0,0,0,0,0,0,0,0,0,0,0 };
	short i;
	for (i=0;i<16;i++) m_patch[i] = defaults[i]; 
	strcpy(m_name,"new");
	m_default = 0;
}

GrooveName * GrooveNameList::GetGrooveName(DWORD grooveid)

{
	GrooveName *pgroove = GetHead();
	for (;pgroove;pgroove = pgroove->GetNext())
	{
		if (pgroove->m_grooveid == grooveid) break;
	}
	return (pgroove);
}

void GrooveNameList::AddGrooveName(char *name,DWORD grooveid)

{
	GrooveName *pgroove;
	pgroove = new GrooveName;
	if (pgroove)
	{
		strncpy(pgroove->m_name,name,sizeof(pgroove->m_name));
		pgroove->m_grooveid = grooveid;
		AddTail(pgroove);
	}
}

void GrooveNameList::SetDefaults()

{
	AddGrooveName("Relaxed",PF_A);
	AddGrooveName("Medium",PF_B);
	AddGrooveName("Active",PF_C);
	AddGrooveName("Frantic",PF_D);
}
     
void Instruments::Save( IStream *pIStream )

{ 
	WriteID( pIStream, ID_INSTRUMENTS );
	pIStream->Write( this, sizeof( Instruments ), NULL );
}

long Instruments::Size()

{
	return(sizeof(Instruments));
}

Instruments * Instruments::Load( IStream *pIStream,long /*lfilesize*/)

{
	Instruments *pinst = new Instruments;
	pIStream->Read( pinst, sizeof(Instruments), NULL );
	return(pinst);		
}
   
Instruments * Instruments::LoadFile(char* /*filename*/)

{
/*	MyFile file ;
	unsigned long size, id ;
	Instruments *pinst;

	if(file.Open(filename, CFile::modeRead ))
	{
	    id = file.ReadID();
    	size = file.ReadSize();
	    if (id == ID_INSTRUMENTS)
    	{
			pinst = Instruments::Load(&file,size);
		}
		file.Close();
	}
	return(pinst);
*/
	return NULL;
}

void Instruments::SaveFile(char* /*filename*/)

{
/*	MyFile file ;

	if(file.Open(filename, CFile::modeCreate |
	  	CFile::modeReadWrite | CFile::shareExclusive))
	{
		Save(&file);
		file.Close();
	}
*/
}

GrooveName::GrooveName()

{
	strcpy(m_name,"Duh...");
	m_grooveid = 0;
}

void GrooveName::Save( IStream *pIStream )

{ 
	WriteID( pIStream, ID_GROOVENAME );
	pIStream->Write(this, sizeof(GrooveName), NULL );
}

long GrooveName::Size()

{
	return(sizeof(GrooveName));
}

GrooveName * GrooveName::Load( IStream *pIStream,long /*lfilesize*/)

{
	GrooveName *pinst = new GrooveName;
	pIStream->Read( pinst, sizeof(GrooveName),NULL );
	return(pinst);		
}


void InstrumentsList::ClearList()

{
	Instruments *pinst;
	while ( (pinst = GetHead()) != 0 )
	{
		Remove(pinst);
		delete pinst;
	}
}

void GrooveNameList::ClearList()

{
	GrooveName *pgroove;
	while ( (pgroove = GetHead()) != 0 )
	{
		Remove(pgroove);
		delete pgroove;
	}
}

void PersonalityList::ClearList()

{
	Personality *map;
	while ( (map = GetHead()) != 0 )
	{
		Remove(map);
		delete map;
	}
}

#define ID_STYL        0x5354594C

/*
static void makenewname(char * filename)

{
	char drive[_MAX_DRIVE];
	char dir[_MAX_DIR];
	char file[30];

	_splitpath(filename,drive,dir,file,NULL);
	_makepath(filename,drive,dir,file,".sct"); 
}
*/
/*
static BOOL copyfile(char * oldfile,char * newfile)

{
	CFile source;
	CFile dest;
	if (dest.Open(newfile,CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive))
	{
		if (source.Open(oldfile,CFile::modeRead | CFile::shareExclusive))
		{
			int length = 200;
			char buff[200];
			while (length > 0)
			{
				length = source.Read(buff,200);
				dest.Write(buff,length);
			}
			source.Close();
			dest.Close();
			return(TRUE);
		}
		dest.Close();
	}
	return(FALSE);	
}
*/




void ChordEntryToChordExt(ChordEntry* pChordEntry, ChordExt* pChordExt)
{
	ASSERT(pChordEntry);
	ASSERT(pChordExt);


	*dynamic_cast<DMPolyChord*>(pChordExt) = pChordEntry->m_chordsel;
//	pChordExt->KeyDown() = pChordEntry->KeyDown();
}


long ChordPalette::Size(long version)
{
	if(version == ID_DMCHORDPALETTE)
	{
		return sizeof(ChordPalette);
	}
	else
	{
		return 24 * (sizeof(void*) + OldChordEntry::SizeChordSelection());
	}
}

HRESULT ChordPalette::Save(IStream* pStream, long version)
{
	HRESULT hr = S_OK;
	OldChordEntry oce;
	for(int i = 0; i < 24; i++)
	{
		if(version == ID_DMCHORDPALETTE)
		{
			ASSERT(FALSE);	// not implemented yet
		}
		else
		{
			WriteSize(pStream, 0);	// dwlistitem ptr
			m_chords[i].Save(oce);
			hr = pStream->Write(&oce, OldChordEntry::SizeChordSelection(), NULL);
		}
	}
	return hr;
}

HRESULT ChordPalette::Load(IStream* pStream, long version)
{
	HRESULT hr = S_OK;
	OldChordEntry oce;
	for(int i = 0; i < 24; i++)
	{
		if(version == ID_DMCHORDPALETTE)
		{
			ASSERT(FALSE);	// not implemented yet
		}
		else
		{
			ReadSize(pStream);	// dwlistitem ptr
			hr = pStream->Read(&oce, OldChordEntry::SizeChordSelection(), NULL);
			m_chords[i].Load(oce);
		}
	}
	return hr;
}




void DMPolyChord::InitLevels()
{
	for(int i = 0; i < MAX_POLY; i++)
	{
		SubChord(i)->Levels() = (1 << i);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\Chord.h ===
// chord.h

#include "DWList.h"
#include "ChordMapStripMgr.h"

#ifndef __CHORD_H__
#define __CHORD_H__

#pragma pack(1)

#define FIELDOFFSET(s,f)     (long)(& (((s __RPC_FAR *)0)->f))


#define MakeID(a,b,c,d)  ( (LONG)(a)<<24L | (LONG)(b)<<16L | (c)<<8 | (d) )

#define ID_CHORDENTRY   MakeID('s','C','E','N')
#define ID_NEXTLIST     MakeID('s','N','X','L')
#define ID_PERSONALITY  MakeID('s','P','E','R')
#define ID_PERSONREF    MakeID('s','P','R','F')
#define ID_NEWSTYLE     MakeID('s','S','T','Y')
#define ID_CHORDPALETTE MakeID('s','C','P','L')
#define ID_TEMPLATE     MakeID('s','T','P','L')
#define ID_TEMPLATELIST MakeID('s','T','L','S')
#define ID_SIGNPOST     MakeID('s','S','N','P')
#define ID_INSTRUMENTS  MakeID('s','I','N','S')
#define ID_COMMAND      MakeID('s','C','M','D')
#define ID_GROOVENAME   MakeID('s','G','R','N')

// Large versions for editing:
#define ID_EPERSONALITY MakeID('s','C','M','P')
#define ID_ECHORDENTRY  MakeID('e','C','E','N')
#define ID_ENEXTLIST    MakeID('e','N','X','L')
#define ID_ESTYLE       MakeID('e','S','T','Y')
#define ID_EPERSONREF   MakeID('e','P','R','F')

// new DM ids
#define ID_DMCHORDENTRY		MakeID('x','C','E','N')
#define ID_DMNEXTLIST		MakeID('x','N','X','L')
#define ID_DMSIGNPOST		MakeID('x','S','N','P')
#define ID_DMCHORDPALETTE	MakeID('x','C','P','L')
#define ID_DMPERSONALITY	MakeID('x','P','E','R')

// extended version for Jazz
#define ID_JPERSONALITY MakeID('j','C','M','P')
#define ID_J4PERSONALITY MakeID('4', 'C', 'M', 'P')
#define ID_J5PERSONALITY MakeID('5', 'C', 'M', 'P')

/*  SCTchord bBits flags ===============================================*/
#define CHORD_INVERT  0x10      /* This chord may be inverted           */
#define CHORD_FOUR    0x20      /* This should be a 4 note chord        */
#define CHORD_UPPER   0x40      /* Shift upper octave down              */
#define CHORD_SIMPLE  0x80      /* This is a simple chord               */
#define CHORD_COUNT   0x0F      /* Number of notes in chord (up to 15)  */

#define CHORD_CONNECTION_TOCHORD 0x4000 /* chord is "to" part of a connection */
#define CHORD_CONNECTION_FROMCHORD 0x2000 /* chord is "from" part of a connection */

// enums for selection type (matches Chordmapmgr enums
#define CHORD_NO_SELECTION						0
#define CHORD_PALETTE_SELECTED					1
#define CHORD_MAP_SELECTED							2
#define CHORD_CONNECTION_SELECTED			3

#define ID_CHRD        0x43485244
#define ID_KBRD        0x4B425244

void swaplong(char data[]);
void WriteID( IStream *pIStream, DWORD id );
void WriteSize( IStream *pIStream, long size );
long ReadID( IStream *pIStream );
long ReadSize( IStream *pIStream );


inline long Rotate24(long val, long shift)
{
	__int64 mask64 = 0xffffff;
	__int64 val64 = val;

	ASSERT(shift > -24 && shift < 24);
	if(shift < 0)
	{
		shift = 24 + shift;
	}
	val64 = (val64 & mask64) << shift;
	__int64 excess = (val64 >> 24) & mask64;	// rotate
	val64 |= (excess & ~(1<<shift));
	val =  long(val64 & mask64);
	return val;
}


inline unsigned long Canonical24(unsigned long pattern, unsigned long root)
//
// convert pattern (scale or chord) to a canonical representation where octave 
// equivalences are filled in.
//
{
	if(!(pattern & 0xf00000))
	{
		// dup at octave
		pattern |= pattern << 12;
	}
	pattern = Rotate24(pattern, root%12);
	// fill in lower bits
	pattern |= pattern>>12;
	return pattern;
}

inline DWORD BlueBits(DWORD& cp, DWORD cr, DWORD& sp, DWORD sr, bool bReturnCanonicalForm = true)
// ~(chord -> scale) = ~(scale | ~chord) = ~scale & chord
{
	DWORD scale, chord;
	scale = Canonical24(sp,sr);
	chord = Canonical24(cp,cr);
	DWORD pattern = ~scale  & chord;
	if(bReturnCanonicalForm)
	{
		sp = scale;
		cp = chord;
	}
	return pattern;
}


inline bool InScale(char root, long chordpattern, long scalepattern)
{
	bool match = (Rotate24(chordpattern, (long)root) | scalepattern) == scalepattern;
	return match;
}


// structs for loading old personalities
struct OldChordEntry
{
	// ChordSelection = 38
	long time;
	long pattern;
	char name[12];
	char keydown;
	char root;
	char inscale;
	char flat;
	short varflags;
	short measure;
	char beat;
	BYTE bits;
	long scalepattern;
	long melodypattern;
	// SmallChordEntry = 44
	DWORD dwflags;
	short nid;
	// extended = 54
	short rect[4];
	short page;
	static DWORD	SizeExtendedChordEntry();
	static DWORD	SizeChordSelection();
	static DWORD	SizeSmallChordEntry();
};

struct OldNextChord
{
	// small
	DWORD	dwflags;
	short	nweight;
	short	nminbeats;
	short	nmaxbeats;
	short	nid;
	// extended
	short	rect[4];
};

// DM structures
// DMChord represents a subchord in a multi chord structure
class DMPolyChord;
class DMChord
{
	DWORD	m_dwChordPattern;
	DWORD	m_dwScalePattern;
	DWORD	m_dwInvertPattern;
	DWORD	m_dwLevels;		// which levels of multi chord this subchord supports
	WORD	m_wFlags;
	BYTE	m_bChordRoot;
	BYTE	m_bScaleRoot;
	BYTE	m_bFlat;
	BYTE	m_bBits;
	bool	m_bInUse;
public:
	DWORD&	ChordPattern()
	{
		return m_dwChordPattern;
	}
	DWORD ChordPattern() const
	{
		return m_dwChordPattern;
	}
	DWORD&	ScalePattern()
	{
		return m_dwScalePattern;
	}
	DWORD	ScalePattern() const
	{
		return m_dwScalePattern;
	}
	DWORD&	InvertPattern()
	{
		return m_dwInvertPattern;
	}
	DWORD	InvertPattern() const
	{
		return m_dwInvertPattern;
	}
	DWORD& Levels()
	{
		return m_dwLevels;
	}
	DWORD Levels() const
	{
		return m_dwLevels;
	}
	WORD&	Flags()
	{
		return m_wFlags;
	}
	WORD	Flags() const
	{
		return m_wFlags;
	}
	BYTE&	ChordRoot()
	{
		return m_bChordRoot;
	}
	BYTE	ChordRoot() const
	{
		return m_bChordRoot;
	}
	BYTE&	ScaleRoot()
	{
		return m_bScaleRoot;
	}
	BYTE	ScaleRoot() const
	{
		return m_bScaleRoot;
	}
	BYTE&	UseFlat()
	{
		return m_bFlat;
	}
	BYTE	UseFlat() const
	{
		return m_bFlat;
	}
	BYTE&	Bits()
	{
		return m_bBits;
	}
	BYTE	Bits() const
	{
		return m_bBits;
	}
	bool&	InUse()
	{
		return m_bInUse;
	}
	bool	InUse() const
	{
		return m_bInUse;
	}
	DMChord();
	DMChord(const DMChord& chord)
	{
		memcpy(this, &chord, sizeof(DMChord));
	}
	DMChord& operator = (const DMChord& chord)
	{
		memcpy(this, &chord, sizeof(DMChord));
		return *this;
	}
	int BassNote();
	int Third(int * bass);
	int Fifth(int * bass, int * third);
	int Seventh(int* bass, int* third, int* fifth);
	void ChordNotes(int& bass, int& third, int& fifth, int& seventh);
	int NoteCount();	// number of notes in chord
};

// DMPolyChord represents a multi chord
class DMPolyChord
{
public:
	void InitLevels();
	enum { ALL = -1, MAX_POLY = 4, MAX_NAME = 12 };
	DMPolyChord();
	DMPolyChord(const DMPolyChord&);
	DMChord* const	operator[] (int index)
	{
		if(index >= MAX_POLY 
			|| index < 0)
		{
			return 0;
		}
		else
		{
			return &m_Chords[index];
		}
	}
	DMChord* const SubChord(int index)
	{
		if(index >= MAX_POLY 
			|| index < 0)
		{
			return 0;
		}
		else
		{
			return &m_Chords[index];
		}
	}
	DWORD&	Time()
	{
		return m_dwTime;
	}
	DWORD	Time() const
	{
		return m_dwTime;
	}
	short&	Measure()
	{
		return m_nMeasure;
	}
	short Measure() const
	{
		return m_nMeasure;
	}
	BYTE&	Beat()
	{
		return m_bBeat;
	}
	BYTE	Beat() const
	{
		return m_bBeat;
	}
	TCHAR* const Name()
	{
		return m_szName;
	}
	DMPolyChord& operator = (const DMPolyChord&);
	enum { INVALID = 255 };	// invalid chord (set root index to this to indicate)
	BYTE& RootIndex()
	{
		return m_bRootIndex;
	}
	void Load(OldChordEntry& oce);
	void Save(OldChordEntry& oce);
	bool& KeyDown() 
	{
		return m_keydown;
	}
	// some convenience funcs for old code
	DMChord* const Base()
	{
		if(m_bRootIndex == INVALID)
			return SubChord(0);
		else
			return SubChord(m_bRootIndex);
	}
	DMChord* operator->()
	{
		return Base();
	}

	void SetBase(int v)
	{
		m_bRootIndex = static_cast<BYTE>(v);
	}

	// mass copy functions, from base to other subchords
	void PropagateChordPattern();
	void PropagateScalePattern();
	void PropagateInvertPattern();
	void PropagateLevels();
	void PropagateFlags();
	void PropagateChordRoot();
	void PropagateScaleRoot();
	void PropagateUseFlat();
	void PropagateBits();
	void PropagateInUse();
	void PropagateAll();

protected:
	DMChord	m_Chords[MAX_POLY];
	DWORD	m_dwTime;
	short	m_nMeasure;
	BYTE	m_bBeat;
	BYTE	m_bRootIndex;	// identifies which chord in m_Chords is the root
	TCHAR	m_szName[12];
	bool	m_keydown;
};




class ChordSelection : public DWListItem, public DMPolyChord {
public:
            ChordSelection();
			ChordSelection(const ChordSelection& cs) : DMPolyChord(cs)
			{
				SetNext(0);
			}
    void    SetBits(int nSubChord);		// nSubChord == -1 --> match all subchords
//    void    SetMelody(int nSubChord);        // Converts pattern into melodypattern. 
											// nSubChord == -1 --> match all subchords
    BOOL    Equals(ChordSelection *second, int nSubChord);	// nSubChord == -1 --> match all subchords
    void    GetName(char *string);
    void    RootToString(char *string); // Convert from root to text name.

    void    LoadFile(char *filename);
    void    SaveFile(char *filename);
	void SetChordPattern(DWORD dwPattern, int nSubChord);
	void SetScalePattern(DWORD dwPattern, int nSubChord);
	void SetChordRoot(BYTE root, int nSubChord);
	void SetScaleRoot(BYTE root, int nSubChord);
	void SetUseFlats(BYTE bFlat, int nSubChord);
};


#define ID_CHRD        0x43485244
#define ID_KBRD        0x4B425244

#define CHORD_WIDTH     80
#define CHORD_HEIGHT    26
#define CENTER_X        (CHORD_WIDTH >> 1)
#define CENTER_Y        (CHORD_HEIGHT >> 1)
#define NEXT_HEIGHT     14
#define NEXT_INDENT     10

class Personality;
//class MyFile;
class NextChord;
class SearchInfo;

class NextList : public DWList {
public:
    NextChord *     GetHead() { return(NextChord*)DWList::GetHead();};
	NextChord *		RemoveHead() { return (NextChord*)DWList::RemoveHead();}
    void            ClearList();
    void			Save( IStream *pIStream, BOOL bSmall );
    long            Size(BOOL bSmall);
    void            Load( IStream *pIStream,long lsize);
};

class SmallChordEntry : public DWListItem {
public:
	SmallChordEntry()
	{
		memset(this, 0, sizeof(SmallChordEntry));
	}
	SmallChordEntry(const SmallChordEntry& );
    NextList        m_nextchordlist;// List of chords to go to next.
    ChordSelection  m_chordsel;     // Chord definition.
    unsigned long   m_dwflags;      // Various flags.
    short           m_nid;          // ID for pointer maintenance.
};


//#define SmallChordEntryFileSize  (OldChord - sizeof(DWListItem) + sizeof(unsigned long) + sizeof(short));

#define SmallChordEntryFileSize (OldChordEntry::SizeSmallChordEntry())


#define CE_SELECTED 1               // This is the active chord.
#define CE_START    2
#define CE_END      4
#define CE_MEASURE  8
#define CE_PATH     16
#define CE_TREE     32

#define CE_MATCHED			(1 << 8)	// if signpost chord, indicates chord is matched by chord in signpost list
#define CE_DRAGSELECT		(1 << 9)
#define CE_DROPSELECT		(1 << 10)



class CChordItem;
class CPropChord;
class ChordEntry : public SmallChordEntry {
public:
                    ChordEntry();
					ChordEntry(const ChordEntry& ce);
                    ~ChordEntry();
	bool			IsSignPost()
	{
		return (m_dwflags & CE_START) || (m_dwflags & CE_END);
	}
	void			CopyNextList(ChordEntry& sce, bool bCopyOnlySelected);
	ChordEntry *    GetNext(){ return (ChordEntry *)(DWListItem::GetNext()); };
    void            Save( IStream *pIStream, BOOL bSmall );
    long            Size(BOOL bSmall, long version = 0);
    static ChordEntry * Load( IStream *pIStream,long filesize, long id);
    void            Draw(CDC *pDC,short page);
    void            CleanupNexts();
	void			LoadSmall(OldChordEntry& oce);
	void			LoadExtended(OldChordEntry& oce);
	void			SaveSmall(OldChordEntry& oce);
	void			SaveExtended(OldChordEntry& oce);
    void            Debug();
    void            AssignParents();
    void            MarkTree();
	void			LoadFromChordItem(CChordItem&);
	void			LoadFromPropChord(CPropChord& chord);
	void			SaveToPropChord(CPropChord& chord);
    struct
	{
		short		left;
		short		top;
		short		right;
		short		bottom;
	} m_rect;
    short           m_page;
	struct
	{
		short		left;
		short		top;
		short		right;
		short		bottom;
	} m_lastrect;
    Personality     *m_parent;      // The parent chord map.
};

//#define ChordEntryFileSize (SmallChordEntryFileSize + (sizeof(short) * 4) + sizeof(short))

#define ChordEntryFileSize (OldChordEntry::SizeExtendedChordEntry())

class ChordEntryList : public DWList {
public:
    ChordEntry *    GetHead() {return(ChordEntry *)DWList::GetHead();};
	ChordEntry *	RemoveHead() {return (ChordEntry *)DWList::RemoveHead();};
	void			ClearList();
};

#define PAGE_1      1
#define PAGE_2      2
#define PAGE_3      4
#define PAGE_4      8
#define PAGE_5      0x10
#define PAGE_6      0x20
#define PAGE_7      0x40
#define PAGE_8      0x80



class SmallNextChord : public DWListItem {
public:
    ChordEntry      *m_nextchord;   // Destination chord.
	BOOL			IsSelected()
	{
		return !(m_nextchord == NULL);
	}
    unsigned long   m_dwflags;
    short           m_nweight;      // Importance of destination chord.
    short           m_nminbeats;    // Min beats to wait till chord.
    short           m_nmaxbeats;    // Max beats to wait till chord.
    short           m_nid;          // ID of destination chord.
};

#define SmallNextChordFileSize (sizeof(SmallNextChord) - sizeof(ChordEntry *))

class NextChord : public SmallNextChord {
public:
                    NextChord();
					NextChord(const NextChord& nc)
					{
						m_nextchord = 0;
						m_parent = nc.m_parent;
						SetNext(0);
						m_dwflags = nc.m_dwflags;
						m_nweight = nc.m_nweight;
						m_nminbeats = nc.m_nminbeats;
						m_nmaxbeats = nc.m_nmaxbeats;
						m_nid = nc.m_nid;
						memcpy(&m_rect, &(nc.m_rect), sizeof(m_rect));
					}
    NextChord *     GetNext() {return(NextChord *)DWListItem::GetNext();};
    void            Debug();
    void            MarkTree();
    void            Draw(CDC *pDC,short page);
//    CRect           m_rect;         // Box in display.
	struct
	{
		short		left;
		short		top;
		short		right;
		short		bottom;
	} m_rect;
    ChordEntry      *m_parent;      // Source chord.
};

#define NextChordFileSize (SmallNextChordFileSize + sizeof(ChordEntry *))

#define NC_SELECTED 1               // This is the active connector.
#define NC_PATH     2               // For walking the tree.
#define NC_NOPATH   4               // Failed tree walk.
#define NC_TREE     8               // For displaying a tree.
#define NC_DELETE	16

class TempCommand;
class PlayChord;

class FailSearch {
public:
                    FailSearch()
                    {
                        m_toomanybeats = 0;
                        m_toofewbeats = 0;
                        m_toomanychords = 0;
                        m_toofewchords = 0;
                    }
    short           m_toomanybeats;
    short           m_toofewbeats;
    short           m_toomanychords;
    short           m_toofewchords;
};

class SearchInfo {
public:
                    SearchInfo()
                    {
                        m_pfirstchord = NULL;
                        m_pplaychord = NULL;
                    };
    ChordSelection  m_start;
    ChordSelection  m_end;
    PlayChord *     m_pplaychord;
    ChordEntry *    m_pfirstchord;
    short           m_beats;
    short           m_minbeats;
    short           m_maxbeats;
    short           m_chords;
    short           m_minchords;
    short           m_maxchords;
    short           m_activity;
    FailSearch      m_fail;
};

#define ACTIVITY_SLOW   2
#define ACTIVITY_MEDIUM 1
#define ACTIVITY_FAST   0

class ChordPalette {
public:
                    ChordPalette();
    void            InitChords(BOOL major,BOOL allnotes,BOOL fat,BOOL flat);
    BOOL            LoadFile(char *filename);
    BOOL            SaveFile(char *filename);
	HRESULT			Load(IStream* pStream, long version = 0);
	HRESULT			Save(IStream*, long version = 0);
	static long		Size(long version);
	ChordSelection&	Chord(int i) { return m_chords[i]; }
    ChordSelection  m_chords[24];
};



#define PF_FILL     1           /* Fill pattern.                    */
#define PF_INTRO    2
#define PF_WHOLE    4           /* Handles chords on measures.      */
#define PF_HALF     8           /* Chords every two beats.          */
#define PF_QUARTER  0x10        /* Chords on beats.                 */
#define PF_BREAK    0x20
#define PF_END      0x40
#define PF_A        0x80
#define PF_B        0x100
#define PF_C        0x200
#define PF_D        0x400
#define PF_E        0x800
#define PF_F        0x1000
#define PF_G        0x2000
#define PF_H        0x10000
#define PF_STOPNOW  0x4000
#define PF_INRIFF   0x8000
#define PF_BEATS    (PF_WHOLE | PF_HALF | PF_QUARTER)
#define PF_RIFF     (PF_INTRO | PF_BREAK | PF_FILL | PF_END)
#define PF_GROOVE   (PF_A | PF_B | PF_C | PF_D | PF_E | PF_F | PF_G | PF_H)

#define SP_A        1
#define SP_B        2
#define SP_C        4
#define SP_D        8
#define SP_E        0x10
#define SP_F        0x20
#define SP_LETTER   (SP_A | SP_B | SP_C | SP_D | SP_E | SP_F)
#define SP_1        0x100
#define SP_2        0x200
#define SP_3        0x400
#define SP_4        0x800
#define SP_5        0x1000
#define SP_6        0x2000
#define SP_7        0x4000
#define SP_ROOT     (SP_1 | SP_2 | SP_3 | SP_4 | SP_5 | SP_6 | SP_7)
#define SP_CADENCE  0x8000

// Structure shape:

#define STR_FALLING     1
#define STR_LEVEL       2
#define STR_LOOPABLE    3
#define STR_LOUD        4
#define STR_QUIET       5
#define STR_PEAKING     6
#define STR_RANDOM      7
#define STR_RISING      8
#define STR_SONG        9  

/*
class Template : public DWListItem {
public:
                    Template();
                    ~Template();
    Template *      GetNext() { return(Template *) DWListItem::GetNext();};
    void            Save(MyFile *pfile);
    long            Size();
    static Template *Load(MyFile *pfile,long lsize);
    static Template *LoadFile(char *filename);
    BOOL            SaveFile(char *filename);
    void            CopyInto(Template *);
    void            MakeName(char *string,short max);
    void            CommandsToString(char *string,short max);
    void            ExpandCommands();
    void            CompressCommands();
    void            CreateSignPosts();
    void            CopyCommands(Template *psource,short measure);
    void            CreateEmbellishments(short shape);
    void            AddChord(short nmeasure,DWORD dwchord);
    void            AddCommand(short nmeasure,DWORD dwcommand);
    void            InsertCommand(Command *pcommand,BOOL iscommand);
    void            CutCommands(Template *pdest,short measure,short length);
    void            PasteCommands(Template *psource,short measure);
    short             NextSignPost(short measure,DWORD signpost,short quantize);
    DWORD           GetFirstSignPost();
    void            Dump();
//  void            StringToNodes(char *string,short max);
    char            m_name[20];
    char            m_type[20];
    short           m_measures;
    CommandList     m_commandlist;
};
*/
/*
class TemplateList : public DWList {
public:
                    TemplateList();
    void            ClearList();
    Template *      GetHead() { return (Template *) DWList::GetHead();};
    void            Save(MyFile *pfile);
    long            Size();
    static TemplateList *Load(MyFile *pfile,long lsize);
    static TemplateList *LoadFile(char *filename);
    BOOL            SaveFile(char *filename);
    void            CopyInto(TemplateList *);
    void            CompressCommands();
};
*/

class SignPost : public DWListItem {
public:
	enum { MAX_CADENCE = 2 };
                    SignPost();
    SignPost *      GetNext() {return(SignPost *) DWListItem::GetNext();};
    void            Save( IStream *pIStream );
    static long            Size(long version = 0);
    static SignPost *Load( IStream *pIStream,long lsize);
    void            SaveFile(char *filename);
    static SignPost *LoadFile(char *filename);
    void            MakeName(char *string);
    ChordSelection  m_chord;            // Chord for sign post.
    ChordSelection  m_cadence[MAX_CADENCE];       // Chords for cadence.
    DWORD           m_chords;       // Which kinds of signpost supported.
    DWORD           m_dwflags;
    DWORD           m_tempflags;
};

class SignPostList : public IndexList {
public:
    SignPost *      GetHead() {return(SignPost *) IndexList::GetHead();};
};

#define SPOST_CADENCE1  2   // Use the first cadence chord.
#define SPOST_CADENCE2  4   // Use the second cadence chord.

class PlayChord : public DWListItem {
public:
                    PlayChord();
    PlayChord *     GetNext() {return (PlayChord *)DWListItem::GetNext();};
    ChordSelection *m_pchord;       // Chord to perform.
    NextChord *     m_pnext;        // Transition pointer to chord.
    unsigned long   m_dwflags;
    short           m_measure;
    short           m_beat;
    short           m_minbeats;
    short           m_maxbeats;
};

class PlayList : public DWList {
public:
    void            ClearList();
    PlayChord *     GetHead() {return(PlayChord *) DWList::GetHead();};
};


class PersonalityRef {
public:
    char            m_stylename[20];// Unique name for UI display.
    char            m_name[20];     // Personality name for internal use.
    char            m_filename[9];  // Unique name for file.
    char            m_isdefault;    // Set for default personality.
};

class Personality : public DWListItem {
public:
                    Personality();
                    ~Personality();
    Personality *   GetNext() {return(Personality *)DWListItem::GetNext();};

    void            Save( IStream *pIStream, long version = 0 );	// save just personality
    void			Load( IStream *pIStream,long lsize, long version = 0); // load just personality

    void            SaveRef( IStream *pIStream,BOOL bSmall);
    long			TotalSize(BOOL bSmall, long version = 0);	// includes contained structs
	static long		PersonalitySize(long version = 0);		// just size of this structure
    static Personality *LoadRef( IStream *pIStream,long lsize,BOOL bSmall);
    BOOL            LoadFile(char *filename);
    BOOL            SaveFile(char *filename,BOOL bSmall);
    void            Debug();
    void            AssignParents();
    void            Draw(CDC *pDC,short page);
    void            MarkTree(ChordEntry *pchord);
    BOOL            IsValidChord(ChordEntry *ptest);
    BOOL            IsValidNext(NextChord *ptest);
    void            ClearChordFlags(unsigned long flag);
    void            ClearNextFlags(unsigned long flag);
    ChordEntry *    FindXYChord(CPoint point,short page);
    NextChord *     FindXYNext(CPoint point,short page);
    void            AssignIDs();    // Make sure all chords have IDs.
    void            ResolveConnections(); // Resolve pointers.
    BOOL            PlayStop();
    BOOL            CalcViewSize();
    BOOL            GetChord(ChordSelection *pchord,DWORD flag,short index);
    short             GetChordCount(DWORD flag);
    short             GetChordIndex(ChordSelection *pcsel,DWORD flag);
    void            InsertChords(short leftedge,DWORD flags);
    void            BuildNeededChords(ChordEntryList *list,DWORD flags);
    ChordEntryList  m_chordlist;    // All chords in the map.
    SignPostList    m_signpostlist; // All available sign posts.
    long            m_scalepattern; // Scale for map.
    char            m_name[20];     // ID Name (not used by application.) Musical Name
    char            m_description[80];
    char			m_username[20]; // Generic name for display.
    ChordPalette    m_chordpalette; // Palette of Chords for static Map.
    unsigned long   m_dwflags;
    PlayList        m_playlist;     // Collection of NextChords for playback.
    ChordEntry *    m_pfirstchord;
    PersonalityRef  m_personref;    // Used to track name and file io.
    short			m_cx;
	short			m_cy;				// CSize           m_size;
};

#define CM_FLAT     1               // Display scale and chords with flats.
#define CM_DEFAULT  2               // Default personality.
#define CM_EMBED    4               // Used in Style Packager.

class PersonalityList : public IndexList {
public:
    Personality *   GetHead() {return(Personality *) IndexList::GetHead();};
    Personality *   GetIndexedItem()
                    {
                        return(Personality *) IndexList::GetIndexedItem();
                    };
    void            ClearList();
};

#define INST_LEAD       0
#define INST_STRINGS    1
#define INST_GUITAR     2
#define INST_PIANO      3
#define INST_BASS       4
#define INST_DRUMS      5


class Instruments : public DWListItem {
public:
                    Instruments();
    Instruments *   GetNext() {return(Instruments *)DWListItem::GetNext();};
    static Instruments * LoadFile(char *filename);
    void            SaveFile(char *filename);
    void            Save( IStream *pIStream );
    long            Size();
    static Instruments * Load( IStream *pIStream,long lsize);
    char            m_name[20];
    unsigned char   m_patch[16];
    char            m_default;
};

class InstrumentsList : public DWList {
public:
    Instruments *   GetHead() {return(Instruments *) DWList::GetHead();};
    void            ClearList();
};

class GrooveName : public DWListItem {
public:
                    GrooveName();
    GrooveName *    GetNext() {return(GrooveName *)DWListItem::GetNext();};
    void            Save( IStream *pIStream );
    long            Size();
    static GrooveName * Load( IStream *pIStream,long lsize);
    char            m_name[20];
    DWORD           m_grooveid;
};

class GrooveNameList : public DWList {
public:
    GrooveName *    GetHead() {return(GrooveName *) DWList::GetHead();};
    void            ClearList();
    void            SetDefaults();
    void            AddGrooveName(char *name,DWORD grooveid);
    GrooveName *    GetGrooveName(DWORD grooveid);
};

class ChordChangeCallback : public IUnknown
{
public:

	ChordChangeCallback() : m_pChordEntry(0), m_callbackType(Unknown), m_dwRef(0) { AddRef();}
	ChordChangeCallback(int ct) : m_pChordEntry(0), m_callbackType(ct), m_dwRef(0) { AddRef();}
	~ChordChangeCallback();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	// callback info determination
	enum   { Unknown, ChordMapNewSelection,  ParentShowProps};

//	void SetCallbackType(CallbackType ct) { m_callbackType = ct; }
	int GetCallbackType() { return m_callbackType; }

	void SetChordEntry(ChordEntry* pChordEntry) {ASSERT(pChordEntry); 
											   m_pChordEntry = pChordEntry;}

	ChordEntry* GetChordEntry() {return m_pChordEntry;}
	
private:
	ChordEntry* m_pChordEntry;
	int m_callbackType;
	DWORD		m_dwRef;
};

class PreEditNotification : public IUnknown
{
	DWORD m_dwRef;
public:
	PreEditNotification(CString reason) : m_strReason(reason), m_dwRef(0)
	{
		AddRef();
	}

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	CString	m_strReason;
};

// sent when chordmap detects that orphan status of chords or signposts may need to be rechecked
class CheckForOrphansNotification : public IUnknown
{
	DWORD m_dwRef;
public:
	CheckForOrphansNotification() 
		: m_dwRef(0)
	{
		AddRef();
	}

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
};

// sent when chordmap notifies personality of change of zoom
class ZoomChangeNotification : public IUnknown
{
	DWORD m_dwRef;
public:
	ZoomChangeNotification() 
		: m_dwRef(0)
	{
		AddRef();
	}

	double m_dblZoom;

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv )
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
		if(::IsEqualIID(riid, IID_IUnknown))
		{
			AddRef();
			*ppv = this;
			return S_OK;
		}

		if(::IsEqualIID(riid, IID_ZoomChangeNotification))
		{
			AddRef();
			*ppv = this;
			return S_OK;
		}

		*ppv = NULL;
		return E_NOINTERFACE;
	}
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
};


//////////////////////////////////////////
// ChordExt Structure
// Used to store a Section's single linked chord list.
// Use: CSection::m_paChordChanges.
class ChordExt	: public DMPolyChord
{
//	bool		m_keydown;
public:
	ChordExt()
	{
		m_keydown = false;
		pNext = 0;
	}
    ChordExt		*pNext;
//	bool& KeyDown()
//	{
//		return m_keydown;
//	}
};

typedef struct CommandExt
{
    CommandExt* pNext;
    long        time;       // Time, in clocks
    short       measure;    // Which measure
    DWORD       command;    // Command type
    DWORD       chord;      // Used by composition engine
} CommandExt;



void ChordEntryToChordExt(ChordEntry* pChordEntry, ChordExt* pChordExt);

#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\CConnectionPropPageMgr.cpp ===
#include "stdafx.h"
#include "..\includes\DMUSProd.h"
#include "ChordMapStripMgr.h"
#include "ConnectionPropPage.h"
#include "ConnectionPropPageMgr.h"
#include "LockoutNotification.h"


// PropPageConnection.cpp : implementation file
//

#include "..\includes\Conductor.h"
#include "PropChord.h"
#include "PropPageMgr.h"
#include "PropPageChord.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
/////////////////////////////////////////////////////////////////////////////
// CConnectionPropPageMgr property page

CConnectionPropPageMgr::CConnectionPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pPropPageConnection = NULL;
	m_pJazzFramework = NULL;
	CStaticPropPageManager::CStaticPropPageManager();
}

CConnectionPropPageMgr::~CConnectionPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageConnection )
	{
		delete m_pPropPageConnection;
		m_pPropPageConnection = 0;
	}
	if ( m_pJazzFramework )
	{
		m_pJazzFramework->Release();
		m_pPropPageConnection = 0;
	}
	CStaticPropPageManager::~CStaticPropPageManager();
}

HRESULT STDMETHODCALLTYPE CConnectionPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
};

HRESULT STDMETHODCALLTYPE CConnectionPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;

	strTitle.LoadString( IDS_PROPPAGE_CONNECTION );
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
};

HRESULT STDMETHODCALLTYPE CConnectionPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add Connection tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	if(!m_pPropPageConnection)
		m_pPropPageConnection = new CConnectionPropPage();
	if( m_pPropPageConnection )
	{

		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pPropPageConnection->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		m_pPropPageConnection->m_pPropPageMgr = this;
		if (!m_pJazzFramework)
		{
			pIPropSheet->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pJazzFramework );
		}
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};

HRESULT STDMETHODCALLTYPE CConnectionPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ConnectionData data;
	ConnectionData* pdata = &data;
	if( m_pIPropPageObject == NULL )
	{
		return E_FAIL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pdata ) ) )
	{
		return E_FAIL;
	}
	if (m_pPropPageConnection )
	{
		// Don't send OnKill/OnUpdate notifications when updating the display
		CLockoutNotification LockoutNotifications( m_pPropPageConnection->m_hWnd );

		m_pPropPageConnection->SetConnection( pdata->nWeight );
		// hack to cure race condition: if you set maxbeats first, test that it is >= minbeats
		// may fail as minbeats hasn't been updated yet
		short nMinBeats = pdata->nMinBeats;
		m_pPropPageConnection->SetMinBeats(0);
		m_pPropPageConnection->SetMaxBeats(pdata->nMaxBeats);
		m_pPropPageConnection->SetMinBeats(nMinBeats);
		m_pPropPageConnection->SetMinMaxEdit(pdata->fVariableNotFixed);
	}
	else
	{
		return E_FAIL;
	}
	return S_OK;
};


HRESULT STDMETHODCALLTYPE CConnectionPropPageMgr::UpdateObjectWithTabData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ConnectionData data;
	if( m_pIPropPageObject == NULL || m_pPropPageConnection == NULL)
	{
		return E_FAIL;
	}
	
	data.nWeight = m_pPropPageConnection->m_nWeight;
	data.nMinBeats = m_pPropPageConnection->m_nMinBeats;
	data.nMaxBeats = m_pPropPageConnection->m_nMaxBeats;

	HRESULT hr = m_pIPropPageObject->SetData( (void *)&data );
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ChordInversionPropPage.h ===
#if !defined(AFX_CHORDINVERSIONPROPPAGE_H__E4A7E136_B485_11D1_9875_00805FA67D16__INCLUDED_)
#define AFX_CHORDINVERSIONPROPPAGE_H__E4A7E136_B485_11D1_9875_00805FA67D16__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include "conductor.h"
#include "..\shared\keyboard.h"
#include "..\shared\invertvector.h"

// ChordInversionPropPage.h : header file
//

class BitFlag
{
	unsigned long	dw;
public:
	BitFlag() { dw = 0; }
	BitFlag(unsigned long l) { dw = l; }
	BitFlag& operator = (unsigned long l)
	{
		dw = l;
		return *this;
	}
	unsigned long GetBit(int bit)
	{
		return dw & (1 << bit);
	}
	void SetBit(int bit)
	{
		dw |= (1 << bit);
	}
	void ClearBit(int bit)
	{
		dw &= ~(1<<bit);
	}
	operator unsigned long()
	{
		return dw;
	}
};

class InversionState
{
	int m_state;
public:
	enum { Root=0, First, Second, Third, NStates };
	InversionState()
	{
		m_state = Root;
	}
	void Reset()
	{
		m_state = Root;
	}
	int Get() const { return m_state; }
	void Set(int m)
	{
		ASSERT(Root <= m && m <= Third);
		if(Root <=m && m <= Third)
		{
			m_state = m;
		}
	}
	int Rotate(int highestInvert = -1)
	{
		//highestInvert == # notes in chord
		//highestInvert == -1 -> no inversion limit
		//highestInvert == 0 -> only a single note--nothing to invert
		if(highestInvert > NStates)
			highestInvert = NStates;	// 3 inversions is limit
		if(highestInvert != 0)
		{
			m_state = (m_state + 1) % ((highestInvert==-1) ? NStates : highestInvert );
		}
		return m_state;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage dialog
class CChordPropPageMgr;

class CChordInversionPropPage : public CPropertyPage
{
	friend class CChordPropPageMgr;
	DECLARE_DYNCREATE(CChordInversionPropPage)

// Construction
public:
	CChordInversionPropPage();
	~CChordInversionPropPage();
	enum { MAX_POLY = 4 , CHORDNOTE_DUR = 250, SCALENOTE_DUR = 250, CHORDNOTE_DELAY = 125, SCALENOTE_DELAY=125};

// Dialog Data
	//{{AFX_DATA(CChordInversionPropPage)
	enum { IDD = IDD_CHORDINVERSION_PROPPAGE };
	CKeyboard	m_keysinv4;
	CKeyboard	m_keysinv3;
	CKeyboard	m_keysinv2;
	CKeyboard	m_keysinv1;
	CKeyboard	m_keysbase4;
	CKeyboard	m_keysbase3;
	CKeyboard	m_keysbase2;
	CKeyboard	m_keysbase1;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChordInversionPropPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChordInversionPropPage)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonInvert1();
	afx_msg void OnButtonInvert2();
	afx_msg void OnButtonInvert3();
	afx_msg void OnButtonInvert4();
	afx_msg void OnButtonIplay1();
	afx_msg void OnButtonIplay2();
	afx_msg void OnButtonIplay3();
	afx_msg void OnButtonIplay4();
	afx_msg void OnCheckLegal1();
	afx_msg void OnCheckLegal2();
	afx_msg void OnCheckLegal3();
	afx_msg void OnCheckLegal4();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	HRESULT ChangePatch(BYTE ch, BYTE inst, BYTE msb, BYTE lsb);
	HRESULT PlayNote(BYTE ch, BYTE key, BYTE vel, DWORD startTime, DWORD dur);
	void PlayChordInversion(int index);
	int GetInversionKeyboardIndex(const CKeyboard* pKeyboard);
	CKeyboard* GetInversionKeyboard(int index);
	int GetChordKeyboardIndex(const CKeyboard* pKeyboard);
	CKeyboard* GetChordKeyboard(int index);
	void SetChord(CPropChord* pChord, int SubChord = -1 /* default = all subchords */);
	void SetChordData(CChordScalePropPageData* pChordScalePropPageData);
	void UpdateChordData();
	void DrawInversionNote(CPropChord* pChord, DWORD dwChordInversion, int index, short nX);
	// IUnknown functions
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

private:
	void EnableControls(BOOL bEnable);
	CBitmapButton	m_nextinvert4;
	CBitmapButton	m_nextinvert3;
	CBitmapButton	m_nextinvert2;
	CBitmapButton	m_nextinvert1;
	
	CBitmapButton	m_play4;
	CBitmapButton	m_play3;
	CBitmapButton	m_play2;
	CBitmapButton	m_play1;

	InversionState	m_invertStates[CPropChord::MAX_POLY];
	InvertVector	m_invertVector[CPropChord::MAX_POLY];
	
	CPropChord		m_Chord;
	BOOL			m_fLockAllScales;
	BOOL			m_fSyncLevelOneToAll;

	DWORD			m_cRef;
	CChordPropPageMgr*	m_pPropPageMgr;
	IDMUSProdConductor*	m_pIConductor;
	IDirectMusicPerformance*	m_pIPerformance;
	bool	m_bValidChord;
	BOOL	m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHORDINVERSIONPROPPAGE_H__E4A7E136_B485_11D1_9875_00805FA67D16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ChordIO.cpp ===
#include "stdafx.h"
#include "ChordIO.h"
#include "..\shared\riffstrm.h"
#include "chord.h"

CChordItem::CChordItem()

{
//	TRACE("New ChordItem, addr = %p\n");
	m_lDrawPosition = 0;
	m_dwIndex = 0;
	m_fSelected = 0;
}

CChordItem::CChordItem(const CChordItem& chord)
{
//	TRACE("New ChordItem, addr = %p\n");
	m_lDrawPosition = chord.m_lDrawPosition;
	m_dwIndex = chord.m_dwIndex;
	m_fSelected = chord.m_fSelected;
	*((CPropChord*)this) = chord;
}

CChordItem::CChordItem(const ChordEntry& chord)
{
//	TRACE("New ChordItem, addr = %p\n");
	m_lDrawPosition = 0;
	m_dwIndex = 0;
	m_fSelected = 0;
	SetSelected(const_cast<ChordEntry&>(chord).m_chordsel.KeyDown());
	if( (chord.m_dwflags & CE_START) || (chord.m_dwflags & CE_END) )
	{
		m_fSelected |= SignPost;
		if(chord.m_dwflags & CE_START)
		{
			m_fSelected |= BegSignPost;
		}
		if(chord.m_dwflags & CE_END)
		{
			m_fSelected |= EndSignPost;
		}
	}
	CPropChord* pProp = dynamic_cast<CPropChord*>(this);
	const_cast<ChordEntry&>(chord).SaveToPropChord(*pProp);
}

CChordItem::CChordItem(const ChordSelection& chord)
{
//	TRACE("New ChordItem, addr = %p\n");
	m_lDrawPosition = 0;
	m_dwIndex = 0;
	m_fSelected = 0;
	ChordEntry chordentry;
	chordentry.m_chordsel = chord;
	SetSelected(const_cast<ChordSelection&>(chord).KeyDown());
	CPropChord* pProp = dynamic_cast<CPropChord*>(this);
	const_cast<ChordEntry&>(chordentry).SaveToPropChord(*pProp);
}


DWORD CChordList::PreparePropChord( CPropChord *pPropChord )

/*	Scan through the chord list and combine all chords that have
	m_fSelected set into the one chord for the property page.
*/

{
	DWORD dwSelectCount = 0;	// How many are selected.
	memset( (void *) pPropChord, 0, sizeof (CPropChord));
	CChordItem* pChord = GetHead();
	for (;pChord != NULL; pChord = pChord->GetNext())
	{
		if (pChord->IsSelected())
		{
			if (dwSelectCount == 0)
			{
				*pPropChord = *pChord;
				pPropChord->SetUndetermined(-1, 0);
			}
			else
			{
				pChord->CopyToPropChord(pPropChord, CPropChord::ALL);
			}
			dwSelectCount++;
		}
	}
	return dwSelectCount;
}

DWORD CChordList::RetrievePropChord( CPropChord *pPropChord )

{
	DWORD dwSelectCount = 0;	// How many are selected.
	CChordItem* pChord = GetHead();
	for (;pChord != NULL; pChord = pChord->GetNext())
	{
		if (pChord->IsSelected())
		{
			pChord->CopyFromPropChord(pPropChord, CPropChord::ALL);
			dwSelectCount++;
		}
	}
	return dwSelectCount;
}

void CChordList::InsertByAscendingTime(CChordItem* pChord)
{
	ASSERT(pChord);
	CChordItem* pItem = GetHead();
	while(pItem && *pItem < *pChord)
	{
		pItem = pItem->GetNext();
	}
	if(pItem)
	{
		InsertBefore(pItem, pChord);
	}
	else
	{
		AddTail(pChord);
	}
}

void CChordList::ClearSelections( )

{
	CChordItem* pChord = GetHead();
	for (;pChord != NULL; pChord = pChord->GetNext())
	{
		pChord->SetSelected(FALSE);
	}
}

void CChordList::ClearList()
{
	CChordItem* pChord;
	while( pChord = RemoveHead() )
	{
		delete pChord;
	}
}


HRESULT CChordList::Load( LPSTREAM pStream )
{
	HRESULT		hr = S_OK;
	DWORD		cb;
	DWORD		cSize;
    CChordItem*		pChord;
    ioOldChordSelection iChordSelection;
    WORD        wSizeChord;
	STATSTG		statstg;
	DWORD		dwIndex = 0;

	if( NULL == pStream )
	{
		return E_POINTER;
	}
	if( hr = FAILED( pStream->Stat( &statstg, STATFLAG_NONAME ) ))
	{
		return hr;
	}

	DMUSProdStreamInfo	StreamInfo;//Added ECW 4/24/98
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{//Changed ECW 4/24/98
		pPersistInfo->GetStreamInfo( &StreamInfo );
		if(pPersistInfo)
		{
			ftFileType = StreamInfo.ftFileType;
			guidDataFormat = StreamInfo.guidDataFormat;
			pPersistInfo->Release();
		}
	}


	if( IsEqualGUID( guidDataFormat, GUID_CurrentVersion ))
	{
		return	DMLoad(pStream);
	}

	ClearList();
	cSize = statstg.cbSize.LowPart;

//    cSize = pck->cksize;
//	*plstChord = NULL;
	// load size of chord structure
    hr = pStream->Read( &wSizeChord, sizeof( wSizeChord ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSizeChord ) )
	{
        hr = E_FAIL;
		goto ON_ERR;
	}
	cSize -= cb;
	while( cSize )
	{
        if( wSizeChord > sizeof( ioOldChordSelection ) )
        {
            hr = pStream->Read( &iChordSelection, sizeof( ioOldChordSelection ), &cb );
            if( FAILED( hr ) || cb != sizeof( ioOldChordSelection ) )
            {
				hr = E_FAIL;
				break;
            }
            StreamSeek( pStream, wSizeChord - sizeof( ioOldChordSelection ), STREAM_SEEK_CUR );
        }
        else
        {
            hr = pStream->Read( &iChordSelection, wSizeChord, &cb );
            if( FAILED( hr ) || cb != wSizeChord )
            {
				hr = E_FAIL;
				break;
            }
        }
        cSize -= wSizeChord;

        pChord = new CChordItem;

        if( pChord == NULL )
		{
            hr = E_OUTOFMEMORY;
            goto ON_ERR;
        }

		memset(pChord->Name(), 0, DMPolyChord::MAX_NAME);
        WideCharToMultiByte( CP_ACP, 0, iChordSelection.wstrName, -1, pChord->Name(),  DMPolyChord::MAX_NAME, NULL, NULL );
        if( iChordSelection.fCSFlags & CSF_FLAT )
        {
            pChord->Base()->UseFlat() = 1;
        }
		if( iChordSelection.fCSFlags & CSF_SELECTED)
		{
			pChord->SetSelected(TRUE);
		}
		else
		{
			pChord->SetSelected(FALSE);
		}
		if( iChordSelection.fCSFlags & CSF_SIGNPOST)
		{
			/*
			if(iChordSelection.fCSFlags & CSF_BEGSIGNPOST)
			{
				pChord->SetBegSignPost(true);
			}
			if(iChordSelection.fCSFlags & CSF_ENDSIGNPOST)
			{
				pChord->SetEndSignPost(true);
			}
			*/
			pChord->SetSignPost(true);	// not necessary unless no beg, end flags set
		}
		else
		{
			pChord->SetSignPost(false);
		}
		pChord->Beat() = iChordSelection.bBeat;
		pChord->Measure() = iChordSelection.wMeasure;
		pChord->Base()->ChordPattern() = iChordSelection.aChord[0].lChordPattern;
		pChord->Base()->ScalePattern() = iChordSelection.aChord[0].lScalePattern;
		pChord->Base()->InvertPattern() = iChordSelection.aChord[0].lInvertPattern;
		pChord->Base()->Flags() = iChordSelection.aChord[0].wCFlags;
		pChord->Base()->ChordRoot() = iChordSelection.aChord[0].bRoot;
		pChord->Base()->ScaleRoot() = pChord->Base()->ChordRoot();
        pChord->SetBits(pChord->RootIndex());
		pChord->m_dwIndex = dwIndex++;
		pChord->PropagateAll();	// legacy: set all subchords to base chord
		AddTail(pChord);
    }

ON_ERR:
    return hr;
}

// Save the chordlist to a normal stream
HRESULT CChordList::Save( LPSTREAM pStream, BOOL bClearDirty,  FileType ftFileType )
{
    HRESULT     hr;
    DWORD       cb;
    WORD        wSize;
    ioOldChordSelection iChordSelection;
    CChordItem*   pChord;
    int         i;
	
	DMUSProdStreamInfo	StreamInfo;//Added ECW 4/24/98
//	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{//Changed ECW 4/24/98
		pPersistInfo->GetStreamInfo( &StreamInfo );
		if(pPersistInfo)
		{
			ftFileType = StreamInfo.ftFileType;
			guidDataFormat = StreamInfo.guidDataFormat;
			pPersistInfo->Release();
		}
	}


	if( IsEqualGUID( guidDataFormat, GUID_CurrentVersion ))
	{
		return	DMSave(pStream, bClearDirty);
	}

    wSize = sizeof( ioOldChordSelection );
//	FixBytes( FBT_SHORT, &wSize );
    hr = pStream->Write( &wSize, sizeof( wSize ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSize ) )
    {
        return E_FAIL;
    }

	
    for( pChord = GetHead() ; pChord != NULL; pChord = pChord->GetNext() )
    {
        memset( &iChordSelection, 0, sizeof( ioOldChordSelection ) );
        MultiByteToWideChar( CP_ACP, 0, pChord->Name(), -1, iChordSelection.wstrName, sizeof( iChordSelection.wstrName ) / sizeof( wchar_t ) );
        if( pChord->Base()->UseFlat() != 0 )
        {
            iChordSelection.fCSFlags |= CSF_FLAT;
        }
		if( pChord->IsSelected())
		{
			iChordSelection.fCSFlags |= CSF_SELECTED;
		}
		if( pChord->IsSignPost())
		{
			iChordSelection.fCSFlags |= CSF_SIGNPOST;
			/*
			if(pChord->IsBegSignPost())
			{
				iChordSelection.fCSFlags |= CSF_BEGSIGNPOST;
			}
			if(pChord->IsEndSignPost())
			{
				iChordSelection.fCSFlags |= CSF_ENDSIGNPOST;
			}
			*/
		}
/* not available in CChordItem
        if( pChord->inscale != 0 )
        {
            iChordSelection.fCSFlags |= CSF_INSCALE;
        }
        if( pChord->keydown != 0 )
        {
            iChordSelection.fCSFlags |= CSF_KEYDOWN;
        }
        if( ( pChord->bits & CHORD_SIMPLE ) != 0 )
        {
            iChordSelection.fCSFlags |= CSF_SIMPLE;
        }
*/
        iChordSelection.bBeat = pChord->Beat();
        iChordSelection.wMeasure = pChord->Measure();
        for( i = 0 ; i < 4 ; ++i )
        {
            iChordSelection.aChord[i].lChordPattern = pChord->Base()->ChordPattern();
            iChordSelection.aChord[i].lScalePattern = pChord->Base()->ScalePattern();
/* not available in CChordItem
            iChordSelection.aChord[i].lInvertPattern = ~0;
*/
            iChordSelection.aChord[i].bRoot = pChord->Base()->ChordRoot();
        }
//		FixBytes( FBT_IOCHORDSELECTION, &iChordSelection );
        if( FAILED( pStream->Write( &iChordSelection, sizeof( iChordSelection), &cb ) ) ||
            cb != sizeof( iChordSelection ) )
        {
			hr = E_FAIL;
			break;
        }
    }
	return hr;
}

HRESULT CChordList::DMLoad(IStream* pStream)
{
	HRESULT		hr = S_OK;
	DWORD		cb;
	DWORD		cSize;
    CChordItem*		pChord;
    ioChordSelection iChordSelection;
    WORD        wSizeChord;
	STATSTG		statstg;
	DWORD		dwIndex = 0;

	if( NULL == pStream )
	{
		return E_POINTER;
	}
	if( hr = FAILED( pStream->Stat( &statstg, STATFLAG_NONAME ) ))
	{
		return hr;
	}

	ClearList();
	cSize = statstg.cbSize.LowPart;

//    cSize = pck->cksize;
//	*plstChord = NULL;
	// load size of chord structure
    hr = pStream->Read( &wSizeChord, sizeof( wSizeChord ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSizeChord ) )
	{
        hr = E_FAIL;
		goto ON_ERR;
	}
	cSize -= cb;
	while( cSize )
	{
        if( wSizeChord > sizeof( ioChordSelection ) )
        {
            hr = pStream->Read( &iChordSelection, sizeof( ioChordSelection ), &cb );
            if( FAILED( hr ) || cb != sizeof( ioChordSelection ) )
            {
				hr = E_FAIL;
				break;
            }
            StreamSeek( pStream, wSizeChord - sizeof( ioChordSelection ), STREAM_SEEK_CUR );
        }
        else
        {
            hr = pStream->Read( &iChordSelection, wSizeChord, &cb );
            if( FAILED( hr ) || cb != wSizeChord )
            {
				hr = E_FAIL;
				break;
            }
        }
        cSize -= wSizeChord;

        pChord = new CChordItem;

        if( pChord == NULL )
		{
            hr = E_OUTOFMEMORY;
            goto ON_ERR;
        }

        WideCharToMultiByte( CP_ACP, 0, iChordSelection.wstrName, -1, pChord->Name(), DMPolyChord::MAX_NAME , NULL, NULL );

		if( iChordSelection.bKeydown)
		{
			pChord->SetSelected(TRUE);
		}
		else
		{
			pChord->SetSelected(FALSE);
		}
		if( iChordSelection.fCSFlags & CSF_SIGNPOST)
		{
			pChord->SetSignPost(true);
			if(iChordSelection.fCSFlags & CSF_BEGSIGNPOST)
			{
				pChord->SetBegSignPost(true);
			}
			if(iChordSelection.fCSFlags & CSF_ENDSIGNPOST)
			{
				pChord->SetEndSignPost(true);
			}
		}
		else
		{
			pChord->SetSignPost(FALSE);
		}

		pChord->m_dwIndex = dwIndex++;
		pChord->Beat() = iChordSelection.bBeat;
		pChord->Measure() = iChordSelection.nMeasure;

		for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
		{
			DMChord* pDM = pChord->SubChord(i);
			pDM->ChordPattern() = iChordSelection.aChord[i].dwChordPattern;
			pDM->ScalePattern() = iChordSelection.aChord[i].dwScalePattern;
			pDM->InvertPattern() = iChordSelection.aChord[i].dwInvertPattern;
			pDM->ChordRoot() = iChordSelection.aChord[i].bChordRoot;
			pDM->ScaleRoot() = iChordSelection.aChord[i].bScaleRoot;
			pDM->Flags() = iChordSelection.aChord[i].wFlags;
			pDM->Levels() = iChordSelection.aChord[i].dwLevels;
			pDM->UseFlat() = iChordSelection.aChord[i].bFlat;
			pDM->InUse() = iChordSelection.aChord[i].bInUse;
			pDM->Bits() = iChordSelection.aChord[i].bBits;
		}
		
		AddTail(pChord);
    }

ON_ERR:
    return hr;
}

HRESULT CChordList::DMSave(IStream* pStream, BOOL bClearDirty)
{
	UNREFERENCED_PARAMETER(bClearDirty);
    HRESULT     hr;
    DWORD       cb;
    WORD        wSize;
    ioChordSelection iChordSelection;
    CChordItem*   pChord;
    int         i;

    wSize = sizeof( ioChordSelection );
//	FixBytes( FBT_SHORT, &wSize );
    hr = pStream->Write( &wSize, sizeof( wSize ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSize ) )
    {
        return E_FAIL;
    }

	
    for( pChord = GetHead() ; pChord != NULL; pChord = pChord->GetNext() )
    {
        memset( &iChordSelection, 0, sizeof( iChordSelection ) );
        MultiByteToWideChar( CP_ACP, 0, pChord->Name(), -1, iChordSelection.wstrName, sizeof( iChordSelection.wstrName ) / sizeof( wchar_t ) );
        if( pChord->Base()->UseFlat() != 0 )
        {
            iChordSelection.fCSFlags |= CSF_FLAT;
        }
		if( pChord->IsSelected())
		{
			iChordSelection.bKeydown = TRUE;
		}
		else
		{
			iChordSelection.bKeydown = FALSE;
		}
		if( pChord->IsSignPost())
		{
			iChordSelection.fCSFlags |= CSF_SIGNPOST;
			if(pChord->IsBegSignPost())
			{
				iChordSelection.fCSFlags |= CSF_BEGSIGNPOST;
			}
			if(pChord->IsEndSignPost())
			{
				iChordSelection.fCSFlags |= CSF_ENDSIGNPOST;
			}
		}
        iChordSelection.bBeat = pChord->Beat();
        iChordSelection.nMeasure = pChord->Measure();
        for( i = 0 ; i < DMPolyChord::MAX_POLY ; ++i )
        {
			DMChord* pDM = pChord->SubChord(i);
            iChordSelection.aChord[i].dwChordPattern = pDM->ChordPattern();
            iChordSelection.aChord[i].dwScalePattern = pDM->ScalePattern();
			iChordSelection.aChord[i].dwInvertPattern = pDM->InvertPattern();
            iChordSelection.aChord[i].bChordRoot = pDM->ChordRoot();
			iChordSelection.aChord[i].bScaleRoot = pDM->ScaleRoot();
			iChordSelection.aChord[i].dwLevels = pDM->Levels();
			iChordSelection.aChord[i].bFlat = pDM->UseFlat();
			iChordSelection.aChord[i].bInUse = pDM->InUse();
			iChordSelection.aChord[i].wFlags = pDM->Flags();
			iChordSelection.aChord[i].bBits = pDM->Bits();
        }
//		FixBytes( FBT_IOCHORDSELECTION, &iChordSelection );
        if( FAILED( pStream->Write( &iChordSelection, sizeof( iChordSelection), &cb ) ) ||
            cb != sizeof( iChordSelection ) )
        {
			hr = E_FAIL;
			break;
        }
    }
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ChordDatabase.cpp ===
#include "stdafx.h"
#include <afxtempl.h>
#pragma warning(disable:4201)
#include "chordmapstripmgr.h"
#pragma warning(default:4201)
#include "DMUSProd.h"
#include "StyleDesigner.h"
//#include "Personality.h"
#include "..\shared\RiffStrm.h"	
#include "ChordDatabase.h"
#include "resource.h"


/////////////////////////////////////////////// SignPostChunk members
//
SignPostChunk::SignPostChunk(const SignPost* pSignPost)
{
	dwFlags = pSignPost->m_dwflags;
	dwChords = pSignPost->m_chords;
}

HRESULT SignPostChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	IStream* pIStream;
	HRESULT hr;
	DWORD dwBytesWritten;
	// Write SignPost chunk header
	WriteChunk chunk(pRiffStream, FOURCC_IOSIGNPOST);
	hr = chunk.State();
	if(  hr  == 0 )
	{
		pIStream = pRiffStream->GetStream();
		ASSERT( pIStream != NULL );

		// Write Signpost chunk data
		hr = pIStream->Write( this, sizeof(SignPostChunk), &dwBytesWritten) == 0
			&& dwBytesWritten == sizeof(ioSignPost) ? S_OK : E_FAIL;
	    pIStream->Release();
	}
    return hr;
}

HRESULT SignPostChunk::Read(IDMUSProdRIFFStream* pIRiffStream)
{
	ASSERT(pIRiffStream);
	HRESULT hr;
	DWORD dwBytesRead;
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream != NULL);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}
	hr = pIStream->Read(this, sizeof(SignPostChunk), &dwBytesRead) == 0
		&& dwBytesRead == sizeof(ioSignPost) ? S_OK : E_FAIL;
	pIStream->Release();
	return hr;
}

HRESULT SignPostChunk::Extract(const SignPost* pSignPost)
{
	ASSERT(pSignPost);
	if(!pSignPost)
		return E_INVALIDARG;

	dwFlags = pSignPost->m_dwflags;
	dwChords = pSignPost->m_chords;

	return S_OK;
}

HRESULT  SignPostChunk::Insert(SignPost* pSignPost)
{
	ASSERT(pSignPost);
	if(!pSignPost)
		return E_INVALIDARG;

	pSignPost->m_dwflags = dwFlags;
	pSignPost->m_chords = dwChords;

	return S_OK;
}

//////////////////////////////////////////// NextChordChunk members
//
NextChordChunk::NextChordChunk(const NextChord* pNext)
{
	dwFlags = pNext->m_dwflags;
	nWeight = pNext->m_nweight;
	wMinBeats = pNext->m_nminbeats;
	wMaxBeats = pNext->m_nmaxbeats;
	wConnectionID = pNext->m_nid;
}

HRESULT NextChordChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	IStream* pIStream;
	HRESULT hr = S_OK;
	DWORD dwBytesWritten;
	
	ASSERT(pRiffStream);

// Deliberitely commented out
//	WriteChunk chunk(pRiffStream, FOURCC_IONEXTCHORD);
//	hr = chunk.State();
	if( hr == S_OK )
	{

	    pIStream = pRiffStream->GetStream();
		ASSERT( pIStream != NULL );

		// Write NextChord chunk data
		hr = pIStream->Write( this, sizeof(NextChordChunk), &dwBytesWritten) == 0
			&& dwBytesWritten == sizeof(ioNextChord) ? S_OK : E_FAIL;

	    pIStream->Release();
	}

    return hr;
}

HRESULT NextChordChunk::Read(IDMUSProdRIFFStream* pIRiffStream)
{
	IStream* pIStream;
	HRESULT hr;
	DWORD dwBytesRead;
	
	ASSERT(pIRiffStream);

	pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream != NULL);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}

	hr = pIStream->Read(this, sizeof(NextChordChunk), &dwBytesRead) == 0
		&& dwBytesRead == sizeof(ioNextChord) ? S_OK : E_FAIL;
	pIStream->Release();
	return hr;
}

HRESULT NextChordChunk::Extract(const NextChord* pNext)
{
	dwFlags = pNext->m_dwflags;
	nWeight = pNext->m_nweight;
	wMinBeats = pNext->m_nminbeats;
	wMaxBeats = pNext->m_nmaxbeats;
	wConnectionID = pNext->m_nid;
	return S_OK;
}

HRESULT NextChordChunk::Insert( NextChord* pNext)
{
	pNext->m_dwflags = dwFlags;
	pNext->m_nweight = nWeight;
	pNext->m_nminbeats = wMinBeats;
	pNext->m_nmaxbeats = wMaxBeats;
	pNext->m_nid = wConnectionID;
	return S_OK;
}

//////////////////////////////////////////////// ChordEntryChunk members
//
ChordEntryChunk::ChordEntryChunk(const ChordEntry* pChord)
{
	dwFlags = pChord->m_dwflags;
	wConnectionID = pChord->m_nid;
}

HRESULT ChordEntryChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	IStream* pIStream;
	HRESULT hr;
	DWORD dwBytesWritten;

	ASSERT(pRiffStream);

	WriteChunk chunk(pRiffStream, FOURCC_CHORDENTRY);
	hr = chunk.State();

	if(hr == 0)
	{
		pIStream = pRiffStream->GetStream();
		ASSERT( pIStream != NULL );
		// Write ChordEntry chunk data
		hr = pIStream->Write( this, sizeof(ChordEntryChunk), &dwBytesWritten)
				&&  dwBytesWritten == sizeof(ioChordEntry);
		pIStream->Release();
	}

    return hr;
}

HRESULT ChordEntryChunk::Read(IDMUSProdRIFFStream* pIRiffStream)
{
	IStream* pIStream;
	HRESULT hr;
	DWORD dwBytesRead;

	ASSERT(pIRiffStream);
	pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );
	hr = (pIStream->Read( this, sizeof(ChordEntryChunk), &dwBytesRead) == 0
		&&  dwBytesRead == sizeof(ioChordEntry)) ? S_OK : E_FAIL;
	pIStream->Release();

    return hr;
}

HRESULT ChordEntryChunk::Extract(const ChordEntry* pChord)
{
	dwFlags = pChord->m_dwflags;
	wConnectionID = pChord->m_nid;
	return S_OK;
}

HRESULT ChordEntryChunk::Insert( ChordEntry* pChord)
{
	pChord->m_dwflags = dwFlags;
	pChord->m_nid = wConnectionID;
	return S_OK;
}

///////////////////////////////////////////////// ChordEntryEdit helpers
//
HRESULT WriteChordEntryEditChunk(IDMUSProdRIFFStream* pRiffStream, ChordEntryList* plist)
{
	ASSERT(pRiffStream);
	ASSERT(plist);
	if(pRiffStream == NULL || plist == NULL)
	{
		return E_INVALIDARG;
	}
	if(plist->GetHead() == NULL)
	{
		// nothing to do
		return S_OK;
	}
	IStream* pStream = pRiffStream->GetStream();
	ASSERT(pStream);
	if(pStream == NULL)
	{
		return E_FAIL;
	}

	WriteChunk chunk(pRiffStream, FOURCC_CHORDENTRYEDIT);
	HRESULT hr = chunk.State();
	if(hr == S_OK)
	{
		DWORD size = sizeof(ChordEntryEditChunk);
		hr = pStream->Write(&size, sizeof(DWORD), 0);
		ChordEntry* pChord = plist->GetHead();
		while(pChord != NULL && hr == S_OK)
		{
			ChordEntryEditChunk chunk(pChord);
			chunk.Write(pRiffStream);
			pChord = pChord->GetNext();
		}
	}
	pStream->Release();
	return hr;
}

HRESULT ReadChordEntryEditChunk(IDMUSProdRIFFStream* pRiffStream, ChordEntryList* plist, MMCKINFO* pckInfo)
{
	ASSERT(pRiffStream);
	ASSERT(pckInfo);
	ASSERT(plist);
	if(pRiffStream == NULL || pckInfo == NULL || plist == NULL)
	{
		return E_INVALIDARG;
	}
	IStream* pStream = pRiffStream->GetStream();
	ASSERT(pStream);
	if(pStream == NULL)
	{
		return E_FAIL;
	}
	
	CMap<short,short, ChordEntryEditChunk, ChordEntryEditChunk&> chunkmap;
	DWORD size, cbSize;
	HRESULT hr = pStream->Read(&size, sizeof(DWORD), &cbSize);
	ASSERT(size == sizeof(ChordEntryEditChunk));
	DWORD count = (pckInfo->cksize - sizeof(DWORD)) / size;
	if(hr == S_OK && size == sizeof(ChordEntryEditChunk))
	{
		// read in edit chunks
		for(DWORD i = 0; hr == S_OK && i < count; i++)
		{
			ChordEntryEditChunk chunk;
			hr = chunk.Read(pRiffStream);
			chunkmap.SetAt(chunk.wConnectionId, chunk);
		}
	}
	ASSERT(hr == S_OK);
	if(hr == S_OK)
	{
		// assign positional coords to chordentries
		for(ChordEntry* pChord = plist->GetHead(); pChord; pChord = pChord->GetNext())
		{
			ChordEntryEditChunk chunk;
			if(chunkmap.Lookup(pChord->m_nid, chunk))
			{
				chunk.Insert(pChord);
			}
			else
			{
				hr = E_FAIL;
				break;
			}
		}
	}
	pStream->Release();
	return hr;
}

//////////////////////////////////////////////// ChordEntryEditChunk members
//
ChordEntryEditChunk::ChordEntryEditChunk(const ChordEntry* pChord)
{
	ChordSelection* psel = &(const_cast<ChordEntry*>(pChord)->m_chordsel);

	for(int i = 0; i < MaxSubChords; i++)
	{
		bBits[i] = psel->SubChord(i)->Bits();
		bUseFlat[i] = psel->SubChord(i)->UseFlat();
	}
	wMeasure = psel->Measure();
	bBeat = psel->Beat();
	wConnectionId = pChord->m_nid;
	left = pChord->m_rect.left;
	top = pChord->m_rect.top;
	right = pChord->m_rect.right;
	bottom = pChord->m_rect.bottom;
	page = pChord->m_page;
	if(psel->KeyDown())
	{
		page |= CHORD_KEYDOWN;
	}
	else
	{
		page &= ~CHORD_KEYDOWN;
	}
}

HRESULT ChordEntryEditChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	IStream* pIStream;
	HRESULT hr = S_OK;
	DWORD dwBytesWritten;

	ASSERT(pRiffStream);

// deliberately commented out
//	WriteChunk chunk(pRiffStream, FOURCC_CHORDENTRYEDIT);
//	hr = chunk.State();

	if(hr == 0)
	{
		pIStream = pRiffStream->GetStream();
		ASSERT( pIStream != NULL );
		// Write ChordEntryEdit chunk data
		hr = pIStream->Write( this, sizeof(ChordEntryEditChunk), &dwBytesWritten)
				&&  dwBytesWritten == sizeof(ioChordEntryEdit);
		pIStream->Release();
	}

    return hr;
}

HRESULT ChordEntryEditChunk::Read(IDMUSProdRIFFStream* pIRiffStream)
{
	IStream* pIStream;
	HRESULT hr;
	DWORD dwBytesRead;

	ASSERT(pIRiffStream);
	pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );
	hr = (pIStream->Read( this, sizeof(ChordEntryEditChunk), &dwBytesRead) == 0
		&&  dwBytesRead == sizeof(ioChordEntryEdit)) ? S_OK : E_FAIL;
	pIStream->Release();

    return hr;
}

HRESULT ChordEntryEditChunk::Extract(const ChordEntry* pChord)
{
	ChordSelection* psel = &(const_cast<ChordEntry*>(pChord)->m_chordsel);

	for(int i = 0; i < MaxSubChords; i++)
	{
		bBits[i] = psel->SubChord(i)->Bits();
		bUseFlat[i] = psel->SubChord(i)->UseFlat();
	}
	wMeasure = psel->Measure();
	bBeat = psel->Beat();
	wConnectionId = pChord->m_nid;
	left = pChord->m_rect.left;
	top = pChord->m_rect.top;
	right = pChord->m_rect.right;
	bottom = pChord->m_rect.bottom;
	page = pChord->m_page;
	if(psel->KeyDown())
	{
		page |= CHORD_KEYDOWN;
	}
	else
	{
		page &= ~CHORD_KEYDOWN;
	}
	return S_OK;
}

HRESULT ChordEntryEditChunk::Insert( ChordEntry* pChord)
{
	ChordSelection* psel = &((pChord)->m_chordsel);
	if(page & CHORD_KEYDOWN)
	{
		psel->KeyDown() = true;
		page &= ~ CHORD_KEYDOWN;
	}
	for(int i = 0; i < MaxSubChords; i++)
	{
		psel->SubChord(i)->Bits() = bBits[i];
		psel->SubChord(i)->UseFlat() = bUseFlat[i];
	}
	pChord->m_chordsel.Measure() = wMeasure;
	pChord->m_chordsel.Beat() = bBeat;
	pChord->m_nid = wConnectionId;
	pChord->m_rect.left = left;
	pChord->m_rect.top = top;
	pChord->m_rect.right = right;
	pChord->m_rect.bottom = bottom;
	pChord->m_page = page;
	return S_OK;
}

////////////////////////////////////////////// ChordListChunk members
//
ChordListChunk::ChordListChunk(DMPolyChord& Chord, DMSubChordSet& chordset, bool bIncludeEditInfo)
{
	memset(name, 0, sizeof(name));
	m_bIncludeEditInfo = bIncludeEditInfo;
	if(m_bIncludeEditInfo)
	{
		m_chordedit.Extract(Chord);
	}
	chordset.Add(Chord, *this);
#ifdef _UNICODE
	// use straight wstrcpy
	_wstrncpy(name, Chord.Name(), 12);
#else
	// use conversion
    MultiByteToWideChar( CP_ACP, 0, Chord.Name(), -1, name, sizeof( name) / sizeof( wchar_t ) );
#endif
}

HRESULT ChordListChunk::Write(IDMUSProdRIFFStream* pIRiffStream)
{
	IStream* pIStream;
	HRESULT hr;
	DWORD dwBytesWritten;

	// Write ChordList chunk header
	WriteListChunk	list(pIRiffStream, FOURCC_LISTCHORD);
	hr = list.State();

	if(hr == 0)
	{
	    pIStream = pIRiffStream->GetStream();
		ASSERT( pIStream != NULL );
		hr = (pIStream != 0) ? S_OK : E_FAIL;

		if(hr == 0)
		{
			WriteChunk* pchunk = new WriteChunk(pIRiffStream, FOURCC_CHORDNAME);
			hr = pchunk->State();
			if(hr == 0)
			{
				hr = pIStream->Write(name, sizeof(name), &dwBytesWritten) == 0 
					&& dwBytesWritten == sizeof(name) ? S_OK : E_FAIL;
			}
			delete pchunk;
		}

		if(hr == 0)
		{
			WriteChunk* pchunk = new WriteChunk(pIRiffStream, FOURCC_SUBCHORDID);
			hr = pchunk->State();
			hr = pIStream->Write( subchordids, sizeof(subchordids), &dwBytesWritten) == 0
				&&  dwBytesWritten == sizeof(subchordids) ? S_OK : E_FAIL;
			delete pchunk;
		}

		if(hr == 0)
		{
			WriteChunk* pchunk = new WriteChunk(pIRiffStream, FOURCC_CHORDEDIT);
			hr = pchunk->State();
			if(hr == 0)
			{
				hr = pIStream->Write(&m_chordedit, sizeof (m_chordedit), &dwBytesWritten);
				hr = (hr == S_OK) && (dwBytesWritten == sizeof(m_chordedit)) ? S_OK : E_FAIL;
			}
			delete pchunk;
		}

	    pIStream->Release();
	}

    return hr;
}

HRESULT ChordListChunk::Read(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent)
{
	HRESULT hr1=S_OK, hr2=S_OK;
	HRESULT hr3 = S_OK;
	ASSERT(pIRiffStream && pckParent);
	MMCKINFO ck;
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(!pIStream)
		return E_FAIL;

	while(pIRiffStream->Descend(&ck, pckParent, 0) == 0)
	{
		switch(ck.ckid)
		{
		case FOURCC_CHORDNAME:
			hr1 = pIStream->Read(name, sizeof(name), 0);
			break;
		case FOURCC_SUBCHORDID:
			hr2 = pIStream->Read(subchordids, sizeof(subchordids), 0);
			break;
		case FOURCC_CHORDEDIT:
			hr3 = pIStream->Read(&m_chordedit, sizeof(m_chordedit), 0);
			m_bIncludeEditInfo = true;
			break;
		}
		pIRiffStream->Ascend(&ck, 0);
	}
	pIStream->Release();
	return (hr1 == S_OK && hr2 == S_OK) ? S_OK : E_FAIL;
}

HRESULT ChordListChunk::Extract( DMPolyChord& Chord, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	m_bIncludeEditInfo = bIncludeEditInfo;
	if(m_bIncludeEditInfo)
	{
		m_chordedit.Extract(Chord);
	}
	m_bIncludeEditInfo = bIncludeEditInfo;
	subchords.Add(Chord, *this);
#ifdef _UNICODE
	// use straight wstrcpy
	_wstrncpy(name, Chord.Name(), NameSize);
#else
	// use conversion
    MultiByteToWideChar( CP_ACP, 0, Chord.Name(), -1, name, sizeof( name) / sizeof( wchar_t ) );
#endif
	return S_OK;
}

HRESULT ChordListChunk::Insert( DMPolyChord& Chord,  const DMSubChordSet& subchords)
{
	memset(Chord.Name(), 0, NameSize);
#ifdef _UNICODE
	// use straight wstrcpy
	_wstrcpy(Chord.Name(), name);
#else
	// use conversion
	WideCharToMultiByte( CP_ACP, 0, name, -1, Chord.Name(), NameSize, NULL, NULL );
#endif
	if(m_bIncludeEditInfo)
	{
		m_chordedit.Insert(Chord);
	}
	return const_cast<DMSubChordSet&>(subchords).Retrieve(Chord, *this);
}

//////////////////////////////////////////////////////////////////// ChordEntryListItem members
//

ChordEntryListItem::ChordEntryListItem(ChordEntry* pChord, DMSubChordSet& subchords, bool bIncludeEditInfo)
: m_bIncludeEditInfo(bIncludeEditInfo)
{
	ASSERT(pChord);
	m_chordentry.Extract(pChord);
	m_chordlist.Extract(pChord->m_chordsel, subchords, m_bIncludeEditInfo);
	for(NextChord* pNext = pChord->m_nextchordlist.GetHead(); pNext; pNext = pNext->GetNext())
	{
		NextChordChunk nextchunk(pNext);
		m_nextchordlist.AddTail(nextchunk);
	}
}

HRESULT ChordEntryListItem::Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	WriteListChunk list(pRiffStream, FOURCC_LISTCHORDENTRY);
	HRESULT hr = list.State();
	if(hr == 0)
	{
		hr = m_chordentry.Write(pRiffStream) == 0
			&& m_chordlist.Write(pRiffStream) == 0 ? S_OK : E_FAIL;
		if(hr == 0)
		{
			WriteChunk chunk(pRiffStream, FOURCC_NEXTCHORDSEQ);
			hr = chunk.State();
			WORD cbioNextChord = sizeof(ioNextChord);
			WriteWord(pRiffStream, cbioNextChord);
			POSITION pos = m_nextchordlist.GetHeadPosition();
			while(pos && hr == 0)
			{
				NextChordChunk nextchunk;
				nextchunk = m_nextchordlist.GetNext(pos);
				hr = nextchunk.Write(pRiffStream);
			}
		}

	}
	return hr;
}

HRESULT ChordEntryListItem::Read(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckParent)
{
	ASSERT(pIRiffStream);
	HRESULT hr1=S_OK,hr2=S_OK,hr3=S_OK;
	ASSERT(pIRiffStream && pckParent);
	MMCKINFO ck;

	m_nextchordlist.RemoveAll();

	while(pIRiffStream->Descend(&ck, pckParent, 0)==0)
	{
		switch(ck.ckid)
		{
		case FOURCC_CHORDENTRY:
			hr1 = m_chordentry.Read(pIRiffStream);
			break;
		case FOURCC_LIST:
			switch(ck.fccType)
			{
			case FOURCC_LISTCHORD:
				hr2 = m_chordlist.Read(pIRiffStream, &ck);
				break;
			}
			break;
			case FOURCC_NEXTCHORDSEQ:
				{
					WORD count;
					if(ReadWord(pIRiffStream, count) == 0)
					{
						count = static_cast<short>((ck.cksize-sizeof(WORD)) / count);
						hr3 = hr2;
						for(WORD i = 0; i < count && hr3 == S_OK; i++)
						{
							NextChordChunk nextchunk;
							hr3 = nextchunk.Read(pIRiffStream);
							m_nextchordlist.AddTail(nextchunk);
						}
					}
				}
				break;
		}
		pIRiffStream->Ascend(&ck, 0);
	}
	return (hr1 || hr2 || hr3) == 0 ? S_OK : E_FAIL;
}

HRESULT	ChordEntryListItem::Extract(ChordEntry* pChord, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	ASSERT(pChord);
	m_bIncludeEditInfo = bIncludeEditInfo;
	HRESULT hr = m_chordentry.Extract(pChord)
					|| m_chordlist.Extract(pChord->m_chordsel, subchords, m_bIncludeEditInfo);
	if(hr == 0)
	{
		for(NextChord* pNext = pChord->m_nextchordlist.GetHead(); pNext; pNext = pNext->GetNext())
		{
			NextChordChunk nextchunk;
			hr |= nextchunk.Extract(pNext);
			m_nextchordlist.AddTail(nextchunk);
		}
	}
	return hr;
}

HRESULT ChordEntryListItem::Insert( ChordEntry* pChord, const DMSubChordSet& subchords)
{
	ASSERT(pChord);
	HRESULT hr = m_chordentry.Insert(pChord)
					|| m_chordlist.Insert(pChord->m_chordsel, subchords);

	if(hr == 0)
	{
		POSITION pos = m_nextchordlist.GetHeadPosition();
		while(pos)
		{
			NextChordChunk nextchunk;
			nextchunk = m_nextchordlist.GetNext(pos);
			NextChord* pNext = new NextChord;
			nextchunk.Insert(pNext);
			pNext->m_parent = pChord;
			pChord->m_nextchordlist.AddTail(pNext);
		}			
	}
	
	return hr;
}


//////////////////////////////////////////////////////////////////// CadenceListChunk members
//
CadenceListChunk::CadenceListChunk(SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo)
: m_bIncludeEditInfo(bIncludeEditInfo)
{
	m_bHasCadenceChord1 = (pSignPost->m_dwflags & SPOST_CADENCE1);
	m_bHasCadenceChord2 = (pSignPost->m_dwflags & SPOST_CADENCE2);

	if(m_bHasCadenceChord1)
	{
		m_CadenceChord1.Extract(pSignPost->m_cadence[0],  subchords, m_bIncludeEditInfo);
	}

	if(m_bHasCadenceChord2)
	{
		m_CadenceChord1.Extract(pSignPost->m_cadence[1],  subchords, m_bIncludeEditInfo);
	}
}



HRESULT CadenceListChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	HRESULT hr = S_OK;

	// Write ChordList chunk header
	if(m_bHasCadenceChord1 || m_bHasCadenceChord2)
	{
		WriteListChunk	list(pRiffStream, FOURCC_LISTCADENCE);
		hr = list.State();

		if(hr == 0)
		{
			// Write Cadence1 chordlist chunk data
			if(m_bHasCadenceChord1)
			{
				hr = m_CadenceChord1.Write(pRiffStream);
			}


			// Write Cadence2 chordlist chunk data
			if(hr == 0 && m_bHasCadenceChord2)
			{
				hr = m_CadenceChord2.Write(pRiffStream);
			}
		}
	}
    return hr;
}

HRESULT CadenceListChunk::Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
// for this to work properly, user must first read in signpost chunk to get which cadence chords,
// otherwise first chord read goes to cadence chord 1 etc.
{
	ASSERT(pRiffStream && pckParent);
	MMCKINFO ck;
	HRESULT hr = S_OK;
	int nextToRead  = 1;
	if(m_bHasCadenceChord2 && !m_bHasCadenceChord1)
	{
		nextToRead = 2;
	}

	while(pRiffStream->Descend(&ck, pckParent, 0) == 0 && hr == S_OK)
	{
		switch(nextToRead)
		{
		case 1:
			hr = m_CadenceChord1.Read(pRiffStream, &ck);
			nextToRead = 2;
			break;
		case 2:
			hr = m_CadenceChord2.Read(pRiffStream, &ck);
			nextToRead = 1;
			break;
		}
		pRiffStream->Ascend(&ck, 0);
	}
	return hr;
}

HRESULT CadenceListChunk::Extract( SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	m_bIncludeEditInfo = bIncludeEditInfo;
	m_bHasCadenceChord1 = (pSignPost->m_dwflags & SPOST_CADENCE1);
	m_bHasCadenceChord2 = (pSignPost->m_dwflags & SPOST_CADENCE2);

	if(m_bHasCadenceChord1)
	{
		m_CadenceChord1.Extract(pSignPost->m_cadence[0],  subchords, m_bIncludeEditInfo);
	}

	if(m_bHasCadenceChord2)
	{
		m_CadenceChord2.Extract(pSignPost->m_cadence[1],  subchords, m_bIncludeEditInfo);
	}
	return S_OK;
}

HRESULT CadenceListChunk::Insert( SignPost* pSignPost, const DMSubChordSet& subchords)
// pSignpost should have been filled in from SignPostChunk before calling this function
{
	ASSERT(pSignPost);
	m_bHasCadenceChord1 = (pSignPost->m_dwflags & SPOST_CADENCE1);
	m_bHasCadenceChord2 = (pSignPost->m_dwflags & SPOST_CADENCE2);

	if(m_bHasCadenceChord1)
	{
		m_CadenceChord1.Insert(pSignPost->m_cadence[0],  subchords);
	}

	if(m_bHasCadenceChord2)
	{
		m_CadenceChord2.Insert(pSignPost->m_cadence[1],  subchords);
	}
	return S_OK;
}

////////////////////////////////////////////////////////// SignPostListItemChunk members
//
SignPostListItemChunk::SignPostListItemChunk(SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo)
: m_bIncludeEditInfo(bIncludeEditInfo)
{
	m_signpost.Extract(pSignPost);
	m_signpostchord.Extract(pSignPost->m_chord, subchords, m_bIncludeEditInfo);
	m_cadencelist.Extract(pSignPost, subchords, m_bIncludeEditInfo);
};

HRESULT SignPostListItemChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	HRESULT hr;

	ASSERT(pRiffStream);
	if(pRiffStream == 0)
	{
		return E_INVALIDARG;
	}

	WriteListChunk list(pRiffStream, FOURCC_LISTSIGNPOSTITEM);
	hr = list.State();

	if(hr == S_OK)
	{
		hr =  m_signpost.Write(pRiffStream)
				||m_signpostchord.Write(pRiffStream)
				|| m_cadencelist.Write(pRiffStream);
	}

	return hr;
}

HRESULT SignPostListItemChunk::Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
	{
		return E_INVALIDARG;
	}

	MMCKINFO ck;
	HRESULT hr = S_OK;
	while(pRiffStream->Descend(&ck, pckParent, 0) == 0 && hr == S_OK)
	{
		switch(ck.ckid)
		{
		case FOURCC_IOSIGNPOST:
			hr = m_signpost.Read(pRiffStream);
			break;
		case FOURCC_LIST:
			switch(ck.fccType)
			{
			case FOURCC_LISTCHORD:
				hr = m_signpostchord.Read(pRiffStream, &ck);
				break;
			case FOURCC_LISTCADENCE:
				hr = m_cadencelist.Read(pRiffStream, &ck);
			break;
			}
		}
		pRiffStream->Ascend(&ck, 0);
	}

	return hr;
}

HRESULT SignPostListItemChunk::Extract(SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	m_bIncludeEditInfo = bIncludeEditInfo;
	HRESULT hr;
	ASSERT(pSignPost);
	if(pSignPost == 0)
	{
		return E_INVALIDARG;
	}

	hr =  m_signpost.Extract(pSignPost)
			|| m_signpostchord.Extract(pSignPost->m_chord, subchords, m_bIncludeEditInfo)
			|| m_cadencelist.Extract(pSignPost, subchords, m_bIncludeEditInfo);

	return hr;
}

HRESULT SignPostListItemChunk::Insert( SignPost* pSignPost, const DMSubChordSet& subchords)
{
	HRESULT hr;
	ASSERT(pSignPost);
	if(pSignPost == 0)
	{
		return E_INVALIDARG;
	}

	hr =	m_signpost.Insert(pSignPost)
			|| m_signpostchord.Insert(pSignPost->m_chord, subchords)
			|| m_cadencelist.Insert(pSignPost, subchords);

	return hr;
}


///////////////////////////////////////////////////////// SignPostListChunk members
//
SignPostListChunk::SignPostListChunk(SignPostList& signpostlist, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	m_bIncludeEditInfo = bIncludeEditInfo;
	for(SignPost* pSignPost = signpostlist.GetHead(); pSignPost; pSignPost = pSignPost->GetNext())
	{
		SignPostListItemChunk* pItem = new SignPostListItemChunk(pSignPost, subchords, m_bIncludeEditInfo);
		AddTail(pItem);
	}
}

SignPostListChunk::~SignPostListChunk()
{
	while(!IsEmpty())
	{
		SignPostListItemChunk* pItem = RemoveHead();
		delete pItem;
	}
}

HRESULT	SignPostListChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	HRESULT hr = S_OK;
	POSITION pos = GetHeadPosition();
	if(pos != NULL)
	{
		WriteListChunk	list(pRiffStream, FOURCC_SIGNPOSTLIST);
		hr = list.State();
		while(pos != NULL && hr==S_OK)
		{
			SignPostListItemChunk* pItem = GetNext(pos);
			hr = pItem->Write(pRiffStream);
		}
	}
	return hr;
}

HRESULT SignPostListChunk::Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
	{
		return E_INVALIDARG;
	}

	MMCKINFO ck;
	HRESULT hr = S_OK;
	while(pRiffStream->Descend(&ck, pckParent, 0) == 0 && hr == S_OK)
	{
		switch(ck.ckid)
		{
		case FOURCC_LIST:
			switch(ck.fccType)
			{
			case FOURCC_LISTSIGNPOSTITEM:
				{
					SignPostListItemChunk* pchunk = new SignPostListItemChunk;
					hr = pchunk->Read(pRiffStream, &ck);
					if(hr == S_OK)
					{
						AddTail(pchunk);
					}
					break;
				}
			break;
			}
		}
		pRiffStream->Ascend(&ck, 0);
	}

	return hr;
}

HRESULT SignPostListChunk::Extract(SignPostList& signpostlist, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	m_bIncludeEditInfo = bIncludeEditInfo;
	for(SignPost* pSignPost = signpostlist.GetHead(); pSignPost; pSignPost = pSignPost->GetNext())
	{
		SignPostListItemChunk* pItem = new SignPostListItemChunk(pSignPost, subchords, m_bIncludeEditInfo);
		AddTail(pItem);
	}
	return S_OK;
}

HRESULT SignPostListChunk::Insert(SignPostList& signpostlist, const DMSubChordSet& subchords)
{
	HRESULT hr = S_OK;
	POSITION pos = GetHeadPosition();
	while(pos != NULL && hr==S_OK)
	{
		SignPostListItemChunk* pItem = GetNext(pos);
		SignPost* pSignPost = new SignPost;
		if(pSignPost)
		{
			hr = pItem->Insert(pSignPost, subchords);
			signpostlist.AddTail(pSignPost);
		}
		else
		{
			hr = E_FAIL;
		}
	}
	return hr;
}

//////////////////////////////////////////////////////// ChordPaletteList members
//
ChordPaletteList::ChordPaletteList(ChordPalette& chordpalette, DMSubChordSet& subchords)
{
	for(int i = 0; i < 24; i++)
	{
		m_chordlist[i].Extract(chordpalette.m_chords[i], subchords, false);
	}
}

HRESULT ChordPaletteList::Write(IDMUSProdRIFFStream* pRiffStream)
{
	HRESULT hr;

	ASSERT(pRiffStream);
	if(pRiffStream == 0)
	{
		return E_INVALIDARG;
	}

	WriteListChunk list(pRiffStream, FOURCC_LISTCHORDPALETTE);
	hr = list.State();

	for(int i = 0; i < 24 && hr == S_OK; i++)
	{
		hr = m_chordlist[i].Write(pRiffStream);
	}
	return hr;
}

HRESULT ChordPaletteList::Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO*pckParent)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
	{
		return E_INVALIDARG;
	}

	MMCKINFO ck;
	HRESULT hr = S_OK;
	WORD count=0;
	while(pRiffStream->Descend(&ck, pckParent, 0) == 0 && hr == S_OK)
	{
		switch(ck.ckid)
		{
		case FOURCC_LIST:
			switch(ck.fccType)
			{
			case FOURCC_LISTCHORD:
				{
					hr = m_chordlist[count++].Read(pRiffStream, &ck);
					break;
				}
			break;
			}
		}
		pRiffStream->Ascend(&ck, 0);
	}
	ASSERT(count == 24);
	return hr;
}

HRESULT ChordPaletteList::Extract(ChordPalette& chordpalette, DMSubChordSet& subchords)
{
	HRESULT hr = S_OK;
	for(int i = 0; i < 24 && hr == S_OK; i++)
	{
		hr = m_chordlist[i].Extract(chordpalette.m_chords[i], subchords, false);
	}

	return hr;
}

HRESULT ChordPaletteList::Insert(ChordPalette& chordpalette,  const DMSubChordSet& subchords)
{
	HRESULT hr = S_OK;
	for(int i = 0; i < 24 && hr == S_OK; i++)
	{
		hr = m_chordlist[i].Insert(chordpalette.m_chords[i], subchords);
	}

	return hr;
}

//////////////////////////////////////////////////////// DMChordMapList 
//
ChordMapList::ChordMapList(ChordEntryList& chordlist, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	m_bIncludeEditInfo = bIncludeEditInfo;
	int idx = 0;
	for(ChordEntry* pchord = chordlist.GetHead(); pchord; pchord = pchord->GetNext())
	{
			ChordEntryListItem*	pItem = new ChordEntryListItem(pchord, subchords, m_bIncludeEditInfo);
			SetAt(idx++, pItem);	// does a copy
	}
}

ChordMapList::~ChordMapList()
{
	POSITION pos = GetStartPosition();
	while(pos != NULL)
	{
		int key;
		ChordEntryListItem* pItem;
		GetNextAssoc(pos, key, pItem);
		delete pItem;
		RemoveKey(key);
	}
}

HRESULT ChordMapList::Write(IDMUSProdRIFFStream* pRiffStream)
{
	POSITION pos = GetStartPosition();
	HRESULT hr = S_OK;

	WriteListChunk list(pRiffStream, FOURCC_LISTCHORDMAP);
	hr = list.State();
	
	while(hr == S_OK && pos != NULL)
	{
		int key;
		ChordEntryListItem* pItem;
		GetNextAssoc(pos, key, pItem);
		hr = pItem->Write(pRiffStream);
	}
	return hr;
}

HRESULT ChordMapList::Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
	{
		return E_INVALIDARG;
	}

	MMCKINFO ck;
	HRESULT hr = S_OK;
	WORD count = 0;
	while(pRiffStream->Descend(&ck, pckParent, 0) == 0&& hr == S_OK)
	{
		switch(ck.ckid)
		{
		case FOURCC_LIST:
			switch(ck.fccType)
			{
			case FOURCC_LISTCHORDENTRY:
				{
					ChordEntryListItem* item = new ChordEntryListItem;
					hr = item->Read(pRiffStream, &ck);
					if(hr == S_OK)
					{
						SetAt(count++, item);
					}
					else
					{
						delete item;
					}
					break;
				}
			break;
			}
		}
		pRiffStream->Ascend(&ck, 0);
	}

	return hr;
}

HRESULT ChordMapList::Extract( ChordEntryList& chordlist, DMSubChordSet& subchords, bool bIncludeEditInfo)
{
	HRESULT hr = S_OK;
	m_bIncludeEditInfo = bIncludeEditInfo;
	int idx = 0;
	for(ChordEntry* pchord = chordlist.GetHead(); pchord; pchord = pchord->GetNext())
	{
			ChordEntryListItem*	pItem = new ChordEntryListItem(pchord, subchords, m_bIncludeEditInfo);
			SetAt(idx++, pItem);	// does a copy
	}
	return hr;
}

HRESULT ChordMapList::Insert(ChordEntryList& chordlist, const DMSubChordSet& subchords)
{
	POSITION pos = GetStartPosition();
	HRESULT hr = S_OK;
	while(hr == S_OK && pos != NULL)
	{
		int key;
		ChordEntryListItem* pItem;
		ChordEntry* pchord = new ChordEntry;
		if(!pchord)
		{
			hr = E_FAIL;
		}
		else
		{
			GetNextAssoc(pos, key, pItem);
			hr = pItem->Insert(pchord, subchords);
			chordlist.AddTail(pchord);
		}
	}
	return hr;
	
}

//////////////////////////////////////////////////////// DMSubChordSet members
//
DMSubChordSet::~DMSubChordSet()
{
	if(m_aSubChord)
	{
		delete [] m_aSubChord;
		m_aSubChord = 0;
		m_cSubChord = 0;
	}

	POSITION pos = GetStartPosition();
	while(pos != NULL)
	{
		WORD idx;
		ioSubChord Item;
		GetNextAssoc(pos, Item, idx);
		RemoveKey(Item);
	}
}

HRESULT	DMSubChordSet::Add(DMPolyChord& Chord,  ChordListChunk& chordlist)
{

	int n = min(DMPolyChord::MAX_POLY, ChordListChunk::maxsubchords);

	for(int i = 0; i < n; i++)
	{
		ioSubChord	Sub(*Chord[i]);
		WORD id;
		if(!Lookup(Sub, id))
		{
			id = wNextKey++;
			SetAt(Sub, id);
		}
		chordlist.subchordids[i] = id;
	}
	return S_OK;
}

HRESULT DMSubChordSet::Retrieve( DMPolyChord& Chord, const ChordListChunk& chordlist) 
{
	int n = min(DMPolyChord::MAX_POLY, ChordListChunk::maxsubchords);

	HRESULT hr = S_OK;

	if(!m_aSubChord)
	{
		BuildSubChordArray();
	}
	ASSERT(m_cSubChord > 0);
	if(m_cSubChord == 0)
	{
		return E_FAIL;
	}

	for(int i = 0; i < n; i++)
	{
		WORD id = chordlist.subchordids[i];
		if(id < m_cSubChord)
		{
//			ioSubChord sub;
			m_aSubChord[id].CopyToDMChord(*Chord.SubChord(i));
		}
	}
	return hr;
}

HRESULT DMSubChordSet::Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	IStream* pStream;
	HRESULT hr;
	DWORD dwBytesWritten;
	if(!m_aSubChord)
	{
		BuildSubChordArray();
	}

	ASSERT(m_cSubChord > 0);
	if(m_cSubChord == 0)
	{
		return E_FAIL;
	}

	WriteChunk	chunk(pRiffStream, FOURCC_SUBCHORD);
	hr = chunk.State();

	if(hr == S_OK)
	{
		pStream = pRiffStream->GetStream();
		ASSERT(pStream);
		if(pStream == NULL)
		{
			return E_FAIL;
		}
		unsigned short cb = static_cast<unsigned short>(sizeof(ioSubChord));
		hr = pStream->Write(&cb, sizeof(unsigned short), &dwBytesWritten);
		if(hr == S_OK && dwBytesWritten == sizeof(unsigned short))
		{
			for(WORD i = 0; hr == S_OK && i < m_cSubChord; i++)
			{
				hr = pStream->Write(&m_aSubChord[i], sizeof(ioSubChord), &dwBytesWritten);
				if(dwBytesWritten != sizeof(ioSubChord))
				{
					hr = E_FAIL;
				}
			}
		}
		pStream->Release();
	}
	return hr;
}

bool DMSubChordSet::m_sbDisableMessages = false;

HRESULT DMSubChordSet::Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pck)
{
	ASSERT(pRiffStream);
	HRESULT hr = S_OK;
	DWORD dwBytesRead;
	IStream* pIStream = pRiffStream->GetStream();
	ASSERT(pIStream != NULL);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}
	WORD cbioSubChordSize;	
	hr = pIStream->Read(&cbioSubChordSize, sizeof(WORD), &dwBytesRead);
	ASSERT(cbioSubChordSize==sizeof(ioSubChord));
	WORD count = static_cast<WORD>((pck->cksize - sizeof(WORD)) / cbioSubChordSize);
	WORD key = 0;
	DWORD	cbRead = sizeof(WORD);	// already read size of ioSubChord

	if(cbioSubChordSize != sizeof(ioSubChord))
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

	while(cbRead < pck->cksize && hr == S_OK)
	{
		ioSubChord sub;
		DWORD	cb;
		hr = pIStream->Read(&sub, cbioSubChordSize, &cb);
		if(cb != cbioSubChordSize)
		{
			hr = E_FAIL;
		}
		// make sure we got the lowest bit pattern in chords
		while(sub.dwChordPattern && !(sub.dwChordPattern & 0x1))
		{
			sub.dwChordPattern = sub.dwChordPattern >> 1;
			sub.bChordRoot++;
			sub.wCFlags |= CSF_SHIFTED;	// make this chord unique
		}
		// make sure root in range
		if(sub.bChordRoot > 23)
		{
			// make this chord unique
			while(sub.bChordRoot > 23)
			{
				sub.bChordRoot -= 12;
			}
			sub.wCFlags |= CSF_SHIFTED;	// make this chord unique
			if(!m_sbDisableMessages)
				AfxMessageBox(IDS_ILLEGALCHORD);
		}

		WORD id;
		if(!Lookup(sub, id))
		{
			id = key++;
			SetAt(sub, id);
		}

		cbRead += cb;
	}

	ASSERT(count == key);
	if(count != key)
	{
		hr = E_FAIL;
	}
	else
	{
		m_cSubChord = count;
	}
ON_ERR:
	pIStream->Release();
	return hr;
}


void DMSubChordSet::BuildSubChordArray()
{
	if(m_aSubChord)
	{
		delete [] m_aSubChord;
		m_aSubChord = 0;
		m_cSubChord = 0;
	}

	m_cSubChord = static_cast<unsigned short>(GetCount());

	m_aSubChord = new ioSubChord[m_cSubChord];
	POSITION pos = GetStartPosition();
	while(pos)
	{
		ioSubChord Sub;
		WORD idx;
		GetNextAssoc(pos, Sub, idx);
		ASSERT(idx < m_cSubChord);
		memcpy(&m_aSubChord[idx], &Sub, sizeof(ioSubChord));
	}
}

HRESULT DMSaveChordData(ChordEntryList& chordEntryList, IStream * pIStream, bool bIncludeDesignInfo)
{
	DMSubChordSet subchordset;
	ChordMapList	chordmap;
	IDMUSProdRIFFStream* pIRiffStream;


	HRESULT hr = S_OK;

	hr = chordmap.Extract(chordEntryList, subchordset, false);

	ASSERT(pIStream);
	if(pIStream == 0)
	{
		return E_INVALIDARG;
	}

	hr = AllocRIFFStream(pIStream, &pIRiffStream);

	if(hr == S_OK)
	{
		hr = subchordset.Write(pIRiffStream) || chordmap.Write(pIRiffStream);
		if(hr == S_OK /* && bIncludeDesignInfo */)
		{
			hr = WriteChordEntryEditChunk(pIRiffStream, &chordEntryList);
		}
		pIRiffStream->Release();
	}
	return hr;
}

HRESULT DMLoadChordData(ChordEntryList& chordEntryList, IStream* pIStream)
{
	MMCKINFO		ck;
	HRESULT			hr=S_OK;

	DMSubChordSet subchords;
	bool bDMSubChordSetRead = false;
	bool bDMChordMapRead = false;

	IDMUSProdRIFFStream* pIRiffStream;;
	ASSERT( pIStream != NULL );

	hr = AllocRIFFStream(pIStream, &pIRiffStream);



	while(SUCCEEDED(hr) && pIRiffStream->Descend( &ck, NULL, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
		case FOURCC_SUBCHORD:			
			hr = subchords.Read(pIRiffStream, &ck);
			bDMSubChordSetRead = true;
			if(FAILED(hr))
			{
				hr = E_FAIL;
				goto ON_ERR;
			}
			break;

		case FOURCC_CHORDENTRYEDIT:
			ASSERT(bDMChordMapRead);
			if(bDMChordMapRead)
			{
				hr = ReadChordEntryEditChunk(pIRiffStream, &chordEntryList, &ck);
			}
			break;

		case FOURCC_LIST:
			switch( ck.fccType )
			{

/*
			case FOURCC_LISTCHORDPALETTE:
				{
					ChordPaletteList chordpalette;
					if(!bDMSubChordSetRead)
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					hr = chordpalette.Read(pIRiffStream, &ck);
					if(FAILED(hr))
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					chordpalette.Insert(m_pPersonality->m_chordpalette, subchords);
				}
				break;
*/
			case FOURCC_LISTCHORDMAP:
				{
					ChordMapList chordmap;
 					if(!bDMSubChordSetRead)
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					hr = chordmap.Read(pIRiffStream, &ck);
					if(FAILED(hr))
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					chordmap.Insert(chordEntryList, subchords);
				}
				bDMChordMapRead = true;
				break;
/*
			case FOURCC_SIGNPOSTLIST:
				{
					SignPostListChunk signposts;
					if(!bDMSubChordSetRead)
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					hr = signposts.Read(pIRiffStream, &ck);
					if(FAILED(hr))
					{
						hr = E_FAIL;
						goto ON_ERR;
					}
					signposts.Insert(m_pPersonality->m_signpostlist, subchords);
				}
				break;
*/
			}
		}
        pIRiffStream->Ascend( &ck, 0 );
    }


ON_ERR:
    if ( pIRiffStream != NULL )
	{
		pIRiffStream->Release();
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ChordIO.h ===
#ifndef __CHORDIO_H_
#define __CHORDIO_H_

#include "dmusprod.h"
#include "DWList.h"
#include "PropChord.h"

class ChordEntry;
class ChordSelection;
class CChordItem : public DWListItem, public CPropChord
{
//	Used to track the selection of the chord in display.
	DWORD		m_fSelected;		// Selection and more
public:
	enum {Selected = 1, SignPost = 2, BegSignPost = 4, EndSignPost = 8}; 
	CChordItem();
	CChordItem(const CChordItem&);
	CChordItem(const ChordEntry&);
	CChordItem(const ChordSelection&);
	CChordItem& operator = (const CChordItem& item)
	{
		*dynamic_cast<CPropChord*>(this) = dynamic_cast<const CPropChord&>(item);
		m_fSelected = item.m_fSelected;
		return *this;
	}
	CChordItem *    GetNext() {return(CChordItem *)DWListItem::GetNext();};

	BOOL IsSelected() { return m_fSelected & Selected; }
	DWORD FSelected() { return m_fSelected; }
	void SetSelected(BOOL b)
	{
		if(b)
		{
			m_fSelected |= Selected;
		}
		else
		{
			m_fSelected &= ~Selected;
		}
	}

	BOOL IsSignPost() { return m_fSelected & SignPost; }
	BOOL IsBegSignPost() {return m_fSelected & BegSignPost; }
	BOOL IsEndSignPost() {return m_fSelected & EndSignPost; }
	void SetBegSignPost(bool b)
	{
		if(b)
		{
			m_fSelected |= BegSignPost;
		}
		else
		{
			m_fSelected &= ~BegSignPost;
		}
		SetSignPost(true);
	}
	void SetEndSignPost(bool b)
	{
		if(b)
		{
			m_fSelected |= EndSignPost;
		}
		else
		{
			m_fSelected &= ~EndSignPost;
		}
		SetSignPost(true);
	}
	void SetSignPost(bool b)
	{
		if(b)
		{
			m_fSelected |= SignPost;
		}
		else
		{
			m_fSelected &= ~SignPost;
			m_fSelected &= ~BegSignPost;
			m_fSelected &= ~EndSignPost;
		}
	}
//	Used to manage drawing and indexing.
	long		m_lDrawPosition;	// Drawn position in strip.
	DWORD		m_dwIndex;			// Index in list. (probably not needed anymore)
}; 

class CChordList : public DWList
{
public:
    CChordItem *    GetHead() {return(CChordItem *)DWList::GetHead();};
	CChordItem *	RemoveHead() { return(CChordItem *)DWList::RemoveHead();};
	void		ClearList();
	void		ClearSelections();
	DWORD		PreparePropChord( CPropChord *pPropChord );
	DWORD		RetrievePropChord( CPropChord *pPropChord );
	void		InsertByAscendingTime(CChordItem *pChord);	// *pChord <= *(pChord->next)
	HRESULT		Load( LPSTREAM pStream );
	HRESULT		Save( LPSTREAM pStream, BOOL bClearDirty, FileType ftFileType = FT_RUNTIME );
	HRESULT		DMLoad(IStream* pStream);
	HRESULT		DMSave(IStream* pStream, BOOL bClearDirty);
};


typedef struct ioOldChord
{
	long	lChordPattern;	// pattern that defines chord
	long	lScalePattern;	// scale pattern for the chord
	long	lInvertPattern;	// inversion pattern
    BYTE    bRoot;			// root note of chord
	BYTE    bReserved;		// expansion room
	WORD    wCFlags;		// bit flags
	long	lReserved;		// expansion room
} ioOldChord;

typedef struct ioOldChordSelection
{
    wchar_t wstrName[16];   // text for display
    BYTE    fCSFlags;      // ChordSelection flags
    BYTE    bBeat;         // beat this falls on
    WORD    wMeasure;       // measure this falls on
    ioOldChord aChord[4];      // array of chords: levels
    BYTE    bClick;        // click this falls on
} ioOldChordSelection;


typedef struct ioChord
{
	DWORD	dwChordPattern;	// pattern that defines chord
	DWORD	dwScalePattern;	// scale pattern for the chord
	DWORD	dwInvertPattern;	// inversion pattern
	DWORD	dwLevels;				// what levels this chord supports
    BYTE    bChordRoot;			// root note of chord
	BYTE    bScaleRoot;		// root note of scale
	BYTE	bFlat;
	BYTE	bBits;
	WORD    wFlags;		// bit flags
	bool		bInUse;
} ioChord;

typedef struct ioChordSelection
{
    ioChord aChord[DMPolyChord::MAX_POLY];      // array of chords: levels
	DWORD	dwTime;
	short		nMeasure;
	BYTE	bBeat;
	BYTE	bRootIndex;
    wchar_t wstrName[DMPolyChord::MAX_NAME];   // text for display
	bool		bKeydown;
	BYTE	fCSFlags;
} ioChordSelection;

enum
{
	CSF_KEYDOWN = 	1,	// key currently held down in sjam kybd
	CSF_INSCALE = 	2,	// member of scale
	CSF_FLAT =		4,	// display with flat
	CSF_SIMPLE =	8,	// simple chord, display at top of sjam list
	CSF_SELECTED = 0x80, // this chord is selected
	CSF_SIGNPOST = 0x40, // this chord is from a signpost
	CSF_BEGSIGNPOST = 0x10,
	CSF_ENDSIGNPOST = 0x20
};
/*
// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}
*/
#endif // __CHORDIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ChordDatabase.h ===
#ifndef CHORDDATABASE_H
#define CHORDDATABASE_H

#include "Chord.h"
#include "chordio.h"
#include "chordmapriff.h"

// pattern for single data chunk objects:
// To save to a riffstream: XChunk myChunk(pData); myChunk.Write(pRiffStream);
// To extract from a riffstream: extern XChunk myChunk; mChunk.Read(pRiffStream); myChunk.Insert(pData);


HRESULT DMSaveChordData(ChordEntryList& chordEntryList, IStream * pIStream, bool bIncludeDesignInfo);

HRESULT DMLoadChordData(ChordEntryList& chordEntryList, IStream* pIStream);

class SignPostChunk : public ioSignPost
{
public:
	SignPostChunk() {}
	SignPostChunk(IDMUSProdRIFFStream* pRiffStream)
	{
		Read(pRiffStream);
	}
	SignPostChunk( const SignPost* pSignPost);
	HRESULT	Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT	Read(IDMUSProdRIFFStream* pRiffStream);
	HRESULT	Extract(const SignPost* pSignPost);
	HRESULT Insert( SignPost* pSignPost);
};

class NextChordChunk: public ioNextChord
{
public:
	NextChordChunk() {}
	NextChordChunk(const NextChord* pNext);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream);
	HRESULT	Extract(const NextChord* pNext);
	HRESULT Insert( NextChord* pNext);
};

class ChordEntryChunk: public ioChordEntry
{
public:
	ChordEntryChunk() {}
	ChordEntryChunk(const ChordEntry* pChord);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream);
	HRESULT	Extract(const ChordEntry* pChord);
	HRESULT Insert( ChordEntry* pChord);
};

// chord entry edit info helpers
HRESULT WriteChordEntryEditChunk(IDMUSProdRIFFStream* pRiffStream, ChordEntryList* plist);
HRESULT ReadChordEntryEditChunk(IDMUSProdRIFFStream* pRiffStream, ChordEntryList* plist, MMCKINFO* pckInfo);

class ChordEntryEditChunk : public ioChordEntryEdit
{
public:
	ChordEntryEditChunk() {}
	ChordEntryEditChunk(const ChordEntry* pChord);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Extract(const ChordEntry* pChord);
	HRESULT Insert(ChordEntry* pChord);
};

class DMSubChordSet;

class ChordListChunk
{
	DMChordEdit m_chordedit;
	bool m_bIncludeEditInfo;
public:
	enum {NameSize = DMPolyChord::MAX_NAME};
	ChordListChunk() {m_bIncludeEditInfo = false;  memset(name, 0, sizeof(name));}
	ChordListChunk(DMPolyChord& pChord, DMSubChordSet& chordset, bool bIncludeEditInfo);
	enum { maxsubchords = MaxSubChords};
	WCHAR	name[NameSize];
	WORD	subchordids[maxsubchords];
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent);
	HRESULT	Extract( DMPolyChord& pChord, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Insert( DMPolyChord& pChord, const DMSubChordSet& subchords);
};


class ChordEntryListItem
{
	bool m_bIncludeEditInfo;
public:
	ChordEntryListItem() {m_bIncludeEditInfo = false;}
	ChordEntryListItem(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
	{
		Read(pRiffStream, pckParent);
	}
	ChordEntryListItem( ChordEntry* pChord, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent);
	HRESULT	Extract(ChordEntry* pChord, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Insert( ChordEntry* pChord, const DMSubChordSet& subchords);
private:
	ChordEntryChunk	m_chordentry;
	ChordListChunk	  m_chordlist;
	CList<NextChordChunk, NextChordChunk&> m_nextchordlist;
};


class CadenceListChunk
{
	bool m_bIncludeEditInfo;
public:
	CadenceListChunk() {m_bHasCadenceChord1 = false; m_bHasCadenceChord2 = false; m_bIncludeEditInfo = false;};
	CadenceListChunk( SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent);
	HRESULT	Extract( SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Insert( SignPost* pSignPost, const DMSubChordSet& subchords);
private:
	ChordListChunk	m_CadenceChord1;
	ChordListChunk	m_CadenceChord2;
	BOOL					m_bHasCadenceChord1;
	BOOL					m_bHasCadenceChord2;;
};

class SignPostListItemChunk
{
	bool m_bIncludeEditInfo;
public:
	SignPostListItemChunk() {m_bIncludeEditInfo = false;}
	SignPostListItemChunk(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
	{
		ASSERT(pRiffStream);
		Read(pRiffStream, pckParent);
	}
	SignPostListItemChunk( SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent);
	HRESULT	Extract( SignPost* pSignPost, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Insert( SignPost* pSignPost, const DMSubChordSet& subchords);
private:
	SignPostChunk	m_signpost;
	ChordListChunk	m_signpostchord;
	CadenceListChunk	m_cadencelist;
};

class SignPostListChunk : public 	CList<SignPostListItemChunk*, SignPostListItemChunk*&>
{
	bool m_bIncludeEditInfo;
public:
	SignPostListChunk() {m_bIncludeEditInfo = false;}
	SignPostListChunk(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
	{
		ASSERT(pRiffStream);
		Read(pRiffStream, pckParent);
	}
	SignPostListChunk( SignPostList& signpostlist, DMSubChordSet& subchords, bool bIncludeEditInfo);
	~SignPostListChunk();
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent);
	HRESULT	Extract( SignPostList& signpostlist, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Insert( SignPostList& signpostlist, const DMSubChordSet& subchords);
};

class ChordPaletteList
{
public:
	ChordPaletteList() {}
	ChordPaletteList(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
	{
		ASSERT(pRiffStream);
		Read(pRiffStream, pckParent);
	}
	ChordPaletteList( ChordPalette& chordpalette, DMSubChordSet& subchords);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent);
	HRESULT	Extract( ChordPalette& chordpalette, DMSubChordSet& subchords);
	HRESULT Insert(ChordPalette& chordpalette, const DMSubChordSet& subchords);
private:
	ChordListChunk	m_chordlist[24];
};

class ChordMapList : public CMap<int, int, ChordEntryListItem*, ChordEntryListItem*&>
{
	bool m_bIncludeEditInfo;
public:
	ChordMapList() {m_bIncludeEditInfo = false;}
	ChordMapList(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
	{
		ASSERT(pRiffStream);
		Read(pRiffStream, pckParent);
	}
	ChordMapList( ChordEntryList& chordlist, DMSubChordSet& subchords, bool bIncludeEditInfo);
	~ChordMapList();
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent);
	HRESULT	Extract( ChordEntryList& chordlist, DMSubChordSet& subchords, bool bIncludeEditInfo);
	HRESULT Insert(ChordEntryList& chordlist, const DMSubChordSet& subchords);

};



inline BOOL	operator == (ioSubChord p1, ioSubChord p2)
{
	return !memcmp(&p1, &p2, sizeof(ioSubChord));
}


class DMSubChordSet : public CMap<ioSubChord, ioSubChord&, WORD, WORD&>
//
// This class used to prepare subChords to be saved.  Add screens for duplications.
//
{
	WORD	wNextKey;
	ioSubChord*  m_aSubChord;
	WORD		 m_cSubChord;
	void		 BuildSubChordArray();
public:
	static bool	m_sbDisableMessages;
	DMSubChordSet() { wNextKey = 0; m_cSubChord = 0; m_aSubChord = 0;}
	~DMSubChordSet();
	// access functions
	HRESULT Add( DMPolyChord& Chord, ChordListChunk& chordlist);
	HRESULT Retrieve(DMPolyChord& Chord, const ChordListChunk& chordlist) ;
	// storage functions
	HRESULT	Write(IDMUSProdRIFFStream* pRiffStream);				// writes chord data to pStream
	HRESULT	Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pck);	// reads chord data to pStream
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ChordInversionPropPage.cpp ===
// ChordInversionPropPage.cpp : implementation file
//

#include "stdafx.h"
#include "..\includes\DMUSProd.h"
#include "..\includes\Conductor.h"
#include "PropChord.h"
#include "PropPageMgr.h"
#include "chordmapstripmgr.h"
#include "ChordInversionPropPage.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage property page

IMPLEMENT_DYNCREATE(CChordInversionPropPage, CPropertyPage)

CChordInversionPropPage::CChordInversionPropPage() : CPropertyPage(CChordInversionPropPage::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	//{{AFX_DATA_INIT(CChordInversionPropPage)
	//}}AFX_DATA_INIT
	m_pPropPageMgr = NULL;
	m_pIConductor = 0;
	m_pIPerformance = 0;
	m_cRef = 0;
	m_fLockAllScales = TRUE;
	m_fSyncLevelOneToAll = TRUE;
	AddRef();
	m_bValidChord = false;
	m_fNeedToDetach = FALSE;
}

CChordInversionPropPage::~CChordInversionPropPage()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(m_pIConductor)
	{
		m_pIConductor->Release();
	}
	if(m_pIPerformance)
	{
		m_pIPerformance->Release();
	}
}

void CChordInversionPropPage::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChordInversionPropPage)
	DDX_Control(pDX, IDC_KEYS_INVERSIONS4, m_keysinv4);
	DDX_Control(pDX, IDC_KEYS_INVERSIONS3, m_keysinv3);
	DDX_Control(pDX, IDC_KEYS_INVERSIONS2, m_keysinv2);
	DDX_Control(pDX, IDC_KEYS_INVERSIONS1, m_keysinv1);
	DDX_Control(pDX, IDC_KEYS_BASECHORD4, m_keysbase4);
	DDX_Control(pDX, IDC_KEYS_BASECHORD3, m_keysbase3);
	DDX_Control(pDX, IDC_KEYS_BASECHORD2, m_keysbase2);
	DDX_Control(pDX, IDC_KEYS_BASECHORD1, m_keysbase1);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChordInversionPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CChordInversionPropPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_DRAWITEM()
	ON_WM_MEASUREITEM()
	ON_BN_CLICKED(IDC_BUTTON_INVERT1, OnButtonInvert1)
	ON_BN_CLICKED(IDC_BUTTON_INVERT2, OnButtonInvert2)
	ON_BN_CLICKED(IDC_BUTTON_INVERT3, OnButtonInvert3)
	ON_BN_CLICKED(IDC_BUTTON_INVERT4, OnButtonInvert4)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY1, OnButtonIplay1)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY2, OnButtonIplay2)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY3, OnButtonIplay3)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY4, OnButtonIplay4)
	ON_BN_CLICKED(IDC_CHECK_LEGAL1, OnCheckLegal1)
	ON_BN_CLICKED(IDC_CHECK_LEGAL2, OnCheckLegal2)
	ON_BN_CLICKED(IDC_CHECK_LEGAL3, OnCheckLegal3)
	ON_BN_CLICKED(IDC_CHECK_LEGAL4, OnCheckLegal4)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage message handlers



////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage other funcs


/////////////////////////////////////////////////////////////////////////////
// PropPageChord IUnknown
STDMETHODIMP CChordInversionPropPage::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	ASSERT( ppv );
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdMidiInCPt))
	{
        *ppv = (IUnknown *) (IDMUSProdMidiInCPt *) this;
	}
	else
	{
		return E_NOTIMPL;
	}
    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CChordInversionPropPage::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CChordInversionPropPage::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


int CChordInversionPropPage::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}

void CChordInversionPropPage::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}
	CPropertyPage::OnDestroy();	
}

// required to get owner draw controls to paint 
void CChordInversionPropPage::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CPropertyPage::OnDrawItem(nIDCtl, lpDrawItemStruct);
}

void CChordInversionPropPage::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CPropertyPage::OnMeasureItem(nIDCtl, lpMeasureItemStruct);
}

BOOL CChordInversionPropPage::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	
	m_nextinvert4.AutoLoad(IDC_BUTTON_INVERT4, this);
	m_nextinvert3.AutoLoad(IDC_BUTTON_INVERT3, this);
	m_nextinvert2.AutoLoad(IDC_BUTTON_INVERT2, this);
	m_nextinvert1.AutoLoad(IDC_BUTTON_INVERT1, this);

	m_play4.AutoLoad(IDC_BUTTON_IPLAY4, this);
	m_play3.AutoLoad(IDC_BUTTON_IPLAY3, this);
	m_play2.AutoLoad(IDC_BUTTON_IPLAY2, this);
	m_play1.AutoLoad(IDC_BUTTON_IPLAY1, this);

	CPropertyPage::OnInitDialog();
	
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CChordInversionPropPage::OnButtonInvert1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[0].Rotate(m_Chord.SubChord(0)->NoteCount());
	SetChord(&m_Chord, 0);
}

void CChordInversionPropPage::OnButtonInvert2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[1].Rotate(m_Chord.SubChord(1)->NoteCount());
	SetChord(&m_Chord, 1);
}

void CChordInversionPropPage::OnButtonInvert3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[2].Rotate(m_Chord.SubChord(2)->NoteCount());
	SetChord(&m_Chord, 2);
}

void CChordInversionPropPage::OnButtonInvert4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[3].Rotate(m_Chord.SubChord(3)->NoteCount());
	SetChord(&m_Chord, 3);
}

void CChordInversionPropPage::OnButtonIplay1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(0);
}

void CChordInversionPropPage::OnButtonIplay2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(1);	
}

void CChordInversionPropPage::OnButtonIplay3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(2);	
}

void CChordInversionPropPage::OnButtonIplay4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(3);	
}

void CChordInversionPropPage::OnCheckLegal1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL1);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[0].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[0].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(0)->InvertPattern() = m_invertVector[0].GetInvertPattern();
		UpdateChordData();
	}	
}

void CChordInversionPropPage::OnCheckLegal2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL2);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[1].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[1].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(1)->InvertPattern() = m_invertVector[1].GetInvertPattern();
		UpdateChordData();
	}	
}

void CChordInversionPropPage::OnCheckLegal3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL3);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[2].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[2].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(2)->InvertPattern() = m_invertVector[2].GetInvertPattern();
		UpdateChordData();
	}	
	
}

void CChordInversionPropPage::OnCheckLegal4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL4);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[3].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[3].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(3)->InvertPattern() = m_invertVector[3].GetInvertPattern();
		UpdateChordData();
	}	
	
}

void CChordInversionPropPage::UpdateChordData(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject)
	{
		CChordScalePropPageData chordscalePropPageData;

		chordscalePropPageData.m_pPropChord = &m_Chord;
		chordscalePropPageData.m_fLockAllScales = m_fLockAllScales;
		chordscalePropPageData.m_fSyncLevelOneToAll = m_fSyncLevelOneToAll;

		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &chordscalePropPageData);
	}	
}

void CChordInversionPropPage::SetChordData(CChordScalePropPageData* pChordScalePropPageData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pChordScalePropPageData != NULL );
	if( pChordScalePropPageData )
	{
		SetChord( pChordScalePropPageData->m_pPropChord );

		m_fLockAllScales = pChordScalePropPageData->m_fLockAllScales;
		m_fSyncLevelOneToAll = pChordScalePropPageData->m_fSyncLevelOneToAll;
	}
}


void CChordInversionPropPage::SetChord(CPropChord * pChord, int subchord)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	char str[30];
	
	m_Chord = *pChord;

	if( IsWindow( m_hWnd ) == 0 ) return;
	
	if(::IsWindow(m_play4.m_hWnd))
	{

		if(m_Chord.RootIndex() == DMPolyChord::INVALID)
		{
			EnableControls(FALSE);
		}
		else
		{
			EnableControls(TRUE);
		}
	}

	if(pChord->RootIndex() >= DMPolyChord::MAX_POLY) 
		return;	// invalid chord, controls will be blanked out


	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_NAME)
	{
		SetDlgItemText(IDC_EDIT_NAME,"");
	}
	else
	{
		SetDlgItemText(IDC_EDIT_INAME,pChord->Name());
	}
	pChord->RootToString(str, pChord->RootIndex());
	SetDlgItemText(IDC_EDIT_IROOT,str);
//	SetCheckBox(pChord, UD_FLAT, IDC_CHECKBOX_FLATS, pChord->Base()->UseFlat() && 1);
	short nGrayed;
	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_CHORDPATTERN) nGrayed = 4;
	else nGrayed = 0;
	int nX;
	int k0 = subchord == -1 ? 0 : subchord;
	int k1 = subchord == -1 ? CPropChord::MAX_POLY : subchord + 1;
	bool globalset = (subchord == -1);
	
	for(int n = k0; n < k1; n++)
	{
		// clear keyboards
		GetChordKeyboard(n)->ClearKeys();
		GetInversionKeyboard(n)->ClearKeys();

		// determine chord inversions
		int bass,third,fifth, seventh;
		BitFlag bfChord(pChord->SubChord(n)->ChordPattern());
		pChord->SubChord(n)->ChordNotes(bass, third, fifth, seventh);
		int inversion = m_invertStates[n].Get();
		if(inversion >= InversionState::First && third > -1)
		{
			bfChord.ClearBit(bass);
			bfChord.SetBit(bass+12);
		}
		if(inversion >= InversionState::Second && fifth > -1)
		{
			bfChord.ClearBit(third);
			bfChord.SetBit(third+12);
		}
		if(inversion >= InversionState::Third &&  seventh > -1)
		{
			bfChord.ClearBit(fifth);
			bfChord.SetBit(fifth+12);
		}
		DWORD dwChord = bfChord;
		// make sure pattern is tranposed
		dwChord = Rotate24(dwChord, pChord->SubChord(n)->ChordRoot() % 24);

		GetChordKeyboard(n)->Transpose(pChord->SubChord(n)->ChordRoot(), true);
		int shift = (pChord->SubChord(n)->ChordRoot())%24;
		if(globalset)
		{
			// only do this when all keys chords change (ie you've switched to this prop page)
			GetInversionKeyboard(n)->SetLowerBound(shift);
		}
		for (nX = 0; nX < 24; nX++)
		{
			short nState = nGrayed;
			if ((pChord->SubChord(n)->ChordPattern() >> nX) & 1) nState += 2;
			GetChordKeyboard(n)->SetNoteState(nX,"",nState);
			DrawInversionNote(pChord, dwChord, n, nX);
		}
		// finally set check box according to legality of inversion
		m_invertVector[n].SetChord(m_Chord.SubChord(n)->ChordPattern());
		m_invertVector[n].SetInversion(m_Chord.SubChord(n)->InvertPattern());
		CButton* pButton=0;
		switch(n)
		{
		case 0:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL1);
			break;
		case 1:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL2);
			break;
		case 2:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL3);
			break;
		case 3:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL4);
			break;
		}
		if(pButton)
		{
			if(inversion == 0)
			{
				pButton->SetCheck(1);
			}
			else if(m_invertVector[n].GetAllowedInversion(inversion-1))
			{
				pButton->SetCheck(1);
			}
			else
			{
				pButton->SetCheck(0);
			}
		}
	}

}

CKeyboard* CChordInversionPropPage::GetChordKeyboard(int index)
{
		switch(index)
		{
		case 0:
			return &m_keysbase1;			
			break;
		case 1:
			return &m_keysbase2;
			break;
		case 2:
			return &m_keysbase3;
			break;
		case 3:
			return &m_keysbase4;
			break;
		default:
			return 0;
			break;
		}
}

int CChordInversionPropPage::GetChordKeyboardIndex(const CKeyboard * pKeyboard)
{
	int i = 0;
	for(i; i < CPropChord::MAX_POLY; i++)
	{
		if(GetChordKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= CPropChord::MAX_POLY ? -1 : i;

}

CKeyboard* CChordInversionPropPage::GetInversionKeyboard(int index)
{
		switch(index)
		{
		case 0:
			return &m_keysinv1;			
			break;
		case 1:
			return &m_keysinv2;
			break;
		case 2:
			return &m_keysinv3;
			break;
		case 3:
			return &m_keysinv4;
			break;
		default:
			return 0;
			break;
		}

}

int CChordInversionPropPage::GetInversionKeyboardIndex(const CKeyboard * pKeyboard)
{
	int i = 0;
	for(i; i < CPropChord::MAX_POLY; i++)
	{
		if(GetInversionKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= CPropChord::MAX_POLY ? -1 : i;

}


void CChordInversionPropPage::DrawInversionNote(CPropChord* pChord, DWORD dwChordInversion, int index, short nX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	nX += GetInversionKeyboard(index)->LowerBound();
	short nX24 = nX%24;
	short nGrayed;
	if (pChord->GetUndetermined(index) & UD_SCALEPATTERN) nGrayed = 4;
	else nGrayed = 0;

	short nState = nGrayed;
	if ((dwChordInversion >> nX24) & 1) 
		nState += 2;
	GetInversionKeyboard(index)->SetNoteState(nX,"",nState);
}

BOOL CChordInversionPropPage::OnSetActive() 
{
	// TODO: Add your specialized code here and/or call the base class
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// make sure chord in sync from any changes in chordscaleproppage.
	CChordScalePropPageData chordscalePropPageData;
	CChordScalePropPageData* pChordScalePropPageData = &chordscalePropPageData;
	if( SUCCEEDED ( m_pPropPageMgr->m_pIPropPageObject->GetData( (void **)&pChordScalePropPageData ) ) )
	{
		SetChordData(pChordScalePropPageData);
	}
	return CPropertyPage::OnSetActive();
}

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0

#define MIDI_BASEPITCH		48


void CChordInversionPropPage::PlayChordInversion(int index)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if(m_pIConductor == NULL)
	{
		IDMUSProdComponent* pIComponent = NULL;
		if (m_pPropPageMgr->m_pIFramework)
		{
			if( SUCCEEDED ( m_pPropPageMgr->m_pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
			{
				HRESULT hr = pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&m_pIConductor );
				pIComponent->Release();
				if(FAILED(hr))
				{
					ASSERT(FALSE);
					return;
				}

			}
		}
	}
	
	short nX;
	DWORD dwTime = 0;
	ChangePatch(0,0,0,0);

	// determine chord inversions
	int bass,third,fifth, seventh;
	BitFlag bfChord(m_Chord.SubChord(index)->ChordPattern());
	m_Chord.SubChord(index)->ChordNotes(bass, third, fifth, seventh);
	int inversion = m_invertStates[index].Get();
	if(inversion >= InversionState::First && third > -1)
	{
		bfChord.ClearBit(bass);
		bfChord.SetBit(bass+12);
	}
	if(inversion >= InversionState::Second && fifth > -1)
	{
		bfChord.ClearBit(third);
		bfChord.SetBit(third+12);
	}
	if(inversion >= InversionState::Third &&  seventh > -1)
	{
		bfChord.ClearBit(fifth);
		bfChord.SetBit(fifth+12);
	}
	DWORD dwChord = bfChord;
	DWORD root = m_Chord.SubChord(index)->ChordRoot() % 12;

	for (nX = 0; nX < 24; nX++)
	{
		if ((dwChord >> nX) & 1)
		{
			unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX + root);
			PlayNote(0, note, 120, dwTime, CHORDNOTE_DUR);
			dwTime += CHORDNOTE_DUR;
		}
	}
}

HRESULT CChordInversionPropPage::PlayNote(BYTE ch, BYTE key, BYTE vel, DWORD startTime, DWORD dur)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;

	// make sure we have a performance
	if(m_pIPerformance == 0)
	{
		hr = m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIPerformance);
		if(FAILED(hr))
		{
			return hr;
		}
	}

	// Allocate and initialize a PMsg
	DMUS_MIDI_PMSG* pMidi = NULL;
	hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMidi);
	if(FAILED(hr))
	{
		return hr;
	}
	memset(pMidi, 0, sizeof(DMUS_MIDI_PMSG));

	// fill in midi note on
	pMidi->bStatus = 0x90 + (ch&0xf);	// note on
	pMidi->bByte1 = key;
	pMidi->bByte2 = vel;

	REFERENCE_TIME	rtNow;
	m_pIPerformance->GetLatencyTime(&rtNow);
	pMidi->rtTime = startTime * 10000 + rtNow;
	pMidi->dwFlags = DMUS_PMSGF_REFTIME;
	pMidi->dwPChannel = (ch&0xf);
	pMidi->dwVirtualTrackID = 1;
	pMidi->dwType = DMUS_PMSGT_MIDI;

	hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pMidi));

	if(SUCCEEDED(hr))
	{
		// Allocate and initialize a PMsg
		DMUS_MIDI_PMSG* pMidi = NULL;
		hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMidi);
		if(FAILED(hr))
		{
			return hr;
		}
		memset(pMidi, 0, sizeof(DMUS_MIDI_PMSG));
		// fill in midi note off
		pMidi->bStatus = 0x80 + (ch&0xf);	// note on
		pMidi->bByte1 = key;
		pMidi->bByte2 = vel;

		pMidi->rtTime = (startTime + dur)* 10000 + rtNow;
		pMidi->dwFlags = DMUS_PMSGF_REFTIME;
		pMidi->dwPChannel = (ch&0xf);
		pMidi->dwVirtualTrackID = 1;
		pMidi->dwType = DMUS_PMSGT_MIDI;

		hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pMidi));
	}
	
	return hr;
}

HRESULT CChordInversionPropPage::ChangePatch(BYTE ch, BYTE inst, BYTE msb, BYTE lsb)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;

	// make sure we have a performance
	if(m_pIPerformance == 0)
	{
		hr = m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIPerformance);
		if(FAILED(hr))
		{
			return hr;
		}
	}

	// Allocate and initialize a PMsg
	DMUS_PATCH_PMSG* pPatch = NULL;
	hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_PATCH_PMSG), (DMUS_PMSG**)&pPatch);
	if(FAILED(hr))
	{
		return hr;
	}
	memset(pPatch, 0, sizeof(DMUS_PATCH_PMSG));

	// fill in patch
	REFERENCE_TIME	rtNow;
	m_pIPerformance->GetLatencyTime(&rtNow);
	pPatch->byInstrument = inst;
	pPatch->byMSB = msb;
	pPatch->byLSB = lsb;

	pPatch->rtTime = rtNow;
	pPatch->dwFlags = DMUS_PMSGF_REFTIME;
	pPatch->dwPChannel = (ch&0xf);
	pPatch->dwVirtualTrackID = 1;
	pPatch->dwType = DMUS_PMSGT_PATCH;


	hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pPatch));

	return hr;
}

void CChordInversionPropPage::EnableControls(BOOL bEnable)
{
	m_nextinvert4.EnableWindow(bEnable);
	m_nextinvert3.EnableWindow(bEnable);
	m_nextinvert1.EnableWindow(bEnable);
	m_nextinvert2.EnableWindow(bEnable);

	m_play4.EnableWindow(bEnable);
	m_play3.EnableWindow(bEnable);
	m_play2.EnableWindow(bEnable);
	m_play1.EnableWindow(bEnable);

	GetDlgItem(IDC_CHECK_LEGAL1)->EnableWindow(bEnable);
	GetDlgItem(IDC_CHECK_LEGAL2)->EnableWindow(bEnable);
	GetDlgItem(IDC_CHECK_LEGAL3)->EnableWindow(bEnable);
	GetDlgItem(IDC_CHECK_LEGAL4)->EnableWindow(bEnable);

	if(!bEnable)
	{
		// grey out keyboard
		for(short i = 0; i < 48; i++)
		{
			short nState = 4;
			m_keysinv4.SetNoteState(i,"",nState);
			m_keysinv3.SetNoteState(i,"",nState);
			m_keysinv2.SetNoteState(i,"",nState);
			m_keysinv1.SetNoteState(i,"",nState);
			m_keysbase4.SetNoteState(i,"",nState);
			m_keysbase3.SetNoteState(i,"",nState);
			m_keysbase2.SetNoteState(i,"",nState);
			m_keysbase1.SetNoteState(i,"",nState);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ChordMapMgr.cpp ===
// ChordMapMgr.cpp : Implementation of CChordMapMgr
#include "stdafx.h"
#include "ChordMapStripMgr.h"
#include "ChordMapMgr.h"
#include "..\shared\RiffStrm.h"
#include "ChordDatabase.h"
#include <ChordMapDesigner.h>
#include <SegmentGuids.h>
#include "..\shared\musictimeconverter.h"

/////////////////////////////////////////////////////////////////////////////
// CChordMapMgr

CChordMapMgr::CChordMapMgr()
{
	m_pTimeline = NULL;
	m_pChordMapList = NULL;
	m_nIDCounter = 1;
	m_pPropertyPage = NULL;
	m_pChordPropPageMgr = NULL;
	m_pConnectionPropPageMgr = NULL;
	m_pJazzFramework = NULL;
	m_pCopyDataObject = NULL;
	m_pChordMapStrip = NULL;
	m_pSelectedConnection = 0;
	m_selection = NoSelection;
	m_dwGroupBits = 1;
	m_dblZoom = 0.03125;

	m_pIChordMapNode = NULL;
	m_pIDMTrack = NULL;
	m_dwKey = 12;	// default = 2 C
}


CChordMapMgr::~CChordMapMgr()
{
//				ClearChordMapList(); Intentially left commented.  CPersonality will delete this list.
	if( m_pJazzFramework ) m_pJazzFramework->Release();
	ASSERT( m_pPropertyPage == NULL );
	if( m_pIDMTrack )
	{
		m_pIDMTrack->Release();
	}
	if( m_pChordPropPageMgr ) 
		m_pChordPropPageMgr->Release();
	if( m_pConnectionPropPageMgr ) 
		m_pConnectionPropPageMgr->Release();
	if( m_pCopyDataObject )
	{
		if( S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CChordMapMgr IChordMapMgr

HRESULT STDMETHODCALLTYPE CChordMapMgr::CreateChordMapStrip( 
        /* [out] */ IDMUSProdStrip **ppStrip)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr;
	
	if( NULL == ppStrip )
	{
		return E_POINTER;
	}
	if( m_pChordMapStrip )
	{
		// Sloppy coding, but it shouldn't cause a memory leak if m_pChordMapStrip is non-NULL here
		//ASSERT(FALSE);
	}
	m_pChordMapStrip = new CChordMapStrip(this);
	if( !m_pChordMapStrip )
	{
		return E_OUTOFMEMORY;
	}
	hr = m_pChordMapStrip->QueryInterface( IID_IDMUSProdStrip, (void**)ppStrip );
	m_pChordMapStrip->Release();	// intentional
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CChordMapMgr IDMUSProdStripMgr

HRESULT STDMETHODCALLTYPE CChordMapMgr::GetParam(
		/* [in] */  REFGUID		guidType,
		/* [in] */  MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME*	pmtNext,
		/* [out] */ void*		pData)
{
	ASSERT(pData);
	if(pData == 0)
	{
		return E_POINTER;
	}

	if(::IsEqualGUID(guidType, GUID_ChordMapStripUndoText))
	{
		// pData is CString ptr
		CString* pstr = static_cast<CString*>(pData);
		GetLastEdit(*pstr);
		return S_OK;
	}
	else if(::IsEqualGUID(guidType, GUID_SelectedObjectType))
	{
		// pData is int ptr
		int* pint = static_cast<int*>(pData);
		*pint = m_selection;
		return S_OK;
	}
	else if(::IsEqualGUID(guidType, GUID_SelectedConnection))
	{
		// pData is NextChord ptr
		NextChord** pnext = static_cast<NextChord**>(pData);
		*pnext = m_pSelectedConnection;
		return S_OK;
	}
	else if(::IsEqualGUID(guidType, GUID_SelectedPaletteIndex))
	{
		// pData is int ptr
		*static_cast<int*>(pData) = m_nSelectedIndex;
		return S_OK;
	}
	else if(::IsEqualGUID(guidType, GUID_DocRootNode))
	{
		IDMUSProdNode** ppIDocRootNode = (IDMUSProdNode **)pData;

		*ppIDocRootNode = m_pIChordMapNode;
		if( m_pIChordMapNode )
		{
			m_pIChordMapNode->AddRef();
		}
		return S_OK;
	}
	else
	{
		return E_INVALIDARG;
	}
}

HRESULT STDMETHODCALLTYPE CChordMapMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	if( ::IsEqualGUID( guidType, GUID_VariableNotFixed ) )
	{
		VARIANT v;
		v.vt = VT_BOOL;
		V_BOOL(&v) = *(BOOL*)pData;
		m_pChordMapStrip->SetStripProperty((STRIPPROPERTY)666, v);
		m_pChordMapStrip->RecomputeConnections( true );
		m_pTimeline->StripInvalidateRect(m_pChordMapStrip, NULL, TRUE);
		return S_OK;
	}
	else if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		IDMUSProdNode* pIDocRootNode = (IDMUSProdNode *)pData;

		m_pIChordMapNode = pIDocRootNode;
		return S_OK;
	}

	return E_INVALIDARG;
}

HRESULT STDMETHODCALLTYPE CChordMapMgr::IsParamSupported(
		/* [in] */ REFGUID		guidType)
{
	if( ::IsEqualGUID( guidType, GUID_VariableNotFixed ) 
	||  ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		return S_OK;
	}
	return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CChordMapMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	// TimeSig change
	if( ::IsEqualGUID( rguidType, GUID_TimeSignature ) )
	{
		if(m_pTimeline)	// only update if strip exists (timeline exists -> strip exists)
			m_pChordMapStrip->ComputeChordMap();
		return S_OK;
	}
	else
		return E_INVALIDARG;
}
HRESULT STDMETHODCALLTYPE CChordMapMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

		/* Unsupported
	case SMP_IDIRECTMUSICTRACK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pDMProdFramework )
		{
			return m_pDMProdFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		DMUS_IO_TRACK_HEADER *pioTrackHeader = V_BYREF( &variant );
		if( pioTrackHeader == NULL )
		{
			return E_POINTER;
		}

		pioTrackHeader->guidClassID = CLSID_DirectMusicBandTrack;
		pioTrackHeader->dwPosition = 0;
		pioTrackHeader->dwGroup = m_dwGroupBits;
		pioTrackHeader->ckid = NULL;
		pioTrackHeader->fccType = DMUS_FOURCC_BANDTRACK_FORM;
		break;
		*/

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pJazzFramework )
		{
			m_pJazzFramework->Release();
			m_pJazzFramework = NULL;
		}
		if( m_pTimeline )
		{
			if( V_UNKNOWN( &variant ) == NULL )
			{
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);
			}
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}
		if( V_UNKNOWN( &variant ) )
		{
			if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
			{
				return E_FAIL;
			}
			else
			{
				// set m_pJazzFramework to the jazz framework pointer
				VARIANT var;
				LPUNKNOWN punk;
				if( SUCCEEDED(m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var )) )
				{
					punk = V_UNKNOWN(&var);
					if( punk )
					{
						punk->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pJazzFramework );
						punk->Release();
					}
				}
			}
		}
		break;

		/* Unsupported
	case SMP_IDIRECTMUSICTRACK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
		}
		if( V_UNKNOWN( &variant ) )
		{
			V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack );
		}
		else
		{
			m_pIDMTrack = NULL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pDMProdFramework )
		{
			m_pDMProdFramework->Release();
			m_pDMProdFramework = NULL;
		}
		if( V_UNKNOWN( &variant ) )
		{
			return V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMProdFramework);
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		DMUS_IO_TRACK_HEADER *pioTrackHeader = V_BYREF( &variant );
		if( pioTrackHeader == NULL )
		{
			return E_POINTER;
		}
		m_dwGroupBits = pioTrackHeader->dwGroup;
		m_dwOldGroupBits = pioTrackHeader->dwGroup;
		break;
		*/

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapMgr::CreateBlankChord( ChordEntry** ppChord )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT		hr = S_OK;
	ChordEntry*	pChord = NULL;

	// Allocate new Chord
	if( (pChord = new ChordEntry) == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Set chord roots to key
	DWORD key = m_dwKey & ~UseFlats;
	pChord->m_chordsel = m_pChordPalette->m_chords[key];
	if(m_dwKey & UseFlats)
	{
		pChord->m_chordsel.SubChord(0)->UseFlat() = true;
		pChord->m_chordsel.PropagateUseFlat();
	}

	NextChord* pNextChord = new NextChord;
	if( pNextChord == NULL )
	{
		delete pChord;
		return E_OUTOFMEMORY;
	}

	pNextChord->m_parent = pChord;
	pChord->m_nextchordlist.AddTail(pNextChord);

	ZeroMemory( &(pChord->m_rect), sizeof(pChord->m_rect) );
	ZeroMemory( &(pChord->m_lastrect), sizeof(pChord->m_lastrect) );

	((SmallChordEntry*)pChord)->m_nid = m_nIDCounter++;

	*ppChord = pChord;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CChordMapMgr IPersist

HRESULT CChordMapMgr::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CChordMapMgr IPersistStream functions

HRESULT CChordMapMgr::IsDirty()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return S_FALSE;
}

HRESULT CChordMapMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = E_FAIL;

	if( FAILED(LoadChordMapAndPalette( pIStream )) )
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT CChordMapMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return E_NOTIMPL;
}

HRESULT CChordMapMgr::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return E_NOTIMPL;
}

HRESULT CChordMapMgr::GetTimeSig(long* top, long* bottom)
{
	if(!m_pTimeline)
		return E_FAIL;

	DMUS_TIMESIGNATURE timesig;

	HRESULT hr = m_pTimeline->GetParam(GUID_TimeSignature, 0xFFFFFFFF, 0, 0, NULL, static_cast<void*>(&timesig));

	if(top && SUCCEEDED(hr))
	{
		*top = static_cast<long>(timesig.bBeatsPerMeasure);
	}

	if(bottom && SUCCEEDED(hr))
	{
		*bottom = static_cast<long>(timesig.bBeat);
	}

	return hr;
}



static void SetChordMapBits()
{

/*
	LONG    i;
	short   count = 0;

    for( i=0L ;  i<32L ;  i++ )
    {
        if( pChordMap->pattern & (1L << i) )
            count++;
    }

    if( !pChordMap->bits )
    {
        pChordMap->bits |= ChordMap_INVERT;
        if( count > 3 )
            pChordMap->bits |= ChordMap_FOUR;
        if( pChordMap->pattern & (15L << 18L) )
            pChordMap->bits |= ChordMap_UPPER;
    }
    pChordMap->bits &= ~ChordMap_COUNT;
    pChordMap->bits |= count;
*/
}

void CChordMapMgr::ClearChordMapList(void)
{
	/* m_pChordMapList is shared with CPersonality.  DON'T DELETE IT! */
	ASSERT( 0 );
}


HRESULT CChordMapMgr::LoadChordMapAndPalette( LPSTREAM pIStream /*, LPMMCKINFO pck, ChordMapExt** plstChordMap */)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pIStream != NULL );

	DWORD			cbRead = 0;
	int			cbSize;

	STATSTG	stg;
	STATFLAG stgflag = STATFLAG_NONAME;

	if(FAILED(pIStream->Stat(&stg, stgflag)))
	{
		return E_FAIL;
	}
	
	cbSize = stg.cbSize.LowPart;

	// we're going to redo the selection, so clear out the current one
	m_pSelectedConnection = NULL;	// ok, since the chordlist is managed by the personality
	m_selection = NoSelection;

	// Merely save the ChordMapList ptr. 
	if( FAILED(pIStream->Read( &m_pChordMapList, sizeof(m_pChordMapList), &cbRead )) )
	{
		m_pChordMapList = NULL;
		return E_FAIL;
	}
	cbSize -= cbRead;

	// And the palette
	if( FAILED(pIStream->Read( &m_pChordPalette, sizeof(m_pChordPalette), &cbRead )) )
	{
		m_pChordMapList = NULL;
		return E_FAIL;
	}
	cbSize -= cbRead;

	// anything left in stream --> we've got a personality key spec.
	if(cbSize > 0)
	{
		if( FAILED(pIStream->Read( &m_dwKey, sizeof(DWORD), &cbRead )) )
		{
			m_pChordMapList = NULL;
			return E_FAIL;
		}
		cbSize -= cbRead;
		// check for selection info
		if(cbSize > 0)
		{
			int selection;
			if( FAILED(pIStream->Read( &selection, sizeof(selection), &cbRead)))
			{
				m_selection = NoSelection;
				return E_FAIL;
			}
			else if(selection > 0 && selection < EndEnum)
			{
				m_selection = static_cast<CChordMapMgr::SelectionType>(selection);
			}
			else
			{
				// keep current selection
			}
			cbSize -= cbRead;
			if(cbSize > 0)
			{
				short nidToChord, nidFromChord;
				// check for connecting chords
				if( FAILED(pIStream->Read(&nidFromChord, sizeof(nidFromChord), &cbRead)))
				{
					return E_FAIL;
				}
				cbSize -= cbRead;
				if(cbSize > 0)
				{
					if(FAILED(pIStream->Read(&nidToChord, sizeof(nidToChord), &cbRead)))
					{
						return E_FAIL;
					}
					if(m_selection == ConnectionSelected)
					{
						SetUpNextChord(nidFromChord, nidToChord);
					}
					cbSize -= cbRead;
					if(cbSize > 0)
					{
						if(FAILED(pIStream->Read(&m_nSelectedIndex, sizeof(m_nSelectedIndex), &cbRead)))
						{
							return E_FAIL;
						}
						cbSize -= cbRead;
						/*
						if(cbSize > 0)
						{
							if(FAILED(pIStream->Read(&m_dblZoom, sizeof(double), &cbRead)))
							{
								return E_FAIL;
							}
							cbSize -= cbRead;
						}
						*/
					}
				}
			}
		}
	}

	// Find next Chord ID number.
	if( FAILED(FindUniqueID( &m_nIDCounter )) )
	{
		m_pChordMapList = NULL;
		return E_FAIL;
	}

	if(m_selection != ChordSelected && m_selection != ConnectionSelected && m_selection != PaletteSelected)
	{
		// clear selections
		ChordEntry* pChord = NULL;

		// Go through the Chords in the ChordList and check each connection for a hit.
		for(	pChord = m_pChordMapList->GetHead();
				pChord != NULL;
				pChord = pChord->GetNext() )
		{
			if( pChord->m_chordsel.KeyDown() == TRUE )
			{
				pChord->m_chordsel.KeyDown() = FALSE;
			}
			// clear out flags too
	//		pChord->m_dwflags = 0;
		}

		// now clear out chord palette
		for(int i = 0; i < 24; i++)
		{
			m_pChordPalette->m_chords[i].KeyDown() = false;
		}
	}
	else if (IsPropPageShowing())
	{
		bool bShow = false;
		if(m_selection == ChordSelected || m_selection == PaletteSelected)
		{
			PreparePropChord();

			if( m_pChordPropPageMgr == NULL )
			{
				HRESULT hr;
				CChordPropPageMgr* pPPM = new CChordPropPageMgr(m_pJazzFramework);
				if( NULL == pPPM ) return E_OUTOFMEMORY;
				hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pChordPropPageMgr );
				m_pChordPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
				if( FAILED(hr) )
					return hr;
			}
			m_pChordPropPageMgr->RefreshData();
			bShow = true;
		}
		else if(m_selection == ConnectionSelected)
		{
			if( m_pConnectionPropPageMgr == NULL )
			{
				HRESULT hr;
				CConnectionPropPageMgr* pPPM = new CConnectionPropPageMgr;
				if( NULL == pPPM ) return E_OUTOFMEMORY;
				hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pConnectionPropPageMgr );
				m_pConnectionPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
				if( FAILED(hr) )
					return hr;
			}
			m_pConnectionPropPageMgr->RefreshData();
			bShow = true;
		}

		if(bShow)
		{
			ShowPropPage(TRUE);
			OnShowProperties();
		}
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapMgr::FindUniqueID( /* [out] */ int* pnID )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pnID != NULL );

	(*pnID) = 0;
	for(	ChordEntry* pChord = m_pChordMapList->GetHead();
			pChord;
			pChord = pChord->GetNext() )
	{
		if( pChord->m_nid > (*pnID) )
		{
			(*pnID) = pChord->m_nid;
		}
	}
	
	(*pnID)++;			

	return S_OK;
}

// Save the ChordMaplist to a normal stream
HRESULT CChordMapMgr::SaveChordMapList( LPSTREAM pStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageObject functions

HRESULT STDMETHODCALLTYPE CChordMapMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_selection == ConnectionSelected )
	{
		ConnectionData* pConnectionData = (ConnectionData *)*ppData;

		if( m_pSelectedConnection )
		{
			VARIANT var;
			m_pChordMapStrip->GetStripProperty( (STRIPPROPERTY)666, &var );
			pConnectionData->fVariableNotFixed = V_BOOL(&var);
			pConnectionData->nWeight = m_pSelectedConnection->m_nweight;
			pConnectionData->nMinBeats = m_pSelectedConnection->m_nminbeats;
			pConnectionData->nMaxBeats = m_pSelectedConnection->m_nmaxbeats;
		}
		else
		{
			ASSERT( m_pSelectedConnection != NULL );
			return E_UNEXPECTED;
		}
	}
	else if( m_selection == ChordSelected
		 ||	 m_selection == PaletteSelected 
		 ||  m_selection == MultipleSelections
		 ||  m_selection == NoSelection )
	{
		CChordScalePropPageData* pChordScalePropPageData = (CChordScalePropPageData *)*ppData;

		pChordScalePropPageData->m_pPropChord = &m_SelectedChord;
		pChordScalePropPageData->m_fLockAllScales = true;
		pChordScalePropPageData->m_fSyncLevelOneToAll = true;

		if( m_pIChordMapNode )
		{
			IDMUSProdChordMapInfo* pIChordMapInfo;
			if( SUCCEEDED ( m_pIChordMapNode->QueryInterface( IID_IDMUSProdChordMapInfo, (void**)&pIChordMapInfo ) ) )
			{
				DMUSProdChordMapUIInfo info;
				memset( &info, 0, sizeof(DMUSProdChordMapUIInfo) );
				info.wSize = sizeof(DMUSProdChordMapUIInfo);

				if( SUCCEEDED ( pIChordMapInfo->GetChordMapUIInfo( &info ) ) )
				{
					pChordScalePropPageData->m_fLockAllScales = info.fLockAllScales ? TRUE : FALSE;
					pChordScalePropPageData->m_fSyncLevelOneToAll = info.fSyncLevelOneToAll ? TRUE : FALSE;
				}

				pIChordMapInfo->Release();
			}
		}
	}
	else
	{
		ASSERT(FALSE);
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapMgr::PropChordToChord( ChordEntry *pChord, CPropChord *pPropChord )
{
	ASSERT( pPropChord != NULL );
	ASSERT( pChord != NULL );

	if(pPropChord == NULL || pChord == NULL)
	{
		return E_INVALIDARG;
	}

	dynamic_cast<DMPolyChord&>(pChord->m_chordsel) = *dynamic_cast<DMPolyChord*>(pPropChord);
	
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapMgr::ChordToPropChord( CPropChord *pPropChord, ChordEntry *pChord )
{
	ASSERT( pPropChord != NULL );
	ASSERT( pChord != NULL );

	if(pPropChord == NULL || pChord == NULL)
	{
		return E_INVALIDARG;
	}

	ZeroMemory( pPropChord, sizeof(*pPropChord) );

	*dynamic_cast<DMPolyChord*>(pPropChord) = dynamic_cast<DMPolyChord&>(pChord->m_chordsel);

	return S_OK;
}


HRESULT STDMETHODCALLTYPE CChordMapMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	BOOL fRefresh = FALSE;
	CPropChord* pNewChord = 0;

	if( m_selection == ConnectionSelected )
	{
		ASSERT(m_pSelectedConnection);
		if(!m_pSelectedConnection)
		{
			return E_UNEXPECTED;
		}
		ConnectionData* pCon = reinterpret_cast<ConnectionData*>(pData);
		if(m_pSelectedConnection->m_nweight != pCon->nWeight)
		{
			m_pSelectedConnection->m_nweight = pCon->nWeight;
			fRefresh = TRUE;
		}
		if(m_pSelectedConnection->m_nminbeats != pCon->nMinBeats)
		{
			m_pSelectedConnection->m_nminbeats = pCon->nMinBeats;
			fRefresh = TRUE;
		}
		if(m_pSelectedConnection->m_nmaxbeats != pCon->nMaxBeats)
		{
			m_pSelectedConnection->m_nmaxbeats = pCon->nMaxBeats;
			fRefresh = TRUE;
		}
		if(fRefresh)
		{
			SendEditNotification(IDS_UNDO_EditConnection);
		}
	}
	else if( m_selection == ChordSelected
		 ||  m_selection == PaletteSelected )
	{
		CChordScalePropPageData* pChordScalePropPageData = (CChordScalePropPageData *)pData;
		pNewChord = pChordScalePropPageData->m_pPropChord;

		DWORD dwChangedFlags[DMPolyChord::MAX_POLY];
		bool bStructureChange = false;

		if( m_pIChordMapNode )
		{
			IDMUSProdChordMapInfo* pIChordMapInfo;
			if( SUCCEEDED ( m_pIChordMapNode->QueryInterface( IID_IDMUSProdChordMapInfo, (void**)&pIChordMapInfo ) ) )
			{
				DMUSProdChordMapUIInfo info;
				memset( &info, 0, sizeof(DMUSProdChordMapUIInfo) );
				info.wSize = sizeof(DMUSProdChordMapUIInfo);

				if( SUCCEEDED( pIChordMapInfo->GetChordMapUIInfo( &info ) ) )
				{
					if( pChordScalePropPageData->m_fLockAllScales != info.fLockAllScales )
					{
						fRefresh = TRUE;
						SendEditNotification( IDS_UNDO_LOCK_SCALES );
						info.fLockAllScales = pChordScalePropPageData->m_fLockAllScales;
						pIChordMapInfo->SetChordMapUIInfo( &info );
					}
					else if( pChordScalePropPageData->m_fSyncLevelOneToAll != info.fSyncLevelOneToAll )
					{
						fRefresh = TRUE;
						SendEditNotification( IDS_UNDO_SYNC_LEVELS );	
						info.fSyncLevelOneToAll = pChordScalePropPageData->m_fSyncLevelOneToAll;
						pIChordMapInfo->SetChordMapUIInfo( &info );
					}
				}
			
				pIChordMapInfo->Release();
			}
		}

		m_SelectedChord = *pNewChord;

		if( fRefresh == FALSE )
		{
			if(m_SelectedChord.GetUndetermined(m_SelectedChord.RootIndex()) & UD_FROMCHORDPALETTE)
			{
				SendEditNotification(IDS_UNDO_EditPaletteChord);	
				ChordSelection* pSel = &(m_pChordPalette->m_chords[m_nSelectedIndex]);
				// Only refresh if UI elements have changed.
				fRefresh =	((pSel->Base()->ChordRoot() != m_SelectedChord.Base()->ChordRoot())
							|| (strcmp(pSel->Name(), m_SelectedChord.Name()))
							|| pSel->Base()->UseFlat() != m_SelectedChord.Base()->UseFlat());

				for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
				{
					DMChord* pDMFrom = pNewChord->SubChord(i);
					DMChord* pDMTo = pSel->SubChord(i);

					dwChangedFlags[i] = ~pNewChord->GetUndetermined(i);

					if (dwChangedFlags[i] & UD_NAME)
					{
						strcpy(pSel->Name(), pNewChord->Name());
					}
					if (dwChangedFlags[i] & UD_CHORDPATTERN)
					{
						pDMTo->ChordPattern() = pDMFrom->ChordPattern();
					}
					if (dwChangedFlags[i] & UD_SCALEPATTERN)
					{
						pDMTo->ScalePattern() = pDMFrom->ScalePattern();
					}
					if(dwChangedFlags[i] & UD_INVERTPATTERN)
					{
						pDMTo->InvertPattern() = pDMFrom->InvertPattern();
					}
					if (dwChangedFlags[i] & UD_CHORDROOT)
					{
						pDMTo->ChordRoot() = pDMFrom->ChordRoot();
					}
					if(dwChangedFlags[i] & UD_SCALEROOT)
					{
						pDMTo->ScaleRoot() = pDMFrom->ScaleRoot();
					}
					if (dwChangedFlags[i] & UD_FLAT)
					{
						pDMTo->UseFlat() = pDMFrom->UseFlat();
					}
					if (dwChangedFlags[i] & UD_LEVELS)
					{
						pDMTo->Levels() = pDMFrom->Levels();
					}
					if (dwChangedFlags[i] & UD_INVERT)
					{
						pDMTo->Bits() &= ~CHORD_INVERT;
						pDMTo->Bits() |= (pDMFrom->Bits() & CHORD_INVERT);
					}
					if (dwChangedFlags[i] & UD_FOUR)
					{
						pDMTo->Bits() &= ~CHORD_FOUR;
						pDMTo->Bits() |= (pDMFrom->Bits() & CHORD_FOUR);
					}
					if (dwChangedFlags[i] & UD_UPPER)
					{
						pDMTo->Bits() &= ~CHORD_UPPER;
						pDMTo->Bits() |= (pDMFrom->Bits() & CHORD_UPPER);
					}
				}
			}
			else
			{
				SendEditNotification(IDS_UNDO_EditChordMapChord);	
			
				for( ChordEntry *pChord = m_pChordMapList->GetHead(); pChord != NULL; pChord = pChord->GetNext() )
				{
	//				DMChord* pdm = pChord->m_chordsel.SubChord(pChord->m_chordsel.RootIndex());
					if( pChord->m_chordsel.KeyDown() != 1 ) continue;

					
					// Only refresh if UI elements have changed.
					fRefresh =	((pChord->m_chordsel.Base()->ChordRoot() != m_SelectedChord.Base()->ChordRoot()) ||
							(strcmp(pChord->m_chordsel.Name(), m_SelectedChord.Name())) ||
							pChord->m_chordsel.Base()->UseFlat() != m_SelectedChord.Base()->UseFlat());

					for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
					{
						DMChord* pDMFrom = pNewChord->SubChord(i);
						DMChord* pDMTo = pChord->m_chordsel.SubChord(i);

						if(pChord->IsSignPost())
						{
							if(i == pNewChord->RootIndex())
							{
								bStructureChange = (pDMFrom->ChordRoot() != pDMTo->ChordRoot());
							}

							bStructureChange = bStructureChange || (pDMFrom->ChordPattern() != pDMTo->ChordPattern());
						}

						dwChangedFlags[i] = ~pNewChord->GetUndetermined(i);
						if (dwChangedFlags[i] & UD_NAME)
						{
							strcpy(pChord->m_chordsel.Name(), pNewChord->Name());
						}
						if (dwChangedFlags[i] & UD_CHORDPATTERN)
						{
							pDMTo->ChordPattern() = pDMFrom->ChordPattern();
						}
						if (dwChangedFlags[i] & UD_SCALEPATTERN)
						{
							pDMTo->ScalePattern() = pDMFrom->ScalePattern();
						}
						if(dwChangedFlags[i] & UD_INVERTPATTERN)
						{
							pDMTo->InvertPattern() = pDMFrom->InvertPattern();
						}
						if (dwChangedFlags[i] & UD_CHORDROOT)
						{
							pDMTo->ChordRoot() = pDMFrom->ChordRoot();
						}
						if(dwChangedFlags[i] & UD_SCALEROOT)
						{
							pDMTo->ScaleRoot() = pDMFrom->ScaleRoot();
						}
						if (dwChangedFlags[i] & UD_FLAT)
						{
							pDMTo->UseFlat() = pDMFrom->UseFlat();
						}
						if (dwChangedFlags[i] & UD_LEVELS)
						{
							pDMTo->Levels() = pDMFrom->Levels();
						}
						if (dwChangedFlags[i] & UD_INVERT)
						{
							pDMTo->Bits() &= ~CHORD_INVERT;
							pDMTo->Bits() |= (pDMFrom->Bits() & CHORD_INVERT);
						}
						if (dwChangedFlags[i] & UD_FOUR)
						{
							pDMTo->Bits() &= ~CHORD_FOUR;
							pDMTo->Bits() |= (pDMFrom->Bits() & CHORD_FOUR);
						}
						if (dwChangedFlags[i] & UD_UPPER)
						{
							pDMTo->Bits() &= ~CHORD_UPPER;
							pDMTo->Bits() |= (pDMFrom->Bits() & CHORD_UPPER);
						}
					}
				}
			}
		}

		if( bStructureChange )
		{
			m_pTimeline->OnDataChanged(new CheckForOrphansNotification);
		}
	}

	if( fRefresh )
	{
		m_pTimeline->StripInvalidateRect(m_pChordMapStrip, NULL, TRUE);

		if(pNewChord)
		{
			ChordChangeCallback* pCallback = new ChordChangeCallback(ChordChangeCallback::ChordMapNewSelection);
			ChordEntry* pChordEntry = new ChordEntry;
			PropChordToChord(pChordEntry, pNewChord);
			pCallback->SetChordEntry(pChordEntry);
			m_pTimeline->OnDataChanged( pCallback );
		}
		else
		{
			// chord connection has changed, just update personality
			m_pTimeline->OnDataChanged( NULL );
		}
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapMgr::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;
	if(m_selection == ChordSelected || m_selection == PaletteSelected || 
		m_selection == MultipleSelections || m_selection == NoSelection)
	{
		if( m_pChordPropPageMgr == NULL )
		{
			CChordPropPageMgr* pPPM = new CChordPropPageMgr(m_pJazzFramework);
			if( NULL == pPPM ) return E_OUTOFMEMORY;
			hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pChordPropPageMgr );
			m_pChordPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
			if( FAILED(hr) )
				return hr;
		}
		hr = m_pTimeline->SetPropertyPage(m_pChordPropPageMgr, (IDMUSProdPropPageObject*)this);
		m_pChordPropPageMgr->RefreshData();
	}
	else if(m_selection == ConnectionSelected)
	{
		if( m_pConnectionPropPageMgr == NULL )
		{
			CConnectionPropPageMgr* pPPM = new CConnectionPropPageMgr;
			if( NULL == pPPM ) return E_OUTOFMEMORY;
			hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pConnectionPropPageMgr );
			m_pConnectionPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
			if( FAILED(hr) )
				return hr;
		}
		hr = m_pTimeline->SetPropertyPage(m_pConnectionPropPageMgr, (IDMUSProdPropPageObject*)this);
		m_pConnectionPropPageMgr->RefreshData();
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CChordMapMgr::OnRemoveFromPageManager( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapMgr::PreparePropChord()
{
	BOOL	fFirst = TRUE;
	CPropChord tempChord;

	for( ChordEntry *pChord = m_pChordMapList->GetHead(); pChord != NULL; pChord = pChord->GetNext() )
	{
		// Only add selected chords to the Chord template.
		if( pChord->m_chordsel.KeyDown() != 1 ) continue;

		ZeroMemory( &tempChord, sizeof(tempChord) );

//		ChordToPropChord( &tempChord, pChord );
		dynamic_cast<DMPolyChord&>(tempChord) = dynamic_cast<DMPolyChord&>(pChord->m_chordsel);

		if( fFirst == TRUE )
		{
			ZeroMemory( &m_SelectedChord, sizeof(m_SelectedChord) );
			m_SelectedChord = tempChord;
			fFirst = FALSE;
			// m_SelectedChord.m_dwUndetermined = 0; 	// ZeroMemory() handles this.
		}
		else
		{
			tempChord.CopyToPropChord( &m_SelectedChord, CPropChord::ALL );
		}
	}

	return S_OK;
}


void CChordMapMgr::GetLastEdit(CString & str)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(m_pChordMapStrip);
	str = "";

	if(m_pChordMapStrip)
	{
		str.LoadString( m_pChordMapStrip->m_nLastEdit );
	}
}


void CChordMapMgr::SendEditNotification(UINT type)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(m_pChordMapStrip);

	if(m_pChordMapStrip)
	{
		HINSTANCE hinst = _Module.GetModuleInstance();
		TCHAR buf[256];
		m_pChordMapStrip->m_nLastEdit = type;
		::LoadString(hinst, m_pChordMapStrip->m_nLastEdit, buf, 256);
		if(strlen(buf) > 0)
		{
			PreEditNotification* pEditNotify = new PreEditNotification(buf);
			m_pTimeline->OnDataChanged( pEditNotify );
		}
		else
		{
			ASSERT(FALSE);
		}
	}
}

void CChordMapMgr::SetUpNextChord(short nidFrom, short nidTo)
{
	bool bDone = false;
	for(ChordEntry *pchord = m_pChordMapList->GetHead();
		pchord != NULL && !bDone;
		pchord = pchord->GetNext())
	{
		for(NextChord *pnext = pchord->m_nextchordlist.GetHead();
			pnext != NULL;
			pnext = pnext->GetNext()
			)
		{
			if(pnext->m_nid == nidTo && pnext->m_parent->m_nid == nidFrom)
			{
				m_pSelectedConnection = pnext;
				bDone = true;	// force break from outer loop
				break;
			}
		} 
	}
}


bool CChordMapMgr::IsPropPageShowing()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(!m_pJazzFramework)
	{
		return false;	// no framework then proppage isn't showing
	}
	/*
	if( m_pPropPageMgr == NULL )
	{
		return false;
	}
	*/

	// check PropertyPage
	IDMUSProdPropSheet* pJPS;
	bool rc = false;
	if( SUCCEEDED(m_pJazzFramework->QueryInterface( IID_IDMUSProdPropSheet,
		(void**)&pJPS )))
	{
		if(pJPS->IsShowing() == S_OK&& pJPS->IsEqualPageManagerObject((IDMUSProdPropPageObject*)this) == S_OK)
			rc = true;
		else
			rc = false;
		pJPS->Release();
	}

	return rc;

}

HRESULT CChordMapMgr::ShowPropPage(BOOL fShow)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(m_pJazzFramework);
	HRESULT hr = E_FAIL;
	if(m_pJazzFramework == NULL)
	{
		return false;
	}

	// SetPropertyPage
	if( m_pJazzFramework )
	{
		IDMUSProdPropSheet* pJPS;
		if( SUCCEEDED(hr = m_pJazzFramework->QueryInterface( IID_IDMUSProdPropSheet,
			(void**)&pJPS )))
		{
			pJPS->Show(fShow);
			pJPS->Release();
		}
	}

	return hr;

}



void CChordMapMgr::MakeCompatibleNids(ChordEntryList &list)
// makes nids of ChordEntries in list compatabile with existing chord entries
{
	int maxnid = -1;

	for(ChordEntry* pchord = list.GetHead(); pchord; pchord = pchord->GetNext())
	{
		pchord->m_nid += m_nIDCounter;
		if(maxnid < pchord->m_nid)
		{
			maxnid = pchord->m_nid;
		}
		for(NextChord* pnext = pchord->m_nextchordlist.GetHead(); pnext; pnext = pnext->GetNext())
		{
			if(pnext->m_nid > 0)
			{
				pnext->m_nid += m_nIDCounter;
				if(maxnid < pnext->m_nid)
				{
					maxnid = pnext->m_nid;
				}
			}
		}
	}
	m_nIDCounter = maxnid + 1;
}

bool CChordMapMgr::LessThan(const ChordEntry& a, const ChordEntry&b )
{
	CMusicTimeConverter cmta(a.m_chordsel.Measure(), a.m_chordsel.Beat(), m_pTimeline, m_dwGroupBits);
	CMusicTimeConverter cmtb(b.m_chordsel.Measure(), b.m_chordsel.Beat(), m_pTimeline, m_dwGroupBits);
	return cmta < cmtb;
}

bool CChordMapMgr::GreaterThan(const ChordEntry& a, const ChordEntry&b )
{
	CMusicTimeConverter cmta(a.m_chordsel.Measure(), a.m_chordsel.Beat(), m_pTimeline, m_dwGroupBits);
	CMusicTimeConverter cmtb(b.m_chordsel.Measure(), b.m_chordsel.Beat(), m_pTimeline, m_dwGroupBits);
	return cmta > cmtb;
}

long CChordMapMgr::AbsDiff(const ChordEntry& a, const ChordEntry&b)
{
	DMUS_TIMESIGNATURE dmTimeSig;
	m_pTimeline->GetParam(GUID_TimeSignature, m_dwGroupBits, 0, 0,0, &dmTimeSig);
	long beatsa = a.m_chordsel.Measure() * dmTimeSig.bBeatsPerMeasure + a.m_chordsel.Beat();
	long beatsb = b.m_chordsel.Measure() * dmTimeSig.bBeatsPerMeasure + b.m_chordsel.Beat();
	return beatsa >= beatsb ? beatsa - beatsb : beatsb - beatsa;
}

void CChordMapMgr::DetectAndReverseConnections(ChordEntryList &list)
{
	for(ChordEntry* pChord = list.GetHead(); pChord; pChord = pChord->GetNext())
	{
		NextChord* pNext = 0;
		for(pNext = pChord->m_nextchordlist.GetHead(); pNext; pNext = pNext->GetNext())
		{
			if(pNext->m_nextchord == NULL)
			{
				// this is the empty connection used for constructing new connects
				continue;
			}
			ChordEntry& parent = *(pNext->m_parent);
			ChordEntry& target = *(pNext->m_nextchord);
			if(LessThan(parent,target))
			{
				// order is ok
				continue;
			}
			if(GreaterThan(parent, target))
			{
				NextChord* pNewNext = new NextChord;
				pNewNext->m_nid = pNext->m_parent->m_nid;
				pNewNext->m_parent = pNext->m_nextchord;
				pNewNext->m_nextchord = pNext->m_parent;
				pNewNext->m_nminbeats = pNewNext->m_nmaxbeats = static_cast<short>(AbsDiff(parent, target));
				/*
				// sign post check and corrections
				if(parent.m_dwflags & CE_START)
				{
					parent.m_dwflags |= CE_END;
				}
				else if(target.m_dwflags & CE_END)
				{
					parent.m_dwflags |= CE_START;
				}
				*/
				// add new connection to target
				target.m_nextchordlist.AddHead(pNewNext);
			}
			// mark old nextchord for deletion
			pNext->m_dwflags |= NC_DELETE;
			// add new next chord to target

		}
		NextList nextlist;
		for(pNext = pChord->m_nextchordlist.RemoveHead(); pNext; pNext = pChord->m_nextchordlist.RemoveHead())
		{
			if(!(pNext->m_dwflags & NC_DELETE))
			{

				nextlist.AddTail(pNext);
			}
			else
			{
				delete pNext;
			}
		}
		pChord->m_nextchordlist.Cat(&nextlist);
	}
}


void CChordMapMgr::HitTest(RECT &rect)
{
	RECT rectSelect;
	long x;
	memcpy(&rectSelect, &rect, sizeof(RECT));


	if(rectSelect.top > rectSelect.bottom)
	{
		x = rectSelect.bottom;
		rectSelect.bottom = rectSelect.top;
		rectSelect.top = x;
	}
	if(rectSelect.left > rectSelect.right)
	{
		x = rectSelect.right;
		rectSelect.right = rectSelect.left;
		rectSelect.left = x;
	}

	for(ChordEntry* pChord = m_pChordMapList->GetHead(); pChord; pChord = pChord->GetNext())
	{
//		TRACE("bound rect:(%d,%d,%d,%d), chord upper left(%d,%d)\r\n",
//			rectSelect.left, rectSelect.top, rectSelect.right, rectSelect.bottom,
//			pChord->m_rect.left, pChord->m_rect.top);

		bool bIntersectsAtTop = (rectSelect.top < pChord->m_rect.top 
										&& pChord->m_rect.top < rectSelect.bottom);

		bool bIntersectsAtLeft = (rectSelect.left < pChord->m_rect.left 
										&& pChord->m_rect.left < rectSelect.right);

		bool bIntersectsAtBottom = (rectSelect.bottom > pChord->m_rect.bottom 
										&& pChord->m_rect.bottom > rectSelect.top);

		if(bIntersectsAtLeft && (bIntersectsAtBottom || bIntersectsAtTop))
		{
			pChord->m_chordsel.KeyDown() = TRUE;
		}
		else
		{
			pChord->m_chordsel.KeyDown() = FALSE;
		}
	}
}

void CChordMapMgr::GetBoundariesOfSelectedChords(long& lStartTime, long& lEndTime)
{
	VARIANT vtInit;
	vtInit.vt = VT_I4;
	m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &vtInit );
	long lLength = V_I4(&vtInit);

	lEndTime = 0;
	lStartTime = lLength;
	if(m_pChordMapList == 0)
		return;

	for(ChordEntry* pChord = m_pChordMapList->GetHead(); pChord; pChord = pChord->GetNext())
	{
		if(pChord->m_chordsel.KeyDown() == TRUE)
		{
			long lTime, clocksPerBeat;
			m_pTimeline->MeasureBeatToClocks(m_dwGroupBits, 0, pChord->m_chordsel.Measure(), pChord->m_chordsel.Beat(), &lTime);
			m_pTimeline->MeasureBeatToClocks(m_dwGroupBits, 0, 0, 1, &clocksPerBeat);
			lStartTime = lTime < lStartTime ? lTime : lStartTime;
			lEndTime = (lTime+clocksPerBeat) > lEndTime ? (lTime+clocksPerBeat) : lEndTime;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ChordMapMgr.h ===
// ChordMapMgr.h : Declaration of the CChordMapMgr

#ifndef __ChordMapMGR_H_
#define __ChordMapMGR_H_
#include "stdafx.h"
#include "resource.h"       // main symbols
#include "timeline.h"
#include "dmusici.h"
#include "Chord.h"
#include "chordio.h"
#include "PropChord.h"
#include "PropPageMgr.h"
#include "ConnectionPropPageMgr.h"
#include "DLLJazzDataObject.h"
//#include <AFXCMN.H>

#define CHORDNAME_MAX 12
#define WM_INSERT_CHORD (WM_USER + 51)

#ifndef __CCHORDMAPSTRIPMGRAPP__
#define __CCHORDMAPSTRIPMGRAPP__
class CChordMapStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};
#endif

/////////////////////////////////////////////////////////////////////////////
// CChordMapMgr
class ATL_NO_VTABLE CChordMapMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CChordMapMgr, &CLSID_ChordMapMgr>,
	public IChordMapMgr,
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdPropPageObject
{
friend class CChordMapStrip;
public:
	CChordMapMgr();
	~CChordMapMgr();

protected:
	void ClearChordMapList(void);

protected:
	DWORD				m_dwKey;
	IDMUSProdTimeline*	m_pTimeline;
	ChordEntryList*		m_pChordMapList;
	ChordPalette*		m_pChordPalette;
	int					m_nIDCounter;
	int					m_nSelectedIndex;
	double				m_dblZoom;
	CChordMapStrip*		m_pChordMapStrip;

	IDataObject*		m_pCopyDataObject;

	// Supports Chord and Connection Property Page.
			// TO DO: SelectedObjectType parameter in GetTypeThis should be replaced by explicit calls to determine 
			// selection type
		// Note: until then DO NOT change order of enums in CChordMapMgr
	enum SelectionType{NoSelection, PaletteSelected, ChordSelected, ConnectionSelected, 
		MultipleSelections, EndEnum}	m_selection;

	// TBD: the numeric flag below needs to be set from some const global to project ( == CPersonality::UseFlats)
	enum {UseFlats = 0x10000000 };

	CPropChord					m_SelectedChord;
	NextChord*					m_pSelectedConnection;
	IDMUSProdFramework*			m_pJazzFramework;
	CPropertyPage*				m_pPropertyPage;
	IDMUSProdPropPageManager*	m_pChordPropPageMgr;
	IDMUSProdPropPageManager*	m_pConnectionPropPageMgr;
	DWORD						m_dwGroupBits;
	IDirectMusicTrack*			m_pIDMTrack;
	IDMUSProdNode*				m_pIChordMapNode; // DocRoot node of ChordMap

public:
DECLARE_REGISTRY_RESOURCEID(IDR_CHORDMAPMGR)

BEGIN_COM_MAP(CChordMapMgr)
	COM_INTERFACE_ENTRY_IID(IID_IChordMapMgr,IChordMapMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()


BEGIN_MSG_MAP(CChordMapMgr)
END_MSG_MAP()


// IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

// IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( /* [retval][out] */ void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( /* [in] */ void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties( void);
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void);

// IChordMapMgr
public:
	void GetBoundariesOfSelectedChords(long& lStartTime, long& lEndTime);
	void HitTest(RECT& rectSelect);
	void MakeCompatibleNids(ChordEntryList& list);
	HRESULT ShowPropPage(BOOL fShow);
	bool IsPropPageShowing();
	void SendEditNotification(UINT type);
	void GetLastEdit(CString& str);

	HRESULT STDMETHODCALLTYPE CreateChordMapStrip( 
		/* [out] */ IDMUSProdStrip **ppStrip);
	HRESULT STDMETHODCALLTYPE IsParamSupported(
		/* [in] */ REFGUID		guidType);
	HRESULT STDMETHODCALLTYPE GetParam(
		/* [in] */  REFGUID		guidType,
		/* [in] */  MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME*	pmtNext,
		/* [out] */ void*		pData);
	HRESULT STDMETHODCALLTYPE SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData);
	HRESULT STDMETHODCALLTYPE OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData);
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( 
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant);
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( 
		/* [in] */ STRIPMGRPROPERTY smp,
		/* [in] */ VARIANT		variant);
	HRESULT STDMETHODCALLTYPE CreateBlankChord(
		/* [out] */ ChordEntry** ppChord );
	HRESULT STDMETHODCALLTYPE FindUniqueID(
		/* [out] */ int* pnID );
	HRESULT STDMETHODCALLTYPE PreparePropChord();
//	HRESULT STDMETHODCALLTYPE PrepareConnection();
	HRESULT STDMETHODCALLTYPE PropChordToChord(
		/* [in] */  ChordEntry *pChord,
		/* [out] */ CPropChord *pPropChord );
	HRESULT STDMETHODCALLTYPE ChordToPropChord(
		/* [in] */  CPropChord *pPropChord,
		/* [out] */ ChordEntry *pChord );

	HRESULT GetTimeSig(long* top, long* bottom);

protected:
	HRESULT LoadChordMapAndPalette( LPSTREAM pIStream /*, LPMMCKINFO pck, ChordMapExt** plstChordMap */);
	HRESULT SaveChordMapList( LPSTREAM );
	

private:
	void DetectAndReverseConnections(ChordEntryList& list);
	void SetUpNextChord(short nidFrom, short nidTo);
	bool LessThan(const ChordEntry&a, const ChordEntry&b);
	bool GreaterThan(const ChordEntry&a, const ChordEntry&b);
	long AbsDiff(const ChordEntry&a, const ChordEntry&b);
};

#include "ContextMenuHandler.h"
// String lengths
#define ROOT_TO_NAME_MAX		30

/*
#define STOP_SIGN_HEIGHT		27
#define	STOP_SIGN_WIDTH			14
#define GO_SIGN_HEIGHT			27

#define MOUSEDRAG_GRACE_X		10
#define MOUSEDRAG_GRACE_Y		10
*/

///*
#define STOP_SIGN_HEIGHT		16
#define	STOP_SIGN_WIDTH			12
#define GO_SIGN_HEIGHT			16

#define MOUSEDRAG_GRACE_X		5
#define MOUSEDRAG_GRACE_Y		5
//*/

#define	FUNCTION_NAME_HEIGHT		12

#define HORIZ_LINE_HEIGHT	1
#define PIANOROLL_BLACKKEY_COLOR	RGB( 0, 0, 0 )
#define PIANOROLL_WHITEKEY_COLOR	RGB( 255, 255, 232 )
#define PIANOROLL_SELKEY_COLOR		RGB( 255, 0, 0)


/*
#define CHORD_DEFAULT_HEIGHT 40
#define CHORD_DEFAULT_WIDTH 70  // For testing.  Real chords will use zoom factor into account for width.

#define CONNECTION_HEIGHT		15
#define CONNECTION_WIDTH		35
#define CONNECTION_SEPERATOR	15
*/

///*
#define CHORD_DEFAULT_HEIGHT 30
#define CHORD_DEFAULT_WIDTH 60  // For testing.  Real chords will use zoom factor into account for width.

#define CONNECTION_HEIGHT		6
#define CONNECTION_WIDTH		10
#define CONNECTION_SEPERATOR	6
//*/

#define CONNECTION_FILL_BACKGROUND		RGB( 204, 204, 255 )
#define CONNECTION_FILL					RGB( 192, 192, 192 )
#define CONNECTION_TEXT_COLOR			RGB( 0, 0, 0 )
#define CHORD_CONNECTION_3D_HIGHLIGHT	RGB( 255, 255, 255 )
#define CHORD_CONNECTION_3D_LOWLIGHT	RGB( 0, 0, 0 )
#define CHORD_CONNECTION_3D_FILL		RGB( 0, 64, 128 )
#define CHORD_CONNECTION_TEXT_COLOR		RGB( 255, 255, 0 )

#define CONNECTION_SEL_FILL				RGB(255,255,0)
#define CONNECTION_SEL_FILL_BACKGROUND	RGB(255,0,255)

#define CHORD_CONNECTION_3D_SEL_FILL		RGB( 255, 0, 0 )
#define CHORD_CONNECTION_3D_SEL_HIGHLIGHT	RGB( 255, 255, 0 )
#define CHORD_CONNECTION_3D_SEL_LOWLIGHT	RGB( 0, 0, 128 )


typedef void (*pfnCallback)(long hint);

struct DragState
{
	enum {off=0, left=1, right=2, up=4, down=8};	// use when scrolling outside window boundaries
	short xOrg;
	short yOrg;
	short xTo;
	short yTo;
	bool  bActive;
	bool  bAutoscroll;
	short dir;
	DragState()
	{
		xOrg = yOrg = xTo = yTo = 0;
		bActive = false;
		bAutoscroll = false;
		dir = off;
	}
};

class CChordMapStrip : public IDMUSProdStrip , 
					   public IDropTarget, 
					   public IDropSource, 
					   public IDMUSProdTimelineEdit,
					   public IDMUSProdStripFunctionBar
{
friend class CChordMapMgr;
protected:
	void ComputeSelectionBoxOutline(POINTS ptBeg, POINTS ptEnd, bool bRecomputeDragState = true);
	HRESULT RecomputeConnections( bool fChangingToVariableMode );
	HRESULT OnCommand(UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos, BOOL bRefresh, BOOL bSyncEngine, ChordEntry*&	pChordChange);
	HRESULT OnRButtonUp(UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnInsert(UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos,
								  BOOL bRefresh, BOOL bSyncEngine, ChordEntry*&	pChordChange);
	HRESULT MergeChords(ChordEntryList& list, POINTL pt, ChordEntry* pRefChord, bool bDropNotPaste);
	void GetBoundingRectRelativeToChord(ChordEntryList& list, ChordEntry* pRefChord, RECT& rect);
	void GetBoundingRect(ChordEntryList& list, RECT& rect);
	void GetBoundingRectOfSelectedChords(RECT& rect);
	long GetVerticalScroll();
	HRESULT CheckBoundsForDrag(POINTL pt, RECT* pExcess = 0);
	void	SetFocusToTimeline();
	HRESULT DoDragDrop(WPARAM wParam, LPARAM lParam, ChordEntry* pChord, ChordEntry*& pChordChange);
	bool ContainsSignpost(ChordEntryList& list);
	void PositionToMeasureBeat(long pos, long& measure, long& beat);
	void MeasureBeatToPosition(long measure, long beat, long& pos);
	void PositionToClocks(long pos, long& clocks);
	void ClocksToPosition(long clocks, long& pos);
	long ClocksPerMeasure();
	bool SelectedChordsContainsSignpost();
	long				m_cRef;
	CChordMapMgr*		m_pChordMapMgr;
	IDMUSProdStripMgr*	m_pStripMgr;
	BOOL				m_fSelected;
	BOOL				m_fDragging;
	bool				m_fCapture;
	bool				m_bDrop;
	BOOL				m_fConnectionDrag;
	RECT				m_rcScreenClip;
	BOOL				m_fVariableNotFixed;
	long				m_lFocusHint;
	pfnCallback			m_pfnFocusCallback;

	enum { ConnectionDrag = 1, SelectionDrag = 2 };
	DragState		m_SelectionDragState;
	DragState		m_ConnectionDragState;

	// bounding box select state vars
	RECT			m_rectSelect;
	RECT			m_rectBounding;
	POINTS			m_ptAnchor;
	bool	m_bInSelectionNet;

	// Kludge for messaging.
	CContextMenuHandler m_MenuHandler;

	// For rubber-band UI
	CBitmap *m_pbmpBackground;
	void GetWindowOrg(long& xpos, long& ypos);
	long	m_xOrg;
	long	m_yOrg;

	// strip size
	enum { enumMaxHeight = 2000, enumDefaultHeight = 800, enumFBWidth = 100 };

	long CChordMapStrip::GetStripHeight()
	{	
		long h = enumDefaultHeight;
		return h;
	}
	// drag drop state
	IDataObject*	m_pISourceDataObject;			// Object being dragged	
	IDataObject*	m_pITargetDataObject;
	RECT			m_rectAggregate;		// used to store boundaries of chord aggregate being dragged
											// relative to chord mouse is on top of
	DWORD			m_dwStartDragButton;	// Mouse button that initiated drag operation
	DWORD			m_dwOverDragButton;		// Mouse button stored in IDropTarget::DragOver
	DWORD			m_dwOverDragEffect;		// Drag effects stored in IDropTarget::DragOver
	CImageList*		m_pDragImage;			// Image used for drag operation feedback
	DWORD			m_dwDragRMenuEffect;	// Result from drag context menu
	UINT			m_cfChordList;
	UINT			m_cfChordMapList;
	POINTL			m_startDragPosition;	// pos where drag was started

	ChordEntry*		m_pDragChord;			// intra-chordmap chord being dragged
	POINTS			m_ptDrop;				// where a drag move or drag copy is completed
	bool			m_bInternalDrop;		// false at beg of drag and set to true if source == target

	UINT			m_nLastEdit;			// resource id of last edit

	POINTS			m_ptLastMouse;			// point at last mouse click
	POINTS			m_ptLastRightMouse;
	BOOL			m_bSelecting;
	enum { BegSignPost, EndSignPost };
	BOOL			ToggleSignPost(int BegOrEnd, POINTS where);
	double			 ZoomFactor();
	int				m_irowSaved;			// used to save last position of chords inserted from
											// from signpost grid

public:
	CChordMapStrip( CChordMapMgr* pChordMapMgr)
	{
		ASSERT( pChordMapMgr );
		RECT rect = {0,0,0,0};
		memcpy(&m_rectSelect, &rect, sizeof(RECT));
		m_pChordMapMgr = pChordMapMgr;
		m_pStripMgr = (IDMUSProdStripMgr*)pChordMapMgr;
		m_pStripMgr->AddRef();
		m_cRef = 0;
		AddRef();
		m_fSelected = FALSE;
		m_bSelecting = FALSE;
		m_fDragging = FALSE;
		m_bInSelectionNet = false;
		m_bDrop = false;
		m_fCapture = false;
		m_fConnectionDrag = FALSE;
//		m_fVariableNotFixed = FALSE;
		m_fVariableNotFixed = TRUE;
		ZeroMemory( &m_rcScreenClip, sizeof(m_rcScreenClip) );
		m_pbmpBackground = NULL;
		m_MenuHandler.CreateEx(0L, NULL, "Hidden command strip menu handler",
							   WS_POPUP | WS_CHILD, rect, NULL, 0, NULL);


		m_lFocusHint = 0;
		m_pfnFocusCallback = 0;

		m_nLastEdit = 0;

		m_xOrg = m_yOrg = 0;

		m_irowSaved = 0;

		m_pITargetDataObject = 0;
		m_pISourceDataObject = 0;
		m_bInternalDrop = false;
		m_dwStartDragButton = 0;
		m_dwOverDragButton = 0;
		m_dwOverDragEffect = 0;
		m_pDragImage = 0;
	};

	~CChordMapStrip()
	{
		if(IsWindow(m_MenuHandler.m_hWnd))
		{
			//m_MenuHandler.DestroyWindow();
			::DestroyWindow( m_MenuHandler.m_hWnd );
		}

		ASSERT( m_pStripMgr );
		m_pStripMgr->Release();	
		
		ASSERT( m_pbmpBackground == NULL ); // MUST be NULL or Connection drag is leaking.
	}

// IUnknown
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
// IDMUSProdStrip
public:
	HRESULT	STDMETHODCALLTYPE	Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
    HRESULT STDMETHODCALLTYPE	GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
    HRESULT STDMETHODCALLTYPE	SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE	OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

	// IDMUSProdStripFunctionBar
	HRESULT	STDMETHODCALLTYPE	FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE	FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

	// helpers for IDMUSProdStripFunctionBar
	void	DrawFunctionBar( HDC hDC, STRIPVIEW sv );


// IChordMapStrip
public:
	HRESULT STDMETHODCALLTYPE	SetChordXY( ChordEntry* pChord, POINTS& Point );
	HRESULT STDMETHODCALLTYPE	GetClickedChord( POINTS& Point, ChordEntry** ppChord );
	HRESULT STDMETHODCALLTYPE	GetClickedConnection( POINTS& Point, ChordEntry** ppChord, ChordEntry** ppNextChord );
	HRESULT STDMETHODCALLTYPE	CountConnections( ChordEntry* pChord, int* pnCount );
	HRESULT STDMETHODCALLTYPE	ConnectionToChord( NextChord* pNextChord, ChordEntry** ppChord );
	HRESULT STDMETHODCALLTYPE	ChordFromID( int nID, ChordEntry** ppChord );
	HRESULT STDMETHODCALLTYPE	DrawConnectionBoxes( CDC& cDC, ChordEntry* pChord, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE	DrawChord( CDC& cDC, ChordEntry* pChord, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE	SetNewChordXY( POINTS& DropPoint );
	HRESULT STDMETHODCALLTYPE	ClearSelectedChords();
	HRESULT STDMETHODCALLTYPE	GetNumSelections( int* pnSelected = NULL );
	HRESULT STDMETHODCALLTYPE	AddConnection( ChordEntry* pFromChord, ChordEntry* pToChord );
	HRESULT STDMETHODCALLTYPE	ClearDragRes();
	HRESULT STDMETHODCALLTYPE	DoPropertyPage( enum CChordMapMgr::SelectionType selection, BOOL fShow = FALSE );
	HRESULT STDMETHODCALLTYPE	DelSelChords();
	HRESULT STDMETHODCALLTYPE	DelSelConnections();
	HRESULT STDMETHODCALLTYPE	DeleteAllConnections( int nID );
	HRESULT STDMETHODCALLTYPE	DeleteConnection(NextChord* pNextChord);
	HRESULT	STDMETHODCALLTYPE	SetSelectedConnection(NextChord* pNextChord);
	HRESULT STDMETHODCALLTYPE	ResolveConnections();
	HRESULT	STDMETHODCALLTYPE	SyncRectToMeasureBeat( ChordEntry* pChord );

// IDMUSProdTimelineEdit
	HRESULT STDMETHODCALLTYPE Cut( /* in */ /* out */ IDMUSProdTimelineDataObject *pIDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Copy( /* in */ /* out */ IDMUSProdTimelineDataObject *pIDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( /* in */ IDMUSProdTimelineDataObject* pIDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pIDataObject = NULL );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// Overloaded copy
	HRESULT Copy( IDMUSProdTimelineDataObject *pITimelineDataObject, int index );

	// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

	// IDropSource
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );
	
	// IDropSource helpers
	CImageList* CreateDragImage();
	HRESULT		CreateDataObject(IDataObject**, POINTS where);
	HRESULT		CreateDataObject(IDataObject** ppIDataObject, int index);
	HRESULT SaveSelectedChords(LPSTREAM, ChordEntry* pChordAtDragPoint, BOOL bNormalize = FALSE);
	HRESULT SaveSelectedChordItems(LPSTREAM, ChordEntry* pChordAtDragPoint, BOOL bNormalize = FALSE);
	void MarkSelectedChords(DWORD flags);
	void UnMarkChords(DWORD flags);
	void UnMarkChords(ChordEntryList& list, DWORD flags);
	// deletes chords marked by given flag
	void DeleteMarkedChords(DWORD flags);
	ChordEntry* FirstSelectedChord();

	// scrolling helpers
	long	LeftEdge();
	long	RightEdge();
	HRESULT	ScrollHoriz(long pos);
	HRESULT ScrollVert(long pos);

	// added jmf 8/8/97
	HRESULT STDMETHODCALLTYPE	ComputeChordMap();
	HRESULT STDMETHODCALLTYPE	ComputeChord( ChordEntry* pChord );
	HRESULT STDMETHODCALLTYPE	ComputeConnectionBoxes( ChordEntry* pChord );

	BOOL ProcessKey(int nVirtKey, unsigned long lKeyData);
	BOOL ProcessOnSize();
	void SetFocus();
	HRESULT InsertNewChord(POINTS ptWhere, ChordEntry*& pChord);
    void RenumberIDs();    // Renumber all connection IDs.


	// DropTarget helpers
	CWnd* GetTimelineCWnd();
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT ChordEntryPasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, POINTL pt, bool bDropNotEditPaste);
	HRESULT ChordItemPasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, POINTL pt, bool bDropNotEditPaste);
	HRESULT FBPasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, POINTL pt, bool bDropNotEditPaste);
	HRESULT InsertChords(CChordList& list, POINTL pt);
	HRESULT NormalizeChordList(ChordEntryList& list, long beatOffset, 
								long* firstMeasure=0, long* firstBeat=0,
								long* lastMeasure=0, long* lastBeat=0);
	HRESULT NormalizeChordList(CChordList& list, long beatOffset, 
								long* firstMeasure=0, long* firstBeat=0,
								long* lastMeasure=0, long* lastBeat=0);
	void InternalMove(POINTS ptDrop);
	ChordEntry* InternalCopy(POINTS ptDrop);
	// other helpers
	int PaletteChordIndexFromCoords( POINTS pt);
	void ClearPaletteSelections();
	void ClearSelectedConnections();
	void FindYPositionForChord(short xpos, short& ypos, bool bUpdatePosition);
	BOOL IntersectsChordInMap(CRect& rect);
	HRESULT DragConnection(LPARAM lParam, POINTS ptMouseDown);
	void UpdateAutoScroll(DragState* pDragState);
};

typedef enum tagPIANO_KEY_COLOR
{
	WHITE,
	BLACK
} PIANO_KEY_COLOR;
const PIANO_KEY_COLOR PianoKeyColor[] = {
	WHITE,BLACK,WHITE,BLACK,WHITE,WHITE,BLACK,WHITE,BLACK,WHITE,BLACK,WHITE };



#endif //__ChordMapMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ConnectionPropPage.cpp ===
// ConnectionPropPage.cpp : implementation file
//

#include "stdafx.h"
#include "chordmapstripmgr.h"
#include "ConnectionPropPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConnectionPropPage property page

IMPLEMENT_DYNCREATE(CConnectionPropPage, CPropertyPage)

CConnectionPropPage::CConnectionPropPage() : CPropertyPage(CConnectionPropPage::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	//{{AFX_DATA_INIT(CConnectionPropPage)
	//}}AFX_DATA_INIT

	m_nWeight = 0;
	m_nMinBeats = 1;
	m_nMaxBeats = 1;
	m_fNeedToDetach = FALSE;
}

CConnectionPropPage::~CConnectionPropPage()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
}

void CConnectionPropPage::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConnectionPropPage)
	DDX_Control(pDX, IDC_SPIN_MINBEATS, m_spinMinBeats);
	DDX_Control(pDX, IDC_SPIN_MAXBEATS, m_spinMaxBeats);
	DDX_Control(pDX, IDC_EDIT_MINBEATS, m_editMinBeats);
	DDX_Control(pDX, IDC_EDIT_MAXBEATS, m_editMaxBeats);
	DDX_Control(pDX, IDC_SPINWEIGHT, m_spinWeight);
	DDX_Control(pDX, IDC_EDITWEIGHT, m_editWeight);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConnectionPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CConnectionPropPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_UPDATE(IDC_EDITWEIGHT, OnUpdateEditweight)
	ON_EN_KILLFOCUS(IDC_EDIT_MAXBEATS, OnKillFocusEditMaxBeats)
	ON_EN_KILLFOCUS(IDC_EDIT_MINBEATS, OnKillFocusEditMinBeats)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MAXBEATS, OnDeltaPosSpinMaxBeats)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MINBEATS, OnDeltaPosSpinMinBeats)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConnectionPropPage message handlers

BOOL CConnectionPropPage::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CPropertyPage::OnInitDialog();
	
	m_editWeight.SetLimitText(3);
	m_editMinBeats.SetLimitText(3);
	m_editMaxBeats.SetLimitText(3);
	m_spinWeight.SetRange(0,100);
	m_spinMinBeats.SetRange(1, 100);
	m_spinMaxBeats.SetRange(1, 100);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CConnectionPropPage::SetConnection(short val)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ::IsWindow( m_spinWeight.m_hWnd ) == FALSE )
	{
		return;
	}

	ASSERT(val <= 100);
	if(val <= 100)
	{
		m_spinWeight.SetPos(val);
		CString str;
		str.Format("%d", val);
		m_editWeight.SetWindowText(str);
		m_nWeight = val;
	}
}

void CConnectionPropPage::SetMinBeats(short val)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ::IsWindow( m_spinMinBeats.m_hWnd ) == FALSE )
	{
		return;
	}
	
	m_spinMinBeats.SetPos(val);
	CString str;
	str.Format("%d", val);
	m_editMinBeats.SetWindowText(str);
	m_nMinBeats = val;
}

void CConnectionPropPage::SetMaxBeats(short val)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ::IsWindow( m_spinMaxBeats.m_hWnd ) == FALSE )
	{
		return;
	}

	m_spinMaxBeats.SetPos(val);
	CString str;
	str.Format("%d", val);
	m_editMaxBeats.SetWindowText(str);
	m_nMaxBeats = val;
}

void CConnectionPropPage::SetMinMaxEdit(BOOL fEnable)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_editMaxBeats.EnableWindow(fEnable);
	m_editMinBeats.EnableWindow(fEnable);
	m_spinMaxBeats.EnableWindow(fEnable);
	m_spinMinBeats.EnableWindow(fEnable);

	if( fEnable == FALSE )
	{
		m_editMaxBeats.SetWindowText( NULL );
		m_editMinBeats.SetWindowText( NULL );
	}
}

int CConnectionPropPage::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	return 0;
}

void CConnectionPropPage::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();	
}

BOOL CConnectionPropPage::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	return CPropertyPage::OnSetActive();
}

void CConnectionPropPage::OnUpdateEditweight() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ::IsWindow( m_editWeight.m_hWnd ) == FALSE )
	{
		return;
	}

	char chNum[50];
	m_editWeight.GetWindowText(chNum, 50);
	short nWeight = atoi(chNum);

	if(nWeight > 100)
	{
		SetConnection(m_nWeight);
	}
	else
	{
		m_nWeight = nWeight;
		if (m_pPropPageMgr)
		{
			m_pPropPageMgr->UpdateObjectWithTabData();
		}
	}
	
}

void CConnectionPropPage::OnKillFocusEditMinBeats() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ::IsWindow( m_editMinBeats.m_hWnd ) == FALSE )
	{
		return;
	}

	CString strMinBeats;
	m_editMinBeats.GetWindowText( strMinBeats );

	// Strip leading and trailing spaces
	strMinBeats.TrimRight();
	strMinBeats.TrimLeft();

	if( strMinBeats.IsEmpty() )
	{
		SetMinBeats( m_nMinBeats );
	}
	else
	{
		short nNewMinBeats = _ttoi( strMinBeats );

		nNewMinBeats = max( 1, nNewMinBeats );
		nNewMinBeats = min( m_nMaxBeats, nNewMinBeats );

		if( m_nMinBeats != nNewMinBeats )
		{
			m_nMinBeats = nNewMinBeats;
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->UpdateObjectWithTabData();
			}
		}

		SetMinBeats( m_nMinBeats );
	}
}

void CConnectionPropPage::OnDeltaPosSpinMinBeats(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ::IsWindow( m_spinMinBeats.m_hWnd ) == FALSE )
	{
		return;
	}

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	if( HIWORD(m_spinMinBeats.GetPos()) == 0 )
	{
		int nNewMinBeats = m_nMinBeats + pNMUpDown->iDelta;

		nNewMinBeats = max( 1, nNewMinBeats );
		nNewMinBeats = min( m_nMaxBeats, nNewMinBeats );

		if( m_nMinBeats != nNewMinBeats )
		{
			m_nMinBeats = nNewMinBeats;
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->UpdateObjectWithTabData();
			}
		}

		SetMinBeats( m_nMinBeats );
	}
	
	*pResult = 1;
}

void CConnectionPropPage::OnKillFocusEditMaxBeats() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ::IsWindow( m_editMaxBeats.m_hWnd ) == FALSE )
	{
		return;
	}

	CString strMaxBeats;
	m_editMaxBeats.GetWindowText( strMaxBeats );

	// Strip leading and trailing spaces
	strMaxBeats.TrimRight();
	strMaxBeats.TrimLeft();

	if( strMaxBeats.IsEmpty() )
	{
		SetMaxBeats( m_nMaxBeats );
	}
	else
	{
		short nNewMaxBeats = _ttoi( strMaxBeats );

		nNewMaxBeats = max( m_nMinBeats, nNewMaxBeats );

		if( m_nMaxBeats != nNewMaxBeats )
		{
			m_nMaxBeats = nNewMaxBeats;
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->UpdateObjectWithTabData();
			}
		}

		SetMaxBeats( m_nMaxBeats );
	}
}

void CConnectionPropPage::OnDeltaPosSpinMaxBeats(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ::IsWindow( m_spinMaxBeats.m_hWnd ) == FALSE )
	{
		return;
	}

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	if( HIWORD(m_spinMaxBeats.GetPos()) == 0 )
	{
		int nNewMaxBeats = m_nMaxBeats + pNMUpDown->iDelta;

		nNewMaxBeats = max( m_nMinBeats, nNewMaxBeats );

		if( m_nMaxBeats != nNewMaxBeats )
		{
			m_nMaxBeats = nNewMaxBeats;
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->UpdateObjectWithTabData();
			}
		}

		SetMaxBeats( m_nMaxBeats );
	}
	
	*pResult = 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ConnectionPropPage.h ===
#if !defined(AFX_CONNECTIONPROPPAGE_H__B9C5C49F_8240_11D1_984C_00805FA67D16__INCLUDED_)
#define AFX_CONNECTIONPROPPAGE_H__B9C5C49F_8240_11D1_984C_00805FA67D16__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ConnectionPropPage.h : header file
//

#include "resource.h"
#include "connectionproppagemgr.h"


/////////////////////////////////////////////////////////////////////////////
// CConnectionPropPage dialog

class CConnectionPropPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CConnectionPropPage)

// Construction
public:
	void SetConnection(short val);
	void SetMinBeats(short val);
	void SetMaxBeats(short val);
	void SetMinMaxEdit(BOOL fEnable);
	CConnectionPropPage();
	~CConnectionPropPage();
	CConnectionPropPageMgr* m_pPropPageMgr;

	short m_nWeight;
	short m_nMinBeats;
	short m_nMaxBeats;
	BOOL  m_fVariableNotFixed;

// Dialog Data
	//{{AFX_DATA(CConnectionPropPage)
	enum { IDD = IDD_CONNECTION_PROPAGE };
	CSpinButtonCtrl	m_spinMinBeats;
	CSpinButtonCtrl	m_spinMaxBeats;
	CEdit	m_editMinBeats;
	CEdit	m_editMaxBeats;
	CSpinButtonCtrl	m_spinWeight;
	CEdit	m_editWeight;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CConnectionPropPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL	m_fNeedToDetach;

	// Generated message map functions
	//{{AFX_MSG(CConnectionPropPage)
	virtual BOOL OnInitDialog();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnUpdateEditweight();
	afx_msg void OnKillFocusEditMaxBeats();
	afx_msg void OnKillFocusEditMinBeats();
	afx_msg void OnDeltaPosSpinMaxBeats(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinMinBeats(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONNECTIONPROPPAGE_H__B9C5C49F_8240_11D1_984C_00805FA67D16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ChordMapStrip.cpp ===
// ChordMapStrip.cpp : Implementation of CChordMapStrip
#include "stdafx.h"
#include <math.h>
#include "ChordMapStripMgr.h"
#include "chordio.h"
#include "ChordMapMgr.h"
#include "..\shared\RiffStrm.h"
#include "chorddatabase.h"

extern CChordMapStripMgrApp theApp;

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CChordMapStrip helpers


inline BOOL IsDeleteKey(int nVirtKey, unsigned long lKeyData)
{
	if(nVirtKey == VK_DELETE)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

inline BOOL IsCutKey(int nVirtKey, unsigned long lKeyData)
{
	if(::GetKeyState(VK_CONTROL))
	{
		TRACE("Keycode = %x\n", nVirtKey);
	}
	return FALSE;
}

inline BOOL IsInsertKey(int nVirtKey, unsigned long lKeyData)
{
	DWORD dwInsert = 0x01000000;
	if((nVirtKey == 45) && (lKeyData & dwInsert))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}



/////////////////////////////////////////////////////////////////////////////
// CChordMapStrip IUnknown
STDMETHODIMP CChordMapStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( ppv );
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip*) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDropTarget))
	{
		*ppv = (IDropTarget *) this;
	}
	else if (IsEqualIID(riid, IID_IDropSource))
	{
		*ppv = (IDropSource *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdTimelineEdit))
	{
		*ppv = (IDMUSProdTimelineEdit *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
		*ppv = (IDMUSProdStripFunctionBar *) this;
	}

	else
	{
		return E_NOTIMPL;
	}
    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CChordMapStrip::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CChordMapStrip::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CChordMapStrip IDMUSProdStrip
/*
static const char astrRootNote[12][3] =
{
	"C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"
};
*/

HRESULT	STDMETHODCALLTYPE CChordMapStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CDC	dc;

	if( m_pChordMapMgr->m_pTimeline )
	{
		m_pChordMapMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, m_pChordMapMgr->m_dwGroupBits, 0, lXOffset );
		if( dc.Attach(hDC) )
		{
			ChordEntry*	pChord;
			RECT		rcChord;

			dc.GetClipBox( &m_rcScreenClip );
			
			dc.SetBkMode( TRANSPARENT );
			// Sync all chords in ChordMapPane
			if( (pChord = m_pChordMapMgr->m_pChordMapList->GetHead()) != NULL )
			{		
				while( pChord ) //( ( pChord ) && (lPosition - lXOffset < rcScreenClip.right) )
				{
					SyncRectToMeasureBeat(pChord );
					
					pChord = pChord->GetNext();
				}
			}

			// Draw Chords in ChordMap Pane
			if( (pChord = m_pChordMapMgr->m_pChordMapList->GetHead()) != NULL )
			{
				COLORREF	crPrevBkColor = dc.SetBkColor( CHORD_CONNECTION_3D_FILL ),
							crPrevForColor = dc.SetTextColor( CHORD_CONNECTION_TEXT_COLOR );
				
				while( pChord ) //( ( pChord ) && (lPosition < rcScreenClip.right) )
				{
					rcChord.left = pChord->m_rect.left;
					rcChord.right = pChord->m_rect.right;
					rcChord.top = pChord->m_rect.top;
					rcChord.bottom = pChord->m_rect.bottom;

					// Display Chord Box.
					DrawChord( dc, pChord, lXOffset );
					
					DrawConnectionBoxes( dc, pChord, lXOffset );
					
					pChord = pChord->GetNext();
				}
				dc.SetBkColor( crPrevBkColor );
				dc.SetTextColor( crPrevForColor );
			}

			// if dragging a connection, draw the line
			if(m_ConnectionDragState.bActive)
			{
				dc.MoveTo(m_ConnectionDragState.xOrg-lXOffset, m_ConnectionDragState.yOrg);
				dc.LineTo(m_ConnectionDragState.xTo, m_ConnectionDragState.yTo);
//				TRACE("\nline to: (%d,%d)", m_ConnectionDragState.xTo, m_ConnectionDragState.yTo);
			}

			// if dragging selection box, draw the line
			if(m_SelectionDragState.bActive)
			{
				/* swapped in ComputeSelectionBoxOutline
				RECT rect;
				if(m_rectBounding.left > m_rectBounding.right)
				{
					rect.left = m_rectBounding.right;
					rect.right = m_rectBounding.left;
				}
				else
				{
					rect.left = m_rectBounding.left;
					rect.right = m_rectBounding.right;
				}
				if(m_rectBounding.top > m_rectBounding.bottom)
				{
					rect.top = m_rectBounding.bottom;
					rect.bottom = m_rectBounding.top;
				}
				else
				{
					rect.top = m_rectBounding.top;
					rect.bottom = m_rectBounding.bottom;
				}
				*/
//				TRACE("top edge: %x bottom edge: %x\r\n", m_rectBounding.top, m_rectBounding.bottom);
				dc.DrawFocusRect(&m_rectBounding);
			}

			dc.Detach();
		}
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case SP_RESIZEABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE; 
		break;
	case SP_GUTTERSELECTABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;
	case SP_MINMAXABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;
	case SP_MAXHEIGHT:
		pvar->vt = VT_INT;
		V_INT(pvar) = enumMaxHeight;
		break;
	case SP_DEFAULTHEIGHT:
		pvar->vt = VT_INT;
		V_INT(pvar) = enumDefaultHeight;
		break;

case 666:	// whether strip uses variable mode or fixed time mode for chord placement
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = m_fVariableNotFixed;
		break;
	case WM_USER+1:	// change later to SP_USER+1, also change 666 to SP_USER
		pvar->vt = VT_INT;
		V_INT(pvar) = (long)m_pfnFocusCallback;
		break;
	case WM_USER+2:
		pvar->vt = VT_INT;
		V_INT(pvar) = m_lFocusHint;
		break;
	default:
		return E_FAIL;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( sp )
	{
	case SP_BEGINSELECT:
		break;
	case SP_ENDSELECT:
		break;
	case SP_GUTTERSELECT:
		m_pChordMapMgr->m_pTimeline->StripInvalidateRect( this, NULL, TRUE );
		m_fSelected = V_BOOL(&var);
		break;
	case 666:	// whether strip uses variable mode or fixed time mode for chord placement
		m_fVariableNotFixed = V_BOOL(&var);
		break;
	case WM_USER+1:	// change later to SP_USER+1, also change 666 to SP_USER
		m_pfnFocusCallback = (pfnCallback)V_INT(&var);
		break;
	case WM_USER+2:
		m_lFocusHint = V_INT(&var);
		break;
	default:
		return E_FAIL;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::SyncRectToMeasureBeat( ChordEntry* pChord )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pChordMapMgr != NULL );
	ASSERT( m_pChordMapMgr->m_pTimeline != NULL );

	LONG lPosition;

	// Get LeftX of Chord Box and use existing Y of ChordBox.
	if( FAILED(m_pChordMapMgr->m_pTimeline->MeasureBeatToPosition( m_pChordMapMgr->m_dwGroupBits, 0,
														pChord->m_chordsel.Measure(),
														pChord->m_chordsel.Beat(),
														&lPosition )) )
	{
		return E_FAIL;
	}

	pChord->m_rect.left		= (short)lPosition;
	pChord->m_rect.right	= (short)lPosition + CHORD_DEFAULT_WIDTH;

	// When Chord box needs to be made larger to hold connection boxes then add the code here.

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::SetChordXY( ChordEntry* pChord, POINTS& Point )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	LONG	lMeasureX, lMeasure, lBeat;

	ASSERT( m_pChordMapMgr != NULL );
	ASSERT( m_pChordMapMgr->m_pTimeline != NULL );

	// If this is an Ending or Beginning Chord then snap to measure boundary
	// Connecting Chords snap to beat boundaries.
	m_pChordMapMgr->m_pTimeline->PositionToMeasureBeat( m_pChordMapMgr->m_dwGroupBits, 0, Point.x, &lMeasure, &lBeat );

	if( (pChord->m_dwflags & CE_START) || (pChord->m_dwflags & CE_END) )
	{
		lBeat = 0;
	}
	m_pChordMapMgr->m_pTimeline->MeasureBeatToPosition( m_pChordMapMgr->m_dwGroupBits, 0, lMeasure, lBeat, &lMeasureX );

	// Set default Chord widths here (for default).  <m_rect.right would become Position units away from m_rect.left>

	pChord->m_rect.left		= (short)lMeasureX;
	pChord->m_rect.right	= (short)lMeasureX + CHORD_DEFAULT_WIDTH;
	pChord->m_rect.top		= Point.y;
	pChord->m_rect.bottom	= Point.y + CHORD_DEFAULT_HEIGHT;

	pChord->m_lastrect.left		= 0;
	pChord->m_lastrect.right	= 0;
	pChord->m_lastrect.top		= 0;
	pChord->m_lastrect.bottom	= 0;

	pChord->m_chordsel.Measure() = (short)lMeasure;
	pChord->m_chordsel.Beat() = (char)lBeat;

	return hr;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::GetClickedChord( POINTS& Point, ChordEntry** ppChord )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if(ppChord == NULL)
		return E_UNEXPECTED;
	ChordEntry*	pChord = NULL;
	*ppChord = NULL;
	
//	ASSERT( ppChord != NULL );	// Assert that we have a valid address to store the found Chord.


	// Find Last Selected Chord in ChordList...Last Selected chord is last drawn so it
	// should be on top of the Z-order
	for(	pChord = m_pChordMapMgr->m_pChordMapList->GetHead();
			pChord != NULL;
			pChord = pChord->GetNext() )
	{
		if( (Point.x >= pChord->m_rect.left && Point.x <= pChord->m_rect.right) &&
			(Point.y >= pChord->m_rect.top && Point.y <= pChord->m_rect.bottom) )
		{
			*ppChord = pChord;
		}
	}


	return (*ppChord==NULL)?E_FAIL:S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::ClearDragRes()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// The Drag Resources do not need to be cleared.
	if( m_pbmpBackground == NULL )
	{
		return S_FALSE;
	}

	m_pbmpBackground->DeleteObject();
	delete m_pbmpBackground;
	m_pbmpBackground = NULL;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::DeleteAllConnections( int nID )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	// Delete Connection
	for(ChordEntry *pchord = m_pChordMapMgr->m_pChordMapList->GetHead();
		pchord != NULL;
		pchord = pchord->GetNext())
	{
		for(NextChord *pnext = pchord->m_nextchordlist.GetHead();
			pnext != NULL;
			)
		{
			// Delete all connections to the newly removed Chord.
			if( pnext->m_nid == nID )
			{
				NextChord* ptemp = pnext->GetNext();
				pchord->m_nextchordlist.Remove(pnext);
				delete pnext;
				pnext = ptemp;
			}
			else
			{
				pnext->m_nextchord = NULL;
				pnext = pnext->GetNext();
			}
		} 
	}
	m_pChordMapMgr->m_selection = CChordMapMgr::NoSelection;
	DoPropertyPage(m_pChordMapMgr->m_selection);

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::DeleteConnection( NextChord* pNextChord )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	pNextChord->m_parent->m_nextchordlist.Remove(pNextChord);
	delete pNextChord;
	return S_OK;
}

void CChordMapStrip::RenumberIDs()
{
	m_pChordMapMgr->m_nIDCounter = 1;
	
	// Assign numbers to all chords
	ChordEntry* pchord = m_pChordMapMgr->m_pChordMapList->GetHead();  
	for( ;  pchord ;  pchord = pchord->GetNext() )
	{ 
		pchord->m_nid = m_pChordMapMgr->m_nIDCounter++;
	}
	
	// Sync connecting chords
	pchord = m_pChordMapMgr->m_pChordMapList->GetHead();  
	for( ;  pchord ;  pchord = pchord->GetNext() )
	{ 
		NextChord* pnext = pchord->m_nextchordlist.GetHead();
		for( ;  pnext ;  pnext = pnext->GetNext() )
		{
			if( pnext->m_nextchord )
			{
				pnext->m_nid = pnext->m_nextchord->m_nid;
			}
		} 
	}
}


HRESULT STDMETHODCALLTYPE CChordMapStrip::ResolveConnections()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	for(ChordEntry *pchord = m_pChordMapMgr->m_pChordMapList->GetHead();
		pchord != NULL;
		pchord = pchord->GetNext())
	{
		for(NextChord *pnext = pchord->m_nextchordlist.GetHead();
			pnext != NULL;
			pnext = pnext->GetNext())
		{
			pnext->m_nextchord = NULL;
		} 
	}

	pchord = m_pChordMapMgr->m_pChordMapList->GetHead();   
	for (;pchord;pchord = pchord->GetNext())
	{
		NextChord *pnext = pchord->m_nextchordlist.GetHead();
		for (;pnext;pnext = pnext->GetNext())
		{
			if (pnext->m_nid)
			{
				ChordEntry *pconnect = m_pChordMapMgr->m_pChordMapList->GetHead();   
				for (;pconnect;pconnect = pconnect->GetNext())
				{
                	if (pconnect->m_nid == pnext->m_nid) break;
				}
				pnext->m_nextchord = pconnect;
			}
		} 
	}
	
	// Renumber connection ids
	RenumberIDs();

	return S_OK;
}

HRESULT	STDMETHODCALLTYPE CChordMapStrip::SetSelectedConnection(NextChord* pNextChord)
{
	if(pNextChord)
	{
		m_pChordMapMgr->m_pSelectedConnection = pNextChord;
		m_pChordMapMgr->m_selection = CChordMapMgr::ConnectionSelected;
	}
	else
	{
		m_pChordMapMgr->m_pSelectedConnection = NULL;
		m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::DelSelChords()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = E_FAIL;
	
	bool bCheckForOrphans = false;

	bool bDelete = GetNumSelections() == S_OK;
	if(bDelete)
	{
		// need to send notify before deleting chords
		m_pChordMapMgr->SendEditNotification(IDS_UNDO_DeleteChord);
	}

	for( ChordEntry *pChord = m_pChordMapMgr->m_pChordMapList->GetHead();
		 pChord != NULL;
	   )
	{
		// This Chord is not selected to be deleted.  Get the next chord in the list and continue.
		if( !pChord->m_chordsel.KeyDown() )
		{
			pChord = pChord->GetNext();
			continue;
		}

		// Delete the Chord and get the next chord in the list.
		int nOldID = pChord->m_nid;
		m_pChordMapMgr->m_pChordMapList->Remove(pChord);
		if(pChord->IsSignPost())
		{
			bCheckForOrphans = true;
		}
		bDelete = true;
		delete pChord;
		pChord = m_pChordMapMgr->m_pChordMapList->GetHead();
		
		// Remove all Connections to this Chord ID
		DeleteAllConnections( nOldID );

		// Resolve connections
		ResolveConnections();
	}

	// make sure all selections are nullified
	ClearSelectedChords();
	ClearSelectedConnections();
	m_pChordMapMgr->m_selection = CChordMapMgr::NoSelection;
	m_pChordMapMgr->m_SelectedChord.RootIndex() = DMPolyChord::INVALID;
	DoPropertyPage(m_pChordMapMgr->m_selection);

	if(bCheckForOrphans)
	{
		m_pChordMapMgr->m_pTimeline->OnDataChanged(new CheckForOrphansNotification);
	}


	return hr;

}

HRESULT STDMETHODCALLTYPE CChordMapStrip::DelSelConnections()
// currently only connects THE selected connection
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;

	if(m_pChordMapMgr->m_pSelectedConnection && m_pChordMapMgr->m_pSelectedConnection->m_nextchord)
	{
		m_pChordMapMgr->SendEditNotification(IDS_UNDO_RemoveConnection);
		DeleteConnection(m_pChordMapMgr->m_pSelectedConnection);
		m_pChordMapMgr->m_pSelectedConnection = NULL;
		m_pChordMapMgr->m_selection = CChordMapMgr::NoSelection;
		m_pChordMapMgr->m_SelectedChord.RootIndex() = DMPolyChord::INVALID;
		DoPropertyPage(m_pChordMapMgr->m_selection);
	}

	return hr;

}

BOOL CChordMapStrip::ProcessOnSize()
{
	TRACE("Process On Size\n");
	VARIANT			var;
	m_pChordMapMgr->m_pTimeline->GetTimelineProperty(TP_MAXIMUM_HEIGHT, &var);
	int h = V_I4(&var);
	h = h > enumDefaultHeight ? h : enumDefaultHeight;
	V_I4(&var) = h;
	BOOL b = SUCCEEDED(m_pChordMapMgr->m_pTimeline->StripSetTimelineProperty((IDMUSProdStrip*)this, STP_HEIGHT, var));
	ASSERT(b);
	return b;
}

#ifndef ONESTEP_DRAGDROP
#define ONESTEP_DRAGDROP
#endif

/*
static void SyncTrace(int num)
{
	TRACE("\r\nSyncTrace at point %d\r\n", num);
}
*/

HRESULT STDMETHODCALLTYPE CChordMapStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	BOOL		bRefresh = FALSE;
	BOOL		bSyncEngine = FALSE;
	ChordEntry*	pChordChange = NULL;
	ChordEntry	tempChord;
	bool bConnectionChange = false;
	m_bDrop = false;
	ChordEntry*	pChord;
	static		int cMouseCount;	// used to make sure chord is painted before dragging
	static		bool bChordWasSelected = false;	// used to remember state of control-clicked chords
//	static		bool bInSelectionNet = false; 

	HRESULT		hr = E_NOTIMPL;

	static	POINTS	ptMouseDown;	// Used on MouseDrag and MouseUp operations.  This was the initial MouseDown point.
	static	HCURSOR	hCursor = NULL;	// Used to show dragging cursor

	switch( nMsg )
	{
	case WM_TIMER:
		{
			// wParam is timer id
			switch(wParam)
			{
			case ConnectionDrag:
				UpdateAutoScroll(&m_ConnectionDragState);
				break;
			case SelectionDrag:
				{
					// counter makes sure that compute gets called 
					// only every other time so that window gets
					// opportunity to scroll
//					TRACE("Timer handler for SelectionDrag\r\n");
					UpdateAutoScroll(&m_SelectionDragState);
//					OnWMMessage(WM_MOUSEMOVE, MK_LBUTTON, 
//								m_ptLastMouse.x + (m_ptLastMouse.y << 16), 0,0);
					CWnd* pWnd = GetTimelineCWnd();
					HWND hwnd = pWnd->GetSafeHwnd();
					m_pChordMapMgr->HitTest(m_rectSelect);
					m_pChordMapMgr->m_pTimeline->Refresh();
					::InvalidateRect(hwnd, 0, TRUE);
					::UpdateWindow(hwnd);

					ComputeSelectionBoxOutline(m_ptAnchor, m_ptLastMouse, false);
					/*
					m_pChordMapMgr->HitTest(m_rectSelect);
//					ComputeSelectionBoxOutline(m_ptAnchor, m_ptLastMouse, false);
					CWnd* pWnd = GetTimelineCWnd();
					HWND hwnd = pWnd->GetSafeHwnd();
					m_pChordMapMgr->m_pTimeline->Refresh();
					::InvalidateRect(hwnd, 0, TRUE);
					::UpdateWindow(hwnd);
					*/
				}
				break;
			}
		}
		break;

		case WM_CREATE:
		{
			VARIANT var;
			var.vt = VT_R8;

			m_cfChordList = RegisterClipboardFormat( CF_CHORDLIST );
			m_cfChordMapList = RegisterClipboardFormat( CF_CHORDMAP_LIST);

			GetWindowOrg(m_xOrg, m_yOrg);	// not used, but keep just in case

			break;
		}
/*
		case WM_DESTROY:
		{
			// persist zoom factor to personality
			VARIANT var;
			var.vt = VT_R8;
			m_pChordMapMgr->m_pTimeline->GetTimelineProperty(TP_ZOOM, &var);
			ZoomChangeNotification* pZoom = new ZoomChangeNotification;
			pZoom->m_dblZoom = V_R8(&var);
			m_pChordMapMgr->m_pTimeline->OnDataChanged( pZoom );
			break;
		}
*/
		case WM_SIZE:
		{
			ProcessOnSize();
			TRACE("Received Size Message\n");
			break;
		}
		case WM_KEYDOWN:
		{
			int nVirtKey = (int)wParam;
			unsigned long lKeyData = lParam;
			if(IsInsertKey(nVirtKey, lKeyData))
			{
				ChordEntry *pChord;
				POINTS		ptNewPoint = m_ptLastMouse;
				hr = InsertNewChord(ptNewPoint, pChord);
				if(hr == S_OK)
				{
					pChordChange = pChord;					// notify client of selected chord
					m_fSelected = TRUE;
					m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
					bRefresh = TRUE;
					bSyncEngine = TRUE;
//					SyncTrace(1);
				}
			}
			else if((m_fSelected = ProcessKey(nVirtKey, lKeyData)))
			{
				bRefresh = TRUE;
				bSyncEngine = TRUE;
//				SyncTrace(2);
				hr = S_OK;
			}
			break;
		}
		case WM_COMMAND:
			hr =  OnCommand(nMsg, wParam, lParam, lXPos, lYPos, bRefresh, bSyncEngine, pChordChange);
//			SyncTrace(3);
			break;
		
		case WM_RBUTTONDOWN:
			m_SelectionDragState.bActive = false;
			m_bInSelectionNet = false;
			ptMouseDown = MAKEPOINTS( lParam );
			SetFocusToTimeline();
			if( SUCCEEDED(GetClickedChord( ptMouseDown, &pChord )) )
			{
				if(!pChord->m_chordsel.KeyDown())
				{
					ClearSelectedChords();
					ClearSelectedConnections();
				}
				pChord->m_chordsel.KeyDown() = TRUE;
				pChordChange = pChord;
				m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
				bRefresh = TRUE;
				bSyncEngine = TRUE;
//				SyncTrace(4);
			}
			else
			{
				if( SUCCEEDED(GetClickedConnection( ptMouseDown, &pChord, NULL )) )
				{

					ClearSelectedChords();
					m_fSelected = FALSE;
					m_fDragging = FALSE;
					m_pChordMapMgr->m_selection = CChordMapMgr::ConnectionSelected;
					bRefresh = TRUE;
				}
				else
				{
					ClearSelectedChords();
					ClearSelectedConnections();
					bRefresh = TRUE;
					DoPropertyPage(CChordMapMgr::NoSelection);				}
			}
			break;
		case WM_RBUTTONUP:
			hr = OnRButtonUp(nMsg, wParam, lParam, lXPos, lYPos);
			break;
		
		case WM_INSERT_CHORD:
			hr = OnInsert(nMsg, wParam, lParam, lXPos, lYPos, bRefresh, bSyncEngine, pChordChange);
//			SyncTrace(5);
			break;

// MouseMoving 
		case WM_MOUSEMOVE:
//			TRACE("\n YPOS = %x", lYPos);
			if( wParam & MK_RBUTTON ) 
			{
				break;
			}
			else if (m_bInSelectionNet)
			{
				CWnd* pWnd = GetTimelineCWnd();
				HWND hwnd = pWnd->GetSafeHwnd();
				bRefresh = FALSE;
				m_ptLastMouse = MAKEPOINTS(lParam);
				m_pChordMapMgr->HitTest(m_rectSelect);
				m_pChordMapMgr->m_pTimeline->Refresh();
				::InvalidateRect(hwnd, 0, TRUE);
				::UpdateWindow(hwnd);

				ComputeSelectionBoxOutline(m_ptAnchor, m_ptLastMouse);
			}

			// Timeline Bug does not pass mouse messages along to it's children
			// so we can't set the cursor back to it's original state when the
			// user drags a Chord to the timeline and releases the mouse button.
			// Also, we don't have a window handle so we can't call ::SetCapture().
			if( !(wParam & MK_LBUTTON) && (hCursor != NULL) )
			{
				SetCursor( hCursor );
				hCursor = NULL;
				m_fDragging = FALSE;
				ClipCursor( NULL );
				TRACE("\nSet Dragging False");
			}

// LMB is DOWN
			if( wParam & MK_LBUTTON )
			{
				// User is dragging a Chord.
				if(!m_fConnectionDrag && SUCCEEDED(GetClickedChord( ptMouseDown, &pChord )) )
				{
					if(cMouseCount == 0)
						DoDragDrop(wParam, lParam, pChord, pChordChange);
					else
						--cMouseCount;
					break;
				}

				// User is dragging a Connection.
				else if( m_fConnectionDrag == TRUE )
				{
					TRACE("\nDragConnection");
					DragConnection(lParam, ptMouseDown);
					bRefresh = TRUE;
				}
				break;
			}
// LMB is UP
			else
			{
//				TRACE("\nClean up the DCs");
				// Clean up the DCs if the user drags the connection outside of the window, releases the button,
				// and we don't get the message.
				if( m_pbmpBackground != NULL )
				{
					m_fConnectionDrag = FALSE;
					ClearDragRes();
				}
			}
			
			break;

		case WM_LBUTTONDOWN:
		// Store Mouse Position.
		ptMouseDown = MAKEPOINTS( lParam );
		m_ptLastMouse = ptMouseDown;
			
			SetFocusToTimeline();

			// User want to drag the Chord.
			if( SUCCEEDED(GetClickedChord( ptMouseDown, &pChord )) )
			{
				ClearSelectedConnections();
				if(wParam & MK_CONTROL)
				{
					if(!pChord->m_chordsel.KeyDown())
					{
						bChordWasSelected = false;
						pChord->m_chordsel.KeyDown() = !pChord->m_chordsel.KeyDown();
					}
					else
					{
						bChordWasSelected = true;
					}
				}
				else
				{
					if(!pChord->m_chordsel.KeyDown())
					{
						ClearSelectedChords();
						ClearSelectedConnections();
					}
					pChord->m_chordsel.KeyDown() = TRUE;
				}
				bRefresh = TRUE;
				bSyncEngine = TRUE;
//				SyncTrace(6);
				cMouseCount = 3;
				pChordChange = pChord;
				m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
			}
			else
			{
				/////////////////////
				// Drag Connection (Modify/Add)
				if( SUCCEEDED(GetClickedConnection( ptMouseDown, &pChord, NULL )) )
				{

					ClearSelectedChords();
					m_fSelected = FALSE;
					m_fDragging = FALSE;
					m_pChordMapMgr->m_selection = CChordMapMgr::ConnectionSelected;
					m_fConnectionDrag = TRUE;
					if(m_fCapture == false)
					{
						VARIANT var;
						var.vt = VT_BOOL;
						V_BOOL(&var) = TRUE;
						m_pChordMapMgr->m_pTimeline->SetTimelineProperty(TP_STRIPMOUSECAPTURE, var);
						m_fCapture = true;
					}
					m_ConnectionDragState.bActive = true;
					break;	// Break Modify Connection
				}
				else
				{
					// whitespace click
					ClearSelectedChords();
					ClearSelectedConnections();
					VARIANT var;
					var.vt = VT_BOOL;
					V_BOOL(&var) = TRUE;
					m_pChordMapMgr->m_pTimeline->SetTimelineProperty(TP_STRIPMOUSECAPTURE, var);
					m_fCapture = true;
					m_bInSelectionNet = true;
					m_ptAnchor = ptMouseDown;
					ComputeSelectionBoxOutline(m_ptAnchor, m_ptLastMouse);
					m_SelectionDragState.bActive = true;
					bRefresh = TRUE;
					DoPropertyPage(CChordMapMgr::NoSelection);
				}
			}
			break;

		case WM_LBUTTONUP:			
			POINTS ptMouseUp;
			if(m_fCapture)
			{
				VARIANT var;
				var.vt = VT_BOOL;
				V_BOOL(&var) = FALSE;
				m_pChordMapMgr->m_pTimeline->SetTimelineProperty(TP_STRIPMOUSECAPTURE, var);
				m_fCapture = false;
				if(m_bInSelectionNet)
				{
					int nsel;
					GetNumSelections(&nsel);
					if(nsel == 1)
						m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
					else if(nsel > 1)
						m_pChordMapMgr->m_selection = CChordMapMgr::MultipleSelections;
					if(m_SelectionDragState.bAutoscroll)
					{
						::KillTimer(GetTimelineCWnd()->m_hWnd, SelectionDrag);
						TRACE("Killing Timer for SelectionDrag\n");
					}
					m_SelectionDragState.bActive = false;
					m_SelectionDragState.dir = DragState::off;
					m_bInSelectionNet = false;
					bRefresh = TRUE;
				}
			}
			m_ConnectionDragState.bActive = false;
			m_ConnectionDragState.dir = DragState::off;
			if(m_ConnectionDragState.bAutoscroll)
			{
				::KillTimer(GetTimelineCWnd()->m_hWnd, ConnectionDrag);
			}
			ptMouseUp = MAKEPOINTS( lParam );

			// If user didn't select a Chord then they want to:
			// 1) Add a Connection between Chords
			// 2) Cancel a Chord-Add operation
			// 3) Drop a Dragged Chord
			// 4) Add a new Chord to the ChordMap
			// 5) Cancel a Connection drag operation
			// 6) Cancel Chord selection if m_fSelected flag is set
			//
			if( FAILED(GetClickedChord( ptMouseUp, &pChord )) )
			{
				if( SUCCEEDED(GetClickedConnection( ptMouseUp, &pChord, NULL )) )
				{
					bConnectionChange = TRUE;
				}

				/////////////////////////
				// 6) Cancel Chord Select Operation
				if( m_fSelected == TRUE )
				{
					m_fSelected = FALSE;
				}

				/////////////////////////////
				// 5) Cancel Connection drag operation
				if( m_fConnectionDrag == TRUE )
				{
					ClearDragRes(); // Release DCs and BackBuffer.
					m_fConnectionDrag = FALSE;
					bRefresh = TRUE;
					hr = S_OK;
					break;
				}
			}
// User Selected a Chord (pChord is valid).
			else
			{	
				// Since the method succeeded we should always have a valid ptr to the selected chord.
				ASSERT( pChord != NULL );
				ChordEntry* pPrevChord;

				// If this release is over the same Chord that was initially clicked, then select/deselect it.
				// At this point it is not a drag operation.
				if( SUCCEEDED(GetClickedChord( ptMouseDown, &pPrevChord )) )
				{

					if( pPrevChord == pChord )
					{
						int selcount;
						if(pChord->m_chordsel.KeyDown())
						{
							if(!(wParam & MK_CONTROL))
							{
								// deselect everything else, then reselect
								ClearSelectedChords();
								ClearSelectedConnections();
								pChord->m_chordsel.KeyDown() = TRUE;
							}
							else
							{
								if(bChordWasSelected)
									pChord->m_chordsel.KeyDown() = !pChord->m_chordsel.KeyDown();
								bChordWasSelected = false;
							}
							// make sure chord is on top
							m_pChordMapMgr->m_pChordMapList->Remove(pChord);
							pChord->SetNext(0);
							m_pChordMapMgr->m_pChordMapList->AddTail(pChord);
//							bSyncEngine = TRUE;
							bSyncEngine = FALSE;  // already did sync
//							SyncTrace(7);
							pChordChange = pChord;	// notify client of selected chord
							m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
						}
						
						m_fSelected = ( GetNumSelections(&selcount) == S_OK ) ? TRUE : FALSE;
						hr = S_OK;

						m_fDragging = FALSE;

						bRefresh = TRUE;
						
						// Show Chord(s) in PropertyPage if visible
						switch(selcount)
						{
						case 0:
							m_pChordMapMgr->m_SelectedChord.RootIndex() = DMPolyChord::INVALID;
							DoPropertyPage(CChordMapMgr::NoSelection);
							pChordChange = 0;
							break;
						case 1:
							pChordChange = pChord;
//							DoPropertyPage(CChordMapMgr::ChordSelected);
							break;
						default: // multiple select
							pChordChange = 0;
							m_pChordMapMgr->m_SelectedChord.RootIndex() = DMPolyChord::INVALID;
							DoPropertyPage(CChordMapMgr::MultipleSelections);
							break;
						}
						hr = S_OK;
					}
					// Restore the previous cursor
					if( hCursor != NULL )
					{
						SetCursor( hCursor );
						hCursor = NULL;
						ClipCursor( NULL );
					}
					break;	// User Selected a Chord
				}

				// Drop the Connection on a Chord
				if( m_fConnectionDrag == TRUE )
				{
					ChordEntry* pFromChord;
					ChordEntry* pNextChord;
					if( SUCCEEDED(GetClickedConnection( ptMouseDown, &pFromChord, &pNextChord )) )
					{
						ASSERT( pFromChord != NULL );

						// Don't connect chords to themselves
						if( pFromChord == pChord )
						{
							hr = S_FALSE;
						}
						// If the user is connecting a Chord that occurs before the first, then fail.
						// We will also prohibit the user from dragging Chords beyond any Chords it is connected to.
						else if( pFromChord->m_rect.left >= pChord->m_rect.left )
						{
							hr = E_FAIL;
						}
						else // Ok to Connect these two Chords.
						{
							// first make sure not multiple connecting
							bool bAllowConnection = true;
							for(NextChord* pnext = pFromChord->m_nextchordlist.GetHead();
									pnext;pnext = pnext->GetNext() )
							{
								// Prohibit more than one connection from pFromChord to pToChord
								if( pnext->m_nextchord == pChord )
								{
									CString msg;
									msg.LoadString(IDS_MULTIPLE_CONN);
									AfxMessageBox(msg,MB_ICONEXCLAMATION );
									bAllowConnection = false;
								}
							}

							if(bAllowConnection)
							// Add new Connection
							{
								if(pNextChord)
									m_pChordMapMgr->SendEditNotification(IDS_UNDO_MoveConnection);
								else
									m_pChordMapMgr->SendEditNotification(IDS_UNDO_AddConnection);
								// allow connection should always succeed
								if( SUCCEEDED(hr = AddConnection( pFromChord, pChord )) )
								{
									bSyncEngine = TRUE;
								}
								bConnectionChange = true;
							}
						}
					}


					bRefresh = TRUE;
					
					m_fConnectionDrag = FALSE;
					hr = S_OK;

					// Clean up DCs and Bitmaps
					ClearDragRes();
					break;

				}

			}
						
	}
	if( bSyncEngine == TRUE )
	{
		TRACE( "ChordMapStrip: Syncing w/ Engine\n" );
		ComputeChordMap();
		if(!m_bDrop && pChordChange)
		{
			ChordChangeCallback* pCallback = new ChordChangeCallback(ChordChangeCallback::ChordMapNewSelection);
			// this is roundabout way to copy chord, but what the hey, we need something the client can delete
			ChordEntry* pc = new ChordEntry;
			CPropChord prop;
			m_pChordMapMgr->ChordToPropChord(&prop, pChordChange);
			m_pChordMapMgr->PropChordToChord(pc, &prop);
			pCallback->SetChordEntry(pc);
			m_pChordMapMgr->m_pTimeline->OnDataChanged( pCallback );
			DoPropertyPage(m_pChordMapMgr->m_selection);
		}
		else if(bConnectionChange)
		{
			m_pChordMapMgr->m_pTimeline->OnDataChanged( NULL );
			DoPropertyPage(CChordMapMgr::ConnectionSelected);
		}
		else
		{
			m_pChordMapMgr->m_pTimeline->OnDataChanged( NULL );
		}
	}
	else if(bConnectionChange)
	{
		DoPropertyPage(CChordMapMgr::ConnectionSelected);
	}
	/*  This already covered in the if (bSyncEngine == TRUE) clause
	else if(!m_bDrop && pChordChange)
	{
		ChordChangeCallback* pCallback = new ChordChangeCallback(ChordChangeCallback::ChordMapNewSelection);
		// this is roundabout way to copy chord, but what the hey, we need something the client can delete
		ChordEntry* pc = new ChordEntry;
		CPropChord prop;
		m_pChordMapMgr->ChordToPropChord(&prop, pChordChange);
		m_pChordMapMgr->PropChordToChord(pc, &prop);
		pCallback->SetChordEntry(pc);
		m_pChordMapMgr->m_pTimeline->OnDataChanged( pCallback );
		DoPropertyPage(m_pChordMapMgr->m_selection);
	}
*/
	if( bRefresh == TRUE )
	{
		// Kludge: Timeline doesn't refresh properly.  Force refresh.
		m_pChordMapMgr->m_pTimeline->Refresh();
		m_pChordMapMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::DoPropertyPage( enum CChordMapMgr::SelectionType selection, BOOL fShow )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(CChordMapMgr::NoSelection <= selection && selection < CChordMapMgr::EndEnum);
	if(!(CChordMapMgr::NoSelection <= selection && selection < CChordMapMgr::EndEnum))
	{
		return E_UNEXPECTED;
	}
	m_pChordMapMgr->m_selection = static_cast<enum CChordMapMgr::SelectionType>(selection);
	if(m_pChordMapMgr->m_selection == CChordMapMgr::PaletteSelected)
	{
		ASSERT( m_pChordMapMgr->m_pJazzFramework != NULL );

		if( fShow == TRUE )
		{
			IDMUSProdPropSheet* pJPS;
			if( SUCCEEDED(m_pChordMapMgr->m_pJazzFramework->QueryInterface( IID_IDMUSProdPropSheet,
				(void**)&pJPS )))
			{
				pJPS->Show(TRUE);
				pJPS->Release();
			}
		}

		m_pChordMapMgr->OnShowProperties();
		if( m_pChordMapMgr->m_pChordPropPageMgr )
		{
			m_pChordMapMgr->m_pChordPropPageMgr->RefreshData();
		}
	}
	else if(m_pChordMapMgr->m_selection == CChordMapMgr::ChordSelected)
	{
		// Prepare the template SelectedChord buffer with
		// selected chords.
		m_pChordMapMgr->PreparePropChord();


		ASSERT( m_pChordMapMgr->m_pJazzFramework != NULL );

		if( fShow == TRUE )
		{
			IDMUSProdPropSheet* pJPS;
			if( SUCCEEDED(m_pChordMapMgr->m_pJazzFramework->QueryInterface( IID_IDMUSProdPropSheet,
				(void**)&pJPS )))
			{
				pJPS->Show(TRUE);
				pJPS->Release();
			}
		}

		// Get the window with the focus so we can set the focus back to it
		// to handle keyboard actions like DELETE
		CWnd* pWindowWithFocus = CWnd::GetFocus();

		m_pChordMapMgr->OnShowProperties();

		// Set the focus back to the previous window 
		if(pWindowWithFocus)
			pWindowWithFocus->SetFocus();

		if( m_pChordMapMgr->m_pChordPropPageMgr )
		{
			m_pChordMapMgr->m_pChordPropPageMgr->RefreshData();
		}
	}
	else if(m_pChordMapMgr->m_selection == CChordMapMgr::ConnectionSelected)
	{
		// Prepare the template SelectedConnection buffer with
		// selected connection.
//		m_pChordMapMgr->PrepareConnection();


		ASSERT( m_pChordMapMgr->m_pJazzFramework != NULL );

		if( fShow == TRUE )
		{
			IDMUSProdPropSheet* pJPS;
			if( SUCCEEDED(m_pChordMapMgr->m_pJazzFramework->QueryInterface( IID_IDMUSProdPropSheet,
				(void**)&pJPS )))
			{
				pJPS->Show(TRUE);
				pJPS->Release();
			}
		}

		// Get the window with the focus so we can set the focus back to it
		// to handle keyboard actions like DELETE
		CWnd* pWindowWithFocus = CWnd::GetFocus();
		
		m_pChordMapMgr->OnShowProperties();

		// Set the focus back to the previous window 
		if(pWindowWithFocus)
			pWindowWithFocus->SetFocus();

		if( m_pChordMapMgr->m_pConnectionPropPageMgr )
		{
			m_pChordMapMgr->m_pConnectionPropPageMgr->RefreshData();
		}
	
	}
	else
	{
		// this is the Invalid Prop Page
		if( m_pChordMapMgr->m_pChordPropPageMgr != NULL )
		{
			m_pChordMapMgr->m_pChordPropPageMgr->RefreshData();
		}
		m_pChordMapMgr->m_SelectedChord.RootIndex() = DMPolyChord::INVALID;
		m_pChordMapMgr->OnShowProperties();
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::AddConnection( ChordEntry* pFromChord, ChordEntry* pToChord )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	NextChord* pnext;
	if(m_pChordMapMgr->m_pSelectedConnection->m_nextchord != NULL)
	{

		// use this to link to chord, first delete its old connection
		m_pChordMapMgr->m_pSelectedConnection->m_nextchord = 0;
		m_pChordMapMgr->m_pSelectedConnection->m_nid = 0;
		pnext = m_pChordMapMgr->m_pSelectedConnection;
	}

	else
	{
		// find blank NextChord
		for(pnext = pFromChord->m_nextchordlist.GetHead();
			(pnext) && (pnext->m_nextchord) /*&& (pnext->m_nextchord != pToChord)*/;
			pnext = pnext->GetNext() );

		ASSERT( pnext != NULL );


		ASSERT( pnext->m_nextchord == NULL );

		NextChord* pConnection = new NextChord;
		if( pConnection == NULL )
		{
			return E_FAIL;
		}
		// Get the new last box ready (as far as we can)
		pConnection->m_parent = pFromChord;
		// Connect the Connection to the parent chord.
		pFromChord->m_nextchordlist.AddTail(pConnection);
	}

	// Link the new Connection
	pnext->m_nextchord = pToChord;
	pnext->m_nid = pToChord->m_nid;

	// Establish min/max beats
	long nC1Pos, nC2Pos;
	long nC1Clocks, nC2Clocks;
	m_pChordMapMgr->m_pTimeline->MeasureBeatToClocks( m_pChordMapMgr->m_dwGroupBits, 0,
													  pFromChord->m_chordsel.Measure(), 
													  pFromChord->m_chordsel.Beat(), 
													  &nC1Clocks );
	m_pChordMapMgr->m_pTimeline->MeasureBeatToClocks( m_pChordMapMgr->m_dwGroupBits, 0,
													  pToChord->m_chordsel.Measure(),
													  pToChord->m_chordsel.Beat(), 
													  &nC2Clocks );
	long nDeltaC1C2 = ( nC1Clocks > nC2Clocks ) ? nC1Clocks - nC2Clocks : nC2Clocks - nC1Clocks;

	m_pChordMapMgr->m_pTimeline->ClocksToMeasureBeat( m_pChordMapMgr->m_dwGroupBits, 0, nDeltaC1C2, &nC1Pos, &nC2Pos );

	long bpm;
	m_pChordMapMgr->GetTimeSig(&bpm, 0);
	nC2Pos += bpm*nC1Pos;

	if( m_fVariableNotFixed )
	{
		pnext->m_nminbeats = 1;
		pnext->m_nmaxbeats = (short)nC2Pos;
	}
	else
	{
		pnext->m_nminbeats = (short)nC2Pos;
		pnext->m_nmaxbeats = (short)nC2Pos;
	}

	// update selected connection
	SetSelectedConnection(pnext);	

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::CountConnections( ChordEntry* pChord, int* pnCount )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pChord != NULL );

	if( pChord == NULL )
	{
		return E_INVALIDARG;
	}

	*pnCount = 0;

	NextChord *pNextChord = pChord->m_nextchordlist.GetHead();

	// New Chord
	if( !pNextChord )
	{
		return S_OK;
	}

	do{
		(*pnCount)++;
	}while( (pNextChord = pNextChord->GetNext()) != NULL );

	return ((*pnCount) == 0)?S_FALSE:S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::ConnectionToChord( NextChord* pNextChord, ChordEntry** ppChord )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pNextChord != NULL );
	ASSERT( ppChord != NULL );
	
	if( (ppChord == NULL) || (pNextChord == NULL) )
	{
		return E_INVALIDARG;
	}

	// Reached the end of the list.  Return E_FAIL to indicate that we couldn't
	// return a valid ChordEntry pointer.
	if( (*ppChord = (((SmallNextChord*)(&*pNextChord)))->m_nextchord) == NULL )
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::ChordFromID( int nID, ChordEntry** ppChord )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	for(	ChordEntry* pceOldChord = m_pChordMapMgr->m_pChordMapList->GetHead();
			pceOldChord != NULL;
			pceOldChord = pceOldChord->GetNext() )
	{
		if( ((SmallChordEntry*)pceOldChord)->m_nid == nID )
		{
			break;
		}
	}

	if( pceOldChord == NULL )
	{
		return E_FAIL;
	}

	(*ppChord) = pceOldChord;

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::DrawConnectionBoxes( CDC& cDC, ChordEntry* pChord, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( pChord != NULL );

	RECT		boundrect;	// Bounding rectangle used to draw Boxes.
	int			nNumConnections;
	NextChord*	pConnection;

	// Draw Chord Connection boxes in front of Chords.  Including blank one for adding.
	if( CountConnections( pChord, &nNumConnections ) == S_FALSE )
	{
		return S_OK; // This is an ending Chord and should not have connection boxes.
	}

	// Increment the number of connections so we can account for a blank 'Add' connection box.

//	double zoom = ZoomFactor();
//	if(zoom < 1.0) zoom = 1.0;
	// for now zoom = 1
	long zoom = 1;

	boundrect.bottom	=	(pChord->m_rect.top + ( long(zoom*(pChord->m_rect.bottom - pChord->m_rect.top) )>>1)) -
					((( long(CONNECTION_HEIGHT*zoom)>>1)*nNumConnections)+nNumConnections);
	boundrect.left	= pChord->m_rect.left + (pChord->m_rect.right - pChord->m_rect.left)*zoom + 1;
	boundrect.right	= boundrect.left + CONNECTION_WIDTH*zoom;

	// Set next Connection ptr so we can set the text for connections 
	// right after we draw the boxes for them.  
	pConnection = pChord->m_nextchordlist.GetHead();

	// Set text color for Connection box text and restore before method ends
	int			nEndWeight;
	VARIANT		vt;
	vt.vt = VT_I4;

	COLORREF	colRef = cDC.GetTextColor();
	cDC.SetTextColor( CONNECTION_TEXT_COLOR );

	while( pConnection )
	{
////////////////
// Draw the Connection boxes
//
		CPen *pOldPen;
		CPen pen;

		if (m_pChordMapMgr->m_pSelectedConnection == pConnection) 
		{
			if (!pen.CreatePen(PS_SOLID,2,RGB(0xFF,0,0)))
			{
				return E_OUTOFMEMORY;
			}
			pOldPen = cDC.SelectObject(&pen);
		} 


		boundrect.top = boundrect.bottom;
		boundrect.bottom += CONNECTION_HEIGHT+1;

		// If the top connection box is heigher then the top of the screen, then make the
		// top connection box = 0 and bump the bottom connection box down the amount
		// of where we adjusted for the top.
		if( boundrect.top < 0 )
		{
			boundrect.bottom += -(boundrect.top);
			boundrect.top = 0;
		}


		// Save the Connection box coordinates for mouse-hit checking.
		pConnection->m_rect.left	= (short)(boundrect.left);
		pConnection->m_rect.top		= (short)(boundrect.top);
		pConnection->m_rect.right	= (short)(boundrect.right);
		pConnection->m_rect.bottom	= (short)(boundrect.bottom);

		RECT rect;
		rect.top = boundrect.top;
		rect.bottom = boundrect.bottom;
		rect.left = boundrect.left - lXOffset;
		rect.right = boundrect.right -lXOffset;

		if(m_pChordMapMgr->m_pSelectedConnection == pConnection)
		{
			cDC.FillSolidRect(	&rect, CONNECTION_SEL_FILL );
		}
		else
		{
			cDC.FillSolidRect(	&rect, CONNECTION_FILL_BACKGROUND );
		}
		cDC.Draw3dRect(	&rect, CHORD_CONNECTION_3D_HIGHLIGHT, CHORD_CONNECTION_3D_LOWLIGHT );

		// If this connection connects two chords then show the weight and min/max data
		// for the connection.  Otherwise it's a blank 'Add' Connection box.
		if( pConnection->m_nextchord != NULL )
		{
			// Show weight as a measurement of the box.
			nEndWeight = (int)((rect.right-rect.left)*(((SmallNextChord*)pConnection)->m_nweight/100.0));
			if(m_pChordMapMgr->m_pSelectedConnection == pConnection)
			{
				cDC.FillSolidRect(	rect.left+1,
									rect.top+1,
									nEndWeight,
									rect.bottom-rect.top-2,
									CONNECTION_SEL_FILL );
			}
/*
			else if(m_fVariableNotFixed)
			{
				// draw grey half rect used to show min/max
				cDC.FillSolidRect(	rect.left+1,
									rect.top+1,
									nEndWeight,
									rect.bottom-rect.top-2,
									CONNECTION_FILL );
									
			}

*/
////////////////
// Update min/max depending on the distance to the next chord.
//
			long nC1Pos, nC2Pos;
			long nC1Clocks, nC2Clocks;
			m_pChordMapMgr->m_pTimeline->MeasureBeatToClocks( m_pChordMapMgr->m_dwGroupBits, 0, 
															  pChord->m_chordsel.Measure(), 
															  pChord->m_chordsel.Beat(), 
															  &nC1Clocks );
			m_pChordMapMgr->m_pTimeline->MeasureBeatToClocks( m_pChordMapMgr->m_dwGroupBits, 0,
															  pConnection->m_nextchord->m_chordsel.Measure(),
															  pConnection->m_nextchord->m_chordsel.Beat(), 
															  &nC2Clocks );
			long nDeltaC1C2 = ( nC1Clocks > nC2Clocks ) ? nC1Clocks - nC2Clocks 
															: nC2Clocks - nC1Clocks;
			m_pChordMapMgr->m_pTimeline->ClocksToMeasureBeat( m_pChordMapMgr->m_dwGroupBits, 0, nDeltaC1C2, &nC1Pos, &nC2Pos );
			
			long bpm = 4;
			m_pChordMapMgr->GetTimeSig(&bpm, 0);
			nC2Pos += (bpm*nC1Pos);
			if(!m_fVariableNotFixed)
			{
				pConnection->m_nminbeats = (short)nC2Pos;
				pConnection->m_nmaxbeats = (short)nC2Pos;
			}						

////////////////
// Draw the Min/Max numbers in the Connection box
//
/*
			if(m_fVariableNotFixed)
			{
				CString csBuf;

				csBuf.Format( "%d/%d",	((SmallNextChord*)pConnection)->m_nminbeats,
										((SmallNextChord*)pConnection)->m_nmaxbeats );
				cDC.DrawText( csBuf, &rect, DT_CENTER );
			}
*/
//////////////////
// Draw the Connecting line
//
			cDC.MoveTo( pConnection->m_rect.right - lXOffset, pConnection->m_rect.top + ((pConnection->m_rect.bottom-pConnection->m_rect.top)>>1) );
			cDC.LineTo( pConnection->m_nextchord->m_rect.left - lXOffset, pConnection->m_nextchord->m_rect.top + ((pConnection->m_nextchord->m_rect.bottom-pConnection->m_nextchord->m_rect.top)>>1) );
			
		}
		if(m_pChordMapMgr->m_pSelectedConnection == pConnection)
		{
			cDC.SelectObject(pOldPen);
		}

		pConnection = pConnection->GetNext();
	}

	
	// Restore previous text color
	cDC.SetTextColor( colRef );

	return S_OK;
}
					
HRESULT STDMETHODCALLTYPE CChordMapStrip::DrawChord( CDC& cDC, ChordEntry* pChord, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pChord != NULL );

	if( pChord->m_rect.left < 0 )
	{
		pChord->m_rect.left = 0;
		pChord->m_rect.right = CHORD_DEFAULT_WIDTH;
	}

	if( pChord->m_rect.right - pChord->m_rect.left > CHORD_DEFAULT_WIDTH)
	{
		pChord->m_rect.right = pChord->m_rect.left + CHORD_DEFAULT_WIDTH;
	}

	if( pChord->m_rect.top < 0 )
	{
//		pChord->m_rect.top = 0;
//		pChord->m_rect.bottom = CHORD_DEFAULT_HEIGHT;
		pChord->m_rect.top = -pChord->m_rect.top;
		pChord->m_rect.bottom += CHORD_DEFAULT_HEIGHT;
	}

	if( pChord->m_rect.bottom - pChord->m_rect.top > CHORD_DEFAULT_HEIGHT)
	{
		pChord->m_rect.bottom = pChord->m_rect.top + CHORD_DEFAULT_HEIGHT;
	}

	// Calculate Chord rect based on measure and beat.
	// called in draw: for zoom all chords need to be computed prior to draw
//	SyncRectToMeasureBeat( pChord );

//	double zoom = ZoomFactor();
//	if(zoom < 1.0) zoom = 1.0;
	// for now zoom = 1
	long zoom = 1;

	COLORREF crFill, crHighLight, crLowLight;
	// Draw selected Chord box
	if( pChord->m_chordsel.KeyDown() == TRUE )
	{
		crFill = CHORD_CONNECTION_3D_SEL_FILL;
		crHighLight = CHORD_CONNECTION_3D_SEL_HIGHLIGHT;
		crLowLight = CHORD_CONNECTION_3D_SEL_LOWLIGHT;
	}
	// Draw unselected Chord box
	else
	{
		crFill = CHORD_CONNECTION_3D_FILL;
		crHighLight = CHORD_CONNECTION_3D_HIGHLIGHT;
		crLowLight = CHORD_CONNECTION_3D_LOWLIGHT;
	}

	long d1 = pChord->m_rect.left - lXOffset * zoom;
	long d2 = pChord->m_rect.top;
	long d3 = (pChord->m_rect.right - pChord->m_rect.left) * zoom;
	long d4 = (pChord->m_rect.bottom - pChord->m_rect.top) * zoom;

	cDC.FillSolidRect(	d1, d2, d3, d4, crFill);

	cDC.Draw3dRect(	d1, d2, d3, d4, crHighLight, crLowLight );

	// Display Special characters for Beginning and Ending Chords.
	CBitmap	cBitmap;
	CPoint	cPoint( d1+1, d2+1 );
	CSize	cSize;
	if( pChord->m_dwflags & CE_START )	// Starting Chord.
	{
		if(pChord->m_chordsel.KeyDown())
		{
			cBitmap.LoadBitmap( MAKEINTRESOURCE( IDB_GOSIGN_SEL ) );
		}
		else
		{
			cBitmap.LoadBitmap( MAKEINTRESOURCE( IDB_GOSIGN ) );
		}
		cSize = cBitmap.GetBitmapDimension();
//		cPoint.y -= GO_SIGN_HEIGHT;
		cDC.DrawState( cPoint, cSize, &cBitmap, DST_BITMAP | DSS_NORMAL );
		cBitmap.DeleteObject();
	}
	if( pChord->m_dwflags & CE_END )		// Ending Chord
	{
		if( pChord->m_dwflags & CE_START )
		{
			cPoint.x = (pChord->m_rect.right - STOP_SIGN_WIDTH - lXOffset)*zoom;
		}

		if(pChord->m_chordsel.KeyDown())
		{
			cBitmap.LoadBitmap( MAKEINTRESOURCE( IDB_STOPSIGN_SEL ) );
		}
		else
		{
			cBitmap.LoadBitmap( MAKEINTRESOURCE( IDB_STOPSIGN ) );
		}
		cSize = cBitmap.GetBitmapDimension();
//		cPoint.y = (rect.bottom - STOP_SIGN_HEIGHT);
		cDC.DrawState( cPoint, cSize, &cBitmap, DST_BITMAP | DSS_NORMAL );
		cBitmap.DeleteObject();
	}
	
	if( !(pChord->m_dwflags & (CE_START + CE_END)) )
	{
		// need size of bitmap
		cBitmap.LoadBitmap( MAKEINTRESOURCE (IDB_GOSIGN) );
		cSize = cBitmap.GetBitmapDimension();
		cBitmap.DeleteObject();
	}
	
	
	// Display the Chord name.
	RECT rect;
	CString csChordName1, csChordName2;
	char	szRootName[ROOT_TO_NAME_MAX];

	pChord->m_chordsel.RootToString(szRootName);
	int nChars = strlen(szRootName) + 1 + strlen(pChord->m_chordsel.Name() );
	if(nChars <= 6)
	{
		csChordName1.Format( "%s %s", szRootName, pChord->m_chordsel.Name() );
	}
	else
	{
		csChordName1 = szRootName;
		csChordName2 = pChord->m_chordsel.Name();
	}

	LOGFONT lf;
	memset( &lf, 0 , sizeof(LOGFONT));
	lf.lfHeight = -MulDiv(8, GetDeviceCaps(cDC, LOGPIXELSY), 72);
	lf.lfWeight = 400;
//	lf.lfPitchAndFamily = DEFAULT_PITCH | FF_MODERN;
	_tcscpy(lf.lfFaceName, _T("Arial"));

	
//	rect.left	= pChord->m_rect.left+1 - lXOffset*zoom;
//	rect.right	= pChord->m_rect.right-1 - lXOffset*zoom;
	rect.left = pChord->m_rect.left + cSize.cx + 1 - lXOffset*zoom;
	rect.right = pChord->m_rect.right - cSize.cx - 1 - lXOffset*zoom;
	rect.top		= pChord->m_rect.top + 1;
	rect.bottom	= rect.top - lf.lfHeight + 1;

	// indicate whether or not chord is orphan
	if( (pChord->m_dwflags & CE_START) || (pChord->m_dwflags & CE_END))
	{
		if(pChord->m_dwflags & CE_MATCHED)
		{
			lf.lfWeight = 700;
		}
		else
		{
			lf.lfItalic = TRUE;
		}
	}

	CFont font;
	if (font.CreateFontIndirect( &lf ))
	{
		CFont *pOldFont;
		pOldFont = cDC.SelectObject( &font );
		if (pOldFont)
		{
			// 
			int nOldBkMode;
			nOldBkMode = cDC.SetBkMode( TRANSPARENT );
			::DrawText(cDC, csChordName1, csChordName1.GetLength(), &rect, 
						DT_WORD_ELLIPSIS | DT_NOPREFIX | DT_CENTER | /*DT_WORDBREAK */ DT_SINGLELINE);
			if(!csChordName2.IsEmpty())
			{
				rect.top = rect.bottom + 1;
				rect.bottom = rect.top - lf.lfHeight + 1;
				::DrawText(cDC, csChordName2, csChordName2.GetLength(), &rect, 
						DT_WORD_ELLIPSIS | DT_NOPREFIX | DT_CENTER | DT_WORDBREAK);
			}
			
			cDC.SetBkMode( nOldBkMode );
			cDC.SelectObject( pOldFont );
		}
	}



	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::SetNewChordXY( POINTS& DropPoint )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ChordEntry*		pChord;

	// Find Selected Chord in ChordList...
	for(	pChord = m_pChordMapMgr->m_pChordMapList->GetHead();
			pChord != NULL;
			pChord = pChord->GetNext() )
	{
		if( pChord->m_chordsel.KeyDown() == TRUE )
		{
			break;
		}
	}

	if( pChord == NULL )
	{
		return E_FAIL;
	}

	// Update the XY of the Chord, measure and beat members too.
	SetChordXY( pChord, DropPoint );

	// Indicate that we are no longer dragging this Chord.
	pChord->m_chordsel.KeyDown() = FALSE;

	// Update min/max for Connections that exit from this Chord.


	return S_OK;
}

void CChordMapStrip::ClearSelectedConnections() 
{

	ASSERT( m_pChordMapMgr != NULL );
	ASSERT( m_pChordMapMgr->m_pChordMapList != NULL );

	ChordEntry*	pChord		= NULL;
	NextChord*	pConnection	= NULL;

	// Go through the Chords in the ChordList and check each connection for a hit.
	for(	pChord = m_pChordMapMgr->m_pChordMapList->GetHead();
			(pChord != NULL) && (pConnection == NULL);
			pChord = pChord->GetNext() )
	{
		// Go through Connections looking for a hit
		for(	pConnection = pChord->m_nextchordlist.GetHead();
				pConnection != NULL;
				pConnection = pConnection->GetNext() )
		{
				SetSelectedConnection(NULL);
		}
	}

	
}


HRESULT STDMETHODCALLTYPE CChordMapStrip::GetClickedConnection( POINTS& Point, ChordEntry** ppChord, ChordEntry** ppNextChord )
// modified to return only if there is a connection if ppChord && ppNextChord are null pointers
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pChordMapMgr != NULL );
	ASSERT( m_pChordMapMgr->m_pChordMapList != NULL );
//	ASSERT( ppChord != NULL );

	ChordEntry*	pChord		= NULL;
	NextChord*	pConnection	= NULL;

//	*ppChord = NULL;

	// Go through the Chords in the ChordList and check each connection for a hit.
	for(	pChord = m_pChordMapMgr->m_pChordMapList->GetHead();
			(pChord != NULL) && (pConnection == NULL);
			pChord = pChord->GetNext() )
	{
		// Go through Connections looking for a hit
		for(	pConnection = pChord->m_nextchordlist.GetHead();
				pConnection != NULL;
				pConnection = pConnection->GetNext() )
		{
			if( (Point.x >= pConnection->m_rect.left && Point.x <= pConnection->m_rect.right) &&
				(Point.y >= pConnection->m_rect.top && Point.y <= pConnection->m_rect.bottom) )
			{
				SetSelectedConnection(pConnection);
				break; // Found a hit.
			}
		}
	}

	// Didn't find a hit.
	if( (pChord == NULL) && (pConnection == NULL) )
	{
		return E_FAIL;
	}

	// Otherwise the hit was a regular 'ol Connection box.
	if(ppChord)
		(*ppChord) = pConnection->m_parent;
	if(ppNextChord)
		(*ppNextChord) = pConnection->m_nextchord;

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::ClearSelectedChords()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ChordEntry* pChord = NULL;

	// Go through the Chords in the ChordList and check each connection for a hit.
	for(	pChord = m_pChordMapMgr->m_pChordMapList->GetHead();
			pChord != NULL;
			pChord = pChord->GetNext() )
	{
		if( pChord->m_chordsel.KeyDown() == TRUE )
		{
			pChord->m_chordsel.KeyDown() = FALSE;
		}
	}

	// now clear out chord palette
	for(int i = 0; i < 24; i++)
	{
		m_pChordMapMgr->m_pChordPalette->m_chords[i].KeyDown() = false;
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::GetNumSelections( int* pnSelected )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	ChordEntry* pChord = NULL;
	int nSelected = 0;

	// Go through the Chords in the ChordList and check each connection for a hit.
	for(	pChord = m_pChordMapMgr->m_pChordMapList->GetHead();
			pChord != NULL;
			pChord = pChord->GetNext() )
	{
		if( pChord->m_chordsel.KeyDown() == TRUE )
		{
			nSelected++;
		}
	}		

	// Default behavior of GetNumSelections is to just return S_FALSE if no Chords are selected.
	if( pnSelected != NULL )
	{
		(*pnSelected) = nSelected;
	}

	return (nSelected == 0) ? S_FALSE : S_OK;
}


// kludge because draw not happening before engine data sync
HRESULT STDMETHODCALLTYPE CChordMapStrip::ComputeChordMap()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pChordMapMgr->m_pTimeline )
	{
		ChordEntry*	pChord;
		RECT		rcChord;


		// Draw Chords in ChordMap Pane
		if( (pChord = m_pChordMapMgr->m_pChordMapList->GetHead()) != NULL )
		{
			while( pChord ) //( ( pChord ) && (lPosition < rcScreenClip.right) )
			{
				rcChord.left = pChord->m_rect.left;
				rcChord.right = pChord->m_rect.right;
				rcChord.top = pChord->m_rect.top;
				rcChord.bottom = pChord->m_rect.bottom;

				// Display Chord Box.
				ComputeChord(pChord );
					
				ComputeConnectionBoxes(pChord );
					
				pChord = pChord->GetNext();
			}
		}
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::ComputeChord(ChordEntry* pChord)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pChord != NULL );

	if( pChord->m_rect.left < 0 )
	{
		pChord->m_rect.left = 0;
		pChord->m_rect.right = CHORD_DEFAULT_WIDTH;
	}
	if( pChord->m_rect.top < 0 )
	{
		pChord->m_rect.top = 0;
		pChord->m_rect.bottom = CHORD_DEFAULT_HEIGHT;
	}

	// Calculate Chord rect based on measure and beat.
	SyncRectToMeasureBeat( pChord );

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::ComputeConnectionBoxes(ChordEntry* pChord)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pChord != NULL );

	RECT		rect;	// Bounding rectangle used to draw Boxes.
	int			nNumConnections;
	NextChord*	pConnection;

	// Draw Chord Connection boxes in front of Chords.  Including blank one for adding.
	if( CountConnections( pChord, &nNumConnections ) == S_FALSE )
	{
		return S_OK; // This is an ending Chord and should not have connection boxes.
	}

	// Increment the number of connections so we can account for a blank 'Add' connection box.

	rect.bottom	=	(pChord->m_rect.top + ((pChord->m_rect.bottom - pChord->m_rect.top)>>1)) -
					(((CONNECTION_HEIGHT>>1)*nNumConnections)+nNumConnections);
	rect.left	= pChord->m_rect.right + 1;
	rect.right	= rect.left + CONNECTION_WIDTH;

	// Set next Connection ptr so we can set the text for connections 
	// right after we draw the boxes for them.  
	pConnection = pChord->m_nextchordlist.GetHead();

	// Set text color for Connection box text and restore before method ends
	VARIANT		vt;
	vt.vt = VT_I4;


	while( pConnection )
	{
////////////////
// Draw the Connection boxes
//
		rect.top = rect.bottom;
		rect.bottom += CONNECTION_HEIGHT+1;

		// If the top connection box is heigher then the top of the screen, then make the
		// top connection box = 0 and bump the bottom connection box down the amount
		// of where we adjusted for the top.
		if( rect.top < 0 )
		{
			rect.bottom += -(rect.top);
			rect.top = 0;
		}

		// Save the Connection box coordinates for mouse-hit checking.
		pConnection->m_rect.left	= (short)(rect.left);
		pConnection->m_rect.top		= (short)(rect.top);
		pConnection->m_rect.right	= (short)(rect.right);
		pConnection->m_rect.bottom	= (short)(rect.bottom);


		// If this connection connects two chords then show the weight and min/max data
		// for the connection.  Otherwise it's a blank 'Add' Connection box.
		if( pConnection->m_nextchord != NULL )
		{

////////////////
// Update min/max depending on the distance to the next chord.
//
			long nC1Pos, nC2Pos;
			long nC1Clocks, nC2Clocks;
			m_pChordMapMgr->m_pTimeline->MeasureBeatToClocks( m_pChordMapMgr->m_dwGroupBits, 0,
															  pChord->m_chordsel.Measure(), 
															  pChord->m_chordsel.Beat(), 
															  &nC1Clocks );
			m_pChordMapMgr->m_pTimeline->MeasureBeatToClocks( m_pChordMapMgr->m_dwGroupBits, 0,
															  pConnection->m_nextchord->m_chordsel.Measure(),
															  pConnection->m_nextchord->m_chordsel.Beat(), 
															  &nC2Clocks );
			long nDeltaC1C2 = ( nC1Clocks > nC2Clocks ) ? nC1Clocks - nC2Clocks 
															: nC2Clocks - nC1Clocks;

			m_pChordMapMgr->m_pTimeline->ClocksToMeasureBeat( m_pChordMapMgr->m_dwGroupBits, 0, nDeltaC1C2, &nC1Pos, &nC2Pos );

			long bpm;
/*
			DMUS_TIMESIGNATURE timesig;
			m_pChordMapMgr->m_pTimeline->GetParam(GUID_TimeSignature, 0xFFFFFFFF, 0, 0, 0, static_cast<void*>(&timesig));
			nC2Pos += timesig.bBeatsPerMeasure*nC1Pos;
*/
			m_pChordMapMgr->GetTimeSig(&bpm, 0);
			nC2Pos += bpm*nC1Pos;
			if(!m_fVariableNotFixed)
			{
				pConnection->m_nminbeats = (short)nC2Pos;
				pConnection->m_nmaxbeats = (short)nC2Pos;
			}
		
			
		}

		pConnection = pConnection->GetNext();
	}

	return S_OK;
}


BOOL CChordMapStrip::ProcessKey(int nVirtKey, unsigned long lKeyData)
{
	BOOL b = FALSE;
	if(IsDeleteKey(nVirtKey, lKeyData))
	{
		if(m_pChordMapMgr->m_pSelectedConnection && m_pChordMapMgr->m_pSelectedConnection->m_nextchord)
		{
			m_pChordMapMgr->SendEditNotification(IDS_UNDO_RemoveConnection);
			DelSelConnections();
//			DeleteConnection(m_pChordMapMgr->m_pSelectedConnection);
//			m_pChordMapMgr->m_pSelectedConnection = NULL;
//			m_pChordMapMgr->m_selection = CChordMapMgr::NoSelection;
//			DoPropertyPage(m_pChordMapMgr->m_selection);
			b = TRUE;
		}
		else if(m_pChordMapMgr->m_selection == CChordMapMgr::ChordSelected 
				|| m_pChordMapMgr->m_selection == CChordMapMgr::MultipleSelections)
		{
			DelSelChords();
			m_pChordMapMgr->m_selection = CChordMapMgr::NoSelection;
			b = TRUE;
		}
	}
	else if (IsCutKey(nVirtKey, lKeyData))
	{
	}
	return b;
}

///////////////////////////////////////////////// DropTarget helpers

CWnd* CChordMapStrip::GetTimelineCWnd()
{
	CDC cDC;
	VARIANT vt;
	vt.vt = VT_I4;

	CWnd* pWnd = 0;

	// Get the DC of our Strip
	if( m_pChordMapMgr->m_pTimeline )
	{
		if( SUCCEEDED(m_pChordMapMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GET_HDC, &vt )) )
		{
			if( cDC.Attach( (HDC)(vt.lVal) ) != 0 )
			{
				pWnd = cDC.GetWindow();
				cDC.Detach();
			}
			if( pWnd )
			{
				::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(vt.lVal) );
			}
			else
			{
				::ReleaseDC( NULL, (HDC)(vt.lVal) );
			}
		}
	}
	return pWnd;
}

HRESULT CChordMapStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfChordList ) )
		|| SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, m_cfChordMapList ) ) )
	{
		hr = S_OK;
	}

	pDataObject->Release();
	return hr;
}

///////////////////////////////////////////////////////// IDropTarget methods
// IDropTarget CChordMapStrip::DragEnter

HRESULT CChordMapStrip::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	TRACE("\nCChordMapStrip Drag Enter!");
	ASSERT( pIDataObject != NULL );
	if(pIDataObject == NULL)
		return E_UNEXPECTED;

	if(m_pITargetDataObject != NULL)
	{
		TRACE("releasing m_pITargetDataObject\r\n");
		m_pITargetDataObject->Release();
		m_pITargetDataObject = 0;
	}

	if( m_pDragImage )
	{
		CPoint point( pt.x, pt.y );

		CWnd *pWnd = GetTimelineCWnd();
		if( pWnd )
		{
			// Show the feedback image
			m_pDragImage->DragEnter( pWnd->GetDesktopWindow(), point );
		}
	}

	// Store IDataObject associated with current drag-drop operation
	m_pITargetDataObject = pIDataObject;
	m_pITargetDataObject->AddRef();

	// save boundary information about chord aggregate being dragged
	
	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pJazzDataObject = new CDllJazzDataObject();
	if( pJazzDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	IStream* pIStream;
	if(SUCCEEDED (pJazzDataObject->AttemptRead( pIDataObject, m_cfChordMapList, &pIStream)))
	{
			ChordEntryList list;
			LARGE_INTEGER liTemp;
			// seek to beginning of stream
			liTemp.QuadPart = 0;
			// declare a temp list and write chords into it
			DMSubChordSet::m_sbDisableMessages = true;
			hr = DMLoadChordData(list, pIStream);
			DMSubChordSet::m_sbDisableMessages = false;
			ChordEntry* pRefChord = list.GetHead();
			if(pRefChord)
			{
				GetBoundingRectRelativeToChord(list, pRefChord, m_rectAggregate);
			}
			// reset everything
			pIStream->Seek(liTemp, STREAM_SEEK_SET, NULL);
			pIStream->Release();
			list.ClearList();
	}
	else
	{
		memset(&m_rectAggregate, 0, sizeof(RECT));
	}

	pJazzDataObject->Release();

	
	if( m_pDragImage )
	{
		CPoint point( pt.x, pt.y );

		// Show the feedback image
		m_pDragImage->DragEnter( GetTimelineCWnd()->GetDesktopWindow (), point );
	}
/*
	// Make sure editor is on top
	if( m_pStyle->m_hWndEditor )
	{
		::BringWindowToTop( m_pStyle->m_hWndEditor );
	}
*/
	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CChordMapStrip::DragOver

HRESULT CChordMapStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	int height;

	HRESULT hr = S_OK;

//	TRACE("CChordMapStrip Drag to %x\n", pt.y);
	if(m_pITargetDataObject == NULL)
		ASSERT( m_pITargetDataObject != NULL );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragShowNolock( FALSE );
	}


	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	VARIANT var;
	hr = m_pChordMapMgr->m_pTimeline->StripGetTimelineProperty(this, STP_HEIGHT, &var);
	if(hr != S_OK)
	{
		goto Leave;
	}
	height = V_I4(&var);
	// adjust for vertical scroll
//	height += GetVerticalScroll();

	if( pt.y > (height) )
	{
		// prevent chord from getting swallowed up by the abyss
		hr = E_FAIL;
		goto Leave;
	}
/*
	if(CheckBoundsForDrag(pt) != S_OK)	
	{
		hr = E_FAIL;
	}
*/
	if( CanPasteFromData( m_pITargetDataObject ) == S_OK && (CheckBoundsForDrag(pt) == S_OK))
	{
		if( grfKeyState & MK_RBUTTON )
		{
			dwEffect = *pdwEffect;
		}
		else
		{
			if( grfKeyState & MK_CONTROL )
			{
				dwEffect = DROPEFFECT_COPY;
			}
			else
			{
				if( *pdwEffect & DROPEFFECT_COPY
				&&  *pdwEffect & DROPEFFECT_MOVE )
				{
					dwEffect = DROPEFFECT_MOVE;
				}
				else
				{
					dwEffect = *pdwEffect;
				}
			}
		}
	}

	if( m_pDragImage )
	{
		// Show the feedback image
		m_pDragImage->DragShowNolock( TRUE );
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}
Leave:
	*pdwEffect = dwEffect;
//	TRACE("pdwEffect = %d\r\n", dwEffect);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CChordMapStrip::DragLeave

HRESULT CChordMapStrip::DragLeave( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	TRACE("CChordMapStrip Drag Leave!");

	// Release IDataObject
	if( m_pITargetDataObject )
	{
		m_pITargetDataObject->Release();
		m_pITargetDataObject = NULL;
	}

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( GetTimelineCWnd()->GetDesktopWindow () );
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CChordMapStrip::Drop

HRESULT CChordMapStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pITargetDataObject != NULL );
	ASSERT( m_pITargetDataObject == pIDataObject );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( GetTimelineCWnd()->GetDesktopWindow () );
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;
		
		// Display arrow cursor
		::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
	
		// Prepare context menu
		hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Get a window to attach menu to
			CWnd* pWnd = GetTimelineCWnd();
			if(pWnd)
			{
				// Display and track menu
				CPoint point( pt.x, pt.y );
				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, pWnd->GetSafeHwnd(), NULL );
				DestroyMenu( hMenu );

				// Need to process WM_COMMAND from TrackPopupMenu
				MSG msg;
				while( ::PeekMessage( &msg, pWnd->GetSafeHwnd(), NULL, NULL, PM_REMOVE) )
				{
					if( msg.message == WM_COMMAND )
					{
						OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
					}
					else
					{
						TranslateMessage( &msg );
						DispatchMessage( &msg );
					}
				}

				// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
				m_dwOverDragEffect = m_dwDragRMenuEffect;
				m_dwDragRMenuEffect = DROPEFFECT_NONE;
			}
		}
	}

	// Paste data
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		// BUGBUG: Error messages?
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pChordMapMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				if(pt.x < 0)
				{
					hr = FBPasteAt( pITimelineDataObject, pt, true);
				}
				else
				{
					if( S_OK == pITimelineDataObject->IsClipFormatAvailable(m_cfChordMapList) )
					{
						hr = ChordEntryPasteAt(pITimelineDataObject, pt, true);
					}
					else if(S_OK == pITimelineDataObject->IsClipFormatAvailable(m_cfChordList))
					{
						hr = ChordItemPasteAt(pITimelineDataObject, pt, true);
					}
					else
					{
						ASSERT(FALSE);
						hr = E_UNEXPECTED;
					}
				}
				if( SUCCEEDED ( hr ) )
				{
					*pdwEffect = m_dwOverDragEffect;
				}
			}
			pITimelineDataObject->Release();
		}
	}

	// Cleanup
	DragLeave();

	return hr;
}

HRESULT CChordMapStrip::InsertChords(CChordList& list, POINTL pt)
{
//	ChordEntry pChordChange = 0;
	HRESULT hr = S_OK;
	VARIANT			var;
	m_pChordMapMgr->m_pTimeline->GetTimelineProperty(TP_MAXIMUM_HEIGHT, &var);
	int strip_height = V_I4(&var);
	short y = static_cast<short>(pt.y);
	for(CChordItem* pItem = list.GetHead(); pItem; pItem = pItem->GetNext())
	{
		ChordEntry* pChord = NULL;
		hr = m_pChordMapMgr->CreateBlankChord(&pChord);
		if(SUCCEEDED(hr))
		{
			pChord->LoadFromChordItem(*pItem);
			// we need to regenerate this because LoadFromChordItem does not preserve nid
			((SmallChordEntry*)pChord)->m_nid = m_pChordMapMgr->m_nIDCounter++;
			// Set new Chord (UI Box) where the user clicked the mouse.
			long position;
			// need to preserve measure (mapping to position distorts it)
			short measure = pChord->m_chordsel.Measure();
			BYTE beat = pChord->m_chordsel.Beat();
			m_pChordMapMgr->m_pTimeline->MeasureBeatToPosition( m_pChordMapMgr->m_dwGroupBits, 0,
																pChord->m_chordsel.Measure(),
																pChord->m_chordsel.Beat(),
																&position);

			POINTS ptNewPoint;
			ptNewPoint.x = static_cast<short>(position);
			ptNewPoint.y = y;
			y += 20;
			if(y > strip_height)
			{
				y = 0;
			}
			if( FAILED(SetChordXY( pChord, ptNewPoint )) ) // If user clicks end of timeline then method should fail (it currently does not).
			{
				delete pChord;
				break;
			}

			pChord->m_chordsel.Measure() = measure;
			pChord->m_chordsel.Beat() = beat;
			m_pChordMapMgr->m_pChordMapList->AddTail( pChord );
			ClearSelectedChords();
			ClearSelectedConnections();
			pChord->m_chordsel.KeyDown() = TRUE;	// new inserted chord is selected
//			pChordChange = pChord;					// notify client of selected chord
			m_fSelected = TRUE;
			m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
		}
		else
		{
			ASSERT(FALSE);
			break;
		}
	}
	return hr;
}


HRESULT CChordMapStrip::NormalizeChordList(CChordList& list, long beatOffset, 
									long* pFirstMeasure, long* pFirstBeat,
									long* pLastMeasure, long* pLastBeat)
//
// normalize using strip's timesig, also returns min/max measure/beat of list if user asks for it
//
{
	long bpm;
	HRESULT hr = E_FAIL;
	long minBeats = 0x7fffffff;
	long maxBeats = 0;
	long totalBeats;
	long beatLength;
	CChordItem* pChord = 0;
	if(SUCCEEDED(m_pChordMapMgr->GetTimeSig(&bpm, 0)))
	{
		hr = S_OK;
		for(pChord = list.GetHead(); pChord; pChord = pChord->GetNext())
		{
			totalBeats = pChord->Measure()*bpm + pChord->Beat();
			if(totalBeats < minBeats)
				minBeats = totalBeats;
			if(totalBeats > maxBeats)
				maxBeats = totalBeats;
		}
		
		VARIANT var;
		m_pChordMapMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var);
		long m,b;
		m_pChordMapMgr->m_pTimeline->ClocksToMeasureBeat(0xFFFFFFFF, 0, V_I4(&var), &m, &b);
		beatLength = m*bpm + b;
		if( (maxBeats + beatOffset) > beatLength)
		{
			CString msg;
			msg.LoadString(IDS_PASTE_TOOLONG);
			AfxMessageBox(msg);
			hr = E_FAIL;
		}
		else
		{
			for(pChord = list.GetHead(); pChord; pChord = pChord->GetNext())
			{
				totalBeats = pChord->Measure()*bpm + pChord->Beat() - minBeats + beatOffset;
				pChord->Measure() = short(totalBeats / bpm);
				pChord->Beat() = char(totalBeats - (pChord->Measure() * bpm));
			}
			if(pFirstMeasure)
				*pFirstMeasure = minBeats/bpm;
			if(pFirstBeat)
				*pFirstBeat = minBeats - (minBeats/bpm)*bpm;
			if(pLastMeasure)
				*pLastMeasure = maxBeats/bpm;
			if(pLastBeat)
				*pLastBeat = maxBeats - (maxBeats/bpm)*bpm;
		}
	}
	return hr;
}


HRESULT CChordMapStrip::NormalizeChordList(ChordEntryList& list, long beatOffset,
									long* pFirstMeasure, long* pFirstBeat,
									long* pLastMeasure, long* pLastBeat)
//
// normalize using strip's timesig, also returns min/max measure/beat of list if user asks for it
//
{
	long bpm;
	HRESULT hr = E_FAIL;
	long minBeats = 0x7fffffff;
	long maxBeats = 0;
	long totalBeats;
	long beatLengthMap;
	long beatLengthList;
	ChordEntry* pChord;
	if(SUCCEEDED(m_pChordMapMgr->GetTimeSig(&bpm, 0)))
	{
		hr = S_OK;
		for(pChord = list.GetHead(); pChord; pChord = pChord->GetNext())
		{
			totalBeats = pChord->m_chordsel.Measure()*bpm + pChord->m_chordsel.Beat();
			if(totalBeats < minBeats)
				minBeats = totalBeats;
			if(totalBeats > maxBeats)
				maxBeats = totalBeats;
		}

		VARIANT var;
		m_pChordMapMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var);
		long m,b;
		m_pChordMapMgr->m_pTimeline->ClocksToMeasureBeat(0xFFFFFFFF, 0, V_I4(&var), &m, &b);
		beatLengthMap = m*bpm + b;
		beatLengthList = maxBeats - minBeats;

		// check not needed
		if(false && (beatLengthList + beatOffset) > beatLengthMap)
		{
			CString msg;
			msg.LoadString(IDS_PASTE_TOOLONG);
			AfxMessageBox(msg);
			hr = E_FAIL;
		}
		else
		{
			long excessBeats = 0;
			for(pChord = list.GetHead(); pChord; pChord = pChord->GetNext())
			{
				totalBeats = pChord->m_chordsel.Measure()*bpm + pChord->m_chordsel.Beat() 
								 + beatOffset;
				if((totalBeats - beatLengthMap) >= 0)
				{
					excessBeats = (totalBeats-beatLengthMap+1);
				}
				pChord->m_chordsel.Measure() = short(totalBeats / bpm);
				pChord->m_chordsel.Beat() = char(totalBeats - (pChord->m_chordsel.Measure() * bpm));
			}

			if(excessBeats > 0)
			{
				for(ChordEntry* pChord = list.GetHead(); pChord; pChord = pChord->GetNext())
				{
					long beats = pChord->m_chordsel.Measure()*bpm + pChord->m_chordsel.Beat();
					beats -= excessBeats;
					pChord->m_chordsel.Measure() = (short)(beats / bpm);
					pChord->m_chordsel.Beat() = (BYTE)(beats  %  bpm);
				}
			}

			if(pFirstMeasure)
				*pFirstMeasure = minBeats/bpm;
			if(pFirstBeat)
				*pFirstBeat = minBeats - (minBeats/bpm)*bpm;
			if(pLastMeasure)
				*pLastMeasure = maxBeats/bpm;
			if(pLastBeat)
				*pLastBeat = maxBeats - (maxBeats/bpm)*bpm;
		}
	}
	return hr;
}

HRESULT CChordMapStrip::ChordEntryPasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, 
										  POINTL pt, bool bDropNotEditPaste)
{
	ChordEntry* pRefChord = NULL;	// chord at drag point
	bool bOrphanCheck = false;
	if( pITimelineDataObject == NULL )
	{
		return E_NOTIMPL;
	}

	HRESULT hr = E_FAIL;

	if( pITimelineDataObject->IsClipFormatAvailable( m_cfChordMapList ) == S_OK )
	{
		IStream* pIStream;
		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfChordMapList, &pIStream)))
		{
			LARGE_INTEGER liTemp;
			// seek to beginning of stream
			liTemp.QuadPart = 0;
			pIStream->Seek(liTemp, STREAM_SEEK_SET, NULL);
			// declare a temp list and write chords into it
			ChordEntryList list;
			hr = DMLoadChordData(list, pIStream);
			pIStream->Release();
			if(list.GetHead() == NULL)
			{
				// don't drop an empty list
				hr = E_FAIL;
				goto Leave;
			}
			else if(bDropNotEditPaste)
			{
				// this is normally set in drag over, we need to make sure its set for paste as well
				ChordEntry* pRefChord = list.GetHead();
				if(pRefChord)
				{
					GetBoundingRectRelativeToChord(list, pRefChord, m_rectAggregate);
				}
			}
			// update times from position of drop
			
			if( m_pChordMapMgr->m_pTimeline )
			{
				// get offset of first chord's drag position to normalize all chords to offset zero:
				long beatDragOffset ;
				// convert drop postition to beats
				long position = pt.x;
				long beatDropOffset;
				long firstBeat = 0, lastBeat = 0;
				long firstMeasure = 0, lastMeasure = 0;
				long m,b;
				long timesigBPM, offset;
				bool bFromPalette = m_startDragPosition.x < 0;
				if(SUCCEEDED(m_pChordMapMgr->m_pTimeline->PositionToMeasureBeat( m_pChordMapMgr->m_dwGroupBits, 0, position, &m, &b)))
				{
					// convert measure/beat to beats in the timesig of the target
					m_pChordMapMgr->GetTimeSig(&timesigBPM, 0);
					if(bDropNotEditPaste)
					{
						beatDropOffset = m*timesigBPM + b;
						// check that we've actually "moved" somewhere.  If not cancel the drop
						if(m_pISourceDataObject == m_pITargetDataObject && !bFromPalette)
						{
							// we're in our strip, check if we've moved
							long deltapos = abs(pt.x - m_startDragPosition.x);
							long m,b;
							m_pChordMapMgr->m_pTimeline->PositionToMeasureBeat( m_pChordMapMgr->m_dwGroupBits, 0, deltapos, &m, &b);
							if(m == 0 && b < 1 && (abs(pt.y - m_startDragPosition.y) < 2))
							{
								hr = E_FAIL;
							}
							else if(m_dwOverDragEffect == DROPEFFECT_MOVE)
							{
								// save drop point -- need to let source thread handle rest of it
								// so we can do different things on a move or copy
								if(ContainsSignpost(list))
								{
									// adjust drop point so it is integral number of measures from
									// drag point
									long clocks, clocksPerMeasure;
									
									deltapos = pt.x - m_startDragPosition.x;
									PositionToClocks(deltapos, clocks);
									clocksPerMeasure = ClocksPerMeasure();
									if(clocks >= 0)
									{
										clocks = (clocks / clocksPerMeasure) * clocksPerMeasure;
									}
									else
									{
										clocks = ( (clocks/clocksPerMeasure) - 1 ) * clocksPerMeasure;
									}
									ClocksToPosition(clocks, deltapos);
									pt.x = m_startDragPosition.x + deltapos + 1;

									if(pt.x < 0)
									{
										// oops went too far, correct.
										ClocksToPosition(clocksPerMeasure, deltapos);
										pt.x += deltapos;
									}
									
								}
								m_ptDrop.x = static_cast<short>(pt.x);
								m_ptDrop.y = static_cast<short>(pt.y);
								m_bInternalDrop = true;
								hr = S_OK;
//								InternalDrop(ptDrop);
							}
							else
							{
								m_bInternalDrop = false;	
							}
							if(!(hr==S_OK) || m_bInternalDrop)
							{
								list.ClearList();
								goto Leave;
							}
						}
						// offset measure/beat in chords to be drop
						// first find selected chord
						ChordEntry* pChord = NULL;
						bool bContainsSignpost = false;
						long beatFirstChord = 0;
						pRefChord = 0;
						ChordEntry* pFirstChord = NULL;
						for(pChord = list.GetHead(); pChord; pChord = pChord->GetNext()) 
						{
							// find chord where mouse is
							if(pChord->m_chordsel.KeyDown())
							{
								pRefChord = pChord;
							}
							// got signposts?
							if( (pChord->m_dwflags & CE_START) || (pChord->m_dwflags & CE_END) )
							{
								bContainsSignpost = true;
							}
							// find earliest chord
							if(pFirstChord == 0)
							{
								pFirstChord = pChord;
							}
							else if(pChord->m_chordsel.Measure() < pFirstChord->m_chordsel.Measure())
							{
								pFirstChord = pChord;
							}
							else if(pChord->m_chordsel.Measure() == pFirstChord->m_chordsel.Measure()
									&& pChord->m_chordsel.Beat() < pFirstChord->m_chordsel.Beat())
							{
								pFirstChord = pChord;
							}
						}
						if(pRefChord)
						{
							// this is selected chord: use it as the drag offset
							// convert its measure/beat to beats
							beatDragOffset = pRefChord->m_chordsel.Measure()*timesigBPM + pRefChord->m_chordsel.Beat();
						}
						else
						{
							// no chord selected, list came from somewhere else, dragoffset = 0
							beatDragOffset = 0;
						}
						offset = beatDropOffset - beatDragOffset;
						if(bContainsSignpost)
						{
							// adjust offset to an integral number of beats
							if( (offset < 0) && ( (-offset % timesigBPM) != 0))
							{
								offset = offset - (timesigBPM - (-offset)%timesigBPM);
							}
							else if((offset % timesigBPM) != 0)
							{
								offset = offset - offset%timesigBPM;
							}
							// make sure no negative chords, since pRefChord is first chord,
							// this means when(pRefChord) + offset <= 0 while maintaining
							// offset % timesigBPM
							beatFirstChord = pFirstChord->m_chordsel.Measure()*timesigBPM + pFirstChord->m_chordsel.Beat();
							while( (beatFirstChord + offset) < 0)
							{
								offset += timesigBPM;
							}
						}
					}
					else
					{
						bool bContainsSignpost = false;
						// paste, need refchord to be earliest chord
						pRefChord = 0;
						for(ChordEntry* pChord = list.GetHead(); pChord; pChord = pChord->GetNext())
						{
							if( (pChord->m_dwflags & CE_START) || (pChord->m_dwflags & CE_END) )
							{
								bContainsSignpost = true;
							}
							if(pRefChord == 0)
							{
								pRefChord = pChord;
							}
							else if(pChord->m_chordsel.Measure() < pRefChord->m_chordsel.Measure())
							{
								pRefChord = pChord;
							}
							else if(pChord->m_chordsel.Measure() == pRefChord->m_chordsel.Measure()
									&& pChord->m_chordsel.Beat() < pRefChord->m_chordsel.Beat())
							{
								pRefChord = pChord;
							}
						}
						beatDropOffset = m*timesigBPM + b;
						beatDragOffset = pRefChord->m_chordsel.Measure()*timesigBPM + pRefChord->m_chordsel.Beat();
						offset = beatDropOffset - beatDragOffset;
						if(bContainsSignpost)
						{
							// adjust offset to an integral number of beats
							if( (offset < 0) && ( (-offset % timesigBPM) != 0))
							{
								offset = offset - (timesigBPM - (-offset)%timesigBPM);
							}
							else if((offset % timesigBPM) != 0)
							{
								offset = offset - offset%timesigBPM;
							}
							// make sure no negative chords, since pRefChord is first chord,
							// this means when(pRefChord) + offset <= 0 while maintaining
							// offset % timesigBPM
							while( (beatDragOffset + offset) < 0)
							{
								offset += timesigBPM;
							}
						}
					}
					hr = NormalizeChordList(list, offset, &firstMeasure, &firstBeat, &lastMeasure, &lastBeat);
					if(hr != S_OK)
					{
						list.ClearList();
						goto Leave;
					}
					m_pChordMapMgr->SendEditNotification(IDS_UNDO_PasteChord);
					UnMarkChords(list, CE_DRAGSELECT);
					m_pChordMapMgr->m_pTimeline->Refresh();
					hr = MergeChords(list, pt, pRefChord, bDropNotEditPaste);
					ResolveConnections();
					for(ChordEntry* pChord = list.GetHead(); pChord; pChord = pChord->GetNext())
					{
						if( (pChord->m_dwflags & CE_START) || (pChord->m_dwflags & CE_END))
						{
							bOrphanCheck = true;
						}
					}
					list.ClearList();

					m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
					if(bOrphanCheck)
					{
						m_pChordMapMgr->m_pTimeline->OnDataChanged(new CheckForOrphansNotification);
					}
					DoPropertyPage(m_pChordMapMgr->m_selection);
/*
					if( m_pChordMapMgr->m_pPropPageMgr )
					{
						m_pChordMapMgr->m_pPropPageMgr->RefreshData();
					}
*/
					m_pChordMapMgr->m_pTimeline->OnDataChanged(0);
					m_pChordMapMgr->m_pTimeline->Refresh();

				}
				else
				{
					ASSERT(0);
				}
			}
			else
			{
				list.ClearList();
			}
		}
	}

Leave:	
	return hr;
	
}

HRESULT CChordMapStrip::ChordItemPasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, POINTL pt, bool bDropNotEditPaste)
{
	if( pITimelineDataObject == NULL )
	{
		return E_NOTIMPL;
	}

	HRESULT hr = E_FAIL;

	if( pITimelineDataObject->IsClipFormatAvailable( m_cfChordList ) == S_OK )
	{
		IStream* pIStream;
		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfChordList, &pIStream)))
		{
			LARGE_INTEGER liTemp;
			// seek to beginning of stream
			liTemp.QuadPart = 0;
			pIStream->Seek(liTemp, STREAM_SEEK_SET, NULL);
			// declare a temp list and write chords into it
			CChordList list;
			list.Load(pIStream);
			pIStream->Release();
			if(list.GetHead() == NULL)
			{
				// don't drop an empty list
				hr = E_FAIL;
				goto Leave;
			}
			// update times from position of drop
			
			if( m_pChordMapMgr->m_pTimeline )
			{
				// get offset of first chord's drag position to normalize all chords to offset zero:
				long beatDragOffset ;
				// convert drop postition to beats
				long position = pt.x;
				long beatDropOffset;
				long firstBeat = 0, lastBeat = 0;
				long firstMeasure = 0, lastMeasure = 0;
				long m,b;
				long timesigBPM, offset;
				bool bFromPalette = m_startDragPosition.x < 0;
				if(SUCCEEDED(m_pChordMapMgr->m_pTimeline->PositionToMeasureBeat( m_pChordMapMgr->m_dwGroupBits, 0, position, &m, &b)))
				{
					// convert measure/beat to beats in the timesig of the target
					m_pChordMapMgr->GetTimeSig(&timesigBPM, 0);
					if(bDropNotEditPaste)
					{
						beatDropOffset = m*timesigBPM + b;
						// check that we've actually "moved" somewhere.  If not cancel the drop
						if(m_pISourceDataObject == m_pITargetDataObject && !bFromPalette)
						{
							// we're in our strip, check if we've moved
							long deltapos = abs(pt.x - m_startDragPosition.x);
							long m,b;
							m_pChordMapMgr->m_pTimeline->PositionToMeasureBeat( m_pChordMapMgr->m_dwGroupBits, 0, deltapos, &m, &b);
							if(m == 0 && b < 1 && (abs(pt.y - m_startDragPosition.y) < 2))
							{
								hr = E_FAIL;
							}
							else
							{
								// save drop point -- need to let source thread handle rest of it
								// so we can do different things on a move or copy
								m_ptDrop.x = static_cast<short>(pt.x);
								m_ptDrop.y = static_cast<short>(pt.y);
								m_bInternalDrop = true;
								hr = S_OK;
//								InternalDrop(ptDrop);
							}
							list.ClearList();
							goto Leave;
						}
						// offset measure/beat in chords to be drop
						// first find selected chord
						CChordItem* pChord = NULL;
						for(pChord = list.GetHead(); pChord && !pChord->IsSelected(); pChord = pChord->GetNext()) 
						{
							continue;
						}
						BOOL bNotFromPalette = true;
						if(pChord && bNotFromPalette)
						{
							// this is selected chord: use it as the drag offset
							// convert its measure/beat to beats
							beatDragOffset = pChord->Measure()*timesigBPM + pChord->Beat();
							// if this is from the signpost list, then no drop offset, chords go
							// at beginning and end if signpost, at end if cadence
//							if(pChord->IsSignPost())
//							{
//								beatDropOffset = 0;
//							}
						}
						else
						{
							// no chord selected, list came from somewhere else, dragoffset = 0
							beatDragOffset = 0;
						}
						offset = beatDropOffset - beatDragOffset;
						if(offset < 0)
						{
							offset = 0;
						}
					}
					else
					{
						offset = m*timesigBPM + b;
					}
					hr = NormalizeChordList(list, offset, &firstMeasure, &firstBeat, &lastMeasure, &lastBeat);
					if(hr != S_OK)
					{
						list.ClearList();
						goto Leave;
					}
					m_pChordMapMgr->SendEditNotification(IDS_UNDO_PasteChord);
					hr = InsertChords(list, pt);
					ResolveConnections();
					// if any of chords are signpost, link chords
					for(CChordItem* pChord = list.GetHead(); pChord ; pChord = pChord->GetNext())
					{
						if(pChord->IsSignPost())
						{
							m_pChordMapMgr->m_pTimeline->OnDataChanged(new CheckForOrphansNotification);
							break;
						}
					}

					

					list.ClearList();



					m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
					DoPropertyPage(m_pChordMapMgr->m_selection);
					
					/*
					if( m_pChordMapMgr->m_pPropPageMgr )
					{
						m_pChordMapMgr->m_pPropPageMgr->RefreshData();
					}
					*/

					m_pChordMapMgr->m_pTimeline->OnDataChanged(0);
					m_pChordMapMgr->m_pTimeline->Refresh();

				}
				else
				{
					ASSERT(0);
				}
			}
			else
			{
				list.ClearList();
			}
		}
	}

Leave:	
	return hr;
	
}



HRESULT CChordMapStrip::FBPasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, POINTL pt, bool bDropNotEditPaste)
{
	if( pITimelineDataObject == NULL )
	{
		return E_NOTIMPL;
	}

	HRESULT hr = E_FAIL;

	if( pITimelineDataObject->IsClipFormatAvailable( m_cfChordList ) == S_OK )
	{
		IStream* pIStream;
		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfChordList, &pIStream)))
		{
			LARGE_INTEGER liTemp;
			// seek to beginning of stream
			liTemp.QuadPart = 0;
			pIStream->Seek(liTemp, STREAM_SEEK_SET, NULL);
			// declare a temp list and write chords into it
			CChordList list;
			list.Load(pIStream);
			pIStream->Release();
			if(list.GetHead() == NULL)
			{
				// don't drop an empty list
				hr = E_FAIL;
				goto Leave;
			}
			// update times from position of drop	
			POINTS pts;
			pts.x = static_cast<short>(pt.x);
			pts.y = static_cast<short>(pt.y);

			long index = PaletteChordIndexFromCoords(pts);

			bool bFromPalette = m_startDragPosition.x < 0;

			if(bFromPalette && m_startDragPosition.x == pt.x)
			{
				// we're dropping on where we started, cancel paste at
				hr = E_FAIL;
				list.ClearList();
				goto Leave;
			}
			
			// put chord in palette
			m_pChordMapMgr->SendEditNotification(IDS_UNDO_PastePalette);
			ChordEntry ce;
			ce.LoadFromChordItem(*list.GetHead());
			ChordSelection& chordsel = m_pChordMapMgr->m_pChordPalette->Chord(index);
			dynamic_cast<DMPolyChord&>(chordsel) = ce.m_chordsel;
			list.ClearList();
			// convert root to match postion in palette
			chordsel.Base()->ChordRoot() = static_cast<unsigned char>(index);
			hr = S_OK;
			// select only dropped chord
			ClearPaletteSelections();
			chordsel.KeyDown() = true;
//			m_pChordMapMgr->m_pTimeline->OnDataChanged(0);
			m_pChordMapMgr->m_pTimeline->Refresh();

		}
	}
Leave:	
	return hr;
	
}

// IDropSource Methods
HRESULT CChordMapStrip::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton & MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton & MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}

HRESULT CChordMapStrip::GiveFeedback( DWORD dwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pDragImage )
	{
		CPoint pt;

		GetCursorPos( &pt );

		// Move the drag image
		m_pDragImage->DragMove( pt );
	}

	return DRAGDROP_S_USEDEFAULTCURSORS;
}

CImageList* CChordMapStrip::CreateDragImage()
{
	CImageList* pimage = new CImageList;
	ASSERT(pimage);
	if(!pimage)
	{
		return 0;
	}
	pimage->Create(::GetSystemMetrics(SM_CXICON), ::GetSystemMetrics(SM_CYICON),
					ILC_COLOR4 | ILC_MASK, 1,1);
	pimage->SetBkColor(CLR_NONE);
	HICON hIcon = ::LoadIcon( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_CHORDTRUCK));
	pimage->Add(hIcon);
	return pimage;
}

HRESULT	CChordMapStrip::CreateDataObject(IDataObject** ppIDataObject, POINTS where)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Selected Chords into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( m_pChordMapMgr->m_pJazzFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		ChordEntry* pChordAtDragPoint;
		hr = GetClickedChord(where, &pChordAtDragPoint);
		ASSERT(pChordAtDragPoint);
		m_pDragChord = pChordAtDragPoint;
		TRACE("drag chord created, addr = %p\n");
		if(!SUCCEEDED(hr))
		{
			ASSERT(FALSE);
			pIStream->Release();
			return hr;
		}
		// mark the chords as being dragged: this used later for deleting chords in drag move
		MarkSelectedChords(CE_DRAGSELECT);
//		pChordAtDragPoint = FirstSelectedChord();
		if( SUCCEEDED ( SaveSelectedChords( pIStream, pChordAtDragPoint, TRUE ) ) )
		{
			// Place CF_CHORDLIST into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_cfChordMapList, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		pIStream->Release();
	}


	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;

}


// create data object from chord palette
HRESULT	CChordMapStrip::CreateDataObject(IDataObject** ppIDataObject, int index)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Selected Chords into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( m_pChordMapMgr->m_pJazzFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		ChordEntry* pChordAtDragPoint = new ChordEntry;
		ASSERT(pChordAtDragPoint);
		if(!pChordAtDragPoint)
		{
			hr = E_FAIL;
			pIStream->Release();
			return hr;
		}
		CChordItem* pChordItem = new CChordItem(m_pChordMapMgr->m_pChordPalette->Chord(index));
		ASSERT(pChordItem);
		if(!pChordItem)
		{
			hr = E_FAIL;
			pIStream->Release();
			return hr;
		}
		pChordItem->Measure() = 0;
		pChordItem->Beat() = 0;
		pChordAtDragPoint->LoadFromChordItem(*pChordItem);
		m_pDragChord = pChordAtDragPoint;
		CChordList list;
		list.AddTail(pChordItem);
		TRACE("drag chord created, addr = %p\n");
		hr = list.Save(pIStream, FALSE);
		list.ClearList();
		if( SUCCEEDED(hr))
		{
			// Place CF_CHORDLIST into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_cfChordList, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		pIStream->Release();
	}


	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;

}


ChordEntry* CChordMapStrip::FirstSelectedChord()
{
	ChordEntry* pFoundChord = NULL;
	for(ChordEntry* pChord = m_pChordMapMgr->m_pChordMapList->GetHead(); pChord; pChord = pChord->GetNext())
	{
		if(pChord->m_chordsel.KeyDown())
		{
			pFoundChord = pChord;
			break;
		}
	}
	return pFoundChord;
}

void CChordMapStrip::MarkSelectedChords(DWORD flags)
{
	for(ChordEntry* pChord = m_pChordMapMgr->m_pChordMapList->GetHead(); pChord; pChord = pChord->GetNext())
	{
		if(pChord->m_chordsel.KeyDown())
			pChord->m_dwflags |= flags;
	}
}

HRESULT CChordMapStrip::SaveSelectedChordItems(LPSTREAM pStream, ChordEntry* pChordAtDragPoint, BOOL bNormalize)
{
	ASSERT(pStream);
	ASSERT(pChordAtDragPoint);
	CChordList list;
	ChordEntry* pChord;
	CChordItem* pItem;
	long offset;
	// copy selected chords to list
	for(pChord = m_pChordMapMgr->m_pChordMapList->GetHead(); pChord; pChord = pChord->GetNext())
	{
		if(pChord->m_chordsel.KeyDown())
		{
			// make sure that only the chord at the mouse drag point is selected
//			pChord->m_chordsel.KeyDown() = (pChord == pChordAtDragPoint) ? TRUE : FALSE;
			list.AddTail(new CChordItem(*pChord));
			// re-select chord
//			pChord->m_chordsel.KeyDown() = TRUE;
		}

	}
	// check that anything is selected
	if(!list.GetHead())
		return E_FAIL;
	// normalize chords so that first chord is at offset 0
	if(bNormalize)
	{
		pItem = list.GetHead();
		long bpm;
		m_pChordMapMgr->GetTimeSig(&bpm, 0);
		offset = pItem->Measure()*bpm + pItem->Beat();
		NormalizeChordList(list, -offset);

	}
	HRESULT hr = list.Save(pStream, FALSE, FT_DESIGN);
	list.ClearList();
	return hr;
}

HRESULT CChordMapStrip::SaveSelectedChords(LPSTREAM pStream, ChordEntry* pChordAtDragPoint, BOOL bNormalize)
{
	ASSERT(pStream);
	ASSERT(pChordAtDragPoint);
	ChordEntryList list;
	ChordEntry* pChord;
	long offset;
	// add drag chord to head of list
	pChord = new ChordEntry(*pChordAtDragPoint);
	pChord->CopyNextList(*pChordAtDragPoint, TRUE);
	pChord->m_chordsel.KeyDown() = TRUE;
	list.AddHead(pChord);
	// copy selected chords to list
	for(pChord = m_pChordMapMgr->m_pChordMapList->GetHead(); pChord; pChord = pChord->GetNext())
	{
		if(pChord->m_chordsel.KeyDown() && pChord != pChordAtDragPoint)
		{
			// make new copy of chord
			ChordEntry* pNewChord = new ChordEntry(*pChord);
			pNewChord->CopyNextList(*pChord, TRUE);
			pNewChord->m_chordsel.KeyDown() = FALSE;
			list.AddTail(pNewChord);
		}
	}
	// check that anything is selected
	if(!list.GetHead())
		return E_FAIL;
	// normalize chords so that first chord is at offset 0
	if(bNormalize)
	{
		pChord = list.GetHead();
		long bpm;
		m_pChordMapMgr->GetTimeSig(&bpm, 0);
		offset = pChord->m_chordsel.Measure()*bpm + pChord->m_chordsel.Beat();
//		NormalizeChordList(list, -offset);

	}
	
	HRESULT hr = DMSaveChordData(list, pStream, true);
	list.ClearList();
	return hr;
}



void CChordMapStrip::DeleteMarkedChords(DWORD flags)
{
	for(ChordEntry *pChord = m_pChordMapMgr->m_pChordMapList->GetHead();pChord != NULL;	)
	{
		if( !(pChord->m_dwflags & flags) )
		{
			// chord not selected, continue
			pChord = pChord->GetNext();
			continue;
		}
		// Delete the Chord and get the next chord in the list.
		int nOldID = pChord->m_nid;
		m_pChordMapMgr->m_pChordMapList->Remove(pChord);
		delete pChord;
		pChord = m_pChordMapMgr->m_pChordMapList->GetHead();
		
		// Remove all Connections to this Chord ID
		DeleteAllConnections( nOldID );

		// Resolve connections
		ResolveConnections();
	}
}

void CChordMapStrip::UnMarkChords(DWORD flags)
{
	for(ChordEntry* pChord = m_pChordMapMgr->m_pChordMapList->GetHead(); pChord; pChord = pChord->GetNext())
	{
		pChord->m_dwflags &= ~flags;
	}
}

void CChordMapStrip::UnMarkChords(ChordEntryList& list, DWORD flags)
{
	for(ChordEntry* pChord = list.GetHead(); pChord; pChord = pChord->GetNext())
	{
		pChord->m_dwflags &= ~flags;
	}
}


/* old single chord version
void CChordMapStrip::InternalMove(POINTS ptDrop)
{
	ASSERT(m_pDragChord);
	if( m_pDragChord)
	{
		// Move the Chord.
		ClearSelectedChords();
		ClearSelectedConnections();
		m_pDragChord->m_chordsel.KeyDown() = TRUE;
		m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
		SetNewChordXY( ptDrop );

		m_fSelected = FALSE;
		m_fDragging = FALSE;

		// need this since SetNewChordXY clears selection
		m_pDragChord->m_chordsel.KeyDown() = TRUE;


	}
}
*/

POINTS operator+(POINTS pt1, POINTS pt2)
{
	POINTS pt;
	pt.x = pt1.x + pt2.x;
	pt.y = pt1.y + pt2.y;
	return pt;
}
POINTS operator-(POINTS pt1, POINTS pt2)
{
	POINTS pt;
	pt.x = pt1.x - pt2.x;
	pt.y = pt1.y - pt2.y;
	return pt;
}

POINTS GetChordTopLeft(ChordEntry* pChord)
{
	POINTS pt;
	pt.x = pChord->m_rect.left;
	pt.y = pChord->m_rect.top;
	return pt;
}
void CChordMapStrip::InternalMove(POINTS ptDrop)
{
	ASSERT(m_pDragChord);
	if(!m_pDragChord)
		return;

	// get needed timeline props
	VARIANT			var;
	int strip_height = GetStripHeight();
	m_pChordMapMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var);
	int clocks = V_I4(&var);
	m_pChordMapMgr->m_pTimeline->GetTimelineProperty( TP_VERTICAL_SCROLL, &var );	
	short vpos = (short)V_I4(&var);
	m_pChordMapMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var );	
	short hpos = (short)V_I4(&var);
	long strip_width;
	m_pChordMapMgr->m_pTimeline->ClocksToPosition(clocks, &strip_width);
	

	// need later to check right boundary
	m_pChordMapMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var);
	clocks = V_I4(&var);
	long lengthInMeasures, lengthInBeats, timesigBPM;
	m_pChordMapMgr->m_pTimeline->ClocksToMeasureBeat(m_pChordMapMgr->m_dwGroupBits, 0,
									clocks,
									&lengthInMeasures, &lengthInBeats);
	m_pChordMapMgr->GetTimeSig(&timesigBPM, 0);
	lengthInBeats = lengthInMeasures*timesigBPM + lengthInBeats;

	// get bounding rect and translate its top left courner to drop/past point
	RECT rect;
	GetBoundingRectOfSelectedChords(rect);

	short xtrans = (short)(ptDrop.x - m_startDragPosition.x);
	short ytrans = (short)(ptDrop.y - m_startDragPosition.y);

	// translate all selected (dropped) chords
	long excessBeats = 0;
	long underflow = 0;
	for(ChordEntry* pChord = m_pChordMapMgr->m_pChordMapList->GetHead(); pChord; pChord = pChord->GetNext())
	{
		if(pChord->m_chordsel.KeyDown() == TRUE)
		{
			POINTS ptNewPoint;
			ptNewPoint.x = pChord->m_rect.left + xtrans;
			ptNewPoint.y = pChord->m_rect.top + ytrans;
			
			SetChordXY(pChord,	ptNewPoint);
			pChord->m_chordsel.KeyDown() = TRUE;

			long beats = pChord->m_chordsel.Measure()*timesigBPM + pChord->m_chordsel.Beat();
			if((beats-lengthInBeats) >= excessBeats)
			{
				excessBeats = (beats-lengthInBeats+1);
			}
			if(beats < 0 && beats < underflow)
			{
				underflow = beats;
			}
		}
	}

	if( /*!SelectedChordsContainsSignpost() && */(excessBeats > 0 || underflow < 0) )
	{
		if(SelectedChordsContainsSignpost())
		{
			long bpm;
			long beat;
			m_pChordMapMgr->GetTimeSig(&bpm, &beat);
			excessBeats = excessBeats > 0 ? excessBeats + bpm - (excessBeats % bpm) : 0;
			underflow = underflow < 0 ? underflow - (bpm - ((-underflow) % bpm)) : 0;
		}
		for(ChordEntry* pChord = m_pChordMapMgr->m_pChordMapList->GetHead(); pChord; pChord = pChord->GetNext())
		{
			if(pChord->m_chordsel.KeyDown() == TRUE)
			{
				long beats = pChord->m_chordsel.Measure()*timesigBPM + pChord->m_chordsel.Beat();
				beats -= excessBeats;
				beats -= underflow;
				pChord->m_chordsel.Measure() = (short)(beats / timesigBPM);
				pChord->m_chordsel.Beat() = (BYTE)(beats % timesigBPM);
			}
		}
	}

	m_fDragging = FALSE;
}


ChordEntry* CChordMapStrip::InternalCopy(POINTS ptDrop)
{
	ChordEntry *pChord = 0;

	pChord = new ChordEntry(*m_pDragChord);

	NextChord* pNextChord = new NextChord;
	if( pNextChord == NULL )
	{
		delete pChord;
		return 0;
	}

	pNextChord->m_parent = pChord;
	pChord->m_nextchordlist.AddTail(pNextChord);

	ZeroMemory( &(pChord->m_rect), sizeof(pChord->m_rect) );
	ZeroMemory( &(pChord->m_lastrect), sizeof(pChord->m_lastrect) );

	((SmallChordEntry*)pChord)->m_nid = m_pChordMapMgr->m_nIDCounter++;

	// Set new Chord (UI Box) where the user clicked the mouse.
	if( FAILED(SetChordXY( pChord, ptDrop )) ) // If user clicks end of timeline then method should fail (it currently does not).
	{
		delete pChord;
		pChord = 0;
	}

	m_pChordMapMgr->m_pChordMapList->AddTail( pChord );
	ClearSelectedChords();
	pChord->m_chordsel.KeyDown() = TRUE;	// new inserted chord is selected
	return pChord;
}



/////////////////////////////////////////////////////////////////////////////
// CChordMapStrip IDMUSProdTimelineEdit

HRESULT CChordMapStrip::Cut( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr;

	hr = CanCut();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	hr = Copy(pITimelineDataObject);
	if( SUCCEEDED( hr ))
	{
		hr = Delete();
	}

	return hr;
}

HRESULT CChordMapStrip::Copy( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;
	IStream*			pStreamCopy;

	if(m_pChordMapMgr->m_selection == CChordMapMgr::PaletteSelected)
	{
		return Copy(pITimelineDataObject, m_pChordMapMgr->m_nSelectedIndex);
	}

	hr = CanCopy();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pChordMapMgr != NULL );
	if( m_pChordMapMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfChordMapList == 0 )
	{
		m_cfChordMapList = RegisterClipboardFormat( CF_CHORDMAP_LIST );
		if( m_cfChordMapList == 0 )
		{
			return E_FAIL;
		}
	}
	if( m_cfChordList == 0)
	{
		m_cfChordList = RegisterClipboardFormat( CF_CHORDLIST );
		if( m_cfChordList == 0)
		{
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected commands in.
//	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );
	hr = m_pChordMapMgr->m_pJazzFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pStreamCopy);
	
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	// Save the commands into the stream.
	MarkSelectedChords(CE_DRAGSELECT);
	// make sure chord at cursor is first
	ChordEntry* pChordAtDragPoint = 0;
	hr = GetClickedChord(m_ptLastMouse, &pChordAtDragPoint);
	if(FAILED(hr) || pChordAtDragPoint==0)
	{
		pChordAtDragPoint = FirstSelectedChord();
	}
	hr = SaveSelectedChords( pStreamCopy, pChordAtDragPoint, TRUE );
	if( FAILED( hr ))
	{
		pStreamCopy->Release();
		return E_UNEXPECTED;
	}

	if(pITimelineDataObject != NULL)
	{
		// add the stream to the passed ITimelineDataObject
		// This only works for chords from chordmap, not for those from palette
		hr = pITimelineDataObject->AddExternalClipFormat( m_cfChordMapList, pStreamCopy );
		pStreamCopy->Release();
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			return E_FAIL;
		}
	}
	// Otherwise, add it to the clipboard
	else
	{
		// There is no existing data object, so just create a new one
		hr = m_pChordMapMgr->m_pTimeline->AllocTimelineDataObject(&pITimelineDataObject);
		ASSERT(hr == S_OK);
		if(hr != S_OK)
		{
			return E_FAIL;
		}

		// Set the start and edit time of this copy
		long lStartTime, lEndTime;
		m_pChordMapMgr->GetBoundariesOfSelectedChords(lStartTime, lEndTime);
		hr = pITimelineDataObject->SetBoundaries(lStartTime, lEndTime);

		// add the stream to the DataObject
		hr = pITimelineDataObject->AddExternalClipFormat( m_cfChordMapList, pStreamCopy );
		pStreamCopy->Release();
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}

		// get the new IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export(&pIDataObject);

		// Release the ITimelineDataObject
		pITimelineDataObject->Release();

		// Exit if the Export failed
		if(FAILED(hr))
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );
		if( hr != S_OK )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// If we already have a CopyDataObject, release it
		if(m_pChordMapMgr->m_pCopyDataObject)
		{
			m_pChordMapMgr->m_pCopyDataObject->Release();
		}

		// set m_pCopyDataObject to the object we just copied to the clipboard
		m_pChordMapMgr->m_pCopyDataObject = pIDataObject;

		// Not needed = Object was AddRef()'d when it was exported from the IDMUSProdTimelineDataObject
		// m_pCopyDataObject->AddRef
	}

	return hr;
}

HRESULT CChordMapStrip::Copy( IDMUSProdTimelineDataObject *pITimelineDataObject, int index )
//
// Copy Palette Chord
//
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;
	IStream*			pStreamCopy;
	CChordItem*			pChordItem;
	CChordList			list;

	bool guard = ( index >=0 && index <= 23 );
	ASSERT(guard);
	if( !guard )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pChordMapMgr != NULL );
	if( m_pChordMapMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfChordMapList == 0 )
	{
		m_cfChordMapList = RegisterClipboardFormat( CF_CHORDMAP_LIST );
		if( m_cfChordMapList == 0 )
		{
			return E_FAIL;
		}
	}
	if( m_cfChordList == 0)
	{
		m_cfChordList = RegisterClipboardFormat( CF_CHORDLIST );
		if( m_cfChordList == 0)
		{
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected commands in.
//	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );
	hr = m_pChordMapMgr->m_pJazzFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pStreamCopy);
	
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	// get palette chord
	pChordItem = new CChordItem(m_pChordMapMgr->m_pChordPalette->Chord(index));
	ASSERT(pChordItem);
	if(!pChordItem)
	{
		return E_OUTOFMEMORY;
	}
	pChordItem->Measure() = 0;
	pChordItem->Beat() = 0;

	list.AddTail(pChordItem);
	hr = list.Save(pStreamCopy, FALSE);
	list.ClearList();

	if(hr != S_OK)
	{
		return E_FAIL;
	}

	if(pITimelineDataObject != NULL)
	{
		// add the stream to the passed ITimelineDataObject
		// This only works for chords from chordmap, not for those from palette
		hr = pITimelineDataObject->AddExternalClipFormat( m_cfChordMapList, pStreamCopy );
		pStreamCopy->Release();
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			return E_FAIL;
		}
	}
	// Otherwise, add it to the clipboard
	else
	{
		// There is no existing data object, so just create a new one
		hr = m_pChordMapMgr->m_pTimeline->AllocTimelineDataObject(&pITimelineDataObject);
		ASSERT(hr == S_OK);
		if(hr != S_OK)
		{
			return E_FAIL;
		}

		// Set the start and edit time of this copy
		long clocksPerBeat;
		m_pChordMapMgr->m_pTimeline->MeasureBeatToClocks(m_pChordMapMgr->m_dwGroupBits, 0, 0, 1, &clocksPerBeat);
		hr = pITimelineDataObject->SetBoundaries(0, clocksPerBeat);

		// add the stream to the DataObject
		hr = pITimelineDataObject->AddExternalClipFormat( m_cfChordList, pStreamCopy );
		pStreamCopy->Release();
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}

		// get the new IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export(&pIDataObject);

		// Release the ITimelineDataObject
		pITimelineDataObject->Release();

		// Exit if the Export failed
		if(FAILED(hr))
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );
		if( hr != S_OK )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// If we already have a CopyDataObject, release it
		if(m_pChordMapMgr->m_pCopyDataObject)
		{
			m_pChordMapMgr->m_pCopyDataObject->Release();
		}

		// set m_pCopyDataObject to the object we just copied to the clipboard
		m_pChordMapMgr->m_pCopyDataObject = pIDataObject;

		// Not needed = Object was AddRef()'d when it was exported from the IDMUSProdTimelineDataObject
		// m_pCopyDataObject->AddRef
	}

	return hr;
}



HRESULT CChordMapStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT				hr;
	
	hr = CanPaste( pITimelineDataObject );
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pChordMapMgr != NULL );
	if( m_pChordMapMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pChordMapMgr->m_pTimeline != NULL );
	if( m_pChordMapMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Make sure everything on the timeline is deselected.
	// JHD 8/5/98: Why is this here?
	/*
	m_bSelecting = TRUE;
	m_pChordMapMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pChordMapMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_bSelecting = FALSE;
	*/
	
	// If the format hasn't been registered yet, do it now.
	if( m_cfChordList == 0 )
	{
		m_cfChordList = RegisterClipboardFormat( CF_CHORDLIST );
		if( m_cfChordList == 0 )
		{
			return E_FAIL;
		}
	}
	if( m_cfChordMapList == 0 )
	{
		m_cfChordMapList = RegisterClipboardFormat( CF_CHORDMAP_LIST );
		if( m_cfChordMapList == 0 )
		{
			return E_FAIL;
		}
	}
	
	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pChordMapMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		pIDataObject->Release();
		if( FAILED(hr) )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}

	// Paste
	POINTL pt;
	pt.x = m_ptLastMouse.x;
	pt.y = m_ptLastMouse.y;

	// do we have enough room to paste?
	long lStart, lEnd, lTime, lLength, mm, bb;
	VARIANT vtInit;
	vtInit.vt = VT_I4;

	pITimelineDataObject->GetBoundaries(&lStart, &lEnd);
	m_pChordMapMgr->m_pTimeline->PositionToClocks(pt.x, &lTime);
	// round time down to nearest beat
	m_pChordMapMgr->m_pTimeline->ClocksToMeasureBeat(m_pChordMapMgr->m_dwGroupBits, 0, lTime, &mm, &bb);
	m_pChordMapMgr->m_pTimeline->MeasureBeatToClocks(m_pChordMapMgr->m_dwGroupBits, 0, mm, bb, &lTime);
	m_pChordMapMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &vtInit );
	lLength = V_I4(&vtInit);

	if( (lTime + lEnd - lStart) > lLength) 
	{
		AfxMessageBox(IDS_MAPTOOSHORT);
		hr = E_FAIL;
	}
	else
	{
		if( S_OK == pITimelineDataObject->IsClipFormatAvailable(m_cfChordMapList) )
		{
			hr = ChordEntryPasteAt(pITimelineDataObject, pt, false);
		}
		else
		{
			hr = ChordItemPasteAt(pITimelineDataObject, pt, false);
		}
	}
	
	if(SUCCEEDED(hr))
	{
		m_pChordMapMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
	}
	pITimelineDataObject->Release();

	return hr;
}

HRESULT CChordMapStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	ChordEntry* pChord = NULL;
	hr = m_pChordMapMgr->CreateBlankChord(&pChord);
	if(SUCCEEDED(hr))
	{
		hr = SetChordXY( pChord, m_ptLastMouse);
		if(SUCCEEDED(hr))
		{
			ClearSelectedChords();
			ClearSelectedConnections();
			pChord->m_chordsel.KeyDown() = TRUE;
			m_pChordMapMgr->SendEditNotification(IDS_INSERT);
			m_pChordMapMgr->m_pChordMapList->AddTail(pChord);
			m_fSelected = TRUE;
			m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
			DoPropertyPage(CChordMapMgr::ChordSelected);
			TRACE( "ChordMapStrip: Syncing w/ Engine\n" );
			ComputeChordMap();
			ChordChangeCallback* pCallback = new ChordChangeCallback(ChordChangeCallback::ChordMapNewSelection);
			// this is roundabout way to copy chord, but what the hey, we need something the client can delete
			ChordEntry* pc = new ChordEntry;
			CPropChord prop;
			m_pChordMapMgr->ChordToPropChord(&prop, pChord);
			m_pChordMapMgr->PropChordToChord(pc, &prop);
			pCallback->SetChordEntry(pc);
			m_pChordMapMgr->m_pTimeline->OnDataChanged( pCallback );
			m_pChordMapMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
		}
		else
		{
			delete pChord;
		}
	}
	return hr;
}

HRESULT CChordMapStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = CanDelete();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pChordMapMgr != NULL );
	if( m_pChordMapMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pChordMapMgr->m_pTimeline != NULL );
	if( m_pChordMapMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	if( m_pChordMapMgr->m_selection == CChordMapMgr::ChordSelected 
	||  m_pChordMapMgr->m_selection == CChordMapMgr::MultipleSelections)
	{
		DelSelChords();
		m_pChordMapMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
		m_pChordMapMgr->m_pTimeline->OnDataChanged( NULL );
		m_pChordMapMgr->m_pTimeline->OnDataChanged(new CheckForOrphansNotification);
	}
	else if( m_pChordMapMgr->m_selection == CChordMapMgr::ConnectionSelected )
	{
		DelSelConnections();
		m_pChordMapMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
		m_pChordMapMgr->m_pTimeline->OnDataChanged( NULL );
	}

	return S_OK;
}

HRESULT CChordMapStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pChordMapMgr != NULL );
	if( m_pChordMapMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pChordMapMgr->m_pTimeline != NULL );
	if( m_pChordMapMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	for(ChordEntry* pChord = m_pChordMapMgr->m_pChordMapList->GetHead(); pChord; pChord = pChord->GetNext())
	{
		pChord->m_chordsel.KeyDown() = true;
	}


	

	m_pChordMapMgr->m_SelectedChord.RootIndex() = DMPolyChord::INVALID;
	m_pChordMapMgr->m_selection = CChordMapMgr::MultipleSelections;


	m_pChordMapMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
	if( m_pChordMapMgr->m_pChordPropPageMgr != NULL )
	{
		m_pChordMapMgr->m_pChordPropPageMgr->RefreshData();
	}
	m_pChordMapMgr->OnShowProperties();
	
	return S_OK;
}

HRESULT CChordMapStrip::CanCut( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pChordMapMgr != NULL );
	if( m_pChordMapMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	if( CanCopy() == S_OK && CanDelete() == S_OK )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}

}

HRESULT CChordMapStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pChordMapMgr != NULL );
	if( m_pChordMapMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	if(m_pChordMapMgr->m_selection == CChordMapMgr::PaletteSelected)
	{
		return S_OK;
	}
	else
	{
		return GetNumSelections();
	}
}

HRESULT CChordMapStrip::CanPaste( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;

	ASSERT( m_pChordMapMgr != NULL );
	if( m_pChordMapMgr == NULL )
	{
		return E_UNEXPECTED;
	}
/*
	// Something must be selected so paste knows where to put the data.
	if( !m_pCommandMgr->m_bSelected )
	{
		return S_FALSE;
	}
*/
	// If the format hasn't been registered yet, do it now.
	if( m_cfChordList == 0 )
	{
		m_cfChordList = RegisterClipboardFormat( CF_CHORDLIST );
		if( m_cfChordList == 0 )
		{
			return E_FAIL;
		}
	}

	if( m_cfChordMapList == 0 )
	{
		m_cfChordMapList = RegisterClipboardFormat( CF_CHORDMAP_LIST );
		if( m_cfChordMapList == 0 )
		{
			return E_FAIL;
		}
	}
	// If pITimelineDataObject != NULL, check it.
	if( pITimelineDataObject != NULL )
	{
		hr = pITimelineDataObject->IsClipFormatAvailable( m_cfChordList );
		if(hr != S_OK)
		{
			hr = pITimelineDataObject->IsClipFormatAvailable( m_cfChordMapList );
		}
	}
	// Otherwise, check the clipboard
	else
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		if( SUCCEEDED( OleGetClipboard(&pIDataObject) ) )
		{
			// Create a new TimelineDataObject
			IDMUSProdTimelineDataObject *pITimelineDataObject;
			if( SUCCEEDED( m_pChordMapMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
			{
				// Insert the IDataObject into the TimelineDataObject
				if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
				{
					hr = pITimelineDataObject->IsClipFormatAvailable(m_cfChordList);
					if(hr != S_OK)
					{
						hr = pITimelineDataObject->IsClipFormatAvailable( m_cfChordMapList );
					}
				}
				pITimelineDataObject->Release();
			}
			pIDataObject->Release();
		}
	}

	if (hr == S_OK)
	{
		return S_OK;
	}

	return S_FALSE;
}

HRESULT CChordMapStrip::CanInsert( void )
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
//	HRESULT hr = GetClickedChord( m_ptLastMouse, NULL );
//	return hr == S_OK ? S_OK : S_FALSE;
	if(m_pChordMapMgr->m_selection != CChordMapMgr::PaletteSelected)
		return S_OK;
	else
		return S_FALSE;
}

HRESULT CChordMapStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( GetNumSelections() == S_OK )
	{
		return S_OK;
	}

	if( m_pChordMapMgr->m_selection == CChordMapMgr::ConnectionSelected 
	&&  m_pChordMapMgr->m_pSelectedConnection->m_nextchord )
	{
		return S_OK;
	}

	return S_FALSE;
}

HRESULT CChordMapStrip::CanSelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return m_pChordMapMgr->m_pChordMapList->IsEmpty() ? S_FALSE : S_OK;
}

void CChordMapStrip::SetFocus()
{
	IOleInPlaceObjectWindowless* pIOleInPlaceObjectWindowless;
	m_pChordMapMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleInPlaceObjectWindowless );
	if (pIOleInPlaceObjectWindowless)
	{
		HWND hwnd;
		if (pIOleInPlaceObjectWindowless->GetWindow(&hwnd) == S_OK)
		{
			::SetFocus(hwnd);
		}
		pIOleInPlaceObjectWindowless->Release();
	}
}



/////////////////////////////////// misc helpers
BOOL CChordMapStrip::ToggleSignPost(int BegOrEnd, POINTS where)
{
	BOOL bResult = TRUE;
	ChordEntry* pChord;
	if(SUCCEEDED(GetClickedChord(where, &pChord)))
	{
		m_pChordMapMgr->SendEditNotification(IDS_UNDO_ToggleSignPost);
		pChord->m_dwflags ^= (BegOrEnd == BegSignPost) ? CE_START : CE_END;
		// set beat to zero.  If chord turned into signpost this forces beat to zero as required
		// if chord was signpost and is now free, then beat was already zero so no harm done.
		pChord->m_chordsel.Beat() = 0;
		m_pChordMapMgr->m_pTimeline->OnDataChanged(new CheckForOrphansNotification);
	}
	else
	{
		bResult = FALSE;
	}
	return bResult;
}



/////////////////////////////////////////////////////////////////////////////
// CChordMapStrip IDMUSProdStripFunctionBar
HRESULT	STDMETHODCALLTYPE CChordMapStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	DrawFunctionBar( hDC, sv );
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMapStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;
	ChordEntry* pChordChange = 0;
	ChordSelection* pChordsel = 0;
	POINTS ptMouse;
	int index;
	ptMouse = MAKEPOINTS( lParam );
	
	bool bRecallThisFunction = false;

	switch(nMsg)
	{
		case WM_MOUSEMOVE:
			if(m_bInSelectionNet)
			{
				// continuation of drag
				CWnd* pWnd = GetTimelineCWnd();
				HWND hwnd = pWnd->GetSafeHwnd();
				m_ptLastMouse = MAKEPOINTS(lParam);
				m_pChordMapMgr->HitTest(m_rectSelect);
				m_pChordMapMgr->m_pTimeline->Refresh();
				::InvalidateRect(hwnd, 0, TRUE);
				::UpdateWindow(hwnd);

				ComputeSelectionBoxOutline(m_ptAnchor, m_ptLastMouse);
			}
			break;
		case WM_LBUTTONUP:
			if(m_fCapture)
			{
				VARIANT var;
				var.vt = VT_BOOL;
				V_BOOL(&var) = FALSE;
				m_pChordMapMgr->m_pTimeline->SetTimelineProperty(TP_STRIPMOUSECAPTURE, var);
				m_fCapture = false;
				if(m_bInSelectionNet)
				{
					int nsel;
					GetNumSelections(&nsel);
					if(nsel == 1)
						m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
					else if(nsel > 1)
						m_pChordMapMgr->m_selection = CChordMapMgr::MultipleSelections;
					if(m_SelectionDragState.bAutoscroll)
					{
						::KillTimer(GetTimelineCWnd()->m_hWnd, SelectionDrag);
						TRACE("Killing Timer for SelectionDrag\n");
					}
					m_SelectionDragState.bActive = false;
					m_SelectionDragState.dir = DragState::off;
					m_bInSelectionNet = false;
					CWnd* pWnd = GetTimelineCWnd();
					HWND hwnd = pWnd->GetSafeHwnd();
					m_pChordMapMgr->m_pTimeline->Refresh();
					::InvalidateRect(hwnd, 0, TRUE);
					::UpdateWindow(hwnd);
				}
			}
			break;
		case WM_COMMAND:
			switch( LOWORD(wParam) )
			{
				case IDR_PALETTE_PROPS:
					{
						TRACE("Chordpalette properties selected\n");
						// have we selected a chord?
						int index = PaletteChordIndexFromCoords(m_ptLastMouse);
						if(index < 0)
							break;
						// yes, clear everything else and show this chord
						ClearSelectedChords();
						ClearSelectedConnections();
						pChordChange = new ChordEntry;
						pChordChange->LoadFromChordItem(CChordItem(m_pChordMapMgr->m_pChordPalette->Chord(index)));
						m_pChordMapMgr->m_pChordPalette->m_chords[index].KeyDown() = true;
						m_fSelected = TRUE;
						m_pChordMapMgr->m_selection = CChordMapMgr::PaletteSelected;
						pChordChange->SaveToPropChord(m_pChordMapMgr->m_SelectedChord);
						m_pChordMapMgr->m_SelectedChord.Undetermined(m_pChordMapMgr->m_SelectedChord.RootIndex()) |= UD_FROMCHORDPALETTE;
						m_pChordMapMgr->m_nSelectedIndex = index;
						DoPropertyPage(CChordMapMgr::PaletteSelected, TRUE ); // Make the PropertyPage display.
						ChordChangeCallback* pCallback = new ChordChangeCallback(ChordChangeCallback::ChordMapNewSelection);
						pCallback->SetChordEntry(pChordChange);
						m_pChordMapMgr->m_pTimeline->OnDataChanged( pCallback );
						m_pChordMapMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);
						return S_OK;
					}
					break;
				case ID_PALETTE_COPY:
					{
						TRACE("Chordpalette copy selected\n");
						hr = Copy(0, m_pChordMapMgr->m_nSelectedIndex);
					}
					break;
			}
			break;
		case WM_LBUTTONDOWN:
			// set focus to timeline
			// Set the focus to the timeline
			IOleInPlaceObjectWindowless* pIOleInPlaceObjectWindowless;
			m_pChordMapMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleInPlaceObjectWindowless );
			if (pIOleInPlaceObjectWindowless)
			{
				HWND hwnd;
				if (pIOleInPlaceObjectWindowless->GetWindow(&hwnd) == S_OK)
				{
					::SetFocus(hwnd);
				}
				pIOleInPlaceObjectWindowless->Release();
			}
			// have we selected a chord?
			index = PaletteChordIndexFromCoords(ptMouse);
			if(index < 0)
				break;

			pChordsel = &(m_pChordMapMgr->m_pChordPalette->Chord(index));
			if(pChordsel->KeyDown() == true)
			{
				// user is starting a drag
				m_fDragging = TRUE;
				m_bDrop = true;
				IDropSource* pIDropSource;
				DWORD dwEffect = DROPEFFECT_NONE;
				if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
				{
					hr = CreateDataObject(&m_pISourceDataObject, index);
					if(SUCCEEDED(hr))
					{
						m_pDragImage = CreateDragImage();
						if(m_pDragImage)
						{
							m_pDragImage->BeginDrag(0, CPoint(8,12));
						}
						// start drag drop
						DWORD dwOKDragEffects = DROPEFFECT_COPY;
						m_dwStartDragButton = (unsigned long)wParam;
						// store index and mark as being from chord palette
						m_startDragPosition.x = -(index+1);
						m_bInternalDrop = false;
						hr  = ::DoDragDrop(m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect);
						m_startDragPosition.x = 0;
						// we don't need this until we are a target so just delete it
						// remember to remove when we become a target
						delete m_pDragChord;
						m_pDragChord = 0;
						// drag drop completed, cleanup
						m_dwStartDragButton = 0;
						if(m_pDragImage)
						{
							m_pDragImage->EndDrag();
							delete m_pDragImage;
							m_pDragImage = NULL;
						}
						switch(hr)
						{
						case DRAGDROP_S_DROP:
							if(m_bInternalDrop)
							{
								m_bInternalDrop = false;
								ASSERT(FALSE);	// not supported yet
							}
							else if(dwEffect != DROPEFFECT_NONE)
							{
								// not an internal drop, don't need to do anything
								TRACE("Successful drag drop from chord palette\n");
							}
							else
							{
								m_bDrop = false;
							}
							break;
						default:
							m_bDrop=false;
							break;
						}
						hr = S_OK;
						m_pISourceDataObject->Release();
						m_pISourceDataObject = NULL;
					}
					pIDropSource->Release();
				}
				else
				{
					hr = E_FAIL;
					break;
				}
			}
			else
			{
				pChordChange = new ChordEntry();
				pChordChange->LoadFromChordItem(CChordItem(m_pChordMapMgr->m_pChordPalette->Chord(index)));
				bRecallThisFunction = true;
			}
			break;
		case WM_RBUTTONDOWN:
			// have we selected a chord?
			{
				index = PaletteChordIndexFromCoords(ptMouse);
				if(index < 0)
					break;
				pChordChange = new ChordEntry;
				pChordChange->LoadFromChordItem(CChordItem(m_pChordMapMgr->m_pChordPalette->Chord(index)));
				m_ptLastMouse = ptMouse;
				VARIANT var;
				var.vt = VT_BOOL;
				V_BOOL(&var) = TRUE;
				m_pChordMapMgr->m_pTimeline->SetTimelineProperty(TP_STRIPMOUSECAPTURE, var);
				m_fCapture = true;
			}
			break;
		case WM_RBUTTONUP:
			{
				HMENU hMenu, hMenuPopup;
				POINT	 pt;
				m_ptLastMouse = ptMouse;

				if(m_fCapture)
				{
					VARIANT var;
					var.vt = VT_BOOL;
					V_BOOL(&var) = FALSE;
					m_pChordMapMgr->m_pTimeline->SetTimelineProperty(TP_STRIPMOUSECAPTURE, var);
					m_fCapture = false;
				}
				// Load the SignPost RMB menu.
				hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDR_PALETTE_RMENU) );
				hMenuPopup = ::GetSubMenu(hMenu, 0);
				m_MenuHandler.m_pStrip = (IDMUSProdStrip *)this;
				GetCursorPos(&pt);
				m_pChordMapMgr->m_pTimeline->TrackPopupMenu(hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE);
			}
			break;
	}

	if(pChordChange)
	{
		ClearSelectedChords();
		ClearSelectedConnections();
		m_pChordMapMgr->m_pChordPalette->m_chords[index].KeyDown() = true;
		m_fSelected = TRUE;
//		m_pChordMapMgr->m_selection = CChordMapMgr::PaletteSelected;
		// next couple of lines assures that legacy palette chords will show accidentals correctly
		if(m_pChordMapMgr->m_dwKey & CChordMapMgr::UseFlats)
		{
			pChordChange->m_chordsel.SubChord(0)->UseFlat() = true;
			pChordChange->m_chordsel.PropagateUseFlat();
		}
		pChordChange->SaveToPropChord(m_pChordMapMgr->m_SelectedChord);
		m_pChordMapMgr->m_SelectedChord.Undetermined(m_pChordMapMgr->m_SelectedChord.RootIndex()) |= UD_FROMCHORDPALETTE;
		m_pChordMapMgr->m_nSelectedIndex = index;
		DoPropertyPage(CChordMapMgr::PaletteSelected ); // Make the PropertyPage display.
		ChordChangeCallback* pCallback = new ChordChangeCallback(ChordChangeCallback::ChordMapNewSelection);
		pCallback->SetChordEntry(pChordChange);
		m_pChordMapMgr->m_pTimeline->OnDataChanged( pCallback );
		m_pChordMapMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);
		if(bRecallThisFunction)
		{
			FBOnWMMessage(nMsg, wParam, lParam, lXPos, lYPos);
		}
	}
	return hr;
}

int CChordMapStrip::PaletteChordIndexFromCoords( POINTS pt)
{
	long lHeight;
	
	lHeight = enumDefaultHeight;
	lHeight -= FUNCTION_NAME_HEIGHT;
	

	if(pt.y < FUNCTION_NAME_HEIGHT)
		return -1;
	pt.y -= FUNCTION_NAME_HEIGHT;
	double keyheight = static_cast<double>(lHeight)/24.0;
	int index = static_cast<int>(floor(static_cast<double>(pt.y)/keyheight));
	index = 23 - index;
	if(index < 0) index = 0;
	return index;
}

void CChordMapStrip::DrawFunctionBar( HDC hDC, STRIPVIEW sv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( sv == SV_FUNCTIONBAR_NORMAL )
	{
		CRect	rectClip;
		RECT	rectNote;
		CDC		dc;
		short	value;
		long	lTop;
		long lWidth, lHeight;
//		static const char MidiValueToName[61] = "C    C#/DbD    D#/EbE    F    F#/GbG    G#/AbA    A#/BbB    ";
		static const char* NoteNames[12] = {"C", "C#", "D", "D#", "E", "F", "F#", "G",
			"G#", "A", "A#", "B" };
		static const char* FlatNoteNames[12] = {"C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"};

		if( dc.Attach(hDC) )
		{
			lWidth = enumFBWidth;
			lHeight = enumDefaultHeight;
			CPoint point = dc.GetWindowOrg();
			point.y -= FUNCTION_NAME_HEIGHT;
			lHeight -= FUNCTION_NAME_HEIGHT;
			dc.SetWindowOrg( point );
			
			dc.GetClipBox( &rectClip );
			dc.FillSolidRect( rectClip, dc.GetNearestColor(GetSysColor(COLOR_WINDOW)));
			CPen	penNoteLine;
			if( !penNoteLine.CreatePen( PS_SOLID, 1, RGB(0,0,0) ))
			{
				dc.Detach();
				return;
			}
			short keyheight = lHeight / 24;
			for( value = 0; value < 24; value++ )
			{
				lTop = (long)(( 23 - value ) * ( lHeight ))/24;
				if( lTop > rectClip.bottom )
				{
					continue;
				}
				rectNote.top = lTop;
				rectNote.bottom = (long)(( 24 - value ) * ( lHeight ))/24;;
				if( rectNote.bottom < rectClip.top )
				{
					continue;
				}
				rectNote.left = rectClip.left;
				rectNote.right = rectClip.right;
				if(m_pChordMapMgr->m_pChordPalette->m_chords[value].KeyDown())
				{
					dc.FillSolidRect ( &rectNote, dc.GetNearestColor(PIANOROLL_SELKEY_COLOR));
				}
				else if( PianoKeyColor[ value % 12 ] == BLACK )
				{
					dc.FillSolidRect( &rectNote, dc.GetNearestColor(PIANOROLL_BLACKKEY_COLOR));
				}
				else
				{
					dc.FillSolidRect( &rectNote, dc.GetNearestColor(PIANOROLL_WHITEKEY_COLOR));
				}
				
				// draw chord names
				CPen*	ppenOld;
				ppenOld = dc.SelectObject( &penNoteLine );
				dc.MoveTo( rectNote.left, rectNote.bottom );
				dc.LineTo( rectNote.right, rectNote.bottom );
				dc.SelectObject( ppenOld );

				LOGFONT lf;
				memset( &lf, 0 , sizeof(LOGFONT));
//				lf.lfHeight = long(keyheight * 1.4 );
				lf.lfHeight = 100;
//				lfHeight = -MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
				lf.lfWidth = 0;
				//lf.lfEscapement = 0;
				//lf.lfOrientation = 0;
				lf.lfWeight = 400;
				//lf.lfItalic = FALSE;
				//lf.lfUnderline = FALSE;
				//lf.lfStrikeOut = FALSE;
				//lf.lfCharSet = ANSI_CHARSET;
				//lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
				//lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
				//lf.lfQuality = DEFAULT_QUALITY;
				lf.lfPitchAndFamily = DEFAULT_PITCH | FF_MODERN;
				strcpy(lf.lfFaceName,"Arial(Baltic)");
				
//				TEXTMETRIC tm;
				CFont font;


//				if (font.CreatePointFontIndirect( &lf, &dc))
				if (font.CreatePointFont( 100,"System", &dc))
				{
					CFont *pOldFont;
					pOldFont = dc.SelectObject( &font );
					if (pOldFont)
					{
						COLORREF oldColor;
						if(m_pChordMapMgr->m_pChordPalette->m_chords[value].KeyDown())
						{
							oldColor = dc.SetTextColor( RGB(255, 255, 255) );
						}
						else if( PianoKeyColor[ value % 12 ] == BLACK )
						{
							oldColor = dc.SetTextColor( RGB(255, 255, 255) );
						}
						else
						{
							oldColor = dc.SetTextColor( RGB(0, 0, 0) );
						}
//							oldColor = dc.SetTextColor( RGB(0, 0, 0) );
						
						int nOldBkMode;
						nOldBkMode = dc.SetBkMode( TRANSPARENT );
		
						CString cstrTxt;
						//cstrTxt.Format( "%s%d", CString(MidiValueToName).Mid((value % 12)*5, 5) , value/12 );
//							cstrTxt.Format( "C %d", value/12 );
/* don't need -- setting "use flats" on personality prop page sets flag in each chord
						if(m_pChordMapMgr->m_dwKey & m_pChordMapMgr->UseFlats)	
						{
							cstrTxt.Format("%s %s", 
											FlatNoteNames[value%12],
											m_pChordMapMgr->m_pChordPalette->Chord(value).Name());
						}
*/
						DMChord* pDMChord = m_pChordMapMgr->m_pChordPalette->Chord(value).Base();
						/* else */ if(m_pChordMapMgr->m_pChordPalette->Chord(value).Base()->UseFlat() == TRUE)
						{
							cstrTxt.Format("%s %s", 
											FlatNoteNames[value%12],
											m_pChordMapMgr->m_pChordPalette->Chord(value).Name());
						}
						else
						{
							cstrTxt.Format("%s %s", 
											NoteNames[value%12],
											m_pChordMapMgr->m_pChordPalette->Chord(value).Name());
						}
						rectNote.left = 0;
						dc.DrawText( cstrTxt, &rectNote,
							DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX );
						
						dc.SetBkMode( nOldBkMode );
						dc.SetTextColor( oldColor );
						dc.SelectObject( pOldFont );
					}
				}
			}
			penNoteLine.DeleteObject();
			dc.Detach();
		}
	}
}


void CChordMapStrip::ClearPaletteSelections()
{
	for(int idx = 0; idx < 24; idx++)
	{
		m_pChordMapMgr->m_pChordPalette->m_chords[idx].KeyDown() = false;
	}
}

double CChordMapStrip::ZoomFactor()
{
	double nominal = 24.0;	// 24 pixels per beat
	long m = 0;
	long b = 1;
	long pos;
	double factor = 1.0;
	if(SUCCEEDED(m_pChordMapMgr->m_pTimeline->MeasureBeatToPosition( m_pChordMapMgr->m_dwGroupBits, 0, m,b, &pos)))
	{
		factor = double(pos)/nominal;
	}
	return factor;
}

long CChordMapStrip::LeftEdge()
//
// returns left edge of chordmap in strip coordinates (0 = 0 time)
//
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(m_pChordMapMgr);
	ASSERT(m_pChordMapMgr->m_pTimeline);

	long pos;
	HRESULT hr;
	VARIANT var;
	if(SUCCEEDED(hr = m_pChordMapMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var )))
	{
		pos = V_I4(&var);
	}
	else
	{
		pos = -1;
	}
	return pos;
}

long CChordMapStrip::RightEdge()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(m_pChordMapMgr);
	ASSERT(m_pChordMapMgr->m_pTimeline);

	long pos;
	HRESULT hr = S_OK;
	VARIANT var;
	if(SUCCEEDED(hr = m_pChordMapMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var )))
	{
		pos = V_I4(&var);
		if(SUCCEEDED(hr = m_pChordMapMgr->m_pTimeline->StripGetTimelineProperty(this, STP_STRIP_RECT, &var )))
		{
			RECT* pRect = (RECT*)V_BYREF(&var);
			CRect rect(*pRect);
			pos += rect.Width();
			delete pRect;
		}
	}
	if(FAILED(hr))
	{
		pos = -1;
	}
	return pos;
}

HRESULT CChordMapStrip::ScrollHoriz(long pos)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(m_pChordMapMgr);
	ASSERT(m_pChordMapMgr->m_pTimeline);

	VARIANT var;
	var.vt = VT_I4;
	V_I4(&var) = pos;

	HRESULT hr = m_pChordMapMgr->m_pTimeline->SetTimelineProperty(TP_HORIZONTAL_SCROLL, var);
	return hr;
}

HRESULT CChordMapStrip::ScrollVert(long pos)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(m_pChordMapMgr);
	ASSERT(m_pChordMapMgr->m_pTimeline);

	VARIANT var;
	var.vt = VT_I4;
	V_I4(&var) = pos;

	HRESULT hr = m_pChordMapMgr->m_pTimeline->SetTimelineProperty(TP_VERTICAL_SCROLL, var);
	return hr;
}

HRESULT CChordMapStrip::InsertNewChord(POINTS ptWhere, ChordEntry*& pChord)
{
	HRESULT hr = S_OK;
	if( FAILED(m_pChordMapMgr->CreateBlankChord( &pChord )) )
	{
		hr = E_NOTIMPL;
		goto END;
	}

	// Set new Chord (UI Box) where the user clicked the mouse.
	if( FAILED(SetChordXY( pChord, ptWhere )) ) // If user clicks end of timeline then method should fail (it currently does not).
	{
		delete pChord;
		hr = E_FAIL;
		goto END;
	}

	pChord->SaveToPropChord(m_pChordMapMgr->m_SelectedChord);

	ClearSelectedChords();
	ClearSelectedConnections();
	pChord->m_chordsel.KeyDown() = TRUE;	// new inserted chord is selected
	m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
	m_pChordMapMgr->SendEditNotification(IDS_INSERT);
	m_pChordMapMgr->m_pChordMapList->AddTail( pChord );

	m_pChordMapMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );


END:
	return hr;
}


void CChordMapStrip::GetWindowOrg(long& xpos, long& ypos)
{
	CDC cDC;
	VARIANT vt;
	vt.vt = VT_I4;

	// Get the DC of our Strip					
	if( SUCCEEDED(m_pChordMapMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip*)this, STP_GET_HDC, &vt )) )
	{
		CWnd* pWnd = NULL;
		if( cDC.Attach( (HDC)(vt.lVal) ) != 0 )
		{
			pWnd = cDC.GetWindow();
			CPoint pt;
			pt = cDC.GetWindowOrg();
			xpos = pt.x;
			ypos = pt.y;
			cDC.Detach();
		}
		if( pWnd )
		{
			::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(vt.lVal) );
		}
		else
		{
			::ReleaseDC( NULL, (HDC)(vt.lVal) );
		}
	}
}

HRESULT CChordMapStrip::MergeChords(ChordEntryList &list, POINTL pt, ChordEntry* pRefChord, bool bDropNotPaste)
{
	HRESULT hr = S_OK;

	UNREFERENCED_PARAMETER(bDropNotPaste);

	// get needed timeline props
	VARIANT			var;
	m_pChordMapMgr->m_pTimeline->GetTimelineProperty(TP_MAXIMUM_HEIGHT, &var);
	int strip_height = V_I4(&var);
	m_pChordMapMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var);
	int clocks = V_I4(&var);
	m_pChordMapMgr->m_pTimeline->GetTimelineProperty( TP_VERTICAL_SCROLL, &var );	
	short vpos = (short)V_I4(&var);
	m_pChordMapMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var );	
	short hpos = (short)V_I4(&var);
	long strip_width;
	m_pChordMapMgr->m_pTimeline->ClocksToPosition(clocks, &strip_width);
	
	// transform boundaries if scrolling
	strip_height += vpos;
	// strip_width is entire width of timeline, strip height is only the visible part (without scrolling)
//	strip_width += hpos;
	
	m_pChordMapMgr->MakeCompatibleNids(list);

	// get bounding rect and translate it's top left corner to drop/paste point
	RECT rect;
	GetBoundingRect(list, rect);
	short xtrans = pt.x - pRefChord->m_rect.left;
	short ytrans = pt.y - pRefChord->m_rect.top;

	short xExcess = 0, yExcess = 0;
	if((rect.top + ytrans) < 0)
		yExcess = -(rect.top + ytrans);	// yExcess >= 0
	if((rect.left + xtrans) < 0)
	{
		// should be impossible for paste: (pRectChord->m_rect.left == pt.x) > 0
		xExcess = -(rect.left + xtrans);  // xExcess >= 0
	}
	if((rect.bottom + ytrans)> strip_height)
	{
		yExcess = strip_height - (rect.bottom + ytrans); // yExcess <= 0
	}
	if((rect.right  + xtrans) > strip_width)
	{
		xExcess = strip_width - (rect.right + xtrans);  // xExcess <= 0;
	}

	for(ChordEntry* pItem = list.GetHead(); pItem; pItem = pItem->GetNext())
	{
		ChordEntry* pChord = new ChordEntry(*pItem);
		pChord->CopyNextList(*pItem, TRUE);
		POINTS ptNewPoint;
		ptNewPoint.x = pChord->m_rect.left + xtrans;
		ptNewPoint.y = pChord->m_rect.top  + ytrans;
		ptNewPoint.x += xExcess;
		ptNewPoint.y += yExcess;
		// preserve measure
		long lMeasure = pChord->m_chordsel.Measure();
		long lBeat = pChord->m_chordsel.Beat();
		if( FAILED(SetChordXY( pChord, ptNewPoint )) ) // If user clicks end of timeline then method should fail (it currently does not).
		{
			delete pChord;
			break;
		}
		pChord->m_chordsel.Measure() = (short)lMeasure;
		pChord->m_chordsel.Beat() = (BYTE)lBeat;
		m_pChordMapMgr->m_pChordMapList->AddTail( pChord );
		pChord->m_chordsel.KeyDown() = TRUE;	// new inserted chord is selected
//			pChordChange = pChord;					// notify client of selected chord
		m_fSelected = TRUE;
		m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
	}
	return hr;
}

BOOL CChordMapStrip::IntersectsChordInMap(CRect& rect)
{
	ChordEntry* pChord;
	CRect urect(0,0,0,0);
	for(pChord = m_pChordMapMgr->m_pChordMapList->GetHead(); pChord; pChord = pChord->GetNext())
	{
		CRect chordrect(pChord->m_rect.left, pChord->m_rect.top, pChord->m_rect.right, pChord->m_rect.bottom);
		CRect irect;
		irect.IntersectRect(chordrect, rect);
		if(!irect.IsRectEmpty())
		{
			urect.UnionRect(urect, irect);
		}
	}
	return urect.IsRectEmpty();
}

void CChordMapStrip::FindYPositionForChord(short xpos, short& ypos, bool bUpdatePosition)
{

	// get candidate y pos
	//long ypos;
	/*
	VARIANT			var;
	m_pChordMapMgr->m_pTimeline->GetTimelineProperty(TP_MAXIMUM_HEIGHT, &var);
	int strip_height = V_I4(&var);
	int nrow = strip_height/CHORD_DEFAULT_HEIGHT;
	*/
	int nrow = enumDefaultHeight/CHORD_DEFAULT_HEIGHT;
	BOOL fFoundPos = FALSE;
	int irow = m_irowSaved;	// previous position saved
	for(irow; !fFoundPos && irow < nrow; irow++)
	{
		ypos = irow * CHORD_DEFAULT_HEIGHT;
		CRect rect;
		rect.left			= (short)xpos;
		rect.right			= (short)xpos + CHORD_DEFAULT_WIDTH;
		rect.top			= (short)ypos;
		rect.bottom			= (short)ypos + CHORD_DEFAULT_HEIGHT;

		fFoundPos = IntersectsChordInMap(rect);
	}

	if(!fFoundPos)
	{
		ypos = ((m_irowSaved+1)%nrow) * CHORD_DEFAULT_HEIGHT;
	}

	if(bUpdatePosition)
	{
		m_irowSaved = (m_irowSaved + 1) % nrow;
	}
}

HRESULT CChordMapStrip::DragConnection(LPARAM lParam, POINTS ptMouseDown)
{
	CDC cDC;
	VARIANT vt;
	vt.vt = VT_I4;


	// Get the DC of our Strip					
	if( SUCCEEDED(m_pChordMapMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip*)this, STP_GET_HDC, &vt )) )
	{
		if( cDC.Attach( (HDC)(vt.lVal) ) != 0 )
		{
			// Figure out coordinates for connection line
			POINTS ptCurPos = MAKEPOINTS(lParam);
			short xOrg = ptMouseDown.x;
			short yOrg = ptMouseDown.y;
			short xTo = ptCurPos.x;
			short yTo = ptCurPos.y;
			long vpos, hpos;
			VARIANT var;
			if(SUCCEEDED(m_pChordMapMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var )))
			{
				hpos = V_I4(&var);
//				xOrg -= static_cast<short>(hpos);
				xTo -= static_cast<short>(hpos);
			}
			if(SUCCEEDED(m_pChordMapMgr->m_pTimeline->GetTimelineProperty( TP_VERTICAL_SCROLL, &var )))
			{
				vpos = V_I4(&var);
//				yOrg -= static_cast<short>(vpos);
//				yTo -= static_cast<short>(vpos);
			}
			// end figure out coords

			// update ConnectionDragState
			m_ConnectionDragState.xOrg = xOrg;
			m_ConnectionDragState.yOrg = yOrg;
			m_ConnectionDragState.xTo = xTo;
			m_ConnectionDragState.yTo = yTo;

			RECT rtStrip;
			cDC.GetClipBox( &rtStrip );
			TRACE(" xTo: %d, yTo: %d, right edge: %d\r\n", xTo, yTo, rtStrip.right);

			// set up autoscroll
			if(xTo > rtStrip.right)
			{
//				TRACE("\nTurn on right Drag");
				m_ConnectionDragState.dir |= DragState::right;
			}
			else
			{
//				TRACE("\nTurn off right Drag");
				m_ConnectionDragState.dir &= ~DragState::right;
			}
			if(xTo < rtStrip.left + 3)
			{
//				TRACE("\nTurn on left Drag ");
//				TRACE("xTo=%d, rtStrip.left=%d, hpos=%d\n", xTo, rtStrip.left, hpos);
				m_ConnectionDragState.dir |= DragState::left;
			}
			else
			{
//				TRACE("\nTurn off left Drag");
				m_ConnectionDragState.dir &= ~DragState::left;
			}
			if(yTo < rtStrip.top)
			{
				m_ConnectionDragState.dir |= DragState::up;
			}
			else
			{
				m_ConnectionDragState.dir &= ~DragState::up;
			}
			if(yTo > rtStrip.bottom)
			{
				m_ConnectionDragState.dir |= DragState::down;
			}
			else
			{
				m_ConnectionDragState.dir &= ~DragState::down;
			}

			if(m_ConnectionDragState.dir != DragState::off
				&& !m_ConnectionDragState.bAutoscroll)
			{
				// turn autoscrolling on
				m_ConnectionDragState.bAutoscroll  = true;
				::SetTimer(GetTimelineCWnd()->m_hWnd, ConnectionDrag, 100, NULL);
			}
			else if(m_ConnectionDragState.dir == DragState::off
					&& m_ConnectionDragState.bAutoscroll)
			{
				// turn autoscrolling off
				m_ConnectionDragState.bAutoscroll = false;
				::KillTimer(GetTimelineCWnd()->m_hWnd, ConnectionDrag);
			}
					
			CWnd* pWnd = cDC.GetWindow();
			cDC.Detach();
			if( pWnd )
			{
				::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(vt.lVal) );
			}
			else
			{
				::ReleaseDC( NULL, (HDC)(vt.lVal) );
			}
		}
	}
	return S_OK;
}




void CChordMapStrip::UpdateAutoScroll(DragState* pDragState)
{
	long vpos, hpos;
	VARIANT var;
	if(SUCCEEDED(m_pChordMapMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var )))
	{
		hpos = V_I4(&var);
	}
	if(SUCCEEDED(m_pChordMapMgr->m_pTimeline->GetTimelineProperty( TP_VERTICAL_SCROLL, &var )))
	{
		vpos = V_I4(&var);
	}

	if(pDragState->bAutoscroll)
	{
		if(pDragState->dir == DragState::left)
		{
			ScrollHoriz(hpos-12);
		}
		if(pDragState->dir == DragState::right)
		{
			ScrollHoriz(hpos+12);
		}
		if(pDragState->dir == DragState::up)
		{
			ScrollVert(vpos-12);
		}
		if(pDragState->dir == DragState::down)
		{
			ScrollVert(vpos+12);
		}
	}
}


HRESULT CChordMapStrip::OnCommand(UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos,
								  BOOL bRefresh, BOOL bSyncEngine, ChordEntry*&	pChordChange)
{
	HRESULT hr = S_OK;
	ChordEntry	tempChord;
	switch( LOWORD(wParam) )
	{
		case ID_PALETTE_COPY:
		case IDR_PALETTE_PROPS:
			// reflect to FBOnWMMessage
			return FBOnWMMessage( nMsg, wParam, lParam, lXPos, lYPos );
			break;

		case IDM_BEGSIGNPOST:
			bRefresh = TRUE;
			bSyncEngine = TRUE;
			ToggleSignPost(BegSignPost, m_ptLastRightMouse);
			break;
		case IDM_ENDSIGNPOST:
			bRefresh = TRUE;
			bSyncEngine = TRUE;
			ToggleSignPost(EndSignPost, m_ptLastRightMouse);
			break;
		case ID_EDIT_CUT:
			bRefresh = TRUE;
			bSyncEngine = TRUE;
			m_ptLastMouse.x = m_ptLastRightMouse.x;
			m_ptLastMouse.y = m_ptLastRightMouse.y;
			m_pChordMapMgr->SendEditNotification(IDS_UNDO_CutChord);
			hr = Cut();
			break;
		case ID_EDIT_COPY:
			// make sure mouse pts are the same
			m_ptLastMouse.x = m_ptLastRightMouse.x;
			m_ptLastMouse.y = m_ptLastRightMouse.y;
			hr = Copy();
			break;
		case ID_EDIT_PASTE:
			bRefresh = TRUE;
			bSyncEngine = TRUE;
			hr = Paste();
			SetFocus();
	//					m_nLastEdit = IDS_PASTE; // deliberately commented out--PasteAt does this
			break;
		case ID_EDIT_SELECT_ALL:
			hr = SelectAll();
			bRefresh = TRUE;
			break;
		case IDM_CHORD_INSERT:
			{
				ChordEntry *pChord;
				POINTS		ptNewPoint = m_ptLastRightMouse;
				hr = InsertNewChord(ptNewPoint, pChord);
				if(hr == S_OK)
				{
					pChordChange = pChord;					// notify client of selected chord
					m_fSelected = TRUE;
					m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
					DoPropertyPage(CChordMapMgr::ChordSelected);
					bRefresh = TRUE;
					bSyncEngine = TRUE;
				}
			}
			break;
		case IDM_CHORD_DELETE:
		case ID_TIMELINE_DELETE:
			{
				Delete();
			}
			break;
		case IDM_KILLPROPS:
			if( m_pChordMapMgr->m_pChordPropPageMgr && m_pChordMapMgr->IsPropPageShowing())
			{
				m_pChordMapMgr->ShowPropPage(FALSE);
			}
			break;
		case IDM_CLEARSELECT:
			m_fSelected = FALSE;
			m_pChordMapMgr->m_selection = CChordMapMgr::NoSelection;
			ClearPaletteSelections();
			ClearSelectedChords();
			ClearSelectedConnections();
			bRefresh = TRUE;
			m_pChordMapMgr->m_pTimeline->Refresh();
			m_pChordMapMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

			break;
		case IDM_PROPERTIES:
		case ID_TIMELINE_PROPERTIES:
			{
				// make sure that right clicked chord gets selected
				// so we do properties for the right chord
				ChordEntry* pChord;
				GetClickedChord(m_ptLastRightMouse, &pChord);
				if(!pChord)
				{
					if(m_pChordMapMgr->m_selection == CChordMapMgr::ChordSelected)
					{
						pChord = FirstSelectedChord();
						ASSERT(pChord);
						ClearSelectedChords();
						ClearSelectedConnections();
						pChord->m_chordsel.KeyDown() = TRUE;
						bRefresh = TRUE;
						bSyncEngine = TRUE;
						pChordChange = pChord;	// notify client of chord selected
						m_fSelected = TRUE;
						m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
						DoPropertyPage( CChordMapMgr::ChordSelected, TRUE ); // Make the PropertyPage display.
					}
					else if(m_pChordMapMgr->m_selection == CChordMapMgr::ConnectionSelected)
					{
						DoPropertyPage(CChordMapMgr::ConnectionSelected, TRUE);
					}
					else if(m_pChordMapMgr->m_selection == CChordMapMgr::PaletteSelected)
					{
						ClearSelectedChords();
						ClearSelectedConnections();
						m_pChordMapMgr->m_pChordPalette->m_chords[m_pChordMapMgr->m_nSelectedIndex].KeyDown() = true;

						tempChord.m_chordsel = m_pChordMapMgr->m_pChordPalette->Chord(m_pChordMapMgr->m_nSelectedIndex);
						bRefresh = TRUE;
						bSyncEngine = TRUE;
						m_fSelected = TRUE;
						tempChord.SaveToPropChord(m_pChordMapMgr->m_SelectedChord);
						pChordChange = &tempChord;
						m_pChordMapMgr->m_SelectedChord.Undetermined(m_pChordMapMgr->m_SelectedChord.RootIndex()) |= UD_FROMCHORDPALETTE;
						DoPropertyPage(CChordMapMgr::PaletteSelected, TRUE);
					}
					else if(m_pChordMapMgr->m_selection == CChordMapMgr::NoSelection
						|| m_pChordMapMgr->m_selection == CChordMapMgr::MultipleSelections)
					{
						m_pChordMapMgr->m_SelectedChord.RootIndex() = DMPolyChord::INVALID;
						DoPropertyPage(m_pChordMapMgr->m_selection);
					}
					else
					{
						ChordChangeCallback* pCallback = 
									new ChordChangeCallback(ChordChangeCallback::ParentShowProps);
						m_pChordMapMgr->m_pTimeline->OnDataChanged( pCallback );

						SetFocus();	// back to use
					}
				}
				else
				{
					ClearSelectedChords();
					ClearSelectedConnections();
					pChord->m_chordsel.KeyDown() = TRUE;
					bRefresh = TRUE;
					bSyncEngine = TRUE;
					pChordChange = pChord;	// notify client of chord selected
					m_fSelected = TRUE;
					m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
					DoPropertyPage( CChordMapMgr::ChordSelected, TRUE ); // Make the PropertyPage display.
				}
			}
			break;
	}
	return hr;
}

HRESULT CChordMapStrip::OnRButtonUp(UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	HRESULT hr = S_OK;
	if(m_fCapture)
	{
		VARIANT var;
		var.vt = VT_BOOL;
		V_BOOL(&var) = FALSE;
		m_pChordMapMgr->m_pTimeline->SetTimelineProperty(TP_STRIPMOUSECAPTURE, var);
		m_fCapture = false;
	}
	HMENU hMenu, hMenuPopup;
	POINT	 pt;
	POINTS ptCur = MAKEPOINTS(lParam);
	ChordEntry* pChord;
	GetClickedChord(ptCur, &pChord);
	m_fSelected = (GetNumSelections() == S_OK);
	/* select logic down in RButtonDown
	if(m_fSelected)
	{
		ClearSelectedChords();
		ClearSelectedConnections();
		if(pChord)
			pChord->m_chordsel.KeyDown() = TRUE;
	}
	*/
	m_ptLastRightMouse = ptCur;	// save so we know where the chord is
	m_ptLastMouse = ptCur;

	// Load the SignPost RMB menu.
	hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDR_CHORD_RMENU) );
	hMenuPopup = ::GetSubMenu(hMenu, 0);
	BOOL fOldSelected = m_fSelected;
	if(GetNumSelections() == S_OK || (S_OK == GetClickedConnection(ptCur, 0, 0) ) )
	{
		// select chord to fool timeline menu enabler so that delete is an option
		m_fSelected = TRUE;
		::EnableMenuItem(hMenuPopup, IDM_CHORD_INSERT, MF_GRAYED);
	}				
	else
	{
//		::EnableMenuItem(hMenuPopup, IDM_CHORD_DELETE, MF_GRAYED);
		::EnableMenuItem(hMenuPopup, IDM_PROPERTIES, MF_GRAYED);
	}

	if(CanDelete() != S_OK)
	{
		::EnableMenuItem(hMenuPopup, IDM_CHORD_DELETE, MF_GRAYED);
	}

	if(CanCut() != S_OK)
	{
		::EnableMenuItem(hMenuPopup, ID_EDIT_CUT, MF_GRAYED);
	}
	if(CanCopy() != S_OK)
	{
		::EnableMenuItem(hMenuPopup, ID_EDIT_COPY, MF_GRAYED);
	}
	if(CanPaste() != S_OK)
	{
		::EnableMenuItem(hMenuPopup, ID_EDIT_PASTE, MF_GRAYED);
	}
	if(CanSelectAll() != S_OK)
	{
		::EnableMenuItem(hMenuPopup, ID_EDIT_SELECT_ALL, MF_GRAYED);
	}

	m_MenuHandler.m_pStrip = (IDMUSProdStrip *)this;
	GetCursorPos(&pt);
	m_pChordMapMgr->m_pTimeline->TrackPopupMenu(hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE);
	::DestroyMenu(hMenu);
	m_fSelected = fOldSelected;

	// make sure selection choices are updated
	m_pChordMapMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

	return hr;
}


HRESULT CChordMapStrip::OnInsert(UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos,
								  BOOL bRefresh, BOOL bSyncEngine, ChordEntry*&	pChordChange)
{
	ChordEntry *pChord;
	ChordSelection *pTemp;
	POINTS		ptNewPoint = {0, 0};
	CRect rect;
	long measure = 0;

	HRESULT hr = S_OK;

	if( FAILED(m_pChordMapMgr->CreateBlankChord( &pChord )) )
	{
		hr = E_NOTIMPL;
		goto Leave;
	}

	// Copy the allocated SignPost Chord into the new Beginning Chord.
	pTemp = (ChordSelection *)lParam;
	ASSERT( pTemp != NULL );  // means bug in SignPost list.

	memcpy( &(pChord->m_chordsel), pTemp, sizeof( pChord->m_chordsel ) );
	pChord->m_dwflags = (DWORD)(wParam);

	if(wParam & CE_END)
	{
		VARIANT vtInit;
		long clocks;
		long pos;
		vtInit.vt = VT_I4;
		m_pChordMapMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &vtInit );
		clocks = V_I4(&vtInit);
		m_pChordMapMgr->m_pTimeline->ClocksToMeasureBeat( m_pChordMapMgr->m_dwGroupBits, 0, clocks, &measure, 0);
		--measure;
		m_pChordMapMgr->m_pTimeline->MeasureBeatToPosition( m_pChordMapMgr->m_dwGroupBits, 0, measure, 0, &pos);
		ptNewPoint.x = static_cast<short>(pos);
		FindYPositionForChord(ptNewPoint.x, ptNewPoint.y, true);
	}
	else
	{
		// only clear for beginning signpost (or cadence chords)
		// end signpost chords are usually inserted with beg signpost chords and we
		// want to highlight both
		ClearSelectedChords();
		ptNewPoint.x = 0;
		FindYPositionForChord(0, ptNewPoint.y, false);
	}

	// Set new Chord (UI Box) where the user clicked the mouse.
	if( FAILED(SetChordXY( pChord, ptNewPoint )) ) // If user clicks end of timeline then method should fail (it currently does not).
	{
		delete pChord;
		hr = E_FAIL;
		goto Leave;
	}
	// redo measure as timeline calcs sometimes screw it up
	pChord->m_chordsel.Measure() = (short)measure;
	m_pChordMapMgr->SendEditNotification(IDS_INSERT);
	m_pChordMapMgr->m_pChordMapList->AddTail( pChord );
	pChord->m_chordsel.KeyDown() = TRUE;
	bRefresh = TRUE;
	bSyncEngine = TRUE;
	pChordChange = pChord;	// notify client of selected chord
	hr = S_OK;

Leave:
	return hr;

}

void CChordMapStrip::SetFocusToTimeline()
{
	// set focus to timeline
			// Set the focus to the timeline
	IOleInPlaceObjectWindowless* pIOleInPlaceObjectWindowless;
	m_pChordMapMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleInPlaceObjectWindowless );
	if (pIOleInPlaceObjectWindowless)
	{
		HWND hwnd;
		if (pIOleInPlaceObjectWindowless->GetWindow(&hwnd) == S_OK)
		{
			::SetFocus(hwnd);
		}
		pIOleInPlaceObjectWindowless->Release();
	}

	// notify parent dialog that we have focus
	if( m_pfnFocusCallback)
	{
		m_pfnFocusCallback(m_lFocusHint);
	}
}

HRESULT CChordMapStrip::DoDragDrop(WPARAM wParam, LPARAM lParam, ChordEntry* pChord, ChordEntry*& pChordChange)
{
	HRESULT hr = S_OK;
	// first cancel drag drop
	if(m_fCapture)
	{
		VARIANT var;
		var.vt = VT_BOOL;
		V_BOOL(&var) = FALSE;
		m_pChordMapMgr->m_pTimeline->SetTimelineProperty(TP_STRIPMOUSECAPTURE, var);
		m_fCapture = false;
	}
	///////////////////////////////
	// Drag Chord
	m_fDragging = TRUE;
	m_bDrop = false;
	pChord->m_chordsel.KeyDown() = TRUE; // select and drag at same time
	// make sure chord is on top
	m_pChordMapMgr->m_pChordMapList->Remove(pChord);
	pChord->SetNext(0);
	m_pChordMapMgr->m_pChordMapList->AddTail(pChord);
	m_pChordMapMgr->m_selection = CChordMapMgr::ChordSelected;
	m_fSelected = TRUE;
	pChordChange = pChord;	// notify client of chord selected
	if(pChord->m_chordsel.KeyDown())	// drag/drop ops
	{
		m_bDrop = true;
		IDropSource* pIDropSource;
		DWORD dwEffect = DROPEFFECT_NONE;
		if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
		{
			// create data object and image
			hr = CreateDataObject(&m_pISourceDataObject, m_ptLastMouse);
			if(SUCCEEDED(hr))
			{
				m_pDragImage = CreateDragImage();
				if(m_pDragImage)
				{
					m_pDragImage->BeginDrag(0, CPoint(8,12));
				}
				// start drag drop
				// when CanCut added, check to see if DROPEFFECT_MOVE allowed (see chordstrip.cpp)
				DWORD dwOKDragEffects = DROPEFFECT_COPY | DROPEFFECT_MOVE;
				m_dwStartDragButton = (unsigned long)wParam;
				/*
				m_startDragPosition.x = (long)(LOWORD(lParam));
				m_startDragPosition.y = (long)(HIWORD(lParam));
				*/
				// set to upper left of chord being dragged
				m_startDragPosition.x = pChord->m_rect.left;
				m_startDragPosition.y = pChord->m_rect.top;
				m_bInternalDrop = false;
				hr = ::DoDragDrop(m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect);
				// drag drop completed, cleanup
				m_dwStartDragButton = 0;
				if(m_pDragImage)
				{
					m_pDragImage->EndDrag();
					delete m_pDragImage;
					m_pDragImage = NULL;
				}
				switch(hr)
				{
				case DRAGDROP_S_DROP:
					if(m_bInternalDrop)
					{
						m_bInternalDrop = false;
						if(dwEffect & DROPEFFECT_MOVE)
						{
							// we're doing an internal drag/drop, just move the chord
							pChordChange = m_pDragChord;
							ASSERT(pChordChange);
							m_pChordMapMgr->SendEditNotification(IDS_MOVE);
							InternalMove(m_ptDrop);
						}
						else // this path never entered: copies handled like foreign drops
						{
							pChordChange = m_pDragChord;
							ASSERT(pChordChange);
							m_pChordMapMgr->SendEditNotification(IDS_COPY);
							InternalCopy(m_ptDrop);
						}
						m_pChordMapMgr->DetectAndReverseConnections(*(m_pChordMapMgr->m_pChordMapList));
					}
					else if(dwEffect & DROPEFFECT_MOVE)
					{
						m_pChordMapMgr->SendEditNotification(IDS_DELETE);
						DeleteMarkedChords(CE_DRAGSELECT);
						pChordChange = 0;
					}
					if(dwEffect == DROPEFFECT_NONE)
					{
						m_bDrop = false;
					}
					break;
				default:
					m_bDrop = false;
					break;
				}
				hr = S_OK;
				m_pISourceDataObject->Release();
				m_pISourceDataObject = NULL;
				m_startDragPosition.x = 0;
				m_startDragPosition.y = 0;
			}
			pIDropSource->Release();
			UnMarkChords(CE_DRAGSELECT);
		}
		else
		{
			hr = E_FAIL;
		}

		bool drop = m_bDrop;
		m_bDrop = drop;

		if(!m_bDrop)
		{
			/* selected chords should remain selected
			ClearSelectedChords();
			*/
		}
		else
		{
			RecomputeConnections( false );
			m_pChordMapMgr->m_pTimeline->OnDataChanged(0);
		}
		m_pChordMapMgr->m_pTimeline->Refresh();


	}
	else
	{
		// select chord
		pChord->m_chordsel.KeyDown() = TRUE;
	}
	// forces Jazz/OLE drag/drop rather than old intra-chordmap drag/drop
	m_fDragging = FALSE;
	return hr;
}


void CChordMapStrip::GetBoundingRectRelativeToChord(ChordEntryList& list, ChordEntry* pRefChord, RECT& rect)
{
	GetBoundingRect(list, rect);


	// take max extents relative to chord's top left corner
	rect.left = rect.left - pRefChord->m_rect.left;
	rect.top = rect.top - pRefChord->m_rect.top;
	rect.right = rect.right - pRefChord->m_rect.left;
	rect.bottom = rect.bottom - pRefChord->m_rect.top;
/*
	if(m_pISourceDataObject == m_pITargetDataObject)
	{
		// intra-map drag -- correct for diff between drag-point and refchord
		long x = m_startDragPosition.x;
		long y = m_startDragPosition.y;

		long l = x - pRefChord->m_rect.left;
		long t = y - pRefChord->m_rect.top;
		long r = pRefChord->m_rect.right - x;
		long b = pRefChord->m_rect.bottom -y;

		rect.left -= l;
		rect.top -= t;
		rect.right -= l;
		rect.bottom -= t;
	}
*/
}

HRESULT CChordMapStrip::CheckBoundsForDrag(POINTL pt, RECT* pExcess)
{
	VARIANT var;
	int strip_height = GetStripHeight();
	m_pChordMapMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var);

	int clocks = V_I4(&var);
	long lengthInMeasures, lengthInBeats, timesigBPM;
	long strip_width;
	m_pChordMapMgr->m_pTimeline->ClocksToPosition(clocks, &strip_width);
	m_pChordMapMgr->m_pTimeline->ClocksToMeasureBeat(m_pChordMapMgr->m_dwGroupBits, 0,
									clocks,
									&lengthInMeasures, &lengthInBeats);
	m_pChordMapMgr->GetTimeSig(&timesigBPM, 0);
	lengthInBeats = lengthInMeasures*timesigBPM + lengthInBeats;


	m_pChordMapMgr->m_pTimeline->GetTimelineProperty(TP_VERTICAL_SCROLL, &var);
	int vscroll = V_I4(&var);
/*
	bool ok = (pt.y - m_rectAggregate.top/2) >= 0;
	ok &= ((pt.x - m_rectAggregate.left/2) >= 0);
	ok &= ((pt.y + m_rectAggregate.bottom/2) < strip_height);
	ok &= ((pt.x + m_rectAggregate.right/4) < strip_width);
*/
	
	bool ok = (pt.x + m_rectAggregate.left) >= 0;
	ok = ok && (pt.y + m_rectAggregate.top) >= 0;
	ok = ok && (pt.y + m_rectAggregate.bottom) < strip_height;
	// get position of rightmost chord and translate it to beats
	long rightmost = pt.x + m_rectAggregate.right;
	long m, rightmostBeats;
	rightmost -= CHORD_WIDTH;
	m_pChordMapMgr->m_pTimeline->PositionToMeasureBeat(m_pChordMapMgr->m_dwGroupBits, 0,
														rightmost,
														&m, &rightmostBeats);
	rightmostBeats = m*timesigBPM + rightmostBeats;

	ok = ok && (rightmostBeats < (lengthInBeats-1));

/*
	static int x = 0;
	x += 1;
	x = x % 10;
	if(x == 0)
	{
		TRACE("\r\nl:%d, t:%d, b:%d, height:%d, rightmostBeats:%d, lengthInBeats:%d",
				pt.x + m_rectAggregate.left,
				pt.y + m_rectAggregate.top,
				pt.y + m_rectAggregate.bottom,
				strip_height, 
				rightmostBeats,
				lengthInBeats);
	}
*/
	CString s;
	s = ok ? "OK" : "OUT";
	if(!ok)
	{
		TRACE("DragPoint Outside = %d, %d\r\n", pt.x, pt.y);
	}
	if(pExcess)
	{
		pExcess->top = pt.y - m_rectAggregate.top/2;
		pExcess->left = pt.x - m_rectAggregate.left/2;
		pExcess->bottom = strip_height - pt.y - m_rectAggregate.bottom/2;
		pExcess->right = strip_width - pt.x - m_rectAggregate.right/4;
	}
	return ok ? S_OK : S_FALSE;
}




void CChordMapStrip::ComputeSelectionBoxOutline(POINTS ptBeg, POINTS ptEnd, bool bRecomputeDragState)
{
	VARIANT var;
	CDC dc;
	CRect rectFBar;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	ASSERT(m_pChordMapMgr);
	
	if(!m_pChordMapMgr)
		return;
	ASSERT(m_pChordMapMgr->m_pTimeline);
	if(!m_pChordMapMgr->m_pTimeline)
		return;
	if( FAILED ( m_pChordMapMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_FBAR_RECT, &var ) ) )
	{
		return;
	}
	rectFBar.InflateRect(1, 1);

	m_SelectionDragState.bActive = true;


	// Get the DC of our Strip					
	if( SUCCEEDED(m_pChordMapMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip*)this, STP_GET_HDC, &var )) )
	{
		RECT rtStrip;
		if( dc.Attach( (HDC)(var.lVal) ) != 0 )
		{                  

			dc.GetClipBox(&rtStrip);
			long vpos, hpos;
			if(SUCCEEDED(m_pChordMapMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var )))
			{
				hpos = V_I4(&var);
			}
			if(SUCCEEDED(m_pChordMapMgr->m_pTimeline->GetTimelineProperty( TP_VERTICAL_SCROLL, &var )))
			{
				vpos = V_I4(&var);
			}

			if(bRecomputeDragState)
			{
				// setup or update autoscroll
				short xOrg = ptBeg.x - static_cast<short>(hpos);
				short xTo = ptEnd.x  - static_cast<short>(hpos);
				short yOrg = ptBeg.y - static_cast<short>(vpos);
				short yTo = ptEnd.y - static_cast<short>(vpos);
				TRACE("ptBeg: (%d, %d) ptEnd: (%d, %d)\r\n", ptBeg.x, ptBeg.y, ptEnd.x, ptEnd.y);
				/*
				short xOrg = ptBeg.x - static_cast<short>(hpos);
				short xTo = ptEnd.x  - static_cast<short>(hpos);
				short yOrg = ptBeg.y - static_cast<short>(vpos);
				short yTo = ptEnd.y - static_cast<short>(vpos);
				*/
				m_SelectionDragState.xOrg = xOrg;
				m_SelectionDragState.yOrg = yOrg;
				m_SelectionDragState.xTo = xTo;
				m_SelectionDragState.yTo = yTo;


//				TRACE("xTo: %d, right edge: %d\r\n", xTo, rtStrip.right);
				if(xTo > rtStrip.right)
				{
					m_SelectionDragState.dir |= DragState::right;
				}
				else
				{
					m_SelectionDragState.dir &= ~DragState::right;
				}
				if(xTo < rtStrip.left+3)
				{
					m_SelectionDragState.dir |= DragState::left;
				}
				else
				{
					m_SelectionDragState.dir &= ~DragState::left;
				}
				if(yTo < rtStrip.top)
				{
					m_SelectionDragState.dir |= DragState::up;
				}
				else
				{
					m_SelectionDragState.dir &= ~DragState::up;
				}
				if(yTo > rtStrip.bottom)
				{
					m_SelectionDragState.dir |= DragState::down;
				}
				else
				{
					m_SelectionDragState.dir &= ~DragState::down;
				}
				if(m_SelectionDragState.dir != DragState::off && !m_SelectionDragState.bAutoscroll)
				{
					// turn autoscrolling on
					m_SelectionDragState.bAutoscroll = true;
					::SetTimer(GetTimelineCWnd()->m_hWnd, SelectionDrag, 100, NULL);
//					TRACE("Setting Timer for SelectionDrag\r\n");
				}
				else if(m_SelectionDragState.dir == DragState::off && m_SelectionDragState.bAutoscroll)
				{
					// turn autoscrolling off
					m_SelectionDragState.bAutoscroll = false;
					::KillTimer(GetTimelineCWnd()->m_hWnd, SelectionDrag);
					TRACE("Killing Timer for SelectionDrag\r\n");
				}
			}

		  // set select rectangle
			m_rectSelect.top = ptBeg.y <= ptEnd.y ? ptBeg.y : ptEnd.y;
			m_rectSelect.bottom = ptBeg.y <= ptEnd.y ? ptEnd.y : ptBeg.y;
			m_rectSelect.right = ptBeg.x <= ptEnd.x ? ptEnd.x : ptBeg.x;
			m_rectSelect.left = ptBeg.x <= ptEnd.x ? ptBeg.x : ptEnd.x;

			if(ptBeg.x <= ptEnd.x)
			{
				// normal rectangle
				if(m_SelectionDragState.dir == DragState::left)
				{
					// against left edge
					m_rectBounding.left = rtStrip.left;
				}
				else
				{
					m_rectBounding.left = ptBeg.x - hpos;
				}
				if(m_SelectionDragState.dir == DragState::right)
				{
					// against right edge
					m_rectBounding.right = rtStrip.right;
				}
				else
				{
					m_rectBounding.right = ptEnd.x - hpos;
				}
			}
			else
			{
				// left side > right side, swap sides
				if(m_SelectionDragState.dir == DragState::left)
				{
					// against left edge
					m_rectBounding.right = rtStrip.left;
				}
				else
				{
					m_rectBounding.right = ptBeg.x - hpos;
				}
				if(m_SelectionDragState.dir == DragState::right)
				{
					// against right edge
					m_rectBounding.left = rtStrip.right;
				}
				else
				{
					m_rectBounding.left = ptEnd.x - hpos;
				}
			}

			if(ptBeg.y <= ptEnd.y)
			{
				// normal rectangle
				if(m_SelectionDragState.dir == DragState::up)
				{
					// against top edge
					m_rectBounding.top = rtStrip.top;
				}
				else
				{
					m_rectBounding.top = ptBeg.y/* - vpos*/;
				}
				if(m_SelectionDragState.dir == DragState::down)
				{
					// against bottom edge
					m_rectBounding.bottom = rtStrip.bottom;
				}
				else
				{
					m_rectBounding.bottom = ptEnd.y/* - vpos*/;
				}
			}
			else
			{
				// top side > bottom side, swap sides
				if(m_SelectionDragState.dir == DragState::up)
				{
					// against top edge
					m_rectBounding.bottom = rtStrip.top;
				}
				else
				{
					m_rectBounding.bottom = ptBeg.y /*- vpos*/;
				}
				if(m_SelectionDragState.dir == DragState::down)
				{
					// against bottom edge
					m_rectBounding.top = rtStrip.bottom;
				}
				else
				{
					m_rectBounding.top = ptEnd.y /*- vpos*/;
				}
			}

		}
		TRACE("top edge: %x bottom edge: %x\r\n", rtStrip.top, rtStrip.bottom);
		dc.Detach();
	}
}

void CChordMapStrip::GetBoundingRect(ChordEntryList& list, RECT& rect)
{
	rect.left = 0x7fffffff;
	rect.right = 0;
	rect.top = 0x7fffffff;
	rect.bottom = 0;

	for(ChordEntry* pChord = list.GetHead(); pChord; pChord = pChord->GetNext())
	{
		if(pChord->m_rect.left < rect.left)
		{
			rect.left = pChord->m_rect.left;
		}
		if(pChord->m_rect.right > rect.right)
		{
			rect.right = pChord->m_rect.right;
		}
		if(pChord->m_rect.top < rect.top)
		{
			rect.top = pChord->m_rect.top;
		}
		if(pChord->m_rect.bottom > rect.bottom)
		{
			rect.bottom = pChord->m_rect.bottom;
		}
	}
	if(rect.bottom < rect.top)
	{
		rect.bottom = rect.top;
	}
}

void CChordMapStrip::GetBoundingRectOfSelectedChords(RECT& rect)
{
	rect.left = 0x7fffffff;
	rect.right = 0;
	rect.top = 0x7fffffff;
	rect.bottom = 0;

	for(ChordEntry* pChord = m_pChordMapMgr->m_pChordMapList->GetHead(); 
			pChord; pChord = pChord->GetNext())
	{
		if(pChord->m_chordsel.KeyDown())
		{
			if(pChord->m_rect.left < rect.left)
			{
				rect.left = pChord->m_rect.left;
			}
			if(pChord->m_rect.right > rect.right)
			{
				rect.right = pChord->m_rect.right;
			}
			if(pChord->m_rect.top < rect.top)
			{
				rect.top = pChord->m_rect.top;
			}
			if(pChord->m_rect.bottom > rect.bottom)
			{
				rect.bottom = pChord->m_rect.bottom;
			}
		}
	}
}

long CChordMapStrip::GetVerticalScroll()
{
	VARIANT var;
	m_pChordMapMgr->m_pTimeline->GetTimelineProperty(TP_VERTICAL_SCROLL, &var);
	long vscroll = V_I4(&var);
	return vscroll;
}



HRESULT CChordMapStrip::RecomputeConnections( bool fChangingToVariableMode )
{
	ChordEntry* pChord;
	for(pChord = m_pChordMapMgr->m_pChordMapList->GetHead(); pChord; pChord = pChord->GetNext())
	{
		NextChord*	pConnection;
		pConnection = pChord->m_nextchordlist.GetHead();

		while( pConnection )
		{
			if( pConnection->m_nextchord != NULL )
			{

				long nC1Pos, nC2Pos;
				long nC1Clocks, nC2Clocks;
				m_pChordMapMgr->m_pTimeline->MeasureBeatToClocks( m_pChordMapMgr->m_dwGroupBits, 0,
																  pChord->m_chordsel.Measure(), 
																  pChord->m_chordsel.Beat(), 
																  &nC1Clocks );
				m_pChordMapMgr->m_pTimeline->MeasureBeatToClocks( m_pChordMapMgr->m_dwGroupBits, 0,
																  pConnection->m_nextchord->m_chordsel.Measure(),
																  pConnection->m_nextchord->m_chordsel.Beat(), 
																  &nC2Clocks );
				long nDeltaC1C2 = ( nC1Clocks > nC2Clocks ) ? nC1Clocks - nC2Clocks 
																: nC2Clocks - nC1Clocks;

				m_pChordMapMgr->m_pTimeline->ClocksToMeasureBeat( m_pChordMapMgr->m_dwGroupBits, 0, nDeltaC1C2, &nC1Pos, &nC2Pos );

				long bpm;
				m_pChordMapMgr->GetTimeSig(&bpm, 0);
				nC2Pos += bpm*nC1Pos;

				if( m_fVariableNotFixed )
				{
					if( fChangingToVariableMode
					|| ((pChord->m_chordsel.KeyDown() == TRUE) && (pConnection->m_nextchord->m_chordsel.KeyDown() == FALSE))
					|| ((pChord->m_chordsel.KeyDown() == FALSE) && (pConnection->m_nextchord->m_chordsel.KeyDown() == TRUE)) )
					{
						pConnection->m_nminbeats = 1;
						pConnection->m_nmaxbeats = (short)nC2Pos;
					}
				}
				else
				{
					pConnection->m_nminbeats = (short)nC2Pos;
					pConnection->m_nmaxbeats = (short)nC2Pos;
				}
			}

			pConnection = pConnection->GetNext();
		}
	}
	return S_OK;
}

bool CChordMapStrip::ContainsSignpost(ChordEntryList& list)
{
	bool bContainsSignpost = false;
	for(ChordEntry* pChord = list.GetHead(); pChord && !bContainsSignpost; pChord = pChord->GetNext())
	{
		if( (pChord->m_dwflags & CE_START) || (pChord->m_dwflags & CE_END) )
		{
			bContainsSignpost = true;
		}
	}
	return bContainsSignpost;
}

bool CChordMapStrip::SelectedChordsContainsSignpost()
{
	bool bContainsSignpost = false;
	for(ChordEntry* pChord = m_pChordMapMgr->m_pChordMapList->GetHead(); pChord; pChord = pChord->GetNext())
	{
		if( (pChord->m_chordsel.KeyDown()) && ( (pChord->m_dwflags & CE_START) || (pChord->m_dwflags & CE_END)) )
		{
			bContainsSignpost = true;
		}
	}
	return bContainsSignpost;
}

void CChordMapStrip::PositionToMeasureBeat(long pos, long& measure, long& beat)
{
	m_pChordMapMgr->m_pTimeline->PositionToMeasureBeat( m_pChordMapMgr->m_dwGroupBits, 
														0, 
														pos, 
														&measure, &beat);
}

void CChordMapStrip::MeasureBeatToPosition(long measure, long beat, long& pos)
{
	m_pChordMapMgr->m_pTimeline->MeasureBeatToPosition(m_pChordMapMgr->m_dwGroupBits,
														0,
														measure, beat,
														&pos);
}

void CChordMapStrip::PositionToClocks(long pos, long& clocks)
{
	m_pChordMapMgr->m_pTimeline->PositionToClocks(pos, &clocks);
}

void CChordMapStrip::ClocksToPosition(long clocks, long& pos)
{
	m_pChordMapMgr->m_pTimeline->ClocksToPosition(clocks, &pos);
}

long CChordMapStrip::ClocksPerMeasure()
{
	long bpm;
	long beat;
	m_pChordMapMgr->GetTimeSig(&bpm, &beat);

	long clocksPerMeasure = ( (DMUS_PPQ * 4) / beat ) * bpm;
	return clocksPerMeasure;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ChordMapStripMgr.cpp ===
// ChordMapStripMgr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f ChordMapStripMgrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "ChordMapStripMgr.h"

#include "ChordMapMgr.h"
#include <ChordMapDesigner.h>
#include <SegmentGuids.h>
#include "AFXCTL.H"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_ChordMapMgr, CChordMapMgr)
END_OBJECT_MAP()

/*class CChordMapStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};
*/

CChordMapStripMgrApp theApp;

BOOL CChordMapStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	return CWinApp::InitInstance();
}

int CChordMapStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	//AfxOleUnregisterTypeLib( LIBID_ChordMapSTRIPMGRLib );
	_Module.UnregisterServer(FALSE);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ChordScalePropPage.h ===
#if !defined(AFX_CHORDSCALEPROPPAGE_H__E4A7E135_B485_11D1_9875_00805FA67D16__INCLUDED_)
#define AFX_CHORDSCALEPROPPAGE_H__E4A7E135_B485_11D1_9875_00805FA67D16__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <afxext.h>
#include "resource.h"
#include "dmusici.h"
#include "conductor.h"
#include "..\shared\keyboard.h"
// ChordScalePropPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CChordScalePropPageData (used to transfer data to/from property tab)

class CChordScalePropPageData
{
public:
	CChordScalePropPageData()
	{
		m_pPropChord = NULL;
		m_fLockAllScales = TRUE;
		m_fSyncLevelOneToAll = TRUE;
	}
	
	~CChordScalePropPageData()
	{
	}

	CPropChord*			m_pPropChord;
	BOOL				m_fLockAllScales;
	BOOL				m_fSyncLevelOneToAll;
};


/////////////////////////////////////////////////////////////////////////////
// CChordScalePropPage dialog
class CChordPropPageMgr;

class CChordScalePropPage : public CPropertyPage, public IDMUSProdMidiInCPt
{
	friend class CChordPropPageMgr;
	DECLARE_DYNCREATE(CChordScalePropPage)

// Construction
public:
	enum { MAX_POLY = 4 , CHORDNOTE_DUR = 250, SCALENOTE_DUR = 250, CHORDNOTE_DELAY = 125, SCALENOTE_DELAY=25};
	CChordScalePropPage();
	~CChordScalePropPage();
// dispatch callbacks from keyboard controls
	void DispatchKeyboardChange(CKeyboard* pKeyboard, short nKey);

// Dialog Data
	//{{AFX_DATA(CChordScalePropPage)
	enum { IDD = IDD_CHORDSCALE_PROPPAGE };
	CSpinButtonCtrl	m_spinRoot;
	CEdit	m_chordname;
	CKeyboard	m_keysscale4;
	CKeyboard	m_keysscale3;
	CKeyboard	m_keysscale2;
	CKeyboard	m_keysscale1;
	CKeyboard	m_keyschord4;
	CKeyboard	m_keyschord3;
	CKeyboard	m_keyschord2;
	CKeyboard	m_keyschord1;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChordScalePropPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChordScalePropPage)
	virtual BOOL OnInitDialog();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnButtonMidichord4();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnButtonMidichord1();
	afx_msg void OnButtonMidichord2();
	afx_msg void OnButtonMidichord3();
	afx_msg void OnButtonMidiroot();
	afx_msg void OnButtonMidiscale1();
	afx_msg void OnButtonMidiscale2();
	afx_msg void OnButtonMidiscale3();
	afx_msg void OnButtonMidiscale4();
	afx_msg void OnButtonPlay1();
	afx_msg void OnButtonPlay2();
	afx_msg void OnButtonPlay3();
	afx_msg void OnButtonPlay4();
	afx_msg void OnButtonPlayall();
	afx_msg void OnChangeEditName();
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnUseflats();
	afx_msg void OnUsesharps();
	afx_msg void OnDeltaposSpinRoot(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void WarnUser();
	void DispatchRightMouseKeyboard(CKeyboard* pKeyboard, short nKey, CPoint& ptMouse);
	HRESULT ChangePatch(BYTE ch, BYTE inst, BYTE msb, BYTE lsb);
	HRESULT PlayNote(BYTE ch, BYTE key, BYTE vel, DWORD startTime, DWORD dur);
	void PlayAllChords();
	void PlaySubChord(int index);
	void SetMidiIn(int keyboard);
	void SetChord(CPropChord* pChord);
	void SetChordData(CChordScalePropPageData* pChordScalePropPageData);
	void UpdateChordData();

	// IUnknown functions
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IDMUSProdMidiInCPt functions
	HRESULT STDMETHODCALLTYPE OnMidiMsg(REFERENCE_TIME rtTime, 
										BYTE bStatus, 
										BYTE bData1, 
										BYTE bData2);

private:
	BOOL m_bNotWarn;
	enum {All = -1, Nop = 1000, CopyChord, CopyScale, CopyChordScale, ClearChordScale};	// chord to chord copy ops
	void ComputeCopyOp(WORD menuid, int& from, int& to, int& what);
	CButton* GetButton(int id);
	enum {None = -1, Chord1 = 0, Chord2 = 1, Chord3 = 2, Chord4 = 3, Scale1 = 4, Scale2 = 5, Scale3 = 6, Scale4 = 7, Root = 8};
	UINT	m_MidiInIds[MAX_POLY*2 + 1];
	int m_fMidiInputTarget;
	void OnChangeRoot( bool fUpdateChordData );
	void SetCheckBox(CPropChord* pChord, DWORD dwUDFlag, UINT nDlgID, UINT nState);
	void OnNoteDownChordKeys(CKeyboard* pKeyboard, int index, short nKey);
	void OnNoteDownScaleKeys(CKeyboard* pKeyboard, int index, short nKey);
//	void DrawScaleNote(CPropChord* pChord, int index, short nX);
	void DrawScale(CPropChord* pChord, int index, int note = -1 /* set this to do only one note */);
	int	GetChordKeyboardIndex(const CKeyboard* pKeyboard);
	int GetScaleKeyboardIndex(const CKeyboard* pKeyboard);
	int m_nLastKeyboardLevel;	// keyboard last rightclicked on (for copy ops)
	CKeyboard*		GetChordKeyboard(int index)
	{
		switch(index)
		{
		case 0:
			return &m_keyschord1;			
			break;
		case 1:
			return &m_keyschord2;
			break;
		case 2:
			return &m_keyschord3;
			break;
		case 3:
			return &m_keyschord4;
			break;
		default:
			return 0;
			break;
		}
	}
	CKeyboard*		GetScaleKeyboard(int index)
	{
		switch(index)
		{
		case 0:
			return &m_keysscale1;
			break;
		case 1:
			return &m_keysscale2;
			break;
		case 2:
			return &m_keysscale3;
			break;
		case 3:
			return &m_keysscale4;
			break;
		default:
			return 0;
			break;
		}
	}

	CBitmapButton	m_midichord4;
	CBitmapButton	m_midichord3;
	CBitmapButton	m_midichord2;
	CBitmapButton	m_midichord1;
	CBitmapButton* GetMidiChordButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_midichord1;			
			break;
		case 1:
			return &m_midichord2;
			break;
		case 2:
			return &m_midichord3;
			break;
		case 3:
			return &m_midichord4;
			break;
		default:
			return 0;
			break;
		}
	}

	CBitmapButton	m_midiscale4;
	CBitmapButton	m_midiscale3;
	CBitmapButton	m_midiscale2;
	CBitmapButton	m_midiscale1;
	CBitmapButton*	GetMidiScaleButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_midiscale1;
			break;
		case 1:
			return &m_midiscale2;
			break;
		case 2:
			return &m_midiscale3;
			break;
		case 3:
			return &m_midiscale4;
			break;
		default:
			return 0;
			break;
		}
	}

	
	CBitmapButton	m_midiroot;
	
	CBitmapButton	m_shiftl4;
	CBitmapButton	m_shiftl3;
	CBitmapButton	m_shiftl2;
	CBitmapButton	m_shiftl1;
	CBitmapButton* GetShiftLButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_shiftl1;
			break;
		case 1:
			return &m_shiftl2;
			break;
		case 2:
			return &m_shiftl3;
			break;
		case 3:
			return &m_shiftl4;
			break;
		default:
			return 0;
			break;
		}
	}

	CBitmapButton	m_shiftr4;
	CBitmapButton	m_shiftr3;
	CBitmapButton	m_shiftr2;
	CBitmapButton	m_shiftr1;
	CBitmapButton* GetShiftRButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_shiftr1;
			break;
		case 1:
			return &m_shiftr2;
			break;
		case 2:
			return &m_shiftr3;
			break;
		case 3:
			return &m_shiftr4;
			break;
		default:
			return 0;
			break;
		}
	}
	
	CBitmapButton	m_play4;
	CBitmapButton	m_play3;
	CBitmapButton	m_play2;
	CBitmapButton	m_play1;
	CBitmapButton* GetPlayButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_play1;
			break;
		case 1:
			return &m_play2;
			break;
		case 2:
			return &m_play3;
			break;
		case 3:
			return &m_play4;
			break;
		default:
			return 0;
			break;
		}
	}
		
void EnableControls(BOOL bEnable);

	CBitmapButton	m_playall;
	
	BOOL			m_fNeedToDetach;
	bool			m_bValidChord;
	
	CPropChord		m_Chord;
	BOOL			m_fLockAllScales;
	BOOL			m_fSyncLevelOneToAll;

	DWORD			m_cRef;
	CChordPropPageMgr*	m_pPropPageMgr;
	IDMUSProdConductor* m_pIConductor;
	IDirectMusicPerformance*	m_pIPerformance;
	void RegisterMidi();
	void UnRegisterMidi();
	DWORD m_dwCookie;		// may be used to distinguish what chord is receiving input (if necessary)
	DWORD m_cRegCount;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHORDSCALEPROPPAGE_H__E4A7E135_B485_11D1_9875_00805FA67D16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ChordScalePropPage.cpp ===
// ChordScalePropPage.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "..\includes\DMUSProd.h"
#include "..\includes\Conductor.h"
#include "DllBasePropPageManager.h"
#include "PropChord.h"
#include "PropPageMgr.h"
#include "chordmapstripmgr.h"
#include "ChordScalePropPage.h"
#include "IllegalChord.h"
#pragma warning(default:4201)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////// Callbacks for CKeyboard Events
//
void KeyboardChangeCallback(CKeyboard* pKeyboard, void* hint, short nKey)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CChordScalePropPage* pdlg = (CChordScalePropPage*)hint;
	pdlg->DispatchKeyboardChange(pKeyboard, nKey);
}

void RMouseKeyboardCallback(CKeyboard* pKeyboard, void* hint, short nKey, CPoint& ptMouse)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CChordScalePropPage* pdlg = (CChordScalePropPage*)hint;
	pdlg->DispatchRightMouseKeyboard(pKeyboard, nKey, ptMouse);
}

/////////////////////////////////////////////////////////////////////////////
// CChordScalePropPage property page

IMPLEMENT_DYNCREATE(CChordScalePropPage, CPropertyPage)

CChordScalePropPage::CChordScalePropPage() : CPropertyPage(CChordScalePropPage::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	//{{AFX_DATA_INIT(CChordScalePropPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pPropPageMgr = NULL;
	m_fMidiInputTarget = None;
	m_dwCookie = 0;
	m_pIConductor = 0;
	m_pIPerformance = 0;
	m_cRef = 0;
	m_cRegCount = 0;
	m_bValidChord = false;
	m_fNeedToDetach = FALSE;
	m_fLockAllScales = TRUE;
	m_fSyncLevelOneToAll = TRUE;
	AddRef();

	m_MidiInIds[0] = IDC_BUTTON_MIDICHORD1;
	m_MidiInIds[1] = IDC_BUTTON_MIDICHORD2;
	m_MidiInIds[2] = IDC_BUTTON_MIDICHORD3;
	m_MidiInIds[3] = IDC_BUTTON_MIDICHORD4;

	m_MidiInIds[4] = IDC_BUTTON_MIDISCALE1;
	m_MidiInIds[5] = IDC_BUTTON_MIDISCALE2;
	m_MidiInIds[6] = IDC_BUTTON_MIDISCALE3;
	m_MidiInIds[7] = IDC_BUTTON_MIDISCALE4;

	m_MidiInIds[8] = 0;

	m_nLastKeyboardLevel = -1;

	m_bNotWarn = FALSE;
}

CChordScalePropPage::~CChordScalePropPage()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	UnRegisterMidi();	// make sure we're unregistered
	if(m_pIConductor)
	{
		m_pIConductor->Release();
	}
	if(m_pIPerformance)
	{
		m_pIPerformance->Release();
	}
}

void CChordScalePropPage::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChordScalePropPage)
	DDX_Control(pDX, IDC_SPIN_ROOT, m_spinRoot);
	DDX_Control(pDX, IDC_EDIT_NAME, m_chordname);
	DDX_Control(pDX, IDC_KEYS_SCALE4, m_keysscale4);
	DDX_Control(pDX, IDC_KEYS_SCALE3, m_keysscale3);
	DDX_Control(pDX, IDC_KEYS_SCALE2, m_keysscale2);
	DDX_Control(pDX, IDC_KEYS_SCALE1, m_keysscale1);
	DDX_Control(pDX, IDC_KEYS_CHORD4, m_keyschord4);
	DDX_Control(pDX, IDC_KEYS_CHORD3, m_keyschord3);
	DDX_Control(pDX, IDC_KEYS_CHORD2, m_keyschord2);
	DDX_Control(pDX, IDC_KEYS_CHORD1, m_keyschord1);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChordScalePropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CChordScalePropPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD4, OnButtonMidichord4)
	ON_WM_DRAWITEM()
	ON_WM_MEASUREITEM()
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD1, OnButtonMidichord1)
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD2, OnButtonMidichord2)
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD3, OnButtonMidichord3)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE1, OnButtonMidiscale1)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE2, OnButtonMidiscale2)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE3, OnButtonMidiscale3)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE4, OnButtonMidiscale4)
	ON_BN_CLICKED(IDC_BUTTON_PLAY1, OnButtonPlay1)
	ON_BN_CLICKED(IDC_BUTTON_PLAY2, OnButtonPlay2)
	ON_BN_CLICKED(IDC_BUTTON_PLAY3, OnButtonPlay3)
	ON_BN_CLICKED(IDC_BUTTON_PLAY4, OnButtonPlay4)
	ON_BN_CLICKED(IDC_BUTTON_PLAYALL, OnButtonPlayall)
	ON_EN_CHANGE(IDC_EDIT_NAME, OnChangeEditName)
	ON_WM_KILLFOCUS()
	ON_BN_CLICKED(IDC_USEFLATS, OnUseflats)
	ON_BN_CLICKED(IDC_USESHARPS, OnUsesharps)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ROOT, OnDeltaposSpinRoot)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChordScalePropPage message handlers


///////////////////////////////////////////////////////////////////////////
// CChordScalePropPage other funcs
const short KeyOCXTrans = 48;
const short KeyOCXLow = 0;
const short KeyOCXHigh = 23;
#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0

#define MIDI_BASEPITCH		48

HRESULT CChordScalePropPage::OnMidiMsg(REFERENCE_TIME rtTime,
									   BYTE bStatus, 
									   BYTE bData1, 
									   BYTE bData2)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	UNREFERENCED_PARAMETER(rtTime);

	// Note On
	if((int)(bStatus & 0xF0) == (int)0x90)
	{

		char Text[128];
		sprintf(Text, "Inside  PropPageChord::OnMidiMsg going to play %d note on\n", bData1); 
		TRACE0(Text);

		// set note
		short nKey = static_cast<short>(bData1 - KeyOCXTrans);

		if(m_fMidiInputTarget < 4)
		{
			bool rootHasChanged = m_fMidiInputTarget == 0 && (nKey <= m_Chord.Base()->ChordRoot());
			DispatchKeyboardChange(GetChordKeyboard(m_fMidiInputTarget), nKey);
			if(rootHasChanged)
			{
//				GetChordKeyboard(m_fMidiInputTarget)->SetLowerBound(GetChordKeyboard(m_fMidiInputTarget)->Transpose());
			}
		}
		else if(m_fMidiInputTarget < 8)
		{
			DispatchKeyboardChange(GetScaleKeyboard(m_fMidiInputTarget - 4), nKey);
		}
	}

	// Note Off
	if((int)(bStatus & 0xF0) == (int)0x80)
	{
		char Text[128];
		sprintf(Text, "Inside  PropPageChord::OnMidiMsg going to play %d note off\n", bData1); 
		TRACE0(Text);
	}

	// set up patch
	m_pIConductor->PlayMIDIEvent( MIDI_CCHANGE, 7, 100, 0);
	m_pIConductor->PlayMIDIEvent( MIDI_CCHANGE, 10, 63, 0);
	m_pIConductor->PlayMIDIEvent( MIDI_CCHANGE, 32, 0, 0);
	m_pIConductor->PlayMIDIEvent( MIDI_CCHANGE, 0, 0, 0);
	m_pIConductor->PlayMIDIEvent( MIDI_PCHANGE, 0, 0, 0 );
	m_pIConductor->PlayMIDIEvent( MIDI_PCHANGE+1, 10, 0, 0 );

	m_pIConductor->PlayMIDIEvent(static_cast<BYTE>(bStatus & 0xF0),
								 bData1,
								 bData2,
								 0);	
	
	return S_OK;
}

void CChordScalePropPage::RegisterMidi() 
{
	ASSERT(m_cRegCount <= 1);
	if(m_fMidiInputTarget != None && m_cRegCount == 0)
	{
		++m_cRegCount;
		REGISTER_MIDI_IN(m_pIConductor, m_dwCookie)	
	}
}

void CChordScalePropPage::UnRegisterMidi()
{
	ASSERT(m_cRegCount <= 1);
	if(m_cRegCount)
	{
		m_cRegCount--;
		UNREGISTER_MIDI_IN(m_pIConductor, m_dwCookie)
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageChord IUnknown
STDMETHODIMP CChordScalePropPage::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	ASSERT( ppv );
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdMidiInCPt))
	{
        *ppv = (IUnknown *) (IDMUSProdMidiInCPt *) this;
	}
	else
	{
		return E_NOTIMPL;
	}
    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CChordScalePropPage::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CChordScalePropPage::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}

BOOL CChordScalePropPage::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	
	for(int i = 0; i < MAX_POLY; i++)
	{
		GetChordKeyboard(i)->SetLButtonUpCallback(KeyboardChangeCallback, this);
		GetScaleKeyboard(i)->SetLButtonUpCallback(KeyboardChangeCallback, this);
		GetChordKeyboard(i)->SetRButtonDownCallback(RMouseKeyboardCallback, this);
		GetScaleKeyboard(i)->SetRButtonDownCallback(RMouseKeyboardCallback, this);
		GetScaleKeyboard(i)->SetExtent(12);
		GetChordKeyboard(i)->SetExtent(48);
		GetChordKeyboard(i)->SetRootKeys(24);
		GetScaleKeyboard(i)->SetRootKeys(0);
	}
	
	m_midichord4.AutoLoad(IDC_BUTTON_MIDICHORD4, this);
	m_midichord3.AutoLoad(IDC_BUTTON_MIDICHORD3, this);
	m_midichord2.AutoLoad(IDC_BUTTON_MIDICHORD2, this);
	/*
	m_midichord1.Create( "MIDIPLUG", 
									 BS_OWNERDRAW | BS_AUTOCHECKBOX | WS_CHILD | WS_VISIBLE | WS_TABSTOP,
									 CRect(14,84,26,94), 
									 this, 
									 IDC_BUTTON_MIDICHORD1 );
									 */
	m_midichord1.AutoLoad(IDC_BUTTON_MIDICHORD1, this);
//	m_midichord1.LoadBitmaps( "MIDIPLUGU", "MIDIPLUGD");



	m_midiscale4.AutoLoad(IDC_BUTTON_MIDISCALE4, this);
	m_midiscale3.AutoLoad(IDC_BUTTON_MIDISCALE3, this);
	m_midiscale2.AutoLoad(IDC_BUTTON_MIDISCALE2, this);
	m_midiscale1.AutoLoad(IDC_BUTTON_MIDISCALE1, this);


//	m_midiroot.AutoLoad(IDC_BUTTON_MIDIROOT, this);


	m_play4.AutoLoad(IDC_BUTTON_PLAY4, this);
	m_play3.AutoLoad(IDC_BUTTON_PLAY3, this);
	m_play2.AutoLoad(IDC_BUTTON_PLAY2, this);
	m_play1.AutoLoad(IDC_BUTTON_PLAY1, this);

	m_playall.AutoLoad(IDC_BUTTON_PLAYALL, this);



	CPropertyPage::OnInitDialog();

	m_chordname.LimitText(11);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

int CChordScalePropPage::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}

void CChordScalePropPage::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}
	UnRegisterMidi();

	CPropertyPage::OnDestroy();	
}


void CChordScalePropPage::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	// TODO: Add your message handler code here and/or call default
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
/*
	CButton* pButton = GetButton(nIDCtl);
	if(pButton)
	{
		lpDrawItemStruct->itemState = pButton->GetChecked() ? ODS_SELECTED : ODS_DEFAULT;
	}
*/		
	CPropertyPage::OnDrawItem(nIDCtl, lpDrawItemStruct);	
}

void CChordScalePropPage::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct) 
{
	// TODO: Add your message handler code here and/or call default
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CPropertyPage::OnMeasureItem(nIDCtl, lpMeasureItemStruct);
}

void CChordScalePropPage::OnButtonMidichord1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord1);
}

void CChordScalePropPage::OnButtonMidichord2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord2);
}

void CChordScalePropPage::OnButtonMidichord3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord3);
}
void CChordScalePropPage::OnButtonMidichord4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord4);	
}

void CChordScalePropPage::OnButtonMidiroot() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Root);
}

void CChordScalePropPage::OnButtonMidiscale1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale1);
}

void CChordScalePropPage::OnButtonMidiscale2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale2);
}

void CChordScalePropPage::OnButtonMidiscale3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale3);
}

void CChordScalePropPage::OnButtonMidiscale4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale4);
}

void CChordScalePropPage::OnButtonPlay1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(0);
}

void CChordScalePropPage::OnButtonPlay2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(1);	
}

void CChordScalePropPage::OnButtonPlay3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(2);
}

void CChordScalePropPage::OnButtonPlay4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(3);
}

void CChordScalePropPage::OnButtonPlayall() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayAllChords();
}

void CChordScalePropPage::OnChangeEditName() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	char szName[30];
	GetDlgItemText(IDC_EDIT_NAME,szName,sizeof(szName));
	if (strcmp("",szName) && (strcmp(m_Chord.Name(),szName)))
	{
		strncpy(m_Chord.Name(),szName, DMPolyChord::MAX_NAME);
		m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_NAME;
		UpdateChordData();
	}

	
}

void CChordScalePropPage::DispatchKeyboardChange(CKeyboard* pKeyboard, short nKey)
{
	int i;
	if( (i = GetChordKeyboardIndex(pKeyboard))  >= 0 )
	{
		// send both CKeyboard* and index to save loakup
		OnNoteDownChordKeys(pKeyboard, i, nKey);
	}
	else if( (i = GetScaleKeyboardIndex(pKeyboard)) >= 0 )
	{
		// send both CKeyboard* and index to save loakup
		OnNoteDownScaleKeys(pKeyboard, i, nKey);
	}
}

int CChordScalePropPage::GetChordKeyboardIndex(const CKeyboard* pKeyboard)
{
	int i = 0;
	for(i; i < MAX_POLY; i++)
	{
		if(GetChordKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= MAX_POLY ? -1 : i;
}

int CChordScalePropPage::GetScaleKeyboardIndex(const CKeyboard* pKeyboard)
{
	int i = 0;
	for(i; i < MAX_POLY; i++)
	{
		if(GetScaleKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= MAX_POLY ? -1 : i;
}

void CChordScalePropPage::OnNoteDownChordKeys(CKeyboard* pKeyboard, int index, short nKey) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(0 <= index && index < MAX_POLY && pKeyboard);

	if(nKey < 0)
	{
		return;	// root too low
	}

	if (m_Chord.GetUndetermined(index) & UD_CHORDPATTERN)
	{
		m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
		for (short iKey = 0; iKey < 24; iKey++)
		{
			pKeyboard->SetNoteState(iKey,"",static_cast<short>((1 && ((m_Chord.SubChord(index)->ChordPattern() >> iKey) & 1)) << 1));
		}
	}
	else
	{
		bool rootHasChanged = false;
		short root = static_cast<short>(m_Chord.SubChord(index)->ChordRoot());
		if(nKey < root)
		{
			// root is lower, but we want to keep same chord members so shift up
			// but first make sure that we're not increasing span of chord > 2 octaves
			DWORD shift = root - nKey;
			DWORD pattern = 0xFFFFFFFF << (23 - shift);
			bool bTooHigh = m_Chord.SubChord(index)->ChordPattern() != 0 // an empty chord can never be too high
								&& (HighestBit(m_Chord.SubChord(index)->ChordPattern()) + root  - nKey) >= 24;

			if(root - nKey > 23)
			{
				WarnUser();
			}

			else if(!bTooHigh || (pattern & m_Chord.SubChord(index)->ChordPattern()) == 0)
			{
				// new root
				m_Chord.SubChord(index)->ChordRoot() = static_cast<unsigned char>(nKey);
				rootHasChanged = true;
				m_Chord.SubChord(index)->ChordPattern() <<= shift;
				// make sure anything higher than two octaves of pattern is cutoff.
				m_Chord.SubChord(index)->ChordPattern() &= 0x00ffffff;
				// add member for root note
				m_Chord.SubChord(index)->ChordPattern() |= 0x1;
				m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
			}
			else if(pKeyboard->GetNoteState(static_cast<short>(nKey)) == 2)
			{
				// allow user to turn off bit patterns >= 24 semitones from root
				pKeyboard->SetNoteState(static_cast<short>(nKey), "", 0);
			}
			else
			{
				WarnUser();
			}
		}
		else if(m_Chord.SubChord(index)->ChordPattern() == 0)
		{
			// this is the first note of chord hence it is the root.
			rootHasChanged = true;
			m_Chord.SubChord(index)->ChordRoot() = static_cast<BYTE>(nKey);

			m_Chord.SubChord(index)->ChordPattern() = 1;
			m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
		}
		else if(nKey == root)
		{
			// root must be set so clear it
			pKeyboard->SetNoteState(static_cast<short>(nKey-pKeyboard->Transpose()),"",0);
			// new root
			rootHasChanged = true;
			// third of chord is now root
			root = static_cast<short>(m_Chord.SubChord(index)->Third(0));
			if(root < 0)
			{
				// no chord, set root to lowest note
				root = 0;
				m_Chord.SubChord(index)->ChordRoot() = static_cast<unsigned char>(root);
				m_Chord.SubChord(index)->ChordPattern() = 0;
			}
			else
			{
				m_Chord.SubChord(index)->ChordRoot() = static_cast<BYTE>(root + nKey);
				// shift chord to "root" position, this also gets rid of old root note
				m_Chord.SubChord(index)->ChordPattern() >>= root;
			}
			m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
		}
		else
		{
			//  just update chord
			// if further away from root than 24 semitones, don't allow it
			// TODO: warn user
			DWORD shift = nKey - m_Chord.SubChord(index)->ChordRoot();
			if(shift < 24)
			{
				shift = 1 << shift;
				m_Chord.SubChord(index)->ChordPattern() ^= shift;
				m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
				short state = static_cast<short>(m_Chord.SubChord(index)->ChordPattern() & shift ? 2 : 0);
				pKeyboard->SetNoteState(static_cast<short>(nKey),"", state);
			}
			else if(pKeyboard->GetNoteState(static_cast<short>(nKey)) == 2)
			{
				// allow user to turn off bit patterns >= 24 semitones from root
				pKeyboard->SetNoteState(static_cast<short>(nKey), "", 0);
			}
			else
			{
				WarnUser();
			}
		}


		if(rootHasChanged)
		{
			// need to redraw chord and scale keyboards
			int root = m_Chord.SubChord(index)->ChordRoot();
			for (int nX = root; nX < root + 24; nX++)
			{
				if(nX >= 48)
					break;
				short nState;
				if (m_Chord.GetUndetermined(m_Chord.RootIndex()) & UD_CHORDPATTERN) 
					nState = 4;
				else 
					nState = 0;
				if ((m_Chord.SubChord(index)->ChordPattern() >> (nX-root)) & 1) 
					nState += 2;
				pKeyboard->SetNoteState(static_cast<short>(nX),"",nState);

			}
			DrawScale(&m_Chord, index);
			if(index == m_Chord.RootIndex())
			{
				OnChangeRoot( false );	
			}
		}
		else
		{
			short	scaleKey = static_cast<short>(nKey % 12);
			DrawScale(&m_Chord, index, scaleKey);
		}
	}


	if( m_fSyncLevelOneToAll
	&&  index == 0 )
	{
		for( int i = 0; i < MAX_POLY; i++ )
		{
			if( i != index )
			{
				m_Chord.SubChord(i)->ChordPattern() = m_Chord.SubChord(index)->ChordPattern();
				m_Chord.SubChord(i)->ChordRoot() = m_Chord.SubChord(index)->ChordRoot();
				m_Chord.Undetermined(i) &= ~UD_CHORDPATTERN;
			}
		}
		SetChord(&m_Chord);
	}
	UpdateChordData();
}



void CChordScalePropPage::OnNoteDownScaleKeys(CKeyboard* pKeyboard, int index, short nKey) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT(0 <= index && index < MAX_POLY && pKeyboard);

//	nKey = nKey - pKeyboard->Transpose();
	if(nKey < 0)
		nKey += 12;
	if(nKey > 23)
		nKey -= 12;
	short nOtherKey = static_cast<short>((nKey + 12) % 24);

	if (m_Chord.Undetermined(index) & UD_SCALEPATTERN)
	{
		m_Chord.Undetermined(index) &= ~UD_SCALEPATTERN;
		DrawScale(&m_Chord, index);
	}
	else
	{
		DWORD dwScalePattern = m_Chord.SubChord(index)->ScalePattern();
		DWORD dwScaleRoot = m_Chord.SubChord(index)->ScaleRoot() % 12;
		dwScalePattern = Rotate24(dwScalePattern, dwScaleRoot);
		dwScalePattern ^= (1 << nKey);
		dwScalePattern ^= (1 << nOtherKey);
		dwScalePattern = Rotate24(dwScalePattern, 12-dwScaleRoot);
		m_Chord.SubChord(index)->ScalePattern() = dwScalePattern;
		DrawScale(&m_Chord, index);
	}

	if( m_fSyncLevelOneToAll
	&&  index == 0 )
	{
		for( int i = 0; i < MAX_POLY; i++ )
		{
			if( i != index )
			{
				m_Chord.SubChord(i)->ScalePattern() = m_Chord.SubChord(index)->ScalePattern();
				m_Chord.Undetermined(i) &= ~UD_SCALEPATTERN;
			}
		}
		SetChord(&m_Chord);
	}
	UpdateChordData();
}

void CChordScalePropPage::DrawScale(CPropChord* pChord, int index, int note)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	short nGrayed;
	if (pChord->GetUndetermined(index) & UD_SCALEPATTERN) nGrayed = 4;
	else nGrayed = 0;

	// match bits
	DWORD dwScale = pChord->SubChord(index)->ScalePattern();
	DWORD dwChord = pChord->SubChord(index)->ChordPattern();
	DWORD dwBlueBits = BlueBits(dwChord, pChord->SubChord(index)->ChordRoot(),
													dwScale, pChord->SubChord(index)->ScaleRoot()
													);

	// draw scale
	int lower = (note == -1) ? 0 : note;
	int upper = (note == -1) ? 12 : note + 1;
	for(int i = lower; i < upper; i++)
	{
		short nState = nGrayed;
		if(dwScale & (1 << i))
		{
			nState = 2;
		}
		else if(dwBlueBits & (1 << i))
		{
			nState = 1;
		}
		GetScaleKeyboard(index)->SetNoteState(static_cast<short>(i),"",nState);
	}
}

void CChordScalePropPage::UpdateChordData(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject)
	{
		CChordScalePropPageData chordscalePropPageData;

		chordscalePropPageData.m_pPropChord = &m_Chord;
		chordscalePropPageData.m_fLockAllScales = m_fLockAllScales;
		chordscalePropPageData.m_fSyncLevelOneToAll = m_fSyncLevelOneToAll;

		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &chordscalePropPageData);
	}	
}

void CChordScalePropPage::SetChordData(CChordScalePropPageData* pChordScalePropPageData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pChordScalePropPageData != NULL );
	if( pChordScalePropPageData )
	{
		SetChord( pChordScalePropPageData->m_pPropChord );

		m_fLockAllScales = pChordScalePropPageData->m_fLockAllScales;
		m_fSyncLevelOneToAll = pChordScalePropPageData->m_fSyncLevelOneToAll;
	}
}

void CChordScalePropPage::SetChord(CPropChord * pChord)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	char str[30];
	
	m_Chord = *pChord;

	if( IsWindow( m_hWnd ) == 0 ) return;

	if(::IsWindow(m_midiscale4.m_hWnd))
	{

		if(m_Chord.RootIndex() == DMPolyChord::INVALID)
		{
			EnableControls(FALSE);
		}
		else
		{
			EnableControls(TRUE);
		}
	}

	if(pChord->RootIndex() >= DMPolyChord::MAX_POLY) 
		return;	// invalid chord, controls will be blanked out


	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_NAME)
	{
		SetDlgItemText(IDC_EDIT_NAME,"");
	}
	else
	{
		SetDlgItemText(IDC_EDIT_NAME,pChord->Name());
	}

	if(pChord->GetUndetermined(pChord->RootIndex()) & UD_FROMCHORDPALETTE)
	{
		m_spinRoot.EnableWindow(FALSE);
	}
	else
	{
		m_spinRoot.EnableWindow(TRUE);
	}

	pChord->RootToString(str, pChord->RootIndex());
	SetDlgItemText(IDC_EDIT_ROOT,str);
	SetCheckBox(pChord, UD_FLAT, IDC_USEFLATS, pChord->Base()->UseFlat() && 1);
	SetCheckBox(pChord, UD_FLAT, IDC_USESHARPS, !(pChord->Base()->UseFlat() && 1));
	short nGrayed;
	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_CHORDPATTERN) nGrayed = 4;
	else nGrayed = 0;
	int nX;
	for(int n = 0; n < CPropChord::MAX_POLY; n++)
	{
		GetChordKeyboard(n)->ClearKeys();
		GetScaleKeyboard(n)->ClearKeys();

		int root = static_cast<int>(pChord->SubChord(n)->ChordRoot());
		for (nX = root; nX < root+24; nX++)
		{
			if(nX >= 48)
				break;
			short nState = nGrayed;
			if ((pChord->SubChord(n)->ChordPattern() >> (nX-root)) & 1) nState += 2;
			GetChordKeyboard(n)->SetNoteState(static_cast<short>(nX),"",nState);
		}
		DrawScale(pChord, n);
	}
}

void CChordScalePropPage::SetCheckBox(CPropChord * pChord, DWORD dwUDFlag, UINT nDlgID, UINT nState)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if (pChord->GetUndetermined(pChord->RootIndex()) & dwUDFlag)
	{
		CButton *pButton = (CButton *) GetDlgItem(nDlgID);
		if (pButton)
		{
//			pButton->SetButtonStyle(BS_AUTO3STATE);
			pButton->SetCheck(0);		
		}
	}
	else
	{
		CButton *pButton = (CButton *) GetDlgItem(nDlgID);
		if (pButton)
		{
//			pButton->SetButtonStyle(BS_AUTOCHECKBOX);
			pButton->SetCheck(nState);
		}
	}

}

BOOL CChordScalePropPage::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RegisterMidi();
	
	return CPropertyPage::OnSetActive();
}


void CChordScalePropPage::OnKillFocus(CWnd* pNewWnd) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CPropertyPage::OnKillFocus(pNewWnd);
	
	// TODO: Add your message handler code here
	
}


void CChordScalePropPage::OnChangeRoot( bool fUpdateChordData ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	char str[30];
	DMChord* pSub = m_Chord.SubChord(m_Chord.RootIndex());
	while(pSub->ChordRoot() > 23)
	{
		pSub->ChordRoot() -= 12;
		AfxMessageBox(IDS_ILLEGALCHORD);
		SetChord(&m_Chord);
	}
	m_Chord.RootToString(str, m_Chord.RootIndex());
	SetDlgItemText(IDC_EDIT_ROOT, str);
	m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_CHORDROOT;
	DrawScale(&m_Chord, m_Chord.RootIndex());

	if( fUpdateChordData )
	{
		UpdateChordData();
	}
}

void CChordScalePropPage::OnUseflats() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	for(int i = 0; i < CPropChord::MAX_POLY; i++)
	{
		m_Chord.Undetermined(i) &= ~UD_FLAT;
		m_Chord.SubChord(i)->UseFlat() = 1;
	}
	OnChangeRoot( true );
	UpdateChordData();
}

void CChordScalePropPage::OnUsesharps() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	for(int i = 0; i < CPropChord::MAX_POLY; i++)
	{
		m_Chord.Undetermined(i) &= ~UD_FLAT;
		m_Chord.SubChord(i)->UseFlat() = 0;
	}
	OnChangeRoot( true );
	UpdateChordData();
}

void CChordScalePropPage::SetMidiIn(int keyboard)
{
	if(m_fMidiInputTarget == keyboard)
	{
			CButton* pButton = (CButton*)GetDlgItem(m_MidiInIds[m_fMidiInputTarget]);
			pButton->SetState(FALSE);
			m_fMidiInputTarget  = None;
			UnRegisterMidi();
			return;
	}

	if(m_fMidiInputTarget != None)
	{
			CButton* pButton = (CButton*)GetDlgItem(m_MidiInIds[m_fMidiInputTarget]);
			pButton->SetState(FALSE);
	}
	
	m_fMidiInputTarget = keyboard;
	CButton* pButton = (CButton*)GetDlgItem(m_MidiInIds[m_fMidiInputTarget]);
	pButton->SetState(TRUE);
	RegisterMidi();
}

CButton* CChordScalePropPage::GetButton(int id)
{
	CButton* pButton = 0;
	switch(id)
	{
	case IDC_BUTTON_MIDICHORD1:
		pButton = dynamic_cast<CButton*>(&m_midichord1);
		break;
	case IDC_BUTTON_MIDICHORD2:
		pButton = dynamic_cast<CButton*>(&m_midichord2);
		break;
	case IDC_BUTTON_MIDICHORD3:
		pButton = dynamic_cast<CButton*>(&m_midichord3);
		break;
	case IDC_BUTTON_MIDICHORD4:
		pButton = dynamic_cast<CButton*>(&m_midichord4);
		break;
	case IDC_BUTTON_MIDISCALE1:
		pButton = dynamic_cast<CButton*>(&m_midiscale1);
		break;
	case IDC_BUTTON_MIDISCALE2:
		pButton = dynamic_cast<CButton*>(&m_midiscale3);
		break;
	case IDC_BUTTON_MIDISCALE3:
		pButton = dynamic_cast<CButton*>(&m_midiscale3);
		break;
	case IDC_BUTTON_MIDISCALE4:
		pButton = dynamic_cast<CButton*>(&m_midiscale4);
		break;
	}
	return pButton;
}

void CChordScalePropPage::PlaySubChord(int index)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	short nX;
	DWORD dwTime = 0;

	ChangePatch(0,0,0,0);

	for (nX = 0; nX < 24; nX++)
	{
		if ((m_Chord.SubChord(index)->ChordPattern() >> nX) & 1)
		{
			 unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX + m_Chord.SubChord(index)->ChordRoot());
			PlayNote(0, note, 120, dwTime, CHORDNOTE_DUR); 
			dwTime += CHORDNOTE_DUR;
		}
	}
	dwTime += CHORDNOTE_DELAY;
	for (nX = 0; nX < 25; nX++)
	{
		if ((m_Chord.SubChord(index)->ScalePattern() >> nX) & 1)
		{
			unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX+ m_Chord.SubChord(index)->ScaleRoot());
			PlayNote(0, note, 120, dwTime, SCALENOTE_DUR); 
			dwTime += SCALENOTE_DUR;
		}
	}
}

void CChordScalePropPage::PlayAllChords()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	short nX;
	DWORD dwTime = 0;

	ChangePatch(0,0,0,0);

	for(int index = 0; index < MAX_POLY; index++)
	{
		for (nX = 0; nX < 24; nX++)
		{
			if ((m_Chord.SubChord(index)->ChordPattern() >> nX) & 1)
			{
				 unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX + m_Chord.SubChord(index)->ChordRoot());
				PlayNote(0, note, 120, dwTime, CHORDNOTE_DUR);
				dwTime += CHORDNOTE_DUR;
			}
		}
		dwTime += CHORDNOTE_DUR*2;
	}
}

void CChordScalePropPage::OnDeltaposSpinRoot(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	// check that root positions of subchords is in range
	for(int j = 0; j < DMPolyChord::MAX_POLY; j++)
	{
		short chordRoot = static_cast<short>(m_Chord.SubChord(j)->ChordRoot() - pNMUpDown->iDelta);
		DWORD pattern = m_Chord.SubChord(j)->ChordPattern();

		// skip empty patterns
		if(!pattern)
		{
			continue;
		}

		if(chordRoot < 0)
		{
			return;	// out of range
		}

		// check if highest note is in range
		short highestNote = 0;
		for(int k = 0; k < sizeof(DWORD)*8; k++)
		{
			if(pattern & (1 << k))
			{
				highestNote = k;
			}
		}
		if(highestNote + chordRoot >= 48)
		{
			return;	// out of range
		}
	}

	for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
	{
		short chordRoot = static_cast<short>(m_Chord.SubChord(i)->ChordRoot() - pNMUpDown->iDelta);
		bool changeScale = true;
		if (chordRoot < 0 || m_Chord.SubChord(i)->ChordPattern() == 0) 
		{
			chordRoot = 0;
			changeScale = false;
		}
		m_Chord.SubChord(i)->ChordRoot() = (BYTE) chordRoot;

		if( changeScale )
		{
			if( m_fLockAllScales == FALSE )
			{
				m_Chord.SubChord(i)->ScalePattern() = Rotate24(m_Chord.SubChord(i)->ScalePattern(), -pNMUpDown->iDelta);
			}
		}
	}

	char str[10];
	m_Chord.RootToString(str, m_Chord.RootIndex());
	SetDlgItemText(IDC_EDIT_ROOT, str);
	m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_CHORDROOT;

	SetChord(&m_Chord);
	OnChangeRoot( true );

	*pResult = 0;
}

HRESULT CChordScalePropPage::PlayNote(BYTE ch, BYTE key, BYTE vel, DWORD startTime, DWORD dur)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;

	// make sure we have a performance
	if(m_pIPerformance == 0)
	{
		hr = m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIPerformance);
		if(FAILED(hr))
		{
			return hr;
		}
	}

	// Allocate and initialize a PMsg
	DMUS_MIDI_PMSG* pMidi = NULL;
	hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMidi);
	if(FAILED(hr))
	{
		return hr;
	}
	memset(pMidi, 0, sizeof(DMUS_MIDI_PMSG));

	// fill in midi note on
	pMidi->bStatus = static_cast<BYTE>(0x90 + (ch&0xf));	// note on
	pMidi->bByte1 = key;
	pMidi->bByte2 = vel;

	REFERENCE_TIME	rtNow;
	m_pIPerformance->GetLatencyTime(&rtNow);
	pMidi->rtTime = startTime * 10000 + rtNow;
	pMidi->dwFlags = DMUS_PMSGF_REFTIME;
	pMidi->dwPChannel = (ch&0xf);
	pMidi->dwVirtualTrackID = 1;
	pMidi->dwType = DMUS_PMSGT_MIDI;

	hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pMidi));

	if(SUCCEEDED(hr))
	{
		// Allocate and initialize a PMsg
		DMUS_MIDI_PMSG* pMidi = NULL;
		hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMidi);
		if(FAILED(hr))
		{
			return hr;
		}
		memset(pMidi, 0, sizeof(DMUS_MIDI_PMSG));
		// fill in midi note off
		pMidi->bStatus = static_cast<BYTE>(0x80 + (ch&0xf));	// note on
		pMidi->bByte1 = key;
		pMidi->bByte2 = vel;

		pMidi->rtTime = (startTime + dur)* 10000 + rtNow;
		pMidi->dwFlags = DMUS_PMSGF_REFTIME;
		pMidi->dwPChannel = (ch&0xf);
		pMidi->dwVirtualTrackID = 1;
		pMidi->dwType = DMUS_PMSGT_MIDI;

		hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pMidi));
	}
	
	return hr;
}

HRESULT CChordScalePropPage::ChangePatch(BYTE ch, BYTE inst, BYTE msb, BYTE lsb)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;

	// make sure we have a performance
	if(m_pIPerformance == 0)
	{
		hr = m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIPerformance);
		if(FAILED(hr))
		{
			return hr;
		}
	}

	// Allocate and initialize a PMsg
	DMUS_PATCH_PMSG* pPatch = NULL;
	hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_PATCH_PMSG), (DMUS_PMSG**)&pPatch);
	if(FAILED(hr))
	{
		return hr;
	}
	memset(pPatch, 0, sizeof(DMUS_PATCH_PMSG));

	// fill in patch
	REFERENCE_TIME	rtNow;
	m_pIPerformance->GetLatencyTime(&rtNow);
	pPatch->byInstrument = inst;
	pPatch->byMSB = msb;
	pPatch->byLSB = lsb;

	pPatch->rtTime = rtNow;
	pPatch->dwFlags = DMUS_PMSGF_REFTIME;
	pPatch->dwPChannel = (ch&0xf);
	pPatch->dwVirtualTrackID = 1;
	pPatch->dwType = DMUS_PMSGT_PATCH;


	hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pPatch));

	return hr;
}

BOOL CChordScalePropPage::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	int to, from, whatop;
	bool bModified = false;

	ComputeCopyOp((WORD)wParam, from, to, whatop);

	if(whatop > Nop)
	{
		switch(whatop)
		{
		case CopyChord:
			TRACE("CopyChord from %d to %d\n", from+1, to+1);
			if(to != All)
			{
				if(to == m_Chord.RootIndex() && m_Chord[from]->ChordRoot() > 23)
				{
					// need to make sure root is legal
					AfxMessageBox(IDS_ILLEGALCHORD3);
					break;
				}
				m_Chord[to]->ChordPattern() = m_Chord[from]->ChordPattern();
				m_Chord[to]->ChordRoot() = m_Chord[from]->ChordRoot();
			}
			else
			{
				for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
				{
					if(i == from)
						continue;
					if(i == m_Chord.RootIndex() && m_Chord[from]->ChordRoot() > 23)
					{
						// need to make sure root is legal
						AfxMessageBox(IDS_ILLEGALCHORD3);
						continue;
					}
					m_Chord[i]->ChordPattern() = m_Chord[from]->ChordPattern();
					m_Chord[i]->ChordRoot() = m_Chord[from]->ChordRoot();
				}
			}
			bModified = true;
			break;
		
		case CopyScale:
			TRACE("CopyScale from %d to %d\n", from+1, to+1);
			if(to != All)
			{
				m_Chord[to]->ScalePattern() = m_Chord[from]->ScalePattern();
				m_Chord[to]->ScaleRoot() = m_Chord[from]->ScaleRoot();
			}
			else
			{
				for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
				{
					if(i == from)
						continue;
					m_Chord[i]->ScalePattern() = m_Chord[from]->ScalePattern();
					m_Chord[i]->ScaleRoot() = m_Chord[from]->ScaleRoot();
				}
			}
			bModified = true;
			break;

		case CopyChordScale:
			TRACE("CopyChordScale from %d to %d\n", from+1, to+1);
			if(to != All)
			{
				if(to == m_Chord.RootIndex() && m_Chord[from]->ChordRoot() > 23)
				{
					// need to make sure root is legal
					AfxMessageBox(IDS_ILLEGALCHORD);
					break;
				}
				m_Chord[to]->ChordPattern() = m_Chord[from]->ChordPattern();
				m_Chord[to]->ChordRoot() = m_Chord[from]->ChordRoot();
				m_Chord[to]->ScalePattern() = m_Chord[from]->ScalePattern();
				m_Chord[to]->ScaleRoot() = m_Chord[from]->ScaleRoot();
			}
			else
			{
				for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
				{
					if(i == from)
						continue;
					if(i == m_Chord.RootIndex() && m_Chord[from]->ChordRoot() > 23)
					{
						// need to make sure root is legal
						AfxMessageBox(IDS_ILLEGALCHORD3);
						continue;
					}
					m_Chord[i]->ChordPattern() = m_Chord[from]->ChordPattern();
					m_Chord[i]->ChordRoot() = m_Chord[from]->ChordRoot();
					m_Chord[i]->ScalePattern() = m_Chord[from]->ScalePattern();
					m_Chord[i]->ScaleRoot() = m_Chord[from]->ScaleRoot();
				}
			}
			bModified = true;
			break;
		
		case ClearChordScale:
			TRACE("ClearChordScale from %d to %d\n", from+1, to+1);
			if(to != All)
			{
				m_Chord[to]->ChordPattern() = 0;
				m_Chord[to]->ChordRoot() = 0;
				m_Chord[to]->ScalePattern() = 0;
				m_Chord[to]->ScaleRoot() = 0;
			}
			else
			{
				for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
				{
					m_Chord[i]->ChordPattern() = 0;
					m_Chord[i]->ChordRoot() = 0;
					m_Chord[i]->ScalePattern() = 0;
					m_Chord[i]->ScaleRoot() = 0;
				}
			}
			bModified = true;
			break;
		
		default:
			TRACE("No operation\n");
			break;
		}
	}
	else
	{
		// additional commands go here
		switch( wParam )
		{
			case IDM_LOCK_ALL_SCALES:
				m_fLockAllScales = m_fLockAllScales ? FALSE : TRUE;
				bModified = true;
				break;
			
			case IDM_SYNC_ALL_LEVELS:
				m_fSyncLevelOneToAll = m_fSyncLevelOneToAll ? FALSE : TRUE;
				bModified = true;
				break;
		}
	}

	if(bModified)
	{
		SetChord(&m_Chord);
		UpdateChordData();
	}

	return CPropertyPage::OnCommand(wParam, lParam);
}

void CChordScalePropPage::DispatchRightMouseKeyboard(CKeyboard * pKeyboard, short nKey, CPoint& ptMouse)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(nKey);
	int i;
	if( (i = GetChordKeyboardIndex(pKeyboard))  >= 0 )
	{
		TRACE("Right click on chord keyboard %d\n", i);
	}
	else if( (i = GetScaleKeyboardIndex(pKeyboard)) >= 0 )
	{
		TRACE("Right click on scale keyboard %d\n", i);
	}

	m_nLastKeyboardLevel = i;	// save keyboard that sent right click

	CMenu cMenu;
	if( cMenu.LoadMenu( MAKEINTRESOURCE(IDR_CHORDPROP) ) != 0 )
	{
		CMenu* pSubMenu = cMenu.GetSubMenu(0);
		if( pSubMenu )
		{
			pSubMenu->CheckMenuItem( IDM_LOCK_ALL_SCALES, (m_fLockAllScales ? MF_CHECKED : MF_UNCHECKED) );
			pSubMenu->CheckMenuItem( IDM_SYNC_ALL_LEVELS, (m_fSyncLevelOneToAll ? MF_CHECKED : MF_UNCHECKED) );

			for( int j = 3; j < 6; j++ )
			{
				CMenu* pSubSubMenu = pSubMenu->GetSubMenu( j );
				if( pSubSubMenu )
				{
					for( int k = 0; k < 4; k++ )
					{
						if( m_nLastKeyboardLevel == -1
						||  m_nLastKeyboardLevel == (3 - k) )
						{
							pSubSubMenu->EnableMenuItem( k, MF_BYPOSITION | MF_GRAYED );
						}
						else
						{
							pSubSubMenu->EnableMenuItem( k, MF_BYPOSITION | MF_ENABLED );
						}
					}
				}
			}

			pKeyboard->ClientToScreen( &ptMouse );

			MSG	msg;
			if( pSubMenu->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON, (int)(ptMouse.x), (int)(ptMouse.y),
										  this ) != 0 )
			{
				::PeekMessage( &msg, pKeyboard->GetSafeHwnd(), 0, 0, PM_REMOVE ); // Remove the last mouse click msg from the queue.
			}
		}
	}
}



void CChordScalePropPage::ComputeCopyOp(WORD menuid, int & from, int & to, int & what)
{
	from = m_nLastKeyboardLevel;
	if(from == -1)
		return;		// not from a menu
	switch(menuid)
	{
	case ID_COPY_CHORD1:
		what = CopyChord;
		to = 0;
		break;
	case ID_COPY_CHORD2:
		what = CopyChord;
		to = 1;
		break;
	case ID_COPY_CHORD3:
		what = CopyChord;
		to = 2;
		break;
	case ID_COPY_CHORD4:
		what = CopyChord;
		to = 3;
		break;
	case ID_COPY_CHORDALL:
		what = CopyChord;
		to = All;
		break;

	case ID_COPY_SCALE1:
		what = CopyScale;
		to = 0;
		break;
	case ID_COPY_SCALE2:
		what = CopyScale;
		to = 1;
		break;
	case ID_COPY_SCALE3:
		what = CopyScale;
		to = 2;
		break;
	case ID_COPY_SCALE4:
		what = CopyScale;
		to = 3;
		break;
	case ID_COPY_SCALEALL:
		what = CopyScale;
		to = All;
		break;

	case ID_COPY_CHORDSCALE1:
		what = CopyChordScale;
		to = 0;
		break;
	case ID_COPY_CHORDSCALE2:
		what = CopyChordScale;
		to = 1;
		break;
	case ID_COPY_CHORDSCALE3:
		what = CopyChordScale;
		to = 2;
		break;
	case ID_COPY_CHORDSCALE4:
		what = CopyChordScale;
		to = 3;
		break;
	case ID_COPY_CHORDSCALEALL:
		what = CopyChordScale;
		to = All;
		break;

	case ID_CLEAR_CHORDSCALE1:
		what = ClearChordScale;
		to = 0;
		break;
	case ID_CLEAR_CHORDSCALE2:
		what = ClearChordScale;
		to = 1;
		break;
	case ID_CLEAR_CHORDSCALE3:
		what = ClearChordScale;
		to = 2;
		break;
	case ID_CLEAR_CHORDSCALE4:
		what = ClearChordScale;
		to = 3;
		break;
	case ID_CLEAR_CHORDSCALEALL:
		what = ClearChordScale;
		to = All;
		break;

	default:
		what = Nop;
		break;
	}
	m_nLastKeyboardLevel = -1;
}

void CChordScalePropPage::WarnUser()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if(!m_bNotWarn)
	{
		CIllegalChord dlg;
		dlg.m_bDontWarn = m_bNotWarn;
		dlg.DoModal();
		m_bNotWarn = dlg.m_bDontWarn;
	}

}

void CChordScalePropPage::EnableControls(BOOL bEnable)
{
	if( IsWindow( m_hWnd ) == 0  || !::IsWindow(m_midiscale4.m_hWnd)) return;

	if(!bEnable)
	{
		SetDlgItemText(IDC_EDIT_ROOT, "");
		m_chordname.SetWindowText("");
		for(int n = 0; n < CPropChord::MAX_POLY; n++)
		{
			GetChordKeyboard(n)->ClearKeys();
			GetScaleKeyboard(n)->ClearKeys();
			short nState = 4;
			short nX;
			for (nX = 0; nX < 48; nX++)
			{
				GetChordKeyboard(n)->SetNoteState(static_cast<short>(nX),"",nState);
			}
			for(nX = 0; nX < 12; nX++)
			{
				GetScaleKeyboard(n)->SetNoteState(static_cast<short>(nX),"",nState);
			}
		}
	}

	GetDlgItem(IDC_USEFLATS)->EnableWindow(bEnable);
	GetDlgItem(IDC_USESHARPS)->EnableWindow(bEnable);
	
	m_spinRoot.EnableWindow(bEnable);
	m_chordname.EnableWindow(bEnable);
	m_keysscale4.EnableWindow(bEnable);
	m_keysscale3.EnableWindow(bEnable);
	m_keysscale2.EnableWindow(bEnable);
	m_keysscale1.EnableWindow(bEnable);
	m_keyschord4.EnableWindow(bEnable);
	m_keyschord3.EnableWindow(bEnable);
	m_keyschord2.EnableWindow(bEnable);
	m_keyschord1.EnableWindow(bEnable);
	m_midichord4.EnableWindow(bEnable);
	m_midichord3.EnableWindow(bEnable);
	m_midichord2.EnableWindow(bEnable);
	m_midichord1.EnableWindow(bEnable);
	m_midiscale4.EnableWindow(bEnable);
	m_midiscale3.EnableWindow(bEnable);
	m_midiscale2.EnableWindow(bEnable);
	m_midiscale1.EnableWindow(bEnable);

	m_play1.EnableWindow(bEnable);
	m_play2.EnableWindow(bEnable);
	m_play3.EnableWindow(bEnable);
	m_play4.EnableWindow(bEnable);
	m_playall.EnableWindow(bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\chordmapriff.h ===
#ifndef PERSONALITYRIFF_H
#define PERSONALITYRIFF_H

#pragma warning(disable:4201)


#define MAKE_TIMESIG( bpm, beat ) ( (long)( ((DWORD)(WORD)beat) | ( ((DWORD)(WORD)bpm) << 16 ) ) )
#define TIMESIG_BEAT( tsig ) ( (short)tsig )
#define TIMESIG_BPM( tsig ) ( (WORD)( ((DWORD)tsig) >> 16 ) )

#define CHORD_KEYDOWN 0x8000/* chord is selected (used in upper bit of ioChordEntryEdit::page) */


// this should match enums in iochord.h
enum
{
//	CSF_KEYDOWN = 	1,	// key currently held down in sjam kybd
//	CSF_INSCALE = 	2,	// member of scale
//	CSF_FLAT =		4,	// display with flat
//	CSF_SIMPLE =	8,	// simple chord, display at top of sjam list
//	CSF_SELECTED = 0x80, // this chord is selected
//	CSF_SIGNPOST = 0x40, // this chord is from a signpost
	CSF_SHIFTED = 0x20	// this chord has been altered from an illegal chord
						// used to make chord unique so that Load subchord database code works correctly
						// (see use in ChordDatabase.cpp)
};


// runtime chunks
#define FOURCC_PERSONALITY	mmioFOURCC('D','M','P','R')
#define FOURCC_IOPERSONALITY		mmioFOURCC('p','e','r','h')
#define FOURCC_GUID					mmioFOURCC('g','u','i','d')
#define FOURCC_SUBCHORD				mmioFOURCC('c','h','d','t')
#define FOURCC_CHORDENTRY			mmioFOURCC('c','h','e','h')
#define FOURCC_SUBCHORDID			mmioFOURCC('s','b','c','n')
#define FOURCC_IONEXTCHORD			mmioFOURCC('n','c','r','d')
#define FOURCC_NEXTCHORDSEQ		  mmioFOURCC('n','c','s','q')
#define FOURCC_IOSIGNPOST			mmioFOURCC('s','p','s','h')
#define FOURCC_CHORDNAME			mmioFOURCC('I','N','A','M')
#define FOURCC_PERSONALITYSTRUCT	mmioFOURCC('p','s','t','r')

// runtime list chunks
#define FOURCC_LISTCHORDENTRY		mmioFOURCC('c','h','o','e')
#define FOURCC_LISTCHORDMAP			mmioFOURCC('c','m','a','p')
#define FOURCC_LISTCHORD			mmioFOURCC('c','h','r','d')
#define FOURCC_LISTCHORDPALETTE		mmioFOURCC('c','h','p','l')
#define FOURCC_LISTCADENCE			mmioFOURCC('c','a','d','e')
#define FOURCC_LISTSIGNPOSTITEM			mmioFOURCC('s','p','s','t')

#define FOURCC_SIGNPOSTLIST		mmioFOURCC('s','p','s','q')


// design time chunks
#define FOURCC_PERSONALITYKEY		 mmioFOURCC('p','k','e','y')
#define FOURCC_PERSONALITYEDIT		mmioFOURCC('p','e','d','t')
#define FOURCC_CHORDENTRYEDIT		mmioFOURCC('c','e','e','d')
#define FOURCC_CHORDEDIT				  mmioFOURCC('c','h','e','d')
#define DM_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DM_FOURCC_INFO_LIST	        mmioFOURCC('I','N','F','O')
#define DM_FOURCC_UNFO_LIST	        mmioFOURCC('U','N','F','O')
#define DM_FOURCC_CATEGORY_CHUNK    mmioFOURCC('c','a','t','g')
#define DM_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')

// constants
const int MaxSubChords = 4;

// simple riff read/writers
inline HRESULT ReadWord(IDMUSProdRIFFStream* pIRiffStream, WORD& val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Read(&val, sizeof(WORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

inline HRESULT ReadDword(IDMUSProdRIFFStream* pIRiffStream, DWORD& val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Read(&val, sizeof(DWORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

inline HRESULT WriteWord(IDMUSProdRIFFStream* pIRiffStream, WORD val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Write(&val, sizeof(WORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

inline HRESULT WriteDWord(IDMUSProdRIFFStream* pIRiffStream, DWORD val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Write(&val, sizeof(DWORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}


// chunk navigators
class WriteChunk
{
	MMCKINFO m_ck;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	WriteChunk(IDMUSProdRIFFStream* pRiffStream, FOURCC id)
	{
		m_ck.ckid = id;
		m_pRiffStream = pRiffStream;
		m_hr = pRiffStream->CreateChunk( &m_ck, 0 );
	}
	HRESULT	State(MMCKINFO* pck = 0)
	{
		if(pck)
		{
			memcpy(pck,  &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		return m_ck.ckid;
	}
	~WriteChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
};

class ReadChunk
{
	MMCKINFO m_ck;
	MMCKINFO* m_pckParent;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	ReadChunk(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent) : m_pRiffStream(pRiffStream)
	{
		m_pckParent = pckParent;
		m_hr = pRiffStream->Descend( &m_ck,  m_pckParent, 0 );
	}
	~ReadChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		if(m_ck.ckid == FOURCC_LIST)
		{
			return m_ck.fccType;
		}
		else
		{
			return m_ck.ckid;
		}
	}
};


// list navigators
class WriteListChunk
{
	MMCKINFO m_ck;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	WriteListChunk(IDMUSProdRIFFStream* pRiffStream, FOURCC id)
	{
		m_ck.fccType = id;
		m_pRiffStream = pRiffStream;
 		m_hr = pRiffStream->CreateChunk( &m_ck, MMIO_CREATELIST );
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		return m_ck.ckid;
	}
	~WriteListChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
};


// run time data structs
struct ioPersonality
{
	char	szLoadName[20];
	DWORD	dwScalePattern;
	DWORD	dwFlags;
	ioPersonality()
	{
		memset(this, 0, sizeof(ioPersonality));
	}
};

struct ioSubChord
{
	DWORD	dwChordPattern;
	DWORD	dwScalePattern;
	DWORD	dwInvertPattern;
	BYTE	bChordRoot;
	BYTE	bScaleRoot;
	WORD	wCFlags;
	DWORD	dwLevels;	// parts or which subchord levels this chord supports
	ioSubChord()
	{
		memset(this, 0, sizeof(ioSubChord));
	}
	ioSubChord(DMChord& chord)
	{
		dwChordPattern = chord.ChordPattern();
		dwScalePattern = chord.ScalePattern();
		dwInvertPattern = chord.InvertPattern();
		dwLevels = chord.Levels();
		wCFlags = chord.Flags();
		bChordRoot = chord.ChordRoot();
		bScaleRoot = chord.ScaleRoot();
	}
	void CopyToDMChord(DMChord& chord)
	{
		chord.ChordPattern() = dwChordPattern;
		chord.ScalePattern() = dwScalePattern;
		chord.InvertPattern() = dwInvertPattern;
		chord.Levels() = dwLevels;
		chord.Flags() = wCFlags;
		chord.ChordRoot() = bChordRoot;
		chord.ScaleRoot() = bScaleRoot;
	}
	BOOL operator==(const ioSubChord& sub)
	{
		return !(memcmp(this, &sub, sizeof(ioSubChord)));
	}
	operator unsigned long()
	{
		return dwChordPattern;
	}
};

struct ioChordEntry
{
	DWORD	dwFlags;
	WORD	wConnectionID;	// replaces runtime "pointer to this"
	ioChordEntry()
	{
		memset(this, 0, sizeof(ioChordEntry));
	}
};

struct ioNextChord
{
	DWORD	dwFlags;
	WORD	nWeight;
	WORD	wMinBeats;
	WORD	wMaxBeats;
	WORD	wConnectionID;	// points to an ioChordEntry
	ioNextChord()
	{
		memset(this, 0, sizeof(ioNextChord));
	}
};

struct ioSignPost
{
	DWORD	dwChords;	// 1bit per group
	DWORD	dwFlags;
	ioSignPost()
	{
		memset(this, 0, sizeof(ioSignPost));
	}
};


// design time data structs
struct ioPersonalityEdit
{
	WCHAR	wchUserName[20];
	WCHAR	wchDescription[80];
	BYTE		bVariableNotFixed; // variable or fixed grid chordmap
	WORD	wChordMapLength;
	BOOL	  fUseTimeSignature;
	LONG	lTimeSignature;
	BYTE		bKeySig;
	WORD	wSplitterYPos;
	WORD	wScrollHorPos;
	WORD	wScrollVertPos;
	BYTE		selection;
	WORD	wConnectionIdSelectedChord;
	// next two fields identify a selected connection
	WORD	wConnectionIdSelectedFromChord;
	WORD	wConnectionIdSelectedToChord;
	WORD	wSelectedSignpostRow;
	WORD	wSelectedSignpostCol;
	ioPersonalityEdit()
	{
		memset(this,0,sizeof(ioPersonalityEdit));
	}
};

struct ioChordEntryEdit
{
	BYTE	bBits[MaxSubChords];
	BYTE	 bUseFlat[MaxSubChords];
	WORD	wMeasure;
	BYTE	 bBeat;
	// mrect
	short		left;
	short		top;
	short		right;
	short		bottom;
    short		page;
	WORD	wConnectionId;	// maplet to ioChordEntry
	ioChordEntryEdit()
	{
		memset(this,0,sizeof(ioChordEntryEdit));
	}
};

struct DMChordEdit
{
	BYTE	bBits[MaxSubChords];
	BYTE	 bUseFlat[MaxSubChords];
	DMChordEdit()
	{
		memset(this,0,sizeof(DMChordEdit));
	}
	DMChordEdit(const DMPolyChord& chord)
	{
		for(int i = 0; i < MaxSubChords; i++)
		{
			DMChord* pchord = const_cast<DMPolyChord&>(chord).SubChord(i);
			bBits[i] = pchord->Bits();
			bUseFlat[i] = pchord->UseFlat();
		}
	}
	void Extract(const DMPolyChord& chord)
	{
		for(int i = 0; i < MaxSubChords; i++)
		{
			DMChord* pchord = const_cast<DMPolyChord&>(chord).SubChord(i);
			bBits[i] = pchord->Bits();
			bUseFlat[i] = pchord->UseFlat();
		}
	}
	void Insert(DMPolyChord& chord)
	{
		for(int i = 0; i < MaxSubChords; i++)
		{
			chord.SubChord(i)->Bits() = bBits[i];
			chord.SubChord(i)->UseFlat() = bUseFlat[i];
		}
	}
};

struct PersonalityStructure
{
	char	bVariableNotFixed;
	char	bKey;
	char	bUseTimeSignature;
	char	bReserved1;
	short  wChordMapLength;
	short	wReserved1;
	long	lTimeSig;
	PersonalityStructure()
	{
		bVariableNotFixed = FALSE;
		bKey = 0;
		bUseTimeSignature = TRUE;
		bReserved1 = 0;
		wChordMapLength = 20;
		wReserved1 = 0;
		lTimeSig = MAKE_TIMESIG(4,4) ;
	}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream)
	{
		IStream* pIStream;
		HRESULT hr;
		DWORD dwBytesWritten;
		// Write  header
		WriteChunk chunk(pRiffStream, FOURCC_PERSONALITYSTRUCT);
		hr = chunk.State();
		if(  hr  == 0 )
		{
			pIStream = pRiffStream->GetStream();
			ASSERT( pIStream != NULL );

			// Write Signpost chunk data
			hr = pIStream->Write( this, sizeof(PersonalityStructure), &dwBytesWritten) == 0
				&& dwBytesWritten == sizeof(PersonalityStructure) ? S_OK : E_FAIL;
			pIStream->Release();
		}
		return hr;
	}

	HRESULT Read(IDMUSProdRIFFStream* pIRiffStream)
	{
		ASSERT(pIRiffStream);
		HRESULT hr;
		DWORD dwBytesRead;
		IStream* pIStream = pIRiffStream->GetStream();
		ASSERT(pIStream != NULL);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}
		hr = pIStream->Read(this, sizeof(PersonalityStructure), &dwBytesRead) == 0
			&& dwBytesRead == sizeof(PersonalityStructure) ? S_OK : E_FAIL;
		pIStream->Release();
		return hr;
	}

};

struct ioPersonalityVersion
{
	enum {PersonalityVersionMS = 0x0001000, PersonalityVersionLS = 0x00000000};
	DWORD	m_dwVersionMS;
	DWORD	m_dwVersionLS;
	ioPersonalityVersion()
	{
		m_dwVersionMS = PersonalityVersionMS;
		m_dwVersionLS = PersonalityVersionLS;
	}
};


#ifdef XXXXTryAndCompileThisXXXX

RIFF
(
	'DMPR'
	<perh-ck>			// Personality header chunk
	<pstr-ck>			// personality structual info
	[<guid-ck>]			// guid chunk
	[<vers-ck>]			// version chunk (two DWORDS)
	<INFO-list>		  // standard MS Info chunk
	<chdt-ck>		   // subchord database
	<chpl-list>			// chord palette
	<cmap-list>		  // chord map
	<spst-list>			// signpost list
	[<ceed-ck>]		// optional chordmap position data
 )

 <chdt> ::= chdt(<cbChordSize::WORD>  <ioSubChord> ... )

<chpl-list> ::= LIST('chpl' 
								<chrd-list> ... // chord definition
							 )

<chrd-list> ::= LIST('chrd' 
								<INAM-ck> // name of chord in wide char format
								<sbcn-ck>	// list of subchords composing chord
								[<ched-ck>]   //  optional chord edit flags
								)

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
								<cheh-ck>	// chord entry data
								<chrd-list>	// chord definition
								<ncrd-ck>	// connecting(next) chords
								)

<spst-list> ::= LIST('spst'
							 <spsh-ck>
							 <chrd-list>
							 [<cade-list>]
							 )

<cade-list> ::= LIST('cade' <chrd-list> ...)
								
<sbcn-ck> ::= sbcn(<cSubChordID:WORD>)

<ceed-ck> ::= ceed(ioChordEntryEdit)

<ched-ck> ::= ched(DMChordEdit)

<cheh-ck> ::= cheh(i<ioChordEntry>)

<ncrd-ck> ::= ncrd(<ioNextChord>)

<spsh-ck> ::= spsh(<ioSignPost>)

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ConnectionPropPageMgr.h ===
// ConnectionPropPageMgr.h : Handles the property pages

#ifndef __CONNECTIONPROPPAGEMGR_H_
#define __CONNECTIONPROPPAGEMGR_H_

//#include "connectionproppage.h"
#include "staticproppagemanager.h"

struct ConnectionData
{
	short nWeight;
	short nMinBeats;
	short nMaxBeats;
	BOOL  fVariableNotFixed;
	ConnectionData() { nWeight = nMinBeats = nMaxBeats = 0; fVariableNotFixed = FALSE;}
};

class CConnectionPropPageMgr : CStaticPropPageManager
{
	friend class CConnectionPropPage;
public:
	HRESULT STDMETHODCALLTYPE UpdateObjectWithTabData();
	CConnectionPropPageMgr();
	~CConnectionPropPageMgr();
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
	CConnectionPropPage*		m_pPropPageConnection;
	IDMUSProdFramework*			m_pJazzFramework;
};

#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ContextMenuHandler.cpp ===
// ContextMenuHandler.cpp : implementation file
//

#include "stdafx.h"
#include "ChordMapStripMgr.h"
#include "ContextMenuHandler.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler

CContextMenuHandler::CContextMenuHandler()
{
	m_pStrip = NULL;
}

CContextMenuHandler::~CContextMenuHandler()
{
}


BEGIN_MESSAGE_MAP(CContextMenuHandler, CWnd)
	//{{AFX_MSG_MAP(CContextMenuHandler)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler message handlers

BOOL CContextMenuHandler::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	HRESULT hr = S_FALSE;

	if(m_pStrip != NULL)
	{
		hr = m_pStrip->OnWMMessage(WM_COMMAND, wParam, lParam, 0, 0);
	}
	
	if(hr == S_OK)
	{
		return TRUE;
	}

	return CWnd::OnCommand(wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\IllegalChord.cpp ===
// IllegalChord.cpp : implementation file
//
#include "stdafx.h"
#pragma warning(disable:4201)
#include "resource.h"
#include "chordmapstripmgr.h"
#include "IllegalChord.h"
#pragma warning(default:4201)


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CIllegalChord dialog


CIllegalChord::CIllegalChord(CWnd* pParent /*=NULL*/)
	: CDialog(CIllegalChord::IDD, pParent)
{
	//{{AFX_DATA_INIT(CIllegalChord)
	m_bDontWarn = FALSE;
	//}}AFX_DATA_INIT

}


void CIllegalChord::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIllegalChord)
	DDX_Control(pDX, IDC_ILLEGALCHORD, m_infotext);
	DDX_Check(pDX, IDC_DONTWARN, m_bDontWarn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CIllegalChord, CDialog)
	//{{AFX_MSG_MAP(CIllegalChord)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIllegalChord message handlers

BOOL CIllegalChord::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CString s1,s2;

	s1.LoadString(IDS_ILLEGALCHORD2);
	s2.LoadString(IDS_DONTWARN);

	m_infotext.SetWindowText(s1);
	
	SetDlgItemText(IDC_DONTWARN, s2);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\FileIO.h ===
#define CHORD_INVERT  0x10      /* This chord may be inverted           */
#define CHORD_FOUR    0x20      /* This should be a 4 note chord        */
#define CHORD_UPPER   0x40      /* Shift upper octave down              */
#define CHORD_SIMPLE  0x80      /* This is a simple chord               */
#define CHORD_COUNT   0x0F      /* Number of notes in chord (up to 15)  */

//////////////////////////////////////////
// ChordExt Structure
// Used to store a Section's single linked chord list.
// Use: CSection::m_paChordChanges.
typedef struct ChordExt				// Based on ChordSelection
{
    ChordExt		*pNext;
    long			time;
    long			pattern;		// Pattern that defines chord
    char			name[12];		// Text for display
    char			keydown;		// Currently held down
    char			root;			// Root note of chord
    char			inscale;		// Member of scale
    char			flat;			// Display with flat
    short			varflags;		// Used to select appropriate variation
    short			measure;		// What measure
    char			beat;			// What beat this falls on
    unsigned char	bits;			// Invert and item count
    long			scalepattern;	// Scale Pattern for the chord
    long			melodypattern;	// Melody Pattern for the chord
} ChordExt;

typedef struct ioChord
{
	long	lChordPattern;	// pattern that defines chord
	long	lScalePattern;	// scale pattern for the chord
	long	lInvertPattern;	// inversion pattern
    	BYTE    bRoot;		// root note of chord
	BYTE    bReserved;	// expansion room
	WORD    wCFlags;	// bit flags
	long	lReserved;	// expansion room
} ioChord;

typedef struct ioChordSelection
{
    wchar_t wstrName[16];   // text for display
    BYTE    fCSFlags;      // ChordSelection flags
    BYTE    bBeat;         // beat this falls on
    WORD    wMeasure;       // measure this falls on
    ioChord aChord[4];      // array of chords: levels
    BYTE    bClick;        // click this falls on
} ioChordSelection;

enum
{
	CSF_KEYDOWN = 	1,	// key currently held down in sjam kybd
	CSF_INSCALE = 	2,	// member of scale
	CSF_FLAT =		4,	// display with flat
	CSF_SIMPLE =	8,	// simple chord, display at top of sjam list
};

// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\DWList.cpp ===
//
// DWList.cpp
//

#include "stdafx.h"  

#include <stdarg.h>
#include <stddef.h>
#include <ctype.h>
#include "DWList.h"

LONG DWListItem::GetCount(void) const
{
    LONG l;
    const DWListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

DWListItem* DWListItem::Cat(DWListItem *pItem)
{
    DWListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

DWListItem* DWListItem::Remove(DWListItem *pItem)
{
    DWListItem *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

DWListItem* DWListItem::GetPrev(DWListItem *pItem) const
{
    const DWListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (DWListItem*)prev;
}

DWListItem * DWListItem::GetItem(LONG index)

{
	DWListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) index--;
	return (scan);
}

void DWList::InsertBefore(DWListItem *pItem,DWListItem *pInsert)

{
	DWListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\keysocx.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "keysocx.h"

/////////////////////////////////////////////////////////////////////////////
// CKeysOCX

IMPLEMENT_DYNCREATE(CKeysOCX, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CKeysOCX properties

/////////////////////////////////////////////////////////////////////////////
// CKeysOCX operations

void CKeysOCX::SetNoteState(short nKey, LPCTSTR pszName, short nState)
{
	static BYTE parms[] =
		VTS_I2 VTS_BSTR VTS_I2;
	InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 nKey, pszName, nState);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\IllegalChord.h ===
#if !defined(AFX_ILLEGALCHORD_H__9036C8B9_5315_11D2_BC79_00C04FA3726E__INCLUDED_)
#define AFX_ILLEGALCHORD_H__9036C8B9_5315_11D2_BC79_00C04FA3726E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// IllegalChord.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CIllegalChord dialog

class CIllegalChord : public CDialog
{
// Construction
public:
	CIllegalChord(CWnd* pParent = NULL);   // standard constructor


// Dialog Data
	//{{AFX_DATA(CIllegalChord)
	enum { IDD = IDD_ILLEGALCHORD };
	CStatic	m_infotext;
	BOOL	m_bDontWarn;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CIllegalChord)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CIllegalChord)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ILLEGALCHORD_H__9036C8B9_5315_11D2_BC79_00C04FA3726E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\DWList.h ===
//
// DWList.h
//
#ifndef __DWList_H__
#define __DWList_H__

//#pragma warning(disable: 4505)

class DWList;

class DWListItem
{
	friend DWList;
public:
    DWListItem() { m_pNext=NULL; };
    DWListItem *GetNext() const {return m_pNext;};
    void SetNext(DWListItem *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    DWListItem* Cat(DWListItem* pItem);
    DWListItem* AddTail(DWListItem* pItem) {return Cat(pItem);};
    DWListItem* Remove(DWListItem* pItem);
    DWListItem* GetPrev(DWListItem *pItem) const;
    DWListItem* GetItem(LONG index);

private:
    DWListItem *m_pNext;
};

class DWList
{
public:
    DWList() {m_pHead=NULL;};
    DWListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    LONG GetCount() const {return m_pHead->GetCount();}; 
    DWListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(DWListItem *pItem,DWListItem *pInsert);
    void Cat(DWListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(DWList *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(DWListItem *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(DWListItem *pItem) {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(DWListItem *pItem) {m_pHead=m_pHead->Remove(pItem);};
    DWListItem *GetPrev(DWListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    DWListItem *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    DWListItem *RemoveHead(void)
        {
            DWListItem *li;
            li=m_pHead;
            if(m_pHead)
                m_pHead=m_pHead->GetNext();
			if(li)
			{
				li->m_pNext = 0;
			}
            return li;
        }

protected:
    DWListItem *m_pHead;
};

class IndexList : public DWList 
{
public:
				IndexList() { 
					DWList();
					m_index = 0; 
				};
	DWListItem	*GetIndexedItem() { return(GetItem(m_index)); }
	void		SetIndex(LONG index)
				{
					m_index = index;
					if (GetCount() <= (LONG) index) m_index = 0;
				}
	DWListItem	*RemoveIndexedItem()
				{
					DWListItem *item = GetIndexedItem();
					if (item) Remove(item);
					return (item);
				}
	void		AddIndexedItem(DWListItem *item)
				{
					AddHead(item);
					m_index = 0;
				}

	LONG		m_index;
};

#endif // __DWList_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\ContextMenuHandler.h ===
#if !defined(AFX_CONTEXTMENUHANDLER_H__B49AF6C3_EE6A_11D0_BAD6_00805F493F43__INCLUDED_)
#define AFX_CONTEXTMENUHANDLER_H__B49AF6C3_EE6A_11D0_BAD6_00805F493F43__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ContextMenuHandler.h : header file
//

#include "timeline.h"

/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler window

class CContextMenuHandler : public CWnd
{
// Construction
public:
	CContextMenuHandler();

// Attributes
public:

	IDMUSProdStrip *m_pStrip;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CContextMenuHandler)
	protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CContextMenuHandler();

	// Generated message map functions
protected:
	//{{AFX_MSG(CContextMenuHandler)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONTEXTMENUHANDLER_H__B49AF6C3_EE6A_11D0_BAD6_00805F493F43__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\keysocx.h ===
#if !defined(AFX_KEYSOCX1_H__D7F3D362_F9FC_11D0_9EDC_00AA00A21BA9__INCLUDED_)
#define AFX_KEYSOCX1_H__D7F3D362_F9FC_11D0_9EDC_00AA00A21BA9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CKeysOCX wrapper class

class CKeysOCX : public CWnd
{
protected:
	DECLARE_DYNCREATE(CKeysOCX)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xcdd09f86, 0xe73c, 0x11d0, { 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
	void SetNoteState(short nKey, LPCTSTR pszName, short nState);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_KEYSOCX1_H__D7F3D362_F9FC_11D0_9EDC_00AA00A21BA9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\PropChord.cpp ===
#include "stdafx.h"
#include "PropChord.h"

CPropChord::CPropChord()
{
	for(int i = 0; i < MAX_POLY; i++)
		m_dwUndetermined[i] = 0;
}

static char *convert[] = {"C","C#","D","D#","E","F","F#","G","G#","A","A#","B"};
static char *flatconvert[] = {"C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"};

void CPropChord::RootToString(char *pszName, int nSubChord)
{
//	ASSERT(nSubChord < MAX_POLY);
	nSubChord = nSubChord >= MAX_POLY ? 0 : nSubChord;	// < 0 --> default root (0)
	int nX = (char)( SubChord(nSubChord)->ChordRoot() % 12 );
	if( SubChord(nSubChord)->UseFlat() )
		wsprintf( pszName,"%d%s",1 + (SubChord(nSubChord)->ChordRoot() / 12), (LPSTR)flatconvert[nX] ) ;
	else
		wsprintf( pszName,"%d%s",1 + (SubChord(nSubChord)->ChordRoot()/ 12), (LPSTR)convert[nX] ) ;
}


void CPropChord::SetBits(int nSubChord)
{
	LONG    nX;
	int   nCount = 0;

	DMChord* pSub = SubChord(nSubChord);

    for( nX=0L ;  nX<32L ;  nX++ )
    {
        if( pSub->ChordPattern() & (1L << nX) )
            nCount++;
    }

    if( !pSub->Bits() )
    {
        pSub->Bits() |= CHORD_INVERT;
        if( nCount > 3 )
            pSub->Bits() |= CHORD_FOUR;
        if( pSub->ChordPattern() & (15L << 18L) )
            pSub->Bits() |= CHORD_UPPER;
    }
    pSub->Bits() &= ~CHORD_COUNT;
    pSub->Bits() |= nCount;
}

void CPropChord::CopyToPropChord( CPropChord *pPropChord,  int nSubChord)
{
	ASSERT(nSubChord < MAX_POLY);

	int lower = nSubChord <0 ? 0 : nSubChord;
	int upper = nSubChord < -1 ? MAX_POLY : nSubChord + 1;
	int i;
	DWORD dwChangeFlags[MAX_POLY] ;
	
	for(i = 0; i < MAX_POLY; i++)
	{
		dwChangeFlags[i] = 0;
		pPropChord->m_dwUndetermined[i] = 0;
	}

	for(i = lower; i < upper; i++)
	{
		DMChord* pSubL = SubChord(i);
		DMChord* pSubR = pPropChord->SubChord(i);

		if (pSubL->ChordPattern() != pSubR->ChordPattern())
		{
			dwChangeFlags[i] |= UD_CHORDPATTERN;
		}

		if (pSubL->ScalePattern() != pSubR->ScalePattern())
		{
			dwChangeFlags[i] |= UD_SCALEPATTERN;
		}

		if (strcmp(Name(), pPropChord->Name()))
		{
			dwChangeFlags[i] |= UD_NAME;
		}

		if (pSubL->ChordRoot() != pSubR->ChordRoot())
		{
			dwChangeFlags[i] |= UD_CHORDROOT;
		}

		if (pSubL->ScaleRoot() != pSubR->ScaleRoot())
		{
			dwChangeFlags[i] |= UD_CHORDROOT;
		}

		if (pSubL->UseFlat() != pSubR->UseFlat())
		{
			dwChangeFlags[i] |= UD_FLAT;
		}

		if ((pSubL->Bits() & CHORD_INVERT) != (pSubR->Bits() & CHORD_INVERT))
		{
			dwChangeFlags[i] |= UD_INVERT;
		}

		if ((pSubL->Bits() & CHORD_FOUR) != (pSubR->Bits() & CHORD_FOUR))
		{
			dwChangeFlags[i] |= UD_FOUR;
		}

		if ((pSubL->Bits() & CHORD_UPPER) != (pSubR->Bits() & CHORD_UPPER))
		{
			dwChangeFlags[i] |= UD_UPPER;
		}

		if(pSubL->InvertPattern() != pSubR->InvertPattern())
		{
			dwChangeFlags[i] |= UD_INVERTPATTERN;
		}
		
		if(pSubL->Levels() != pSubR->Levels())
		{
			dwChangeFlags[i] |= UD_LEVELS;
		}

		pPropChord->m_dwUndetermined[i] = dwChangeFlags[i];
	}
}

  
void CPropChord::CopyFromPropChord( CPropChord *pPropChord, int nSubChord )
{
	ASSERT(nSubChord < MAX_POLY);

	int lower = nSubChord == -1 ? 0 : nSubChord;
	int upper = nSubChord == -1 ? MAX_POLY : nSubChord + 1;
	int i;
	DWORD dwChangeFlags[MAX_POLY] ;
	for(i = 0; i < MAX_POLY; i++)
	{
		dwChangeFlags[i] = ~(pPropChord->m_dwUndetermined[i]);
	}

	for(i = lower; i < upper; i++)
	{
		DMChord* pSubL = SubChord(i);
		DMChord* pSubR = pPropChord->SubChord(i);

		if (dwChangeFlags[i] & UD_CHORDPATTERN)
		{
			pSubL->ChordPattern() = pSubR->ChordPattern();
		}

		if (dwChangeFlags[i] & UD_SCALEPATTERN)
		{
			pSubL->ScalePattern() = pSubR->ScalePattern();
		}

		if (dwChangeFlags[i] & UD_NAME)
		{
			strcpy(Name(), pPropChord->Name());
		}

		if (dwChangeFlags[i] & UD_CHORDROOT)
		{
			pSubL->ChordRoot() = pSubR->ChordRoot();
		}

		if( dwChangeFlags[i] & UD_SCALEROOT)
		{
			pSubL->ScaleRoot() = pSubR->ScaleRoot();
		}

		if (dwChangeFlags[i] & UD_FLAT)
		{
			pSubL->UseFlat() = pSubR->UseFlat();
		}

		if (dwChangeFlags[i] & UD_INVERT)
		{
			pSubL->Bits() &= ~CHORD_INVERT;
			pSubL->Bits() |= (pSubR->Bits() & CHORD_INVERT);
		}

		if (dwChangeFlags[i] & UD_FOUR)
		{
			pSubL->Bits() &= ~CHORD_FOUR;
			pSubL->Bits() |= (pSubR->Bits() & CHORD_FOUR);
		}

		if (dwChangeFlags[i] & UD_UPPER)
		{
			pSubL->Bits() &= ~CHORD_UPPER;
			pSubL->Bits() |= (pSubR->Bits() & CHORD_UPPER);
		}

		if(dwChangeFlags[i] & UD_INVERTPATTERN)
		{
			pSubL->InvertPattern() = pSubR->InvertPattern();
		}

		if(dwChangeFlags[i] & UD_LEVELS)
		{
			pSubL->Levels() = pSubR->Levels();
		}
	}
}


BOOL CPropChord :: operator < (const CPropChord& chord)
{
	if( Measure() == chord.Measure())
	{
		if(Beat() < chord.Beat())
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	else if (Measure() < chord.Measure())
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

CPropChord& CPropChord::operator = (const CPropChord& chord)
{
	if(&chord == this)
	{
		return *this;
	}

	*dynamic_cast<DMPolyChord*>(const_cast<CPropChord*>(this)) = chord;

	for(int i = 0; i < MAX_POLY; i++)
	{
		m_dwUndetermined[i] = chord.m_dwUndetermined[i];
	}

	return *this;
}

CPropChord::CPropChord(const CPropChord& chord)
{
	*dynamic_cast<DMPolyChord*>(const_cast<CPropChord*>(this)) = chord;

	for(int i = 0; i < MAX_POLY; i++)
	{
		m_dwUndetermined[i] = chord.m_dwUndetermined[i];
	}
}

void	CPropChord::SetUndetermined(int nSubChord, DWORD value)
{
	ASSERT(nSubChord < MAX_POLY);
	int lower = nSubChord == -1 ? 0 : static_cast<int>(nSubChord);
	int upper = nSubChord == -1 ? MAX_POLY : static_cast<int>(nSubChord) + 1;
	for(int i = lower; i < upper; i++)
	{
		m_dwUndetermined[i] = value;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\PropChord.h ===
#ifndef __PROPCHORD_H_
#define __PROPCHORD_H_

#include "chord.h"

#define CHORD_INVERT  0x10      /* This chord may be inverted           */
#define CHORD_FOUR    0x20      /* This should be a 4 note chord        */
#define CHORD_UPPER   0x40      /* Shift upper octave down              */
#define CHORD_SIMPLE  0x80      /* This is a simple chord               */
#define CHORD_COUNT   0x0F      /* Number of notes in chord (up to 15)  */

class CPropChord : public DMPolyChord
{
//	Used to track which fields are shared by multiple 
//	chords and have multiple values, so are undetermined.
	DWORD		m_dwUndetermined[MAX_POLY];
public:
	enum {ALL = -1};
				CPropChord();
				CPropChord(const CPropChord&);
	void		SetBits(int nSubChord);
	void		CopyToPropChord( CPropChord *pPropChord, int nSubChord );	// nSubChord = -1 -> all subchords
	void		CopyFromPropChord( CPropChord *pPropChord, int nSubChord ); // nSubChord = -1 -> all subchords
	void		RootToString(char *pszName, int nSubChord);
	CPropChord&	operator = (const CPropChord&);
	BOOL		operator < (const CPropChord&);
	void		SetUndetermined(int nSubChord, DWORD value);	// nSubChord = -1 -> all subchords
	DWORD	GetUndetermined(int nSubChord)
	{
//		ASSERT(nSubChord < MAX_POLY);
		if(nSubChord >= MAX_POLY)
			nSubChord = 0;			// this chord is invalid but we still need a valid subchord index
									// as zero is the rootindex use that
		return m_dwUndetermined[nSubChord];
	}
	DWORD& Undetermined(int nSubChord)
	{
//		ASSERT(nSubChord < MAX_POLY);
		if(nSubChord >= MAX_POLY)
			nSubChord = 0;			// this chord is invalid but we still need a valid subchord index
									// as zero is the rootindex use that
		return m_dwUndetermined[nSubChord];
	}
	/*
    DWORD		m_dwTime;
    DWORD		m_dwChordPattern;	// Pattern that defines chord
    DWORD		m_dwScalePattern;	// Scale Pattern for the chord
    short		m_nMeasure;			// What measure
    char		m_szName[12];		// Text for display
    BYTE		m_bRoot;			// Root note of chord
    BYTE		m_bFlat;			// Display with flat
    BYTE		m_bBeat;			// What beat this falls on
    BYTE		m_bBits;			// Invert and item count
	*/
};

// Flags for m_dwUndetermined:

#define UD_CHORDPATTERN		(1 << 0)
#define UD_SCALEPATTERN		(1 << 1)
#define UD_NAME				(1 << 2)
#define UD_CHORDROOT				(1 << 3)
#define UD_FLAT				(1 << 4)
#define UD_INVERT			(1 << 5)
#define UD_FOUR				(1 << 6)
#define UD_UPPER			(1 << 7)
#define UD_SIMPLE			(1 << 8)
#define UD_DRAGSELECT		(1 << 9)
#define UD_DROPSELECT		(1 << 10)
#define UD_FROMCHORDPALETTE	(1 << 11)
#define UD_SCALEROOT		(1<<12)
#define UD_INVERTPATTERN	(1 << 13)
#define UD_LEVELS (1 << 14)

#endif // __PROPCHORD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\PropPageMgr.cpp ===
// CChordPropPageMgr : implementation file
//

#include "stdafx.h"
#include "..\includes\DMUSProd.h"
#include "..\includes\Conductor.h"
#include "PropChord.h"
#include "PropPageMgr.h"
#include "ChordScalePropPage.h"
#include "ChordInversionPropPage.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr property page

short CChordPropPageMgr::sm_nActiveTab = 0;

HRESULT STDMETHODCALLTYPE CChordPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
};


CChordPropPageMgr::CChordPropPageMgr( IDMUSProdFramework* pIFramework )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( pIFramework != NULL );
	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	m_pChordScalePropPage = NULL;
	m_pChordInversionPropPage = NULL;
	CStaticPropPageManager::CStaticPropPageManager();
}

CChordPropPageMgr::~CChordPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pChordScalePropPage )
	{
		m_pChordScalePropPage->Release();
		m_pChordScalePropPage = 0;
	}
	if(m_pChordInversionPropPage)
	{
		m_pChordInversionPropPage->Release();
		m_pChordInversionPropPage = 0;
	}
	if ( m_pIFramework )
	{
		m_pIFramework->Release();
		m_pIFramework = 0;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CChordPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_PROPPAGE_CHORD );
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CChordPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;


	// Add Chord/Scale tab
	if(m_pChordScalePropPage == NULL)
	{
		m_pChordScalePropPage = new CChordScalePropPage( );
	}
	ASSERT(m_pChordScalePropPage);
	if( m_pChordScalePropPage )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pChordScalePropPage->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		// fill in proppagemgr member
		m_pChordScalePropPage->m_pPropPageMgr = this;
		// fill in proppage's conductor member
		if(!m_pChordScalePropPage->m_pIConductor)
		{
			ASSERT(m_pIFramework);
			IDMUSProdComponent* pIComponent = NULL;
			IDMUSProdConductor* pConductor = NULL;
			if( SUCCEEDED ( m_pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
			{
				pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pConductor );
				if (pConductor)
				{
					m_pChordScalePropPage->m_pIConductor = pConductor;
				}
				pIComponent->Release();
			}
		}
	}


	// Add ChordInversion tab
	if(m_pChordInversionPropPage == NULL)
	{
		m_pChordInversionPropPage = new CChordInversionPropPage( );
	}
	ASSERT(m_pChordInversionPropPage);
	if( m_pChordInversionPropPage )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pChordInversionPropPage->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
		// fill in proppagemgr member
		m_pChordInversionPropPage->m_pPropPageMgr = this;
		if(!m_pChordInversionPropPage->m_pIConductor)
		{
			ASSERT(m_pIFramework);
			IDMUSProdComponent* pIComponent = NULL;
			IDMUSProdConductor* pConductor = NULL;
			if( SUCCEEDED ( m_pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
			{
				pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pConductor );
				if (pConductor)
				{
					m_pChordInversionPropPage->m_pIConductor = pConductor;
				}
				pIComponent->Release();
			}
		}
	}


	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}

/*
/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CChordPropPageMgr::OnRemoveFromPropertySheet( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CChordPropPageMgr::sm_nActiveTab );

	CDllBasePropPageManager::OnRemoveFromPropertySheet();

//	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}
*/

/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr IDMUSProdPropPageManager::RefreshData

HRESULT CChordPropPageMgr::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIPropPageObject == NULL )
	{
		return E_FAIL;
	}

	CChordScalePropPageData chordscalePropPageData;
	CChordScalePropPageData* pChordScalePropPageData = &chordscalePropPageData;

	if( SUCCEEDED ( m_pIPropPageObject->GetData( (void **)&pChordScalePropPageData ) ) )
	{
		m_pChordScalePropPage->SetChordData( pChordScalePropPageData );
		m_pChordInversionPropPage->SetChordData( pChordScalePropPageData );
		return S_OK;
	}

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\PropPageMgr.h ===
// PropPageMgr.h : Handles the property pages

#ifndef __PROPPAGEMGR_H_
#define __PROPPAGEMGR_H_

#include "ChordScalePropPage.h"
#include "ChordInversionPropPage.h"
#include "staticproppagemanager.h"

class CChordPropPageMgr : public  CStaticPropPageManager
{
	friend class CChordScalePropPage;
	friend class CChordInversionPropPage;
public:
	CChordPropPageMgr(IDMUSProdFramework* pIFramework );
	~CChordPropPageMgr();
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
//	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet( void );

	// Additional methods

	CChordScalePropPage*		m_pChordScalePropPage;
	CChordInversionPropPage*	m_pChordInversionPropPage;
	IDMUSProdFramework*		m_pIFramework;

	static short					sm_nActiveTab;
};

#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\PropPageChord.h ===
#include "..\shared\keyboard.h"

#if !defined(AFX_PROPPAGECHORD_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_PROPPAGECHORD_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include "conductor.h"
// PropPageChord.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// PropPageChord dialog
class CChordPropPageMgr;

class PropPageChord : public CPropertyPage, public IDMUSProdMidiInCPt
{
	friend class CChordPropPageMgr;
	DECLARE_DYNCREATE(PropPageChord)

// Construction
public:
	PropPageChord();
	~PropPageChord();
	void DispatchKeyboardChange(CKeyboard* pKeyboard, short nKey);

// Dialog Data
	//{{AFX_DATA(PropPageChord)
	enum { IDD = IDD_CHORD_PROPPAGE };
	CKeyboard	m_cScale;
	CKeyboard	m_cChord;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPageChord)
	public:
	virtual BOOL OnSetActive();
	virtual int DoModal();
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:

	afx_msg long OnWMUser(WPARAM, LPARAM);
	// Generated message map functions
	//{{AFX_MSG(PropPageChord)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnNoteDownChordKeys(short nKey);
	afx_msg void OnChordDropoctave();
	afx_msg void OnChordFlat();
	afx_msg void OnChordFournotes();
	afx_msg void OnChordInvert();
	afx_msg void OnChangeChordName();
	afx_msg void OnDeltaposRootSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeRootText();
	afx_msg void OnNoteDownScaleKeys(short nKey);
	afx_msg void OnTest();
	afx_msg void OnChordMidiIn();
	afx_msg void OnScaleMidiIn();
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void PreProcessPSP( PROPSHEETPAGE& psp, BOOL bWizard );
	void SetChord( CPropChord * pChord );

// IUnknown
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IDMUSProdMidiInCPt functions
	HRESULT STDMETHODCALLTYPE OnMidiMsg(REFERENCE_TIME rtTime, 
										BYTE bStatus, 
										BYTE bData1, 
										BYTE bData2);

private:
	DWORD	m_cRef;
	void DrawScaleNote(CPropChord* pChord, short nX);
	void SetCheckBox(CPropChord* pChord, DWORD dwUDFlag, UINT nDlgID, UINT nState);
	CPropChord				m_Chord;
	CChordPropPageMgr*		m_pPropPageMgr;
	IDMUSProdConductor*		m_pIConductor;
	// midi chord/scale input members
	void RegisterMidi();
	void UnRegisterMidi();
	DWORD m_dwCookie;		// may be used to distinguish what chord is receiving input (if necessary)
	enum {None, Chord, Scale };
	int	 m_fMidiInputTarget;
	DWORD m_cRegCount;
	BOOL m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGECHORD_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ChordMapStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_CHORD              101
#define IDR_CHORDMAPMGR                 102
#define IDS_DELETE                      102
#define IDD_CONNECTION_PROPAGE          102
#define IDS_UNDO_DeleteChord            102
#define IDS_PASTE                       103
#define IDS_UNDO_PasteChord             103
#define IDS_INSERT                      104
#define IDS_UNDO_InsertChord            104
#define IDD_CHORD_PROPPAGE              105
#define IDS_UNDO_EditChordMapChord      105
#define IDS_UNDO_ToggleSignPost         106
#define IDS_UNDO_CutChord               107
#define IDS_UNDO_AddConnection          108
#define IDS_UNDO_RemoveConnection       109
#define IDS_UNDO_EditConnection         110
#define IDS_UNDO_MoveConnection         111
#define IDS_UNDO_EditPaletteChord       112
#define IDS_UNDO_PastePalette           113
#define IDS_UNDO_LOCK_SCALES            114
#define IDS_UNDO_SYNC_LEVELS            115
#define IDC_CHORD_MOVE                  202
#define IDC_CHORD_MIDI_IN               202
#define IDB_STOPSIGN                    203
#define IDC_CHORD_NAME                  203
#define IDB_GOSIGN                      204
#define IDC_CHORD_MIDI_IN2              205
#define IDC_SPIN1                       206
#define IDC_ROOT_SPIN                   206
#define IDC_SPINWEIGHT                  206
#define IDC_EDIT2                       207
#define IDC_ROOT_TEXT                   207
#define IDC_CHORD_INVERT                208
#define IDC_CHORD_DROPOCTAVE            209
#define IDC_CHORD_FOURNOTES             210
#define IDC_CHORD_FLAT                  211
#define IDC_TEST                        212
#define IDC_ANIPUSHBUTTON1              215
#define IDC_KEYSOCXCTRL1                216
#define IDC_CHORD_KEYS                  216
#define IDC_KEYSOCXCTRL2                217
#define IDC_SCALE_KEYS                  217
#define IDR_CHORD_RMENU                 219
#define IDC_EDITWEIGHT                  219
#define IDI_CHORDTRUCK                  220
#define IDD_CHORDSCALE_PROPPAGE         221
#define IDD_CHORDINVERSION_PROPPAGE     222
#define IDC_BUTTON_MIDICHORD4           223
#define IDC_EDIT_ROOT                   224
#define IDC_EDIT_NAME                   225
#define IDC_CHECKBOX_FLATS              226
#define IDC_BUTTON3                     227
#define IDC_KEYS_SCALE4                 227
#define IDC_KEYS_BASECHORD4             228
#define IDC_KEYS_BASECHORD3             229
#define IDC_KEYS_BASECHORD2             230
#define IDC_BUTTON7                     231
#define IDC_KEYS_SCALE3                 231
#define IDC_KEYS_BASECHORD1             232
#define IDC_BUTTON9                     233
#define IDC_KEYS_SCALE1                 233
#define IDC_BUTTON10                    234
#define IDC_KEYS_SCALE2                 234
#define IDC_KEYS_CHORD4                 235
#define IDC_KEYS_INVERSIONS4            235
#define IDC_BUTTON8                     236
#define IDC_KEYS_CHORD3                 236
#define IDC_KEYS_INVERSIONS3            236
#define IDC_BUTTON11                    237
#define IDC_KEYS_CHORD1                 237
#define IDC_KEYS_INVERSIONS2            237
#define IDC_BUTTON12                    238
#define IDC_KEYS_CHORD2                 238
#define IDC_KEYS_INVERSIONS1            238
#define IDC_BUTTON_INVERT4              239
#define IDC_BUTTON_SHIFTLEFT4           240
#define IDC_BUTTON_SHIFTL4              240
#define IDC_BUTTON_IPLAY4               240
#define IDC_BUTTON_IPLAY3               241
#define IDB_GOSIGN_SEL                  241
#define IDC_BUTTON_IPLAY2               242
#define IDB_STOPSIGN_SEL                242
#define IDM_DRAG_RMENU                  243
#define IDC_BUTTON_IPLAY1               243
#define IDC_EDIT_IROOT                  244
#define IDR_PALETTE_RMENU               244
#define IDC_EDIT_INAME                  245
#define IDC_CHECK_LEGAL4                246
#define IDC_CHECK_LEGAL3                247
#define IDC_USESHARPS                   247
#define IDC_CHECK_LEGAL2                248
#define IDC_USEFLATS                    248
#define IDC_CHECK_LEGAL1                249
#define IDC_SPIN_ROOT                   250
#define IDC_BUTTON_MIDICHORD3           253
#define IDC_EDIT_MINBEATS               253
#define IDC_SPIN_MINBEATS               254
#define IDC_BUTTON15                    255
#define IDC_BUTTON_MIDICHORD2           255
#define IDC_EDIT_MAXBEATS               255
#define IDC_BUTTON_MIDICHORD5           256
#define IDC_SPIN_MAXBEATS               256
#define IDC_DONTWARN                    256
#define IDC_BUTTON17                    257
#define IDC_BUTTON_MIDICHORD1           257
#define IDC_ILLEGALCHORD                257
#define IDC_BUTTON19                    259
#define IDC_BUTTON_MIDISCALE4           259
#define IDC_BUTTON_INVERT3              260
#define IDC_BUTTON21                    261
#define IDC_BUTTON_MIDISCALE3           261
#define IDC_BUTTON_INVERT2              261
#define IDC_BUTTON_INVERT1              262
#define IDC_BUTTON23                    263
#define IDC_BUTTON_MIDISCALE2           263
#define IDC_BUTTON25                    265
#define IDC_BUTTON_MIDISCALE1           265
#define IDC_BUTTON14                    267
#define IDC_BUTTON_SHIFTL3              267
#define IDC_BUTTON16                    268
#define IDC_BUTTON_SHIFTL2              268
#define IDC_BUTTON18                    269
#define IDC_BUTTON_SHIFTL1              269
#define IDC_BUTTON20                    270
#define IDC_BUTTON_SHIFTR1              270
#define IDC_BUTTON22                    271
#define IDC_BUTTON_SHIFTR2              271
#define IDC_BUTTON24                    272
#define IDC_BUTTON_SHIFTR3              272
#define IDR_CHORDPROP                   272
#define IDC_BUTTON_SHIFTRIGHT4          273
#define IDC_BUTTON_SHIFTR4              273
#define IDD_ILLEGALCHORD                273
#define IDC_BUTTON27                    274
#define IDC_BUTTON_PLAY4                274
#define IDC_BUTTON28                    275
#define IDC_BUTTON_PLAY3                275
#define IDC_BUTTON29                    276
#define IDC_BUTTON_PLAY2                276
#define IDC_BUTTON30                    277
#define IDC_BUTTON_PLAY1                277
#define IDC_BUTTON_ROOTMIDI             278
#define IDC_BUTTON_MIDIROOT             278
#define IDC_BUTTON_PLAYALL              279
#define IDM_KILLPROPS                   666
#define IDM_CLEARSELECT                 667
#define ID_TIMELINE_CUT                 32768
#define ID_TIMELINE_PROPERTIES          32768
#define IDM_PROPERTIES                  32769
#define IDM_CHORD_DELETE                32770
#define ID_TIMELINE_PASTE               32770
#define IDM_CHORDINSERT                 32771
#define ID_TIMELINE_SELECTALL           32771
#define ID_TIMELINE_DELETE              32771
#define IDM_CHORD_INSERT                32772
#define IDS_MOVE                        32772
#define IDS_COPY                        32773
#define IDM_BEGSIGNPOST                 32773
#define IDM_ENDSIGNPOST                 32774
#define IDM_LOCK_ALL_SCALES             32774
#define IDS_PROPPAGE_CONNECTION         32775
#define IDM_SYNC_ALL_LEVELS             32775
#define IDR_PALETTE_PROPS               32776
#define ID_COPY_CHORD4                  32777
#define ID_COPY_SCALE4                  32778
#define ID_COPY_CHORDSCALE4             32779
#define ID_COPY_CHORD1                  32799
#define ID_COPY_CHORD2                  32800
#define ID_COPY_CHORD3                  32801
#define ID_COPY_CHORDALL                32802
#define ID_COPY_SCALE1                  32803
#define ID_COPY_SCALE2                  32804
#define ID_COPY_SCALE3                  32805
#define IDM_DRAG_MOVE                   32806
#define ID_COPY_CHORDSCALE1             32806
#define IDM_DRAG_CANCEL                 32807
#define ID_COPY_CHORDSCALE2             32807
#define IDM_DRAG_COPY                   32808
#define ID_COPY_CHORDSCALE3             32808
#define ID_COPY_CHORDSCALEALL           32809
#define ID_CLEAR_CHORDSCALE2            32811
#define ID_CLEAR_CHORDSCALE3            32812
#define ID_CLEAR_CHORDSCALE4            32813
#define ID_CLEAR_CHORDSCALEALL          32814
#define ID_COPY_SCALEALL                32815
#define ID_CLEAR_CHORDSCALE1            32816
#define IDS_LEVEL                       57706
#define IDS_ILLEGALCHORD                57709
#define IDS_ILLEGALCHORD2               57710
#define IDS_DONTWARN                    57711
#define IDS_PASTE_TOOLONG               57712
#define IDS_MULTIPLE_CONN               57713
#define IDS_MAPTOOSHORT                 57714
#define IDS_ILLEGALCHORD3               57715
#define ID_PALETTE_COPY                 57716

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        245
#define _APS_NEXT_COMMAND_VALUE         32780
#define _APS_NEXT_CONTROL_VALUE         257
#define _APS_NEXT_SYMED_VALUE           117
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\PropPageChord.cpp ===
// PropPageChord.cpp : implementation file
//

#include "stdafx.h"
#include "..\includes\DMUSProd.h"
#include "..\includes\Conductor.h"
#include "PropChord.h"
#include "PropPageMgr.h"
#include "PropPageChord.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////// Callback for CKeyboard Events
//
void KeyboardChangeCallback(CKeyboard* pKeyboard, void* hint, short nKey)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PropPageChord* pdlg = (PropPageChord*)hint;
	pdlg->DispatchKeyboardChange(pKeyboard, nKey);
}

/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr property page

CChordPropPageMgr::CChordPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pPropPageChord = NULL;
	m_pJazzFramework = NULL;
	CStaticPropPageManager::CStaticPropPageManager();
	m_fNeedToDetach = FALSE;
}

CChordPropPageMgr::~CChordPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageChord )
	{
		m_pPropPageChord->Release();
		m_pPropPageChord = 0;
	}
	if ( m_pJazzFramework )
	{
		m_pJazzFramework->Release();
		m_pJazzFramework = 0;
	}
	CStaticPropPageManager::~CStaticPropPageManager();
}

HRESULT STDMETHODCALLTYPE CChordPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
};

HRESULT STDMETHODCALLTYPE CChordPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;

	strTitle.LoadString( IDS_PROPPAGE_CHORD );
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
};

HRESULT STDMETHODCALLTYPE CChordPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add Chord tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	if(!m_pPropPageChord)
		m_pPropPageChord = new PropPageChord();
	if( m_pPropPageChord )
	{
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pPropPageChord->m_psp, sizeof(PROPSHEETPAGE) );
		m_pPropPageChord->PreProcessPSP( psp, FALSE );

		hPage = ::CreatePropertySheetPage( &psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		m_pPropPageChord->m_pPropPageMgr = this;
		if (!m_pJazzFramework)
		{
			pIPropSheet->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pJazzFramework );
		}
		// fill in proppage's conductor member
		if(!m_pPropPageChord->m_pIConductor)
		{
			ASSERT(m_pJazzFramework);
			IDMUSProdComponent* pIComponent = NULL;
			IDMUSProdConductor* pConductor = NULL;
			if( SUCCEEDED ( m_pJazzFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
			{
				pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pConductor );
				if (pConductor)
				{
					m_pPropPageChord->m_pIConductor = pConductor;
				}
				pIComponent->Release();
			}
		}
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};

HRESULT STDMETHODCALLTYPE CChordPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIPropPageObject 
	&&  m_pPropPageChord )
	{
		CChordScalePropPageData chordscalePropPageData;
		CChordScalePropPageData* pChordScalePropPageData = &chordscalePropPageData;

		if( SUCCEEDED ( m_pIPropPageObject->GetData( (void **)&pChordScalePropPageData ) ) )
		{
			m_pPropPageChord->SetChordData( pChordScalePropPageData );
			return S_OK;
		}
	}

	return E_FAIL;
};

/////////////////////////////////////////////////////////////////////////////
// PropPageChord property page

IMPLEMENT_DYNCREATE(PropPageChord, CPropertyPage)

PropPageChord::PropPageChord(): CPropertyPage(PropPageChord::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


//	CPropertyPage(IDD_CHORD_PROPPAGE);
	//{{AFX_DATA_INIT(PropPageChord)
	//}}AFX_DATA_INIT
	m_pPropPageMgr = NULL;
	m_fMidiInputTarget = None;
	m_dwCookie = 0;
	m_pIConductor = 0;
	m_cRef = 0;
	m_cRegCount = 0;
	AddRef();
}

PropPageChord::~PropPageChord()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	UnRegisterMidi();	// make sure we're unregistered
	if(m_pIConductor)
	{
		m_pIConductor->Release();
	}
}

void PropPageChord::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(PropPageChord)
	DDX_Control(pDX, IDC_SCALE_KEYS, m_cScale);
	DDX_Control(pDX, IDC_CHORD_KEYS, m_cChord);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPageChord, CPropertyPage)
	ON_MESSAGE(WM_USER, OnWMUser)
	//{{AFX_MSG_MAP(PropPageChord)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_CHORD_DROPOCTAVE, OnChordDropoctave)
	ON_BN_CLICKED(IDC_CHORD_FLAT, OnChordFlat)
	ON_BN_CLICKED(IDC_CHORD_FOURNOTES, OnChordFournotes)
	ON_BN_CLICKED(IDC_CHORD_INVERT, OnChordInvert)
	ON_EN_CHANGE(IDC_CHORD_NAME, OnChangeChordName)
	ON_NOTIFY(UDN_DELTAPOS, IDC_ROOT_SPIN, OnDeltaposRootSpin)
	ON_EN_CHANGE(IDC_ROOT_TEXT, OnChangeRootText)
	ON_BN_CLICKED(IDC_TEST, OnTest)
	ON_BN_CLICKED(IDC_CHORD_MIDI_IN, OnChordMidiIn)
	ON_BN_CLICKED(IDC_CHORD_MIDI_IN2, OnScaleMidiIn)
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPageChord custom functions

void PropPageChord::DrawScaleNote(CPropChord* pChord, short nX)

{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	short nGrayed;
	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_SCALEPATTERN) nGrayed = 4;
	else nGrayed = 0;
	DWORD dwChord = pChord->Base()->ChordPattern() << (pChord->Base()->ChordRoot() % 12);
	short nState = nGrayed;
	if ((pChord->Base()->ScalePattern() >> nX) & 1) 
	{
		nState++;
		if ((dwChord >> nX) & 1) nState += 2;
	}
	else
	{
		if ((dwChord >> nX) & 1) nState += 2;
	}
	m_cScale.SetNoteState(nX,"",nState);
}

void PropPageChord::SetCheckBox(CPropChord* pChord, DWORD dwUDFlag, UINT nDlgID, UINT nState)

{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if (pChord->GetUndetermined(pChord->RootIndex()) & dwUDFlag)
	{
		CButton *pButton = (CButton *) GetDlgItem(nDlgID);
		if (pButton)
		{
			pButton->SetButtonStyle(BS_AUTO3STATE);
			pButton->SetCheck(2);		
		}
	}
	else
	{
		CButton *pButton = (CButton *) GetDlgItem(nDlgID);
		if (pButton)
		{
			pButton->SetButtonStyle(BS_AUTOCHECKBOX);
			pButton->SetCheck(nState);
		}
	}
}

void PropPageChord::SetChord( CPropChord* pChord )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	char str[30];
	m_Chord = *pChord;
	
	if( IsWindow( m_hWnd ) == 0 ) return;

	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_NAME)
	{
		SetDlgItemText(IDC_CHORD_NAME,"");
	}
	else
	{
		SetDlgItemText(IDC_CHORD_NAME,pChord->Name());
	}
	pChord->RootToString(str, pChord->RootIndex());
	SetDlgItemText(IDC_ROOT_TEXT,str);
	SetCheckBox(pChord, UD_INVERT, IDC_CHORD_INVERT,(pChord->Base()->Bits() & CHORD_INVERT) && 1);
	SetCheckBox(pChord, UD_UPPER, IDC_CHORD_DROPOCTAVE,(pChord->Base()->Bits() & CHORD_UPPER) && 1);
	SetCheckBox(pChord, UD_FOUR, IDC_CHORD_FOURNOTES,(pChord->Base()->Bits() & CHORD_FOUR) && 1);
	SetCheckBox(pChord, UD_FLAT, IDC_CHORD_FLAT,pChord->Base()->UseFlat() && 1);
	short nGrayed;
	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_CHORDPATTERN) nGrayed = 4;
	else nGrayed = 0;
	int nX;
	for (nX = 0; nX < 24; nX++)
	{
		short nState = nGrayed;
		if ((pChord->Base()->ChordPattern() >> nX) & 1) nState += 2;
		m_cChord.SetNoteState(nX,"",nState);
	}
	for (nX = 0; nX < 24; nX++)
	{
		DrawScaleNote(pChord, nX);
	}
}

/////////////////////////////////////////////////////////////////////////////
// PropPageChord message handlers

int PropPageChord::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}

void PropPageChord::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}
	UnRegisterMidi();

	CPropertyPage::OnDestroy();	
}

BOOL PropPageChord::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	RegisterMidi();

	return CPropertyPage::OnSetActive();
}


int PropPageChord::DoModal() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	return CPropertyPage::DoModal();
}

BOOL PropPageChord::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	// TODO: Add your specialized code here and/or call the base class
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	return CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
}

/////////////////////////////////////////////////////////////////////////////
// PropPageChord::PreProcessPSP

void PropPageChord::PreProcessPSP( PROPSHEETPAGE& psp, BOOL bWizard )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	PreProcessPageTemplate( psp, FALSE );
}

BOOL PropPageChord::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_cChord.SetLButtonUpCallback(KeyboardChangeCallback, this);
	m_cScale.SetLButtonUpCallback(KeyboardChangeCallback, this);

	CPropertyPage::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT PropPageChord::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return CPropertyPage::WindowProc(message, wParam, lParam);
}

BEGIN_EVENTSINK_MAP(PropPageChord, CPropertyPage)
    //{{AFX_EVENTSINK_MAP(PropPageChord)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void PropPageChord::OnNoteDownChordKeys(short nKey) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if (m_Chord.GetUndetermined(m_Chord.RootIndex()) & UD_CHORDPATTERN)
	{
		m_Chord.Undetermined(m_Chord.RootIndex()) &= ~UD_CHORDPATTERN;
		for (nKey = 0; nKey < 24; nKey++)
		{
			m_cChord.SetNoteState(nKey,"",(1 && ((m_Chord.Base()->ChordPattern() >> nKey) & 1)) << 1);
		}
	}
	else
	{
		m_Chord.Base()->ChordPattern() ^= (1 << nKey);
		m_Chord.Undetermined(m_Chord.RootIndex()) &= ~UD_CHORDPATTERN;
		m_cChord.SetNoteState(nKey,"",(1 && ((m_Chord.Base()->ChordPattern() >> nKey) & 1)) << 1);
		DrawScaleNote(&m_Chord, (nKey + m_Chord.Base()->ChordRoot()) % 24);
		DrawScaleNote(&m_Chord, (nKey + m_Chord.Base()->ChordRoot() + 12) % 24);
	}
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
	}
}


void PropPageChord::OnNoteDownScaleKeys(short nKey) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	short nOtherKey = (nKey + 12) % 24;
	if (m_Chord.Undetermined(m_Chord.RootIndex()) & UD_SCALEPATTERN)
	{
		m_Chord.Undetermined(m_Chord.RootIndex()) &= ~UD_SCALEPATTERN;
//		m_Chord.m_dwScalePattern ^= (1 << nKey);
		for (nKey = 0; nKey < 24; nKey++)
		{
			DrawScaleNote(&m_Chord,nKey);
		}
	}
	else
	{
		m_Chord.Base()->ScalePattern() ^= (1 << nKey);
		m_Chord.Base()->ScalePattern() ^= (1 << nOtherKey);
		DrawScaleNote(&m_Chord,nKey);
		DrawScaleNote(&m_Chord,nOtherKey);
	}
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
	}	
}

void PropPageChord::OnChordDropoctave() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	UINT nChecked = IsDlgButtonChecked(IDC_CHORD_DROPOCTAVE);
	UINT nState;
	if (m_Chord.Undetermined(m_Chord.RootIndex()) & UD_UPPER)
	{
		nState = 2;
	}
	else if (m_Chord.Base()->Bits() & CHORD_UPPER)
	{
		nState = 1;
	}
	else nState = 0;
	if (nState != nChecked)
	{
		if (nChecked == 2)
		{
			CButton *pButton = (CButton *) GetDlgItem(IDC_CHORD_DROPOCTAVE);
			if (pButton)
			{
				pButton->SetButtonStyle(BS_AUTOCHECKBOX);
				pButton->SetCheck(nState);			
			}
		}
		else
		{
			m_Chord.Undetermined(m_Chord.RootIndex()) &= ~UD_UPPER;
			if (nChecked == 1)
			{
				m_Chord.Base()->Bits() |= CHORD_UPPER;
			}
			else 
			{
				m_Chord.Base()->Bits() &= ~CHORD_UPPER;
			}
			if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
			{
				m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
			}	
		}
	}
}

void PropPageChord::OnChordFlat() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	UINT nChecked = IsDlgButtonChecked(IDC_CHORD_FLAT);
	UINT nState;
	if (m_Chord.Undetermined(m_Chord.RootIndex())  & UD_FLAT)
	{
		nState = 2;
	}
	else if (m_Chord.Base()->UseFlat())
	{
		nState = 1;
	}
	else nState = 0;
	if (nState != nChecked)
	{
		if (nChecked == 2)
		{
			CButton *pButton = (CButton *) GetDlgItem(IDC_CHORD_FLAT);
			if (pButton)
			{
				pButton->SetButtonStyle(BS_AUTOCHECKBOX);
				pButton->SetCheck(nState);			
			}
		}
		else
		{
			m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_FLAT;
			if (nChecked == 1)
			{
				m_Chord.Base()->UseFlat() = TRUE;
			}
			else 
			{
				m_Chord.Base()->UseFlat() = FALSE;
			}
			if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
			{
				m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
			}	
		}
	}
}

void PropPageChord::OnChordFournotes() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	UINT nChecked = IsDlgButtonChecked(IDC_CHORD_FOURNOTES);
	UINT nState;
	if (m_Chord.Undetermined(m_Chord.RootIndex())  & UD_FOUR)
	{
		nState = 2;
	}
	else if (m_Chord.Base()->Bits() & CHORD_FOUR)
	{
		nState = 1;
	}
	else nState = 0;
	if (nState != nChecked)
	{
		if (nChecked == 2)
		{
			CButton *pButton = (CButton *) GetDlgItem(IDC_CHORD_FOURNOTES);
			if (pButton)
			{
				pButton->SetButtonStyle(BS_AUTOCHECKBOX);
				pButton->SetCheck(nState);			
			}
		}
		else
		{
			m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_FOUR;
			if (nChecked == 1)
			{
				m_Chord.Base()->Bits() |= CHORD_FOUR;
			}
			else 
			{
				m_Chord.Base()->Bits() &= ~CHORD_FOUR;
			}
			if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
			{
				m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
			}	
		}
	}
}

void PropPageChord::OnChordInvert() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	UINT nChecked = IsDlgButtonChecked(IDC_CHORD_INVERT);
	UINT nState;
	
	if (m_Chord.Undetermined(m_Chord.RootIndex())  & UD_INVERT)
	{
		nState = 2;
	}
	else if (m_Chord.Base()->Bits() & CHORD_INVERT)
	{
		nState = 1;
	}
	else nState = 0;
	if (nState != nChecked)
	{
		if (nChecked == 2)
		{
			CButton *pButton = (CButton *) GetDlgItem(IDC_CHORD_INVERT);
			if (pButton)
			{
				pButton->SetButtonStyle(BS_AUTOCHECKBOX);
				pButton->SetCheck(nState);			
			}
		}
		else
		{
			m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_INVERT;
			if (nChecked == 1)
			{
				m_Chord.Base()->Bits() |= CHORD_INVERT;
			}
			else 
			{
				m_Chord.Base()->Bits() &= ~CHORD_INVERT;
			}
			if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
			{
				m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
			}	
		}
	}
}

void PropPageChord::OnChangeChordName() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	char szName[30];
	GetDlgItemText(IDC_CHORD_NAME,szName,sizeof(m_Chord.Name()));
	if (strcmp("",szName) && (strcmp(m_Chord.Name(),szName)))
	{
		strcpy(m_Chord.Name(),szName);
		m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_NAME;
		if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
		{
			m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
		}	
	}
}

void PropPageChord::OnDeltaposRootSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

#ifdef CHORDMAP
	if(m_Chord.Undetermined(m_Chord.RootIndex())  & UD_FROMCHORDPALETTE)
		return;	// can't change root of palette chords
#endif
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	short nX = m_Chord.Base()->ChordRoot() - pNMUpDown->iDelta;
	if (nX < 0) nX = 0;
	if (nX > 23) nX = 23;
	m_Chord.Base()->ChordRoot() = (BYTE) nX;
	char str[10];
	m_Chord.RootToString(str, m_Chord.RootIndex());
	SetDlgItemText(IDC_ROOT_TEXT,str);
	m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_CHORDROOT;
	for (nX = 0; nX < 24; nX++)
	{
		DrawScaleNote(&m_Chord, nX);
	}
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
	}	
	*pResult = 0;
}

void PropPageChord::OnChangeRootText() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
	}	
}
#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0

#define MIDI_BASEPITCH		60

void PropPageChord::OnTest() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	IDMUSProdConductor *pConductor = NULL;
	IDMUSProdComponent* pIComponent = NULL;
	if (m_pPropPageMgr->m_pJazzFramework)
	{
		if( SUCCEEDED ( m_pPropPageMgr->m_pJazzFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
		{
			pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pConductor );
			if (pConductor)
			{
				short nX;
				DWORD dwTime = 500;
				pConductor->PlayMIDIEvent( MIDI_PCHANGE, 0, 0, 0 );
				pConductor->PlayMIDIEvent( MIDI_PCHANGE+1, 10, 0, 0 );
				for (nX = 0; nX < 24; nX++)
				{
					if ((m_Chord.Base()->ChordPattern() >> nX) & 1)
					{
						short note = MIDI_BASEPITCH + nX + m_Chord.Base()->ChordRoot();
						pConductor->PlayMIDIEvent( MIDI_NOTEON, 
							note, 120, dwTime );
						pConductor->PlayMIDIEvent( MIDI_NOTEOFF, 
							note, 120, dwTime + 1000 );
					}
				}
				dwTime += 1000;
				for (nX = 0; nX < 25; nX++)
				{
					if ((m_Chord.Base()->ScalePattern() >> nX) & 1)
					{
						short note = MIDI_BASEPITCH + nX;
						pConductor->PlayMIDIEvent( MIDI_NOTEON+1, 
							note,  100, dwTime );
						pConductor->PlayMIDIEvent( MIDI_NOTEOFF+1, 
							note,  100, dwTime + 180);
						dwTime += 200;
					}
				}
				pConductor->Release();
			}
			pIComponent->Release();
		}
	}
}

void PropPageChord::OnChordMidiIn() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	CButton* chord = (CButton*)GetDlgItem(IDC_CHORD_MIDI_IN);
	ASSERT(chord);
	CButton* scale = (CButton*)GetDlgItem(IDC_CHORD_MIDI_IN2);
	ASSERT(scale);


	if(m_fMidiInputTarget == None || m_fMidiInputTarget == Scale)
	{
		m_fMidiInputTarget = Chord;
		chord->SetCheck(1);
		scale->SetCheck(0);
		RegisterMidi();
	}
	else if(m_fMidiInputTarget == Chord)
	{
		m_fMidiInputTarget = None;
		chord->SetCheck(0);
		scale->SetCheck(0);
		UnRegisterMidi();
	}
}

void PropPageChord::OnScaleMidiIn() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	CButton* chord = (CButton*)GetDlgItem(IDC_CHORD_MIDI_IN);
	ASSERT(chord);
	CButton* scale = (CButton*)GetDlgItem(IDC_CHORD_MIDI_IN2);
	ASSERT(scale);


	if(m_fMidiInputTarget == None || m_fMidiInputTarget == Chord)
	{
		m_fMidiInputTarget = Scale;
		chord->SetCheck(0);
		scale->SetCheck(1);
		RegisterMidi();
	}
	else if(m_fMidiInputTarget == Scale)
	{
		m_fMidiInputTarget = None;
		chord->SetCheck(0);
		scale->SetCheck(0);
		UnRegisterMidi();
	}
}

const short KeyOCXTrans = 48;
const short KeyOCXLow = 0;
const short KeyOCXHigh = 23;

HRESULT PropPageChord::OnMidiMsg(REFERENCE_TIME rtTime,
									   BYTE bStatus, 
									   BYTE bData1, 
									   BYTE bData2)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Note On
	if((int)(bStatus & 0xF0) == (int)0x90)
	{

		char Text[128];
		sprintf(Text, "Inside  PropPageChord::OnMidiMsg going to play %d note on\n", bData1); 
		TRACE0(Text);
		
		// set note
		short nKey = bData1 - KeyOCXTrans;
		if(nKey >= KeyOCXLow && nKey <= KeyOCXHigh)
		{
			this->PostMessage(WM_USER, nKey, 0);
		}
	}

	// Note Off
	if((int)(bStatus & 0xF0) == (int)0x80)
	{
		char Text[128];
		sprintf(Text, "Inside  PropPageChord::OnMidiMsg going to play %d note off\n", bData1); 
		TRACE0(Text);
	}

	// set up patch
	m_pIConductor->PlayMIDIEvent( MIDI_PCHANGE, 0, 0, 0 );
	m_pIConductor->PlayMIDIEvent( MIDI_PCHANGE+1, 10, 0, 0 );

	m_pIConductor->PlayMIDIEvent((bStatus & 0xF0),
								 bData1,
								 bData2,
								 0);	
	
	return S_OK;
}

void PropPageChord::RegisterMidi() 
{
	ASSERT(m_cRegCount <= 1);
	if(m_fMidiInputTarget != None && m_cRegCount == 0)
	{
		++m_cRegCount;
		REGISTER_MIDI_IN(m_pIConductor, m_dwCookie)	
	}
}

void PropPageChord::UnRegisterMidi()
{
	ASSERT(m_cRegCount <= 1);
	if(m_cRegCount)
	{
		m_cRegCount--;
		UNREGISTER_MIDI_IN(m_pIConductor, m_dwCookie)
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageChord IUnknown
STDMETHODIMP PropPageChord::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	ASSERT( ppv );
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdMidiInCPt))
	{
        *ppv = (IUnknown *) (IDMUSProdMidiInCPt *) this;
	}
	else
	{
		return E_NOTIMPL;
	}
    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) PropPageChord::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	return ++m_cRef;
}

STDMETHODIMP_(ULONG) PropPageChord::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}

void PropPageChord::OnKillFocus(CWnd* pNewWnd) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	CPropertyPage::OnKillFocus(pNewWnd);
	
	AfxMessageBox("Losing Focus");	
}

long PropPageChord::OnWMUser(WPARAM midinote, LPARAM)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if(m_fMidiInputTarget == Chord)
	{
		OnNoteDownChordKeys(midinote);
	}
	else if(m_fMidiInputTarget == Scale)
	{
		OnNoteDownScaleKeys(midinote);
	}
	return 0;
}

void PropPageChord::DispatchKeyboardChange(CKeyboard* pKeyboard, short nKey)
{
	if(pKeyboard == &m_cChord)
	{
		OnNoteDownChordKeys(nKey);
	}
	else if(pKeyboard == &m_cScale)
	{
		OnNoteDownScaleKeys(nKey);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>
#include <afxdlgs.h>
#include <AFXCMN.H>

#include <Afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordMapStripMgr\RiffStructs.h ===
#ifndef __RIFFSTRUCTS_H__
#define __RIFFSTRUCTS_H__

#pragma pack(2)


/*
typedef struct ioNoteEvent
{
    long    lTime;           // When this event occurs.
    BYTE    bStatus;         // MIDI status.
    BYTE    bNote;           // Note value.
    BYTE    bVelocity;       // Note velocity.
    BYTE    bVoiceID;        // Band member who will play note
    WORD    wDuration;       // Lead line note duration. (Song)
    BYTE    bEventType;      // Type of event
} ioNoteEvent;
*/

/*
typedef struct ioNote
{
    BYTE    bEventType;           // Type of event
    BYTE    bVoiceID;             // Instrument identifier.
    short   nTime;                // Time from center of beat.
    WORD    wVariation;           // 16 variation bits.
    BYTE    bScaleValue;          // Position in scale.
    BYTE    bBits;                // Various bits.
    BYTE    bValue;               // Note value.
    BYTE    bVelocity;            // Note velocity.
    WORD    nMusicValue;  // Description of note in chord and key.
    short   nDuration;            // Duration
    BYTE    bTimeRange;           // Range to randomize time.
    BYTE    bDurRange;            // Range to randomize duration.
    BYTE    bVelRange;            // Range to randomize velocity.
    BYTE    bPlayMode;
} ioNote;
*/

/*
typedef struct ioCurveEvent
{
    long    lTime;
    WORD    wVariation;
    BYTE    bVoiceID;
    BYTE    bVelocity;
    BYTE    bEventType;
} ioCurveEvent;
*/

/*
typedef struct ioCurve
{
    BYTE    bEventType;
    BYTE    bVoiceID;
    short   nTime;
    WORD    wVariation;
    BYTE    bCCData;
} ioCurve;
*/

/*
typedef struct ioSubCurve
{
    BYTE    bCurveType; // defines the shape of the curve
    char    fFlipped;  // flaggs defining the flipped state: not, vertical, or horizontal
    short   nMinTime;   // left lower corner of bounding box.
    short   nMinValue;  // also used by the ECT_INSTANT curve type.
    short   nMaxTime;   // right upper corner of bounding box.
    short   nMaxValue;
} ioSubCurve;
*/

/*
typedef struct ioMute
{
    long    lTime;           // Time in clocks.
    WORD    wMuteBits;       // Which instruments to mute.
    WORD    wLock;          // Lock flag
} ioMute;
*/


typedef struct ioCommand
{
    long    lTime;       // Time, in clocks.
    DWORD   dwCommand;    // Command type.
} ioCommand;



typedef struct ioChord
{
	long	lChordPattern;	// pattern that defines chord
	long	lScalePattern;	// scale pattern for the chord
	long	lInvertPattern;	// inversion pattern
    BYTE    bRoot;         // root note of chord
    BYTE    bReserved;     // expansion room
    WORD    wCFlags;        // bit flags
	long	lReserved;		// expansion room
} ioChord;


// this should match enums in iochord.h
enum
{
	CSF_KEYDOWN = 	1,	// key currently held down in sjam kybd
	CSF_INSCALE = 	2,	// member of scale
	CSF_FLAT =		4,	// display with flat
	CSF_SIMPLE =	8,	// simple chord, display at top of sjam list
	CSF_SELECTED = 0x80, // this chord is selected
	CSF_SIGNPOST = 0x40, // this chord is from a signpost
	CSF_SHIFTED = 0x20	// this chord has been altered from an illegal chord
						// used to make chord unique so that Load subchord database code works correctly
						// (see use in ChordDatabase.cpp)

};



typedef struct ioChordSelection
{
    wchar_t wstrName[16];   // text for display
    BYTE    fCSFlags;      // ChordSelection flags
    BYTE    bBeat;         // beat this falls on
    WORD    wMeasure;       // measure this falls on
    ioChord aChord[4];      // array of chords: levels
    BYTE    bClick;        // click this falls on
} ioChordSelection;


#define KEY_FLAT 0x80
typedef struct ioSect
{
    long    lTime;           // Time this section starts.
    wchar_t wstrName[16];       // Each section has a name.
    WORD    wTempo;             // Tempo.
    WORD    wRepeats;           // Number of repeats.
    WORD    wMeasureLength;     // Length, in measures.
    WORD    wClocksPerMeasure;  // Length of each measure.
    WORD    wClocksPerBeat;     // Length of each beat.
    WORD    wTempoFract;        // Tempo fraction.  (0-65536) (Score only)
    DWORD   dwFlags;           // Currently not used in SuperJAM!
    char    chKey;          // key sig. High bit is flat bit, the rest is root.
    char    chPad[3];
    GUID    guidStyle;
    GUID    guidPersonality;
    wchar_t wstrCategory[16];
} ioSection;

/*
typedef struct ioBand
{
    wchar_t wstrName[20]; // Band name
    BYTE    abPatch[16];
    BYTE    abVolume[16];
    BYTE    abPan[16];
    signed char achOctave[16];
    char    fDefault;    // This band is the style's default band
    char    chPad;
    WORD    awDLSBank[16];
    BYTE    abDLSPatch[16];
    GUID    guidCollection;
//    wchar_t wstrCollection[16];
    char    szCollection[32];           // this only needs to be single-wide chars
} ioBand;
*/

/*
typedef struct ioLyric
{
    long    lTime;       // Time, in clocks
} ioLyric;
*/

/*
typedef struct ioPhrase
{
    long    lTime;
    BYTE    bID;    // which phrase it is. Index starting at 0.
} ioPhrase;
*/

/*
typedef struct ioClick
{
    short   lTime;               // Index into grid.
} ioClick;
*/

typedef struct ioPattern
{
    long    lTime;             // Time this starts.
    DWORD   dwLength;           // Pattern length in clocks.
    DWORD   fFlags;            // Various flags.
    WORD    wClocksPerClick;   // Size of each click.
    WORD    wBeat;             // What note gets the beat.
    WORD    wClocksPerBeat;    // Size of each beat.
    WORD    wMeasures;         // Number of measures.
    wchar_t wstrName[16];         // Name of pattern.
    DWORD   dwKeyPattern;       // Key for defining in.
    DWORD   dwChordPattern;     // Defining chord.
    BYTE    abInvertUpper[16];   // Inversion upper limit.
    BYTE    abInvertLower[16];   // Inversion upper limit.
    WORD    wInvert;     // Activate inversion flags.
    WORD    awVarFlags[16][16]; // Var flags for all musicians.
    WORD    wAutoInvert;    // Automatically set inversion limits
    BYTE    bRoot;             // Root for defining.
    char    achChordChoice[16];
} ioPattern;

/*
typedef struct ioStyle
{
    wchar_t wstrName[16];         // Each style has a name.
    WORD    wBPM;              // Beats per measure.
    WORD    wBeat;             // Beat note.
    WORD    wClocksPerClick;   // Clocks per click in patterns.
    WORD    wClocksPerBeat;    // Clocks per beat.
    WORD    wClocksPerMeasure; // Clocks per measure.
    WORD    wTempo;            // Tempo.
    WORD    wTempoFract;
    GUID    guid;
    wchar_t wstrCategory[16];
} ioStyle;
*/

typedef struct ioPersonalityRef
{
    wchar_t wstrName[20];       // Internal name stored in personality
    char    fDefault;           // 1=Default personality
    char    achPad[3];
    GUID    guid;
} ioPersonalityRef;

#pragma pack()

#endif // __RIFFSTRUCTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\Chord.h ===
// chord.h

#include "DWList.h"

#ifndef __CHORD_H__
#define __CHORD_H__

#pragma pack(1)

#define FIELDOFFSET(s,f)     (long)(& (((s __RPC_FAR *)0)->f))


#define MakeID(a,b,c,d)  ( (LONG)(a)<<24L | (LONG)(b)<<16L | (c)<<8 | (d) )

#define ID_CHORDENTRY   MakeID('s','C','E','N')
#define ID_NEXTLIST     MakeID('s','N','X','L')
#define ID_PERSONALITY  MakeID('s','P','E','R')
#define ID_PERSONREF    MakeID('s','P','R','F')
#define ID_NEWSTYLE     MakeID('s','S','T','Y')
#define ID_CHORDPALETTE MakeID('s','C','P','L')
#define ID_TEMPLATE     MakeID('s','T','P','L')
#define ID_TEMPLATELIST MakeID('s','T','L','S')
#define ID_SIGNPOST     MakeID('s','S','N','P')
#define ID_INSTRUMENTS  MakeID('s','I','N','S')
#define ID_COMMAND      MakeID('s','C','M','D')
#define ID_GROOVENAME   MakeID('s','G','R','N')

// Large versions for editing:
#define ID_EPERSONALITY MakeID('s','C','M','P')
#define ID_ECHORDENTRY  MakeID('e','C','E','N')
#define ID_ENEXTLIST    MakeID('e','N','X','L')
#define ID_ESTYLE       MakeID('e','S','T','Y')
#define ID_EPERSONREF   MakeID('e','P','R','F')

// new DM ids
#define ID_DMCHORDENTRY		MakeID('x','C','E','N')
#define ID_DMNEXTLIST		MakeID('x','N','X','L')
#define ID_DMSIGNPOST		MakeID('x','S','N','P')
#define ID_DMCHORDPALETTE	MakeID('x','C','P','L')
#define ID_DMPERSONALITY	MakeID('x','P','E','R')

// extended version for Jazz
#define ID_JPERSONALITY MakeID('j','C','M','P')
#define ID_J4PERSONALITY MakeID('4', 'C', 'M', 'P')
#define ID_J5PERSONALITY MakeID('5', 'C', 'M', 'P')

/*  SCTchord bBits flags ===============================================*/
#define CHORD_INVERT  0x10      /* This chord may be inverted           */
#define CHORD_FOUR    0x20      /* This should be a 4 note chord        */
#define CHORD_UPPER   0x40      /* Shift upper octave down              */
#define CHORD_SIMPLE  0x80      /* This is a simple chord               */
#define CHORD_COUNT   0x0F      /* Number of notes in chord (up to 15)  */
#define ID_CHRD        0x43485244
#define ID_KBRD        0x4B425244

void swaplong(char data[]);
void WriteID( IStream *pIStream, DWORD id );
void WriteSize( IStream *pIStream, long size );
long ReadID( IStream *pIStream );
long ReadSize( IStream *pIStream );


inline long Rotate24(long val, long shift)
{
	__int64 mask64 = 0xffffff;
	__int64 val64 = val;

	ASSERT(shift > -24 && shift < 24);
	if(shift < 0)
	{
		shift = 24 + shift;
	}
	val64 = (val64 & mask64) << shift;
	__int64 excess = (val64 >> 24) & mask64;	// rotate
	val64 |= (excess & ~(1<<shift));
	val =  long(val64 & mask64);
	return val;
}


inline unsigned long Canonical24(unsigned long pattern, unsigned long root)
//
// convert pattern (scale or chord) to a canonical representation where octave 
// equivalences are filled in.
//
{
	if(!(pattern & 0xf00000))
	{
		// dup at octave
		pattern |= pattern << 12;
	}
	pattern = Rotate24(pattern, root%12);
	// fill in lower bits
	pattern |= pattern>>12;
	return pattern;
}

inline DWORD BlueBits(DWORD& cp, DWORD cr, DWORD& sp, DWORD sr, bool bReturnCanonicalForm = true)
// ~(chord -> scale) = ~(scale | ~chord) = ~scale & chord
{
	DWORD scale, chord;
	scale = Canonical24(sp,sr);
	chord = Canonical24(cp,cr);
	DWORD pattern = ~scale  & chord;
	if(bReturnCanonicalForm)
	{
		sp = scale;
		cp = chord;
	}
	return pattern;
}


inline bool InScale(char root, long chordpattern, long scalepattern)
{
	bool match = (Rotate24(chordpattern, (long)root) | scalepattern) == scalepattern;
	return match;
}


// structs for loading old personalities
struct OldChordEntry
{
	// ChordSelection = 38
	long time;
	long pattern;
	char name[12];
	char keydown;
	char root;
	char inscale;
	char flat;
	short varflags;
	short measure;
	char beat;
	BYTE bits;
	long scalepattern;
	long melodypattern;
	// SmallChordEntry = 44
	DWORD dwflags;
	short nid;
	// extended = 54
	short rect[4];
	short page;
	static DWORD	SizeExtendedChordEntry();
	static DWORD	SizeChordSelection();
	static DWORD	SizeSmallChordEntry();
};

struct OldNextChord
{
	// small
	DWORD	dwflags;
	short	nweight;
	short	nminbeats;
	short	nmaxbeats;
	short	nid;
	// extended
	short	rect[4];
};

// DM structures
// DMChord represents a subchord in a multi chord structure
class DMPolyChord;
class DMChord
{
	DWORD	m_dwChordPattern;
	DWORD	m_dwScalePattern;
	DWORD	m_dwInvertPattern;
	DWORD	m_dwLevels;		// which levels of multi chord this subchord supports
	WORD	m_wFlags;
	BYTE	m_bChordRoot;
	BYTE	m_bScaleRoot;
	BYTE	m_bFlat;
	BYTE	m_bBits;
	bool	m_bInUse;
public:
	DWORD&	ChordPattern()
	{
		return m_dwChordPattern;
	}
	DWORD ChordPattern() const
	{
		return m_dwChordPattern;
	}
	DWORD&	ScalePattern()
	{
		return m_dwScalePattern;
	}
	DWORD	ScalePattern() const
	{
		return m_dwScalePattern;
	}
	DWORD&	InvertPattern()
	{
		return m_dwInvertPattern;
	}
	DWORD	InvertPattern() const
	{
		return m_dwInvertPattern;
	}
	DWORD& Levels()
	{
		return m_dwLevels;
	}
	DWORD Levels() const
	{
		return m_dwLevels;
	}
	WORD&	Flags()
	{
		return m_wFlags;
	}
	WORD	Flags() const
	{
		return m_wFlags;
	}
	BYTE&	ChordRoot()
	{
		return m_bChordRoot;
	}
	BYTE	ChordRoot() const
	{
		return m_bChordRoot;
	}
	BYTE&	ScaleRoot()
	{
		return m_bScaleRoot;
	}
	BYTE	ScaleRoot() const
	{
		return m_bScaleRoot;
	}
	BYTE&	UseFlat()
	{
		return m_bFlat;
	}
	BYTE	UseFlat() const
	{
		return m_bFlat;
	}
	BYTE&	Bits()
	{
		return m_bBits;
	}
	BYTE	Bits() const
	{
		return m_bBits;
	}
	bool&	InUse()
	{
		return m_bInUse;
	}
	bool	InUse() const
	{
		return m_bInUse;
	}
	DMChord();
	DMChord(const DMChord& chord)
	{
		memcpy(this, &chord, sizeof(DMChord));
	}
	DMChord& operator = (const DMChord& chord)
	{
		memcpy(this, &chord, sizeof(DMChord));
		return *this;
	}
	int BassNote();
	int Third(int * bass);
	int Fifth(int * bass, int * third);
	int Seventh(int* bass, int* third, int* fifth);
	void ChordNotes(int& bass, int& third, int& fifth, int& seventh);
	int NoteCount();	// number of notes in chord
};

// DMPolyChord represents a multi chord
class DMPolyChord
{
public:
	void InitLevels();
	enum { ALL = -1, MAX_POLY = 4, MAX_NAME = 12 };
	DMPolyChord();
	DMPolyChord(const DMPolyChord&);
	DMChord* const	operator[] (int index)
	{
		if(index >= MAX_POLY 
			|| index < 0)
		{
			return 0;
		}
		else
		{
			return &m_Chords[index];
		}
	}
	DMChord* const SubChord(int index)
	{
		if(index >= MAX_POLY 
			|| index < 0)
		{
			return 0;
		}
		else
		{
			return &m_Chords[index];
		}
	}
	DWORD&	Time()
	{
		return m_dwTime;
	}
	DWORD	Time() const
	{
		return m_dwTime;
	}
	short&	Measure()
	{
		return m_nMeasure;
	}
	short Measure() const
	{
		return m_nMeasure;
	}
	BYTE&	Beat()
	{
		return m_bBeat;
	}
	BYTE	Beat() const
	{
		return m_bBeat;
	}
	BYTE&	Flags()
	{
		return m_bFlags;
	}
	BYTE	Flags() const
	{
		return m_bFlags;
	}
	TCHAR* const Name()
	{
		return m_szName;
	}
	DMPolyChord& operator = (const DMPolyChord&);
	enum { INVALID = 255 };	// invalid chord (set root index to this to indicate)
	BYTE& RootIndex()
	{
		return m_bRootIndex;
	}
	void Load(OldChordEntry& oce);
	void Save(OldChordEntry& oce);
	bool& KeyDown() 
	{
		return m_keydown;
	}
	// some convenience funcs for old code
	DMChord* const Base()
	{
		return SubChord(m_bRootIndex);
	}
	DMChord* operator->()
	{
		return Base();
	}

	void SetBase(int v)
	{
		m_bRootIndex = static_cast<BYTE>(v);
	}

	// mass copy functions, from base to other subchords
	void PropagateChordPattern();
	void PropagateScalePattern();
	void PropagateInvertPattern();
	void PropagateLevels();
	void PropagateFlags();
	void PropagateChordRoot();
	void PropagateScaleRoot();
	void PropagateUseFlat();
	void PropagateBits();
	void PropagateInUse();
	void PropagateAll();

protected:
	DMChord	m_Chords[MAX_POLY];
	DWORD	m_dwTime;
	short	m_nMeasure;
	BYTE	m_bBeat;
	BYTE	m_bFlags;
	BYTE	m_bRootIndex;	// identifies which chord in m_Chords is the root
	TCHAR	m_szName[12];
	bool	m_keydown;
};




class ChordSelection : public DWListItem, public DMPolyChord {
public:
            ChordSelection();
    void    SetBits(int nSubChord);		// nSubChord == -1 --> match all subchords
//    void    SetMelody(int nSubChord);        // Converts pattern into melodypattern. 
											// nSubChord == -1 --> match all subchords
    BOOL    Equals(ChordSelection *second, int nSubChord);	// nSubChord == -1 --> match all subchords
    void    GetName(char *string);
    void    RootToString(char *string); // Convert from root to text name.

    void    LoadFile(char *filename);
    void    SaveFile(char *filename);
	void SetChordPattern(DWORD dwPattern, int nSubChord);
	void SetScalePattern(DWORD dwPattern, int nSubChord);
	void SetChordRoot(BYTE root, int nSubChord);
	void SetScaleRoot(BYTE root, int nSubChord);
	void SetUseFlats(BYTE bFlat, int nSubChord);
};


#define ID_CHRD        0x43485244
#define ID_KBRD        0x4B425244

#define CHORD_WIDTH     80
#define CHORD_HEIGHT    26
#define CENTER_X        (CHORD_WIDTH >> 1)
#define CENTER_Y        (CHORD_HEIGHT >> 1)
#define NEXT_HEIGHT     14
#define NEXT_INDENT     10

class Personality;
//class MyFile;
class NextChord;
class SearchInfo;

class NextList : public DWList {
public:
    NextChord *     GetHead() { return(NextChord*)DWList::GetHead();};
    void            ClearList();
    void			Save( IStream *pIStream, BOOL bSmall );
    long            Size(BOOL bSmall);
    void            Load( IStream *pIStream,long lsize);
};

class SmallChordEntry : public DWListItem {
public:
    NextList        m_nextchordlist;// List of chords to go to next.
    ChordSelection  m_chordsel;     // Chord definition.
    unsigned long   m_dwflags;      // Various flags.
    short           m_nid;          // ID for pointer maintenance.
};


//#define SmallChordEntryFileSize  (OldChord - sizeof(DWListItem) + sizeof(unsigned long) + sizeof(short));

#define SmallChordEntryFileSize (OldChordEntry::SizeSmallChordEntry())

class CChordItem;
class CPropChord;
class ChordEntry : public SmallChordEntry {
public:
                    ChordEntry();
                    ~ChordEntry();
    ChordEntry *    GetNext(){ return (ChordEntry *)(DWListItem::GetNext()); };
    void            Save( IStream *pIStream, BOOL bSmall );
    long            Size(BOOL bSmall, long version = 0);
    static ChordEntry * Load( IStream *pIStream,long filesize, long id);
    void            Draw(CDC *pDC,short page);
    void            CleanupNexts();
    NextChord *     ChooseNextChord();
    BOOL            Walk(SearchInfo *search);
	void			LoadSmall(OldChordEntry& oce);
	void			LoadExtended(OldChordEntry& oce);
	void			SaveSmall(OldChordEntry& oce);
	void			SaveExtended(OldChordEntry& oce);
    void            Debug();
    void            AssignParents();
    void            MarkTree();
	void			LoadFromChordItem(CChordItem&);
	void			LoadFromPropChord(CPropChord& chord);
	void			SaveToPropChord(CPropChord& chord);
    struct
	{
		short		left;
		short		top;
		short		right;
		short		bottom;
	} m_rect;
    short           m_page;
	struct
	{
		short		left;
		short		top;
		short		right;
		short		bottom;
	} m_lastrect;
    Personality     *m_parent;      // The parent chord map.
};

//#define ChordEntryFileSize (SmallChordEntryFileSize + (sizeof(short) * 4) + sizeof(short))

#define ChordEntryFileSize (OldChordEntry::SizeExtendedChordEntry())

class ChordEntryList : public DWList {
public:
    ChordEntry *    GetHead() {return(ChordEntry *)DWList::GetHead();};
	ChordEntry *	RemoveHead() {return (ChordEntry *)DWList::RemoveHead();};
};

#define PAGE_1      1
#define PAGE_2      2
#define PAGE_3      4
#define PAGE_4      8
#define PAGE_5      0x10
#define PAGE_6      0x20
#define PAGE_7      0x40
#define PAGE_8      0x80


#define CE_SELECTED 1               // This is the active chord.
#define CE_START    2
#define CE_END      4
#define CE_MEASURE  8
#define CE_PATH     16
#define CE_TREE     32

#define CE_DRAGSELECT		(1 << 9)
#define CE_DROPSELECT		(1 << 10)


class SmallNextChord : public DWListItem {
public:
    ChordEntry      *m_nextchord;   // Destination chord.
    unsigned long   m_dwflags;
    short           m_nweight;      // Importance of destination chord.
    short           m_nminbeats;    // Min beats to wait till chord.
    short           m_nmaxbeats;    // Max beats to wait till chord.
    short           m_nid;          // ID of destination chord.
};

#define SmallNextChordFileSize (sizeof(SmallNextChord) - sizeof(ChordEntry *))

class NextChord : public SmallNextChord {
public:
                    NextChord();
    NextChord *     GetNext() {return(NextChord *)DWListItem::GetNext();};
    BOOL            Walk(SearchInfo *search);
    void            Debug();
    void            MarkTree();
    void            Draw(CDC *pDC,short page);
//    CRect           m_rect;         // Box in display.
	struct
	{
		short		left;
		short		top;
		short		right;
		short		bottom;
	} m_rect;
    ChordEntry      *m_parent;      // Source chord.
};

#define NextChordFileSize (SmallNextChordFileSize + sizeof(ChordEntry *))

#define NC_SELECTED 1               // This is the active connector.
#define NC_PATH     2               // For walking the tree.
#define NC_NOPATH   4               // Failed tree walk.
#define NC_TREE     8               // For displaying a tree.

class TempCommand;
class PlayChord;

class FailSearch {
public:
                    FailSearch()
                    {
                        m_toomanybeats = 0;
                        m_toofewbeats = 0;
                        m_toomanychords = 0;
                        m_toofewchords = 0;
                    }
    short           m_toomanybeats;
    short           m_toofewbeats;
    short           m_toomanychords;
    short           m_toofewchords;
};

class SearchInfo {
public:
                    SearchInfo()
                    {
                        m_pfirstchord = NULL;
                        m_pplaychord = NULL;
                    };
    ChordSelection  m_start;
    ChordSelection  m_end;
    PlayChord *     m_pplaychord;
    ChordEntry *    m_pfirstchord;
    short           m_beats;
    short           m_minbeats;
    short           m_maxbeats;
    short           m_chords;
    short           m_minchords;
    short           m_maxchords;
    short           m_activity;
    FailSearch      m_fail;
};

#define ACTIVITY_SLOW   2
#define ACTIVITY_MEDIUM 1
#define ACTIVITY_FAST   0

class ChordPalette {
public:
                    ChordPalette();
    void            InitChords(BOOL major,BOOL allnotes,BOOL fat,BOOL flat);
    BOOL            LoadFile(char *filename);
    BOOL            SaveFile(char *filename);
	HRESULT			Load(IStream* pStream, long version = 0);
	HRESULT			Save(IStream*, long version = 0);
	static long		Size(long version);
	ChordSelection&	Chord(int i) { return m_chords[i]; }
    ChordSelection  m_chords[24];
};



#define PF_FILL     1           /* Fill pattern.                    */
#define PF_INTRO    2
#define PF_WHOLE    4           /* Handles chords on measures.      */
#define PF_HALF     8           /* Chords every two beats.          */
#define PF_QUARTER  0x10        /* Chords on beats.                 */
#define PF_BREAK    0x20
#define PF_END      0x40
#define PF_A        0x80
#define PF_B        0x100
#define PF_C        0x200
#define PF_D        0x400
#define PF_E        0x800
#define PF_F        0x1000
#define PF_G        0x2000
#define PF_H        0x10000
#define PF_STOPNOW  0x4000
#define PF_INRIFF   0x8000
#define PF_BEATS    (PF_WHOLE | PF_HALF | PF_QUARTER)
#define PF_RIFF     (PF_INTRO | PF_BREAK | PF_FILL | PF_END)
#define PF_GROOVE   (PF_A | PF_B | PF_C | PF_D | PF_E | PF_F | PF_G | PF_H)

#define SP_A        1
#define SP_B        2
#define SP_C        4
#define SP_D        8
#define SP_E        0x10
#define SP_F        0x20
#define SP_LETTER   (SP_A | SP_B | SP_C | SP_D | SP_E | SP_F)
#define SP_1        0x100
#define SP_2        0x200
#define SP_3        0x400
#define SP_4        0x800
#define SP_5        0x1000
#define SP_6        0x2000
#define SP_7        0x4000
#define SP_ROOT     (SP_1 | SP_2 | SP_3 | SP_4 | SP_5 | SP_6 | SP_7)
#define SP_CADENCE  0x8000

// Structure shape:

#define STR_FALLING     1
#define STR_LEVEL       2
#define STR_LOOPABLE    3
#define STR_LOUD        4
#define STR_QUIET       5
#define STR_PEAKING     6
#define STR_RANDOM      7
#define STR_RISING      8
#define STR_SONG        9  

/*
class Template : public DWListItem {
public:
                    Template();
                    ~Template();
    Template *      GetNext() { return(Template *) DWListItem::GetNext();};
    void            Save(MyFile *pfile);
    long            Size();
    static Template *Load(MyFile *pfile,long lsize);
    static Template *LoadFile(char *filename);
    BOOL            SaveFile(char *filename);
    void            CopyInto(Template *);
    void            MakeName(char *string,short max);
    void            CommandsToString(char *string,short max);
    void            ExpandCommands();
    void            CompressCommands();
    void            CreateSignPosts();
    void            CopyCommands(Template *psource,short measure);
    void            CreateEmbellishments(short shape);
    void            AddChord(short nmeasure,DWORD dwchord);
    void            AddCommand(short nmeasure,DWORD dwcommand);
    void            InsertCommand(Command *pcommand,BOOL iscommand);
    void            CutCommands(Template *pdest,short measure,short length);
    void            PasteCommands(Template *psource,short measure);
    short             NextSignPost(short measure,DWORD signpost,short quantize);
    DWORD           GetFirstSignPost();
    void            Dump();
//  void            StringToNodes(char *string,short max);
    char            m_name[20];
    char            m_type[20];
    short           m_measures;
    CommandList     m_commandlist;
};
*/
/*
class TemplateList : public DWList {
public:
                    TemplateList();
    void            ClearList();
    Template *      GetHead() { return (Template *) DWList::GetHead();};
    void            Save(MyFile *pfile);
    long            Size();
    static TemplateList *Load(MyFile *pfile,long lsize);
    static TemplateList *LoadFile(char *filename);
    BOOL            SaveFile(char *filename);
    void            CopyInto(TemplateList *);
    void            CompressCommands();
};
*/

class SignPost : public DWListItem {
public:
	enum { MAX_CADENCE = 2 };
                    SignPost();
    SignPost *      GetNext() {return(SignPost *) DWListItem::GetNext();};
    void            Save( IStream *pIStream );
    static long            Size(long version = 0);
    static SignPost *Load( IStream *pIStream,long lsize);
    void            SaveFile(char *filename);
    static SignPost *LoadFile(char *filename);
    void            MakeName(char *string);
    ChordSelection  m_chord;            // Chord for sign post.
    ChordSelection  m_cadence[MAX_CADENCE];       // Chords for cadence.
    DWORD           m_chords;       // Which kinds of signpost supported.
    DWORD           m_dwflags;
    DWORD           m_tempflags;
};

class SignPostList : public IndexList {
public:
    SignPost *      GetHead() {return(SignPost *) IndexList::GetHead();};
};

#define SPOST_CADENCE1  2   // Use the first cadence chord.
#define SPOST_CADENCE2  4   // Use the second cadence chord.

class PlayChord : public DWListItem {
public:
                    PlayChord();
    PlayChord *     GetNext() {return (PlayChord *)DWListItem::GetNext();};
    ChordSelection *m_pchord;       // Chord to perform.
    NextChord *     m_pnext;        // Transition pointer to chord.
    unsigned long   m_dwflags;
    short           m_measure;
    short           m_beat;
    short           m_minbeats;
    short           m_maxbeats;
};

class PlayList : public DWList {
public:
    void            ClearList();
    PlayChord *     GetHead() {return(PlayChord *) DWList::GetHead();};
};


class PersonalityRef {
public:
    char            m_stylename[20];// Unique name for UI display.
    char            m_name[20];     // Personality name for internal use.
    char            m_filename[9];  // Unique name for file.
    char            m_isdefault;    // Set for default personality.
};

class Personality : public DWListItem {
public:
                    Personality();
                    ~Personality();
    Personality *   GetNext() {return(Personality *)DWListItem::GetNext();};

    void            Save( IStream *pIStream, long version = 0 );	// save just personality
    void			Load( IStream *pIStream,long lsize, long version = 0); // load just personality

    void            SaveRef( IStream *pIStream,BOOL bSmall);
    long			TotalSize(BOOL bSmall, long version = 0);	// includes contained structs
	static long		PersonalitySize(long version = 0);		// just size of this structure
    static Personality *LoadRef( IStream *pIStream,long lsize,BOOL bSmall);
    BOOL            LoadFile(char *filename);
    BOOL            SaveFile(char *filename,BOOL bSmall);
    void            Debug();
    void            AssignParents();
    void            Draw(CDC *pDC,short page);
    void            MarkTree(ChordEntry *pchord);
    BOOL            IsValidChord(ChordEntry *ptest);
    BOOL            IsValidNext(NextChord *ptest);
    void            ClearChordFlags(unsigned long flag);
    void            ClearNextFlags(unsigned long flag);
    ChordEntry *    FindXYChord(CPoint point,short page);
    NextChord *     FindXYNext(CPoint point,short page);
    void            AssignIDs();    // Make sure all chords have IDs.
    void            ResolveConnections(); // Resolve pointers.
    BOOL            Compose(SearchInfo *search);
    BOOL            PlayStart();
    BOOL            PlayNext();
    BOOL            PlayStop();
    BOOL            CalcViewSize();
    BOOL            GetChord(ChordSelection *pchord,DWORD flag,short index);
    short             GetChordCount(DWORD flag);
    short             GetChordIndex(ChordSelection *pcsel,DWORD flag);
    void            InsertChords(short leftedge,DWORD flags);
    void            BuildNeededChords(ChordEntryList *list,DWORD flags);
    ChordEntryList  m_chordlist;    // All chords in the map.
    SignPostList    m_signpostlist; // All available sign posts.
    long            m_scalepattern; // Scale for map.
    char            m_name[20];     // ID Name (not used by application.) Musical Name
    char            m_description[80];
    char			m_username[20]; // Generic name for display.
    ChordPalette    m_chordpalette; // Palette of Chords for static Map.
    unsigned long   m_dwflags;
    PlayList        m_playlist;     // Collection of NextChords for playback.
    ChordEntry *    m_pfirstchord;
    PersonalityRef  m_personref;    // Used to track name and file io.
    short			m_cx;
	short			m_cy;				// CSize           m_size;
};

#define CM_FLAT     1               // Display scale and chords with flats.
#define CM_DEFAULT  2               // Default personality.
#define CM_EMBED    4               // Used in Style Packager.

class PersonalityList : public IndexList {
public:
    Personality *   GetHead() {return(Personality *) IndexList::GetHead();};
    Personality *   GetIndexedItem()
                    {
                        return(Personality *) IndexList::GetIndexedItem();
                    };
    void            ClearList();
};

#define INST_LEAD       0
#define INST_STRINGS    1
#define INST_GUITAR     2
#define INST_PIANO      3
#define INST_BASS       4
#define INST_DRUMS      5


class Instruments : public DWListItem {
public:
                    Instruments();
    Instruments *   GetNext() {return(Instruments *)DWListItem::GetNext();};
    static Instruments * LoadFile(char *filename);
    void            SaveFile(char *filename);
    void            Save( IStream *pIStream );
    long            Size();
    static Instruments * Load( IStream *pIStream,long lsize);
    char            m_name[20];
    unsigned char   m_patch[16];
    char            m_default;
};

class InstrumentsList : public DWList {
public:
    Instruments *   GetHead() {return(Instruments *) DWList::GetHead();};
    void            ClearList();
};

class GrooveName : public DWListItem {
public:
                    GrooveName();
    GrooveName *    GetNext() {return(GrooveName *)DWListItem::GetNext();};
    void            Save( IStream *pIStream );
    long            Size();
    static GrooveName * Load( IStream *pIStream,long lsize);
    char            m_name[20];
    DWORD           m_grooveid;
};

class GrooveNameList : public DWList {
public:
    GrooveName *    GetHead() {return(GrooveName *) DWList::GetHead();};
    void            ClearList();
    void            SetDefaults();
    void            AddGrooveName(char *name,DWORD grooveid);
    GrooveName *    GetGrooveName(DWORD grooveid);
};

/*
class Style {
public:
                    Style();
                    ~Style();
    Personality *   GetPersonality();       // Returns current active Personality.
    void            SetPersonality(short index); // Switch to different Personality.
    void            AddPersonality();       // Create new empty Personality.
    BOOL            LoadFile(char *filename);
    BOOL            SaveFile(char *filename);
    static Style *  Load( IStream *pIStream,long lsize);
    void            Save( IStream *pIStream,BOOL fSmall);
    long            Size(BOOL fSmall);
    BOOL            Merge(char *filename);
    void            MergeSave( IStream *pIStream,BOOL fSmall);
    long            MergeSize(BOOL fSmall);
    PersonalityList m_personalitylist;      // List of Personalitys.
    InstrumentsList m_instrumentslist;  // List of instrument settings.
    GrooveNameList  m_groovenamelist;   // Grooves can have names.
};
*/

/*
class TempCommand : public Command {
public:
    TempCommand *   GetNext() {return(TempCommand *) DWListItem::GetNext();};
    SignPost *      m_psignpost;
    ChordEntry *    m_pfirstchord;
    PlayList        m_playlist;
    SearchInfo      m_searchinfo;
};
*/
/*
class TempCommandList : public DWList {
public:
    TempCommand *   GetHead() {return(TempCommand *) DWList::GetHead();};
    void            ClearList();        // Delete TempCommand list.
};
*/
/*
class ComposeEngine {
public:
                    ComposeEngine();
                    ~ComposeEngine();
    void            SendEvent(BYTE status,BYTE data1,BYTE data2);
    void            ChordOn(ChordSelection *pchord,short channel);
    void            ChordOff(ChordSelection *pchord,short channel);
    void            InsertChordProgression(PlayChord *pnext,LPSCTSECTION psection);
    void            InsertCommandList(Command *pcommand,LPSCTSECTION psection);
    void            SoundCardSetup();
    void            LoadStyle();
    void            CreateSection(Template *ptemp,Personality *pcmap,
                        LPSCTSTYLE pstyle,short activity);
    LPSCTSECTION    ComposeTransition(LPSCTSECTION pstartsection,
                        LPSCTSECTION pendsection,
                        LPSCTSTYLE pstyle,
                        Personality *pperson, short nmeasure, DWORD dwcommandflags, DWORD dwflags);
    void            CreateTransition(Personality *pcmap,LPSCTSTYLE pstyle,
                        ChordSelection *pchord,short measures,DWORD command);
    void            BuildSection(Personality *pcmap,LPSCTSTYLE pstyle,
                        short activity,short structure,short measures,DWORD flags);
    void            SwitchPersonality(Personality *pcmap,BOOL btrackscale);
    void            PlaySection();
    Template *      m_ptemplate;
    Personality *       m_ppersonality;
    PlayList        m_playlist;         // List of chords to play.
    TempCommandList m_commandlist;      //
    LPSCTDATA       m_psctdata;         // SCore dll.
    LPSCTPERFORMANCE m_pperformance;
    LPSCTSECTION    m_psection;         // Section for testing with.
    LPSCTSECTION    m_ptransition;      // Section for testing transitions.
};
*/


class ChordChangeCallback : public IUnknown
{
public:

	ChordChangeCallback() : m_pChordEntry(0), m_callbackType(Unknown), m_dwRef(0) { AddRef();}
	ChordChangeCallback(int ct) : m_pChordEntry(0), m_callbackType(ct), m_dwRef(0) { AddRef();}
	~ChordChangeCallback();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	// callback info determination
	enum   { Unknown, ChordMapNewSelection,  ParentShowProps};

//	void SetCallbackType(CallbackType ct) { m_callbackType = ct; }
	int GetCallbackType() { return m_callbackType; }

	void SetChordEntry(ChordEntry* pChordEntry) {ASSERT(pChordEntry); 
											   m_pChordEntry = pChordEntry;}

	ChordEntry* GetChordEntry() {return m_pChordEntry;}
	
private:
	ChordEntry* m_pChordEntry;
	int m_callbackType;
	DWORD		m_dwRef;
};

//////////////////////////////////////////
// ChordExt Structure
// Used to store a Section's single linked chord list.
// Use: CSection::m_paChordChanges.
class ChordExt	: public DMPolyChord
{
//	bool		m_keydown;
public:
	ChordExt()
	{
		m_keydown = false;
		pNext = 0;
	}
    ChordExt		*pNext;
//	bool& KeyDown()
//	{
//		return m_keydown;
//	}
};

typedef struct CommandExt
{
    CommandExt* pNext;
    long        time;       // Time, in clocks
    short       measure;    // Which measure
    DWORD       command;    // Command type
    DWORD       chord;      // Used by composition engine
} CommandExt;



void ChordEntryToChordExt(ChordEntry* pChordEntry, ChordExt* pChordExt);

#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\ChordInversionPropPage.cpp ===
// ChordInversionPropPage.cpp : implementation file
//

#include "stdafx.h"
#include "..\includes\DMUSProd.h"
#include "..\includes\Conductor.h"
#include "PropChord.h"
#include "PropPageMgr.h"
#include "chordstripmgr.h"
#include "ChordInversionPropPage.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage property page

IMPLEMENT_DYNCREATE(CChordInversionPropPage, CPropertyPage)

CChordInversionPropPage::CChordInversionPropPage() : CPropertyPage(CChordInversionPropPage::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	//{{AFX_DATA_INIT(CChordInversionPropPage)
	//}}AFX_DATA_INIT
	m_pPropPageMgr = NULL;
	m_pIConductor = 0;
	m_pIPerformance = 0;
	m_cRef = 0;
	m_fLockAllScales = true;
	m_fSyncLevelOneToAll = true;
	AddRef();
	m_bValidChord = false;
	m_fNeedToDetach = FALSE;
}

CChordInversionPropPage::~CChordInversionPropPage()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(m_pIConductor)
	{
		m_pIConductor->Release();
	}
	if(m_pIPerformance)
	{
		m_pIPerformance->Release();
	}
}

void CChordInversionPropPage::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChordInversionPropPage)
	DDX_Control(pDX, IDC_KEYS_INVERSIONS4, m_keysinv4);
	DDX_Control(pDX, IDC_KEYS_INVERSIONS3, m_keysinv3);
	DDX_Control(pDX, IDC_KEYS_INVERSIONS2, m_keysinv2);
	DDX_Control(pDX, IDC_KEYS_INVERSIONS1, m_keysinv1);
	DDX_Control(pDX, IDC_KEYS_BASECHORD4, m_keysbase4);
	DDX_Control(pDX, IDC_KEYS_BASECHORD3, m_keysbase3);
	DDX_Control(pDX, IDC_KEYS_BASECHORD2, m_keysbase2);
	DDX_Control(pDX, IDC_KEYS_BASECHORD1, m_keysbase1);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChordInversionPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CChordInversionPropPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_DRAWITEM()
	ON_WM_MEASUREITEM()
	ON_BN_CLICKED(IDC_BUTTON_INVERT1, OnButtonInvert1)
	ON_BN_CLICKED(IDC_BUTTON_INVERT2, OnButtonInvert2)
	ON_BN_CLICKED(IDC_BUTTON_INVERT3, OnButtonInvert3)
	ON_BN_CLICKED(IDC_BUTTON_INVERT4, OnButtonInvert4)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY1, OnButtonIplay1)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY2, OnButtonIplay2)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY3, OnButtonIplay3)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY4, OnButtonIplay4)
	ON_BN_CLICKED(IDC_CHECK_LEGAL1, OnCheckLegal1)
	ON_BN_CLICKED(IDC_CHECK_LEGAL2, OnCheckLegal2)
	ON_BN_CLICKED(IDC_CHECK_LEGAL3, OnCheckLegal3)
	ON_BN_CLICKED(IDC_CHECK_LEGAL4, OnCheckLegal4)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage message handlers



////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage other funcs


/////////////////////////////////////////////////////////////////////////////
// PropPageChord IUnknown
STDMETHODIMP CChordInversionPropPage::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	ASSERT( ppv );
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdMidiInCPt))
	{
        *ppv = (IUnknown *) (IDMUSProdMidiInCPt *) this;
	}
	else
	{
		return E_NOTIMPL;
	}
    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CChordInversionPropPage::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CChordInversionPropPage::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


/////////////////////////////////////////////////////
//// Data transfer
void  CChordInversionPropPage::CopyDataToTab( CPropChord*  pTabData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(pTabData && m_bValidChord)
	{
		*pTabData = m_Chord;
	}
	else
	{
		pTabData = 0;
	}
}

void CChordInversionPropPage::GetDataFromTab( const CPropChord* pTabData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(pTabData)
	{
		m_Chord = *pTabData;
		for(int i = 0; i < m_Chord.MAX_POLY; i++)
		{
			m_invertVector[i].SetChord(m_Chord.SubChord(i)->ChordPattern());
			m_invertVector[i].SetInversion(m_Chord.SubChord(i)->InvertPattern());
		}
		m_bValidChord = true;
	}
	else
	{
		m_bValidChord = false;
	}
}

int CChordInversionPropPage::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}

void CChordInversionPropPage::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}
	CPropertyPage::OnDestroy();	
}

// required to get owner draw controls to paint 
void CChordInversionPropPage::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CPropertyPage::OnDrawItem(nIDCtl, lpDrawItemStruct);
}

void CChordInversionPropPage::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CPropertyPage::OnMeasureItem(nIDCtl, lpMeasureItemStruct);
}

BOOL CChordInversionPropPage::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	
	m_nextinvert4.AutoLoad(IDC_BUTTON_INVERT4, this);
	m_nextinvert3.AutoLoad(IDC_BUTTON_INVERT3, this);
	m_nextinvert2.AutoLoad(IDC_BUTTON_INVERT2, this);
	m_nextinvert1.AutoLoad(IDC_BUTTON_INVERT1, this);

	m_play4.AutoLoad(IDC_BUTTON_IPLAY4, this);
	m_play3.AutoLoad(IDC_BUTTON_IPLAY3, this);
	m_play2.AutoLoad(IDC_BUTTON_IPLAY2, this);
	m_play1.AutoLoad(IDC_BUTTON_IPLAY1, this);

	CPropertyPage::OnInitDialog();
	
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CChordInversionPropPage::OnButtonInvert1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[0].Rotate(m_Chord.SubChord(0)->NoteCount());
	SetChord(&m_Chord, 0);
}

void CChordInversionPropPage::OnButtonInvert2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[1].Rotate(m_Chord.SubChord(1)->NoteCount());
	SetChord(&m_Chord, 1);
}

void CChordInversionPropPage::OnButtonInvert3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[2].Rotate(m_Chord.SubChord(2)->NoteCount());
	SetChord(&m_Chord, 2);
}

void CChordInversionPropPage::OnButtonInvert4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[3].Rotate(m_Chord.SubChord(3)->NoteCount());
	SetChord(&m_Chord, 3);
}

void CChordInversionPropPage::OnButtonIplay1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(0);
}

void CChordInversionPropPage::OnButtonIplay2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(1);	
}

void CChordInversionPropPage::OnButtonIplay3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(2);	
}

void CChordInversionPropPage::OnButtonIplay4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(3);	
}

void CChordInversionPropPage::OnCheckLegal1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL1);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[0].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[0].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(0)->InvertPattern() = m_invertVector[0].GetInvertPattern();
		UpdateChordData();
	}	
}

void CChordInversionPropPage::OnCheckLegal2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL2);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[1].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[1].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(1)->InvertPattern() = m_invertVector[1].GetInvertPattern();
		UpdateChordData();
	}	
}

void CChordInversionPropPage::OnCheckLegal3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL3);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[2].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[2].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(2)->InvertPattern() = m_invertVector[2].GetInvertPattern();
		UpdateChordData();
	}	
	
}

void CChordInversionPropPage::OnCheckLegal4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL4);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[3].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[3].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(3)->InvertPattern() = m_invertVector[3].GetInvertPattern();
		UpdateChordData();
	}	
	
}

void CChordInversionPropPage::UpdateChordData(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject)
	{
		CChordScalePropPageData chordscalePropPageData;

		chordscalePropPageData.m_pPropChord = &m_Chord;
		chordscalePropPageData.m_fLockAllScales = m_fLockAllScales;
		chordscalePropPageData.m_fSyncLevelOneToAll = m_fSyncLevelOneToAll;

		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &chordscalePropPageData);
	}	
}

void CChordInversionPropPage::SetChordData(CChordScalePropPageData* pChordScalePropPageData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pChordScalePropPageData != NULL );
	if( pChordScalePropPageData )
	{
		SetChord( pChordScalePropPageData->m_pPropChord );

		m_fLockAllScales = pChordScalePropPageData->m_fLockAllScales;
		m_fSyncLevelOneToAll = pChordScalePropPageData->m_fSyncLevelOneToAll;
	}
}

void CChordInversionPropPage::SetChord(CPropChord * pChord, int subchord)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	char str[30];
	m_Chord = *pChord;
	
	if( IsWindow( m_hWnd ) == 0 ) return;
	

	if(::IsWindow(m_play4.m_hWnd))
	{

		if(m_Chord.RootIndex() == DMPolyChord::INVALID)
		{
			EnableControls(FALSE);
		}
		else
		{
			EnableControls(TRUE);
		}
	}
	if(pChord->RootIndex() >= DMPolyChord::MAX_POLY) 
		return;	// invalid chord, controls will be blanked out


	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_NAME)
	{
		SetDlgItemText(IDC_EDIT_NAME,"");
	}
	else
	{
		SetDlgItemText(IDC_EDIT_INAME,pChord->Name());
	}
	pChord->RootToString(str, pChord->RootIndex());
	SetDlgItemText(IDC_EDIT_IROOT,str);
//	SetCheckBox(pChord, UD_FLAT, IDC_CHECKBOX_FLATS, pChord->Base()->UseFlat() && 1);
	short nGrayed;
	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_CHORDPATTERN) nGrayed = 4;
	else nGrayed = 0;
	int nX;
	int k0 = subchord == -1 ? 0 : subchord;
	int k1 = subchord == -1 ? CPropChord::MAX_POLY : subchord + 1;
	bool globalset = (subchord == -1);
	
	for(int n = k0; n < k1; n++)
	{
		// clear keyboards
		GetChordKeyboard(n)->ClearKeys();
		GetInversionKeyboard(n)->ClearKeys();

		// determine chord inversions
		int bass,third,fifth, seventh;
		BitFlag bfChord(pChord->SubChord(n)->ChordPattern());
		pChord->SubChord(n)->ChordNotes(bass, third, fifth, seventh);
		int inversion = m_invertStates[n].Get();
		if(inversion >= InversionState::First && third > -1)
		{
			bfChord.ClearBit(bass);
			bfChord.SetBit(bass+12);
		}
		if(inversion >= InversionState::Second && fifth > -1)
		{
			bfChord.ClearBit(third);
			bfChord.SetBit(third+12);
		}
		if(inversion >= InversionState::Third &&  seventh > -1)
		{
			bfChord.ClearBit(fifth);
			bfChord.SetBit(fifth+12);
		}
		DWORD dwChord = bfChord;
		// make sure pattern is tranposed
		dwChord = Rotate24(dwChord, pChord->SubChord(n)->ChordRoot() % 24);

		GetChordKeyboard(n)->Transpose(pChord->SubChord(n)->ChordRoot(), true);
		int shift = (pChord->SubChord(n)->ChordRoot())%24;
		if(globalset)
		{
			// only do this when all keys chords change (ie you've switched to this prop page)
			GetInversionKeyboard(n)->SetLowerBound(shift);
		}
		for (nX = 0; nX < 24; nX++)
		{
			short nState = nGrayed;
			if ((pChord->SubChord(n)->ChordPattern() >> nX) & 1) nState += 2;
			GetChordKeyboard(n)->SetNoteState(nX,"",nState);
			DrawInversionNote(pChord, dwChord, n, nX);
		}
		// finally set check box according to legality of inversion
		m_invertVector[n].SetChord(m_Chord.SubChord(n)->ChordPattern());
		m_invertVector[n].SetInversion(m_Chord.SubChord(n)->InvertPattern());
		CButton* pButton=0;
		switch(n)
		{
		case 0:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL1);
			break;
		case 1:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL2);
			break;
		case 2:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL3);
			break;
		case 3:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL4);
			break;
		}
		if(pButton)
		{
			if(inversion == 0)
			{
				pButton->SetCheck(1);
			}
			else if(m_invertVector[n].GetAllowedInversion(inversion-1))
			{
				pButton->SetCheck(1);
			}
			else
			{
				pButton->SetCheck(0);
			}
		}
	}

}

CKeyboard* CChordInversionPropPage::GetChordKeyboard(int index)
{
		switch(index)
		{
		case 0:
			return &m_keysbase1;			
			break;
		case 1:
			return &m_keysbase2;
			break;
		case 2:
			return &m_keysbase3;
			break;
		case 3:
			return &m_keysbase4;
			break;
		default:
			return 0;
			break;
		}
}

int CChordInversionPropPage::GetChordKeyboardIndex(const CKeyboard * pKeyboard)
{
	int i = 0;
	for(i; i < CPropChord::MAX_POLY; i++)
	{
		if(GetChordKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= CPropChord::MAX_POLY ? -1 : i;

}

CKeyboard* CChordInversionPropPage::GetInversionKeyboard(int index)
{
		switch(index)
		{
		case 0:
			return &m_keysinv1;			
			break;
		case 1:
			return &m_keysinv2;
			break;
		case 2:
			return &m_keysinv3;
			break;
		case 3:
			return &m_keysinv4;
			break;
		default:
			return 0;
			break;
		}

}

int CChordInversionPropPage::GetInversionKeyboardIndex(const CKeyboard * pKeyboard)
{
	int i = 0;
	for(i; i < CPropChord::MAX_POLY; i++)
	{
		if(GetInversionKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= CPropChord::MAX_POLY ? -1 : i;

}


void CChordInversionPropPage::DrawInversionNote(CPropChord* pChord, DWORD dwChordInversion, int index, short nX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	nX += GetInversionKeyboard(index)->LowerBound();
	short nX24 = nX%24;
	short nGrayed;
	if (pChord->GetUndetermined(index) & UD_SCALEPATTERN) nGrayed = 4;
	else nGrayed = 0;

	short nState = nGrayed;
	if ((dwChordInversion >> nX24) & 1) 
		nState += 2;
	GetInversionKeyboard(index)->SetNoteState(nX,"",nState);
}

BOOL CChordInversionPropPage::OnSetActive() 
{
	// TODO: Add your specialized code here and/or call the base class
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// make sure chord in sync from any changes in chordscaleproppage.
	CChordScalePropPageData chordscalePropPageData;
	CChordScalePropPageData* pChordScalePropPageData = &chordscalePropPageData;
	if( SUCCEEDED ( m_pPropPageMgr->m_pIPropPageObject->GetData( (void **)&pChordScalePropPageData ) ) )
	{
		SetChordData(pChordScalePropPageData);
	}
	return CPropertyPage::OnSetActive();
}

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0

#define MIDI_BASEPITCH		48


void CChordInversionPropPage::PlayChordInversion(int index)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if(m_pIConductor == NULL)
	{
		IDMUSProdComponent* pIComponent = NULL;
		if (m_pPropPageMgr->m_pIFramework)
		{
			if( SUCCEEDED ( m_pPropPageMgr->m_pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
			{
				HRESULT hr = pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&m_pIConductor );
				pIComponent->Release();
				if(FAILED(hr))
				{
					ASSERT(FALSE);
					return;
				}

			}
		}
	}
	
	short nX;
	DWORD dwTime = 0;
	ChangePatch(0,0,0,0);

	// determine chord inversions
	int bass,third,fifth, seventh;
	BitFlag bfChord(m_Chord.SubChord(index)->ChordPattern());
	m_Chord.SubChord(index)->ChordNotes(bass, third, fifth, seventh);
	int inversion = m_invertStates[index].Get();
	if(inversion >= InversionState::First && third > -1)
	{
		bfChord.ClearBit(bass);
		bfChord.SetBit(bass+12);
	}
	if(inversion >= InversionState::Second && fifth > -1)
	{
		bfChord.ClearBit(third);
		bfChord.SetBit(third+12);
	}
	if(inversion >= InversionState::Third &&  seventh > -1)
	{
		bfChord.ClearBit(fifth);
		bfChord.SetBit(fifth+12);
	}
	DWORD dwChord = bfChord;
	DWORD root = m_Chord.SubChord(index)->ChordRoot() % 12;

	for (nX = 0; nX < 24; nX++)
	{
		if ((dwChord >> nX) & 1)
		{
			unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX + root);
			PlayNote(0, note, 120, dwTime, CHORDNOTE_DUR);
			dwTime += CHORDNOTE_DUR;
		}
	}
}

HRESULT CChordInversionPropPage::PlayNote(BYTE ch, BYTE key, BYTE vel, DWORD startTime, DWORD dur)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;

	// make sure we have a performance
	if(m_pIPerformance == 0)
	{
		hr = m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIPerformance);
		if(FAILED(hr))
		{
			return hr;
		}
	}

	// Allocate and initialize a PMsg
	DMUS_MIDI_PMSG* pMidi = NULL;
	hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMidi);
	if(FAILED(hr))
	{
		return hr;
	}
	memset(pMidi, 0, sizeof(DMUS_MIDI_PMSG));

	// fill in midi note on
	pMidi->bStatus = 0x90 + (ch&0xf);	// note on
	pMidi->bByte1 = key;
	pMidi->bByte2 = vel;

	REFERENCE_TIME	rtNow;
	m_pIPerformance->GetLatencyTime(&rtNow);
	pMidi->rtTime = startTime * 10000 + rtNow;
	pMidi->dwFlags = DMUS_PMSGF_REFTIME;
	pMidi->dwPChannel = (ch&0xf);
	pMidi->dwVirtualTrackID = 1;
	pMidi->dwType = DMUS_PMSGT_MIDI;

	hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pMidi));

	if(SUCCEEDED(hr))
	{
		// Allocate and initialize a PMsg
		DMUS_MIDI_PMSG* pMidi = NULL;
		hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMidi);
		if(FAILED(hr))
		{
			return hr;
		}
		memset(pMidi, 0, sizeof(DMUS_MIDI_PMSG));
		// fill in midi note off
		pMidi->bStatus = 0x80 + (ch&0xf);	// note on
		pMidi->bByte1 = key;
		pMidi->bByte2 = vel;

		pMidi->rtTime = (startTime + dur)* 10000 + rtNow;
		pMidi->dwFlags = DMUS_PMSGF_REFTIME;
		pMidi->dwPChannel = (ch&0xf);
		pMidi->dwVirtualTrackID = 1;
		pMidi->dwType = DMUS_PMSGT_MIDI;

		hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pMidi));
	}
	
	return hr;
}

HRESULT CChordInversionPropPage::ChangePatch(BYTE ch, BYTE inst, BYTE msb, BYTE lsb)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;

	// make sure we have a performance
	if(m_pIPerformance == 0)
	{
		hr = m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIPerformance);
		if(FAILED(hr))
		{
			return hr;
		}
	}

	// Allocate and initialize a PMsg
	DMUS_PATCH_PMSG* pPatch = NULL;
	hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_PATCH_PMSG), (DMUS_PMSG**)&pPatch);
	if(FAILED(hr))
	{
		return hr;
	}
	memset(pPatch, 0, sizeof(DMUS_PATCH_PMSG));

	// fill in patch
	REFERENCE_TIME	rtNow;
	m_pIPerformance->GetLatencyTime(&rtNow);
	pPatch->byInstrument = inst;
	pPatch->byMSB = msb;
	pPatch->byLSB = lsb;

	pPatch->rtTime = rtNow;
	pPatch->dwFlags = DMUS_PMSGF_REFTIME;
	pPatch->dwPChannel = (ch&0xf);
	pPatch->dwVirtualTrackID = 1;
	pPatch->dwType = DMUS_PMSGT_PATCH;


	hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pPatch));

	return hr;
}

void CChordInversionPropPage::EnableControls(BOOL bEnable)
{
	m_nextinvert4.EnableWindow(bEnable);
	m_nextinvert3.EnableWindow(bEnable);
	m_nextinvert1.EnableWindow(bEnable);
	m_nextinvert2.EnableWindow(bEnable);

	m_play4.EnableWindow(bEnable);
	m_play3.EnableWindow(bEnable);
	m_play2.EnableWindow(bEnable);
	m_play1.EnableWindow(bEnable);

	GetDlgItem(IDC_CHECK_LEGAL1)->EnableWindow(bEnable);
	GetDlgItem(IDC_CHECK_LEGAL2)->EnableWindow(bEnable);
	GetDlgItem(IDC_CHECK_LEGAL3)->EnableWindow(bEnable);
	GetDlgItem(IDC_CHECK_LEGAL4)->EnableWindow(bEnable);

	if(!bEnable)
	{
		// grey out keyboard
		for(short i = 0; i < 48; i++)
		{
			short nState = 4;
			m_keysinv4.SetNoteState(i,"",nState);
			m_keysinv3.SetNoteState(i,"",nState);
			m_keysinv2.SetNoteState(i,"",nState);
			m_keysinv1.SetNoteState(i,"",nState);
			m_keysbase4.SetNoteState(i,"",nState);
			m_keysbase3.SetNoteState(i,"",nState);
			m_keysbase2.SetNoteState(i,"",nState);
			m_keysbase1.SetNoteState(i,"",nState);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\Chord.cpp ===
//	chord.cpp

#include "stdafx.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stddef.h>
#include <ctype.h>
#include <time.h>
#include "chord.h"
#include "chordio.h"
#include "propchord.h"
#include "RiffStrm.h"

/*
#ifndef CHORDMAP
#pragma pack(6)
#endif
*/

DWORD OldChordEntry::SizeExtendedChordEntry()
{
	return sizeof(OldChordEntry);
}
DWORD OldChordEntry::SizeSmallChordEntry()
{
	return SizeExtendedChordEntry() - 5*sizeof(short);
}
DWORD OldChordEntry::SizeChordSelection()
{
	return SizeExtendedChordEntry() - (5*sizeof(short) + sizeof(short) + sizeof(DWORD));
}

DMChord::DMChord()
{
	m_dwChordPattern = 0x91;
	m_bChordRoot = 12;
	m_bScaleRoot = 0;
	m_bFlat = FALSE;
	m_bBits = 3 | CHORD_INVERT | CHORD_SIMPLE;
	m_wFlags =0;
	m_dwScalePattern = 0xAB5AB5;
	m_dwLevels = ~(unsigned)0;	// all levels
	m_bInUse = false;
	m_dwInvertPattern = ~(unsigned)0;
}

int DMChord::BassNote()
{
	int retval = -1;
	for(int i = 0; i < 24; i++)
	{
		if(m_dwChordPattern & (1 << i))
		{
			retval = i;
			break;
		}
	}
	return retval;
}

int DMChord::Third(int* bass)
{
	int third = -1;
	int bassnote = BassNote();

	if(bassnote != third)
	{
		for(int i = bassnote + 1; i < 24; i++)
		{
			if(m_dwChordPattern & (1 << i))
			{
					third = i;
					break;
			}
		}
	}

	if(bass)
	{
		*bass = bassnote;
	}
	return third;
}

int DMChord::Fifth(int* bass, int* third)
{
	int fifth = -1;
	int thirdnote = Third(bass);

	if(thirdnote != fifth)
	{
		for(int i = thirdnote+1; i < 24; i++)
		{
			if(m_dwChordPattern & (1 << i))
			{
					fifth = i;
					break;
			}
		}
	}

	if(third)
	{
		*third = thirdnote;
	}
	return fifth;
}

int DMChord::Seventh(int* bass, int* third, int* fifth)
{
	int seventh = -1;
	int fifthnote = Fifth(bass, third);

	if(fifthnote != seventh)
	{
		for(int i = fifthnote+1; i < 24; i++)
		{
			if(m_dwChordPattern & (1 << i))
			{
				seventh = i;
				break;
			}
		}
	}

	if(fifth)
	{
		*fifth = fifthnote;
	}
	return seventh;
}

void DMChord::ChordNotes(int& bass, int& third, int& fifth, int& seventh)
{
	seventh = Seventh(&bass, &third, &fifth);
}

int DMChord::NoteCount()
{
	int count  = 0;
	for(int i = 0; i < 24; i++)
	{
		if(m_dwChordPattern & (1 << i))
		{
			++count;
		}
	}
	return count;
}

DMPolyChord::DMPolyChord()
{
	strcpy(m_szName, _T("M"));
	m_dwTime = 0;
	m_nMeasure = 0;
	m_bBeat = 0;
	m_bFlags = 0;
	m_bRootIndex = 0;
	m_keydown = false;
	InitLevels();
}

DMPolyChord::DMPolyChord(const DMPolyChord& poly)
{
	memcpy(this, &poly, sizeof(DMPolyChord));
}

DMPolyChord& DMPolyChord::operator = (const DMPolyChord& poly)
{
	memcpy(this, &poly, sizeof(DMPolyChord));
	return *this;
}

void DMPolyChord::Load(OldChordEntry& oce)
{
	m_dwTime = oce.time;
	m_nMeasure = oce.measure;
	m_bBeat = oce.beat;
	strcpy(m_szName, _T(oce.name));
	m_keydown = oce.keydown ? true : false;
	m_bRootIndex = 0;
	DMChord* pChord = 0;

	// old chords are single level, bottom 4 notes = level 1 (bass), top 4 notes = level two (upper).
	DWORD bass = 0, upper = 0;
	DWORD cbass = 4, cupper = 4;
	int bits = sizeof(DWORD) * 8;	// should be 32
	for(int j = 0; j < sizeof(DWORD)*8; j++)
	{
		if( (oce.pattern & (1 << j)) && cbass > 0)
		{
			--cbass;
			bass |= (1 << j);
		}
		if( (oce.pattern & (1 << (bits - 1 - j))) && cupper > 0)
		{
			--cupper;
			upper |= 1 << (bits - 1 - j);
		}
	}

	// now fill in rest of chord information
	for(int i = 0; i < MAX_POLY; i++)
	{
		pChord = (*this)[i];
		pChord->ChordRoot() = oce.root;
//		pChord->ScaleRoot() = oce.root;
		pChord->ScaleRoot() = 0;
		switch(i)
		{
		case 0:	// bass chord
			pChord->ChordPattern() = bass;
			pChord->InUse() = true;
			break;
		case 1: // upper chord
			pChord->ChordPattern() = upper;
			break;
		default:	// rest of the levels
			pChord->ChordPattern() = oce.pattern;
			break;
		}
		pChord->ScalePattern() = oce.scalepattern;
		pChord->Flags() = oce.varflags;
		pChord->UseFlat() = oce.flat;
		pChord->Bits() = oce.bits;
		pChord->InUse() = false;
	}
	InitLevels();
}

void DMPolyChord::Save(OldChordEntry& oce)
{
	oce.time = m_dwTime;
	oce.measure = m_nMeasure;
	oce.beat = m_bBeat;

	ASSERT(sizeof(m_szName) == sizeof(oce.name));	// catch wide char conversion

	strcpy(oce.name, m_szName);
	oce.keydown = m_keydown;
	DMChord* pChord = SubChord(m_bRootIndex);
	oce.root = pChord->ChordRoot();
	oce.pattern = pChord->ChordPattern();
	oce.varflags = pChord->Flags();
	oce.flat = pChord->UseFlat();
	oce.bits = pChord->Bits();
	oce.scalepattern = pChord->ScalePattern();
	oce.melodypattern = 0;
	oce.inscale = InScale(oce.root, oce.pattern, oce.scalepattern);
}

	// mass copy functions, from base to other subchords
void DMPolyChord::PropagateChordPattern()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].ChordPattern() = m_Chords[root].ChordPattern();
	}
}

void DMPolyChord::PropagateScalePattern()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].ScalePattern() = m_Chords[root].ScalePattern();
	}
}

void DMPolyChord::PropagateInvertPattern()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].InvertPattern() = m_Chords[root].InvertPattern();
	}
}

void DMPolyChord::PropagateLevels()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].Levels() = m_Chords[root].Levels();
	}
}

void DMPolyChord::PropagateFlags()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].Flags() = m_Chords[root].Flags();
	}
}

void DMPolyChord::PropagateChordRoot()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].ChordRoot() = m_Chords[root].ChordRoot();
	}
}

void DMPolyChord::PropagateScaleRoot()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].ScaleRoot() = m_Chords[root].ScaleRoot();
	}
}

void DMPolyChord::PropagateUseFlat()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].UseFlat() = m_Chords[root].UseFlat();
	}
}

void DMPolyChord::PropagateBits()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].Bits() = m_Chords[root].Bits();
	}
}
void DMPolyChord::PropagateInUse()
{
	int root = static_cast<int>(m_bRootIndex);
	for(int i = 0; i < MAX_POLY; i++)
	{
		if(i == root)
			continue;
		m_Chords[i].InUse() = m_Chords[root].InUse();
	}
}

void DMPolyChord::PropagateAll()
{
	PropagateChordPattern();
	PropagateScalePattern();
	PropagateInvertPattern();
	PropagateLevels();
	PropagateFlags();
	PropagateChordRoot();
	PropagateScaleRoot();
	PropagateUseFlat();
	PropagateBits();
	PropagateInUse();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

void swaplong(char data[])
{
    char temp;
    temp = data[0];
    data[0] = data[3];
    data[3] = temp;
    temp = data[1];
    data[1] = data[2];
    data[2] = temp;
}

void WriteID( IStream *pIStream, DWORD id )
{
	pIStream->Write( &id, 4, NULL );
}

void WriteSize( IStream *pIStream, long size )
{
	swaplong((char *)&size);
	pIStream->Write( &size, 4, NULL );
}

long ReadID( IStream *pIStream )
{
	DWORD	dwTemp;
	long	lID;
	
	pIStream->Read( &lID, 4, &dwTemp );
	return lID;
}

long ReadSize( IStream *pIStream )
{
    long	lTemp,
			lSize;
	
	pIStream->Read( &lSize, 4, (DWORD*)&lTemp );
	swaplong( (char*)&lSize );

	return lSize;
}


void ChordSelection::SetBits(int nSubChord)

{
	if(nSubChord >= MAX_POLY)
	{
		return;	// out of range
	}

	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		LONG    i ;
		short   count = 0 ;

		for( i=0L ;  i<32L ;  i++ ) {
			if( m_Chords[k].ChordPattern() & (1L << i) )
				count++ ;
		}
		
		if( !m_Chords[k].Bits() ) {
			m_Chords[k].Bits() |= CHORD_INVERT ;
			if( count > 3 )
				m_Chords[k].Bits() |= CHORD_FOUR ;
			if( m_Chords[k].ChordPattern() & (15L << 18L) )
				m_Chords[k].Bits() |= CHORD_UPPER ;
		}
		m_Chords[k].Bits() &= ~CHORD_COUNT ;
		m_Chords[k].Bits() |= count ;
	}
}

void ChordSelection::SetChordPattern(DWORD dwPattern, int nSubChord)
{
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		m_Chords[k].ChordPattern() = dwPattern;
	}
}

void ChordSelection::SetScalePattern(DWORD dwPattern, int nSubChord)
{
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		m_Chords[k].ScalePattern() = dwPattern;
	}
}

void ChordSelection::SetChordRoot(BYTE root, int nSubChord)
{
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		m_Chords[k].ChordRoot() = root;
	}
}

void ChordSelection::SetScaleRoot(BYTE root, int nSubChord)
{
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		m_Chords[k].ScaleRoot() = root;
	}
}

void ChordSelection::SetUseFlats(BYTE bFlat, int nSubChord)
{
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int k = nBegin; k < nEnd; k++)
	{
		m_Chords[k].ScaleRoot() = bFlat;
	}
}


ChordSelection::ChordSelection()
{
}

BOOL ChordSelection::Equals(ChordSelection *second, int nSubChord)

{
	if(nSubChord >= MAX_POLY)
	{
		return FALSE;	// out of range
	}

	BOOL bMatch = TRUE;
	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? MAX_POLY : nSubChord + 1;
	for( int i = nBegin; bMatch && i < nEnd; i++)
	{
		if(!m_Chords[i].InUse())
		{
			// dont match empty chords
			continue;
		}
		char a = m_Chords[i].ChordRoot();
		char b = second->m_Chords[i].ChordRoot();
		while (a > 11) a -= 12;
		while (b > 11) b -= 12;
		bMatch = ((m_Chords[i].ChordPattern() == second->m_Chords[i].ChordPattern()) && (a == b));
	}
	return bMatch;
}


static char *convert[] = {"C","C#","D","D#","E","F","F#","G","G#","A","A#","B"};
static char *flatconvert[] = {"C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"};

void ChordSelection::RootToString(char *string)
{
	int nSubChord = (int)m_bRootIndex;
	char note = (char)( m_Chords[nSubChord].ChordRoot() % 12 );
	if( m_Chords[nSubChord].UseFlat() )
		wsprintf( string,"%d %s",1 + (m_Chords[nSubChord].ChordRoot() / 12), (LPSTR)flatconvert[note] ) ;
	else
		wsprintf( string,"%d %s",1 + (m_Chords[nSubChord].ChordRoot() / 12), (LPSTR)convert[note] ) ;
}

void ChordSelection::GetName(char *string)
{
	char root[20];
	RootToString(root);
	wsprintf(string,"%s %s",root,m_szName);
}



ChordPalette::ChordPalette()
{
	InitChords(TRUE,FALSE,FALSE,FALSE);
}

static void autochord(ChordSelection *pchord, short type, short index, int nSubChord)

{


	static long chordpatternarray[8] = {
		0x91,0x89,0x49,0x891,0x491,0x489,0x249,0x449
	};
	static char *namearray[8] = {
		"M","m","o","M7","7","m7","o7",""
	};
	char maj3table[12] = { 0,0,1,0,1,0,0,0,0,1,0,2 } ;
	char min3table[12] = { 1,0,2,0,2,1,2,0,0,2,0,2 } ;
	char maj4table[12] = { 3,6,5,6,5,3,6,4,6,5,3,6 } ;
	char min4table[12] = { 1,3,6,0,6,5,6,4,3,7,4,6 } ;
	static long  scalearray[4][12] = {
		{	0xAB5AB5,0x36B36B,0xAB5AB5,0x5AD5AD,0xAB5AB5,0xAB5AB5, 
			0xD6AD6A,0xAB5AB5,0x9AD9AD,0xAB5AB5,0x5AD5AD,0xAB5AB5  },//Maj3 
	
		{	0x9AD9AD,0x96B96B,0x9AD9AD,0x9AD9AD,0x6B56B5,0x9AD9AD, 
			0xB6DB6D,0x9AD9AD,0x9AD9AD,0x6AD6AD,0x5AD5AD,0x9AD9AD  },//min3

		{	0xAB5AB5,0x6B36B3,0xAB5AB5,0x6CD6CD,0xAB5AB5,0xAB5AB5, 
			0xB69B69,0xAB5AB5,0x9AD9AD,0xAB5AB5,0x5AD5AD,0xAB5AB5  },//Maj4
	
		{	0x9AD9AD,0x96B96B,0x9AD9AD,0x9AD9AD,0x59B59B,0x9AD9AD, 
			0xB6DB6D,0x9AD9AD,0x9AD9AD,0x6AD6AD,0x5AD5AD,0x9AD9AD  },//min4
	} ;

	int nBegin = nSubChord < 0 ? 0 : nSubChord;
	int nEnd = nSubChord < 0 ? DMPolyChord::MAX_POLY : nSubChord + 1;
	ChordSelection& chord = *pchord;
	for( int i = nBegin; i < nEnd; i++)
	{
		chord[i]->ScalePattern() = scalearray[type][index];
		if( type == 0 ) {        // major triads.
			index = maj3table[index];
		}
		else if( type == 1 ) {        // minor triads.
			index = min3table[index];
		}
		else if( type == 2 ) {        // major sevenths.
			index = maj4table[index];
		}
		else 
		{ 
			index = min4table[index];
		}
		strcpy(chord.Name(),namearray[index]);
		chord[i]->ChordPattern() = chordpatternarray[index];
	}
}  

void ChordPalette::InitChords(BOOL major,BOOL allnotes,BOOL fat,BOOL flat)

{
	short key;
	short index;
	short type;
	long pattern;
	if (fat) type = 2;
	else type = 0;
	if (major) 
	{
		pattern = 0xAB5AB5; 
	}
	else
	{
		pattern = 0x9AD9AD; 
		type++;
	}
	for( key = 0;  key < 24;  key++ ) 
	{
		index = (short)(key % 12);
		if( pattern & (1 << index)) 
		{
			autochord(&m_chords[key], type, index, DMPolyChord::ALL ) ;
		}
		else if (allnotes) 
		{
			autochord(&m_chords[key], type, index, DMPolyChord::ALL ) ;
		}
		else  {
			*m_chords[key].Name() = 0;
			m_chords[key].SetChordPattern(1, DMPolyChord::ALL);
		}
		m_chords[key].SetChordRoot((char) key, DMPolyChord::ALL);
		m_chords[key].SetScaleRoot((char) key, DMPolyChord::ALL);
		m_chords[key].SetUseFlats((char) flat, DMPolyChord::ALL);
		m_chords[key].SetBits(DMPolyChord::ALL);
	}
} 

ChordEntry::ChordEntry()

{
	DWListItem();
	m_nid = 0;
	m_dwflags = 0;
	m_parent = 0;
	m_page = 0;
	m_nextchordlist.RemoveAll();
}   

void ChordEntry::LoadSmall(OldChordEntry& oce)
{
	m_nid = oce.nid;
	m_dwflags = oce.dwflags;
	m_chordsel.Load(oce);
}

void ChordEntry::LoadExtended(OldChordEntry& oce)
{
	m_page = oce.page;
	memcpy(&m_rect, &oce.rect, sizeof(m_rect));
	LoadSmall(oce);
}

void ChordEntry::LoadFromPropChord(CPropChord& chord)
{
	dynamic_cast<DMPolyChord&>(const_cast<ChordEntry*>(this)->m_chordsel) = chord;
	m_dwflags = 0;
}

void ChordEntry::SaveToPropChord(CPropChord& chord)
{
	dynamic_cast<DMPolyChord&>(chord) = dynamic_cast<DMPolyChord&>(const_cast<ChordEntry*>(this)->m_chordsel);
}

void ChordEntry::LoadFromChordItem(CChordItem& chord)
{
	m_chordsel.KeyDown() = chord.IsSelected() ? true : false;
	LoadFromPropChord(dynamic_cast<CPropChord&>(chord));
	if(chord.IsSignPost())
	{
		if(chord.Measure() == 0)
		{
			m_dwflags |= CE_START;
		}
		else
		{
			m_dwflags |= CE_END;
		}
	}
}


void ChordEntry::SaveSmall(OldChordEntry& oce)
{
	oce.nid = m_nid;
	oce.dwflags = m_dwflags;
	m_chordsel.Save(oce);
}

void ChordEntry::SaveExtended(OldChordEntry& oce)
{
	oce.page = m_page;
	memcpy(&oce.rect, &m_rect, sizeof(m_rect));
	SaveSmall(oce);
}

void ChordEntry::Debug()

{
	NextChord *pnext = m_nextchordlist.GetHead();
	TRACE("ChordEntry %ls: \n",m_chordsel.Name());
	for (;pnext;)
	{
		pnext->Debug();
		pnext = pnext->GetNext();
	}
}

void ChordEntry::AssignParents()

{
	NextChord *pnext = m_nextchordlist.GetHead();
	for (;pnext;)
	{
		pnext->m_parent = this;
		pnext = pnext->GetNext();
	}
}

ChordEntry::~ChordEntry()

{
	m_nextchordlist.ClearList();
}

void ChordSelection::SaveFile(char * /*filename*/)

{
	ASSERT(FALSE);
}

void ChordSelection::LoadFile(char * /*filename*/)

{
	ASSERT(FALSE);
}


void ChordEntry::CleanupNexts()

{
	NextChord *pnext = m_nextchordlist.GetHead();
	BOOL gotone = 0;
	CRect rect( m_rect.left, m_rect.top, m_rect.right, m_rect.bottom );
	rect.left += NEXT_INDENT;
	rect.bottom = rect.top;
	rect.top -= NEXT_HEIGHT;  
	for (;pnext;pnext = pnext->GetNext())
	{
		if (pnext->m_nextchord == NULL) gotone = TRUE;
		pnext->m_rect.left = (short)rect.left;
		pnext->m_rect.top = (short)rect.top;
		pnext->m_rect.right = (short)rect.right;
		pnext->m_rect.bottom = (short)rect.bottom;
		rect.bottom -= NEXT_HEIGHT;
		rect.top -= NEXT_HEIGHT;
	}
	if (gotone) return;
	pnext = new NextChord;
	if (pnext)
	{
		m_nextchordlist.AddTail(pnext);
		pnext->m_rect.left = (short)rect.left;
		pnext->m_rect.top = (short)rect.top;
		pnext->m_rect.right = (short)rect.right;
		pnext->m_rect.bottom = (short)rect.bottom;
		pnext->m_parent = this;
	}
}

void ChordEntry::Draw(CDC *pDC,short page)

{ 
	CPen *pOldPen;
	CPen pen;
	CBrush brush;
	CFont font;
	CFont *oldfont;
	NextChord *pnext;
	char string[50];
	if (page & m_page)
	{
		pnext = m_nextchordlist.GetHead();
		for (;pnext;pnext = pnext->GetNext())
		{
			pnext->Draw(pDC,page);
		}
		if (m_dwflags & CE_SELECTED) 
		{
			if (!pen.CreatePen(PS_SOLID,1,RGB(0xFF,0,0))) return; 
		} 
		else if (m_dwflags & CE_PATH)
		{ 
			if (!pen.CreatePen(PS_SOLID,1,RGB(0,0,0xFF))) return;   
		}
		else if (m_dwflags & CE_TREE)
		{ 
			if (!pen.CreatePen(PS_SOLID,1,RGB(0x77,0,0x77))) return;   
		}
		else 
		{ 
			if (!pen.CreatePen(PS_SOLID,1,RGB(0,0,0))) return;   
		}
		pOldPen = pDC->SelectObject(&pen);
		pDC->MoveTo(m_rect.left,m_rect.top);
		pDC->LineTo(m_rect.right,m_rect.top);
		pDC->LineTo(m_rect.right,m_rect.bottom);
		pDC->LineTo(m_rect.left,m_rect.bottom);
		pDC->LineTo(m_rect.left,m_rect.top);
		if (font.CreateFont(14,0,0,0,0,0,0,0,0,0,0,0,0,0))
		{
			oldfont = pDC->SelectObject(&font);
			strcpy(string, m_chordsel.Name());
			pDC->TextOut(m_rect.left + 4,m_rect.bottom - 2,string,strlen(string)); 
			pDC->SelectObject(oldfont);
		}      
	//	if (brush.CreateSolidBrush(RGB(0,0,0xFF)))
	//	{
	//		CBrush *pOldBrush;
	//		pOldBrush = pDC->SelectObject(&brush);
			if (m_dwflags & CE_MEASURE)
				pDC->Ellipse(m_rect.right - 14,m_rect.bottom - 4,
							m_rect.right - 4,m_rect.bottom - 14);  
			if (m_dwflags & CE_START)  
			{
				pDC->MoveTo(m_rect.left,(m_rect.top + m_rect.bottom) >> 1);
				pDC->LineTo(m_rect.left + CENTER_Y,m_rect.top); 
			}
			if (m_dwflags & CE_END)  
			{
				pDC->MoveTo(m_rect.right,(m_rect.top + m_rect.bottom) >> 1);
				pDC->LineTo(m_rect.right - CENTER_Y,m_rect.top); 
			}
	//		pDC->SelectObject(pOldBrush);
	//	}
		pDC->SelectObject(pOldPen);
	}
}

void NextChord::Draw(CDC *pDC,short page)

{ 
	CPen *pOldPen;
	CPen pen;
	CBrush brush;
	CFont font;
	CFont *oldfont;
	short cx,cy;
	if (m_dwflags & NC_SELECTED) 
	{
		if (!pen.CreatePen(PS_SOLID,1,RGB(0xFF,0,0))) return; 
	} 
	else if (m_dwflags & NC_TREE) 
	{
		if (!pen.CreatePen(PS_SOLID,1,RGB(0x77,0,0x77))) return; 
	} 
	else 
	{ 
		if (!pen.CreatePen(PS_SOLID,1,RGB(0,0,0))) return;   
	}
	pOldPen = pDC->SelectObject(&pen);
	pDC->MoveTo(m_rect.right,m_rect.bottom);
	pDC->LineTo(m_rect.right,m_rect.top);
	pDC->LineTo(m_rect.left,m_rect.top);
	pDC->LineTo(m_rect.left,m_rect.bottom);
	if (m_nextchord)
	{
		cx = (short)(m_rect.right - 6);
		cy = (short)((m_rect.top + m_rect.bottom) >> 1);
		pDC->Ellipse(cx - 3,cy - 3,cx + 3, cy + 3);
		if (m_nextchord->m_page & page)
		{
			pDC->MoveTo(cx,cy);
			pDC->LineTo(m_nextchord->m_rect.left,
				(m_nextchord->m_rect.top + m_nextchord->m_rect.bottom) >> 1); 
		}
		if (brush.CreateSolidBrush(RGB(0,0,0)))
		{
			CBrush *pOldBrush; 
			short w = (short)(m_nweight * (m_rect.right - m_rect.left - (CHORD_WIDTH >> 1)));
			w /= 101;
			pOldBrush = pDC->SelectObject(&brush);
			pDC->Rectangle(m_rect.left + 3,m_rect.top + 3,
				m_rect.left + 3 + w,m_rect.bottom - 3);
			pDC->SelectObject(pOldBrush);
		}		
		if (font.CreateFont(10,0,0,0,0,0,0,0,0,0,0,0,0,0))
		{
			char string[20];
			oldfont = pDC->SelectObject(&font);
			wsprintf(string,"%d:%d",m_nminbeats,m_nmaxbeats);
			cx = (short)(m_rect.right - (CHORD_WIDTH >> 1) + 3);
			pDC->TextOut(cx,m_rect.bottom - 2,string,strlen(string)); 
			pDC->SelectObject(oldfont);
		} 
	}        
	pDC->SelectObject(pOldPen);
}

void NextChord::Debug()

{
	TRACE("NextChord: Flags: %lx, ",m_dwflags);
	if (m_nextchord) TRACE("Connecting to %ls\n",m_nextchord->m_chordsel.Name());
	else TRACE("No connection\n");
}

NextChord::NextChord()

{
	DWListItem();
	m_nextchord = NULL;
	m_nid = 0;
	m_dwflags = 0; 
	m_nweight = 50;
	m_nminbeats = 1;
	m_nmaxbeats = 12; 
}



long totalnext = 0;

void NextList::Save( IStream *pIStream, BOOL bSmall )
{
	NextChord *pnext = GetHead();
	long size;
	if( bSmall )
	{
		size = SmallNextChordFileSize; 
		WriteID( pIStream, ID_NEXTLIST );
	}
	else
	{
	    size = NextChordFileSize;
		WriteID( pIStream, ID_ENEXTLIST );
	}
	WriteSize( pIStream, Size(bSmall) );
	WriteSize( pIStream, size );
	for (;pnext;pnext = pnext->GetNext())
	{
		if( bSmall )
		{
			if (!pnext->m_nextchord) continue;
		}
		pIStream->Write( (void *)&pnext->m_dwflags, (short)size, NULL );
		totalnext++;
	}
}

long NextList::Size(BOOL bSmall)

{
	NextChord *pnext = GetHead();
	long size = 4;
	if( bSmall )
	{
		for (;pnext;pnext = pnext->GetNext())
		{
			if (pnext->m_nextchord) size += SmallNextChordFileSize;
		}
	}
	else size += (GetCount() * NextChordFileSize);
	return(size);
}

void NextList::Load( IStream *pIStream,long lsize)

{
	long lrecordsize = ReadSize( pIStream );
	lsize -= 4;
	ClearList();
	for (;lsize > 0;)
	{
		NextChord *pnext = new NextChord;
		if (pnext)
		{
			pIStream->Read( &pnext->m_dwflags, NextChordFileSize, NULL );
			pnext->SetNext(NULL);
			AddTail(pnext);
		}
		else
		{
			StreamSeek( pIStream, lrecordsize, STREAM_SEEK_CUR );
		}
		lsize -= lrecordsize;
	}
}

void NextList::ClearList()

{
	NextChord *pnext = GetHead();
	for (;pnext;)
	{
		NextChord *next = pnext->GetNext();
		delete pnext;
		pnext = next;	
	}
	RemoveAll();
}

void ChordEntry::Save( IStream *pIStream, BOOL bSmall )
{
	OldChordEntry oce;
	if (bSmall)
	{
		WriteID( pIStream, ID_CHORDENTRY );
		WriteSize( pIStream, Size(bSmall) );
		WriteSize( pIStream, SmallChordEntryFileSize );
		SaveSmall(oce);
		pIStream->Write( &oce, SmallChordEntryFileSize, NULL ); 
	}
	else 
	{
		WriteID( pIStream, ID_ECHORDENTRY );
		WriteSize( pIStream, Size(bSmall) );
		WriteSize( pIStream, ChordEntryFileSize );
		SaveExtended(oce);
		pIStream->Write( &oce, ChordEntryFileSize, NULL );
	}
	m_nextchordlist.Save( pIStream,bSmall );
}


long ChordEntry::Size(BOOL bSmall, long version)
{
	if(version == ID_DMCHORDENTRY)
	{
		ASSERT(FALSE);	// not implemented yet
		return 0;
	}
	else
	{
		long lsize = 0; 
		lsize += 4;						// Size of record field. 
		if (bSmall) lsize += SmallChordEntryFileSize;
		else lsize += (ChordEntryFileSize);  
		lsize += (m_nextchordlist.Size(bSmall) + 8);
		return(lsize);
	}
}

ChordEntry *ChordEntry::Load( IStream *pIStream,long lfilesize, long id)

{
	ChordEntry *pchord = new ChordEntry;
	long lrecordsize = ReadSize( pIStream );
	lfilesize -= 4;
	if (pchord)
	{
		if(id == ID_DMCHORDENTRY)
		{
			ASSERT(FALSE);	// not implemented
		}
		else
		{
			OldChordEntry oce;
			pIStream->Read( &oce, lrecordsize, NULL );
			if(id == ID_ECHORDENTRY)
			{
				pchord->LoadExtended(oce);
			}
			else
			{
				pchord->LoadSmall(oce);
			}
			lfilesize -= lrecordsize;
			pchord->m_nextchordlist.RemoveAll();
			for (;lfilesize > 0;)
			{
				long dwid = ReadID( pIStream );
				lrecordsize = ReadSize( pIStream );
				lfilesize -= 8;
				if (dwid == ID_ENEXTLIST)
				{
					pchord->m_nextchordlist.Load(pIStream,lrecordsize);
				}
				else if (dwid == ID_NEXTLIST)
				{
					pchord->m_nextchordlist.Load(pIStream,lrecordsize);
				}
				else
				{
					StreamSeek( pIStream, lrecordsize, STREAM_SEEK_CUR );
				}
				lfilesize -= lrecordsize;
			}
		}
		if (lfilesize) TRACE("ERROR: Chord read leaves filesize at %ld\n",
			lfilesize);
	}
	else
	{
		StreamSeek( pIStream, lfilesize, STREAM_SEEK_CUR );
	}
	return(pchord);		
}

void Personality::SaveRef( IStream *pIStream,BOOL bSmall)

{ 
	if (bSmall) WriteID( pIStream, ID_PERSONREF ); 
	else WriteID( pIStream, ID_EPERSONREF );
	strcpy(m_personref.m_name,m_name);  
	if (bSmall) m_personref.m_isdefault = (char) (CM_DEFAULT & m_dwflags);
	else m_personref.m_isdefault = (char)((CM_DEFAULT | CM_EMBED) & m_dwflags);
	pIStream->Write( &m_personref, sizeof(PersonalityRef), NULL );
}

static char drivename[_MAX_DRIVE];
static char dirname[_MAX_DIR];

void SignPost::Save( IStream *pIStream )

{
	WriteID( pIStream, ID_SIGNPOST );
	WriteSize( pIStream, Size() );
	OldChordEntry oce;

	WriteSize( pIStream, 0L);	// must write space for signpost's DWListItem pointer

	WriteSize( pIStream, 0L);	// must write space for chord's DWListItem pointer
	m_chord.Save(oce);
	DWORD size = OldChordEntry::SizeChordSelection();
	pIStream->Write(&oce, size, NULL);
	WriteSize( pIStream, 0L); // must write space for pointer
	m_cadence[0].Save(oce);
	pIStream->Write(&oce, size, NULL);
	WriteSize( pIStream, 0L); // must write space for pointer
	m_cadence[1].Save(oce);
	pIStream->Write(&oce, size, NULL);

    pIStream->Write( &m_chords, sizeof(DWORD)*3, NULL );
}

long SignPost::Size(long version)
{
	if(version == ID_DMSIGNPOST)
	{
		ASSERT(FALSE); // not implemented
		return 0;
	}
	else
	{
		long size = OldChordEntry::SizeChordSelection()*(MAX_CADENCE+1);
		size += 3*sizeof(DWORD);
		size += 4*sizeof(void *);
		return size;
	}
}

SignPost *SignPost::Load( IStream *pIStream,long /*lfilesize*/)

{
    SignPost *psignpost = new SignPost;
	ReadSize(pIStream);	// move past sizeof(DWListItem) == sizeof(pointer)
	/*
	long id = ReadID(pIStream);
	ReadSize(pIStream);	// move past size record
	if(id == ID_DMSIGNPOST)
	{
		ASSERT(FALSE);	// not implemented
	}
	*/
	OldChordEntry oce;
	DWORD size = OldChordEntry::SizeChordSelection();
	ReadSize(pIStream);	// move past sizeof(DWListItem) == sizeof(pointer)
	pIStream->Read( &oce, size, NULL);
	psignpost->m_chord.Load(oce);
	ReadSize(pIStream);	// move past sizeof(DWListItem) == sizeof(pointer)
	pIStream->Read( &oce, size, NULL);
	psignpost->m_cadence[0].Load(oce);
	ReadSize(pIStream);	// move past sizeof(DWListItem) == sizeof(pointer)
	pIStream->Read( &oce, size, NULL);
	psignpost->m_cadence[1].Load(oce);
    pIStream->Read( &(psignpost->m_chords), sizeof(DWORD)*3, NULL );
    return(psignpost);      
}

PlayChord::PlayChord()
{
    m_pchord = NULL;
    m_pnext = NULL;
    m_dwflags = 0;
//  m_time = 0;
    m_beat = 0;
    m_measure = 0;
}

/*
static void setdirname(char *fullpath)
{ 
	_splitpath(fullpath,drivename,dirname,NULL,NULL);
}
*/
/*
static void getdirname(char *path)

{
	_makepath(path,drivename,dirname,NULL,NULL);
}
*/

Personality * Personality::LoadRef( IStream* /*pIStream*/,long /*lsize*/,BOOL /*bSmall*/)

{
/*
//	char filename[9];
	char fullfile[200];
	char dirname[120];
	PersonalityRef personref;

	pfile->ReadRecord(&personref,sizeof(PersonalityRef),lsize);
	getdirname(dirname);
    if (bSmall) wsprintf(fullfile,"%s%s.per",dirname,personref.m_filename);
    else wsprintf(fullfile,"%s%s.cmp",dirname,personref.m_filename);

	MyFile file ;
	unsigned long size, id ;
	Personality *pcmap = NULL;

TRACE("Loading Personality from file %s\n",fullfile);
	if(file.Open(fullfile, CFile::modeRead ))
	{
	    id = file.ReadID();
    	size = file.ReadSize();
	    if (!bSmall && (id == ID_EPERSONALITY))
    	{
			pcmap = Personality::Load(&file,size);
		}
		else if (bSmall && (id == ID_PERSONALITY))
		{
			pcmap = Personality::Load(&file,size);
		}
		file.Close();
	}
	if (pcmap) 
	{
		pcmap->m_personref = personref;
		pcmap->m_dwflags &= ~(CM_EMBED | CM_DEFAULT);
		pcmap->m_dwflags |= personref.m_isdefault;
	}
	return(pcmap);
*/
	return NULL;
}

void Personality::Save( IStream *pIStream, long version )
// only save personality, not contained objects
{
	if(version == ID_DMPERSONALITY)
	{
		ASSERT(FALSE);	// not implemented
	}
	else
	{
		WriteSize(pIStream, 0);	// Personality is a DWListItem, write out "pointer"
		pIStream->Write(&m_chordlist, sizeof(m_chordlist), NULL);	// m_chordlist
		pIStream->Write(&m_signpostlist, sizeof(m_signpostlist), NULL);
		pIStream->Write(&m_scalepattern, sizeof(m_scalepattern), NULL);
		pIStream->Write(&m_name, sizeof(m_name), NULL);
		pIStream->Write(&m_description, sizeof(m_description), NULL);
		pIStream->Write(&m_username, sizeof(m_username), NULL);
	
		m_chordpalette.Save(pIStream);

		pIStream->Write( &m_dwflags, sizeof(m_dwflags), NULL );
		pIStream->Write( &m_playlist, sizeof(m_playlist), NULL);
		pIStream->Write( &m_pfirstchord, sizeof(m_pfirstchord), NULL);
		pIStream->Write( &m_personref, sizeof(m_personref), NULL);
		pIStream->Write( &m_cx, sizeof(m_cx), NULL);
		pIStream->Write( &m_cy, sizeof(m_cy), NULL);
	}
}


void Personality::Load( IStream *pIStream,long /*lfilesize*/, long version)
// load only personality, not contained objects
{
	if(version == ID_DMPERSONALITY)
	{
		ASSERT(FALSE);	// not implemented
	}
	// else
	DWORD size;
	ReadSize(pIStream);	// Personality is a DWListItem, read past the pointer
	pIStream->Read(&m_chordlist, sizeof(m_chordlist), &size);	// m_chordlist
	pIStream->Read(&m_signpostlist, sizeof(m_signpostlist), &size);
	pIStream->Read(&m_scalepattern, sizeof(m_scalepattern), &size);
	pIStream->Read(&m_name, sizeof(m_name), &size);
	pIStream->Read(&m_description, sizeof(m_description), &size);
	pIStream->Read(&m_username, sizeof(m_username), &size);

	m_chordpalette.Load(pIStream);

	pIStream->Read( &m_dwflags, sizeof(m_dwflags), NULL );
	pIStream->Read( &m_playlist, sizeof(m_playlist), NULL);
	pIStream->Read( &m_pfirstchord, sizeof(m_pfirstchord), NULL);
	pIStream->Read( &m_personref, sizeof(m_personref), NULL);
	pIStream->Read( &m_cx, sizeof(m_cx), NULL);
	pIStream->Read( &m_cy, sizeof(m_cy), NULL);

//		pIStream->Read(pcmap,lrecordsize,NULL);
	m_pfirstchord = NULL;
	m_playlist.RemoveAll();
	m_chordlist.RemoveAll();
	m_signpostlist.RemoveAll();
}
	
	
long Personality::TotalSize(BOOL bSmall, long version)

{
	ChordEntry *pchord;
	long lsize = 0; 
	lsize += 4;						// Size of record field.

	if(version == ID_DMPERSONALITY)
	{
		ASSERT(FALSE);	// not implemented
		return 0;
	}
	else
	{
		lsize += PersonalitySize();	    	// Size of record.

		pchord = m_chordlist.GetHead();
		for(;pchord;pchord = pchord->GetNext())
		{       
			lsize += (pchord->Size(bSmall) + 8);
		}
		SignPost *psign;
		psign = m_signpostlist.GetHead();
		for(;psign;psign = psign->GetNext())
		{       
			lsize += (psign->Size() + 8);
		}
		return(lsize);
	}
}

long Personality::PersonalitySize(long version)
{
	if(version == ID_DMPERSONALITY)
	{
		return sizeof(Personality);
	}
	else
	{
		long size = sizeof(Personality) - sizeof(ChordPalette);
		size += (OldChordEntry::SizeChordSelection() + sizeof(void *)) * 24;
		return size;
	}
}


BOOL Personality::LoadFile(char* /*filename*/)

{
/*	MyFile file ;
	unsigned long size, id ;
	Personality *pcmap;

	if(file.Open(filename, CFile::modeRead ))
	{
	    id = file.ReadID();
    	size = file.ReadSize();
	    if (id == ID_EPERSONALITY)
    	{
			pcmap = Personality::Load(&file,size);
			if (pcmap)
			{
				Personality temp;
				temp = *this;
				*this = *pcmap;
				AssignParents();
				*pcmap = temp;
				delete pcmap;
				file.Close();
				_splitpath(filename,NULL,NULL,m_personref.m_filename,NULL);
				memset(&temp,0,sizeof(Personality));
				return(TRUE);
			}
		}
		file.Close();
	}
	return(FALSE);
*/
	return TRUE;
}

BOOL Personality::SaveFile(char* /*filename*/, BOOL /*bSmall*/)

{
/*
	MyFile file ;
	if(file.Open(filename, CFile::modeCreate |
	  	CFile::modeReadWrite | CFile::shareExclusive))
	{
		Save(&file,bSmall);
		file.Close();
		return(TRUE);
	}
	return(FALSE);
*/
	return TRUE;
}

BOOL ChordPalette::LoadFile(char* /*filename*/)

{
/*
	MyFile file;
	
	if (file.Open(filename, CFile::modeRead ))
	{
	    long id = file.ReadID();
    	long size = file.ReadSize();
	    if (id == ID_CHORDPALETTE)
    	{
			file.ReadRecord(this,sizeof(ChordPalette),size);
			file.Close();
			return(TRUE);
		}
		file.Close();
	}
	return(FALSE);                                    
*/
	return TRUE;
}

BOOL ChordPalette::SaveFile(char* /*filename*/)

{
/*
	MyFile file ;

	if(file.Open(filename, CFile::modeCreate |
	  	CFile::modeReadWrite | CFile::shareExclusive))
	{
		file.WriteID(ID_CHORDPALETTE);
		file.WriteRecord(this,sizeof(ChordPalette));
		file.Close();
		return(TRUE);
	}
	return(FALSE);
*/
	return TRUE;
}

void Personality::InsertChords(short leftedge,DWORD flags)

{
	CRect rect;
	ChordEntryList list;
	ChordEntry *pchord;
   	rect.left = leftedge;
   	rect.right = rect.left + CHORD_WIDTH;
   	rect.bottom = -20;
   	rect.top = rect.bottom - CHORD_HEIGHT;
	BuildNeededChords(&list,flags);
	m_chordlist.Cat(list.GetHead());
	pchord = list.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		pchord->m_rect.top = (short)rect.top;
		pchord->m_rect.left = (short)rect.left;
		pchord->m_rect.right = (short)rect.right;
		pchord->m_rect.bottom = (short)rect.bottom;
		pchord->m_dwflags |= flags;  
		rect.bottom -= (CHORD_HEIGHT * 4);
		rect.top -= (CHORD_HEIGHT * 4);
		pchord->m_parent = this;
		pchord->CleanupNexts(); 
	}
	AssignIDs();
}


static BOOL inchordlist(ChordEntry *plist,ChordSelection *pchord,DWORD flags)

{
	for (;plist;plist = plist->GetNext())
	{
		if (pchord->Equals(&plist->m_chordsel, DMPolyChord::ALL) && (plist->m_dwflags & flags))
		{
			return(TRUE);
		}
	}
	return(FALSE);			
}

static void addchordtolist(ChordEntryList *list,ChordSelection *chord,DWORD flags)

{
	ChordEntry *pchord = new ChordEntry;
	if (pchord)
	{
		pchord->m_chordsel = *chord;
		pchord->m_dwflags = flags;
		list->AddTail(pchord);
	}
}

static void maybeputinlist(
	ChordEntryList *newlist,ChordEntryList *oldlist,
	ChordSelection *pcsel,DWORD flags)

{
	if (!inchordlist(newlist->GetHead(),pcsel,flags))
	{
		if (!inchordlist(oldlist->GetHead(),pcsel,flags))
		{
			addchordtolist(newlist,pcsel,flags);
		}
	}
}

void Personality::BuildNeededChords(ChordEntryList *list,DWORD flags)

{
	SignPost *psign = m_signpostlist.GetHead();
	for (;psign;psign = psign->GetNext())
	{
		maybeputinlist(list,&m_chordlist,&psign->m_chord,flags);
		if (flags & CE_END)
		{
			if (psign->m_dwflags & SPOST_CADENCE1)
			{
				maybeputinlist(list,&m_chordlist,&psign->m_cadence[0],flags);
			}
			else if (psign->m_dwflags & SPOST_CADENCE2)
			{
				maybeputinlist(list,&m_chordlist,&psign->m_cadence[1],flags);
			}
		}
	}
} 

Personality::Personality()

{
	static short count = 1;
	m_chordlist.RemoveAll();
	m_playlist.RemoveAll(); 
	m_signpostlist.RemoveAll();
	m_scalepattern = 0xAB5AB5; 
	m_description[0] = 0; 
	m_personref.m_stylename[0] = 0;
	wsprintf(m_name,"Personality %d",count++);
				
}

/*
BOOL NextChord::Walk(SearchInfo *search)

{
	BOOL result = FALSE;
	if (m_nextchord) {
		search->m_minbeats = (short)( search->m_minbeats + m_nminbeats );
		search->m_maxbeats = (short)( search->m_maxbeats + m_nmaxbeats );
		search->m_chords++;
		result = m_nextchord->Walk(search); 
		search->m_chords--;
		search->m_minbeats = (short)( search->m_minbeats - m_nminbeats );
		search->m_maxbeats = (short)( search->m_maxbeats - m_nmaxbeats );
	}
	return(result);
}


NextChord *ChordEntry::ChooseNextChord()

{
	int total = 0;
	int choice;
	NextChord *pnext = m_nextchordlist.GetHead();
	for (;pnext;pnext = pnext->GetNext())
	{                                                      
		if (!(pnext->m_dwflags & NC_NOPATH)) 
		{
			if (pnext->m_nextchord)
			{
				total += pnext->m_nweight; 
			}
		}
	}
	if (!total) return(NULL); 
	choice = (short)(rand() % total);
	pnext = m_nextchordlist.GetHead();
	for (;pnext;pnext = pnext->GetNext())
	{                                                      
		if (!(pnext->m_dwflags & NC_NOPATH)) 
		{
			if (pnext->m_nextchord)
			{
				choice -= pnext->m_nweight;
			}
			if (choice < 0)
			{
				return(pnext); 
			}
		}
	}
	return(NULL);
}

BOOL ChordEntry::Walk(SearchInfo *search)

{
	NextChord *pnext = m_nextchordlist.GetHead();
	if (search->m_chords > search->m_maxchords) 
	{
		search->m_fail.m_toomanychords++;
		return (FALSE);
	}  
	for (;pnext;pnext = pnext->GetNext())
	{                                                            
		pnext->m_dwflags &= ~(NC_PATH | NC_NOPATH);
	}
	if ((m_dwflags & CE_END) && (m_chordsel.Equals(&search->m_end))) 
	{
		if (search->m_chords >= search->m_minchords)
		{
			if (search->m_beats <= search->m_maxbeats)
			{
				if (search->m_beats >= search->m_minbeats) 
				{
					m_dwflags |= CE_PATH;
					return(TRUE);
				}
				else search->m_fail.m_toomanybeats++;
			}
			else search->m_fail.m_toofewbeats++;
		}
		else
		{
			search->m_fail.m_toofewchords++;
		}
	}
	m_dwflags &= ~CE_PATH;
	if (search->m_pplaychord)
	{
		search->m_pplaychord = search->m_pplaychord->GetNext();
	}
	if (search->m_pplaychord)
	{
		PlayChord *pplay = search->m_pplaychord;
		if (pplay->m_pchord)
		{
			NextChord *pnext = pplay->m_pnext; 
			if (pnext)  
			{
				if (pnext->Walk(search))
				{
					pnext->m_dwflags |= NC_PATH;
					m_dwflags |= CE_PATH;
					return(TRUE);
				}
				else
				{
					pnext->m_dwflags |= NC_NOPATH;
					search->m_pplaychord = NULL;
				} 
			}
		}
	}
	while( ( pnext = ChooseNextChord() ) != NULL )
	{
		if (pnext->Walk(search))
		{
			pnext->m_dwflags |= NC_PATH;
			m_dwflags |= CE_PATH;
			return(TRUE);
		}
		else
		{
			pnext->m_dwflags |= NC_NOPATH;
		}
	}
	return (FALSE);
}



BOOL Personality::Compose(SearchInfo *search)

{
	PlayChord *pdupe;
	ChordEntry *pchord = NULL;
	SearchInfo tempsearch;
	FailSearch tempfail;
//	search->m_pplaychord = NULL;
//	search->m_pfirstchord = NULL;
	tempsearch = *search; 
	short i = 0; 
	// First, if we have a previous instance with the same starting point,
	// try to come up with a solution using its path.
    if (search->m_pplaychord && search->m_pfirstchord)
    { 
		pchord = search->m_pfirstchord;
		ClearNextFlags(NC_PATH);
		ClearChordFlags(CE_PATH);
		if (pchord->Walk(search)) 
		{
		}
		else 
		{	
			pchord = NULL;
		}
	}
	if (!pchord)
	{
		pchord = m_chordlist.GetHead();
		for (;pchord;pchord = pchord->GetNext())
		{
			if (pchord->m_dwflags & CE_START)
			{
				if (pchord->m_chordsel.Equals(&search->m_start)) 
				{
					ClearNextFlags(NC_PATH);
					ClearChordFlags(CE_PATH);
					tempfail = search->m_fail;
					*search = tempsearch; 
					search->m_fail = tempfail;   	
					if (pchord->Walk(search)) break;
				}
			}
		} 
	}
	if (!pchord) 
	{
		m_pfirstchord = NULL;
		m_playlist.RemoveAll();
		return(FALSE);   
	}
	pdupe = new PlayChord;
	if (pdupe)
	{
		pdupe->m_pchord = &pchord->m_chordsel;
		pdupe->SetNext(NULL);
		pdupe->m_measure = (short)i++;
		pdupe->m_minbeats = pdupe->m_maxbeats = 0;
		pdupe->m_pnext = NULL;
		m_pfirstchord = pchord;
		m_playlist.AddTail(pdupe);
	}		
	for (;pchord;)
	{
		NextChord *pnext;
		pnext = pchord->m_nextchordlist.GetHead();
		for (;pnext;)
		{
			if (pnext->m_dwflags & NC_PATH)
			{
//				if (pnext->m_nextchord->m_dwflags & CE_END) break;
				pdupe = new PlayChord;
				if (pdupe)
				{
					pdupe->m_pchord = &pnext->m_nextchord->m_chordsel;
					pdupe->SetNext(NULL);
					pdupe->m_measure = (short)i++;
					pdupe->m_minbeats = (short)pnext->m_nminbeats;
					pdupe->m_maxbeats = (short)pnext->m_nmaxbeats; 
					pdupe->m_pnext = pnext;
					m_playlist.AddTail(pdupe);
				}
				break;
			}
			else
			{
				pnext = pnext->GetNext();
			}
		}
		if (pnext)
		{
			pchord = pnext->m_nextchord;
		}
		else pchord = NULL;
	}
	return(TRUE);
}
*/

//BOOL Personality::PlayStart()

//{
/*
	PlayChord *pnext = (PlayChord *) m_playlist.GetHead();
	if (pnext) 
	{
		Engine->InsertChordProgression(pnext,Engine->m_psection);
		Engine->PlaySection();
	}
	return(FALSE);
*/
//	return FALSE;
//} 

//BOOL Personality::PlayNext()
//
//{
//	return(FALSE);
//}

void PlayList::ClearList()

{
	PlayChord *pnext = GetHead();
	for (;pnext;)
	{
		PlayChord *next = pnext->GetNext();
		delete pnext;
		pnext = next;	
	}
	RemoveAll();
}

SignPost::SignPost()
{
    m_chords = SP_A | SP_B | SP_C;
    m_dwflags = SPOST_CADENCE1 | SPOST_CADENCE2;
    m_tempflags = 0;
}

BOOL Personality::PlayStop()

{
	m_playlist.ClearList();
	return(TRUE);
}

void Personality::AssignIDs()

{
	ChordEntry *pchord = m_chordlist.GetHead();   
	for (;pchord;pchord = pchord->GetNext())
	{ 
		if (!pchord->m_nid) 
		{
			short scan = 1;
			for (scan = 1;;scan++)
			{
				ChordEntry *pscan = m_chordlist.GetHead();   
				for (;pscan;pscan = pscan->GetNext())
				{
					if (pscan->m_nid == scan) break;
				}
				if (!pscan) break;
			}
			pchord->m_nid = scan;
		}
	}
}

void Personality::ResolveConnections()

{
	ChordEntry *pchord = m_chordlist.GetHead();   
	for (;pchord;pchord = pchord->GetNext())
	{
		NextChord *pnext = pchord->m_nextchordlist.GetHead();
		for (;pnext;pnext = pnext->GetNext())
		{
			pnext->m_nextchord = NULL;
		} 
	}
	pchord = m_chordlist.GetHead();   
	for (;pchord;pchord = pchord->GetNext())
	{
		NextChord *pnext = pchord->m_nextchordlist.GetHead();
		for (;pnext;pnext = pnext->GetNext())
		{
			if (pnext->m_nid)
			{
				ChordEntry *pconnect = m_chordlist.GetHead();   
				for (;pconnect;pconnect = pconnect->GetNext())
				{
                	if (pconnect->m_nid == pnext->m_nid) break;
                }
				pnext->m_nextchord = pconnect;
			}
		} 
	}
}

Personality::~Personality()

{
	ChordEntry *pchord = m_chordlist.GetHead();
	SignPost *psignpost = m_signpostlist.GetHead();
	PlayStop(); 
	for (;pchord;)
	{
		ChordEntry *next = pchord->GetNext();
		delete pchord;
		pchord = next;	
	}
	m_chordlist.RemoveAll();
	for (;psignpost;)
	{
		SignPost *next = psignpost->GetNext();
		delete psignpost;
		psignpost = next;	
	}
	m_signpostlist.RemoveAll();
}

void Personality::Debug()

{
	ChordEntry *pchord = m_chordlist.GetHead(); 
	TRACE("Chord List:\n");
	for (;pchord;pchord = pchord->GetNext())
	{
		pchord->Debug();
	}
/*	TRACE("Play List:\n");
	NextChord *pnext = (NextChord *) m_playlist.GetHead();
	for (;pnext;pnext = (NextChord *) pnext->GetNext())
	{
		pnext->Debug();
	}  */
}

void Personality::AssignParents()

{
	ChordEntry *pchord = m_chordlist.GetHead(); 
	for (;pchord;pchord = pchord->GetNext())
	{
		pchord->m_parent = this;
		pchord->AssignParents();
	}
/*	NextChord *pnext = (NextChord *) m_playlist.GetHead();
	for (;pnext;pnext = (NextChord *) pnext->GetNext())
	{
		pnext->m_parent = NULL;
	}  */
}

void Personality::Draw(CDC *pDC,short page)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		pchord->Draw(pDC,page);
	}
}   

BOOL Personality::IsValidChord(ChordEntry *ptest)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord == ptest) return(TRUE);
	}
	return (FALSE);
	
}

BOOL Personality::IsValidNext(NextChord *ptest)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		NextChord *pnext = pchord->m_nextchordlist.GetHead();
		for (;pnext;pnext = pnext->GetNext())
		{
			if (pnext == ptest) return(TRUE);
		}
	}
	return (FALSE);
}

void Personality::ClearChordFlags(unsigned long flag)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		pchord->m_dwflags &= ~flag;
	}
}

void Personality::ClearNextFlags(unsigned long flag)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		NextChord *pscan = pchord->m_nextchordlist.GetHead();
		for (;pscan;pscan = pscan->GetNext())
		{
			pscan->m_dwflags &= ~flag;
		}
	}
}


void ChordEntry::MarkTree()

{
	m_dwflags |= CE_TREE;
	NextChord *pscan = m_nextchordlist.GetHead();
	for (;pscan;pscan = pscan->GetNext())
	{
		pscan->MarkTree();
	}
}

void NextChord::MarkTree()

{
	m_dwflags |= NC_TREE;
	if (m_nextchord) m_nextchord->MarkTree();
}

void Personality::MarkTree(ChordEntry *pchord)

{
//	ClearNextFlags(NC_TREE);
//	ClearChordFlags(CE_TREE);
	if (pchord)
	{
		pchord->MarkTree();
	}
}

ChordEntry *Personality::FindXYChord(CPoint point,short page)

{
	CRect crTemp;
	ChordEntry *pchord = m_chordlist.GetHead();

	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord->m_page & page)
//		if (findall || (pchord->m_dwflags & (CE_TREE | CE_END)))
		{
			crTemp.left = pchord->m_rect.left;
			crTemp.right = pchord->m_rect.right;
			crTemp.top = pchord->m_rect.top;
			crTemp.bottom = pchord->m_rect.bottom;
//			if (pchord->m_rect.PtInRect(point)) break;
			if (crTemp.PtInRect(point)) break;
		}
	}
	return (pchord);
}

NextChord *Personality::FindXYNext(CPoint point,short page)

{
	CRect crTemp;

	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord->m_page & page)
//		if (findall || (pchord->m_dwflags & (CE_TREE | CE_END)))
		{
			NextChord *pnext = (NextChord *) pchord->m_nextchordlist.GetHead();
			for (;pnext;pnext = (NextChord *) pnext->GetNext())
			{
				crTemp.SetRect( pnext->m_rect.left, pnext->m_rect.top,
								pnext->m_rect.right, pnext->m_rect.bottom );
//				if (findall || (pnext->m_dwflags & NC_TREE))
//				{
//					if (pnext->m_rect.PtInRect(point)) return(pnext);  
					if (crTemp.PtInRect(point)) return(pnext);  
//				}
			}   
		}
	}
	return (NULL);
}   

BOOL Personality::CalcViewSize()

{
    CRect rect;
    CSize size;
    rect.SetRectEmpty(); 
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
//		rect |= pchord->m_rect;
		rect.left |= pchord->m_rect.left;
  		rect.right |= pchord->m_rect.right;
  		rect.bottom |= pchord->m_rect.bottom;  
  		rect.top |= pchord->m_rect.top;  
    }
    size.cx = rect.Width(); + CHORD_WIDTH;
    size.cy = rect.Height() + CHORD_HEIGHT + (4 * NEXT_HEIGHT);
    if (size.cx == m_cx || size.cy == m_cy) return(FALSE);
    //m_size = size;
    return(TRUE);
}

BOOL Personality::GetChord(ChordSelection *pcsel,DWORD flag,short index)

{
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord->m_dwflags & flag)
		{
			if (!index) 
			{
				*pcsel = pchord->m_chordsel; 
				return(TRUE);
			}
			index--;
		}
	}
	return(FALSE);
}

short Personality::GetChordIndex(ChordSelection *pcsel,DWORD flag)

{
	short index = 0;
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord->m_dwflags & flag)
		{
			if (pcsel->Equals(&pchord->m_chordsel, DMPolyChord::ALL)) return(index); 
			index++;
		}
	}
	return(0);
}

short Personality::GetChordCount(DWORD flag)

{
	short count = 0;
	ChordEntry *pchord = m_chordlist.GetHead();
	for (;pchord;pchord = pchord->GetNext())
	{
		if (pchord->m_dwflags & flag) count++;
	}
	return(count);
}

Instruments::Instruments()

{
	static unsigned char defaults[16] = { 73,48,25,0,32,0,0,0,0,0,0,0,0,0,0,0 };
	short i;
	for (i=0;i<16;i++) m_patch[i] = defaults[i]; 
	strcpy(m_name,"new");
	m_default = 0;
}

GrooveName * GrooveNameList::GetGrooveName(DWORD grooveid)

{
	GrooveName *pgroove = GetHead();
	for (;pgroove;pgroove = pgroove->GetNext())
	{
		if (pgroove->m_grooveid == grooveid) break;
	}
	return (pgroove);
}

void GrooveNameList::AddGrooveName(char *name,DWORD grooveid)

{
	GrooveName *pgroove;
	pgroove = new GrooveName;
	if (pgroove)
	{
		strncpy(pgroove->m_name,name,sizeof(pgroove->m_name));
		pgroove->m_grooveid = grooveid;
		AddTail(pgroove);
	}
}

void GrooveNameList::SetDefaults()

{
	AddGrooveName("Relaxed",PF_A);
	AddGrooveName("Medium",PF_B);
	AddGrooveName("Active",PF_C);
	AddGrooveName("Frantic",PF_D);
}
     
void Instruments::Save( IStream *pIStream )

{ 
	WriteID( pIStream, ID_INSTRUMENTS );
	pIStream->Write( this, sizeof( Instruments ), NULL );
}

long Instruments::Size()

{
	return(sizeof(Instruments));
}

Instruments * Instruments::Load( IStream *pIStream,long /*lfilesize*/)

{
	Instruments *pinst = new Instruments;
	pIStream->Read( pinst, sizeof(Instruments), NULL );
	return(pinst);		
}
   
Instruments * Instruments::LoadFile(char* /*filename*/)

{
/*	MyFile file ;
	unsigned long size, id ;
	Instruments *pinst;

	if(file.Open(filename, CFile::modeRead ))
	{
	    id = file.ReadID();
    	size = file.ReadSize();
	    if (id == ID_INSTRUMENTS)
    	{
			pinst = Instruments::Load(&file,size);
		}
		file.Close();
	}
	return(pinst);
*/
	return NULL;
}

void Instruments::SaveFile(char* /*filename*/)

{
/*	MyFile file ;

	if(file.Open(filename, CFile::modeCreate |
	  	CFile::modeReadWrite | CFile::shareExclusive))
	{
		Save(&file);
		file.Close();
	}
*/
}

GrooveName::GrooveName()

{
	strcpy(m_name,"Duh...");
	m_grooveid = 0;
}

void GrooveName::Save( IStream *pIStream )

{ 
	WriteID( pIStream, ID_GROOVENAME );
	pIStream->Write(this, sizeof(GrooveName), NULL );
}

long GrooveName::Size()

{
	return(sizeof(GrooveName));
}

GrooveName * GrooveName::Load( IStream *pIStream,long /*lfilesize*/)

{
	GrooveName *pinst = new GrooveName;
	pIStream->Read( pinst, sizeof(GrooveName),NULL );
	return(pinst);		
}


void InstrumentsList::ClearList()

{
	Instruments *pinst;
	while ( (pinst = GetHead()) != 0 )
	{
		Remove(pinst);
		delete pinst;
	}
}

void GrooveNameList::ClearList()

{
	GrooveName *pgroove;
	while ( (pgroove = GetHead()) != 0 )
	{
		Remove(pgroove);
		delete pgroove;
	}
}

void PersonalityList::ClearList()

{
	Personality *map;
	while ( (map = GetHead()) != 0 )
	{
		Remove(map);
		delete map;
	}
}

#define ID_STYL        0x5354594C

/*
static void makenewname(char * filename)

{
	char drive[_MAX_DRIVE];
	char dir[_MAX_DIR];
	char file[30];

	_splitpath(filename,drive,dir,file,NULL);
	_makepath(filename,drive,dir,file,".sct"); 
}
*/
/*
static BOOL copyfile(char * oldfile,char * newfile)

{
	CFile source;
	CFile dest;
	if (dest.Open(newfile,CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive))
	{
		if (source.Open(oldfile,CFile::modeRead | CFile::shareExclusive))
		{
			int length = 200;
			char buff[200];
			while (length > 0)
			{
				length = source.Read(buff,200);
				dest.Write(buff,length);
			}
			source.Close();
			dest.Close();
			return(TRUE);
		}
		dest.Close();
	}
	return(FALSE);	
}
*/

ChordChangeCallback::~ChordChangeCallback()
{
	if(m_pChordEntry)delete m_pChordEntry;
}

HRESULT ChordChangeCallback::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    if(::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG ChordChangeCallback::AddRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));	
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG ChordChangeCallback::Release()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

void ChordEntryToChordExt(ChordEntry* pChordEntry, ChordExt* pChordExt)
{
	ASSERT(pChordEntry);
	ASSERT(pChordExt);


	*dynamic_cast<DMPolyChord*>(pChordExt) = pChordEntry->m_chordsel;
//	pChordExt->KeyDown() = pChordEntry->KeyDown();
}


long ChordPalette::Size(long version)
{
	if(version == ID_DMCHORDPALETTE)
	{
		return sizeof(ChordPalette);
	}
	else
	{
		return 24 * (sizeof(void*) + OldChordEntry::SizeChordSelection());
	}
}

HRESULT ChordPalette::Save(IStream* pStream, long version)
{
	HRESULT hr = S_OK;
	OldChordEntry oce;
	for(int i = 0; i < 24; i++)
	{
		if(version == ID_DMCHORDPALETTE)
		{
			ASSERT(FALSE);	// not implemented yet
		}
		else
		{
			WriteSize(pStream, 0);	// dwlistitem ptr
			m_chords[i].Save(oce);
			hr = pStream->Write(&oce, OldChordEntry::SizeChordSelection(), NULL);
		}
	}
	return hr;
}

HRESULT ChordPalette::Load(IStream* pStream, long version)
{
	HRESULT hr = S_OK;
	OldChordEntry oce;
	for(int i = 0; i < 24; i++)
	{
		if(version == ID_DMCHORDPALETTE)
		{
			ASSERT(FALSE);	// not implemented yet
		}
		else
		{
			ReadSize(pStream);	// dwlistitem ptr
			hr = pStream->Read(&oce, OldChordEntry::SizeChordSelection(), NULL);
			m_chords[i].Load(oce);
		}
	}
	return hr;
}




void DMPolyChord::InitLevels()
{
	for(int i = 0; i < MAX_POLY; i++)
	{
		SubChord(i)->Levels() = (1 << i);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\ChordInversionPropPage.h ===
#if !defined(AFX_CHORDINVERSIONPROPPAGE_H__E4A7E136_B485_11D1_9875_00805FA67D16__INCLUDED_)
#define AFX_CHORDINVERSIONPROPPAGE_H__E4A7E136_B485_11D1_9875_00805FA67D16__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include "conductor.h"
#include "..\shared\keyboard.h"
#include "..\shared\invertvector.h"

// ChordInversionPropPage.h : header file
//

class BitFlag
{
	unsigned long	dw;
public:
	BitFlag() { dw = 0; }
	BitFlag(unsigned long l) { dw = l; }
	BitFlag& operator = (unsigned long l)
	{
		dw = l;
		return *this;
	}
	unsigned long GetBit(int bit)
	{
		return dw & (1 << bit);
	}
	void SetBit(int bit)
	{
		dw |= (1 << bit);
	}
	void ClearBit(int bit)
	{
		dw &= ~(1<<bit);
	}
	operator unsigned long()
	{
		return dw;
	}
};

class InversionState
{
	int m_state;
public:
	enum { Root=0, First, Second, Third, NStates };
	InversionState()
	{
		m_state = Root;
	}
	void Reset()
	{
		m_state = Root;
	}
	int Get() const { return m_state; }
	void Set(int m)
	{
		ASSERT(Root <= m && m <= Third);
		if(Root <=m && m <= Third)
		{
			m_state = m;
		}
	}
	int Rotate(int highestInvert = -1)
	{
		//highestInvert == # notes in chord
		//highestInvert == -1 -> no inversion limit
		//highestInvert == 0 -> only a single note--nothing to invert
		if(highestInvert > NStates)
			highestInvert = NStates;	// 3 inversions is limit
		if(highestInvert != 0)
		{
			m_state = (m_state + 1) % ((highestInvert==-1) ? NStates : highestInvert );
		}
		return m_state;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage dialog
class CChordPropPageMgr;

class CChordInversionPropPage : public CPropertyPage
{
	friend class CChordPropPageMgr;
	DECLARE_DYNCREATE(CChordInversionPropPage)

// Construction
public:
	CChordInversionPropPage();
	~CChordInversionPropPage();
	enum { MAX_POLY = 4 , CHORDNOTE_DUR = 250, SCALENOTE_DUR = 250, CHORDNOTE_DELAY = 125, SCALENOTE_DELAY=125};

// Dialog Data
	//{{AFX_DATA(CChordInversionPropPage)
	enum { IDD = IDD_CHORDINVERSION_PROPPAGE };
	CKeyboard	m_keysinv4;
	CKeyboard	m_keysinv3;
	CKeyboard	m_keysinv2;
	CKeyboard	m_keysinv1;
	CKeyboard	m_keysbase4;
	CKeyboard	m_keysbase3;
	CKeyboard	m_keysbase2;
	CKeyboard	m_keysbase1;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChordInversionPropPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChordInversionPropPage)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonInvert1();
	afx_msg void OnButtonInvert2();
	afx_msg void OnButtonInvert3();
	afx_msg void OnButtonInvert4();
	afx_msg void OnButtonIplay1();
	afx_msg void OnButtonIplay2();
	afx_msg void OnButtonIplay3();
	afx_msg void OnButtonIplay4();
	afx_msg void OnCheckLegal1();
	afx_msg void OnCheckLegal2();
	afx_msg void OnCheckLegal3();
	afx_msg void OnCheckLegal4();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void EnableControls(BOOL bEnable);
	HRESULT ChangePatch(BYTE ch, BYTE inst, BYTE msb, BYTE lsb);
	HRESULT PlayNote(BYTE ch, BYTE key, BYTE vel, DWORD startTime, DWORD dur);
	void PlayChordInversion(int index);
	int GetInversionKeyboardIndex(const CKeyboard* pKeyboard);
	CKeyboard* GetInversionKeyboard(int index);
	int GetChordKeyboardIndex(const CKeyboard* pKeyboard);
	CKeyboard* GetChordKeyboard(int index);
	void SetChord(CPropChord* pChord, int SubChord = -1 /* default = all subchords */);
	void SetChordData(CChordScalePropPageData* pChordScalePropPageData);
	void UpdateChordData();
	void DrawInversionNote(CPropChord* pChord, DWORD dwChordInversion, int index, short nX);
	// IUnknown functions
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// data transfer
	void CopyDataToTab( CPropChord*  TabData );
	void GetDataFromTab( const CPropChord* TabData );


private:
	CBitmapButton	m_nextinvert4;
	CBitmapButton	m_nextinvert3;
	CBitmapButton	m_nextinvert2;
	CBitmapButton	m_nextinvert1;
	
	CBitmapButton	m_play4;
	CBitmapButton	m_play3;
	CBitmapButton	m_play2;
	CBitmapButton	m_play1;

	InversionState	m_invertStates[CPropChord::MAX_POLY];
	InvertVector	m_invertVector[CPropChord::MAX_POLY];
	
	CPropChord			m_Chord;
	bool				m_fLockAllScales;
	bool				m_fSyncLevelOneToAll;

	DWORD				m_cRef;
	CChordPropPageMgr*	m_pPropPageMgr;
	IDMUSProdConductor*	m_pIConductor;
	IDirectMusicPerformance*	m_pIPerformance;
	bool				m_bValidChord;
	BOOL				m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHORDINVERSIONPROPPAGE_H__E4A7E136_B485_11D1_9875_00805FA67D16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\ChordIO.cpp ===
#include "stdafx.h"
#include "ChordIO.h"
#include "riffstrm.h"
#include "chord.h"
#include <dmusici.h>

CChordItem::CChordItem()

{
//	TRACE("New ChordItem, addr = %p\n");
	m_lDrawPosition = 0;
	m_dwIndex = 0;
	m_fSelected = 0;
}

CChordItem::CChordItem(const CChordItem& chord)
{
//	TRACE("New ChordItem, addr = %p\n");
	m_lDrawPosition = chord.m_lDrawPosition;
	m_dwIndex = chord.m_dwIndex;
	m_fSelected = chord.m_fSelected;
	*((CPropChord*)this) = chord;
}

CChordItem::CChordItem(const ChordEntry& chord)
{
//	TRACE("New ChordItem, addr = %p\n");
	m_lDrawPosition = 0;
	m_dwIndex = 0;
	m_fSelected = 0;
	SetSelected(const_cast<ChordEntry&>(chord).m_chordsel.KeyDown());
	CPropChord* pProp = dynamic_cast<CPropChord*>(this);
	const_cast<ChordEntry&>(chord).SaveToPropChord(*pProp);
}

CChordItem::CChordItem(const ChordSelection& chord)
{
//	TRACE("New ChordItem, addr = %p\n");
	m_lDrawPosition = 0;
	m_dwIndex = 0;
	m_fSelected = 0;
	ChordEntry chordentry;
	chordentry.m_chordsel = chord;
	SetSelected(const_cast<ChordSelection&>(chord).KeyDown());
	CPropChord* pProp = dynamic_cast<CPropChord*>(this);
	const_cast<ChordEntry&>(chordentry).SaveToPropChord(*pProp);
}


DWORD CChordList::PreparePropChord( CPropChord *pPropChord )

/*	Scan through the chord list and combine all chords that have
	m_fSelected set into the one chord for the property page.
*/

{
	DWORD dwSelectCount = 0;	// How many are selected.
	memset( (void *) pPropChord, 0, sizeof (CPropChord));
	CChordItem* pChord = GetHead();
	for (;pChord != NULL; pChord = pChord->GetNext())
	{
		if (pChord->IsSelected())
		{
			if (dwSelectCount == 0)
			{
				*pPropChord = *pChord;
				pPropChord->SetUndetermined(-1, 0);
			}
			else
			{
				pChord->CopyToPropChord(pPropChord, CPropChord::ALL);
			}
			dwSelectCount++;
		}
	}
	return dwSelectCount;
}

DWORD CChordList::RetrievePropChord( CPropChord *pPropChord )

{
	DWORD dwSelectCount = 0;	// How many are selected.
	CChordItem* pChord = GetHead();
	for (;pChord != NULL; pChord = pChord->GetNext())
	{
		if (pChord->IsSelected())
		{
			pChord->CopyFromPropChord(pPropChord, CPropChord::ALL);
			dwSelectCount++;
		}
	}
	return dwSelectCount;
}

void CChordList::InsertByAscendingTime(CChordItem* pChord, bool bReplaceCoincident)
{
	ASSERT(pChord);
	CChordItem* pItem = GetHead();
	while(pItem && *pItem < *pChord)
	{
		pItem = pItem->GetNext();
	}
	if(pItem)
	{
		InsertBefore(pItem, pChord);
		if(bReplaceCoincident && pItem->IsCoincident(*pChord))
		{
			Remove(pItem);
			delete pItem;
		}
	}
	else
	{
		AddTail(pChord);
	}
}

void CChordList::ClearSelections( )

{
	CChordItem* pChord = GetHead();
	for (;pChord != NULL; pChord = pChord->GetNext())
	{
		pChord->SetSelected(FALSE);
	}
}

void CChordList::ClearList()
{
	CChordItem* pChord;
	while( pChord = RemoveHead() )
	{
		delete pChord;
	}
}


HRESULT CChordList::Load( LPSTREAM pStream )
{
	HRESULT		hr = S_OK;
	DWORD		cb;
	DWORD		cSize;
    CChordItem*		pChord;
    ioOldChordSelection iChordSelection;
    WORD        wSizeChord;
	STATSTG		statstg;
	DWORD		dwIndex = 0;

	if( NULL == pStream )
	{
		return E_POINTER;
	}
	if( hr = FAILED( pStream->Stat( &statstg, STATFLAG_NONAME ) ))
	{
		return hr;
	}

	DMUSProdStreamInfo	StreamInfo;//Added ECW 4/24/98
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{//Changed ECW 4/24/98
		pPersistInfo->GetStreamInfo( &StreamInfo );
		if(pPersistInfo)
		{
			ftFileType = StreamInfo.ftFileType;
			guidDataFormat = StreamInfo.guidDataFormat;
			pPersistInfo->Release();
		}
	}


	if( IsEqualGUID( guidDataFormat, GUID_CurrentVersion ))
	{
		return	DMLoad(pStream);
	}

	ClearList();
	cSize = statstg.cbSize.LowPart;

//    cSize = pck->cksize;
//	*plstChord = NULL;
	// load size of chord structure
    hr = pStream->Read( &wSizeChord, sizeof( wSizeChord ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSizeChord ) )
	{
        hr = E_FAIL;
		goto ON_ERR;
	}
	cSize -= cb;
	while( cSize )
	{
        if( wSizeChord > sizeof( ioOldChordSelection ) )
        {
            hr = pStream->Read( &iChordSelection, sizeof( ioOldChordSelection ), &cb );
            if( FAILED( hr ) || cb != sizeof( ioOldChordSelection ) )
            {
				hr = E_FAIL;
				break;
            }
            StreamSeek( pStream, wSizeChord - sizeof( ioOldChordSelection ), STREAM_SEEK_CUR );
        }
        else
        {
            hr = pStream->Read( &iChordSelection, wSizeChord, &cb );
            if( FAILED( hr ) || cb != wSizeChord )
            {
				hr = E_FAIL;
				break;
            }
        }
        cSize -= wSizeChord;

        pChord = new CChordItem;

        if( pChord == NULL )
		{
            hr = E_OUTOFMEMORY;
            goto ON_ERR;
        }

		memset(pChord->Name(), 0, DMPolyChord::MAX_NAME);
        WideCharToMultiByte( CP_ACP, 0, iChordSelection.wstrName, -1, pChord->Name(), DMPolyChord::MAX_NAME, NULL, NULL );
        if( iChordSelection.fCSFlags & CSF_FLAT )
        {
            pChord->Base()->UseFlat() = 1;
        }
		if( iChordSelection.fCSFlags & CSF_SELECTED)
		{
			pChord->SetSelected(TRUE);
		}
		else
		{
			pChord->SetSelected(FALSE);
		}
		if( iChordSelection.fCSFlags & CSF_SIGNPOST)
		{
			pChord->SetSignPost(TRUE);
		}
		else
		{
			pChord->SetSignPost(FALSE);
		}
		pChord->Beat() = iChordSelection.bBeat;
		pChord->Measure() = iChordSelection.wMeasure;
		pChord->Base()->ChordPattern() = iChordSelection.aChord[0].lChordPattern;
		pChord->Base()->ScalePattern() = iChordSelection.aChord[0].lScalePattern;
		pChord->Base()->InvertPattern() = iChordSelection.aChord[0].lInvertPattern;
		pChord->Base()->Flags() = iChordSelection.aChord[0].wCFlags;
		pChord->Base()->ChordRoot() = iChordSelection.aChord[0].bRoot;
		pChord->Base()->ScaleRoot() = pChord->Base()->ChordRoot();
        pChord->SetBits(pChord->RootIndex());
		pChord->m_dwIndex = dwIndex++;
		pChord->PropagateAll();	// legacy: set all subchords to base chord
		AddTail(pChord);
    }

ON_ERR:
    return hr;
}

// Save the chordlist to a normal stream
HRESULT CChordList::Save( LPSTREAM pStream, BOOL bClearDirty )
{
    HRESULT     hr;
    DWORD       cb;
    WORD        wSize;
    ioOldChordSelection iChordSelection;
    CChordItem*   pChord;
    int         i;

	DMUSProdStreamInfo	StreamInfo;//Added ECW 4/24/98
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{//Changed ECW 4/24/98
		pPersistInfo->GetStreamInfo( &StreamInfo );
		if(pPersistInfo)
		{
			ftFileType = StreamInfo.ftFileType;
			guidDataFormat = StreamInfo.guidDataFormat;
			pPersistInfo->Release();
		}
	}


	if( IsEqualGUID( guidDataFormat, GUID_CurrentVersion ))
	{
		return	DMSave(pStream, bClearDirty);
	}

    wSize = sizeof( ioOldChordSelection );
    hr = pStream->Write( &wSize, sizeof( wSize ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSize ) )
    {
        return E_FAIL;
    }

	
    for( pChord = GetHead() ; pChord != NULL; pChord = pChord->GetNext() )
    {
        memset( &iChordSelection, 0, sizeof( ioOldChordSelection ) );
        MultiByteToWideChar( CP_ACP, 0, pChord->Name(), -1, iChordSelection.wstrName, sizeof( iChordSelection.wstrName ) / sizeof( wchar_t ) );
        if( pChord->Base()->UseFlat() != 0 )
        {
            iChordSelection.fCSFlags |= CSF_FLAT;
        }
		if( pChord->IsSelected())
		{
			iChordSelection.fCSFlags |= CSF_SELECTED;
		}
		if( pChord->IsSignPost())
		{
			iChordSelection.fCSFlags |= CSF_SIGNPOST;
		}
/* not available in CChordItem
        if( pChord->inscale != 0 )
        {
            iChordSelection.fCSFlags |= CSF_INSCALE;
        }
        if( pChord->keydown != 0 )
        {
            iChordSelection.fCSFlags |= CSF_KEYDOWN;
        }
        if( ( pChord->bits & CHORD_SIMPLE ) != 0 )
        {
            iChordSelection.fCSFlags |= CSF_SIMPLE;
        }
*/
        iChordSelection.bBeat = pChord->Beat();
        iChordSelection.wMeasure = pChord->Measure();
        for( i = 0 ; i < 4 ; ++i )
        {
            iChordSelection.aChord[i].lChordPattern = pChord->Base()->ChordPattern();
            iChordSelection.aChord[i].lScalePattern = pChord->Base()->ScalePattern();
/* not available in CChordItem
            iChordSelection.aChord[i].lInvertPattern = ~0;
*/
            iChordSelection.aChord[i].bRoot = pChord->Base()->ChordRoot();
        }
        if( FAILED( pStream->Write( &iChordSelection, sizeof( iChordSelection), &cb ) ) ||
            cb != sizeof( iChordSelection ) )
        {
			hr = E_FAIL;
			break;
        }
    }
	return hr;
}


void CChordList::SetPatternEditorMode( BYTE bPatternEditorMode )
{
	m_bPatternEditorMode = bPatternEditorMode;
}


HRESULT CChordList::DMLoad(IStream* pStream)
{
	HRESULT		hr = S_OK;
	DWORD		cb;
	DWORD		cSize;
    CChordItem*		pChord;
    ioChordSelection iChordSelection;
    WORD        wSizeChord;
	STATSTG		statstg;
	DWORD		dwIndex = 0;

	if( NULL == pStream )
	{
		return E_POINTER;
	}
	if( hr = FAILED( pStream->Stat( &statstg, STATFLAG_NONAME ) ))
	{
		return hr;
	}

	ClearList();
	cSize = statstg.cbSize.LowPart;

//    cSize = pck->cksize;
//	*plstChord = NULL;
	// load size of chord structure
    hr = pStream->Read( &wSizeChord, sizeof( wSizeChord ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSizeChord ) )
	{
        hr = E_FAIL;
		goto ON_ERR;
	}
	cSize -= cb;
	while( cSize )
	{
        if( wSizeChord > sizeof( ioChordSelection ) )
        {
            hr = pStream->Read( &iChordSelection, sizeof( ioChordSelection ), &cb );
            if( FAILED( hr ) || cb != sizeof( ioChordSelection ) )
            {
				hr = E_FAIL;
				break;
            }
            StreamSeek( pStream, wSizeChord - sizeof( ioChordSelection ), STREAM_SEEK_CUR );
        }
        else
        {
            hr = pStream->Read( &iChordSelection, wSizeChord, &cb );
            if( FAILED( hr ) || cb != wSizeChord )
            {
				hr = E_FAIL;
				break;
            }
        }
        cSize -= wSizeChord;

        pChord = new CChordItem;

        if( pChord == NULL )
		{
            hr = E_OUTOFMEMORY;
            goto ON_ERR;
        }

		memset(pChord->Name(), 0, DMPolyChord::MAX_NAME);		
        WideCharToMultiByte( CP_ACP, 0, iChordSelection.wstrName, -1, pChord->Name(), DMPolyChord::MAX_NAME, NULL, NULL );

		if( iChordSelection.bKeydown)
		{
			pChord->SetSelected(TRUE);
		}
		else
		{
			pChord->SetSelected(FALSE);
		}
		if( iChordSelection.fCSFlags & CSF_SIGNPOST)
		{
			pChord->SetSignPost(TRUE);
		}
		else
		{
			pChord->SetSignPost(FALSE);
		}

		pChord->m_dwIndex = dwIndex++;
		pChord->Beat() = iChordSelection.bBeat;
		pChord->Measure() = iChordSelection.nMeasure;
		pChord->Flags() = iChordSelection.bFlags;

		if( m_bPatternEditorMode != 0xFF )
		{
			// DMUS_CHORDKEYF_SILENT does not apply to chords in pattern editor
			pChord->Flags() &= ~DMUS_CHORDKEYF_SILENT;
		}

		for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
		{
			DMChord* pDM = pChord->SubChord(i);
			pDM->ChordPattern() = iChordSelection.aChord[i].dwChordPattern;
			pDM->ScalePattern() = iChordSelection.aChord[i].dwScalePattern;
			pDM->InvertPattern() = iChordSelection.aChord[i].dwInvertPattern;
			pDM->ChordRoot() = iChordSelection.aChord[i].bChordRoot;
			pDM->ScaleRoot() = iChordSelection.aChord[i].bScaleRoot;
			pDM->Flags() = iChordSelection.aChord[i].wFlags;
			pDM->Levels() = iChordSelection.aChord[i].dwLevels;
			pDM->UseFlat() = iChordSelection.aChord[i].bFlat;
			pDM->InUse() = iChordSelection.aChord[i].bInUse;
			pDM->Bits() = iChordSelection.aChord[i].bBits;
		}
		
		AddTail(pChord);
    }

ON_ERR:
    return hr;
}

HRESULT CChordList::DMSave(IStream* pStream, BOOL bClearDirty)
{
	UNREFERENCED_PARAMETER(bClearDirty);
    HRESULT     hr;
    DWORD       cb;
    WORD        wSize;
    ioChordSelection iChordSelection;
    CChordItem*   pChord;
    int         i;

    wSize = sizeof( ioChordSelection );
    hr = pStream->Write( &wSize, sizeof( wSize ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSize ) )
    {
        return E_FAIL;
    }

	
    for( pChord = GetHead() ; pChord != NULL; pChord = pChord->GetNext() )
    {
        memset( &iChordSelection, 0, sizeof( iChordSelection ) );
        MultiByteToWideChar( CP_ACP, 0, pChord->Name(), -1, iChordSelection.wstrName, sizeof( iChordSelection.wstrName ) / sizeof( wchar_t ) );
        if( pChord->Base()->UseFlat() != 0 )
        {
            iChordSelection.fCSFlags |= CSF_FLAT;
        }
		if( pChord->IsSelected())
		{
			iChordSelection.bKeydown = TRUE;
		}
		else
		{
			iChordSelection.bKeydown = FALSE;
		}
		if( pChord->IsSignPost())
		{
			iChordSelection.fCSFlags |= CSF_SIGNPOST;
		}
        iChordSelection.bBeat = pChord->Beat();
        iChordSelection.nMeasure = pChord->Measure();
        iChordSelection.bFlags = pChord->Flags();
        for( i = 0 ; i < DMPolyChord::MAX_POLY ; ++i )
        {
			DMChord* pDM = pChord->SubChord(i);
            iChordSelection.aChord[i].dwChordPattern = pDM->ChordPattern();
            iChordSelection.aChord[i].dwScalePattern = pDM->ScalePattern();
			iChordSelection.aChord[i].dwInvertPattern = pDM->InvertPattern();
            iChordSelection.aChord[i].bChordRoot = pDM->ChordRoot();
			iChordSelection.aChord[i].bScaleRoot = pDM->ScaleRoot();
			iChordSelection.aChord[i].dwLevels = pDM->Levels();
			iChordSelection.aChord[i].bFlat = pDM->UseFlat();
			iChordSelection.aChord[i].bInUse = pDM->InUse();
			iChordSelection.aChord[i].wFlags = pDM->Flags();
			iChordSelection.aChord[i].bBits = pDM->Bits();
        }
        if( FAILED( pStream->Write( &iChordSelection, sizeof( iChordSelection), &cb ) ) ||
            cb != sizeof( iChordSelection ) )
        {
			hr = E_FAIL;
			break;
        }
    }
	return hr;
}

void CChordList::Transpose(short deltaKey)
{
	CChordItem* pchord = 0;
	for(pchord=GetHead(); pchord; pchord = pchord->GetNext())
	{
		for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
		{
			short root = pchord->SubChord(i)->ChordRoot() + deltaKey;
			if(root < 0)
				root += 12;
			if(root > 23)
				root -= 12;
			pchord->SubChord(i)->ChordRoot() = static_cast<unsigned char>(root);
			pchord->SubChord(i)->ScalePattern() = Rotate24(pchord->SubChord(i)->ScalePattern(), deltaKey);
		}
	}
}

void CChordList::UseFlats(bool bUseFlats)
{
	CChordItem* pchord = 0;
	for(pchord=GetHead(); pchord; pchord = pchord->GetNext())
	{
		for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
		{
			pchord->SubChord(i)->UseFlat() = bUseFlats;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\ChordIO.h ===
#ifndef __CHORDIO_H_
#define __CHORDIO_H_

#include "dmusprod.h"
#include "DWList.h"
#include "PropChord.h"

class ChordEntry;
class ChordSelection;
class CChordItem : public DWListItem, public CPropChord
{
//	Used to track the selection of the chord in display.
	DWORD		m_fSelected;		// Selection and more
public:
	enum {Selected = 1, SignPost = 2}; 
	CChordItem();
	CChordItem(const CChordItem&);
	CChordItem(const ChordEntry&);
	CChordItem(const ChordSelection&);
	CChordItem& operator = (const CChordItem& item)
	{
		*dynamic_cast<CPropChord*>(this) = dynamic_cast<const CPropChord&>(item);
		m_fSelected = item.m_fSelected;
		return *this;
	}
	CChordItem *    GetNext() {return(CChordItem *)DWListItem::GetNext();};

	bool After(const CChordItem& Chord)
	{
		if(m_nMeasure > Chord.m_nMeasure)
			return true;
		else if(m_nMeasure == Chord.m_nMeasure && m_bBeat > Chord.m_bBeat)
			return true;
		else
			return false;
	}
	bool Before(const CChordItem& Chord)
	{
		if(m_nMeasure < Chord.m_nMeasure)
			return true;
		else if(m_nMeasure == Chord.m_nMeasure && m_bBeat < Chord.m_bBeat)
			return true;
		else
			return false;
	}

	bool IsCoincident(const CChordItem& Chord)
	{
		if(m_nMeasure == Chord.m_nMeasure && m_bBeat == Chord.m_bBeat)
			return true;
		else
			return false;
	}

	BOOL IsSelected() { return m_fSelected & Selected; }
	void SetSelected(BOOL b)
	{
		if(b)
		{
			m_fSelected |= Selected;
		}
		else
		{
			m_fSelected &= ~Selected;
		}
	}

	BOOL IsSignPost() { return m_fSelected & SignPost; }
	void SetSignPost(BOOL b)
	{
		if(b)
		{
			m_fSelected |= SignPost;
		}
		else
		{
			m_fSelected &= ~SignPost;
		}
	}

//	Used to manage drawing and indexing.
	long		m_lDrawPosition;	// Drawn position in strip.
	DWORD		m_dwIndex;			// Index in list. (probably not needed anymore)
}; 

class CChordList : public DWList
{
public:
	CChordList()
	{
		m_bPatternEditorMode = 0xFF;
	}
public:
	void Transpose(short deltaKey);
	void UseFlats(bool bUseFlats);
    CChordItem *    GetHead() {return(CChordItem *)DWList::GetHead();};
	CChordItem *	RemoveHead() { return(CChordItem *)DWList::RemoveHead();};
	void		ClearList();
	void		ClearSelections();
	DWORD		PreparePropChord( CPropChord *pPropChord );
	DWORD		RetrievePropChord( CPropChord *pPropChord );
	// *pChord <= *(pChord->next)
	void		InsertByAscendingTime(CChordItem *pChord, bool bReplaceCoincidentChord = false);
	HRESULT		Load( LPSTREAM pStream );
	HRESULT		Save( LPSTREAM pStream, BOOL bClearDirty );
	HRESULT		DMLoad(IStream* pStream);
	HRESULT		DMSave(IStream* pStream, BOOL bClearDirty);
	void		SetPatternEditorMode( BYTE bPatternEditorMode );

private:
	BYTE		m_bPatternEditorMode;
};


typedef struct ioOldChord
{
	long	lChordPattern;	// pattern that defines chord
	long	lScalePattern;	// scale pattern for the chord
	long	lInvertPattern;	// inversion pattern
    BYTE    bRoot;			// root note of chord
	BYTE    bReserved;		// expansion room
	WORD    wCFlags;		// bit flags
	long	lReserved;		// expansion room
} ioOldChord;

typedef struct ioOldChordSelection
{
    wchar_t wstrName[16];   // text for display
    BYTE    fCSFlags;      // ChordSelection flags
    BYTE    bBeat;         // beat this falls on
    WORD    wMeasure;       // measure this falls on
    ioOldChord aChord[4];      // array of chords: levels
    BYTE    bClick;        // click this falls on
} ioOldChordSelection;


typedef struct ioChord
{
	DWORD	dwChordPattern;	// pattern that defines chord
	DWORD	dwScalePattern;	// scale pattern for the chord
	DWORD	dwInvertPattern;	// inversion pattern
	DWORD	dwLevels;				// what levels this chord supports
    BYTE    bChordRoot;			// root note of chord
	BYTE    bScaleRoot;		// root note of scale
	BYTE	bFlat;
	BYTE	bBits;
	WORD    wFlags;		// bit flags
	bool	bInUse;
} ioChord;

typedef struct ioChordSelection
{
    ioChord aChord[DMPolyChord::MAX_POLY];      // array of chords: levels
	DWORD	dwTime;
	short	nMeasure;
	BYTE	bBeat;
	BYTE	bRootIndex;
    wchar_t wstrName[DMPolyChord::MAX_NAME];   // text for display
	bool	bKeydown;
	BYTE	fCSFlags;
	BYTE	bFlags;
} ioChordSelection;

enum
{
	CSF_KEYDOWN = 	1,	// key currently held down in sjam kybd
	CSF_INSCALE = 	2,	// member of scale
	CSF_FLAT =		4,	// display with flat
	CSF_SIMPLE =	8,	// simple chord, display at top of sjam list
	CSF_SELECTED = 0x80, // this chord is selected
	CSF_SIGNPOST = 0x40, // this chord is from a signpost
};
/*
// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}
*/
#endif // __CHORDIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\ChordMgr.h ===
// ChordMgr.h : Declaration of the CChordMgr

#ifndef __CHORDMGR_H_
#define __CHORDMGR_H_

#include "resource.h"       // main symbols
#include "timeline.h"
#include "..\includes\DMUSProd.h"
#include "PropPageMgr.h"
#include "ChordIO.h"
#include "DLLJazzDataObject.h"
#include "MusicTimeConverter.h"
#include "..\shared\SelectedRegion.h"

////////////////////////////////////////////////////////////////////////////////
// Chord Track design-time RIFF chunk header
#define DMUS_FOURCC_CHORD_DESIGN_CHUNK     mmioFOURCC('c','t','d','c')

////////////////////////////////////////////////////////////////////////////////
// Chord Track design-time structure

#pragma pack(2)

struct ioDMChordDesignChunk
{
	ioDMChordDesignChunk()
	{
		m_bDisplayingFlats = 0;
		m_bKeyRoot = 0;
		m_bNumAccidentals = 0;
		m_bPad = 0;
		m_fLockAllScales = true;
		m_fSyncLevelOneToAll = true;
	}

	BYTE	m_bDisplayingFlats;
	BYTE	m_bKeyRoot;
	BYTE	m_bNumAccidentals;
	BYTE	m_bPad;
	bool	m_fLockAllScales;
	bool	m_fSyncLevelOneToAll;
};

#pragma pack()

#define PPQN            192				// IMA pulses per quarter note
#define PPQNx4          ( PPQN << 2 )
#define PPQN_2          ( PPQN >> 1 )

#define DM_PPQN         768				// Direct Music pulses per quarter note
#define DM_PPQNx4       ( DM_PPQN << 2 )
#define DM_PPQN_2       ( DM_PPQN >> 1 )

#define SEL_NONE		0
#define SEL_ONE			1
#define SEL_MULTIPLE	2

#define HIDE_NONE_SELECTED	0
#define HIDE_ALL_ON			1
#define HIDE_ALL_OFF		2
#define HIDE_MIXED			3

#define TRACKCONFIG_VALID_MASK ( DMUS_TRACKCONFIG_NOTIFICATION_ENABLED | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION | DMUS_TRACKCONFIG_CONTROL_ENABLED | DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)


interface IDirectMusicTrack;
/////////////////////////////////////////////////////////////////////////////
// CChordMgr
class ATL_NO_VTABLE CChordMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CChordMgr, &CLSID_ChordMgr>,
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdPropPageObject
{
friend class CChordStrip;
public:
	CChordMgr();
	~CChordMgr();

	enum {DefaultScale = 0xAB5AB5, DefaultKey = 12};
protected:
	IDMUSProdTimeline*		m_pTimeline;
	CChordList				m_ChordList;
	CChordStrip*			m_pChordStrip;
	CPropChord				m_SelectedChord;
	IDMUSProdFramework*		m_pIDMUSProdFramework;
	CPropertyPage*			m_pPropertyPage;
	IDMUSProdPropPageManager*	m_pPropPageMgr;
	IDataObject*		m_pCopyDataObject;
	DWORD					m_dwGroupBits;
	DWORD					m_dwOldGroupBits;
	DWORD					m_dwTrackExtrasFlags;
	DWORD					m_dwProducerOnlyFlags;
	IDirectMusicTrack*		m_pIDMTrack;
	BOOL					m_fUseChordStripPPG;
	BOOL					m_fNeedChordMeasure1Beat1;
	DWORD					m_dwPosition;	// of track in segment
	DWORD					m_dwScale;
	BYTE					m_bKey;
	BYTE					m_bPatternEditorMode;

	BOOL					m_fDisplayingFlats;
	int						m_nKeyRoot;
	int						m_nNumAccidentals;

	bool					m_fLockAllScales;
	bool					m_fSyncLevelOneToAll;
public:
DECLARE_REGISTRY_RESOURCEID(IDR_CHORDMGR)

BEGIN_COM_MAP(CChordMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()


// IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

// IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( /* [retval][out] */ void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( /* [in] */ void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties( void);
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void);

// IDMUSProdStripMgr
public:
	bool UseFlatsNotSharps(BYTE bKey, DWORD dwScale);
	HRESULT SaveSelectedChords(IStream* pStream, long offset);
	void SelectAll();
	HRESULT GetSpanOfChordList(long& lStartTime, long& lEndTime, CChordList* pList = NULL, bool bSelectedChordsOnly = false);
	HRESULT GetBoundariesOfSelectedChords(long& lStartTime, long& lEndTime);
	BOOL SelectSegment(long begintime, long endtime);

	HRESULT STDMETHODCALLTYPE IsParamSupported(
		/* [in] */ REFGUID		guidType);
	HRESULT STDMETHODCALLTYPE GetParam(
		/* [in] */  REFGUID		guidType,
		/* [in] */  MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME*	pmtNext,
		/* [out] */ void*		pData);
	HRESULT STDMETHODCALLTYPE SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData);
	HRESULT STDMETHODCALLTYPE OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData);
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( 
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant);
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( 
		/* [in] */ STRIPMGRPROPERTY smp,
		/* [in] */ VARIANT		variant);

protected:
//	HRESULT LoadChordList( LPSTREAM pStream );
//	HRESULT SaveChordList( LPSTREAM );
	HRESULT	DeleteSelectedChords();
	// pChordAtDragPoint == NULL means ignore
	HRESULT SaveSelectedChords(LPSTREAM, CChordItem* pChordAtDragPoint, BOOL bNormalize = FALSE,
								long* pNormalOffset=0);
	HRESULT GetTimeSig(long* top, long* bottom, long mtTime);
// general helpers
	HRESULT NormalizeChordList(CChordList& list, long clockOffset, long* pStartClocks=0, long* pEndClocks=0);

	// marks m_dwUndermined field CChordItems in list
	void MarkSelectedChords(DWORD flags);
	// unmarks flag m_dwUndermined field CChordItems in list
	void UnMarkChords(DWORD flags);
	// deletes chords marked by given flag
	void DeleteMarkedChords(DWORD flags);
	void UnselectChords();
	HRESULT UpdateDirectMusic( BOOL fUpdateSegmentDesigner );
	HRESULT ImportChordsFromChordTrack( void );
	HRESULT ImportKeyFromChordTrack( void );
	
// Misc
	bool	IsSelected();				// returns if one or more chords are selected.
	short	HowManySelected();			// returns SEL_NONE, SEL_ONE, SEL_MULTIPLE
	short	GetSelectedHideState();		// returns HIDE_ALL_ON, HIDE_ALL_OFF, HIDE_MIXED
	CChordItem* FirstSelectedChord();
	void RecalculateMusicTimeValue(CChordItem* pChord);
	bool IsChordAt(long measure, long beat);
	long ShiftChordsBackwards(long measure, long bpm);
	void	RecalculateMusicTimeValues();
	void	UpdateMasterScaleAndKey(); // Updates m_dwScale and m_bKey based on the key root and # of sharps/flats
	void	UpdateKeyRootAndAccidentals(); // Updates m_nNumAccidentals and m_nKeyRoot from m_dwScale and m_bKey
};


class CChordStrip : public IDMUSProdStrip, public IDMUSProdStripFunctionBar, public IDMUSProdTimelineEdit,
	public IDropSource, public IDropTarget,
	public IDMUSProdPropPageObject
{
friend class CChordMgr;
protected:
	long	m_cRef;
	long	m_lBeginSelect;
	long	m_lEndSelect;
	bool	m_bMouseSelect;
	CListSelectedRegion*	m_pSelectedRegions;
	CChordMgr*			m_pChordMgr;
	IDMUSProdStripMgr*  m_pStripMgr;
	BOOL	m_bGutterSelected;	// whether the gutter select is selected
	BOOL	m_bSelecting;
public:
	CChordStrip( CChordMgr* pChordMgr )
	{
		ASSERT( pChordMgr );
		m_bLeftMouseButtonDown =false;
		m_pSelectedRegions = 0;
		m_pChordMgr = pChordMgr;
		m_pStripMgr = (IDMUSProdStripMgr*)pChordMgr;
		//m_pStripMgr->AddRef();
		m_cRef = 0;
		AddRef();
		m_bGutterSelected = FALSE;
		m_bSelecting = FALSE;
		m_bMouseSelect = false;
		m_lBeginSelect = 0;
		m_lEndSelect = 0;
		m_pISourceDataObject = NULL;
		m_pITargetDataObject = NULL;
		m_dwStartDragButton = 0;
		m_dwOverDragButton = 0;
		m_dwOverDragEffect = 0;
		m_dwDragRMenuEffect = DROPEFFECT_NONE;
		m_nLastEdit = 0;
		m_fShowChordProps = FALSE;
		m_lXPos = -1;
		m_startDragPosition = 0;
		m_fPropPageActive = FALSE;
		m_pPropPageMgr = NULL;
		m_nStripIsDragDropSource = 0;
		m_cfChordList = 0;
	};

	~CChordStrip()
	{
		//m_pStripMgr->Release();
		if ( m_pPropPageMgr )
		{
			m_pPropPageMgr->Release();
		}

		if(m_pSelectedRegions)
		{
			delete m_pSelectedRegions;
		}
	}

private:
	HRESULT StartDragDrop(IDMUSProdTimeline* pTimeline, LONG lXPos);
	void SelectChordsInSelectedRegions();
	void SelectRegionsFromSelectedChords();
	void FormatNameForDrawRoutine( CString& strName, CChordItem* pChord );
	HRESULT NormalizeSelectedRegions(CListSelectedRegion& list, long clockoffset, 
									 long* pStartClocks=0, long* pEndClocks=0);
	HRESULT SaveSelectedRegions(IStream* pIStream, long offset, bool bNormalize);
	HRESULT PostRightClickMenu(IDMUSProdTimeline* pTimeline, POINT pt);
	HRESULT DoRightClickMenu(IDMUSProdTimeline* pTimeline, POINT pt);
	HRESULT ShowPropertySheet(IDMUSProdTimeline*);
	void UnselectGutterRange( void );
	BOOL ProcessKey(int nVirtKey, unsigned long lKeyData);
	CChordItem *		GetChordFromPoint( long lPos );
	LONG			m_lXPos;		// used for temp storage of xpos when doing mouse edits

	IDataObject*	m_pISourceDataObject;			// Object being dragged	
	IDataObject*	m_pITargetDataObject;
	bool			m_bLeftMouseButtonDown;
	DWORD			m_dwStartDragButton;	// Mouse button that initiated drag operation
	DWORD			m_dwOverDragButton;		// Mouse button stored in IDropTarget::DragOver
	DWORD			m_dwOverDragEffect;		// Drag effects stored in IDropTarget::DragOver
	DWORD			m_dwDragRMenuEffect;	// Result from drag context menu
	UINT			m_cfChordList;
	LONG			m_startDragPosition;	// xpos where drag was started
	UINT			m_nLastEdit;			// resource id of last edit
	short			m_nStripIsDragDropSource;	

	BOOL			m_fShowChordProps;
	BOOL			m_fPropPageActive;
	IDMUSProdPropPageManager *m_pPropPageMgr;
// IUnknown
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
// IDMUSProdStrip
public:
	HRESULT	STDMETHODCALLTYPE	Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
    HRESULT STDMETHODCALLTYPE	GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
    HRESULT STDMETHODCALLTYPE	SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE	OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit
	HRESULT STDMETHODCALLTYPE Cut( /* in */ IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Copy( /* in */ IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( /* in */ IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDropSource
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );

// IDropSource helpers
	CImageList* CreateDragImage();
	HRESULT		CreateDataObject(IDataObject**, long position);

// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

// IDropTarget helpers
	CWnd* GetTimelineCWnd();
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteReplace(CChordList& list, CMusicTimeConverter& cmtStart, CMusicTimeConverter& cmtEnd, BOOL& fChanged);
	HRESULT PasteMerge(CChordList& list, CMusicTimeConverter& cmtStart, CMusicTimeConverter& cmtEnd, BOOL& fChanged);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, POINTL pt, bool bDropNotEditPaste);

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

};


inline bool CListSelectedRegion_Contains(CListSelectedRegion& csrList, CChordItem& chord)
{
	return csrList.Contains(chord.Measure(), chord.Beat());
}

// add a region using a chord's position and duration (1 beat)
inline void CListSelectedRegion_AddRegion(CListSelectedRegion& csrList, CChordItem& chord)
{
	CMusicTimeConverter cmtBeg(chord.Measure(), chord.Beat(), csrList.Timeline(), csrList.GroupBits());
	CMusicTimeConverter cmtEnd = cmtBeg;
	cmtEnd.AddOffset(0,1, csrList.Timeline(), csrList.GroupBits());
	CSelectedRegion* psr = new CSelectedRegion(cmtBeg, cmtEnd);
	csrList.AddHead(psr);
}



#endif //__CHORDMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\ChordScalePropPage.h ===
#if !defined(AFX_CHORDSCALEPROPPAGE_H__E4A7E135_B485_11D1_9875_00805FA67D16__INCLUDED_)
#define AFX_CHORDSCALEPROPPAGE_H__E4A7E135_B485_11D1_9875_00805FA67D16__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <afxext.h>
#include "resource.h"
#include "dmusici.h"
#include "conductor.h"
#include "..\shared\keyboard.h"
// ChordScalePropPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CChordScalePropPageData (used to transfer data to/from property tab)

class CChordScalePropPageData
{
public:
	CChordScalePropPageData()
	{
		m_pPropChord = NULL;
		m_fLockAllScales = true;
		m_fSyncLevelOneToAll = true;
	}
	
	~CChordScalePropPageData()
	{
	}

	CPropChord*			m_pPropChord;
	bool				m_fLockAllScales;
	bool				m_fSyncLevelOneToAll;
};


/////////////////////////////////////////////////////////////////////////////
// CChordScalePropPage dialog
class CChordPropPageMgr;

class CChordScalePropPage : public CPropertyPage, public IDMUSProdMidiInCPt
{
	friend class CChordPropPageMgr;
	DECLARE_DYNCREATE(CChordScalePropPage)

// Construction
public:
	enum { MAX_POLY = 4 , CHORDNOTE_DUR = 250, SCALENOTE_DUR = 250, CHORDNOTE_DELAY = 125, SCALENOTE_DELAY=25};
	CChordScalePropPage();
	~CChordScalePropPage();
// dispatch callbacks from keyboard controls
	void DispatchKeyboardChange(CKeyboard* pKeyboard, short nKey);

// Dialog Data
	//{{AFX_DATA(CChordScalePropPage)
	enum { IDD = IDD_CHORDSCALE_PROPPAGE };
	CSpinButtonCtrl	m_spinRoot;
	CEdit	m_chordname;
	CKeyboard	m_keysscale4;
	CKeyboard	m_keysscale3;
	CKeyboard	m_keysscale2;
	CKeyboard	m_keysscale1;
	CKeyboard	m_keyschord4;
	CKeyboard	m_keyschord3;
	CKeyboard	m_keyschord2;
	CKeyboard	m_keyschord1;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChordScalePropPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChordScalePropPage)
	virtual BOOL OnInitDialog();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnButtonMidichord4();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnButtonMidichord1();
	afx_msg void OnButtonMidichord2();
	afx_msg void OnButtonMidichord3();
	afx_msg void OnButtonMidiroot();
	afx_msg void OnButtonMidiscale1();
	afx_msg void OnButtonMidiscale2();
	afx_msg void OnButtonMidiscale3();
	afx_msg void OnButtonMidiscale4();
	afx_msg void OnButtonPlay1();
	afx_msg void OnButtonPlay2();
	afx_msg void OnButtonPlay3();
	afx_msg void OnButtonPlay4();
	afx_msg void OnButtonPlayall();
	afx_msg void OnChangeEditName();
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnUseflats();
	afx_msg void OnUsesharps();
	afx_msg void OnDeltaposSpinRoot(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL m_bValid;
public:
	void EnableControls(BOOL bEnable);
	void WarnUser();
	void DispatchRightMouseKeyboard(CKeyboard* pKeyboard, short nKey, CPoint& ptMouse);
	HRESULT ChangePatch(BYTE ch, BYTE inst, BYTE msb, BYTE lsb);
	HRESULT PlayNote(BYTE ch, BYTE key, BYTE vel, DWORD startTime, DWORD dur);
	void PlayAllChords();
	void PlaySubChord(int index);
	void SetMidiIn(int keyboard);
	void SetChord(CPropChord* pChord);
	void SetChordData(CChordScalePropPageData* pChordScalePropPageData);
	void UpdateChordData();
	// IUnknown functions
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IDMUSProdMidiInCPt functions
	HRESULT STDMETHODCALLTYPE OnMidiMsg(REFERENCE_TIME rtTime, 
										BYTE bStatus, 
										BYTE bData1, 
										BYTE bData2);

	// data transfer functions
	void CopyDataToTab(  CPropChord* pTabData );
	void GetDataFromTab( const CPropChord* pTabData );

private:
	BOOL m_bNotWarn;
	enum {All = -1, Nop = 1000, CopyChord, CopyScale, CopyChordScale, ClearChordScale};	// chord to chord copy ops
	void ComputeCopyOp(WORD menuid, int& from, int& to, int& what);
	CButton* GetButton(int id);
	enum {None = -1, Chord1 = 0, Chord2 = 1, Chord3 = 2, Chord4 = 3, Scale1 = 4, Scale2 = 5, Scale3 = 6, Scale4 = 7, Root = 8};
	UINT	m_MidiInIds[MAX_POLY*2 + 1];
	int m_fMidiInputTarget;
	void OnChangeRoot( bool fUpdateChordData );
	void SetCheckBox(CPropChord* pChord, DWORD dwUDFlag, UINT nDlgID, UINT nState);
	void OnNoteDownChordKeys(CKeyboard* pKeyboard, int index, short nKey);
	void OnNoteDownScaleKeys(CKeyboard* pKeyboard, int index, short nKey);
//	void DrawScaleNote(CPropChord* pChord, int index, short nX);
	void DrawScale(CPropChord* pChord, int index, int note = -1 /* set this to do only one note */);
	int	GetChordKeyboardIndex(const CKeyboard* pKeyboard);
	int GetScaleKeyboardIndex(const CKeyboard* pKeyboard);
	int m_nLastKeyboardLevel;	// keyboard last rightclicked on (for copy ops)
	CKeyboard*		GetChordKeyboard(int index)
	{
		switch(index)
		{
		case 0:
			return &m_keyschord1;			
			break;
		case 1:
			return &m_keyschord2;
			break;
		case 2:
			return &m_keyschord3;
			break;
		case 3:
			return &m_keyschord4;
			break;
		default:
			return 0;
			break;
		}
	}
	CKeyboard*		GetScaleKeyboard(int index)
	{
		switch(index)
		{
		case 0:
			return &m_keysscale1;
			break;
		case 1:
			return &m_keysscale2;
			break;
		case 2:
			return &m_keysscale3;
			break;
		case 3:
			return &m_keysscale4;
			break;
		default:
			return 0;
			break;
		}
	}

	CBitmapButton	m_midichord4;
	CBitmapButton	m_midichord3;
	CBitmapButton	m_midichord2;
	CBitmapButton	m_midichord1;
	CBitmapButton* GetMidiChordButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_midichord1;			
			break;
		case 1:
			return &m_midichord2;
			break;
		case 2:
			return &m_midichord3;
			break;
		case 3:
			return &m_midichord4;
			break;
		default:
			return 0;
			break;
		}
	}

	CBitmapButton	m_midiscale4;
	CBitmapButton	m_midiscale3;
	CBitmapButton	m_midiscale2;
	CBitmapButton	m_midiscale1;
	CBitmapButton*	GetMidiScaleButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_midiscale1;
			break;
		case 1:
			return &m_midiscale2;
			break;
		case 2:
			return &m_midiscale3;
			break;
		case 3:
			return &m_midiscale4;
			break;
		default:
			return 0;
			break;
		}
	}

	
	CBitmapButton	m_midiroot;
	
	CBitmapButton	m_shiftl4;
	CBitmapButton	m_shiftl3;
	CBitmapButton	m_shiftl2;
	CBitmapButton	m_shiftl1;
	CBitmapButton* GetShiftLButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_shiftl1;
			break;
		case 1:
			return &m_shiftl2;
			break;
		case 2:
			return &m_shiftl3;
			break;
		case 3:
			return &m_shiftl4;
			break;
		default:
			return 0;
			break;
		}
	}

	CBitmapButton	m_shiftr4;
	CBitmapButton	m_shiftr3;
	CBitmapButton	m_shiftr2;
	CBitmapButton	m_shiftr1;
	CBitmapButton* GetShiftRButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_shiftr1;
			break;
		case 1:
			return &m_shiftr2;
			break;
		case 2:
			return &m_shiftr3;
			break;
		case 3:
			return &m_shiftr4;
			break;
		default:
			return 0;
			break;
		}
	}
	
	CBitmapButton	m_play4;
	CBitmapButton	m_play3;
	CBitmapButton	m_play2;
	CBitmapButton	m_play1;
	CBitmapButton* GetPlayButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_play1;
			break;
		case 1:
			return &m_play2;
			break;
		case 2:
			return &m_play3;
			break;
		case 3:
			return &m_play4;
			break;
		default:
			return 0;
			break;
		}
	}
		
	CBitmapButton		m_playall;
	
	CPropChord			m_Chord;
	bool				m_fLockAllScales;
	bool				m_fSyncLevelOneToAll;

	BOOL				m_fNeedToDetach;
	bool				m_bValidChord;
	DWORD				m_cRef;
	CChordPropPageMgr*	m_pPropPageMgr;
	IDMUSProdConductor*	m_pIConductor;
	IDirectMusicPerformance*	m_pIPerformance;
	void RegisterMidi();
	void UnRegisterMidi();
	DWORD m_dwCookie;		// may be used to distinguish what chord is receiving input (if necessary)
	DWORD m_cRegCount;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHORDSCALEPROPPAGE_H__E4A7E135_B485_11D1_9875_00805FA67D16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\ChordMgr.cpp ===
// ChordMgr.cpp : Implementation of CChordMgr
#include "stdafx.h"
#include "ChordIO.h"
#include "ChordStripMgr.h"
#include "ChordMgr.h"
#include "RiffStrm.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "chordstripriff.h"
#include "SegmentGuids.h"
#include "SegmentIO.h"
#include <ChordMapDesigner.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CChordMgr

CChordMgr::CChordMgr()
{
	m_pTimeline = NULL;
	m_pIDMUSProdFramework = NULL;
	m_pPropertyPage = NULL;
	m_pPropPageMgr = NULL;
	m_pCopyDataObject = NULL;
	m_pChordStrip = NULL;
	m_dwGroupBits = 1;
	m_dwOldGroupBits = 1;
	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;
	m_dwProducerOnlyFlags = 0;
	m_pIDMTrack = NULL;
	m_fUseChordStripPPG = TRUE;
	m_fNeedChordMeasure1Beat1 = FALSE;
	m_bPatternEditorMode = 0xFF;
	m_bKey = 0;
	m_dwScale = 0xAB5AB5;	
	m_fDisplayingFlats = FALSE;
	m_nKeyRoot = 0;
	m_nNumAccidentals = 0;
	m_fLockAllScales = true;
	m_fSyncLevelOneToAll = true;
	m_pChordStrip = new CChordStrip(this);
	ASSERT( m_pChordStrip );
}

CChordMgr::~CChordMgr()
{
	if( m_pIDMUSProdFramework )
	{
		m_pIDMUSProdFramework->Release();
	}
	m_ChordList.ClearList();
	ASSERT( m_pTimeline == NULL );
	ASSERT( m_pPropertyPage == NULL );
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
	}
	if( m_pIDMTrack )
	{
		m_pIDMTrack->Release();
	}
	if( m_pChordStrip )
	{
		m_pChordStrip->Release();
	}
	if( m_pCopyDataObject )
	{
		if( S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CChordMgr IDMUSProdStripMgr

HRESULT STDMETHODCALLTYPE CChordMgr::GetParam(
		/* [in] */  REFGUID		guidType,
		/* [in] */  MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME*	pmtNext,
		/* [out] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pData != NULL );
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		BSTR bstr;
		CString str;
		str.LoadString(m_pChordStrip->m_nLastEdit);
		try
		{
			bstr = str.AllocSysString();
		}
		catch(CMemoryException*)
		{
			return E_OUTOFMEMORY;
		}
		*(BSTR*)pData = bstr;
		return S_OK;
	}

	else if( ::IsEqualGUID( guidType, GUID_PatternEditorMode ) )
	{
		BYTE* pPatternEditorMode = (BYTE *)pData;

		*pPatternEditorMode= m_bPatternEditorMode;
		return S_OK;
	}

	else if( ::IsEqualGUID( guidType, GUID_ChordParam ) )
	{

		HRESULT hr = E_FAIL;
		long lChordMeasure = 0;
		long lChordBeat = 0;
		// convert mtTime into Measure/Beat
		CMusicTimeConverter cmt(mtTime);

		if(m_pTimeline)
		{
			hr = cmt.GetMeasureBeat(lChordMeasure, lChordBeat, m_pTimeline, m_dwGroupBits, 0);
		}
		else
		{
			hr = cmt.GetMeasureBeat(lChordMeasure, lChordBeat, 4, 4);
		}


		CChordItem* pTheChord = m_ChordList.GetHead();
		CChordItem* pNext = pTheChord ? pTheChord->GetNext() : NULL;

		while( pNext )
		{
			if( pNext->Measure() > lChordMeasure )
			{
				break;
			}

			if( pNext->Measure() == lChordMeasure
			&&  pNext->Beat() > lChordBeat )
			{
				break;
			}

			pTheChord = pNext;
			pNext = pNext->GetNext();
		}

		if( pTheChord )
		{
			DMUS_CHORD_PARAM* pchordData = (DMUS_CHORD_PARAM *)pData;

			// Set key/scale of chord strip
			pchordData->bKey = m_bKey;
			pchordData->dwScale = m_dwScale;

			// Set chord information
	        MultiByteToWideChar( CP_ACP, 0, pTheChord->Name(), -1, 
				pchordData->wszName, sizeof( pchordData->wszName ) / sizeof( wchar_t ) );
			pchordData->wMeasure = pTheChord->Measure();
			pchordData->bBeat = pTheChord->Beat();
			pchordData->bSubChordCount = DMPolyChord::MAX_POLY;


			for( int i=0 ;  i<DMPolyChord::MAX_POLY ;  i++ )
			{
				pchordData->SubChordList[i].dwChordPattern 
					= dynamic_cast<DMPolyChord*>(pTheChord)->SubChord(i)->ChordPattern();
				pchordData->SubChordList[i].dwScalePattern 
					= dynamic_cast<DMPolyChord*>(pTheChord)->SubChord(i)->ScalePattern();
				pchordData->SubChordList[i].dwInversionPoints 
					= dynamic_cast<DMPolyChord*>(pTheChord)->SubChord(i)->InvertPattern();
				pchordData->SubChordList[i].dwLevels 
					= dynamic_cast<DMPolyChord*>(pTheChord)->SubChord(i)->Levels();
				pchordData->SubChordList[i].bChordRoot 
					= dynamic_cast<DMPolyChord*>(pTheChord)->SubChord(i)->ChordRoot();
				pchordData->SubChordList[i].bScaleRoot 
					= dynamic_cast<DMPolyChord*>(pTheChord)->SubChord(i)->ScaleRoot();
			}

			if( pmtNext )
			{
				if( pNext )
				{
					CMusicTimeConverter cmtNext;
					if(m_pTimeline)
					{
						cmtNext.SetTime(pNext->Measure(), pNext->Beat(), m_pTimeline, m_dwGroupBits, 0);
					}
					else
					{
						cmtNext.Time() = pNext->Time();
					}
					*pmtNext = cmtNext.Time() - mtTime;
				}
				else
				{
					*pmtNext = 0;
				}
			}

			return S_OK;
		}
		else
		{
			return E_FAIL;
		}

	}

	// Get overall key
	else if( ::IsEqualGUID( guidType, GUID_ChordKey ) )
	{
		DWORD* pdwKey = (DWORD *)pData;

		ASSERT( m_nKeyRoot >= 0 );
		ASSERT( m_nNumAccidentals >= 0);
		*pdwKey = (m_nKeyRoot & 0x0000FFFF) | ((m_nNumAccidentals & 0x0000FFFF) << 16);
		return S_OK;
	}

	// Get sharps/flats flag
	else if( ::IsEqualGUID( guidType, GUID_ChordSharpsFlats ) )
	{
		BOOL* pfDisplayingFlats = (BOOL *)pData;

		*pfDisplayingFlats= m_fDisplayingFlats;
		return S_OK;
	}
	// get sharps/flats flag for an individual chord
	else if(::IsEqualGUID( guidType, GUID_ChordIndividualChordSharpsFlats))
	{
		HRESULT hr = E_FAIL;
		long lMeasure = 0;
		long lBeat = 0;
		// convert mtTime into Measure/Beat
		CMusicTimeConverter cmt(mtTime);

		if(m_pTimeline)
		{
			hr = cmt.GetMeasureBeat(lMeasure, lBeat, m_pTimeline, m_dwGroupBits, 0);
		}
		else
		{
			hr = cmt.GetMeasureBeat(lMeasure, lBeat, 4, 4);
		}

		BOOL* pfDisplayingFlats = (BOOL *)pData;
		for(CChordItem* pChord = m_ChordList.GetHead(); pChord; pChord = pChord->GetNext())
		{
			if(pChord->Measure() == lMeasure && pChord->Beat() == lBeat)
			{
				*pfDisplayingFlats = pChord->SubChord(pChord->RootIndex())->UseFlat();
				return S_OK;
			}
		}
		return E_INVALIDARG;
	}
/* not necessary in a get
	if( m_pTimeline )
	{
		m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)m_pChordStrip, NULL, TRUE );
	}
*/

	return E_INVALIDARG;
}

HRESULT STDMETHODCALLTYPE CChordMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = E_INVALIDARG;

	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID( guidType, GUID_UseGroupBitsPPG ) )
	{
		BOOL* pUseGroupBitsPPG = (BOOL *)pData;

		m_fUseChordStripPPG = *pUseGroupBitsPPG;
		hr = S_OK;
	}

	else if( ::IsEqualGUID( guidType, GUID_PatternEditorMode ) )
	{
		BYTE* pPatternEditorMode = (BYTE *)pData;

		m_bPatternEditorMode = *pPatternEditorMode;
		hr = S_OK;
	}

	else if( ::IsEqualGUID( guidType, GUID_NeedChordMeasure1Beat1 ) )
	{
		BOOL* pNeedChordMeasure1Beat1 = (BOOL *)pData;

		m_fNeedChordMeasure1Beat1 = *pNeedChordMeasure1Beat1;
		hr = S_OK;
	}

	else if( ::IsEqualGUID( guidType, GUID_ChordParam))
	{
		long lMeasure = 0;
		long lBeat = 0;
		// convert mtTime into Measure/Beat
		CMusicTimeConverter cmt(mtTime);

		if(m_pTimeline)
		{
			hr = cmt.GetMeasureBeat(lMeasure, lBeat, m_pTimeline, m_dwGroupBits, 0);
		}
		else
		{
			hr = cmt.GetMeasureBeat(lMeasure, lBeat, 4, 4);
		}

		CChordItem* pChord = new CChordItem;
		DMUS_CHORD_PARAM* pChordParam = (DMUS_CHORD_PARAM*)pData;

		memset(pChord, 0, sizeof(CChordItem));

		WideCharToMultiByte(CP_ACP, 0, pChordParam->wszName, -1, pChord->Name(), DMPolyChord::MAX_NAME, NULL, NULL);

		pChord->Measure() = static_cast<WORD>(lMeasure);
		pChord->Beat() = static_cast<BYTE>(lBeat);
		ASSERT(pChordParam->bSubChordCount <= DMPolyChord::MAX_POLY);
		ASSERT(pChordParam->bSubChordCount > 0);

		if(pChordParam->bSubChordCount > DMPolyChord::MAX_POLY || pChordParam->bSubChordCount == 0)
		{
			delete pChord;
			return E_INVALIDARG;
		}

		for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
		{
			if(i >= pChordParam->bSubChordCount)
			{
				pChord->SubChord(i)->UseFlat() = 0;
				pChord->SubChord(i)->Levels() = 1 << i;
				pChord->SubChord(i)->ChordPattern() = pChord->SubChord(0)->ChordPattern();
				pChord->SubChord(i)->ChordRoot() = pChord->SubChord(0)->ChordRoot();
				pChord->SubChord(i)->ScalePattern() = pChord->SubChord(0)->ScalePattern();
				pChord->SubChord(i)->ScaleRoot() = pChord->SubChord(0)->ScaleRoot();
				pChord->SubChord(i)->InvertPattern() = pChord->SubChord(0)->InvertPattern();
			}
			else
			{
				pChord->SubChord(i)->UseFlat() = 0;
				pChord->SubChord(i)->Levels() = pChordParam->SubChordList[i].dwLevels;
				pChord->SubChord(i)->ChordPattern() = pChordParam->SubChordList[i].dwChordPattern;
				pChord->SubChord(i)->ChordRoot() = pChordParam->SubChordList[i].bChordRoot;
				pChord->SubChord(i)->ScalePattern() = pChordParam->SubChordList[i].dwScalePattern;
				pChord->SubChord(i)->ScaleRoot() = pChordParam->SubChordList[i].bScaleRoot;
				pChord->SubChord(i)->InvertPattern() = pChordParam->SubChordList[i].dwInversionPoints;
			}
		}
		m_ChordList.InsertByAscendingTime(pChord);
		hr = S_OK;
	}
	// Change overall key
	else if( ::IsEqualGUID( guidType, GUID_ChordKey ) )
	{
		DWORD dwKey = *(DWORD *)pData;
		m_nKeyRoot = dwKey & 0xFFFF;
		m_nNumAccidentals = (dwKey >> 16) & 0xFFFF;
		UpdateMasterScaleAndKey();
		hr =  S_OK;
	}
	// change sharps/flats flag
	else if( ::IsEqualGUID( guidType, GUID_ChordSharpsFlats ) )
	{
		m_fDisplayingFlats = *(BOOL *)pData;
		UpdateMasterScaleAndKey();
		hr = S_OK;
	}
	// change sharps/flats flag in an individual chord
	else if(::IsEqualGUID( guidType, GUID_ChordIndividualChordSharpsFlats))
	{
		long lMeasure = 0;
		long lBeat = 0;
		// convert mtTime into Measure/Beat
		CMusicTimeConverter cmt(mtTime);

		if(m_pTimeline)
		{
			hr = cmt.GetMeasureBeat(lMeasure, lBeat, m_pTimeline, m_dwGroupBits, 0);
		}
		else
		{
			hr = cmt.GetMeasureBeat(lMeasure, lBeat, 4, 4);
		}

		BOOL fDisplayingFlats = *(BOOL *)pData;
		for(CChordItem* pChord = m_ChordList.GetHead(); pChord; pChord = pChord->GetNext())
		{
			if(pChord->Measure() == lMeasure && pChord->Beat() == lBeat)
			{
				for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
				{
					pChord->SubChord(i)->UseFlat() = fDisplayingFlats;
				}
				hr = S_OK;
				break;
			}
		}
		hr = E_INVALIDARG;
	}

	if( m_pTimeline )
	{
		m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)m_pChordStrip, NULL, TRUE );
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CChordMgr::IsParamSupported(
		/* [in] */ REFGUID		guidType)
{
	if( ::IsEqualGUID( guidType, GUID_ChordParam )
	||  ::IsEqualGUID( guidType, GUID_PatternEditorMode )
	||  ::IsEqualGUID( guidType, GUID_ChordKey )
	||  ::IsEqualGUID( guidType, GUID_ChordSharpsFlats )
	||	::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) 
	||  ::IsEqualGUID( guidType, GUID_ChordIndividualChordSharpsFlats))
	{
		return S_OK;
	}
	return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CChordMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwGroupBits);
	UNREFERENCED_PARAMETER(pData);

	// TimeSig change
	if( ::IsEqualGUID( rguidType, GUID_TimeSignature ) )
	{
		RecalculateMusicTimeValues();
		if( m_pTimeline )
		{
			m_pTimeline->OnDataChanged( (IDMUSProdStripMgr *)this );
		}
		UpdateDirectMusic( FALSE );
		return S_OK;
	}

	// All tracks added
	else if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		RecalculateMusicTimeValues();
		UpdateDirectMusic( FALSE );
		return S_OK;
	}

	// Pattern track group bits change
	else if( ::IsEqualGUID( rguidType, CLSID_DirectMusicPatternTrack ) )
	{
		// Check if there are any MIDIStripMgrs in m_dwGroupBits
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( m_pTimeline->GetStripMgr( CLSID_DirectMusicPatternTrack, m_dwGroupBits, 0, &pStripMgr ) ) )
		{
			pStripMgr->Release();
		}
		else
		{
			// No MIDIStripMgrs, reset the CHORDSTRIP_MODE to nothing
			m_bPatternEditorMode = 0xFF;

			// Redraw the strip
			m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)m_pChordStrip, NULL, TRUE );
		}
		return S_OK;
	}

	return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CChordMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMUSProdFramework )
		{
			return m_pIDMUSProdFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackHeader->guidClassID = CLSID_DirectMusicChordTrack;
			pioTrackHeader->dwPosition = 0;
			pioTrackHeader->dwGroup = m_dwGroupBits;
			pioTrackHeader->ckid = NULL;
			pioTrackHeader->fccType = DMUS_FOURCC_CHORDTRACK_LIST;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER_MASK:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = TRACKCONFIG_VALID_MASK;
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( pVariant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			pioProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}

		// If we were previously attached to a timeline, remove our PropPageObject and strip from it
		if( m_pTimeline )
		{
			m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);
			if( m_pChordStrip )
			{
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)m_pChordStrip);
				m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pChordStrip );
			}
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, CLSID_DirectMusicPatternTrack, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwOldGroupBits );
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}

		if( V_UNKNOWN( &variant ) )
		{
			if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
			{
				return E_FAIL;
			}
			else
			{
//				RecalculateMusicTimeValues();
//				UpdateDirectMusic( FALSE );

				m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pChordStrip, CLSID_DirectMusicChordTrack, m_dwGroupBits, 0 );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, CLSID_DirectMusicPatternTrack, m_dwGroupBits );
			}
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
		}
		if( V_UNKNOWN( &variant ) )
		{
			V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack );
		}
		else
		{
			m_pIDMTrack = NULL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIDMUSProdFramework )
		{
			m_pIDMUSProdFramework->Release();
			m_pIDMUSProdFramework = NULL;
		}
		if( V_UNKNOWN( &variant ) )
		{
			return V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pIDMUSProdFramework);
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}
			m_dwGroupBits = pioTrackHeader->dwGroup;
			m_dwOldGroupBits = pioTrackHeader->dwGroup;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
		}
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( &variant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			m_dwProducerOnlyFlags = pioProducerOnlyChunk->dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CChordMgr IPersist

HRESULT CChordMgr::GetClassID( CLSID* pClsId )
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CChordMgr IPersistStream functions

HRESULT CChordMgr::IsDirty()
{
	return S_FALSE;
}

HRESULT CChordMgr::Load( IStream* pStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pStream == NULL )
	{
		ImportKeyFromChordTrack();
		return ImportChordsFromChordTrack();
	}

	IDMUSProdRIFFStream*	pRiffStream;
    MMCKINFO				ck;
	HRESULT					hr;
	if( FAILED( hr = AllocRIFFStream( pStream, &pRiffStream ) ) )
	{
		return hr;
	}

	// Load the Track
	while( pRiffStream->Descend( &ck, NULL, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
		case DMUS_FOURCC_CHORD_DESIGN_CHUNK:
			{
				ioDMChordDesignChunk iDesignChunk;

				DWORD cbRead, dwSize = min ( ck.cksize, sizeof(ioDMChordDesignChunk) );
				if( SUCCEEDED( pStream->Read( &iDesignChunk, dwSize, &cbRead) ) 
				 && (cbRead == dwSize) )
				{
					m_fDisplayingFlats = (iDesignChunk.m_bDisplayingFlats != 0);
					m_nKeyRoot = iDesignChunk.m_bKeyRoot;
					m_nNumAccidentals = iDesignChunk.m_bNumAccidentals;
					m_fLockAllScales = iDesignChunk.m_fLockAllScales;
					m_fSyncLevelOneToAll = iDesignChunk.m_fSyncLevelOneToAll;
					// make all chord display or not display flats according to m_fDisplayingFlats
					// no -- this is a load, chords are displayed according to individual settings
//					m_ChordList.UseFlats(static_cast<bool>(m_fDisplayingFlats));
				}
			}
			break;

		case FOURCC_LIST:
			switch( ck.fccType )
			{
			// found the chord list chunk
			case DMUS_FOURCC_CHORDTRACK_LIST:
				{
					// read the chordlist (this also clears m_ChordList)
					ChordListChunk	chordlist(&m_ChordList);
					hr = chordlist.Read(pRiffStream, &ck);
					if(hr == S_OK)
					{
						if(chordlist.Scale() == 0)
						{
							m_dwScale = DefaultScale;
							m_bKey = DefaultKey;
							chordlist.Scale() = (m_bKey << 24) + m_dwScale;
						}
						else
						{
							m_dwScale = chordlist.Scale() & 0x00FFFFFF;
							m_bKey = (BYTE)(chordlist.Scale() >> 24);
						}
						// Initialize m_nKeyRoot and m_nNumAccidentals
						UpdateKeyRootAndAccidentals();
						UpdateDirectMusic( FALSE );
						hr = pRiffStream->Ascend(&ck, 0) ;
					}
				}
				break;
			default:
				break;
			}
			break;
		default:
			break;
		}
	}
	pRiffStream->Release();
	if( m_pTimeline )
	{
		m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)m_pChordStrip, NULL, TRUE );
	}
	return hr;
}

HRESULT CChordMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	DMUSProdStreamInfo	StreamInfo;//Added ECW 4/24/98
	FileType	ftFileType;
	GUID		guidDataFormat;

	RecalculateMusicTimeValues();

	// We want to know what type of save we are doing because we
	// don't want to save UI information in Personality 'Release' files...	
	IDMUSProdPersistInfo *pIDMUSProdPersist = NULL;
	if( FAILED( hr = pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void**)&pIDMUSProdPersist ) ) )
	{
		ftFileType = FT_RUNTIME;
		guidDataFormat = GUID_CurrentVersion;
//		hr = S_OK;
		return E_NOTIMPL;
	}
	else
	{//Changed ECW 4/24/98
		hr = pIDMUSProdPersist->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pIDMUSProdPersist->Release();
		if (FAILED( hr ))
		{
			return hr;
		}
	}

	IDMUSProdRIFFStream* pRiffStream;
	hr = AllocRIFFStream(pIStream, &pRiffStream);
	if(FAILED(hr))
	{
		return hr;
	}

	// save track
	ChordListChunk chordlistchunk(&m_ChordList, m_dwScale + (m_bKey << 24),(ftFileType==FT_DESIGN));
	hr = chordlistchunk.Write(pRiffStream);

	if( (ftFileType == FT_DESIGN) && SUCCEEDED(hr) )
	{
		// Write the Design-time chunk
	    MMCKINFO ckDesign;
		ckDesign.ckid = DMUS_FOURCC_CHORD_DESIGN_CHUNK;
		if( pRiffStream->CreateChunk( &ckDesign, 0 ) == 0 )
		{
			ioDMChordDesignChunk oDesignChunk;
			ZeroMemory( &oDesignChunk, sizeof(ioDMChordDesignChunk) );
			oDesignChunk.m_bDisplayingFlats = m_fDisplayingFlats;
			oDesignChunk.m_bKeyRoot = (BYTE)m_nKeyRoot;
			oDesignChunk.m_bNumAccidentals = (BYTE)m_nNumAccidentals;
			oDesignChunk.m_fLockAllScales = m_fLockAllScales;
			oDesignChunk.m_fSyncLevelOneToAll = m_fSyncLevelOneToAll;

			DWORD cbWritten;
			hr = pIStream->Write( &oDesignChunk, sizeof(ioDMChordDesignChunk), &cbWritten );
			if( SUCCEEDED(hr) && (cbWritten != sizeof(ioDMChordDesignChunk)) )
			{
				hr = E_FAIL;
			}

			pRiffStream->Ascend( &ckDesign, 0 );
		}
	}

	pRiffStream->Release();
	return hr;
}

HRESULT CChordMgr::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageObject functions

HRESULT STDMETHODCALLTYPE CChordMgr::GetData( /* [retval][out] */ void **ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CChordScalePropPageData* pChordScalePropPageData = (CChordScalePropPageData *)*ppData;

	pChordScalePropPageData->m_pPropChord = &m_SelectedChord;
	pChordScalePropPageData->m_fLockAllScales = m_fLockAllScales;
	pChordScalePropPageData->m_fSyncLevelOneToAll = m_fSyncLevelOneToAll;

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CChordScalePropPageData* pChordScalePropPageData = (CChordScalePropPageData *)pData;
	CPropChord* pChord = pChordScalePropPageData->m_pPropChord;

	TRACE("\r\n invert masks: %x %x %x %x\r\n", 
			pChord->SubChord(0)->InvertPattern(),
			pChord->SubChord(1)->InvertPattern(),
			pChord->SubChord(2)->InvertPattern(),
			pChord->SubChord(3)->InvertPattern());

	BOOL fRefresh = FALSE;

	if( pChordScalePropPageData->m_fLockAllScales != m_fLockAllScales )
	{
		fRefresh = TRUE;
		m_pChordStrip->m_nLastEdit = IDS_UNDO_LOCK_SCALES;
	}
	else if( pChordScalePropPageData->m_fSyncLevelOneToAll != m_fSyncLevelOneToAll )
	{
		fRefresh = TRUE;
		m_pChordStrip->m_nLastEdit = IDS_UNDO_SYNC_LEVELS;
	}
	else
	{
		fRefresh = memcmp(pChord, &m_SelectedChord, sizeof(CPropChord));
		if( fRefresh )
		{
			m_pChordStrip->m_nLastEdit = IDS_UNDO_CHANGE;
		}
	}

	m_SelectedChord = *pChord;
	m_fLockAllScales = pChordScalePropPageData->m_fLockAllScales;
	m_fSyncLevelOneToAll = pChordScalePropPageData->m_fSyncLevelOneToAll;

	m_ChordList.RetrievePropChord( pChord );
	m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)m_pChordStrip, NULL, TRUE );
	if(fRefresh)
	{
		// Let the object know about the changes
		UpdateDirectMusic( TRUE );
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;
	ASSERT(m_pIDMUSProdFramework);
	if( m_pPropPageMgr == NULL )
	{
		CChordPropPageMgr* pPPM = new CChordPropPageMgr(m_pIDMUSProdFramework);
		if( NULL == pPPM ) return E_OUTOFMEMORY;
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		m_pPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
		if( FAILED(hr) )
			return hr;
	}
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	return hr;
}

HRESULT STDMETHODCALLTYPE CChordMgr::OnRemoveFromPageManager( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return S_OK;
}

HRESULT CChordMgr::UpdateDirectMusic( BOOL fUpdateSegmentDesigner )
{
	HRESULT hr = E_FAIL;
	if( m_pTimeline && fUpdateSegmentDesigner )
	{
		m_pTimeline->OnDataChanged( (IDMUSProdStripMgr *)this );
		m_pTimeline->NotifyStripMgrs( GUID_ChordParam, m_dwGroupBits, NULL );
	}

	if( m_pIDMTrack && m_pIDMUSProdFramework )
	{
		IPersistStream* pIPersistStream;
		if( SUCCEEDED( m_pIDMTrack->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream ) ) )
		{
			IStream *pIStream;
			if( SUCCEEDED( m_pIDMUSProdFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIStream ) ) )
			{
				if( SUCCEEDED( Save( pIStream, FALSE ) ) )
				{
					LARGE_INTEGER liTemp;
					liTemp.QuadPart = 0;
					if( SUCCEEDED( pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL ) ) )
					{
						hr = pIPersistStream->Load( pIStream );
					}
				}
				pIStream->Release();
			}
			pIPersistStream->Release();
		}
	}
	return hr;
}

////////////////////// methods to support drag and drop
HRESULT CChordMgr::DeleteSelectedChords()
{
	CChordList list;
	CChordItem* pChord;

	// get rid of all selected chords
	while( pChord = m_ChordList.RemoveHead() )
	{
		if( pChord->IsSelected() )
		{
			delete pChord;
		}
		else
		{
			pChord->SetNext(0);
			list.AddTail(pChord);
		}
	}

	// write back remaining runs
	while( pChord = list.RemoveHead())
	{
		pChord->SetNext(0);
		m_ChordList.AddTail(pChord);
	}
	return S_OK;
}



HRESULT CChordMgr::SaveSelectedChords(LPSTREAM pStream, CChordItem* pChordAtDragPoint, 
									  BOOL bNormalize, long* pOffset)
{
	ASSERT(pStream);
	ASSERT(pChordAtDragPoint);
	CChordList list;
	CChordItem* pChord;
	// copy selected chords to list
	for(pChord = m_ChordList.GetHead(); pChord; pChord = pChord->GetNext())
	{
		if(pChord->IsSelected())
		{
			// make sure that only the chord at the mouse drag point is selected
			pChord->SetSelected( (pChord == pChordAtDragPoint) ? TRUE : FALSE);
			list.AddTail(new CChordItem(*pChord));
			// re-select chord
			pChord->SetSelected(TRUE);
		}
	}
	// check that anything is selected
	if(!list.GetHead())
		return S_FALSE; // Nothing selected
	// normalize chords so that first chord is at offset 0
	if(bNormalize)
	{
		pChord = list.GetHead();
		CMusicTimeConverter cmt(pChord->Measure(), pChord->Beat(), m_pTimeline, m_dwGroupBits);
		NormalizeChordList(list, -cmt);
		if(pOffset)
		{
			*pOffset = cmt.Time();	// save for later use
		}

	}
	HRESULT hr = list.Save(pStream, FALSE);
	list.ClearList();
	return hr;
}

HRESULT CChordMgr::GetTimeSig(long* top, long* bottom, long mtTime)
{
	if(!m_pTimeline)
		return E_FAIL;

	DMUS_TIMESIGNATURE dmTimeSig;

	if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, mtTime, NULL, &dmTimeSig ) ) )
	{
		if( top )
		{
			*top = dmTimeSig.bBeatsPerMeasure;
		}
		if( bottom )
		{
			*bottom = dmTimeSig.bBeat;
		}
		return S_OK;
	}
	return E_FAIL;
}



HRESULT CChordMgr::NormalizeChordList(CChordList& list, long clockOffset, long* pStartClocks, long* pEndClocks)
//
// normalize using strip's timesig, also returns min/max measure/beat of list if user asks for it
//
{
	HRESULT hr = S_OK;
	CMusicTimeConverter cmtMin(0x7fffffff);
	CMusicTimeConverter cmtMax(0);
	
	ASSERT(m_pTimeline);
	if(!m_pTimeline)
		return E_UNEXPECTED;

	for(CChordItem* pChord = list.GetHead(); pChord; pChord = pChord->GetNext())
	{
		long m,b;
		CMusicTimeConverter cmt(pChord->Measure(), pChord->Beat(), m_pTimeline, m_dwGroupBits);
		// convert min/max
		if(cmt < cmtMin)
			cmtMin = cmt;
		if(cmtMax < cmt)
			cmtMax = cmt;
		// offset chord
		cmt = cmt + clockOffset;
		hr = cmt.GetMeasureBeat(m,b, m_pTimeline, m_dwGroupBits);
		if(FAILED(hr))
		{
			break;
		}
		pChord->Measure() = static_cast<short>(m);
		pChord->Beat() = static_cast<BYTE>(b);
	}
	if(SUCCEEDED(hr))
	{
		// indicate min/max
		if(pStartClocks)
			*pStartClocks = cmtMin;
		if(pEndClocks)
			*pEndClocks = cmtMax;
	}
	return hr;
}

void CChordMgr::MarkSelectedChords(DWORD flags)
{
	for(CChordItem* pChord = m_ChordList.GetHead(); pChord; pChord = pChord->GetNext())
	{
		if(pChord->IsSelected())
		{
			for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
			{
				pChord->Undetermined(i) |= flags;
			}
		}
	}
}

void CChordMgr::DeleteMarkedChords(DWORD flags)
{
	CChordList list;
	CChordItem* pChord;
	// get rid of all marked chords
	while( pChord = m_ChordList.RemoveHead() )
	{
		if(pChord->Undetermined(pChord->RootIndex()) & flags)
		{
			delete pChord;
		}
		else
		{
			pChord->SetNext(0);
			list.AddTail(pChord);
		}
	}

	// write back remaining runs
	while( pChord = list.RemoveHead())
	{
		pChord->SetNext(0);
		m_ChordList.AddTail(pChord);
	}
}

void CChordMgr::UnMarkChords(DWORD flags)
{

	for(CChordItem* pChord = m_ChordList.GetHead(); pChord; pChord = pChord->GetNext())
	{
			for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
			{
				pChord->Undetermined(i) &= ~flags;
			}
	}
}

void CChordMgr::UnselectChords()
{
	m_ChordList.ClearSelections();
}


bool CChordMgr::IsSelected()
{
	for(CChordItem* pChord = m_ChordList.GetHead(); pChord; pChord = pChord->GetNext())
	{
		if(pChord->IsSelected())
			return true;
	}
	return false;
}


short CChordMgr::GetSelectedHideState()
{
	short nHideState = HIDE_NONE_SELECTED;

	for( CChordItem* pChord = m_ChordList.GetHead();  pChord;  pChord = pChord->GetNext() )
	{
		if( pChord->IsSelected() )
		{
			if( pChord->Flags() & DMUS_CHORDKEYF_SILENT )
			{
				if( nHideState == HIDE_ALL_OFF )
				{
					nHideState = HIDE_MIXED;
					break;
				}
				nHideState = HIDE_ALL_ON;
			}
			else
			{
				if( nHideState == HIDE_ALL_ON )
				{
					nHideState = HIDE_MIXED;
					break;
				}
				nHideState = HIDE_ALL_OFF;
			}
		}
	}

	return nHideState;
}


short CChordMgr::HowManySelected()
{
	short nHowMany = SEL_NONE;

	for( CChordItem* pChord = m_ChordList.GetHead();  pChord;  pChord = pChord->GetNext() )
	{
		if( pChord->IsSelected() )
		{
			if( nHowMany )
			{
				return SEL_MULTIPLE;
			}

			nHowMany = SEL_ONE;
		}
	}

	return nHowMany;
}

CChordItem* CChordMgr::FirstSelectedChord()
{
	CChordItem* pChord = m_ChordList.GetHead();
	bool found = false;
	for(;pChord && !found; pChord = pChord->GetNext())
	{
		if(pChord->IsSelected())
		{
			found = true;
			break;
		}
	}
	if(found)
	{
		return pChord;
	}
	else
	{
		return NULL;
	}
}

BOOL CChordMgr::SelectSegment(long begintime, long endtime)
//
// returns true if anything was selected, otherwise returns false
//
{
	ASSERT(m_pTimeline);
	ASSERT(m_pChordStrip);
	if(!m_pTimeline || !m_pChordStrip)
	{
		return FALSE;
	}
	if( begintime == -1)
	{
		// till we implement m_lShiftFromMeasure (see CommandMgr::SelectSegment),
		// just set it to beginning
		begintime = 0;
	}

	CMusicTimeConverter cmtBeg(begintime);
	CMusicTimeConverter cmtEnd(endtime);
	CSelectedRegion region(cmtBeg, cmtEnd);

	m_pChordStrip->m_pSelectedRegions->AddRegion(region);
	m_pChordStrip->SelectChordsInSelectedRegions();
/*
	for(CChordItem* pChord = m_ChordList.GetHead(); pChord; pChord = pChord->GetNext())
	{
		long measure = static_cast<long>(pChord->Measure()) & 0xffff;
		long beat = static_cast<long>(pChord->Beat()) & 0xff;
		long clocks;
		m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, measure, beat, &clocks);
		if(begintime <= clocks && clocks < endtime)
		{
			pChord->SetSelected(TRUE);
			m_SelectedChord = *pChord;
			result = TRUE;
		}
		else
		{
			pChord->SetSelected(FALSE);
		}
	}
*/
	return TRUE;
}

HRESULT CChordMgr::ImportKeyFromChordTrack( void )
{
	if( m_pTimeline == NULL )
	{
		return E_FAIL;
	}

	// Get the ChordMap's DocRoot
	MUSIC_TIME mtTime;
	IDMUSProdNode* pIPersonalityNode;
	if( SUCCEEDED( m_pTimeline->GetParam( GUID_PersonalityNode, m_dwGroupBits, 0, 0, &mtTime, &pIPersonalityNode ) ) )
	{
		IDMUSProdChordMapInfo* pIChordMapInfo;
		if( SUCCEEDED ( pIPersonalityNode->QueryInterface( IID_IDMUSProdChordMapInfo, (void**)&pIChordMapInfo ) ) )
		{
			DMUSProdChordMapInfo info;
			memset( &info, 0, sizeof(DMUSProdChordMapInfo) );
			info.wSize = sizeof(DMUSProdChordMapInfo);

			if( SUCCEEDED ( pIChordMapInfo->GetChordMapInfo( &info ) ) )
			{
				m_bKey = info.bKey % 24;
				m_dwScale = info.lScalePattern;
				m_fDisplayingFlats = info.fUseFlats;
				UpdateKeyRootAndAccidentals();
			}

			pIChordMapInfo->Release();
		}

		pIPersonalityNode->Release();
	}

	return S_OK;
}


HRESULT CChordMgr::ImportChordsFromChordTrack( void )
{
	if( m_pIDMTrack == NULL )
	{
		return E_FAIL;
	}

	// Clear chords before load
	m_ChordList.ClearList();

	// Load chords
	DMUS_CHORD_PARAM dmChordParam;
	MUSIC_TIME mtNow, mtNext;
	mtNow = 0;
	while( SUCCEEDED( m_pIDMTrack->GetParam( GUID_ChordParam, mtNow, &mtNext, &dmChordParam ) ) )
	{
		ChordSelection chordSelection;
		chordSelection.Beat() = dmChordParam.bBeat;
		chordSelection.Measure() = dmChordParam.wMeasure;
		chordSelection.Time() = mtNow;
		// Convert dmChordParam.wszName[16] to chordSelection.m_szName[12]
		memset(chordSelection.Name(), 0, DMPolyChord::MAX_NAME);
		WideCharToMultiByte( CP_ACP, 0, dmChordParam.wszName, -1, chordSelection.Name(), 
											DMPolyChord::MAX_NAME, NULL, NULL );
		
		// Convert dmChordParam.bSubChordCount, DMUS_SUBCHORD SubChordList[DMUS_MAXSUBCHORD] 
		// to DMChord chordSelection.m_Chords[MAX_POLY]
		int nchords = dmChordParam.bSubChordCount < DMPolyChord::MAX_POLY ? dmChordParam.bSubChordCount : DMPolyChord::MAX_POLY;
		for(int i = 0; i < nchords; i++)
		{
			chordSelection.SubChord(i)->ChordPattern() = dmChordParam.SubChordList[i].dwChordPattern;
			chordSelection.SubChord(i)->ScalePattern() = dmChordParam.SubChordList[i].dwScalePattern;
			chordSelection.SubChord(i)->InvertPattern() = dmChordParam.SubChordList[i].dwInversionPoints;
			chordSelection.SubChord(i)->Levels() = dmChordParam.SubChordList[i].dwLevels;
			chordSelection.SubChord(i)->ChordRoot() = dmChordParam.SubChordList[i].bChordRoot;
			chordSelection.SubChord(i)->ScaleRoot() = dmChordParam.SubChordList[i].bScaleRoot;
		}

		CChordItem* pItem = new CChordItem( chordSelection );
		if( pItem )
		{
			m_ChordList.AddTail( pItem );
		}
		if( mtNext == 0 )
		{
			break;
		}
		else
		{
			mtNow += mtNext;
		}
	}

	// Redraw the chord strip
	if( m_pTimeline )
	{
		m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)m_pChordStrip, NULL, TRUE );
	}
	m_ChordList.UseFlats( (m_fDisplayingFlats != 0) ? true : false);

	// Sync to refresh chord strip's root/key
	UpdateDirectMusic( FALSE );
	return S_FALSE;
}


void CChordMgr::RecalculateMusicTimeValue(CChordItem* pChord)
{
	if( m_pTimeline )
	{
		MUSIC_TIME mtTime;
		m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, pChord->Measure(), pChord->Beat(), &mtTime );
		pChord->Time() = mtTime;
	}
}

/*
static void MarkChord(CChordItem* pChord, long value)
{
	pChord->Undetermined(pChord->RootIndex()) = value;
}


void CChordMgr::MarkChordsInMeasure(long measure, long bpm)
{
	for(CChordItem* pChord = m_ChordList.GetHead(); pChord; pChord = pChord->GetNext())
	{
		if(pChord->Measure() == measure && pChord->Beat() < bpm)
		{
			MarkChord(pChord, InMeasure);
		}
	}
}
*/

bool CChordMgr::IsChordAt(long measure, long beat)
{
	for(CChordItem* pItem = m_ChordList.GetHead(); pItem; pItem = pItem->GetNext())
	{
		if(measure == pItem->Measure() && beat == pItem->Beat())
		{
			return true;
		}
	}
	return false;
}

long CChordMgr::ShiftChordsBackwards(long measure, long bpm)
{
	long firstEmptyBeat = 0;
	CChordItem* pItem = m_ChordList.GetHead();
	CChordItem* pFirst = 0;
	// find the first chord of the target measure
	for(; pItem && pItem->Measure() < measure; pItem = pItem->GetNext())
	{
		continue;
	}
	if(pItem && pItem->Measure() == measure)
	{
		pFirst = pItem;
	}
	else
	{
		ASSERT(FALSE);	// we should never get here: no chords in measure -> plenty of empty beats
		return bpm;		// assues that function returns failure.
	}
	// find first empty beat
	for(pItem = pFirst; pItem && firstEmptyBeat < bpm && pItem->Measure() == measure; pItem = pItem->GetNext())
	{
		if(pItem->Beat() > firstEmptyBeat)
		{
			break;
		}
		firstEmptyBeat++;
	}
	if(firstEmptyBeat < bpm)
	{
		// do the shift
		for(pItem = pFirst; 
			pItem && pItem->Measure() <= measure;  
			pItem = pItem->GetNext())
		{
			if(pItem->Measure() == measure && pItem->Beat() > firstEmptyBeat)
			{
				pItem->Beat() -=1;
			}
		}
	}
	return firstEmptyBeat;
}


void CChordMgr::RecalculateMusicTimeValues()
{
	if(m_pTimeline)
	{
		long measure = -1;
		long beat = -1;
		CMusicTimeConverter cmt;
		CChordList lstByMeasure;
		for(CChordItem* pChord = m_ChordList.GetHead(); pChord; pChord = pChord->GetNext())
		{
			DMUS_TIMESIGNATURE dmTimeSig;
			measure = pChord->Measure();
			beat = pChord->Beat();
			cmt.SetTime(measure,beat,m_pTimeline, m_dwGroupBits);
			cmt.GetTimeSig(dmTimeSig, m_pTimeline, m_dwGroupBits);
			if(beat >= dmTimeSig.bBeatsPerMeasure)
			{
				// adjust beat to last beat of measure and check if coincident chord on last beat
				pChord->Beat() = dmTimeSig.bBeatsPerMeasure;	// this is too many beats, but hopefully
																// it'll be shifted below
				if(IsChordAt(measure, dmTimeSig.bBeatsPerMeasure - 1))
				{
					long firstEmptyBeat = ShiftChordsBackwards(measure, dmTimeSig.bBeatsPerMeasure);
					if(firstEmptyBeat >= dmTimeSig.bBeatsPerMeasure)
					{
						// no room for chord, mark it for deletion
						pChord->Undetermined(pChord->RootIndex()) = 1;
					}
					else
					{
						pChord->Undetermined(pChord->RootIndex()) = 0;
						RecalculateMusicTimeValue(pChord);
					}
				}
				else
				{
					pChord->Beat() = dmTimeSig.bBeatsPerMeasure - 1;
					pChord->Undetermined(pChord->RootIndex()) = 0;
					RecalculateMusicTimeValue(pChord);
				}
			}
			else
			{
				pChord->Undetermined(pChord->RootIndex()) = 0;
				RecalculateMusicTimeValue(pChord);
			}
		}
		DeleteMarkedChords(1);
	}
}

HRESULT CChordMgr::GetBoundariesOfSelectedChords(long & lStartTime, long & lEndTime)
{
	ASSERT(m_pTimeline);
	HRESULT hr = S_OK;
	lStartTime = lEndTime = -1;
	CMusicTimeConverter cmt;
	CChordItem* pChord = m_ChordList.GetHead();
	for(; pChord; pChord = pChord->GetNext())
	{
		if(pChord->IsSelected())
		{
			hr = cmt.SetTime(pChord->Measure(), pChord->Beat(),
							m_pTimeline, m_dwGroupBits);
			if(FAILED(hr))
			{
				goto CheckBounds;
			}
			if(lStartTime == -1 || cmt < lStartTime)
			{
				lStartTime = cmt;
			}
			if(lEndTime == -1 || cmt > lEndTime)
			{
				lEndTime = cmt;
			}
		}
	}
CheckBounds:
	if(hr == S_OK && (lStartTime == -1 || lEndTime == -1))
	{
		// nothing selected
		hr = S_FALSE;
	}
	else
	{
		// advance endtime by one beat
		DMUS_TIMESIGNATURE dmTimeSig;
		long m,b;
		cmt = lEndTime;
		hr = cmt.GetTimeSig(dmTimeSig, m_pTimeline, m_dwGroupBits);
		ASSERT(SUCCEEDED(hr));
		if(FAILED(hr))
			return hr;
		hr = cmt.GetMeasureBeat(m,b, m_pTimeline, m_dwGroupBits);
		ASSERT(SUCCEEDED(hr));
		if(FAILED(hr))
			return hr;
		b++;
		if(b > dmTimeSig.bBeatsPerMeasure)
		{
			m++;
			b = 0;
		}
		hr = cmt.SetTime(m,b, m_pTimeline, m_dwGroupBits);
		ASSERT(SUCCEEDED(hr));
		if(FAILED(hr))
			return hr;
		lEndTime = cmt - 1;
	}
	return hr;
}


HRESULT CChordMgr::GetSpanOfChordList(long& lStartTime, long& lEndTime, CChordList * pList, bool bSelectedChordsOnly)
{
	ASSERT(m_pTimeline);
	if(m_pTimeline == NULL)
		return E_UNEXPECTED;
	HRESULT hr = S_OK;
	if(pList == NULL)
	{
		// use internal chord list
		pList = &m_ChordList;
	}
	lStartTime = -1;
	lEndTime = -1;
	CChordItem* pChord;
	for(pChord = pList->GetHead(); pChord; pChord = pChord->GetNext())
	{
		CMusicTimeConverter cmt;
		if(!bSelectedChordsOnly || pChord->IsSelected())
		{
			hr = cmt.SetTime(pChord->Measure(), pChord->Beat(),
							m_pTimeline, m_dwGroupBits);
			if(hr == S_OK)
			{
				if(lStartTime == -1 || cmt < lStartTime)
					lStartTime = cmt;
				if(lEndTime == -1 || cmt > lEndTime)
					lEndTime = cmt;
			}
			else
			{
				break;
			}
		}
	}
	if(lStartTime == -1 || lEndTime == -1)
	{
		lStartTime = lEndTime = -1;
		hr = S_FALSE;
	}

	// extend endtime out 1/4
//	lEndTime += DMUS_PPQ;
	return hr;
}

void CChordMgr::SelectAll()
{
	CChordItem* pChord = m_ChordList.GetHead();
	while(pChord)
	{
		pChord->SetSelected(TRUE);
		pChord = pChord->GetNext();
	}
}

const DWORD adwFlatScales[8] = {
	0x00AB5AB5, // C
	0x006B56B5,	// F
	0x006AD6AD,	// Bb
	0x005AD5AD, // Eb
	0x005AB5AB,	// Ab
	0x0056B56B,	// Db
	0x00D6AD6A,	// Gb
	0x00D5AD5A};// Cb
const DWORD adwSharpScales[8] = {
	0x00AB5AB5,	// C
	0x00AD5AD5,	// G
	0x00AD6AD6,	// D
	0x00B56B56,	// A
	0x00B5AB5A,	// E
	0x00D5AD5A,	// B
	0x00D6AD6A,	// F#
	0x0056B56B};// C#

// Updates m_dwScale and m_bKey based on the key root and # of sharps/flats
void CChordMgr::UpdateMasterScaleAndKey()
{
	ASSERT( m_nNumAccidentals < 8 );
	ASSERT( m_nKeyRoot < 12 );

	m_nNumAccidentals = min( m_nNumAccidentals, 7 );
	m_nKeyRoot = m_nKeyRoot % 12;

	DWORD dwOrigScale;
	if( m_fDisplayingFlats )
	{
		dwOrigScale = adwFlatScales[m_nNumAccidentals];
	}
	else
	{
		dwOrigScale = adwSharpScales[m_nNumAccidentals];
	}

	// Shift the scale so bit 0 of m_dwScale is the key root
	m_dwScale = (dwOrigScale >> m_nKeyRoot)
			  | (0x00FFFFFF & (dwOrigScale << (12 - m_nKeyRoot)));
	m_bKey = m_nKeyRoot;
}

// Updates m_nNumAccidentals and m_nKeyRoot from m_dwScale and m_bKey
void CChordMgr::UpdateKeyRootAndAccidentals()
{
	ASSERT( m_bKey < 24 );
	m_nKeyRoot = m_bKey % 12;

	for( int iNumAccidentals = 0; iNumAccidentals < 8; iNumAccidentals++ )
	{
		// Check sharp scales
		if( !m_fDisplayingFlats && m_dwScale == ((adwSharpScales[iNumAccidentals] >> m_nKeyRoot) |
						  (0x00FFFFFF & (adwSharpScales[iNumAccidentals] << (12 - m_nKeyRoot)))) )
		{
			m_nNumAccidentals = iNumAccidentals;
			goto Leave;
		}
		// Check flat scales
		else if( m_fDisplayingFlats && m_dwScale == ((adwFlatScales[iNumAccidentals] >> m_nKeyRoot) |
						  (0x00FFFFFF & (adwFlatScales[iNumAccidentals] << (12 - m_nKeyRoot)))) )
		{
			m_nNumAccidentals = iNumAccidentals;
			goto Leave;
		}
	}

	// Not a normal scale
//	TRACE("CChordMgr::UpdateKeyRootAndAccidentals: Loaded abnormal scale %x - using C major\n", m_dwScale );
//	m_nNumAccidentals = 0;
//	m_fDisplayingFlats = FALSE;
Leave:
	;
}

HRESULT CChordMgr::SaveSelectedChords(IStream *pStream, long offset)
// save selected chords and adjust by "offset"
{
	ASSERT(pStream);
	CChordList list;
	CChordItem* pChord;
	// copy selected chords to list
	for(pChord = m_ChordList.GetHead(); pChord; pChord = pChord->GetNext())
	{
		if(pChord->IsSelected())
		{
			// make sure that only the chord at the mouse drag point is selected
			pChord->SetSelected( FALSE );
			list.AddTail(new CChordItem(*pChord));
			// re-select chord
			pChord->SetSelected(TRUE);
		}
	}
	// check that anything is selected
	if(!list.GetHead())
		return S_FALSE; // Nothing selected
	// substract offset from each chord

	pChord = list.GetHead();
	NormalizeChordList(list, -offset);

	HRESULT hr = list.Save(pStream, FALSE);
	list.ClearList();
	return hr;
}

bool CChordMgr::UseFlatsNotSharps(BYTE bKey, DWORD dwScale)
// uses key and scale portion of DMUS_CHORD_PARAM to determine if chord should be displayed with sharps or flats
{
	bool bFlatsNotSharps = false;
	for( int iNumAccidentals = 0; iNumAccidentals < 8; iNumAccidentals++ )
	{
		// Check sharp scales
		if( dwScale == ((adwSharpScales[iNumAccidentals] >> bKey) |
						  (0x00FFFFFF & (adwSharpScales[iNumAccidentals] << (12 - bKey)))) )
		{
			bFlatsNotSharps = false;
			goto Leave;
		}
		// Check flat scales
		if( dwScale == ((adwFlatScales[iNumAccidentals] >> bKey) |
						  (0x00FFFFFF & (adwFlatScales[iNumAccidentals] << (12 - bKey)))) )
		{
			bFlatsNotSharps = true;
			goto Leave;
		}
	}
Leave:
	return bFlatsNotSharps;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\ChordScalePropPage.cpp ===
// ChordScalePropPage.cpp : implementation file
//

#include "stdafx.h"
#pragma warning(disable:4201)
#include "..\includes\DMUSProd.h"
#include "..\includes\Conductor.h"
#include "DllBasePropPageManager.h"
#include "PropChord.h"
#include "PropPageMgr.h"
#include "chordstripmgr.h"
#include "ChordScalePropPage.h"
#include "IllegalChord.h"
#pragma warning(default:4201)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define WM_MIDIMSG	WM_USER + 23

///////////////////////// Callbacks for CKeyboard Events
//
void KeyboardChangeCallback(CKeyboard* pKeyboard, void* hint, short nKey)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CChordScalePropPage* pdlg = (CChordScalePropPage*)hint;
	pdlg->DispatchKeyboardChange(pKeyboard, nKey);
}

void RMouseKeyboardCallback(CKeyboard* pKeyboard, void* hint, short nKey, CPoint& ptMouse)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CChordScalePropPage* pdlg = (CChordScalePropPage*)hint;
	pdlg->DispatchRightMouseKeyboard(pKeyboard, nKey, ptMouse);
}

/////////////////////////////////////////////////////////////////////////////
// CChordScalePropPage property page

IMPLEMENT_DYNCREATE(CChordScalePropPage, CPropertyPage)

CChordScalePropPage::CChordScalePropPage() : CPropertyPage(CChordScalePropPage::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	//{{AFX_DATA_INIT(CChordScalePropPage)
	//}}AFX_DATA_INIT

	m_pPropPageMgr = NULL;
	m_fMidiInputTarget = None;
	m_dwCookie = 0;
	m_pIConductor = 0;
	m_pIPerformance = 0;
	m_cRef = 0;
	m_cRegCount = 0;
	m_bValidChord = false;
	m_fNeedToDetach = FALSE;
	m_fLockAllScales = true;
	m_fSyncLevelOneToAll = true;
	AddRef();

	m_MidiInIds[0] = IDC_BUTTON_MIDICHORD1;
	m_MidiInIds[1] = IDC_BUTTON_MIDICHORD2;
	m_MidiInIds[2] = IDC_BUTTON_MIDICHORD3;
	m_MidiInIds[3] = IDC_BUTTON_MIDICHORD4;

	m_MidiInIds[4] = IDC_BUTTON_MIDISCALE1;
	m_MidiInIds[5] = IDC_BUTTON_MIDISCALE2;
	m_MidiInIds[6] = IDC_BUTTON_MIDISCALE3;
	m_MidiInIds[7] = IDC_BUTTON_MIDISCALE4;

	m_MidiInIds[8] = 0;

	m_nLastKeyboardLevel = -1;

	m_bNotWarn = FALSE;

	m_bValid = FALSE;
}

CChordScalePropPage::~CChordScalePropPage()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	UnRegisterMidi();	// make sure we're unregistered
	if(m_pIConductor)
	{
		m_pIConductor->Release();
	}
	if(m_pIPerformance)
	{
		m_pIPerformance->Release();
	}
}

void CChordScalePropPage::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChordScalePropPage)
	DDX_Control(pDX, IDC_SPIN_ROOT, m_spinRoot);
	DDX_Control(pDX, IDC_EDIT_NAME, m_chordname);
	DDX_Control(pDX, IDC_KEYS_SCALE4, m_keysscale4);
	DDX_Control(pDX, IDC_KEYS_SCALE3, m_keysscale3);
	DDX_Control(pDX, IDC_KEYS_SCALE2, m_keysscale2);
	DDX_Control(pDX, IDC_KEYS_SCALE1, m_keysscale1);
	DDX_Control(pDX, IDC_KEYS_CHORD4, m_keyschord4);
	DDX_Control(pDX, IDC_KEYS_CHORD3, m_keyschord3);
	DDX_Control(pDX, IDC_KEYS_CHORD2, m_keyschord2);
	DDX_Control(pDX, IDC_KEYS_CHORD1, m_keyschord1);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChordScalePropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CChordScalePropPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD4, OnButtonMidichord4)
	ON_WM_DRAWITEM()
	ON_WM_MEASUREITEM()
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD1, OnButtonMidichord1)
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD2, OnButtonMidichord2)
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD3, OnButtonMidichord3)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE1, OnButtonMidiscale1)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE2, OnButtonMidiscale2)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE3, OnButtonMidiscale3)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE4, OnButtonMidiscale4)
	ON_BN_CLICKED(IDC_BUTTON_PLAY1, OnButtonPlay1)
	ON_BN_CLICKED(IDC_BUTTON_PLAY2, OnButtonPlay2)
	ON_BN_CLICKED(IDC_BUTTON_PLAY3, OnButtonPlay3)
	ON_BN_CLICKED(IDC_BUTTON_PLAY4, OnButtonPlay4)
	ON_BN_CLICKED(IDC_BUTTON_PLAYALL, OnButtonPlayall)
	ON_EN_CHANGE(IDC_EDIT_NAME, OnChangeEditName)
	ON_WM_KILLFOCUS()
	ON_BN_CLICKED(IDC_USEFLATS, OnUseflats)
	ON_BN_CLICKED(IDC_USESHARPS, OnUsesharps)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ROOT, OnDeltaposSpinRoot)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChordScalePropPage message handlers


///////////////////////////////////////////////////////////////////////////
// CChordScalePropPage other funcs
const short KeyOCXTrans = 48;
const short KeyOCXLow = 0;
const short KeyOCXHigh = 23;
#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0

#define MIDI_BASEPITCH		48

HRESULT CChordScalePropPage::OnMidiMsg(REFERENCE_TIME rtTime,
									   BYTE bStatus, 
									   BYTE bData1, 
									   BYTE bData2)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	UNREFERENCED_PARAMETER(rtTime);

	// Note On
	if((int)(bStatus & 0xF0) == (int)0x90)
	{

		char Text[128];
		sprintf(Text, "Inside  PropPageChord::OnMidiMsg going to play %d note on\n", bData1); 
		TRACE0(Text);

		// set note
		short nKey = static_cast<short>(bData1 - KeyOCXTrans);

		if(m_fMidiInputTarget < 4)
		{
			bool rootHasChanged = m_fMidiInputTarget == 0 && (nKey <= m_Chord.Base()->ChordRoot());
			PostMessage(WM_MIDIMSG, (WPARAM)nKey, (LPARAM)GetChordKeyboard(m_fMidiInputTarget));
			if(rootHasChanged)
			{
//				GetChordKeyboard(m_fMidiInputTarget)->SetLowerBound(GetChordKeyboard(m_fMidiInputTarget)->Transpose());
			}
		}
		else if(m_fMidiInputTarget < 8)
		{
			PostMessage(WM_MIDIMSG, (WPARAM)nKey, (LPARAM)GetScaleKeyboard(m_fMidiInputTarget - 4));
		}
	}

	// Note Off
	if((int)(bStatus & 0xF0) == (int)0x80)
	{
		char Text[128];
		sprintf(Text, "Inside  PropPageChord::OnMidiMsg going to play %d note off\n", bData1); 
		TRACE0(Text);
	}

	// set up patch
	m_pIConductor->PlayMIDIEvent( MIDI_CCHANGE, 7, 100, 0);
	m_pIConductor->PlayMIDIEvent( MIDI_CCHANGE, 10, 63, 0);
	m_pIConductor->PlayMIDIEvent( MIDI_CCHANGE, 32, 0, 0);
	m_pIConductor->PlayMIDIEvent( MIDI_CCHANGE, 0, 0, 0);
	m_pIConductor->PlayMIDIEvent( MIDI_PCHANGE, 0, 0, 0 );
	m_pIConductor->PlayMIDIEvent( MIDI_PCHANGE+1, 10, 0, 0 );

	m_pIConductor->PlayMIDIEvent(static_cast<BYTE>(bStatus & 0xF0),
								 bData1,
								 bData2,
								 0);	
	
	return S_OK;
}

void CChordScalePropPage::RegisterMidi() 
{
	ASSERT(m_cRegCount <= 1);
	if(m_fMidiInputTarget != None && m_cRegCount == 0)
	{
		++m_cRegCount;
		REGISTER_MIDI_IN(m_pIConductor, m_dwCookie)	
	}
}

void CChordScalePropPage::UnRegisterMidi()
{
	ASSERT(m_cRegCount <= 1);
	if(m_cRegCount)
	{
		m_cRegCount--;
		UNREGISTER_MIDI_IN(m_pIConductor, m_dwCookie)
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageChord IUnknown
STDMETHODIMP CChordScalePropPage::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	ASSERT( ppv );
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdMidiInCPt))
	{
        *ppv = (IUnknown *) (IDMUSProdMidiInCPt *) this;
	}
	else
	{
		return E_NOTIMPL;
	}
    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CChordScalePropPage::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CChordScalePropPage::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}

/////////////////////////////////////////////////////
//// Data transfer
void  CChordScalePropPage::CopyDataToTab( CPropChord*  pTabData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(pTabData && m_bValidChord)
	{
		*pTabData = m_Chord;
	}
	else
	{
		pTabData = 0;
	}
}

void CChordScalePropPage::GetDataFromTab( const CPropChord* pTabData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(pTabData)
	{
		m_Chord = *pTabData;
		m_bValidChord = true;
	}
	else
	{
		m_bValidChord = false;
	}
}

BOOL CChordScalePropPage::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	for(int i = 0; i < MAX_POLY; i++)
	{
		GetChordKeyboard(i)->SetLButtonUpCallback(KeyboardChangeCallback, this);
		GetScaleKeyboard(i)->SetLButtonUpCallback(KeyboardChangeCallback, this);
		GetChordKeyboard(i)->SetRButtonDownCallback(RMouseKeyboardCallback, this);
		GetScaleKeyboard(i)->SetRButtonDownCallback(RMouseKeyboardCallback, this);
		GetScaleKeyboard(i)->SetExtent(12);
		GetChordKeyboard(i)->SetExtent(48);
		GetChordKeyboard(i)->SetRootKeys(24);
		GetScaleKeyboard(i)->SetRootKeys(0);
	}
	
	m_midichord4.AutoLoad(IDC_BUTTON_MIDICHORD4, this);
	m_midichord3.AutoLoad(IDC_BUTTON_MIDICHORD3, this);
	m_midichord2.AutoLoad(IDC_BUTTON_MIDICHORD2, this);
	/*
	m_midichord1.Create( "MIDIPLUG", 
									 BS_OWNERDRAW | BS_AUTOCHECKBOX | WS_CHILD | WS_VISIBLE | WS_TABSTOP,
									 CRect(14,84,26,94), 
									 this, 
									 IDC_BUTTON_MIDICHORD1 );
									 */
	m_midichord1.AutoLoad(IDC_BUTTON_MIDICHORD1, this);
//	m_midichord1.LoadBitmaps( "MIDIPLUGU", "MIDIPLUGD");



	m_midiscale4.AutoLoad(IDC_BUTTON_MIDISCALE4, this);
	m_midiscale3.AutoLoad(IDC_BUTTON_MIDISCALE3, this);
	m_midiscale2.AutoLoad(IDC_BUTTON_MIDISCALE2, this);
	m_midiscale1.AutoLoad(IDC_BUTTON_MIDISCALE1, this);


//	m_midiroot.AutoLoad(IDC_BUTTON_MIDIROOT, this);


	m_play4.AutoLoad(IDC_BUTTON_PLAY4, this);
	m_play3.AutoLoad(IDC_BUTTON_PLAY3, this);
	m_play2.AutoLoad(IDC_BUTTON_PLAY2, this);
	m_play1.AutoLoad(IDC_BUTTON_PLAY1, this);

	m_playall.AutoLoad(IDC_BUTTON_PLAYALL, this);



	CPropertyPage::OnInitDialog();

	m_chordname.LimitText(11);

	m_bValid = TRUE;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

int CChordScalePropPage::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}

void CChordScalePropPage::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}
	UnRegisterMidi();

	CPropertyPage::OnDestroy();	
}


void CChordScalePropPage::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	// TODO: Add your message handler code here and/or call default
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
/*
	CButton* pButton = GetButton(nIDCtl);
	if(pButton)
	{
		lpDrawItemStruct->itemState = pButton->GetChecked() ? ODS_SELECTED : ODS_DEFAULT;
	}
*/		
	CPropertyPage::OnDrawItem(nIDCtl, lpDrawItemStruct);	
}

void CChordScalePropPage::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct) 
{
	// TODO: Add your message handler code here and/or call default
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CPropertyPage::OnMeasureItem(nIDCtl, lpMeasureItemStruct);
}

void CChordScalePropPage::OnButtonMidichord1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord1);
}

void CChordScalePropPage::OnButtonMidichord2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord2);
}

void CChordScalePropPage::OnButtonMidichord3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord3);
}
void CChordScalePropPage::OnButtonMidichord4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord4);	
}

void CChordScalePropPage::OnButtonMidiroot() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Root);
}

void CChordScalePropPage::OnButtonMidiscale1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale1);
}

void CChordScalePropPage::OnButtonMidiscale2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale2);
}

void CChordScalePropPage::OnButtonMidiscale3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale3);
}

void CChordScalePropPage::OnButtonMidiscale4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale4);
}

void CChordScalePropPage::OnButtonPlay1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(0);
}

void CChordScalePropPage::OnButtonPlay2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(1);	
}

void CChordScalePropPage::OnButtonPlay3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(2);
}

void CChordScalePropPage::OnButtonPlay4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(3);
}

void CChordScalePropPage::OnButtonPlayall() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayAllChords();
}

void CChordScalePropPage::OnChangeEditName() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	char szName[30];
	GetDlgItemText(IDC_EDIT_NAME,szName,sizeof(szName));
	if (strcmp("",szName) && (strcmp(m_Chord.Name(),szName)))
	{
		strncpy(m_Chord.Name(),szName, DMPolyChord::MAX_NAME);
		m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_NAME;
		UpdateChordData();
	}
}

void CChordScalePropPage::DispatchKeyboardChange(CKeyboard* pKeyboard, short nKey)
{
	int i;
	if( (i = GetChordKeyboardIndex(pKeyboard))  >= 0 )
	{
		// send both CKeyboard* and index to save loakup
		OnNoteDownChordKeys(pKeyboard, i, nKey);
	}
	else if( (i = GetScaleKeyboardIndex(pKeyboard)) >= 0 )
	{
		// send both CKeyboard* and index to save loakup
		OnNoteDownScaleKeys(pKeyboard, i, nKey);
	}
}

int CChordScalePropPage::GetChordKeyboardIndex(const CKeyboard* pKeyboard)
{
	int i = 0;
	for(i; i < MAX_POLY; i++)
	{
		if(GetChordKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= MAX_POLY ? -1 : i;
}

int CChordScalePropPage::GetScaleKeyboardIndex(const CKeyboard* pKeyboard)
{
	int i = 0;
	for(i; i < MAX_POLY; i++)
	{
		if(GetScaleKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= MAX_POLY ? -1 : i;
}

void CChordScalePropPage::OnNoteDownChordKeys(CKeyboard* pKeyboard, int index, short nKey) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(0 <= index && index < MAX_POLY && pKeyboard);

	if(nKey < 0)
	{
		return;	// root too low
	}

	if (m_Chord.GetUndetermined(index) & UD_CHORDPATTERN)
	{
		m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
		for (short iKey = 0; iKey < 24; iKey++)
		{
			pKeyboard->SetNoteState(iKey,"",static_cast<short>((1 && ((m_Chord.SubChord(index)->ChordPattern() >> iKey) & 1)) << 1));
		}
	}
	else
	{
		bool rootHasChanged = false;
		short root = static_cast<short>(m_Chord.SubChord(index)->ChordRoot());
		if(nKey < root)
		{
			// root is lower, but we want to keep same chord members so shift up
			// but first make sure that we're not increasing span of chord > 2 octaves
			DWORD shift = root - nKey;
			DWORD pattern = 0xFFFFFFFF << (23 - shift);
			bool bTooHigh = m_Chord.SubChord(index)->ChordPattern() != 0 // an empty chord can never be too high
								&& (HighestBit(m_Chord.SubChord(index)->ChordPattern()) + root  - nKey) >= 24;

			if(root - nKey > 23)
			{
				WarnUser();
			}

			else if(!bTooHigh || (pattern & m_Chord.SubChord(index)->ChordPattern()) == 0)
			{
				// new root
				m_Chord.SubChord(index)->ChordRoot() = static_cast<unsigned char>(nKey);
				rootHasChanged = true;
				m_Chord.SubChord(index)->ChordPattern() <<= shift;
				// make sure anything higher than two octaves of pattern is cutoff.
				m_Chord.SubChord(index)->ChordPattern() &= 0x00ffffff;
				// add member for root note
				m_Chord.SubChord(index)->ChordPattern() |= 0x1;
				m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
			}
			else if(pKeyboard->GetNoteState(static_cast<short>(nKey)) == 2)
			{
				// allow user to turn off bit patterns >= 24 semitones from root
				pKeyboard->SetNoteState(static_cast<short>(nKey), "", 0);
			}
			else
			{
				WarnUser();
			}
		}
		else if(m_Chord.SubChord(index)->ChordPattern() == 0)
		{
			// this is the first note of chord hence it is the root.
			rootHasChanged = true;
			m_Chord.SubChord(index)->ChordRoot() = static_cast<BYTE>(nKey);

			m_Chord.SubChord(index)->ChordPattern() = 1;
			m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
		}
		else if(nKey == root)
		{
			// root must be set so clear it
			pKeyboard->SetNoteState(static_cast<short>(nKey-pKeyboard->Transpose()),"",0);
			// new root
			rootHasChanged = true;
			// third of chord is now root
			root = static_cast<short>(m_Chord.SubChord(index)->Third(0));
			if(root < 0)
			{
				// no chord, set root to lowest note
				root = 0;
				m_Chord.SubChord(index)->ChordRoot() = static_cast<unsigned char>(root);
				m_Chord.SubChord(index)->ChordPattern() = 0;
			}
			else
			{
				m_Chord.SubChord(index)->ChordRoot() = static_cast<BYTE>(root + nKey);
				// shift chord to "root" position, this also gets rid of old root note
				m_Chord.SubChord(index)->ChordPattern() >>= root;
			}
			m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
		}
		else
		{
			//  just update chord
			// if further away from root than 24 semitones, don't allow it
			// TODO: warn user
			DWORD shift = nKey - m_Chord.SubChord(index)->ChordRoot();
			if(shift < 24)
			{
				shift = 1 << shift;
				m_Chord.SubChord(index)->ChordPattern() ^= shift;
				m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
				short state = static_cast<short>(m_Chord.SubChord(index)->ChordPattern() & shift ? 2 : 0);
				pKeyboard->SetNoteState(static_cast<short>(nKey),"", state);
			}
			else if(pKeyboard->GetNoteState(static_cast<short>(nKey)) == 2)
			{
				// allow user to turn off bit patterns >= 24 semitones from root
				pKeyboard->SetNoteState(static_cast<short>(nKey), "", 0);
			}
			else
			{
				WarnUser();
			}
		}


		if(rootHasChanged)
		{
			// need to redraw chord and scale keyboards
			int root = m_Chord.SubChord(index)->ChordRoot();
			for (int nX = root; nX < root + 24; nX++)
			{
				if(nX >= 48)
					break;
				short nState;
				if (m_Chord.GetUndetermined(m_Chord.RootIndex()) & UD_CHORDPATTERN) 
					nState = 4;
				else 
					nState = 0;
				if ((m_Chord.SubChord(index)->ChordPattern() >> (nX-root)) & 1) 
					nState += 2;
				pKeyboard->SetNoteState(static_cast<short>(nX),"",nState);

			}
			DrawScale(&m_Chord, index);
			if(index == m_Chord.RootIndex())
			{
				OnChangeRoot( false );
			}
		}
		else
		{
			short	scaleKey = static_cast<short>(nKey % 12);
			DrawScale(&m_Chord, index, scaleKey);
		}
	}

	if( m_fSyncLevelOneToAll
	&&  index == 0 )
	{
		for( int i = 0; i < MAX_POLY; i++ )
		{
			if( i != index )
			{
				m_Chord.SubChord(i)->ChordPattern() = m_Chord.SubChord(index)->ChordPattern();
				m_Chord.SubChord(i)->ChordRoot() = m_Chord.SubChord(index)->ChordRoot();
				m_Chord.Undetermined(i) &= ~UD_CHORDPATTERN;
			}
		}
		SetChord(&m_Chord);
	}
	UpdateChordData();
}


void CChordScalePropPage::OnNoteDownScaleKeys(CKeyboard* pKeyboard, int index, short nKey) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT(0 <= index && index < MAX_POLY && pKeyboard);

//	nKey = nKey - pKeyboard->Transpose();
	if(nKey < 0)
		nKey += 12;
	if(nKey > 23)
		nKey -= 12;
	short nOtherKey = static_cast<short>((nKey + 12) % 24);

	if (m_Chord.Undetermined(index) & UD_SCALEPATTERN)
	{
		m_Chord.Undetermined(index) &= ~UD_SCALEPATTERN;
		DrawScale(&m_Chord, index);
	}
	else
	{
		DWORD dwScalePattern = m_Chord.SubChord(index)->ScalePattern();
		DWORD dwScaleRoot = m_Chord.SubChord(index)->ScaleRoot() % 12;
		dwScalePattern = Rotate24(dwScalePattern, dwScaleRoot);
		dwScalePattern ^= (1 << nKey);
		dwScalePattern ^= (1 << nOtherKey);
		dwScalePattern = Rotate24(dwScalePattern, 12-dwScaleRoot);
		m_Chord.SubChord(index)->ScalePattern() = dwScalePattern;
		DrawScale(&m_Chord, index);
	}

	if( m_fSyncLevelOneToAll
	&&  index == 0 )
	{
		for( int i = 0; i < MAX_POLY; i++ )
		{
			if( i != index )
			{
				m_Chord.SubChord(i)->ScalePattern() = m_Chord.SubChord(index)->ScalePattern();
				m_Chord.Undetermined(i) &= ~UD_SCALEPATTERN;
			}
		}
		SetChord(&m_Chord);
	}
	UpdateChordData();
}

void CChordScalePropPage::DrawScale(CPropChord* pChord, int index, int note)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	short nGrayed;
	if (pChord->GetUndetermined(index) & UD_SCALEPATTERN) nGrayed = 4;
	else nGrayed = 0;

	// match bits
	DWORD dwScale = pChord->SubChord(index)->ScalePattern();
	DWORD dwChord = pChord->SubChord(index)->ChordPattern();
	DWORD dwBlueBits = BlueBits(dwChord, pChord->SubChord(index)->ChordRoot(),
													dwScale, pChord->SubChord(index)->ScaleRoot()
													);

	// draw scale
	int lower = (note == -1) ? 0 : note;
	int upper = (note == -1) ? 12 : note + 1;
	for(int i = lower; i < upper; i++)
	{
		short nState = nGrayed;
		if(dwScale & (1 << i))
		{
			nState = 2;
		}
		else if(dwBlueBits & (1 << i))
		{
			nState = 1;
		}
		GetScaleKeyboard(index)->SetNoteState(static_cast<short>(i),"",nState);
	}
}

void CChordScalePropPage::UpdateChordData(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr
	&&  m_pPropPageMgr->m_pIPropPageObject)
	{
		CChordScalePropPageData chordscalePropPageData;

		chordscalePropPageData.m_pPropChord = &m_Chord;
		chordscalePropPageData.m_fLockAllScales = m_fLockAllScales;
		chordscalePropPageData.m_fSyncLevelOneToAll = m_fSyncLevelOneToAll;

		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &chordscalePropPageData);
	}	
}

void CChordScalePropPage::SetChordData(CChordScalePropPageData* pChordScalePropPageData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pChordScalePropPageData != NULL );
	if( pChordScalePropPageData )
	{
		SetChord( pChordScalePropPageData->m_pPropChord );

		m_fLockAllScales = pChordScalePropPageData->m_fLockAllScales;
		m_fSyncLevelOneToAll = pChordScalePropPageData->m_fSyncLevelOneToAll;
	}
}

void CChordScalePropPage::SetChord(CPropChord * pChord)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	char str[30];
	
	m_Chord = *pChord;

	if( IsWindow( m_hWnd ) == 0 || !m_bValid) return;

	if(m_bValid && ::IsWindow(m_midiscale4.m_hWnd))
	{

		if(m_Chord.RootIndex() == DMPolyChord::INVALID)
		{
			EnableControls(FALSE);
		}
		else
		{
			EnableControls(TRUE);
		}
	}
	
	if(pChord->RootIndex() >= DMPolyChord::MAX_POLY) 
		return;	// invalid chord, controls will be blanked out

	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_NAME)
	{
		SetDlgItemText(IDC_EDIT_NAME,"");
	}
	else
	{
		SetDlgItemText(IDC_EDIT_NAME,pChord->Name());
	}
	pChord->RootToString(str, pChord->RootIndex());
	SetDlgItemText(IDC_EDIT_ROOT,str);
	SetCheckBox(pChord, UD_FLAT, IDC_USEFLATS, pChord->Base()->UseFlat() && 1);
	SetCheckBox(pChord, UD_FLAT, IDC_USESHARPS, !(pChord->Base()->UseFlat() && 1));
	short nGrayed;
	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_CHORDPATTERN) nGrayed = 4;
	else nGrayed = 0;
	int nX;
	for(int n = 0; n < CPropChord::MAX_POLY; n++)
	{
		GetChordKeyboard(n)->ClearKeys();
		GetScaleKeyboard(n)->ClearKeys();

		int root = static_cast<int>(pChord->SubChord(n)->ChordRoot());
		for (nX = root; nX < root+24; nX++)
		{
			if(nX >= 48)
				break;
			short nState = nGrayed;
			if ((pChord->SubChord(n)->ChordPattern() >> (nX-root)) & 1) nState += 2;
			GetChordKeyboard(n)->SetNoteState(static_cast<short>(nX),"",nState);
		}
		DrawScale(pChord, n);
	}
}

void CChordScalePropPage::SetCheckBox(CPropChord * pChord, DWORD dwUDFlag, UINT nDlgID, UINT nState)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if (pChord->GetUndetermined(pChord->RootIndex()) & dwUDFlag)
	{
		CButton *pButton = (CButton *) GetDlgItem(nDlgID);
		if (pButton)
		{
//			pButton->SetButtonStyle(BS_AUTO3STATE);
			pButton->SetCheck(0);		
		}
	}
	else
	{
		CButton *pButton = (CButton *) GetDlgItem(nDlgID);
		if (pButton)
		{
//			pButton->SetButtonStyle(BS_AUTOCHECKBOX);
			pButton->SetCheck(nState);
		}
	}

}

BOOL CChordScalePropPage::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RegisterMidi();
	
	return CPropertyPage::OnSetActive();
}


void CChordScalePropPage::OnKillFocus(CWnd* pNewWnd) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CPropertyPage::OnKillFocus(pNewWnd);
	
	// TODO: Add your message handler code here
	
}


void CChordScalePropPage::OnChangeRoot( bool fUpdateChordData ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	char str[30];
	DMChord* pSub = m_Chord.SubChord(m_Chord.RootIndex());
	while(pSub->ChordRoot() > 23)
	{
		pSub->ChordRoot() -= 12;
		AfxMessageBox(IDS_ILLEGALCHORD);
		SetChord(&m_Chord);
	}
	m_Chord.RootToString(str, m_Chord.RootIndex());
	SetDlgItemText(IDC_EDIT_ROOT, str);
	m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_CHORDROOT;
	DrawScale(&m_Chord, m_Chord.RootIndex());

	if( fUpdateChordData )
	{
		UpdateChordData();
	}
}

void CChordScalePropPage::OnUseflats() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	for(int i = 0; i < CPropChord::MAX_POLY; i++)
	{
		m_Chord.Undetermined(i) &= ~UD_FLAT;
		m_Chord.SubChord(i)->UseFlat() = 1;
	}
	OnChangeRoot( true );
	UpdateChordData();
}

void CChordScalePropPage::OnUsesharps() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	for(int i = 0; i < CPropChord::MAX_POLY; i++)
	{
		m_Chord.Undetermined(i) &= ~UD_FLAT;
		m_Chord.SubChord(i)->UseFlat() = 0;
	}
	OnChangeRoot( true );
	UpdateChordData();
}

void CChordScalePropPage::SetMidiIn(int keyboard)
{
	if(m_fMidiInputTarget == keyboard)
	{
			CButton* pButton = (CButton*)GetDlgItem(m_MidiInIds[m_fMidiInputTarget]);
			pButton->SetState(FALSE);
			m_fMidiInputTarget  = None;
			UnRegisterMidi();
			return;
	}

	if(m_fMidiInputTarget != None)
	{
			CButton* pButton = (CButton*)GetDlgItem(m_MidiInIds[m_fMidiInputTarget]);
			pButton->SetState(FALSE);
	}
	
	m_fMidiInputTarget = keyboard;
	CButton* pButton = (CButton*)GetDlgItem(m_MidiInIds[m_fMidiInputTarget]);
	pButton->SetState(TRUE);
	RegisterMidi();
}

CButton* CChordScalePropPage::GetButton(int id)
{
	CButton* pButton = 0;
	switch(id)
	{
	case IDC_BUTTON_MIDICHORD1:
		pButton = dynamic_cast<CButton*>(&m_midichord1);
		break;
	case IDC_BUTTON_MIDICHORD2:
		pButton = dynamic_cast<CButton*>(&m_midichord2);
		break;
	case IDC_BUTTON_MIDICHORD3:
		pButton = dynamic_cast<CButton*>(&m_midichord3);
		break;
	case IDC_BUTTON_MIDICHORD4:
		pButton = dynamic_cast<CButton*>(&m_midichord4);
		break;
	case IDC_BUTTON_MIDISCALE1:
		pButton = dynamic_cast<CButton*>(&m_midiscale1);
		break;
	case IDC_BUTTON_MIDISCALE2:
		pButton = dynamic_cast<CButton*>(&m_midiscale3);
		break;
	case IDC_BUTTON_MIDISCALE3:
		pButton = dynamic_cast<CButton*>(&m_midiscale3);
		break;
	case IDC_BUTTON_MIDISCALE4:
		pButton = dynamic_cast<CButton*>(&m_midiscale4);
		break;
	}
	return pButton;
}

void CChordScalePropPage::PlaySubChord(int index)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	short nX;
	DWORD dwTime = 0;

	ChangePatch(0,0,0,0);

	for (nX = 0; nX < 24; nX++)
	{
		if ((m_Chord.SubChord(index)->ChordPattern() >> nX) & 1)
		{
			 unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX + m_Chord.SubChord(index)->ChordRoot());
			PlayNote(0, note, 120, dwTime, CHORDNOTE_DUR); 
			dwTime += CHORDNOTE_DUR;
		}
	}
	dwTime += CHORDNOTE_DELAY;
	for (nX = 0; nX < 25; nX++)
	{
		if ((m_Chord.SubChord(index)->ScalePattern() >> nX) & 1)
		{
			unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX+ m_Chord.SubChord(index)->ScaleRoot());
			PlayNote(0, note, 120, dwTime, SCALENOTE_DUR); 
			dwTime += SCALENOTE_DUR;
		}
	}
}

void CChordScalePropPage::PlayAllChords()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	short nX;
	DWORD dwTime = 0;

	ChangePatch(0,0,0,0);

	for(int index = 0; index < MAX_POLY; index++)
	{
		for (nX = 0; nX < 24; nX++)
		{
			if ((m_Chord.SubChord(index)->ChordPattern() >> nX) & 1)
			{
				 unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX + m_Chord.SubChord(index)->ChordRoot());
				PlayNote(0, note, 120, dwTime, CHORDNOTE_DUR);
				dwTime += CHORDNOTE_DUR;
			}
		}
		dwTime += CHORDNOTE_DUR*2;
	}
}

void CChordScalePropPage::OnDeltaposSpinRoot(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	// check that subchords are in range
	for(int j = 0; j < DMPolyChord::MAX_POLY; j++)
	{
		short chordRoot = static_cast<short>(m_Chord.SubChord(j)->ChordRoot() - pNMUpDown->iDelta);
		DWORD pattern = m_Chord.SubChord(j)->ChordPattern();

		// skip empty patterns
		if(!pattern)
		{
			continue;
		}

		if(chordRoot < 0)
		{
			return;	// out of range
		}

		// check if highest note is in range
		short highestNote = 0;
		for(int k = 0; k < sizeof(DWORD)*8; k++)
		{
			if(pattern & (1 << k))
			{
				highestNote = k;
			}
		}
		if(highestNote + chordRoot >= 48)
		{
			return;	// out of range
		}
	}
	for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
	{
		short chordRoot = static_cast<short>(m_Chord.SubChord(i)->ChordRoot() - pNMUpDown->iDelta);
		bool changeScale = true;
		if (chordRoot < 0 || m_Chord.SubChord(i)->ChordPattern() == 0) 
		{
			chordRoot = 0;
			changeScale = false;
		}
		/*
		if (chordRoot  > 23) 
		{
			chordRoot = 23;
			changeScale = false;
		}
		*/
		m_Chord.SubChord(i)->ChordRoot() = (BYTE) chordRoot;

		if( changeScale )
		{
			if( m_fLockAllScales == false )
			{
				m_Chord.SubChord(i)->ScalePattern() = Rotate24(m_Chord.SubChord(i)->ScalePattern(), -pNMUpDown->iDelta);
			}
		}
	}

	char str[10];
	m_Chord.RootToString(str, m_Chord.RootIndex());
	SetDlgItemText(IDC_EDIT_ROOT, str);
	m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_CHORDROOT;

	SetChord(&m_Chord);
	OnChangeRoot( true );

	*pResult = 0;
}

HRESULT CChordScalePropPage::PlayNote(BYTE ch, BYTE key, BYTE vel, DWORD startTime, DWORD dur)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;

	// make sure we have a performance
	if(m_pIPerformance == 0)
	{
		hr = m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIPerformance);
		if(FAILED(hr))
		{
			return hr;
		}
	}

	// Allocate and initialize a PMsg
	DMUS_MIDI_PMSG* pMidi = NULL;
	hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMidi);
	if(FAILED(hr))
	{
		return hr;
	}
	memset(pMidi, 0, sizeof(DMUS_MIDI_PMSG));

	// fill in midi note on
	pMidi->bStatus = static_cast<BYTE>(0x90 + (ch&0xf));	// note on
	pMidi->bByte1 = key;
	pMidi->bByte2 = vel;

	REFERENCE_TIME	rtNow;
	m_pIPerformance->GetLatencyTime(&rtNow);
	pMidi->rtTime = startTime * 10000 + rtNow;
	pMidi->dwFlags = DMUS_PMSGF_REFTIME;
	pMidi->dwPChannel = (ch&0xf);
	pMidi->dwVirtualTrackID = 1;
	pMidi->dwType = DMUS_PMSGT_MIDI;

	hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pMidi));

	if(SUCCEEDED(hr))
	{
		// Allocate and initialize a PMsg
		DMUS_MIDI_PMSG* pMidi = NULL;
		hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_MIDI_PMSG), (DMUS_PMSG**)&pMidi);
		if(FAILED(hr))
		{
			return hr;
		}
		memset(pMidi, 0, sizeof(DMUS_MIDI_PMSG));
		// fill in midi note off
		pMidi->bStatus = static_cast<BYTE>(0x80 + (ch&0xf));	// note on
		pMidi->bByte1 = key;
		pMidi->bByte2 = vel;

		pMidi->rtTime = (startTime + dur)* 10000 + rtNow;
		pMidi->dwFlags = DMUS_PMSGF_REFTIME;
		pMidi->dwPChannel = (ch&0xf);
		pMidi->dwVirtualTrackID = 1;
		pMidi->dwType = DMUS_PMSGT_MIDI;

		hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pMidi));
	}
	
	return hr;
}

HRESULT CChordScalePropPage::ChangePatch(BYTE ch, BYTE inst, BYTE msb, BYTE lsb)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;

	// make sure we have a performance
	if(m_pIPerformance == 0)
	{
		hr = m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIPerformance);
		if(FAILED(hr))
		{
			return hr;
		}
	}

	// Allocate and initialize a PMsg
	DMUS_PATCH_PMSG* pPatch = NULL;
	hr = m_pIPerformance->AllocPMsg(sizeof (DMUS_PATCH_PMSG), (DMUS_PMSG**)&pPatch);
	if(FAILED(hr))
	{
		return hr;
	}
	memset(pPatch, 0, sizeof(DMUS_PATCH_PMSG));

	// fill in patch
	REFERENCE_TIME	rtNow;
	m_pIPerformance->GetLatencyTime(&rtNow);
	pPatch->byInstrument = inst;
	pPatch->byMSB = msb;
	pPatch->byLSB = lsb;

	pPatch->rtTime = rtNow;
	pPatch->dwFlags = DMUS_PMSGF_REFTIME;
	pPatch->dwPChannel = (ch&0xf);
	pPatch->dwVirtualTrackID = 1;
	pPatch->dwType = DMUS_PMSGT_PATCH;


	hr = m_pIPerformance->SendPMsg(reinterpret_cast<DMUS_PMSG*>(pPatch));

	return hr;
}

BOOL CChordScalePropPage::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	int to, from, whatop;
	bool bModified = false;

	ComputeCopyOp((WORD)wParam, from, to, whatop);

	if(whatop > Nop)
	{
		switch(whatop)
		{
		case CopyChord:
			TRACE("CopyChord from %d to %d\n", from+1, to+1);
			if(to != All)
			{
				if(to == m_Chord.RootIndex() && m_Chord[from]->ChordRoot() > 23)
				{
					// need to make sure root is legal
					AfxMessageBox(IDS_ILLEGALCHORD3);
					break;
				}
				m_Chord[to]->ChordPattern() = m_Chord[from]->ChordPattern();
				m_Chord[to]->ChordRoot() = m_Chord[from]->ChordRoot();
			}
			else
			{
				for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
				{
					if(i == from)
						continue;
					if(i == m_Chord.RootIndex() && m_Chord[from]->ChordRoot() > 23)
					{
						// need to make sure root is legal
						AfxMessageBox(IDS_ILLEGALCHORD3);
						continue;
					}
					m_Chord[i]->ChordPattern() = m_Chord[from]->ChordPattern();
					m_Chord[i]->ChordRoot() = m_Chord[from]->ChordRoot();
				}
			}
			bModified = true;
			break;

		case CopyScale:
			TRACE("CopyScale from %d to %d\n", from+1, to+1);
			if(to != All)
			{
				m_Chord[to]->ScalePattern() = m_Chord[from]->ScalePattern();
				m_Chord[to]->ScaleRoot() = m_Chord[from]->ScaleRoot();
			}
			else
			{
				for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
				{
					if(i == from)
						continue;
					m_Chord[i]->ScalePattern() = m_Chord[from]->ScalePattern();
					m_Chord[i]->ScaleRoot() = m_Chord[from]->ScaleRoot();
				}
			}
			bModified = true;
			break;

		case CopyChordScale:
			TRACE("CopyChordScale from %d to %d\n", from+1, to+1);
			if(to != All)
			{
				if(to == m_Chord.RootIndex() && m_Chord[from]->ChordRoot() > 23)
				{
					// need to make sure root is legal
					AfxMessageBox(IDS_ILLEGALCHORD3);
					break;
				}
				m_Chord[to]->ChordPattern() = m_Chord[from]->ChordPattern();
				m_Chord[to]->ChordRoot() = m_Chord[from]->ChordRoot();
				m_Chord[to]->ScalePattern() = m_Chord[from]->ScalePattern();
				m_Chord[to]->ScaleRoot() = m_Chord[from]->ScaleRoot();
			}
			else
			{
				for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
				{
					if(i == from)
						continue;
					if(i == m_Chord.RootIndex() && m_Chord[from]->ChordRoot() > 23)
					{
						// need to make sure root is legal
						AfxMessageBox(IDS_ILLEGALCHORD3);
						continue;
					}
					m_Chord[i]->ChordPattern() = m_Chord[from]->ChordPattern();
					m_Chord[i]->ChordRoot() = m_Chord[from]->ChordRoot();
					m_Chord[i]->ScalePattern() = m_Chord[from]->ScalePattern();
					m_Chord[i]->ScaleRoot() = m_Chord[from]->ScaleRoot();
				}
			}
			bModified = true;
			break;

		case ClearChordScale:
			TRACE("ClearChordScale from %d to %d\n", from+1, to+1);
			if(to != All)
			{
				m_Chord[to]->ChordPattern() = 0;
				m_Chord[to]->ChordRoot() = 0;
				m_Chord[to]->ScalePattern() = 0;
				m_Chord[to]->ScaleRoot() = 0;
			}
			else
			{
				for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
				{
					m_Chord[i]->ChordPattern() = 0;
					m_Chord[i]->ChordRoot() = 0;
					m_Chord[i]->ScalePattern() = 0;
					m_Chord[i]->ScaleRoot() = 0;
				}
			}
			bModified = true;
			break;

		default:
			TRACE("No operation\n");
			break;
		}
	}
	else
	{
		// additional commands go here
		switch( wParam )
		{
			case IDM_LOCK_ALL_SCALES:
				m_fLockAllScales = m_fLockAllScales ? false : true;
				bModified = true;
				break;
			
			case IDM_SYNC_ALL_LEVELS:
				m_fSyncLevelOneToAll = m_fSyncLevelOneToAll ? false : true;
				bModified = true;
				break;
		}
	}

	if(bModified)
	{
		SetChord(&m_Chord);
		UpdateChordData();
	}

	return CPropertyPage::OnCommand(wParam, lParam);
}

void CChordScalePropPage::DispatchRightMouseKeyboard(CKeyboard * pKeyboard, short nKey, CPoint& ptMouse)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(nKey);
	int i;
	if( (i = GetChordKeyboardIndex(pKeyboard))  >= 0 )
	{
		TRACE("Right click on chord keyboard %d\n", i);
	}
	else if( (i = GetScaleKeyboardIndex(pKeyboard)) >= 0 )
	{
		TRACE("Right click on scale keyboard %d\n", i);
	}

	m_nLastKeyboardLevel = i;	// save keyboard that sent right click

	CMenu cMenu;
	if( cMenu.LoadMenu( MAKEINTRESOURCE(IDR_CHORDPROP) ) != 0 )
	{
		CMenu* pSubMenu = cMenu.GetSubMenu(0);
		if( pSubMenu )
		{
			pSubMenu->CheckMenuItem( IDM_LOCK_ALL_SCALES, (m_fLockAllScales ? MF_CHECKED : MF_UNCHECKED) );
			pSubMenu->CheckMenuItem( IDM_SYNC_ALL_LEVELS, (m_fSyncLevelOneToAll ? MF_CHECKED : MF_UNCHECKED) );

			for( int j = 3; j < 6; j++ )
			{
				CMenu* pSubSubMenu = pSubMenu->GetSubMenu( j );
				if( pSubSubMenu )
				{
					for( int k = 0; k < 4; k++ )
					{
						if( m_nLastKeyboardLevel == -1
						||  m_nLastKeyboardLevel == (3 - k) )
						{
							pSubSubMenu->EnableMenuItem( k, MF_BYPOSITION | MF_GRAYED );
						}
						else
						{
							pSubSubMenu->EnableMenuItem( k, MF_BYPOSITION | MF_ENABLED );
						}
					}
				}
			}

			pKeyboard->ClientToScreen( &ptMouse );

			MSG	msg;
			if( pSubMenu->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON, (int)(ptMouse.x), (int)(ptMouse.y),
										  this ) != 0 )
			{
				::PeekMessage( &msg, pKeyboard->GetSafeHwnd(), 0, 0, PM_REMOVE ); // Remove the last mouse click msg from the queue.
			}
		}
	}
}



void CChordScalePropPage::ComputeCopyOp(WORD menuid, int & from, int & to, int & what)
{
	from = m_nLastKeyboardLevel;
	if(from == -1)
		return;		// not from a menu
	switch(menuid)
	{
	case ID_COPY_CHORD1:
		what = CopyChord;
		to = 0;
		break;
	case ID_COPY_CHORD2:
		what = CopyChord;
		to = 1;
		break;
	case ID_COPY_CHORD3:
		what = CopyChord;
		to = 2;
		break;
	case ID_COPY_CHORD4:
		what = CopyChord;
		to = 3;
		break;
	case ID_COPY_CHORDALL:
		what = CopyChord;
		to = All;
		break;

	case ID_COPY_SCALE1:
		what = CopyScale;
		to = 0;
		break;
	case ID_COPY_SCALE2:
		what = CopyScale;
		to = 1;
		break;
	case ID_COPY_SCALE3:
		what = CopyScale;
		to = 2;
		break;
	case ID_COPY_SCALE4:
		what = CopyScale;
		to = 3;
		break;
	case ID_COPY_SCALEALL:
		what = CopyScale;
		to = All;
		break;

	case ID_COPY_CHORDSCALE1:
		what = CopyChordScale;
		to = 0;
		break;
	case ID_COPY_CHORDSCALE2:
		what = CopyChordScale;
		to = 1;
		break;
	case ID_COPY_CHORDSCALE3:
		what = CopyChordScale;
		to = 2;
		break;
	case ID_COPY_CHORDSCALE4:
		what = CopyChordScale;
		to = 3;
		break;
	case ID_COPY_CHORDSCALEALL:
		what = CopyChordScale;
		to = All;
		break;

	case ID_CLEAR_CHORDSCALE1:
		what = ClearChordScale;
		to = 0;
		break;
	case ID_CLEAR_CHORDSCALE2:
		what = ClearChordScale;
		to = 1;
		break;
	case ID_CLEAR_CHORDSCALE3:
		what = ClearChordScale;
		to = 2;
		break;
	case ID_CLEAR_CHORDSCALE4:
		what = ClearChordScale;
		to = 3;
		break;
	case ID_CLEAR_CHORDSCALEALL:
		what = ClearChordScale;
		to = All;
		break;

	default:
		what = Nop;
		break;
	}
	m_nLastKeyboardLevel = -1;
}

void CChordScalePropPage::WarnUser()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if(!m_bNotWarn)
	{
		CIllegalChord dlg;
		dlg.m_bDontWarn = m_bNotWarn;
		dlg.DoModal();
		m_bNotWarn = dlg.m_bDontWarn;
	}

}

void CChordScalePropPage::EnableControls(BOOL bEnable)
{
	if(!m_bValid)
		return;

	if(!bEnable)
	{
		SetDlgItemText(IDC_EDIT_ROOT, "");
		m_chordname.SetWindowText("");
		for(int n = 0; n < CPropChord::MAX_POLY; n++)
		{
			GetChordKeyboard(n)->ClearKeys();
			GetScaleKeyboard(n)->ClearKeys();
			short nState = 4;
			short nX;
			for (nX = 0; nX < 48; nX++)
			{
				GetChordKeyboard(n)->SetNoteState(static_cast<short>(nX),"",nState);
			}
			for(nX = 0; nX < 12; nX++)
			{
				GetScaleKeyboard(n)->SetNoteState(static_cast<short>(nX),"",nState);
			}
		}
	}

	GetDlgItem(IDC_USEFLATS)->EnableWindow(bEnable);
	GetDlgItem(IDC_USESHARPS)->EnableWindow(bEnable);
	
	m_spinRoot.EnableWindow(bEnable);
	m_chordname.EnableWindow(bEnable);
	m_keysscale4.EnableWindow(bEnable);
	m_keysscale3.EnableWindow(bEnable);
	m_keysscale2.EnableWindow(bEnable);
	m_keysscale1.EnableWindow(bEnable);
	m_keyschord4.EnableWindow(bEnable);
	m_keyschord3.EnableWindow(bEnable);
	m_keyschord2.EnableWindow(bEnable);
	m_keyschord1.EnableWindow(bEnable);
	m_midichord4.EnableWindow(bEnable);
	m_midichord3.EnableWindow(bEnable);
	m_midichord2.EnableWindow(bEnable);
	m_midichord1.EnableWindow(bEnable);
	m_midiscale4.EnableWindow(bEnable);
	m_midiscale3.EnableWindow(bEnable);
	m_midiscale2.EnableWindow(bEnable);
	m_midiscale1.EnableWindow(bEnable);

	m_play1.EnableWindow(bEnable);
	m_play2.EnableWindow(bEnable);
	m_play3.EnableWindow(bEnable);
	m_play4.EnableWindow(bEnable);
	m_playall.EnableWindow(bEnable);
}

LRESULT CChordScalePropPage::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
{
	if(message == WM_MIDIMSG)
	{
		DispatchKeyboardChange(reinterpret_cast<CKeyboard*>(lParam), static_cast<short>(wParam));
	}
	
	return CPropertyPage::WindowProc(message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\DWList.cpp ===
//
// DWList.cpp
//

#include "stdafx.h"  

#include <stdarg.h>
#include <stddef.h>
#include <ctype.h>
#include "DWList.h"

LONG DWListItem::GetCount(void) const
{
    LONG l;
    const DWListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

DWListItem* DWListItem::Cat(DWListItem *pItem)
{
    DWListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

DWListItem* DWListItem::Remove(DWListItem *pItem)
{
    DWListItem *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

DWListItem* DWListItem::GetPrev(DWListItem *pItem) const
{
    const DWListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (DWListItem*)prev;
}

DWListItem * DWListItem::GetItem(LONG index)

{
	DWListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) index--;
	return (scan);
}

void DWList::InsertBefore(DWListItem *pItem,DWListItem *pInsert)

{
	DWListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\ChordStripMgr.cpp ===
// ChordStripMgr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f ChordStripMgrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "riffstrm.h"
#include "initguid.h"
#include <SegmentGuids.h>
#include "ChordIO.h"
#include "ChordStripMgr.h"
#include <ChordMapDesigner.h>

#include "ChordMgr.h"
#include "AFXCTL.H"
#include <dmusici.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_ChordMgr, CChordMgr)
END_OBJECT_MAP()

class CChordStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CChordStripMgrApp theApp;

BOOL CChordStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	return CWinApp::InitInstance();
}

int CChordStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DMUSProducer strip managers

static BOOL RegisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[256];
	TCHAR	 szStripManager[32];
	TCHAR	 szUserName[32];
    TCHAR    szEditorGuid[100];
	TCHAR	 szTrackGuid[100];
    CString  strTrackName, strEditorName;
    TCHAR    szComponentPath[256];
    
	_tcscpy( szStripManager, _T("StripManager") );
	_tcscpy( szUserName, _T("UserName") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
	
    if( SUCCEEDED( StringFromIID(CLSID_ChordMgr, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorGuid, sizeof(szEditorGuid), NULL, NULL );
        CoTaskMemFree( psz );
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicChordTrack, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackGuid, sizeof(szTrackGuid), NULL, NULL );
			CoTaskMemFree( psz );

			strTrackName.LoadString( IDS_TRACK_NAME );
			_tcscpy( szRegPath, szComponentPath );
			_tcscat( szRegPath, szTrackGuid );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szStripManager, szEditorGuid)) )
			{
				return FALSE;
			}
			strEditorName.LoadString( IDS_EDITOR_NAME );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szUserName, strEditorName)) )
			{
				return FALSE;
			}
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[255];
	TCHAR    szGuid[100];
	
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicChordTrack, &psz) ) )
   	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib(LIBID_CHORDSTRIPMGRLib) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\IllegalChord.h ===
#if !defined(AFX_ILLEGALCHORD_H__9036C8B9_5315_11D2_BC79_00C04FA3726E__INCLUDED_)
#define AFX_ILLEGALCHORD_H__9036C8B9_5315_11D2_BC79_00C04FA3726E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// IllegalChord.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CIllegalChord dialog

class CIllegalChord : public CDialog
{
// Construction
public:
	CIllegalChord(CWnd* pParent = NULL);   // standard constructor


// Dialog Data
	//{{AFX_DATA(CIllegalChord)
	enum { IDD = IDD_ILLEGALCHORD };
	CStatic	m_infotext;
	BOOL	m_bDontWarn;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CIllegalChord)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CIllegalChord)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ILLEGALCHORD_H__9036C8B9_5315_11D2_BC79_00C04FA3726E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\ChordStrip.cpp ===
// ChordStrip.cpp : Implementation of CChordStrip
#include "stdafx.h"
#include "ChordIO.h"
#include "ChordStripMgr.h"
#include "ChordMgr.h"
#include "..\shared\MusicTimeConverter.h"
#include "ChordStripPPG.h"
#include "SegmentGuids.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include "SegmentIO.h"
#include "GrayOutRect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define STRIP_HEIGHT 20

static const cbKeySize = 2;

extern const TCHAR SharpKey[12*cbKeySize+1];
extern const TCHAR FlatKey[12*cbKeySize +1];

CString GetName(DWORD dwGroupBits, CString strName)
{
	CString strText, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}

	return strText + CString(": ") + strName;
}

CString GetKeyText( int nKeyRoot, int nNumAccidentals, BOOL fDisplayingFlats )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strText2;
	TCHAR tcstrText1[3];
	TCHAR tcstrTmp[10];
	if( fDisplayingFlats )
	{
		_tcsncpy( tcstrText1, &(FlatKey[nKeyRoot * cbKeySize]), cbKeySize );
		tcstrText1[2] = 0;
		if( tcstrText1[1] == _T(' ') )
		{
			tcstrText1[1] = 0;
		}
		strText2.LoadString( IDS_FLAT_PROPPAGE_TEXT );
	}
	else
	{
		_tcsncpy( tcstrText1, &(SharpKey[nKeyRoot * cbKeySize]), cbKeySize );
		tcstrText1[2] = 0;
		if( tcstrText1[1] == _T(' ') )
		{
			tcstrText1[1] = 0;
		}
		strText2.LoadString( IDS_SHARP_PROPPAGE_TEXT );
	}

	// Add the # of accidentals
	_itot( nNumAccidentals, tcstrTmp, 10 );
	strText2 = tcstrTmp + strText2;

	// Format the string to be "(Key=C#/7#'s)"
	CString strReturn;
	AfxFormatString2( strReturn, IDS_KEY_NAME_FORMAT, tcstrText1, strText2 );
	return strReturn;
}

/////////////////////////////////////////////////////////////////////////////
// CChordStrip

/////////////////////////////////////////////////////////////////////////////
// CChordStrip IUnknown
STDMETHODIMP CChordStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	ASSERT( ppv );
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip*) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdStripFunctionBar ))
	{
		*ppv = (IDMUSProdStripFunctionBar*) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdTimelineEdit ))
	{
		*ppv = (IDMUSProdTimelineEdit*) this;
	}
	else if( IsEqualIID( riid, IID_IDropSource ))
	{
		*ppv = (IDropSource*) this;
	}
	else if( IsEqualIID( riid, IID_IDropTarget ))
	{
		*ppv = (IDropTarget*) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdPropPageObject ))
	{
		*ppv = (IDMUSProdPropPageObject*) this;
	}
	else
	{
		return E_NOTIMPL;
	}
    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CChordStrip::AddRef(void)
{
	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CChordStrip::Release(void)
{
	if( 0L == --m_cRef )
	{
//		if(m_pSelectedRegions)
//		{
//			delete m_pSelectedRegions;
//			m_pSelectedRegions = 0;
//		}
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


void CChordStrip::FormatNameForDrawRoutine( CString& strName, CChordItem* pChord )
{
	char strTemp[24];

	strName.Empty();

	if( pChord->Flags() & DMUS_CHORDKEYF_SILENT )
	{
		strName = _T( "(" );
	}

	pChord->RootToString( strTemp, pChord->RootIndex() );
	strcat( strTemp, pChord->Name() );

	strName += strTemp;

	if( pChord->Flags() & DMUS_CHORDKEYF_SILENT )
	{
		strName += _T( ")" );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CChordStrip IDMUSProdStrip

static bool IntersectsRect(CList<CRect, CRect&>& list, CRect& target)
{
	POSITION pos = list.GetHeadPosition();
	bool rc = false;
	target.NormalizeRect();
	while(pos && !rc)
	{
		CRect regionRect = list.GetNext(pos);
		regionRect.NormalizeRect();
		regionRect &= target;
		rc = !regionRect.IsRectNull();
	}
	return rc;
}

HRESULT	STDMETHODCALLTYPE CChordStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CDC	dc;
	CList<CRect, CRect&> chordRectList;
	CList<CRect, CRect&> regionRectList;

	if( m_pChordMgr->m_pTimeline)
	{
		m_pChordMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, m_pChordMgr->m_dwGroupBits, 0, lXOffset );
		if( dc.Attach(hDC) )
		{
			// draw numbers
			// get first number we need to draw
			CRect	rectClip;
			CRect	rectHighlight;
			long	lFirstVisibleMeasure, lFirstVisibleBeat, lPosition;
			long	lPartialVisibleMeasure, lPartialVisibleBeat;
			long	lClocks;

			CString	str;
			CString	strGhost;
			RECT	rectGhost;
			CChordItem* pGhostChord = NULL;

			CChordItem* pChord = m_pChordMgr->m_ChordList.GetHead();

			dc.GetClipBox( &rectClip );
			//rectHighlight = rectClip;
			rectHighlight.top = 0;
			rectHighlight.bottom = STRIP_HEIGHT;

			// find first visible measure for ghosting chords
			bool bGhostChordCovered = false;	// whether or not a real chord exists where ghostchord would be
			m_pChordMgr->m_pTimeline->GetMarkerTime(MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lClocks);
			CMusicTimeConverter	cmtFirstVisible(lClocks);
			cmtFirstVisible.GetMeasureBeat(lPartialVisibleMeasure, lPartialVisibleBeat, m_pChordMgr->m_pTimeline, m_pChordMgr->m_dwGroupBits);
			CMusicTimeConverter cmtNearestMeasureBeat(lPartialVisibleMeasure, lPartialVisibleBeat, m_pChordMgr->m_pTimeline, m_pChordMgr->m_dwGroupBits);
			if(cmtNearestMeasureBeat.Time() < cmtFirstVisible.Time())
			{
				// round up
				DMUS_TIMESIGNATURE	dmTimeSig;
				cmtFirstVisible.GetTimeSig(dmTimeSig, m_pChordMgr->m_pTimeline, m_pChordMgr->m_dwGroupBits);
				lFirstVisibleBeat = lPartialVisibleBeat + 1;
				lFirstVisibleMeasure = lPartialVisibleMeasure;
				if(lFirstVisibleBeat > (static_cast<long>(dmTimeSig.bBeatsPerMeasure)-1))
				{
					lFirstVisibleBeat = 0;
					lFirstVisibleMeasure = lPartialVisibleMeasure + 1;
				}
			}
			else
			{
				lFirstVisibleBeat = lPartialVisibleBeat;
				lFirstVisibleMeasure = lPartialVisibleMeasure;
			}
			// find nearest chord before first visible measure/beat
			for(CChordItem* pTestChord = pChord; pTestChord; pTestChord = pTestChord->GetNext())
			{
				if( (pTestChord->Measure() < lFirstVisibleMeasure) 
					|| (pTestChord->Measure() == lFirstVisibleMeasure && pTestChord->Beat() < lFirstVisibleBeat) )
				{
					pGhostChord = pTestChord;
				}
				else
				{
					break;
				}
			}
			if(pGhostChord)
			{
				FormatNameForDrawRoutine( strGhost, pGhostChord );

				// get rect of chord, we may have to truncate it if ghostchord covers part of real chord
				m_pChordMgr->m_pTimeline->MeasureBeatToPosition(m_pChordMgr->m_dwGroupBits, 0, 
												lFirstVisibleMeasure, lFirstVisibleBeat, &lPosition);
				lPosition++;
				CSize csize;
				csize = dc.GetTextExtent(strGhost);
				rectGhost.left = lPosition - lXOffset;
				rectGhost.right = rectGhost.left + csize.cx;
				rectGhost.top = 0;
				rectGhost.bottom = STRIP_HEIGHT;
			}


			// we'll draw chord after checking whether or not chord covers it

//			m_pChordMgr->m_pTimeline->PositionToMeasureBeat( m_pChordMgr->m_dwGroupBits, 0, rectClip.left + lXOffset, &lMeasure, NULL );

			while( pChord )
			{
				if( (pChord->Measure() == lFirstVisibleMeasure && pChord->Beat() == lFirstVisibleBeat)
					|| (pChord->Measure() == lPartialVisibleMeasure && pChord->Beat() == lPartialVisibleBeat))
				{
					bGhostChordCovered = true;
				}
				m_pChordMgr->m_pTimeline->MeasureBeatToPosition( m_pChordMgr->m_dwGroupBits, 0, pChord->Measure(), pChord->Beat(), &lPosition );
				lPosition++;

				if(pGhostChord)
				{
					long lTruePos = lPosition - lXOffset;
					// truncate ghost chord's text so that it doesn't cover up a real chord
					if(lTruePos > rectGhost.left && lTruePos < rectGhost.right)
					{
						rectGhost.right = lTruePos;
					}
				}


				// If this chord is not visible (beyond right side of display), break out of the loop
				if( lPosition - lXOffset > rectClip.right )
				{
					break;
				}

				FormatNameForDrawRoutine( str, pChord );

				CChordItem *pChordTemp;

				// Get the bounding rect for the beat.
				rectHighlight.left = lPosition - lXOffset;

				// If the next chord covers part of the previous chord, then truncate text
				pChordTemp = pChord->GetNext();
				if( pChordTemp != NULL)
				{
					m_pChordMgr->m_pTimeline->MeasureBeatToPosition( m_pChordMgr->m_dwGroupBits, 0, pChordTemp->Measure(), 
													 pChordTemp->Beat(), &(rectHighlight.right));
					CSize csize;
					csize = dc.GetTextExtent(str);
					if( (rectHighlight.left + csize.cx) > rectHighlight.right)
					{
						dc.DrawText(str, rectHighlight, (DT_LEFT | DT_NOPREFIX));
					}
					else
					{
						dc.TextOut( lPosition - lXOffset, 0, str, strlen(str) );
					}
					
				}
				else
				{
					dc.TextOut( lPosition - lXOffset, 0, str, strlen(str) );
				}

				pChord->m_lDrawPosition = lPosition;
				pChord = pChord->GetNext();
			}

			// make sure the selected chord is shown in its entirety
			pChord = m_pChordMgr->m_ChordList.GetHead();
//			m_pChordMgr->m_pTimeline->PositionToMeasureBeat( m_pChordMgr->m_dwGroupBits, 0, rectClip.left + lXOffset, &lMeasure, NULL );
			bool bSelected = false;
			// Leave rectHighlight alone
			//rectHighlight = rectClip;
			while(  pChord )	
			{
				if(pChord->IsSelected() && m_lBeginSelect == m_lEndSelect )
				{
					long lBeatEndPos;
					m_pChordMgr->m_pTimeline->MeasureBeatToPosition( m_pChordMgr->m_dwGroupBits, 0, 
															pChord->Measure(), pChord->Beat(), &lPosition );
					m_pChordMgr->m_pTimeline->MeasureBeatToPosition( m_pChordMgr->m_dwGroupBits, 0, 
															pChord->Measure(), pChord->Beat()+1, &lBeatEndPos );
					// find extent of text
					CSize csize;
					FormatNameForDrawRoutine( str, pChord );
					csize = dc.GetTextExtent(str);
					long lExtent = lPosition + csize.cx;
					lExtent = lBeatEndPos > lExtent ? lBeatEndPos : lExtent;
					// truncate if a selected chord covers part of text
					CChordItem* pTempChord = pChord->GetNext();
					bool bTruncated = false;
					while(pTempChord && !bTruncated)
					{
						if(pTempChord->IsSelected())
						{
							
							long lrpos;
							m_pChordMgr->m_pTimeline->MeasureBeatToPosition(m_pChordMgr->m_dwGroupBits, 0,
															 pTempChord->Measure(),
															 pTempChord->Beat(),
															 &lrpos);
							lExtent = (lExtent <= lrpos) ? lExtent : lrpos;
							bTruncated = true;
						}
						pTempChord = pTempChord->GetNext();
					}
					rectHighlight.left = lPosition - lXOffset;
					rectHighlight.right = lExtent - lXOffset;
					dc.DrawText(str, rectHighlight,	 (DT_LEFT | DT_NOPREFIX));
					//TRACE("Highlight Rect: %d %d", rectHighlight.left, rectHighlight.right);
//					GrayOutRect( dc.m_hDC, rectHighlight );
					chordRectList.AddTail(CRect(rectHighlight));	// add so that selectedRegions draw won't double invert
				}

				pChord = pChord->GetNext();
			}
			

			// now draw ghost chord
			if(!bGhostChordCovered && pGhostChord)
			{
				COLORREF cr = dc.SetTextColor(RGB(168,168,168));	// light grey
				dc.DrawText(strGhost, &rectGhost, (DT_LEFT | DT_NOPREFIX));
				dc.SetTextColor(cr);
			}

			
			// Highlight the selected range if there is one.
			if( m_bGutterSelected && m_lBeginSelect != m_lEndSelect )
			{
				m_pChordMgr->m_pTimeline->ClocksToPosition( m_lBeginSelect > m_lEndSelect ? m_lEndSelect : m_lBeginSelect,
											 &(rectHighlight.left));
				m_pChordMgr->m_pTimeline->ClocksToPosition( m_lBeginSelect > m_lEndSelect ? m_lBeginSelect : m_lEndSelect,
											 &(rectHighlight.right));

				rectHighlight.left -= lXOffset;
				rectHighlight.right -= lXOffset;
				// Invert it.
				GrayOutRect( dc.m_hDC, rectHighlight );
			}
			else if(m_pSelectedRegions)
			{
				// Combine region rects with chord rects
				POSITION pos = m_pSelectedRegions->GetHeadPosition();
				while(pos)
				{
					CSelectedRegion* psr = m_pSelectedRegions->GetNext(pos);
					rectHighlight.left = psr->BeginPos(m_pChordMgr->m_pTimeline) - lXOffset;
					rectHighlight.right = psr->EndPos(m_pChordMgr->m_pTimeline) - lXOffset;
					POSITION pos1, pos2;
					pos1 = chordRectList.GetHeadPosition();
					while(pos1)
					{
						pos2 = pos1;
						CRect chordRect = chordRectList.GetNext(pos1);
						CRect tmp;
						tmp.IntersectRect(chordRect, rectHighlight);
						if(!tmp.IsRectEmpty())
						{
							rectHighlight |= chordRect;
							chordRectList.RemoveAt(pos2);
						}
					}
					regionRectList.AddTail(rectHighlight);
				}
			}
			
			// last step may have some overlapping region rects -- combine them
			POSITION pos = regionRectList.GetHeadPosition();
			while(pos)
			{
				POSITION tmp = pos;
				CRect rect = regionRectList.GetNext(pos);
				bool canCombine = false;
				POSITION tmp1 = pos;
				while(tmp1 && !canCombine)
				{
					CRect& rectNext = regionRectList.GetNext(tmp1);
					if(!(rect & rectNext).IsRectEmpty())
					{
						canCombine = true;
						rectNext |= rect;
						regionRectList.RemoveAt(tmp);
					}
				}
			}
			// draw inverted regions
			pos = regionRectList.GetHeadPosition();
			while(pos)
			{
				CRect rect = regionRectList.GetNext(pos);
				GrayOutRect( dc.m_hDC, rect );
			}
/*
			pos = chordRectList.GetHeadPosition();
			while(pos)
			{
				CRect rect = chordRectList.GetNext(pos);
				GrayOutRect( dc.m_hDC, rect );
			}
*/
			dc.Detach();
		}
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case SP_RESIZEABLE:
		pvar->vt = VT_BOOL;
//		V_BOOL(pvar) = TRUE; // this is really FALSE, but we'll make it true for now for testing
		V_BOOL(pvar) = FALSE;
		break;
	case SP_GUTTERSELECTABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;
	case SP_MINMAXABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;
	case SP_DEFAULTHEIGHT:
	case SP_MINHEIGHT:
	case SP_MAXHEIGHT:
		pvar->vt = VT_INT;
		V_INT(pvar) = STRIP_HEIGHT;
		break;
	case SP_NAME:
		{
			BSTR bstr;
			CString str;
			CString strTemp;
			TCHAR buf[256];

			HINSTANCE hinst = _Module.GetModuleInstance();

			// Set strTemp to the correct string, according to m_bPatternEditorMode
			if( m_pChordMgr->m_bPatternEditorMode == 1 )
			{
				::LoadString( hinst, IDS_MIDI_MODE_TEXT, buf, 256 );
				strTemp = buf;
			}
			else if( m_pChordMgr->m_bPatternEditorMode == 2 )
			{
				::LoadString( hinst, IDS_FUNCTION_MODE_TEXT, buf, 256 );
				strTemp = buf;
			}

			// Check if we're in the segment designer
			if( m_pChordMgr->m_pIDMTrack )
			{
				// Yes - load the 'Chord' text
				::LoadString( hinst, IDS_CHORDS_TEXT, buf, 256 );

				// If the m_bPatternEditorMode text is empty
				if( strTemp.IsEmpty() )
				{
					// Just use the 'Chord' text
					strTemp = buf;
				}
				else
				{
					// Use the m_bPatternEditorMode text + the 'Chord' text
					strTemp += CString(_T(" ")) + CString(buf);
				}

				// Format the name to include the group bits at the front
				str = GetName( m_pChordMgr->m_dwGroupBits, strTemp );
			}
			else
			{
				// No, we're in the pattern editor
				::LoadString( hinst, IDS_PATTERN_EDITOR_TEXT, buf, 256 );

				// Use the m_bPatternEditorMode text + the 'Chord for Composition' text
				str = strTemp + _T(" ") + buf;
			}

			// Add the Key to the name
			str += _T(" ") + GetKeyText(m_pChordMgr->m_nKeyRoot, m_pChordMgr->m_nNumAccidentals, m_pChordMgr->m_fDisplayingFlats);
			
			pvar->vt = VT_BSTR; 
			try
			{
				bstr = str.AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR(pvar) = bstr;
		}
		break;
	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		if( m_pChordMgr )
		{
			m_pChordMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		}
		else
		{
			V_UNKNOWN(pvar) = NULL;
		}
		break;
	default:
		return E_FAIL;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CChordStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	long measure, beat;
	switch( sp )
	{
	case SP_BEGINSELECT:
	case SP_ENDSELECT:
		if( var.vt != VT_I4)
		{
			return E_FAIL;
		}
		if( sp == SP_BEGINSELECT )
		{
			m_lBeginSelect = V_I4( &var );
			// round down to nearest beat
			m_pChordMgr->m_pTimeline->ClocksToMeasureBeat(m_pChordMgr->m_dwGroupBits, 0, m_lBeginSelect,
															&measure, &beat);
			m_pChordMgr->m_pTimeline->MeasureBeatToClocks(m_pChordMgr->m_dwGroupBits, 0,
															measure, beat, &m_lBeginSelect);
		}
		else
		{
			long clocks;
			clocks = m_lEndSelect = V_I4( &var );
			// clip to nearest beat
			m_pChordMgr->m_pTimeline->ClocksToMeasureBeat(m_pChordMgr->m_dwGroupBits, 0, m_lEndSelect,
															&measure, &beat);
			m_pChordMgr->m_pTimeline->MeasureBeatToClocks(m_pChordMgr->m_dwGroupBits, 0,
															measure, beat, &m_lEndSelect);
			if(clocks > m_lEndSelect)
			{
				beat++;
				m_pChordMgr->m_pTimeline->MeasureBeatToClocks(m_pChordMgr->m_dwGroupBits, 0,
															measure, beat, &m_lEndSelect);
			}
		}

		if( m_bSelecting )
		{
			break;
		}

		// Initialize anchor for future shift-select operations
		m_pSelectedRegions->SetShiftSelectAnchor( 0 );

		if( m_lBeginSelect == m_lEndSelect )
		{	
			m_pSelectedRegions->Clear();
			SelectChordsInSelectedRegions();

			m_pChordMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			break;
		}
		if( m_bGutterSelected )
		{
			m_pSelectedRegions->Clear();
			SelectChordsInSelectedRegions();
			m_pChordMgr->SelectSegment( m_lBeginSelect, m_lEndSelect );
			// save point of begin select for pasting from timeline
			m_pChordMgr->m_pTimeline->ClocksToPosition(m_lBeginSelect, &m_lXPos);
		}
		else
		{
			m_pChordMgr->UnselectChords();
		}
		m_pChordMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

		// Update the property page
		if( m_pChordMgr->m_pPropPageMgr != NULL )
		{
			m_pChordMgr->m_pPropPageMgr->RefreshData();
		}
		break;
	case SP_GUTTERSELECT:
		m_bGutterSelected = V_BOOL(&var);
		if( m_lBeginSelect == m_lEndSelect )
		{	
			m_pSelectedRegions->Clear();
			SelectChordsInSelectedRegions();
			m_pChordMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			if(m_bGutterSelected)
			{
				long lTime;
				// save point of begin select for pasting from timeline
				m_pChordMgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime);
				m_pChordMgr->m_pTimeline->ClocksToPosition(lTime, &m_lXPos);
			}
			break;
		}
		if( m_bGutterSelected )
		{
			long lTime;
			m_pSelectedRegions->Clear();
			SelectChordsInSelectedRegions();
			m_pChordMgr->m_pTimeline->GetMarkerTime(MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lBeginSelect);
			m_pChordMgr->m_pTimeline->GetMarkerTime(MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lEndSelect);
			m_pChordMgr->SelectSegment( m_lBeginSelect, m_lEndSelect );
			// save point of begin select for pasting from timeline
			m_pChordMgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime);
			m_pChordMgr->m_pTimeline->ClocksToPosition(lTime, &m_lXPos);
		}
		else
		{
			m_pSelectedRegions->Clear();
			SelectChordsInSelectedRegions();
		}
		m_pChordMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

		// Update the property page
		if( m_pChordMgr->m_pPropPageMgr != NULL )
		{
			m_pChordMgr->m_pPropPageMgr->RefreshData();
		}
		break;
	default:
		return E_FAIL;
	}
	return S_OK;
}

CChordItem *CChordStrip::GetChordFromPoint( long lPos )
{
	long lMeasure, lBeat;


	if( m_pChordMgr->m_pTimeline )
	{
		CChordItem *pChord = m_pChordMgr->m_ChordList.GetHead();
		if ( SUCCEEDED(	m_pChordMgr->m_pTimeline->PositionToMeasureBeat( m_pChordMgr->m_dwGroupBits, 0, lPos, &lMeasure, &lBeat )))
		{
			for( ; pChord != NULL; pChord = pChord->GetNext())
			{
				if ( pChord->Measure() == lMeasure)
				{
					if (pChord->Beat() == lBeat)
					{
						break;
					}
				}
				else if ( pChord->Measure() > lMeasure )
				{
					pChord = NULL;
					break;
				}
			}
		}
		return pChord;
	}
	return NULL;
}


HRESULT STDMETHODCALLTYPE CChordStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_OK;
	CChordItem* pChord = NULL;
	VARIANT var;
	static slXPos;

	if( m_pChordMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}
	switch( nMsg )
	{
	case WM_KEYDOWN:
		{
			int nVirtKey = (int)wParam;
			unsigned long lKeyData = lParam;
			if(ProcessKey(nVirtKey, lKeyData))
			{
				m_nLastEdit = IDS_UNDO_DELETE;
				m_pChordMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
				m_pChordMgr->UpdateDirectMusic( TRUE );
			}
			hr = S_OK;
			break;
		}
	case WM_LBUTTONDOWN:
		// capture mouse so we get the LBUTTONUP message as well
		// the timeline will release the capture when it receives the
		// LBUTTONUP message
		GetTimelineCWnd()->SetFocus();
		slXPos = lXPos;
		var.vt = VT_BOOL;
		V_BOOL(&var) = TRUE;
		m_pChordMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
		UnselectGutterRange();
		m_fShowChordProps = TRUE;

		pChord = GetChordFromPoint( lXPos );

		if(wParam & MK_SHIFT)
		{
			m_pSelectedRegions->ShiftAddRegion(lXPos);
			SelectChordsInSelectedRegions();
		}
		else
		{
			if( pChord )					// drag/drop ops
			{
				if(wParam & MK_CONTROL)
				{
					// only want to do this once--when a chord is selected it goes through twice, once
					// so that selection shows up, then a second time to do drag drop.  We only want to toggle
					// if (a) no chord was selected or (b) no drag/drop done.
					m_pSelectedRegions->DelayToggle(lXPos);
					SelectChordsInSelectedRegions();
	//				return S_OK;
				}
				else if(!pChord->IsSelected())
				{
					m_pSelectedRegions->Clear();
					m_pSelectedRegions->AddRegion(lXPos);
					SelectChordsInSelectedRegions();
					m_pChordMgr->m_SelectedChord = *pChord;
				}
				m_bLeftMouseButtonDown = true;
				m_dwStartDragButton = (unsigned long)wParam;
				m_startDragPosition = lXPos;
			}
			else
			{
				if(wParam & MK_CONTROL)
				{
					m_pSelectedRegions->ToggleRegion(lXPos);
					SelectChordsInSelectedRegions();
				}
				else
				{
					m_pSelectedRegions->Clear();
					m_pSelectedRegions->AddRegion(lXPos);
					SelectChordsInSelectedRegions();
				}
			}

			// Set anchor for future shift-select operations
			m_pSelectedRegions->SetShiftSelectAnchor( lXPos );
		}

		if(pChord && pChord->IsSelected())
		{
			m_pChordMgr->m_SelectedChord = *pChord;
			m_pChordMgr->m_ChordList.PreparePropChord( &m_pChordMgr->m_SelectedChord );
		}
		else if(m_pChordMgr->IsSelected())
		{
			CChordItem* pItem = m_pChordMgr->FirstSelectedChord();
			m_pChordMgr->m_SelectedChord = *pItem;
			m_pChordMgr->m_ChordList.PreparePropChord( &m_pChordMgr->m_SelectedChord );
		}
		else
		{
			m_pChordMgr->m_SelectedChord.RootIndex() = DMPolyChord::INVALID;
		}

		// Todo, replace NULL by actual area invalidated (in strip coordinates)
		m_pChordMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

		if( m_pChordMgr->m_pPropPageMgr )
		{
			m_pChordMgr->m_pPropPageMgr->RefreshData();
		}
		m_pChordMgr->OnShowProperties();
		break;
	case WM_RBUTTONDOWN:
		UnselectGutterRange();
		// Get the item at the mouse click.
		// TODO: modify code to work with CListSelectedRegion
	    pChord = GetChordFromPoint( lXPos );
		slXPos = lXPos;
		if( !(wParam & MK_CONTROL)
		&&  !(wParam & MK_SHIFT) )
		{
			if( pChord )
			{
				if( !pChord->IsSelected() )
				{
					m_pChordMgr->UnselectChords();
					pChord->SetSelected( TRUE );
					m_pChordMgr->m_SelectedChord = *pChord;
					m_pChordMgr->m_ChordList.PreparePropChord( &m_pChordMgr->m_SelectedChord );
					m_pSelectedRegions->Clear();
					m_pSelectedRegions->AddRegion(lXPos);
				}
				else
				{
					// chord is selected already, do nothing
				}
			}
			else
			{
				// if region not selected, select it, otherwise do nothing
				long m, b;
				m_pChordMgr->m_pTimeline->PositionToMeasureBeat(m_pChordMgr->m_dwGroupBits, 0, lXPos, &m, &b);
				if(!m_pSelectedRegions->Contains(m,b))
				{
					m_pChordMgr->UnselectChords();
					m_pSelectedRegions->Clear();
					m_pChordMgr->m_SelectedChord.RootIndex() = DMPolyChord::INVALID;
					m_pSelectedRegions->AddRegion(lXPos);
				}
				else
				{
					// region is selected already, do nothing
				}
			}
		}
		else
		{
			// control or shift
		}


		m_pChordMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
		m_fShowChordProps = TRUE;
		if( m_pChordMgr->m_pPropPageMgr )
		{
			m_pChordMgr->m_pPropPageMgr->RefreshData();
		}
		m_pChordMgr->OnShowProperties(); 
		break;
	case WM_RBUTTONUP:
		POINT pt;
		BOOL	bResult;
		// Get the cursor position (To put the menu there)
		bResult = GetCursorPos( &pt );
		ASSERT( bResult );
		if( !bResult )
		{
			hr = E_UNEXPECTED;
			break;
		}

		m_lXPos = lXPos;
		hr = DoRightClickMenu( m_pChordMgr->m_pTimeline, pt );
		break;
	case WM_COMMAND:
		WORD wNotifyCode;
		WORD wID;

		wNotifyCode	= HIWORD( wParam );	// notification code 
		wID			= LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
		case ID_VIEW_PROPERTIES:
			hr = ShowPropertySheet(m_pChordMgr->m_pTimeline);
			if (m_fShowChordProps )
			{
				// Change to the chord property page
				m_pChordMgr->OnShowProperties();
			}
			else
			{
				// Change to our property page
				OnShowProperties();
			}
			break;
		case ID_EDIT_CUT:
			hr = Cut();
			break;
		case ID_EDIT_COPY:
			hr = Copy();
			break;
		case ID_EDIT_DELETE:
			hr = Delete();
			break;
		case ID_EDIT_PASTE:
			hr = Paste();
			break;
		case ID_EDIT_INSERT:
			hr = Insert();
			break;
		case ID_EDIT_SELECT_ALL:
			hr = SelectAll();
			break;
		case ID_HIDE_FROM_RHYTHM:
		{
			short nState = m_pChordMgr->GetSelectedHideState();
			for( CChordItem* pChord = m_pChordMgr->m_ChordList.GetHead();  pChord;  pChord = pChord->GetNext() )
			{
				if( pChord->IsSelected() )
				{
					if( nState == HIDE_ALL_ON )
					{
						pChord->Flags() &= ~DMUS_CHORDKEYF_SILENT;
					}
					else
					{
						pChord->Flags() |= DMUS_CHORDKEYF_SILENT;
					}
				}
			}
			m_nLastEdit = IDS_UNDO_HIDE_FROM_RHYTHM;
			m_pChordMgr->UpdateDirectMusic( TRUE );
			m_pChordMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			hr = S_OK;
			break;
		}
		case IDM_CONSTANT_MIDI:
			m_pChordMgr->m_bPatternEditorMode = 1;
			m_pChordMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			m_pChordMgr->m_pTimeline->NotifyStripMgrs( GUID_ChordParam, m_pChordMgr->m_dwGroupBits, NULL );
			hr = S_OK;
			break;
		case IDM_CONSTANT_FUNCTION:
			m_pChordMgr->m_bPatternEditorMode = 2;
			m_pChordMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			m_pChordMgr->m_pTimeline->NotifyStripMgrs( GUID_ChordParam, m_pChordMgr->m_dwGroupBits, NULL );
			hr = S_OK;
			break;
		default:
			break;
		}
		break;

	case WM_LBUTTONUP:
		{
			pChord = GetChordFromPoint( lXPos );
			if(pChord)
			{
				if( !(wParam & MK_CONTROL)
				&&  !(wParam & MK_SHIFT) )
				{
					m_pSelectedRegions->Clear();
					m_pSelectedRegions->AddRegion(lXPos);
				}
				else
				{
					m_pSelectedRegions->CompleteToggle();
				}
//				m_pSelectedRegions->CompleteDeselect();
				SelectChordsInSelectedRegions();
				// make sure if no chords are selected that prop page shows invalid
				if(!m_pChordMgr->IsSelected())
				{
					m_pChordMgr->m_SelectedChord.RootIndex() = DMPolyChord::INVALID;
					if( m_pChordMgr->m_pPropPageMgr )
					{
						m_pChordMgr->m_pPropPageMgr->RefreshData();
					}
//					m_pChordMgr->OnShowProperties();
				}
				else
				{
					// adjust property page to show first selected chord
					m_pChordMgr->m_SelectedChord = *(m_pChordMgr->FirstSelectedChord());
					m_pChordMgr->m_ChordList.PreparePropChord( &m_pChordMgr->m_SelectedChord );
					
				}
				m_pChordMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			}
			m_bLeftMouseButtonDown = false;
			m_lXPos = lXPos;
//		UnselectGutterRange();
			m_bMouseSelect = false;
			hr = S_OK;
			// if nothing is selected, invalidate prop page
			if(m_pSelectedRegions->IsEmpty())
			{
				m_pChordMgr->m_SelectedChord.RootIndex() = DMPolyChord::INVALID;
			}
			m_fShowChordProps = TRUE;
			if( m_pChordMgr->m_pPropPageMgr )
			{
				m_pChordMgr->m_pPropPageMgr->RefreshData();
			}
			m_pChordMgr->OnShowProperties(); 
		}
		break;
	case WM_MOUSEMOVE:
		if(m_bLeftMouseButtonDown)
		{
			if(abs(slXPos - lXPos) <= 3)
				return S_OK;	// delay till user actually moves
			hr = StartDragDrop(m_pChordMgr->m_pTimeline, m_startDragPosition);
			if(hr != S_OK)
			{
				m_lXPos = lXPos;	// because drag drop eats mouse up
				m_pSelectedRegions->CompleteToggle();
//				m_pSelectedRegions->CompleteDeselect();
				SelectChordsInSelectedRegions();
				// make sure if no chords are selected that prop page shows invalid
				if(!m_pChordMgr->IsSelected())
				{
					m_pChordMgr->m_SelectedChord.RootIndex() = DMPolyChord::INVALID;
					if( m_pChordMgr->m_pPropPageMgr )
					{
						m_pChordMgr->m_pPropPageMgr->RefreshData();
					}
//					m_pChordMgr->OnShowProperties();
				}		
				m_pChordMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			}
		}
		m_bLeftMouseButtonDown = false;
		break;
	case WM_CREATE:
		// Get Left and right selection boundaries
		m_bGutterSelected = FALSE;
		m_pChordMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lBeginSelect );
		m_pChordMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lEndSelect );

		if( !m_cfChordList )
		{
			m_cfChordList = RegisterClipboardFormat( CF_CHORDLIST );
		}

		if(!m_pSelectedRegions)
			m_pSelectedRegions = new CListSelectedRegion(m_pChordMgr->m_pTimeline, m_pChordMgr->m_dwGroupBits);
		else
		{
			m_pSelectedRegions->m_pTimeline = m_pChordMgr->m_pTimeline;
			m_pSelectedRegions->m_dwGroupbits = m_pChordMgr->m_dwGroupBits;
		}
		break;
	default:
		break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CChordStrip IDMUSProdTimelineEdit

HRESULT CChordStrip::Cut( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr;

	hr = CanCut();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	hr = Copy(pITimelineDataObject);
	if( SUCCEEDED( hr ))
	{
		hr = Delete();
	}

	return hr;
}

HRESULT CChordStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;
	IStream*			pStreamCopy;

	hr = CanCopy();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pChordMgr != NULL );
	if( m_pChordMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfChordList == 0 )
	{
		m_cfChordList = RegisterClipboardFormat( CF_CHORDLIST );
		if( m_cfChordList == 0 )
		{
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected commands in.
	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	// Save the commands into the stream.
	long offset, endRegion;
	m_pSelectedRegions->GetSpan(offset, endRegion);
	hr = m_pChordMgr->SaveSelectedChords( pStreamCopy, offset );
	/* not necessary, unless you want to save regions in clipboard
	if(hr == S_OK)
	{
		hr = SaveSelectedRegions(pStreamCopy, offset, TRUE );
	}
	*/
	if( FAILED( hr ))
	{
		pStreamCopy->Release();
		return E_UNEXPECTED;
	}

	if(pITimelineDataObject != NULL)
	{
		// add the stream to the passed ITimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfChordList, pStreamCopy );
		pStreamCopy->Release();
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			return E_FAIL;
		}
	}
	// Otherwise, add it to the clipboard
	else
	{
		// There is no existing data object, so just create a new one
		hr = m_pChordMgr->m_pTimeline->AllocTimelineDataObject(&pITimelineDataObject);
		ASSERT(hr == S_OK);
		if(hr != S_OK)
		{
			return E_FAIL;
		}

		// Set the start and edit time of this copy
		long lRegionStart, lRegionEnd;
		m_pSelectedRegions->GetSpan(lRegionStart, lRegionEnd);
		hr = pITimelineDataObject->SetBoundaries(lRegionStart, (lRegionEnd - 1));

		// add the stream to the DataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfChordList, pStreamCopy );
		pStreamCopy->Release();
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}

		// get the new IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export(&pIDataObject);

		// Release the ITimelineDataObject
		pITimelineDataObject->Release();

		// Exit if the Export failed
		if(FAILED(hr))
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );
		if( hr != S_OK )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// If we already have a CopyDataObject, release it
		if(m_pChordMgr->m_pCopyDataObject)
		{
			m_pChordMgr->m_pCopyDataObject->Release();
		}

		// set m_pCopyDataObject to the object we just copied to the clipboard
		m_pChordMgr->m_pCopyDataObject = pIDataObject;

		// Not needed = Object was AddRef()'d when it was exported from the IDMUSProdTimelineDataObject
		// m_pCopyDataObject->AddRef
	}

	return hr;
}


HRESULT CChordStrip::PasteReplace(CChordList& list, CMusicTimeConverter& cmtStart, CMusicTimeConverter& cmtEnd, BOOL& fChanged)
//
// this algorithm is slow -- we make several passes, but it is clear and lists should be relatively short
//
{
//	ASSERT(cmtStart <= cmtEnd);
	// add regions of chords to selected regions to be used as a mask to delete overwritten chords
	CChordItem* pChord;
	m_pChordMgr->m_ChordList.ClearSelections();
	// select chords in same time range
	pChord = m_pChordMgr->m_ChordList.GetHead();
	for(; pChord; pChord = pChord->GetNext())
	{
		CMusicTimeConverter cmtChord(pChord->Measure(), pChord->Beat(), 
										m_pChordMgr->m_pTimeline, m_pChordMgr->m_dwGroupBits);
		if(cmtChord > cmtEnd)
			break;		// done, past selection range
		else if(cmtChord < cmtStart)
			continue;	// not to selection range yet
		else
		{
			pChord->SetSelected(TRUE);
			fChanged = TRUE; // This chord will be deleted below
		}
	}
	// delete selected chords
	m_pChordMgr->DeleteSelectedChords();
	// now insert list
	for(pChord = list.RemoveHead(); pChord; pChord = list.RemoveHead())
	{
		pChord->SetNext(0);
		pChord->SetSelected(TRUE);		// make sure chord is selected
//		pChord->m_dwUndeterminined |= UD_DROPSELECT; // prevent property page logic from mucking with dropped chords
		m_pChordMgr->m_ChordList.InsertByAscendingTime(pChord);
		fChanged = TRUE;
	}
	return S_OK;
}


HRESULT CChordStrip::PasteMerge(CChordList& list, CMusicTimeConverter& cmtStart, CMusicTimeConverter& cmtEnd, BOOL& fChanged)
//
// this algorithm is slow -- we make several passes, but it is clear and lists should be relatively short
//
{
//	ASSERT(cmtStart < cmtEnd);
	m_pChordMgr->m_ChordList.ClearSelections();
	CChordItem* pChord;
	// now insert list
	for(pChord = list.RemoveHead(); pChord; pChord = list.RemoveHead())
	{
		pChord->SetNext(0);
		pChord->SetSelected(TRUE);		// make sure chord is selected
//		pChord->m_dwUndeterminined |= UD_DROPSELECT; // prevent property page logic from mucking with dropped chords
		m_pChordMgr->m_ChordList.InsertByAscendingTime(pChord, true);
		fChanged = TRUE;
	}
	return S_OK;
}

HRESULT CChordStrip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, POINTL pt, bool bDropNotEditPaste)
{
	if( pITimelineDataObject == NULL )
	{
		return E_NOTIMPL;
	}

	HRESULT hr = E_FAIL;

	if( pITimelineDataObject->IsClipFormatAvailable( m_cfChordList ) == S_OK )
	{
		IStream* pIStream;
		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfChordList, &pIStream)))
		{
			// declare a temp list and write chords into it
			CChordList list;
			// Set PatternEditorMode so DMUS_CHORDKEYF_SILENT flag turned off when chords pasted into Pattern editor
			list.SetPatternEditorMode( m_pChordMgr->m_bPatternEditorMode );	
			list.Load(pIStream);
			pIStream->Release();
			if(bDropNotEditPaste && (list.GetHead() == NULL))
			{
				// don't drop an empty list, note don't check listRegions since can't have paste from regions only
				// However, do paste an empty list
				hr = E_FAIL;
				goto Leave;
			}
			// update times from position of drop
			
			if( m_pChordMgr->m_pTimeline )
			{
				// get offset of first chord's drag position to normalize all chords to offset zero:
				long clocksDragOffset ;
				// convert drop postition to beats
				long position = pt.x;
				long clocksDropOffset;
				long firstClock = 0, lastClock = 0;
				long m,b;
				long offset;
				if(SUCCEEDED(m_pChordMgr->m_pTimeline->PositionToMeasureBeat(m_pChordMgr->m_dwGroupBits, 0, position, &m, &b)))
				{
						// convert measure/beat to clcks
					CMusicTimeConverter cmt(m,b, m_pChordMgr->m_pTimeline, m_pChordMgr->m_dwGroupBits);
					if(bDropNotEditPaste)
					{
						clocksDropOffset = cmt;
						// check that we've actually "moved" somewhere.  If not cancel the drop
						if(m_pISourceDataObject == m_pITargetDataObject)
						{
							// we're in our strip
							long deltapos = abs(pt.x - m_startDragPosition);
							/*
							long m,b;
							m_pChordMgr->m_pTimeline->PositionToMeasureBeat(m_pChordMgr->m_dwGroupBits, 0, deltapos, &m, &b);
							if(m == 0 && b < 1)
							*/
							if(deltapos < 1)
							{
								// cancel drop
								hr = E_FAIL;
								list.ClearList();
								goto Leave;
							}
						}
						// offset measure/beat in chords to be drop
						// first find selected chord
						CChordItem* pChord = NULL;
						for(pChord = list.GetHead(); pChord && !pChord->IsSelected(); pChord = pChord->GetNext()) 
						{
							continue;
						}
						if(pChord)
						{
							// this is selected chord: use it as the drag offset
							// convert its measure/beat to beats
							CMusicTimeConverter cmt1(pChord->Measure(), pChord->Beat(), 
														m_pChordMgr->m_pTimeline, m_pChordMgr->m_dwGroupBits);
							clocksDragOffset = cmt1;
						}
						else
						{
							// no chord selected, list came from somewhere else, dragoffset = 0
							clocksDragOffset = 0;
						}
						offset = clocksDropOffset - clocksDragOffset;
						if(offset < 0)
						{
							offset = 0;
						}
					}
					else
					{
						offset = cmt;
					}
					TIMELINE_PASTE_TYPE pasteType;
					long lStartTime, lEndTime;
					// get timespan of pasted area
					if(bDropNotEditPaste)
					{
						// need to set boundaries and paste type from internal data
						m_pChordMgr->GetSpanOfChordList(lStartTime, lEndTime, &list);
						pasteType = TL_PASTE_MERGE;
						hr = S_OK;
					}
					else
					{
						hr = pITimelineDataObject->GetBoundaries(&lStartTime, &lEndTime);
						hr = m_pChordMgr->m_pTimeline->GetPasteType(&pasteType);
						lEndTime -= lStartTime;
						lStartTime = 0;
					}
					ASSERT(hr==S_OK);
					m_pChordMgr->NormalizeChordList(list, offset);
					// normalized time converters
					CMusicTimeConverter cmtStart(lStartTime + offset);
					CMusicTimeConverter cmtEnd( lEndTime + offset );
					BOOL fChanged = FALSE;
					if(hr == S_OK)
					{
						// Just did this.
						//if(SUCCEEDED(hr))
						{
							switch (pasteType)
							{
							case TL_PASTE_OVERWRITE:
								hr = PasteReplace(list, cmtStart, cmtEnd, fChanged);
								break;
							case TL_PASTE_MERGE:
								// no regions, since regions are transparent in a merge
								hr = PasteMerge(list, cmtStart, cmtEnd, fChanged);
								break;
							default:
								hr = E_UNEXPECTED;
								break;
							}
							if(SUCCEEDED(hr))
							{
								SelectRegionsFromSelectedChords();
							}
						}
//						m_pSelectedRegions->Clear();	// no selected "space" after paste
					}

					if( m_nStripIsDragDropSource )
					{
						// Drag/drop Target and Source are the same StyleRef strip
						m_nStripIsDragDropSource = 2;
					}
					else if ( fChanged )
					{
						if(!bDropNotEditPaste)
						{
							// make sure chord is in prop page
							CChordItem* pChord = GetChordFromPoint( pt.x );
							if(!pChord)
							{
								// first chord will do
								pChord = m_pChordMgr->m_ChordList.GetHead();
							}
							if(pChord)
							{
								m_pChordMgr->m_SelectedChord = *pChord;
								m_pChordMgr->m_ChordList.PreparePropChord( &m_pChordMgr->m_SelectedChord );
								m_pChordMgr->OnShowProperties();
								if( m_pChordMgr->m_pPropPageMgr )
								{
									m_pChordMgr->m_pPropPageMgr->RefreshData();
								}
							}

						}
						m_nLastEdit = IDS_UNDO_PASTE;
						m_pChordMgr->UpdateDirectMusic( TRUE );
						m_pChordMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
					}

				}
				else
				{
					ASSERT(0);
				}
			}

		}
	}
Leave:	
	return hr;
	
}




HRESULT CChordStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT				hr;
	
	hr = CanPaste( pITimelineDataObject );
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pChordMgr != NULL );
	if( m_pChordMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pChordMgr->m_pTimeline != NULL );
	if( m_pChordMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfChordList == 0 )
	{
		m_cfChordList = RegisterClipboardFormat( CF_CHORDLIST );
		if( m_cfChordList == 0 )
		{
			return E_FAIL;
		}
	}
	
	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pChordMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		pIDataObject->Release();
		if( FAILED(hr) )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}

	// Paste
	POINTL pt;
	pt.x = m_lXPos;
	pt.y = 0;
	hr = PasteAt(pITimelineDataObject, pt, false);
	if(SUCCEEDED(hr))
	{
		m_pChordMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
	}
	pITimelineDataObject->Release();

	return hr;
}

HRESULT CChordStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	long	lClocks;
	long	lBeat;
	long	lMeasure;
	CChordItem* pChord = NULL;

	// Unselect all items in this strip 
	m_pChordMgr->UnselectChords();
	
	// Unselect items in other strips
	UnselectGutterRange();

	if( m_pChordMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}
	hr = m_pChordMgr->m_pTimeline->PositionToClocks( m_lXPos, &lClocks );
	ASSERT( SUCCEEDED( hr ));
	hr = m_pChordMgr->m_pTimeline->ClocksToMeasureBeat( m_pChordMgr->m_dwGroupBits, 0, lClocks, &lMeasure, &lBeat );
	if(SUCCEEDED(hr))
	{
		CChordItem* pChord = new CChordItem;
		if(pChord == NULL)
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			DWORD dwPos = 1;
			DWORD dwChordPattern = 1;
			for( int i = 1 ;  i < 24 ;  i++ )
			{
				if( m_pChordMgr->m_dwScale & (1 << i) )
				{
					dwPos++;

					if( dwPos == 3
					||  dwPos == 5 )
					{
						dwChordPattern |= (1 << i);
					}

					if( dwPos >= 5 )
					{
						break;
					}
				}
			}

			for( i = 0;  i < DMPolyChord::MAX_POLY;  i++ )
			{
				pChord->SubChord(i)->ChordRoot() = m_pChordMgr->m_nKeyRoot + 12;
				while( pChord->SubChord(i)->ChordRoot() > 24 )
				{
					pChord->SubChord(i)->ChordRoot() -= 12;
				}
				pChord->SubChord(i)->ChordPattern() = dwChordPattern;
				pChord->SubChord(i)->ScaleRoot() = m_pChordMgr->m_nKeyRoot;
				pChord->SubChord(i)->ScalePattern() = m_pChordMgr->m_dwScale;
				pChord->SubChord(i)->UseFlat() = m_pChordMgr->m_fDisplayingFlats;
			}
			strcpy(pChord->Name(), "M");
			pChord->m_dwIndex = 0;	// probably not needed anymore
			pChord->SetSelected(TRUE);
			m_pChordMgr->m_SelectedChord = *pChord;
			pChord->Measure() = static_cast<short>(lMeasure);
			pChord->Beat() = static_cast<BYTE>(lBeat);
			m_pChordMgr->m_ChordList.InsertByAscendingTime(pChord);
			m_pChordMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);

			SelectRegionsFromSelectedChords();

			ShowPropertySheet(m_pChordMgr->m_pTimeline);
			m_pChordMgr->OnShowProperties();
			if( m_pChordMgr->m_pPropPageMgr )
			{
				m_pChordMgr->m_pPropPageMgr->RefreshData();
			}
			m_nLastEdit = IDS_UNDO_PASTE;
			m_pChordMgr->UpdateDirectMusic( TRUE );
		}
	}

	return hr;
}

HRESULT CChordStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
//	HRESULT			hr = E_NOTIMPL;

	/* This may be part of a cut operation.  You can cut empty space, but you can't delete it.
	HRESULT hr = CanDelete();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}
	*/

	ASSERT( m_pChordMgr != NULL );
	if( m_pChordMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pChordMgr->m_pTimeline != NULL );
	if( m_pChordMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_pChordMgr->DeleteSelectedChords();
	m_pSelectedRegions->Clear();
	m_pChordMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	m_pChordMgr->m_SelectedChord.RootIndex() = DMPolyChord::INVALID;


	if( m_pChordMgr->m_pPropPageMgr )
	{
		m_pChordMgr->m_pPropPageMgr->RefreshData();
	}

	m_nLastEdit = IDS_UNDO_DELETE;
	m_pChordMgr->UpdateDirectMusic( TRUE );
	return S_OK;
}

HRESULT CChordStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pSelectedRegions->SelectAll();
	SelectChordsInSelectedRegions();


	CChordItem* pChord = m_pChordMgr->FirstSelectedChord();
	if(pChord)
	{
		m_pChordMgr->m_SelectedChord = *pChord;
		m_pChordMgr->m_ChordList.PreparePropChord( &m_pChordMgr->m_SelectedChord );
	}
	if( pChord )
	{
		m_fShowChordProps = TRUE;
		m_pChordMgr->OnShowProperties();
	}

	m_pChordMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	
	return S_OK;
}

HRESULT CChordStrip::CanCut( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pChordMgr != NULL );
	if( m_pChordMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can cut even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pChordMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pChordMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pChordMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	if( CanCopy() == S_OK && CanDelete() == S_OK )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}

}

HRESULT CChordStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pChordMgr != NULL );
	if( m_pChordMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can copy even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pChordMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pChordMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pChordMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	return m_pChordMgr->IsSelected() ? S_OK : S_FALSE;
}

HRESULT CChordStrip::CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;

	ASSERT( m_pChordMgr != NULL );
	if( m_pChordMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfChordList == 0 )
	{
		m_cfChordList = RegisterClipboardFormat( CF_CHORDLIST );
		if( m_cfChordList == 0 )
		{
			return E_FAIL;
		}
	}

	// If pITimelineDataObject != NULL, check it.
	if( pITimelineDataObject != NULL )
	{
		hr = pITimelineDataObject->IsClipFormatAvailable( m_cfChordList );
	}
	// Otherwise, check the clipboard
	else
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		if( SUCCEEDED( OleGetClipboard(&pIDataObject) ) )
		{
			// Create a new TimelineDataObject
			IDMUSProdTimelineDataObject *pITimelineDataObject;
			if( SUCCEEDED( m_pChordMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
			{
				// Insert the IDataObject into the TimelineDataObject
				if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
				{
					hr = pITimelineDataObject->IsClipFormatAvailable(m_cfChordList);
				}
				pITimelineDataObject->Release();
			}
			pIDataObject->Release();
		}
	}

	if (hr == S_OK)
	{
		return S_OK;
	}

	return S_FALSE;
}

HRESULT CChordStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_lXPos < 0 )
	{
		return S_FALSE;
	}

	CPropChord* pChord = GetChordFromPoint( m_lXPos );
	VARIANT var;
	
	if( m_pChordMgr == NULL
	||  m_pChordMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_pChordMgr->m_pTimeline->GetTimelineProperty(TP_CLOCKLENGTH, &var);
	long len = V_I4(&var);
	long clocks;
	m_pChordMgr->m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &clocks);

	if( clocks >= len
	||  pChord != NULL )
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}

HRESULT CChordStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return m_pChordMgr->IsSelected() ? S_OK : S_FALSE;
}

HRESULT CChordStrip::CanSelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return m_pChordMgr->m_ChordList.IsEmpty() && !m_bGutterSelected ? S_FALSE : S_OK;
}

// IDropSource Methods
HRESULT CChordStrip::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton & MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton & MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}

HRESULT CChordStrip::GiveFeedback( DWORD dwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return DRAGDROP_S_USEDEFAULTCURSORS;
}

HRESULT	CChordStrip::CreateDataObject(IDataObject** ppIDataObject, long position)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Selected Chords into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( m_pChordMgr->m_pIDMUSProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		CChordItem* pChordAtDragPoint = GetChordFromPoint( position );

		// mark the chords as being dragged: this used later for deleting chords in drag move
		m_pChordMgr->MarkSelectedChords(UD_DRAGSELECT);
		long offset;
		if( SUCCEEDED ( m_pChordMgr->SaveSelectedChords( pIStream, pChordAtDragPoint, TRUE, &offset ) ) )
		{
			// uncomment to save regions in clipboard
//			if( SUCCEEDED (SaveSelectedRegions(pIStream, offset, TRUE) ) )
//			{
				// Place CF_CHORDLIST into CDllJazzDataObject
				if( SUCCEEDED ( pDataObject->AddClipFormat( m_cfChordList, pIStream ) ) )
				{
					hr = S_OK;
				}
//			}
		}

		pIStream->Release();
	}


	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;

}

/////////////////////////////////////////////////// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// IDropTarget CChordStrip::DragEnter

HRESULT CChordStrip::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	//TRACE("CChordStrip Drag Enter!");
	ASSERT( pIDataObject != NULL );
	ASSERT( m_pITargetDataObject == NULL );

	// Store IDataObject associated with current drag-drop operation
	m_pITargetDataObject = pIDataObject;
	m_pITargetDataObject->AddRef();

/*
	// Make sure editor is on top
	if( m_pStyle->m_hWndEditor )
	{
		::BringWindowToTop( m_pStyle->m_hWndEditor );
	}
*/
	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CChordStrip::DragOver

HRESULT CChordStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	//TRACE("CChordStrip Drag OVER!");
	if(m_pITargetDataObject == NULL)
		ASSERT( m_pITargetDataObject != NULL );

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	if( CanPasteFromData( m_pITargetDataObject ) == S_OK )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			dwEffect = *pdwEffect;
		}
		else
		{
			if( grfKeyState & MK_CONTROL )
			{
				dwEffect = DROPEFFECT_COPY;
			}
			else
			{
				if( *pdwEffect & DROPEFFECT_COPY
				&&  *pdwEffect & DROPEFFECT_MOVE )
				{
					dwEffect = DROPEFFECT_MOVE;
				}
				else
				{
					dwEffect = *pdwEffect;
				}
			}
		}
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CChordStrip::DragLeave

HRESULT CChordStrip::DragLeave( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	//TRACE("CChordStrip Drag Leave!");

	// Release IDataObject
	if( m_pITargetDataObject )
	{
		m_pITargetDataObject->Release();
		m_pITargetDataObject = NULL;
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CChordStrip::Drop

HRESULT CChordStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pITargetDataObject != NULL );
	ASSERT( m_pITargetDataObject == pIDataObject );

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;
		
		// Display arrow cursor
		::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
	
		// Prepare context menu
		hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Get a window to attach menu to
			CWnd* pWnd = GetTimelineCWnd();
			if(pWnd)
			{
				// Display and track menu
				CPoint point( pt.x, pt.y );
				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, pWnd->GetSafeHwnd(), NULL );
				DestroyMenu( hMenu );

				// Need to process WM_COMMAND from TrackPopupMenu
				MSG msg;
				while( ::PeekMessage( &msg, pWnd->GetSafeHwnd(), NULL, NULL, PM_REMOVE) )
				{
					if( msg.message == WM_COMMAND )
					{
						OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
					}
					else
					{
						TranslateMessage( &msg );
						DispatchMessage( &msg );
					}
				}

				// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
				m_dwOverDragEffect = m_dwDragRMenuEffect;
				m_dwDragRMenuEffect = DROPEFFECT_NONE;
			}
		}
	}

	// Paste data
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		// BUGBUG: Error messages?
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pChordMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				hr = PasteAt( pITimelineDataObject, pt, true );
				if( SUCCEEDED ( hr ) )
				{
					*pdwEffect = m_dwOverDragEffect;
				}
			}
			pITimelineDataObject->Release();
		}
	}

	// Cleanup
	DragLeave();

	return hr;
}



CWnd* CChordStrip::GetTimelineCWnd()
{
	CDC cDC;
	VARIANT vt;
	vt.vt = VT_I4;

	CWnd* pWnd = 0;

	// Get the DC of our Strip
	if( m_pChordMgr->m_pTimeline )
	{
		if( SUCCEEDED(m_pChordMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GET_HDC, &vt )) )
		{
			if( cDC.Attach( (HDC)(vt.lVal) ) != 0 )
			{
				pWnd = cDC.GetWindow();
				cDC.Detach();
			}
			if( pWnd )
			{
				::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(vt.lVal) );
			}
			else
			{
				::ReleaseDC( NULL, (HDC)(vt.lVal) );
			}
		}
	}
	return pWnd;
}


HRESULT CChordStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfChordList ) ))
	{
		hr = S_OK;
	}

	pDataObject->Release();
	return hr;
}


inline BOOL IsDeleteKey(int nVirtKey, unsigned long lKeyData)
{
	DWORD dwDelete = 0x01000000;
	if((nVirtKey == 53  || nVirtKey == 46) && (lKeyData & dwDelete))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CChordStrip::ProcessKey(int nVirtKey, unsigned long lKeyData)
{
	BOOL b = FALSE;
	if(IsDeleteKey(nVirtKey, lKeyData))
	{
		m_pChordMgr->DeleteSelectedChords();
		b = TRUE;
	}
	return b;
}


HRESULT CChordStrip::ShowPropertySheet(IDMUSProdTimeline* pTimeline)
{
	//GiveTimelineFocus();
	HRESULT hr = S_OK;
	// Get a pointer to the property sheet and show it

	VARIANT			var;
	LPUNKNOWN		punk;
	IDMUSProdPropSheet*	pIPropSheet;
	pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	if( var.vt == VT_UNKNOWN )
	{
		punk = V_UNKNOWN( &var );
		if( punk )
		{
			hr = punk->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
			ASSERT( SUCCEEDED( hr ));
			if( FAILED( hr ))
			{
				hr = E_UNEXPECTED;
			}
			else
			{
				pIPropSheet->Show( TRUE );
				pIPropSheet->Release();
			}
			punk->Release();
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CChordStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CChordStrip::FBDraw

HRESULT CChordStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CChordStrip::FBOnWMMessage

HRESULT CChordStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Process the window message
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
	case WM_RBUTTONDOWN:
		m_lXPos = -1;
		m_fShowChordProps = FALSE;
		OnShowProperties();
		break;
	case WM_RBUTTONUP:
		// Display a right-click context menu.
		POINT pt;
		// Get the cursor position (To put the menu there)
		if( !GetCursorPos( &pt ) )
		{
			hr = E_UNEXPECTED;
			break;
		}

		if( m_pChordMgr->m_pTimeline )
		{
			hr = DoRightClickMenu( m_pChordMgr->m_pTimeline, pt );
		}
		break;

	default:
		break;
	}
	return hr;
}


// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CChordStrip::GetData

HRESULT CChordStrip::GetData( void **ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (ppData == NULL) || (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	DWORD *pdwIndex = static_cast<DWORD *>(*ppData);

	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		// Copy our groupbits to the location pointed to by ppData
		PPGTrackParams *pPPGTrackParams = static_cast<PPGTrackParams *>(*ppData);
		pPPGTrackParams->dwGroupBits = m_pChordMgr->m_dwGroupBits;
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		// Copy our track setting to the location pointed to by ppData
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);
		pPPGTrackFlagsParams->dwTrackExtrasFlags = m_pChordMgr->m_dwTrackExtrasFlags;
		pPPGTrackFlagsParams->dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
		pPPGTrackFlagsParams->dwProducerOnlyFlags = m_pChordMgr->m_dwProducerOnlyFlags;
		pPPGTrackFlagsParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;
		break;
	}
	case 2:
		{
			ioChordStripPPG *poChordStripPPG = (ioChordStripPPG *)*ppData;
			poChordStripPPG->fUseFlats = m_pChordMgr->m_fDisplayingFlats;
			poChordStripPPG->nKeyRoot = m_pChordMgr->m_nKeyRoot;
			poChordStripPPG->nNumAccidentals = m_pChordMgr->m_nNumAccidentals;
			break;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CChordStrip::SetData

HRESULT CChordStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pData == NULL )
	{
		return E_POINTER;
	}

	DWORD *pdwIndex = static_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
		// Only allow changing the group bits and track settings if m_fShowChordProps is set
		if( m_pChordMgr->m_fUseChordStripPPG )
		{
			PPGTrackParams *pPPGTrackParams = reinterpret_cast<PPGTrackParams *>(pData);

			// Update our group bits setting, if necessary
			if( pPPGTrackParams->dwGroupBits != m_pChordMgr->m_dwGroupBits )
			{
				m_nLastEdit = IDS_UNDO_TRACK_GROUP;
				DWORD dwOldBits = m_pChordMgr->m_dwGroupBits;
				m_pChordMgr->m_dwGroupBits = pPPGTrackParams->dwGroupBits;
				m_pChordMgr->m_pTimeline->OnDataChanged( (IDMUSProdStripMgr*)m_pChordMgr );
				m_pChordMgr->m_dwOldGroupBits = m_pChordMgr->m_dwGroupBits;
				m_pChordMgr->m_pTimeline->NotifyStripMgrs( GUID_ChordKey, dwOldBits | m_pChordMgr->m_dwGroupBits, NULL );
				m_pChordMgr->m_pTimeline->NotifyStripMgrs( GUID_ChordSharpsFlats, dwOldBits | m_pChordMgr->m_dwGroupBits, NULL );

				// Check if there are any MIDIStripMgrs in m_dwGroupBits
				IDMUSProdStripMgr *pStripMgr;
				if( SUCCEEDED( m_pChordMgr->m_pTimeline->GetStripMgr( CLSID_DirectMusicPatternTrack, m_pChordMgr->m_dwGroupBits, 0, &pStripMgr ) ) )
				{
					pStripMgr->Release();
				}
				else
				{
					// No MIDIStripMgrs, reset the CHORDSTRIP_MODE to nothing
					m_pChordMgr->m_bPatternEditorMode = 0xFF;
				}
			}
			return S_OK;
		}
		break;

	case TRACKFLAGSPPG_INDEX:
		// Only allow changing the group bits and track settings if m_fShowChordProps is set
		if( m_pChordMgr->m_fUseChordStripPPG )
		{
			PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);

			// Update our track extras flags, if necessary
			if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pChordMgr->m_dwTrackExtrasFlags )
			{
				m_pChordMgr->m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;

				// Notify our editor that we've changed
				m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
				m_pChordMgr->m_pTimeline->OnDataChanged( (IDMUSProdStripMgr*)m_pChordMgr );
			}
			// Update our Producer-specific flags, if necessary
			else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_pChordMgr->m_dwProducerOnlyFlags )
			{
				m_pChordMgr->m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;

				// Notify our editor that we've changed
				m_nLastEdit = IDS_UNDO_PRODUCERONLY;
				m_pChordMgr->m_pTimeline->OnDataChanged( (IDMUSProdStripMgr*)m_pChordMgr );
			}
			return S_OK;
		}
		break;

	case 2:
		{
			ioChordStripPPG *piChordStripPPG = (ioChordStripPPG *)pData;

			if( m_pChordMgr->m_fDisplayingFlats != piChordStripPPG->fUseFlats ||
					 m_pChordMgr->m_nKeyRoot != piChordStripPPG->nKeyRoot ||
					 m_pChordMgr->m_nNumAccidentals != piChordStripPPG->nNumAccidentals )
			{
				if( m_pChordMgr->m_fDisplayingFlats != piChordStripPPG->fUseFlats )
				{
					m_pChordMgr->m_fDisplayingFlats = piChordStripPPG->fUseFlats;
					m_pChordMgr->m_ChordList.UseFlats(piChordStripPPG->fUseFlats == TRUE);
					// Must be done before updating DirectMusic and the other StripMgrs
					m_pChordMgr->UpdateMasterScaleAndKey();
					m_pChordMgr->UpdateDirectMusic( TRUE );
					m_pChordMgr->m_pTimeline->NotifyStripMgrs( GUID_ChordSharpsFlats, m_pChordMgr->m_dwGroupBits, NULL );
				}

				if( m_pChordMgr->m_nKeyRoot != piChordStripPPG->nKeyRoot ||
					m_pChordMgr->m_nNumAccidentals != piChordStripPPG->nNumAccidentals )
				{
					m_pChordMgr->m_nKeyRoot = piChordStripPPG->nKeyRoot;
					m_pChordMgr->m_nNumAccidentals = piChordStripPPG->nNumAccidentals;
					// Must be done before updating the other StripMgrs
					m_pChordMgr->UpdateMasterScaleAndKey();
					m_pChordMgr->UpdateDirectMusic( TRUE );
					m_pChordMgr->m_pTimeline->NotifyStripMgrs( GUID_ChordKey, m_pChordMgr->m_dwGroupBits, NULL );
				}

				m_pChordMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
				m_nLastEdit = IDS_UNDO_KEYCHANGE;
				m_pChordMgr->m_pTimeline->OnDataChanged( (IDMUSProdStripMgr*)m_pChordMgr );
			}
			return S_OK;
			break;
		}
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CChordStrip::OnShowProperties

HRESULT CChordStrip::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to the Timeline
	if( m_pChordMgr->m_pTimeline == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the Framework from the timeline
	IDMUSProdFramework* pIFramework = NULL;
	VARIANT var;
	m_pChordMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	pIFramework = (IDMUSProdFramework*) V_UNKNOWN(&var);
	if (pIFramework == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}


	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	pIFramework->Release();
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}

	// If our property page is already displayed, exit
	if(m_fPropPageActive)
	{
		ASSERT( m_pPropPageMgr != NULL );
		pIPropSheet->Release();
		return S_OK;
	}

	// Get a reference to our property page manager
	HRESULT hr = S_OK;
	if( m_pPropPageMgr == NULL )
	{
		CChordStripPropPageMgr* pPPM = new CChordStripPropPageMgr;
		if( NULL == pPPM )
		{
			hr = E_OUTOFMEMORY;
			goto EXIT;
		}
		pPPM->m_fShowGroupBits = m_pChordMgr->m_fUseChordStripPPG;
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		m_pPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
		if( FAILED(hr) )
		{
			goto EXIT;
		}
	}

	// Set the property page to refer to the groupbits and/or key property page.
	short nActiveTab;
	nActiveTab = CChordStripPropPageMgr::sm_nActiveTab;
	m_pChordMgr->m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	m_fPropPageActive = TRUE;
	pIPropSheet->SetActivePage( nActiveTab ); 

EXIT:
	// release our reference to the property sheet
	pIPropSheet->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CChordStrip::OnRemoveFromPageManager

HRESULT CChordStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject(NULL);
	}
	m_fPropPageActive = FALSE;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CChordStrip::UnselectGutterRange

void CChordStrip::UnselectGutterRange( void )
{
	ASSERT( m_pChordMgr->m_pTimeline != NULL );

	// Make sure everything on the timeline is deselected.
	m_bSelecting = TRUE;
	m_pChordMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pChordMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_bSelecting = FALSE;
}

HRESULT CChordStrip::StartDragDrop(IDMUSProdTimeline* pTimeline, LONG lXPos)
{
	HRESULT hr = S_OK;
	VARIANT var;
	BOOL bDrop = FALSE;

	m_nStripIsDragDropSource = 1;	

	bDrop = TRUE;
	// drag drop will capture mouse, so release it from timeline
	V_BOOL(&var) = FALSE;
	pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
	IDropSource*	pIDropSource;
//				IDataObject*	pIDataObject;
	DWORD			dwEffect = DROPEFFECT_NONE;
	if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
	{
		// create data object and image
		hr = CreateDataObject(&m_pISourceDataObject, lXPos);
		if(SUCCEEDED(hr))
		{
			// start drag drop
			DWORD dwOKDragEffects = DROPEFFECT_COPY;
			if(CanCut() == S_OK)
			{
				dwOKDragEffects |= DROPEFFECT_MOVE;
			}
			m_startDragPosition = lXPos;
			hr = ::DoDragDrop(m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect);

			// drag drop completed, clean up
			m_dwStartDragButton = 0;
			switch(hr)
			{
			case DRAGDROP_S_DROP:
				if(dwEffect & DROPEFFECT_MOVE)
				{
					m_pChordMgr->DeleteMarkedChords(UD_DRAGSELECT);
				}
				if(dwEffect == DROPEFFECT_NONE)
				{
					bDrop = FALSE;
				}
				break;
			default:
				bDrop = FALSE;
				break;
			}
			hr = S_OK;
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;
		}
		else
		{
			m_nStripIsDragDropSource = 0;	
		}

		pIDropSource->Release();
		m_pChordMgr->UnMarkChords(UD_DRAGSELECT);

	}
	else
	{
		m_nStripIsDragDropSource = 0;	
		hr = E_FAIL;
		goto END;
	}

	if(!bDrop)
	{
		hr = S_FALSE;
	}
	else if( dwEffect != DROPEFFECT_NONE )
	{
		if( m_nStripIsDragDropSource == 2 )
		{
			// Drag/drop target and source are the same PersRef strip
			if( dwEffect == DROPEFFECT_MOVE )
			{
				m_nLastEdit = IDS_UNDO_MOVE;
			}
			else
			{
				m_nLastEdit = IDS_UNDO_PASTE;
			}
			m_pChordMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
			m_fShowChordProps = TRUE;
			if( m_pChordMgr->m_pPropPageMgr )
			{
				m_pChordMgr->m_pPropPageMgr->RefreshData();
			}
			m_pChordMgr->OnShowProperties(); 
			m_pChordMgr->UpdateDirectMusic( TRUE );
		}
		else
		{
			if( dwEffect == DROPEFFECT_MOVE )
			{
				m_nLastEdit = IDS_UNDO_DELETE;
				m_pChordMgr->UpdateDirectMusic( TRUE );
			}
		}
	}

	// Done with drag/drop
	m_nStripIsDragDropSource = 0;


END:
	return hr;
}


HRESULT CChordStrip :: DoRightClickMenu(IDMUSProdTimeline* pTimeline, POINT pt)
{
	HMENU hMenu;
	HMENU hMenuPopup;

	HRESULT hr = S_OK;

	// Check if we're in the segment designer
	if( m_pChordMgr->m_pIDMTrack )
	{
		// Does the Segment contain a Pattern track?
		if( m_pChordMgr->m_bPatternEditorMode == 0xFF )
		{
			// No Pattern Track - Use Segment editor right-click menu
			hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_SEGMENT_EDITOR_RMENU) );
		}
		else
		{
			// Has Pattern Track - Use Segment editor (with Pattern Track) right-click menu
			hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_SEGMENT_EDITOR_WITHPTRN_RMENU) );
		}
		if( hMenu )
		{
			// Initialize menu items specific to Segment editor
			hMenuPopup = ::GetSubMenu(hMenu, 0);
			if( hMenuPopup )
			{
				switch( m_pChordMgr->GetSelectedHideState() )
				{
					case HIDE_NONE_SELECTED:
						::CheckMenuItem( hMenuPopup, ID_HIDE_FROM_RHYTHM, (MF_UNCHECKED | MF_BYCOMMAND) );
						::EnableMenuItem( hMenuPopup, ID_HIDE_FROM_RHYTHM, (MF_GRAYED | MF_BYCOMMAND) );
						break;

					case HIDE_ALL_ON:
					{
						::CheckMenuItem( hMenuPopup, ID_HIDE_FROM_RHYTHM, (MF_CHECKED | MF_BYCOMMAND) );
						::EnableMenuItem( hMenuPopup, ID_HIDE_FROM_RHYTHM, (MF_ENABLED | MF_BYCOMMAND) );
						break;
					}

					case HIDE_ALL_OFF:
					case HIDE_MIXED:
					{
						::CheckMenuItem( hMenuPopup, ID_HIDE_FROM_RHYTHM, (MF_UNCHECKED | MF_BYCOMMAND) );
						::EnableMenuItem( hMenuPopup, ID_HIDE_FROM_RHYTHM, (MF_ENABLED | MF_BYCOMMAND) );
						break;
					}
				}
				// Does the Segment contain a Pattern track?
				if( m_pChordMgr->m_bPatternEditorMode != 0xFF )
				{
					// Has Pattern Track
					if( m_pChordMgr->m_bPatternEditorMode == 1 )
					{
						::CheckMenuItem( hMenuPopup, IDM_CONSTANT_MIDI, (MF_CHECKED | MF_BYCOMMAND) );
						::CheckMenuItem( hMenuPopup, IDM_CONSTANT_FUNCTION, (MF_UNCHECKED | MF_BYCOMMAND) );
					}				
					else
					{
						::CheckMenuItem( hMenuPopup, IDM_CONSTANT_MIDI, (MF_UNCHECKED | MF_BYCOMMAND) );
						::CheckMenuItem( hMenuPopup, IDM_CONSTANT_FUNCTION, (MF_CHECKED | MF_BYCOMMAND) );
					}
				}
			}
		}
	}
	else
	{
		// Use Pattern editor right-click menu
		hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_PATTERN_EDITOR_RMENU) );
		if( hMenu )
		{
			// Initialize menu items specific to Pattern editor
			hMenuPopup = ::GetSubMenu(hMenu, 0);
			if( hMenuPopup )
			{
				if( m_pChordMgr->m_bPatternEditorMode == 1 )
				{
					::CheckMenuItem( hMenuPopup, IDM_CONSTANT_MIDI, (MF_CHECKED | MF_BYCOMMAND) );
					::CheckMenuItem( hMenuPopup, IDM_CONSTANT_FUNCTION, (MF_UNCHECKED | MF_BYCOMMAND) );
				}				
				else
				{
					::CheckMenuItem( hMenuPopup, IDM_CONSTANT_MIDI, (MF_UNCHECKED | MF_BYCOMMAND) );
					::CheckMenuItem( hMenuPopup, IDM_CONSTANT_FUNCTION, (MF_CHECKED | MF_BYCOMMAND) );
				}
			}
		}
	}

	if( hMenu
	&&  hMenuPopup )
	{
		::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED :
				MF_GRAYED );
		::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED :
				MF_GRAYED );
		::EnableMenuItem( hMenuPopup, 2, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION :
				MF_GRAYED | MF_BYPOSITION );
		::EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ? MF_ENABLED :
				MF_GRAYED );
		::EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED :
				MF_GRAYED );
		::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( CanSelectAll() == S_OK ) ? MF_ENABLED :
				MF_GRAYED );
		::EnableMenuItem( hMenuPopup, ID_VIEW_PROPERTIES, MF_ENABLED );

		pTimeline->TrackPopupMenu( hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE );
	}

	if( hMenu )
	{
		::DestroyMenu( hMenu );
	}

	return hr;
}


HRESULT CChordStrip :: PostRightClickMenu(IDMUSProdTimeline* pTimeline, POINT pt)
{
	HRESULT hr = S_OK;
	// Use Chordstrip editor right-click menu
	HMENU hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_PATTERN_EDITOR_RMENU) );
	HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);
	if( m_pChordMgr->m_bPatternEditorMode == 1 )
	{
		::CheckMenuItem( hMenuPopup, IDM_CONSTANT_MIDI, (MF_CHECKED | MF_BYCOMMAND) );
		::CheckMenuItem( hMenuPopup, IDM_CONSTANT_FUNCTION, (MF_UNCHECKED | MF_BYCOMMAND) );
	}				
	else
	{
		::CheckMenuItem( hMenuPopup, IDM_CONSTANT_MIDI, (MF_UNCHECKED | MF_BYCOMMAND) );
		::CheckMenuItem( hMenuPopup, IDM_CONSTANT_FUNCTION, (MF_CHECKED | MF_BYCOMMAND) );
	}

	::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, 2, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION :
			MF_GRAYED | MF_BYPOSITION );
	::EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( CanSelectAll() == S_OK ) ? MF_ENABLED :
			MF_GRAYED );
	::EnableMenuItem( hMenuPopup, ID_VIEW_PROPERTIES, MF_ENABLED );

	pTimeline->TrackPopupMenu(hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE);
	::DestroyMenu( hMenu );

	return hr;
}

void CChordStrip::SelectChordsInSelectedRegions()
{
	for(CChordItem* pChord = m_pChordMgr->m_ChordList.GetHead(); pChord; pChord = pChord->GetNext())
	{
		if(m_pSelectedRegions->Contains(pChord->Measure(), pChord->Beat()))		
		{
			pChord->SetSelected(TRUE);
		}
		else
		{
			pChord->SetSelected(FALSE);
		}
	}
}

void CChordStrip::SelectRegionsFromSelectedChords()
{
	m_pSelectedRegions->Clear();
	for(CChordItem* pChord = m_pChordMgr->m_ChordList.GetHead(); pChord; pChord = pChord->GetNext())
	{
		if(pChord->IsSelected())
		{
			CListSelectedRegion_AddRegion(*m_pSelectedRegions, *pChord);
		}
	}
}


HRESULT CChordStrip::NormalizeSelectedRegions(CListSelectedRegion& list, long clockoffset, long* pStartClocks, long* pEndClocks)
{
	HRESULT hr = S_OK;
	CMusicTimeConverter cmtMin(0x7fffffff);
	CMusicTimeConverter cmtMax(0);

	POSITION pos = list.GetHeadPosition();
	while(pos)
	{
		CSelectedRegion* psr = list.GetNext(pos);
		if(psr->Beg() < cmtMin)
		{
			cmtMin = psr->Beg();
		}
		if(cmtMax < psr->End())
		{
			cmtMax = psr->End();
		}
		// offset selected Regions
		psr->Beg().Time() += clockoffset;
		psr->End().Time() += clockoffset;
	}
	if(pStartClocks)
		*pStartClocks = cmtMin;
	if(pEndClocks)
		*pEndClocks = cmtMax;
	return hr;
}

HRESULT CChordStrip::SaveSelectedRegions(IStream* pIStream, long offset, bool bNormalize)
{
	ASSERT(pIStream);

	CListSelectedRegion list(m_pChordMgr->m_pTimeline, m_pChordMgr->m_dwGroupBits);
	
	list.Copy(*m_pSelectedRegions);

	if(!list.IsEmpty() && bNormalize)
	{
		NormalizeSelectedRegions(list, TRUE);
	}
	
	HRESULT hr = list.Save(pIStream);
	list.Clear();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\ChordStripPPG.h ===
#if !defined(AFX_CHORDSTRIPPPG_H__8D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
#define AFX_CHORDSTRIPPPG_H__8D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <staticproppagemanager.h>
#include <afxdlgs.h>
#include "resource.h"

struct ioChordStripPPG
{
	DWORD	dwPageIndex;
	BOOL	fUseFlats;
	int		nKeyRoot;
	int		nNumAccidentals;
};

// ChordStripPPG.h : header file
//

class CKeyRootEdit :
	public CEdit
{
	DECLARE_DYNCREATE(CKeyRootEdit)
public:
	CKeyRootEdit();

	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

protected:
};

/////////////////////////////////////////////////////////////////////////////
// CChordStripPropPageMgr

class CChordStripPropPageMgr : public CStaticPropPageManager
{
friend class CChordStripPPG;
public:
	CChordStripPropPageMgr();
	~CChordStripPropPageMgr();
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
													 LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

	BOOL					m_fShowGroupBits;
	static short			sm_nActiveTab;

protected:
	class CChordStripPPG*	m_pChordStripPPG;
	class CGroupBitsPPG*	m_pGroupBitsPPG;
	class CTrackFlagsPPG*	m_pTrackFlagsPPG;
};

/////////////////////////////////////////////////////////////////////////////
// CChordStripPPG dialog

class CChordStripPPG : public CPropertyPage
{
	DECLARE_DYNCREATE(CChordStripPPG)

// Construction
public:
	CChordStripPPG();
	~CChordStripPPG();

// Dialog Data
	//{{AFX_DATA(CChordStripPPG)
	enum { IDD = IDD_PROPPAGE_CHORDTRACK_KEY };
	CSpinButtonCtrl	m_spinKeyRoot;
	CSpinButtonCtrl	m_spinAccidentals;
	CEdit	m_editAccidentals;
	CKeyRootEdit	m_editKeyRoot;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChordStripPPG)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChordStripPPG)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioFlat();
	afx_msg void OnRadioSharp();
	afx_msg void OnChangeEditAccidentals();
	afx_msg void OnDeltaposSpinKeyRoot(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditKeyRoot();
	afx_msg void OnKillfocusEditAccidentals();
	afx_msg void OnChangeEditKeyRoot();
	afx_msg void OnDeltaposSpinAccidentals(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableItem( int nID, BOOL fEnable );
	void ShowItem( int nID, BOOL fEnable );
	void EnableControls( BOOL fEnable );
	void UpdatePPO();

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	CChordStripPropPageMgr*		m_pPropPageMgr;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	BOOL						m_fNeedToDetach;

	// Key Signature data
	BOOL						m_fUseFlats;
	int							m_nKeyRoot;
	int							m_nNumAccidentals;
	BOOL						m_fChangedKeyRoot;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHORDSTRIPPPG_H__8D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\ChordStripPPG.cpp ===
// ChordStripPPG.cpp : implementation file
//

#include "stdafx.h"
#include "ChordStripPPG.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static const cbKeySize = 2;
//												  0 1 2 3 4 5 6 7 8 9 1011
extern const TCHAR SharpKey[12*cbKeySize+1] = _T("C C#D D#E F F#G G#A A#B ");
extern const TCHAR FlatKey[12*cbKeySize +1] = _T("C DbD EbE F GbG AbA BbB ");

// Mapping from 'a-g' to Key Root number.(0-11)
static const int CharToKey[7] = { 9, 11, 0, 2, 4, 5, 7 };

short CChordStripPropPageMgr::sm_nActiveTab = 0;


IMPLEMENT_DYNCREATE( CKeyRootEdit, CEdit )

CKeyRootEdit::CKeyRootEdit() : CEdit()
{
}

LRESULT CKeyRootEdit::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	switch( message )
	{
	case WM_CHAR:
		//TRACE("KeyRootEdit: %d '%c' %x %x\n", wParam, (char)wParam, wParam, lParam );
		switch( wParam )
		{
		case 8:  // Backspace
		case '#':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
			// These are handled by the Edit control directly
			/*
		case 71: // Home
		case 75: // Left
		case 77: // Right
		case 79: // End
		case 82: // Ins
		case 83: // Del
			*/
			break;
		default:
			return TRUE;
		break;
		}
	}
	return CEdit::WindowProc( message, wParam, lParam );
}

/////////////////////////////////////////////////////////////////////////////
// CChordStripPropPageMgr property page

CChordStripPropPageMgr::CChordStripPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pChordStripPPG = NULL;
	m_pGroupBitsPPG = NULL;
	m_pTrackFlagsPPG = NULL;
	m_fShowGroupBits = TRUE;
	CStaticPropPageManager::CStaticPropPageManager();
}

CChordStripPropPageMgr::~CChordStripPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pChordStripPPG )
	{
		delete m_pChordStripPPG;
		m_pChordStripPPG = NULL;
	}
	if( m_pGroupBitsPPG )
	{
		delete m_pGroupBitsPPG;
		m_pGroupBitsPPG = NULL;
	}
	if( m_pTrackFlagsPPG )
	{
		delete m_pTrackFlagsPPG;
		m_pTrackFlagsPPG = NULL;
	}
	CStaticPropPageManager::~CStaticPropPageManager();
}

HRESULT CChordStripPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
}

HRESULT CChordStripPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString cstrPart;
	cstrPart.LoadString( IDS_PROPPAGE_GROUP_BITS );
	*pbstrTitle = cstrPart.AllocSysString();

	return S_OK;
}

HRESULT CChordStripPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;
	// Add Group Bits tab, if necessary
	if( m_fShowGroupBits )
	{
		if( NULL == m_pGroupBitsPPG )
		{
			m_pGroupBitsPPG = new CGroupBitsPPG();
		}
		if( m_pGroupBitsPPG )
		{
			hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pGroupBitsPPG->m_psp );
			if( hPage )
			{
				hPropSheetPage[nNbrPages] = (LONG *)hPage;
				nNbrPages++;
			}

			// Weak reference
			m_pGroupBitsPPG->m_pIPropSheet = m_pIPropSheet;

			// Tell the property page to update the active tab setting
			CGroupBitsPPG::sm_pnActiveTab = &CChordStripPropPageMgr::sm_nActiveTab;
		}

		// Add track flags tab
		if( NULL == m_pTrackFlagsPPG )
		{
			m_pTrackFlagsPPG = new CTrackFlagsPPG();
		}
		if( m_pTrackFlagsPPG )
		{
			hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTrackFlagsPPG->m_psp );
			if( hPage )
			{
				hPropSheetPage[nNbrPages] = (LONG *)hPage;
				nNbrPages++;
			}			

			// Weak reference
			m_pTrackFlagsPPG->m_pIPropSheet = m_pIPropSheet;

			// Tell the property page to update the active tab setting
			CTrackFlagsPPG::sm_pnActiveTab = &CChordStripPropPageMgr::sm_nActiveTab;
		}
	}

	// Add Key tab
	if( NULL == m_pChordStripPPG )
	{
		m_pChordStripPPG = new CChordStripPPG();
	}
	if( m_pChordStripPPG )
	{
		m_pChordStripPPG->m_psp.pszTitle = (TCHAR *)IDS_KEY_TITLE;
		m_pChordStripPPG->m_psp.dwFlags |= PSP_USETITLE;

		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pChordStripPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		
		// Weak reference
		m_pChordStripPPG->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
}

HRESULT CChordStripPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pChordStripPPG )
	{
		m_pChordStripPPG->RefreshData();
	}
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->RefreshData();
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->RefreshData();
	}
	return S_OK;
}

HRESULT CChordStripPropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pChordStripPPG )
	{
		m_pChordStripPPG->SetObject( pINewPropPageObject );
	}
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->SetObject( pINewPropPageObject );
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->SetObject( pINewPropPageObject );
	}
	return CBasePropPageManager::SetObject( pINewPropPageObject );
}

/////////////////////////////////////////////////////////////////////////////
// CChordStripPPG property page

IMPLEMENT_DYNCREATE(CChordStripPPG, CPropertyPage)

CChordStripPPG::CChordStripPPG() : CPropertyPage(CChordStripPPG::IDD)
{
	//{{AFX_DATA_INIT(CChordStripPPG)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pPPO = NULL;
	m_pPropPageMgr = NULL;
	m_fNeedToDetach = FALSE;
	m_fUseFlats = FALSE;
	m_nKeyRoot = 0;
	m_nNumAccidentals = 0;
	m_fChangedKeyRoot = FALSE;
}

CChordStripPPG::~CChordStripPPG()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
}

void CChordStripPPG::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChordStripPPG)
	DDX_Control(pDX, IDC_SPIN_KEY_ROOT, m_spinKeyRoot);
	DDX_Control(pDX, IDC_SPIN_ACCIDENTALS, m_spinAccidentals);
	DDX_Control(pDX, IDC_EDIT_ACCIDENTALS, m_editAccidentals);
	DDX_Control(pDX, IDC_EDIT_KEY_ROOT, m_editKeyRoot);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChordStripPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CChordStripPPG)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_RADIO_FLAT, OnRadioFlat)
	ON_BN_CLICKED(IDC_RADIO_SHARP, OnRadioSharp)
	ON_EN_CHANGE(IDC_EDIT_ACCIDENTALS, OnChangeEditAccidentals)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_KEY_ROOT, OnDeltaposSpinKeyRoot)
	ON_EN_KILLFOCUS(IDC_EDIT_KEY_ROOT, OnKillfocusEditKeyRoot)
	ON_EN_KILLFOCUS(IDC_EDIT_ACCIDENTALS, OnKillfocusEditAccidentals)
	ON_EN_CHANGE(IDC_EDIT_KEY_ROOT, OnChangeEditKeyRoot)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ACCIDENTALS, OnDeltaposSpinAccidentals)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CChordStripPPG::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CChordStripPPG::EnableItem( int nID, BOOL fEnable )
{
	CWnd *pWnd = GetDlgItem( nID );
	if( pWnd )
	{
		pWnd->EnableWindow(fEnable);
	}
}

void CChordStripPPG::ShowItem( int nID, BOOL fEnable )
{
	CWnd *pWnd = GetDlgItem( nID );
	if( pWnd )
	{
		pWnd->ShowWindow(fEnable);
	}
}

void CChordStripPPG::EnableControls( BOOL fEnable ) 
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if( ::IsWindow(m_editAccidentals.m_hWnd))
	{
		m_editAccidentals.EnableWindow( fEnable );
		m_spinAccidentals.EnableWindow( fEnable );
		m_editKeyRoot.EnableWindow( fEnable );
		m_spinKeyRoot.EnableWindow( fEnable );
		EnableItem( IDC_RADIO_SHARP, fEnable );
		EnableItem( IDC_RADIO_FLAT, fEnable );
		EnableItem( IDC_STATIC_KEY_ROOT, fEnable );
		EnableItem( IDC_STATIC_KEY_SIG, fEnable );
		EnableItem( IDC_STATIC_ACCIDENTALS, fEnable );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CChordStripPPG message handlers

int CChordStripPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CChordStripPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

BOOL CChordStripPPG::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();

	m_editAccidentals.SetLimitText( 1 );
	m_spinAccidentals.SetRange( 0, 7 );

	m_editKeyRoot.SetLimitText( 2 );
	m_spinKeyRoot.SetRange( 0, 11 );
	
	return FALSE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

void CChordStripPPG::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioChordStripPPG iChordStripPPG, *pioChordStripPPG;
	iChordStripPPG.dwPageIndex = 2;
	pioChordStripPPG = &iChordStripPPG;
	if( FAILED( m_pPPO->GetData( (void**)&pioChordStripPPG ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	m_fUseFlats = iChordStripPPG.fUseFlats;
	m_nKeyRoot = iChordStripPPG.nKeyRoot;
	CString strText;
	if( m_fUseFlats )
	{
		CheckRadioButton( IDC_RADIO_SHARP, IDC_RADIO_FLAT, IDC_RADIO_FLAT );
		strText.LoadString( IDS_FLAT_PROPPAGE_TEXT );
		m_editKeyRoot.SetWindowText( CString(FlatKey).Mid(m_nKeyRoot * cbKeySize, cbKeySize) );
	}
	else
	{
		CheckRadioButton( IDC_RADIO_SHARP, IDC_RADIO_FLAT, IDC_RADIO_SHARP );
		strText.LoadString( IDS_SHARP_PROPPAGE_TEXT );
		m_editKeyRoot.SetWindowText( CString(SharpKey).Mid(m_nKeyRoot * cbKeySize, cbKeySize) );
	}
	SetDlgItemText( IDC_STATIC_ACCIDENTALS, strText );

	m_nNumAccidentals = iChordStripPPG.nNumAccidentals;
	m_spinAccidentals.SetPos( m_nNumAccidentals );

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
}

BOOL CChordStripPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( m_pPropPageMgr && m_pPropPageMgr->m_pIPropSheet )
	{
		m_pPropPageMgr->m_pIPropSheet->GetActivePage( &CChordStripPropPageMgr::sm_nActiveTab );
	}

	return CPropertyPage::OnSetActive();
}

void CChordStripPPG::UpdatePPO()
{
	if( m_pPPO )
	{
		ioChordStripPPG oChordStripPPG;
		oChordStripPPG.dwPageIndex = 2;
		oChordStripPPG.fUseFlats = m_fUseFlats;
		oChordStripPPG.nKeyRoot = m_nKeyRoot;
		oChordStripPPG.nNumAccidentals = m_nNumAccidentals;

		m_pPPO->SetData( (void *)&oChordStripPPG );
	}
}

BOOL CChordStripPPG::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				/*
				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_EDIT_PCHANNEL:
								m_spinPChannel.SetPos( m_dwPChannel + 1 );
								break;
						}
					}
					return TRUE;
				}
				*/

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}

void CChordStripPPG::OnRadioFlat() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_fUseFlats = TRUE;
	CString strText;
	strText.LoadString( IDS_FLAT_PROPPAGE_TEXT );
	SetDlgItemText( IDC_STATIC_ACCIDENTALS, strText );
	m_editKeyRoot.SetWindowText( CString(FlatKey).Mid(m_nKeyRoot * cbKeySize, cbKeySize) );
	UpdatePPO();
}

void CChordStripPPG::OnRadioSharp() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_fUseFlats = FALSE;
	CString strText;
	strText.LoadString( IDS_SHARP_PROPPAGE_TEXT );
	SetDlgItemText( IDC_STATIC_ACCIDENTALS, strText );
	m_editKeyRoot.SetWindowText( CString(SharpKey).Mid(m_nKeyRoot * cbKeySize, cbKeySize) );
	UpdatePPO();
}

void CChordStripPPG::OnDeltaposSpinKeyRoot(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	if( m_pPPO )
	{
		if( m_fChangedKeyRoot )
		{
			m_fChangedKeyRoot = FALSE;
			if (m_editKeyRoot.GetSafeHwnd() != NULL)
			{
				CString strNewKeyRoot;
				m_editKeyRoot.GetWindowText( strNewKeyRoot );
				if ( !strNewKeyRoot.IsEmpty() )
				{
					strNewKeyRoot.MakeLower();
					char cKey = strNewKeyRoot[0] - 'a';
					char cAcc = 0;
					BOOL fNeedToRedraw = FALSE;
					if( strNewKeyRoot.GetLength() > 1 )
					{
						if( strNewKeyRoot[1] == 'b' )
						{
							cAcc = -1;
						}
						else if( strNewKeyRoot[1] == '#' )
						{
							cAcc = 1;
						}
					}
					if( cKey >= 0 && cKey <= 6 )
					{
						// Need to add 12 and %12 to handle B# and Cb
						m_nKeyRoot = (CharToKey[cKey] + cAcc + 12) % 12;
					}
				}
			}
		}
		int nNewKeyRoot = m_nKeyRoot + pNMUpDown->iDelta;
		if( nNewKeyRoot < 0 )
		{
			nNewKeyRoot = 11 - ((abs(nNewKeyRoot) - 1) % 12);
		}
		nNewKeyRoot %= 12;

		if( nNewKeyRoot != m_nKeyRoot )
		{
			m_nKeyRoot = nNewKeyRoot;

			if( m_fUseFlats )
			{
				m_editKeyRoot.SetWindowText( CString(FlatKey).Mid(m_nKeyRoot * cbKeySize, cbKeySize) );
			}
			else
			{
				m_editKeyRoot.SetWindowText( CString(SharpKey).Mid(m_nKeyRoot * cbKeySize, cbKeySize) );
			}
			UpdatePPO();
		}
	}
	
	*pResult = 1;
}

void CChordStripPPG::OnKillfocusEditKeyRoot() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_editKeyRoot.GetSafeHwnd() != NULL)
	{
		m_fChangedKeyRoot = FALSE;

		CString strNewKeyRoot;
		m_editKeyRoot.GetWindowText( strNewKeyRoot );
		if ( !strNewKeyRoot.IsEmpty() )
		{
			strNewKeyRoot.MakeLower();
			char cKey = strNewKeyRoot[0] - 'a';
			char cAcc = 0;
			BOOL fNeedToRedraw = FALSE;
			if( strNewKeyRoot.GetLength() > 1 )
			{
				if( strNewKeyRoot[1] == 'b' )
				{
					cAcc = -1;
				}
				else if( strNewKeyRoot[1] == '#' )
				{
					cAcc = 1;
				}
			}
			if( cKey >= 0 && cKey <= 6 )
			{
				// Need to add 12 and %12 to handle B# and Cb
				m_nKeyRoot = (CharToKey[cKey] + cAcc + 12) % 12;
			}
		}

		// Redraw the Edit control with the correctly formatted key
		if( m_fUseFlats )
		{
			m_editKeyRoot.SetWindowText( CString(FlatKey).Mid(m_nKeyRoot * cbKeySize, cbKeySize) );
		}
		else
		{
			m_editKeyRoot.SetWindowText( CString(SharpKey).Mid(m_nKeyRoot * cbKeySize, cbKeySize) );
		}
	}
}

void CChordStripPPG::OnDeltaposSpinAccidentals(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	if( m_pPPO )
	{
		// Update the value
		int nNewNumAccidentals = m_nNumAccidentals;
		nNewNumAccidentals += ((NM_UPDOWN* )pNMHDR)->iDelta;
        if( nNewNumAccidentals < 0 )
        {
            nNewNumAccidentals = 7;
        }
        else if( nNewNumAccidentals > 7 )
        {
            nNewNumAccidentals = 0;
        }
		if( nNewNumAccidentals != m_nNumAccidentals )
		{
			m_nNumAccidentals = nNewNumAccidentals;
			m_spinAccidentals.SetPos( m_nNumAccidentals );
			UpdatePPO();
		}
	}
	
	*pResult = 1;
}

void CChordStripPPG::OnChangeEditAccidentals() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO )
	{
		if( m_editAccidentals.GetSafeHwnd() != NULL)
		{
			BOOL fTransSuccess = FALSE;
			int nNewNumAccidentals = GetDlgItemInt( IDC_EDIT_ACCIDENTALS, &fTransSuccess );
			if( fTransSuccess )
			{
				if( nNewNumAccidentals > 7 )
				{
					nNewNumAccidentals %= 8;
					m_spinAccidentals.SetPos( nNewNumAccidentals );
				}
				if( nNewNumAccidentals != m_nNumAccidentals )
				{
					m_nNumAccidentals = nNewNumAccidentals;
					m_spinAccidentals.SetPos( m_nNumAccidentals );
					UpdatePPO();
				}
			}
		}
	}
}

void CChordStripPPG::OnKillfocusEditAccidentals() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_editAccidentals.GetSafeHwnd() != NULL)
	{
		CString strNewAccidentals;
		m_editAccidentals.GetWindowText( strNewAccidentals );
		if( strNewAccidentals.IsEmpty() )
		{
			m_spinAccidentals.SetPos( m_nNumAccidentals );
		}
		else
		{
			// Strip leading and trailing spaces
			strNewAccidentals.TrimRight();
			strNewAccidentals.TrimLeft();

			// Convert from text to dword;
			int nNewNumAccidentals = atoi( strNewAccidentals );
			nNewNumAccidentals %= 8;
			if( nNewNumAccidentals != m_nNumAccidentals )
			{
				m_nNumAccidentals = nNewNumAccidentals;
				m_spinAccidentals.SetPos( m_nNumAccidentals );
				UpdatePPO();
			}
		}
	}
}

void CChordStripPPG::OnChangeEditKeyRoot() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	// TODO: Add your control notification handler code here
	m_fChangedKeyRoot = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\ChordStripRiff.cpp ===
#include "stdafx.h"
#include "..\includes\DMUSProd.h"
#include "ChordIO.h"
#include "chord.h"
#include "DLLJazzDataObject.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "resource.h"

#include "chordstripriff.h"

SubChordChunk::SubChordChunk(const DMChord* pChord)
{
	ZeroMemory(this, sizeof(SubChordChunk)); // Zeros out trailing padding bytes
	ASSERT(pChord);
	if(pChord)
	{
		dwChordPattern = pChord->ChordPattern();
		dwScalePattern = pChord->ScalePattern();
		dwInversionPoints = pChord->InvertPattern();
		dwLevels = pChord->Levels();
		bChordRoot = pChord->ChordRoot();
		bScaleRoot = pChord->ScaleRoot();
	}
}

HRESULT SubChordChunk::Write(IStream* pIStream)
{
	HRESULT hr=S_OK;
	DWORD dwBytesWritten;
//	WriteChunk chunk(pRiffStream, DMUS_FOURCC_CHORDTRACK_CHORD);
//	hr = chunk.State();
	if(  hr  == S_OK )
	{
		hr = pIStream->Write( this, sizeof(DMUS_IO_SUBCHORD), &dwBytesWritten) == 0
			&& dwBytesWritten == sizeof(DMUS_IO_SUBCHORD) ? S_OK : E_FAIL;
	}
    return hr;
}

HRESULT SubChordChunk::Read(IStream* pIStream, DWORD dwSubChordSize)
{
	ASSERT(pIStream);
	HRESULT hr;
	DWORD dwBytesRead, dwBytesToRead;
	dwBytesToRead = min( sizeof(DMUS_IO_SUBCHORD), dwSubChordSize );
	hr = pIStream->Read(this, dwBytesToRead, &dwBytesRead) == 0
		&& dwBytesRead == dwBytesToRead ? S_OK : E_FAIL;

	if( dwSubChordSize > sizeof(DMUS_IO_SUBCHORD)
	&&	SUCCEEDED(hr) )
	{
		StreamSeek( pIStream, dwSubChordSize - sizeof(DMUS_IO_SUBCHORD), SEEK_CUR );
	}
	/* uncomment to fix bug 17868 in Manbugs DB
	if(hr == S_OK)
	{
		bool bWarnUser = false;
		// make sure that root is correct and pattern is lowest available
		while(dwChordPattern && !(dwChordPattern & 1))
		{
			dwChordPattern = dwChordPattern >> 1;
			++bChordRoot;
			bWarnUser = true;
		}
		while(bChordRoot > 23)
		{
			bChordRoot -= 12;
			bWarnUser = true;
		}
		if(bWarnUser)
		{
			AfxMessageBox(IDS_ILLEGALCHORD);
		}
	}
	*/
	return hr;
}

HRESULT SubChordChunk::Extract(const DMChord* pChord)
{
	ASSERT(pChord);
	if(pChord)
	{
		dwChordPattern = pChord->ChordPattern();
		dwScalePattern = pChord->ScalePattern();
		dwInversionPoints = pChord->InvertPattern();
		dwLevels = pChord->Levels();
		bChordRoot = pChord->ChordRoot();
		bScaleRoot = pChord->ScaleRoot();
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
}

HRESULT SubChordChunk::Insert(DMChord* pChord)
{
	ASSERT(pChord);
	if(pChord)
	{
		pChord->ChordPattern() = dwChordPattern;
		pChord->ScalePattern() = dwScalePattern;
		pChord->InvertPattern() = dwInversionPoints;
		pChord->Levels() = dwLevels;
		pChord->ChordRoot() = bChordRoot;
		pChord->ScaleRoot() = bScaleRoot;
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
}

/////////////////////////////////////////////// ChordChunk members

ChordChunk::ChordChunk(const CChordItem* pChord)
{
	ASSERT(pChord);
	if(pChord)
	{
		MultiByteToWideChar( CP_ACP, 0, const_cast<CChordItem*>(pChord)->Name(), -1, wszName, sizeof( wszName) / sizeof( wchar_t ) );
		mtTime = pChord->Time();
		wMeasure = pChord->Measure();
		bBeat = pChord->Beat();
		for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
		{
			m_subchords[i].Extract(const_cast<CChordItem*>(pChord)->SubChord(i));
		}
	}
}

HRESULT ChordChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	HRESULT hr = S_OK;
//	WriteChunk chunk(pRiffStream, DMUS_FOURCC_CHORDTRACK_LIST);
//	hr = chunk.State();
	if(  hr  == 0 )
	{
		WriteDWord(pRiffStream, sizeof(DMUS_IO_CHORD));
		IStream* pIStream = pRiffStream->GetStream();
		ASSERT(pIStream != NULL);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}
		hr = pIStream->Write(dynamic_cast<DMUS_IO_CHORD*>(this), sizeof(DMUS_IO_CHORD), 0);
		WriteDWord(pRiffStream, DMPolyChord::MAX_POLY);
		WriteDWord(pRiffStream, sizeof(DMUS_IO_SUBCHORD));
		for(int i = 0; i < DMPolyChord::MAX_POLY && hr == 0; i++)
		{
			hr = m_subchords[i].Write(pIStream);
		}
		pIStream->Release();
	}
    return hr;
}

HRESULT ChordChunk::Read(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	HRESULT hr;
	DWORD dwBytesRead;
	IStream* pIStream = pRiffStream->GetStream();
	ASSERT(pIStream != NULL);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}
	DWORD chordsize;
	DWORD subchordsize;
	DWORD chordcount;
	hr = ReadDWord(pRiffStream, chordsize);
	ASSERT(chordsize == sizeof(DMUS_IO_CHORD));
	if(hr == 0)
	{
		hr = pIStream->Read(dynamic_cast<DMUS_IO_CHORD*>(this), chordsize, &dwBytesRead);
		hr = hr == S_OK && dwBytesRead == chordsize ? S_OK : E_FAIL;
	}
	if(hr == 0)
	{
		hr = ReadDWord(pRiffStream, chordcount);
	}
	if(hr == 0)
	{
		hr = ReadDWord(pRiffStream, subchordsize);
	}
	for(unsigned int i = 0; i < chordcount && hr == 0; i++)
	{
		if(i < DMPolyChord::MAX_POLY)
		{
			hr = m_subchords[i].Read(pIStream, subchordsize);
		}
	}

	pIStream->Release();
	return hr;
}

HRESULT ChordChunk::Extract(const CChordItem* pChord)
{
	ASSERT(pChord);
	if(pChord)
	{
		MultiByteToWideChar( CP_ACP, 0, const_cast<CChordItem*>(pChord)->Name(), -1, wszName, sizeof( wszName) / sizeof( wchar_t ) );
		mtTime = pChord->Time();
		wMeasure = pChord->Measure();
		bBeat = pChord->Beat();
		bFlags = pChord->Flags();
		for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
		{
			m_subchords[i].Extract(const_cast<CChordItem*>(pChord)->SubChord(i));
		}
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
}

HRESULT ChordChunk::Insert(CChordItem* pChord)
{
	ASSERT(pChord);
	if(pChord)
	{
		memset(pChord->Name(), 0, DMPolyChord::MAX_NAME);
		WideCharToMultiByte( CP_ACP, 0, wszName, -1, pChord->Name(), DMPolyChord::MAX_NAME, NULL, NULL );
		pChord->Time() = mtTime;
		pChord->Measure() = wMeasure;
		pChord->Beat() = bBeat;
		pChord->Flags() = bFlags;
		for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
		{
			m_subchords[i].Insert(pChord->SubChord(i));
		}
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
}

/////////////////////////////////////////////// ChordDesignChunk members

ChordDesignChunk::ChordDesignChunk(const CChordItem* pChord)
{
	ASSERT(pChord);
	m_fFlatsNotSharps = FALSE;
	if(!pChord)
	{
		return;
	}
	if(pChord)
	{
		m_fFlatsNotSharps = const_cast<CChordItem*>(pChord)->SubChord(const_cast<CChordItem*>(pChord)->RootIndex())->UseFlat();
	}
}

HRESULT ChordDesignChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	HRESULT hr = S_OK;
	if(  hr  == S_OK )
	{
		WriteDWord(pRiffStream, structSize);
		IStream* pIStream = pRiffStream->GetStream();
		ASSERT(pIStream != NULL);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}
		hr = pIStream->Write(&m_fFlatsNotSharps, firstItemSize, 0);
		pIStream->Release();
	}
    return hr;
}

HRESULT ChordDesignChunk::Read(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	HRESULT hr;
	IStream* pIStream = pRiffStream->GetStream();
	ASSERT(pIStream != NULL);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}
	DWORD infosize, dwBytesRead;
	hr = ReadDWord(pRiffStream, infosize);
	
	ASSERT(hr == S_OK);
	if(hr != S_OK)
	{
		pIStream->Release();
		return hr;
	}
	ASSERT(infosize >= firstItemSize);
	if(infosize < firstItemSize)
	{
		pIStream->Release();
		return E_UNEXPECTED;
	}

	hr = pIStream->Read(&m_fFlatsNotSharps, firstItemSize, &dwBytesRead);
	hr = (hr == S_OK && firstItemSize == dwBytesRead) ? S_OK : E_FAIL;
	pIStream->Release();
	return hr;
}

HRESULT ChordDesignChunk::Extract(const CChordItem* pChord)
{
	ASSERT(pChord);
	if(pChord)
	{
		m_fFlatsNotSharps = const_cast<CChordItem*>(pChord)->SubChord(const_cast<CChordItem*>(pChord)->RootIndex())->UseFlat();
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
}

HRESULT ChordDesignChunk::Insert(CChordItem* pChord)
{
	ASSERT(pChord);
	if(pChord)
	{
		for(int i = 0; i < DMPolyChord::MAX_POLY; i++)
		{
			pChord->SubChord(i)->UseFlat() = m_fFlatsNotSharps;
		}
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
}

////////////////////////////////// ChordListChunk members

HRESULT ChordListChunk::Write(IDMUSProdRIFFStream* pRiffStream)
{
	HRESULT hr;
	DWORD dwBytes;
	ASSERT(pRiffStream);
	if(pRiffStream == NULL)
	{
		return E_INVALIDARG;
	}


	WriteListChunk list(pRiffStream, DMUS_FOURCC_CHORDTRACK_LIST);
	hr = list.State();

	if(hr== S_OK)
	{
		IStream* pIStream = pRiffStream->GetStream();
		ASSERT(pIStream);
		if(!pIStream)
		{
			return E_FAIL;
		}
		WriteChunk chunk(pRiffStream, DMUS_FOURCC_CHORDTRACKHEADER_CHUNK);
		hr = chunk.State();
		if(hr == S_OK)
		{
			hr = pIStream->Write(&m_scale , sizeof(DWORD), &dwBytes);
			hr = dwBytes == sizeof(DWORD) ? hr : E_FAIL;
		}
		pIStream->Release();
	}


	for(CChordItem* pItem = m_plist->GetHead(); pItem && (hr == S_OK); pItem = pItem->GetNext())
	{
		{
			// need scope to destroy writechunk and complete ascension
			ChordChunk chordchunk;
			WriteChunk writechunk(pRiffStream, DMUS_FOURCC_CHORDTRACKBODY_CHUNK);
			hr = writechunk.State();

			if(hr == S_OK)
			{
				chordchunk.Extract(pItem);
				hr = chordchunk.Write(pRiffStream);
			}
		}
		if(m_designTime)
		{
			ChordDesignChunk designChunk;
			WriteChunk writechunk(pRiffStream, DMUSPROD_FOURCC_CHORDDESIGNINFO);
			hr = writechunk.State();
			if(hr == S_OK)
			{
				designChunk.Extract(pItem);
				hr = designChunk.Write(pRiffStream);
			}
		}
	}
	return hr;
}

HRESULT ChordListChunk::Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
{
	HRESULT hr = S_OK;
	ASSERT(pRiffStream && pckParent);
	MMCKINFO ck;

	ASSERT(m_plist);
	if(m_plist == NULL)
		return E_UNEXPECTED;

	DWORD dwBytes;

	CChordItem* pItem = 0;


	m_plist->ClearList();
	while(hr == S_OK && pRiffStream->Descend(&ck, pckParent, 0) == 0)
	{
		switch(ck.ckid)
		{
		case DMUS_FOURCC_CHORDTRACKHEADER_CHUNK:
			{
				IStream* pIStream = pRiffStream->GetStream();
				ASSERT(pIStream);
				if(!pIStream)
					hr = E_FAIL;
				else
				{
					hr = pIStream->Read(&m_scale, sizeof(DWORD), &dwBytes) == S_OK &&
							dwBytes == sizeof(DWORD) ? S_OK : E_FAIL;				
					pIStream->Release();
				}
			}
			break;
		case DMUS_FOURCC_CHORDTRACKBODY_CHUNK:
			{
				pItem = new CChordItem;
				ChordChunk chunk;
				hr = chunk.Read(pRiffStream);
				if(hr == S_OK)
				{
					chunk.Insert(pItem);
					m_plist->AddTail(pItem);
				}
				else
				{
					delete pItem;
				}
			}
			break;
		case DMUSPROD_FOURCC_CHORDDESIGNINFO:
			{
				// assumes that design info applies to the last read chorditem
				if(pItem)
				{
					ChordDesignChunk chunk;
					hr = chunk.Read(pRiffStream);
					if(hr == S_OK)
					{
						chunk.Insert(pItem);
					}
				}
			}
			break;
		default:
			// wrong chunk type
			hr = E_FAIL;
			break;
		}
		pRiffStream->Ascend(&ck, 0);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\DWList.h ===
//
// DWList.h
//
#ifndef __DWList_H__
#define __DWList_H__

//#pragma warning(disable: 4505)

class DWListItem
{
public:
    DWListItem() { m_pNext=NULL; };
    DWListItem *GetNext() const {return m_pNext;};
    void SetNext(DWListItem *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    DWListItem* Cat(DWListItem* pItem);
    DWListItem* AddTail(DWListItem* pItem) {return Cat(pItem);};
    DWListItem* Remove(DWListItem* pItem);
    DWListItem* GetPrev(DWListItem *pItem) const;
    DWListItem* GetItem(LONG index);

private:
    DWListItem *m_pNext;
};

class DWList
{
public:
    DWList() {m_pHead=NULL;};
    DWListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    LONG GetCount() const {return m_pHead->GetCount();}; 
    DWListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(DWListItem *pItem,DWListItem *pInsert);
    void Cat(DWListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(DWList *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(DWListItem *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(DWListItem *pItem) {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(DWListItem *pItem) {m_pHead=m_pHead->Remove(pItem);};
    DWListItem *GetPrev(DWListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    DWListItem *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    DWListItem *RemoveHead(void)
        {
            DWListItem *li;
            li=m_pHead;
            if(m_pHead)
                m_pHead=m_pHead->GetNext();
            return li;
        }

protected:
    DWListItem *m_pHead;
};

class IndexList : public DWList 
{
public:
				IndexList() { 
					DWList();
					m_index = 0; 
				};
	DWListItem	*GetIndexedItem() { return(GetItem(m_index)); }
	void		SetIndex(LONG index)
				{
					m_index = index;
					if (GetCount() <= (LONG) index) m_index = 0;
				}
	DWListItem	*RemoveIndexedItem()
				{
					DWListItem *item = GetIndexedItem();
					if (item) Remove(item);
					return (item);
				}
	void		AddIndexedItem(DWListItem *item)
				{
					AddHead(item);
					m_index = 0;
				}

	LONG		m_index;
};

#endif // __DWList_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\ChordStripRiff.h ===
#ifndef CHORDSTRIPRIFF_H
#define CHORDSTRIPRIFF_H


#include "dmusicf.h"
#include "chordio.h"
#include "riffstrm.h"

// constants
const int MaxSubChords = 4;
/*
#ifndef DMUS_FOURCC_CHORDTRACK_LIST
#define DMUS_FOURCC_CHORDTRACK_LIST	mmioFOURCC('c','h','r','d')
#endif

#define DMUS_FOURCC_CHORDTRACK_CHORD mmioFOURCC('c', 'r', 'd', 'b')
*/

#define DMUSPROD_FOURCC_CHORDDESIGNINFO mmioFOURCC('c','r','d','t')

// simple riff read/writers
inline HRESULT ReadDWord(IDMUSProdRIFFStream* pIRiffStream, DWORD& val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Read(&val, sizeof(DWORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

inline HRESULT WriteDWord(IDMUSProdRIFFStream* pIRiffStream, DWORD val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Write(&val, sizeof(DWORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}
// chunk navigators
class WriteChunk
{
	MMCKINFO m_ck;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	WriteChunk(IDMUSProdRIFFStream* pRiffStream, FOURCC id)
	{
		m_ck.ckid = id;
		m_pRiffStream = pRiffStream;
		m_hr = pRiffStream->CreateChunk( &m_ck, 0 );
	}
	HRESULT	State(MMCKINFO* pck = 0)
	{
		if(pck)
		{
			memcpy(pck,  &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		return m_ck.ckid;
	}
	~WriteChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
};

class ReadChunk
{
	MMCKINFO m_ck;
	MMCKINFO* m_pckParent;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	ReadChunk(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent) : m_pRiffStream(pRiffStream)
	{
		m_pckParent = pckParent;
		m_hr = pRiffStream->Descend( &m_ck,  m_pckParent, 0 );
	}
	~ReadChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		if(m_ck.ckid == FOURCC_LIST)
		{
			return m_ck.fccType;
		}
		else
		{
			return m_ck.ckid;
		}
	}
};

// list navigators
class WriteListChunk
{
	MMCKINFO m_ck;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	WriteListChunk(IDMUSProdRIFFStream* pRiffStream, FOURCC id)
	{
		m_ck.fccType = id;
		m_pRiffStream = pRiffStream;
 		m_hr = pRiffStream->CreateChunk( &m_ck, MMIO_CREATELIST );
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		return m_ck.ckid;
	}
	~WriteListChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
};


class SubChordChunk : public DMUS_IO_SUBCHORD
{
public:
	SubChordChunk() {ZeroMemory(this, sizeof(SubChordChunk));}
	SubChordChunk(const DMChord * pChord);
	HRESULT Write(IStream* pIStream);
	HRESULT Read(IStream* pIStream, DWORD dwSubChordSize);
	HRESULT Extract(const DMChord* pChord);
	HRESULT Insert(DMChord* pChord);
};


class ChordChunk : public DMUS_IO_CHORD
{
	SubChordChunk	m_subchords[DMPolyChord::MAX_POLY];
public:
	ChordChunk() {}
	ChordChunk(IDMUSProdRIFFStream* pRiffStream)
	{
		Read(pRiffStream);
	}
	ChordChunk(const CChordItem * pChord);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Extract(const CChordItem* pChord);
	HRESULT Insert(CChordItem* pChord);
};

class ChordDesignChunk
{
	BOOL	m_fFlatsNotSharps;
public:
	enum { structSize = sizeof(BOOL), firstItemSize = sizeof(BOOL), secondItemSize = 0 };	// use to determine how much design time info to read
	ChordDesignChunk() {m_fFlatsNotSharps = FALSE;}
	ChordDesignChunk(IDMUSProdRIFFStream* pRiffStream)
	{
		Read(pRiffStream);
	}
	ChordDesignChunk(const CChordItem * pChord);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Extract(const CChordItem* pChord);
	HRESULT Insert(CChordItem* pChord);
	BOOL& UseFlats() 
	{
		return m_fFlatsNotSharps;
	}
};

class ChordTrackHeaderChunk : public DMUS_IO_TRACK_HEADER
{
public:
	ChordTrackHeaderChunk() 
	{
		guidClassID = CLSID_DirectMusicChordTrack;
		ckid = DMUS_FOURCC_TRACK_CHUNK;
		fccType = 0;
		dwPosition = 0;	// this is undetermined
		dwGroup = 0;	// so is this
	}
	ChordTrackHeaderChunk(IDMUSProdRIFFStream* pRiffStream)
	{
		Read(pRiffStream);
	}
	ChordTrackHeaderChunk(DWORD position, DWORD group)
	{
		guidClassID = CLSID_DirectMusicChordTrack;
		ckid = 0;
		fccType = DMUS_FOURCC_TRACK_CHUNK;
		dwPosition = position;
		dwGroup = group;
	}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream)
	{
		ASSERT(pRiffStream);
		HRESULT hr;
		DWORD dwBytesRead;
		IStream* pIStream = pRiffStream->GetStream();
		ASSERT(pIStream != NULL);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}
		WriteChunk chunk(pRiffStream, DMUS_FOURCC_TRACK_CHUNK);
		hr = chunk.State();
		if(hr == S_OK)
		{
			hr = pIStream->Write(dynamic_cast<DMUS_IO_TRACK_HEADER*>(this),
											  sizeof(DMUS_IO_TRACK_HEADER), &dwBytesRead);
			hr = (hr == S_OK) && (dwBytesRead == sizeof(DMUS_IO_TRACK_HEADER)) ? S_OK : E_FAIL;
		}
		pIStream->Release();
		return hr;
	}
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream)
	{
		ASSERT(pRiffStream);
		HRESULT hr;
		DWORD dwBytesRead;
		IStream* pIStream = pRiffStream->GetStream();
		ASSERT(pIStream != NULL);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}
		hr = pIStream->Read(dynamic_cast<DMUS_IO_TRACK_HEADER*>(this),
										  sizeof(DMUS_IO_TRACK_HEADER), &dwBytesRead);
		hr = (hr == S_OK) && (dwBytesRead == sizeof(DMUS_IO_TRACK_HEADER)) ? S_OK : E_FAIL;
		pIStream->Release();
		return hr;
	}
	DWORD& Position()
	{
		return dwPosition;
	}
	DWORD& Group()
	{
		return dwGroup;
	}
};

//
class ChordListChunk
{
	CChordList* m_plist;
	DWORD	m_scale;
	bool	m_designTime;
public:
	ChordListChunk() {m_designTime = false;}
	ChordListChunk(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent)
	{
		Read(pRiffStream, pckParent);
	}
	ChordListChunk( CChordList * plist, DWORD scale = 0, bool designTime = false)
	{
		m_plist = plist;
		m_scale = scale;
		m_designTime = designTime;
	}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
	HRESULT Read(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent);
	CChordList*& List()
	{
		return m_plist;
	}
	DWORD& Scale()
	{
		return m_scale;
	}
	bool& DesignTime()
	{
		return m_designTime;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\IllegalChord.cpp ===
// IllegalChord.cpp : implementation file
//
#include "stdafx.h"
#pragma warning(disable:4201)
#include "chordstripmgr.h"
#include "resource.h"
#include "IllegalChord.h"
#pragma warning(default:4201)


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CIllegalChord dialog


CIllegalChord::CIllegalChord(CWnd* pParent /*=NULL*/)
	: CDialog(CIllegalChord::IDD, pParent)
{
	//{{AFX_DATA_INIT(CIllegalChord)
	m_bDontWarn = FALSE;
	//}}AFX_DATA_INIT

}


void CIllegalChord::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIllegalChord)
	DDX_Control(pDX, IDC_ILLEGALCHORD, m_infotext);
	DDX_Check(pDX, IDC_DONTWARN, m_bDontWarn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CIllegalChord, CDialog)
	//{{AFX_MSG_MAP(CIllegalChord)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIllegalChord message handlers

BOOL CIllegalChord::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CString s1,s2;

	s1.LoadString(IDS_ILLEGALCHORD2);
	s2.LoadString(IDS_DONTWARN);

	m_infotext.SetWindowText(s1);
	
	SetDlgItemText(IDC_DONTWARN, s2);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\PropPageMgr.h ===
// PropPageMgr.h : Handles the property pages

#ifndef __PROPPAGEMGR_H_
#define __PROPPAGEMGR_H_

#include "ChordScalePropPage.h"
#include "ChordInversionPropPage.h"
#include "staticproppagemanager.h"

class CChordPropPageMgr : public  CStaticPropPageManager
{
	friend class CChordScalePropPage;
	friend class CChordInversionPropPage;
public:
	CChordPropPageMgr(IDMUSProdFramework* pIFramework );
	~CChordPropPageMgr();
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
//	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet( void );

	// Additional methods
	void UpdateObjectWithTabData();

	CChordScalePropPage*		m_pChordScalePropPage;
	CChordInversionPropPage*	m_pChordInversionPropPage;
	IDMUSProdFramework*		m_pIFramework;

	static short					sm_nActiveTab;
};

#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\PropChord.cpp ===
#include "stdafx.h"
#include "PropChord.h"

CPropChord::CPropChord()
{
	for(int i = 0; i < MAX_POLY; i++)
		m_dwUndetermined[i] = 0;
}

static char *convert[] = {"C","C#","D","D#","E","F","F#","G","G#","A","A#","B"};
static char *flatconvert[] = {"C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"};

void CPropChord::RootToString(char *pszName, int nSubChord)
{
	ASSERT(nSubChord < MAX_POLY);
	nSubChord = nSubChord < 0 ? 0 : nSubChord;	// < 0 --> default root (0)
	int nX = (char)( SubChord(nSubChord)->ChordRoot() % 12 );
	if( SubChord(nSubChord)->UseFlat() )
		wsprintf( pszName,"%d%s",1 + (SubChord(nSubChord)->ChordRoot() / 12), (LPSTR)flatconvert[nX] ) ;
	else
		wsprintf( pszName,"%d%s",1 + (SubChord(nSubChord)->ChordRoot()/ 12), (LPSTR)convert[nX] ) ;
}


void CPropChord::SetBits(int nSubChord)
{
	LONG    nX;
	int   nCount = 0;

	DMChord* pSub = SubChord(nSubChord);

    for( nX=0L ;  nX<32L ;  nX++ )
    {
        if( pSub->ChordPattern() & (1L << nX) )
            nCount++;
    }

    if( !pSub->Bits() )
    {
        pSub->Bits() |= CHORD_INVERT;
        if( nCount > 3 )
            pSub->Bits() |= CHORD_FOUR;
        if( pSub->ChordPattern() & (15L << 18L) )
            pSub->Bits() |= CHORD_UPPER;
    }
    pSub->Bits() &= ~CHORD_COUNT;
    pSub->Bits() |= nCount;
}

void CPropChord::CopyToPropChord( CPropChord *pPropChord,  int nSubChord)
{
	ASSERT(nSubChord < MAX_POLY);

	int lower = nSubChord <0 ? 0 : nSubChord;
	int upper = nSubChord < -1 ? MAX_POLY : nSubChord + 1;
	int i;
	DWORD dwChangeFlags[MAX_POLY] ;
	
	for(i = 0; i < MAX_POLY; i++)
	{
		dwChangeFlags[i] = 0;
		pPropChord->m_dwUndetermined[i] = 0;
	}

	for(i = lower; i < upper; i++)
	{
		DMChord* pSubL = SubChord(i);
		DMChord* pSubR = pPropChord->SubChord(i);

		if (pSubL->ChordPattern() != pSubR->ChordPattern())
		{
			dwChangeFlags[i] |= UD_CHORDPATTERN;
		}

		if (pSubL->ScalePattern() != pSubR->ScalePattern())
		{
			dwChangeFlags[i] |= UD_SCALEPATTERN;
		}

		if (strcmp(Name(), pPropChord->Name()))
		{
			dwChangeFlags[i] |= UD_NAME;
		}

		if (pSubL->ChordRoot() != pSubR->ChordRoot())
		{
			dwChangeFlags[i] |= UD_CHORDROOT;
		}

		if (pSubL->ScaleRoot() != pSubR->ScaleRoot())
		{
			dwChangeFlags[i] |= UD_SCALEROOT;
		}

		if (pSubL->UseFlat() != pSubR->UseFlat())
		{
			dwChangeFlags[i] |= UD_FLAT;
		}

		if ((pSubL->Bits() & CHORD_INVERT) != (pSubR->Bits() & CHORD_INVERT))
		{
			dwChangeFlags[i] |= UD_INVERT;
		}

		if ((pSubL->Bits() & CHORD_FOUR) != (pSubR->Bits() & CHORD_FOUR))
		{
			dwChangeFlags[i] |= UD_FOUR;
		}

		if ((pSubL->Bits() & CHORD_UPPER) != (pSubR->Bits() & CHORD_UPPER))
		{
			dwChangeFlags[i] |= UD_UPPER;
		}

		if(pSubL->InvertPattern() != pSubR->InvertPattern())
		{
			dwChangeFlags[i] |= UD_INVERTPATTERN;
		}
		
		if(pSubL->Levels() != pSubR->Levels())
		{
			dwChangeFlags[i] |= UD_LEVELS;
		}

		pPropChord->m_dwUndetermined[i] = dwChangeFlags[i];
	}
}

  
void CPropChord::CopyFromPropChord( CPropChord *pPropChord, int nSubChord )
{
	ASSERT(nSubChord < MAX_POLY);

	int lower = nSubChord == -1 ? 0 : nSubChord;
	int upper = nSubChord == -1 ? MAX_POLY : nSubChord + 1;
	int i;
	DWORD dwChangeFlags[MAX_POLY] ;
	for(i = 0; i < MAX_POLY; i++)
	{
		dwChangeFlags[i] = ~(pPropChord->m_dwUndetermined[i]);
	}

	for(i = lower; i < upper; i++)
	{
		DMChord* pSubL = SubChord(i);
		DMChord* pSubR = pPropChord->SubChord(i);

		if (dwChangeFlags[i] & UD_CHORDPATTERN)
		{
			pSubL->ChordPattern() = pSubR->ChordPattern();
		}

		if (dwChangeFlags[i] & UD_SCALEPATTERN)
		{
			pSubL->ScalePattern() = pSubR->ScalePattern();
		}

		if (dwChangeFlags[i] & UD_NAME)
		{
			strcpy(Name(), pPropChord->Name());
		}

		if (dwChangeFlags[i] & UD_CHORDROOT)
		{
			pSubL->ChordRoot() = pSubR->ChordRoot();
		}

		if( dwChangeFlags[i] & UD_SCALEROOT)
		{
			pSubL->ScaleRoot() = pSubR->ScaleRoot();
		}

		if (dwChangeFlags[i] & UD_FLAT)
		{
			pSubL->UseFlat() = pSubR->UseFlat();
		}

		if (dwChangeFlags[i] & UD_INVERT)
		{
			pSubL->Bits() &= ~CHORD_INVERT;
			pSubL->Bits() |= (pSubR->Bits() & CHORD_INVERT);
		}

		if (dwChangeFlags[i] & UD_FOUR)
		{
			pSubL->Bits() &= ~CHORD_FOUR;
			pSubL->Bits() |= (pSubR->Bits() & CHORD_FOUR);
		}

		if (dwChangeFlags[i] & UD_UPPER)
		{
			pSubL->Bits() &= ~CHORD_UPPER;
			pSubL->Bits() |= (pSubR->Bits() & CHORD_UPPER);
		}

		if(dwChangeFlags[i] & UD_INVERTPATTERN)
		{
			pSubL->InvertPattern() = pSubR->InvertPattern();
		}

		if(dwChangeFlags[i] & UD_LEVELS)
		{
			pSubL->Levels() = pSubR->Levels();
		}
	}
}


BOOL CPropChord :: operator < (const CPropChord& chord)
{
	if( Measure() == chord.Measure())
	{
		if(Beat() < chord.Beat())
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	else if (Measure() < chord.Measure())
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

CPropChord& CPropChord::operator = (const CPropChord& chord)
{
	if(&chord == this)
	{
		return *this;
	}

	*dynamic_cast<DMPolyChord*>(const_cast<CPropChord*>(this)) = chord;

	for(int i = 0; i < MAX_POLY; i++)
	{
		m_dwUndetermined[i] = chord.m_dwUndetermined[i];
	}

	return *this;
}

CPropChord::CPropChord(const CPropChord& chord)
{
	*dynamic_cast<DMPolyChord*>(const_cast<CPropChord*>(this)) = chord;

	for(int i = 0; i < MAX_POLY; i++)
	{
		m_dwUndetermined[i] = chord.m_dwUndetermined[i];
	}
}

void	CPropChord::SetUndetermined(int nSubChord, DWORD value)
{
	ASSERT(nSubChord < MAX_POLY);
	int lower = nSubChord == -1 ? 0 : static_cast<int>(nSubChord);
	int upper = nSubChord == -1 ? MAX_POLY : static_cast<int>(nSubChord) + 1;
	for(int i = lower; i < upper; i++)
	{
		m_dwUndetermined[i] = value;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\PropPageMgr.cpp ===
// CChordPropPageMgr : implementation file
//

#include "stdafx.h"
#include "..\includes\DMUSProd.h"
#include "..\includes\Conductor.h"
#include "PropChord.h"
#include "PropPageMgr.h"
#include "ChordScalePropPage.h"
#include "ChordInversionPropPage.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr property page

short CChordPropPageMgr::sm_nActiveTab = 0;

HRESULT STDMETHODCALLTYPE CChordPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
};


CChordPropPageMgr::CChordPropPageMgr( IDMUSProdFramework* pIFramework )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pIFramework != NULL );
	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	m_pChordScalePropPage = NULL;
	m_pChordInversionPropPage = NULL;
	CStaticPropPageManager::CStaticPropPageManager();
}

CChordPropPageMgr::~CChordPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pChordScalePropPage )
	{
		m_pChordScalePropPage->Release();
		m_pChordScalePropPage = 0;
	}
	if(m_pChordInversionPropPage)
	{
		m_pChordInversionPropPage->Release();
		m_pChordInversionPropPage = 0;
	}
	if ( m_pIFramework )
	{
		m_pIFramework->Release();
		m_pIFramework = 0;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CChordPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_PROPPAGE_CHORD );
/*
	CPropChord tabData;
	void* pTabData = &tabData;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pTabData))) )
	{
		strTitle = tabData.strName + _T(" ") + strTitle;
	}
*/
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CChordPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;


	// Add Chord/Scale tab
	if(m_pChordScalePropPage == NULL)
	{
		m_pChordScalePropPage = new CChordScalePropPage( );
	}
	ASSERT(m_pChordScalePropPage);
	if( m_pChordScalePropPage )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pChordScalePropPage->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		// fill in proppagemgr member
		m_pChordScalePropPage->m_pPropPageMgr = this;
		// fill in proppage's conductor member
		if(!m_pChordScalePropPage->m_pIConductor)
		{
			ASSERT(m_pIFramework);
			IDMUSProdComponent* pIComponent = NULL;
			IDMUSProdConductor* pConductor = NULL;
			if( SUCCEEDED ( m_pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
			{
				pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pConductor );
				if (pConductor)
				{
					m_pChordScalePropPage->m_pIConductor = pConductor;
				}
				pIComponent->Release();
			}
		}
	}


	// Add ChordInversion tab
	if(m_pChordInversionPropPage == NULL)
	{
		m_pChordInversionPropPage = new CChordInversionPropPage( );
	}
	ASSERT(m_pChordInversionPropPage);
	if( m_pChordInversionPropPage )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pChordInversionPropPage->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
		// fill in proppagemgr member
		m_pChordInversionPropPage->m_pPropPageMgr = this;
		if(!m_pChordInversionPropPage->m_pIConductor)
		{
			ASSERT(m_pIFramework);
			IDMUSProdComponent* pIComponent = NULL;
			IDMUSProdConductor* pConductor = NULL;
			if( SUCCEEDED ( m_pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
			{
				pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pConductor );
				if (pConductor)
				{
					m_pChordInversionPropPage->m_pIConductor = pConductor;
				}
				pIComponent->Release();
			}
		}
	}


	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}

/*
/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CChordPropPageMgr::OnRemoveFromPropertySheet( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CChordPropPageMgr::sm_nActiveTab );

	CDllBasePropPageManager::OnRemoveFromPropertySheet();

//	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}
*/

/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr IDMUSProdPropPageManager::RefreshData

HRESULT CChordPropPageMgr::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CChordScalePropPageData chordscalePropPageData;
	CChordScalePropPageData* pChordScalePropPageData = &chordscalePropPageData;

	if( m_pIPropPageObject == NULL )
	{
		return E_FAIL;
	}

	if( SUCCEEDED ( m_pIPropPageObject->GetData( (void **)&pChordScalePropPageData ) ) )
	{
		m_pChordScalePropPage->SetChordData(pChordScalePropPageData);
		m_pChordInversionPropPage->SetChordData(pChordScalePropPageData);
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr IDMUSProdPropPageManager::UpdateObjectWithTabData

void CChordPropPageMgr::UpdateObjectWithTabData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pIPropPageObject != NULL );

	CPropChord tabData;

	// Populate the tabPersonality structure
	m_pChordScalePropPage->GetDataFromTab( &tabData );
	m_pChordInversionPropPage->GetDataFromTab( &tabData ); 
	
	// Send the new data to the PropPageObject
	m_pIPropPageObject->SetData( (void *)&tabData );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\PropChord.h ===
#ifndef __PROPCHORD_H_
#define __PROPCHORD_H_

#include "chord.h"

#define CHORD_INVERT  0x10      /* This chord may be inverted           */
#define CHORD_FOUR    0x20      /* This should be a 4 note chord        */
#define CHORD_UPPER   0x40      /* Shift upper octave down              */
#define CHORD_SIMPLE  0x80      /* This is a simple chord               */
#define CHORD_COUNT   0x0F      /* Number of notes in chord (up to 15)  */

class CPropChord : public DMPolyChord
{
//	Used to track which fields are shared by multiple 
//	chords and have multiple values, so are undetermined.
	DWORD		m_dwUndetermined[MAX_POLY];
public:
	enum {ALL = -1};
				CPropChord();
				CPropChord(const CPropChord&);
	void		SetBits(int nSubChord);
	void		CopyToPropChord( CPropChord *pPropChord, int nSubChord );	// nSubChord = -1 -> all subchords
	void		CopyFromPropChord( CPropChord *pPropChord, int nSubChord ); // nSubChord = -1 -> all subchords
	void		RootToString(char *pszName, int nSubChord);
	CPropChord&	operator = (const CPropChord&);
	BOOL		operator < (const CPropChord&);
	void		SetUndetermined(int nSubChord, DWORD value);	// nSubChord = -1 -> all subchords
	DWORD	GetUndetermined(int nSubChord)
	{
		ASSERT(nSubChord < DMPolyChord::MAX_POLY);
		return m_dwUndetermined[nSubChord];
	}
	DWORD& Undetermined(int nSubChord)
	{
		ASSERT(nSubChord < DMPolyChord::MAX_POLY);
		return m_dwUndetermined[nSubChord];
	}
	/*
    DWORD		m_dwTime;
    DWORD		m_dwChordPattern;	// Pattern that defines chord
    DWORD		m_dwScalePattern;	// Scale Pattern for the chord
    short		m_nMeasure;			// What measure
    char		m_szName[12];		// Text for display
    BYTE		m_bRoot;			// Root note of chord
    BYTE		m_bFlat;			// Display with flat
    BYTE		m_bBeat;			// What beat this falls on
    BYTE		m_bBits;			// Invert and item count
	*/
};

// Flags for m_dwUndetermined:

#define UD_CHORDPATTERN		(1 << 0)
#define UD_SCALEPATTERN		(1 << 1)
#define UD_NAME				(1 << 2)
#define UD_CHORDROOT				(1 << 3)
#define UD_FLAT				(1 << 4)
#define UD_INVERT			(1 << 5)
#define UD_FOUR				(1 << 6)
#define UD_UPPER			(1 << 7)
#define UD_SIMPLE			(1 << 8)
#define UD_DRAGSELECT		(1 << 9)
#define UD_DROPSELECT		(1 << 10)
#define UD_FROMCHORDPALETTE	(1 << 11)
#define UD_SCALEROOT		(1<<12)
#define UD_INVERTPATTERN	(1 << 13)
#define UD_LEVELS (1 << 14)

#endif // __PROPCHORD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\CommandStripMgr\commandio.cpp ===
#include "stdafx.h"
#include "ChordIO.h"



CChordItem::CChordItem()

{
	m_lDrawPosition = 0;
	m_dwIndex = 0;
	m_fSelected = FALSE;
}

CChordItem::CChordItem(const CChordItem& chord)
{
	m_lDrawPosition = chord.m_lDrawPosition;
	m_dwIndex = chord.m_dwIndex;
	m_fSelected = chord.m_fSelected;
	*((CPropChord*)this) = chord;
}

DWORD CChordList::PreparePropChord( CPropChord *pPropChord )

/*	Scan through the chord list and combine all chords that have
	m_fSelected set into the one chord for the property page.
*/

{
	DWORD dwSelectCount = 0;	// How many are selected.
	memset( (void *) pPropChord, 0, sizeof (CPropChord));
	CChordItem* pChord = GetHead();
	for (;pChord != NULL; pChord = pChord->GetNext())
	{
		if (pChord->m_fSelected)
		{
			if (dwSelectCount == 0)
			{
				*pPropChord = *pChord;
				pPropChord->m_dwUndetermined = 0;
			}
			else
			{
				pChord->CopyToPropChord(pPropChord);
			}
			dwSelectCount++;
		}
	}
	return dwSelectCount;
}

DWORD CChordList::RetrievePropChord( CPropChord *pPropChord )

{
	DWORD dwSelectCount = 0;	// How many are selected.
	CChordItem* pChord = GetHead();
	for (;pChord != NULL; pChord = pChord->GetNext())
	{
		if (pChord->m_fSelected)
		{
			pChord->CopyFromPropChord(pPropChord);
			dwSelectCount++;
		}
	}
	return dwSelectCount;
}

void CChordList::ClearSelections( )

{
	CChordItem* pChord = GetHead();
	for (;pChord != NULL; pChord = pChord->GetNext())
	{
		pChord->m_fSelected = FALSE;
	}
}

void CChordList::ClearList()
{
	CChordItem* pChord;
	while( pChord = RemoveHead() )
	{
		delete pChord;
	}
}


void CChordList::InsertByAscendingTime(CChordItem* pChord)
{
	ASSERT(pChord);
	CChordItem* pItem = GetHead();
	while(pItem && *pItem < *pChord)
	{
		pItem = pItem->GetNext();
	}
	if(pItem)
	{
		InsertBefore(pItem, pChord);
	}
	else
	{
		AddTail(pChord);
	}
}

HRESULT CChordList::Load( LPSTREAM pStream )
{
	HRESULT		hr = S_OK;
	DWORD		cb;
	DWORD		cSize;
    CChordItem*		pChord;
    ioChordSelection iChordSelection;
    WORD        wSizeChord;
	STATSTG		statstg;
	DWORD		dwIndex = 0;

	if( NULL == pStream )
	{
		return E_POINTER;
	}
	if( hr = FAILED( pStream->Stat( &statstg, STATFLAG_NONAME ) ))
	{
		return hr;
	}
	ClearList();
	cSize = statstg.cbSize.LowPart;

//    cSize = pck->cksize;
//	*plstChord = NULL;
	// load size of chord structure
    hr = pStream->Read( &wSizeChord, sizeof( wSizeChord ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSizeChord ) )
	{
        hr = E_FAIL;
		goto ON_ERR;
	}
	cSize -= cb;
	while( cSize )
	{
        if( wSizeChord > sizeof( ioChordSelection ) )
        {
            hr = pStream->Read( &iChordSelection, sizeof( ioChordSelection ), &cb );
            if( FAILED( hr ) || cb != sizeof( ioChordSelection ) )
            {
				hr = E_FAIL;
				break;
            }
            StreamSeek( pStream, wSizeChord - sizeof( ioChordSelection ), STREAM_SEEK_CUR );
        }
        else
        {
            hr = pStream->Read( &iChordSelection, wSizeChord, &cb );
            if( FAILED( hr ) || cb != wSizeChord )
            {
				hr = E_FAIL;
				break;
            }
        }
        cSize -= wSizeChord;

        pChord = new CChordItem;

        if( pChord == NULL )
		{
            hr = E_OUTOFMEMORY;
            goto ON_ERR;
        }

        WideCharToMultiByte( CP_ACP, 0, iChordSelection.wstrName, -1, pChord->m_szName, sizeof( pChord->m_szName ), NULL, NULL );
        if( iChordSelection.fCSFlags & CSF_FLAT )
        {
            pChord->m_bFlat = 1;
        }
		if( iChordSelection.fCSFlags & CSF_SELECTED)
		{
			pChord->m_fSelected = 1;
		}
        pChord->m_bBeat = iChordSelection.bBeat;
        pChord->m_nMeasure = iChordSelection.wMeasure;
        pChord->m_dwChordPattern = iChordSelection.aChord[0].lChordPattern;
        pChord->m_dwScalePattern = iChordSelection.aChord[0].lScalePattern;
		pChord->m_bRoot = iChordSelection.aChord[0].bRoot;
        pChord->SetBits();
		pChord->m_dwIndex = dwIndex++;
		AddTail(pChord);
    }

ON_ERR:
    return hr;
}

// Save the chordlist to a normal stream
HRESULT CChordList::Save( LPSTREAM pStream, BOOL bClearDirty )
{
    HRESULT     hr;
    DWORD       cb;
    WORD        wSize;
    ioChordSelection iChordSelection;
    CChordItem*   pChord;
    int         i;

    wSize = sizeof( ioChordSelection );
//	FixBytes( FBT_SHORT, &wSize );
    hr = pStream->Write( &wSize, sizeof( wSize ), &cb );
    if( FAILED( hr ) || cb != sizeof( wSize ) )
    {
        return E_FAIL;
    }

	
    for( pChord = GetHead() ; pChord != NULL; pChord = pChord->GetNext() )
    {
        memset( &iChordSelection, 0, sizeof( iChordSelection ) );
        MultiByteToWideChar( CP_ACP, 0, pChord->m_szName, -1, iChordSelection.wstrName, sizeof( iChordSelection.wstrName ) / sizeof( wchar_t ) );
        if( pChord->m_bFlat != 0 )
        {
            iChordSelection.fCSFlags |= CSF_FLAT;
        }
		if( pChord->m_fSelected)
		{
			iChordSelection.fCSFlags |= CSF_SELECTED;
		}
/* not available in CChordItem
        if( pChord->inscale != 0 )
        {
            iChordSelection.fCSFlags |= CSF_INSCALE;
        }
        if( pChord->keydown != 0 )
        {
            iChordSelection.fCSFlags |= CSF_KEYDOWN;
        }
        if( ( pChord->bits & CHORD_SIMPLE ) != 0 )
        {
            iChordSelection.fCSFlags |= CSF_SIMPLE;
        }
*/
        iChordSelection.bBeat = pChord->m_bBeat;
        iChordSelection.wMeasure = pChord->m_nMeasure;
        for( i = 0 ; i < 4 ; ++i )
        {
            iChordSelection.aChord[i].lChordPattern = pChord->m_dwChordPattern;
            iChordSelection.aChord[i].lScalePattern = pChord->m_dwScalePattern;
/* not available in CChordItem
            iChordSelection.aChord[i].lInvertPattern = ~0;
*/
            iChordSelection.aChord[i].bRoot = pChord->m_bRoot;
        }
//		FixBytes( FBT_IOCHORDSELECTION, &iChordSelection );
        if( FAILED( pStream->Write( &iChordSelection, sizeof( iChordSelection), &cb ) ) ||
            cb != sizeof( iChordSelection ) )
        {
			hr = E_FAIL;
			break;
        }
    }
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\CommandStripMgr\CommandMgr.cpp ===
// CommandMgr.cpp : Implementation of CCommandMgr
#include "stdafx.h"
#include "CommandStripMgr.h"
#include "CommandMgr.h"
#include "FileIO.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "RiffStrm.h"
#include "SegmentGuids.h"
#include "SegmentIO.h"

/////////////////////////////////////////////////////////////////////////////
// CCommandMgr
CCommandMgr::CCommandMgr()
{
	m_pTimeline				= NULL;
	m_pCommandList			= NULL;
	m_pMeasureArray			= NULL;
	m_pIPageManager			= NULL;
	m_pDragDataObject		= NULL;
	m_pCopyDataObject		= NULL;
	m_bSelected				= FALSE;
	ZeroMemory( &m_PPGCommand, sizeof( PPGCommand ) );
	m_nMeasures				= 0;
	m_lShiftFromMeasure		= 0;
	m_pCommandStrip			= 0;
	m_dwGroupBits			= 1;
	m_dwOldGroupBits		= 1;
	m_dwTrackExtrasFlags	= DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;
	m_dwProducerOnlyFlags	= 0;
	m_pIDMTrack				= NULL;
	m_pTempIStream			= NULL;
}

CCommandMgr::~CCommandMgr()
{
	ClearCommandList( m_pCommandList );

	if( m_pMeasureArray != NULL )
	{
		delete [] m_pMeasureArray;
	}

	if( m_pIPageManager != NULL )
	{
		m_pIPageManager->Release();
		m_pIPageManager = NULL;
	}
	if( m_pTempIStream )
	{
		m_pTempIStream->Release();
	}
	if( m_pIDMTrack )
	{
		m_pIDMTrack->Release();
	}
	if( m_pDragDataObject )
	{
		m_pDragDataObject->Release();
		m_pDragDataObject = NULL;
	}
	if( m_pCopyDataObject )
	{
		if( S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}
	if( m_pCommandStrip )
	{
		m_pCommandStrip->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCommandMgr IDMUSProdStripMgr

HRESULT STDMETHODCALLTYPE CCommandMgr::GetParam(
		/* [in] */  REFGUID		guidType,
		/* [in] */  MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME*	pmtNext,
		/* [out] */ void*		pData)
{
	UNREFERENCED_PARAMETER(mtTime);
	UNREFERENCED_PARAMETER(pmtNext);
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(::IsEqualGUID(guidType, GUID_Segment_Undo_BSTR))
	{
		BSTR bstr;
		CString str;
		str.LoadString(m_pCommandStrip->m_nLastEdit);
		try
		{
			bstr = str.AllocSysString();
		}
		catch(CMemoryException*)
		{
			return E_OUTOFMEMORY;
		}
		*(BSTR*)pData = bstr;
		return S_OK;
	}
	return E_INVALIDARG;
}

HRESULT STDMETHODCALLTYPE CCommandMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	UNREFERENCED_PARAMETER(guidType);
	UNREFERENCED_PARAMETER(mtTime);
	UNREFERENCED_PARAMETER(pData);
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CCommandMgr::IsParamSupported(
		/* [in] */ REFGUID		guidType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(::IsEqualGUID(guidType, GUID_Segment_Undo_BSTR))
	{
		return S_OK;
	}
	return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CCommandMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwGroupBits);
	UNREFERENCED_PARAMETER(pData);
	HRESULT hr = S_OK;
	if(::IsEqualGUID(rguidType, GUID_Segment_Length_Change))
	{
		hr = ResizeMeasureArray();
		if(hr == S_OK)
		{
			m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)m_pCommandStrip, NULL, TRUE);
		}
		UpdateSegment();
	}
	else if(::IsEqualGUID(rguidType, GUID_Segment_AllTracksAdded))
	{
		// Make sure measure array is the correct size
		hr = VerifyMeasureArray();
		if( FAILED ( hr ) )
		{
			return hr;
		}
		m_pCommandStrip->m_fInAllTracksAdded = TRUE;
		ResizeMeasureArray();
		m_pCommandStrip->m_fInAllTracksAdded = FALSE;
		// Load stream (deferred load)
		if( m_pTempIStream )
		{
			//seek to beginning
			LARGE_INTEGER	liTemp;
			liTemp.QuadPart = 0;
			m_pTempIStream->Seek(liTemp, STREAM_SEEK_SET, NULL);	//seek to beginning
			Load( m_pTempIStream );
			// After we've initialized ourself, we should never need to re-initialize
			m_pTempIStream->Release();
			m_pTempIStream = NULL;
		}
		// Sync with DirectMusic
		if( m_pIDMTrack )
		{
			SyncWithDirectMusic();
		}
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CCommandMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

		/* Unsupported
	case SMP_IDMUSPRODFRAMEWORK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pDMProdFramework )
		{
			return m_pDMProdFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;
		*/

	case SMP_DMUSIOTRACKHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackHeader->guidClassID = CLSID_DirectMusicCommandTrack;
			pioTrackHeader->dwPosition = 0;
			pioTrackHeader->dwGroup = m_dwGroupBits;
			pioTrackHeader->ckid = DMUS_FOURCC_COMMANDTRACK_CHUNK;
			pioTrackHeader->fccType = NULL;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER_MASK:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = TRACKCONFIG_VALID_MASK;
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( pVariant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			pioProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CCommandMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}

		// If we were previously attached to a timeline, remove our PropPageObject and strip from it
		if(m_pTimeline)
		{
			m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject *)this);
			if( m_pCommandStrip )
			{
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject *)m_pCommandStrip);
				m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pCommandStrip );
				m_pCommandStrip->Release();
				m_pCommandStrip = NULL;
			}
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Length_Change, m_dwOldGroupBits);
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwOldGroupBits);
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}

		if( V_UNKNOWN( &variant ) )
		{
			if ( FAILED(V_UNKNOWN( &variant )->QueryInterface(IID_IDMUSProdTimeline, (void**)&m_pTimeline) ) )
			{
				return E_FAIL;
			}
			else
			{
				// Only support handling one strip at a time
				if ( m_pCommandStrip )
				{
					return E_FAIL;
				}

				// Create a strip and add it to the timeline
				m_pCommandStrip = new CCommandStrip(this);
				if( !m_pCommandStrip )
				{
					return E_OUTOFMEMORY;
				}

				m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pCommandStrip, CLSID_DirectMusicCommandTrack, m_dwGroupBits, 0 );
				m_pTimeline->AddToNotifyList((IDMUSProdStripMgr *)this, GUID_Segment_Length_Change, m_dwGroupBits);
				m_pTimeline->AddToNotifyList((IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits);
			}
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
		}
		if( V_UNKNOWN( &variant ) )
		{
			V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack );
		}
		else
		{
			m_pIDMTrack = NULL;
		}
		break;

		/* Not implemented
	case SMP_IDMUSPRODFRAMEWORK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pDMProdFramework )
		{
			m_pDMProdFramework->Release();
			m_pDMProdFramework = NULL;
		}
		if( V_UNKNOWN( &variant ) )
		{
			return V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMProdFramework);
		}
		break;
		*/

	case SMP_DMUSIOTRACKHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwOldGroupBits = m_dwGroupBits;
			m_dwGroupBits = pioTrackHeader->dwGroup;
			if(m_pCommandStrip)
				m_pCommandStrip->m_nLastEdit = IDS_UNDO_TRACKGROUP;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
		}
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( &variant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			m_dwProducerOnlyFlags = pioProducerOnlyChunk->dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCommandMgr IPersist

HRESULT CCommandMgr::GetClassID( CLSID* pClsId )
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pClsId);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CCommandMgr IPersistStream functions

HRESULT CCommandMgr::IsDirty()
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	// BUGBUG: Should implement
	return S_FALSE;
}

HRESULT CCommandMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	// If the strip hasn't been added to the timeline, save the stream until it
	// is added to the Timeline.
	if( m_pTimeline == NULL )
	{
		if( m_pTempIStream )
		{
			m_pTempIStream->Release();
		}
		if( SUCCEEDED( CreateStreamOnHGlobal( NULL, TRUE, &m_pTempIStream ) ) )
		{
			STATSTG StatStg;
			if ( SUCCEEDED( pIStream->Stat( &StatStg, STATFLAG_NONAME ) ) )
			{
				if( SUCCEEDED( pIStream->CopyTo( m_pTempIStream, StatStg.cbSize, NULL, NULL ) ) )
				{
					if( m_pIDMTrack )
					{
						IPersistStream* pIPersistStream;
						if( SUCCEEDED( m_pIDMTrack->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream ) ) )
						{
							//seek to beginning
							LARGE_INTEGER	liTemp;
							liTemp.QuadPart = 0;
							m_pTempIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );
							pIPersistStream->Load( m_pTempIStream );
							pIPersistStream->Release();
						}
					}
					return S_OK;
				}
				else
				{
					TRACE("Segment: Unable to copy to memory stream\n");
					m_pTempIStream->Release();
					return E_FAIL;
				}
			}
			else
			{
				TRACE("Segment: Unable to stat stream\n");
				m_pTempIStream->Release();
				return E_FAIL;
			}
		}
		else
		{
			TRACE("Segment: Unable to create memory stream\n");
			return E_FAIL;
		}
	}

	VARIANT var;
	long	lMeasureLength;
	long	lTimeLength;

	// Clear the list in case the clocks per measure has changed.
	ClearCommandList( m_pCommandList, FALSE );
	m_pCommandList = NULL;
	// Get the length of the timeline and make sure that m_nMeasures and m_lShiftFromMeasure
	// are accurate.

	/*
	// Don't call load until the strip has been added to the timeline
	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}
	*/
	m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	lTimeLength = V_I4( &var );
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lTimeLength, &lMeasureLength, NULL );
	// Ensure lMeasureLength is at least 1
	lMeasureLength = max( 1, lMeasureLength );
	if( m_nMeasures != (short) lMeasureLength )
	{
		if( m_pMeasureArray != NULL )
		{
			delete [] m_pMeasureArray;
			m_pMeasureArray = NULL;
		}

		m_pMeasureArray = new CommandMeasureInfo[lMeasureLength];
		if( m_pMeasureArray == NULL)
		{
			return E_OUTOFMEMORY;
		}
		m_nMeasures = (short) lMeasureLength;
		// Initialize the array.
		for( short n = 0; n < m_nMeasures; n++ )
		{
			m_pMeasureArray[n].dwFlags = 0;
			m_pMeasureArray[n].pCommand = NULL;
		}

		if( m_lShiftFromMeasure >= m_nMeasures )
		{
			m_lShiftFromMeasure = m_nMeasures - 1;
		}
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Check for Direct Music format
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	MMCKINFO	ck;
	DWORD		dwByteCount;

	// Load the Track
	while( pIRiffStream->Descend( &ck, NULL, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case mmioFOURCC('c','m','n','d'):
			{
				DWORD dwCommandSize;

				hr = pIStream->Read( &dwCommandSize, sizeof(DWORD), &dwByteCount );
				if(FAILED(hr) || dwByteCount != sizeof(DWORD))
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// Compute amount to skip between each command
				DWORD dwSkip = max( 0, dwCommandSize - sizeof( DMUS_IO_COMMAND ) );

				// Compute amount of each command to read
				dwCommandSize = min( dwCommandSize, sizeof( DMUS_IO_COMMAND ) );

				long lLength;
				lLength = ck.cksize - sizeof(DWORD);

				while( lLength > 0 )
				{
					DMUS_IO_COMMAND iCommand;

					ZeroMemory( &iCommand, sizeof( DMUS_IO_COMMAND ) );
					hr = pIStream->Read( &iCommand, dwCommandSize, &dwByteCount );
					if(FAILED(hr) || dwByteCount != dwCommandSize)
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}
					lLength -= dwCommandSize;

					if(iCommand.wMeasure >= m_nMeasures)
					{
						break;
					}

					// If there is data to skip, skip it
					if( dwSkip )
					{
						hr = StreamSeek( pIStream, dwSkip, SEEK_CUR );
						if( FAILED(hr) )
						{
							goto ON_ERROR;
						}
					}

					ASSERT( m_pMeasureArray[iCommand.wMeasure].pCommand == NULL );
					m_pMeasureArray[iCommand.wMeasure].pCommand = new CommandExt;
					if( m_pMeasureArray[iCommand.wMeasure].pCommand == NULL )
					{
						hr = E_OUTOFMEMORY;
						goto ON_ERROR;
					}
					m_pMeasureArray[iCommand.wMeasure].pCommand->lTime		= iCommand.mtTime;
					m_pMeasureArray[iCommand.wMeasure].pCommand->bCommand	= iCommand.bCommand;
					m_pMeasureArray[iCommand.wMeasure].pCommand->bGrooveLevel = iCommand.bGrooveLevel;
					if( iCommand.bGrooveRange > 100 )
					{
						m_pMeasureArray[iCommand.wMeasure].pCommand->bGrooveRange = 0;
					}
					else
					{
						m_pMeasureArray[iCommand.wMeasure].pCommand->bGrooveRange = iCommand.bGrooveRange;
					}
					if( iCommand.bRepeatMode > DMUS_PATTERNT_RANDOM_ROW )
					{
						m_pMeasureArray[iCommand.wMeasure].pCommand->bRepeatMode = 0;
					}
					else
					{
						m_pMeasureArray[iCommand.wMeasure].pCommand->bRepeatMode = iCommand.bRepeatMode;
					}
				}
				break;
			}
		}
		pIRiffStream->Ascend( &ck, 0 );
	}

	// Update the "next" pointers
	m_pCommandList = NULL;
	CommandExt*	pCE;
	pCE = NULL;
	int n;
	for( n = 0; n < m_nMeasures; n++ )
	{
		if( m_pMeasureArray[n].pCommand != NULL )
		{
			if( m_pCommandList == NULL )
			{
				m_pCommandList = m_pMeasureArray[n].pCommand;
			}
			else
			{
				pCE->pNext = m_pMeasureArray[n].pCommand;
			}
			pCE = m_pMeasureArray[n].pCommand;
			pCE->pNext = NULL;
		}
	}

	// Update the property page and the object we represent.
	if( m_pIPageManager != NULL )
	{
		m_pIPageManager->RefreshData();
	}

ON_ERROR:
	pIRiffStream->Release();;
	return hr;
}


HRESULT CCommandMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(fClearDirty);
	HRESULT hr;
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	//ASSERT(m_pMeasureArray != NULL );
	hr = VerifyMeasureArray();
	if (FAILED(hr)) return hr;

	if( NULL == pIStream )
	{
		return E_INVALIDARG;
	}

    MMCKINFO ck;
	IDMUSProdRIFFStream* pIRiffStream;
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	ck.ckid = mmioFOURCC( 'c', 'm', 'n', 'd' );
	hr = pIRiffStream->CreateChunk( &ck, 0 );
    if( hr == S_OK )
    {
		hr = SaveCommandList( pIStream, FALSE );
		// Always ascend.
		pIRiffStream->Ascend( &ck, 0 );
	}
	pIRiffStream->Release();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CCommandMgr::SyncWithDirectMusic

HRESULT CCommandMgr::SyncWithDirectMusic(  )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	IDMUSProdFramework *pIFramework = NULL;
	VARIANT var;
	m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	if( var.vt == VT_UNKNOWN )
	{
		IUnknown *punk;
		punk = V_UNKNOWN( &var );
		if( punk )
		{
			if( SUCCEEDED( punk->QueryInterface( IID_IDMUSProdFramework, (void**)&pIFramework ) ) )
			{

				// 1. persist the strip to a stream
				IStream* pIMemStream = NULL;
				IPersistStream* pIPersistStream = NULL;
				hr = pIFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream );
				if( SUCCEEDED ( hr ) )
				{
					StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
					hr = Save(pIMemStream, FALSE);
					if (SUCCEEDED(hr))
					{
						hr = m_pIDMTrack->QueryInterface(IID_IPersistStream, (void**)&pIPersistStream);
						if (SUCCEEDED(hr))
						{
							StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
							// 2. Load the stream into the track.
							hr = pIPersistStream->Load(pIMemStream);
							pIPersistStream->Release();
						}
					}
					pIMemStream->Release();
				}
				pIFramework->Release();
			}
			punk->Release();
		}
	}

	return hr;
}


HRESULT CCommandMgr::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pcbSize);
	return E_NOTIMPL;
}


HRESULT CCommandMgr::VerifyMeasureArray()
{
	VARIANT var;
	long	lMeasureLength;
	long	lTimeLength;

	if (m_pMeasureArray == NULL)
	{
		m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
		lTimeLength = V_I4( &var );
		m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lTimeLength, &lMeasureLength, NULL );
		// Ensure lMeasureLength is at least 1
		lMeasureLength = max( 1, lMeasureLength );

		m_pMeasureArray = new CommandMeasureInfo[lMeasureLength];
		if( m_pMeasureArray == NULL)
		{
			return E_OUTOFMEMORY;
		}
		m_nMeasures = (short) lMeasureLength;
		// Initialize the array.
		for( short n = 0; n < m_nMeasures; n++ )
		{
			m_pMeasureArray[n].dwFlags = 0;
			m_pMeasureArray[n].pCommand = NULL;
		}

		if( m_lShiftFromMeasure >= m_nMeasures )
		{
			m_lShiftFromMeasure = m_nMeasures - 1;
		}
	}
	return S_OK;
}
	
/////////////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageObject functions

HRESULT STDMETHODCALLTYPE CCommandMgr::GetData( /* [retval][out] */ void** ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	bool fValid = false;
	short n;

	//ASSERT(m_pMeasureArray != NULL );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return hr;

	m_PPGCommand.dwValid = 0;

	if( m_bSelected )
	{
		// Set the fields of the PPGCommand
		for( n = 0; n < m_nMeasures; n++ )
		{
			if( m_pMeasureArray[n].dwFlags & CMI_SELECTED )
			{
				if( m_pMeasureArray[n].pCommand != NULL )
				{
					if( !fValid )
					{
						m_PPGCommand.dwValid	= VALID_COMMAND | VALID_GROOVE | VALID_GROOVERANGE | VALID_REPEATMODE;
						m_PPGCommand.bCommand	= m_pMeasureArray[n].pCommand->bCommand;
						m_PPGCommand.bGrooveLevel	= m_pMeasureArray[n].pCommand->bGrooveLevel;
						m_PPGCommand.bGrooveRange	= m_pMeasureArray[n].pCommand->bGrooveRange;
						m_PPGCommand.bRepeatMode	= m_pMeasureArray[n].pCommand->bRepeatMode;
						fValid = true;
					}
					else
					{
						 if( m_PPGCommand.dwValid & VALID_COMMAND )
						 {
							 if( m_PPGCommand.bCommand != m_pMeasureArray[n].pCommand->bCommand)
							 {
								 m_PPGCommand.dwValid &= ~VALID_COMMAND;
							 }
						 }
						 if( m_PPGCommand.dwValid & VALID_GROOVE )
						 {
							 if( m_PPGCommand.bGrooveLevel != m_pMeasureArray[n].pCommand->bGrooveLevel )
							 {
								 m_PPGCommand.dwValid &= ~VALID_GROOVE;
							 }
						 }
						 if( m_PPGCommand.dwValid & VALID_GROOVERANGE )
						 {
							 if( m_PPGCommand.bGrooveRange != m_pMeasureArray[n].pCommand->bGrooveRange )
							 {
								 m_PPGCommand.dwValid &= ~VALID_GROOVERANGE;
							 }
						 }
						 if( m_PPGCommand.dwValid & VALID_REPEATMODE )
						 {
							 if( m_PPGCommand.bRepeatMode != m_pMeasureArray[n].pCommand->bRepeatMode )
							 {
								 m_PPGCommand.dwValid &= ~VALID_REPEATMODE;
							 }
						 }
						 if( m_PPGCommand.dwValid == 0 )
						 {
							 break;
						 }
					}
				}
				else if( !fValid )
				{
					fValid = TRUE;
					m_PPGCommand.dwValid = VALID_COMMAND | VALID_GROOVE | VALID_GROOVERANGE | VALID_REPEATMODE;
					m_PPGCommand.bCommand = 0;
					m_PPGCommand.bGrooveLevel = 0;
					m_PPGCommand.bGrooveRange = 0;
					m_PPGCommand.bRepeatMode = 0;
				}
				else
				{
					if( (m_PPGCommand.dwValid & VALID_COMMAND)
					&&	(m_PPGCommand.bCommand != 0) )
					{
						m_PPGCommand.dwValid &= ~VALID_COMMAND;
					}
					if( (m_PPGCommand.dwValid & VALID_GROOVE)
					&&	(m_PPGCommand.bGrooveLevel != 0 ) )
					{
						m_PPGCommand.dwValid &= ~VALID_GROOVE;
					}
					if( (m_PPGCommand.dwValid & VALID_GROOVERANGE)
					&&	(m_PPGCommand.bGrooveRange != 0 ) )
					{
						m_PPGCommand.dwValid &= ~VALID_GROOVERANGE;
					}
					if( (m_PPGCommand.dwValid & VALID_REPEATMODE)
					&&	(m_PPGCommand.bRepeatMode != 0 ) )
					{
						m_PPGCommand.dwValid &= ~VALID_REPEATMODE;
					}
					m_PPGCommand.bCommand = 0;
					m_PPGCommand.bGrooveLevel = 0;
					m_PPGCommand.bGrooveRange = 0;
					m_PPGCommand.bRepeatMode = 0;
				}		
			}
		}
		*ppData = &m_PPGCommand;
	}
	else
	{
		*ppData = NULL;
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CCommandMgr::SetData( /* [in] */ void* pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CommandExt*	pCE;
	BOOL		bValid = FALSE;
	BYTE		bCommand;
	BYTE		bGrooveLevel;
    BYTE        bGrooveRange;
    BYTE        bRepeatMode;
	short		n;

	m_pCommandStrip->m_nLastEdit = 0;

	if( pData == NULL )
	{
		return E_INVALIDARG;
	}

	ASSERT( m_bSelected && m_pMeasureArray != NULL && m_pTimeline != NULL );
	if( !m_bSelected || m_pMeasureArray == NULL || m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	memcpy( &m_PPGCommand, pData, sizeof( PPGCommand ));

	if( (m_PPGCommand.dwValid == ( VALID_COMMAND | VALID_GROOVE | VALID_GROOVERANGE | VALID_REPEATMODE ))
	&&	(m_PPGCommand.bCommand == 0)
	&&	(m_PPGCommand.bGrooveLevel == 0)
	&&	(m_PPGCommand.bGrooveRange == 0)
	&&	(m_PPGCommand.bRepeatMode == 0) )
	{
		// Delete the selected items
		m_pCommandStrip->m_nLastEdit = IDS_DELETE;
		DeleteSelected();

		// Update the segment and DirectMusic track with the new data
		UpdateSegment();

		// Refresh the display
		m_pTimeline->StripInvalidateRect( m_pCommandStrip, NULL, FALSE );

		return S_OK;
	}

	// Apply the changes to the selected measures.
	for( n = 0; n < m_nMeasures; n++ )
	{
 		bool bNewGroove = false;
		if( m_pMeasureArray[n].dwFlags & CMI_SELECTED )
		{
			if( m_pMeasureArray[n].pCommand != NULL )
			{
				bCommand = m_pMeasureArray[n].pCommand->bCommand;
				bGrooveLevel = m_pMeasureArray[n].pCommand->bGrooveLevel;
				bGrooveRange = m_pMeasureArray[n].pCommand->bGrooveRange;
				bRepeatMode = m_pMeasureArray[n].pCommand->bRepeatMode;
				if( (bCommand == 0) && (bGrooveLevel == 0) && (bGrooveRange == 0) && (bRepeatMode == 0) )
				{
					bNewGroove = true;
				}
			}
			else
			{
				bCommand = 0;
				bGrooveLevel = 0;
				bGrooveRange = 0;
				bRepeatMode = 0;
				bNewGroove = true;
			}

			// Get the command for this measure.
			if( m_PPGCommand.dwValid & VALID_COMMAND )
			{
				bCommand =  m_PPGCommand.bCommand;
			}
			if( m_PPGCommand.dwValid & VALID_GROOVE )
			{
				bGrooveLevel = m_PPGCommand.bGrooveLevel;
			}
			if( m_PPGCommand.dwValid & VALID_GROOVERANGE )
			{
				bGrooveRange = m_PPGCommand.bGrooveRange;
			}
			if( m_PPGCommand.dwValid & VALID_REPEATMODE )
			{
				bRepeatMode = m_PPGCommand.bRepeatMode;
			}

			// Update the measure.
			if( (bCommand == 0) && (bGrooveLevel == 0) && (bGrooveRange == 0) && (bRepeatMode == 0)
			&&	(m_pMeasureArray[n].pCommand != NULL) )
			{
				delete m_pMeasureArray[n].pCommand;
				m_pMeasureArray[n].pCommand = NULL;
				m_pCommandStrip->m_nLastEdit = IDS_DELETE;
			}
			else if( (bCommand != 0) || (bGrooveLevel != 0) || (bGrooveRange != 0) || (bRepeatMode != 0) )
			{
				if(bNewGroove)
				{
					m_pCommandStrip->m_nLastEdit = IDS_INSERT;
				}
				else
				{
					m_pCommandStrip->m_nLastEdit = IDS_CHANGE;
				}
				if( m_pMeasureArray[n].pCommand == NULL )
				{
					m_pMeasureArray[n].pCommand = new CommandExt;
					if( m_pMeasureArray[n].pCommand == NULL )
					{
						m_pCommandStrip->m_nLastEdit = NULL;
						return E_OUTOFMEMORY;
					}
					m_pCommandStrip->m_nLastEdit = IDS_INSERT;
				}
				m_pMeasureArray[n].pCommand->bCommand = bCommand;
				m_pMeasureArray[n].pCommand->bGrooveLevel = bGrooveLevel;
				m_pMeasureArray[n].pCommand->bGrooveRange = bGrooveRange;
				m_pMeasureArray[n].pCommand->bRepeatMode = bRepeatMode;
				m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, (long)n, 0, &( m_pMeasureArray[n].pCommand->lTime ));
			}
			bValid = TRUE;
		}
	}

	// Update the "next" pointers
	m_pCommandList = NULL;
	pCE = NULL;
	for( n = 0; n < m_nMeasures; n++ )
	{
		if( m_pMeasureArray[n].pCommand != NULL )
		{
			if( m_pCommandList == NULL )
			{
				m_pCommandList = m_pMeasureArray[n].pCommand;
			}
			else
			{
				pCE->pNext = m_pMeasureArray[n].pCommand;
			}
			pCE = m_pMeasureArray[n].pCommand;
			pCE->pNext = NULL;
		}
	}

	ASSERT( bValid );
	if( !bValid )
	{
		return E_UNEXPECTED;
	}

	m_pTimeline->StripInvalidateRect( m_pCommandStrip, NULL, FALSE );

	// Let the object know about the changes
	UpdateSegment();
	return S_OK;
}

HRESULT CCommandMgr::OnShowProperties(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;
	if( m_pIPageManager == NULL )
	{
		CCommandPPGMgr *pPPM = new CCommandPPGMgr;
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pIPageManager );
		m_pIPageManager->Release(); // this releases the 2nd ref, leaving only one
		if( FAILED( hr ))
		{
			return hr;
		}
	}
	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}
	m_pTimeline->SetPropertyPage( m_pIPageManager, (IDMUSProdPropPageObject*)this );
	m_pIPageManager->RefreshData();
	return hr;
}

HRESULT CCommandMgr::OnRemoveFromPageManager(void)
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// BUGBUG: Should we do something here?
	return S_OK;
}

HRESULT CCommandMgr::SaveCommandList( IStream* pStream, BOOL bOnlySelected )
{
	return SaveDroppedCommandList( pStream, bOnlySelected, 0 );
	/*
	HRESULT		hr;
    DWORD		dwSizeCommand;
	DWORD		cb;
    DMUS_IO_COMMAND	iCommand;

	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	//ASSERT(m_pMeasureArray != NULL );
	hr = VerifyMeasureArray();
	if (FAILED(hr)) return hr;

	if( NULL == pStream )
	{
		return E_POINTER;
	}

	// Write the size of the command structure
	dwSizeCommand = sizeof( DMUS_IO_COMMAND );
	hr = pStream->Write( &dwSizeCommand, sizeof( dwSizeCommand ), &cb );
    if( FAILED( hr ) || cb != sizeof( dwSizeCommand ))
	{
		return E_FAIL;
	}

	// Write the commands
	for( short n = 0; n < m_nMeasures; n++ )
	{
		ZeroMemory( &iCommand, sizeof( DMUS_IO_COMMAND ) );
		iCommand.wMeasure = n;
		m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, iCommand.wMeasure, 0, &iCommand.mtTime );

		if( m_pMeasureArray[n].pCommand != NULL )
		{
			iCommand.bCommand = m_pMeasureArray[n].pCommand->bCommand;
			iCommand.bGrooveLevel = m_pMeasureArray[n].pCommand->bGrooveLevel;
			iCommand.bGrooveRange = m_pMeasureArray[n].pCommand->bGrooveRange;
			iCommand.bRepeatMode = m_pMeasureArray[n].pCommand->bRepeatMode;
			m_pMeasureArray[n].pCommand->lTime = iCommand.mtTime;
		}

		if(( bOnlySelected && (m_pMeasureArray[n].dwFlags & CMI_SELECTED) ) ||
		   ( !bOnlySelected && (iCommand.bCommand != 0 || iCommand.bGrooveLevel != 0 ||
								iCommand.bGrooveRange != 0 || iCommand.bRepeatMode != 0) ))
		{
			hr = pStream->Write( &iCommand, sizeof( DMUS_IO_COMMAND ), &cb );
			if( FAILED( hr ) || cb != sizeof( DMUS_IO_COMMAND ))
			{
				return E_FAIL;
			}
		}
	}
	return S_OK;
	*/
}

HRESULT CCommandMgr::SaveDroppedCommandList( IStream* pStream, BOOL bOnlySelected, short nOffsetMeasure )
{
	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	//ASSERT(m_pMeasureArray != NULL );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return hr;

	if( NULL == pStream )
	{
		return E_POINTER;
	}

	// Convert nOffsetMeasure into a time offset
	long lTimeOffset;
	m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, nOffsetMeasure, 0, &lTimeOffset );

	// Write the size of the command structure
	DWORD cb, dwSizeCommand = sizeof( DMUS_IO_COMMAND );
	hr = pStream->Write( &dwSizeCommand, sizeof( dwSizeCommand ), &cb );
    if( FAILED( hr ) || cb != sizeof( dwSizeCommand ))
	{
		return E_FAIL;
	}

	// Write the commands
    DMUS_IO_COMMAND	iCommand;
	for( short n = 0; n < m_nMeasures; n++ )
	{
		// Initialize the DMUS_IO_COMMAND structure
		ZeroMemory( &iCommand, sizeof( DMUS_IO_COMMAND ) );
		// Set the measure number
		iCommand.wMeasure	= (WORD) (n - nOffsetMeasure);
		// Convert from a measure number to a time
		m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, n, 0, &iCommand.mtTime );
		// Offset the time of this command
		iCommand.mtTime	-= lTimeOffset;
		// If there is a command, update iCommand with the data from it
		if( m_pMeasureArray[n].pCommand != NULL )
		{
			iCommand.bCommand = m_pMeasureArray[n].pCommand->bCommand;
			iCommand.bGrooveLevel = m_pMeasureArray[n].pCommand->bGrooveLevel;
			iCommand.bGrooveRange = m_pMeasureArray[n].pCommand->bGrooveRange;
			iCommand.bRepeatMode = m_pMeasureArray[n].pCommand->bRepeatMode;
			if( nOffsetMeasure == 0 )
			{
				m_pMeasureArray[n].pCommand->lTime = iCommand.mtTime;
			}
		}

		if(( bOnlySelected && ( m_pMeasureArray[n].dwFlags & CMI_SELECTED )) ||
		   ( !bOnlySelected && (iCommand.bCommand != 0 || iCommand.bGrooveLevel != 0 ||
								iCommand.bGrooveRange != 0 || iCommand.bRepeatMode != 0) ))
		{
			hr = pStream->Write( &iCommand, sizeof( DMUS_IO_COMMAND ), &cb );
			if( FAILED( hr ) || cb != sizeof( DMUS_IO_COMMAND ))
			{
				return E_FAIL;
			}
		}
	}
	return S_OK;
}

void CCommandMgr::ClearCommandList( CommandExt* pCommandList, BOOL bClearSelection )
{
	CommandExt* pCE;

	if( pCommandList == m_pCommandList )
	{
		if( m_nMeasures > 0 )
		{
			//ASSERT(m_pMeasureArray != NULL );
			HRESULT hr = VerifyMeasureArray();
			if (FAILED(hr)) return;
			if( m_pMeasureArray != NULL )
			{
				for( short n = 0; n < m_nMeasures; n++ )
				{
					m_pMeasureArray[n].pCommand = NULL;
					if( bClearSelection )
					{
						m_pMeasureArray[n].dwFlags &= ~CMI_SELECTED;
					}
				}
			}
		}
	}

	while( pCommandList )
	{
		pCE = pCommandList->pNext;
		delete pCommandList;
		pCommandList = pCE;
	}
}

void CCommandMgr::SelectSegment( long lBeginTime, long lEndTime )
{
	long	lBegin;
	long	lEnd;
	long	lMeasure;
	long	lTemp;

	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return;
	}

	//ASSERT(m_pMeasureArray != NULL );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	lTemp = lBeginTime;
	if( lBeginTime == -1 )	// Use shiftfrommeasure
	{
		m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, m_lShiftFromMeasure, 0, &lTemp );
	}

	if( lTemp > lEndTime )
	{
		lBegin	= lEndTime;
		lEnd	= lTemp;
	}
	else
	{
		lBegin	= lTemp;
		lEnd	= lEndTime;
	}

	// Convert lBegin and lEnd to measures.
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lBegin, &lMeasure, NULL );
	lBegin = lMeasure;
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lEnd, &lMeasure, NULL );
	lEnd = lMeasure;

//	ASSERT( lEnd < (long) m_nMeasures );
	if( lEnd >= m_nMeasures )
	{
//		return;
		lEnd = m_nMeasures - 1;	// round up to next higher measure ok unless its the last measure
	}

	// Set the selected flag of the measures in this segment.
	short n;
	for( n = (short) lBegin; n <= (short) lEnd; n++ )
	{
		m_pMeasureArray[n].dwFlags |= CMI_SELECTED;
		m_bSelected = TRUE;
	}
}

HRESULT CCommandMgr::InsertCommand( long lMeasure )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT		hr;
	long		lClocks;
	long		lInsertMeasure;

	lInsertMeasure = lMeasure;
	if( lInsertMeasure == -1 )
	{
		lInsertMeasure = (long) GetFirstSelectedMeasure();
	}

	ASSERT( lInsertMeasure > -1 && lInsertMeasure < (long) m_nMeasures );
	if( lInsertMeasure < 0 || lInsertMeasure >= (long) m_nMeasures )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pTimeline != NULL && m_pMeasureArray != NULL );
	if( m_pTimeline == NULL || m_pMeasureArray == NULL )
	{
		return E_UNEXPECTED;
	}

	if( m_pMeasureArray[lInsertMeasure].pCommand != NULL )
	{
		// Just open the property page.
		OnShowProperties();
		return S_OK;
	}

	m_pMeasureArray[lInsertMeasure].pCommand = new CommandExt;
	if( m_pMeasureArray[lInsertMeasure].pCommand == NULL )
	{
		return E_OUTOFMEMORY;
	}

	ClearSelected();
	m_pMeasureArray[lInsertMeasure].dwFlags |= CMI_SELECTED;
	m_bSelected = TRUE;

	// Update the list pointers.
	short n;

	// Find the previous command.
	for( n = short (lInsertMeasure - 1); n > -1; n-- )
	{
		if( m_pMeasureArray[n].pCommand != NULL )
		{
			break;
		}
	}

	if( n > -1 )
	{
		m_pMeasureArray[n].pCommand->pNext = m_pMeasureArray[lInsertMeasure].pCommand;

		// Find the next command.
		for( n = short (lInsertMeasure + 1); n < m_nMeasures; n++ )
		{
			if( m_pMeasureArray[n].pCommand != NULL )
			{
				break;
			}
		}
		if( n < m_nMeasures )
		{
			m_pMeasureArray[lInsertMeasure].pCommand->pNext = m_pMeasureArray[n].pCommand;
		}
		else
		{
			m_pMeasureArray[lInsertMeasure].pCommand->pNext = NULL;
		}
	}
	else
	{
		/* this doesn't seem right
		ASSERT( m_pCommandList == NULL );
		if( m_pCommandList != NULL )
		{
			return E_UNEXPECTED;
		}
		*/
		CommandExt* pCmd = m_pCommandList;
		m_pCommandList = m_pMeasureArray[lInsertMeasure].pCommand;
		m_pCommandList->pNext = pCmd;
	}

	m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lInsertMeasure, 0, &lClocks );

	// Initialize the command.
	m_pMeasureArray[lInsertMeasure].pCommand->lTime		= lClocks;
	m_pMeasureArray[lInsertMeasure].pCommand->bCommand	= DMUS_COMMANDT_GROOVE;
	m_pMeasureArray[lInsertMeasure].pCommand->bGrooveLevel	= 1;
	m_pMeasureArray[lInsertMeasure].pCommand->bGrooveRange	= 0;
	m_pMeasureArray[lInsertMeasure].pCommand->bRepeatMode	= 0;

	// Get a pointer to the property sheet and show it
	IDMUSProdPropSheet*	pIPropSheet;
	VARIANT			var;
	LPUNKNOWN		punk;

	m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	if( var.vt == VT_UNKNOWN )
	{
		punk = V_UNKNOWN( &var );
		if( punk )
		{
			hr = punk->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
			ASSERT( SUCCEEDED( hr ));
			if( FAILED( hr ))
			{
				return E_UNEXPECTED;
			}
			pIPropSheet->Show( TRUE );
			pIPropSheet->Release();
			punk->Release();
		}
	}
	// Update the property page.
	OnShowProperties();
	return S_OK;
}

void CCommandMgr::ClearSelected()
{
	//ASSERT(m_pMeasureArray != NULL || m_nMeasures == 0 );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	short n;

	for( n = 0; n < m_nMeasures; n++ )
	{
		m_pMeasureArray[n].dwFlags &= ~CMI_SELECTED;
	}

	m_bSelected = FALSE;
}

void CCommandMgr::SelectAll()
{
	//ASSERT(m_pMeasureArray != NULL || m_nMeasures == 0 );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	short n;

	for( n = 0; n < m_nMeasures; n++ )
	{
		m_pMeasureArray[n].dwFlags |= CMI_SELECTED;
	}

	m_bSelected = TRUE;

	if( m_pIPageManager != NULL )
	{
		m_pIPageManager->RefreshData();
	}
}

void CCommandMgr::DeleteSelected()
{
	CommandExt*	pCE = NULL;
	short		n;

	//ASSERT(m_pMeasureArray != NULL || m_nMeasures == 0 );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	for( n = 0; n < m_nMeasures; n++ )
	{
		if( m_pMeasureArray[n].pCommand != NULL )
		{
			if( m_pMeasureArray[n].dwFlags & CMI_SELECTED )
			{
				if( pCE == NULL )
				{
					ASSERT( m_pCommandList == m_pMeasureArray[n].pCommand );
					m_pCommandList = m_pMeasureArray[n].pCommand->pNext;
				}
				else
				{
					ASSERT( pCE->pNext == m_pMeasureArray[n].pCommand );
					pCE->pNext = m_pMeasureArray[n].pCommand->pNext;
				}
				delete m_pMeasureArray[n].pCommand;
				m_pMeasureArray[n].pCommand = NULL;
			}
			else
			{
				pCE = m_pMeasureArray[n].pCommand;
			}
		}
		// Leave the measure selected, so the user can still use the selection.
//		m_pMeasureArray[n].dwFlags &= ~CMI_SELECTED;
	}

	if( m_pIPageManager != NULL )
	{
		m_pIPageManager->RefreshData();
	}
//	UpdateSegment();
}

void CCommandMgr::ToggleSelect( long lMeasure )
{
	//ASSERT(m_pMeasureArray != NULL );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	if( lMeasure >= (long) m_nMeasures )
	{
		return;
	}

	m_pMeasureArray[lMeasure].dwFlags ^= CMI_SELECTED;
	if( m_pMeasureArray[lMeasure].dwFlags & CMI_SELECTED )
	{
		m_bSelected = TRUE;
	}

	if( m_pIPageManager != NULL )
	{
		m_pIPageManager->RefreshData();
	}
}

BOOL CCommandMgr::IsSelected( long lMeasure )
{
	//ASSERT(m_pMeasureArray != NULL );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return FALSE;

	//ASSERT( lMeasure < (long) m_nMeasures );
	if( lMeasure >= (long) m_nMeasures )
	{
		return FALSE;
	}

	return ( m_pMeasureArray[lMeasure].dwFlags & CMI_SELECTED ? TRUE : FALSE );
}

short CCommandMgr::GetFirstSelectedMeasure()
{
	short n;

	if( m_pMeasureArray == NULL )
	{
		return -1;
	}

	for( n = 0; n < m_nMeasures; n++ )
	{
		if( m_pMeasureArray[n].dwFlags & CMI_SELECTED )
		{
			return n;
		}
	}

	return -1;
}

CommandExt* CCommandMgr::GetFirstSelectedCommand()
{
	for( int n = 0; n < m_nMeasures; n++ )
	{
		if( m_pMeasureArray[n].pCommand && (m_pMeasureArray[n].dwFlags & CMI_SELECTED) )
		{
			return m_pMeasureArray[n].pCommand;
		}
	}
	return NULL;
}

void CCommandMgr::GetBoundariesOfSelectedCommands( long *plStart, long *plEnd )
{
	ASSERT( plStart );
	ASSERT( plEnd );

	if( m_pMeasureArray == NULL )
	{
		*plStart = -1;
		*plEnd = -1;
		return;
	}

	BOOL fSetStart = FALSE;
	long lEnd = -1;
	for( int n = 0; n < m_nMeasures; n++ )
	{
		if( m_pMeasureArray[n].dwFlags & CMI_SELECTED )
		{
			if( lEnd < n )
			{
				lEnd = n;
			}
			if( !fSetStart )
			{
				fSetStart = TRUE;
				*plStart = n;
			}
		}
	}

	if( !fSetStart )
	{
		*plStart = -1;
		*plEnd = -1;
	}
	else
	{
		m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, *plStart, 0, plStart );
		m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lEnd, 0, plEnd );
		if( *plEnd <= *plStart )
		{
			*plEnd = *plStart + 1;
		}
	}
}

BOOL CCommandMgr::DeleteBetweenTimes( long lStart, long lEnd )
{
	ASSERT( lStart >=0 );
	ASSERT( lEnd >= 0 );

	BOOL fChanged = FALSE;

	if( SUCCEEDED( m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lStart, &lStart, NULL ) )
	&&  SUCCEEDED( m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lEnd, &lEnd, NULL ) ) )
	{
		lEnd = min( lEnd, (m_nMeasures - 1) );
		CommandExt*	pCE = NULL;
		for( int n=0; n <= lEnd; n++ )
		{
			if( n >= lStart )
			{
				if( m_pMeasureArray[n].pCommand )
				{
					if( pCE == NULL )
					{
						ASSERT( m_pCommandList == m_pMeasureArray[n].pCommand );
						m_pCommandList = m_pMeasureArray[n].pCommand->pNext;
					}
					else
					{
						ASSERT( pCE->pNext == m_pMeasureArray[n].pCommand );
						pCE->pNext = m_pMeasureArray[n].pCommand->pNext;
					}
					delete m_pMeasureArray[n].pCommand;
					m_pMeasureArray[n].pCommand = NULL;
					fChanged = TRUE;
				}
			}
			else
			{
				if( m_pMeasureArray[n].pCommand )
				{
					pCE = m_pMeasureArray[n].pCommand;
				}
			}
		}
	}

	return fChanged;
}

short CCommandMgr::MarkSelectedCommands(DWORD flags)
// returns offset of first measure from zero
{

	short	n;
	BOOL	bFirstTime = TRUE;
	short	nOffset = -1;
	//ASSERT(m_pMeasureArray != NULL || m_nMeasures == 0 );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return 0;

	for( n = 0; n < m_nMeasures; n++ )
	{
		if( m_pMeasureArray[n].dwFlags & CMI_SELECTED )
		{
			if(bFirstTime)
			{
				nOffset = n;
				bFirstTime = FALSE;
			}
			if( m_pMeasureArray[n].pCommand != NULL )
			{
				m_pMeasureArray[n].pCommand->dwDragDrop |= flags;
			}
		}
	}
	return nOffset;
}

void CCommandMgr::DeleteMarkedCommands(DWORD dwFlags)
{
	CommandExt*	pCE = NULL;
	short		n;

	//ASSERT(m_pMeasureArray != NULL || m_nMeasures == 0 );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	for( n = 0; n < m_nMeasures; n++ )
	{
		if( m_pMeasureArray[n].pCommand != NULL )
		{
			if( m_pMeasureArray[n].pCommand->dwDragDrop & dwFlags )
			{
				if( pCE == NULL )
				{
					ASSERT( m_pCommandList == m_pMeasureArray[n].pCommand );
					m_pCommandList = m_pMeasureArray[n].pCommand->pNext;
				}
				else
				{
					ASSERT( pCE->pNext == m_pMeasureArray[n].pCommand );
					pCE->pNext = m_pMeasureArray[n].pCommand->pNext;
				}
				delete m_pMeasureArray[n].pCommand;
				m_pMeasureArray[n].pCommand = NULL;
			}
			else
			{
				pCE = m_pMeasureArray[n].pCommand;
			}
		}
		// Leave the measure selected, so the user can still use the selection.
//		m_pMeasureArray[n].dwFlags &= ~CMI_SELECTED;
	}

	if( m_pIPageManager != NULL )
	{
		m_pIPageManager->RefreshData();
	}
//	UpdateSegment();
}

void CCommandMgr::UnMarkCommands(WORD flags)
{

	short		n;
	//ASSERT(m_pMeasureArray != NULL || m_nMeasures == 0 );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	for( n = 0; n < m_nMeasures; n++ )
	{
		if( m_pMeasureArray[n].pCommand != NULL )
		{
			m_pMeasureArray[n].pCommand->dwDragDrop &= ~flags;
		}
	}

}

void CCommandMgr::MarkAtMeasure(DWORD measure, WORD flags)
{
	//ASSERT(m_pMeasureArray != NULL || m_nMeasures == 0 );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	if(m_pMeasureArray[measure].pCommand != NULL)
	{
		m_pMeasureArray[measure].pCommand->dwDragDrop |= flags;
	}

}

void CCommandMgr::UnMarkAtMeasure(DWORD measure, WORD flags)
{
	//ASSERT(m_pMeasureArray != NULL || m_nMeasures == 0 );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	if(m_pMeasureArray[measure].pCommand != NULL)
	{
		m_pMeasureArray[measure].pCommand->dwDragDrop &= ~flags;
	}

}

HRESULT CCommandMgr::LoadDroppedCommandList( IStream* pStream, long lDropPos, bool fDragging, BOOL &fChanged )
{
	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	//ASSERT(m_pMeasureArray != NULL );
	HRESULT	hr;
	hr = VerifyMeasureArray();
	if (FAILED(hr)) return hr;

	if( NULL == pStream )
	{
		return E_POINTER;
	}

	// Get the size of the stream.
	STATSTG statstg;
	hr = pStream->Stat( &statstg, STATFLAG_NONAME );
	if( FAILED( hr ))
	{
		return hr;
	}

	DWORD cSize;
	cSize = statstg.cbSize.LowPart;

	// Don't seek to the beginning of the stream (command strip data can be embedded)
	//liStreamPos.QuadPart = 0;
	//hr = pStream->Seek( liStreamPos, STREAM_SEEK_SET, NULL );
	//ASSERT( SUCCEEDED( hr ));

	DWORD cb;
	long lDragMeasure = 0;	// measure at which mouse grabbed dragged data
	if( fDragging )
	{
		// load drag pt
		hr = pStream->Read(&lDragMeasure, sizeof( long), &cb);
		if( FAILED( hr ) || cb != sizeof( long ) )
		{
			return E_FAIL;
		}

		cSize -= cb;
	}

    // load size of command structure
	DWORD dwSizeCommand;
    hr = pStream->Read( &dwSizeCommand, sizeof( dwSizeCommand ), &cb );
    if( FAILED( hr ) || cb != sizeof( dwSizeCommand ) )
	{
        return E_FAIL;
	}

	cSize -= cb;

	// Save our current position
	DWORD cSizeOrig = cSize;	// Size of stream
	DWORD cCurPos = StreamTell( pStream );

	long lLastMeasure = LONG_MIN;
	DMUS_IO_COMMAND iCommand;
	LARGE_INTEGER liStreamPos;
	while( cSize >= dwSizeCommand )
	{
		// Read the command struct.
        if( dwSizeCommand > sizeof( DMUS_IO_COMMAND ) )
		{
            hr = pStream->Read( &iCommand, sizeof( DMUS_IO_COMMAND ), &cb );
            if( FAILED( hr ) || cb != sizeof( DMUS_IO_COMMAND ) )
			{
				return E_FAIL;
			}
			// Seek past the extra data.
			liStreamPos.QuadPart = dwSizeCommand - sizeof( DMUS_IO_COMMAND );
			pStream->Seek( liStreamPos, STREAM_SEEK_CUR, NULL );
			if( FAILED( hr ) )
			{
				return E_FAIL;
			}
		}
		else
		{
            hr = pStream->Read( &iCommand, dwSizeCommand, &cb );
            if( FAILED( hr ) || cb != dwSizeCommand )
			{
				return E_FAIL;
			}
		}

		// If this measure is greater than any previous ones, save it
		if( iCommand.wMeasure > lLastMeasure )
		{
			lLastMeasure = iCommand.wMeasure;
		}

		cSize -= dwSizeCommand;
	}

	// Restore our position back to the start of the signposts
	cSize = cSizeOrig;
	StreamSeek( pStream, cCurPos, STREAM_SEEK_SET );

	BOOL bFirstTime = TRUE;
	long lAdjustMeasure = 0;
	long lMeasure;
	while( cSize >= dwSizeCommand )
	{
		// Read the command struct.
        if( dwSizeCommand > sizeof( DMUS_IO_COMMAND ) )
        {
            hr = pStream->Read( &iCommand, sizeof( DMUS_IO_COMMAND ), &cb );
            if( FAILED( hr ) || cb != sizeof( DMUS_IO_COMMAND ) )
            {
                return E_FAIL;
            }
			// Seek past the extra data.
			liStreamPos.QuadPart = dwSizeCommand - sizeof( DMUS_IO_COMMAND );
			pStream->Seek( liStreamPos, STREAM_SEEK_CUR, NULL );
 			if( FAILED( hr ) )
			{
				return E_FAIL;
			}
		}
        else
        {
            hr = pStream->Read( &iCommand, dwSizeCommand, &cb );
            if( FAILED( hr ) || cb != dwSizeCommand )
            {
                return E_FAIL;
            }
        }

        cSize -= dwSizeCommand;

		// If this is a paste, and we are looking at the first command, determine the amount
		// of time the lTime field of each of the commands being inserted should be shifted.
		if( bFirstTime )
		{
			if( !fDragging )
			{
				// Use position of cursor
				long lTime;
				m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime);
				m_pTimeline->ClocksToMeasureBeat(m_dwGroupBits, 0, lTime, &lMeasure, NULL);

				// Adjust the commands so the first one starts in lMeasure
				lAdjustMeasure = lMeasure - iCommand.wMeasure;
			}
			else
			{
				// If drop position is less than or equal to 0, drop in measure 0
				if(lDropPos <= 0)
				{
					lMeasure = 0;
				}
				else
				{
					m_pTimeline->PositionToMeasureBeat(m_dwGroupBits, 0, lDropPos, &lMeasure, NULL );
				}

				// Adjustment is drop measure - drag measure
				lAdjustMeasure = lMeasure - lDragMeasure;
			}

			// Ensure that the last command starts before the end of the segment
			if( lAdjustMeasure + lLastMeasure >= m_nMeasures )
			{
				lAdjustMeasure = m_nMeasures - lLastMeasure - 1;
			}

			// Ensure that the first command starts at or after measure 0
			if( iCommand.wMeasure + lAdjustMeasure < 0 )
			{
				lAdjustMeasure -= iCommand.wMeasure + lAdjustMeasure;
			}

			bFirstTime = FALSE;
			ClearSelected();
		}

		// Adjust the time of the command from the drag and drop measures
		lMeasure = iCommand.wMeasure + lAdjustMeasure;

		// Should be at least 0
		ASSERT( lMeasure >= 0 );
		if(lMeasure < 0)
		{
			lMeasure = 0;
		}

		// Any items that would paste beyond the end of this segment are lost
		if( lMeasure >= (long) m_nMeasures )
		{
			break;
		}

		if( (iCommand.bCommand == 0) && (iCommand.bGrooveLevel == 0)
		&&	(iCommand.bGrooveRange == 0) && (iCommand.bRepeatMode == 0) )
		{
			// If we are dragging a blank measure on top of a measure with a command, delete the command
			if( fDragging && m_pMeasureArray[lMeasure].pCommand != NULL )
			{
				delete m_pMeasureArray[lMeasure].pCommand;
				m_pMeasureArray[lMeasure].pCommand = NULL;
				fChanged = TRUE;
			}
		}
		else
		{
			// If the measure doesn't already have a command, create one
			if( m_pMeasureArray[lMeasure].pCommand == NULL )
			{
				m_pMeasureArray[lMeasure].pCommand = new CommandExt;
				if( m_pMeasureArray[lMeasure].pCommand == NULL )
				{
					return E_OUTOFMEMORY;
				}
			}

			// convert measure to a time
			m_pTimeline->MeasureBeatToClocks(m_dwGroupBits, 0, lMeasure, 0, &iCommand.mtTime);

			m_pMeasureArray[lMeasure].pCommand->lTime		= iCommand.mtTime;
			m_pMeasureArray[lMeasure].pCommand->bCommand	= iCommand.bCommand;
			m_pMeasureArray[lMeasure].pCommand->bGrooveLevel= iCommand.bGrooveLevel;
			m_pMeasureArray[lMeasure].pCommand->bGrooveRange= iCommand.bGrooveRange;
			m_pMeasureArray[lMeasure].pCommand->bRepeatMode	= iCommand.bRepeatMode;
			UnMarkAtMeasure(lMeasure, DRAG_SELECT);
			fChanged = TRUE;
		}

		m_pMeasureArray[lMeasure].dwFlags |= CMI_SELECTED;
		m_bSelected = TRUE;
	} // while( cSize > 0 )

	// Update the "next" pointers
	m_pCommandList = NULL;
	CommandExt* pCE = NULL;
	for( short n = 0; n < m_nMeasures; n++ )
	{
		if( m_pMeasureArray[n].pCommand != NULL )
		{
			if( m_pCommandList == NULL )
			{
				m_pCommandList = m_pMeasureArray[n].pCommand;
			}
			else
			{
				pCE->pNext = m_pMeasureArray[n].pCommand;
			}
			pCE = m_pMeasureArray[n].pCommand;
			pCE->pNext = NULL;
		}
	}

	// Update the property page and the object we represent.
	if( m_pIPageManager != NULL )
	{
		m_pIPageManager->RefreshData();
	}

	return S_OK;
}

void CCommandMgr::UpdateSegment( void )
{
	ASSERT( m_pTimeline );
	if( m_pTimeline )
	{
		m_pTimeline->OnDataChanged( (IDMUSProdStripMgr *)this );
	}

	ASSERT( m_pIDMTrack );
	if( m_pIDMTrack )
	{
		SyncWithDirectMusic();
	}
}

HRESULT CCommandMgr::ResizeMeasureArray()
{
	HRESULT hr = S_OK;
	VARIANT var;
	long	lMeasureLength;
	long	lTimeLength;
	bool	bSmallerNotLarger;
	hr = m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	if(hr != S_OK)
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}
	lTimeLength = V_I4( &var );
	hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lTimeLength, &lMeasureLength, NULL );
	if(hr != S_OK)
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}
	// Ensure lMeasureLength is at least 1
	lMeasureLength = max( 1, lMeasureLength );
	if( m_nMeasures != (short) lMeasureLength )
	{
		bSmallerNotLarger = (short)lMeasureLength < m_nMeasures;
		CommandMeasureInfo* pMeasureArray = new CommandMeasureInfo[lMeasureLength];
		if( m_pMeasureArray == NULL)
		{
			return E_OUTOFMEMORY;
		}
		// copy from the array.
		short nlen = m_nMeasures <= (short)lMeasureLength ? m_nMeasures : (short)lMeasureLength;
		short n = 0;
		for(n = 0; n < nlen; n++)
		{
			pMeasureArray[n].dwFlags = m_pMeasureArray[n].dwFlags;
			pMeasureArray[n].pCommand = m_pMeasureArray[n].pCommand;
		}
		// initialize any remaining new measures 
		// (if lMeasure < m_pMeasureArray, then this for loop never entered)
		for( n = nlen; n < (short)lMeasureLength; n++ )
		{
			pMeasureArray[n].dwFlags = 0;
			pMeasureArray[n].pCommand = NULL;
		}

		m_nMeasures = (short) lMeasureLength;
		delete [] m_pMeasureArray;
		m_pMeasureArray = pMeasureArray;
		if( m_lShiftFromMeasure >= m_nMeasures )
		{
			m_lShiftFromMeasure = m_nMeasures - 1;
		}
		if(hr == S_OK)
		{
			if(bSmallerNotLarger)
			{
				SyncMeasureArray();
			}
			if( m_pCommandStrip->m_fInAllTracksAdded == FALSE )
			{
				UpdateSegment();
			}
		}
	}

	return hr;
}

void CCommandMgr::SyncMeasureArray()
{
	CommandExt	*pSPE;
	RemoveOrphanCommands();
	// Update the "next" pointers
	m_pCommandList = NULL;
	pSPE = NULL;
	for(short n = 0; n < m_nMeasures; n++)
	{
		if(m_pMeasureArray[n].pCommand != NULL)
		{
			if(m_pCommandList == NULL)
			{
				m_pCommandList = m_pMeasureArray[n].pCommand;
			}
			else
			{
				pSPE->pNext = m_pMeasureArray[n].pCommand;
			}
			pSPE = m_pMeasureArray[n].pCommand;
			pSPE->pNext = NULL;
		}
	}
}

void CCommandMgr::RemoveOrphanCommands()
// removes Commands that don't have a corresponding measure
// for purposes of this function, Commands with corresponding measures
// are said to be "legal".
{
	CommandExt* pExt = NULL;
	for(short n = 0; n < m_nMeasures; n++)
	{
		if(m_pMeasureArray[n].pCommand)
		{
			CommandExt* p = new CommandExt;
			memcpy(p, m_pMeasureArray[n].pCommand, sizeof(CommandExt));
			p->pNext = 0;
			m_pMeasureArray[n].pCommand = p;
			if(pExt)
			{
				pExt->pNext = p;
			}
			else
			{
				pExt = p;
			}
		}
	}

	CommandExt* p = m_pCommandList;
	while(p)
	{
		CommandExt* q = p->pNext;
		delete p;
		p = q;
	}
	m_pCommandList = pExt;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ChordStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ChordStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_CHORD              101
#define IDR_CHORDMGR                    102
#define IDD_CHORD_PROPPAGE              105
#define IDS_TRACK_NAME                  105
#define IDS_EDITOR_NAME                 106
#define IDS_PROPPAGE_GROUP_BITS         107
#define IDS_ERR_DELETE_FIRST_CHORD      108
#define IDS_CHORDS_TEXT                 109
#define IDS_MIDI_MODE_TEXT              110
#define IDS_FUNCTION_MODE_TEXT          111
#define IDS_PATTERN_EDITOR_TEXT         112
#define IDS_SHARP_PROPPAGE_TEXT         113
#define IDS_FLAT_PROPPAGE_TEXT          114
#define IDS_GROUPBITS_TITLE             115
#define IDS_KEY_TITLE                   116
#define IDS_KEY_NAME_FORMAT             117
#define IDR_PATTERN_EDITOR_RMENU        201
#define IDC_CHORD_MIDI_IN               202
#define IDC_CHORD_NAME                  203
#define IDC_CHORD_MIDI_IN2              205
#define IDC_SPIN1                       206
#define IDC_ROOT_SPIN                   206
#define IDC_EDIT2                       207
#define IDC_ROOT_TEXT                   207
#define IDC_CHORD_INVERT                208
#define IDC_CHORD_DROPOCTAVE            209
#define IDC_CHORD_FOURNOTES             210
#define IDI_CHORDTRUCK                  210
#define IDC_CHORD_FLAT                  211
#define IDC_TEST                        212
#define IDC_ANIPUSHBUTTON1              215
#define IDC_KEYSOCXCTRL1                216
#define IDC_CHORD_KEYS                  216
#define IDC_KEYSOCXCTRL2                217
#define IDC_SCALE_KEYS                  217
#define IDD_CHORDSCALE_PROPPAGE         221
#define IDD_CHORDINVERSION_PROPPAGE     222
#define IDC_BUTTON_MIDICHORD4           223
#define IDC_EDIT_ROOT                   224
#define IDC_EDIT_NAME                   225
#define IDC_KEYS_SCALE4                 227
#define IDC_KEYS_BASECHORD4             228
#define IDC_KEYS_BASECHORD3             229
#define IDC_KEYS_BASECHORD2             230
#define IDC_KEYS_SCALE3                 231
#define IDC_KEYS_BASECHORD1             232
#define IDC_KEYS_SCALE1                 233
#define IDC_KEYS_SCALE2                 234
#define IDC_KEYS_INVERSIONS4            235
#define IDC_KEYS_CHORD4                 235
#define IDC_KEYS_INVERSIONS3            236
#define IDC_KEYS_CHORD3                 236
#define IDC_KEYS_INVERSIONS2            237
#define IDC_KEYS_CHORD1                 237
#define IDC_KEYS_INVERSIONS1            238
#define IDC_KEYS_CHORD2                 238
#define IDC_BUTTON_INVERT4              239
#define IDC_BUTTON_IPLAY4               240
#define IDC_BUTTON_SHIFTL4              240
#define IDC_BUTTON_IPLAY3               241
#define IDC_BUTTON_IPLAY2               242
#define IDM_DRAG_RMENU                  243
#define IDC_BUTTON_IPLAY1               243
#define IDC_EDIT_IROOT                  244
#define IDC_EDIT_INAME                  245
#define IDC_CHECK_LEGAL4                246
#define IDC_CHECK_LEGAL3                247
#define IDC_USESHARPS                   247
#define IDC_CHECK_LEGAL2                248
#define IDC_USEFLATS                    248
#define IDC_CHECK_LEGAL1                249
#define IDC_SPIN_ROOT                   250
#define IDC_BUTTON_MIDICHORD3           253
#define IDC_BUTTON_MIDICHORD2           255
#define IDC_EDIT_KEY_ROOT               255
#define IDC_DONTWARN                    256
#define IDC_SPIN_KEY_ROOT               256
#define IDC_BUTTON_MIDICHORD1           257
#define IDC_ILLEGALCHORD                257
#define IDC_RADIO_SHARP                 257
#define IDC_RADIO_FLAT                  258
#define IDC_BUTTON_MIDISCALE4           259
#define IDC_STATIC_KEY_ROOT             259
#define IDC_BUTTON_INVERT3              260
#define IDC_BUTTON_INVERT2              261
#define IDC_BUTTON_MIDISCALE3           261
#define IDC_BUTTON_INVERT1              262
#define IDC_BUTTON_MIDISCALE2           263
#define IDC_STATIC_KEY_SIG              263
#define IDC_STATIC_ACCIDENTALS          264
#define IDC_BUTTON_MIDISCALE1           265
#define IDC_BUTTON_SHIFTL3              267
#define IDC_BUTTON_SHIFTL2              268
#define IDC_BUTTON_SHIFTL1              269
#define IDC_BUTTON_SHIFTR1              270
#define IDC_BUTTON_SHIFTR2              271
#define IDC_BUTTON_SHIFTR3              272
#define IDR_CHORDPROP                   272
#define IDC_BUTTON_SHIFTR4              273
#define IDD_ILLEGALCHORD                273
#define IDR_SEGMENT_EDITOR_RMENU        273
#define IDC_BUTTON_PLAY4                274
#define IDD_PROPPAGE_CHORDTRACK_KEY     274
#define IDR_SEGMENT_EDITOR_WITHPTRN_RMENU 274
#define IDC_BUTTON_PLAY3                275
#define IDC_BUTTON_PLAY2                276
#define IDC_BUTTON_PLAY1                277
#define IDC_BUTTON_PLAYALL              279
#define IDC_EDIT_ACCIDENTALS            280
#define IDC_SPIN_ACCIDENTALS            281
#define IDM_CONSTANT_MIDI               400
#define IDM_CONSTANT_FUNCTION           401
#define ID_VIEW_PROPERTIES              32768
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define ID_HIDE_FROM_RHYTHM             32773
#define IDM_LOCK_ALL_SCALES             32774
#define IDM_SYNC_ALL_LEVELS             32775
#define ID_COPY_CHORDSCALE4             32776
#define ID_COPY_SCALE4                  32777
#define ID_COPY_CHORD4                  32778
#define ID_EDIT_PASTE_MERGE             32797
#define ID_EDIT_PASTE_OVERWRITE         32798
#define ID_COPY_CHORD1                  32799
#define ID_COPY_CHORD2                  32800
#define ID_COPY_CHORD3                  32801
#define ID_COPY_CHORDALL                32802
#define ID_COPY_SCALE1                  32803
#define ID_COPY_SCALE2                  32804
#define ID_COPY_SCALE3                  32805
#define IDM_DRAG_MOVE                   32806
#define ID_COPY_CHORDSCALE1             32806
#define IDM_DRAG_CANCEL                 32807
#define ID_COPY_CHORDSCALE2             32807
#define IDM_DRAG_COPY                   32808
#define ID_COPY_CHORDSCALE3             32808
#define ID_COPY_CHORDSCALEALL           32809
#define ID_CLEAR_CHORDSCALE2            32811
#define ID_CLEAR_CHORDSCALE3            32812
#define ID_CLEAR_CHORDSCALE4            32813
#define ID_CLEAR_CHORDSCALEALL          32814
#define ID_COPY_SCALEALL                32815
#define ID_CLEAR_CHORDSCALE1            32816
#define ID_EDIT_DELETE_TRACK            32900
#define ID_EDIT_ADD_TRACK               32901
#define IDS_LEVEL                       57706
#define IDS_ILLEGALCHORD                57709
#define IDS_ILLEGALCHORD2               57710
#define IDS_DONTWARN                    57711
#define IDS_UNDO_PASTE                  57712
#define IDS_UNDO_DELETE                 57713
#define IDS_UNDO_INSERT                 57714
#define IDS_UNDO_CHANGE                 57715
#define IDS_UNDO_TRACK_GROUP            57716
#define IDS_UNDO_MOVE                   57717
#define IDS_UNDO_KEYCHANGE              57718
#define IDS_ILLEGALCHORD3               57719
#define IDS_UNDO_TRACKEXTRAS            57720
#define IDS_UNDO_PRODUCERONLY           57721
#define IDS_UNDO_HIDE_FROM_RHYTHM       57722
#define IDS_UNDO_LOCK_SCALES            57723
#define IDS_UNDO_SYNC_LEVELS            57724

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        282
#define _APS_NEXT_COMMAND_VALUE         32779
#define _APS_NEXT_CONTROL_VALUE         220
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\CommandStripMgr\CommandMgr.h ===
// CommandMgr.h : Declaration of the CCommandMgr

#ifndef __COMMANDMGR_H_
#define __COMMANDMGR_H_

#include "resource.h"       // main symbols
#include <afxcmn.h>
//#include "JazzDataObject.h"
#include "timeline.h"
#include "CommandPPGMgr.h"
#include "FileIO.h"
#include "DllJazzDataObject.h"
#include <dmusici.h>
#include <mmsystem.h>

class CCommandStripMgrApp;
interface IDirectMusicTrack;

extern CCommandStripMgrApp theApp;

#define TRACKCONFIG_VALID_MASK ( DMUS_TRACKCONFIG_NOTIFICATION_ENABLED | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION | DMUS_TRACKCONFIG_CONTROL_ENABLED | DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)

/////////////////////////////////////////////////////////////////////////////
// CCommandStripMgrApp
class CCommandStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

/////////////////////////////////////////////////////////////////////////////
// CCommandMgr
class ATL_NO_VTABLE CCommandMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCommandMgr, &CLSID_CommandMgr>,
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdPropPageObject
{
friend class CCommandStrip;
public:
	CCommandMgr();
	~CCommandMgr();
protected:
	IDMUSProdTimeline*			m_pTimeline;
	struct CommandExt*			m_pCommandList;
	struct CommandMeasureInfo*	m_pMeasureArray;	// CommandMeasureInfo[m_nMeasures]
	IDMUSProdPropPageManager*		m_pIPageManager;
	BOOL						m_bSelected;
	PPGCommand					m_PPGCommand;
	CDllJazzDataObject*			m_pDragDataObject;
	IDataObject*				m_pCopyDataObject;
	long						m_lShiftFromMeasure;
	short						m_nMeasures;
	CCommandStrip*				m_pCommandStrip;	// managed strip

public:

DECLARE_REGISTRY_RESOURCEID(IDR_COMMANDMGR)

BEGIN_COM_MAP(CCommandMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()


// IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

// IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( /* [retval][out] */ void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( /* [in] */ void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

// IDMUSProdStripMgr
public:
	HRESULT STDMETHODCALLTYPE IsParamSupported(
		/* [in] */ REFGUID		guidType);
	HRESULT STDMETHODCALLTYPE GetParam(
		/* [in] */  REFGUID		guidType,
		/* [in] */  MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME*	pmtNext,
		/* [out] */ void*		pData);
	HRESULT STDMETHODCALLTYPE SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData);
	HRESULT STDMETHODCALLTYPE OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData);
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( 
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant);
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( 
		/* [in] */ STRIPMGRPROPERTY smp,
		/* [in] */ VARIANT		variant);

protected:
	HRESULT SyncWithDirectMusic(  );
	HRESULT VerifyMeasureArray();
	HRESULT	LoadCommandList( IStream* pIStream );
	HRESULT	SaveCommandList( IStream* pIStream, BOOL bOnlySelected );
	HRESULT	InsertCommand( long lMeasure );
	void	ClearCommandList( CommandExt* pCommandList, BOOL bClearSelection = TRUE );
	void	SelectSegment( long lBeginTime, long lEndTime );
	void	ClearSelected();
	void	SelectAll();
	void	DeleteSelected();
	void	ToggleSelect( long lMeasure );
	BOOL	IsSelected( long lMeasure );
	short	GetFirstSelectedMeasure();
	CommandExt* GetFirstSelectedCommand();
	void	GetBoundariesOfSelectedCommands( long *plStart, long *plEnd );
	BOOL	DeleteBetweenTimes( long lStart, long lEnd );

	short	MarkSelectedCommands(DWORD flags);
	void	DeleteMarkedCommands(DWORD flags);
	void	UnMarkCommands(WORD flags);
	void	MarkAtMeasure(DWORD measure, WORD flags);
	void	UnMarkAtMeasure(DWORD measure, WORD flags);
	CommandExt*	GetCommandAtMeasure(long lMeasure = -1)
	{
		ASSERT(m_pMeasureArray);
		if(lMeasure >= 0 && lMeasure < m_nMeasures)
		{
			return m_pMeasureArray[lMeasure].pCommand;
		}
		else
		{
			return 0;
		}
	}
	HRESULT LoadDroppedCommandList( IStream* pStream, long lDropPos, bool fDragging, BOOL &fChanged );
	HRESULT	SaveDroppedCommandList( IStream* pIStream, BOOL bOnlySelected, short nOffsetMeasure );

	void UpdateSegment( void );

private:
	void RemoveOrphanCommands();
	void SyncMeasureArray();
	HRESULT ResizeMeasureArray();
	GUID		m_guidClassID;	// Class id of track.
	DWORD		m_dwPosition;	// Position in track list.
	DWORD		m_dwGroupBits;	// Group bits for track. 
	DWORD		m_dwOldGroupBits;
	DWORD		m_dwTrackExtrasFlags;
	DWORD		m_dwProducerOnlyFlags;

	FOURCC      m_ckid;			// chunk ID of track's data chunk if 0 fccType valid
	FOURCC      m_fccType;		// list type if NULL ckid valid
	IDirectMusicTrack*		m_pIDMTrack;
	IStream					*m_pTempIStream;
};

class CCommandStrip : 
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdPropPageObject,
	public IDMUSProdTimelineEdit,
	public IDropSource, 
	public IDropTarget
{
friend class CCommandMgr;
protected:
	long				m_cRef;
	CCommandMgr*		m_pCommandMgr;
	IDMUSProdStripMgr*	m_pStripMgr;
	BOOL				m_fSelected;
	BOOL				m_bSelecting;
	BOOL				m_bContextMenuPaste;
	long				m_lLastFirstMeasure;
	long				m_lBeginSelect;
	long				m_lEndSelect;
	CRect				m_rectInvalid;
	UINT				m_cfFormat;
	enum	{ off, source, target };
	int					m_nDragDropStatus;
	WPARAM				m_wParam;	// save message param for aborted drag/drop completion

	// drag/drop support
	IDataObject*	m_pISourceDataObject;			// Object being dragged	
	IDataObject*	m_pITargetDataObject;
	DWORD			m_dwStartDragButton;	// Mouse button that initiated drag operation
	DWORD			m_dwOverDragButton;		// Mouse button stored in IDropTarget::DragOver
	DWORD			m_dwOverDragEffect;		// Drag effects stored in IDropTarget::DragOver
	CImageList*		m_pDragImage;			// Image used for drag operation feedback
	DWORD			m_dwDragRMenuEffect;	// Result from drag context menu
	UINT			m_cfCommandList;
	LONG			m_startDragPosition;	// xpos where drag was started

	// select support
	BOOL			m_bWasSelected;
	BOOL			m_fInAllTracksAdded;

public:
	CCommandStrip( CCommandMgr* pCommandMgr )
	{
		RECT rect;

		m_nDragDropStatus = off;

		m_bWasSelected = false;

		rect.top = 0;
		rect.bottom = 0;
		rect.left = 0;
		rect.right = 0;
		ASSERT( pCommandMgr );
		m_pCommandMgr = pCommandMgr;
		m_pStripMgr = (IDMUSProdStripMgr*)pCommandMgr;
		if( m_pStripMgr )
		{
			m_pStripMgr->AddRef();
		}
		m_cRef = 0;
		AddRef();
		m_fSelected = FALSE;
		m_bSelecting = FALSE;
		m_bContextMenuPaste = FALSE;
		m_cfFormat = RegisterClipboardFormat( CF_COMMANDLIST );
		m_lLastFirstMeasure = -1;
		m_lBeginSelect = 0;
		m_lEndSelect = 0;
		m_pISourceDataObject = NULL;
		m_pITargetDataObject = NULL;
		m_dwStartDragButton = 0;
		m_dwOverDragButton = 0;
		m_dwOverDragEffect = 0;
		m_pDragImage = NULL;
		m_dwDragRMenuEffect = DROPEFFECT_NONE;
		m_nLastEdit = 0;
		m_fShowGroupProps = FALSE;
		m_fPropPageActive = FALSE;
		m_pPropPageMgr = NULL;
		m_fLButtonDown = FALSE;
		m_fInAllTracksAdded = FALSE;
	};

	~CCommandStrip()
	{
		ASSERT( m_pStripMgr );
		if( m_pStripMgr )
		{
			m_pStripMgr->Release();
		}
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->Release();
		}
	}

// IUnknown
public:
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID *ppv );
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
// IDMUSProdStrip
public:
	HRESULT	STDMETHODCALLTYPE	Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
    HRESULT STDMETHODCALLTYPE	GetStripProperty( STRIPPROPERTY sp, VARIANT* pvar );
    HRESULT STDMETHODCALLTYPE	SetStripProperty( STRIPPROPERTY sp, VARIANT var );
	HRESULT STDMETHODCALLTYPE	OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDropTarget
public:
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
// IDrop helpers
protected:
	HWND	GetTimelineHWND();
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteAt( IDataObject* pIDataObject, long lPastePos, BOOL &fChanged );

// IDropSource
public:
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );

// IDropSource helpers
protected:
	CImageList* CreateDragImage();
	HRESULT		CreateDataObject(IDataObject**, long measure);
	HRESULT		DoDragDrop(WPARAM mousekeybutton, LONG lXPos, long lmeasure);


// IDMUSProdStripFunctionBar
public:
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit
public:
	HRESULT STDMETHODCALLTYPE Cut( /* in */ IDMUSProdTimelineDataObject* pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE Copy( /* in */ IDMUSProdTimelineDataObject* pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE Paste( /* in */ IDMUSProdTimelineDataObject* pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( /* in */ IDMUSProdTimelineDataObject* pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

// Other
protected:
	void SetEnabledItems( HMENU hMenu );
	void UnselectGutterRange( void );

	HRESULT OnRButtonUp( WPARAM wParam, LONG lXPos, LONG lYPos );
	HRESULT OnLButtonUp( WPARAM wParam, LONG lXPos, LONG lYPos );
	HRESULT OnLButtonDown( WPARAM wParam, LONG lXPos, LONG lYPos );
	HRESULT OnMouseMove( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

private:
	HRESULT GiveTimelineFocus( void );
	UINT m_nLastEdit;		// holds string resource id of last edit operation
	HRESULT		OnShowProperties(IDMUSProdTimeline*);
	LONG		m_lXPos;				// used for temp storage of xpos when doing mouse edits
	BOOL		m_fShowGroupProps;		// if TRUE, show Group property page, else show SignPost property page
	BOOL		m_fPropPageActive;		// TRUE if our property page is active
	IDMUSProdPropPageManager*	m_pPropPageMgr;
	BOOL		m_fLButtonDown;			// TRUE if the left mouse button is down

};
#endif //__COMMANDMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\CommandStripMgr\CommandPPG.cpp ===
// CommandPPG.cpp : Implementation of command property page.
//

#include "stdafx.h"
#include "commandstripmgr.h"
#include "CommandPPG.h"
#include <dmusici.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

inline int RepeatModeToIndex( BYTE bRepeatMode )
{
	switch( bRepeatMode )
	{
	case 4:
		return 5;
	case 5:
		return 4;
	default:
		return bRepeatMode;
	}
}

inline BYTE IndexToRepeatMode( int nIndex )
{
	switch( nIndex )
	{
	case 4:
		return 5;
	case 5:
		return 4;
	default:
		return BYTE(nIndex);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCommandPPG property page

IMPLEMENT_DYNCREATE( CCommandPPG, CPropertyPage )

CCommandPPG::CCommandPPG() : CPropertyPage( CCommandPPG::IDD )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_pPageManager = NULL;
	ZeroMemory( &m_PPGCommandData, sizeof(PPGCommand) );
	m_cstrOldLevel = _T("75");  // upper bound of old C groove
	m_bEmbCustom = 100;
	//{{AFX_DATA_INIT(CCommandPPG)
	//}}AFX_DATA_INIT
}

CCommandPPG::~CCommandPPG()
{
}

void CCommandPPG::DoDataExchange( CDataExchange* pDX )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CPropertyPage::DoDataExchange( pDX );
	//{{AFX_DATA_MAP(CCommandPPG)
	DDX_Control(pDX, IDC_COMBO_REPEAT_PATTERN, m_comboRepeatPattern);
	DDX_Control(pDX, IDC_STATIC_EMB_CUSTOM, m_staticEmbCustom);
	DDX_Control(pDX, IDC_SPIN_GROOVE_RANGE, m_spinGrooveRange);
	DDX_Control(pDX, IDC_SPIN_EMB_CUSTOM, m_spinEmbCustom);
	DDX_Control(pDX, IDC_EDIT_GROOVE_RANGE, m_editGrooveRange);
	DDX_Control(pDX, IDC_EDIT_EMB_CUSTOM, m_editEmbCustom);
	DDX_Control(pDX, IDC_CHECK_GROOVE_LEVEL, m_CheckGrooveLevel);
	DDX_Control(pDX, IDC_SPIN_GROOVE_LEVEL, m_spinGrooveLevel);
	DDX_Control(pDX, IDC_EDIT_GROOVE_LEVEL, m_editGrooveLevel);
	DDX_Control(pDX, IDC_COMMAND_EMBELLISHMENTLIST, m_listboxEmbellishment);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP( CCommandPPG, CPropertyPage )
	//{{AFX_MSG_MAP(CCommandPPG)
	ON_LBN_SELCHANGE(IDC_COMMAND_EMBELLISHMENTLIST, OnSelchangeCommandEmbellishmentlist)
	ON_EN_CHANGE(IDC_EDIT_GROOVE_LEVEL, OnChangeEditGrooveLevel)
	ON_BN_CLICKED(IDC_CHECK_GROOVE_LEVEL, OnCheckGrooveLevel)
	ON_EN_CHANGE(IDC_EDIT_GROOVE_RANGE, OnChangeEditGrooveRange)
	ON_CBN_SELCHANGE(IDC_COMBO_REPEAT_PATTERN, OnSelchangeComboRepeatPattern)
	ON_EN_KILLFOCUS(IDC_EDIT_EMB_CUSTOM, OnKillfocusEditEmbCustom)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_EMB_CUSTOM, OnDeltaposSpinEmbCustom)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCommandPPG message handlers

void CCommandPPG::OnSelchangeCommandEmbellishmentlist() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( (m_pPageManager == NULL)
	||	(m_pPageManager->m_pIPropPageObject == NULL) )
	{
		return;
	}

	int iIndex = m_listboxEmbellishment.GetCurSel();
	ASSERT( iIndex >= 0 );

	// Set the embellishment.
	BYTE bNewCommand;
	if( iIndex < 6 )
	{
		if( iIndex == 4 )
		{
			bNewCommand = m_bEmbCustom; // Custom
		}
		else
		{
			static const BYTE abIndexToCommand[6] = {
				DMUS_COMMANDT_INTRO,
				DMUS_COMMANDT_FILL,
				DMUS_COMMANDT_BREAK,
				DMUS_COMMANDT_END,
				0,
				DMUS_COMMANDT_GROOVE };
			bNewCommand = abIndexToCommand[iIndex];
		}
	}
	else
	{
		ASSERT(FALSE);
		return;
	}

	if( !(m_PPGCommandData.dwValid & VALID_COMMAND)
	||	(bNewCommand != m_PPGCommandData.bCommand) )
	{
		m_PPGCommandData.dwValid |= VALID_COMMAND;
		m_PPGCommandData.bCommand = bNewCommand;

		// If custom, ensure the edit control displays the correct data
		if( bNewCommand >= 100 )
		{
			SetDlgItemInt( IDC_EDIT_EMB_CUSTOM, bNewCommand, FALSE );
		}

		// Update the state of the 'Custom Embellishment' controls
		EnableItems( TRUE );

		HRESULT hr = m_pPageManager->m_pIPropPageObject->SetData( &m_PPGCommandData );
		ASSERT( SUCCEEDED( hr ));
		if( S_FALSE == hr )
		{
			// The new data was rejected!
			PPGCommand*	pCommand = NULL;

			hr = m_pPageManager->m_pIPropPageObject->GetData( (void **) &pCommand );
			ASSERT( SUCCEEDED( hr ));
			hr = SetData( pCommand );
			ASSERT( SUCCEEDED( hr ));
		}
	}
}

BOOL CCommandPPG::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CPropertyPage::OnInitDialog();
	
	// Fill the embellishment listbox
	m_listboxEmbellishment.ResetContent();
	CString strEmbellishment;
	for( int iItem = IDS_INTRO_TEXT; iItem <= IDS_NONE_TEXT; iItem++ )
	{
		strEmbellishment.LoadString( iItem );
		m_listboxEmbellishment.AddString( strEmbellishment );
	}

	m_editGrooveLevel.SetWindowText( _T("") );
	m_editGrooveLevel.LimitText( 3 );
	m_spinGrooveLevel.SetRange(1, 100);

	m_editGrooveRange.SetWindowText( _T("") );
	m_editGrooveRange.LimitText( 3 );
	m_spinGrooveRange.SetRange(0, 100);

	m_editEmbCustom.SetWindowText( _T("") );
	m_editEmbCustom.LimitText( 3 );
	m_spinEmbCustom.SetRange(100, 199);

	m_CheckGrooveLevel.SetCheck(BST_UNCHECKED);	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CCommandPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Set the controls in case they have changed since this was last activated
	// and RefreshData has not yet been called.
	SetData( &m_PPGCommandData );

	return CPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
// CCommandPPG additional functions

void CCommandPPG::EnableItems( BOOL fEnable )
{
	// Embellishment list box
	if( IsWindow( m_listboxEmbellishment.m_hWnd ))
	{
		m_listboxEmbellishment.EnableWindow( fEnable );
	}

	// Groove level edit box
	if( IsWindow( m_editGrooveLevel.m_hWnd ))
	{
		m_editGrooveLevel.EnableWindow( fEnable );
	}
	if( IsWindow( m_spinGrooveLevel.m_hWnd ))
	{
		m_spinGrooveLevel.EnableWindow( fEnable );
	}

	// Groove level check box
	if( IsWindow( m_CheckGrooveLevel.m_hWnd ))
	{
		m_CheckGrooveLevel.EnableWindow( fEnable );
	}

	// Groove range edit box
	if( IsWindow( m_spinGrooveRange.m_hWnd ))
	{
		if( !fEnable
		||	((m_PPGCommandData.dwValid & VALID_GROOVE)
			 &&	(m_PPGCommandData.bGrooveLevel == 0)) )
		{
			m_editGrooveRange.EnableWindow( FALSE );
			m_spinGrooveRange.EnableWindow( FALSE );
		}
		else
		{
			m_editGrooveRange.EnableWindow( TRUE );
			m_spinGrooveRange.EnableWindow( TRUE );
		}
	}

	// Repeat Pattern combo box
	if( IsWindow( m_comboRepeatPattern.m_hWnd ) )
	{
		m_comboRepeatPattern.EnableWindow( fEnable );
	}

	// Custom embellishment edit box (and static text)
	if( IsWindow( m_editEmbCustom.m_hWnd ) )
	{
		if( !fEnable || !(m_PPGCommandData.dwValid & VALID_COMMAND)
		||	(m_PPGCommandData.bCommand < 100) )
		{
			m_editEmbCustom.EnableWindow( FALSE );
			m_spinEmbCustom.EnableWindow( FALSE );
			m_staticEmbCustom.EnableWindow( FALSE );
		}
		else
		{
			m_editEmbCustom.EnableWindow( TRUE );
			m_spinEmbCustom.EnableWindow( TRUE );
			m_staticEmbCustom.EnableWindow( TRUE );
		}
	}
}

HRESULT CCommandPPG::SetData( PPGCommand* pCommand )
{
	if( pCommand == NULL )
	{
		// Disable the property page.
		EnableItems( FALSE );
		return S_OK;
	}

	memcpy( &m_PPGCommandData, pCommand, sizeof( PPGCommand ));

	// Enable the property page
	EnableItems( TRUE );

	// prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	if( !( m_PPGCommandData.dwValid & VALID_COMMAND ))
	{
		// If we don't have a valid embellishment, just don't select anything
		m_listboxEmbellishment.SetCurSel( -1 );
	}
	else
	{
		// Otherwise go select the appropriate value in the listbox.
		int iIndex = -1;

		if( m_PPGCommandData.bCommand < 5 )
		{
			static const int aiCommandToIndex[5] = {
				5, // DMUS_COMMANDT_GROOVE
				1, // DMUS_COMMANDT_FILL
				0, // DMUS_COMMANDT_INTRO
				2, // DMUS_COMMANDT_BREAK
				3};// DMUS_COMMANDT_END

			iIndex = aiCommandToIndex[m_PPGCommandData.bCommand];
		}
		else
		{
			ASSERT( m_PPGCommandData.bCommand >= 100 );
			m_bEmbCustom = m_PPGCommandData.bCommand;
			SetDlgItemInt( IDC_EDIT_EMB_CUSTOM, m_bEmbCustom, FALSE );
			iIndex = 4;
		}

		m_listboxEmbellishment.SetCurSel( iIndex );
	}

	if( ( m_PPGCommandData.dwValid & VALID_GROOVE ))
	{
		if (m_PPGCommandData.bGrooveLevel >= 1 && m_PPGCommandData.bGrooveLevel <= 100)
		{
			m_CheckGrooveLevel.SetCheck(0);

			SetDlgItemInt( IDC_EDIT_GROOVE_LEVEL, m_PPGCommandData.bGrooveLevel, FALSE );
		}
		else
		{
			m_CheckGrooveLevel.SetCheck(1);
			m_editGrooveLevel.SetWindowText( _T("") );
		}
	}
	else
	{
		m_CheckGrooveLevel.SetCheck(1);
		m_editGrooveLevel.SetWindowText( _T("") );
	}

	if( ( m_PPGCommandData.dwValid & VALID_GROOVERANGE ))
	{
		SetDlgItemInt( IDC_EDIT_GROOVE_RANGE, m_PPGCommandData.bGrooveRange / 2, FALSE );
	}
	else
	{
		m_editGrooveRange.SetWindowText( _T("") );
	}

	if( ( m_PPGCommandData.dwValid & VALID_REPEATMODE ))
	{
		int iSel = RepeatModeToIndex( m_PPGCommandData.bRepeatMode );
		ASSERT( iSel < 6 );

		m_comboRepeatPattern.SetCurSel( iSel );
	}
	else
	{
		m_comboRepeatPattern.SetCurSel( -1 );
	}

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;

	return S_OK;
}


void CCommandPPG::OnChangeEditGrooveLevel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !IsWindow( m_spinGrooveLevel.m_hWnd ) )
	{
		return;
	}

	BOOL fTransSuccess;
	long lValue = GetDlgItemInt( IDC_EDIT_GROOVE_LEVEL, &fTransSuccess, FALSE );
	if ( !fTransSuccess || (lValue < 0) )
	{
		lValue = 0;
	}
	else if (lValue > 100)
	{
		lValue = 100;
		m_spinGrooveLevel.SetPos( lValue );
	}

	if( !(m_PPGCommandData.dwValid & VALID_GROOVE)
	||	(m_PPGCommandData.bGrooveLevel != (BYTE)lValue) )
	{
		// Set the groove.
		m_PPGCommandData.dwValid |= VALID_GROOVE;
		m_PPGCommandData.bGrooveLevel = (BYTE)lValue;

		// Update the state of the 'None' checkbox
		if (lValue != 0)
		{
			m_CheckGrooveLevel.SetCheck(BST_UNCHECKED);
			EnableItems(TRUE);
		}
		else
		{
			m_CheckGrooveLevel.SetCheck(BST_CHECKED);
			m_editGrooveLevel.SetWindowText( _T("") );
			EnableItems(TRUE);
		}

		if( m_pPageManager && m_pPageManager->m_pIPropPageObject)
		{
			HRESULT hr = m_pPageManager->m_pIPropPageObject->SetData( &m_PPGCommandData );
			ASSERT( SUCCEEDED( hr ));
			if( S_FALSE == hr )
			{
				// The new data was rejected!
				PPGCommand*	pCommand = NULL;

				hr = m_pPageManager->m_pIPropPageObject->GetData( (void **) &pCommand );
				ASSERT(SUCCEEDED(hr));
				hr = SetData(pCommand);
				ASSERT(SUCCEEDED(hr));
			}
		}
	}
}

void CCommandPPG::OnCheckGrooveLevel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_CheckGrooveLevel.SetCheck(m_CheckGrooveLevel.GetCheck() ? BST_UNCHECKED : BST_CHECKED);
	if (m_CheckGrooveLevel.GetCheck())
	{
		m_editGrooveLevel.GetWindowText(m_cstrOldLevel);
		m_editGrooveLevel.SetWindowText(_T(""));
	}
	else
	{
		m_editGrooveLevel.SetWindowText(m_cstrOldLevel);
	}
	OnSetActive();
}

void CCommandPPG::OnKillfocusEditEmbCustom() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !IsWindow( m_spinEmbCustom.m_hWnd ) )
	{
		return;
	}

	BOOL fTransSuccess;
	long lValue = GetDlgItemInt( IDC_EDIT_EMB_CUSTOM, &fTransSuccess, FALSE );
	if ( !fTransSuccess || (lValue < 100) )
	{
		lValue = 100;
		m_spinEmbCustom.SetPos( lValue );
	}
	else if (lValue > 199)
	{
		lValue = 199;
		m_spinEmbCustom.SetPos( lValue );
	}

	if( !(m_PPGCommandData.dwValid & VALID_COMMAND)
	||	(m_PPGCommandData.bCommand != (BYTE)lValue) )
	{
		// Set the custom embellishment
		m_PPGCommandData.dwValid |= VALID_COMMAND;
		m_PPGCommandData.bCommand = (BYTE)lValue;
		m_bEmbCustom = (BYTE)lValue;

		if( m_pPageManager && m_pPageManager->m_pIPropPageObject)
		{
			HRESULT hr = m_pPageManager->m_pIPropPageObject->SetData( &m_PPGCommandData );
			ASSERT( SUCCEEDED( hr ));
			if( S_FALSE == hr )
			{
				// The new data was rejected!
				PPGCommand*	pCommand = NULL;

				hr = m_pPageManager->m_pIPropPageObject->GetData( (void **) &pCommand );
				ASSERT(SUCCEEDED(hr));
				hr = SetData(pCommand);
				ASSERT(SUCCEEDED(hr));
			}
		}
	}
}

void CCommandPPG::OnChangeEditGrooveRange() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !IsWindow( m_spinEmbCustom.m_hWnd ) )
	{
		return;
	}

	BOOL fTransSuccess;
	long lValue = GetDlgItemInt( IDC_EDIT_GROOVE_RANGE, &fTransSuccess, FALSE );
	if ( !fTransSuccess || (lValue < 0) )
	{
		lValue = 0;
		m_spinGrooveRange.SetPos( lValue );
	}
	else if (lValue > 100)
	{
		lValue = 100;
		m_spinGrooveRange.SetPos( lValue );
	}

	if( !(m_PPGCommandData.dwValid & VALID_GROOVERANGE)
	||	(m_PPGCommandData.bGrooveRange != (BYTE)(lValue * 2)) )
	{
		// Set the groove range
		m_PPGCommandData.dwValid |= VALID_GROOVERANGE;
		m_PPGCommandData.bGrooveRange = (BYTE)(lValue * 2);

		if( m_pPageManager && m_pPageManager->m_pIPropPageObject)
		{
			HRESULT hr = m_pPageManager->m_pIPropPageObject->SetData( &m_PPGCommandData );
			ASSERT( SUCCEEDED( hr ));
			if( S_FALSE == hr )
			{
				// The new data was rejected!
				PPGCommand*	pCommand = NULL;

				hr = m_pPageManager->m_pIPropPageObject->GetData( (void **) &pCommand );
				ASSERT(SUCCEEDED(hr));
				hr = SetData(pCommand);
				ASSERT(SUCCEEDED(hr));
			}
		}
	}
}

void CCommandPPG::OnSelchangeComboRepeatPattern() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( (m_pPageManager == NULL)
	||	(m_pPageManager->m_pIPropPageObject == NULL) )
	{
		return;
	}

	// Get and validate the repeat pattern.
	int iIndex = m_comboRepeatPattern.GetCurSel();
	if( (iIndex >= 6)
	||	(iIndex < 0 ) )
	{
		ASSERT(FALSE);
		return;
	}

	BYTE bNewRepeatMode = IndexToRepeatMode( iIndex );

	if( !(m_PPGCommandData.dwValid & VALID_REPEATMODE)
	||	(bNewRepeatMode != m_PPGCommandData.bRepeatMode) )
	{
		m_PPGCommandData.dwValid |= VALID_REPEATMODE;
		m_PPGCommandData.bRepeatMode = bNewRepeatMode;

		HRESULT hr = m_pPageManager->m_pIPropPageObject->SetData( &m_PPGCommandData );
		ASSERT( SUCCEEDED( hr ));
		if( S_FALSE == hr )
		{
			// The new data was rejected!
			PPGCommand*	pCommand = NULL;

			hr = m_pPageManager->m_pIPropPageObject->GetData( (void **) &pCommand );
			ASSERT( SUCCEEDED( hr ));
			hr = SetData( pCommand );
			ASSERT( SUCCEEDED( hr ));
		}
	}
}

void CCommandPPG::OnDeltaposSpinEmbCustom(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnKillfocusEditEmbCustom();

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int nCustomEmb = m_spinEmbCustom.GetPos();

	if( HIWORD(nCustomEmb) == 0 )
	{
		int nNewCustomEmb = LOWORD(nCustomEmb) + pNMUpDown->iDelta;

		if( nNewCustomEmb < 100)
		{
			nNewCustomEmb = 100;
		}
	
		if( nNewCustomEmb > 199)
		{
			nNewCustomEmb = 199;
		}

		m_spinEmbCustom.SetPos( nNewCustomEmb );

		if( !(m_PPGCommandData.dwValid & VALID_COMMAND)
		||	(m_PPGCommandData.bCommand != (BYTE)nNewCustomEmb) )
		{
			// Set the custom embellishment
			m_PPGCommandData.dwValid |= VALID_COMMAND;
			m_PPGCommandData.bCommand = (BYTE)nNewCustomEmb;
			m_bEmbCustom = (BYTE)nNewCustomEmb;

			if( m_pPageManager && m_pPageManager->m_pIPropPageObject)
			{
				HRESULT hr = m_pPageManager->m_pIPropPageObject->SetData( &m_PPGCommandData );
				ASSERT( SUCCEEDED( hr ));
				if( S_FALSE == hr )
				{
					// The new data was rejected!
					PPGCommand*	pCommand = NULL;

					hr = m_pPageManager->m_pIPropPageObject->GetData( (void **) &pCommand );
					ASSERT(SUCCEEDED(hr));
					hr = SetData(pCommand);
					ASSERT(SUCCEEDED(hr));
				}
			}
		}
	}

	*pResult = 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\CommandStripMgr\CommandPPGMgr.h ===
// CommandPPGMgr.h: interface for the CCommandPPGMgr class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __SIGNPOSTPPGMGR_H__
#define __SIGNPOSTPPGMGR_H__

// {33EEC071-F31B-11d0-BADE-00805F493F43}
static const GUID GUID_CommandPPGMgr = 
{ 0x33eec071, 0xf31b, 0x11d0, { 0xba, 0xde, 0x0, 0x80, 0x5f, 0x49, 0x3f, 0x43 } };

#include "StaticPropPageManager.h"
#include "CommandPPG.h"

class CCommandPPG;

//////////////////////////////////////////////////////////////////////
//  CCommandPPGMgr

class CCommandPPGMgr : public CStaticPropPageManager 
{
friend class CCommandPPG;
public:
	CCommandPPGMgr();
	virtual ~CCommandPPGMgr();

    // IDMUSProdPropPageManager functions
	HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();

	// Member variables
private:
	CCommandPPG*	m_pCommandPPG;
};

#endif //__SIGNPOSTPPGMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\CommandStripMgr\CommandPPGMgr.cpp ===
// CommandPPGMgr.cpp: implementation of the CCommandPPGMgr class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CommandStripMgr.h"
#include "FileIO.h"
#include "CommandPPGMgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// CCommandPPGMgr Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCommandPPGMgr::CCommandPPGMgr() : CStaticPropPageManager()
{
	m_pCommandPPG	= NULL;
	m_GUIDManager	= GUID_CommandPPGMgr;
}

CCommandPPGMgr::~CCommandPPGMgr()
{
	if( m_pCommandPPG )
	{
		delete m_pCommandPPG;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCommandPPGMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CCommandPPGMgr IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CCommandPPGMgr::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if(( pbstrTitle == NULL )
	|| ( pfAddPropertiesText == NULL ))
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;

	strTitle.LoadString( IDS_PROPPAGE_COMMAND );
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCommandPPGMgr IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CCommandPPGMgr::GetPropertySheetPages( IDMUSProdPropSheet *pIPropSheet, LONG *hPropSheetPage[], short *pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if(( hPropSheetPage == NULL )
	|| ( pnNbrPages == NULL ))
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	HPROPSHEETPAGE hPage;

	// If the property page has already been created, get a handle for it.
	if( m_pCommandPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pCommandPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[0] = (long *) hPage;
			*pnNbrPages = 1;
			return S_OK;
		}
		*pnNbrPages = 0;
		delete m_pCommandPPG;
		m_pCommandPPG = NULL;
		return E_OUTOFMEMORY;
	}

	// Otherwise, create a new property page
	m_pCommandPPG = new CCommandPPG();
	if( m_pCommandPPG )
	{
		m_pCommandPPG->m_pPageManager = this;
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pCommandPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[0] = (long *) hPage;
			*pnNbrPages = 1;
			return S_OK;
		}
		delete m_pCommandPPG;
		m_pCommandPPG = NULL;
	}

	// We couldn't create the page
	*pnNbrPages = 0;
	return E_OUTOFMEMORY;
}

/////////////////////////////////////////////////////////////////////////////
// CCommandPPGMgr IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CCommandPPGMgr::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr;

	hr = CBasePropPageManager::OnRemoveFromPropertySheet();
	if( FAILED( hr ))
	{
		return hr;
	}

	if( m_pIPropSheet )
	{
		m_pIPropSheet->Release();
		m_pIPropSheet = NULL;
	}

	if( m_pCommandPPG )
	{
		hr = m_pCommandPPG->SetData( NULL );
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CCommandPPGMgr IDMUSProdPropPageManager::RefreshData

HRESULT CCommandPPGMgr::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT		hr = S_OK;
	PPGCommand*	pCommand = NULL;
	
	if( m_pIPropPageObject != NULL )
	{
		hr = m_pIPropPageObject->GetData( (void **) &pCommand );
		if( FAILED( hr ))
		{
			return hr;
		}
	}

	if( m_pCommandPPG )
	{
		hr = m_pCommandPPG->SetData( pCommand );
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CCommandPPGMgr IDMUSProdPropPageManager::RemoveObject

HRESULT CCommandPPGMgr::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	HRESULT hr;

	hr = CStaticPropPageManager::RemoveObject( pIPropPageObject );
	if( SUCCEEDED( hr ))
	{
		if( m_pCommandPPG )
		{
			hr = m_pCommandPPG->SetData( NULL );
		}
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\CommandStripMgr\CommandStripMgr.cpp ===
// CommandStripMgr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f CommandStripMgrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <dmusici.h>
#include "CommandStripMgr.h"
#include "CommandMgr.h"
#include <SegmentGuids.h>


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CommandMgr, CCommandMgr)
END_OBJECT_MAP()

CCommandStripMgrApp theApp;

BOOL CCommandStripMgrApp::InitInstance()
{
	_Module.Init( ObjectMap, m_hInstance );
	return CWinApp::InitInstance();
}

int CCommandStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return( AfxDllCanUnloadNow() == S_OK && _Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID* ppv )
{
	return _Module.GetClassObject( rclsid, riid, ppv );
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DMUSProducer strip managers

static BOOL RegisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[256];
	TCHAR	 szStripManager[32];
	TCHAR	 szUserName[32];
    TCHAR    szEditorGuid[100];
	TCHAR	 szTrackGuid[100];
    CString  strTrackName, strEditorName;
    TCHAR    szComponentPath[256];
    
	_tcscpy( szStripManager, _T("StripManager") );
	_tcscpy( szUserName, _T("UserName") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
	
    if( SUCCEEDED( StringFromIID(CLSID_CommandMgr, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorGuid, sizeof(szEditorGuid), NULL, NULL );
        CoTaskMemFree( psz );
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicCommandTrack, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackGuid, sizeof(szTrackGuid), NULL, NULL );
			CoTaskMemFree( psz );

			strTrackName.LoadString( IDS_TRACK_NAME );
			_tcscpy( szRegPath, szComponentPath );
			_tcscat( szRegPath, szTrackGuid );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szStripManager, szEditorGuid)) )
			{
				return FALSE;
			}
			strEditorName.LoadString( IDS_EDITOR_NAME );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szUserName, strEditorName)) )
			{
				return FALSE;
			}
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[255];
	TCHAR    szGuid[100];
	
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicCommandTrack, &psz) ) )
   	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_COMMANDSTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\CommandStripMgr\ContextMenuHandler.cpp ===
// ContextMenuHandler.cpp : Implementation of temporary window to handle WM_COMMAND messages 
//							from the context menu.
//

#include "stdafx.h"
#include "CommandStripMgr.h"
#include "ContextMenuHandler.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler

CContextMenuHandler::CContextMenuHandler()
{
	m_pStrip = NULL;
}

CContextMenuHandler::~CContextMenuHandler()
{
}


BEGIN_MESSAGE_MAP(CContextMenuHandler, CWnd)
	//{{AFX_MSG_MAP(CContextMenuHandler)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler message handlers

BOOL CContextMenuHandler::OnCommand( WPARAM wParam, LPARAM lParam ) 
{
	HRESULT hr = S_FALSE;

	if( m_pStrip != NULL )
	{
		hr = m_pStrip->OnWMMessage( WM_COMMAND, wParam, lParam, 0, 0 );
	}
	
	if( hr == S_OK )
	{
		return TRUE;
	}

	return CWnd::OnCommand( wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\CommandStripMgr\CommandPPG.h ===
#if !defined(AFX_COMMANDPPG_H__1A2A29E6_EF4E_11D0_BAD9_00805F493F43__INCLUDED_)
#define AFX_COMMANDPPG_H__1A2A29E6_EF4E_11D0_BAD9_00805F493F43__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CommandPPG.h : header file
//

#include <afxctl.h>
#include "resource.h"
#include "stdafx.h"
#include "CommandPPGMgr.h"
#include "CommandMgr.h"
#include "FileIO.h"

class CCommandPPGMgr;

/////////////////////////////////////////////////////////////////////////////
// CCommandPPG dialog

class CCommandPPG : public CPropertyPage
{
	DECLARE_DYNCREATE(CCommandPPG)

// Construction
public:
	CCommandPPG();
	~CCommandPPG();

// Attributes
	CCommandPPGMgr*	m_pPageManager;

// Functions
	HRESULT SetData( PPGCommand* pCommand );

// Dialog Data
	//{{AFX_DATA(CCommandPPG)
	enum { IDD = IDD_PROPPAGE_COMMANDS };
	CComboBox	m_comboRepeatPattern;
	CStatic	m_staticEmbCustom;
	CSpinButtonCtrl	m_spinGrooveRange;
	CSpinButtonCtrl	m_spinEmbCustom;
	CEdit	m_editGrooveRange;
	CEdit	m_editEmbCustom;
	CButton	m_CheckGrooveLevel;
	CSpinButtonCtrl	m_spinGrooveLevel;
	CEdit	m_editGrooveLevel;
	CListBox	m_listboxEmbellishment;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCommandPPG)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCommandPPG)
	afx_msg void OnSelchangeCommandEmbellishmentlist();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditGrooveLevel();
	afx_msg void OnCheckGrooveLevel();
	afx_msg void OnChangeEditGrooveRange();
	afx_msg void OnSelchangeComboRepeatPattern();
	afx_msg void OnKillfocusEditEmbCustom();
	afx_msg void OnDeltaposSpinEmbCustom(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void			EnableItems( BOOL fEnable );

	PPGCommand		m_PPGCommandData;
	CString			m_cstrOldLevel;
	BYTE			m_bEmbCustom;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COMMANDPPG_H__1A2A29E6_EF4E_11D0_BAD9_00805F493F43__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\CommandStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\CommandStripMgr\ContextMenuHandler.h ===
#if !defined(AFX_CONTEXTMENUHANDLER_H__B49AF6C3_EE6A_11D0_BAD6_00805F493F43__INCLUDED_)
#define AFX_CONTEXTMENUHANDLER_H__B49AF6C3_EE6A_11D0_BAD6_00805F493F43__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ContextMenuHandler.h : header file
//

#include "timeline.h"

/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler window

class CContextMenuHandler : public CWnd
{
// Construction
public:
	CContextMenuHandler();

// Attributes
public:

	IDMUSProdStrip* m_pStrip;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CContextMenuHandler)
	protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CContextMenuHandler();

	// Generated message map functions
protected:
	//{{AFX_MSG(CContextMenuHandler)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONTEXTMENUHANDLER_H__B49AF6C3_EE6A_11D0_BAD6_00805F493F43__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\CommandStripMgr\FileIO.h ===
#ifndef __COMMAND_FILEIO_H__
#define __COMMAND_FILEIO_H__



typedef struct CommandExt
{
	CommandExt() { memset( this, 0, sizeof(this) ); }
    CommandExt* pNext;
    long        lTime;		// Time, in clocks
	DWORD		dwDragDrop;
    BYTE        bCommand;	// Command type
    BYTE        bGrooveLevel;	// Command's groove level (1 - 100)
    BYTE        bGrooveRange;   // Groove range
    BYTE        bRepeatMode;    // Used to control selection of patterns with same groove level
} CommandExt;

typedef struct CommandMeasureInfo
{
	CommandExt*	pCommand;	// The command in this measure.
	DWORD		dwFlags;	// Currently, just whether the measure is selected.
} CommandMeasureInfo;

typedef struct ioCommand
{
    long    lTime;       // Time, in clocks.
    DWORD   dwCommand;    // Command type.
} ioCommand;

typedef struct PPGCommand
{
	long		lMeasure;
	DWORD		dwValid;
    BYTE        bCommand;	// Command type
    BYTE        bGrooveLevel;	// Command's groove level (1 - 100)
    BYTE        bGrooveRange;   // Groove range
    BYTE        bRepeatMode;    // Used to control selection of patterns with same groove level
} PPGCommand;

/* structure of dwDragDrop

	Bit	 0:			Drag select flag (command is part of drag select)
	Bit  1:			Drop cursor flag (command is drop cursor)
	Bits 2  - 11:	Not Used
	Bits 12 - 27	measure for drag/drop
	Bits 28 - 31	Not Used

*/

#define C_FILL      0x1		// Do a fill
#define C_INTRO     0x2		// Do an intro
#define C_BREAK     0x20	// Do a drum break
#define C_END       0x40	// End the song
#define C_MASK		0x7F
#define GROOVE_A	0x80
#define GROOVE_B	0x100
#define GROOVE_C	0x200
#define GROOVE_D	0x400
#define GROOVE_MASK	0x780

#define DRAG_SELECT	0x1	//	this is part of a dragged command list
#define DROP_CURSOR	0x2	//  this command is at the drop cursor point

#define MEASURE_MASK	0x0FFFF000	// position of measure info in dwCommand for persisted commands

#define VALID_COMMAND	0x1
#define VALID_GROOVE	0x2
#define VALID_GROOVERANGE	0x4
#define VALID_REPEATMODE	0x8

// Custom embellishment values
#define MIN_EMB_CUSTOM_ID	100
#define MAX_EMB_CUSTOM_ID	199

#define CMI_SELECTED	0x1	// The measure is selected.


long __inline GetMeasureFromCommand(DWORD dwDragDrop)
{
	long m = long(dwDragDrop) & MEASURE_MASK;
	m = (m >> 12) & 0xFFFF;
	return m;
}

void __inline SetMeasureInCommand(DWORD& dwDragDrop, long lMeasure)
{
	lMeasure = (lMeasure << 12) & MEASURE_MASK;
	dwDragDrop &= ~MEASURE_MASK;  // clear any previous value
	dwDragDrop |= lMeasure;
}

/*
class CCommandList
{
	CommandExt*	pHead;
public:
    CCommandItem *   GetHead() {return pHead};
	CCommandItem *	RemoveHead() { CommandExt* p = pHead; pHead = p->Next; }
	void		ClearList();
	void		ClearFlags(DWORD flag);
	void		InsertByAscendingTime(CCommandItem *pChord);	// *pCommand <= *(pCommand->next)
	HRESULT		Load( LPSTREAM pStream );
	HRESULT		Save( LPSTREAM pStream, BOOL bClearDirty );
};
*/

/*
// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}
*/




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\CommandStripMgr\CommandStrip.cpp ===
// CommandStrip.cpp : Implementation of CCommandStrip
#include "stdafx.h"
#include "CommandStripMgr.h"
#include "CommandMgr.h"
#include "FileIO.h"
#include "DllJazzDataObject.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include <dmusici.h>
#include "SegmentIO.h"
#include "GrayOutRect.h"

// Light grey
#define GREY_COMMAND_COLOR		RGB( 168, 168, 168 )
#define STRIP_HEIGHT			20

CString GetName(DWORD dwGroupBits, CString strName)
{
	CString strText, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}

	return strText + CString(": ") + strName;
}

void GetGrooveText( BYTE bGrooveLevel, BYTE bGrooveRange, BYTE bRepeatMode, CString &strGroove )
{
	// Erase strGroove
	strGroove.Empty();

	// Determine what text (if any) to display for the groove
	if (bGrooveLevel >= 1 && bGrooveLevel <= 100)
	{
		// A groove range of 1 acts like a groove range of 0, so ignore it as well as 0
		if( bGrooveRange > 1 )
		{
			/* TODO: Is this faster?
			TCHAR tcstrTmp1[4], tcstrTmp2[4];
			_itot(pCommand->bGrooveLevel - pCommand->bGrooveRange / 2, tcstrTmp1, 10);
			_itot(pCommand->bGrooveLevel + pCommand->bGrooveRange / 2, tcstrTmp2, 10);
			TCHAR tcstrTmp3[10];
			_tcscpy( tcstrTmp3, _T("(") );
			strGroove = _tcsncat( _tcsncat( _tcsncat( _tcsncat( tcstrTmp3, tcstrTmp1, 4 ), _T("-"), 2 ), tcstrTmp2, 4 ), _T(")"), 2 );
			*/
			strGroove.Format("(%d-%d)", max( 1, bGrooveLevel - bGrooveRange / 2 ),
										min( 100, bGrooveLevel + bGrooveRange / 2 ) );
		}
		else
		{
			TCHAR tcstrTmp[4];
			_itot(bGrooveLevel, tcstrTmp, 10);

			TCHAR tcstrTmp2[6];
			_tcscpy( tcstrTmp2, _T("(") );
			strGroove = _tcsncat( _tcsncat( tcstrTmp2, tcstrTmp, 4 ), _T(")"), 2 );
		}
	}

	// Determine what text (if any) to display for the repeat mode
	CString strRepeatMode;
	if( (bRepeatMode > 0) && (bRepeatMode <= 5)
	&&	strRepeatMode.LoadString( IDS_RANDOM + bRepeatMode ) )
	{
		if( !strGroove.IsEmpty() )
		{
			strGroove += " ";
		}
		strGroove += strRepeatMode;
	}
}

void GetCommandText( CommandExt* pCommand, CString &strCommand )
{
	// Erase strCommand
	strCommand.Empty();

	if( pCommand == NULL )
	{
		return;
	}

	// Determine what text (if any) to display for the embellishment
	switch( pCommand->bCommand )
	{
	case DMUS_COMMANDT_FILL:
		strCommand.LoadString( IDS_FILL_TEXT );
		break;
	case DMUS_COMMANDT_BREAK:
		strCommand.LoadString( IDS_BREAK_TEXT );
		break;
	case DMUS_COMMANDT_INTRO:
		strCommand.LoadString( IDS_INTRO_TEXT );
		break;
	case DMUS_COMMANDT_END:
		strCommand.LoadString( IDS_END_TEXT );
		break;
	case DMUS_COMMANDT_GROOVE:
		//strCommand += "Groove";
		break;
	default:
		if( (pCommand->bCommand >= MIN_EMB_CUSTOM_ID)
		&&	(pCommand->bCommand <= MAX_EMB_CUSTOM_ID) )
		{
			TCHAR tcstrTmp[4];
			_itot( pCommand->bCommand, tcstrTmp, 10 );
			strCommand = CString(tcstrTmp);
		}
		break;
	}

	// Determine what text (if any) to display for the groove
	CString strGroove;
	GetGrooveText( pCommand->bGrooveLevel, pCommand->bGrooveRange, pCommand->bRepeatMode, strGroove );

	if( !strGroove.IsEmpty() )
	{
		if( !strCommand.IsEmpty() )
		{
			strCommand += " ";
		}
		strCommand += strGroove;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCommandStrip

/////////////////////////////////////////////////////////////////////////////
// CCommandStrip IUnknown
STDMETHODIMP CCommandStrip::QueryInterface( REFIID riid, LPVOID* ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( ppv );
    *ppv = NULL;
    if( IsEqualIID( riid, IID_IUnknown ))
	{
        *ppv = (IUnknown*) (IDMUSProdStrip*) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdStrip ))
	{
        *ppv = (IDMUSProdStrip*) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
        *ppv = (IUnknown *) (IDMUSProdStripFunctionBar *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdPropPageObject))
	{
        *ppv = (IUnknown *) (IDMUSProdPropPageObject *) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdTimelineEdit ))
	{
		*ppv = (IDMUSProdTimelineEdit*) this;
	}
	else if( IsEqualIID( riid, IID_IDropSource ))
	{
		*ppv = (IDropSource*) this;
	}
	else if( IsEqualIID( riid, IID_IDropTarget ))
	{
		*ppv = (IDropTarget*) this;
	}
	else
	{
		return E_NOINTERFACE;
	}
    ((IUnknown*) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CCommandStrip::AddRef(void)
{
	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CCommandStrip::Release(void)
{
	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCommandStrip IDMUSProdStrip

HRESULT	STDMETHODCALLTYPE CCommandStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(sv);

	BYTE			bGreyGroove = 0;
	BYTE			bGreyGrooveRange = 0;
	BYTE			bGreyRepeatMode = 0;
	//CRect			rectInvalid;
	CRect			rectHighlight;
	long			lPositionFirst;
	long			lMeasureFirst;// = m_lLastFirstMeasure;

	ASSERT( m_pCommandMgr != NULL && m_pStripMgr != NULL );
	if( m_pCommandMgr == NULL || m_pStripMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	if( m_pCommandMgr->m_pTimeline )
	{
		m_pCommandMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, m_pCommandMgr->m_dwGroupBits, 0, lXOffset );
		if( hDC )
		{
			// draw the commands
			CRect		rectClip;
			CString		strCommand;
			CommandExt*	pCommand = m_pCommandMgr->m_pCommandList;
			long		position;
			long		lMeasure;
			SIZE		sizeText, sizeGreyText;
			bool		fDrawGreyText = true;
			RECT		rectToDrawIn;

			::GetClipBox( hDC, &rectClip );
			rectHighlight = rectClip;

			rectToDrawIn.top = 0;
			rectToDrawIn.bottom = STRIP_HEIGHT;

			// Find the measure in which to draw the greyed command.
			m_pCommandMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lPositionFirst );

			// The following few lines are because of a bug in the timeline which sometimes
			// sends a null clipping region.
			// Make sure we should even bother drawing.
			m_pCommandMgr->m_pTimeline->ClocksToPosition(lPositionFirst, &position);
			if( position - lXOffset > rectClip.right )
			{
				return S_OK;
			}

			m_pCommandMgr->m_pTimeline->ClocksToMeasureBeat( m_pCommandMgr->m_dwGroupBits, 0, lPositionFirst, &lMeasureFirst, NULL );
			long lClocks;
			m_pCommandMgr->m_pTimeline->MeasureBeatToClocks( m_pCommandMgr->m_dwGroupBits, 0, lMeasureFirst, 0, &lClocks );
			if( lClocks < lPositionFirst )
			{
				lMeasureFirst += 1;
			}
			m_pCommandMgr->m_pTimeline->MeasureBeatToPosition( m_pCommandMgr->m_dwGroupBits, 0, lMeasureFirst, 0, &lPositionFirst );

			while( pCommand )
			{
				m_pCommandMgr->m_pTimeline->ClocksToMeasureBeat( m_pCommandMgr->m_dwGroupBits, 0, pCommand->lTime, &lMeasure, NULL );
				if( lMeasure < lMeasureFirst )
				{
					// Only update the groove level and range if it is set
					if( (pCommand->bGrooveLevel >= 1) && (pCommand->bGrooveLevel <= 100) )
					{
						bGreyGroove = pCommand->bGrooveLevel;
						bGreyGrooveRange = pCommand->bGrooveRange;
					}

					// Always update the repeat mode
					bGreyRepeatMode = pCommand->bRepeatMode;
				}

				m_pCommandMgr->m_pTimeline->ClocksToPosition( pCommand->lTime, &position );
				position++;

				rectToDrawIn.left = position - lXOffset;

				if( pCommand->pNext )
				{
					m_pCommandMgr->m_pTimeline->ClocksToPosition( pCommand->pNext->lTime, &rectToDrawIn.right );
					rectToDrawIn.right -= lXOffset - 1;
				}
				else
				{
					rectToDrawIn.right = SHRT_MAX;
				}

				GetCommandText( pCommand, strCommand );

				if( lMeasure <= lMeasureFirst )
				{
					// Get the extent of the groove text
					if( ::GetTextExtentPoint( hDC, strCommand, strCommand.GetLength(), &sizeText ) )
					{
						// Check if we should display a grey groove level
						CString	strGreyText;
						sizeGreyText.cx = 0;
						if( fDrawGreyText
						&&	pCommand->bGrooveLevel == 0 )
						{
							// Add the space after the embellishment text
							strCommand += _T(" ");

							// Recalculate the size of the text
							::GetTextExtentPoint( hDC, strCommand, strCommand.GetLength(), &sizeText );

							// Convert the grey groove level and range to a string
							GetGrooveText( bGreyGroove, bGreyGrooveRange, 0xFF, strGreyText );

							// Get the extent of the groove text
							::GetTextExtentPoint( hDC, strGreyText, strGreyText.GetLength(), &sizeGreyText );
						}

						// If the text extends past the left edge
						if( position - lXOffset + sizeText.cx + sizeGreyText.cx > rectClip.left )
						{
							// Write out the groove text
							::DrawText( hDC, strCommand, -1, &rectToDrawIn, DT_LEFT | DT_NOPREFIX | DT_SINGLELINE | DT_TOP );

							// Write out the grey text, if necessary
							if( !strGreyText.IsEmpty() )
							{
								// Set rectInvalid so we invalidate the old grey text
								//rectInvalid = m_rectInvalid;

								// Calculate the rectangle to draw in
								rectToDrawIn.left = position - lXOffset + sizeText.cx;

								// Check if there is any space to draw the grey text
								if( rectToDrawIn.left < rectToDrawIn.right )
								{
									// Set m_rectInvalid so that the next time the strip is drawn, the grey command will be erased.
									//m_rectInvalid = rectToDrawIn;
									//m_rectInvalid.left += lXOffset;
									//m_rectInvalid.right = min( m_rectInvalid.right + lXOffset, m_rectInvalid.left + sizeGreyText.cx );

									// Draw the greyed command.
									COLORREF crOld = ::SetTextColor( hDC, GREY_COMMAND_COLOR);
									::DrawText( hDC, strGreyText, -1, &rectToDrawIn, DT_LEFT | DT_NOPREFIX | DT_SINGLELINE | DT_TOP );
									::SetTextColor( hDC, crOld );
								}
							}

							// Flag that we don't need to draw the grey text
							fDrawGreyText = false;
						}
					}
				}
				else // if( lMeasure > lMeasureFirst )
				{
					// Check if we need to draw the grey text in lMeasureFirst
					if( fDrawGreyText )
					{
						// Yes - Draw the greyed command
						long lGreyPosition = lPositionFirst + 1;

						// Convert the groove level and range to a string
						CString	strGreyText;
						GetGrooveText( bGreyGroove, bGreyGrooveRange, bGreyRepeatMode, strGreyText );

						// Write out the grey text, if necessary
						if( !strGreyText.IsEmpty() )
						{
							// Set rectInvalid so that we invalidate the old grey text
							//rectInvalid = m_rectInvalid;

							// Calculate the rectangle to draw in
							RECT rectGreyText = rectToDrawIn;
							rectGreyText.left = lGreyPosition - lXOffset;
							rectGreyText.right = position - lXOffset;

							if( rectGreyText.left < rectGreyText.right )
							{
								// Set m_rectInvalid so that the next time the strip is drawn, the grey command will be erased.
								//::GetTextExtentPoint( hDC, strGreyText, strGreyText.GetLength(), &sizeGreyText );

								// Set m_rectInvalid so that the next time the strip is drawn, the grey command will be erased.
								//m_rectInvalid = rectGreyText;
								//m_rectInvalid.left += lXOffset;
								//m_rectInvalid.right = min( position, m_rectInvalid.left + sizeGreyText.cx );

								// Draw the greyed command.
								COLORREF crOld = ::SetTextColor( hDC, GREY_COMMAND_COLOR);
								::DrawText( hDC, strGreyText, -1, &rectGreyText, DT_LEFT | DT_NOPREFIX | DT_SINGLELINE | DT_TOP );
								::SetTextColor( hDC, crOld );
							}
						}

						// Flag that we don't need to draw the grey text
						fDrawGreyText = false;
					}

					// Now, write out the groove text
					::DrawText( hDC, strCommand, -1, &rectToDrawIn, DT_LEFT | DT_NOPREFIX | DT_SINGLELINE | DT_TOP );
				}

				pCommand = pCommand->pNext;
				if( position - lXOffset > rectClip.right )
				{
					break;
				}
			} // while( pCommand )

			// Need to draw the grey text after all commands have been drawn
			if( fDrawGreyText )
			{
				// Yes - Draw the greyed command
				long lGreyPosition = lPositionFirst + 1;

				// Convert the groove level and range to a string
				CString	strGreyText;
				GetGrooveText( bGreyGroove, bGreyGrooveRange, bGreyRepeatMode, strGreyText );

				// Write out the grey text, if necessary
				if( !strGreyText.IsEmpty() )
				{
					// Set rectInvalid so that we invalidate the old grey text
					//rectInvalid = m_rectInvalid;

					// Get the size of the grey text, for m_rectInvalid
					//::GetTextExtentPoint( hDC, strGreyText, strGreyText.GetLength(), &sizeGreyText );

					// Set m_rectInvalid so that the next time the strip is drawn, the grey command will be erased.
					//m_rectInvalid = rectToDrawIn;
					//m_rectInvalid.left = lGreyPosition;
					//m_rectInvalid.right = lGreyPosition + sizeGreyText.cx;

					// Draw the greyed command.
					COLORREF crOld = ::SetTextColor( hDC, GREY_COMMAND_COLOR);
					::TextOut( hDC, lGreyPosition - lXOffset, 0, strGreyText, strGreyText.GetLength() );
					::SetTextColor( hDC, crOld );
				}
			}

			// Highlight the selected measures.
			if( m_pCommandMgr->m_bSelected )
			{
				ASSERT( m_pCommandMgr->m_pMeasureArray != NULL );
				if( m_pCommandMgr->m_pMeasureArray == NULL )
				{
					return E_UNEXPECTED;
				}

				long lBeginSelMeasure;
				long lEndSelMeasure;
				long lMeasureBeginPosition = 0;
				long lMeasureEndPosition = 0;
				short n;

				lBeginSelMeasure = -1;
				lEndSelMeasure = -1;
				for( n = 0; n < m_pCommandMgr->m_nMeasures; n++ )
				{
					if( m_pCommandMgr->m_pMeasureArray[n].dwFlags & CMI_SELECTED )
					{
						if( lBeginSelMeasure == -1 )
						{
							lBeginSelMeasure = (long) n;
						}
						lEndSelMeasure = (long) n + 1;
					}
					else if( lBeginSelMeasure != -1 )
					{
						ASSERT( lEndSelMeasure > lBeginSelMeasure );

						// Highlight the range which just ended.
						m_pCommandMgr->m_pTimeline->MeasureBeatToPosition( m_pCommandMgr->m_dwGroupBits, 0, lBeginSelMeasure, 0, &lMeasureBeginPosition );
						m_pCommandMgr->m_pTimeline->MeasureBeatToPosition( m_pCommandMgr->m_dwGroupBits, 0, lEndSelMeasure, 0, &lMeasureEndPosition );
						rectHighlight.left = lMeasureBeginPosition - lXOffset;
						rectHighlight.right = lMeasureEndPosition - lXOffset;
						GrayOutRect( hDC, &rectHighlight );
						lBeginSelMeasure = -1;
						lEndSelMeasure = -1;
					}
				}

				if( lBeginSelMeasure != -1 )
				{
					// The last measure was highlighted.
					m_pCommandMgr->m_pTimeline->MeasureBeatToPosition( m_pCommandMgr->m_dwGroupBits, 0, lBeginSelMeasure, 0, &lMeasureBeginPosition );
					m_pCommandMgr->m_pTimeline->MeasureBeatToPosition( m_pCommandMgr->m_dwGroupBits, 0, lEndSelMeasure, 0, &lMeasureEndPosition );
					rectHighlight.left = lMeasureBeginPosition - lXOffset;
					rectHighlight.right = lMeasureEndPosition - lXOffset;
					GrayOutRect( hDC, &rectHighlight );
				}
			}
		}
		/*
		if( m_lLastFirstMeasure > -1 && ( m_lLastFirstMeasure != lMeasureFirst ))
		{
			m_lLastFirstMeasure = -1;
			
			// If the position of the grey text changed, and the rect to invalidate
			// was not redrawn
			if( (rectInvalid != m_rectInvalid)
			&&	( !rectClip.PtInRect( CPoint(rectInvalid.left, rectInvalid.top) ||
				  !rectClip.PtInRect( CPoint(rectInvalid.right, rectInvalid.bottom) ) )
			{
				rectInvalid.left -= lXOffset;
				rectInvalid.right -= lXOffset;
				m_pCommandMgr->m_pTimeline->StripInvalidateRect( this, rectInvalid, TRUE );
			}
		}
		*/
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CCommandStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case SP_RESIZEABLE:
		pvar->vt = VT_BOOL;
		V_BOOL( pvar ) = FALSE;
		break;
	case SP_GUTTERSELECTABLE:
		pvar->vt = VT_BOOL;
		V_BOOL( pvar ) = TRUE;
		break;
	case SP_MINMAXABLE:
		pvar->vt = VT_BOOL;
		V_BOOL( pvar ) = FALSE;
		break;
	case SP_DEFAULTHEIGHT:
		pvar->vt = VT_INT;
		V_INT( pvar ) = STRIP_HEIGHT;
		break;
	case SP_NAME:
		{
			BSTR bstr;
			CString strName;
			strName.LoadString( IDS_FUNCTIONBAR_TEXT );

			CString str = GetName(m_pCommandMgr->m_dwGroupBits, strName);
			pvar->vt = VT_BSTR;
			try
			{
				bstr = str.AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR( pvar ) = bstr;
		}
		break;
	case SP_BEGINSELECT:
		pvar->vt = VT_I4;
		V_I4( pvar ) = m_lBeginSelect;
		break;
	case SP_ENDSELECT:
		pvar->vt = VT_I4;
		V_I4( pvar ) = m_lEndSelect;
		break;
	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		if( m_pCommandMgr )
		{
			m_pCommandMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		}
		else
		{
			V_UNKNOWN(pvar) = NULL;
		}
		break;
	default:
		return E_FAIL;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CCommandStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pCommandMgr != NULL );
	if( m_pCommandMgr == NULL )
	{
		return E_UNEXPECTED;
	}
	ASSERT( m_pCommandMgr->m_pTimeline != NULL );
	if( m_pCommandMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	switch( sp )
	{
	case SP_BEGINSELECT:
	case SP_ENDSELECT:
		if( var.vt != VT_I4 )
		{
			return E_FAIL;
		}
		if( sp == SP_BEGINSELECT )
		{
			m_lBeginSelect = V_I4( &var );
		}
		else
		{
			m_lEndSelect = V_I4( &var );
		}

		if( m_bSelecting )
		{
			break;
		}

		if( m_lBeginSelect == m_lEndSelect )
		{	
			if( m_pCommandMgr->m_bSelected )
			{
				m_pCommandMgr->ClearSelected();
			}
			m_pCommandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			break;
		}
		if( m_fSelected )
		{
			m_pCommandMgr->ClearSelected();
			m_pCommandMgr->SelectSegment( m_lBeginSelect, m_lEndSelect );
		}
		else if( m_pCommandMgr->m_bSelected )
		{
			m_pCommandMgr->ClearSelected();
		}
		else
		{
			break;
		}
		m_pCommandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

		// Update the property page
		if( m_pCommandMgr->m_pIPageManager != NULL )
		{
			m_pCommandMgr->m_pIPageManager->RefreshData();
		}
		break;
	case SP_GUTTERSELECT:
		m_fSelected = V_BOOL( &var );
		if( m_lBeginSelect == m_lEndSelect )
		{
			// Selection doesn't change.
			break;
		}
		if( m_fSelected )
		{
			ASSERT( !m_pCommandMgr->m_bSelected );
			m_pCommandMgr->SelectSegment( m_lBeginSelect, m_lEndSelect );
		}
		else
		{
			m_pCommandMgr->ClearSelected();
		}
		m_pCommandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
		break;
	default:
		return E_FAIL;
	}
	return S_OK;
}

// Make the timeline regain Focus
HRESULT CCommandStrip::GiveTimelineFocus( void )
{
	HRESULT hr = E_POINTER;
	ASSERT(m_pCommandMgr != NULL);
	if(m_pCommandMgr != NULL)
	{
		ASSERT(m_pCommandMgr->m_pTimeline != NULL);
		if(m_pCommandMgr->m_pTimeline != NULL)
		{
			IOleInPlaceObjectWindowless* pIOleInPlaceObjectWindowless;
			if(SUCCEEDED(m_pCommandMgr->m_pTimeline->QueryInterface(IID_IOleInPlaceObjectWindowless, (void **) &pIOleInPlaceObjectWindowless)))
			{
				HWND hWnd;
				pIOleInPlaceObjectWindowless->GetWindow(&hWnd);
				::SetFocus(hWnd);
				pIOleInPlaceObjectWindowless->Release();
				hr = S_OK;
			}
		}
	}
	return hr;
}


HRESULT CCommandStrip::DoDragDrop(WPARAM mousekeybutton, LONG lXPos, long lmeasure)
{
	HRESULT hr;
	BOOL bDrop = TRUE;
	IDropSource*	pIDropSource;
	DWORD			dwEffect = DROPEFFECT_NONE;
	if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
	{
		// create data object and image
		hr = CreateDataObject(&m_pISourceDataObject, lmeasure);
		if(SUCCEEDED(hr))
		{
			m_pDragImage = CreateDragImage();
			if(m_pDragImage)
			{
				m_pDragImage->BeginDrag(0, CPoint(8,12));
			}
			// start drag drop
			DWORD dwOKDragEffects = DROPEFFECT_COPY;
			if(CanCut() == S_OK)
			{
				dwOKDragEffects |= DROPEFFECT_MOVE;
			}
			m_dwStartDragButton = (unsigned long)mousekeybutton;
			m_startDragPosition = lXPos;
			m_nDragDropStatus = source;
			hr = ::DoDragDrop(m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect);

			// drag drop completed, clean up
			m_dwStartDragButton = 0;
			if(m_pDragImage)
			{
				m_pDragImage->EndDrag();
				delete m_pDragImage;
				m_pDragImage = NULL;
			}
			switch(hr)
			{
			case DRAGDROP_S_DROP:
				if(dwEffect & DROPEFFECT_MOVE)
				{
					switch(m_nDragDropStatus)
					{
					case source:
						// target was different strip
						m_nLastEdit = IDS_DELETE;
						break;
					case target:
						m_nLastEdit = IDS_UNDO_MOVE;
						break;
					}
					m_pCommandMgr->DeleteMarkedCommands(DRAG_SELECT);
				}
				if(dwEffect == DROPEFFECT_NONE)
				{
						bDrop = FALSE;
				}
				break;
			default:
				bDrop = FALSE;
				break;
			}
			m_nDragDropStatus = off;
			hr = bDrop ? S_OK : S_FALSE;
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;
		}
		pIDropSource->Release();
		m_pCommandMgr->UnMarkCommands(DRAG_SELECT);
		m_pCommandMgr->SyncWithDirectMusic();
	}
	else
	{
		hr = E_FAIL;
	}

	if(bDrop)
	{
		m_pCommandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
		m_pCommandMgr->OnShowProperties();
		m_pCommandMgr->UpdateSegment();
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CCommandStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(lParam);

	HRESULT			hr = S_FALSE;
	CString			strError;

	ASSERT( m_pCommandMgr != NULL );
	if( m_pCommandMgr == NULL )
	{
		return E_UNEXPECTED;
	}
	
	ASSERT( m_pCommandMgr->m_pTimeline != NULL );
	if( m_pCommandMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	switch( nMsg )
	{

	case WM_LBUTTONDOWN:
		hr = OnLButtonDown( wParam, lXPos, lYPos );
		break;

	case WM_LBUTTONUP:
		m_lXPos = lXPos;
		hr = OnLButtonUp( wParam, lXPos, lYPos );
		break;

	case WM_RBUTTONDOWN:
		// Make sure everything on the timeline is deselected.
		UnselectGutterRange();
		break;

	case WM_RBUTTONUP:
		m_lXPos = lXPos;
		hr = OnRButtonUp( wParam, lXPos, lYPos );
		break;

	case WM_MOUSEMOVE:
		hr = OnMouseMove( wParam, lParam, lXPos, lYPos );
		break;

	case WM_SETFOCUS:
		m_pCommandMgr->m_lShiftFromMeasure = 0;
		break;

	case WM_COMMAND:
		WORD wNotifyCode;
		WORD wID;

		wNotifyCode	= HIWORD( wParam );	// notification code 
		wID			= LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
		case ID_VIEW_PROPERTIES:
			//GiveTimelineFocus();

			// Get a pointer to the property sheet and show it

			VARIANT			var;
			LPUNKNOWN		punk;
			IDMUSProdPropSheet*	pIPropSheet;
			m_pCommandMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
			if( var.vt == VT_UNKNOWN )
			{
				punk = V_UNKNOWN( &var );
				if( punk )
				{
					hr = punk->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
					ASSERT( SUCCEEDED( hr ));
					if( FAILED( hr ))
					{
						hr = E_UNEXPECTED;
						break;
					}
					pIPropSheet->Show( TRUE );
					pIPropSheet->Release();
					punk->Release();
				}
			}
			hr = OnShowProperties(m_pCommandMgr->m_pTimeline);
			if (!m_fShowGroupProps)
			{
				// Change to the groove property page
				m_pCommandMgr->OnShowProperties();
			}
			else
			{
				// Change to our property page
				OnShowProperties();
			}
			hr = S_OK;
			break;
		case ID_EDIT_CUT:
			hr = Cut( NULL );
			break;
		case ID_EDIT_COPY:
			hr = Copy( NULL );
			break;
		case ID_EDIT_DELETE:
			hr = Delete();
			break;
		case ID_EDIT_PASTE:
			if( m_lXPos >= 0 )
			{
				m_bContextMenuPaste = TRUE;
			}
			hr = Paste( NULL );
			m_bContextMenuPaste = FALSE;
			break;
		case ID_EDIT_INSERT:
			hr = Insert();
			m_pCommandMgr->OnShowProperties();
			break;
		case ID_EDIT_SELECT_ALL:
			hr = SelectAll();
			break;
		default:
			break;
		}
		break;

	case WM_CREATE:
		m_cfCommandList = RegisterClipboardFormat( CF_COMMANDLIST );

		// Get Left and right selection boundaries
		m_fSelected = FALSE;
		m_pCommandMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lBeginSelect );
		m_pCommandMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lEndSelect );
		m_pCommandMgr->ClearSelected();
		m_pCommandMgr->m_lShiftFromMeasure = 0;
		break;

	default:
		break;
	}
	return hr;
}

void CCommandStrip::SetEnabledItems( HMENU hMenu )
{
	ASSERT( m_pCommandMgr != NULL );
	if( m_pCommandMgr == NULL )
	{
		return;
	}

	EnableMenuItem( hMenu, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED :
					MF_GRAYED | MF_BYCOMMAND );
	EnableMenuItem( hMenu, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED :
					MF_GRAYED | MF_BYCOMMAND );
	EnableMenuItem( hMenu, ID_EDIT_PASTE, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED :
					MF_GRAYED | MF_BYCOMMAND );
	EnableMenuItem( hMenu, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ? MF_ENABLED :
					MF_GRAYED | MF_BYCOMMAND );
	EnableMenuItem( hMenu, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED :
					MF_GRAYED | MF_BYCOMMAND );
	EnableMenuItem( hMenu, ID_VIEW_PROPERTIES, m_pCommandMgr->m_bSelected ? MF_ENABLED :
					MF_GRAYED | MF_BYCOMMAND );
}


void CCommandStrip::UnselectGutterRange( void )
{
	ASSERT( m_pCommandMgr->m_pTimeline != NULL );

	// Make sure everything on the timeline is deselected.
	m_bSelecting = TRUE;
	m_pCommandMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pCommandMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_bSelecting = FALSE;
}

// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CCommandStrip::GetData

HRESULT CCommandStrip::GetData( void **ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (ppData == NULL) || (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	// Check which property page is requesting the data
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		// Copy our groupbits to the location pointed to by ppData
		PPGTrackParams *pPPGTrackParams = static_cast<PPGTrackParams *>(*ppData);
		pPPGTrackParams->dwGroupBits = m_pCommandMgr->m_dwGroupBits;
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		// Copy our track setting to the location pointed to by ppData
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);
		pPPGTrackFlagsParams->dwTrackExtrasFlags = m_pCommandMgr->m_dwTrackExtrasFlags;
		pPPGTrackFlagsParams->dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
		pPPGTrackFlagsParams->dwProducerOnlyFlags = m_pCommandMgr->m_dwProducerOnlyFlags;
		pPPGTrackFlagsParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;
		break;
	}
	default:
		ASSERT(FALSE);
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCommandStrip::SetData

HRESULT CCommandStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pData == NULL )
	{
		return E_INVALIDARG;
	}
	// Check which property page is setting the data
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		PPGTrackParams *pPPGTrackParams = reinterpret_cast<PPGTrackParams *>(pData);

		// Update our group bits setting, if necessary
		if( pPPGTrackParams->dwGroupBits != m_pCommandMgr->m_dwGroupBits )
		{
			m_pCommandMgr->m_dwGroupBits = pPPGTrackParams->dwGroupBits;

			// Notify our editor that we've changed
			m_nLastEdit = IDS_UNDO_TRACKGROUP;
			m_pCommandMgr->UpdateSegment();
		}
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);

		// Update our track extras flags, if necessary
		if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pCommandMgr->m_dwTrackExtrasFlags )
		{
			m_pCommandMgr->m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;

			// Notify our editor that we've changed
			m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
			m_pCommandMgr->UpdateSegment();
		}
		// Update our Producer-specific flags, if necessary
		else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_pCommandMgr->m_dwProducerOnlyFlags )
		{
			m_pCommandMgr->m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;

			// Notify our editor that we've changed
			m_nLastEdit = IDS_UNDO_PRODUCERONLY;
			m_pCommandMgr->UpdateSegment();
		}
		break;
	}
	default:
		ASSERT(FALSE);
		return E_INVALIDARG;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCommandStrip::OnShowProperties

HRESULT CCommandStrip::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to the Timeline
	if( !m_pCommandMgr->m_pTimeline )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the Framework from the timeline
	IDMUSProdFramework* pIFramework = NULL;
	VARIANT var;
	m_pCommandMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	pIFramework = (IDMUSProdFramework*) V_UNKNOWN(&var);
	if (pIFramework == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}


	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	pIFramework->Release();
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}

	// If our property page is already displayed, exit
	if(m_fPropPageActive)
	{
		ASSERT( m_pPropPageMgr != NULL );
		pIPropSheet->Release();
		return S_OK;
	}

	// Get a reference to our property page manager
	HRESULT hr = S_OK;
	if( m_pPropPageMgr == NULL )
	{
		CGroupBitsPropPageMgr* pPPM = new CGroupBitsPropPageMgr;
		if( NULL == pPPM )
		{
			hr = E_OUTOFMEMORY;
			goto EXIT;
		}
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		m_pPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
		if( FAILED(hr) )
		{
			goto EXIT;
		}
	}

	// Set the property page to refer to the Group property page.
	short nActiveTab;
	nActiveTab = CGroupBitsPropPageMgr::sm_nActiveTab;
	m_pCommandMgr->m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	m_fPropPageActive = TRUE;
	pIPropSheet->SetActivePage( nActiveTab ); 

EXIT:
	// release our reference to the property sheet
	pIPropSheet->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCommandStrip::OnRemoveFromPageManager

HRESULT CCommandStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject(NULL);
	}
	m_fPropPageActive = FALSE;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCommandStrip::OnShowProperties

HRESULT CCommandStrip::OnShowProperties(IDMUSProdTimeline* pTimeline)
{
	HRESULT hr = S_OK;

	// Get a pointer to the property sheet and show it
	VARIANT			var;
	LPUNKNOWN		punk;
	IDMUSProdPropSheet*	pIPropSheet;
	pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	if( var.vt == VT_UNKNOWN )
	{
		punk = V_UNKNOWN( &var );
		if( punk )
		{
			hr = punk->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
			ASSERT( SUCCEEDED( hr ));
			if( FAILED( hr ))
			{
				hr = E_UNEXPECTED;
			}
			else
			{
				pIPropSheet->Show( TRUE );
				pIPropSheet->Release();
			}
			punk->Release();
		}
	}
	m_pCommandMgr->OnShowProperties();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCommandStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CCommandStrip::FBDraw

HRESULT CCommandStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(sv);
	UNREFERENCED_PARAMETER(hDC);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CCommandStrip::FBOnWMMessage

HRESULT CCommandStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lXPos);
	UNREFERENCED_PARAMETER(lYPos);

	// Process the window message
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		m_fShowGroupProps = TRUE;
		OnShowProperties();
		break;
	case WM_RBUTTONUP:
		m_fShowGroupProps = TRUE;
		OnShowProperties();
		m_lXPos = -1;

		// Display a right-click context menu.
		POINT pt;
		// Get the cursor position (To put the menu there)
		if( !GetCursorPos( &pt ) )
		{
			hr = E_UNEXPECTED;
			break;
		}

		if( m_pCommandMgr->m_pTimeline )
		{
			m_pCommandMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);
		}
		break;

	default:
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCommandStrip IDMUSProdTimelineEdit

HRESULT CCommandStrip::Cut( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr;

	hr = CanCut();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	hr = Copy( pITimelineDataObject );
	if( SUCCEEDED( hr ))
	{
		hr = Delete();
	}

	return hr;
}

HRESULT CCommandStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;
	IStream*			pStreamCopy;

	hr = CanCopy();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pCommandMgr != NULL );
	if( m_pCommandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfFormat == 0 )
	{
		m_cfFormat = RegisterClipboardFormat( CF_COMMANDLIST );
		if( m_cfFormat == 0 )
		{
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected commands in.
	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	// Save the commands into the stream.
	hr = m_pCommandMgr->SaveCommandList( pStreamCopy, TRUE );
	if( FAILED( hr ))
	{
		pStreamCopy->Release();
		return E_UNEXPECTED;
	}

	if(pITimelineDataObject != NULL)
	{
		// add the stream to the passed ITimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfFormat, pStreamCopy );
		pStreamCopy->Release();
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			return E_FAIL;
		}
	}
	// Otherwise, add it to the clipboard
	else
	{
		// There is no existing data object, so just create a new one
		hr = m_pCommandMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		ASSERT( hr == S_OK );
		if( hr != S_OK )
		{
			return E_FAIL;
		}

		// Set the start and edit time of this copy
		long lStartTime, lEndTime;
		m_pCommandMgr->GetBoundariesOfSelectedCommands( &lStartTime, &lEndTime );
		hr = pITimelineDataObject->SetBoundaries( lStartTime, lEndTime );

		// add the stream to the ITimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfFormat, pStreamCopy );

		// Release the IStream we copied into
		pStreamCopy->Release();

		// Exit with an error if we failed to add the stream
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}

		// get the IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export( &pIDataObject );

		// Release the ITimelineDataObject
		pITimelineDataObject->Release();

		// Exit if the export failed
		if( FAILED(hr) )
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );

		// Exit if we failed to set the clipboard with our data
		if( hr != S_OK )
		{
			// Release the IDataObject
			pIDataObject->Release();
			return E_FAIL;
		}

		// If we already have a CopyDataObject, release it
		if(	m_pCommandMgr->m_pCopyDataObject )
		{
			m_pCommandMgr->m_pCopyDataObject->Release();
		}

		// Set m_pCopyDataObject to the object we just copied to the clipboard
		m_pCommandMgr->m_pCopyDataObject = pIDataObject;

		// Not needed - Object was AddRef()'d when it was exported from the ITimelienDataObject
		//m_pCommandMgr->m_pCopyDataObject->AddRef();
	}

	return hr;
}

HRESULT CCommandStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;
	IStream*			pStreamPaste;
	
	hr = CanPaste( pITimelineDataObject );
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pCommandMgr != NULL );
	if( m_pCommandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pCommandMgr->m_pTimeline != NULL );
	if( m_pCommandMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Make sure everything on the timeline is deselected.
	UnselectGutterRange();
	
	// If the format hasn't been registered yet, do it now.
	if( m_cfFormat == 0 )
	{
		m_cfFormat = RegisterClipboardFormat( CF_COMMANDLIST );
		if( m_cfFormat == 0 )
		{
			return E_FAIL;
		}
	}
	
	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pCommandMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		pIDataObject->Release();
		if( FAILED(hr) )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}

	// Determine paste measure
	MUSIC_TIME mtTime;
	long lMeasure, lBeat;
	if( m_bContextMenuPaste )
	{
		m_pCommandMgr->m_pTimeline->PositionToClocks( m_lXPos, &mtTime );
	}
	else
	{
		if( FAILED( m_pCommandMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime ) ) )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}
	}
	m_pCommandMgr->m_pTimeline->ClocksToMeasureBeat( m_pCommandMgr->m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
	m_pCommandMgr->m_pTimeline->MeasureBeatToClocks( m_pCommandMgr->m_dwGroupBits, 0, lMeasure, 0, &mtTime );

	hr = pITimelineDataObject->IsClipFormatAvailable(m_cfFormat);
	if(hr != S_OK)
	{
		pITimelineDataObject->Release();
		return E_FAIL;
	}
	
	hr = pITimelineDataObject->AttemptRead( m_cfFormat, &pStreamPaste);
	if(hr != S_OK)
	{
		pITimelineDataObject->Release();
		return E_FAIL;
	}

	// Get the paste type
	TIMELINE_PASTE_TYPE tlPasteType;
	if( FAILED( m_pCommandMgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
	{
		pITimelineDataObject->Release();
		return E_FAIL;
	}

	BOOL fChanged = FALSE;

	if( tlPasteType == TL_PASTE_OVERWRITE )
	{
		long lStart, lEnd, lDiff;
		if( SUCCEEDED( pITimelineDataObject->GetBoundaries( &lStart, &lEnd ) ) )
		{
			ASSERT( lStart < lEnd );

			lDiff = lEnd - lStart;
			lStart = mtTime;
			lEnd = lStart + lDiff;

			fChanged = m_pCommandMgr->DeleteBetweenTimes( lStart, lEnd );
		}
	}
	pITimelineDataObject->Release();
	pITimelineDataObject = NULL;

	// Now, do the paste operation
	hr = m_pCommandMgr->LoadDroppedCommandList( pStreamPaste, 0, FALSE, fChanged );	// This also updates the property page.

	pStreamPaste->Release(); 
	if( FAILED( hr ) )
	{
		return E_FAIL;
	}

	if(SUCCEEDED(hr) && fChanged)
	{
		m_nLastEdit = IDS_PASTE;
		m_pCommandMgr->UpdateSegment();
		m_pCommandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
	}

	return S_OK;
}

HRESULT CCommandStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT			hr;

	hr = CanInsert();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pCommandMgr != NULL );
	if( m_pCommandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pCommandMgr->m_pTimeline != NULL );
	if( m_pCommandMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Make sure everything on the timeline is deselected.
	UnselectGutterRange();

	m_nLastEdit = IDS_INSERT;
	hr = m_pCommandMgr->InsertCommand( -1 );	// Insert at first selected.
	m_pCommandMgr->UpdateSegment();
	m_pCommandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	return hr;
}

HRESULT CCommandStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	/* Ignore this, since we can be in a Cut() operation.  We can cut blank data, but we can't delete it.
	HRESULT hr = CanDelete();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}
	*/

	ASSERT( m_pCommandMgr != NULL );
	if( m_pCommandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pCommandMgr->m_pTimeline != NULL );
	if( m_pCommandMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_nLastEdit = IDS_DELETE;
	m_pCommandMgr->DeleteSelected();
	m_pCommandMgr->UpdateSegment();
	m_pCommandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	return S_OK;
}

HRESULT CCommandStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pCommandMgr != NULL );
	if( m_pCommandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pCommandMgr->m_pTimeline != NULL );
	if( m_pCommandMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_pCommandMgr->SelectAll();

	m_pCommandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
	if( m_pCommandMgr->m_pIPageManager != NULL )
	{
		m_pCommandMgr->m_pIPageManager->RefreshData();
	}
	
	return S_OK;
}

HRESULT CCommandStrip::CanCut( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pCommandMgr != NULL );
	if( m_pCommandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can cut even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pCommandMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pCommandMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pCommandMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	if( CanCopy() == S_OK && CanDelete() == S_OK )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}

HRESULT CCommandStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pCommandMgr != NULL );
	if( m_pCommandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can cut even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pCommandMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pCommandMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pCommandMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	//return m_pCommandMgr->m_bSelected ? S_OK : S_FALSE;
	if (m_pCommandMgr->m_bSelected)
	{
		CommandExt* pCommand = m_pCommandMgr->GetFirstSelectedCommand();
		return pCommand == NULL ? S_FALSE : S_OK;
	}
	else return S_FALSE;
}

HRESULT CCommandStrip::CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = S_FALSE;

	ASSERT( m_pCommandMgr != NULL );
	if( m_pCommandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfFormat == 0 )
	{
		m_cfFormat = RegisterClipboardFormat( CF_COMMANDLIST );
		if( m_cfFormat == 0 )
		{
			return E_FAIL;
		}
	}

	// If pITimelineDataObject != NULL, check it.
	if( pITimelineDataObject != NULL )
	{
		hr = pITimelineDataObject->IsClipFormatAvailable( m_cfFormat );
	}
	// Otherwise, check the clipboard
	else
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		if( SUCCEEDED( OleGetClipboard(&pIDataObject) ) )
		{
			// Create a new TimelineDataObject
			IDMUSProdTimelineDataObject *pITimelineDataObject;
			if( SUCCEEDED( m_pCommandMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
			{
				// Insert the IDataObject into the TimelineDataObject
				if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
				{
					hr = pITimelineDataObject->IsClipFormatAvailable(m_cfFormat);
				}
				pITimelineDataObject->Release();
			}
			pIDataObject->Release();
		}
	}

	if (hr == S_OK)
	{
		return S_OK;
	}

	return S_FALSE;
}

HRESULT CCommandStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pCommandMgr != NULL );
	if( m_pCommandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	//return m_pCommandMgr->m_bSelected ? S_OK : S_FALSE;
	if (m_pCommandMgr->m_bSelected)
	{
		CommandExt* pCommand = m_pCommandMgr->GetFirstSelectedCommand();
		return pCommand == NULL ? S_OK : S_FALSE;
	}
	else return S_FALSE;
}

HRESULT CCommandStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pCommandMgr != NULL );
	if( m_pCommandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	//return m_pCommandMgr->m_bSelected ? S_OK : S_FALSE;
	if (m_pCommandMgr->m_bSelected)
	{
		CommandExt* pCommand = m_pCommandMgr->GetFirstSelectedCommand();
		return pCommand == NULL ? S_FALSE : S_OK;
	}
	else return S_FALSE;
}

HRESULT CCommandStrip::CanSelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Look through all measures for a command
	for( int n = 0; n < m_pCommandMgr->m_nMeasures; n++ )
	{
		if( m_pCommandMgr->m_pMeasureArray[n].pCommand )
		{
			// Found a command - return S_OK (yes)
			return S_OK;
		}
	}

	// No commands found - return S_FALSE (no)
	return S_FALSE;
}


// IDropSource Methods
HRESULT CCommandStrip::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton & MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton & MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}

HRESULT CCommandStrip::GiveFeedback( DWORD dwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwEffect);

	if( m_pDragImage )
	{
		CPoint pt;
		GetCursorPos( &pt );

		// Move the drag image
		m_pDragImage->DragMove( pt );
	}

	return DRAGDROP_S_USEDEFAULTCURSORS;
}

CImageList* CCommandStrip::CreateDragImage()
{
	/*
	CImageList* pimage = new CImageList;
	ASSERT(pimage);
	if(!pimage)
	{
		return 0;
	}
	pimage->Create(::GetSystemMetrics(SM_CXICON), ::GetSystemMetrics(SM_CYICON),
					ILC_COLOR4 | ILC_MASK, 1,1);
	pimage->SetBkColor(CLR_NONE);
	HICON hIcon = ::LoadIcon( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_ICON1));
	if(hIcon == NULL)
	{
		//DWORD err = ::GetLastError();
	}
	pimage->Add(hIcon);
	return pimage;
	*/
	return NULL;
}

HRESULT	CCommandStrip::CreateDataObject(IDataObject** ppIDataObject, long measure)
{
	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	ASSERT( m_pCommandMgr != NULL );
	if( m_pCommandMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pCommandMgr->m_pTimeline != NULL );
	if( m_pCommandMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// get pJazzFramework
	VARIANT var;
	LPUNKNOWN punk;
	IDMUSProdFramework* pJazzFramework = NULL;
	m_pCommandMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	if( var.vt == VT_UNKNOWN )
	{
		punk = V_UNKNOWN(&var);
		if( punk )
		{
			punk->QueryInterface( IID_IDMUSProdFramework, (void**)&pJazzFramework );
			punk->Release();
		}
	}
	ASSERT(pJazzFramework != NULL);
	if(pJazzFramework == NULL)
	{
		return E_UNEXPECTED;
	}

	

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Selected Commands into stream
	HRESULT hr = E_FAIL;


	if( SUCCEEDED ( pJazzFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{

		// mark the chords as being dragged: this used later for deleting chords in drag move
		// make sure that if this strip is drop target that they get deselected!
		short nZeroOffset = m_pCommandMgr->MarkSelectedCommands(DRAG_SELECT);
		measure -= nZeroOffset;
		// write measure at which mouse grabbed drag selection into the stream
		DWORD cb;
		hr = pIStream->Write( &measure, sizeof( long ), &cb );
	    if( FAILED( hr ) || cb != sizeof( long ))
		{
			hr = E_FAIL;
			goto Leave;
		}


		if( SUCCEEDED ( m_pCommandMgr->SaveDroppedCommandList( pIStream, TRUE, nZeroOffset ) ) )
		{
			// Place CF_COMMANDLIST into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_cfCommandList, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		pIStream->Release();
	}

Leave:
	if(pJazzFramework)
		pJazzFramework->Release();
	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;

}

/////////////////////////////////////////////////// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// IDropTarget CCommandStrip::DragEnter

HRESULT CCommandStrip::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	//TRACE("CCommandStrip Drag Enter!\n");
	ASSERT( pIDataObject != NULL );
	ASSERT( m_pITargetDataObject == NULL );

	// Store IDataObject associated with current drag-drop operation
	m_pITargetDataObject = pIDataObject;
	m_pITargetDataObject->AddRef();

	if( m_pDragImage )
	{
		CPoint point( pt.x, pt.y );

		// Show the feedback image
		m_pDragImage->DragEnter( CWnd::FromHandle( ::GetDesktopWindow() ), point );
	}
/*
	// Make sure editor is on top
	if( m_pStyle->m_hWndEditor )
	{
		::BringWindowToTop( m_pStyle->m_hWndEditor );
	}
*/
	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CCommandStrip::DragOver

HRESULT CCommandStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	//TRACE("CCommandStrip Drag OVER!\n");
	if(m_pITargetDataObject == NULL)
		ASSERT( m_pITargetDataObject != NULL );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragShowNolock( FALSE );
	}

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	LONG lLeftSide, lRightSide;
	if( (pt.x >= 0) &&
		SUCCEEDED( m_pCommandMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftSide ) ) &&
		SUCCEEDED( m_pCommandMgr->m_pTimeline->ClocksToPosition( lLeftSide, &lLeftSide ) ) &&
		(pt.x >= lLeftSide) && SUCCEEDED( m_pCommandMgr->m_pTimeline->MeasureBeatToPosition( m_pCommandMgr->m_dwGroupBits,0, m_pCommandMgr->m_nMeasures, 0, &lRightSide ) ) &&
		(pt.x < lRightSide ) && (CanPasteFromData( m_pITargetDataObject ) == S_OK) )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			dwEffect = *pdwEffect;
		}
		else
		{
			if( grfKeyState & MK_CONTROL )
			{
				dwEffect = DROPEFFECT_COPY;
			}
			else
			{
				if( *pdwEffect & DROPEFFECT_COPY
				&&  *pdwEffect & DROPEFFECT_MOVE )
				{
					dwEffect = DROPEFFECT_MOVE;
				}
				else
				{
					dwEffect = *pdwEffect;
				}
			}
		}
	}

	if( m_pDragImage )
	{
		// Show the feedback image
		m_pDragImage->DragShowNolock( TRUE );
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CCommandStrip::DragLeave

HRESULT CCommandStrip::DragLeave( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	//TRACE("CCommandStrip Drag Leave!\n");

	// Release IDataObject
	if( m_pITargetDataObject )
	{
		m_pITargetDataObject->Release();
		m_pITargetDataObject = NULL;
	}

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( CWnd::FromHandle( ::GetDesktopWindow() ) );
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CCommandStrip::Drop

HRESULT CCommandStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(grfKeyState);

	ASSERT( m_pITargetDataObject != NULL );
	ASSERT( m_pITargetDataObject == pIDataObject );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( CWnd::FromHandle( ::GetDesktopWindow() ) );
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;
		
		// Display arrow cursor
		::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
	
		// Prepare context menu
		hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Get a window to attach menu to
			HWND hwnd = GetTimelineHWND();
			if(hwnd)
			{
				// Display and track menu
				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  pt.x, pt.y, 0, hwnd, NULL );
				DestroyMenu( hMenu );

				// Need to process WM_COMMAND from TrackPopupMenu
				MSG msg;
				while( ::PeekMessage( &msg, hwnd, NULL, NULL, PM_REMOVE) )
				{
					if( msg.message == WM_COMMAND )
					{
						OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
					}
					else
					{
						TranslateMessage( &msg );
						DispatchMessage( &msg );
					}
				}

				// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
				m_dwOverDragEffect = m_dwDragRMenuEffect;
				m_dwDragRMenuEffect = DROPEFFECT_NONE;
			}
		}
	}

	// Paste data
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		if(m_nDragDropStatus == source)
		{
		//	don't drop at same place

			long lSource, lTarget;
			if( FAILED( m_pCommandMgr->m_pTimeline->PositionToMeasureBeat( 
								m_pCommandMgr->m_dwGroupBits, 0, m_startDragPosition, &lSource, NULL ) ))
			{
				ASSERT( FALSE );
				return E_UNEXPECTED;
			}
			if( FAILED( m_pCommandMgr->m_pTimeline->PositionToMeasureBeat( 
								m_pCommandMgr->m_dwGroupBits, 0, pt.x, &lTarget, NULL ) ))
			{
				ASSERT( FALSE );
				return E_UNEXPECTED;
			}

			if(lSource == lTarget)
			{
				m_pITargetDataObject->Release();
				m_pITargetDataObject = NULL;
				*pdwEffect = DROPEFFECT_NONE;
				if(m_wParam & MK_LBUTTON)
					OnLButtonUp(m_wParam, pt.x, pt.y);
				else if(m_wParam & MK_RBUTTON)
					OnRButtonUp(m_wParam, pt.x, pt.y);
				return S_OK;
			}
		}
		
		BOOL fChanged = FALSE;
		hr = PasteAt( pIDataObject, pt.x, fChanged );

		if(m_nDragDropStatus == source)
		{
			// in our strip, give the handshake
			m_nDragDropStatus = target;
		}
		else
		{
			if( fChanged )
			{
				m_nLastEdit = IDS_INSERT;
				m_pCommandMgr->UpdateSegment();
				m_pCommandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
				// Update the property page and the object we represent.
				if( m_pCommandMgr->m_pIPageManager != NULL )
				{
					m_pCommandMgr->m_pIPageManager->RefreshData();
				}

				if( m_nDragDropStatus != source )
				{
					UnselectGutterRange();
				}

			}
		}
		if( SUCCEEDED ( hr ) )
		{
			*pdwEffect = m_dwOverDragEffect;
		}
	}

	// Cleanup
	DragLeave();

	return hr;
}



HWND CCommandStrip::GetTimelineHWND()
{
	if( m_pCommandMgr->m_pTimeline )
	{
		IOleWindow *pIOleWindow;
		if( SUCCEEDED(m_pCommandMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow ) ) )
		{
			HWND hwnd = NULL;
			pIOleWindow->GetWindow( &hwnd );
			pIOleWindow->Release();
			return hwnd;
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////// Drop (and paste) helpers
//
HRESULT CCommandStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfCommandList ) ))
	{
		hr = S_OK;
	}

	pDataObject->Release();
	return hr;
}



HRESULT CCommandStrip::PasteAt(IDataObject* pIDataObject, long lPastePos, BOOL &fChanged )
{
	if( pIDataObject == NULL )
	{
		return E_NOTIMPL;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfCommandList ) ) )
	{
		IStream* pIStream;
		if(SUCCEEDED (pDataObject->AttemptRead( pIDataObject, m_cfCommandList, &pIStream)))
		{
			hr = m_pCommandMgr->LoadDroppedCommandList( pIStream, lPastePos, true, fChanged );
		}
	}

	
	pDataObject->Release();
	
	return hr;
}

HRESULT CCommandStrip::OnRButtonUp( WPARAM wParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(lYPos);
	m_fShowGroupProps = FALSE;

	// Get the measure number
	long lMeasure;
	if( FAILED( m_pCommandMgr->m_pTimeline->PositionToMeasureBeat( m_pCommandMgr->m_dwGroupBits, 0, lXPos, &lMeasure, NULL ) ))
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	if( !m_pCommandMgr->m_bSelected )
	{
		// Make sure everything on the timeline is deselected.
		UnselectGutterRange();

		// If nothing is selected, select this measure.
		m_pCommandMgr->ToggleSelect( lMeasure );
		m_pCommandMgr->m_lShiftFromMeasure = lMeasure;

		m_pCommandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*) this, NULL, TRUE );
	}
	else if( !( wParam & ( MK_SHIFT | MK_CONTROL )))
	{
		// Make sure this measure is in the selected list.  If it isn't, make it the only one selected
		if( !m_pCommandMgr->IsSelected( lMeasure ))
		{
			// Make sure everything on the timeline is deselected first.
			UnselectGutterRange();

			m_pCommandMgr->ClearSelected();
			m_pCommandMgr->ToggleSelect( lMeasure );
			m_pCommandMgr->m_lShiftFromMeasure = lMeasure;
		}
		m_pCommandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*) this, NULL, TRUE );
	}

	if (!m_fShowGroupProps)
	{
		// Change to the groove property page
		m_pCommandMgr->OnShowProperties();
	}
	else
	{
		// Change to our property page
		OnShowProperties();
	}
	//if( m_pCommandMgr->m_pIPageManager != NULL )
	//{
	//	m_pCommandMgr->m_pIPageManager->RefreshData();
	//}

	// Get the cursor position (To put the menu there)
	POINT pt;
	if( !GetCursorPos( &pt ) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	m_pCommandMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);

	return S_OK;
}

HRESULT CCommandStrip::OnLButtonUp( WPARAM wParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lYPos);
	m_fShowGroupProps = FALSE;

	// Release mouse capture
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	m_pCommandMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	m_fLButtonDown = FALSE;
	m_dwStartDragButton = 0;

	// Get the clock position
	long lClocks;
	if( FAILED(m_pCommandMgr->m_pTimeline->PositionToClocks( lXPos, &lClocks)))
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}
	// Get the measure number 
	long lMeasure;
	if(FAILED(m_pCommandMgr->m_pTimeline->ClocksToMeasureBeat( m_pCommandMgr->m_dwGroupBits, 0, lClocks, &lMeasure, NULL)))
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	if(!(wParam & MK_CONTROL) && !(wParam & MK_SHIFT))
	{
		m_pCommandMgr->ClearSelected();
		// Toggle the selection state of this measure
		m_pCommandMgr->ToggleSelect(lMeasure);
		// Redraw our strip
		m_pCommandMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
	}
	else if((wParam & MK_CONTROL) && m_bWasSelected)
	{
		m_bWasSelected = false;
		m_pCommandMgr->ToggleSelect(lMeasure);
		// Redraw our strip
		m_pCommandMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
	}

	return S_OK;
}

HRESULT CCommandStrip::OnMouseMove( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(wParam);

	// Get the measure number
	long lMeasure;
	if( FAILED( m_pCommandMgr->m_pTimeline->PositionToMeasureBeat( m_pCommandMgr->m_dwGroupBits, 0, lXPos, &lMeasure, NULL ) ))
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	if( m_fLButtonDown )
	{
		// Release mouse capture
		VARIANT var;
		var.vt = VT_BOOL;
		V_BOOL(&var) = FALSE;
		m_pCommandMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

		// Do Drag'n'drop
		m_wParam = wParam;
		DoDragDrop(m_dwStartDragButton, lXPos, lMeasure);

		// Clear button down flag so we don't do drag'n'drop again.
		m_fLButtonDown= FALSE;

		// need to clear this else control select gets messed up
		m_bWasSelected = false;
	}

	return S_OK;
}

HRESULT CCommandStrip::OnLButtonDown( WPARAM wParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(lYPos);
	long lMeasure;

	m_fShowGroupProps = FALSE;

	m_wParam = wParam;

	// Make sure everything on the timeline is deselected.
	UnselectGutterRange();

	// Get the time position of the mouse click.
	long lClocks;
	if( FAILED( m_pCommandMgr->m_pTimeline->PositionToClocks( lXPos, &lClocks ) ))
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get the measure number
	if( FAILED( m_pCommandMgr->m_pTimeline->ClocksToMeasureBeat( m_pCommandMgr->m_dwGroupBits, 0, lClocks, &lMeasure, NULL ) ) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	if( wParam & MK_SHIFT )
	{
		if( !( wParam & MK_CONTROL ))
		{
			m_pCommandMgr->ClearSelected();
		}
		m_pCommandMgr->SelectSegment( -1, lClocks );
		m_pCommandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
		m_pCommandMgr->OnShowProperties();
		GiveTimelineFocus();
		return S_OK;
	}

	// Get the measure number
	if( FAILED( m_pCommandMgr->m_pTimeline->ClocksToMeasureBeat( m_pCommandMgr->m_dwGroupBits, 0, lClocks, &lMeasure, NULL ) ) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	m_pCommandMgr->m_lShiftFromMeasure = lMeasure;

	// Get the info for the selected measure
	CommandMeasureInfo*	pMeasureInfo = NULL;
	if ( lMeasure >=0 && lMeasure < m_pCommandMgr->m_nMeasures )
	{
		pMeasureInfo = &(m_pCommandMgr->m_pMeasureArray[lMeasure]);
	}

	if( pMeasureInfo )
	{

		if(pMeasureInfo->pCommand && pMeasureInfo->dwFlags & CMI_SELECTED )
		{
			m_pCommandMgr->OnShowProperties();

			// If not already dragging, start drag'n'drop
			if( !m_dwStartDragButton )
			{
//				DoDragDrop(wParam, lXPos, lMeasure);
				m_dwStartDragButton = wParam;
				m_fLButtonDown = TRUE;
			}
			// capture mouse so we get the LBUTTONUP message as well
			// the timeline will release the capture when it receives the
			// LBUTTONUP message
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pCommandMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
			// indicate toggle select to mouse up
			if(wParam & MK_CONTROL)
			{
				m_bWasSelected = true;
			}
		}
		else
		{
			// capture mouse so we get the LBUTTONUP message as well
			// the timeline will release the capture when it receives the
			// LBUTTONUP message
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pCommandMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

			// If we clicked on a command, set m_fLButtonDown to TRUE
			if( pMeasureInfo->pCommand )
			{
				m_dwStartDragButton = wParam;
				m_fLButtonDown = TRUE;
			}

			// If CTRL is not pressed, clear all selections in our strip
			if( !( wParam & MK_CONTROL ))
			{
				m_pCommandMgr->ClearSelected();
				m_pCommandMgr->ToggleSelect(lMeasure);
			}
			else if( wParam & MK_CONTROL && pMeasureInfo->dwFlags & CMI_SELECTED)
			{
				// indicate toggle select to mouse up
				m_bWasSelected = true;
			}
			else
			{
				// Toggle the selection state of this measure
				m_pCommandMgr->ToggleSelect( lMeasure );
			
			}
			// Set the properties to the ones for the current selection.
			m_pCommandMgr->OnShowProperties();
			GiveTimelineFocus();
			// Redraw our strip
			m_pCommandMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
		}
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\Detours\disasm.h ===
//////////////////////////////////////////////////////////////////////////////
//
//	Module:		detours.lib
//  File:		disasm.h
//
//	Detours for binary functions.  Version 1.3. (Build 43)
//  Includes support for all x86 chips prior to the Pentium III.
//
//	Copyright 1999, Microsoft Corporation
//
//	http://research.microsoft.com/sn/detours
//

#pragma once
#ifndef _DISASM_H_
#define _DISASM_H_

class CDetourDis
{
  public:
	CDetourDis(PBYTE *ppbTarget, LONG *plExtra);
	
	PBYTE 	CopyInstruction(PBYTE pbDst, PBYTE pbSrc);
	static BOOL	SanityCheckSystem();

  public:
	struct COPYENTRY;
	typedef const COPYENTRY * REFCOPYENTRY;

	typedef PBYTE (CDetourDis::* COPYFUNC)(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);

	enum {
		DYNAMIC 	= 0x1u,
		ADDRESS 	= 0x2u,
		NOENLARGE	= 0x4u,

		SIB			= 0x10u,
		NOTSIB		= 0x0fu,
	};
	struct COPYENTRY 
	{
		ULONG 		nOpcode 		: 8;				// Opcode
		ULONG		nFixedSize 		: 3;				// Fixed size of opcode
		ULONG		nFixedSize16 	: 3;				// Fixed size when 16 bit operand
		ULONG		nModOffset 		: 3;				// Offset to mod/rm byte (0=none)
		LONG		nRelOffset 		: 3;				// Offset to relative target.
		ULONG		nFlagBits		: 4;				// Flags for DYNAMIC, etc.
		COPYFUNC	pfCopy;								// Function pointer.
	};

  protected:
#define ENTRY_CopyBytes1			1, 1, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes1Dynamic		1, 1, 0, 0, DYNAMIC, CopyBytes
#define ENTRY_CopyBytes2			2, 2, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes2Jump		2, 2, 0, 1, 0, CopyBytes
#define ENTRY_CopyBytes2CantJump	2, 2, 0, 1, NOENLARGE, CopyBytes
#define ENTRY_CopyBytes2Dynamic		2, 2, 0, 0, DYNAMIC, CopyBytes
#define ENTRY_CopyBytes3			3, 3, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes3Dynamic		3, 3, 0, 0, DYNAMIC, CopyBytes
#define ENTRY_CopyBytes3Or5			5, 3, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes3Or5Target	5, 3, 0, 1, 0, CopyBytes
#define ENTRY_CopyBytes5Or7Dynamic	7, 5, 0, 0, DYNAMIC, CopyBytes
#define ENTRY_CopyBytes3Or5Address	5, 3, 0, 0, ADDRESS, CopyBytes
#define ENTRY_CopyBytes4			4, 4, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes5			5, 5, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes7			7, 7, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes2Mod			2, 2, 1, 0, 0, CopyBytes
#define ENTRY_CopyBytes2Mod1		3, 3, 1, 0, 0, CopyBytes
#define ENTRY_CopyBytes2ModOperand	6, 4, 1, 0, 0, CopyBytes
#define ENTRY_CopyBytes3Mod			3, 3, 2, 0, 0, CopyBytes
#define ENTRY_CopyBytesPrefix		1, 1, 0, 0, 0, CopyBytesPrefix
#define ENTRY_Copy0F				1, 1, 0, 0, 0, Copy0F
#define ENTRY_Copy66				1, 1, 0, 0, 0, Copy66
#define ENTRY_Copy67				1, 1, 0, 0, 0, Copy67
#define ENTRY_CopyF6				0, 0, 0, 0, 0, CopyF6
#define ENTRY_CopyF7				0, 0, 0, 0, 0, CopyF7
#define ENTRY_CopyFF				0, 0, 0, 0, 0, CopyFF
#define ENTRY_Invalid				1, 1, 0, 0, 0, Invalid
#define ENTRY_End					0, 0, 0, 0, 0, NULL
	
	PBYTE CopyBytes(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE CopyBytesPrefix(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	
	PBYTE Invalid(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);

	PBYTE AdjustTarget(PBYTE pbDst, PBYTE pbSrc, LONG cbOp, LONG cbTargetOffset);
	
	VOID	Set16BitOperand();
	VOID	Set32BitOperand();
	VOID	Set16BitAddress();
	VOID	Set32BitAddress();
	
  protected:
	PBYTE Copy0F(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE Copy66(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE Copy67(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE CopyF6(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE CopyF7(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE CopyFF(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);

  protected:	
	static const COPYENTRY	s_rceCopyTable[257];
	static const COPYENTRY	s_rceCopyTable0F[257];
	static const BYTE 		s_rbModRm[256];

  protected:
	BOOL				m_b16BitOperand;
	BOOL				m_b16BitAddress;

	PBYTE *				m_ppbTarget;
	LONG *				m_plExtra;
	
	LONG				m_lScratchExtra;
	PBYTE				m_pbScratchTarget;
	BYTE				m_rbScratchDst[64];
};

#endif //_DISASM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\CommandStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6E6AD933_CD54_11D0_BBE9_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__6E6AD933_CD54_11D0_BBE9_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6E6AD933_CD54_11D0_BBE9_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\CommandStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CommandStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDR_COMMANDMGR                  102
#define IDS_PROPPAGE_GROUP_BITS         110
#define IDS_INTRO_TEXT                  111
#define IDS_FILL_TEXT                   112
#define IDS_BREAK_TEXT                  113
#define IDS_END_TEXT                    114
#define IDS_CUSTOM_TEXT                 115
#define IDS_NONE_TEXT                   116
#define IDS_RANDOM                      117
#define IDS_REPEAT                      118
#define IDS_SEQUENTIAL                  119
#define IDS_RANDOM_START                120
#define IDS_NO_REPEAT                   121
#define IDS_RANDOM_ROW                  122
#define IDC_COMMAND_EMBELLISHMENTLIST   201
#define IDC_COMMAND_GROOVELIST          202
#define IDI_ICON1                       203
#define IDD_PROPPAGE_COMMANDS           205
#define IDD_PROPPAGE_COMMANDS1          206
#define IDC_COMMAND_GRPEMBELLISHMENT    207
#define IDC_COMMAND_GRPGROOVELEVEL      208
#define IDC_EDIT_GROOVE_LEVEL           211
#define IDC_SPIN_GROOVE_LEVEL           212
#define IDC_CHECK_GROOVE_LEVEL          213
#define IDC_EDIT_GROOVE_RANGE           214
#define IDC_SPIN_GROOVE_RANGE           215
#define IDC_COMBO_REPEAT_PATTERN        216
#define IDC_EDIT_EMB_CUSTOM             217
#define IDC_SPIN_EMB_CUSTOM             218
#define IDC_STATIC_EMB_CUSTOM           219
#define IDC_INTRO                       238
#define IDC_FILL                        239
#define IDC_BREAK                       240
#define IDC_END                         241
#define IDC_NOCOMMAND                   242
#define IDC_GRPEMBELLISHMENT            243
#define IDM_DRAG_RMENU                  243
#define IDC_GRVA                        244
#define IDC_GRVB                        245
#define IDC_GRVC                        246
#define IDC_GRVD                        247
#define IDC_NOGROOVE                    248
#define IDC_GRPGROOVELEVEL              249
#define ID_VIEW_PROPERTIES              32768
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define IDS_PROPPAGE_COMMAND            32778
#define IDS_FUNCTIONBAR_TEXT            32779
#define IDS_INSERT                      32780
#define IDS_DELETE                      32781
#define IDS_PASTE                       32782
#define IDS_CHANGE                      32783
#define IDS_TRACK_NAME                  32784
#define IDS_EDITOR_NAME                 32785
#define IDS_UNDO_TRACKGROUP             32786
#define IDS_UNDO_MOVE                   32787
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808
#define IDS_UNDO_TRACKEXTRAS            57718
#define IDS_UNDO_PRODUCERONLY           57719

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        205
#define _APS_NEXT_COMMAND_VALUE         32778
#define _APS_NEXT_CONTROL_VALUE         220
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\Detours\dtrsint.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  File:       dtrsint.h
//  Module:     detours.lib
//
//  Detours for binary functions.  Version 1.3. (Build 43)
//
//  Copyright 1995-1999, Microsoft Corporation
//
//  http://research.microsoft.com/sn/detours
//

#pragma once
#ifndef _DTRSINT_H_
#define _DTRSINT_H_

//////////////////////////////////////////////////////////////////////////////
//
typedef LPAPI_VERSION (NTAPI *PF_ImagehlpApiVersionEx)(LPAPI_VERSION AppVersion);

typedef BOOL (NTAPI *PF_SymInitialize)(IN HANDLE hProcess,
                                       IN LPSTR UserSearchPath,
                                       IN BOOL fInvadeProcess);
typedef DWORD (NTAPI *PF_SymSetOptions)(IN DWORD SymOptions);
typedef DWORD (NTAPI *PF_SymGetOptions)(VOID);
typedef BOOL (NTAPI *PF_SymLoadModule)(IN HANDLE hProcess,
                                       IN HANDLE hFile,
                                       IN PSTR ImageName,
                                       IN PSTR ModuleName,
                                       IN DWORD BaseOfDll,
                                       IN DWORD SizeOfDll);
typedef BOOL (NTAPI *PF_SymGetModuleInfo)(IN HANDLE hProcess,
                                          IN DWORD dwAddr,
                                          OUT PIMAGEHLP_MODULE ModuleInfo);
typedef BOOL (NTAPI *PF_SymGetSymFromName)(IN HANDLE hProcess,
                                           IN LPSTR Name,
                                           OUT PIMAGEHLP_SYMBOL Symbol);
typedef BOOL (NTAPI *PF_BindImage)(IN LPSTR pszImageName,
                                   IN LPSTR pszDllPath,
                                   IN LPSTR pszSymbolPath);

typedef struct _DETOUR_SYM_INFO
{
    HANDLE                   hProcess;
    HMODULE                  hImageHlp;
    PF_ImagehlpApiVersionEx  pfImagehlpApiVersionEx;
    PF_SymInitialize         pfSymInitialize;
    PF_SymSetOptions         pfSymSetOptions;
    PF_SymGetOptions         pfSymGetOptions;
    PF_SymLoadModule         pfSymLoadModule;
    PF_SymGetModuleInfo      pfSymGetModuleInfo;
    PF_SymGetSymFromName     pfSymGetSymFromName;
    PF_BindImage             pfBindImage;
} DETOUR_SYM_INFO, *PDETOUR_SYM_INFO;

//////////////////////////////////////////////////////////////////////////////
//
PDETOUR_SYM_INFO DetourLoadImageHlp(VOID);

//////////////////////////////////////////////////////////////////////////////
//
inline PBYTE DetourGenMovEax(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xB8;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEbx(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBB;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEcx(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xB9;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEdx(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBA;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEsi(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBE;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEdi(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBF;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEbp(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBD;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEsp(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBC;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenPush(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0x68;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenJmp(PBYTE pbCode, PBYTE pbJmpDst, PBYTE pbJmpSrc = 0)
{
    if (pbJmpSrc == 0) {
        pbJmpSrc = pbCode;
    }
    *pbCode++ = 0xE9;
    *((INT32*&)pbCode)++ = pbJmpDst - (pbJmpSrc + 5);
    return pbCode;
}

inline PBYTE DetourGenCall(PBYTE pbCode, PBYTE pbJmpDst, PBYTE pbJmpSrc = 0)
{
    if (pbJmpSrc == 0) {
        pbJmpSrc = pbCode;
    }
    *pbCode++ = 0xE8;
    *((INT32*&)pbCode)++ = pbJmpDst - (pbJmpSrc + 5);
    return pbCode;
}

inline PBYTE DetourGenBreak(PBYTE pbCode)
{
    *pbCode++ = 0xcc;
    return pbCode;
}

inline PBYTE DetourGenBreakRet(PBYTE pbCode)
{
    *pbCode++ = 0xc3;
    return pbCode;
}

inline PBYTE DetourGenBreakNop(PBYTE pbCode)
{
    *pbCode++ = 0x90;
    return pbCode;
}

#endif // _DTRSINT_H_

////////////////////////////////////////////////////////////////  End of File.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\buffer.cpp ===
#include "stdafx.h"
#include "dslink.h"
#include "audiosink.h"

#include "stdafx.h"
#include "dslink.h"
#include "audiosink.h"
#include "math.h"
#include "cconduct.h"
#include "effects.h"
#include "dsbufcfg.h"

DWORD CBuffer::m_sdwNextBusID = 1;

CBuffer::CBuffer(CAudioSink *pSink,LPCDSBUFFERDESC pcBufferDesc,LPDWORD pdwFuncID, DWORD dwBusIDCount, REFGUID guidBufferID)
{
    m_cRef = 0;
	AddRef();

	InitializeCriticalSection( &m_CriticalSection );

    m_pParentSink = pSink;
    m_guidBufferID = guidBufferID;
    m_dwBusCount = dwBusIDCount;
    // Make sure we don't go out of bounds.
    if (m_dwBusCount > AUDIOSINK_MAX_CHANNELS)
    {
        m_dwBusCount = AUDIOSINK_MAX_CHANNELS;
    }

    // How many channels in the buffer?
    if (pcBufferDesc && pcBufferDesc->lpwfxFormat)
    {
        m_dwChannels = pcBufferDesc->lpwfxFormat->nChannels;
    }
    else m_dwChannels = 1;

	// Copy the buffer flags
	if( pcBufferDesc )
	{
		m_dwType = pcBufferDesc->dwFlags;
	}
	else
	{
		if( dwBusIDCount )
		{
			m_dwType = DSBCAPS_SINKIN;
		}
		else
		{
			m_dwType = DSBCAPS_MIXIN;
		}
	}

    // Fill in the bus values for the buses that we want to connect to this buffer.
    DWORD dwIndex = 0;
	if( pSink && pdwFuncID )
	{
		for (;dwIndex < m_dwBusCount;dwIndex++)
		{
			m_dwFunctionIDs[dwIndex] = pdwFuncID[dwIndex];
			m_dwBusIDs[dwIndex] = m_sdwNextBusID++;
			m_pBusBuffer[dwIndex] = new short[pSink->m_dwBusBufferSize];
		}
	}

    // Remaining channels on the buffer get null bus and function ids.
    for (;dwIndex < m_dwChannels;dwIndex++)
    {
        m_dwFunctionIDs[dwIndex] = AUDIOSINK_NULL_BUS_ID;
        m_dwBusIDs[dwIndex] = AUDIOSINK_NULL_BUS_ID;
        m_pBusBuffer[dwIndex] = NULL;
    }

    m_lVolume = 0;
    m_dwFrequency = 22050;
    m_dwLeftVolume = 0xFFFF;
    m_dwRightVolume = 0xFFFF;
    m_lPBend = 0;
    m_lPan = 0;
	if( pcBufferDesc && pcBufferDesc->lpwfxFormat )
	{
		m_wfBufferFormat = *pcBufferDesc->lpwfxFormat;
	}
	else
	{
		m_wfBufferFormat.cbSize = 0;
		m_wfBufferFormat.nAvgBytesPerSec = 44100;
		m_wfBufferFormat.nBlockAlign = 2;
		m_wfBufferFormat.nChannels = 1;
		m_wfBufferFormat.nSamplesPerSec = 22050;
		m_wfBufferFormat.wBitsPerSample = 16;
		m_wfBufferFormat.wFormatTag = WAVE_FORMAT_PCM;
	}

	m_fxChain = NULL;

	// Create the mixin buffer, if necessary
	if( pSink
	&&	(m_dwType & DSBCAPS_MIXIN) )
	{
		// Only create it if we have a pointer to the sink, and we're a Mixin buffer
		m_pExtraBuffer = new short[pSink->m_dwBusBufferSize * m_dwChannels];
	}
	else
	{
		// SetFX will create the buffer when the buffer is asked to have an effect chain
		m_pExtraBuffer = NULL;
	}

    if (pSink)
    {
		pSink->AddBuffer( this );
    }
}

CBuffer::CBuffer(CAudioSink *pSink,IUnknown *punkBufferConfig)
{
    m_cRef = 0;
	AddRef();

	InitializeCriticalSection( &m_CriticalSection );

    m_pParentSink = pSink;

	CDirectSoundBufferConfig *pCDirectSoundBufferConfig = NULL;
	punkBufferConfig->QueryInterface( CLSID_PRIVATE_CDirectSoundBufferConfig, (void **)&pCDirectSoundBufferConfig );

    m_guidBufferID = pCDirectSoundBufferConfig->m_DMUSObjectDesc.guidObject;
    m_dwBusCount = pCDirectSoundBufferConfig->m_dwFuncIDsCount;
    // Make sure we don't go out of bounds.
    if (m_dwBusCount > AUDIOSINK_MAX_CHANNELS)
    {
        m_dwBusCount = AUDIOSINK_MAX_CHANNELS;
    }

    // How many channels in the buffer?
    m_dwChannels = pCDirectSoundBufferConfig->m_DSBufferDesc.nChannels;

    // Fill in the bus values for the buses that we want to connect to this buffer.
    DWORD dwIndex;
    for (dwIndex = 0;dwIndex < m_dwBusCount;dwIndex++)
    {
        m_dwFunctionIDs[dwIndex] = pCDirectSoundBufferConfig->m_pdwFuncIDs[dwIndex];
        m_dwBusIDs[dwIndex] = m_sdwNextBusID++;
        m_pBusBuffer[dwIndex] = new short[pSink->m_dwBusBufferSize];
    }

    // Remaining channels on the buffer get null bus and function ids.
    for (;dwIndex < m_dwChannels;dwIndex++)
    {
        m_dwFunctionIDs[dwIndex] = AUDIOSINK_NULL_BUS_ID;
        m_dwBusIDs[dwIndex] = AUDIOSINK_NULL_BUS_ID;
        m_pBusBuffer[dwIndex] = NULL;
    }

    m_lVolume = pCDirectSoundBufferConfig->m_DSBufferDesc.lVolume;
    m_dwFrequency = m_pParentSink->m_wfSinkFormat.nSamplesPerSec;
    m_dwLeftVolume = 0xFFFF;
    m_dwRightVolume = 0xFFFF;
    m_lPBend = 0;
    m_lPan = pCDirectSoundBufferConfig->m_DSBufferDesc.lPan;

	m_wfBufferFormat = m_pParentSink->m_wfSinkFormat;

	if( m_wfBufferFormat.nChannels != m_dwChannels )
	{
		m_wfBufferFormat.nAvgBytesPerSec /= m_wfBufferFormat.nChannels;
		m_wfBufferFormat.nBlockAlign = short(m_wfBufferFormat.nBlockAlign / m_wfBufferFormat.nChannels);
		m_wfBufferFormat.nAvgBytesPerSec *= m_dwChannels;
		m_wfBufferFormat.nBlockAlign = short(m_wfBufferFormat.nBlockAlign * m_dwChannels);
		m_wfBufferFormat.nChannels = short(m_dwChannels);
	}

	ASSERT( m_wfBufferFormat.nChannels == m_dwChannels );

	m_dwType = pCDirectSoundBufferConfig->m_DSBufferDesc.dwFlags;

	if( (m_dwType & DSBCAPS_CTRLFX)
	&&	pCDirectSoundBufferConfig->m_pDXDMOMapList )
	{
		// Only create an effect chain if we're asked to support effects, and we have an effect chain
		m_fxChain = new CEffectChain(this);
	}
	else
	{
		m_fxChain = NULL;
	}

	if( m_fxChain != NULL )
	{
		HRESULT hr = m_fxChain->Clone( pCDirectSoundBufferConfig );
		if (SUCCEEDED(hr))
		{
			//if (!(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
			{
				hr = m_fxChain->AcquireFxResources();
			}
		}

		if( FAILED(hr) )
		{
			delete m_fxChain;
			m_fxChain = NULL;
		}
	}

	// Create the effect and mixin buffer, if necessary
	if( m_fxChain
	||	(m_dwType & DSBCAPS_MIXIN) )
	{
		// Only crate if this is a mixin buffer or we are asked to support effects
		m_pExtraBuffer = new short[pSink->m_dwBusBufferSize * m_dwChannels];
	}
	else
	{
		m_pExtraBuffer = NULL;
	}

    if (pSink)
    {
		pSink->AddBuffer( this );
    }
}

CBuffer::~CBuffer()
{
	delete m_fxChain;
	m_fxChain = NULL;
    if (m_pParentSink)
    {
        m_pParentSink->RemoveBuffer(this);
    }
    DWORD dwIndex;
    for (dwIndex = 0;dwIndex < m_dwBusCount;dwIndex++)
    {
        delete []m_pBusBuffer[dwIndex];
		m_pBusBuffer[dwIndex] = NULL;
    }

	delete []m_pExtraBuffer;
	m_pExtraBuffer = NULL;

	DeleteCriticalSection( &m_CriticalSection );
}

DWORD CBuffer::DBToMultiplier(long lGain)
{
    if (lGain > 0) lGain = 0;
    double flTemp = lGain;
    flTemp /= 1000.0;
    flTemp = pow(10.0,flTemp);
    flTemp = pow(flTemp,0.5);   // square root.
    flTemp *= 65535.0;          // 2^16th, but avoid overflow...
    return (DWORD) flTemp;
}

void CBuffer::CalcVolume()
{
    if (m_dwChannels == 2)
    {   // Wacky dsound pan algorithm!
        long lLeft;
        long lRight;
        if(m_lPan >= 0)
        {
            lLeft = m_lVolume - m_lPan;
            lRight = m_lVolume;
        }
        else
        {
            lLeft = m_lVolume;
            lRight = m_lVolume + m_lPan;
        }

        m_dwLeftVolume = DBToMultiplier(lLeft);
        m_dwRightVolume = DBToMultiplier(lRight);
    }
    else
    {
        m_dwLeftVolume = m_dwRightVolume = DBToMultiplier(m_lVolume);
    }
}

STDMETHODIMP CBuffer::QueryInterface(const IID &iid, void **ppv)
{
    if(iid == IID_IUnknown || iid == IID_IDirectSoundBuffer8 || iid == IID_IDirectSoundBuffer)
    {
        *ppv = static_cast<IDirectSoundBuffer8*>(this);
    } 
    else if (iid == IID_CBuffer)
    {
        *ppv = this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    
    return S_OK;
}

STDMETHODIMP_(ULONG) CBuffer::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CBuffer::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CBuffer::GetCaps(LPDSBCAPS pBufferCaps) 
{
	UNREFERENCED_PARAMETER(pBufferCaps);
	ASSERT(FALSE);
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::GetCurrentPosition(LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) 
{
	UNREFERENCED_PARAMETER(pdwCurrentPlayCursor);
	UNREFERENCED_PARAMETER(pdwCurrentWriteCursor);
	ASSERT(FALSE);
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten)  
{
	if( pwfxFormat == NULL )
	{
		if (pdwSizeWritten)
		{
			*pdwSizeWritten = sizeof(m_wfBufferFormat);
		}
		else
		{
			return DSERR_INVALIDPARAM;
		}
	}
	else
	{
		const DWORD dwToCopy = min( dwSizeAllocated, sizeof(m_wfBufferFormat) );
		memcpy( pwfxFormat, &m_wfBufferFormat, dwToCopy );
		if (pdwSizeWritten)
		{
			*pdwSizeWritten = dwToCopy;
		}
	}
    return DS_OK;
}

STDMETHODIMP CBuffer::GetVolume(LPLONG plVolume)  
{
    *plVolume = m_lVolume;
    return S_OK;
}

STDMETHODIMP CBuffer::GetPan(LPLONG plPan)  
{
    *plPan = m_lPan;
    return S_OK;
}

STDMETHODIMP CBuffer::GetFrequency(LPDWORD pdwFrequency)  
{
    *pdwFrequency = m_dwFrequency;
    return S_OK;
}

STDMETHODIMP CBuffer::GetStatus(LPDWORD pdwStatus)  
{
	UNREFERENCED_PARAMETER(pdwStatus);
	ASSERT(FALSE);
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::Initialize(LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcBufferDesc)  
{
	UNREFERENCED_PARAMETER(pDirectSound);
	UNREFERENCED_PARAMETER(pcBufferDesc);
	ASSERT(FALSE);
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::Lock(DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)  
{
	UNREFERENCED_PARAMETER(dwOffset);
	UNREFERENCED_PARAMETER(dwBytes);
	UNREFERENCED_PARAMETER(ppvAudioPtr1);
	UNREFERENCED_PARAMETER(pdwAudioBytes1);
	UNREFERENCED_PARAMETER(ppvAudioPtr2);
	UNREFERENCED_PARAMETER(pdwAudioBytes2);
	UNREFERENCED_PARAMETER(dwFlags);
	ASSERT(FALSE);
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::Play(DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags)  
{
	UNREFERENCED_PARAMETER(dwReserved1);
	UNREFERENCED_PARAMETER(dwPriority);
	UNREFERENCED_PARAMETER(dwFlags);
    return S_OK;
}

STDMETHODIMP CBuffer::SetCurrentPosition(DWORD dwNewPosition)  
{
	UNREFERENCED_PARAMETER(dwNewPosition);
	ASSERT(FALSE);
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetFormat(LPCWAVEFORMATEX pcfxFormat)  
{
	if( pcfxFormat == NULL )
	{
		return DSERR_INVALIDPARAM;
	}

	m_wfBufferFormat = *pcfxFormat;

    return S_OK;
}

STDMETHODIMP CBuffer::SetVolume(LONG lVolume)  
{
    m_lVolume = lVolume;
    CalcVolume();
    return S_OK;
}

STDMETHODIMP CBuffer::SetPan(LONG lPan)  
{
    m_lPan = lPan;
    CalcVolume();
    return S_OK;
}

STDMETHODIMP CBuffer::SetFrequency(DWORD dwFrequency)  
{
    m_dwFrequency = dwFrequency;
    double flTemp;
    if (m_pParentSink)
    {
        flTemp = m_pParentSink->m_wfSinkFormat.nSamplesPerSec;
    }
    else flTemp = 22050;
    flTemp = (double) dwFrequency / flTemp;
    flTemp = log10(flTemp);
    flTemp *= 1200 * 3.3219280948873623478703194294894;    // Convert from Log10 to Log2 and multiply by cents per octave.
    m_lPBend = (long) flTemp;
    if (m_pParentSink)
    {
        m_pParentSink->FillBusArrays();
    }
    return S_OK;
}

STDMETHODIMP CBuffer::Stop()  
{
    return S_OK;
}

STDMETHODIMP CBuffer::Unlock(LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2)  
{
	UNREFERENCED_PARAMETER(pvAudioPtr1);
	UNREFERENCED_PARAMETER(dwAudioBytes1);
	UNREFERENCED_PARAMETER(pvAudioPtr2);
	UNREFERENCED_PARAMETER(dwAudioBytes2);
	ASSERT(FALSE);
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::Restore()  
{
	ASSERT(FALSE);
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::SetFX(DWORD dwFxCount, LPDSEFFECTDESC pDSFXDesc, LPDWORD pdwResultCodes)  
{
    //DWORD                   dwStatus;
    HRESULT                 hr = DS_OK;
    //DPF_ENTER();

    ASSERT(IS_VALID_READ_PTR(pDSFXDesc, dwFxCount * sizeof *pDSFXDesc));
    ASSERT(!pdwResultCodes || IS_VALID_WRITE_PTR(pdwResultCodes, dwFxCount * sizeof *pdwResultCodes));

	EnterCriticalSection( &m_CriticalSection );

    // Check access rights
    if(!(m_dwType & DSBCAPS_CTRLFX))
    {
        //RPF(DPFLVL_ERROR, "Buffer was not created with DSBCAPS_CTRLFX flag");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Check the buffer is inactive
	/*
    if(SUCCEEDED(hr))
    {
        hr = GetStatus(&dwStatus);
        if(SUCCEEDED(hr) && (dwStatus & DSBSTATUS_PLAYING))
        {
            //RPF(DPFLVL_ERROR, "Cannot change effects, because buffer is playing");
            hr = DSERR_INVALIDCALL;
        }
    }
	*/

    // Check there are no pending locks on the buffer
	/*
    if(SUCCEEDED(hr) && m_pDeviceBuffer->m_pSysMemBuffer->GetLockCount())
    {
        //RPF(DPFLVL_ERROR, "Cannot change effects, because buffer has pending locks");
        hr = DSERR_INVALIDCALL;
    }
	*/

    if(SUCCEEDED(hr))
    {
        // Release the old FX chain, if necessary
        delete m_fxChain;
		m_fxChain = NULL;

        // If the effects count is 0, we can free up associated resources
        if (dwFxCount == 0)
        {
			if( !(m_dwType & DSBCAPS_MIXIN) )
			{
				delete []m_pExtraBuffer;
				m_pExtraBuffer = NULL;
			}
		}
        else // Allocate the pre-FX buffer and create the FX chain requested
        {
			if( !m_pExtraBuffer )
			{
				m_pExtraBuffer = new short[m_pParentSink->m_dwBusBufferSize * m_dwChannels];

				if( m_pExtraBuffer == NULL )
				{
					hr = E_OUTOFMEMORY;
				}
			}

            if (SUCCEEDED(hr))
            {
                m_fxChain = new CEffectChain(this);
				if( m_fxChain == NULL )
				{
					hr = E_OUTOFMEMORY;
				}
            }
            if (SUCCEEDED(hr))
            {
                hr = m_fxChain->Initialize(dwFxCount, pDSFXDesc, pdwResultCodes);
            }
            if (SUCCEEDED(hr))
            {
                //if (!(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
                {
                    hr = m_fxChain->AcquireFxResources();
                }

                // We need to preserve the return code from AcquireFxResources, in case it's
                // DS_INCOMPLETE, so we omit "hr=" from GetFxStatus (which always succeeds):
                if (pdwResultCodes)
                {
                    m_fxChain->GetFxStatus(pdwResultCodes);
                }
            }
            if (FAILED(hr))
            {
                RELEASE(m_fxChain);

				if( !(m_dwType & DSBCAPS_MIXIN) )
				{
					delete []m_pExtraBuffer;
					m_pExtraBuffer = NULL;
				}
           }
        }
    }

	LeaveCriticalSection( &m_CriticalSection );

    //DPF_LEAVE_HRESULT(hr);
    return hr;
}

STDMETHODIMP CBuffer::AcquireResources(DWORD dwFlags, DWORD dwEffectsCount, LPDWORD pdwResultCodes)  
{
	UNREFERENCED_PARAMETER(dwFlags);
	UNREFERENCED_PARAMETER(dwEffectsCount);
	UNREFERENCED_PARAMETER(pdwResultCodes);
	ASSERT(FALSE);
    return E_NOTIMPL;
}

STDMETHODIMP CBuffer::GetObjectInPath(REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject)  
{
	if( !m_fxChain )
	{
		return DMUS_E_NOT_FOUND;
	}

	return m_fxChain->GetEffectInterface( rguidObject, dwIndex, rguidInterface, ppObject );
}

WAVEFORMATEX* CBuffer::Format( void )
{
	return &m_wfBufferFormat;
}

// Do Pre-Render initialization
void CBuffer::PreRender( DWORD dwLength )
{
	EnterCriticalSection( &m_CriticalSection );

	// If this is a mixin buffer, clear the mixin buffer
	if( m_pExtraBuffer
	&&	(m_dwType & DSBCAPS_MIXIN) )
	{
		ZeroMemory( m_pExtraBuffer, dwLength * sizeof(short) * m_dwChannels );
	}

	LeaveCriticalSection( &m_CriticalSection );
}

// Render the buffer into a temporary 32-bit buffer
void CBuffer::Render( long *plBuffer, DWORD dwLength, REFERENCE_TIME rtTime )
{
	EnterCriticalSection( &m_CriticalSection );

	if( m_fxChain )
	{
		RenderFX( plBuffer, dwLength, rtTime );
	}
	else
	{
		RenderNoFX( plBuffer, dwLength );
	}

	LeaveCriticalSection( &m_CriticalSection );
}

void CBuffer::RenderFX( long *plBuffer, DWORD dwLength, REFERENCE_TIME rtTime )
{
	// If not a Mixin buffer, copy the bus buffers into m_pExtraBuffer
	if( !(m_dwType & DSBCAPS_MIXIN) )
	{
		if( m_dwBusCount == 1 )
		{
			// Do left bus
			short *pnSource = m_pBusBuffer[0];

			// If only one channel
			if( m_dwChannels == 1 )
			{
				// Just copy the data
				memcpy( m_pExtraBuffer, m_pBusBuffer[0], dwLength * sizeof(short) );
			}
			else
			{
				ASSERT( m_dwChannels == 2 );
				// Otherwise need to duplicate it
				short *pnDest = m_pExtraBuffer;
				for (DWORD dwIndex = dwLength; dwIndex > 0; dwIndex--)
				{
					// Copy the value twice, once for left and once for right
					*pnDest = *pnSource;
					pnDest++;
					*pnDest = *pnSource;
					pnDest++;

					// Go to the next source sample
					pnSource++;
				}
			}
		}
		else
		{
			ASSERT( m_dwBusCount == 2 && m_dwChannels == 2 );

			// Do left and right bus
			short *pnSource1 = m_pBusBuffer[0];
			short *pnSource2 = m_pBusBuffer[1]; // 1 = right bus
			short *pnDest = m_pExtraBuffer;
			DWORD dwIndex;

			for (dwIndex = dwLength; dwIndex > 0; dwIndex--)
			{
				// Left
				*pnDest = *pnSource1;
				pnDest++;

				// Right
				*pnDest = *pnSource2;
				pnDest++;

				pnSource1++;
				pnSource2++;
			}
		}
	}

	// Now, apply the effect chain
	m_fxChain->Render( m_pExtraBuffer, dwLength * 2 * m_dwChannels, rtTime );

	RenderFXFinalMix( plBuffer, dwLength );
}

void CBuffer::RenderFXFinalMix( long *plBuffer, DWORD dwLength )
{
	// Now, mix the effect buffer into the main accumulation buffer
	if( m_dwChannels == 1 )
	{
		short *pnSource = m_pExtraBuffer;
		for (DWORD dwIndex = dwLength; dwIndex > 0; dwIndex--)
		{
			long lAccum;

			// Left
			lAccum = *pnSource * m_dwLeftVolume;
			lAccum = lAccum >> 12;

			// Copy the value
			*plBuffer += lAccum;
			plBuffer++;

			// Right
			lAccum = *pnSource * m_dwRightVolume;
			lAccum = lAccum >> 12;

			// Copy the value
			*plBuffer += lAccum;
			plBuffer++;

			// Go to the next source sample
			pnSource++;
		}
	}
	else
	{
		ASSERT( m_dwChannels == 2 );

		short *pnSource = m_pExtraBuffer;
		for (DWORD dwIndex = dwLength; dwIndex > 0; dwIndex--)
		{
			long lAccum;

			// Left
			lAccum = *pnSource * m_dwLeftVolume;
			lAccum = lAccum >> 12;

			// Copy the value
			*plBuffer += lAccum;
			plBuffer++;

			// Go to the next source sample
			pnSource++;

			// Right
			lAccum = *pnSource * m_dwRightVolume;
			lAccum = lAccum >> 12;

			// Copy the value
			*plBuffer += lAccum;
			plBuffer++;

			// Go to the next source sample
			pnSource++;
		}
	}
}

void CBuffer::RenderNoFX( long *plBuffer, DWORD dwLength )
{
	long *plOrigBuffer = plBuffer;

	if( (m_dwBusCount == 1)
	||	((m_dwType & DSBCAPS_MIXIN) && (m_dwChannels == 1)) )
	{
		short *pnSource;
		if( m_dwBusCount == 1 )
		{
			// Do left bus
			pnSource = m_pBusBuffer[0];
		}
		else
		{
			// Use Mixin buffer
			pnSource = m_pExtraBuffer;
		}
		long *plMixBuffer = plOrigBuffer;

		for (DWORD dwIndex = dwLength; dwIndex > 0; dwIndex--)
		{
			long lAccum = *pnSource * m_dwLeftVolume;
			lAccum = lAccum >> 12;

			// Copy the value twice, once to the left channel and once to the right channel
			*plMixBuffer += lAccum;
			*plMixBuffer ++;
			*plMixBuffer += lAccum;
			*plMixBuffer ++;

			pnSource++;
		}
	}
	else if( !(m_dwType & DSBCAPS_MIXIN) )
	{
		ASSERT( m_dwBusCount == 2 );
		// Do left and right bus
		short *pnSource1 = m_pBusBuffer[0];
		short *pnSource2 = m_pBusBuffer[1]; // 1 = right bus
		long *plMixBuffer = plOrigBuffer;
		DWORD dwIndex;

		for (dwIndex = dwLength; dwIndex > 0; dwIndex--)
		{
			long lAccum;

			// Left
			lAccum = *pnSource1 * m_dwLeftVolume;
			lAccum = lAccum >> 12;
			*plMixBuffer += lAccum;
			plMixBuffer++;

			// Right
			lAccum = *pnSource2 * m_dwRightVolume;
			lAccum = lAccum >> 12;
			*plMixBuffer += lAccum;
			plMixBuffer++;

			pnSource1++;
			pnSource2++;
		}
	}
	else
	{
		ASSERT( (m_dwBusCount == 0) && (m_dwChannels == 2) );

		short *pnSource = m_pExtraBuffer;
		long *plMixBuffer = plOrigBuffer;
		DWORD dwIndex;

		for (dwIndex = dwLength; dwIndex > 0; dwIndex--)
		{
			long lAccum;

			// Left
			lAccum = *pnSource * m_dwLeftVolume;
			lAccum = lAccum >> 12;
			*plMixBuffer += lAccum;
			plMixBuffer++;
			pnSource++;

			// Right
			lAccum = *pnSource * m_dwRightVolume;
			lAccum = lAccum >> 12;
			*plMixBuffer += lAccum;
			plMixBuffer++;
			pnSource++;
		}
	}
}


/***************************************************************************
 *
 *  FindSendLoop
 *
 *  Description:
 *      Auxiliary function used in effects.cpp to detect send loops.
 *      Returns DSERR_SENDLOOP if a send effect pointing to this buffer
 *      is detected anywhere in the send graph rooted at pCurBuffer.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer* [in]: Current buffer in graph traversal.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code; DSERR_SENDLOOP if a send loop
 *               is found, otherwise DS_OK.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CDirectSoundSecondaryBuffer::FindSendLoop"

HRESULT CBuffer::FindSendLoop(CBuffer* pCurBuffer)
{
    HRESULT hr = DS_OK;

    //DPF_ENTER();
    //CHECK_WRITE_PTR(pCurBuffer);
	if( !IS_VALID_WRITE_PTR(pCurBuffer, sizeof( CBuffer ) ) )
	{
		return E_INVALIDARG;
	}

    if (pCurBuffer == this)
    {
        //RPF(DPFLVL_ERROR, "Send loop detected from buffer at 0x%p to itself", this);
        hr = DSERR_SENDLOOP;
    }
    else if (pCurBuffer->m_fxChain)
    {
        // Buffer has effects - look for send effects and call ourself recursively.
		POSITION pos = pCurBuffer->m_fxChain->m_fxList.GetHeadPosition();
		while( pos && SUCCEEDED(hr) )
		{
			CEffect* pFxNode = pCurBuffer->m_fxChain->m_fxList.GetNext( pos );

            CBuffer* pDstBuffer = pFxNode->GetDestBuffer();
            if (pDstBuffer)
                hr = FindSendLoop(pDstBuffer); 
        }
    }

    //DPF_LEAVE_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\Detours\disasm.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//	Module:		detours.lib
//  File:		disasm.cpp
//
//	Detours for binary functions.  Version 1.3. (Build 43)
//  Includes support for all x86 chips prior to the Pentium III.
//
//	Copyright 1999, Microsoft Corporation
//
//	http://research.microsoft.com/sn/detours
//

#include <ole2.h>
#include <imagehlp.h>
#include "detours.h"
#include "disasm.h"

#undef ASSERT
#define ASSERT(x)

//////////////////////////////////////////////////////////////////////////////
//
//  Function:
//      DetourCopyInstruction(PBYTE pbDst, PBYTE pbSrc, PBYTE *ppbTarget)
//  Purpose:
//      Copy a single instruction from pbSrc to pbDst.
//  Arguments:
//      pbDst:
//          Destination address for the instruction.  May be NULL in which
//          case DetourCopyInstruction is used to measure an instruction.
//          If not NULL then the source instruction is copied to the
//          destination instruction and any relative arguments are adjusted.
//      pbSrc:
//          Source address of the instruction.
//      ppbTarget:
//          Out parameter for any target instruction address pointed to by
//          the instruction.  For example, a branch or a jump insruction has
//          a target, but a load or store instruction doesn't.  A target is
//          another instruction that may be executed as a result of this
//          instruction.  ppbTarget may be NULL.
//		plExtra:
//			Out parameter for the number of extra bytes needed by the
//			instruction to reach the target.  For example, lExtra = 3 if the
//			instruction had an 8-bit relative offset, but needs a 32-bit
//			relative offset.
//  Returns:
//      Returns the address of the next instruction (following in the source)
//      instruction.  By subtracting pbSrc from the return value, the caller
//      can determinte the size of the instruction copied.
//  Comments:
//      By following the pbTarget, the caller can follow alternate
//      instruction streams.  However, it is not always possible to determine
//      the target based on static analysis.  For example, the destination of
//      a jump relative to a register cannot be determined from just the
//      instruction stream.  The output value, pbTarget, can have any of the
//      following outputs:
//			DETOUR_INSTRUCTION_TARGET_NONE:
//          	The instruction has no targets.
//			DETOUR_INSTRUCTION_TARGET_DYNAMIC:
//          	The instruction has a non-deterministic (dynamic) target.
//				(i.e. the jump is to an address held in a register.)
//          Address:   The instruction has the specified target.
//
//      When copying instructions, DetourCopyInstruction insures that any
//      targets remain constant.  It does so by adjusting any IP relative
//      offsets.
//
PBYTE WINAPI DetourCopyInstructionEx(PBYTE pbDst,
									 PBYTE pbSrc,
									 PBYTE *ppbTarget,
									 LONG *plExtra)
{
	CDetourDis oDetourDisasm(ppbTarget, plExtra);
	return oDetourDisasm.CopyInstruction(pbDst, pbSrc);
}

PBYTE WINAPI DetourCopyInstruction(PBYTE pbDst, PBYTE pbSrc, PBYTE *ppbTarget)
{
	CDetourDis oDetourDisasm(ppbTarget, NULL);
	return oDetourDisasm.CopyInstruction(pbDst, pbSrc);
}

/////////////////////////////////////////////////////////// Disassembler Code.
//
CDetourDis::CDetourDis(PBYTE *ppbTarget, LONG *plExtra)
{
	Set32BitOperand();
	Set32BitAddress();

	m_ppbTarget = ppbTarget ? ppbTarget : &m_pbScratchTarget;
	m_plExtra = plExtra ? plExtra : &m_lScratchExtra;

	*m_ppbTarget = DETOUR_INSTRUCTION_TARGET_NONE;
	*m_plExtra = 0;
}

VOID CDetourDis::Set16BitOperand()
{
	m_b16BitOperand = TRUE;
}

VOID CDetourDis::Set32BitOperand()
{
	m_b16BitOperand = FALSE;
}

VOID CDetourDis::Set16BitAddress()
{
	m_b16BitAddress = TRUE;
}

VOID CDetourDis::Set32BitAddress()
{
	m_b16BitAddress = FALSE;
}

PBYTE CDetourDis::CopyInstruction(PBYTE pbDst, PBYTE pbSrc)
{
	// Configure scratch areas if real areas are not available.
	if (NULL == pbDst) {
		pbDst = m_rbScratchDst;
	}
	if (NULL == pbSrc) {
		// We can't copy a non-existent instruction.
		SetLastError(ERROR_INVALID_DATA);
		return NULL;
	}
	
	// Figure out how big the instruction is, do the appropriate copy,
	// and figure out what the target of the instruction is if any.
	//
	REFCOPYENTRY pEntry = &s_rceCopyTable[pbSrc[0]];
	return (this->*pEntry->pfCopy)(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyBytes(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{
	LONG nBytesFixed = (pEntry->nFlagBits & ADDRESS)
		? (m_b16BitAddress ? pEntry->nFixedSize16 : pEntry->nFixedSize)
		: (m_b16BitOperand ? pEntry->nFixedSize16 : pEntry->nFixedSize);
	LONG nBytes = nBytesFixed;
	if (pEntry->nModOffset > 0) {
		BYTE bModRm = pbSrc[pEntry->nModOffset];
		BYTE bFlags = s_rbModRm[bModRm];
		
		if (bFlags & SIB) {
			BYTE bSib = pbSrc[pEntry->nModOffset + 1];
			
			if ((bSib & 0x07) == 0x05) {
				if ((bModRm & 0xc0) == 0x00) {
					nBytes += 4;
				}
				else if ((bModRm & 0xc0) == 0x40) {
					nBytes += 1;
				}
				else if ((bModRm & 0xc0) == 0x80) {
					nBytes += 4;
				}
			}
		}
		nBytes += bFlags & NOTSIB;
	}
	CopyMemory(pbDst, pbSrc, nBytes);

	if (pEntry->nRelOffset) {
		*m_ppbTarget = AdjustTarget(pbDst, pbSrc, nBytesFixed, pEntry->nRelOffset);
	}
	if (pEntry->nFlagBits & NOENLARGE) {
		*m_plExtra = -*m_plExtra;
	}
	if (pEntry->nFlagBits & DYNAMIC) {
		*m_ppbTarget = DETOUR_INSTRUCTION_TARGET_DYNAMIC;
	}
	return pbSrc + nBytes;
}

PBYTE CDetourDis::CopyBytesPrefix(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{
	CopyBytes(pEntry, pbDst, pbSrc);
	
	pEntry = &s_rceCopyTable[pbSrc[1]];
	return (this->*pEntry->pfCopy)(pEntry, pbDst + 1, pbSrc + 1);
}

PBYTE CDetourDis::AdjustTarget(PBYTE pbDst, PBYTE pbSrc, LONG cbOp, LONG cbTargetOffset)
{
	LONG cbTargetSize = cbOp - cbTargetOffset;
	PBYTE pbTarget = NULL;
	PVOID pvTargetAddr = &pbDst[cbTargetOffset];
	LONG nOldOffset = 0;
	
	switch (cbTargetSize) {
	  case 1:
		nOldOffset = (LONG)*(PCHAR&)pvTargetAddr;
		*m_plExtra = 3;
		break;
	  case 2:
		nOldOffset = (LONG)*(PSHORT&)pvTargetAddr;
		*m_plExtra = 2;
		break;
	  case 4:
		nOldOffset = (LONG)*(PLONG&)pvTargetAddr;
		*m_plExtra = 0;
		break;
	  default:
		ASSERT(!"cbTargetSize is invalid.");
		break;
	}
	
	pbTarget = pbSrc + cbOp + nOldOffset;
	LONG nNewOffset = nOldOffset - (pbDst - pbSrc);
	
	switch (cbTargetSize) {
	  case 1:
		*(PCHAR&)pvTargetAddr = (CHAR)nNewOffset;
		break;
	  case 2:
		*(PSHORT&)pvTargetAddr = (SHORT)nNewOffset;
		break;
	  case 4:
		*(PLONG&)pvTargetAddr = (LONG)nNewOffset;
		break;
	}
	ASSERT(pbDst + cbOp + nNewOffset == pbTarget);
	return pbTarget;
}

PBYTE CDetourDis::Invalid(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{
	ASSERT(!"Invalid Instruction");
	return pbSrc + 1;
}

////////////////////////////////////////////////////// Individual Bytes Codes.
//
PBYTE CDetourDis::Copy0F(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{
	CopyBytes(pEntry, pbDst, pbSrc);
	
	pEntry = &s_rceCopyTable0F[pbSrc[1]];
	return (this->*pEntry->pfCopy)(pEntry, pbDst + 1, pbSrc + 1);
}

PBYTE CDetourDis::Copy66(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{	// Operand-size override prefix
	Set16BitOperand();
	return CopyBytesPrefix(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::Copy67(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{	// Address size override prefix
	Set16BitAddress();
	return CopyBytesPrefix(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyF6(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{
	// TEST BYTE /0
	if (0x00 == (0x38 & pbSrc[1])) {	// reg(bits 543) of ModR/M == 0
		const COPYENTRY ce = { 0xf6, ENTRY_CopyBytes2Mod1 };
		return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
	}
	// DIV /6
	// IDIV /7
	// IMUL /5
	// MUL /4
	// NEG /3
	// NOT /2
	
	const COPYENTRY ce = { 0xf6, ENTRY_CopyBytes2Mod };
	return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyF7(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{
	// TEST WORD /0
	if (0x00 == (0x38 & pbSrc[1])) {	// reg(bits 543) of ModR/M == 0
		const COPYENTRY ce = { 0xf7, ENTRY_CopyBytes2ModOperand };
		return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
	}
	
	// DIV /6
	// IDIV /7
	// IMUL /5
	// MUL /4
	// NEG /3
	// NOT /2
	const COPYENTRY ce = { 0xf7, ENTRY_CopyBytes2Mod };
	return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyFF(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{	// CALL /2
	// CALL /3
	// INC /0
	// JMP /4
	// JMP /5
	// PUSH /6

	if (0x15 == pbSrc[1] || 0x25 == pbSrc[1]) {			// CALL [], JMP []
		PBYTE *ppbTarget = *(PBYTE**) &pbSrc[2];
		*m_ppbTarget = *ppbTarget;
	}
	else if (0x10 == (0x38 & pbSrc[1]) || // CALL /2 --> reg(bits 543) of ModR/M == 010
			 0x18 == (0x38 & pbSrc[1]) || // CALL /3 --> reg(bits 543) of ModR/M == 011
			 0x20 == (0x38 & pbSrc[1]) || // JMP /4 --> reg(bits 543) of ModR/M == 100
			 0x28 == (0x38 & pbSrc[1])    // JMP /5 --> reg(bits 543) of ModR/M == 101
			 ) {
		*m_ppbTarget = DETOUR_INSTRUCTION_TARGET_DYNAMIC;
	}
	const COPYENTRY ce = { 0xff, ENTRY_CopyBytes2Mod };
	return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
}

///////////////////////////////////////////////////////// Disassembler Tables.
//
const BYTE CDetourDis::s_rbModRm[256] = {
	0,0,0,0, SIB|1,4,0,0, 0,0,0,0, SIB|1,4,0,0,					// 0x
	0,0,0,0, SIB|1,4,0,0, 0,0,0,0, SIB|1,4,0,0,					// 1x
	0,0,0,0, SIB|1,4,0,0, 0,0,0,0, SIB|1,4,0,0,					// 2x
	0,0,0,0, SIB|1,4,0,0, 0,0,0,0, SIB|1,4,0,0,					// 3x
	1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,					// 4x
	1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,					// 5x
	1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,					// 6x
	1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,					// 7x
	4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,					// 8x
	4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,					// 9x
	4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,					// Ax
	4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,					// Bx
	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,					// Cx
	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,					// Dx
	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,					// Ex
	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0					// Fx
};

const CDetourDis::COPYENTRY CDetourDis::s_rceCopyTable[257] =
{ 
	{ 0x00, ENTRY_CopyBytes2Mod },						// ADD /r
	{ 0x01, ENTRY_CopyBytes2Mod },						// ADD /r
	{ 0x02, ENTRY_CopyBytes2Mod },						// ADD /r
	{ 0x03, ENTRY_CopyBytes2Mod },						// ADD /r
	{ 0x04, ENTRY_CopyBytes2 },							// ADD ib
	{ 0x05, ENTRY_CopyBytes3Or5 },						// ADD iw
	{ 0x06, ENTRY_CopyBytes1 },							// PUSH
	{ 0x07, ENTRY_CopyBytes1 },							// POP
	{ 0x08, ENTRY_CopyBytes2Mod },						// OR /r
	{ 0x09, ENTRY_CopyBytes2Mod },						// OR /r
	{ 0x0A, ENTRY_CopyBytes2Mod },						// OR /r
	{ 0x0B, ENTRY_CopyBytes2Mod },						// OR /r
	{ 0x0C, ENTRY_CopyBytes2 },							// OR ib
	{ 0x0D, ENTRY_CopyBytes3Or5 },						// OR iw
	{ 0x0E, ENTRY_CopyBytes1 },							// PUSH
	{ 0x0F, ENTRY_Copy0F },								// Extension Ops 
	{ 0x10, ENTRY_CopyBytes2Mod },						// ADC /r
	{ 0x11, ENTRY_CopyBytes2Mod },						// ADC /r
	{ 0x12, ENTRY_CopyBytes2Mod },						// ADC /r
	{ 0x13, ENTRY_CopyBytes2Mod },						// ADC /r
	{ 0x14, ENTRY_CopyBytes2 },							// ADC ib
	{ 0x15, ENTRY_CopyBytes3Or5 },						// ADC id
	{ 0x16, ENTRY_CopyBytes1 },							// PUSH
	{ 0x17, ENTRY_CopyBytes1 },							// POP
	{ 0x18, ENTRY_CopyBytes2Mod },						// SBB /r
	{ 0x19, ENTRY_CopyBytes2Mod },						// SBB /r
	{ 0x1A, ENTRY_CopyBytes2Mod },						// SBB /r
	{ 0x1B, ENTRY_CopyBytes2Mod },						// SBB /r
	{ 0x1C, ENTRY_CopyBytes2 },							// SBB ib
	{ 0x1D, ENTRY_CopyBytes3Or5 },						// SBB id
	{ 0x1E, ENTRY_CopyBytes1 },							// PUSH
	{ 0x1F, ENTRY_CopyBytes1 },							// POP
	{ 0x20, ENTRY_CopyBytes2Mod },						// AND /r
	{ 0x21, ENTRY_CopyBytes2Mod },						// AND /r
	{ 0x22, ENTRY_CopyBytes2Mod },						// AND /r
	{ 0x23, ENTRY_CopyBytes2Mod },						// AND /r
	{ 0x24, ENTRY_CopyBytes2 },							// AND ib
	{ 0x25, ENTRY_CopyBytes3Or5 },						// AND id
	{ 0x26, ENTRY_CopyBytesPrefix },					// ES prefix 
	{ 0x27, ENTRY_CopyBytes1 },							// DAA
	{ 0x28, ENTRY_CopyBytes2Mod },						// SUB /r
	{ 0x29, ENTRY_CopyBytes2Mod },						// SUB /r
	{ 0x2A, ENTRY_CopyBytes2Mod },						// SUB /r
	{ 0x2B, ENTRY_CopyBytes2Mod },						// SUB /r
	{ 0x2C, ENTRY_CopyBytes2 },							// SUB ib
	{ 0x2D, ENTRY_CopyBytes3Or5 },						// SUB id
	{ 0x2E, ENTRY_CopyBytesPrefix },					// CS prefix 
	{ 0x2F, ENTRY_CopyBytes1 },							// DAS
	{ 0x30, ENTRY_CopyBytes2Mod },						// XOR /r
	{ 0x31, ENTRY_CopyBytes2Mod },						// XOR /r
	{ 0x32, ENTRY_CopyBytes2Mod },						// XOR /r
	{ 0x33, ENTRY_CopyBytes2Mod },						// XOR /r
	{ 0x34, ENTRY_CopyBytes2 },							// XOR ib
	{ 0x35, ENTRY_CopyBytes3Or5 },						// XOR id
	{ 0x36, ENTRY_CopyBytesPrefix },					// SS prefix 
	{ 0x37, ENTRY_CopyBytes1 },							// AAA
	{ 0x38, ENTRY_CopyBytes2Mod },						// CMP /r
	{ 0x39, ENTRY_CopyBytes2Mod },						// CMP /r
	{ 0x3A, ENTRY_CopyBytes2Mod },						// CMP /r
	{ 0x3B, ENTRY_CopyBytes2Mod },						// CMP /r
	{ 0x3C, ENTRY_CopyBytes2 },							// CMP ib
	{ 0x3D, ENTRY_CopyBytes3Or5 },						// CMP id
	{ 0x3E, ENTRY_CopyBytesPrefix },					// DS prefix 
	{ 0x3F, ENTRY_CopyBytes1 },							// AAS
	{ 0x40, ENTRY_CopyBytes1 },							// INC
	{ 0x41, ENTRY_CopyBytes1 },							// INC
	{ 0x42, ENTRY_CopyBytes1 },							// INC
	{ 0x43, ENTRY_CopyBytes1 },							// INC
	{ 0x44, ENTRY_CopyBytes1 },							// INC
	{ 0x45, ENTRY_CopyBytes1 },							// INC
	{ 0x46, ENTRY_CopyBytes1 },							// INC
	{ 0x47, ENTRY_CopyBytes1 },							// INC
	{ 0x48, ENTRY_CopyBytes1 },							// DEC
	{ 0x49, ENTRY_CopyBytes1 },							// DEC
	{ 0x4A, ENTRY_CopyBytes1 },							// DEC
	{ 0x4B, ENTRY_CopyBytes1 },							// DEC
	{ 0x4C, ENTRY_CopyBytes1 },							// DEC
	{ 0x4D, ENTRY_CopyBytes1 },							// DEC
	{ 0x4E, ENTRY_CopyBytes1 },							// DEC
	{ 0x4F, ENTRY_CopyBytes1 },							// DEC
	{ 0x50, ENTRY_CopyBytes1 },							// PUSH
	{ 0x51, ENTRY_CopyBytes1 },							// PUSH
	{ 0x52, ENTRY_CopyBytes1 },							// PUSH
	{ 0x53, ENTRY_CopyBytes1 },							// PUSH
	{ 0x54, ENTRY_CopyBytes1 },							// PUSH
	{ 0x55, ENTRY_CopyBytes1 },							// PUSH
	{ 0x56, ENTRY_CopyBytes1 },							// PUSH
	{ 0x57, ENTRY_CopyBytes1 },							// PUSH
	{ 0x58, ENTRY_CopyBytes1 },							// POP
	{ 0x59, ENTRY_CopyBytes1 },							// POP
	{ 0x5A, ENTRY_CopyBytes1 },							// POP
	{ 0x5B, ENTRY_CopyBytes1 },							// POP
	{ 0x5C, ENTRY_CopyBytes1 },							// POP
	{ 0x5D, ENTRY_CopyBytes1 },							// POP
	{ 0x5E, ENTRY_CopyBytes1 },							// POP
	{ 0x5F, ENTRY_CopyBytes1 },							// POP
	{ 0x60, ENTRY_CopyBytes1 },							// PUSHAD
	{ 0x61, ENTRY_CopyBytes1 },							// POPAD
	{ 0x62, ENTRY_CopyBytes2Mod },						// BOUND /r
	{ 0x63, ENTRY_CopyBytes2Mod },						// ARPL /r
	{ 0x64, ENTRY_CopyBytesPrefix },					// FS prefix 
	{ 0x65, ENTRY_CopyBytesPrefix },					// GS prefix 
	{ 0x66, ENTRY_Copy66 },								// Operand Prefix 
	{ 0x67, ENTRY_Copy67 },								// Address Prefix 
	{ 0x68, ENTRY_CopyBytes3Or5 },						// PUSH
	{ 0x69, ENTRY_CopyBytes2ModOperand },				// 
	{ 0x6A, ENTRY_CopyBytes2 },							// PUSH
	{ 0x6B, ENTRY_CopyBytes2Mod1 },						// IMUL /r ib 
	{ 0x6C, ENTRY_CopyBytes1 },							// INS
	{ 0x6D, ENTRY_CopyBytes1 },							// INS
	{ 0x6E, ENTRY_CopyBytes1 },							// OUTS/OUTSB
	{ 0x6F, ENTRY_CopyBytes1 },							// OUTS/OUTSW
	{ 0x70, ENTRY_CopyBytes2Jump },						// JO
	{ 0x71, ENTRY_CopyBytes2Jump },						// JNO
	{ 0x72, ENTRY_CopyBytes2Jump },						// JB/JC/JNAE
	{ 0x73, ENTRY_CopyBytes2Jump },						// JAE/JNB/JNC
	{ 0x74, ENTRY_CopyBytes2Jump },						// JE/JZ
	{ 0x75, ENTRY_CopyBytes2Jump },						// JNE/JNZ
	{ 0x76, ENTRY_CopyBytes2Jump },						// JBE/JNA
	{ 0x77, ENTRY_CopyBytes2Jump },						// JA/JNBE
	{ 0x78, ENTRY_CopyBytes2Jump },						// JS
	{ 0x79, ENTRY_CopyBytes2Jump },						// JNS
	{ 0x7A, ENTRY_CopyBytes2Jump },						// JP/JPE
	{ 0x7B, ENTRY_CopyBytes2Jump },						// JNP/JPO
	{ 0x7C, ENTRY_CopyBytes2Jump },						// JL/JNGE
	{ 0x7D, ENTRY_CopyBytes2Jump },						// JGE/JNL
	{ 0x7E, ENTRY_CopyBytes2Jump },						// JLE/JNG
	{ 0x7F, ENTRY_CopyBytes2Jump },						// JG/JNLE
	{ 0x80, ENTRY_CopyBytes2Mod1 },						// ADC/2 ib, etc.s 
	{ 0x81, ENTRY_CopyBytes2ModOperand },				// 
	{ 0x82, ENTRY_CopyBytes2 },							// MOV al,x
	{ 0x83, ENTRY_CopyBytes2Mod1 },						// ADC/2 ib, etc. 
	{ 0x84, ENTRY_CopyBytes2Mod },						// TEST /r
	{ 0x85, ENTRY_CopyBytes2Mod },						// TEST /r
	{ 0x86, ENTRY_CopyBytes2Mod },						// XCHG /r @todo 
	{ 0x87, ENTRY_CopyBytes2Mod },						// XCHG /r @todo 
	{ 0x88, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x89, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x8A, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x8B, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x8C, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x8D, ENTRY_CopyBytes2Mod },						// LEA /r
	{ 0x8E, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x8F, ENTRY_CopyBytes2Mod },						// POP /0
	{ 0x90, ENTRY_CopyBytes1 },							// NOP
	{ 0x91, ENTRY_CopyBytes1 },							// XCHG
	{ 0x92, ENTRY_CopyBytes1 },							// XCHG
	{ 0x93, ENTRY_CopyBytes1 },							// XCHG
	{ 0x94, ENTRY_CopyBytes1 },							// XCHG
	{ 0x95, ENTRY_CopyBytes1 },							// XCHG
	{ 0x96, ENTRY_CopyBytes1 },							// XCHG
	{ 0x97, ENTRY_CopyBytes1 },							// XCHG
	{ 0x98, ENTRY_CopyBytes1 },							// CWDE
	{ 0x99, ENTRY_CopyBytes1 },							// CDQ
	{ 0x9A, ENTRY_CopyBytes5Or7Dynamic },				// CALL cp 
	{ 0x9B, ENTRY_CopyBytes1 },							// WAIT/FWAIT
	{ 0x9C, ENTRY_CopyBytes1 },							// PUSHFD
	{ 0x9D, ENTRY_CopyBytes1 },							// POPFD
	{ 0x9E, ENTRY_CopyBytes1 },							// SAHF
	{ 0x9F, ENTRY_CopyBytes1 },							// LAHF
	{ 0xA0, ENTRY_CopyBytes3Or5Address },				// MOV
	{ 0xA1, ENTRY_CopyBytes3Or5Address },				// MOV
	{ 0xA2, ENTRY_CopyBytes3Or5Address },				// MOV
	{ 0xA3, ENTRY_CopyBytes3Or5Address },				// MOV
	{ 0xA4, ENTRY_CopyBytes1 },							// MOVS
	{ 0xA5, ENTRY_CopyBytes1 },							// MOVS/MOVSD
	{ 0xA6, ENTRY_CopyBytes1 },							// CMPS/CMPSB
	{ 0xA7, ENTRY_CopyBytes1 },							// CMPS/CMPSW
	{ 0xA8, ENTRY_CopyBytes2 },							// TEST
	{ 0xA9, ENTRY_CopyBytes3Or5 },						// TEST
	{ 0xAA, ENTRY_CopyBytes1 },							// STOS/STOSB
	{ 0xAB, ENTRY_CopyBytes1 },							// STOS/STOSW
	{ 0xAC, ENTRY_CopyBytes1 },							// LODS/LODSB
	{ 0xAD, ENTRY_CopyBytes1 },							// LODS/LODSW
	{ 0xAE, ENTRY_CopyBytes1 },							// SCAS/SCASB
	{ 0xAF, ENTRY_CopyBytes1 },							// SCAS/SCASD
	{ 0xB0, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB1, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB2, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB3, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB4, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB5, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB6, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB7, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB8, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xB9, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBA, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBB, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBC, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBD, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBE, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBF, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xC0, ENTRY_CopyBytes2Mod1 },						// RCL/2 ib, etc. 
	{ 0xC1, ENTRY_CopyBytes2Mod1 },						// RCL/2 ib, etc. 
	{ 0xC2, ENTRY_CopyBytes3 },							// RET
	{ 0xC3, ENTRY_CopyBytes1 },							// RET
	{ 0xC4, ENTRY_CopyBytes2Mod },						// LES
	{ 0xC5, ENTRY_CopyBytes2Mod },						// LDS
	{ 0xC6, ENTRY_CopyBytes2Mod1 },						// MOV 
	{ 0xC7, ENTRY_CopyBytes2ModOperand },				// MOV
	{ 0xC8, ENTRY_CopyBytes4 },							// ENTER
	{ 0xC9, ENTRY_CopyBytes1 },							// LEAVE
	{ 0xCA, ENTRY_CopyBytes3Dynamic },					// RET
	{ 0xCB, ENTRY_CopyBytes1Dynamic },					// RET
	{ 0xCC, ENTRY_CopyBytes1Dynamic },					// INT 3
	{ 0xCD, ENTRY_CopyBytes2Dynamic },					// INT ib
	{ 0xCE, ENTRY_CopyBytes1Dynamic },					// INTO
	{ 0xCF, ENTRY_CopyBytes1Dynamic },					// IRET
	{ 0xD0, ENTRY_CopyBytes2Mod },						// RCL/2, etc.
	{ 0xD1, ENTRY_CopyBytes2Mod },						// RCL/2, etc.
	{ 0xD2, ENTRY_CopyBytes2Mod },						// RCL/2, etc.
	{ 0xD3, ENTRY_CopyBytes2Mod },						// RCL/2, etc.
	{ 0xD4, ENTRY_CopyBytes2 },							// AAM
	{ 0xD5, ENTRY_CopyBytes2 },							// AAD
	{ 0xD6, ENTRY_Invalid },							// 
	{ 0xD7, ENTRY_CopyBytes1 },							// XLAT/XLATB
	{ 0xD8, ENTRY_CopyBytes2Mod },						// FADD, etc. 
	{ 0xD9, ENTRY_CopyBytes2Mod },						// F2XM1, etc.
	{ 0xDA, ENTRY_CopyBytes2Mod },						// FLADD, etc. 
	{ 0xDB, ENTRY_CopyBytes2Mod },						// FCLEX, etc. 
	{ 0xDC, ENTRY_CopyBytes2Mod },						// FADD/0, etc. 
	{ 0xDD, ENTRY_CopyBytes2Mod },						// FFREE, etc. 
	{ 0xDE, ENTRY_CopyBytes2Mod },						// FADDP, etc. 
	{ 0xDF, ENTRY_CopyBytes2Mod },						// FBLD/4, etc. 
	{ 0xE0, ENTRY_CopyBytes2CantJump },					// LOOPNE cb
	{ 0xE1, ENTRY_CopyBytes2CantJump },					// LOOPE cb
	{ 0xE2, ENTRY_CopyBytes2CantJump },					// LOOP cb
	{ 0xE3, ENTRY_CopyBytes2Jump },						// JCXZ/JECXZ
	{ 0xE4, ENTRY_CopyBytes2 },							// IN ib
	{ 0xE5, ENTRY_CopyBytes2 },							// IN id
	{ 0xE6, ENTRY_CopyBytes2 },							// OUT ib
	{ 0xE7, ENTRY_CopyBytes2 },							// OUT ib
	{ 0xE8, ENTRY_CopyBytes3Or5Target },				// CALL cd
	{ 0xE9, ENTRY_CopyBytes3Or5Target },				// JMP cd
	{ 0xEA, ENTRY_CopyBytes5Or7Dynamic },				// JMP cp
	{ 0xEB, ENTRY_CopyBytes2Jump },						// JMP cb
	{ 0xEC, ENTRY_CopyBytes1 },							// IN ib
	{ 0xED, ENTRY_CopyBytes1 },							// IN id
	{ 0xEE, ENTRY_CopyBytes1 },							// OUT
	{ 0xEF, ENTRY_CopyBytes1 },							// OUT
	{ 0xF0, ENTRY_CopyBytesPrefix },					// LOCK prefix 
	{ 0xF1, ENTRY_Invalid },							// 
	{ 0xF2, ENTRY_CopyBytesPrefix },					// REPNE prefix 
	{ 0xF3, ENTRY_CopyBytesPrefix },					// REPE prefix 
	{ 0xF4, ENTRY_CopyBytes1 },							// HLT
	{ 0xF5, ENTRY_CopyBytes1 },							// CMC
	{ 0xF6, ENTRY_CopyF6 },								// TEST/0, DIV/6 
	{ 0xF7, ENTRY_CopyF7 },								// TEST/0, DIV/6 
	{ 0xF8, ENTRY_CopyBytes1 },							// CLC
	{ 0xF9, ENTRY_CopyBytes1 },							// STC
	{ 0xFA, ENTRY_CopyBytes1 },							// CLI
	{ 0xFB, ENTRY_CopyBytes1 },							// STI
	{ 0xFC, ENTRY_CopyBytes1 },							// CLD
	{ 0xFD, ENTRY_CopyBytes1 },							// STD
	{ 0xFE, ENTRY_CopyBytes2Mod },						// DEC/1,INC/0
	{ 0xFF, ENTRY_CopyFF },								// CALL/2
	{ 0, ENTRY_End },
};

const CDetourDis::COPYENTRY CDetourDis::s_rceCopyTable0F[257] =
{
	{ 0x00, ENTRY_CopyBytes2Mod },						// LLDT/2, etc. 
	{ 0x01, ENTRY_CopyBytes2Mod },						// INVLPG/7, etc. 
	{ 0x02, ENTRY_CopyBytes2Mod },						// LAR/r 
	{ 0x03, ENTRY_CopyBytes2Mod },						// LSL/r 
	{ 0x04, ENTRY_Invalid },							// _04 
	{ 0x05, ENTRY_Invalid },							// _05 
	{ 0x06, ENTRY_CopyBytes2 },							// CLTS 
	{ 0x07, ENTRY_Invalid },							// _07 
	{ 0x08, ENTRY_CopyBytes2 },							// INVD 
	{ 0x09, ENTRY_CopyBytes2 },							// WBINVD 
	{ 0x0A, ENTRY_Invalid },							// _0A 
	{ 0x0B, ENTRY_CopyBytes2 },							// UD2 
	{ 0x0C, ENTRY_Invalid },							// _0C 
	{ 0x0D, ENTRY_Invalid },							// _0D 
	{ 0x0E, ENTRY_Invalid },							// _0E 
	{ 0x0F, ENTRY_Invalid },							// _0F 
	{ 0x10, ENTRY_Invalid },							// _10 
	{ 0x11, ENTRY_Invalid },							// _11 
	{ 0x12, ENTRY_Invalid },							// _12 
	{ 0x13, ENTRY_Invalid },							// _13 
	{ 0x14, ENTRY_Invalid },							// _14 
	{ 0x15, ENTRY_Invalid },							// _15 
	{ 0x16, ENTRY_Invalid },							// _16 
	{ 0x17, ENTRY_Invalid },							// _17 
	{ 0x18, ENTRY_Invalid },							// _18 
	{ 0x19, ENTRY_Invalid },							// _19 
	{ 0x1A, ENTRY_Invalid },							// _1A 
	{ 0x1B, ENTRY_Invalid },							// _1B 
	{ 0x1C, ENTRY_Invalid },							// _1C 
	{ 0x1D, ENTRY_Invalid },							// _1D 
	{ 0x1E, ENTRY_Invalid },							// _1E 
	{ 0x1F, ENTRY_Invalid },							// _1F 
	{ 0x20, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x21, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x22, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x23, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x24, ENTRY_Invalid },							// _24 
	{ 0x25, ENTRY_Invalid },							// _25 
	{ 0x26, ENTRY_Invalid },							// _26 
	{ 0x27, ENTRY_Invalid },							// _27 
	{ 0x28, ENTRY_Invalid },							// _28 
	{ 0x29, ENTRY_Invalid },							// _29 
	{ 0x2A, ENTRY_Invalid },							// _2A 
	{ 0x2B, ENTRY_Invalid },							// _2B 
	{ 0x2C, ENTRY_Invalid },							// _2C 
	{ 0x2D, ENTRY_Invalid },							// _2D 
	{ 0x2E, ENTRY_Invalid },							// _2E 
	{ 0x2F, ENTRY_Invalid },							// _2F 
	{ 0x30, ENTRY_CopyBytes2 },							// WRMSR 
	{ 0x31, ENTRY_CopyBytes2 },							// RDTSC 
	{ 0x32, ENTRY_CopyBytes2 },							// RDMSR 
	{ 0x33, ENTRY_CopyBytes2 },							// RDPMC 
	{ 0x34, ENTRY_CopyBytes2 },							// SYSENTER 
	{ 0x35, ENTRY_CopyBytes2 },							// SYSEXIT 
	{ 0x36, ENTRY_Invalid },							// _36 
	{ 0x37, ENTRY_Invalid },							// _37 
	{ 0x38, ENTRY_Invalid },							// _38 
	{ 0x39, ENTRY_Invalid },							// _39 
	{ 0x3A, ENTRY_Invalid },							// _3A 
	{ 0x3B, ENTRY_Invalid },							// _3B 
	{ 0x3C, ENTRY_Invalid },							// _3C 
	{ 0x3D, ENTRY_Invalid },							// _3D 
	{ 0x3E, ENTRY_Invalid },							// _3E 
	{ 0x3F, ENTRY_Invalid },							// _3F 
	{ 0x40, ENTRY_CopyBytes2Mod },						// CMOVO (0F 40) 
	{ 0x41, ENTRY_CopyBytes2Mod },						// CMOVNO (0F 41) 
	{ 0x42, ENTRY_CopyBytes2Mod },						// CMOVB & CMOVNE (0F 42) 
	{ 0x43, ENTRY_CopyBytes2Mod },						// CMOVAE & CMOVNB (0F 43) 
	{ 0x44, ENTRY_CopyBytes2Mod },						// CMOVE & CMOVZ (0F 44) 
	{ 0x45, ENTRY_CopyBytes2Mod },						// CMOVNE & CMOVNZ (0F 45) 
	{ 0x46, ENTRY_CopyBytes2Mod },						// CMOVBE & CMOVNA (0F 46) 
	{ 0x47, ENTRY_CopyBytes2Mod },						// CMOVA & CMOVNBE (0F 47) 
	{ 0x48, ENTRY_CopyBytes2Mod },						// CMOVS (0F 48) 
	{ 0x49, ENTRY_CopyBytes2Mod },						// CMOVNS (0F 49) 
	{ 0x4A, ENTRY_CopyBytes2Mod },						// CMOVP & CMOVPE (0F 4A) 
	{ 0x4B, ENTRY_CopyBytes2Mod },						// CMOVNP & CMOVPO (0F 4B) 
	{ 0x4C, ENTRY_CopyBytes2Mod },						// CMOVL & CMOVNGE (0F 4C) 
	{ 0x4D, ENTRY_CopyBytes2Mod },						// CMOVGE & CMOVNL (0F 4D) 
	{ 0x4E, ENTRY_CopyBytes2Mod },						// CMOVLE & CMOVNG (0F 4E) 
	{ 0x4F, ENTRY_CopyBytes2Mod },						// CMOVG & CMOVNLE (0F 4F) 
	{ 0x50, ENTRY_Invalid },							// _50 
	{ 0x51, ENTRY_Invalid },							// _51 
	{ 0x52, ENTRY_Invalid },							// _52 
	{ 0x53, ENTRY_Invalid },							// _53 
	{ 0x54, ENTRY_Invalid },							// _54 
	{ 0x55, ENTRY_Invalid },							// _55 
	{ 0x56, ENTRY_Invalid },							// _56 
	{ 0x57, ENTRY_Invalid },							// _57 
	{ 0x58, ENTRY_Invalid },							// _58 
	{ 0x59, ENTRY_Invalid },							// _59 
	{ 0x5A, ENTRY_Invalid },							// _5A 
	{ 0x5B, ENTRY_Invalid },							// _5B 
	{ 0x5C, ENTRY_Invalid },							// _5C 
	{ 0x5D, ENTRY_Invalid },							// _5D 
	{ 0x5E, ENTRY_Invalid },							// _5E 
	{ 0x5F, ENTRY_Invalid },							// _5F 
	{ 0x60, ENTRY_CopyBytes2Mod },						// PUNPCKLBW/r 
	{ 0x61, ENTRY_Invalid },							// _61 
	{ 0x62, ENTRY_CopyBytes2Mod },						// PUNPCKLWD/r 
	{ 0x63, ENTRY_CopyBytes2Mod },						// PACKSSWB/r 
	{ 0x64, ENTRY_CopyBytes2Mod },						// PCMPGTB/r 
	{ 0x65, ENTRY_CopyBytes2Mod },						// PCMPGTW/r 
	{ 0x66, ENTRY_CopyBytes2Mod },						// PCMPGTD/r 
	{ 0x67, ENTRY_CopyBytes2Mod },						// PACKUSWB/r 
	{ 0x68, ENTRY_CopyBytes2Mod },						// PUNPCKHBW/r 
	{ 0x69, ENTRY_CopyBytes2Mod },						// PUNPCKHWD/r 
	{ 0x6A, ENTRY_CopyBytes2Mod },						// PUNPCKHDQ/r 
	{ 0x6B, ENTRY_CopyBytes2Mod },						// PACKSSDW/r 
	{ 0x6C, ENTRY_Invalid },							// _6C 
	{ 0x6D, ENTRY_Invalid },							// _6D 
	{ 0x6E, ENTRY_CopyBytes2Mod },						// MOVD/r 
	{ 0x6F, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x70, ENTRY_Invalid },							// _70 
	{ 0x71, ENTRY_CopyBytes2Mod1 },						// PSLLW/6 ib,PSRAW/4 ib,PSRLW/2 ib 
	{ 0x72, ENTRY_CopyBytes2Mod1 },						// PSLLD/6 ib,PSRAD/4 ib,PSRLD/2 ib 
	{ 0x73, ENTRY_CopyBytes2Mod1 },						// PSLLQ/6 ib,PSRLQ/2 ib 
	{ 0x74, ENTRY_CopyBytes2Mod },						// PCMPEQB/r 
	{ 0x75, ENTRY_CopyBytes2Mod },						// PCMPEQW/r 
	{ 0x76, ENTRY_CopyBytes2Mod },						// PCMPEQD/r 
	{ 0x77, ENTRY_CopyBytes2 },							// EMMS 
	{ 0x78, ENTRY_Invalid },							// _78 
	{ 0x79, ENTRY_Invalid },							// _79 
	{ 0x7A, ENTRY_Invalid },							// _7A 
	{ 0x7B, ENTRY_Invalid },							// _7B 
	{ 0x7C, ENTRY_Invalid },							// _7C 
	{ 0x7D, ENTRY_Invalid },							// _7D 
	{ 0x7E, ENTRY_CopyBytes2Mod },						// MOVD/r 
	{ 0x7F, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x80, ENTRY_CopyBytes3Or5Target },				// JO 
	{ 0x81, ENTRY_CopyBytes3Or5Target },				// JNO 
	{ 0x82, ENTRY_CopyBytes3Or5Target },				// JB,JC,JNAE 
	{ 0x83, ENTRY_CopyBytes3Or5Target },				// JAE,JNB,JNC 
	{ 0x84, ENTRY_CopyBytes3Or5Target },				// JE,JZ,JZ 
	{ 0x85, ENTRY_CopyBytes3Or5Target },				// JNE,JNZ 
	{ 0x86, ENTRY_CopyBytes3Or5Target },				// JBE,JNA 
	{ 0x87, ENTRY_CopyBytes3Or5Target },				// JA,JNBE 
	{ 0x88, ENTRY_CopyBytes3Or5Target },				// JS 
	{ 0x89, ENTRY_CopyBytes3Or5Target },				// JNS 
	{ 0x8A, ENTRY_CopyBytes3Or5Target },				// JP,JPE 
	{ 0x8B, ENTRY_CopyBytes3Or5Target },				// JNP,JPO 
	{ 0x8C, ENTRY_CopyBytes3Or5Target },				// JL,NGE 
	{ 0x8D, ENTRY_CopyBytes3Or5Target },				// JGE,JNL 
	{ 0x8E, ENTRY_CopyBytes3Or5Target },				// JLE,JNG 
	{ 0x8F, ENTRY_CopyBytes3Or5Target },				// JG,JNLE 
	{ 0x90, ENTRY_CopyBytes2Mod },						// CMOVO (0F 40) 
	{ 0x91, ENTRY_CopyBytes2Mod },						// CMOVNO (0F 41) 
	{ 0x92, ENTRY_CopyBytes2Mod },						// CMOVB & CMOVC & CMOVNAE (0F 42) 
	{ 0x93, ENTRY_CopyBytes2Mod },						// CMOVAE & CMOVNB & CMOVNC (0F 43) 
	{ 0x94, ENTRY_CopyBytes2Mod },						// CMOVE & CMOVZ (0F 44) 
	{ 0x95, ENTRY_CopyBytes2Mod },						// CMOVNE & CMOVNZ (0F 45) 
	{ 0x96, ENTRY_CopyBytes2Mod },						// CMOVBE & CMOVNA (0F 46) 
	{ 0x97, ENTRY_CopyBytes2Mod },						// CMOVA & CMOVNBE (0F 47) 
	{ 0x98, ENTRY_CopyBytes2Mod },						// CMOVS (0F 48) 
	{ 0x99, ENTRY_CopyBytes2Mod },						// CMOVNS (0F 49) 
	{ 0x9A, ENTRY_CopyBytes2Mod },						// CMOVP & CMOVPE (0F 4A) 
	{ 0x9B, ENTRY_CopyBytes2Mod },						// CMOVNP & CMOVPO (0F 4B) 
	{ 0x9C, ENTRY_CopyBytes2Mod },						// CMOVL & CMOVNGE (0F 4C) 
	{ 0x9D, ENTRY_CopyBytes2Mod },						// CMOVGE & CMOVNL (0F 4D) 
	{ 0x9E, ENTRY_CopyBytes2Mod },						// CMOVLE & CMOVNG (0F 4E) 
	{ 0x9F, ENTRY_CopyBytes2Mod },						// CMOVG & CMOVNLE (0F 4F) 
	{ 0xA0, ENTRY_CopyBytes2 },							// PUSH 
	{ 0xA1, ENTRY_CopyBytes2 },							// POP 
	{ 0xA2, ENTRY_CopyBytes2 },							// CPUID 
	{ 0xA3, ENTRY_CopyBytes2Mod },						// BT  (0F A3)   
	{ 0xA4, ENTRY_CopyBytes2Mod1 },						// SHLD  
	{ 0xA5, ENTRY_CopyBytes2Mod },						// SHLD  
	{ 0xA6, ENTRY_Invalid },							// _A6 
	{ 0xA7, ENTRY_Invalid },							// _A7 
	{ 0xA8, ENTRY_CopyBytes2 },							// PUSH 
	{ 0xA9, ENTRY_CopyBytes2 },							// POP 
	{ 0xAA, ENTRY_CopyBytes2 },							// RSM 
	{ 0xAB, ENTRY_CopyBytes2Mod },						// BTS (0F AB) 
	{ 0xAC, ENTRY_CopyBytes2Mod1 },						// SHRD  
	{ 0xAD, ENTRY_CopyBytes2Mod },						// SHRD  
	{ 0xAE, ENTRY_CopyBytes2Mod },						// FXRSTOR/1,FXSAVE/0 
	{ 0xAF, ENTRY_CopyBytes2Mod },						// IMUL (0F AF) 
	{ 0xB0, ENTRY_CopyBytes2Mod },						// CMPXCHG (0F B0) 
	{ 0xB1, ENTRY_CopyBytes2Mod },						// CMPXCHG (0F B1) 
	{ 0xB2, ENTRY_CopyBytes2Mod },						// LSS/r 
	{ 0xB3, ENTRY_CopyBytes2Mod },						// BTR (0F B3) 
	{ 0xB4, ENTRY_CopyBytes2Mod },						// LFS/r 
	{ 0xB5, ENTRY_CopyBytes2Mod },						// LGS/r 
	{ 0xB6, ENTRY_CopyBytes2Mod },						// MOVZX/r 
	{ 0xB7, ENTRY_CopyBytes2Mod },						// MOVZX/r 
	{ 0xB8, ENTRY_Invalid },							// _B8 
	{ 0xB9, ENTRY_Invalid },							// _B9 
	{ 0xBA, ENTRY_CopyBytes2Mod1 },						// BT & BTC & BTR & BTS (0F BA) 
	{ 0xBB, ENTRY_CopyBytes2Mod },						// BTC (0F BB) 
	{ 0xBC, ENTRY_CopyBytes2Mod },						// BSF (0F BC) 
	{ 0xBD, ENTRY_CopyBytes2Mod },						// BSR (0F BD) 
	{ 0xBE, ENTRY_CopyBytes2Mod },						// MOVSX/r 
	{ 0xBF, ENTRY_CopyBytes2Mod },						// MOVSX/r 
	{ 0xC0, ENTRY_CopyBytes2Mod },						// XADD/r 
	{ 0xC1, ENTRY_CopyBytes2Mod },						// XADD/r 
	{ 0xC2, ENTRY_Invalid },							// _C2 
	{ 0xC3, ENTRY_Invalid },							// _C3 
	{ 0xC4, ENTRY_Invalid },							// _C4 
	{ 0xC5, ENTRY_Invalid },							// _C5 
	{ 0xC6, ENTRY_Invalid },							// _C6 
	{ 0xC7, ENTRY_CopyBytes2Mod },						// CMPXCHG8B (0F C7) 
	{ 0xC8, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xC9, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCA, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCB, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCC, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCD, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCE, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCF, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xD0, ENTRY_Invalid },							// _D0 
	{ 0xD1, ENTRY_CopyBytes2Mod },						// PSRLW/r 
	{ 0xD2, ENTRY_CopyBytes2Mod },						// PSRLD/r 
	{ 0xD3, ENTRY_CopyBytes2Mod },						// PSRLQ/r 
	{ 0xD4, ENTRY_Invalid },							// _D4 
	{ 0xD5, ENTRY_CopyBytes2Mod },						// PMULLW/r 
	{ 0xD6, ENTRY_Invalid },							// _D6 
	{ 0xD7, ENTRY_Invalid },							// _D7 
	{ 0xD8, ENTRY_CopyBytes2Mod },						// PSUBUSB/r 
	{ 0xD9, ENTRY_CopyBytes2Mod },						// PSUBUSW/r 
	{ 0xDA, ENTRY_Invalid },							// _DA 
	{ 0xDB, ENTRY_CopyBytes2Mod },						// PAND/r 
	{ 0xDC, ENTRY_CopyBytes2Mod },						// PADDUSB/r 
	{ 0xDD, ENTRY_CopyBytes2Mod },						// PADDUSW/r 
	{ 0xDE, ENTRY_Invalid },							// _DE 
	{ 0xDF, ENTRY_CopyBytes2Mod },						// PANDN/r 
	{ 0xE0, ENTRY_Invalid },							// _E0 
	{ 0xE1, ENTRY_CopyBytes2Mod },						// PSRAW/r 
	{ 0xE2, ENTRY_CopyBytes2Mod },						// PSRAD/r 
	{ 0xE3, ENTRY_Invalid },							// _E3 
	{ 0xE4, ENTRY_Invalid },							// _E4 
	{ 0xE5, ENTRY_CopyBytes2Mod },						// PMULHW/r 
	{ 0xE6, ENTRY_Invalid },							// _E6 
	{ 0xE7, ENTRY_Invalid },							// _E7 
	{ 0xE8, ENTRY_CopyBytes2Mod },						// PSUBB/r 
	{ 0xE9, ENTRY_CopyBytes2Mod },						// PSUBW/r 
	{ 0xEA, ENTRY_Invalid },							// _EA 
	{ 0xEB, ENTRY_CopyBytes2Mod },						// POR/r 
	{ 0xEC, ENTRY_CopyBytes2Mod },						// PADDSB/r 
	{ 0xED, ENTRY_CopyBytes2Mod },						// PADDSW/r 
	{ 0xEE, ENTRY_Invalid },							// _EE 
	{ 0xEF, ENTRY_CopyBytes2Mod },						// PXOR/r 
	{ 0xF0, ENTRY_Invalid },							// _F0 
	{ 0xF1, ENTRY_CopyBytes2Mod },						// PSLLW/r 
	{ 0xF2, ENTRY_CopyBytes2Mod },						// PSLLD/r 
	{ 0xF3, ENTRY_CopyBytes2Mod },						// PSLLQ/r 
	{ 0xF4, ENTRY_Invalid },							// _F4 
	{ 0xF5, ENTRY_CopyBytes2Mod },						// PMADDWD/r 
	{ 0xF6, ENTRY_Invalid },							// _F6 
	{ 0xF7, ENTRY_Invalid },							// _F7 
	{ 0xF8, ENTRY_CopyBytes2Mod },						// PSUBB/r 
	{ 0xF9, ENTRY_CopyBytes2Mod },						// PSUBW/r 
	{ 0xFA, ENTRY_CopyBytes2Mod },						// PSUBD/r 
	{ 0xFB, ENTRY_Invalid },							// _FB 
	{ 0xFC, ENTRY_CopyBytes2Mod },						// PADDB/r 
	{ 0xFD, ENTRY_CopyBytes2Mod },						// PADDW/r 
	{ 0xFE, ENTRY_CopyBytes2Mod },						// PADDD/r 
	{ 0xFF, ENTRY_Invalid },							// _FF 
	{ 0, ENTRY_End },
};

BOOL CDetourDis::SanityCheckSystem()
{
	for (ULONG n = 0; n < 256; n++) {
		REFCOPYENTRY pEntry = &s_rceCopyTable[n];

		if (n != pEntry->nOpcode) {
			ASSERT(n == pEntry->nOpcode);
			return FALSE;
		}
	}
	if (s_rceCopyTable[256].pfCopy != NULL) {
		ASSERT(!"Missing end marker.");
		return FALSE;
	}
	
	for (n = 0; n < 256; n++) {
		REFCOPYENTRY pEntry = &s_rceCopyTable0F[n];

		if (n != pEntry->nOpcode) {
			ASSERT(n == pEntry->nOpcode);
			return FALSE;
		}
	}
	if (s_rceCopyTable0F[256].pfCopy != NULL) {
		ASSERT(!"Missing end marker.");
		return FALSE;
	}
	
	return TRUE;
}
//
///////////////////////////////////////////////////////////////// End of File.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\detours.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  File:       detours.cpp
//  Module:     detours.lib
//
//  Detours for binary functions.  Version 1.3. (Build 43)
//
//  Copyright 1995-1999, Microsoft Corporation
//
//  http://research.microsoft.com/sn/detours
//

#include "stdafx.h"
#include <ole2.h>
#include <imagehlp.h>
#include "detours.h"
#include "dtrsint.h"

//////////////////////////////////////////////////////////////////////////////
//
enum {
    OP_PRE_ES       = 0x26,
    OP_PRE_CS       = 0x2e,
    OP_PRE_SS       = 0x36,
    OP_PRE_DS       = 0x3e,
    OP_PRE_FS       = 0x64,
    OP_PRE_GS       = 0x65,
    OP_JMP_SEG      = 0x25,
    
    OP_JA           = 0x77,
    OP_NOP          = 0x90,
    OP_CALL         = 0xe8,
    OP_JMP          = 0xe9,
    OP_PREFIX       = 0xff,
    OP_MOV_EAX      = 0xa1,
    OP_SET_EAX      = 0xb8,
    OP_JMP_EAX      = 0xe0,
    OP_RET_POP      = 0xc2,
    OP_RET          = 0xc3,
    OP_BRK          = 0xcc,

    SIZE_OF_JMP     = 5,
    SIZE_OF_NOP     = 1,
    SIZE_OF_BRK     = 1,
    SIZE_OF_TRP_OPS = SIZE_OF_JMP /* + SIZE_OF_BRK */,
};

class CEnableWriteOnCodePage
{
public:
    CEnableWriteOnCodePage(PBYTE pbCode, LONG cbCode = DETOUR_TRAMPOLINE_SIZE)
    {
        m_pbCode = pbCode;
        m_cbCode = cbCode;
        m_dwOldPerm = 0;
        m_hProcess = GetCurrentProcess();

        if (m_pbCode && m_cbCode) {
            if (!FlushInstructionCache(m_hProcess, pbCode, cbCode)) {
                return;
            }
            if (!VirtualProtect(pbCode,
                                cbCode,
                                PAGE_EXECUTE_READWRITE,
                                &m_dwOldPerm)) {
                return;
            }
        }
    }

    ~CEnableWriteOnCodePage()
    {
        if (m_dwOldPerm && m_pbCode && m_cbCode) {
            DWORD dwTemp = 0;
            if (!FlushInstructionCache(m_hProcess, m_pbCode, m_cbCode)) {
                return;
            }
            if (!VirtualProtect(m_pbCode, m_cbCode, m_dwOldPerm, &dwTemp)) {
                return;
            }
        }
    }

    BOOL SetPermission(DWORD dwPerms)
    {
        if (m_dwOldPerm && m_pbCode && m_cbCode) {
            m_dwOldPerm = dwPerms;
            return TRUE;
        }
        return FALSE;
    }

    BOOL IsValid(VOID)
    {
        return m_pbCode && m_cbCode && m_dwOldPerm;
    }

private:
    HANDLE  m_hProcess;
    PBYTE   m_pbCode;
    LONG    m_cbCode;
    DWORD   m_dwOldPerm;
};

//////////////////////////////////////////////////////////////////////////////
//
static BOOL detour_insert_jump(PBYTE pbCode, PBYTE pbDest, LONG cbCode)
{
    if (cbCode < SIZE_OF_JMP)
        return FALSE;

    pbCode = DetourGenJmp(pbCode, pbDest);
    for (cbCode -= SIZE_OF_JMP; cbCode > 0; cbCode--) {
        pbCode = DetourGenBreak(pbCode);
    }
    return TRUE;
}

static BOOL detour_insert_detour(PBYTE pbTarget,
                                 PBYTE pbTrampoline,
                                 PBYTE pbDetour)
{
    PBYTE pbCont = pbTarget;
    for (LONG cbTarget = 0; cbTarget < SIZE_OF_TRP_OPS;) {
        PBYTE pbOp = pbCont;
        BYTE bOp = *pbOp;
        pbCont = DetourCopyInstruction(NULL, pbCont, NULL);
        cbTarget = pbCont - pbTarget;

        if (bOp == OP_JMP ||
            bOp == OP_JMP_EAX ||
            bOp == OP_RET_POP ||
            bOp == OP_RET) {

            break;
        }
        if (bOp == OP_PREFIX && pbOp[1] == OP_JMP_SEG) {
            break;
        }
        if ((bOp == OP_PRE_ES ||
             bOp == OP_PRE_CS ||
             bOp == OP_PRE_SS ||
             bOp == OP_PRE_DS ||
             bOp == OP_PRE_FS ||
             bOp == OP_PRE_GS) &&
            pbOp[1] == OP_PREFIX &&
            pbOp[2] == OP_JMP_SEG) {
            break;
        }
    }
    if (cbTarget  < SIZE_OF_TRP_OPS) {
        // Too few instructions.
        return FALSE;
    }
    if (cbTarget > (DETOUR_TRAMPOLINE_SIZE - SIZE_OF_JMP - 1)) {
        // Too many instructions.
        return FALSE;
    }

    //////////////////////////////////////////////////////// Finalize Reroute.
    //
    CEnableWriteOnCodePage ewTrampoline(pbTrampoline, DETOUR_TRAMPOLINE_SIZE);
    CEnableWriteOnCodePage ewTarget(pbTarget, cbTarget);
    if (!ewTrampoline.SetPermission(PAGE_EXECUTE_READWRITE))
        return FALSE;
    if (!ewTarget.IsValid())
        return FALSE;
    
    PBYTE pbSrc = pbTarget;
    PBYTE pbDst = pbTrampoline;
    for (LONG cbCopy = 0; cbCopy < cbTarget;) {
        pbSrc = DetourCopyInstruction(pbDst, pbSrc, NULL);
        cbCopy = pbSrc - pbTarget;
        pbDst = pbTrampoline + cbCopy;
    }
    if (cbCopy != cbTarget)                             // Count came out different!
        return FALSE;

    if (!detour_insert_jump(pbDst, pbTarget + cbTarget, SIZE_OF_JMP))
        return FALSE;

    pbTrampoline[DETOUR_TRAMPOLINE_SIZE-1] = (BYTE)cbTarget;

    if (!detour_insert_jump(pbTarget, pbDetour, cbTarget))
        return FALSE;
    
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL WINAPI DetourRemove(PBYTE pbTrampoline,
                                       PBYTE pbDetour)
{
    pbTrampoline = DetourGetFinalCode(pbTrampoline, TRUE);
    pbDetour = DetourGetFinalCode(pbDetour, FALSE);

    ////////////////////////////////////// Verify that Trampoline is in place.
    //
    LONG cbTarget = pbTrampoline[DETOUR_TRAMPOLINE_SIZE-1];
    if (cbTarget == 0 || cbTarget >= DETOUR_TRAMPOLINE_SIZE - 1) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (pbTrampoline[cbTarget] != OP_JMP) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
        
    LONG offset = *((PDWORD)&pbTrampoline[cbTarget + 1]);
    PBYTE pbTarget = pbTrampoline + cbTarget + SIZE_OF_JMP + offset - cbTarget;

    if (pbTarget[0] != OP_JMP) {                        // Missing detour.
        SetLastError(ERROR_INVALID_BLOCK);
        return FALSE;
    }

    offset = *((PDWORD)&pbTarget[1]);
    PBYTE pbTargetDetour = pbTarget + SIZE_OF_JMP + offset;
    if (pbTargetDetour != pbDetour) {
        SetLastError(ERROR_INVALID_ACCESS);
        return FALSE;
    }

    /////////////////////////////////////////////////////// Remove the Detour.
    CEnableWriteOnCodePage ewTarget(pbTarget, cbTarget);
    
    PBYTE pbSrc = pbTrampoline;
    PBYTE pbDst = pbTarget;
    for (LONG cbCopy = 0; cbCopy < cbTarget; pbDst = pbTarget + cbCopy) {
        pbSrc = DetourCopyInstruction(pbDst, pbSrc, NULL);
        cbCopy = pbSrc - pbTrampoline;
    }
    if (cbCopy != cbTarget) {                           // Count came out different!
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }
    return TRUE;
}

PBYTE WINAPI DetourFunction(PBYTE pbTarget,
                            PBYTE pbDetour)
{
    PBYTE pbTrampoline = new BYTE [DETOUR_TRAMPOLINE_SIZE];
    if (pbTrampoline == NULL)
        return NULL;

    pbTarget = DetourGetFinalCode(pbTarget, FALSE);
    pbDetour = DetourGetFinalCode(pbDetour, FALSE);

    if (detour_insert_detour(pbTarget, pbTrampoline, pbDetour))
        return pbTrampoline;

    delete[] pbTrampoline;
    return NULL;
}

BOOL WINAPI DetourFunctionWithEmptyTrampoline(PBYTE pbTrampoline,
                                              PBYTE pbTarget,
                                              PBYTE pbDetour)
{
    return DetourFunctionWithEmptyTrampolineEx(pbTrampoline, pbTarget, pbDetour,
                                               NULL, NULL, NULL);
}

BOOL WINAPI DetourFunctionWithEmptyTrampolineEx(PBYTE pbTrampoline,
                                                PBYTE pbTarget,
                                                PBYTE pbDetour,
                                                PBYTE *ppbRealTrampoline,
                                                PBYTE *ppbRealTarget,
                                                PBYTE *ppbRealDetour)
{
    pbTrampoline = DetourGetFinalCode(pbTrampoline, TRUE);
    pbTarget = DetourGetFinalCode(pbTarget, FALSE);
    pbDetour = DetourGetFinalCode(pbDetour, FALSE);
    
    if (ppbRealTrampoline)
        *ppbRealTrampoline = pbTrampoline;
    if (ppbRealTarget)
        *ppbRealTarget = pbTarget;
    if (ppbRealDetour)
        *ppbRealDetour = pbDetour;
    
    if (pbTrampoline == NULL || pbDetour == NULL || pbTarget == NULL)
        return FALSE;
    
    if (pbTrampoline[0] != OP_NOP ||
        pbTrampoline[1] != OP_NOP) {
        
        return FALSE;
    }
    
    return detour_insert_detour(pbTarget, pbTrampoline, pbDetour);
}

BOOL WINAPI DetourFunctionWithTrampoline(PBYTE pbTrampoline,
                                         PBYTE pbDetour)
{
    return DetourFunctionWithTrampolineEx(pbTrampoline, pbDetour, NULL, NULL);
}

BOOL WINAPI DetourFunctionWithTrampolineEx(PBYTE pbTrampoline,
                                           PBYTE pbDetour,
                                           PBYTE *ppbRealTrampoline,
                                           PBYTE *ppbRealTarget)
{
    PBYTE pbTarget = NULL;

    pbTrampoline = DetourGetFinalCode(pbTrampoline, TRUE);
    pbDetour = DetourGetFinalCode(pbDetour, FALSE);
    
    if (ppbRealTrampoline)
        *ppbRealTrampoline = pbTrampoline;
    if (ppbRealTarget)
        *ppbRealTarget = NULL;
    
    if (pbTrampoline == NULL || pbDetour == NULL)
        return FALSE;

    if (pbTrampoline[0] != OP_NOP   ||
        pbTrampoline[1] != OP_NOP   ||
        pbTrampoline[2] != OP_CALL  ||
        pbTrampoline[7] != OP_PREFIX    ||
        pbTrampoline[8] != OP_JMP_EAX) {
        
        return FALSE;
    }

    PVOID (__fastcall * pfAddr)(VOID);

    pfAddr = (PVOID (__fastcall *)(VOID))(pbTrampoline +
                                          SIZE_OF_NOP + SIZE_OF_NOP + SIZE_OF_JMP +
                                          *(LONG *)&pbTrampoline[3]);

    pbTarget = DetourGetFinalCode((PBYTE)(*pfAddr)(), FALSE);
    if (ppbRealTarget)
        *ppbRealTarget = pbTarget;

    return detour_insert_detour(pbTarget, pbTrampoline, pbDetour);
}

//////////////////////////////////////////////////////////////////////////////

PDETOUR_SYM_INFO DetourLoadImageHlp(VOID)
{
    static DETOUR_SYM_INFO symInfo;
    static PDETOUR_SYM_INFO pSymInfo= NULL;

    if (pSymInfo != NULL) {
        return pSymInfo;
    }

    pSymInfo = &symInfo;
    ZeroMemory(&symInfo, sizeof(symInfo));
    symInfo.hProcess = GetCurrentProcess();

    symInfo.hImageHlp = LoadLibraryA("imagehlp.dll");
    if (symInfo.hImageHlp == NULL) {
        return NULL;
    }

    symInfo.pfImagehlpApiVersionEx
        = (PF_ImagehlpApiVersionEx)GetProcAddress(symInfo.hImageHlp,
                                                  "ImagehlpApiVersionEx");
    symInfo.pfSymInitialize
        = (PF_SymInitialize)GetProcAddress(symInfo.hImageHlp, "SymInitialize");
    symInfo.pfSymSetOptions
        = (PF_SymSetOptions)GetProcAddress(symInfo.hImageHlp, "SymSetOptions");
    symInfo.pfSymGetOptions
        = (PF_SymGetOptions)GetProcAddress(symInfo.hImageHlp, "SymGetOptions");
    symInfo.pfSymLoadModule
        = (PF_SymLoadModule)GetProcAddress(symInfo.hImageHlp, "SymLoadModule");
    symInfo.pfSymGetModuleInfo
        = (PF_SymGetModuleInfo)GetProcAddress(symInfo.hImageHlp, "SymGetModuleInfo");
    symInfo.pfSymGetSymFromName
        = (PF_SymGetSymFromName)GetProcAddress(symInfo.hImageHlp, "SymGetSymFromName");
    symInfo.pfBindImage
        = (PF_BindImage)GetProcAddress(symInfo.hImageHlp, "BindImage");

    API_VERSION av;
    ZeroMemory(&av, sizeof(av));
    av.MajorVersion = API_VERSION_NUMBER;
            
    if (symInfo.pfImagehlpApiVersionEx) {
        (*symInfo.pfImagehlpApiVersionEx)(&av);
    }

    if (symInfo.pfImagehlpApiVersionEx == NULL || av.MajorVersion < API_VERSION_NUMBER) {
        FreeLibrary(symInfo.hImageHlp);
        symInfo.hImageHlp = NULL;
        return NULL;
    }
        
    if (symInfo.pfSymInitialize) {
        (*symInfo.pfSymInitialize)(symInfo.hProcess, NULL, FALSE);
    }
        
    if (symInfo.pfSymGetOptions && symInfo.pfSymSetOptions) {
        DWORD dw = (*symInfo.pfSymGetOptions)();
        dw &= (SYMOPT_CASE_INSENSITIVE | SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS);
        (*symInfo.pfSymSetOptions)(dw);
    }
        
    return pSymInfo;
}

//////////////////////////////////////////////////////////////////////////////
//
PBYTE WINAPI DetourGetFinalCode(PBYTE pbCode, BOOL fSkipJmp)
{
    if (pbCode == NULL) {
        return NULL;
    }
    
    if (pbCode[0] == OP_PREFIX && pbCode[1] == OP_JMP_SEG) {
        // Looks like an import alias jump, then get the code it points to.
        pbCode = *(PBYTE *)&pbCode[2];
        pbCode = *(PBYTE *)pbCode;
    }
    else if (pbCode[0] == OP_JMP && fSkipJmp) {         // Reference passed (for tramp).
        // Looks like a reference passed from an incremental-link build.
        // We only skip these for trampolines.
        pbCode = pbCode + SIZE_OF_JMP + *(LONG *)&pbCode[1];
    }
    return pbCode;
}

PBYTE WINAPI DetourFindFunction(PCHAR pszModule, PCHAR pszFunction)
{
    /////////////////////////////////////////////// First, Try GetProcAddress.
    //
    HMODULE hModule = LoadLibraryA(pszModule);
    if (hModule == NULL) {
        return NULL;
    }

    PBYTE pbCode = (PBYTE)GetProcAddress(hModule, pszFunction);
    if (pbCode) {
        return pbCode;
    }

    ////////////////////////////////////////////////////// Then Try ImageHelp.
    //
    PDETOUR_SYM_INFO pSymInfo = DetourLoadImageHlp();
    if (pSymInfo == NULL || 
        pSymInfo->pfSymLoadModule == NULL ||
        pSymInfo->pfSymGetModuleInfo == NULL ||
        pSymInfo->pfSymGetSymFromName == NULL) {

        return NULL;
    }
    
    (*pSymInfo->pfSymLoadModule)(pSymInfo->hProcess, NULL, pszModule, NULL, (DWORD)hModule, 0);

    IMAGEHLP_MODULE modinfo;
    ZeroMemory(&modinfo, sizeof(modinfo));
    if (!(*pSymInfo->pfSymGetModuleInfo)(pSymInfo->hProcess, (DWORD)hModule, &modinfo)) {
        return NULL;
    }

    CHAR szFullName[512];
    strcpy(szFullName, modinfo.ModuleName);
    strcat(szFullName, "!");
    strcat(szFullName, pszFunction);
    
    DWORD nDisplacement = 0;
    struct CFullSymbol : IMAGEHLP_SYMBOL {
        CHAR szRestOfName[512];
    } symbol;
    ZeroMemory(&symbol, sizeof(symbol));
    symbol.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    symbol.MaxNameLength = sizeof(symbol.szRestOfName)/sizeof(0);

    if (!(*pSymInfo->pfSymGetSymFromName)(pSymInfo->hProcess, szFullName, &symbol)) {
        return NULL;
    }

    return (PBYTE)symbol.Address;
}

//////////////////////////////////////////////////// Module Image Functions.
//
HMODULE WINAPI DetourEnumerateModules(HMODULE hModuleLast)
{
    PBYTE pbLast;
    
    if (hModuleLast == NULL) {
        pbLast = (PBYTE)0x10000;
    }
    else {
        pbLast = (PBYTE)hModuleLast + 0x10000;
    }

    MEMORY_BASIC_INFORMATION mbi;
    ZeroMemory(&mbi, sizeof(mbi));

    // Find the next memory region that contains a mapped PE image.
    //
    for (;; pbLast = (PBYTE)mbi.BaseAddress + mbi.RegionSize) {
        if (VirtualQuery((PVOID)pbLast, &mbi, sizeof(mbi)) <= 0) {
            return NULL;
        }

        // Skip uncommitted regions and guard pages.
        //
        if ((mbi.State != MEM_COMMIT) || (mbi.Protect & PAGE_GUARD)) {
            continue;
        }
        
        __try {
            PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pbLast;
            if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
                continue;
            }

            PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                              pDosHeader->e_lfanew);
            if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
                continue;
            }

            return (HMODULE)pDosHeader;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            /* nothing. */
        }
    }
    return NULL;
}

PBYTE WINAPI DetourGetEntryPoint(HMODULE hModule)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
    if (hModule == NULL) {
        pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandle(NULL);
    }
    
    __try {
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }
        
        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return NULL;
        }
        if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return NULL;
        }
        SetLastError(NO_ERROR);
        return (PBYTE)pNtHeader->OptionalHeader.AddressOfEntryPoint +
            pNtHeader->OptionalHeader.ImageBase;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    SetLastError(ERROR_EXE_MARKED_INVALID);
    
    return NULL;
}

static inline PBYTE RvaAdjust(HMODULE hModule, DWORD raddr)
{
    if (raddr != NULL) {
        return (PBYTE)hModule + raddr;
    }
    return NULL;
}

BOOL WINAPI DetourEnumerateExports(HMODULE hModule,
                                   PVOID pContext,
                                   PF_DETOUR_BINARY_EXPORT_CALLBACK pfExport)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
    if (hModule == NULL) {
        pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandle(NULL);
    }
    
    __try {
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }
        
        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return FALSE;
        }
        if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return FALSE;
        }

        PIMAGE_EXPORT_DIRECTORY pExportDir
            = (PIMAGE_EXPORT_DIRECTORY)
            RvaAdjust(hModule,
                      pNtHeader->OptionalHeader
                      .DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
        ULONG cbExportDir = pNtHeader->OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
        
        if (pExportDir == NULL) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return FALSE;
        }

        PCHAR pszName = (PCHAR)RvaAdjust(hModule, pExportDir->Name);
        PDWORD pdwFunctions = (PDWORD)RvaAdjust(hModule, pExportDir->AddressOfFunctions);
        PDWORD pdwNames = (PDWORD)RvaAdjust(hModule, pExportDir->AddressOfNames);
        PWORD pwOrdinals = (PWORD)RvaAdjust(hModule, pExportDir->AddressOfNameOrdinals);

        for (DWORD nFunc = 0; nFunc < pExportDir->NumberOfFunctions; nFunc++) {
            PBYTE pbCode = (PBYTE)RvaAdjust(hModule, pdwFunctions[nFunc]);
            PCHAR pszName = (nFunc < pExportDir->NumberOfNames) ?
                (PCHAR)RvaAdjust(hModule, pdwNames[nFunc]) : NULL;
            ULONG nOrdinal = pExportDir->Base + pwOrdinals[nFunc];

            if (!(*pfExport)(pContext, nOrdinal, pszName, pbCode)) {
                break;
            }
        }
        SetLastError(NO_ERROR);
        return TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    SetLastError(ERROR_EXE_MARKED_INVALID);
    return FALSE;
}

static PDETOUR_LOADED_BINARY WINAPI GetPayloadSectionFromModule(HMODULE hModule)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
    if (hModule == NULL) {
        pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandle(NULL);
    }
    
    __try {
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }
        
        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return NULL;
        }
        if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return NULL;
        }
        
        PIMAGE_SECTION_HEADER pSectionHeaders
            = (PIMAGE_SECTION_HEADER)((PBYTE)pNtHeader
                                      + sizeof(pNtHeader->Signature)
                                      + sizeof(pNtHeader->FileHeader)
                                      + pNtHeader->FileHeader.SizeOfOptionalHeader);

        for (DWORD n = 0; n < pNtHeader->FileHeader.NumberOfSections; n++) {
            if (strcmp((PCHAR)pSectionHeaders[n].Name, ".detour") == 0) {
                if (pSectionHeaders[n].VirtualAddress == 0 ||
                    pSectionHeaders[n].SizeOfRawData == 0) {

                    break;
                }
                    
                PBYTE pbData = (PBYTE)pDosHeader + pSectionHeaders[n].VirtualAddress;
                DETOUR_SECTION_HEADER *pHeader = (DETOUR_SECTION_HEADER *)pbData;
                if (pHeader->cbHeaderSize < sizeof(DETOUR_SECTION_HEADER) ||
                    pHeader->nSignature != DETOUR_SECTION_HEADER_SIGNATURE) {
                    
                    break;
                }

                if (pHeader->nDataOffset == 0) {
                    pHeader->nDataOffset = pHeader->cbHeaderSize;
                }
                SetLastError(NO_ERROR);
                return (PBYTE)pHeader;
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    SetLastError(ERROR_EXE_MARKED_INVALID);
    
    return NULL;
}

DWORD WINAPI DetourGetSizeOfPayloads(HMODULE hModule)
{
    PDETOUR_LOADED_BINARY pBinary = GetPayloadSectionFromModule(hModule);
    
    __try {
        DETOUR_SECTION_HEADER *pHeader = (DETOUR_SECTION_HEADER *)pBinary;
        if (pHeader->cbHeaderSize < sizeof(DETOUR_SECTION_HEADER) ||
            pHeader->nSignature != DETOUR_SECTION_HEADER_SIGNATURE) {
            
            SetLastError(ERROR_INVALID_HANDLE);
            return 0;
        }
        SetLastError(NO_ERROR);
        return pHeader->cbDataSize;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_HANDLE);
        return 0;
    }
    SetLastError(ERROR_INVALID_HANDLE);
    return 0;
}

PBYTE WINAPI DetourFindPayload(HMODULE hModule, REFGUID rguid, DWORD * pcbData)
{
    PBYTE pbData = NULL;
    DWORD cbData = 0;
    if (pcbData) {
        *pcbData = 0;
    }

    PDETOUR_LOADED_BINARY pBinary = GetPayloadSectionFromModule(hModule);
    
    __try {
        DETOUR_SECTION_HEADER *pHeader = (DETOUR_SECTION_HEADER *)pBinary;
        if (pHeader->cbHeaderSize < sizeof(DETOUR_SECTION_HEADER) ||
            pHeader->nSignature != DETOUR_SECTION_HEADER_SIGNATURE) {

            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return NULL;
        }
        
        PBYTE pbBeg = ((PBYTE)pHeader) + pHeader->nDataOffset;
        PBYTE pbEnd = ((PBYTE)pHeader) + pHeader->cbDataSize;
        
        for (pbData = pbBeg; pbData < pbEnd;) {
            DETOUR_SECTION_RECORD *pSection = (DETOUR_SECTION_RECORD *)pbData;
            
            if (pSection->guid == rguid) {
                if (pcbData) {
                    *pcbData = pSection->cbBytes - sizeof(*pSection);
                    SetLastError(NO_ERROR);
                    return (PBYTE)(pSection + 1);
                }
            }
            
            pbData = (PBYTE)pSection + pSection->cbBytes;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_HANDLE);
        return NULL;
    }
    SetLastError(ERROR_INVALID_HANDLE);
    return NULL;
}

//  End of File
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\Detours\detours.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  File:       detours.h
//  Module:     detours.lib
//
//  Detours for binary functions.  Version 1.3. (Build 43)
//
//  Copyright 1995-1999, Microsoft Corporation
//
//  http://research.microsoft.com/sn/detours
//

#pragma once
#ifndef _DETOURS_H_
#define _DETOURS_H_

//#pragma comment(lib, "detours")

//////////////////////////////////////////////////////////////////////////////
//
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
{
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
} GUID;
#endif // !GUID_DEFINED

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#endif // !__cplusplus
//
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/////////////////////////////////////////////////// Instruction Target Macros.
//
#define DETOUR_INSTRUCTION_TARGET_NONE          ((PBYTE)0)
#define DETOUR_INSTRUCTION_TARGET_DYNAMIC       ((PBYTE)~0ul)

/////////////////////////////////////////////////////////// Trampoline Macros.
//
// DETOUR_TRAMPOLINE(trampoline_prototype, target_name)
//
// The naked trampoline must be at least DETOUR_TRAMPOLINE_SIZE bytes.
//
#define DETOUR_TRAMPOLINE_SIZE          32
#define DETOUR_SECTION_HEADER_SIGNATURE 0x00727444   // "Dtr\0"

#define DETOUR_TRAMPOLINE(trampoline,target) \
static PVOID __fastcall _Detours_GetVA_##target(VOID) \
{ \
    return &target; \
} \
\
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { call _Detours_GetVA_##target };\
    __asm { jmp eax };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

#define DETOUR_TRAMPOLINE_EMPTY(trampoline) \
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { xor eax, eax };\
    __asm { mov eax, [eax] };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

/////////////////////////////////////////////////////////// Binary Structures.
//
#pragma pack(push, 8)
typedef struct _DETOUR_SECTION_HEADER
{
    DWORD       cbHeaderSize;
    DWORD       nSignature;
    DWORD       nDataOffset;
    DWORD       cbDataSize;
    
    DWORD       nOriginalImportVirtualAddress;
    DWORD       nOriginalImportSize;
    DWORD       nOriginalBoundImportVirtualAddress;
    DWORD       nOriginalBoundImportSize;
    
    DWORD       nOriginalIatVirtualAddress;
    DWORD       nOriginalIatSize;
    DWORD       nOriginalSizeOfImage;
    DWORD       nReserve;
} DETOUR_SECTION_HEADER, *PDETOUR_SECTION_HEADER;

typedef struct _DETOUR_SECTION_RECORD
{
    DWORD       cbBytes;
    DWORD       nReserved;
    GUID        guid;
} DETOUR_SECTION_RECORD, *PDETOUR_SECTION_RECORD;
#pragma pack(pop)

#define DETOUR_SECTION_HEADER_DECLARE(cbSectionSize) \
{ \
      sizeof(DETOUR_SECTION_HEADER),\
      DETOUR_SECTION_HEADER_SIGNATURE,\
      sizeof(DETOUR_SECTION_HEADER),\
      (cbSectionSize),\
      \
      0,\
      0,\
      0,\
      0,\
      \
      0,\
      0,\
      0,\
      0,\
}

///////////////////////////////////////////////////////////// Binary Typedefs.
//
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_BYWAY_CALLBACK)(PVOID pContext,
                                                         PCHAR pszFile,
                                                         PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FILE_CALLBACK)(PVOID pContext,
                                                        PCHAR pszOrigFile,
                                                        PCHAR pszFile,
                                                        PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_SYMBOL_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszOrigSymbol,
                                                          PCHAR pszSymbol,
                                                          PCHAR *ppszOutSymbol);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FINAL_CALLBACK)(PVOID pContext);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_EXPORT_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszName,
                                                          PBYTE pbCode);

typedef VOID * PDETOUR_BINARY;
typedef VOID * PDETOUR_LOADED_BINARY;

//////////////////////////////////////////////////////// Trampoline Functions.
//
PBYTE WINAPI DetourFunction(PBYTE pbTargetFunction,
                            PBYTE pbDetourFunction);

BOOL WINAPI DetourFunctionWithEmptyTrampoline(PBYTE pbTrampoline,
                                              PBYTE pbTarget,
                                              PBYTE pbDetour);

BOOL WINAPI DetourFunctionWithEmptyTrampolineEx(PBYTE pbTrampoline,
                                                PBYTE pbTarget,
                                                PBYTE pbDetour,
                                                PBYTE *ppbRealTrampoline,
                                                PBYTE *ppbRealTarget,
                                                PBYTE *ppbRealDetour);

BOOL  WINAPI DetourFunctionWithTrampoline(PBYTE pbTrampoline,
                                          PBYTE pbDetour);

BOOL  WINAPI DetourFunctionWithTrampolineEx(PBYTE pbTrampoline,
                                            PBYTE pbDetour,
                                            PBYTE *ppbRealTrampoline,
                                            PBYTE *ppbRealTarget);

BOOL  WINAPI DetourRemove(PBYTE pbTrampoline, PBYTE pbDetour);

////////////////////////////////////////////////////////////// Code Functions.
//
PBYTE WINAPI DetourFindFunction(PCHAR pszModule, PCHAR pszFunction);
PBYTE WINAPI DetourGetFinalCode(PBYTE pbCode, BOOL fSkipJmp);

PBYTE WINAPI DetourCopyInstruction(PBYTE pbDst, PBYTE pbSrc, PBYTE *ppbTarget);
PBYTE WINAPI DetourCopyInstructionEx(PBYTE pbDst,
                                     PBYTE pbSrc,
                                     PBYTE *ppbTarget,
                                     LONG *plExtra);

///////////////////////////////////////////////////// Loaded Binary Functions.
//
HMODULE WINAPI DetourEnumerateModules(HMODULE hModuleLast);
PBYTE WINAPI DetourGetEntryPoint(HMODULE hModule);
BOOL WINAPI DetourEnumerateExports(HMODULE hModule,
                                   PVOID pContext,
                                   PF_DETOUR_BINARY_EXPORT_CALLBACK pfExport);

PBYTE WINAPI DetourFindPayload(HMODULE hModule, REFGUID rguid, DWORD *pcbData);
DWORD WINAPI DetourGetSizeOfPayloads(HMODULE hModule);

///////////////////////////////////////////////// Persistent Binary Functions.
//
BOOL WINAPI DetourBinaryBindA(PCHAR pszFile, PCHAR pszDll, PCHAR pszPath);
BOOL WINAPI DetourBinaryBindW(PWCHAR pwzFile, PWCHAR pwzDll, PWCHAR pwzPath);
#ifdef UNICODE
#define DetourBinaryBind  DetourBinaryBindW
#else
#define DetourBinaryBind  DetourBinaryBindA
#endif // !UNICODE

PDETOUR_BINARY WINAPI DetourBinaryOpen(HANDLE hFile);
PBYTE WINAPI DetourBinaryEnumeratePayloads(PDETOUR_BINARY pBinary,
                                           GUID *pGuid,
                                           DWORD *pcbData,
                                           DWORD *pnIterator);
PBYTE WINAPI DetourBinaryFindPayload(PDETOUR_BINARY pBinary,
                                     REFGUID rguid,
                                     DWORD *pcbData);
PBYTE WINAPI DetourBinarySetPayload(PDETOUR_BINARY pBinary,
                                    REFGUID rguid,
                                    PBYTE pbData,
                                    DWORD cbData);
BOOL WINAPI DetourBinaryDeletePayload(PDETOUR_BINARY pBinary, REFGUID rguid);
BOOL WINAPI DetourBinaryPurgePayloads(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryResetImports(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryEditImports(PDETOUR_BINARY pBinary,
                                    PVOID pContext,
                                    PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,
                                    PF_DETOUR_BINARY_FILE_CALLBACK pfFile,
                                    PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,
                                    PF_DETOUR_BINARY_FINAL_CALLBACK pfFinal);
BOOL WINAPI DetourBinaryWrite(PDETOUR_BINARY pBinary, HANDLE hFile);
BOOL WINAPI DetourBinaryClose(PDETOUR_BINARY pBinary);

/////////////////////////////////////////////// First Chance Exception Filter.
//
LPTOP_LEVEL_EXCEPTION_FILTER WINAPI
DetourFirstChanceExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelFilter);

///////////////////////////////////////////////// Create Process & Inject Dll.
//
typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEA)
    (LPCSTR lpApplicationName,
     LPSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCSTR lpCurrentDirectory,
     LPSTARTUPINFOA lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);

typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEW)
    (LPCWSTR lpApplicationName,
     LPWSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCWSTR lpCurrentDirectory,
     LPSTARTUPINFOW lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);
                                  
BOOL WINAPI DetourCreateProcessWithDllA(LPCSTR lpApplicationName,
                                        LPSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCSTR lpCurrentDirectory,
                                        LPSTARTUPINFOA lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEA
                                        pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllW(LPCWSTR lpApplicationName,
                                        LPWSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCWSTR lpCurrentDirectory,
                                        LPSTARTUPINFOW lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCWSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEW
                                        pfCreateProcessW);
                  
#ifdef UNICODE
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllW
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEW
#else
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllA
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEA
#endif // !UNICODE

BOOL WINAPI DetourContinueProcessWithDllA(HANDLE hProcess, LPCSTR lpDllName);
BOOL WINAPI DetourContinueProcessWithDllW(HANDLE hProcess, LPCWSTR lpDllName);

#ifdef UNICODE
#define DetourContinueProcessWithDll    DetourContinueProcessWithDllW
#else
#define DetourContinueProcessWithDll    DetourContinueProcessWithDllA
#endif // !UNICODE
//
//////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif // __cplusplus

/////////////////////////////////////////////////////////////////// Old Names.
//
#define ContinueProcessWithDll            DetourContinueProcessWithDll 
#define ContinueProcessWithDllA           DetourContinueProcessWithDllA
#define ContinueProcessWithDllW           DetourContinueProcessWithDllW
#define CreateProcessWithDll              DetourCreateProcessWithDll 
#define CreateProcessWithDllA             DetourCreateProcessWithDllA
#define CreateProcessWithDllW             DetourCreateProcessWithDllW
#define DETOUR_TRAMPOLINE_WO_TARGET       DETOUR_TRAMPOLINE_EMPTY
#define DetourBinaryPurgePayload          DetourBinaryPurgePayloads
#define DetourEnumerateExportsForInstance DetourEnumerateExports
#define DetourEnumerateInstances          DetourEnumerateModules
#define DetourFindEntryPointForInstance   DetourGetEntryPoint
#define DetourFindFinalCode               DetourGetFinalCode
#define DetourFindPayloadInBinary         DetourFindPayload
#define DetourGetSizeOfBinary             DetourGetSizeOfPayloads
#define DetourRemoveWithTrampoline        DetourRemove
#define PCREATE_PROCESS_ROUTINE           PDETOUR_CREATE_PROCESS_ROUTINE
#define PCREATE_PROCESS_ROUTINEA          PDETOUR_CREATE_PROCESS_ROUTINEA
#define PCREATE_PROCESS_ROUTINEW          PDETOUR_CREATE_PROCESS_ROUTINEW
//

#endif // _DETOURS_H_

////////////////////////////////////////////////////////////////  End of File.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\dslink.cpp ===
#include "stdafx.h"
#include <mmsystem.h>
#include "dsoundp.h"
#include "dmusici.h"
#include "dslink.h"
#include "audiosink.h"
#include "float.h"
#include "effects.h"
#include "phoneyds.h"
#include "cconduct.h"
#include "fstream.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

DWORD g_dwLatency = DEFAULT_PHONEY_DS_LATENCY;

#ifdef _DEBUG
LogClass g_publicLogClass;
#endif

//#define _FILE_DEBUG 1
#ifdef _FILE_DEBUG
ofstream ofOutput;

void FTRACE( LPSTR pszFormat, ... )
{
	char strText[4096];
	va_list va;

	va_start(va, pszFormat);
	vsprintf(strText, pszFormat, va);
	va_end(va);

	ofOutput.write(strText, strlen( strText ));
}
#endif

bool g_fKslInitialized = false;
TCHAR g_szPhoneyDSoundFilterName[MAX_PATH];       // Filter path

#ifdef _DEBUG
UINT g_nLogLevel = 5;

int LogClass::Log( UINT nLevel, LPSTR pszFormat, ...)
{
	if( nLevel > g_nLogLevel )
	{
		return 0;
	}

	char strText[4096];
	va_list va;

	va_start(va, pszFormat);
	vsprintf(strText, pszFormat, va);
	va_end(va);
	TRACE("%d: %s\n", nLevel, strText);
	return 0;
}
int LogClass::LogEx( DWORD dwType, UINT nLevel, LPSTR pszFormat, ...)
{
	char strText[4096];
	va_list va;

	va_start(va, pszFormat);
	vsprintf(strText, pszFormat, va);
	va_end(va);

	TRACE("%d %d: %s\n", dwType, nLevel, strText);
	return 0;
}
int LogClass::LogSummary( UINT nLevel, LPSTR pszFormat, ...)
{
	char strText[4096];
	va_list va;

	va_start(va, pszFormat);
	vsprintf(strText, pszFormat, va);
	va_end(va);

	TRACE("%d: %s\n", nLevel, strText);
	return 0;
}
int LogClass::LogStatusBar( LPSTR pszFormat, ...)
{
	char strText[4096];
	va_list va;

	va_start(va, pszFormat);
	vsprintf(strText, pszFormat, va);
	va_end(va);

	TRACE("%s\n", strText);
	return 0;
}
void LogClass::LogStdErrorString(DWORD dwErrorCode)
{
	TRACE("Standard error %d\n", dwErrorCode);
	return;
}
#endif // _DEBUG

#ifndef USE_LOOPING_BUFFERS
void MyLock( LONGLONG llWriteStart, DWORD dwWriteCount, BYTE **ppbBuffer, DWORD dwBufferSize, LPVOID *ppStart, DWORD *pdwStart, LPVOID *ppEnd, DWORD *pdwEnd )
{
	int nBufferToUse = int((llWriteStart / dwBufferSize) % NUM_FRAMES);

	DWORD dwWriteStart = DWORD(llWriteStart % dwBufferSize);

	*pdwStart = min( dwWriteCount, dwBufferSize - dwWriteStart );
	*pdwEnd = dwWriteCount - *pdwStart;

	*ppEnd = ppbBuffer[(nBufferToUse + 1) % NUM_FRAMES];
	*ppStart = &(ppbBuffer[nBufferToUse][dwWriteStart]);

	//TRACE("MyLock: %d %I64d, %d, %x:%d, %x:%d\n", nBufferToUse, llWriteStart, dwWriteCount, *ppStart, *pdwStart, *ppEnd, *pdwEnd );
}
#endif //USE_LOOPING_BUFFERS

#ifdef USE_LOOPING_BUFFERS
void MyLoopingLock( LONGLONG llWriteStart, DWORD dwWriteCount, BYTE *pbBuffer, DWORD dwBufferSize, LPVOID *ppStart, DWORD *pdwStart, LPVOID *ppEnd, DWORD *pdwEnd )
{
	DWORD dwWriteStart = DWORD(llWriteStart % dwBufferSize);

	*pdwStart = min( dwWriteCount, dwBufferSize - dwWriteStart );
	*pdwEnd = dwWriteCount - *pdwStart;

	*ppEnd = pbBuffer;
	*ppStart = &(pbBuffer[dwWriteStart]);

	//TRACE("MyLoopingLock: %I64d, %d, %x:%d, %x:%d\n", llWriteStart, dwWriteCount, *ppStart, *pdwStart, *ppEnd, *pdwEnd );
}
#endif //USE_LOOPING_BUFFERS

void CDSLink::ReadBuffer()
{
    ::EnterCriticalSection(&m_CriticalSection);

    if (!m_fActive || !m_pPCMAudioPin /*|| !m_pIMasterClock*/)
    {
        TRACE("Warning: SynthSink - Thread in invalid state\n");
        ::LeaveCriticalSection(&m_CriticalSection);
        return;
    }

	KSSTATE ksState;
	if( m_pPCMAudioPin->GetState( &ksState )
	&&	ksState != KSSTATE_RUN )
	{
        TRACE("Warning: SynthSink - Pin not running\n");
        ::LeaveCriticalSection(&m_CriticalSection);
        return;
	}

	KSAUDIO_POSITION ksAudioPosition;
	if( m_pPCMAudioPin->GetPosition( &ksAudioPosition ) )
	{
		//TRACE("Position: %I64d %I64d %I64d\n", ksAudioPosition.PlayOffset, ksAudioPosition.WriteOffset, m_llAbsWrite );
#ifdef _FILE_DEBUG
		FTRACE("Position: %d %I64d %I64d %I64d ", timeGetTime(), ksAudioPosition.PlayOffset, ksAudioPosition.WriteOffset, m_llAbsWrite );
#endif

#ifdef USE_PINGPONG_BUFFERS
		if( ksAudioPosition.PlayOffset == ksAudioPosition.WriteOffset )
		{
			// We looped through all our buffers!!!
			//m_dwFrame = int(((ksAudioPosition.WriteOffset) / m_pPCMAudioPin->m_cbStreamData) % NUM_FRAMES);
			TRACE("Looped through all buffers\n");
		}

		while( m_pPCMAudioPin->IsSignaled( m_dwFrame ) )
		{
			// Write the next frame
			m_pPCMAudioPin->m_pbStreamData = m_apbData[m_dwFrame];
			m_pPCMAudioPin->WriteData( m_dwFrame, FALSE );

			// Switch to the next frame
			m_dwFrame++;
			m_dwFrame %= NUM_FRAMES;

			//TRACE("Switched to Frame %d at %I64d\n", m_dwFrame, ksAudioPosition.PlayOffset);
		}
#endif

		// Calculate the distance from the play cursor to the write cursor
        DWORD dwCursorDelta;
#ifdef USE_LOOPING_BUFFERS
		if( ksAudioPosition.PlayOffset > ksAudioPosition.WriteOffset )
		{
			ksAudioPosition.WriteOffset += m_pPCMAudioPin->m_cbStreamData;
		}
#endif //USE_LOOPING_BUFFERS
        dwCursorDelta = DWORD(ksAudioPosition.WriteOffset - ksAudioPosition.PlayOffset);

		// Check if the cursor delta is greater than anything we've seen
        if (dwCursorDelta > m_dwWriteFromMax)
        {
            //TRACE( "Warning: SynthSink - Play to Write cursor distance increased from %lu to %lu\n", m_dwWriteFromMax,dwCursorDelta);
            m_dwWriteFromMax = dwCursorDelta;
        }
        else
        {
			DWORD dwOldWriteFromMax = m_dwWriteFromMax;

			// Decrease m_dwWriteFromMax by 1% of the distance to dwCursorDelta
            m_dwWriteFromMax -= ((m_dwWriteFromMax - dwCursorDelta) / 100);
            m_dwWriteFromMax = SampleAlign(m_dwWriteFromMax);
            dwCursorDelta = m_dwWriteFromMax;

			if( dwCursorDelta != dwOldWriteFromMax )
			{
                //TRACE( "Warning: SynthSink - Play to Write cursor distance shrunk from %lu to %lu\n", dwOldWriteFromMax,m_dwWriteFromMax);
			}
        }

        if (m_llAbsWrite == 0)
        {
            // we just started
            m_llAbsPlay = ksAudioPosition.PlayOffset;
#ifdef USE_LOOPING_BUFFERS
			m_dwLastPlay = m_llAbsPlay;
#endif //USE_LOOPING_BUFFERS
            m_llAbsWrite = ksAudioPosition.WriteOffset;
        }

        ULONGLONG llAbsWriteFrom;

		HANDLE hCaptureFile = g_pconductor->m_pPhoneyDSound->GetFileHandle();

        DWORD dwPlayed;

		// Compute the length of the buffer that was played
#ifndef USE_LOOPING_BUFFERS
        dwPlayed = DWORD(ksAudioPosition.PlayOffset - m_llAbsPlay);

		m_llAbsPlay = ksAudioPosition.PlayOffset;
#else //USE_LOOPING_BUFFERS
		// Check if play position looped
		if( ksAudioPosition.PlayOffset < m_dwLastPlay )
		{
			// Yes - add in a copy of the buffer length
			dwPlayed = m_pPCMAudioPin->m_cbStreamData;
		}
		else
		{
			dwPlayed = 0;
		}
		dwPlayed += ksAudioPosition.PlayOffset - m_dwLastPlay;
		m_dwLastPlay = ksAudioPosition.PlayOffset;

		m_llAbsPlay += dwPlayed;
#endif //USE_LOOPING_BUFFERS

		 // Must start writing at least from the write cursor
        llAbsWriteFrom = m_llAbsPlay + DWORD(ksAudioPosition.WriteOffset - ksAudioPosition.PlayOffset);
#ifdef _FILE_DEBUG
		FTRACE("%I64d %d %I64d\n", m_llAbsPlay, dwPlayed, llAbsWriteFrom );
#endif

        // Are we ahead of the write head? (m_llAbsWrite is the position we wrote to the _last_ time)
        if (llAbsWriteFrom > m_llAbsWrite)
        {
            DWORD dwWriteMissed;

            // we are behind-- let's catch up
            dwWriteMissed = DWORD(llAbsWriteFrom - m_llAbsWrite);

            TRACE("Warning: SynthSink - Write underrun, missed %lu bytes\n", dwWriteMissed);
#ifdef _FILE_DEBUG
			FTRACE("Warning: SynthSink - Write underrun, missed %lu bytes\n", dwWriteMissed);
#endif

            m_llAbsWrite = llAbsWriteFrom;

			// Write out zeros for the time that we missed
			if( hCaptureFile != INVALID_HANDLE_VALUE )
			{
				static DWORD adwEmptyArray[16];
				while( dwWriteMissed > 0 )
				{
					DWORD dwWritten;
					WriteFile(hCaptureFile, adwEmptyArray, min( 16 * sizeof(DWORD ), dwWriteMissed ), &dwWritten, NULL);
					dwWriteMissed -= min( 16 * sizeof(DWORD ), dwWriteMissed );
				}
			}
        }

        // how much to write?
        ULONGLONG llAbsWriteTo;
        DWORD dwBytesToFill;

        llAbsWriteTo = llAbsWriteFrom + m_dwWriteTo;
		
#ifdef _FILE_DEBUG
		FTRACE("Write to: %I64d\n", llAbsWriteTo );
#endif

        if( m_pAudioSink
		&&	(llAbsWriteTo > m_llAbsWrite) )
        {
            dwBytesToFill = DWORD(llAbsWriteTo - m_llAbsWrite);
        }
        else
        {
            dwBytesToFill = 0;
        }

#ifdef USE_STREAMING_BUFFERS
		while( dwBytesToFill )
		{
			// Switch to the next frame
			m_dwFrame++;
			m_dwFrame %= NUM_FRAMES;
			m_pPCMAudioPin->m_pbStreamData = m_apbData[m_dwFrame];

			// Calculate the amount of data we're going to write into this frame
			DWORD dwBytesToFillNow = min( dwBytesToFill, m_pPCMAudioPin->m_cbStreamData );

			// Render the data into the buffer
            m_pAudioSink->Render((short*)m_pPCMAudioPin->m_pbStreamData, ByteToSample(dwBytesToFillNow), ByteToSample(m_llAbsWrite),ByteToSample(m_llAbsPlay));

            m_llAbsWrite += dwBytesToFillNow; 

			// Write out the samples we just rendered
			if( hCaptureFile != INVALID_HANDLE_VALUE )
			{
				DWORD dwWritten;
				WriteFile(hCaptureFile, m_pPCMAudioPin->m_pbStreamData, dwBytesToFillNow, &dwWritten, NULL);
			}

			// Write the frame
			DWORD dwTmpCbData = m_pPCMAudioPin->m_cbStreamData;
			m_pPCMAudioPin->m_cbStreamData = dwBytesToFillNow;
			m_pPCMAudioPin->WriteData( m_dwFrame, FALSE );
			m_pPCMAudioPin->m_cbStreamData = dwTmpCbData;

			dwBytesToFill -= dwBytesToFillNow;
		}
#endif
#ifdef USE_LOOPING_BUFFERS
        if (dwBytesToFill)
        {
            LPVOID lpStart, lpEnd;      // Buffer pointers, filled by Lock command.
            DWORD dwStart, dwEnd;       // For Lock.

			MyLoopingLock( m_llAbsWrite, dwBytesToFill, m_pPCMAudioPin->m_pbStreamData, m_pPCMAudioPin->m_cbStreamData, &lpStart, &dwStart, &lpEnd, &dwEnd );
            if (dwStart)
            {
//              TRACE("Clearing from %lx, %ld bytes\n",lpStart,dwStart);
				// No need to clear memory - Render() overwrites it

                m_pAudioSink->Render((short*)lpStart, ByteToSample(dwStart), ByteToSample(m_llAbsWrite),ByteToSample(m_llAbsPlay));

                m_llAbsWrite += dwStart; 

				// Write out the samples we just rendered
				if( hCaptureFile != INVALID_HANDLE_VALUE )
				{
					DWORD dwWritten;
					WriteFile(hCaptureFile, lpStart, dwStart, &dwWritten, NULL);
				}
            }
            if (dwEnd)
            {
//              TRACE("Clearing from %lx, %ld bytes\n",lpEnd,dwEnd);
				ZeroMemory( lpEnd, dwEnd );

                m_pAudioSink->Render((short*)lpEnd, ByteToSample(dwEnd), ByteToSample(m_llAbsWrite),ByteToSample(m_llAbsPlay));

                m_llAbsWrite += dwEnd;

				// Write out the samples we just rendered
				if( hCaptureFile != INVALID_HANDLE_VALUE )
				{
					DWORD dwWritten;
					WriteFile(hCaptureFile, lpEnd, dwEnd, &dwWritten, NULL);
				}
            }

            // write silence into unplayed buffer(s)
            //dwBytesToFill = m_pPCMAudioPin->m_cbStreamData - m_llAbsWrite + dwPlayCursor;

			//MyLock( m_llAbsWrite, dwBytesToFill, m_apbData, m_pPCMAudioPin->m_cbStreamData, &lpStart, &dwStart, &lpEnd, &dwEnd );
            //if (dwStart)
            //{
			//	ZeroMemory( lpStart, dwStart );
            //}
            //if (dwEnd)
            //{
			//	ZeroMemory( lpEnd, dwEnd );
            //}
        }
#endif //USE_PINGPONG_BUFFERS
#ifdef USE_PINGPONG_BUFFERS
        if (dwBytesToFill)
        {
            LPVOID lpStart, lpEnd;      // Buffer pointers, filled by Lock command.
            DWORD dwStart, dwEnd;       // For Lock.

			MyLock( m_llAbsWrite, dwBytesToFill, m_apbData, m_pPCMAudioPin->m_cbStreamData, &lpStart, &dwStart, &lpEnd, &dwEnd );
            if (dwStart)
            {
//              TRACE("Clearing from %lx, %ld bytes\n",lpStart,dwStart);
				// No need to clear memory - Render() overwrites it

                m_pAudioSink->Render((short*)lpStart, ByteToSample(dwStart), ByteToSample(m_llAbsWrite),ByteToSample(m_llAbsPlay));

                m_llAbsWrite += dwStart; 

				// Write out the samples we just rendered
				if( hCaptureFile != INVALID_HANDLE_VALUE )
				{
					DWORD dwWritten;
					WriteFile(hCaptureFile, lpStart, dwStart, &dwWritten, NULL);
				}
            }
            if (dwEnd)
            {
//              TRACE("Clearing from %lx, %ld bytes\n",lpEnd,dwEnd);
				ZeroMemory( lpEnd, dwEnd );

                m_pAudioSink->Render((short*)lpEnd, ByteToSample(dwEnd), ByteToSample(m_llAbsWrite),ByteToSample(m_llAbsPlay));

                m_llAbsWrite += dwEnd;

				// Write out the samples we just rendered
				if( hCaptureFile != INVALID_HANDLE_VALUE )
				{
					DWORD dwWritten;
					WriteFile(hCaptureFile, lpEnd, dwEnd, &dwWritten, NULL);
				}
            }

            // write silence into unplayed buffer(s)
            //dwBytesToFill = m_pPCMAudioPin->m_cbStreamData - m_llAbsWrite + dwPlayCursor;

			//MyLock( m_llAbsWrite, dwBytesToFill, m_apbData, m_pPCMAudioPin->m_cbStreamData, &lpStart, &dwStart, &lpEnd, &dwEnd );
            //if (dwStart)
            //{
			//	ZeroMemory( lpStart, dwStart );
            //}
            //if (dwEnd)
            //{
			//	ZeroMemory( lpEnd, dwEnd );
            //}
        }
#endif //USE_PINGPONG_BUFFERS
    }
    else
    {
        TRACE("Error: SynthSink - Failed to get DS buffer position.\n");
    }

    ::LeaveCriticalSection(&m_CriticalSection);
}


void CDSLink::SynthProc()
{
    for (;;)
    {
        if (m_fPleaseDie)
        {
            m_fPleaseDie = FALSE;
            break;
        }
        
        if (m_fActive)
        {
            ReadBuffer();
        }

		const DWORD dwLatency = g_dwLatency;

		m_dwWriteTo = SampleAlign((500 + (m_wfSynth.nAvgBytesPerSec * dwLatency)) / 1000);
		m_dwResolution = dwLatency/3;
        if (m_dwResolution < 2) m_dwResolution = 2; 
        if (m_dwResolution > 100) m_dwResolution = 100;
        WaitForSingleObject(m_hEvent, m_dwResolution);
    }
}


DWORD WINAPI CDSLink::SynthThread (LPVOID lpThreadParameter)
{
    CDSLink *pLink = (CDSLink *) lpThreadParameter;
    pLink->SynthProc();
    return 0;
}

void TestRender(short *pnBuffer,DWORD dwLength,DWORD dwPosition)
{
    DWORD dwIndex;
    //TRACE("Mixing %ld samples from %ld to %ld on buffer %lx\n",
    //    dwLength,dwPosition,dwLength+dwPosition,pnBuffer);
    for (dwIndex = 0;dwIndex < dwLength;dwIndex++)
    {
        pnBuffer[dwIndex] = (short) (16000 * sin( 3.1415926 * (dwPosition + dwIndex) / 100));
    }
}

HRESULT CDSLink::Connect()
{
/*    if (!m_pSynth)
    {
        TRACE( "Error: SynthSink - Activation failed, SynthSink not initialized\n");
        return DMUS_E_SYNTHNOTCONFIGURED;
    }*/


	/*
    if (!IsValidFormat(&m_wfSynth))
    {
        TRACE( "Error: SynthSink - Activation failed, format not initialized/valid\n");
        return DMUS_E_SYNTHNOTCONFIGURED;
    }
	*/
	/*
    if (!m_pIMasterClock)
    {
        TRACE( "Error: SynthSink - Activation failed, master clock not set\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }*/

#ifdef _FILE_DEBUG
	if( !ofOutput.is_open() )
	{
		ofOutput.open( "\\output.txt" );
	}
#endif

	if( !m_pPCMAudioPin )
	{
		return DMUS_E_DSOUND_NOT_SET;
	}

    if (m_fActive)
    {
        TRACE( "Error: SynthSink - Activation failed, already active\n");
        return DMUS_E_SYNTHACTIVE;
    }

    HRESULT hr = E_FAIL;

    m_dwWriteTo = SampleAlign((500 + (m_wfSynth.nAvgBytesPerSec * g_dwLatency)) / 1000);

    m_llAbsPlay = 0;
	m_llAbsWrite = 0;

	// Create a DSBUFFER_LENGTH_MS buffer
	if( m_pPCMAudioPin->CreateDataBufferMS( DSBUFFER_LENGTH_MS, 0 ) )
	{
		m_pPCMAudioPin->m_cFramesUsed = NUM_FRAMES;
		m_apbData[0] = m_pPCMAudioPin->m_pbStreamData;
		for( int i=1; i < NUM_FRAMES; i++ )
		{
			m_apbData[i] = new BYTE[m_pPCMAudioPin->m_cbStreamData];
		}

		// fill initial buffer with silence
		for( i=0; i < NUM_FRAMES; i++ )
		{
			ZeroMemory(m_apbData[i], m_pPCMAudioPin->m_cbStreamData);
		}

		m_dwFrame = 0;
#ifdef USE_STREAMING_BUFFERS
		if( m_pPCMAudioPin->SetState( KSSTATE_RUN ) )
		{
			Activate();
			hr = S_OK;
		}
#endif //USE_STREAMING_BUFFERS
#ifdef USE_LOOPING_BUFFERS
		if( m_pPCMAudioPin->WriteData( 0, TRUE )
		&&	m_pPCMAudioPin->SetState( KSSTATE_RUN ) )
		{
			Activate();
			hr = S_OK;
		}
#endif //USE_LOOPING_BUFFERS
#ifdef USE_PINGPONG_BUFFERS
		bool fContinue = true;
		for( i=0; i < NUM_FRAMES; i++ )
		{
			m_pPCMAudioPin->m_pbStreamData = m_apbData[i];
			if( !m_pPCMAudioPin->WriteData( i, TRUE ) )
			{
				fContinue = false;
				break;
			}
		}

		if( fContinue
		&&	m_pPCMAudioPin->SetState( KSSTATE_RUN ) )
		{
			Activate();
			hr = S_OK;
		}
#endif //USE_PINGPONG_BUFFERS
	}

	if (FAILED(hr))
    {
        // Clean up
        //

		if( m_pPCMAudioPin )
		{
			m_pPCMAudioPin->SetState( KSSTATE_STOP );
			m_pPCMAudioPin->m_pbStreamData = NULL;
			m_pPCMAudioPin->ClosePin();
			m_pPCMAudioPin = NULL;
		}

        Clear();
    }

    if (SUCCEEDED(hr))
    {
	    ::LeaveCriticalSection(&m_CriticalSection);

        // wait until the pump is primed
        for (WORD wRetry = 0; wRetry < 10 && !m_llAbsWrite; wRetry++)
        {
            Sleep(10);
        }

	    ::EnterCriticalSection(&m_CriticalSection);

        if (m_llAbsWrite)
        {
            TRACE( "Warning: SynthSink - Pump is primed\n");
        }
        else
        {
            TRACE( "Error: SynthSink - Pump is NOT primed\n");
        }
    }

    return hr;
}

HRESULT CDSLink::Disconnect()
{
    // stop the buffer right away!
	if( m_pPCMAudioPin )
	{
		m_pPCMAudioPin->SetState( KSSTATE_STOP );

        // write silence to prevent blip bug if reactivated
		ZeroMemory( m_pPCMAudioPin->m_pbStreamData, m_pPCMAudioPin->m_cbStreamData );
		m_pPCMAudioPin->m_pbStreamData = m_apbData[0];
		ZeroMemory( m_pPCMAudioPin->m_pbStreamData, m_pPCMAudioPin->m_cbStreamData );
	}

    Deactivate();

	m_apbData[0] = NULL;
	for( int i=1; i < NUM_FRAMES; i++ )
	{
		delete []m_apbData[i];
		m_apbData[i] = NULL;
	}

    Clear();

    return S_OK;
}

void CDSLink::Clear()
{
    m_llAbsPlay = 0;        // Absolute point where play head is.
    m_llAbsWrite = 0;		// Absolute point we've written up to.
    m_dwWriteTo = 1000;     // Distance between write head and where we are writing.
}

CDSLink::CDSLink()
{
    ::InitializeCriticalSection(&m_CriticalSection);
	ZeroMemory( &m_wfSynth, sizeof(m_wfSynth) ); 
    m_pAudioSink = NULL;
    m_cRef = 0;
	m_pPCMAudioPin = NULL;
    m_dwWriteFromMax = 0;
    Clear();
    m_fActive = FALSE;
    m_fOpened = FALSE;
    m_fPleaseDie = FALSE;
    m_hThread = NULL;           // Handle for synth thread.
    m_dwThread = 0;             // ID for thread.
    m_hEvent = NULL;            // Used to signal thread.
    m_dwResolution = g_dwLatency/3;
	m_dwFrame = 0;
	for( int i=0; i < NUM_FRAMES; i++ )
	{
		m_apbData[i] = 0;
	}
	m_llAbsPlay = 0;
	m_llAbsWrite = 0;
#ifdef USE_LOOPING_BUFFERS
	m_dwLastPlay = 0;
#endif

    m_wfSynth.cbSize = 0;
    m_wfSynth.nAvgBytesPerSec = 22050 * 2 * 2;
    m_wfSynth.nBlockAlign = 4;
    m_wfSynth.nChannels = 2;
    m_wfSynth.nSamplesPerSec = 22050;
    m_wfSynth.wBitsPerSample = 16;
    m_wfSynth.wFormatTag = WAVE_FORMAT_PCM;
}

CDSLink::~CDSLink()
{
	CloseDown();
        
    ::DeleteCriticalSection(&m_CriticalSection);
}

void CDSLink::SetWaveFormat(WAVEFORMATEX *pWaveFormat)

{
    m_wfSynth.nSamplesPerSec = pWaveFormat->nSamplesPerSec;
    m_wfSynth.nAvgBytesPerSec = m_wfSynth.nSamplesPerSec * 2 * 2;
}

BOOL CDSLink::OpenUp(CAudioSink *pSink)
{
    if (m_fOpened)
    {
        TRACE( "Warning: SynthSink - Already opened\n");
        return TRUE;
    }

    ::EnterCriticalSection(&m_CriticalSection);

    m_fOpened = TRUE;
    m_pAudioSink = pSink;
    
	if( !g_fKslInitialized )
	{
#ifdef _DEBUG
		KslRegisterLog( &g_publicLogClass );
#endif
		KslInitKsLib();
		g_fKslInitialized = true;
	}
	CList<CKsFilter> lstFilters;
	GUID *pGuid = new GUID;
	*pGuid = KSCATEGORY_AUDIO_DEVICE;
	KslEnumFilters( &lstFilters, ePCMAudio, &pGuid, 1, TRUE, TRUE, FALSE );
	CNode<CKsFilter> *pNode = lstFilters.GetHead();
	while( pNode && !m_pPCMAudioPin )
	{
		CPCMAudioFilter *pPCMAudioFilter = (CPCMAudioFilter *)pNode->pData;

		if( g_szPhoneyDSoundFilterName[0] == 0
		||	strcmp( pPCMAudioFilter->m_szFilterName, g_szPhoneyDSoundFilterName ) == 0 )
		{
			CPCMAudioPin *pCPCMAudioPin = pPCMAudioFilter->FindViablePin( &(pPCMAudioFilter->m_listRenderSinkPins), &m_wfSynth );
			if( pCPCMAudioPin )
			{
				pCPCMAudioPin->SetFormat( &m_wfSynth );
#ifdef USE_LOOPING_BUFFERS
				if( pCPCMAudioPin->Instantiate( TRUE ) ) // TRUE - looped, FALSE - not looped
#else //USE_LOOPING_BUFFERS
				if( pCPCMAudioPin->Instantiate( FALSE ) ) // TRUE - looped, FALSE - not looped
#endif //USE_LOOPING_BUFFERS
				{
					CNode<CKsPin> *pPinNode = pPCMAudioFilter->m_listPins.Find( pCPCMAudioPin );
					pPCMAudioFilter->m_listPins.Remove( pPinNode );
					m_pPCMAudioPin = pCPCMAudioPin;
					break;
				}
			}
		}

		pNode = lstFilters.GetNext( pNode );
	}

	pNode = lstFilters.GetHead();
    while(pNode)
    {
        if (pNode->pData)
        {
            delete pNode->pData;
        }
        pNode = lstFilters.GetNext(pNode);
    }
	lstFilters.Empty();

	delete pGuid;

    Connect();

    ::LeaveCriticalSection(&m_CriticalSection);

   return TRUE;
}

void CDSLink::CloseDown()
{
    if (!m_fOpened)
    {
        TRACE("Warning: SynthSink - Process Detach, ports all deactivated\n");
    }
    else
    {
	   ::EnterCriticalSection(&m_CriticalSection);

        Disconnect();
		if( m_pPCMAudioPin )
		{
			m_pPCMAudioPin->SetState( KSSTATE_STOP );
			m_pPCMAudioPin->m_pbStreamData = NULL;
			m_pPCMAudioPin->ClosePin();
			m_pPCMAudioPin = NULL;
		}
        m_fOpened = FALSE;
		if( g_fKslInitialized )
		{
			KslCloseKsLib();
			g_fKslInitialized = false;
		}

	    ::LeaveCriticalSection(&m_CriticalSection);
    }
}

void CDSLink::Activate()
{
    if (!m_fActive)
    {
        m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        m_hThread = CreateThread(NULL, 0, CDSLink::SynthThread, this, 0, &m_dwThread);

        if (m_hThread)
        {
            if (!SetThreadPriority(m_hThread, THREAD_PRIORITY_TIME_CRITICAL))
            {
                TRACE( "Error: SynthSink - Activate couldn't set thread priority\n");
            }
        }
        else
        {
            TRACE( "Error: SynthSink - Activate couldn't create thread\n");
        }
        
        m_fActive = TRUE;
    }
}

void CDSLink::Deactivate()
{
    if (m_fActive)
    {
        m_fActive = FALSE;

        if (m_hThread && m_hEvent)
        {
            m_fPleaseDie = TRUE;

			// Need to leave the critical section to that the sink thread can run
			::LeaveCriticalSection( &m_CriticalSection );

            SetEvent(m_hEvent);
            if (WaitForSingleObject(m_hThread, 10000) == WAIT_TIMEOUT)
            {
                TRACE( "Error: SynthSink - Deactivate, thread did not exit\n");
            }

			// Now, re-enter the critical section
			::EnterCriticalSection( &m_CriticalSection );
        }
        if (m_hEvent)
        {
            CloseHandle(m_hEvent);
            m_hEvent = NULL;
        }
        if(m_hThread)
        {
            CloseHandle(m_hThread);
            m_hThread = NULL;
        }
    }
}

ULONGLONG CDSLink::GetAbsPlaySample(void)
{
	KSAUDIO_POSITION ksAudioPosition;
	if( m_pPCMAudioPin
	&&	m_pPCMAudioPin->GetPosition( &ksAudioPosition ) )
	{
#ifdef USE_LOOPING_BUFFERS
		if( ksAudioPosition.PlayOffset < m_dwLastPlay )
		{
			ksAudioPosition.PlayOffset += m_pPCMAudioPin->m_cbStreamData;
		}
		ksAudioPosition.PlayOffset += m_llAbsPlay - m_dwLastPlay;
#else //USE_LOOPING_BUFFERS
		/*
		if( ksAudioPosition.PlayOffset != m_llAbsPlay )
		{
			TRACE("PlayOffset; %I64d\n", ksAudioPosition.PlayOffset - m_llAbsPlay);
		}
		*/
#endif //USE_LOOPING_BUFFERS
		return ByteToSample(ksAudioPosition.PlayOffset);
	}
	else
	{
		return ByteToSample(m_llAbsPlay);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\DirectKS\ksconn.cpp ===
// ------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1996 - 2000.  All rights reserved.
//
// Module Name:
//
//  ksconn.cpp
//
// Abstract:
//
//  Class implementation of CKsConnection.
//
// -------------------------------------------------------------------------------


#include "stdafx.h"
#include "kslibp.h"

// ------------------------------------------------------------------------
// CKsConnection::CKsConnection
// ------------------------------------------------------------------------
CKsConnection::CKsConnection()
{
    ZeroMemory(&m_Connection, sizeof(m_Connection));
} // CKsConnection

// ------------------------------------------------------------------------
// CKsConnection::CKsConnection()
// ------------------------------------------------------------------------
CKsConnection::CKsConnection(PKSTOPOLOGY_CONNECTION pConnection)
{
    if (pConnection)
    {
        CopyMemory(&m_Connection, pConnection, sizeof(m_Connection));
    }
} // CKsConnection

// ------------------------------------------------------------------------
// CKsConnection::CKsConnection()
// ------------------------------------------------------------------------
CKsConnection::CKsConnection(PCKsConnection pksfCopy)
{
    if (pksfCopy)
    {
        m_Connection.FromNode = pksfCopy->FromNode();
        m_Connection.FromNodePin = pksfCopy->FromNodePin();
        m_Connection.ToNode = pksfCopy->ToNode();
        m_Connection.ToNodePin = pksfCopy->ToNodePin();
    }
} // CKsConnection

// ------------------------------------------------------------------------
// CKsConnection::Initialize
// ------------------------------------------------------------------------
void  
CKsConnection::Initialize
(
    PKSTOPOLOGY_CONNECTION pConnection
)
{
    if (pConnection)
    {
        CopyMemory(&m_Connection, pConnection, sizeof(m_Connection));
    }
} // Initialize

// ------------------------------------------------------------------------
// CKsConnection::FromNode
// ------------------------------------------------------------------------
ULONG 
CKsConnection::FromNode()
{
    return m_Connection.FromNode;
} // FromNode

// ------------------------------------------------------------------------
// CKsConnection::FromNodePin
// ------------------------------------------------------------------------
ULONG 
CKsConnection::FromNodePin()
{
    return m_Connection.FromNodePin;
} // FromNodePin

// ------------------------------------------------------------------------
// CKsConnection::ToNode
// ------------------------------------------------------------------------
ULONG 
CKsConnection::ToNode()
{
    return m_Connection.ToNode;
} // ToNode

// ------------------------------------------------------------------------
// CKsConnection::ToNodePin
// ------------------------------------------------------------------------
ULONG 
CKsConnection::ToNodePin()
{
    return m_Connection.ToNodePin;
} // ToNodePin
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\DirectKS\ilog.h ===
#ifndef _ILOG_INC
#define _ILOG_INC

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// ------------------------------------------------------------------------------
// For consistancy sake, it is recommended that you use the following values for 
// the nLevel param in the various ILog methods
// ------------------------------------------------------------------------------
typedef enum 
{
    eFatalError,            // Memory allocation errors, internal test errors.
    eError,                 // Test case will fail because of this.
    eWarn1,                 // Important warning messages.
    eInfo1,                 // Important information, such as the device name, format.
    eWarn2,                 // 
    eInfo2,                 // Information about test flow.
    eWarn3,                 //
    eInfo3,                 // API logs (tdsound, wave, etc)
    eBlab1,                 // noise not important.
    eBlab2                  // noise not important.
} EErrorLevel;

// ------------------------------------------------------------------------------------------
// interface class for ILog
// Generic logging interface.
// ------------------------------------------------------------------------------------------
class ILog
{
public:
    virtual int      _cdecl Log( UINT nLevel, LPSTR pszFormat, ...) = 0;
    virtual int      _cdecl LogEx( DWORD dwType, UINT nLevel, LPSTR pszFormat, ...) = 0;
    virtual int      _cdecl LogSummary( UINT nLevel, LPSTR pszFormat, ...) = 0;
    virtual int      _cdecl LogStatusBar( LPSTR pszFormat, ...) = 0;
    virtual void     LogStdErrorString(DWORD dwErrorCode) = 0;
	virtual void     SetDeferredLogging (BOOL fOn) = 0;
	virtual void     CommitLog () = 0;
	virtual void	 DiscardDeferredLog () = 0;
};

// ------------------------------------------------------------------------------------------
// This is an implimentation of ILog that doesn't do anything
// If you are building a lib that can be used by both the testshell and by other programs, declare a 
// static LogStub in the lib and point a ILog* to it.  Also provide a registration method, so that 
// apps that use the test shell can enable logging.
//   example:  in the lib  
/*
static LogStub s_LogStub;
static ILog*   s_iLog = &s_LogStub;

BOOL xyzRegisterLog(ILog* iLog)
{
    if(!iLog)
        return FALSE;

    s_iLog = iLog;
    return TRUE;
}
*/
//   end of example
// ------------------------------------------------------------------------------------------
class LogStub : public ILog
{
public:
    virtual int      _cdecl Log( UINT nLevel, LPSTR pszFormat, ...) {UNREFERENCED_PARAMETER(nLevel);UNREFERENCED_PARAMETER(pszFormat);return 0;}
    virtual int      _cdecl LogEx( DWORD dwType, UINT nLevel, LPSTR pszFormat, ...) {UNREFERENCED_PARAMETER(dwType);UNREFERENCED_PARAMETER(nLevel);UNREFERENCED_PARAMETER(pszFormat);return 0;}
    virtual int      _cdecl LogSummary( UINT nLevel, LPSTR pszFormat, ...) {UNREFERENCED_PARAMETER(nLevel);UNREFERENCED_PARAMETER(pszFormat);return 0;}
    virtual int      _cdecl LogStatusBar( LPSTR pszFormat, ...) {UNREFERENCED_PARAMETER(pszFormat);return 0;}
    virtual void     LogStdErrorString(DWORD dwErrorCode) {UNREFERENCED_PARAMETER(dwErrorCode);return;}
	virtual void     SetDeferredLogging (BOOL fOn) {UNREFERENCED_PARAMETER(fOn);return;}
	virtual void     CommitLog () {return;}
	virtual void	 DiscardDeferredLog () {return;}
};

#endif //#ifndef _ILOG_INC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\DirectKS\ksfilter.cpp ===
// ------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1996 - 2000.  All rights reserved.
//
// File Name:
//
//	ksfilter.cpp
//
// Abstract:
//
//  Class implementation of CKsFilter, CTopologyFilter, 
//  and CSysAudioDeviceFilter.
//
// -------------------------------------------------------------------------------

#include "stdafx.h"
#include "kslibp.h"

// ----------------------------------------------------------------------------------
// CKsFilter::CKsFilter
//      constructor
// ----------------------------------------------------------------------------------
CKsFilter::CKsFilter()
  : CKsIrpTarget(INVALID_HANDLE_VALUE),
    m_pRenderPin(NULL),
    m_pCapturePin(NULL),
    m_eType(eUnknown)
{
    m_szFilterName[0] = 0;
    m_szFriendlyName[0] = 0;
    m_szCLSID[0] = 0;
    m_szService[0] = 0;
    m_szBinary[0] = 0;
    m_UserDef = NULL;
}

CKsFilter::CKsFilter
(
    CKsFilter* pksfCopy
) : CKsIrpTarget(INVALID_HANDLE_VALUE),
    m_pRenderPin(NULL),
    m_pCapturePin(NULL),
    m_eType(eUnknown)
{
    if (pksfCopy)
    {
        strcpy(m_szFilterName, pksfCopy->m_szFilterName);
        strcpy(m_szFriendlyName, pksfCopy->m_szFriendlyName);
        strcpy(m_szCLSID, pksfCopy->m_szCLSID);
        strcpy(m_szService, pksfCopy->m_szService);
        strcpy(m_szBinary, pksfCopy->m_szBinary);

        m_eType = pksfCopy->m_eType;
        m_UserDef = pksfCopy->m_UserDef;

        // Copy nodes.
        CNode<CKsNode>*  pNodeNode;
        CKsNode*         pNode;

        pNodeNode = pksfCopy->m_listNodes.GetHead();
        while (pNodeNode)
        {
            pNode = new CKsNode(this, pNodeNode->pData);
            m_listNodes.AddTail(pNode);
            pNodeNode = pksfCopy->m_listNodes.GetNext(pNodeNode);
        }
        
        // Copy Pins.
        CNode<CKsPin>*   pNodePin;
        CKsPin*          pPin;
        
        pNodePin = pksfCopy->m_listPins.GetHead();
        while (pNodePin)
        {
            pPin = new CKsPin(this, pNodePin->pData);
            m_listPins.AddTail(pPin);
            pNodePin = pksfCopy->m_listPins.GetNext(pNodePin);
        }

        // Copy Connections
        CNode<CKsConnection> *pNodeConnection;
        PCKsConnection        pConnection=NULL;

        pNodeConnection = pksfCopy->m_listConnections.GetHead();
        while (pNodeConnection)
        {
            pConnection = new CKsConnection(pNodeConnection->pData);
            m_listConnections.AddTail(pConnection);
            pNodeConnection = pksfCopy->m_listConnections.GetNext(pNodeConnection);
        }

        ClassifyPins(&m_listPins);
    }
}

// ------------------------------------------------------------------------------
CKsFilter::CKsFilter
(
    LPCTSTR     pszName,
    LPCTSTR     pszFriendlyName,
    LPCTSTR     pszCLSID,
    LPCTSTR     pszService,
    LPCTSTR     pszBinary
) : CKsIrpTarget(INVALID_HANDLE_VALUE),
    m_pRenderPin(NULL),
    m_pCapturePin(NULL),
    m_eType(eUnknown)
{
    m_UserDef = NULL;
    ASSERT(pszName && pszFriendlyName && pszCLSID);

    lstrcpy(m_szFilterName, pszName);
    lstrcpy(m_szFriendlyName, pszFriendlyName);
    lstrcpy(m_szCLSID, pszCLSID);
    lstrcpy(m_szService, pszService);
    lstrcpy(m_szBinary, pszBinary);
}

// ------------------------------------------------------------------------------
CKsFilter::~CKsFilter
( 
    void 
)
{
    DestroyLists();
    
    SafeCloseHandle(m_handle);
}

// ----------------------------------------------------------------------------------
// CKsFilter::Instantiate
// ----------------------------------------------------------------------------------
BOOL
CKsFilter::Instantiate
( 
    void 
)
{
    BOOL fRes;

    // get handle
    m_handle = 
        CreateFile
        (   
            m_szFilterName,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL
        );

    fRes = IsValidHandle(m_handle);
    if (!fRes)
    {
        DWORD dwError = GetLastError();
        
        LOG(eWarn2, "CKsFilter::Instantiate:  CreateFile failed for device %s. ErrorCode = dwError", m_szFilterName, dwError);
    }

    return fRes;
}

// ----------------------------------------------------------------------------------
// CKsFilter::EnumerateConnections
// ----------------------------------------------------------------------------------
BOOL    
CKsFilter::EnumerateConnections
(
    void
)
{
    DWORD                   fRes = TRUE;
    ULONG                   cConnections;
    PKSMULTIPLE_ITEM        pkmiTopoConnections = NULL;
    ULONG                   nConnection;
    PKSTOPOLOGY_CONNECTION  pKsConnection;

    fRes =
        GetPropertyMulti
        (
            KSPROPSETID_Topology,
            KSPROPERTY_TOPOLOGY_CONNECTIONS,
            &pkmiTopoConnections 
        );

    if (!fRes)
        LOG(eWarn2, "Failed to get property KSPROPSETID_Topology.KSPROPERTY_TOPOLOGY_CONNECTIONS");

    if (fRes)
    {
        if (pkmiTopoConnections)
        {
            cConnections = pkmiTopoConnections->Count;

            pKsConnection = (PKSTOPOLOGY_CONNECTION) (pkmiTopoConnections + 1);

            for(nConnection = 0; nConnection < cConnections; nConnection++, pKsConnection++)
            {
                PCKsConnection pnewConnection = new CKsConnection(pKsConnection);
                if (pnewConnection)
                {
                    m_listConnections.AddTail(pnewConnection);
                }
            }
        }

        ASSERT(m_listConnections.GetCount() == cConnections);
    }

    SafeLocalFree(pkmiTopoConnections);

    return fRes;
} // EnumerateConnections

// ----------------------------------------------------------------------------------
// CKsFilter::EnumeratePins
// ----------------------------------------------------------------------------------
BOOL    
CKsFilter::EnumeratePins
(
    void
)
{
    DWORD   fRes            = TRUE;
    DWORD   fViableFilter   = FALSE;
    HANDLE  hPin            = NULL;
    ULONG   cPins, nPinId;
    DWORD   dwKsRet         = ERROR_NOT_SUPPORTED;

    // get the number of pins supported by SAD
    fRes = 
        GetPinPropertySimple
        (  
            0,
            KSPROPSETID_Pin,
            KSPROPERTY_PIN_CTYPES,
            &cPins,
            sizeof(cPins)
        );

    if (fRes)
    {
        fRes = FALSE;

        //
        // loop through the pins, looking for audio pins
        //
        for(nPinId = 0; nPinId < cPins; nPinId++)
        {
            //
            // create a new CKsPin
            //
            CKsPin* pNewPin = new CKsPin(this, nPinId);

            //
            // Get the data flow property
            //
            fRes = 
                GetPinPropertySimple
                ( 
                    nPinId,
                    KSPROPSETID_Pin,
                    KSPROPERTY_PIN_DATAFLOW,
                    &pNewPin->m_Descriptor.DataFlow,
                    sizeof(KSPIN_DATAFLOW)
                );
            if (!fRes)
            {
                LOG(eWarn2, "Failed to retrieve pin property KSPROPERTY_PIN_DATAFLOW");
                delete pNewPin;
                continue;
            }

            //
            // Get the communication property.
            //
            fRes = 
                GetPinPropertySimple
                ( 
                    nPinId,
                    KSPROPSETID_Pin,
                    KSPROPERTY_PIN_COMMUNICATION,
                    &pNewPin->m_Descriptor.Communication,
                    sizeof(KSPIN_COMMUNICATION)
                );
            if (!fRes)
            {
                LOG(eWarn2, "Failed to retrieve pin property KSPROPERTY_PIN_COMMUNICATION");
                delete pNewPin;
                continue;
            }


            if (!pNewPin)
            {
                LOG(eWarn2, "Failed to create pin");
                continue;
            }

            m_listPins.AddTail(pNewPin);
        }
    }
    
    ClassifyPins(&m_listPins);

    fViableFilter =
        !   (
                m_listRenderSinkPins.IsEmpty() && 
                m_listRenderSourcePins.IsEmpty() && 
                m_listCaptureSinkPins.IsEmpty() &&
                m_listCaptureSourcePins.IsEmpty()
            );

    // the end
    return fViableFilter;
}

// ----------------------------------------------------------------------------------
// CKsFilter::ClassifyPins
//  Classifies pins in the given list according to their communication and dataflow
//  properties
// ----------------------------------------------------------------------------------
BOOL
CKsFilter::ClassifyPins(CList <CKsPin> *plistPins)
{
    if (plistPins)
    {
        CNode <CKsPin> *pNodePin = plistPins->GetHead();

        while (pNodePin)
        {
            CKsPin *pPin = pNodePin->pData;
            pNodePin = plistPins->GetNext(pNodePin);
            
            if (pPin->m_Descriptor.DataFlow == KSPIN_DATAFLOW_IN)
            {
                switch (pPin->m_Descriptor.Communication)
                {
                    case KSPIN_COMMUNICATION_SINK:
                        m_listRenderSinkPins.AddTail(pPin);      // IRP sink, Data Sink == render sink
                        break;

                    case KSPIN_COMMUNICATION_SOURCE:
                        m_listCaptureSourcePins.AddTail(pPin);   // IRP source, Data Sink == capture source
                        break;

                    case KSPIN_COMMUNICATION_BOTH:
                        m_listRenderSinkPins.AddTail(pPin);      // IRP sink, Data Sink == render sink
                        m_listCaptureSourcePins.AddTail(pPin);   // IRP source, Data Sink == capture source
                        break;
                }
            }
            else
            {
                switch (pPin->m_Descriptor.Communication)
                {
                    case KSPIN_COMMUNICATION_SINK:
                        m_listCaptureSinkPins.AddTail(pPin);     // IRP sink, Data Source == capture sink
                        break;

                    case KSPIN_COMMUNICATION_SOURCE:
                        m_listRenderSourcePins.AddTail(pPin);    // IRP source, Data Source == render source
                        break;

                    case KSPIN_COMMUNICATION_BOTH:
                        m_listCaptureSinkPins.AddTail(pPin);     // IRP sink, Data Source == capture sink
                        m_listRenderSourcePins.AddTail(pPin);    // IRP source, Data Source == render source
                        break;
                }
            }
        }

        return TRUE;
    }

    return FALSE;
} // ClassifyPins

// ----------------------------------------------------------------------------------
// CKsFilter::DestoyLists
//  Destroys pin and node lists.
// ----------------------------------------------------------------------------------
void    
CKsFilter::DestroyLists
(
    void
)
{
    // Clean nodes.
    CNode<CKsNode> *pNodeNode = m_listNodes.GetHead();
    while (pNodeNode)
    {
        if (pNodeNode->pData)
        {
            delete pNodeNode->pData;
        }
        pNodeNode = m_listNodes.GetNext(pNodeNode);
    }

    // Clean pins.
    CNode<CKsPin>* pNodePin = m_listPins.GetHead();
    while(pNodePin)
    {
        if (pNodePin->pData)
        {
            delete pNodePin->pData;
        }
        pNodePin = m_listPins.GetNext(pNodePin);
    }

    // Clean connections.
    CNode<CKsConnection>* pNodeConnection = m_listConnections.GetHead();
    while (pNodeConnection)
    {
        if (pNodeConnection->pData)
        {
            delete pNodeConnection->pData;
        }
        pNodeConnection = m_listConnections.GetNext(pNodeConnection);
    }
    
    // Empty lists.
    m_listConnections.Empty();
    m_listPins.Empty();
    m_listNodes.Empty();
    m_listRenderSinkPins.Empty();
    m_listRenderSourcePins.Empty();
    m_listCaptureSinkPins.Empty();
    m_listCaptureSourcePins.Empty();
} // Close

// ----------------------------------------------------------------------------------
// CKsFilter::EnumerateNodes
//  populates m_listNodes
// ----------------------------------------------------------------------------------
BOOL    
CKsFilter::EnumerateNodes
(
    void
)
{
    DWORD               fRes = TRUE;
    ULONG               cNodes;
    PKSMULTIPLE_ITEM    pkmiTopoNodes = NULL;
    GUID*               argguidNodes;
    ULONG               nNode;

    fRes =
        GetPropertyMulti
        (
            KSPROPSETID_Topology,
            KSPROPERTY_TOPOLOGY_NODES,
            &pkmiTopoNodes
        );

    if (!fRes)
        LOG(eWarn2, "Failed to get property KSPROPSETID_Topology.KSPROPERTY_TOPOLOGY_NODES");

    if (fRes)
    {
        if (pkmiTopoNodes)
        {
            argguidNodes = (GUID*)(pkmiTopoNodes + 1);
            cNodes = pkmiTopoNodes->Count;

            ULONG       ulBytesReturned;
            KSP_NODE    kspNode;
            DWORD       dwSupport;
            BOOL        fResIoctl;
            ULONG       nProperty;

            kspNode.Property.Set = KSPROPSETID_Audio;
            kspNode.Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT | KSPROPERTY_TYPE_TOPOLOGY;
    
            for(nNode = 0; nNode < cNodes; nNode++)
            {
                CKsNode* pnewNode = new CKsNode(this, nNode);
                m_listNodes.AddTail(pnewNode);

                CopyMemory(&pnewNode->m_guidType, &argguidNodes[nNode], sizeof(GUID));

                for(nProperty = KSPROPERTY_AUDIO_LATENCY; nProperty <= KSPROPERTY_AUDIO_3D_INTERFACE; nProperty++)
                {
                    dwSupport = 0;
                    kspNode.Property.Id = nProperty;
                    kspNode.NodeId = nNode;
                    kspNode.Reserved = 0;

                    fResIoctl =
                        SyncIoctl
                        (
                            m_handle,
                            IOCTL_KS_PROPERTY,
                            &kspNode,
                            sizeof(KSP_NODE),
                            &dwSupport,
                            sizeof(DWORD),
                            &ulBytesReturned
                        );

                    if (fResIoctl)
                    {
                        if (dwSupport & KSPROPERTY_TYPE_GET)
                            pnewNode->m_ullSuptdPropsMaskGet |= (1 << (nProperty - 1));

                        if (dwSupport & KSPROPERTY_TYPE_SET)
                            pnewNode->m_ullSuptdPropsMaskSet |= (1 << (nProperty - 1));
                    }
                }
            }
        }

        ASSERT(m_listNodes.GetCount() == cNodes);
    }

    SafeLocalFree(pkmiTopoNodes);

    return fRes;
}

// ----------------------------------------------------------------------------------
// CKsFilter::GetPinPropertySimple
//  Get the value of a simple (non-multi) pin property
// ----------------------------------------------------------------------------------
BOOL
CKsFilter::GetPinPropertySimple
(
    IN  ULONG   nPinID,
    IN  REFGUID guidPropertySet,
    IN  ULONG   nProperty,
    OUT PVOID   pvValue,
    OUT ULONG   cbValue
)
{
    ULONG   ulReturned = 0;
    KSP_PIN KsPProp;

    KsPProp.Property.Set = guidPropertySet;
    KsPProp.Property.Id = nProperty;
    KsPProp.Property.Flags = KSPROPERTY_TYPE_GET;
    KsPProp.PinId = nPinID;
    KsPProp.Reserved = 0;

    return 
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &KsPProp,
            sizeof(KSP_PIN),
            pvValue,
            cbValue,
            &ulReturned
        );
}

// ----------------------------------------------------------------------------------
// CKsFilter::GetPinPropertyMulti
//  Get the value of a multi-type pin property
// ----------------------------------------------------------------------------------
BOOL
CKsFilter::GetPinPropertyMulti
(
    IN  ULONG               nPinID,
    IN  REFGUID             guidPropertySet,
    IN  ULONG               nProperty,
    OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem
)
{
    BOOL    fRes;
    ULONG   ulReturned = 0;
    ULONG   cbMultipleItem = 0;
    KSP_PIN KsPProp;

    KsPProp.Property.Set = guidPropertySet;
    KsPProp.Property.Id = nProperty;
    KsPProp.Property.Flags = KSPROPERTY_TYPE_GET;
    KsPProp.PinId = nPinID;
    KsPProp.Reserved = 0;

    fRes =
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &KsPProp.Property,
            sizeof(KSP_PIN),
            NULL,
            0,
            &cbMultipleItem
        );

    if (fRes)
    {
        *ppKsMultipleItem = (PKSMULTIPLE_ITEM)LocalAlloc(LPTR, cbMultipleItem);
        
        fRes =
            SyncIoctl
            (
                m_handle,
                IOCTL_KS_PROPERTY,
                &KsPProp,
                sizeof(KSP_PIN),
                (PVOID)*ppKsMultipleItem,
                cbMultipleItem,
                &ulReturned
            );
    }

    return fRes;
}

// ----------------------------------------------------------------------------------
// CTopologyFilter      CTopologyFilter      CTopologyFilter      CTopologyFilter      
// ----------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------
// CTopologyFilter::CTopologyFilter
// ----------------------------------------------------------------------------------
CTopologyFilter::CTopologyFilter
(
    LPCTSTR  pszName,
    LPCTSTR  pszFriendlyName,
    LPCTSTR  pszCLSID,
    LPCTSTR  pszService,
    LPCTSTR  pszBinary
) : CKsFilter(pszName, pszFriendlyName, pszCLSID, pszService, pszBinary)
{
    m_eType = eTopology;
}

// ----------------------------------------------------------------------------------
// CSysAudioDeviceFilter   CSysAudioDeviceFilter   CSysAudioDeviceFilter   CSysAudioDeviceFilter
// ----------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------
// CSysAudioDeviceFilter::CSysAudioDeviceFilter
// ----------------------------------------------------------------------------------
CSysAudioDeviceFilter::CSysAudioDeviceFilter
(
    LPCTSTR  pszName,
    LPCTSTR  pszFriendlyName,
    LPCTSTR  pszCLSID,
    LPCTSTR  pszService, 
    LPCTSTR  pszBinary
) : CKsFilter(pszName, pszFriendlyName, pszCLSID, pszService, pszBinary)
{
    m_eType = eSysAudioDevice;
}

CSysAudioDeviceFilter::CSysAudioDeviceFilter
(
    LPCTSTR  pszName,
    LPCTSTR  pszFriendlyName
)
{
    m_eType = eSysAudioDevice;

    lstrcpy(m_szFilterName, pszName);
    lstrcpy(m_szFriendlyName, pszFriendlyName);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\DirectKS\directks.h ===
// ------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// Module Name:
//
//  kslib.h
//
// Abstract:
//  Header file for KsLib.lib and DirectKs.dll
//  This header contains class declarations for CKsFilter and CKsPin and their derived
//  classes.  The purpose of KsLib.lib and DirectKs.dll are to simplify the creation
//  of user mode KS clients.
//  The derived classes are audio specific, however classes for video capture, or other 
//  technologies that use KS/AvStream can be derived from CKsFilter and CKsPin.
//
// -------------------------------------------------------------------------------

//
// Abstract base class for KernelStreaming render & capture
//
#ifndef _KSLIB_H
#define _KSLIB_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

typedef long LONG_PTR, *PLONG_PTR;
typedef unsigned long ULONG_PTR, *PULONG_PTR;

#include <windows.h>
#include <mmsystem.h>
#include <ks.h>
#include <ksmedia.h>
#include <setupapi.h>
#include "ilog.h"
#include "list.h"

typedef struct
{
    KSPIN_CONNECT               Connect;
    KSDATAFORMAT_WAVEFORMATEX   Format;
} KSPIN_CONNECT_WFX, *PKSPIN_CONNECT_WFX;

typedef struct 
{
    KSPROPERTY      Property;
    ULONG           DeviceId;
} KSP_SYSAUDIO, *PKSP_SYSAUDIO;


typedef enum {eUnknown, eTopology, ePCMAudio, eMidi, eDMusic, eSysAudioDevice, eSysAudio} ETechnology;
typedef enum {render, capture} STACKWISE_DATAFLOW;

// forward ho
class CKsPin;
class CKsNode;
class CKsConnection;

// ----------------------------------------------------------------------------------
// CKsIrpTarget
//  This is a base class for controlling Ks file objects, i.e. filters and pins
//  CKsFilter and CKsPin derive from this class
// ----------------------------------------------------------------------------------
class CKsIrpTarget
{
public:
    HANDLE              m_handle;           // Allocated handle of the filter instance
    DWORD               m_dwDevInst;        // Device Instance Handle.
    LPARAM              m_UserDef;          // use this for whatever you want...

    CKsIrpTarget(HANDLE handle) : m_handle(INVALID_HANDLE_VALUE) { UNREFERENCED_PARAMETER(handle);return; }

    // get ----------
    BOOL
    GetPropertySimple
    (
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PVOID               pvDest,
        OUT ULONG               cbDest
    );

    BOOL
    GetPropertyMulti
    (
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem
    );

    BOOL
    GetPropertyMulti
    (
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        IN  PVOID               pvData,
        IN  ULONG               cbData,
        OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem
    );

    BOOL
    GetNodePropertyChannel
    (
        IN  ULONG               nChannel,
        IN  ULONG               nNodeID,
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PVOID               pvDest,
        OUT ULONG               cbDest
    );

    BOOL
    GetNodePropertySimple
    (
        IN  ULONG               nNodeID,
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nPropertySet,
        OUT PVOID               pvDest,
        OUT ULONG               cbDest
    );

    BOOL
    GetNodePropertyMulti
    (
        IN  ULONG               nNodeID,
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem    OPTIONAL
    );

    // set ----------
    BOOL
    SetPropertySimple
    (
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PVOID               pvDest,
        OUT ULONG               cbDest
    );

    BOOL
    SetPropertyMulti
    (
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem
    );

    BOOL
    SetNodePropertyChannel
    (
        IN  ULONG               nChannel,
        IN  ULONG               nNodeID,
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PVOID               pvDest,
        OUT ULONG               cbDest
    );

    BOOL
    SetNodePropertyMulti
    (
        IN  ULONG               nNodeID,
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem    OPTIONAL
    );

    BOOL
    SetNodePropertySimple
    (
        IN  ULONG               nNodeID,
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PVOID               pvDest,
        OUT ULONG               cbDest
    );

    HANDLE  GetHandle(void)     { return m_handle; }
};

typedef CKsIrpTarget *          PCKsIrpTarget;

// ----------------------------------------------------------------------------------
// CKsFilter
//  This is the base class for classes that proxy Ks filters from user mode.
//  Basic usage is 
//      instantiate a CKsFilter (or derived class)
//      call Instantiate, which creates a file object (instantiates the KS filter)
//                  whose handle is stored as m_handle
//      call EnumeratePins, EnumerateNodes, EnumerateConnections to deduce the filter's
//                  topology
//      call CKsIrpTarget functions to get/set properties
// ----------------------------------------------------------------------------------
class CKsFilter : public CKsIrpTarget
{
public:
	TCHAR               m_szFilterName[MAX_PATH];       // Filter path
	TCHAR               m_szFriendlyName[MAX_PATH];	    // Friendly name of the filter
	TCHAR               m_szCLSID[MAX_PATH];	        // Class ID of the filter
	TCHAR               m_szService[MAX_PATH];	        // Name of service, e.g. "kmixer"
	TCHAR               m_szBinary[MAX_PATH];	        // Name of Binary, e.g. "kmixer.sys"

    CList<CKsPin>       m_listPins;

    CList<CKsPin>       m_listRenderSinkPins;
    CList<CKsPin>       m_listRenderSourcePins;
    CList<CKsPin>       m_listCaptureSinkPins;
    CList<CKsPin>       m_listCaptureSourcePins;

    CList<CKsNode>      m_listNodes;

    CList<CKsConnection> m_listConnections;

    CKsPin*             m_pRenderPin;
    CKsPin*             m_pCapturePin;

    ETechnology         m_eType;

//    KSCOMPONENTID       m_ksComponentID;

public:
    CKsFilter();
    CKsFilter
	(
		CKsFilter* pksfCopy
	);
    CKsFilter
	(
		LPCTSTR  pszName,
		LPCTSTR  pszFriendlyName,
		LPCTSTR  pszCLSID,
		LPCTSTR  pszService,
		LPCTSTR  pszBinary
	);
    virtual __stdcall ~CKsFilter(void);

    virtual void    DestroyLists(void);
    BOOL    Instantiate(void);
    BOOL    EnumerateConnections(void);
    BOOL    EnumerateNodes(void);
    virtual BOOL    EnumeratePins(void);

    BOOL
    GetPinPropertySimple
    (
        IN  ULONG               nPinID,
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PVOID               pvDest,
        OUT ULONG               cbDest
    );

    BOOL
    GetPinPropertyMulti
    (
        IN  ULONG               nPinID,
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem    OPTIONAL
    );

protected:
    BOOL
    ClassifyPins(CList <CKsPin> *plistPins);
};

typedef CKsFilter *             PCKsFilter;

typedef struct 
{
    ULONG                       cInterfaces;
    PKSIDENTIFIER               pInterfaces;
    ULONG                       cMediums;
    PKSIDENTIFIER               pMediums;
    ULONG                       cDataRanges;
    PKSDATARANGE                pDataRanges;
    ULONG                       cConstrDataRanges;
    PKSDATARANGE                pConstrDataRanges;
    KSPIN_DATAFLOW              DataFlow;
    KSPIN_COMMUNICATION         Communication;
    KSPIN_CINSTANCES            CInstances;
    KSPIN_CINSTANCES            CInstancesGlobal;
    KSPIN_CINSTANCES            CInstancesNecessary;
    PKSPIN_PHYSICALCONNECTION   PhysicalConnection;
    GUID                        Category;
    PWCHAR                      Name;
} 
PIN_DESCRIPTOR, *PPIN_DESCRIPTOR;

// ----------------------------------------------------------------------------------
// CKsConnection
// ----------------------------------------------------------------------------------
class CKsConnection
{
public:
    CKsConnection();
    CKsConnection(PKSTOPOLOGY_CONNECTION pConnection);
    CKsConnection(CKsConnection * pksfCopy);

    void  Initialize(PKSTOPOLOGY_CONNECTION pConnection);

    ULONG FromNode();
    ULONG FromNodePin();
    ULONG ToNode();
    ULONG ToNodePin();

private:
    KSTOPOLOGY_CONNECTION       m_Connection;
};
typedef CKsConnection *         PCKsConnection;

// ----------------------------------------------------------------------------------
// CKsPin
//  This is the base class for classes that proxy Ks pins from user mode.
//  Basic usage is 
//      CKsFilter::EnumeratePins builds a list of CKsPins
//      look at the PIN_DESCRIPTORs to figure out which pins meet your needs
//      call Instantiate, which creates a file object (instantiates the KS pin)
//                  whose handle is stored as m_handle
//      call CKsIrpTarget functions to get/set properties
//      call WriteData
// ----------------------------------------------------------------------------------
class CKsPin : public CKsIrpTarget
{
public:
    CKsFilter*          m_pFilter;
    ULONG               m_nId;

    PIN_DESCRIPTOR      m_Descriptor;             // description of pin

    KSSTATE             m_ksState;                // state of pin
    PKSPIN_CONNECT      m_pksPinCreate;           // creation parameters of pin
    PKSDATAFORMAT       m_pksDataFormat;          // description of data
    KSSTREAM_HEADER     m_ksStreamHeader[10];
    ULONG               m_cFramesUsed;
    PBYTE               m_pbStreamData;
    DWORD               m_cbStreamData;
	TCHAR               m_szFriendlyName[MAX_PATH];   // Friendly name of the pin

    STACKWISE_DATAFLOW  m_nStackwiseFlow;

    OVERLAPPED          m_ov[10];

    BOOL                m_fLooped;
    ETechnology         m_eType;

protected:
    DWORD               m_dwAlignment;

public:
    CKsPin(CKsFilter* pFilter, CKsPin* pkspCopy);
    CKsPin(CKsFilter* pFilter, ULONG nId);
    virtual ~CKsPin(void);

    BOOL    Instantiate(BOOL fLooped = FALSE );
    void    ClosePin(void);

    BOOL    Wait(DWORD dwMilliseconds, ULONG nFrame);
    BOOL    Wait(DWORD dwMilliseconds);

    BOOL    IsSignaled(ULONG nFrame);
    BOOL    IsSignaled(void);

    OVERLAPPED      &GetOverlapped(UINT unIndex = 0);
    KSSTREAM_HEADER &GetStreamHeader(UINT unIndex = 0);

    BOOL    GetState(PKSSTATE pksState);
    BOOL    SetState(KSSTATE ksState);
    BOOL    Reset(void);

    BOOL    WriteData(ULONG nFrame, BOOL fPause);
    BOOL    ReadData(ULONG nFrame);

    BOOL    WriteData(void);
    BOOL    ReadData(void);
};

typedef CKsPin *            PCKsPin;

/*
typedef struct
{
    REFGUID     guidPropertySet;
    ULONGLONG   ullPropertySupportMaskGet;
    ULONGLONG   ullPropertySupportMaskSet;
} SUPPORTED_PROPERTIES, *SUPPORTED_PROPERTIES;
*/

// ----------------------------------------------------------------------------------
// CKsNode
//  This class wraps an irptarget and associated node id.  It simplifies property
//  calls on nodes.
// ----------------------------------------------------------------------------------
class CKsNode
{
public:
    CKsNode(CKsIrpTarget* pTarget, ULONG nID);
    CKsNode(CKsIrpTarget* pTarget, CKsNode* pksnCopy);

    CKsIrpTarget*   m_pIrpTarget;
    ULONG           m_nId;

    ULONGLONG       m_ullSuptdPropsMaskGet;
    ULONGLONG       m_ullSuptdPropsMaskSet;

    GUID            m_guidType;

    BOOL
    GetNodePropertyChannel
    (
        IN  ULONG               nChannel,
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PVOID               pvDest,
        OUT ULONG               cbDest
    );

    BOOL
    GetNodePropertyMulti
    (
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem    OPTIONAL
    );

    BOOL
    SetNodePropertyChannel
    (
        IN  ULONG               nChannel,
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PVOID               pvDest,
        OUT ULONG               cbDest
    );

    BOOL
    SetNodePropertyMulti
    (
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem    OPTIONAL
    );
};

typedef CKsNode *               PCKsNode;

// forward Ho
class CPCMAudioPin;

// ----------------------------------------------------------------------------------
// CTopologyFilter
// ----------------------------------------------------------------------------------
class CTopologyFilter : public CKsFilter
{
public:
    CTopologyFilter
	(
		LPCTSTR  pszName,
		LPCTSTR  pszFriendlyName,
		LPCTSTR  pszCLSID,
		LPCTSTR  pszService,
		LPCTSTR  pszBinary
    );
};

typedef CTopologyFilter *       PCTopologyFilter;

// ----------------------------------------------------------------------------------
// CPCMAudioFilter
// ----------------------------------------------------------------------------------
class CPCMAudioFilter : public CKsFilter
{
public:
    __stdcall CPCMAudioFilter
	(
		LPCTSTR  pszName,
		LPCTSTR  pszFriendlyName,
		LPCTSTR  pszCLSID,
		LPCTSTR  pszService,
		LPCTSTR  pszBinary
    );

    virtual BOOL    EnumeratePins(void);
    CPCMAudioPin*   __stdcall FindViablePin(CList<CKsPin>* pList, WAVEFORMATEX* pwfx);
    BOOL            CreateCapturePin(WAVEFORMATEX* pwfx, DWORD dwBufferSeconds, DWORD dwAlignment = 0);
    BOOL            CreateRenderPin(WAVEFORMATEX* pwfx, DWORD dwBufferSeconds, DWORD dwAlignment = 0);
};

typedef CPCMAudioFilter *       PCPCMAudioFilter;

// ----------------------------------------------------------------------------------
// CSysAudioDeviceFilter
// ----------------------------------------------------------------------------------
class CSysAudioDeviceFilter : public CKsFilter
{
public:
    ULONG   m_DeviceID;

    CSysAudioDeviceFilter
	(
		LPCTSTR  pszName,
		LPCTSTR  pszFriendlyName,
		LPCTSTR  pszCLSID,
		LPCTSTR  pszService,
		LPCTSTR  pszBinary
    );

    CSysAudioDeviceFilter
	(
		LPCTSTR  pszName,
		LPCTSTR  pszFriendlyName
    );
};

typedef CSysAudioDeviceFilter * PCSysAudioDeviceFilter;

// ----------------------------------------------------------------------------------
// CSysAudio
// ----------------------------------------------------------------------------------
class CSysAudio : public CKsFilter
{
public:
    CList <CSysAudioDeviceFilter>   m_listDevices;

    ULONG                           m_ulDeviceCount;
    
    CSysAudio
	(
		LPCTSTR  pszName,
		LPCTSTR  pszFriendlyName,
		LPCTSTR  pszCLSID,
		LPCTSTR  pszService,
		LPCTSTR  pszBinary
    );
    virtual ~CSysAudio();

    virtual void    DestroyLists(void);
    virtual BOOL    EnumeratePins(void);

    BOOL
    GetDevicePropertySimple
    (
        IN  ULONG               ulDeviceId,
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PVOID               pvDest,
        OUT ULONG               cbDest
    );
    BOOL
    SetDevicePropertySimple
    (
        IN  ULONG               ulDeviceId,
        IN  REFGUID             guidPropertySet,
        IN  ULONG               nProperty,
        OUT PVOID               pvDest,
        OUT ULONG               cbDest
    );
};

typedef CSysAudio * PCSysAudio;

// ------------------------------------------------------------------------------
// the following FMT_XXX flags are used to simplify the caps reported by KSDATARANGE_AUDIO
// They are OR'd and stored in CPCMAudioPin::m_dwWaveFormatMask, which is set in the call 
// to KslEnumFilters if ePCMAudio is specified for the filter type
#define FMT_8BIT           0x00000001
#define FMT_16BIT          0x00000002
#define FMT_20BIT          0x00000004
#define FMT_24BIT          0x00000008
#define FMT_32BIT          0x00000010
#define FMTM_BITDEPTH      0x000000FF

#define FMT_8000HZ         0x00000100
#define FMT_11025HZ        0x00000200
#define FMT_16000HZ        0x00000400
#define FMT_22050HZ        0x00000800
#define FMT_32000HZ        0x00001000
#define FMT_44100HZ        0x00002000
#define FMT_48000HZ        0x00004000
#define FMT_96000HZ        0x00008000
#define FMTM_SAMPLERATE    0x0000FF00

#define FMT_MONO           0x00010000
#define FMT_STEREO         0x00020000
#define FMT_QUAD           0x00040000
#define FMT_SURROUND       0x00080000
#define FMT_5_1            0x00100000
#define FMT_7_1            0x00200000
#define FMTM_SPEAKCONFIG   0x00FF0000

// ----------------------------------------------------------------------------------
// CPCMAudioPin
// ----------------------------------------------------------------------------------
class CPCMAudioPin : public CKsPin
{
public:
    KSAUDIO_POSITION    m_nPosition;
    DWORD               m_dwWaveFormatMask;       // ORed WAVEFORMAT_XXX flags above
	DWORD				m_dwMinSampleFreq;
	DWORD				m_dwMaxSampleFreq;

    CPCMAudioPin(CKsFilter* pFilter, ULONG nId);
    CPCMAudioPin(CKsPin* pPin);     // copy constructor

    BOOL    Initialize(CKsFilter* pFilter, ULONG nID, KSPIN_DATAFLOW nDataFlow, DWORD dwFormatFlags);
    BOOL    SetFormat(WAVEFORMATEX* pwfx);
    BOOL    CreateDataBuffer(DWORD dwBufferSeconds, DWORD dwAlignment = 0);
    BOOL    CreateDataBufferMS(DWORD dwBufferMilliSeconds, DWORD dwAlignment = 0);

    BOOL    GetPosition(KSAUDIO_POSITION* Pos);
    BOOL    SetPosition(KSAUDIO_POSITION* Pos);
};

typedef CPCMAudioPin *          PCPCMAudioPin;

// ----------------------------------------------------------------------------------
// CMidiMusicPin
// ----------------------------------------------------------------------------------
class CMidiMusicPin : public CKsPin
{
public:
    CMidiMusicPin(CKsFilter* pFilter, ULONG nId);
    virtual ~CMidiMusicPin(void);

    BOOL    Initialize(CKsFilter* pFilter, ULONG nID, KSPIN_DATAFLOW nDataFlow, DWORD dwFormatFlags);
    BOOL    CreateDataBuffer(DWORD dwBufferSeconds);
};

typedef CMidiMusicPin *         PCMiniMusicPin;

// ----------------------------------------------------------------------------------
// CDirectMusicPin
// ----------------------------------------------------------------------------------
class CDirectMusicPin : public CKsPin
{
public:
    CDirectMusicPin(CKsFilter* pFilter, ULONG nId);

    BOOL    Initialize(CKsFilter* pFilter, ULONG nID, KSPIN_DATAFLOW nDataFlow, DWORD dwFormatFlags);
    BOOL    CreateDataBuffer(DWORD dwBufferSeconds);
};

typedef CDirectMusicPin *       PCDirectMusicPin;

// ==================================================================================
// these are the APIs exposed by DirectKs
// ==================================================================================

// ------------------------------------------------------------------------------
// Initializes SetupAPI and KsUser
// Call this before KslEnumFilters
// ------------------------------------------------------------------------------
BOOL
KslInitKsLib();

// ------------------------------------------------------------------------------
// Closes SetupAPI and KsUser
// Call when you are done using DirectKs/KsLib
// ------------------------------------------------------------------------------
BOOL
KslCloseKsLib();

// ------------------------------------------------------------------------------
// KslEnumFilters
//   Enumerates available KS filters of type <eFilterType>
// 
//   Also instantiates, and enumerates pins and nodes on each filter if specified.
//   You can instantiate the filter later by calling Instantiate method on the filter.
//   You can also enumerate pins and nodes later, but it is difficult (you need to 
// call the appropriate KSPROPSETID_Pin and KSPROPSETID_Topology properties).  It 
// is therefore, highly recommended that you use this API for that.
// ------------------------------------------------------------------------------
BOOL
KslEnumFilters
(   
    IN      CList<CKsFilter>*   plistFilters,       // pass a ptr to a CList to be populated
    IN      ETechnology         eFilterType,        // populate the list with filters of this type.  Implies that some filters are screened.
    IN OUT  LPGUID*             argpguidCategories, // pass in an array of LPGUIDs that specify the KSCATEGORYs to look for.  Members of this array are ORed.
    IN      ULONG               cguidCategories,    // number of elements in argpguidCategories
    IN      BOOL                fNeedPins = TRUE,   // TRUE -> each CKsFilter::m_listPins will be populated
    IN      BOOL                fNeedNodes = TRUE,  // TRUE -> each CKsFilter::m_listNodes will be populated
    IN      BOOL                fInstantiate = TRUE // TRUE -> filter will be left instantiated
);

// ------------------------------------------------------------------------------
// KslLogEnumResults
// Displays a list of filters using the registered ILog interface (specified by KslRegisterLog)
// ------------------------------------------------------------------------------
void
KslLogEnumResults
(
    CList<CKsFilter>*   plistFilters,       // list to display
    CKsFilter*          pFilterDefault      // highlight this filter
);

// ------------------------------------------------------------------------------
// KslregisterLog
// Specify the ILog-derived interface to use for KslLogenumResuls and in error messages.
// ------------------------------------------------------------------------------
void
KslRegisterLog(ILog* iLog);

// ------------------------------------------------------------------------------
// SyncIoctl
// DeviceIoControl wrapped with OVERLAPPED structure and logging
// ------------------------------------------------------------------------------
BOOL
SyncIoctl
(
    IN      HANDLE  handle,
    IN      ULONG   ulIoctl,
    IN      PVOID   pvInBuffer,
    IN      ULONG   ulInSize,
    OUT     PVOID   pvOutBuffer = NULL,
    IN      ULONG   ulOutSize = 0,
    OUT     PULONG  pulBytesReturned = NULL
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\DirectKS\kslibp.h ===
// ------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1996 - 2000.  All rights reserved.
//
// File Name:
//
//	kslibp.h
//
// Abstract:
//
//  private header for kslib project
//
// @@BEGIN_MSINTERNAL
//      mitchr      08/08/1998  - created
//      jwexler     05/10/2000 - moved out of kslib.cpp
// @@END_MSINTERNAL
// -------------------------------------------------------------------------------


#ifndef _KSLIBP_H
#define _KSLIBP_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include "ilog.h"
#include "directks.h"
//#include "debug.h"

//
// macros
//
#define SafeCloseHandle(h)  if (IsValidHandle((h))) CloseHandle((h));    \
                            h = INVALID_HANDLE_VALUE
#define SafeLocalFree(p)    if ((p)) LocalFree((p));  \
                            p = NULL
#define IsValidHandle(h)    (!(((h) == NULL) || ((h) == INVALID_HANDLE_VALUE)))
#define LOG                 s_iLog->Log                         

//
// because we can't include both windows.h and wdm.h
//
#define CTL_CODE(DeviceType, Function, Method, Access)  \
        (((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method))
        
#define FILE_DEVICE_KS         0x0000002f
#define METHOD_NEITHER                  3

#define FILE_ANY_ACCESS            0x0000
#define FILE_READ_ACCESS           0x0001    // file & pipe
#define FILE_WRITE_ACCESS          0x0002    // file & pipe

inline BOOL
IsEqualGUIDAligned(GUID guid1, GUID guid2)
{
    return ((*(PLONGLONG)(&guid1) == *(PLONGLONG)(&guid2)) && (*((PLONGLONG)(&guid1) + 1) == *((PLONGLONG)(&guid2) + 1)));
}
//
// SetupAPI, KS function typedefs
//
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;

typedef	HDEVINFO
(WINAPI *GETCLASSDEVS)
(
    IN CONST GUID *ClassGuid,  OPTIONAL
    IN PCTSTR      Enumerator, OPTIONAL
    IN HWND        hwndParent, OPTIONAL
    IN DWORD       Flags
);

typedef BOOL
(WINAPI *ENUMDEVICEINTERFACES)
(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,     OPTIONAL
    IN  CONST GUID                *InterfaceClassGuid,
    IN  DWORD                      MemberIndex,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData
);

typedef BOOL
(WINAPI *ENUMDEVICEINFO)
(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  DWORD                      MemberIndex,
    OUT PSP_DEVINFO_DATA           DeviceInfoData
);

typedef BOOL
(WINAPI *GETDEVICEINTERFACEDETAIL)
(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
#ifdef UNICODE
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_W DeviceInterfaceDetailData,     OPTIONAL
#else
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,     OPTIONAL
#endif
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
);

typedef BOOL
(WINAPI *GETDEVICEREGISTRYPROPERTY)
(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
);

typedef HKEY
(WINAPI *OPENDEVICEINTERFACEREGKEY)
(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved,
    IN REGSAM                    samDesired
);

typedef BOOL
(WINAPI *GETDEVICEINTERFACEALIAS)
(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData,
    IN  CONST GUID                *AliasInterfaceClassGuid,
    OUT PSP_DEVICE_INTERFACE_DATA  AliasDeviceInterfaceData
);

typedef BOOL
(WINAPI *DESTROYDEVICEINFOLIST)
(
    IN HDEVINFO DeviceInfoSet
);

typedef DWORD
(WINAPI *KSCREATEPIN)
(
    HANDLE, 
    PKSPIN_CONNECT, 
    DWORD, 
    PHANDLE
);

//
// kslib function prototypes
//
ULONG
CalculateFrameSize
(
    ULONG   nFrame,
    ULONG   cFrames,
    ULONG   cbBuffer
);

//
// externs
//
extern ILog                         *s_iLog;
extern GETCLASSDEVS                 fxnSetupDiGetClassDevs;
extern ENUMDEVICEINTERFACES         fxnSetupDiEnumDeviceInterfaces;
extern ENUMDEVICEINFO               fxnSetupDiEnumDeviceInfo;
extern GETDEVICEINTERFACEDETAIL     fxnSetupDiGetDeviceInterfaceDetail;
extern GETDEVICEREGISTRYPROPERTY    fxnSetupDiGetDeviceRegistryProperty;
extern OPENDEVICEINTERFACEREGKEY    fxnSetupDiOpenDeviceInterfaceRegKey;
extern GETDEVICEINTERFACEALIAS      fxnSetupDiGetDeviceInterfaceAlias;
extern DESTROYDEVICEINFOLIST        fxnSetupDiDestroyDeviceInfoList;
extern KSCREATEPIN                  fxnKsCreatePin;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\DirectKS\kslib.cpp ===
// ------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1996 - 2000.  All rights reserved.
//
// File Name:
//
//  kslib.cpp
//
// Abstract:
//
//  Implementation for exported functions and helpers
//      Exports:
//          KslRegisterLog
//          KslEnumFilters
//          KslInitKsLib
//          KslCloseKsLib
//
// -------------------------------------------------------------------------------

#include "stdafx.h"
#include "kslibp.h"

//
// statics
//
static LogStub s_LogStub;

//
// globals
//
HMODULE g_hSetupDLL     = NULL;
HMODULE g_hKsUserDLL    = NULL;
ILog*   s_iLog          = &s_LogStub;

//
// fxn Pointers
//
// setupapi functions
GETCLASSDEVS                fxnSetupDiGetClassDevs;
ENUMDEVICEINTERFACES        fxnSetupDiEnumDeviceInterfaces;
ENUMDEVICEINFO              fxnSetupDiEnumDeviceInfo;
GETDEVICEINTERFACEDETAIL    fxnSetupDiGetDeviceInterfaceDetail;
GETDEVICEREGISTRYPROPERTY   fxnSetupDiGetDeviceRegistryProperty;
OPENDEVICEINTERFACEREGKEY   fxnSetupDiOpenDeviceInterfaceRegKey;
GETDEVICEINTERFACEALIAS     fxnSetupDiGetDeviceInterfaceAlias;
DESTROYDEVICEINFOLIST       fxnSetupDiDestroyDeviceInfoList;

// ksuser functions
KSCREATEPIN                 fxnKsCreatePin;

//
// kslib functions
//
inline BOOL
IsEventSignaled(HANDLE hEvent)
{
    return (WAIT_OBJECT_0 == WaitForSingleObject((hEvent), 0));
}

// ------------------------------------------------------------------------

void 
PrepKSPinConnect
(
    PKSPIN_CONNECT_WFX  pConnect,
    DWORD               dwSampleRate, 
    DWORD               nChannels, 
    DWORD               nBits,
    BOOL                fLooped
)
{
    // set up pin connection parameters
    pConnect->Connect.PinToHandle = NULL;

    pConnect->Connect.Interface.Set = KSINTERFACESETID_Standard;
    pConnect->Connect.Interface.Id = fLooped ? KSINTERFACE_STANDARD_LOOPED_STREAMING : KSINTERFACE_STANDARD_STREAMING;
    pConnect->Connect.Interface.Flags = 0;

    pConnect->Connect.Medium.Set = KSMEDIUMSETID_Standard;
    pConnect->Connect.Medium.Id = KSMEDIUM_STANDARD_DEVIO;
    pConnect->Connect.Medium.Flags = 0;

    pConnect->Connect.Priority.PriorityClass = KSPRIORITY_NORMAL;
    pConnect->Connect.Priority.PrioritySubClass = 1;

    pConnect->Format.DataFormat.FormatSize = sizeof( KSDATAFORMAT_WAVEFORMATEX );//sizeof(pConnect->Format);
    pConnect->Format.DataFormat.Flags = 0;
    pConnect->Format.DataFormat.Reserved = 0;
    pConnect->Format.DataFormat.SampleSize = (USHORT)(nChannels*nBits/8);
    pConnect->Format.DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
    pConnect->Format.DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
    pConnect->Format.DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;

    pConnect->Format.WaveFormatEx.wFormatTag = WAVE_FORMAT_PCM;
    pConnect->Format.WaveFormatEx.nChannels = (USHORT)nChannels;
    pConnect->Format.WaveFormatEx.nSamplesPerSec = dwSampleRate;
    pConnect->Format.WaveFormatEx.nAvgBytesPerSec = dwSampleRate*nChannels*nBits/8;
    pConnect->Format.WaveFormatEx.wBitsPerSample = (USHORT)nBits;
    pConnect->Format.WaveFormatEx.nBlockAlign = (USHORT)(nChannels*nBits/8);
    pConnect->Format.WaveFormatEx.cbSize = 0;
}


// ------------------------------------------------------------------------
void
KslRegisterLog
(
    ILog* iLog
)
{
    if (iLog)
        s_iLog = iLog;
}

// ------------------------------------------------------------------------
BOOL
SyncIoctl
(
    IN      HANDLE  handle,
    IN      ULONG   ulIoctl,
    IN      PVOID   pvInBuffer,
    IN      ULONG   ulInSize,
    OUT     PVOID   pvOutBuffer,
    IN      ULONG   ulOutSize,
    OUT     PULONG  pulBytesReturned
)
{
    OVERLAPPED  overlapped;
    BOOL        fRes = IsValidHandle(handle);
    ULONG       ulBytesReturned;

    if (!pulBytesReturned)
    {
        pulBytesReturned = &ulBytesReturned;
    }

    if (fRes)
    {
        memset(&overlapped,0,sizeof(overlapped));
        overlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!overlapped.hEvent)
        {
            LOG(eWarn2, "SyncIoctl: failed to create event\n");
            return FALSE;
        }

        fRes = 
            DeviceIoControl
            (
                handle, 
                ulIoctl, 
                pvInBuffer, 
                ulInSize, 
                pvOutBuffer, 
                ulOutSize, 
                pulBytesReturned, 
                &overlapped
            );

        if (!fRes)
        {
            DWORD dwError = GetLastError();

            if (ERROR_IO_PENDING == dwError) 
            {
                // put the 'sync' in 'syncioctl'
                fRes = (WAIT_OBJECT_0 == ::WaitForSingleObject(overlapped.hEvent, INFINITE));
            }
            else    // if this was a property call and the buffer size was zero, then we were 
            if      //  really asking for the size of buffer needed.
            (
                ((ERROR_INSUFFICIENT_BUFFER == dwError) || (ERROR_MORE_DATA == dwError)) && 
                (ulIoctl == IOCTL_KS_PROPERTY) && 
                (ulOutSize == 0)
            )
            {
                fRes = TRUE;
            }
#ifdef SUPERBLAB
            else
            {
                LOG(eBlab1, "DeviceIoControl failed.  IOCTL = %d", ulIoctl);
                s_iLog->LogStdErrorString(dwError);
            }
#endif
        }

        if (!fRes)
            *pulBytesReturned = 0;

        SafeCloseHandle(overlapped.hEvent);
    }

    return fRes;
}

#ifdef UNICODE
#define lstrtok     wcstok
#else
#define lstrtok     strtok
#endif

// --------------------------------------------------------------------------------------------------
// BinaryFromService
//  Given szDriver returns the binary name. szDriver is relative path to the registry.
// --------------------------------------------------------------------------------------------------
BOOL
BinaryFromDriver
(
    LPTSTR  szDriver,
    LPTSTR  szBinary
)
{
    BOOL                    fRes;
    char                    szRegKey[MAX_PATH];
    DWORD                   dwType = 0;
    DWORD                   dwDataSize;
    HKEY                    hKeyDriver = NULL;
    LONG                    lResult = ERROR_SUCCESS;

    fRes = (szDriver && szBinary && szDriver[0] != 0);
    
    // Find the OS.
    if (fRes)
    {
        OSVERSIONINFO osVersionInfo;

        ZeroMemory(&osVersionInfo, sizeof(osVersionInfo));
        
        osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
        GetVersionEx(&osVersionInfo);

        if ( (VER_PLATFORM_WIN32_WINDOWS == osVersionInfo.dwPlatformId) &&
             (0 < osVersionInfo.dwMinorVersion) )
        {
            strcpy(szRegKey, "SYSTEM\\CurrentControlSet\\Services\\Class\\");
        }
        else
        {
            strcpy(szRegKey, "SYSTEM\\CurrentControlSet\\Control\\Class\\");
        }

        strcat(szRegKey, (LPSTR) szDriver);
    }
    
    // Get other driver properties.
    if (fRes)
    {
        dwDataSize = MAX_PATH; 
        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               szRegKey,
                               0,
                               KEY_READ,
                               &hKeyDriver);
        if (ERROR_SUCCESS != lResult)
        {
            LOG(eWarn2, "Cannot open registry key %s", szRegKey); 
            fRes = FALSE;
        }
    }

    if (fRes)
    {
        dwDataSize = MAX_PATH; 
        lResult = RegQueryValueEx(hKeyDriver,
                                  "Driver",
                                  0,
                                  &dwType,
                                  (PBYTE) szBinary,
                                  &dwDataSize);
        if (ERROR_SUCCESS != lResult && ERROR_FILE_NOT_FOUND != lResult)
        {
            LOG(eWarn2, "Cannot read registry key Driver"); 
            fRes = FALSE;
        }
    }

    if (hKeyDriver)
    {
        RegCloseKey(hKeyDriver);
    }
    
    if (fRes)
    {
        CHAR    szPath[MAX_PATH];
        
        GetWindowsDirectory(szPath, MAX_PATH);
        lstrcat(szPath, "\\system32\\drivers\\");
        lstrcat(szPath, szBinary);

        strcpy(szBinary, szPath);
    }

    return fRes;
} // BinaryFromDriver

// ------------------------------------------------------------------------
// EnumFilters
//    Enumerate via the Setup APIs all filters of that are of type (all elements of) argpguidCategories.
// ------------------------------------------------------------------------
BOOL    
KslEnumFilters
(   
    CList<CKsFilter>*   plistFilters,
    ETechnology         eFilterType,
    LPGUID*             argpguidCategories,
    ULONG               cguidCategories,
    BOOL                fNeedPins,          // = TRUE // Enumerates devices for sysaudio.
    BOOL                fNeedNodes,         // = TRUE
    BOOL                fInstantiate        // = TRUE // Should we instantiate.
)
{
    BOOL        fRes = FALSE;
    HDEVINFO    hDevInfo = NULL;

    if (argpguidCategories && argpguidCategories[0] && !IsEqualGUIDAligned(GUID_NULL, *argpguidCategories[0]))
    {
        // Get a handle to the device set specified by the guid
        hDevInfo = 
            fxnSetupDiGetClassDevs
            (
                argpguidCategories[0], 
                NULL, 
                NULL, 
                DIGCF_PRESENT | DIGCF_DEVICEINTERFACE
            );

        fRes = IsValidHandle(hDevInfo);
        if (!fRes)
        {
            LOG(eWarn2, "No devices of class KSCATEGORY_AUDIO found");
        }
        else
        {
            // Loop through members of the set and get details for each
            SP_DEVICE_INTERFACE_DETAIL_DATA*    pDevInterfaceDetails;
            int iClassMember;
            for(iClassMember = 0;;iClassMember++)
            {
                DWORD                               cbInterfaceDetails;
                TCHAR                               szFriendlyName[MAX_PATH];
                TCHAR                               szCLSID[MAX_PATH];
                TCHAR                               szService[MAX_PATH];
                TCHAR                               szBinary[MAX_PATH];
                TCHAR                               szDriver[MAX_PATH];
                DWORD                               cbData = sizeof(szFriendlyName);
                DWORD                               dwType = REG_SZ;
                BOOL                                fRes;
                HKEY                                hKey;
                SP_DEVICE_INTERFACE_DATA            DID;
                SP_DEVICE_INTERFACE_DATA            DIDAlias;
                SP_DEVINFO_DATA                     DevInfoData;
                SP_DEVINFO_DATA                     DeviceInfo;

                szFriendlyName[0] = 0;
                szCLSID[0] = 0;
                szService[0] = 0;
                szBinary[0] = 0;
                szDriver[0] = 0;

                DID.cbSize = sizeof(DID);
                DID.Reserved = 0;
                DIDAlias.cbSize = sizeof(DIDAlias);
                DIDAlias.Reserved = 0;

                DevInfoData.cbSize = sizeof(DevInfoData);
                DevInfoData.Reserved = 0;

                DeviceInfo.cbSize = sizeof(DeviceInfo);
                DeviceInfo.Reserved = 0;

                fRes = 
                    fxnSetupDiEnumDeviceInterfaces
                    (
                        hDevInfo, 
                        NULL, 
                        argpguidCategories[0], 
                        iClassMember,
                        &DID
                    );

                if (!fRes)
                    break;

                fRes = 
                    fxnSetupDiEnumDeviceInfo
                    (
                        hDevInfo,
                        iClassMember,
                        &DeviceInfo
                    );

                // Get details for the device registered in this class
                cbInterfaceDetails = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + MAX_PATH * sizeof(WCHAR);
                pDevInterfaceDetails = 
                    (SP_DEVICE_INTERFACE_DETAIL_DATA*)LocalAlloc(LPTR, cbInterfaceDetails);
                if (!pDevInterfaceDetails)
                {
                    LOG(eWarn2, "Failed to allocate SP_DEVICE_INTERFACE_DETAIL_DATA structure");
                    break;
                }

                pDevInterfaceDetails->cbSize = sizeof(*pDevInterfaceDetails);

                fRes = 
                    fxnSetupDiGetDeviceInterfaceDetail
                    (
                        hDevInfo, 
                        &DID, 
                        pDevInterfaceDetails, 
                        cbInterfaceDetails,
                        NULL, 
                        &DevInfoData
                    );

                if (fRes)
                {
                    // Get more details about the device
                    hKey = 
                        fxnSetupDiOpenDeviceInterfaceRegKey
                        (
                            hDevInfo, 
                            &DID, 
                            0, 
                            KEY_READ
                        );

                    if (IsValidHandle(hKey)) 
                    {
                        // Get the friendly name of the device
                        RegQueryValueEx
                        (
                            hKey, 
                            TEXT("FriendlyName"), 
                            0, 
                            &dwType,
                            (PBYTE)szFriendlyName, 
                            &cbData
                        );

                        // Get the friendly name of the device
                        RegQueryValueEx
                        (
                            hKey, 
                            TEXT("CLSID"), 
                            0, 
                            &dwType,
                            (PBYTE)szCLSID, 
                            &cbData
                        );

                        // Get the name of the service
                        cbData = MAX_PATH;
                        fxnSetupDiGetDeviceRegistryProperty
                        (
                            hDevInfo, 
                            &DevInfoData, 
                            SPDRP_SERVICE, 
                            NULL, 
                            (PBYTE)szService, 
                            cbData, 
                            &cbData
                        );

                        // Get the name of the service
                        cbData = MAX_PATH;
                        fxnSetupDiGetDeviceRegistryProperty
                        (
                            hDevInfo, 
                            &DevInfoData, 
                            SPDRP_DRIVER, 
                            NULL, 
                            (PBYTE)szDriver, 
                            cbData, 
                            &cbData
                        );

                        BinaryFromDriver(szDriver, szBinary);

                        RegCloseKey(hKey);
                    }

                    // 
                    // check additional category guids which may (or may not) have been supplied
                    //
                    for(ULONG nguidCategory = 1; nguidCategory < cguidCategories && fRes; nguidCategory++)
                    {
                        fRes = 
                            fxnSetupDiGetDeviceInterfaceAlias
                            (
                                hDevInfo,
                                &DID,
                                argpguidCategories[nguidCategory],
                                &DIDAlias
                            );

                        if (!fRes && s_iLog)  LOG(eWarn3, "Failed to get requested DeviceInterfaceAlias");

                        //
                        // Check if the this interface alias is enabled.
                        //
                        if (fRes)
                        {
                            if (!DIDAlias.Flags || (DIDAlias.Flags & SPINT_REMOVED))
                            {
                                fRes = FALSE;
                                if (s_iLog)
                                {
                                    LOG(eWarn3, "DeviceInterfaceAlias disabled.");
                                }
                            }
                        }
                    }

                    if (fRes)
                    {
                        CKsFilter* pnewFilter = NULL;

                        switch(eFilterType)
                        {
                            case eUnknown:
                                pnewFilter = new CKsFilter(pDevInterfaceDetails->DevicePath, szFriendlyName, szCLSID, szService, szBinary);
                                break;

                            case eTopology:
                                pnewFilter = new CTopologyFilter(pDevInterfaceDetails->DevicePath, szFriendlyName, szCLSID, szService, szBinary);
                                break;

                            case ePCMAudio:
                                pnewFilter = new CPCMAudioFilter(pDevInterfaceDetails->DevicePath, szFriendlyName, szCLSID, szService, szBinary);
                                break;

                            case eSysAudioDevice:
                                pnewFilter = new CSysAudioDeviceFilter(pDevInterfaceDetails->DevicePath, szFriendlyName, szCLSID, szService, szBinary);
                                break;

                            case eSysAudio:
                                pnewFilter = new CSysAudio(pDevInterfaceDetails->DevicePath, szFriendlyName, szCLSID, szService, szBinary);
                                break;

/*
                            case eMidi:
                                pnewFilter = new CPCMAudioFilter(pDevInterfaceDetails->DevicePath, szFriendlyName, szCLSID);
                                break;

                            case eDMusic:
                                pnewFilter = new CDMusicFilter(pDevInterfaceDetails->DevicePath, szFriendlyName, szCLSID);
                                break;
*/
                            default:
                                pnewFilter = new CKsFilter(pDevInterfaceDetails->DevicePath, szFriendlyName, szCLSID, szService, szBinary);
                                break;
                        }
                        
                        if (pnewFilter)
                        {
                            BOOL fResParse = TRUE;

                            // Device Instance Handle (DEVNODE) might be very useful
                            // for several purposes.
                            pnewFilter->m_dwDevInst = DevInfoData.DevInst;

                            if (fNeedNodes || fNeedPins || fInstantiate)
                            {
                                fResParse = pnewFilter->Instantiate();

                                if (fNeedNodes && fResParse)
                                    fResParse = pnewFilter->EnumerateNodes();
                            
                                // This enumerates Devices for SysAudio devices
                                if (fNeedPins && fResParse)
                                    fResParse = pnewFilter->EnumeratePins();
                            }

                            if (fResParse)
                                plistFilters->AddTail(pnewFilter);
                            else
                                delete pnewFilter;
                        }
                        else
                        {
                            LOG(
                                eFatalError, 
                                "Failed to create CIrpTarget for %s", 
                                pDevInterfaceDetails->DevicePath);
                        }
                    }
                }

                SafeLocalFree(pDevInterfaceDetails);
            } // for
        }
    }

    if (IsValidHandle(hDevInfo))
        fxnSetupDiDestroyDeviceInfoList(hDevInfo);

    return fRes;
} // KslEnumFilters

// ----------------------------------------------------------------------------------
// KslLogEnumResults
//  logs results of EnumFilters
// ----------------------------------------------------------------------------------
void
KslLogEnumResults
(
    CList<CKsFilter>*   plistFilters,
    CKsFilter*          pFilterDefault     // optional
)
{
    // log enum results
    LOG(eInfo2, "  Found %d viable filters:", plistFilters->GetCount());
    if (!plistFilters->IsEmpty())
    {
        CNode<CKsFilter>* pNodeFilter;
        CNode<CKsPin>*    pNodePin;            
        
        pNodeFilter = plistFilters->GetHead();
        while(pNodeFilter)
        {
            CKsFilter* pFilter = pNodeFilter->pData;
            pNodeFilter = plistFilters->GetNext(pNodeFilter);

            ASSERT(pFilter);
            if (pFilter == pFilterDefault)
                LOG(eInfo2, "*     %s", pFilter->m_szFilterName);
            else
                LOG(eInfo2, "      %s", pFilter->m_szFilterName);

            LOG(eInfo2, "    Viable Render Sink Pins:");
            pNodePin = pFilter->m_listRenderSinkPins.GetHead();
            while(pNodePin)
            {
                CKsPin* pPin = pNodePin->pData;
                pNodePin = pFilter->m_listRenderSinkPins.GetNext(pNodePin);

                if (pFilterDefault && pPin == pFilterDefault->m_pRenderPin)
                    LOG(eInfo2, "*     #%d", pPin->m_nId);
                else
                    LOG(eInfo2, "      #%d", pPin->m_nId);
            }

            LOG(eInfo2, "    Viable Render Source Pins:");
            pNodePin = pFilter->m_listRenderSourcePins.GetHead();
            while(pNodePin)
            {
                CKsPin* pPin = pNodePin->pData;
                pNodePin = pFilter->m_listRenderSourcePins.GetNext(pNodePin);

                if (pFilterDefault && pPin == pFilterDefault->m_pRenderPin)
                    LOG(eInfo2, "*     #%d", pPin->m_nId);
                else
                    LOG(eInfo2, "      #%d", pPin->m_nId);
            }
            
            LOG(eInfo2, "    Viable Capture Pins:");
            pNodePin = pFilter->m_listCaptureSinkPins.GetHead();
            while(pNodePin)
            {
                CKsPin* pPin = pNodePin->pData;
                pNodePin = pFilter->m_listCaptureSinkPins.GetNext(pNodePin);

                if (pFilterDefault && pPin == pFilterDefault->m_pCapturePin)
                    LOG(eInfo2, "*     #%d", pPin->m_nId);
                else
                    LOG(eInfo2, "      #%d", pPin->m_nId);
            }

            LOG(eInfo2, "    Viable Capture Pins:");
            pNodePin = pFilter->m_listCaptureSourcePins.GetHead();
            while(pNodePin)
            {
                CKsPin* pPin = pNodePin->pData;
                pNodePin = pFilter->m_listCaptureSourcePins.GetNext(pNodePin);

                if (pFilterDefault && pPin == pFilterDefault->m_pCapturePin)
                    LOG(eInfo2, "*     #%d", pPin->m_nId);
                else
                    LOG(eInfo2, "      #%d", pPin->m_nId);
            }
        }
    }

    LOG(eInfo2, "\n\n");
}

// ------------------------------------------------------------------------------
ULONG
CalculateFrameSize
(
    ULONG   nFrame,
    ULONG   cFrames,
    ULONG   cbBuffer
)
{
    if (cbBuffer % cFrames)
    {
        // if this is the last buffer, then pick up the remainder
        if (nFrame == (cFrames - 1))
        {
            return (cbBuffer % (cFrames - 1));
        }
        // otherwise, round down
        else
        {
            return (cbBuffer / (cFrames - 1));
        }

    }
    else
    {
        return (cbBuffer / cFrames);
    }
}
    
// ----------------------------------------------------------------------------------
// KslInitKsLib
//  Loads functions from SETUPAPI.dll
// ----------------------------------------------------------------------------------
BOOL
KslInitKsLib()
{
    BOOL fRes;

    g_hSetupDLL = LoadLibrary("setupapi.dll");
    g_hKsUserDLL = LoadLibrary("ksuser.dll");

    fRes = IsValidHandle(g_hSetupDLL) && IsValidHandle(g_hKsUserDLL);

    if (fRes)
    {
#ifdef UNICODE
        fxnSetupDiGetClassDevs = (GETCLASSDEVS)
            GetProcAddress(g_hSetupDLL, "SetupDiGetClassDevsW");

        fxnSetupDiGetDeviceInterfaceDetail = (GETDEVICEINTERFACEDETAIL)
            GetProcAddress(g_hSetupDLL, "SetupDiGetDeviceInterfaceDetailW");

        fxnSetupDiGetDeviceRegistryProperty = (GETDEVICEREGISTRYPROPERTY)
            GetProcAddress(g_hSetupDLL, "SetupDiGetDeviceRegistryPropertyW");
#else
        fxnSetupDiGetClassDevs = (GETCLASSDEVS)
            GetProcAddress(g_hSetupDLL, "SetupDiGetClassDevsA");

        fxnSetupDiGetDeviceInterfaceDetail = (GETDEVICEINTERFACEDETAIL)
            GetProcAddress(g_hSetupDLL, "SetupDiGetDeviceInterfaceDetailA");

        fxnSetupDiGetDeviceRegistryProperty = (GETDEVICEREGISTRYPROPERTY)
            GetProcAddress(g_hSetupDLL, "SetupDiGetDeviceRegistryPropertyA");
#endif

        fxnSetupDiEnumDeviceInterfaces = (ENUMDEVICEINTERFACES)
            GetProcAddress(g_hSetupDLL, "SetupDiEnumDeviceInterfaces");

        fxnSetupDiEnumDeviceInfo = (ENUMDEVICEINFO)
            GetProcAddress(g_hSetupDLL, "SetupDiEnumDeviceInfo");

        fxnSetupDiOpenDeviceInterfaceRegKey = (OPENDEVICEINTERFACEREGKEY)
            GetProcAddress(g_hSetupDLL, "SetupDiOpenDeviceInterfaceRegKey");

        fxnSetupDiGetDeviceInterfaceAlias = (GETDEVICEINTERFACEALIAS)
            GetProcAddress(g_hSetupDLL, "SetupDiGetDeviceInterfaceAlias");

        fxnSetupDiDestroyDeviceInfoList = (DESTROYDEVICEINFOLIST)
            GetProcAddress(g_hSetupDLL, "SetupDiDestroyDeviceInfoList");

        fxnKsCreatePin = (KSCREATEPIN)
            GetProcAddress(g_hKsUserDLL, "KsCreatePin");

        fRes = 
            fxnSetupDiEnumDeviceInfo &&
            fxnSetupDiGetClassDevs &&
            fxnSetupDiGetDeviceInterfaceDetail &&
            fxnSetupDiGetDeviceRegistryProperty &&
            fxnSetupDiGetClassDevs &&
            fxnSetupDiGetDeviceInterfaceDetail &&
            fxnSetupDiGetDeviceRegistryProperty &&
            fxnSetupDiEnumDeviceInterfaces &&
            fxnSetupDiOpenDeviceInterfaceRegKey &&
            fxnSetupDiGetDeviceInterfaceAlias &&
            fxnSetupDiDestroyDeviceInfoList &&
            fxnKsCreatePin;
    }

    return fRes;
} // KslInitKsLib

// ----------------------------------------------------------------------------------
// KslCloseKsLib
//  Unloads
// ----------------------------------------------------------------------------------
BOOL
KslCloseKsLib()
{
    if (g_hSetupDLL)
        FreeLibrary(g_hSetupDLL);

    if (g_hKsUserDLL)
        FreeLibrary(g_hKsUserDLL);

    return TRUE;
} // KslCloseKsLib
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\DirectKS\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\DirectKS\ksnode.cpp ===
//==============================================================================
// Copyright (c) 2000 Microsoft Corporation.  All rights reserved.
//
// Module Name:
//	ksnode.cpp
//
// Abstract:
//  Class implementation of CKsNode.
//
//==============================================================================

#include "stdafx.h"
#include "kslibp.h"

// ------------------------------------------------------------------------
// CKsNode::CKsNode
//      copy constructor
// ------------------------------------------------------------------------
CKsNode::CKsNode
(
    CKsIrpTarget*   pIrpTarget,
    CKsNode*        pksnCopy
) : m_pIrpTarget(pIrpTarget), 
    m_ullSuptdPropsMaskGet(0x0000000000000000),
    m_ullSuptdPropsMaskSet(0x0000000000000000)
{
    if (pksnCopy)
    {
        m_nId = pksnCopy->m_nId;
    }
}

// ------------------------------------------------------------------------
// CKsNode::CKsNode
//      constructor
// ------------------------------------------------------------------------
CKsNode::CKsNode
(
    CKsIrpTarget*   pIrpTarget,
    ULONG           nID
) : m_pIrpTarget(pIrpTarget), 
    m_nId(nID), 
    m_ullSuptdPropsMaskGet(0x0000000000000000),
    m_ullSuptdPropsMaskSet(0x0000000000000000)
{
    return;    
}

// ----------------------------------------------------------------------------------
// CKsNode::GetNodePropertyChannel
//  Get simple node property
// ----------------------------------------------------------------------------------
BOOL
CKsNode::GetNodePropertyChannel
(
    IN  ULONG   nChannel,
    IN  REFGUID guidPropertyGet,
    IN  ULONG   nProperty,
    OUT PVOID   pvValue,
    OUT ULONG   cbValue
)
{
    ASSERT(m_pIrpTarget);

    return 
        m_pIrpTarget->GetNodePropertyChannel
        (
            m_nId,
            nChannel,
            guidPropertyGet,
            nProperty,
            pvValue,
            cbValue
        );
}

// ----------------------------------------------------------------------------------
// CKsNode::GetNodePropertyMulti
//  Get the value of a multi-type KSPROPERTY_Node property
// ----------------------------------------------------------------------------------
BOOL
CKsNode::GetNodePropertyMulti
(
    IN  REFGUID             guidPropertyGet,
    IN  ULONG               nProperty,
    OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem
)
{
    ASSERT(m_pIrpTarget);

    return 
        m_pIrpTarget->GetNodePropertyMulti
        (
            m_nId,
            guidPropertyGet,
            nProperty,
            ppKsMultipleItem
        );
}

// ----------------------------------------------------------------------------------
// CKsNode::SetNodePropertyChannel
//  set simple node property
// ----------------------------------------------------------------------------------
BOOL
CKsNode::SetNodePropertyChannel
(
    IN  ULONG   nChannel,
    IN  REFGUID guidPropertySet,
    IN  ULONG   nProperty,
    OUT PVOID   pvValue,
    OUT ULONG   cbValue
)
{
    ASSERT(m_pIrpTarget);

    return 
        m_pIrpTarget->SetNodePropertyChannel
        (
            m_nId,
            nChannel,
            guidPropertySet,
            nProperty,
            pvValue,
            cbValue
        );
}

// ----------------------------------------------------------------------------------
// CKsNode::SetNodePropertyMulti
//  Get the value of a multi-type KSPROPERTY_Node property
// ----------------------------------------------------------------------------------
BOOL
CKsNode::SetNodePropertyMulti
(
    IN  REFGUID             guidPropertySet,
    IN  ULONG               nProperty,
    OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem
)
{
    ASSERT(m_pIrpTarget);

    return 
        m_pIrpTarget->SetNodePropertyMulti
        (
            m_nId,
            guidPropertySet,
            nProperty,
            ppKsMultipleItem
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\DirectKS\ksirptgt.cpp ===
// ------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1996 - 2000.  All rights reserved.
//
// File Name:
//	ksirptgt.cpp
//
// Abstract:
//  Class implementation of CKsIrpTarget.
//
// -------------------------------------------------------------------------------

#include "stdafx.h"
#include "kslibp.h"

// ----------------------------------------------------------------------------------
// CKsIrpTarget::GetPropertySimple
//  Get the value of a simple (non-multi) property
// ----------------------------------------------------------------------------------
BOOL
CKsIrpTarget::GetPropertySimple
(
    IN  REFGUID guidPropertySet,
    IN  ULONG   nProperty,
    OUT PVOID   pvValue,
    OUT ULONG   cbValue
)
{
    ULONG       ulReturned = 0;
    KSPROPERTY  ksProperty;

    ksProperty.Set    = guidPropertySet;    //KSPROPSETID_Topology;
    ksProperty.Id     = nProperty;          //KSPROPERTY_TOPOLOGY_NODES;
    ksProperty.Flags  = KSPROPERTY_TYPE_GET;

    return 
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &ksProperty,
            sizeof(KSPROPERTY),
            pvValue,
            cbValue,
            &ulReturned
        );
}

// ----------------------------------------------------------------------------------
// CKsIrpTarget::GetPropertyMulti
// ----------------------------------------------------------------------------------
BOOL
CKsIrpTarget::GetPropertyMulti
(
    IN  REFGUID             guidPropertySet,
    IN  ULONG               nProperty,
    OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem
)
{
    BOOL        fRes;
    ULONG       cbMultipleItem = 0;
    ULONG       ulReturned = 0;
    KSPROPERTY  ksProperty;

    ksProperty.Set    = guidPropertySet;    //KSPROPSETID_Topology;
    ksProperty.Id     = nProperty;          //KSPROPERTY_TOPOLOGY_NODES;
    ksProperty.Flags  = KSPROPERTY_TYPE_GET;

    fRes =
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &ksProperty,
            sizeof(KSPROPERTY),
            NULL,
            0,
            &cbMultipleItem
        );

    if (fRes && cbMultipleItem)
    {
        *ppKsMultipleItem = (PKSMULTIPLE_ITEM)LocalAlloc(LPTR, cbMultipleItem);
        
        fRes =
            SyncIoctl
            (
                m_handle,
                IOCTL_KS_PROPERTY,
                &ksProperty,
                sizeof(KSPROPERTY),
                (PVOID)*ppKsMultipleItem,
                cbMultipleItem,
                &ulReturned
            );
    }

    return fRes;
}

// ----------------------------------------------------------------------------------
// CKsIrpTarget::GetPropertyMulti
// Use this when input is not KSPROPERTY.
// ----------------------------------------------------------------------------------
BOOL
CKsIrpTarget::GetPropertyMulti
(
    IN  REFGUID             guidPropertySet,
    IN  ULONG               nProperty,
    IN  PVOID               pvData,
    IN  ULONG               cbData,
    OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem
)
{
    BOOL        fRes;
    ULONG       cbMultipleItem = 0;
    ULONG       ulReturned = 0;
    PKSPROPERTY pKsProperty;

    if (!pvData)
    {
        return FALSE;
    }

    pKsProperty         = (PKSPROPERTY) pvData;
    pKsProperty->Set    = guidPropertySet;
    pKsProperty->Id     = nProperty;
    pKsProperty->Flags  = KSPROPERTY_TYPE_GET;

    fRes =
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            (PKSPROPERTY) pvData,
            cbData,
            NULL,
            0,
            &cbMultipleItem
        );

    if (fRes && cbMultipleItem)
    {
        *ppKsMultipleItem = (PKSMULTIPLE_ITEM)LocalAlloc(LPTR, cbMultipleItem);
        
        fRes =
            SyncIoctl
            (
                m_handle,
                IOCTL_KS_PROPERTY,
                (PKSPROPERTY) pvData,
                cbData,
                (PVOID)*ppKsMultipleItem,
                cbMultipleItem,
                &ulReturned
            );
    }

    return fRes;
}

// ----------------------------------------------------------------------------------
// CKsIrpTarget::GetNodePropertyChannel
//  Get the value of a simple (non-multi) KSPROPERTY_Node property
// ----------------------------------------------------------------------------------
BOOL
CKsIrpTarget::GetNodePropertyChannel
(
    IN  ULONG   nNodeID,
    IN  ULONG   nChannel,
    IN  REFGUID guidPropertySet,
    IN  ULONG   nProperty,
    OUT PVOID   pvValue,
    OUT ULONG   cbValue
)
{
    ULONG                           ulReturned = 0;
    KSNODEPROPERTY_AUDIO_CHANNEL    KsNProp;

    KsNProp.NodeProperty.Property.Set = guidPropertySet;
    KsNProp.NodeProperty.Property.Id = nProperty;
    KsNProp.NodeProperty.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    KsNProp.NodeProperty.NodeId = nNodeID;
    KsNProp.NodeProperty.Reserved = 0;
    KsNProp.Channel = nChannel;
    KsNProp.Reserved = 0;

    return 
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &KsNProp,
            sizeof(KsNProp),
            pvValue,
            cbValue,
            &ulReturned
        );
}

// ----------------------------------------------------------------------------------
// CKsIrpTarget::GetNodePropertySimple
//  Get the value of a single type KSPROPERTY_Node property
// ----------------------------------------------------------------------------------
BOOL
CKsIrpTarget::GetNodePropertySimple
(
    IN  ULONG               nNodeID,
    IN  REFGUID             guidPropertySet,
    IN  ULONG               nPropertySet,
    OUT PVOID               pvDest,
    OUT ULONG               cbDest
)
{
    KSNODEPROPERTY          ksNodeProperty;
    ULONG                   ulReturned;

    ksNodeProperty.Property.Set = guidPropertySet;
    ksNodeProperty.Property.Id = nPropertySet;
    ksNodeProperty.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;

    ksNodeProperty.NodeId = nNodeID;
    ksNodeProperty.Reserved = 0;

    return 
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &ksNodeProperty,
            sizeof(ksNodeProperty),
            pvDest,
            cbDest,
            &ulReturned
        );
} // GetNodePropertySimple

// ----------------------------------------------------------------------------------
// CKsIrpTarget::GetNodePropertyMulti
//  Get the value of a multi-type KSPROPERTY_Node property
// ----------------------------------------------------------------------------------
BOOL
CKsIrpTarget::GetNodePropertyMulti
(
    IN  ULONG               nNodeID,
    IN  REFGUID             guidPropertySet,
    IN  ULONG               nProperty,
    OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem
)
{
    BOOL        fRes;
    ULONG       ulReturned = 0;
    ULONG       cbMultipleItem = 0;
    KSP_NODE    KsNProp;

    KsNProp.Property.Set = guidPropertySet;
    KsNProp.Property.Id = nProperty;
    KsNProp.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    KsNProp.NodeId = nNodeID;
    KsNProp.Reserved = 0;

    fRes =
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &KsNProp.Property,
            sizeof(KSP_NODE),
            NULL,
            0,
            &cbMultipleItem
        );

    if (fRes)
    {
        *ppKsMultipleItem = (PKSMULTIPLE_ITEM)LocalAlloc(LPTR, cbMultipleItem);
        
        fRes =
            SyncIoctl
            (
                m_handle,
                IOCTL_KS_PROPERTY,
                &KsNProp,
                sizeof(KSP_NODE),
                (PVOID)*ppKsMultipleItem,
                cbMultipleItem,
                &ulReturned
            );
    }

    return fRes;
}


// ----------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------
// CKsIrpTarget::SetPropertySimple
//  Get the value of a simple (non-multi) property
// ----------------------------------------------------------------------------------
BOOL
CKsIrpTarget::SetPropertySimple
(
    IN  REFGUID guidPropertySet,
    IN  ULONG   nProperty,
    OUT PVOID   pvValue,
    OUT ULONG   cbValue
)
{
    ULONG       ulReturned = 0;
    KSPROPERTY  ksProperty;

    ksProperty.Set    = guidPropertySet; 
    ksProperty.Id     = nProperty;       
    ksProperty.Flags  = KSPROPERTY_TYPE_SET;

    return 
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &ksProperty,
            sizeof(KSPROPERTY),
            pvValue,
            cbValue,
            &ulReturned
        );
}

// ----------------------------------------------------------------------------------
// CKsIrpTarget::SetPropertyMulti
// ----------------------------------------------------------------------------------
BOOL
CKsIrpTarget::SetPropertyMulti
(
    IN  REFGUID             guidPropertySet,
    IN  ULONG               nProperty,
    OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem
)
{
    BOOL        fRes;
    ULONG       cbMultipleItem = 0;
    ULONG       ulReturned = 0;
    KSPROPERTY  ksProperty;

    ksProperty.Set    = guidPropertySet; 
    ksProperty.Id     = nProperty;       
    ksProperty.Flags  = KSPROPERTY_TYPE_SET;

    fRes =
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &ksProperty,
            sizeof(KSPROPERTY),
            NULL,
            0,
            &cbMultipleItem
        );

    if (fRes)
    {
        *ppKsMultipleItem = (PKSMULTIPLE_ITEM)LocalAlloc(LPTR, cbMultipleItem);
        
        fRes =
            SyncIoctl
            (
                m_handle,
                IOCTL_KS_PROPERTY,
                &ksProperty,
                sizeof(KSPROPERTY),
                (PVOID)*ppKsMultipleItem,
                cbMultipleItem,
                &ulReturned
            );
    }

    return fRes;
}

// ----------------------------------------------------------------------------------
// CKsIrpTarget::SetNodePropertyChannel
//  Set the value of a simple (non-multi) KSPROPERTY_Node property
// ----------------------------------------------------------------------------------
BOOL
CKsIrpTarget::SetNodePropertyChannel
(
    IN  ULONG   nNodeID,
    IN  ULONG   nChannel,
    IN  REFGUID guidPropertySet,
    IN  ULONG   nProperty,
    OUT PVOID   pvValue,
    OUT ULONG   cbValue
)
{
    ULONG                           ulReturned = 0;
    KSNODEPROPERTY_AUDIO_CHANNEL    KsNProp;

    KsNProp.NodeProperty.Property.Set = guidPropertySet;
    KsNProp.NodeProperty.Property.Id = nProperty;
    KsNProp.NodeProperty.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
    KsNProp.NodeProperty.NodeId = nNodeID;
    KsNProp.NodeProperty.Reserved = 0;
    KsNProp.Channel = nChannel;
    KsNProp.Reserved = 0;

    return 
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &KsNProp,
            sizeof(KsNProp),
            pvValue,
            cbValue,
            &ulReturned
        );
}

// ----------------------------------------------------------------------------------
// CKsIrpTarget::SetNodePropertyMulti
//  Set the value of a multi-type KSPROPERTY_Node property
// ----------------------------------------------------------------------------------
BOOL
CKsIrpTarget::SetNodePropertyMulti
(
    IN  ULONG               nNodeID,
    IN  REFGUID             guidPropertySet,
    IN  ULONG               nProperty,
    OUT PKSMULTIPLE_ITEM*   ppKsMultipleItem
)
{
    BOOL        fRes;
    ULONG       ulReturned = 0;
    ULONG       cbMultipleItem = 0;
    KSP_NODE    KsNProp;

    KsNProp.Property.Set = guidPropertySet;
    KsNProp.Property.Id = nProperty;
    KsNProp.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
    KsNProp.NodeId = nNodeID;
    KsNProp.Reserved = 0;

    fRes =
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &KsNProp.Property,
            sizeof(KSP_NODE),
            NULL,
            0,
            &cbMultipleItem
        );

    if (fRes)
    {
        *ppKsMultipleItem = (PKSMULTIPLE_ITEM)LocalAlloc(LPTR, cbMultipleItem);
        
        fRes =
            SyncIoctl
            (
                m_handle,
                IOCTL_KS_PROPERTY,
                &KsNProp,
                sizeof(KSP_NODE),
                (PVOID)*ppKsMultipleItem,
                cbMultipleItem,
                &ulReturned
            );
    }

    return fRes;
}

// ----------------------------------------------------------------------------------
// CKsIrpTarget::SetNodePropertySimple
//  Set the value of a single KSPROPERTY_Node
// ----------------------------------------------------------------------------------
BOOL
CKsIrpTarget::SetNodePropertySimple
(
    IN  ULONG               nNodeID,
    IN  REFGUID             guidPropertySet,
    IN  ULONG               nProperty,
    OUT PVOID               pvDest,
    OUT ULONG               cbDest
)
{
    ULONG                           ulReturned = 0;
    KSNODEPROPERTY                  KsNProp;

    KsNProp.Property.Set = guidPropertySet;
    KsNProp.Property.Id = nProperty;
    KsNProp.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
    KsNProp.NodeId = nNodeID;
    KsNProp.Reserved = 0;

    return 
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &KsNProp,
            sizeof(KsNProp),
            pvDest,
            cbDest,
            &ulReturned
        );
} // SetNodePropertySimple
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\DirectKS\kspin.cpp ===
// ------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1996 - 2000.  All rights reserved.
//
// File Name:
//	kspin.cpp
//
// Abstract:
//  Class implementation of CKsPin.
//
// -------------------------------------------------------------------------------

#include "stdafx.h"
#include "kslibp.h"

// ------------------------------------------------------------------------
// CKsPin::CKsPin
//      copy constructor
// ------------------------------------------------------------------------
CKsPin::CKsPin
(
    CKsFilter*  pFilter,
    CKsPin*     pkspCopy
) : CKsIrpTarget(INVALID_HANDLE_VALUE),
    m_pFilter(pFilter),
    m_pksPinCreate(NULL),
    m_pksDataFormat(NULL),
    m_pbStreamData(NULL),
    m_cbStreamData(0L),
    m_dwAlignment(0),
    m_cFramesUsed(1)
{
    if (pkspCopy)
    {
        m_nId = pkspCopy->m_nId;
        m_ksState = pkspCopy->m_ksState;         
        m_nStackwiseFlow = pkspCopy->m_nStackwiseFlow;
        CopyMemory(&m_Descriptor, &pkspCopy->m_Descriptor, sizeof(PIN_DESCRIPTOR));
    }

    ZeroMemory(m_ov, 10 * sizeof(OVERLAPPED));
    ZeroMemory(m_ksStreamHeader, 10 * sizeof(KSSTREAM_HEADER));

    // create IRP-completion event
    for (int i = 0; i < 10; i++)
        m_ov[i].hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);

    m_szFriendlyName[0] = 0;
    m_UserDef = NULL;
}

// ------------------------------------------------------------------------
// CKsPin::CKsPin
//      constructor
// ------------------------------------------------------------------------
CKsPin::CKsPin
(
    CKsFilter*  pFilter,
    ULONG       nId
) : CKsIrpTarget(INVALID_HANDLE_VALUE),
    m_pFilter(pFilter),
    m_nId(nId),
    m_ksState(KSSTATE_STOP),
    m_pksPinCreate(NULL),
    m_pksDataFormat(NULL),
    m_pbStreamData(NULL),
    m_cbStreamData(0L),
    m_nStackwiseFlow(render),
    m_dwAlignment(0),
    m_cFramesUsed(1)
{
    ZeroMemory(&m_Descriptor, sizeof(PIN_DESCRIPTOR));

    ZeroMemory(m_ov, 10 * sizeof(OVERLAPPED));
    ZeroMemory(m_ksStreamHeader, 10 * sizeof(KSSTREAM_HEADER));

    // create IRP-completion event
    for (int i = 0; i < 10; i++)
        m_ov[i].hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);

    m_szFriendlyName[0] = 0;
    m_UserDef = NULL;
}

// ------------------------------------------------------------------------
// CKsPin::~CKsPin
// ------------------------------------------------------------------------
CKsPin::~CKsPin
(
    void
)
{
    ClosePin();
    for (int i = 0; i < 10; i++)
        SafeCloseHandle(m_ov[i].hEvent);

    SafeLocalFree(m_pksPinCreate);
    m_pbStreamData -= m_dwAlignment;
    SafeLocalFree(m_pbStreamData);
}

LPCSTR gpstrState[] = { "KSSTATE_STOP", "KSSTATE_ACQUIRE", "KSSTATE_PAUSE", "KSSTATE_RUN" };
LPCSTR gpstrPinType[] = { "render", "capture" };

// ----------------------------------------------------------------------------------
// CKsPin::Instantiate
//  instantiates m_handle
// ----------------------------------------------------------------------------------
BOOL    
CKsPin::Instantiate
(
    BOOL    fLooped
)
{
    if (!m_pksPinCreate)
        return FALSE;

    HRESULT hRes;

    m_fLooped = fLooped;
    m_pksPinCreate->Interface.Id = 
        m_fLooped ? KSINTERFACE_STANDARD_LOOPED_STREAMING : KSINTERFACE_STANDARD_STREAMING;

    if (fxnKsCreatePin)
    {
        hRes =
            fxnKsCreatePin
            (
                m_pFilter->m_handle,
                m_pksPinCreate,
                GENERIC_WRITE | GENERIC_READ,
                &m_handle
            );
    }
    else
    {
        LOG(eWarn1, "CKsPin::Instantiate.  Error:  fxnKsCreatePin = NULL");
        return FALSE;
    }

    if (hRes == 0)
    {
        LOG(eInfo2, "Successfully instantiated %s pin", m_nStackwiseFlow == render ? "Render" : "Capture");
        return TRUE;
    }
    else
    {
        DWORD dwLastError = GetLastError();
        
        LOG(eWarn2, "CKsPin::Instantiate.  Failed to instantiate %s pin!\nKsCreatePin returned = 0x%08x", m_nStackwiseFlow == render ? "Render" : "Capture", hRes);
        s_iLog->LogStdErrorString(dwLastError);
        return FALSE;
    }
}

// ----------------------------------------------------------------------------------
// CKsPin::ClosePin
//  closes m_handle
// ----------------------------------------------------------------------------------
void
CKsPin::ClosePin
(
    void
)
{
    SetState(KSSTATE_STOP);
    //LOG(eBlab2, "Closing %s pin", gpstrPinType[(UINT)m_nStackwiseFlow]);
    m_pbStreamData -= m_dwAlignment;
    m_dwAlignment = 0; // Ensure that we do not use the same alignment in Destructor.
    SafeLocalFree(m_pbStreamData);
    SafeCloseHandle(m_handle);
}

// ----------------------------------------------------------------------------------
// CKsPin::Wait
//  waits for m_ov[nFrame].hEvent
// ----------------------------------------------------------------------------------
BOOL
CKsPin::Wait
(
    DWORD   dwMilliseconds,
    ULONG   nFrame
)
{
    if (!IsValidHandle(m_ov[nFrame].hEvent))
        return FALSE;

    DWORD   dwWait = WaitForSingleObject(m_ov[nFrame].hEvent, dwMilliseconds);
    BOOL    fRes = (WAIT_OBJECT_0 == dwWait);

    if (!fRes && s_iLog)  LOG(eWarn2, "IRP completion timed out...");

    return fRes;
}

// ----------------------------------------------------------------------------------
// CKsPin::Wait
//  waits for all m_ov[n].hEvent
// ----------------------------------------------------------------------------------
BOOL
CKsPin::Wait
(
    DWORD   dwMilliseconds
)
{
    ULONG   nFrame;
    for (nFrame = 0; nFrame < m_cFramesUsed; nFrame++)
        if (! Wait(dwMilliseconds, nFrame))
            return FALSE;

    return TRUE;
}

// ----------------------------------------------------------------------------------
// CKsPin::IsSignaled
//  check state of m_ov[nFrame].hEvent
// ----------------------------------------------------------------------------------
BOOL
CKsPin::IsSignaled
(
    ULONG   nFrame
)
{
    if (!IsValidHandle(m_ov[nFrame].hEvent))
        return FALSE;

    return (WAIT_OBJECT_0 == WaitForSingleObject(m_ov[nFrame].hEvent, 0));
}

// ----------------------------------------------------------------------------------
// CKsPin::IsSignaled
//  check state of all m_ov[n].hEvent
// ----------------------------------------------------------------------------------
BOOL
CKsPin::IsSignaled
(
    void
)
{
    ULONG   nFrame;
    for (nFrame = 0; nFrame < m_cFramesUsed; nFrame++)
        if (! IsSignaled(nFrame))
            return FALSE;

    return TRUE;
}

// ----------------------------------------------------------------------------------
// CKsPin::GetOverlapped
//  Returns the overlapped structure. transparent to others.
// ----------------------------------------------------------------------------------
OVERLAPPED 
&CKsPin::GetOverlapped
(
    UINT unIndex /* = 0 */
)
{
    return m_ov[unIndex];
} // GetOverlapped

// ----------------------------------------------------------------------------------
// CKsPin::GetOverlapped
//  Returns the stream header structure. transparent to others.
// ----------------------------------------------------------------------------------
KSSTREAM_HEADER 
&CKsPin::GetStreamHeader
(
    UINT unIndex /* = 0 */
)
{
    return m_ksStreamHeader[unIndex];
} // GetStreamHeader

// ----------------------------------------------------------------------------------
// CKsPin::SetState
//  set KSSTATE of pin
// ----------------------------------------------------------------------------------
BOOL    
CKsPin::GetState
(
    PKSSTATE pksState
)
{
    KSPROPERTY    Property;
    ULONG         cbReturned;
    BOOL          fRes;
    KSSTATE       ksState;

    fRes =
        (m_nStackwiseFlow == 0 || m_nStackwiseFlow == 1) &&
        (pksState) &&
        (IsValidHandle(m_handle));

    if (!fRes)
        return FALSE;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_STATE;
    Property.Flags = KSPROPERTY_TYPE_GET;

    fRes = 
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof(KSPROPERTY),
            &ksState,
            sizeof(KSSTATE),
            &cbReturned 
        );

    if (fRes)
    {
        CopyMemory(pksState, &ksState, sizeof(KSSTATE));
    }

    return fRes;
} // GetState

// ----------------------------------------------------------------------------------
// CKsPin::SetState
//  set KSSTATE of pin
// ----------------------------------------------------------------------------------
BOOL    
CKsPin::SetState
(
    KSSTATE ksState
)
{
    KSPROPERTY    Property;
    ULONG         cbReturned;
    BOOL          fRes;

    fRes =
        (m_nStackwiseFlow == 0 || m_nStackwiseFlow == 1) &&
        (ksState == KSSTATE_STOP || ksState == KSSTATE_RUN || ksState == KSSTATE_PAUSE || ksState == KSSTATE_ACQUIRE) &&
        (IsValidHandle(m_handle));

    if (!fRes)
        return FALSE;

    LOG(eInfo3, "Setting %s pin to state %s", gpstrPinType[(UINT)m_nStackwiseFlow], gpstrState[(UINT)ksState]);

    m_ksState = ksState;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_STATE;
    Property.Flags = KSPROPERTY_TYPE_SET;

    fRes = 
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof(KSPROPERTY),
            &ksState,
            sizeof(KSSTATE),
            &cbReturned 
        );

    if (!fRes && s_iLog)  
        LOG(eWarn2, "Failed to set %s pin to state %s", gpstrPinType[(UINT)m_nStackwiseFlow], gpstrState[(UINT)ksState]);

    return fRes;
}

// ----------------------------------------------------------------------------------
// CKsPin::Reset
//  dump some data (namely m_pbStreamData) on the pin
// ----------------------------------------------------------------------------------
BOOL    
CKsPin::Reset
(
    void
)
{
    ULONG   ulIn;
    ULONG   ulBytesReturned;
    BOOL    fResult;
        
    LOG(eInfo3, "Resetting Pin state: IOCTL_KS_RESET_STATE (KSRESET_BEGIN)");
    ulIn = KSRESET_BEGIN;
    fResult =
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_RESET_STATE,
            &ulIn,
            sizeof(ULONG),
            NULL,
            0,
            &ulBytesReturned
        );
    if (!fResult)
    {
        LOG(eWarn2, "IOCTL_KS_RESET_STATE failed");
        s_iLog->LogStdErrorString(GetLastError());
    }

    LOG(eInfo3, "Resetting Pin state: IOCTL_KS_RESET_STATE (KSRESET_END)");
    ulIn = KSRESET_END;
    fResult =
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_RESET_STATE,
            &ulIn,
            sizeof(ULONG),
            NULL,
            0,
            &ulBytesReturned
        );
    if (!fResult)
    {
        LOG(eWarn2, "IOCTL_KS_RESET_STATE failed");
        s_iLog->LogStdErrorString(GetLastError());
    }

    return fResult;
}

// ----------------------------------------------------------------------------------
// CKsPin::WriteData
//  dump some data (namely m_pbStreamData) on the pin using only the nFrame-th frame
// ----------------------------------------------------------------------------------
BOOL    
CKsPin::WriteData
(
    ULONG   nFrame,
	BOOL	fPause
)
{
    DWORD   dwError;
    DWORD   cbReturned;
    BOOL    fRes = TRUE;

    ZeroMemory(&m_ksStreamHeader[nFrame], sizeof(KSSTREAM_HEADER));
    m_ksStreamHeader[nFrame].Size = sizeof(KSSTREAM_HEADER);
    m_ksStreamHeader[nFrame].Data = m_pbStreamData;
    m_ksStreamHeader[nFrame].FrameExtent = m_cbStreamData;
    m_ksStreamHeader[nFrame].DataUsed = m_cbStreamData;
    m_ksStreamHeader[nFrame].PresentationTime.Time          = 0;
    m_ksStreamHeader[nFrame].PresentationTime.Numerator     = 1;
    m_ksStreamHeader[nFrame].PresentationTime.Denominator   = 1;
    m_ksStreamHeader[nFrame].OptionsFlags = m_fLooped ? KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA : 0;

	if( fPause )
	{
		fRes = SetState(KSSTATE_PAUSE);
	}

    if (fRes)
    {
        // submit the data
        LOG(eInfo3, "Submitting IOCTL_KS_WRITE_STREAM IRP ...");
        ResetEvent(m_ov[nFrame].hEvent);
        fRes = 
            DeviceIoControl
            ( 
                m_handle,
                IOCTL_KS_WRITE_STREAM,
                NULL,
                0,
                &m_ksStreamHeader[nFrame],
                sizeof(KSSTREAM_HEADER),
                &cbReturned,
                &m_ov[nFrame]
            );
    }

    // Since we are paused, this should return FALSE
    if (fRes)
    {
        LOG(eWarn2, "DeviceIoControl returned TRUE even though the pin is paused\n");
    }
    else
    {
        // if it did return FALSE, then GetLastError should return ERROR_IO_PENDING
        dwError = GetLastError();
        if (ERROR_IO_PENDING == dwError)
        {
            LOG(eBlab2, "IRP is pending...");
            fRes = TRUE;
        }
        else
        {
            LOG(eWarn2, "GetLastError did not return ERROR_IO_PENDING even though the pin is paused\n");
            s_iLog->LogStdErrorString(dwError);
        }
    }

    return fRes;
}

// ----------------------------------------------------------------------------------
// CKsPin::WriteData
//  dump some data (namely m_pbStreamData) on the pin.  Use all frames
// ----------------------------------------------------------------------------------
BOOL    
CKsPin::WriteData
(
    void
)
{
    BOOL    fRes = TRUE;
    ULONG   nFrame;

    for (nFrame = 0; nFrame < m_cFramesUsed; nFrame++)
        fRes == fRes && WriteData(nFrame, TRUE);

    return fRes;
}

// ----------------------------------------------------------------------------------
// CKsPin::ReadData
//  read some data (into m_pbStreamData) from the pin
// ----------------------------------------------------------------------------------
BOOL    
CKsPin::ReadData
(
    ULONG   nFrame
)
{
    DWORD   dwError;
    DWORD   cbReturned;
    BOOL    fRes = TRUE;

    ZeroMemory(&m_ksStreamHeader[nFrame], sizeof(KSSTREAM_HEADER));
    m_ksStreamHeader[nFrame].Size = sizeof(KSSTREAM_HEADER);
    m_ksStreamHeader[nFrame].Data = m_pbStreamData;
    m_ksStreamHeader[nFrame].FrameExtent = CalculateFrameSize(nFrame, m_cFramesUsed, m_cbStreamData);
    m_ksStreamHeader[nFrame].DataUsed = 0;
    m_ksStreamHeader[nFrame].PresentationTime.Time          = 0;
    m_ksStreamHeader[nFrame].PresentationTime.Numerator     = 1;
    m_ksStreamHeader[nFrame].PresentationTime.Denominator   = 1;
    m_ksStreamHeader[nFrame].OptionsFlags = m_fLooped ? KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA : 0;

    fRes = SetState(KSSTATE_PAUSE);

    if (fRes)
    {
        // submit the data
        LOG(eInfo3, "Submitting IOCTL_KS_WRITE_STREAM IRP ...");
        ResetEvent(m_ov[nFrame].hEvent);
        fRes = 
            DeviceIoControl
            ( 
                m_handle,
                IOCTL_KS_READ_STREAM,
                NULL,
                0,
                &m_ksStreamHeader[nFrame],
                sizeof(KSSTREAM_HEADER),
                &cbReturned,
                &m_ov[nFrame]
            );
    }

    // Since we are paused, this should return FALSE
    if (fRes)
    {
        LOG(eWarn2, "Warning: DeviceIoControl returned TRUE even though the pin is paused\n");
    }
    else
    {
        // if it did return FALSE, then GetLastError should return ERROR_IO_PENDING
        dwError = GetLastError();
        if (ERROR_IO_PENDING == dwError)
        {
            LOG(eBlab2, "IRP is pending...");
            fRes = TRUE;
        }
        else
        {
            LOG(eWarn2, "Warning: GetLastError did not return ERROR_IO_PENDING even though the pin is paused\n");
            s_iLog->LogStdErrorString(dwError);
        }
    }

    if (fRes)
    {
        ASSERT(WAIT_TIMEOUT == WaitForSingleObject(m_ov[nFrame].hEvent, 0));
    }

    return fRes;
}


// ----------------------------------------------------------------------------------
// CKsPin::ReadData
//  dump some data (namely m_pbStreamData) on the pin.  Use all frames
// ----------------------------------------------------------------------------------
BOOL    
CKsPin::ReadData
(
    void
)
{
    BOOL    fRes = TRUE;
    ULONG   nFrame;

    for (nFrame = 0; nFrame < m_cFramesUsed; nFrame++)
        fRes == fRes && ReadData(nFrame);

    return fRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\DirectKS\pcmaudp.cpp ===
//==============================================================================
// Copyright (c) 2000 Microsoft Corporation.  All rights reserved.
//
// Module Name:
//	pcmaudp.cpp
//
// Abstract:
//  Class implementation of CPCMAudioPin.
//
//==============================================================================

#include "stdafx.h"
#include "kslibp.h"

CPCMAudioPin::CPCMAudioPin
(
    CKsFilter*  pFilter,
    ULONG       nId
) : CKsPin(pFilter, nId),
    m_dwWaveFormatMask(0),
	m_dwMinSampleFreq(ULONG_MAX),
	m_dwMaxSampleFreq(0)
{
    // create a KSPIN_CONNECT structure to describe a waveformatex pin
    m_pksPinCreate = 
        (PKSPIN_CONNECT)LocalAlloc(LPTR, sizeof(KSPIN_CONNECT) + sizeof(KSDATAFORMAT_WAVEFORMATEX));
    if (!m_pksPinCreate)
        return;

    ZeroMemory(&m_nPosition, sizeof(KSAUDIO_POSITION));

    m_pksPinCreate->Interface.Set              = KSINTERFACESETID_Standard;
    m_pksPinCreate->Interface.Id               = KSINTERFACE_STANDARD_STREAMING;
    m_pksPinCreate->Interface.Flags            = 0;
    m_pksPinCreate->Medium.Set                 = KSMEDIUMSETID_Standard;
    m_pksPinCreate->Medium.Id                  = KSMEDIUM_TYPE_ANYINSTANCE;
    m_pksPinCreate->Medium.Flags               = 0;
    m_pksPinCreate->PinId                      = nId;
    m_pksPinCreate->PinToHandle                = NULL;
    m_pksPinCreate->Priority.PriorityClass     = KSPRIORITY_NORMAL;
    m_pksPinCreate->Priority.PrioritySubClass  = 1;

    // point m_pksDataFormat to just after the pConnect struct
    PKSDATAFORMAT_WAVEFORMATEX pksDataFormatWfx = (PKSDATAFORMAT_WAVEFORMATEX)(m_pksPinCreate + 1);

    // set up format for KSDATAFORMAT_WAVEFORMATEX
    pksDataFormatWfx->DataFormat.FormatSize = sizeof(KSDATAFORMAT_WAVEFORMATEX);
    pksDataFormatWfx->DataFormat.Flags = 0;
    pksDataFormatWfx->DataFormat.Reserved = 0;
    pksDataFormatWfx->DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
    pksDataFormatWfx->DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
    pksDataFormatWfx->DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;

    m_pksDataFormat = (PKSDATAFORMAT)pksDataFormatWfx;
}

// ----------------------------------------------------------------------------------
// Copy Constructor
// ----------------------------------------------------------------------------------
CPCMAudioPin::CPCMAudioPin
(
    CKsPin*  pkspCopy
) : CKsPin(pkspCopy->m_pFilter, pkspCopy),
    m_dwWaveFormatMask(0),
	m_dwMinSampleFreq(ULONG_MAX),
	m_dwMaxSampleFreq(0)
{
    // create a KSPIN_CONNECT structure to describe a waveformatex pin
    SafeLocalFree(m_pksPinCreate);

    m_pksPinCreate = 
        (PKSPIN_CONNECT)LocalAlloc(LPTR, sizeof(KSPIN_CONNECT) + sizeof(KSDATAFORMAT_WAVEFORMATEX));
    if (!m_pksPinCreate)
        return;

    ZeroMemory(&m_nPosition, sizeof(KSAUDIO_POSITION));

    m_pksPinCreate->Interface.Set              = KSINTERFACESETID_Standard;
    m_pksPinCreate->Interface.Id               = KSINTERFACE_STANDARD_STREAMING;
    m_pksPinCreate->Interface.Flags            = 0;
    m_pksPinCreate->Medium.Set                 = KSMEDIUMSETID_Standard;
    m_pksPinCreate->Medium.Id                  = KSMEDIUM_TYPE_ANYINSTANCE;
    m_pksPinCreate->Medium.Flags               = 0;
    m_pksPinCreate->PinId                      = m_nId;
    m_pksPinCreate->PinToHandle                = NULL;
    m_pksPinCreate->Priority.PriorityClass     = KSPRIORITY_NORMAL;
    m_pksPinCreate->Priority.PrioritySubClass  = 1;

    // point m_pksDataFormat to just after the pConnect struct
    PKSDATAFORMAT_WAVEFORMATEX pksDataFormatWfx = (PKSDATAFORMAT_WAVEFORMATEX)(m_pksPinCreate + 1);

    // set up format for KSDATAFORMAT_WAVEFORMATEX
    pksDataFormatWfx->DataFormat.FormatSize = sizeof(KSDATAFORMAT_WAVEFORMATEX);
    pksDataFormatWfx->DataFormat.Flags = 0;
    pksDataFormatWfx->DataFormat.Reserved = 0;
    pksDataFormatWfx->DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
    pksDataFormatWfx->DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
    pksDataFormatWfx->DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;

    m_pksDataFormat = (PKSDATAFORMAT)pksDataFormatWfx;

//    m_pksPinCreate      = pkspCopy->m_pksPinCreate;     // creation parameters of pin
//    m_pksDataFormat     = pkspCopy->m_pksDataFormat;    // description of data
    // must NULL any pointers in pkspCopy that we inherited so that we don't free them on delete
    pkspCopy->m_pbStreamData = NULL;

    if (pkspCopy->m_eType == ePCMAudio)
	{
        m_dwWaveFormatMask = ((CPCMAudioPin*)pkspCopy)->m_dwWaveFormatMask;
		m_dwMinSampleFreq = ((CPCMAudioPin*)pkspCopy)->m_dwMinSampleFreq;
		m_dwMaxSampleFreq = ((CPCMAudioPin*)pkspCopy)->m_dwMaxSampleFreq;
	}

    // BUGBUG:  ?? is this right??
    delete pkspCopy;
}

// ----------------------------------------------------------------------------------
// CPCMAudioPin::SetFormat
//  sets the format
// ----------------------------------------------------------------------------------
BOOL    
CPCMAudioPin::SetFormat
(
    WAVEFORMATEX* pwfx
)
{
    if (!(pwfx && m_pksDataFormat))
        return FALSE;

    PKSDATAFORMAT_WAVEFORMATEX pksDataFormatWfx = (PKSDATAFORMAT_WAVEFORMATEX)m_pksDataFormat;

    CopyMemory(&pksDataFormatWfx->WaveFormatEx, pwfx, sizeof(WAVEFORMATEX));
    pksDataFormatWfx->DataFormat.SampleSize = (USHORT)(pwfx->nChannels * pwfx->wBitsPerSample / 8);

    return TRUE;
}


// ----------------------------------------------------------------------------------
// CPCMAudioPin::CreateDataBuffer
//  Allocates a buffer of appropriately sized to hold dwBufferSeconds worth o' data
// ----------------------------------------------------------------------------------
BOOL    
CPCMAudioPin::CreateDataBuffer
(
    DWORD   dwBufferSeconds,
    DWORD   dwAlignment /* = 0 */
)
{
    BOOL    fRes;
    PKSDATAFORMAT_WAVEFORMATEX pksDataFormatWfx = (PKSDATAFORMAT_WAVEFORMATEX)m_pksDataFormat;

    fRes = (pksDataFormatWfx != NULL);

    m_dwAlignment = dwAlignment;

    if (fRes)
    {
        m_cbStreamData = 
              dwBufferSeconds
            * pksDataFormatWfx->WaveFormatEx.nChannels 
            * pksDataFormatWfx->WaveFormatEx.nSamplesPerSec
            * pksDataFormatWfx->WaveFormatEx.wBitsPerSample 
            / 8;

        ASSERT(!m_pbStreamData);
        
        m_pbStreamData = (PBYTE)LocalAlloc(LPTR, m_cbStreamData + m_dwAlignment);

        fRes = (m_pbStreamData != NULL);
        if (!fRes)
            LOG(eWarn1, "Error!  Out of memory!");

        m_pbStreamData += m_dwAlignment;
    }

    return fRes;
}

BOOL    
CPCMAudioPin::CreateDataBufferMS
(
    DWORD   dwBufferMiliSeconds,
    DWORD   dwAlignment /* = 0 */
)
{
    BOOL    fRes;
    PKSDATAFORMAT_WAVEFORMATEX pksDataFormatWfx = (PKSDATAFORMAT_WAVEFORMATEX)m_pksDataFormat;

    fRes = (pksDataFormatWfx != NULL);

    m_dwAlignment = dwAlignment;

    if (fRes)
    {
        m_cbStreamData = 
              dwBufferMiliSeconds
            * pksDataFormatWfx->WaveFormatEx.nChannels 
            * pksDataFormatWfx->WaveFormatEx.nSamplesPerSec
            * pksDataFormatWfx->WaveFormatEx.wBitsPerSample 
            / 8
            / 1000;

        ASSERT(!m_pbStreamData);
        
        m_pbStreamData = (PBYTE)LocalAlloc(LPTR, m_cbStreamData + m_dwAlignment);
        
        fRes = (m_pbStreamData != NULL);
        if (!fRes)
            LOG(eWarn1, "Error!  Out of memory!");

        m_pbStreamData += m_dwAlignment;
    }

    return fRes;
}

BOOL
CPCMAudioPin::GetPosition
(
    KSAUDIO_POSITION* pPos
)
{
    BOOL                fRes = (pPos != NULL);

    if (fRes)    
        fRes = 
            GetPropertySimple(KSPROPSETID_Audio, KSPROPERTY_AUDIO_POSITION, pPos, sizeof(KSAUDIO_POSITION));

    if (fRes)
        CopyMemory(&m_nPosition, pPos, sizeof(KSAUDIO_POSITION));

    return fRes;
}

BOOL
CPCMAudioPin::SetPosition
(
    KSAUDIO_POSITION* pPos
)
{
    BOOL                fRes = (pPos != NULL);

    if (fRes)    
        fRes = 
            SetPropertySimple(KSPROPSETID_Audio, KSPROPERTY_AUDIO_POSITION, pPos, sizeof(KSAUDIO_POSITION));

    if (fRes)
        CopyMemory(&m_nPosition, pPos, sizeof(KSAUDIO_POSITION));

    return fRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\DirectKS\list.h ===
// ------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1996 - 2000.  All rights reserved.
//
// File Name:
//
//  Template classes for singly linked list of specified data type
//
// Abstract:
//
//  Implementation for class
//
// @@BEGIN_MSINTERNAL
//      mitchr      08/08/1998  - created
// @@END_MSINTERNAL
// -------------------------------------------------------------------------------

#ifndef _LIST_H_
#define _LIST_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define CList CKSList
#define CNode CKSNode

// forward 
template<class type> class CList;

// -----------------------------------------------------------------------------
template<class type> class CNode
{
private:
    CNode<type>* pPrev;
    
    CNode<type>* pNext;

public:
    type*        pData;

    CNode(type* pNewData)
    {
        pPrev = pNext = NULL;
        pData = pNewData;
    }

friend CList<type>;
};

// -----------------------------------------------------------------------------
template<class type> class CList
{
private:
    CNode<type>* m_pHead;
    CNode<type>* m_pTail;
    UINT         m_cMembers;

public:
    CList(void);
    
    ~CList(void);

    CNode<type>* GetHead(void)
    {
        return m_pHead;
    }
    CNode<type>* GetTail(void)
    {
        return m_pTail;
    }
    CNode<type>* GetNext(CNode<type>* pNode)
    {
        return pNode->pNext;
    }

    CNode<type>* AddTail(type*);
    
    CNode<type>* AddHead(type*);
    
    CNode<type>* Find(type*);
    
    void         Remove(CNode<type>*);
    
    void         Empty(void);
    
    UINT         GetCount(void)  { return m_cMembers; }
    
    BOOL         IsEmpty(void)  { return (m_cMembers == 0); }
};

// ---------------------
template<class type> 
CList<type>::CList(void)
{
    m_pHead = NULL;
    m_pTail = NULL;
    m_cMembers = 0;
}

// ---------------------
template<class type> 
CList<type>::~CList(void)
{
    Empty();
}

// ---------------------
template<class type> 
CNode<type>*
CList<type>::AddHead(type* pNewData)
{
    CNode<type>* pNewNode = new CNode<type>(pNewData);

    if(pNewNode)
    {
        if(m_pHead)
        {
            m_pHead->pPrev = pNewNode;
            pNewNode->pPrev = NULL;
            pNewNode->pNext = m_pHead;
        }

        m_pHead = pNewNode;
        if(!m_pTail)
            m_pTail = pNewNode;

        m_cMembers++;
    }

    return pNewNode;
}

// ---------------------
template<class type> 
CNode<type>*
CList<type>::AddTail(type* pNewData)
{
    CNode<type>* pNewNode = new CNode<type>(pNewData);

    if(pNewNode)
    {
        if(m_pTail)
        {
            m_pTail->pNext = pNewNode;
            pNewNode->pNext = NULL;
            pNewNode->pPrev = m_pTail;
        }
        m_pTail = pNewNode;
        if(!m_pHead)
            m_pHead = pNewNode;

        m_cMembers++;
    }

    return pNewNode;
}

// ---------------------
template<class type> 
CNode<type>*
CList<type>::Find(type* pDataFind)
{
    CNode<type>* pNode = m_pHead;

    while(pNode)
    {
        if(pNode->pData == pDataFind)
            return pNode;

        pNode = pNode->pNext;
    }

    return NULL;
}

// ---------------------
template<class type> 
void
CList<type>::Remove(CNode<type>* pDeadNode)
{
    if(pDeadNode)
    {
        if(pDeadNode->pPrev)
            pDeadNode->pPrev->pNext = pDeadNode->pNext;
        else
            m_pHead = pDeadNode->pNext;

        if(pDeadNode->pNext)
            pDeadNode->pNext->pPrev = pDeadNode->pPrev;
        else
            m_pTail = pDeadNode->pPrev;

        delete pDeadNode;
        m_cMembers--;
    }
}

// ---------------------
template<class type> 
void 
CList<type>::Empty(void)
{
    CNode<type>* pNext;

    while(m_pHead)
    {
        pNext = m_pHead->pNext;
        delete m_pHead;
        m_pHead = pNext;
    }

    m_pHead = m_pTail = NULL;
    m_cMembers = 0;
}

#endif // #ifndef _LIST_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\DirectKS\pcmaudf.cpp ===
//==============================================================================
// Copyright (c) 2000 Microsoft Corporation.  All rights reserved.
//
// Module Name:
//	pcmaudf.cpp
//
// Abstract:
//  Class implementation of CPCMAudioFilter.
//
//==============================================================================

#include "stdafx.h"
#include "kslibp.h"

// ----------------------------------------------------------------------------------
// CPCMAudioFilter::CPCMAudioFilter
// ----------------------------------------------------------------------------------
CPCMAudioFilter::CPCMAudioFilter
(
    LPCTSTR  pszName,
    LPCTSTR  pszFriendlyName,
    LPCTSTR  pszCLSID,
    LPCTSTR  pszService,
    LPCTSTR  pszBinary
) : CKsFilter(pszName, pszFriendlyName, pszCLSID, pszService, pszBinary)
{
    m_eType = ePCMAudio;
}

#define MASK_MIN_MAX_DATARANGE(dw, dwMask, val, min, max)   if (((min) <= (val)) && ((max) >= (val))) (dw) |= (dwMask)
// ----------------------------------------------------------------------------------
// CPCMAudioFilter::EnumeratePins
//  same as CKsFilter::EnumeratePins, but excludes non PCM pins
// ----------------------------------------------------------------------------------
BOOL    
CPCMAudioFilter::EnumeratePins
(
    void
)
{
    DWORD   fRes            = TRUE;
    DWORD    fViableFilter   = FALSE;
    ULONG    cPins, nPinId;

    // get the number of pins supported by SAD
    fRes = 
        GetPinPropertySimple
        (  
            0,
            KSPROPSETID_Pin,
            KSPROPERTY_PIN_CTYPES,
            &cPins,
            sizeof(cPins)
        );

    if (fRes)
    {
        fRes = FALSE;

        //
        // loop through the pins, looking for audio pins
        //
        for(nPinId = 0; nPinId < cPins; nPinId++)
        {
            ULONG               i;
            BOOL                fViablePin;;
            PKSMULTIPLE_ITEM    pMIInterfaces;
            PKSMULTIPLE_ITEM    pMIMediums;
            PKSMULTIPLE_ITEM    pMIDataRanges;
            PKSDATARANGE        pDataRange;

            //
            // create a new CKsPin and add to the appropriate pin list
            //
            CPCMAudioPin* pNewPin = new CPCMAudioPin(this, nPinId);

            //
            // get COMMUNICATION ---------------
            //
            fRes = 
                GetPinPropertySimple
                ( 
                    nPinId,
                    KSPROPSETID_Pin,
                    KSPROPERTY_PIN_COMMUNICATION,
                    &pNewPin->m_Descriptor.Communication,
                    sizeof(KSPIN_COMMUNICATION)
                );
            if (!fRes)
            {
                LOG(eWarn2, "Failed to retrieve pin property KSPROPERTY_PIN_COMMUNICATION");
                goto break_loop;
            }

            // ILL communication
            if ( (pNewPin->m_Descriptor.Communication != KSPIN_COMMUNICATION_SOURCE) &&
                (pNewPin->m_Descriptor.Communication != KSPIN_COMMUNICATION_SINK) &&
                (pNewPin->m_Descriptor.Communication != KSPIN_COMMUNICATION_BOTH) )
                goto break_loop;

            //
            // get PKSPIN_INTERFACEs ---------------
            //
            fRes = GetPinPropertyMulti(nPinId, KSPROPSETID_Pin, KSPROPERTY_PIN_INTERFACES, &pMIInterfaces);
            if (!fRes)
            {
                LOG(eWarn2, "Failed to retrieve pin property KSPROPERTY_PIN_INTERFACES");
                goto break_loop;
            }

            pNewPin->m_Descriptor.cInterfaces = pMIInterfaces->Count;
            pNewPin->m_Descriptor.pInterfaces = (PKSPIN_INTERFACE)(pMIInterfaces + 1);

            // make sure that at least one interface is standard streaming
            for(i = 0, fViablePin = FALSE; i < pNewPin->m_Descriptor.cInterfaces && !fViablePin; i++)
            {
                fViablePin = 
                    fViablePin ||
                    IsEqualGUIDAligned(pNewPin->m_Descriptor.pInterfaces[i].Set, KSINTERFACESETID_Standard) && 
                    (pNewPin->m_Descriptor.pInterfaces[i].Id == KSINTERFACE_STANDARD_STREAMING) ;
            }

            LocalFree(pMIInterfaces);

            if (!fViablePin)
                goto break_loop;

            //
            // get PKSPIN_MEDIUMs ---------------
            //
            fRes = GetPinPropertyMulti(nPinId, KSPROPSETID_Pin, KSPROPERTY_PIN_MEDIUMS, &pMIMediums);
            if (!fRes)
            {
                LOG(eWarn2, "Failed to retrieve pin property KSPROPERTY_PIN_MEDIUMS");
                goto break_loop;
            }

            pNewPin->m_Descriptor.cMediums = pMIMediums->Count;
            pNewPin->m_Descriptor.pMediums = (PKSPIN_MEDIUM)(pMIMediums + 1);

            // make sure that at least one Medium is standard streaming
            for(i = 0, fViablePin = FALSE; i < pNewPin->m_Descriptor.cMediums && !fViablePin; i++)
            {
                fViablePin = 
                    fViablePin ||
                    IsEqualGUIDAligned(pNewPin->m_Descriptor.pMediums[i].Set, KSMEDIUMSETID_Standard) && 
                    (pNewPin->m_Descriptor.pMediums[i].Id == KSMEDIUM_STANDARD_DEVIO);
            }

            LocalFree(pMIMediums);

            if (!fViablePin)
                goto break_loop;

            //
            // get PKSPIN_DATARANGEs ---------------
            //
            fRes = GetPinPropertyMulti(nPinId, KSPROPSETID_Pin, KSPROPERTY_PIN_DATARANGES, &pMIDataRanges);
            if (!fRes)
            {
                LOG(eWarn2, "Failed to retrieve pin property KSPROPERTY_PIN_DATARANGES");
                goto break_loop;
            }

            pNewPin->m_Descriptor.cDataRanges = pMIDataRanges->Count;
            pNewPin->m_Descriptor.pDataRanges = (PKSDATARANGE)(pMIDataRanges + 1);
            pNewPin->m_dwWaveFormatMask = 0x00000000;
			pNewPin->m_dwMinSampleFreq = ULONG_MAX;
			pNewPin->m_dwMaxSampleFreq = 0;

            pDataRange = pNewPin->m_Descriptor.pDataRanges;

            // make sure that at least one data range supports audio
            for(i = 0, fViablePin = FALSE; i < pNewPin->m_Descriptor.cDataRanges; i++)
            {
                // SubType should either be compatible with WAVEFORMATEX or 
                // it should be WILDCARD
                fViablePin = 
                    fViablePin || 
                    IS_VALID_WAVEFORMATEX_GUID(&pDataRange->SubFormat) ||
                    IsEqualGUIDAligned(pDataRange->SubFormat, KSDATAFORMAT_SUBTYPE_PCM) ||
                    IsEqualGUIDAligned(pDataRange->SubFormat, KSDATAFORMAT_SUBTYPE_WILDCARD);

                if (fViablePin && IsEqualGUIDAligned(pDataRange->MajorFormat, KSDATAFORMAT_TYPE_AUDIO))
                {
                    PKSDATARANGE_AUDIO pDataRangeAudio = (PKSDATARANGE_AUDIO)pDataRange;

                    ULONG maxc = pDataRangeAudio->MaximumChannels;
                    ULONG minf = pDataRangeAudio->MinimumSampleFrequency;
                    ULONG maxf = pDataRangeAudio->MaximumSampleFrequency;
                    ULONG minb = pDataRangeAudio->MinimumBitsPerSample;
                    ULONG maxb = pDataRangeAudio->MaximumBitsPerSample;

					pNewPin->m_dwMinSampleFreq = min( pNewPin->m_dwMinSampleFreq, minf );
					pNewPin->m_dwMaxSampleFreq = max( pNewPin->m_dwMaxSampleFreq, maxf );

                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_MONO,       1, 1, maxc);
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_STEREO,     2, 1, maxc);
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_QUAD,       4, 1, maxc);    // BUGBUG:  these two are 
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_SURROUND,   4, 1, maxc);    // ambiguous (actually a design bug in ks)
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_5_1,        6, 1, maxc);
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_7_1,        8, 1, maxc);

                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_8BIT,   8, minb, maxb);
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_16BIT, 16, minb, maxb);
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_20BIT, 20, minb, maxb);
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_24BIT, 24, minb, maxb);
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_32BIT, 32, minb, maxb);

                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_8000HZ,   8000, minf, maxf);
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_11025HZ, 11025, minf, maxf);
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_16000HZ, 16000, minf, maxf);
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_22050HZ, 22050, minf, maxf);
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_32000HZ, 32000, minf, maxf);
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_44100HZ, 44100, minf, maxf);
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_48000HZ, 48000, minf, maxf);
                    MASK_MIN_MAX_DATARANGE(pNewPin->m_dwWaveFormatMask, FMT_96000HZ, 96000, minf, maxf);
                }

                pDataRange = (PKSDATARANGE)( ((PBYTE)pDataRange) + pDataRange->FormatSize);
            }

            LocalFree(pMIDataRanges);

            if (!fViablePin)
                goto break_loop;

            //
            // Get the data flow property
            //
            fRes = 
                GetPinPropertySimple
                (             
                    nPinId,
                    KSPROPSETID_Pin,
                    KSPROPERTY_PIN_DATAFLOW,
                    &pNewPin->m_Descriptor.DataFlow,
                    sizeof(KSPIN_DATAFLOW)
                );
            if (!fRes)
            {
                LOG(eWarn2, "Failed to retrieve pin property KSPROPERTY_PIN_DATAFLOW");
                goto break_loop;
            }

            //
            // create a new CKsPin and add to the appropriate pin list
            //
            if (!pNewPin)
            {
                LOG(eWarn2, "Failed to create pin");
                goto break_loop;
            }

            m_listPins.AddTail(pNewPin);

            continue;

break_loop:
            if (pNewPin)
            {
                delete pNewPin;
                pNewPin = NULL;
            }
        }
    }

    ClassifyPins(&m_listPins);
    
    fViableFilter =
        !   (
                m_listRenderSinkPins.IsEmpty() && 
                m_listRenderSourcePins.IsEmpty() && 
                m_listCaptureSinkPins.IsEmpty() &&
                m_listCaptureSourcePins.IsEmpty()
            );

    // the end
    return fViableFilter;
}

// ----------------------------------------------------------------------------------
// CPCMAudioFilter::FindViablePin
//  look through m_listRenderPins or m_listCapturePins and find one that can do pwfx
// ----------------------------------------------------------------------------------
CPCMAudioPin*
CPCMAudioFilter::FindViablePin
(
    CList<CKsPin>*  pList,
    WAVEFORMATEX*   pwfx
)
{
    CNode<CKsPin>*  pNodeNext;
    CNode<CKsPin>*  pNode;
    CPCMAudioPin*   pPin;
    
    pNode = pList->GetHead();
    while(pNode)
    {
        pNodeNext = pList->GetNext(pNode);
        pPin = (CPCMAudioPin*)pNode->pData;

        BOOL    fViablePin = FALSE;

        //
        // make sure that pwfx parameters are in at least one DataRange supported by this pin
        //
        DWORD   dw = 0x00000000;

        if (pwfx->wBitsPerSample == 8)       dw |= FMT_8BIT ;
        if (pwfx->wBitsPerSample == 16)      dw |= FMT_16BIT;
        if (pwfx->wBitsPerSample == 20)      dw |= FMT_20BIT;
        if (pwfx->wBitsPerSample == 24)      dw |= FMT_24BIT;
        if (pwfx->wBitsPerSample == 32)      dw |= FMT_32BIT;

        if (pwfx->nSamplesPerSec ==  8000)   dw |= FMT_8000HZ ;
        if (pwfx->nSamplesPerSec == 11025)   dw |= FMT_11025HZ;
        if (pwfx->nSamplesPerSec == 16000)   dw |= FMT_16000HZ;
        if (pwfx->nSamplesPerSec == 22050)   dw |= FMT_22050HZ;
        if (pwfx->nSamplesPerSec == 32000)   dw |= FMT_32000HZ;
        if (pwfx->nSamplesPerSec == 44100)   dw |= FMT_44100HZ;
        if (pwfx->nSamplesPerSec == 48000)   dw |= FMT_48000HZ;
        if (pwfx->nSamplesPerSec == 96000)   dw |= FMT_96000HZ;

        if (pwfx->nChannels == 1)            dw |= FMT_MONO  ;
        if (pwfx->nChannels == 2)            dw |= FMT_STEREO;
        if (pwfx->nChannels == 4)            dw |= FMT_QUAD | FMT_SURROUND;
        if (pwfx->nChannels == 6)            dw |= FMT_5_1;
        if (pwfx->nChannels == 7)            dw |= FMT_7_1;

        fViablePin = (dw == (dw & pPin->m_dwWaveFormatMask));
        if (fViablePin)
            return pPin;

        pNode = pNodeNext;
    }

    return NULL;
}

// ----------------------------------------------------------------------------------
// CPCMAudioFilter::CreateRenderPin
//  look through m_listRenderPins and find one that can do pwfx
// ----------------------------------------------------------------------------------
BOOL
CPCMAudioFilter::CreateRenderPin
(
    WAVEFORMATEX*   pwfx,
    DWORD           dwBufferSeconds,
    DWORD           dwAlignment /* = 0 */
)
{
    CPCMAudioPin* pPin = FindViablePin(&m_listRenderSinkPins, pwfx);

    if (!pPin)
    {
        LOG(eWarn2, "Could not find a Render pin that supports the given wave format");
        SetLastError(ERROR_BAD_FORMAT);
        return FALSE;
    }

    SetLastError(0);
    m_pRenderPin = (CKsPin*)pPin;

    if (!pPin->SetFormat(pwfx))
    {
        LOG(eWarn2, "Failed to set Render Pin format");
        return FALSE;
    }

    if (pPin->Instantiate())
    {
        LOG(eInfo2, "Successfully instantiated Render Pin.  Handle = 0x%08x", pPin->m_handle);
    }
    else
    {
        LOG(eWarn2, "Failed to instantiate Render Pin");
        return FALSE;
    }

    return pPin->CreateDataBuffer(dwBufferSeconds, dwAlignment);
}

// ----------------------------------------------------------------------------------
// CPCMAudioFilter::CreateCapturePin
//  look through m_listCapturePins and find one that can do pwfx
// ----------------------------------------------------------------------------------
BOOL
CPCMAudioFilter::CreateCapturePin
(
    WAVEFORMATEX*   pwfx,
    DWORD           dwBufferSeconds,
    DWORD           dwAlignment /* = 0 */
)
{
    CPCMAudioPin*   pPin = FindViablePin(&m_listCaptureSinkPins, pwfx);

    if (!pPin)
    {
        LOG(eWarn2, "Could not find a Capture pin that supports the given wave format");
        SetLastError(ERROR_BAD_FORMAT);
        return FALSE;
    }

    SetLastError(0);
    m_pCapturePin = (CKsPin*)pPin;

    if (!pPin->SetFormat(pwfx))
    {
        LOG(eWarn2, "Failed to set Capture Pin format");
        return FALSE;
    }

    if (pPin->Instantiate())
    {
        LOG(eInfo2, "Successfully instantiated Capture Pin.  Handle = 0x%08x", pPin->m_handle);
    }
    else
    {
        LOG(eWarn2, "Failed to instantiate Capture Pin");
        return FALSE;
    }

    return pPin->CreateDataBuffer(dwBufferSeconds, dwAlignment);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\DirectKS\sysaud.cpp ===
//==============================================================================
// Copyright (c) 2000 Microsoft Corporation.  All rights reserved.
//
// Module Name:
//	sysaud.cpp
//
// Abstract:
//  Class implementation of CSysAudio.
//
//==============================================================================

#include "stdafx.h"
#include "kslibp.h"

// ----------------------------------------------------------------------------------
// CSysAudio::CSysAudio
// ----------------------------------------------------------------------------------
CSysAudio::CSysAudio
(
    LPCTSTR  pszName,
    LPCTSTR  pszFriendlyName,
    LPCTSTR  pszCLSID,
    LPCTSTR  pszService, 
    LPCTSTR  pszBinary
) : CKsFilter(pszName, pszFriendlyName, pszCLSID, pszService, pszBinary),
    m_ulDeviceCount(0)
{
    m_eType = eSysAudio;
}

// ----------------------------------------------------------------------------------
// CSysAudio::~CSysAudio
// ----------------------------------------------------------------------------------
CSysAudio::~CSysAudio()
{
    DestroyLists();
} // ~CSysAudio

// ----------------------------------------------------------------------------------
// CSysAudio::DestroyLists
// ----------------------------------------------------------------------------------
void CSysAudio::DestroyLists()
{
    CKsFilter::DestroyLists();

    CNode <CSysAudioDeviceFilter> *pNode;

    pNode = m_listDevices.GetHead();
    while (pNode)
    {
        delete pNode->pData;
        
        pNode = m_listDevices.GetNext(pNode);
    }

    m_listDevices.Empty();
} // DestroyLists

// ----------------------------------------------------------------------------------
// CSysAudio::EnumeratePins
// This will actually create a list of sysaudio devices.
// ----------------------------------------------------------------------------------
BOOL CSysAudio::EnumeratePins()
{
    BOOL fResult = TRUE;

    //
    // Get number of devices for this filter.
    //
    if (TRUE == fResult)
    {
        fResult = 
            GetPropertySimple
            (
                KSPROPSETID_Sysaudio,
                KSPROPERTY_SYSAUDIO_DEVICE_COUNT,
                &m_ulDeviceCount,
                sizeof(m_ulDeviceCount)
            );
        if (TRUE != fResult)
        {
            LOG(eWarn1, "Cannot get device count from SysAudio");
        }
    }

    //
    // Create a list of devices.
    //
    if (TRUE == fResult)
    {
        WCHAR szDeviceInterfaceName[MAX_PATH];
        WCHAR szDeviceFriendlyName[MAX_PATH];
        CHAR  szInterfaceName[MAX_PATH];
        CHAR  szFriendlyName[MAX_PATH];


        for (ULONG ulDeviceId = 0; ulDeviceId < m_ulDeviceCount; ulDeviceId++)
        {
            //
            // Set current device instance.
            //
            fResult = 
                SetDevicePropertySimple
                (
                    ulDeviceId,
                    KSPROPSETID_Sysaudio,
                    KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
                    NULL,
                    0
                );
            
            //
            // Get sysaudio device properties.
            //
            fResult =
                GetDevicePropertySimple
                (
                    ulDeviceId,
                    KSPROPSETID_Sysaudio,
                    KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME,
                    szDeviceInterfaceName,
                    MAX_PATH * sizeof(WCHAR)
                );
            if (fResult)
            {
                fResult = 
                    GetDevicePropertySimple
                    (
                        ulDeviceId,
                        KSPROPSETID_Sysaudio,
                        KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME,
                        szDeviceFriendlyName,
                        MAX_PATH * sizeof(WCHAR)
                    );
            }

            //
            // Create the device if all is good.
            //
            PCSysAudioDeviceFilter pDevice = NULL;
            if (fResult)
            {
                WideCharToMultiByte
                    (
                        CP_ACP, 
                        0, 
                        szDeviceInterfaceName,
                        MAX_PATH,
                        szInterfaceName,
                        MAX_PATH,
                        NULL,
                        NULL
                    );

                WideCharToMultiByte
                    (
                        CP_ACP, 
                        0, 
                        szDeviceFriendlyName,
                        MAX_PATH,
                        szFriendlyName,
                        MAX_PATH,
                        NULL,
                        NULL
                    );

                pDevice =     
                    new CSysAudioDeviceFilter
                        (
                            szInterfaceName,
                            szFriendlyName
                        );
                if (!pDevice)
                {
                    fResult = FALSE;
                }
            }

            // 
            // Set device properties and add it to device list.
            //
            if (fResult)
            {
                pDevice->m_DeviceID = ulDeviceId;

                m_listDevices.AddTail(pDevice);
            }
        }
    }

    return fResult;
} // EnumeratePins

// ----------------------------------------------------------------------------------
// CSysAudio::GetDevicePropertySimple
// ----------------------------------------------------------------------------------
BOOL
CSysAudio::GetDevicePropertySimple
(
    IN  ULONG               ulDeviceId,
    IN  REFGUID             guidPropertySet,
    IN  ULONG               nProperty,
    OUT PVOID               pvDest,
    OUT ULONG               cbDest
)
{
    ULONG           ulReturned = 0;
    KSP_SYSAUDIO    KsSysAudioProp;

    KsSysAudioProp.Property.Set = guidPropertySet;
    KsSysAudioProp.Property.Id = nProperty;
    KsSysAudioProp.Property.Flags = KSPROPERTY_TYPE_GET;
    KsSysAudioProp.DeviceId = ulDeviceId;

    return 
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &KsSysAudioProp,
            sizeof(KSP_PIN),
            pvDest,
            cbDest,
            &ulReturned
        );
} // GetDevicePropertySimple

BOOL
CSysAudio::SetDevicePropertySimple
(
    IN  ULONG               ulDeviceId,
    IN  REFGUID             guidPropertySet,
    IN  ULONG               nProperty,
    OUT PVOID               pvDest,
    OUT ULONG               cbDest
)
{
    ULONG           ulReturned = 0;
    KSP_SYSAUDIO    KsSysAudioProp;

    KsSysAudioProp.Property.Set = guidPropertySet;
    KsSysAudioProp.Property.Id = nProperty;
    KsSysAudioProp.Property.Flags = KSPROPERTY_TYPE_SET;
    KsSysAudioProp.DeviceId = ulDeviceId;

    return 
        SyncIoctl
        (
            m_handle,
            IOCTL_KS_PROPERTY,
            &KsSysAudioProp,
            sizeof(KSP_PIN),
            pvDest,
            cbDest,
            &ulReturned
        );
} // SetDevicePropertySimple
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\cconduct.cpp ===
// CConductor.cpp : Implementation of CConductorApp and DLL registration.
// @doc Conductor

#include "stdafx.h"
#include <mmsystem.h>
#include "dsoundp.h"
#include "CConduct.h"
#include "phoneyds.h"
#include <atlwin.cpp>
#include <mmsystem.h>
#include <oleauto.h>
#include <dmksctrl.h>
#include <dsound.h>
#include "OutputTool.h"
#include "StatusToolbar.h"
#include "Toolbar.h"
#include "SecondaryToolbar.h"
#include "TREntry.h"
#include <RiffStrm.h>
#include "OptionsToolbar.h"
#include "SynthStatusToolbar.h"
#include "WaveRecordToolbar.h"
#include "MIDISave.h"
#include "AudiopathDesigner.h"
#include "..\WaveSaveDmo\testdmo.h"
#include "DMOInfoProxy.h"
#include "detours.h"
#include "dsbufcfg.h"
#ifdef DMP_XBOX
#include "xboxdbg.h"
#include "..\shared\xguids.h"
#endif


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// Defined in notify.cpp
extern void AddToolsAndSetupWaveSaveForSegState( IUnknown *punk );
extern bool AudiopathHasWaveSaveDMO( IDirectMusicAudioPath *pIDirectMusicAudioPath );

// Defined in dslink.cpp
extern bool g_fKslInitialized;
extern TCHAR g_szPhoneyDSoundFilterName[MAX_PATH];
extern DWORD g_dwLatency;

extern IDirectMusicPort *g_rpLastSampledPort;

static BOOL g_fUsePhoneyDSound = FALSE;

//#define CHECK_FOR_EXTRA_PORT_REFS

#define DEFAULT_NUM_PCHANNELS 128

// Detours stuff ULONG_PTR
extern "C" {
#define FUNCPTR_CoCreate HRESULT (STDAPICALLTYPE *)(IN REFCLSID rclsid, IN LPUNKNOWN pUnkOuter, IN DWORD dwClsContext, IN REFIID riid, OUT LPVOID FAR* ppv)


HRESULT (STDAPICALLTYPE *DynamicTrampoline)(IN REFCLSID rclsid, IN LPUNKNOWN pUnkOuter,
                    IN DWORD dwClsContext, IN REFIID riid, OUT LPVOID FAR* ppv) = NULL;
}

STDAPI DynamicDetour(IN REFCLSID rclsid, IN LPUNKNOWN pUnkOuter,
                    IN DWORD dwClsContext, IN REFIID riid, OUT LPVOID FAR* ppv)
{
	if( rclsid == CLSID_DirectSoundBufferConfig )
	{
#ifdef DMP_XBOX
        if (g_fUsePhoneyDSound)
#endif
        {
		    CDirectSoundBufferConfig *pCDirectSoundBufferConfig = new CDirectSoundBufferConfig;
		    pCDirectSoundBufferConfig->QueryInterface( riid, ppv );
		    pCDirectSoundBufferConfig->Release();
		    return S_OK;
        }
	}
    CLSID clsid = rclsid;
#ifdef DMP_XBOX
    // These bogus classids force the use of our alternate xdmime.dll.
    if (clsid == CLSID_DirectMusicSegmentState)
    {
        clsid = CLSID_XDirectMusicSegmentState;
    }
    else if (clsid == CLSID_DirectMusicPerformance)
    {
        clsid = CLSID_XDirectMusicPerformance;
    }
    else if (clsid == CLSID_DirectMusicSegment)
    {
        clsid = CLSID_XDirectMusicSegment;
    }
    else if (clsid == CLSID_DirectMusicSong)
    {
        clsid = CLSID_XDirectMusicSong;
    }
    else if (clsid == CLSID_DirectMusicAudioPathConfig)
    {
        clsid = CLSID_XDirectMusicAudioPathConfig;
    }
    else if (clsid == CLSID_DirectMusicSeqTrack)
    {
        clsid = CLSID_XDirectMusicSeqTrack;
    }
    else if (clsid == CLSID_DirectMusicGraph)
    {
        clsid = CLSID_XDirectMusicGraph;
    }
    else if (clsid == CLSID_DirectMusicSysExTrack)
    {
        clsid = CLSID_XDirectMusicSysExTrack;
    }
    else if (clsid == CLSID_DirectMusicTempoTrack)
    {
        clsid = CLSID_XDirectMusicTempoTrack;
    }
    else if (clsid == CLSID_DirectMusicTimeSigTrack)
    {
        clsid = CLSID_XDirectMusicTimeSigTrack;
    }
    else if (clsid == CLSID_DirectMusicMarkerTrack)
    {
        clsid = CLSID_XDirectMusicMarkerTrack;
    }
    else if (clsid == CLSID_DirectMusicWaveTrack)
    {
        clsid = CLSID_XDirectMusicWaveTrack;
    }
    else if (clsid == CLSID_DirectMusicSegmentTriggerTrack)
    {
        clsid = CLSID_XDirectMusicSegmentTriggerTrack;
    }
    else if (clsid == CLSID_DirectMusicLyricsTrack)
    {
        clsid = CLSID_XDirectMusicLyricsTrack;
    }
    else if (clsid == CLSID_DirectMusicParamControlTrack)
    {
        clsid = CLSID_XDirectMusicParamControlTrack;
    }
#endif
    return DynamicTrampoline( clsid, pUnkOuter, dwClsContext, riid, ppv );
}

/////////////////////////////////////////////////////////////////////////////
//
// @interface IDMUSProdConductor | Coordinates global access to the DirectMusic Engine for other DirectMusic Producer components.
//
// @base public | IUnknown
//
// @meth HRESULT | GetPerformanceEngine | Returns an AddRef()'d reference to the
//		IDirectMusicPerformance interface.
// @meth HRESULT | GetPort | Returns an AddRef()'d pointer to the first active
//		port that supports DLS.
// @meth HRESULT | RegisterTransport | Adds a transport to the list of items in
//		the Transport Control toolbar's combo box.  
// @meth HRESULT | UnRegisterTransport | Removes a transport from the list of items
//		in the Transport Control toolbar's combo box.
// @meth HRESULT | SetActiveTransport | Sets the owner of the Transport Control toolbar's
//		controls to a specified transport.
// @meth HRESULT | IsTransportPlaying | Helps determine whether or not music is playing.
// @meth HRESULT | PlayMIDIEvent | Plays a MIDI event.
// @meth HRESULT | SetBtnStates | Sets the button states of a transport.
// @meth HRESULT | SetTempo | Sets the tempo displayed in the Transport Control toolbar.
// @meth HRESULT | RegisterNotify | Registers an interface to receive a specific notification
//		from the performance engine.
// @meth HRESULT | UnregisterNotify | Stops a specific notification from being sent to an
//		interface.
// @meth HRESULT | SetTransportName | Updates the name of a transport that is displayed in
//		the Transport Control toolbar's combo box.
// @meth HRESULT | TransportStopped | Notifies Conductor that a transport has stopped
//		playing.
// @meth HRESULT | GetTransitionOptions | Returns a structure containing the transition options
//		set for the Transport Control toolbar's Transition button.
// @meth HRESULT | RegisterSecondaryTransport | Adds a secondary transport to the list of items in
//		the Secondary Segment toolbar's combo boxes.
// @meth HRESULT | UnRegisterSecondaryTransport | Removes a secondary transport from the list of items in
//		the Secondary Segment toolbar's combo boxes.
// @meth HRESULT | SetSecondaryTransportName | Update the name of a secondary transport that is
//		displayed in the Secondary Segment toolbar's combo boxes.
// @meth HRESULT | IsSecondaryTransportPlaying | Helps determine whether or not a secondary segment
//		is playing.
// @meth HRESULT | SetPChannelThru | Starts a thru connection from a specified MIDI input channel to a
//		specified output PChannel.
// @meth HRESULT | CancelPChannelThru | Stops the thru connection from a specified MIDI input channel.
// @meth HRESULT | IsTrackCursorEnabled | Queries the state of the Transport Options toolbar's Track Cursor button.
//
// @xref  <i IDMUSProdTransport>, <i IDMUSProdSecondaryTransport>, <i IDMUSProdNotifyCPt>
//
/////////////////////////////////////////////////////////////////////////////
//
// @enum ButtonStateFlags | State flags for the toolbar buttons
//
//      @emem BS_NO_AUTO_UPDATE | Don't automatigically update the transport buttons from the state
//			of the DirectMusic Performance engine.
//      @emem BS_PLAY_ENABLED | Enable the play button
//      @emem BS_PLAY_CHECKED | Depress the play button
//      @emem BS_STOP_ENABLED | Enable the stop button
//      @emem BS_STOP_CHECKED | Depress the stop button
//      @emem BS_REC_ENABLED | Enable the record button
//      @emem BS_REC_CHECKED | Depress the record button
//      @emem BS_TRANS_ENABLED	| Enable the transition button
//      @emem BS_TRANS_CHECKED	| Depress the transition button
//
// @comm If BS_NO_AUTO_UPDATE is not set, then only the BS_REC_* flags are used.  If BS_NO_AUTO_UPDATE
//		is set, then all BS_* flags are used.
//
// @xref <om IDMUSProdConductor.RegisterTransport>, <om IDMUSProdConductor.SetActiveTransport>,
//		<om IDMUSProdConductor.SetBtnStates>
//
/////////////////////////////////////////////////////////////////////////////
//
// @enum ConductorTransitionFlags | Flags used for setting the transition type
//		@emem TRANS_END_OF_SEGMENT | Transition at the end of the segment queue.
//		@emem TRANS_REGULAR_PATTERN	| Transition using a regular pattern, not an Intro/End/Fill/Break.
//		@emem TRANS_NO_TRANSITION | Don't compose a transition - just switch to
//			the next segment at the specified boundary.
//		@emem TRANS_SEGF_DEFAULT | Transition using the DMUS_SEGF_DEFAULT flag.
//		@emem TRANS_SEGF_NOINVALIDATE | Transition using the DMUS_SEGF_NOINVALIDATE flag.
//
// @xref  <om IDMUSProdConductor.GetTransitionOptions>
//
/////////////////////////////////////////////////////////////////////////////
//
// @struct ConductorTransitionOptions | Contains the transition options set via
//		the Transport Control toolbar's Transition button.
//
// @comm <p wPatternType> may either contain one of the DMUS_COMMANDT_TYPES flags or
//		a custom embellishment id.  Values of 100 through 199 signify a custom
//		embellishment id.
//
// @field DWORD | dwBoundaryFlags | One of DMUS_COMPOSEF_IMMEDIATE, DMUS_COMPOSEF_GRID,
//		DMUS_COMPOSEF_BEAT, DMUS_COMPOSEF_ALIGN, DMUS_COMPOSEF_MEASURE, DMUS_COMPOSEF_DEFAULT,
//		or DMUS_COMPOSEF_NONE.
//      Previous flags are mutually exclusive.  One or more of the following flags may also
//		be set: DMUS_COMPOSEF_ENTIRE_TRANSITION, DMUS_COMPOSEF_1BAR_TRANSITION, 
//		DMUS_COMPOSEF_ENTIRE_ADDITION, DMUS_COMPOSEF_1BAR_ADDITION.
// @field WORD | wPatternType | One of the DMUS_COMMANDT_TYPES flags or the custom embellishment id.
// @field DWORD | dwFlags | More flags, defined in the <t ConductorTransitionFlags> enumeration.
// @field DWORD | pDMUSProdNodeSegmentTransition | A pointer to the <i IDMUSProdNode> interface of
//		the node that contains the transition segment to be used.
//
// @xref  <om IDMUSProdConductor.GetTransitionOptions>
//
/////////////////////////////////////////////////////////////////////////////


//#include <fstream.h>
CMIDIInputContainer* g_pMIDIInputContainer = NULL;
CConductor* g_pconductor = NULL;
#define MIDI_CCHANGE    0xB0

CDownloadedInstrumentList::CDownloadedInstrumentList()
{
	m_pDMPort = NULL;
}

CDownloadedInstrumentList::~CDownloadedInstrumentList()
{
	if( m_pDMPort )
	{
		while( !m_lstDownloadedInstruments.IsEmpty() )
		{
			IDirectMusicDownloadedInstrument *pDownloadedInstrument = m_lstDownloadedInstruments.RemoveHead();
			m_pDMPort->UnloadInstrument( pDownloadedInstrument );
			pDownloadedInstrument->Release();
		}
		RELEASE( m_pDMPort );
	}
}

// GetPortCaps - Gets a port's DMUS_PORTCAPS structure

bool GetPortCaps( IDirectMusic *pDMusic, const REFGUID rguidPort, DMUS_PORTCAPS *pdmPortCaps )
{
	// Try and find the portcaps for the default synth
	DMUS_PORTCAPS dmPortCaps;

	DWORD dwIndex = 0;
	while( true )
	{
		ZeroMemory( &dmPortCaps, sizeof( DMUS_PORTCAPS ) );
		dmPortCaps.dwSize = sizeof( DMUS_PORTCAPS );
		if( S_OK == pDMusic->EnumPort( dwIndex, &dmPortCaps ) )
		{
			if( dmPortCaps.guidPort == rguidPort )
			{
				if( pdmPortCaps )
				{
					memcpy( pdmPortCaps, &dmPortCaps, sizeof( DMUS_PORTCAPS ) );
				}
				return true;
			}
			dwIndex++;
		}
		else
		{
			break;
		}
	}

	return false;
}

/////////////////////////////////////////////////////////////////////////////
// GetRegString - Gets a string from the system registry 

BOOL GetRegString( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpValueName, LPTSTR lpszString, LPDWORD lpdwSize )
{
	HKEY  hKeyOpen;
	LONG  lResult;
	BOOL  fSuccess = FALSE;
	DWORD dwType;

	lResult = ::RegOpenKeyEx( hKey, lpSubKey, 0, KEY_READ, &hKeyOpen );
	if( lResult == ERROR_SUCCESS )
	{
		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, 0, &dwType, (BYTE *)lpszString, lpdwSize );

		if( (dwType == REG_SZ) && (lResult == ERROR_SUCCESS) )
		{
			fSuccess = TRUE;
		}

		::RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

BOOL GetRegDWORD( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpValueName, DWORD *pdwData )
{
	HKEY  hKeyOpen;
	LONG  lResult;
	BOOL  fSuccess = FALSE;
	DWORD dwType = 0, dwSize = sizeof(DWORD);

	lResult = ::RegOpenKeyEx( hKey, lpSubKey, 0, KEY_READ, &hKeyOpen );
	if( lResult == ERROR_SUCCESS )
	{
		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, 0, &dwType, (BYTE *)pdwData, &dwSize );

		if( (dwType == REG_DWORD) && (lResult == ERROR_SUCCESS) )
		{
			fSuccess = TRUE;
		}

		::RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

BOOL GetRegData( HKEY hKey, LPCTSTR lpValueName, BYTE **ppbData, DWORD *pdwSize )
{
	LONG  lResult;
	BOOL  fSuccess = FALSE;
	DWORD dwType = 0;

	lResult = ::RegQueryValueEx( hKey, lpValueName, 0, &dwType, NULL, pdwSize );

	if( (dwType == REG_BINARY) && (lResult == ERROR_SUCCESS) )
	{
		*ppbData = new BYTE[ *pdwSize ];
		lResult = ::RegQueryValueEx( hKey, lpValueName, 0, &dwType, *ppbData, pdwSize );

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}
	}

	return fSuccess;
}

int GetIndexByDataPtr( CComboBox &combobox, void *pData )
{
	if( combobox.GetSafeHwnd() )
	{
		for( int i=0; i < combobox.GetCount(); i++ )
		{
			if( combobox.GetItemDataPtr( i ) == pData )
			{
				return i;
			}
		}
	}
	return -1;
}

CWnd *CreateParentWindow( void )
{
	CWnd* pWndParent = new CWnd;
	if( pWndParent )
	{
		if( !pWndParent->CreateEx(0, AfxRegisterWndClass(0), NULL, WS_OVERLAPPED, 0, 0, 0, 0, NULL, NULL) )
		{
			delete pWndParent;
			pWndParent = NULL;
		}
	}
	return pWndParent;
}

CConductor::CConductor()
{
    m_pFrameWork = NULL;
	m_hWndFramework = NULL;

	m_pDMPerformance = NULL;
	m_pDMusic = NULL;
	m_pDMAudiopath = NULL;
	m_pAudiopathListItem = 0;

	m_hNotifyEvent = NULL;
	m_hNotifyExitEvent = NULL;
	m_pOutputTool = NULL;
	m_pMIDISaveTool = NULL;
	m_pNotifyTool = NULL;

	m_pIUnknownMIDIExport = NULL;
	m_pISegStateMIDIExport = NULL;
	m_fLeadInMeasureMIDIExport = FALSE;

	m_pToolbarHandler = NULL;
	m_pOptionsToolbarHandler = NULL;
	m_pStatusToolbarHandler = NULL;
	m_pSynthStatusToolbar = NULL;
	m_pWaveRecordToolbar = NULL;
	//m_fAudiopathHasDumpDMOs = false;
    g_pconductor = this;
	m_rpActive = NULL;
	m_rpPlaying = NULL;
	m_fShutdown = FALSE;
	m_dblTempo = 120;
    m_fOutputEnabled = FALSE;
	m_fLatencyAppliesToAllAudiopaths = false;
	m_dwLatency = 100;
	m_dwDefaultLatency = LATENCY_UNSUPPORTED;
	m_pPhoneyDSound = NULL;

	// Set tempo ratio
	DWORD dwData;
	if( GetNewRegDWORD( _T("TempoRatio"), &dwData ) )
	{
		if( dwData < int( DMUS_MASTERTEMPO_MIN * 100.0 ) )
		{
			m_nRatio = int( DMUS_MASTERTEMPO_MIN * 100.0 );
		}
		else if( dwData > int( DMUS_MASTERTEMPO_MAX * 100.0 ) )
		{
			m_nRatio = int( DMUS_MASTERTEMPO_MAX * 100.0 );
		}
		else
		{
			m_nRatio = dwData;
		}
	}
	else
	{
		m_nRatio = 50;
	}

	// Set Transition options
	m_TransitionOptions.dwBoundaryFlags = DMUS_COMPOSEF_DEFAULT | DMUS_COMPOSEF_AFTERPREPARETIME;
	if( GetNewRegDWORD( _T("TransitionBoundary"), &dwData ) )
	{
		m_TransitionOptions.dwBoundaryFlags = dwData;
	}
	m_TransitionOptions.wPatternType = 0;
	if( GetNewRegDWORD( _T("TransitionPattern"), &dwData ) )
	{
		m_TransitionOptions.wPatternType = (WORD)dwData;
	}
	m_TransitionOptions.dwFlags = TRANS_NO_TRANSITION;
	if( GetNewRegDWORD( _T("TransitionFlags"), &dwData ) )
	{
		m_TransitionOptions.dwFlags = dwData;
	}
	m_TransitionOptions.pDMUSProdNodeSegmentTransition = NULL;
	// TODO: Load transition segment?

	// Set metronome options
	m_fMetronomeEnabled = FALSE;
	if( GetNewRegDWORD( _T("MetronomeEnabled"), &dwData ) && (dwData != 0) )
	{
		m_fMetronomeEnabled = TRUE;
	}
 
	m_bMetronomeNoteOther = 37;
	if( GetNewRegDWORD( _T("MetronomeNote"), &dwData ) )
	{
		m_bMetronomeNoteOther = BYTE( min( dwData, 127 ) );
	}

	m_bMetronomeNoteOne = 36;
	if( GetNewRegDWORD( _T("MetronomeOneNote"), &dwData ) )
	{
		m_bMetronomeNoteOne = BYTE( min( dwData, 127 ) );
	}

	m_bMetronomeVelocityOther = 100;
	if( GetNewRegDWORD( _T("MetronomeVelocity"), &dwData ) )
	{
		m_bMetronomeVelocityOther = BYTE( min( dwData, 127 ) );
	}

	m_bMetronomeVelocityOne = 117;
	if( GetNewRegDWORD( _T("MetronomeOneVelocity"), &dwData ) )
	{
		m_bMetronomeVelocityOne = BYTE( min( dwData, 127 ) );
	}

	m_dwMetronomePChannel = 9;
	if( GetNewRegDWORD( _T("MetronomePChannel"), &dwData ) )
	{
		m_dwMetronomePChannel = min( dwData,  998 );
	}

	// Set Audio Parameters
#ifndef DMP_XBOX
	m_dwSampleRate = 22050;
#else
	m_dwSampleRate = 48000;
#endif
	if( GetNewRegDWORD( _T("SampleRate"), &dwData ) )
	{
		// Limit sample rate to valid range (set by DMusic performance)
		m_dwSampleRate = min( max( 11025, dwData ), 96000);
	}

	m_dwVoices = 64;
	if( GetNewRegDWORD( _T("Voices"), &dwData ) )
	{
		m_dwVoices = max( 1, min( dwData, 999));
	}

	m_clsidDefaultSynth = GUID_Synth_Default;
	DWORD dwCbData = sizeof(TCHAR) * MAX_PATH;
	TCHAR szGuid[MAX_PATH];
	if( GetNewRegString( _T("DMDefaultPort"), szGuid, &dwCbData ) )
	{
		// Parse port GUID
		GUID guidPortGUID;
		OLECHAR psz[MAX_PATH];
		MultiByteToWideChar( CP_ACP, 0, szGuid, -1, psz, MAX_PATH);

		if( SUCCEEDED( CLSIDFromString(psz, &guidPortGUID) ) )
		{
			// Copy the guid to m_clsidDefaultSynth
			m_clsidDefaultSynth = guidPortGUID;

			// Ensure it's not all zeros
			if( GUID_AllZeros == m_clsidDefaultSynth )
			{
				m_clsidDefaultSynth = GUID_Synth_Default;
			}
		}
	}

	// Set Download flags
#ifndef DMP_XBOX
	m_fDownloadGM = TRUE;
#else
	m_fDownloadGM = FALSE;
#endif
	m_fDownloadDLS = TRUE;
	if( GetNewRegDWORD( _T("DownloadGM"), &dwData ) )
	{
		m_fDownloadGM = (dwData != 0);
	}
	if( GetNewRegDWORD( _T("DownloadDLS"), &dwData ) )
	{
		m_fDownloadDLS = (dwData != 0);
	}


	// Set Phoney DSound option
	g_fUsePhoneyDSound = m_fUsePhoneyDSound = false;
	if( GetNewRegDWORD( _T("UsePhoneyDSound"), &dwData ) && (dwData != 0) )
	{
		g_fUsePhoneyDSound = m_fUsePhoneyDSound = true;
	}
	ZeroMemory( g_szPhoneyDSoundFilterName, sizeof(TCHAR) * MAX_PATH );
	dwCbData = sizeof(TCHAR) * MAX_PATH;
	if( GetNewRegString( _T("PhoneyDSoundDefaultPort"), szGuid, &dwCbData ) )
	{
		// Copy the path to g_szPhoneyDSoundFilterName
		strcpy( g_szPhoneyDSoundFilterName, szGuid );
	}

	::InitializeCriticalSection( &m_csNotifyEntry );
	::InitializeCriticalSection( &m_csAudiopath );
	::InitializeCriticalSection( &m_csAudiopathList );
}

CConductor::~CConductor()
{
	ASSERT( m_fShutdown );

	ReleaseAll();

	if( DynamicTrampoline )
	{
		DetourRemove((PBYTE)DynamicTrampoline, (PBYTE)DynamicDetour);
		DynamicTrampoline = NULL;
	}

	if( g_fKslInitialized )
	{
		KslCloseKsLib();
		g_fKslInitialized = false;
	}

	::DeleteCriticalSection( &m_csAudiopathList );
	::DeleteCriticalSection( &m_csAudiopath );
	::DeleteCriticalSection( &m_csNotifyEntry );
}

void CConductor::ReleaseAll( void )
{
    CleanUp();

	RELEASE( m_pOutputTool );
	RELEASE( m_pMIDISaveTool );
	RELEASE( m_pNotifyTool );

	// Remove any existing default Audio Path
	if (m_pDMPerformance)
	{
		m_pDMPerformance->SetDefaultAudioPath( NULL );
	}

	// Unload any instruments previously downloaded
	while( !m_lstDownloadedInstrumentList.IsEmpty() )
	{
		delete m_lstDownloadedInstrumentList.RemoveHead();
	}

	//RELEASE( m_pAudiopathNode ); // Just a weak reference!

	::EnterCriticalSection( &m_csAudiopath );
	RELEASE( m_pDMAudiopath );
	::LeaveCriticalSection( &m_csAudiopath );

	while( !m_lstAudiopaths.IsEmpty() )
	{
		delete m_lstAudiopaths.RemoveHead();
	}

	RELEASE( m_pDMPerformance );

	RELEASE( m_pDMusic );

	RELEASE( m_pFrameWork );

	RELEASE( m_pPhoneyDSound );

#ifdef _DEBUG
	/*
	while( !m_lstITransportRegEntry.IsEmpty() )
	{
		BSTR name;
		char buf[100];
		IDMUSProdTransport *pTransport;
		m_lstITransportRegEntry.RemoveHead()->GetTransport( &pTransport );
		if( pTransport )
		{
			pTransport->GetName( &name );
			lstrcpy( buf, (char *)name );
			SysFreeString( name );
			lstrcat( buf, " did not unregister its transport interface with Conductor." );
			AfxMessageBox( buf );
		}
	}
	*/
#endif
	// BUGBUG: This will leak memory if not all transports removed themselves?
	m_lstITransportRegEntry.RemoveAll();
    g_pconductor = NULL;
}

HRESULT CConductor::InitializeDirectMusic( CString &strError )
{
	ASSERT( m_pFrameWork != NULL );
	if ( m_pFrameWork == NULL )
	{
		strError.LoadString( IDS_ERROR_NULLFRAMEWORK );
		return E_UNEXPECTED;
	}
	
#ifdef DMP_XBOX 
    // XBOX always needs the CoCreate reroute so it can use its own dmime.dll.
	if( DynamicTrampoline == NULL )
	{
		HRESULT (STDAPICALLTYPE *DynamicTarget)(IN REFCLSID rclsid, IN LPUNKNOWN pUnkOuter,
						IN DWORD dwClsContext, IN REFIID riid, OUT LPVOID FAR* ppv) = &CoCreateInstance;
		DynamicTrampoline = (FUNCPTR_CoCreate)DetourFunction( (PBYTE)DynamicTarget, (PBYTE)DynamicDetour );
	}
#endif

	// Get the DirectMusic object
	HRESULT hr = m_pFrameWork->GetSharedObject( CLSID_DirectMusic, IID_IDirectMusic8, 
												(LPVOID*)&m_pDMusic);
	if ( FAILED(hr) )
	{
		hr = CoCreateInstance(CLSID_DirectMusic,
								  NULL,
								  CLSCTX_INPROC_SERVER,
								  IID_IDirectMusic8,
								  (LPVOID*)&m_pDMusic);
		if ( FAILED(hr) )
		{
			strError.LoadString( IDS_ERR_CREATE_DMUSIC );
			return hr;
		}
	}

	// Get Producer's window handle
	ASSERT( m_pToolbarHandler );
	if( !m_pToolbarHandler )
	{
		strError.LoadString( IDS_ERROR_NULLTOOLBAR );
		return E_UNEXPECTED;
	}
	m_hWndFramework = ::GetParent( m_pToolbarHandler->m_hWnd );

	// Set up DirectSound
	hr = m_pDMusic->SetDirectSound( NULL, m_hWndFramework );
#ifdef _DEBUG
	if( FAILED(hr) )
	{
		TRACE("Conductor: m_pDMusic->SetDirectSound() failed with %x.\n", hr);
	}
#endif

	// DeActivate DirectMusic
	hr = m_pDMusic->Activate( FALSE );
#ifdef _DEBUG
	if( FAILED(hr) )
	{
		TRACE("Conductor: m_pDMusic->Activate() failed with %x.\n", hr);
	}
#endif

	// Create and initialize the performance
	hr = CoCreateInstance( CLSID_DirectMusicPerformance, 
						  NULL, 
						  CLSCTX_ALL, 
						  IID_IDirectMusicPerformance8,
						  (void**)&m_pDMPerformance );
	if ( FAILED(hr) )
	{
		strError.LoadString( IDS_ERR_CREATE_PERF );
		return hr;
	}

	// Query for the base IDirectMusic interface
	IDirectMusic *pDirectMusic;
	if( FAILED( m_pDMusic->QueryInterface( IID_IDirectMusic, (void **)&pDirectMusic ) ) )
	{
		strError.LoadString( IDS_ERR_INIT_PERF );
		return hr;
	}

	// Initialize the performance
	DMUS_AUDIOPARAMS dmAudioParams;
	ZeroMemory( &dmAudioParams, sizeof( DMUS_AUDIOPARAMS ) );
	dmAudioParams.dwSize = sizeof( DMUS_AUDIOPARAMS );
	GetAudioParams( &dmAudioParams );

	// Initialize default latency
	m_dwDefaultLatency = LATENCY_UNSUPPORTED;
    g_fUsePhoneyDSound = m_fUsePhoneyDSound;
	if( m_fUsePhoneyDSound )
	{
		if( !m_pPhoneyDSound )
		{
			m_pPhoneyDSound = new CPhoneyDSound;

			if( DynamicTrampoline == NULL )
			{
				HRESULT (STDAPICALLTYPE *DynamicTarget)(IN REFCLSID rclsid, IN LPUNKNOWN pUnkOuter,
								IN DWORD dwClsContext, IN REFIID riid, OUT LPVOID FAR* ppv) = &CoCreateInstance;
				DynamicTrampoline = (FUNCPTR_CoCreate)DetourFunction( (PBYTE)DynamicTarget, (PBYTE)DynamicDetour );
			}
		}

		if( m_pPhoneyDSound )
		{
			IDirectSound *pDSound;
			m_pPhoneyDSound->QueryInterface(IID_IDirectSound,(void **)&pDSound);
			hr = m_pDMPerformance->InitAudio( &pDirectMusic, &pDSound, m_hWndFramework, 0, 0, DMUS_AUDIOF_ALL, &dmAudioParams);
			pDSound->Release();
		}
		else
		{
			hr = m_pDMPerformance->InitAudio( &pDirectMusic, NULL, m_hWndFramework, 0, 0, DMUS_AUDIOF_ALL, &dmAudioParams );
		}
	}
	else
	{
		hr = m_pDMPerformance->InitAudio( &pDirectMusic, NULL, m_hWndFramework, 0, 0, DMUS_AUDIOF_ALL, &dmAudioParams );
	}
	
	// Release the base IDirectMusic interface
	RELEASE( pDirectMusic );

	// Check to see if the performance initialized correctly.
	if( FAILED(hr) )
	{
		strError.LoadString( IDS_ERR_INIT_PERF );
		return hr;
	}

	// Ensure AutoDownload is NOT set
	BOOL fAutoDownload;
	fAutoDownload = FALSE;
	m_pDMPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAutoDownload, sizeof(BOOL) );

	DWORD dwData;
	if( GetNewRegDWORD( _T("TempoRatioEnabled"), &dwData ) && (dwData != 0) )
	{
		float fModifier;
		fModifier = float(m_nRatio) / 100.0f;
		m_pDMPerformance->SetGlobalParam( GUID_PerfMasterTempo, &fModifier, sizeof(float) );
	}

	// Read in the default DirectMusic audio path from the registry
	// If we don't have a DirectMusic MIDI input port, try and find one.
	IDirectMusicAudioPath *pAudiopath = NULL;
	ReadDefaultDirectMusicAudiopath( &pAudiopath );

	// We may not have an audio path, if the default synth doesn't support audiopaths
	// ASSERT( pAudiopath );

	// Get 'Latency' value
	if( GetNewRegDWORD( _T("Latency"), &dwData ) && (dwData != 0) )
	{
		m_dwLatency = dwData;

		if( m_fUsePhoneyDSound )
		{
			g_dwLatency = dwData;
		}
	}

	// Get 'Update Latency' state
	if( GetNewRegDWORD(_T("ApplyLatencyToAllAudiopaths"), &dwData ) )
	{
		m_fLatencyAppliesToAllAudiopaths = (dwData != 0) ? true : false;
	}

	// Activate the Audio path.  This will overwrite m_dwLatency if m_fLatencyApplies...Paths is not set
	ActivateAudiopath( pAudiopath );

	// Release our reference to the Audio Path
	RELEASE( pAudiopath );

	// Create the output status tool and the MIDI save tool
	m_pOutputTool = new COutputTool;
	m_pMIDISaveTool = new MIDISaveTool;
	m_pNotifyTool = new CNotifyTool;

	// Add output status tool and MIDI save tool to the audio path
	AddTools( m_pDMAudiopath, m_pOutputTool, m_pMIDISaveTool );

	IDirectMusicGraph *pGraph = NULL;
	if( FAILED( m_pDMPerformance->GetGraph( &pGraph ) ) )
	{
		if( SUCCEEDED( ::CoCreateInstance( CLSID_DirectMusicGraph, NULL, CLSCTX_INPROC_SERVER, IID_IDirectMusicGraph, (void **)&pGraph ) ) )
		{
			if( FAILED( m_pDMPerformance->SetGraph( pGraph ) ) )
			{
				pGraph->Release();
				pGraph = NULL;
			}
		}
	}

	if( pGraph )
	{
		pGraph->InsertTool( m_pNotifyTool, NULL, 0, 0 );
		pGraph->Release();
	}

	// Initialize the notification event handler
	m_hNotifyEvent = ::CreateEvent( NULL, FALSE, FALSE, NULL );
	if( m_hNotifyEvent )
	{
		m_pDMPerformance->SetNotificationHandle( m_hNotifyEvent, 0 );
		m_pDMPerformance->AddNotificationType( GUID_NOTIFICATION_SEGMENT );
		m_pDMPerformance->AddNotificationType( GUID_NOTIFICATION_MEASUREANDBEAT );
		m_pDMPerformance->AddNotificationType( GUID_NOTIFICATION_PERFORMANCE );
		// Start Notify thread
		CWinThread *pThread = ::AfxBeginThread( NotifyThreadProc, this );
		if( pThread == NULL )
		{
			TRACE("Conductor: Failed to start Notify thread.\n");
		}
		else
		{
			pThread->m_bAutoDelete = TRUE;
		}
	}

	m_fOutputEnabled = TRUE;

	return S_OK;
	//return hr;
}

HRESULT CConductor::ActivateXboxPath(DWORD dwXboxPath)

{
    // Create the equivalent audiopath on the XBOX itself. 
	IDirectMusicAudioPath *pIDirectMusicAudioPath = NULL;
	HRESULT hr = m_pDMPerformance->GetDefaultAudioPath( &pIDirectMusicAudioPath );
	IKsControl *pIKsControl = NULL;
	if( SUCCEEDED(hr) )
	{
		hr = pIDirectMusicAudioPath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_PORT, 0, CLSID_XboxSynth, 0, IID_IKsControl, (void **)&pIKsControl );
	    if( SUCCEEDED(hr) )
	    {
		    KSPROPERTY ksProperty;
		    ksProperty.Set = GUID_Xbox_PROP_XboxAudioPath;
            ksProperty.Flags = KSPROPERTY_TYPE_SET;
		    ksProperty.Id = 0;
		    DWORD dwDataSize = 0;
		    hr = pIKsControl->KsProperty( &ksProperty, sizeof(KSPROPERTY), &dwXboxPath, sizeof(DWORD), &dwDataSize ); 
	        pIKsControl->Release();
        }
        pIDirectMusicAudioPath->Release();
    }
    return hr;
}



HRESULT CConductor::ActivateAudiopath( IDirectMusicAudioPath *pAudiopath, bool fSendNotificationsAndDownloadGM )
{
	if( !m_pDMPerformance )
	{
		ASSERT( FALSE );
		return E_FAIL;
	}

	// Double-check to make sure something actually should change
	if( pAudiopath == m_pDMAudiopath )
	{
		return S_FALSE;
	}

	// Stop everything to get rid of stuck notes
	StopAllNotesAndSegments();

	// Stop exporting wave and/or MIDI files
	if( m_pWaveRecordToolbar )
	{
		m_pWaveRecordToolbar->StopAll();
	}

	if( fSendNotificationsAndDownloadGM )
	{
		BroadCastPortRemovalNotification();
	}

	// Try and set pAudiopath as the default audio path
	if( SUCCEEDED( m_pDMPerformance->SetDefaultAudioPath( pAudiopath ) ) )
	{
		::EnterCriticalSection( &m_csAudiopath );

		// Release the existing audio path
		RELEASE( m_pDMAudiopath );

		// Clear the pointer to the last sampled output port
		g_rpLastSampledPort = NULL;

		// Save a pointer to the new audio path
		m_pDMAudiopath = pAudiopath;
		if( m_pDMAudiopath )
		{
			m_pDMAudiopath->AddRef();
		}

		::LeaveCriticalSection( &m_csAudiopath );

		// Add output status tool and MIDI save tool to the audio path
		if( pAudiopath )
		{
			AddTools( pAudiopath, m_pOutputTool, m_pMIDISaveTool );
		}

		// Now, download GM (if necessary)
		if( fSendNotificationsAndDownloadGM )
		{
			DownOrUnLoadGM();
		}

		// Initialize the performance
		DMUS_AUDIOPARAMS dmAudioParams;
		ZeroMemory( &dmAudioParams, sizeof( DMUS_AUDIOPARAMS ) );
		dmAudioParams.dwSize = sizeof( DMUS_AUDIOPARAMS );
		GetAudioParams( &dmAudioParams );

		// If the latency value has not yet been set,
		// or if the default synth doesn't support audiopaths
		if( (m_dwDefaultLatency == LATENCY_UNSUPPORTED)
		||	(dmAudioParams.dwFeatures == 0) )
		{
		// Get the default latency
		m_dwDefaultLatency = LATENCY_UNSUPPORTED;

		if( pAudiopath )
		{
			// A flag to show whether or not we have the latency
			bool fGotLatency = false;

			// Iterate through the default Audiopath's ports
			IDirectMusicPort *pDMPort = NULL;
			DWORD dwIndex = 0;
			while( S_OK == pAudiopath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_PORT, 0, GUID_All_Objects, dwIndex, IID_IDirectMusicPort, (void **)&pDMPort ) )
			{
				// Verify we have a valid port pointer
				ASSERT( pDMPort );

				IKsControl *pIKsControl;
				HRESULT hr = pDMPort->QueryInterface(IID_IKsControl, (void**)&pIKsControl);
				if (SUCCEEDED(hr)) 
				{
					KSPROPERTY ksp;
					ULONG cb;
					DWORD dwLatency;

					// Get the latency
					ZeroMemory(&ksp, sizeof(ksp));
					ksp.Set   = GUID_DMUS_PROP_WriteLatency;
					ksp.Id    = 0;
					ksp.Flags = KSPROPERTY_TYPE_GET;

					if( SUCCEEDED( pIKsControl->KsProperty(&ksp,
										 sizeof(ksp),
										 (LPVOID)&dwLatency,
										 sizeof(dwLatency),
										 &cb) ) )
					{
						if( !fGotLatency )
						{
							m_dwDefaultLatency = dwLatency;
							fGotLatency = true;
						}
						else
						{
							m_dwDefaultLatency = max( m_dwDefaultLatency, dwLatency );
						}
					}

					pIKsControl->Release();
				}

				// Release the port
				pDMPort->Release();

				// Go on to the next port in the audio path
				dwIndex++;
			}
		}

		// End latency and default synth check
		}

		// Update the ports' latency, if necessary
		if( m_fUsePhoneyDSound
		||	m_dwDefaultLatency != LATENCY_UNSUPPORTED )
		{
			// If the latency value should not be applied to all audiopaths
			if( !m_fLatencyAppliesToAllAudiopaths )
			{
				// If the default latency is valid
				if( m_dwDefaultLatency != LATENCY_UNSUPPORTED )
				{
					// Reset the current latency value
					m_dwLatency = m_dwDefaultLatency;
				}
				else
				{
					// Otherwise, we're using the Phoney DSound driver
					ASSERT(m_fUsePhoneyDSound);
					// Reset the current latency value
					m_dwLatency = DEFAULT_PHONEY_DS_LATENCY;
				}
			}

			// In all cases, reset the synth's latency
			UpdateLatency();
		}

		// TODO: Write the ID to the registry
		//SetNewRegDWORD(_T("OutputDevice"), pAudiopath, TRUE);

		// Write the configuration to the registry
		WriteDefaultDirectMusicAudiopath();

		// Check if the audiopath has any dump DMOs in it
		/*
		m_fAudiopathHasDumpDMOs = false;
		if( pAudiopath )
		{
			DWORD dwBufferIndex = 0;
			IDirectSoundBuffer* pIDirectSoundBuffer = NULL;
			while( !m_fAudiopathHasDumpDMOs
			&&	(S_OK == pAudiopath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_BUFFER, dwBufferIndex,
				 GUID_All_Objects, 0, IID_IDirectSoundBuffer, (void**) &pIDirectSoundBuffer )) )
			{
				IUnknown* pIUnknown = NULL;
				if( S_OK == pAudiopath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_BUFFER_DMO, dwBufferIndex,
					GUID_DSFX_STANDARD_DUMP, 0, IID_IUnknown, (void**) &pIUnknown ) )
				{
					m_fAudiopathHasDumpDMOs = true;
					pIUnknown->Release();
				}

				dwBufferIndex++;
				pIDirectSoundBuffer->Release();
			}
			dwBufferIndex = 0;
			while( !m_fAudiopathHasDumpDMOs
			&&	(S_OK == pAudiopath->GetObjectInPath( 0, DMUS_PATH_MIXIN_BUFFER, dwBufferIndex,
				 GUID_All_Objects, 0, IID_IDirectSoundBuffer, (void**) &pIDirectSoundBuffer )) )
			{
				IUnknown* pIUnknown = NULL;
				if( S_OK == pAudiopath->GetObjectInPath( 0, DMUS_PATH_MIXIN_BUFFER_DMO, dwBufferIndex,
					GUID_DSFX_STANDARD_DUMP, 0, IID_IUnknown, (void**) &pIUnknown ) )
				{
					m_fAudiopathHasDumpDMOs = true;
					pIUnknown->Release();
				}

				dwBufferIndex++;
				pIDirectSoundBuffer->Release();
			}
		}
		*/

		// Update the wave record button state
		if( m_pWaveRecordToolbar )
		{
			m_pWaveRecordToolbar->UpdateRecordButtonState();
		}

		// Return that we succeeded
		return S_OK;
	}
	else
	{
		AfxMessageBox( IDS_ERR_APATH_ACTIVATE, MB_ICONEXCLAMATION | MB_OK );
		return E_FAIL;
	}
}

// add the tools to the toolgraph
void CConductor::AddToolsToToolgraph(IDirectMusicGraph *pGraph, COutputTool* pCOutputTool, MIDISaveTool* pMIDISaveTool )
{
	ASSERT( pGraph );
	if( pGraph == NULL )
	{
		return;
	}

	HRESULT hr = S_OK;

	// add the tools to the graph - they will be AddRef()'d inside the
	// InsertTool function. The second parameter, NULL, means to apply
	// the tool to all PChannel's. The third parameter, 0, is only
	// applicable if the second parameter is non-NULL. The fourth
	// parameter, 0, means to insert the tool at the beginning of
	// any list of tools inside the graph.
	if( pMIDISaveTool )
	{
		hr = pGraph->InsertTool( (IDirectMusicTool*)pMIDISaveTool, NULL, 0, 0 );

		// It's ok if the tool already exists
		if( hr == DMUS_E_ALREADY_EXISTS )
		{
			hr = S_OK;
		}
	}
	if( pCOutputTool
	&&	SUCCEEDED ( hr ) )
	{
		hr = pGraph->InsertTool( (IDirectMusicTool*)pCOutputTool, NULL, 0, 0 );

		// It's ok if the tool already exists
		/*
		if( hr == DMUS_E_ALREADY_EXISTS )
		{
			hr = S_OK;
		}
		*/
	}
}

// add the tools to the segment state
void CConductor::AddToolsToSegState(IDirectMusicSegmentState8 *pIDirectMusicSegmentState, COutputTool* pCOutputTool, MIDISaveTool* pMIDISaveTool )
{
	ASSERT( pIDirectMusicSegmentState );
	if( pIDirectMusicSegmentState == NULL )
	{
		return;
	}

	// First, query for an IDirectMusicGraph object to hold the tool
	IDirectMusicGraph* pGraph;
	if( SUCCEEDED( pIDirectMusicSegmentState->GetObjectInPath( 0, DMUS_PATH_SEGMENT_GRAPH, 0, GUID_All_Objects, 0,
												IID_IDirectMusicGraph, (void**)&pGraph ) ) )
	{
		AddToolsToToolgraph( pGraph, pCOutputTool, pMIDISaveTool );
		pGraph->Release();
	}
	else if( SUCCEEDED( pIDirectMusicSegmentState->GetObjectInPath( 0, DMUS_PATH_AUDIOPATH_GRAPH, 0, GUID_All_Objects, 0,
												IID_IDirectMusicGraph, (void**)&pGraph ) ) )
	{
		AddToolsToToolgraph( pGraph, pCOutputTool, pMIDISaveTool );
		pGraph->Release();
	}
}

// add the tools to the audio path
void CConductor::AddTools(IDirectMusicAudioPath *pAudiopath, COutputTool* pCOutputTool, MIDISaveTool* pMIDISaveTool)
{
	if( pAudiopath == NULL )
	{
		return;
	}

	// First, query for an IDirectMusicGraph object to hold the tool
	IDirectMusicGraph* pGraph;
	if( SUCCEEDED( pAudiopath->GetObjectInPath( 0, DMUS_PATH_SEGMENT_GRAPH, 0, GUID_All_Objects, 0,
												IID_IDirectMusicGraph, (void**)&pGraph ) ) )
	{
		AddToolsToToolgraph( pGraph, pCOutputTool, pMIDISaveTool );
		pGraph->Release();
	}
	else if( SUCCEEDED( pAudiopath->GetObjectInPath( 0, DMUS_PATH_AUDIOPATH_GRAPH, 0, GUID_All_Objects, 0,
												IID_IDirectMusicGraph, (void**)&pGraph ) ) )
	{
		AddToolsToToolgraph( pGraph, pCOutputTool, pMIDISaveTool );
		pGraph->Release();
	}
}

void CConductor::SetupWaveSaveDMO( IDirectMusicAudioPath *pAudiopath )
{
	ASSERT( pAudiopath );
	if( pAudiopath == NULL )
	{
		return;
	}

	if( m_pWaveRecordToolbar )
	{
		m_pWaveRecordToolbar->StartOrStopDumpDMOsOnAudiopath( m_pWaveRecordToolbar->m_fRecordingWave ? true : false, pAudiopath );
	}
}

void ActivatePortsInAudiopath( IDirectMusicAudioPath *pAudiopath, BOOL fActivate )
{
	if( pAudiopath )
	{
		// Iterate through the default Audiopath's ports
		IDirectMusicPort *pDMPort = NULL;
		DWORD dwIndex = 0;
		while( S_OK == pAudiopath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_PORT, 0, GUID_All_Objects, dwIndex, IID_IDirectMusicPort, (void **)&pDMPort ) )
		{
			// Verify we have a valid port pointer
			if( pDMPort )
			{
				// Activate the port
				pDMPort->Activate( fActivate );

				// Release the port
				pDMPort->Release();
			}

			// Go on to the next port in the audio path
			dwIndex++;
		}
	}
}

HRESULT CConductor::SuspendOutput()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr;

	if( m_pWaveRecordToolbar )
	{
		// Stop exporting wave and/or MIDI files
		m_pWaveRecordToolbar->StopAll();

		// Disable recording wave/MIDI files
		::SendMessage( m_pWaveRecordToolbar->m_hWndToolbar, TB_ENABLEBUTTON, (WPARAM)ID_WAVE_RECORD, (LPARAM) MAKELONG(FALSE, 0) );
		::SendMessage( m_pWaveRecordToolbar->m_hWndToolbar, TB_ENABLEBUTTON, (WPARAM)ID_MIDI_EXPORT, (LPARAM) MAKELONG(FALSE, 0) );
	}

	// Suspend DMusic MIDI input
	if( g_pMIDIInputContainer )
	{
		g_pMIDIInputContainer->OnOutputDisabled();
	}

	hr = S_OK;

	// Invalidate the performance to stop stuck notes
	/*
	MUSIC_TIME mtNow;
	if( SUCCEEDED( m_pDMPerformance->GetTime( NULL, &mtNow ) ) )
	{
		m_pDMPerformance->Invalidate( mtNow, 0 );
	}
	*/

	// Deactivate all Secondary Segments
	POSITION pos = m_lstSecondaryToolbars.GetHeadPosition();
	while( pos )
	{
		m_lstSecondaryToolbars.GetNext( pos )->Activate( FALSE );
	}

	MUSIC_TIME mtNow;
	if( SUCCEEDED( m_pDMPerformance->GetTime( NULL, &mtNow ) ) )
	{
		IDirectMusicSegmentState *pIDirectMusicSegmentState;
		if( SUCCEEDED( m_pDMPerformance->GetSegmentState( &pIDirectMusicSegmentState, mtNow ) ) )
		{
			IDirectMusicSegmentState8 *pIDirectMusicSegmentState8;
			if( SUCCEEDED( pIDirectMusicSegmentState->QueryInterface( IID_IDirectMusicSegmentState8, (void **)&pIDirectMusicSegmentState8 ) ) )
			{
				IDirectMusicAudioPath *pIDirectMusicAudioPath;
				if( SUCCEEDED( pIDirectMusicSegmentState8->GetObjectInPath( 0, DMUS_PATH_AUDIOPATH, 0, GUID_All_Objects, 0, IID_IDirectMusicAudioPath, (void **)&pIDirectMusicAudioPath ) ) )
				{
					pIDirectMusicAudioPath->Activate( FALSE );
					pIDirectMusicAudioPath->Release();
				}
				pIDirectMusicSegmentState8->Release();
			}
			pIDirectMusicSegmentState->Release();
		}
	}

	::EnterCriticalSection( &m_csAudiopath );
	if( m_pDMAudiopath )
	{
		m_pDMAudiopath->Activate( FALSE );
		//ActivatePortsInAudiopath( m_pDMAudioPath, FALSE );
	}
	::LeaveCriticalSection( &m_csAudiopath );

	// Deactivate DirectSound (In this case, NULL means to deactivate DirectSound).
	// In InitializeDirectMusic(), it meant to create a default DirectSound object..
	// Not needed - DirectMusic does this automatically when all ports become inactive.
	//hr = m_pDMusic->SetDirectSound( NULL, m_hWndFramework );

	m_fOutputEnabled = FALSE;

	// Notify all other components that output has been disabled
	BroadCastPortRemovalNotification();

	return hr;
}

HRESULT CConductor::ResumeOutput()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr;

	hr = E_FAIL;
	
	// Resume DMusic MIDI input
	if( g_pMIDIInputContainer )
	{
		g_pMIDIInputContainer->OnOutputEnabled();
	}

	::EnterCriticalSection( &m_csAudiopath );
	if( m_pDMAudiopath )
	{
		m_pDMAudiopath->Activate( TRUE );
		//ActivatePortsInAudiopath( m_pDMAudioPath, TRUE );
	}
	::LeaveCriticalSection( &m_csAudiopath );

	MUSIC_TIME mtNow;
	if( SUCCEEDED( m_pDMPerformance->GetTime( NULL, &mtNow ) ) )
	{
		IDirectMusicSegmentState *pIDirectMusicSegmentState;
		if( SUCCEEDED( m_pDMPerformance->GetSegmentState( &pIDirectMusicSegmentState, mtNow ) ) )
		{
			IDirectMusicSegmentState8 *pIDirectMusicSegmentState8;
			if( SUCCEEDED( pIDirectMusicSegmentState->QueryInterface( IID_IDirectMusicSegmentState8, (void **)&pIDirectMusicSegmentState8 ) ) )
			{
				IDirectMusicAudioPath *pIDirectMusicAudioPath;
				if( SUCCEEDED( pIDirectMusicSegmentState8->GetObjectInPath( 0, DMUS_PATH_AUDIOPATH, 0, GUID_All_Objects, 0, IID_IDirectMusicAudioPath, (void **)&pIDirectMusicAudioPath ) ) )
				{
					pIDirectMusicAudioPath->Activate( TRUE );
					pIDirectMusicAudioPath->Release();
				}
				pIDirectMusicSegmentState8->Release();
			}
			pIDirectMusicSegmentState->Release();
		}
	}

	// Activate all Secondary Segments
	POSITION pos = m_lstSecondaryToolbars.GetHeadPosition();
	while( pos )
	{
		m_lstSecondaryToolbars.GetNext( pos )->Activate( TRUE );
	}

	m_fOutputEnabled = TRUE;

	// Clear all thru connections
	ClearThruConnections();

	// Notify all other components that output has been enabled
	BroadCastPortChangeNotification();

	// Enable recording wave/MIDI files
	if( m_pWaveRecordToolbar )
	{
		m_pWaveRecordToolbar->UpdateRecordButtonState();
		m_pWaveRecordToolbar->UpdateExportMIDIButtonState();
	}
	return hr;
}



//  @method HRESULT | IDMUSProdConductor | GetPerformanceEngine | This function returns an AddRef()'d
//		reference to the IDirectMusicPerformance interface.
//
//  @parm   IUnknown** | ppIPerformance | Location of an IUnknown interface from
//		which an IDirectMusicPerformance interface can be obtained. On success, the caller is responsible
//		for calling <om IUnknown::Release>() when this pointer is no longer needed.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p ppIPerformance>
//
//  @xref  <i IDMUSProdConductor>
//
HRESULT STDMETHODCALLTYPE CConductor::GetPerformanceEngine( IUnknown __RPC_FAR* __RPC_FAR* ppPerformance )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if( ppPerformance == NULL )
    {
        return E_POINTER;
    }
    *ppPerformance = m_pDMPerformance;
	if ( m_pDMPerformance != NULL )
	{
		(*ppPerformance)->AddRef();
	}
    return S_OK;
}

//  @method HRESULT | IDMUSProdConductor | GetPort | This function returns an AddRef()'d pointer to
//		the first active port that supports DLS level 2.
//
//  @parm   IUnknown** | ppIPort | Location of an IUnknown interface from which an
//		IDirectMusicPort interface can be obtained. On success, the caller is responsible for calling
//		<om IUnknown::Release>() when this pointer is no longer needed.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | A NULL was passed as <p ppIPort>
//	@rvalue DMUS_E_TYPE_UNSUPPORTED | No currently active port supports DLS level 2.
//	@rvalue DMUS_E_TYPE_DISABLED | The output is currently disabled.
//
//  @xref  <i IDMUSProdConductor>
//
HRESULT STDMETHODCALLTYPE CConductor::GetPort( IUnknown __RPC_FAR *__RPC_FAR* ppPort )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( ppPort == NULL )
	{
		return E_POINTER;
	}

	::EnterCriticalSection( &m_csAudiopath );
	IDirectMusicAudioPath *pDMAudioPath = m_pDMAudiopath;
	if( pDMAudioPath )
	{
		pDMAudioPath->AddRef();
	}
	::LeaveCriticalSection( &m_csAudiopath );

	if( !m_fOutputEnabled || !pDMAudioPath )
	{
		*ppPort = NULL;
		if( pDMAudioPath )
		{
			pDMAudioPath->Release();
		}
		return DMUS_E_TYPE_DISABLED;
	}

	// Iterate through the default Audiopath's port
	DMUS_PORTCAPS dmPortCaps;
	DWORD dwIndex = 0;
	IDirectMusicPort *pDMPort = NULL;
	while( S_OK == pDMAudioPath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_PORT, 0, GUID_All_Objects, dwIndex, IID_IDirectMusicPort, (void**)&pDMPort ) )
	{
		// Verify we have a valid port pointer
		ASSERT( pDMPort );

		// Initialize the DMUS_PORTCAPS structure
		dmPortCaps.dwSize = sizeof(DMUS_PORTCAPS);

		// Try and get the capabilities of this port, and check if it supports DLS2
		if( SUCCEEDED( pDMPort->GetCaps( &dmPortCaps ) )
		&&	(dmPortCaps.dwFlags & DMUS_PC_DLS2) )
		{
			*ppPort = pDMPort;
			pDMAudioPath->Release();
			return S_OK;
		}

		// Release the port
		pDMPort->Release();

		// Go on to the next port in the audio path
		dwIndex++;
	}

	pDMAudioPath->Release();

	*ppPort = NULL;
	return DMUS_E_TYPE_UNSUPPORTED;
}

/*======================================================================================
METHOD:  ICONDUCTOR::REGISTERTRANSPORT
========================================================================================
@method HRESULT | IDMUSProdConductor| RegisterTransport | Add <p pITransport>
	to the list of items in the Transport Control toolbar's combo box.
	If <p pITransport> is already in the combo box, increment its reference count.

@parm   IDMUSProdTransport* | pITransport | Pointer to the <i IDMUSProdTransport> interface which
		will be added to the Transport Control toolbar's combo box.
@parm	DWORD | dwFlags | A combination of <t ButtonStateFlags> determining the initial state of the
		transport buttons when this transport is active.

@rvalue S_OK | <p pITransport> was successfully added.
@rvalue E_FAIL | An error occurred, and <p pITransport> was not added to the Transport Control
	toolbar's combo box.

@xref  <i IDMUSProdConductor>, <om IDMUSProdConductor.UnRegisterTransport>,
	   <om IDMUSProdConductor.SetActiveTransport>, <om IDMUSProdConductor.SetTransportName>,
	   <om IDMUSProdConductor.IsTransportPlaying>, <om IDMUSProdConductor.TransportStopped>,
	   <i IDMUSProdTransport>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::RegisterTransport( IDMUSProdTransport *pTransport, DWORD dwFlags )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	POSITION pos = m_lstITransportRegEntry.GetHeadPosition();
	IDMUSProdTransport* pTrans;
	while( pos )
	{
		const POSITION posCurrent = pos;
		m_lstITransportRegEntry.GetNext( pos )->GetTransport( &pTrans );;
		if( pTrans == pTransport )
		{
			// Increment reference count on existing entry
			m_lstITransportRegEntry.GetAt( posCurrent )->AddRef();
			return S_OK;
		}
	}
	// Transport was not found so create and add one
	CTransportRegEntry*  pCEntry = new CTransportRegEntry( pTransport );
	if( pCEntry )
	{
		ITransportRegEntry*  pIEntry;
		if( SUCCEEDED(pCEntry->QueryInterface( IID_ITransportRegEntry, (void**) &pIEntry )) )
		{
			m_lstITransportRegEntry.AddHead( pIEntry );

			if (dwFlags & BS_NO_AUTO_UPDATE)
			{
				DWORD dwNewFlags;
				pIEntry->GetFlags( &dwNewFlags );
				dwNewFlags &= ~(B_USER_FLAGS | B_TRANS_ENABLED | B_TRANS_CHECKED);
				dwNewFlags |= B_NOT_USING_ENGINE | (dwFlags & B_USER_FLAGS);
				pIEntry->SetFlags( dwNewFlags );
			}
			else
			{
				// For setting the record button state
				DWORD dwNewFlags;
				pIEntry->GetFlags( &dwNewFlags );
				dwNewFlags &= ~(B_NOT_USING_ENGINE | B_REC_ENABLED | B_REC_CHECKED);
				dwNewFlags |= dwFlags & (B_REC_ENABLED | B_REC_CHECKED);
				if ( m_pToolbarHandler )
				{
					m_pToolbarHandler->SetStateFromEngine( &dwNewFlags );
				}
				pIEntry->SetFlags( dwNewFlags );
			}

			if ( m_pToolbarHandler )
			{
				m_pToolbarHandler->AddTransport( pIEntry );
			}

			return S_OK;
		}
	}
	return E_FAIL;
}

/*======================================================================================
METHOD:  ICONDUCTOR::UNREGISTERTRANSPORT
========================================================================================
@method HRESULT | IDMUSProdConductor| UnRegisterTransport | Remove <p pITransport> from
	the Transport Control toolbar's combo box, and stop it if it is playing.  If it was
	added more than once, remove one reference to it.  When all references are removed,
	it will then be removed from the Transport Control toolbar's combo box and stopped
	if it is playing.

@parm   IDMUSProdTransport* | pITransport | Pointer to the <i IDMUSProdTransport> interface to
		be removed from the Transport Control toolbar's combo box.

@rvalue S_OK | <p pITransport> was successfully removed.
@rvalue E_FAIL | <p pITransport> was not previously added via <om IDMUSProdConductor.RegisterTransport>.
@rvalue E_POINTER | <p pITransport> is NULL.

@xref  <i IDMUSProdConductor>, <om IDMUSProdConductor.RegisterTransport>,
	   <om IDMUSProdConductor.SetActiveTransport>, <om IDMUSProdConductor.SetTransportName>,
	   <om IDMUSProdConductor.IsTransportPlaying>, <om IDMUSProdConductor.TransportStopped>,
	   <i IDMUSProdTransport>
	
--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::UnRegisterTransport( IDMUSProdTransport *pTransport )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pTransport == NULL )
	{
		return E_POINTER;
	}

	POSITION pos = m_lstITransportRegEntry.GetHeadPosition();
	IDMUSProdTransport*  pTrans;
	while( pos )
	{
		const POSITION posCurrent = pos;
		ITransportRegEntry *pITransportRegEntry = m_lstITransportRegEntry.GetNext( pos );
		pITransportRegEntry->GetTransport( &pTrans );
		if( pTrans == pTransport )
		{
			if( pITransportRegEntry == m_rpPlaying )
			{
				pITransportRegEntry->AddRef();
				if ( pITransportRegEntry->Release() == 1 )
				{
					if (FAILED(pTransport->Stop( TRUE )))
					{
						TRACE("UnRegisterTransport: Transport failed to Stop() when unregistered\n");
					}
					else
					{
						DWORD dwFlags;
						pITransportRegEntry->GetFlags( &dwFlags );

						// If we've stopped the engine, wait for the engine to really stop
						if (!(dwFlags & B_NOT_USING_ENGINE))
						{
							short n = 0;
							while( n++ < 100 )
							{
								if( !IsEnginePlaying() )
								{
									break;
								}
								Sleep( 50 );
							}
							if (n==100)
							{
								TRACE("UnRegisterTransport Timed out while stopping playing transport\n");
							}
						}
					}
				}
			}
			if( pITransportRegEntry->Release() == 0 )
			{
				// Remove entry from registry pointer list if no more references
				m_lstITransportRegEntry.RemoveAt( posCurrent );

				if( pITransportRegEntry == m_rpActive )
				{
					m_rpActive = NULL;
				}
				if( pITransportRegEntry == m_rpPlaying )
				{
					m_rpPlaying = NULL;
				}
				if ( m_pToolbarHandler )
				{
					m_pToolbarHandler->RemoveTransport( pITransportRegEntry );
				}
				return S_OK;
			}
		}
	}
	// Entry was not found
	return E_FAIL;
}


/*======================================================================================
METHOD:  ICONDUCTOR::SETACTIVETRANSPORT
========================================================================================
@method HRESULT | IDMUSProdConductor| SetActiveTransport | Sets <p pITransport> as the active
	transport and uses <p dwFlags> to set the initial state of the Transport Control buttons.

@parm   IDMUSProdTransport* | pITransport | Pointer to the <i IDMUSProdTransport> interface to
		set as active in the Transport Control toolbar.
@parm	DWORD | dwFlags | A combination of <t ButtonStateFlags> determining the state of the
		transport buttons.

@rvalue S_OK | The active transport was successfully set.
@rvalue E_INVALIDARG | <p pITransport> was not previously added by calling
		<om IDMUSProdConductor.RegisterTransport>.

@xref  <i IDMUSProdConductor>, <om IDMUSProdConductor.RegisterTransport>,
	   <om IDMUSProdConductor.UnRegisterTransport>, <om IDMUSProdConductor.SetTransportName>,
	   <om IDMUSProdConductor.IsTransportPlaying>, <om IDMUSProdConductor.TransportStopped>,
	   <i IDMUSProdTransport>
  
--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::SetActiveTransport(
	IDMUSProdTransport* pTransport,
	DWORD btnFlags
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if( pTransport == NULL )
    {
        m_rpActive = NULL;
		if ( m_pToolbarHandler )
		{
			m_pToolbarHandler->m_comboActive.SetCurSel(-1);
			m_pToolbarHandler->SetStateAuto();
		}
		// If it exists, redraw the status toolbar
		if( m_pStatusToolbarHandler )
		{
			m_pStatusToolbarHandler->RefreshAllButtons();
		}
        return S_OK;
    }

	// Initialize to NULL
	m_rpActive = NULL;

	POSITION pos = m_lstITransportRegEntry.GetHeadPosition();
	IDMUSProdTransport*  pTmpTransport;
	while( pos )
	{
		ITransportRegEntry *pITransportRegEntry = m_lstITransportRegEntry.GetNext( pos );
		pITransportRegEntry->GetTransport( &pTmpTransport );
		if( pTmpTransport == pTransport )
		{
			// Set active transport index to this entry in the registry
			m_rpActive = pITransportRegEntry;
			break;
		}
	}

	if (m_rpActive == NULL)
	{
		// The transport was not found
		if ( m_pToolbarHandler )
		{
			m_pToolbarHandler->m_comboActive.SetCurSel(-1);
			m_pToolbarHandler->SetStateAuto();
		}
		// If it exists, redraw the status toolbar
		if( m_pStatusToolbarHandler )
		{
			m_pStatusToolbarHandler->RefreshAllButtons();
		}
		return E_INVALIDARG;
	}

	if ( m_pToolbarHandler )
	{
		m_pToolbarHandler->SetActiveTransport( m_rpActive );
	}
	m_rpActive->SetFlags( 0 );

	if (btnFlags & BS_NO_AUTO_UPDATE)
	{
		// For setting the play, stop, and record button states
		SetBtnStates( pTransport, btnFlags );

		DWORD dwFlags;
		m_rpActive->GetFlags( &dwFlags );
		dwFlags &= ~(B_TRANS_ENABLED | B_TRANS_CHECKED);
		m_rpActive->SetFlags( dwFlags );
	}
	else
	{
		// For setting the record button state
		SetBtnStates( pTransport, btnFlags );
		DWORD dwFlags;
		m_rpActive->GetFlags( &dwFlags );
		dwFlags &= ~B_NOT_USING_ENGINE;
		if ( m_pToolbarHandler )
		{
		    m_pToolbarHandler->SetStateFromEngine( &dwFlags );
		}
		m_rpActive->SetFlags( dwFlags );
	}

	if ( m_pToolbarHandler )
	{
	    m_pToolbarHandler->SetStateAuto();
	}

	// If it exists, redraw the status toolbar
	if( m_pStatusToolbarHandler )
	{
		m_pStatusToolbarHandler->RefreshAllButtons();
	}

    return S_OK;
}

/*======================================================================================
METHOD:  ICONDUCTOR::SETTRANSPORTNAME
========================================================================================
@method HRESULT | IDMUSProdConductor| SetTransportName | Sets the name of <p pITransport>
	to <p bstrName>.

@parm   IDMUSProdTransport* | pITransport | Pointer to an <i IDMUSProdTransport> interface.
@parm	BSTR | bstrName | Text to display in the Transport Control toolbar's combo box for <p pITransport>.

@rvalue S_OK | Successfully set the name of <p pITransport> to <p pbstrName>.
@rvalue E_POINTER | Either <p pITransport> or <p bstrName> is NULL.
@rvalue E_INVALIDARG | <p pITransport> was not previously added by calling
		<om IDMUSProdConductor.RegisterTransport>.


@xref  <i IDMUSProdConductor>, <om IDMUSProdConductor.RegisterTransport>,
	   <om IDMUSProdConductor.UnRegisterTransport>, <om IDMUSProdConductor.SetActiveTransport>,
	   <om IDMUSProdConductor.IsTransportPlaying>, <om IDMUSProdConductor.TransportStopped>,
	   <i IDMUSProdTransport>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::SetTransportName( IDMUSProdTransport *pTransport, BSTR bstrName )
{
	if ( pTransport == NULL )
	{
		return E_POINTER;
	}
	if ( bstrName == NULL )
	{
		return E_POINTER;
	}
	IDMUSProdTransport*  pTmpTransport;
	BOOL fTransportFound = FALSE;
	POSITION pos = m_lstITransportRegEntry.GetHeadPosition();
	while( pos )
	{
		ITransportRegEntry *pITransportRegEntry = m_lstITransportRegEntry.GetNext( pos );
		pITransportRegEntry->GetTransport( &pTmpTransport );
		if( pTmpTransport == pTransport )
		{
			fTransportFound = TRUE;

			if ( m_pToolbarHandler )
			{
				// Set transport index to the specified name
				CString strName = bstrName;
				m_pToolbarHandler->RemoveTransport( pITransportRegEntry );
				m_pToolbarHandler->AddTransport( pITransportRegEntry );
				if( m_rpActive == pITransportRegEntry )
				{
					m_pToolbarHandler->SetActiveTransport( pITransportRegEntry );
				}
			}
			break;
		}
	}
	SysFreeString( bstrName );
	if ( fTransportFound )
	{
		return S_OK;
	}
	else
	{
		return E_INVALIDARG;
	}
}

/*======================================================================================
METHOD:  ICONDUCTOR::ISTRANSPORTPLAYING
========================================================================================
@method HRESULT | IDMUSProdConductor| IsTransportPlaying | Returns S_OK if <p pITransport> is playing, and
	S_FALSE if it is not.  If <p pITransport> is NULL, returns S_OK if nothing is playing, and
	S_FALSE if something is playing.

@comm This method will return S_OK if the Conductor thinks the <p pITransport> is the currently
	playing transport.  This may not be the case, so ideally transports should query
	<om IDirectMusicPerformance::IsPlaying>	with their segment state to truly know
	if they are playing or not.

@parm   IDMUSProdTransport* | pITransport | A pointer to the transport to check.  If NULL,
	check whether any transport is playing.

@rvalue S_OK | If <p pITransport> is not NULL, the transport is playing.  Otherwise, no transport is playing.
@rvalue S_FALSE | If <p pITransport> is not NULL, the transport is not playing.  Otherwise, a transport is playing.

@xref  <i IDMUSProdConductor>, <om IDMUSProdConductor.RegisterTransport>,
	   <om IDMUSProdConductor.UnRegisterTransport>, <om IDMUSProdConductor.SetActiveTransport>,
	   <om IDMUSProdConductor.SetTransportName>, <om IDMUSProdConductor.TransportStopped>,
	   <i IDMUSProdTransport>
	
--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::IsTransportPlaying( IDMUSProdTransport *pTransport )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if( pTransport == NULL )
    {
        return m_rpPlaying == NULL ? S_OK : S_FALSE;
    }
    if( m_rpPlaying != NULL )
	{
        IDMUSProdTransport *pRegTransport;
        m_rpPlaying->GetTransport( &pRegTransport );
        return pRegTransport == pTransport ? S_OK : S_FALSE;
	}
    return S_FALSE;
}

/*======================================================================================
METHOD:  ICONDUCTOR::PLAYMIDIEVENT
========================================================================================
@method HRESULT | IDMUSProdConductor| PlayMIDIEvent | Play a MIDI event now, or in the future.

@comm	The MIDI event is played on PChannel 0.

@parm   BYTE | bStatus | Status byte
@parm   BYTE | bData1 | Data byte 1
@parm   BYTE | bData2 | Data byte 2
@parm   DWORD | dwTime | The number of milliseconds into the future to play this
	event.  If zero, play the event as soon as possible.

@rvalue S_OK | The event was successfully played or queued.
@rvalue E_UNEXPECTED | The Conductor was unable to initialize DirectMusic.

@xref  <i IDMUSProdConductor>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::PlayMIDIEvent(BYTE bStatus, BYTE bData1, BYTE bData2, DWORD dwTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT( m_pDMPerformance != NULL );
	if ( m_pDMPerformance == NULL )
	{
		return E_UNEXPECTED;
	}

	HRESULT hr;
	DMUS_PMSG *pPipelineEvent = NULL;

	DMUS_MIDI_PMSG *pDMMidiEvent = NULL;
	hr = m_pDMPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG**)&pDMMidiEvent );
	if ( FAILED(hr) )
	{
		return hr;
	}
	memset( pDMMidiEvent, 0, sizeof(DMUS_MIDI_PMSG) );

	pDMMidiEvent->bStatus = bStatus;
	pDMMidiEvent->bByte1 = bData1;
	pDMMidiEvent->bByte2 = bData2;
	if ( dwTime == 0 )
	{
		//pDMMidiEvent->m_rtTime = 0;
	}
	else
	{
		REFERENCE_TIME rtNow;
		m_pDMPerformance->GetLatencyTime( &rtNow );
		pDMMidiEvent->rtTime = dwTime * 10000 + rtNow;
	}
	pDMMidiEvent->dwFlags = DMUS_PMSGF_REFTIME;
	//pDMMidiEvent->dwPChannel = 0;
	pDMMidiEvent->dwVirtualTrackID = 1;
	pDMMidiEvent->dwType = DMUS_PMSGT_MIDI;
	pPipelineEvent = (DMUS_PMSG*) pDMMidiEvent;

	return m_pDMPerformance->SendPMsg( pPipelineEvent );
}

/*======================================================================================
METHOD:  ICONDUCTOR::SETBTNSTATES
========================================================================================
@method HRESULT | IDMUSProdConductor| SetBtnStates | Sets the button states of <p pITransport> 
	according to the flags in <p dwFlags>.  The method is typically only used if the transport
	is not using the DirectMusic performance engine for playback, or if the transport needs to
	enable or disable the record button.

@parm   IDMUSProdTransport* | pITransport | A pointer to the transport to change the button states for.
@parm	DWORD | dwFlags | A combination of <t ButtonStateFlags> determining the state of the
		transport buttons.

@rvalue S_OK | The button states were successfully set.
@rvalue E_POINTER | <p pITransport> is NULL.
@rvalue E_INVALIDARG | <p pITransport> is not the currently active or currently playing transport.

@xref  <i IDMUSProdConductor>, <i IDMUSProdTransport>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::SetBtnStates( IDMUSProdTransport *pTransport, DWORD btnFlags )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if ( pTransport == NULL )
	{
		return E_POINTER;
	}

	IDMUSProdTransport* pITransport = NULL;

	DWORD dwFlags;
	BOOL fFound = FALSE;
    if( m_rpPlaying != NULL )
	{
		m_rpPlaying->GetTransport( &pITransport );
		if (pITransport == pTransport)
		{
			fFound = TRUE;
			m_rpPlaying->GetFlags( &dwFlags );
		}
	}
    if( m_rpActive != NULL )
	{
		m_rpActive->GetTransport( &pITransport );
		if (pITransport == pTransport)
		{
			fFound = TRUE;
			m_rpActive->GetFlags( &dwFlags );
		}
	}
	if (!fFound)
	{
		// The transport must either be the active transport, or currently playing to
		// be able to set the button states
		return E_INVALIDARG;
	}

	if (btnFlags & BS_PLAY_ENABLED)
	{
		dwFlags |= B_PLAY_ENABLED;
	}
	else
	{
		dwFlags &= ~B_PLAY_ENABLED;
	}
	if (btnFlags & BS_PLAY_CHECKED)
	{
		dwFlags |= B_PLAY_CHECKED;
	}
	else
	{
		dwFlags &= ~B_PLAY_CHECKED;
	}
	
	if (btnFlags & BS_STOP_ENABLED)
	{
		dwFlags |= B_STOP_ENABLED;
	}
	else
	{
		dwFlags &= ~B_STOP_ENABLED;
	}
	if (btnFlags & BS_STOP_CHECKED)
	{
		dwFlags |= B_STOP_CHECKED;
	}
	else
	{
		dwFlags &= ~B_STOP_CHECKED;
	}

	if (btnFlags & BS_RECORD_ENABLED)
	{
		dwFlags |= B_REC_ENABLED;
	}
	else
	{
		dwFlags &= ~B_REC_ENABLED;
	}
	if (btnFlags & BS_RECORD_CHECKED)
	{
		dwFlags |= B_REC_CHECKED;
	}
	else
	{
		dwFlags &= ~B_REC_CHECKED;
	}

	if (btnFlags & BS_NO_AUTO_UPDATE)
	{
		dwFlags |= B_NOT_USING_ENGINE;
	}
	else
	{
		dwFlags &= ~B_NOT_USING_ENGINE;
	}

	if( m_rpPlaying != NULL )
	{
		m_rpPlaying->GetTransport( &pITransport );
		if (pITransport == pTransport)
		{
			m_rpPlaying->SetFlags( dwFlags );
		}
	}
	if( m_rpActive != NULL )
	{
		m_rpActive->GetTransport( &pITransport );
		if (pITransport == pTransport)
		{
			m_rpActive->SetFlags( dwFlags );
		}
	}
	if ( m_pToolbarHandler )
	{
		m_pToolbarHandler->SetStateAuto();
	}
	return S_OK;
}

/*======================================================================================
METHOD:  ICONDUCTOR::SETTEMPO
========================================================================================
@method HRESULT | IDMUSProdConductor| SetTempo | Sets the tempo displayed in the toolbar if
	<p pITransport> is the transport that currently "owns" the toolbar.

@parm	IDMUSProdTransport* | pITransport | A pointer to the transport that currently "owns" the toolbar.
@parm	double | dblTempo | The tempo to change to, in the range DMUS_TEMPO_MIN to DMUS_TEMPO_MAX. 
@parm	BOOL | fEnable | If TRUE, enable editing of the tempo.  If FALSE, disable editing of the tempo.

@comm	If <p fEnable> is FALSE and <p dblTempo> is negative, the tempo edit box will be
	display as empty and disabled.<nl>
	If a transport is currently playing, that transport "owns" the toolbar.  If no transport is currently
	playing, the active transport "owns" the toolbar.

@rvalue S_OK | The tempo was successfully set.
@rvalue E_POINTER | <p pITransport> is NULL.
@rvalue E_INVALIDARG | The transport does not currently "own" the toolbar, or <p dblTempo>
	is out of range.

@xref  <i IDMUSProdConductor>, <i IDMUSProdTransport>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::SetTempo( IDMUSProdTransport *pTransport, double dblTempo, BOOL fEnable )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if ( pTransport == NULL )
	{
		return E_POINTER;
	}

	if( !((dblTempo >= DMUS_TEMPO_MIN && dblTempo <= DMUS_TEMPO_MAX)
		  || (!fEnable && dblTempo < 0.0)) )
	{
		return E_INVALIDARG;
	}

	IDMUSProdTransport *pITransport;
	ITransportRegEntry *pDisplayedRegEntry = GetDisplayedTransport();
    if( pDisplayedRegEntry != NULL )
	{
		pDisplayedRegEntry->GetTransport( &pITransport );
		if ((pITransport == pTransport) && (m_dblTempo != dblTempo))
		{
			m_dblTempo = dblTempo;
			if (m_pToolbarHandler && m_pToolbarHandler->m_editTempo.GetSafeHwnd())
			{
				if(dblTempo >= DMUS_TEMPO_MIN && dblTempo <= DMUS_TEMPO_MAX)
				{
					CString str;
					str.Format("%.2f",dblTempo);
					m_pToolbarHandler->m_editTempo.SetWindowText(str);
				}
				else
				{
					m_pToolbarHandler->m_editTempo.SetWindowText(NULL);
				}

				m_pToolbarHandler->m_editTempo.EnableWindow(fEnable);
				m_pToolbarHandler->m_spinTempo.EnableWindow(fEnable);
			}
			return S_OK;
		}
	}
	return E_INVALIDARG;
}

/*======================================================================================
METHOD:  ICONDUCTOR::REGISTERNOTIFY
========================================================================================
@method HRESULT | IDMUSProdConductor| RegisterNotify | Adds a notification type to the list of
	types that should be sent to this <i IDMUSProdTransport> from the performance engine.

@parm   IDMUSProdNotifyCPt* | pINotifyCPt | The notification interface to send the notification event to.
@parm   REFGUID | rguidNotify | The guid corresponding to the type of notifications to send.

@comm	The parameter <p rguidNotify> is passed to the DirectMusic method
	<om IDirectMusicPerformance::AddNotificationType>.  Valid values are listed in the DirectX SDK
	documentation.

@rvalue S_OK | <p pINotifyCPt> was successfully registered to received the specified notifications.
@rvalue E_POINTER | <p pINotifyCPt> is NULL.
@rvalue E_UNEXPECTED | The Conductor was unable to initialize DirectMusic.

@xref  <i IDMUSProdConductor>, <om IDMUSProdConductor.UnregisterNotify>, <i IDMUSProdNotifyCPt>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::RegisterNotify( IDMUSProdNotifyCPt *pNotifyCPt, REFGUID guidNotify )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if ( pNotifyCPt == NULL )
	{
		return E_POINTER;
	}

	ASSERT( m_pDMPerformance != NULL );
	if ( m_pDMPerformance == NULL )
	{
		return E_UNEXPECTED;
	}

	CNotifyEntry* pNotifyEntry = NULL;
	BOOL fFound = FALSE;

	::EnterCriticalSection( &m_csNotifyEntry );

	// Look through m_lstNotifyEntry for guidNotify
	POSITION pos;
	pos = m_lstNotifyEntry.GetHeadPosition();
	while ( pos != NULL && !fFound )
	{
		pNotifyEntry = m_lstNotifyEntry.GetNext( pos );
		if ( InlineIsEqualGUID( pNotifyEntry->m_guid, guidNotify ) )
		{
			// Found guidNotify, add pNotifyCPt to the end of the list
			fFound = TRUE;
			pNotifyEntry->m_lstNotifyCPt.AddTail( pNotifyCPt );
			//pNotifyCPt->AddRef();
		}
	}

	// Didn't find guidNotify, add a new CNotifyEntry to the end
	// of m_lstNotifyEntry and add the GUID to the performance
	if ( !fFound )
	{
		pNotifyEntry = new CNotifyEntry( pNotifyCPt, guidNotify );
		//pNotifyCPt->AddRef();
		m_lstNotifyEntry.AddTail( pNotifyEntry );
		m_pDMPerformance->AddNotificationType( guidNotify );
	}

	::LeaveCriticalSection( &m_csNotifyEntry );

	return S_OK;
}

/*======================================================================================
METHOD:  ICONDUCTOR::UNREGISTERNOTIFY
========================================================================================
@method HRESULT | IDMUSProdConductor| UnregisterNotify | Removes a notification type from the list of
	notifications that should be sent to this <i IDMUSProdTransport>.

@parm   IDMUSProdNotifyCPt* | pINotifyCPt | The notification interface to stop sending notification events to
@parm   REFGUID | rguidNotify | The guid corresponding to the type of notifications to stop sending

@rvalue S_OK | <p pINotifyCPt> was successfully removed from receiving the specified events
@rvalue E_POINTER | <p pINotifyCPt> is NULL.
@rvalue E_UNEXPECTED | The Conductor was unable to initialize DirectMusic.
@rvalue E_INVALIDARG | <om IDMUSProdConductor.RegisterNotify> was not previously called for this
	<p pINotifyCPt> and <p rguidNotify>.

@xref  <i IDMUSProdConductor>, <om IDMUSProdConductor.RegisterNotify>, <i IDMUSProdNotifyCPt>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::UnregisterNotify( IDMUSProdNotifyCPt *pNotifyCPt, REFGUID guidNotify )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if ( pNotifyCPt == NULL )
	{
		return E_POINTER;
	}

	ASSERT( m_pDMPerformance != NULL );
	if ( m_pDMPerformance == NULL )
	{
		return E_UNEXPECTED;
	}

	CNotifyEntry* pNotifyEntry = NULL;
	BOOL fFound = FALSE;

	::EnterCriticalSection( &m_csNotifyEntry );

	// Look through m_lstNotifyEntry for guidNotify
	POSITION pos;
	pos = m_lstNotifyEntry.GetHeadPosition();
	while ( pos != NULL && !fFound )
	{
		pNotifyEntry = m_lstNotifyEntry.GetNext( pos );
		if ( InlineIsEqualGUID( pNotifyEntry->m_guid, guidNotify ) )
		{
			// Found guidNotify, see if pNotifyCPt is in the list
			POSITION pos2;
			pos2 = pNotifyEntry->m_lstNotifyCPt.Find( pNotifyCPt );

			if ( pos2 != NULL )
			{
				// Found pNotifyCPt in the list, remove it
				fFound = TRUE;
				pNotifyEntry->m_lstNotifyCPt.RemoveAt( pos2 );

				if ( pNotifyEntry->m_lstNotifyCPt.IsEmpty() )
				{
					// If the list is empty, remove it from m_lstNotify Entry and remove
					// guidNotify from the list of notifications in the performance
					pos2 = m_lstNotifyEntry.Find( pNotifyEntry );
					ASSERT( pos2 != NULL );
					if ( pos2 != NULL )
					{
						m_lstNotifyEntry.RemoveAt( pos2 );
						delete pNotifyEntry;
					}
					// Don't remove segment or measurebeat notifications, since we use them to
					// update the toolbar's buttons and for the metronome
					if ( !InlineIsEqualGUID( GUID_NOTIFICATION_SEGMENT, guidNotify ) &&
						 !InlineIsEqualGUID( GUID_NOTIFICATION_MEASUREANDBEAT, guidNotify ) &&
						 !InlineIsEqualGUID( GUID_NOTIFICATION_PERFORMANCE, guidNotify ))
					{
						m_pDMPerformance->RemoveNotificationType( guidNotify );
					}
				}
			}
		}
	}

	::LeaveCriticalSection( &m_csNotifyEntry );

	if ( !fFound )
	{
		return E_INVALIDARG;
	}
	else
	{
		return S_OK;
	}
}

/*======================================================================================
METHOD:  ICONDUCTOR::TRANSPORTSTOPPED
========================================================================================
@method HRESULT | IDMUSProdConductor| TransportStopped | Notifies the Conductor that a transport has stopped playing.

@parm   IDMUSProdTransport* | pITransport | A pointer to the transport that has stopped playing

@comm	This method must be called when a transport stops playing so the Transport Control toolbar
	can switch from displaying a Stop button to displaying a Play button.

@rvalue S_OK | The operation succeeded.
@rvalue E_POINTER | <p pITransport> is NULL.
@rvalue E_INVALIDARG | <p pITransport> does not point to the currently playing transport.
@rvalue E_FAIL | An error occurred.

@xref  <i IDMUSProdConductor>, <om IDMUSProdConductor.RegisterTransport>,
	   <om IDMUSProdConductor.UnRegisterTransport>, <om IDMUSProdConductor.SetActiveTransport>,
	   <om IDMUSProdConductor.SetTransportName>, <om IDMUSProdConductor.IsTransportPlaying>,
	   <i IDMUSProdTransport>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::TransportStopped( IDMUSProdTransport *pTransport )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if( pTransport == NULL )
    {
		return E_POINTER;
    }

	if( m_rpPlaying == NULL )
	{
		return E_INVALIDARG;
	}


	IDMUSProdTransport*  pTmpTransport;
	m_rpPlaying->GetTransport( &pTmpTransport );
	if( pTmpTransport != pTransport )
	{
		return E_INVALIDARG;
	}

	// Pop up the record button
	DWORD dwFlags;
	m_rpPlaying->GetFlags( &dwFlags );
	if( ((dwFlags & B_REC_CHECKED) != 0) && SUCCEEDED( pTransport->Record( FALSE ) ) )
	{
		dwFlags &= ~B_REC_CHECKED;
		m_rpPlaying->SetFlags( dwFlags );
		//SetStateAuto(); // Happens later.
	}

	m_rpPlaying = NULL;
	if ( m_pToolbarHandler )
	{
		// 22125: Can't send window messages - we may be in a notification thread
		if( m_pToolbarHandler->m_comboActive.GetSafeHwnd() != NULL )
		{
			::PostMessage( m_pToolbarHandler->m_hWndToolbar, WM_COMMAND, (WPARAM) MAKELONG( 0, ID_SET_ACTIVE_FROM_POINTER ), (LPARAM) m_pToolbarHandler->m_hWndToolbar );
			::PostMessage( m_pToolbarHandler->m_hWndToolbar, WM_COMMAND, (WPARAM) MAKELONG( 0, ID_SET_STATE_AUTO ), (LPARAM) m_pToolbarHandler->m_hWndToolbar );
		}
	}

	// Flag the wave record toolbar that playback has stopped, so it should stop
	// exporting MIDI
	if( m_pWaveRecordToolbar )
	{
		m_pWaveRecordToolbar->PostMessage( WM_USER + 3, NULL, NULL );
	}

    return S_OK;
}


/*======================================================================================
METHOD:  ICONDUCTOR::GETTRANSITIONOPTIONS
========================================================================================
@method HRESULT | IDMUSProdConductor| GetTransitionOptions | Returns a structure containing parameters
			defining what type of transition the user desires.

@comm	This method should be called in response to a call to the <om IDMUSProdTransport.Transition> method.

@parm   ConductorTransitionOptions* | pTransitionOptions | A pointer to the <t ConductorTransitionOptions> structure to fill in

@rvalue S_OK | The operation succeeded.
@rvalue E_POINTER | <p pTransitionOptions> is NULL.

@xref  <i IDMUSProdConductor>, <t ConductorTransitionOptions>, <om IDMUSProdTransport.Transition>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::GetTransitionOptions( ConductorTransitionOptions *pTransitionOptions )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !pTransitionOptions )
	{
		return E_POINTER;
	}

	pTransitionOptions->dwBoundaryFlags = m_TransitionOptions.dwBoundaryFlags;
	pTransitionOptions->wPatternType = m_TransitionOptions.wPatternType;
	pTransitionOptions->dwFlags = m_TransitionOptions.dwFlags & ~TRANS_PRIVATE_FLAGS;
	pTransitionOptions->pDMUSProdNodeSegmentTransition = m_TransitionOptions.pDMUSProdNodeSegmentTransition;

	return S_OK;
}


/*======================================================================================
METHOD:  ICONDUCTOR::REGISTERSECONDARYTRANSPORT
========================================================================================
@method HRESULT | IDMUSProdConductor| RegisterSecondaryTransport | Add <p pISecondaryTransport>
	to the Secondary Segment toolbar's combo boxes. 	If <p pISecondaryTransport> is already
	listed, increment its reference count.

@parm   <i IDMUSProdSecondaryTransport>* | pISecondaryTransport | Pointer to the <i IDMUSProdSecondaryTransport> 
		interface to add to the Secondary Segment toolbar's combo boxes.

@rvalue S_OK | The secondary segment transport was successfully added.
@rvalue E_POINTER | <p pISecondaryTransport> is NULL.

@xref  <i IDMUSProdConductor>, <om IDMUSProdConductor.UnRegisterSecondaryTransport>,
	   <om IDMUSProdConductor.SetSecondaryTransportName>, <om IDMUSProdConductor.IsSecondaryTransportPlaying>,
	   <i IDMUSProdSecondaryTransport>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::RegisterSecondaryTransport( IDMUSProdSecondaryTransport *pSecondaryTransport )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	POSITION pos = m_lstISecondaryTransportRegEntry.GetHeadPosition();
	IDMUSProdSecondaryTransport*  pSecondaryTrans;
	while( pos )
	{
		POSITION pos2 = pos;
		m_lstISecondaryTransportRegEntry.GetNext( pos )->GetSecondaryTransport( &pSecondaryTrans );
		if( pSecondaryTrans == pSecondaryTransport )
		{
			// Increment reference count on existing entry
			m_lstISecondaryTransportRegEntry.GetAt( pos2 )->AddRef();
			return S_OK;
		}
	}

	// Transport was not found so create and add one
	CSecondaryTransportRegEntry*  pCEntry = new CSecondaryTransportRegEntry( pSecondaryTransport );
	if( pCEntry )
	{
		ISecondaryTransportRegEntry*  pIEntry;
		if( SUCCEEDED(pCEntry->QueryInterface( IID_ISecondaryTransportRegEntry, (void**) &pIEntry )) )
		{
			m_lstISecondaryTransportRegEntry.AddTail( pIEntry );

			BSTR  pbstrName;
			char buf[128];
			// If the transport doens't have a name, use a default name
			if ( SUCCEEDED(	pSecondaryTransport->GetSecondaryTransportName( &pbstrName ) ) )
			{
				WideCharToMultiByte( CP_ACP, 0, pbstrName, -1, buf, 128, NULL, NULL );
				SysFreeString( pbstrName );
			}
			else
			{
				CString strTmp;
				strTmp.LoadString( IDS_DEFAULT_TRANSPORT_NAME );
				strncpy( buf, strTmp, 127 );
			}

			if ( !m_lstSecondaryToolbars.IsEmpty() )
			{
				pos = m_lstSecondaryToolbars.GetHeadPosition();
				while( pos )
				{
					CSecondaryToolbarHandler *pToolbarHandler = m_lstSecondaryToolbars.GetNext( pos );

					int nIndex;
					for( DWORD i=0; i < pToolbarHandler->m_dwNumButtons; i++ )
					{
						nIndex = pToolbarHandler->m_arrayButtons[i]->comboActive.AddString( buf );
						pToolbarHandler->m_arrayButtons[i]->comboActive.SetItemDataPtr( nIndex, pIEntry );
					}

					pToolbarHandler->SetStateAuto();
				}
			}

			return S_OK;
		}
	}
	return E_FAIL;
}


/*======================================================================================
METHOD:  ICONDUCTOR::UNREGISTERSECONDARYTRANSPORT
========================================================================================
@parm   IDMUSProdTransport* | pITransport | Pointer to the <i IDMUSProdTransport> interface to
		be removed from the Transport Control toolbar's combo box.

@method HRESULT | IDMUSProdConductor| UnRegisterSecondaryTransport | Remove <p pISecondaryTransport>
	from the Secondary Segment toolbar's combo boxes, and stop it if it is playing.  If it was
	added more than once, remove one reference to it.  When all references are removed,
	it will then be removed from the Secondary Segment toolbar's combo boxes and stopped
	if it is playing.

@parm   IDMUSProdSecondaryTransport* | pISecondaryTransport | Pointer to the <i IDMUSProdSecondaryTransport> 
		interface to be removed from the Secondary Segment toolbar's combo boxes.

@rvalue S_OK | <p pISecondaryTransport> was successfully removed.
@rvalue E_INVALIDARG | <p pISecondaryTransport> was not previously added via <om IDMUSProdConductor.RegisterSecondaryTransport>.
@rvalue E_POINTER | <p pISecondaryTransport> is NULL.

@xref  <i IDMUSProdConductor>, <om IDMUSProdConductor.RegisterSecondaryTransport>,
	   <om IDMUSProdConductor.SetSecondaryTransportName>, <om IDMUSProdConductor.IsSecondaryTransportPlaying>,
	   <i IDMUSProdSecondaryTransport>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::UnRegisterSecondaryTransport( IDMUSProdSecondaryTransport *pSecondaryTransport )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pSecondaryTransport == NULL )
	{
		return E_POINTER;
	}

	POSITION pos = m_lstISecondaryTransportRegEntry.GetHeadPosition();
	IDMUSProdSecondaryTransport*  pTrans;
	while( pos )
	{
		POSITION pos2 = pos;
		m_lstISecondaryTransportRegEntry.GetNext( pos )->GetSecondaryTransport( &pTrans );
		if( pTrans == pSecondaryTransport )
		{
			// Check if this is the last reference
			ISecondaryTransportRegEntry *pISecondaryRegEntry = m_lstISecondaryTransportRegEntry.GetAt( pos2 );
			pISecondaryRegEntry->AddRef();
			if ( pISecondaryRegEntry->Release() == 1 )
			{
				pos = m_lstSecondaryToolbars.GetHeadPosition();
				while( pos )
				{
					CSecondaryToolbarHandler *pToolbarHandler = m_lstSecondaryToolbars.GetNext( pos );

					for( DWORD i=0; i < pToolbarHandler->m_dwNumButtons; i++ )
					{
						if( pISecondaryRegEntry == pToolbarHandler->m_arrayButtons[i]->pActiveRegEntry )
						{
							// Fake a click on the Stop button so we stop this transport
							// if it's currently playing
							BOOL bHandled;
							pToolbarHandler->OnButtonClicked( 0, WORD(ID_TRANSP_STOP1 + i), 0, bHandled );
							if( pToolbarHandler->m_arrayButtons[i]->pISegmentState )
							{
								TRACE("UnRegisterSecondaryTransport: Transport #%d failed to Stop() when unregistered\n", i);
								RELEASE( pToolbarHandler->m_arrayButtons[i]->pISegmentState );
							}
						}
					}
				}
			}

			// If no more references, remove this secondary transport from all combo boxes
			if( pISecondaryRegEntry->Release() == 0 )
			{
				pos = m_lstSecondaryToolbars.GetHeadPosition();
				while( pos )
				{
					CSecondaryToolbarHandler *pToolbarHandler = m_lstSecondaryToolbars.GetNext( pos );

					// Clear selections if the entry is currenly active, or if the active selection
					// is greater than the one being removed, decrease the index of the active selection
					for( DWORD i=0; i < pToolbarHandler->m_dwNumButtons; i++ )
					{
						if( pISecondaryRegEntry == pToolbarHandler->m_arrayButtons[i]->pActiveRegEntry )
						{
							pToolbarHandler->m_arrayButtons[i]->pActiveRegEntry = NULL;
							pToolbarHandler->m_arrayButtons[i]->comboActive.SetCurSel( -1 );
						}

						// Remove string from combo box
						int nIndex = GetIndexByDataPtr( pToolbarHandler->m_arrayButtons[i]->comboActive, pISecondaryRegEntry );
						if( nIndex != -1 )
						{
							pToolbarHandler->m_arrayButtons[i]->comboActive.DeleteString( nIndex );
						}
					}


					for( i=0; i < MAX_BUTTONS; i++ )
					{
						if( pToolbarHandler->m_apOldButtonInfo[i] )
						{
							if( pISecondaryRegEntry == pToolbarHandler->m_apOldButtonInfo[i]->pActiveRegEntry )
							{
								pToolbarHandler->m_apOldButtonInfo[i]->pActiveRegEntry = NULL;
							}
						}
					}

					// Refresh the display
					pToolbarHandler->SetStateAuto();
				}

				// Remove entry from registry pointer array if no more references
				m_lstISecondaryTransportRegEntry.RemoveAt( pos2 );

				// If no secondary segment transports, need to disable all comboboxes in
				// the secondary segment toolbars
				if( m_lstISecondaryTransportRegEntry.IsEmpty() )
				{
					pos = m_lstSecondaryToolbars.GetHeadPosition();
					while( pos )
					{
						// This updates all the button states
						m_lstSecondaryToolbars.GetNext( pos )->SetStateAuto();
					}
				}
			}

			// return - found the secondary segment transport
			return S_OK;
		}
	}

	// Entry was not found
	return E_INVALIDARG;
}


/*======================================================================================
METHOD:  ICONDUCTOR::SETSECONDARYTRANSPORTNAME
========================================================================================
@method HRESULT | IDMUSProdConductor| SetSecondaryTransportName | Update the name displayed for
	<p pISecondaryTransport> with the text in <p bstrName>.

@parm   IDMUSProdSecondaryTransport* | pISecondaryTransport | Pointer to an <i IDMUSProdSecondaryTransport>
	interface.
@parm	BSTR | bstrName | Text to display in the Secondary Segment toolbar's combo boxes
	for <p pISecondaryTransport>.

@rvalue S_OK | Successfully set the name of <p pISecondaryTransport> to <p pbstrName>.
@rvalue E_POINTER | Either <p pISecondaryTransport> or <p bstrName> is NULL.
@rvalue E_INVALIDARG | <p pISecondaryTransport> was not previously added by calling <om IDMUSProdConductor.RegisterSecondaryTransport>.

@xref  <i IDMUSProdConductor>, <om IDMUSProdConductor.RegisterSecondaryTransport>,
	   <om IDMUSProdConductor.UnRegisterSecondaryTransport>, <om IDMUSProdConductor.IsSecondaryTransportPlaying>,
	   <i IDMUSProdSecondaryTransport>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::SetSecondaryTransportName( IDMUSProdSecondaryTransport *pSecondaryTransport, BSTR bstrName )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( (pSecondaryTransport == NULL) || (bstrName == NULL) )
	{
		return E_POINTER;
	}

	IDMUSProdSecondaryTransport*  pTmpTransport = NULL;
	BOOL fTransportFound = FALSE;
	POSITION pos = m_lstISecondaryTransportRegEntry.GetHeadPosition();

	// Search for the trasnport in the registry
	while( pos )
	{
		POSITION pos2 = pos;
		m_lstISecondaryTransportRegEntry.GetNext( pos )->GetSecondaryTransport( &pTmpTransport );
		if( pTmpTransport == pSecondaryTransport )
		{
			// Found the transport
			fTransportFound = TRUE;

			// Set transport index to the specified name
			char buf[128];
			WideCharToMultiByte( CP_ACP, 0, bstrName, -1, buf, 128, NULL, NULL );

			// Save a pointer to the transport
			ISecondaryTransportRegEntry* pIEntry = m_lstISecondaryTransportRegEntry.GetAt( pos2 );

			// Update the secondary toolbar combo boxes
			POSITION pos2 = m_lstSecondaryToolbars.GetHeadPosition();
			while( pos2 )
			{
				CSecondaryToolbarHandler *pToolbarHandler = m_lstSecondaryToolbars.GetNext( pos2 );

				for( DWORD i=0; i < pToolbarHandler->m_dwNumButtons; i++ )
				{
					// Update combo box
					int nIndex = GetIndexByDataPtr( pToolbarHandler->m_arrayButtons[i]->comboActive, pIEntry );
					if( nIndex != -1 )
					{
						pToolbarHandler->m_arrayButtons[i]->comboActive.DeleteString( nIndex );
						nIndex = pToolbarHandler->m_arrayButtons[i]->comboActive.AddString( buf );
						pToolbarHandler->m_arrayButtons[i]->comboActive.SetItemDataPtr( nIndex, pIEntry );

						// Reset the active item
						pToolbarHandler->m_arrayButtons[i]->comboActive.SetCurSel( GetIndexByDataPtr( pToolbarHandler->m_arrayButtons[i]->comboActive, pToolbarHandler->m_arrayButtons[i]->pActiveRegEntry ) );
					}
				}
			}
			break;
		}
	}

	SysFreeString( bstrName );

	if ( fTransportFound )
	{
		return S_OK;
	}
	else
	{
		return E_INVALIDARG;
	}
}


/*======================================================================================
METHOD:  ICONDUCTOR::ISSECONDARYTRANSPORTPLAYING
========================================================================================
@method HRESULT | IDMUSProdConductor| IsSecondaryTransportPlaying | Returns S_OK if
	<p pISecondaryTransport> is playing, and S_FALSE if it is not.  If <p pISecondaryTransport>
	is NULL, returns S_OK if nothing is playing, and S_FALSE if something is playing.

@parm   IDMUSProdSecondaryTransport* | pISecondaryTransport | A pointer to the secondary transport to check.
	If NULL, check whether anything is playing.

@rvalue S_OK | If <p pISecondaryTransport> is not NULL, the transport is playing.
	Otherwise, no transport is playing.
@rvalue S_FALSE | If <p pISecondaryTransport> is not NULL, the transport is not playing.
	Otherwise, a transport is playing.

@xref  <i IDMUSProdConductor>, <om IDMUSProdConductor.RegisterSecondaryTransport>,
	   <om IDMUSProdConductor.UnRegisterSecondaryTransport>, <om IDMUSProdConductor.SetSecondaryTransportName>,
	   <i IDMUSProdSecondaryTransport>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::IsSecondaryTransportPlaying( IDMUSProdSecondaryTransport *pSecondaryTransport )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// If pSecondary Transport is NULL, check if anything is playing
    if( pSecondaryTransport == NULL )
    {
		POSITION pos = m_lstSecondaryToolbars.GetHeadPosition();
		while( pos )
		{
			CSecondaryToolbarHandler *pToolbarHandler = m_lstSecondaryToolbars.GetNext( pos );

			for( DWORD i=0; i < pToolbarHandler->m_dwNumButtons; i++ )
			{
				if( pToolbarHandler->m_arrayButtons[i]->pISegmentState )
				{
					// Something's playing
					return S_OK;
				}
			}
		}
		// Nothing's playing
		return S_FALSE;
    }

	POSITION pos = m_lstSecondaryToolbars.GetHeadPosition();
	while( pos )
	{
		CSecondaryToolbarHandler *pToolbarHandler = m_lstSecondaryToolbars.GetNext( pos );

		for( DWORD i=0; i < pToolbarHandler->m_dwNumButtons; i++ )
		{
			if( pToolbarHandler->m_arrayButtons[i]->pISegmentState && pToolbarHandler->m_arrayButtons[i]->pActiveRegEntry )
			{
				IDMUSProdSecondaryTransport *pRegTransport;
				pToolbarHandler->m_arrayButtons[i]->pActiveRegEntry->GetSecondaryTransport( &pRegTransport );
				if( pRegTransport == pSecondaryTransport )
				{
					return S_OK;
				}
			}
		}
	}

	return S_FALSE;
}


/*======================================================================================
METHOD:  ICONDUCTOR::SETPCHANNELTHRU
========================================================================================
@method HRESULT | IDMUSProdConductor| SetPChannelThru | Starts a thru connection from the
		specified MIDI input channel to the specified output PChannel.

@parm   DWORD | dwInputChannel | MIDI Input channel number. Must be between 0 and 15, inclusive.
@parm   DWORD | dwPChannel | Output PChannel number.

@rvalue S_OK | The operation succeeded.
@rvalue S_FALSE | Already thruing <p dwInputChannel> to <p dwPChannel>
@rvalue E_UNEXPECTED | The Performance engine does not exist.
@rvalue E_FAIL | There is no DirectMusic MIDI input port, <p dwPChannel> does not exist in the
	current port configuration, or the port that <p dwPChannel> plays on has a latency greater
	than 40ms.
@rvalue E_INVALIDARG | <p dwInputChannel> is greater than 15.

@xref  <i IDMUSProdConductor>, <om IDMUSProdConductor.CancelPChannelThru>

--------------------------------------------------------------------------------------*/

HRESULT STDMETHODCALLTYPE CConductor::SetPChannelThru( DWORD dwInputChannel, DWORD dwPChannel )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( dwInputChannel > 15 )
	{
		return E_INVALIDARG;
	}

	::EnterCriticalSection( &m_csAudiopath );
	IDirectMusicAudioPath *pDMAudiopath = m_pDMAudiopath;
	if( pDMAudiopath )
	{
		pDMAudiopath->AddRef();
	}
	::LeaveCriticalSection( &m_csAudiopath );

	HRESULT hr = E_UNEXPECTED;

	if( m_pDMPerformance
	&&	pDMAudiopath
	&&	g_pMIDIInputContainer )
	{
		hr = g_pMIDIInputContainer->SetPChannelThru( dwInputChannel, dwPChannel, pDMAudiopath );
	}

	if( pDMAudiopath )
	{
		pDMAudiopath->Release();
	}

	return hr;
}


/*======================================================================================
METHOD:  ICONDUCTOR::CANCELPCHANNELTHRU
========================================================================================
@method HRESULT | IDMUSProdConductor| CancelPChannelThru | Stops the thru connection from th