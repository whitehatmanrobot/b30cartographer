turn S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(type* p##pname) \
	{ \
		__if_exists(T::m_##pname) \
		{ \
			ATLTRACE(ATL::atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
			ATLASSERT(p##pname != NULL); \
			if (p##pname == NULL) \
				return E_POINTER; \
			T* pT = (T*) this; \
			*p##pname = pT->m_##pname; \
		} \
		return S_OK; \
	}

#define IMPLEMENT_BOOL_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(VARIANT_BOOL pname) \
	{ \
		__if_exists(T::m_##pname) \
		{ \
			ATLTRACE(ATL::atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
			T* pT = (T*) this; \
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(dispid) == S_FALSE) \
				return S_FALSE; \
			pT->m_##pname = pname; \
			pT->m_bRequiresSave = TRUE; \
			if (pT->m_nFreezeEvents == 0) \
				pT->FireOnChanged(dispid); \
			__if_exists(T::On##fname##Changed) \
			{ \
				pT->On##fname##Changed(); \
			} \
			pT->FireViewChange(); \
			pT->SendOnDataChange(NULL); \
		} \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(VARIANT_BOOL* p##pname) \
	{ \
		__if_exists(T::m_##pname) \
		{ \
			ATLTRACE(ATL::atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
			ATLASSERT(p##pname != NULL); \
			if (p##pname == NULL) \
				return E_POINTER; \
			T* pT = (T*) this; \
			*p##pname = pT->m_##pname ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE; \
		} \
		return S_OK; \
	}

#define IMPLEMENT_BSTR_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(BSTR pname) \
	{ \
		__if_exists(T::m_##pname) \
		{ \
			ATLTRACE(ATL::atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
			T* pT = (T*) this; \
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(dispid) == S_FALSE) \
				return S_FALSE; \
			SysFreeStringHelper(pT->m_##pname); \
			HRESULT hr=SysAllocStringHelper(pT->m_##pname,pname); \
			if (FAILED(hr) && pname != NULL) \
				return E_OUTOFMEMORY; \
			pT->m_bRequiresSave = TRUE; \
			if (pT->m_nFreezeEvents == 0) \
				pT->FireOnChanged(dispid); \
			__if_exists(T::On##fname##Changed) \
			{ \
				pT->On##fname##Changed(); \
			} \
			pT->FireViewChange(); \
			pT->SendOnDataChange(NULL); \
		} \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(BSTR* p##pname) \
	{ \
		__if_exists(T::m_##pname) \
		{ \
			ATLTRACE(ATL::atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
			ATLASSERT(p##pname != NULL); \
			if (p##pname == NULL) \
				return E_POINTER; \
			T* pT = (T*) this; \
			*p##pname = SysAllocString(pT->m_##pname); \
			if (*p##pname == NULL && pT->m_##pname != NULL) \
				return E_OUTOFMEMORY; \
		} \
		return S_OK; \
	}


template < class T, class InterfaceName, const IID* piid = &_ATL_IIDOF(InterfaceName), const GUID* plibid = &CAtlModule::m_libid, WORD wMajor = 1,
WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE CStockPropImpl : public IDispatchImpl< InterfaceName, piid, plibid, wMajor, wMinor, tihclass >
{
public:
	// Font
	HRESULT STDMETHODCALLTYPE put_Font(IFontDisp* pFontDisp)
	{
		__if_exists(T::m_pFont) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::put_Font\n"));
			T* pT = (T*) this;
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
				return S_FALSE;
			pT->m_pFont = 0;
			if (pFontDisp)
			{
				CComQIPtr<IFont, &__uuidof(IFont)> p(pFontDisp);
				if (p)
				{
					CComPtr<IFont> pFont;
					p->Clone(&pFont);
					if (pFont)
					{
						pFont->QueryInterface(__uuidof(IFontDisp), (void**) &pT->m_pFont);
					}
				}
			}
			pT->m_bRequiresSave = TRUE;
			if (pT->m_nFreezeEvents == 0)
				pT->FireOnChanged(DISPID_FONT);
			__if_exists(T::OnFontChanged) 
			{
				pT->OnFontChanged();
			}
			pT->FireViewChange();
			pT->SendOnDataChange(NULL);
		}
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_Font(IFontDisp* pFont)
	{
		__if_exists(T::m_pFont) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::putref_Font\n"));
			T* pT = (T*) this;
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
				return S_FALSE;
			pT->m_pFont = pFont;
			pT->m_bRequiresSave = TRUE;
			if (pT->m_nFreezeEvents == 0)
				pT->FireOnChanged(DISPID_FONT);
			__if_exists(T::OnFontChanged) 
			{
				pT->OnFontChanged();
			}
			pT->FireViewChange();
			pT->SendOnDataChange(NULL);
		}
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Font(IFontDisp** ppFont)
	{
		__if_exists(T::m_pFont) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::get_Font\n"));
			ATLASSERT(ppFont != NULL);
			if (ppFont == NULL)
				return E_POINTER;

			T* pT = (T*) this;
			*ppFont = pT->m_pFont;
			if (*ppFont != NULL)
				(*ppFont)->AddRef();
		}
		return S_OK;
	}
	// Picture
	HRESULT STDMETHODCALLTYPE put_Picture(IPictureDisp* pPicture)
	{
#ifndef _WIN32_WCE
		__if_exists(T::m_pPicture) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::put_Picture\n"));
			T* pT = (T*) this;
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
				return S_FALSE;
			pT->m_pPicture = 0;
			if (pPicture)
			{
				CComQIPtr<IPersistStream, &__uuidof(IPersistStream)> p(pPicture);
				if (p)
				{
					ULARGE_INTEGER l;
					p->GetSizeMax(&l);
					HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
					if (hGlob)
					{
						CComPtr<IStream> spStream;
						CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
						if (spStream)
						{
							if (SUCCEEDED(p->Save(spStream, FALSE)))
							{
								LARGE_INTEGER l;
								l.QuadPart = 0;
								spStream->Seek(l, STREAM_SEEK_SET, NULL);
								OleLoadPicture(spStream, l.LowPart, FALSE, __uuidof(IPictureDisp), (void**)&pT->m_pPicture);
							}
							spStream.Release();
						}
						GlobalFree(hGlob);
					}
				}
			}
			pT->m_bRequiresSave = TRUE;
			if (pT->m_nFreezeEvents == 0)
				pT->FireOnChanged(DISPID_PICTURE);
			__if_exists(T::OnPictureChanged) 
			{
				pT->OnPictureChanged();
			}
			pT->FireViewChange();
			pT->SendOnDataChange(NULL);
		}
		return S_OK;
#else // _WIN32_WCE
		(pPicture);
		ATLTRACENOTIMPL(L"CStockPropImpl::put_Picture");
		return E_NOTIMPL;
#endif // _WIN32_WCE
	}
	HRESULT STDMETHODCALLTYPE putref_Picture(IPictureDisp* pPicture)
	{
		__if_exists(T::m_pPicture) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::putref_Picture\n"));
			T* pT = (T*) this;
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
				return S_FALSE;
			pT->m_pPicture = pPicture;
			pT->m_bRequiresSave = TRUE;
			if (pT->m_nFreezeEvents == 0)
				pT->FireOnChanged(DISPID_PICTURE);
			__if_exists(T::OnPictureChanged) 
			{
				pT->OnPictureChanged();
			}
			pT->FireViewChange();
			pT->SendOnDataChange(NULL);
		}
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Picture(IPictureDisp** ppPicture)
	{
		__if_exists(T::m_pPicture) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::get_Picture\n"));
			ATLASSERT(ppPicture != NULL);
			if (ppPicture == NULL)
				return E_POINTER;

			T* pT = (T*) this;
			*ppPicture = pT->m_pPicture;
			if (*ppPicture != NULL)
				(*ppPicture)->AddRef();
		}
		return S_OK;
	}
	// MouseIcon
	HRESULT STDMETHODCALLTYPE put_MouseIcon(IPictureDisp* pPicture)
	{
#ifndef _WIN32_WCE
		__if_exists(T::m_pMouseIcon) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::put_MouseIcon\n"));
			T* pT = (T*) this;
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
				return S_FALSE;
			pT->m_pMouseIcon = 0;
			if (pPicture)
			{
				CComQIPtr<IPersistStream, &__uuidof(IPersistStream)> p(pPicture);
				if (p)
				{
					ULARGE_INTEGER l;
					p->GetSizeMax(&l);
					HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
					if (hGlob)
					{
						CComPtr<IStream> spStream;
						CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
						if (spStream)
						{
							if (SUCCEEDED(p->Save(spStream, FALSE)))
							{
								LARGE_INTEGER l;
								l.QuadPart = 0;
								spStream->Seek(l, STREAM_SEEK_SET, NULL);
								OleLoadPicture(spStream, l.LowPart, FALSE, __uuidof(IPictureDisp), (void**)&pT->m_pMouseIcon);
							}
							spStream.Release();
						}
						GlobalFree(hGlob);
					}
				}
			}
			pT->m_bRequiresSave = TRUE;
			if (pT->m_nFreezeEvents == 0)
				pT->FireOnChanged(DISPID_MOUSEICON);
			__if_exists(T::OnMouseIconChanged) 
			{
				pT->OnMouseIconChanged();
			}
			pT->FireViewChange();
			pT->SendOnDataChange(NULL);
		}
		return S_OK;
#else // _WIN32_WCE
		(pPicture);
		ATLTRACENOTIMPL(L"CStockPropImpl::put_MouseIcon");
		return E_NOTIMPL;
#endif // _WIN32_WCE
	}
	HRESULT STDMETHODCALLTYPE putref_MouseIcon(IPictureDisp* pPicture)
	{
		__if_exists(T::m_pMouseIcon) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::putref_MouseIcon\n"));
			T* pT = (T*) this;
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
				return S_FALSE;
			pT->m_pMouseIcon = pPicture;
			pT->m_bRequiresSave = TRUE;
			if (pT->m_nFreezeEvents == 0)
				pT->FireOnChanged(DISPID_MOUSEICON);
			__if_exists(T::OnMouseIconChanged) 
			{
				pT->OnMouseIconChanged();
			}
			pT->FireViewChange();
			pT->SendOnDataChange(NULL);
		}
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_MouseIcon(IPictureDisp** ppPicture)
	{
		__if_exists(T::m_pMouseIcon) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::get_MouseIcon\n"));
			ATLASSERT(ppPicture != NULL);
			if (ppPicture == NULL)
				return E_POINTER;

			T* pT = (T*) this;
			*ppPicture = pT->m_pMouseIcon;
			if (*ppPicture != NULL)
				(*ppPicture)->AddRef();
		}
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(OLE_COLOR, BackColor, clrBackColor, DISPID_BACKCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, BorderColor, clrBorderColor, DISPID_BORDERCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, FillColor, clrFillColor, DISPID_FILLCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, ForeColor, clrForeColor, DISPID_FORECOLOR)
	IMPLEMENT_BOOL_STOCKPROP(AutoSize, bAutoSize, DISPID_AUTOSIZE)
	IMPLEMENT_BOOL_STOCKPROP(Valid, bValid, DISPID_VALID)
	IMPLEMENT_BOOL_STOCKPROP(Enabled, bEnabled, DISPID_ENABLED)
	IMPLEMENT_BOOL_STOCKPROP(TabStop, bTabStop, DISPID_TABSTOP)
	IMPLEMENT_BOOL_STOCKPROP(BorderVisible, bBorderVisible, DISPID_BORDERVISIBLE)
	IMPLEMENT_BSTR_STOCKPROP(Text, bstrText, DISPID_TEXT)
	IMPLEMENT_BSTR_STOCKPROP(Caption, bstrCaption, DISPID_CAPTION)
	HRESULT STDMETHODCALLTYPE put_Window(LONG_PTR hWnd)
	{
		return put_HWND(hWnd);
	}
	HRESULT STDMETHODCALLTYPE get_Window(LONG_PTR* phWnd)
	{
		return get_HWND(phWnd);
	}
	HRESULT STDMETHODCALLTYPE put_HWND(LONG_PTR /*hWnd*/)
	{
		ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::put_HWND\n"));
		return E_FAIL;
	}
	HRESULT STDMETHODCALLTYPE get_HWND(LONG_PTR* phWnd)
	{
		__if_exists(T::m_hWnd) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::get_HWND\n"));
			ATLASSERT(phWnd != NULL);
			if (phWnd == NULL)
				return E_POINTER;
			T* pT = (T*) this;
			*phWnd = reinterpret_cast<LONG_PTR>(pT->m_hWnd);
		}
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(LONG, BackStyle, nBackStyle, DISPID_BACKSTYLE)
	IMPLEMENT_STOCKPROP(LONG, BorderStyle, nBorderStyle, DISPID_BORDERSTYLE)
	IMPLEMENT_STOCKPROP(LONG, BorderWidth, nBorderWidth, DISPID_BORDERWIDTH)
	IMPLEMENT_STOCKPROP(LONG, DrawMode, nDrawMode, DISPID_DRAWMODE)
	IMPLEMENT_STOCKPROP(LONG, DrawStyle, nDrawStyle, DISPID_DRAWSTYLE)
	IMPLEMENT_STOCKPROP(LONG, DrawWidth, nDrawWidth, DISPID_DRAWWIDTH)
	IMPLEMENT_STOCKPROP(LONG, FillStyle, nFillStyle, DISPID_FILLSTYLE)
	IMPLEMENT_STOCKPROP(SHORT, Appearance, nAppearance, DISPID_APPEARANCE)
	IMPLEMENT_STOCKPROP(LONG, MousePointer, nMousePointer, DISPID_MOUSEPOINTER)
	IMPLEMENT_STOCKPROP(LONG, ReadyState, nReadyState, DISPID_READYSTATE)
};

#pragma pack(pop)

}; //namespace ATL

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif //!_ATL_NO_PRAGMA_WARNINGS

#endif // _ATLCTL_IMPL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlcrypt.inl ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.


#ifndef __ATLCRYPT_INL__
#define __ATLCRYPT_INL__

#pragma once

#ifndef __ATLCRYPT_H__
	#error atlcrypt.inl requires atlcrypt.h to be included first
#endif


namespace ATL
{

inline CCryptProv::CCryptProv( const CCryptProv& prov ) throw()
{
	m_hProv = prov.m_hProv;
	if (m_hProv)
		AddRef();
}

inline CCryptProv::CCryptProv( HCRYPTPROV hProv, BOOL bTakeOwnership ) throw()
{
	m_hProv = hProv;
	if (m_hProv && !bTakeOwnership)
		AddRef();
}

inline CCryptProv::~CCryptProv() throw()
{
	Release();
}

inline CCryptProv& CCryptProv::operator=( const CCryptProv& prov ) throw()
{
    if(this!=&prov)
    {
	    Release();

	    m_hProv = prov.m_hProv;
	    if( m_hProv != NULL )
	    {
		    AddRef();
	    }
    }
	return( *this );
}

inline HRESULT CCryptProv::AddRef() throw()
{
	ATLASSUME( m_hProv != NULL );

	if (!CryptContextAddRef( m_hProv, NULL, 0))
	{
		return AtlHresultFromLastError();
	}
	return S_OK;
}

inline void CCryptProv::Attach( HCRYPTPROV hProv, BOOL bTakeOwnership ) throw()
{
	ATLASSUME( m_hProv == NULL );

	m_hProv = hProv;
	if (m_hProv && !bTakeOwnership)
		AddRef();
}

inline HCRYPTPROV CCryptProv::Detach() throw()
{
	HCRYPTPROV hProv;

	hProv = m_hProv;
	m_hProv = NULL;

	return( hProv );
}


inline CCryptProv::CCryptProv() throw() :
	m_hProv( NULL )
{
}

inline HRESULT CCryptProv::Release() throw()
{
	if( m_hProv != NULL )
	{
		if (!CryptReleaseContext( m_hProv, 0 ))
		{
			return AtlHresultFromLastError();
		}
		m_hProv = NULL;
	}
	return S_OK;
}

inline HRESULT CCryptProv::Initialize(
	DWORD dwProviderType,
	LPCTSTR szContainer,
	LPCTSTR szProvider,
	DWORD dwFlags) throw()
{
	ATLASSUME(m_hProv == NULL);

	if (!CryptAcquireContext(&m_hProv, szContainer, szProvider, dwProviderType, dwFlags))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptProv::InitVerifyContext(
	DWORD dwProviderType,
	LPCTSTR szProvider,
	DWORD dwFlags) throw()
{
	ATLASSUME(m_hProv == NULL);

	if (!CryptAcquireContext(&m_hProv, NULL, szProvider, dwProviderType, CRYPT_VERIFYCONTEXT | dwFlags))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptProv::InitCreateKeySet(
	DWORD dwProviderType,
	LPCTSTR szContainer,
	LPCTSTR szProvider, 
	DWORD dwFlags) throw()
{
	ATLASSUME(m_hProv == NULL);

	if (!CryptAcquireContext(&m_hProv, szContainer, szProvider, dwProviderType, CRYPT_NEWKEYSET | dwFlags))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptProv::DeleteKeySet(
	DWORD dwProviderType,
	LPCTSTR szContainer,
	LPCTSTR szProvider,
	DWORD dwFlags) throw()
{
	HCRYPTPROV hProv = NULL;
	if (!CryptAcquireContext(&hProv, szContainer, szProvider, dwProviderType, CRYPT_DELETEKEYSET | dwFlags))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}


inline HRESULT CCryptProv::Uninitialize() throw()
{
	ATLASSUME(m_hProv != NULL);

	if (!CryptReleaseContext(m_hProv, 0))
	{
		return AtlHresultFromLastError();
	}
	else 
	{
		m_hProv = NULL;
		return S_OK;
	}
}

inline HRESULT CCryptProv::GetParam(DWORD dwParam, BYTE * pbData, DWORD * pdwDataLen, DWORD dwFlags) throw()
{
	ATLASSUME(m_hProv != NULL);

	if (!CryptGetProvParam(m_hProv, dwParam, pbData, pdwDataLen, dwFlags))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptProv::SetParam( DWORD dwParam, BYTE* pbData, DWORD dwFlags) throw()
{
	ATLASSUME(m_hProv != NULL);

	if (!CryptSetProvParam(m_hProv, dwParam, pbData, dwFlags ))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptProv::GetName(__out_bcount_part(*pdwLength, *pdwLength) LPSTR szBuf, __inout DWORD * pdwLength) throw()
{
	return GetParam(PP_NAME, (BYTE *)szBuf, pdwLength);
}

inline HRESULT CCryptProv::GetContainer(__out_bcount_part(*pdwLength, *pdwLength) LPSTR szBuf, __inout DWORD * pdwLength) throw()
{
	return GetParam(PP_CONTAINER, (BYTE *)szBuf, pdwLength);
}

inline HRESULT CCryptProv::GetImpType(DWORD * pdwImpType) throw()
{
	DWORD dwLength = sizeof(DWORD);
	return GetParam(PP_IMPTYPE, (BYTE *)pdwImpType, &dwLength);
}

inline HRESULT CCryptProv::GetVersion(DWORD * pdwVersion) throw()
{
	DWORD dwLength = sizeof(DWORD);
	return GetParam(PP_VERSION, (BYTE *)pdwVersion, &dwLength);
}

inline HRESULT CCryptProv::GetProvType(DWORD * pdwType) throw()
{
	DWORD dwLength = sizeof(DWORD);
	return GetParam(PP_PROVTYPE, (BYTE * )pdwType, &dwLength);
}

inline HRESULT CCryptProv::GetSecurityDesc(SECURITY_INFORMATION * pSecInfo) throw()
{
	DWORD dwSize = sizeof(SECURITY_INFORMATION);
	return GetParam(PP_KEYSET_SEC_DESCR, (BYTE *)pSecInfo, &dwSize);
}

inline HRESULT CCryptProv::SetSecurityDesc(SECURITY_INFORMATION SecInfo) throw()
{
	return SetParam(PP_KEYSET_SEC_DESCR, (BYTE *)&SecInfo);
}

inline HRESULT CCryptProv::GenRandom(ULONG nLength, BYTE* pbBuffer ) throw()
{
	ATLASSUME(m_hProv != NULL);

	if (!CryptGenRandom( m_hProv, nLength, pbBuffer ))
	{
		return AtlHresultFromLastError();
	}

	return S_OK;
}

inline CCryptHash::CCryptHash() throw() :
	m_hHash( NULL )
{
}

inline CCryptHash::CCryptHash( const CCryptHash& hash ) throw()
{
	m_hHash = hash.Duplicate();
}

inline CCryptHash::CCryptHash( HCRYPTHASH hHash, BOOL bTakeOwnership ) throw()
{
	if (bTakeOwnership)
		m_hHash = hHash;
	else
	{
		m_hHash = NULL;
		BOOL bRet = ::CryptDuplicateHash( hHash, NULL, 0, &m_hHash );
		if (!bRet)
			m_hHash = NULL;
	}
}

inline CCryptHash::~CCryptHash() throw()
{
	Destroy();
}

inline void CCryptHash::Attach( HCRYPTHASH hHash, BOOL bTakeOwnership ) throw()
{
	ATLASSUME( m_hHash == NULL );

	if (bTakeOwnership)
		m_hHash = hHash;
	else
	{
		m_hHash = NULL;
		BOOL bRet = ::CryptDuplicateHash( hHash, NULL, 0, &m_hHash );
		if (!bRet)
			m_hHash = NULL;
	}
}

inline void CCryptHash::Destroy() throw()
{
	if( m_hHash != NULL )
	{
		BOOL bSuccess;

		bSuccess = ::CryptDestroyHash( m_hHash );

		// can fail if the cryptographic service provider
		// (managed by CCryptProv) has already been destroyed
		ATLASSERT( bSuccess );
		m_hHash = NULL;
	}
}

inline HCRYPTHASH CCryptHash::Detach() throw()
{
	HCRYPTHASH hHash;

	hHash = m_hHash;
	m_hHash = NULL;

	return hHash;
}

inline HCRYPTHASH CCryptHash::Duplicate() const throw()
{
	BOOL bSuccess;
	HCRYPTHASH hHash;

	ATLASSUME( m_hHash != NULL );

	hHash = NULL;
	bSuccess = ::CryptDuplicateHash( m_hHash, NULL, 0, &hHash );
	if( !bSuccess )
	{
		return NULL;
	}

	return hHash;
}

inline HRESULT CCryptHash::Uninitialize() throw()
{
	ATLASSUME(m_hHash != NULL);

	if (!CryptDestroyHash(m_hHash))
	{
		return AtlHresultFromLastError();
	}
	else 
	{
		m_hHash = NULL;
		return S_OK;
	}
}

inline HRESULT CCryptHash::Detach(HCRYPTHASH * phHash) throw()
{
	ATLASSERT(phHash);
	if (!phHash)
		return E_INVALIDARG;

	*phHash = m_hHash;
	m_hHash = NULL;

	return S_OK;
}

inline HRESULT CCryptHash::AddData(const BYTE * pbData, DWORD dwDataLen, DWORD dwFlags) throw()
{
	ATLASSUME(m_hHash != NULL);

	if (!CryptHashData(m_hHash, pbData, dwDataLen, dwFlags))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;

}

inline HRESULT CCryptHash::AddString(LPCTSTR szData, DWORD dwFlags) throw()
{
	return AddData((BYTE *)szData, (DWORD)_tcslen(szData) * sizeof(TCHAR), dwFlags);
}

inline HRESULT CCryptHash::GetParam(DWORD dwParam, BYTE * pbData, DWORD * pdwDataLen, DWORD dwFlags) throw()
{
	ATLASSUME(m_hHash != NULL);

	if (!CryptGetHashParam(m_hHash, dwParam, pbData, pdwDataLen, dwFlags))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptHash::SetParam(DWORD dwParam, BYTE * pbData, DWORD dwFlags) throw()
{
	ATLASSUME(m_hHash != NULL);

	if (!CryptSetHashParam(m_hHash, dwParam, pbData, dwFlags))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptHash::GetAlgId(ALG_ID * pAlgId) throw()
{
	DWORD dwSize = sizeof(ALG_ID);
	return GetParam(HP_ALGID, (BYTE *)pAlgId, &dwSize);
}

inline HRESULT CCryptHash::GetSize(DWORD * pdwSize) throw()
{
	DWORD dwLength = sizeof(DWORD);
	return GetParam(HP_HASHSIZE, (BYTE *)pdwSize, &dwLength);
}

inline HRESULT CCryptHash::GetValue(BYTE * pBuf, DWORD * pdwSize) throw()
{
	return GetParam(HP_HASHVAL, pBuf, pdwSize);
}

inline HRESULT CCryptHash::SetValue(BYTE * pBuf) throw()
{
	return SetParam(HP_HASHVAL, pBuf);
}

inline HRESULT CCryptHash::Sign(
	BYTE * pbSignature,
	DWORD * pdwSigLen,
	DWORD dwFlags,
	DWORD dwKeySpec) throw()
{
	ATLASSUME(m_hHash != NULL);

	if (!CryptSignHash(m_hHash, dwKeySpec, NULL, dwFlags, pbSignature, pdwSigLen))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptHash::VerifySignature(
	const BYTE * pbSignature,
	DWORD dwSigLen,
	CCryptKey &PubKey,
	DWORD dwFlags) throw()
{
	ATLASSUME(m_hHash != NULL);

	if (!CryptVerifySignature(m_hHash, pbSignature, dwSigLen, PubKey.GetHandle(), NULL, dwFlags))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

__declspec(selectany) CCryptHash CCryptHash::EmptyHash = CCryptHash();
__declspec(selectany) CCryptKey CCryptKey::EmptyKey = CCryptKey();
inline CCryptKey::CCryptKey() throw() :
	m_hKey( NULL )
{
}

inline CCryptKey::CCryptKey( const CCryptKey& key ) throw()
{
	m_hKey = key.Duplicate();
}

inline CCryptKey::CCryptKey( HCRYPTKEY hKey, BOOL bTakeOwnership ) throw()
{
	if (bTakeOwnership)
		m_hKey = hKey;
	else
	{
		BOOL bSuccess = ::CryptDuplicateKey( hKey, NULL, 0, &m_hKey );
		if( !bSuccess )
			m_hKey = NULL;
	}
}

inline CCryptKey::~CCryptKey() throw()
{
	Destroy();
}

inline void CCryptKey::Attach( HCRYPTKEY hKey, BOOL bTakeOwnership ) throw()
{
	ATLASSUME( m_hKey == NULL );
	if (bTakeOwnership)
		m_hKey = hKey;
	else
	{
		BOOL bSuccess = ::CryptDuplicateKey( hKey, NULL, 0, &m_hKey );
		if( !bSuccess )
			m_hKey = NULL;
	}
}

inline void CCryptKey::Destroy() throw()
{
	if( m_hKey != NULL )
	{
		BOOL bSuccess;

		bSuccess = ::CryptDestroyKey( m_hKey );

		// can fail if the cryptographic service provider
		// (managed by CCryptProv) has already been destroyed
		ATLASSERT( bSuccess );
		m_hKey = NULL;
	}
}

inline HCRYPTKEY CCryptKey::Detach() throw()
{
	HCRYPTKEY hKey;

	hKey = m_hKey;
	m_hKey = NULL;

	return( hKey );
}

inline HCRYPTKEY CCryptKey::Duplicate() const throw()
{
	BOOL bSuccess;

	ATLASSUME( m_hKey != NULL );

	HCRYPTKEY hKey = NULL;
	bSuccess = ::CryptDuplicateKey( m_hKey, NULL, 0, &hKey );
	if( !bSuccess )
		return NULL;

	return hKey;
}

inline HRESULT CCryptKey::Uninitialize() throw()
{
	ATLASSUME(m_hKey != NULL);

	if (!CryptDestroyKey(m_hKey))
	{
		return AtlHresultFromLastError();
	}
	else 
	{
		m_hKey = NULL;
		return S_OK;
	}
}	

inline HRESULT CCryptKey::Encrypt(
	BOOL final,
	BYTE * pbData,
	DWORD * pdwDataLen,
	DWORD dwBufLen,
	CCryptHash &Hash) throw()
{
	ATLASSUME(m_hKey != NULL);

	if (!::CryptEncrypt(m_hKey, Hash.GetHandle(), final, 0, pbData, pdwDataLen, dwBufLen))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;

}

inline HRESULT CCryptKey::Decrypt(BOOL final, BYTE * pbData, DWORD * pdwDataLen, CCryptHash &Hash) throw()
{
	ATLASSUME(m_hKey != NULL);

	if (!::CryptDecrypt(m_hKey, Hash.GetHandle(), final, 0, pbData, pdwDataLen))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}


inline HRESULT CCryptKey::Encrypt(
	const BYTE * pbPlainText,
	DWORD dwPlainTextLen,
	BYTE * pbCipherText,
	DWORD * pdwCipherTextLen,
	CCryptHash &Hash) throw()
{
	ATLASSUME(m_hKey != NULL);

	if (*pdwCipherTextLen < dwPlainTextLen)
		return ERROR_MORE_DATA;

	Checked::memcpy_s(pbCipherText, dwPlainTextLen, pbPlainText, dwPlainTextLen);
	DWORD dwSize = dwPlainTextLen;
	if (!::CryptEncrypt(m_hKey, Hash.GetHandle(), TRUE, 0, pbCipherText, &dwSize, *pdwCipherTextLen))
	{
		return AtlHresultFromLastError();
	}

	*pdwCipherTextLen = dwSize;
	return S_OK;

}

inline HRESULT CCryptKey::Decrypt(
	const BYTE * pbCipherText,
	DWORD dwCipherTextLen,
	BYTE * pbPlainText,
	DWORD * pdwPlainTextLen,
	CCryptHash &Hash) throw()
{
	ATLASSUME(m_hKey != NULL);

	if (*pdwPlainTextLen < dwCipherTextLen)
		return ERROR_MORE_DATA;

	Checked::memcpy_s(pbPlainText, dwCipherTextLen, pbCipherText, dwCipherTextLen);
	DWORD dwSize = dwCipherTextLen;
	if (!::CryptDecrypt(m_hKey, Hash.GetHandle(), TRUE, 0, pbPlainText, &dwSize))
	{
		return AtlHresultFromLastError();
	}

	*pdwPlainTextLen = dwSize;
	return S_OK;
}

inline HRESULT CCryptKey::EncryptString(
	LPCTSTR szPlainText,
	BYTE * pbCipherText,
	DWORD * pdwCipherTextLen,
	CCryptHash &Hash) throw()
{
	DWORD dwSize = ((DWORD)_tcslen(szPlainText) + 1) * sizeof(TCHAR);
	return Encrypt((BYTE *)szPlainText, dwSize, pbCipherText, pdwCipherTextLen, Hash);
}

inline HRESULT CCryptKey::ExportSimpleBlob(
	CCryptKey &ExpKey,
	DWORD dwFlags,
	BYTE * pbData,
	DWORD * pdwDataLen) throw()
{
	ATLASSUME(m_hKey != NULL);

	if (!CryptExportKey(m_hKey, ExpKey.GetHandle(), SIMPLEBLOB, dwFlags, pbData, pdwDataLen))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptKey::ExportPublicKeyBlob(
	CCryptKey &ExpKey,
	DWORD dwFlags,
	BYTE * pbData,
	DWORD * pdwDataLen) throw()
{
	ATLASSUME(m_hKey != NULL);

	if (!CryptExportKey(m_hKey, ExpKey.GetHandle(), PUBLICKEYBLOB, dwFlags, pbData, pdwDataLen))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptKey::ExportPrivateKeyBlob(
	CCryptKey &ExpKey,
	DWORD dwFlags,
	BYTE * pbData,
	DWORD * pdwDataLen) throw()
{
	ATLASSUME(m_hKey != NULL);

	if (!CryptExportKey(m_hKey, ExpKey.GetHandle(), PRIVATEKEYBLOB, dwFlags, pbData, pdwDataLen))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptKey::GetParam(DWORD dwParam, BYTE * pbData, DWORD * pdwDataLen, DWORD dwFlags) throw()
{
	ATLASSUME(m_hKey != NULL);

	if (!CryptGetKeyParam(m_hKey, dwParam, pbData, pdwDataLen, dwFlags))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptKey::SetParam(DWORD dwParam, BYTE * pbData, DWORD dwFlags) throw()
{
	ATLASSUME(m_hKey != NULL);

	if (!CryptSetKeyParam(m_hKey, dwParam, pbData, dwFlags))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptKey::GetAlgId(ALG_ID * pAlgId) throw()
{
	DWORD dwSize = sizeof(DWORD);
	return GetParam(KP_ALGID, (BYTE *)pAlgId, &dwSize);
}

inline HRESULT CCryptKey::SetAlgId(ALG_ID AlgId, DWORD dwFlags) throw()
{
	return SetParam(KP_ALGID, (BYTE *)&AlgId, dwFlags);
}

inline HRESULT CCryptKey::GetBlockLength(DWORD * pdwBlockLen) throw()
{
	DWORD dwSize = sizeof(DWORD);
	return GetParam(KP_BLOCKLEN, (BYTE *)pdwBlockLen, &dwSize);
}

inline HRESULT CCryptKey::GetKeyLength(DWORD * pdwKeyLen) throw()
{
	DWORD dwSize = sizeof(DWORD);
	return GetParam(KP_KEYLEN, (BYTE *)pdwKeyLen, &dwSize);
}

inline HRESULT CCryptKey::GetSalt(BYTE * pbSalt, DWORD * pdwLength) throw()
{
	return GetParam(KP_SALT, pbSalt, pdwLength);
}

inline HRESULT CCryptKey::SetSalt(BYTE * pbSalt) throw()
{
	return SetParam(KP_SALT, pbSalt);
}

inline HRESULT CCryptKey::SetSaltEx(_CRYPTOAPI_BLOB * pBlobSalt) throw()
{
	return SetParam(KP_SALT_EX, (BYTE *)pBlobSalt);
}

inline HRESULT CCryptKey::GetPermissions(DWORD * pdwPerms) throw()
{
	DWORD dwSize = sizeof(DWORD);
	return GetParam(KP_PERMISSIONS, (BYTE *)pdwPerms, &dwSize);
}

inline HRESULT CCryptKey::SetPermissions(DWORD dwPerms) throw()
{
	return SetParam(KP_PERMISSIONS, (BYTE *)&dwPerms);
}

inline HRESULT CCryptKey::GetP(BYTE * pbP, DWORD * pdwLength) throw()
{
	return GetParam(KP_P, (BYTE *)pbP, pdwLength);
}

inline HRESULT CCryptKey::SetP(_CRYPTOAPI_BLOB * pBlobP) throw()
{
	return SetParam(KP_P, (BYTE *)pBlobP);
}

inline HRESULT CCryptKey::SetP(BYTE * pbP, DWORD dwLength) throw()
{
	_CRYPTOAPI_BLOB blob = { dwLength, pbP };
	return SetParam(KP_P, (BYTE *)&blob);
}

inline HRESULT CCryptKey::GetQ(BYTE * pbQ, DWORD * pdwLength) throw()
{
	return GetParam(KP_Q, (BYTE *)pbQ, pdwLength);
}

inline HRESULT CCryptKey::SetQ(_CRYPTOAPI_BLOB * pBlobQ) throw()
{
	return SetParam(KP_Q, (BYTE *)pBlobQ);
}

inline HRESULT CCryptKey::SetQ(BYTE * pbQ, DWORD dwLength) throw()
{
	_CRYPTOAPI_BLOB blob = { dwLength, pbQ };
	return SetParam(KP_Q, (BYTE *)&blob);
}

inline HRESULT CCryptKey::GetG(BYTE * pbG, DWORD * pdwLength) throw()
{
	return GetParam(KP_G, (BYTE *)pbG, pdwLength);
}

inline HRESULT CCryptKey::SetG(_CRYPTOAPI_BLOB * pBlobG) throw()
{
	return SetParam(KP_G, (BYTE *)pBlobG);
}

inline HRESULT CCryptKey::SetG(BYTE * pbG, DWORD dwLength) throw()
{
	_CRYPTOAPI_BLOB blob = { dwLength, pbG };
	return SetParam(KP_G, (BYTE *)&blob);
}

inline HRESULT CCryptKey::SetX() throw()
{
	return SetParam(KP_X, NULL);
}

inline HRESULT CCryptKey::GetEffKeyLen(DWORD * pdwEffKeyLen) throw()
{
	DWORD dwSize = sizeof(DWORD);
	return GetParam(KP_EFFECTIVE_KEYLEN, (BYTE *)pdwEffKeyLen, &dwSize);
}

inline HRESULT CCryptKey::SetEffKeyLen(DWORD dwEffKeyLen) throw()
{
	return SetParam(KP_EFFECTIVE_KEYLEN, (BYTE *)&dwEffKeyLen);
}

inline HRESULT CCryptKey::GetPadding(DWORD * pdwPadding) throw()
{
	DWORD dwSize = sizeof(DWORD);
	return GetParam(KP_PADDING, (BYTE *)pdwPadding, &dwSize);
}

inline HRESULT CCryptKey::SetPadding(DWORD dwPadding) throw()
{
	return SetParam(KP_PADDING, (BYTE *)&dwPadding);
}

inline HRESULT CCryptKey::GetIV(BYTE * pbIV, DWORD * pdwLength) throw()
{
	return GetParam(KP_IV, pbIV, pdwLength);
}

inline HRESULT CCryptKey::SetIV(BYTE * pbIV) throw()
{
	return SetParam(KP_IV, pbIV);
}

inline HRESULT CCryptKey::GetMode(DWORD * pdwMode) throw()
{
	DWORD dwSize = sizeof(DWORD);
	return GetParam(KP_MODE, (BYTE *)pdwMode, &dwSize);
}

inline HRESULT CCryptKey::SetMode(DWORD dwMode) throw()
{
	return SetParam(KP_MODE, (BYTE *)&dwMode);
}

inline HRESULT CCryptKey::GetModeBits(DWORD * pdwModeBits) throw()
{
	DWORD dwSize = sizeof(DWORD);
	return GetParam(KP_MODE_BITS, (BYTE *)pdwModeBits, &dwSize);
}

inline HRESULT CCryptKey::SetModeBits(DWORD dwModeBits) throw()
{
	return SetParam(KP_MODE_BITS, (BYTE *)&dwModeBits);
}

inline HRESULT CCryptDerivedKey::Initialize(
	CCryptProv &Prov,
	CCryptHash &Hash,
	ALG_ID algid,
	DWORD dwFlags) throw()
{
	ATLASSUME(m_hKey == NULL);

	if (!CryptDeriveKey(Prov.GetHandle(), algid, Hash.GetHandle(), dwFlags, &m_hKey))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptRandomKey::Initialize(CCryptProv &Prov, ALG_ID algid, DWORD dwFlags) throw()
{
	ATLASSUME(m_hKey == NULL);

	if (!CryptGenKey(Prov.GetHandle(), algid, dwFlags, &m_hKey))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;

}

inline HRESULT CCryptUserExKey::Initialize(CCryptProv &Prov) throw()
{
	ATLASSUME(m_hKey == NULL);

	if (!CryptGetUserKey(Prov.GetHandle(), AT_KEYEXCHANGE, &m_hKey))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptUserExKey::Create(CCryptProv &Prov) throw()
{
	ATLASSUME(m_hKey == NULL);

	if (!CryptGenKey(Prov.GetHandle(), AT_KEYEXCHANGE, 0, &m_hKey))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptUserSigKey::Initialize(CCryptProv &Prov) throw()
{
	ATLASSUME(m_hKey == NULL);

	if (!CryptGetUserKey(Prov.GetHandle(), AT_SIGNATURE, &m_hKey))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptUserSigKey::Create(CCryptProv &Prov) throw()
{
	ATLASSUME(m_hKey == NULL);

	if (!CryptGenKey(Prov.GetHandle(), AT_SIGNATURE, 0, &m_hKey))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptImportKey::Initialize(
	CCryptProv &Prov,
	BYTE * pbData,
	DWORD dwDataLen,
	CCryptKey &PubKey,
	DWORD dwFlags) throw()
{
	ATLASSUME(m_hKey == NULL);

	if (!CryptImportKey(Prov.GetHandle(), pbData, dwDataLen, PubKey.GetHandle(), dwFlags, &m_hKey))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptKeyedHash::Initialize(
	CCryptProv &Prov,
	ALG_ID Algid,
	CCryptKey &Key,
	DWORD dwFlags) throw()
{
	ATLASSUME(m_hHash == NULL);

	if (!CryptCreateHash(Prov.GetHandle(), Algid, Key.GetHandle(), dwFlags, &m_hHash))
	{
		return AtlHresultFromLastError();
	}
	else return S_OK;
}

inline HRESULT CCryptMD5Hash::Initialize(CCryptProv &Prov, LPCTSTR szText) throw()
{
	ATLASSUME(m_hHash == NULL);

	if (!CryptCreateHash(Prov.GetHandle(), CALG_MD5, 0, 0, &m_hHash))
	{
		return AtlHresultFromLastError();
	}

	if (szText!=NULL)
		return AddString(szText);
	else return S_OK;
}

inline HRESULT CCryptMD4Hash::Initialize(CCryptProv &Prov, LPCTSTR szText) throw()
{
	ATLASSUME(m_hHash == NULL);

	if (!CryptCreateHash(Prov.GetHandle(), CALG_MD4, 0, 0, &m_hHash))
	{
		return AtlHresultFromLastError();
	}
	if (szText!=NULL)
		return AddString(szText);
	else return S_OK;
}

inline HRESULT CCryptMD2Hash::Initialize(CCryptProv &Prov, LPCTSTR szText) throw()
{
	ATLASSUME(m_hHash == NULL);

	if (!CryptCreateHash(Prov.GetHandle(), CALG_MD2, 0, 0, &m_hHash))
	{
		return AtlHresultFromLastError();
	}
	if (szText!=NULL)
		return AddString(szText);
	else return S_OK;
}

inline HRESULT CCryptSHAHash::Initialize(CCryptProv &Prov, LPCTSTR szText) throw()
{
	ATLASSUME(m_hHash == NULL);

	if (!CryptCreateHash(Prov.GetHandle(), CALG_SHA, 0, 0, &m_hHash))
	{
		return AtlHresultFromLastError();
	}
	if (szText!=NULL)
		return AddString(szText);
	else return S_OK;
}

inline HRESULT CCryptHMACHash::Initialize(CCryptProv &Prov, CCryptKey &Key, LPCTSTR szText) throw()
{
	ATLASSUME(m_hHash == NULL);

	if (!CryptCreateHash(Prov.GetHandle(), CALG_HMAC, Key.GetHandle(), 0, &m_hHash))
	{
		return AtlHresultFromLastError();
	}
	if (szText!=NULL)
		return AddString(szText);
	else return S_OK;

}

inline HRESULT CCryptMACHash::Initialize(CCryptProv &Prov, CCryptKey &Key, LPCTSTR szText) throw()
{
	ATLASSUME(m_hHash == NULL);

	if (!CryptCreateHash(Prov.GetHandle(), CALG_MAC, Key.GetHandle(), 0, &m_hHash))
	{
		return AtlHresultFromLastError();
	}
	if (szText!=NULL)
		return AddString(szText);
	else return S_OK;

}

inline HRESULT CCryptSSL3SHAMD5Hash::Initialize(CCryptProv &Prov, CCryptKey &Key, LPCTSTR szText) throw()
{
	ATLASSUME(m_hHash == NULL);

	if (!CryptCreateHash(Prov.GetHandle(), CALG_SSL3_SHAMD5, Key.GetHandle(), 0, &m_hHash))
	{
		return AtlHresultFromLastError();
	}
	if (szText!=NULL)
		return AddString(szText);
	else return S_OK;

}

}; // namespace ATL

#endif //__ATLCRYPT_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlcrypt.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCRYPT_H__
#define __ATLCRYPT_H__

#pragma once

#include <atlchecked.h>
#include <wincrypt.h>


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

class CCryptKey;

class CCryptProv
{
protected:
	HCRYPTPROV m_hProv;

public:
	CCryptProv() throw();
	CCryptProv( const CCryptProv& prov ) throw();
	explicit CCryptProv( HCRYPTPROV hProv, BOOL bTakeOwnership = FALSE ) throw();
	~CCryptProv() throw();

	CCryptProv& operator=( const CCryptProv& prov ) throw();

	HRESULT AddRef() throw();
	void Attach( HCRYPTPROV hProv, BOOL bTakeOwnership = FALSE ) throw();
	HCRYPTPROV Detach() throw();
	HRESULT Release() throw();


	HRESULT Initialize(DWORD dwProviderType = PROV_RSA_FULL, 
		LPCTSTR szContainer = NULL, LPCTSTR szProvider = MS_DEF_PROV,
		DWORD dwFlags = 0) throw();
	HRESULT InitVerifyContext(DWORD dwProviderType = PROV_RSA_FULL, 
		LPCTSTR szProvider = MS_DEF_PROV, DWORD dwFlags = 0) throw();
	HRESULT InitCreateKeySet(DWORD dwProviderType = PROV_RSA_FULL,
		LPCTSTR szContainer = NULL, LPCTSTR szProvider = MS_DEF_PROV,
		DWORD dwFlags = 0) throw();

	HRESULT DeleteKeySet(DWORD dwProviderType = PROV_RSA_FULL, 
		LPCTSTR szContainer = NULL, LPCTSTR szProvider = MS_DEF_PROV,
		DWORD dwFlags = 0) throw();

	HRESULT Uninitialize();

	HRESULT GetParam(DWORD dwParam, BYTE * pbData, DWORD * pdwDataLen, DWORD dwFlags = 0) throw();
	HRESULT SetParam( DWORD dwParam, BYTE* pbData, DWORD dwFlags = 0) throw();
	HRESULT GetName(__out_ecount_part_z(*pdwLength, *pdwLength) LPSTR szBuf, __inout DWORD * pdwLength) throw();
	HRESULT GetContainer(__out_ecount_part_z(*pdwLength, *pdwLength) LPSTR szBuf, __inout DWORD * pdwLength) throw();
	HRESULT GetImpType(DWORD * pdwImpType) throw();
	HRESULT GetVersion(DWORD * pdwVersion) throw();
	HRESULT GetProvType(DWORD * pdwType) throw();
	HRESULT GetSecurityDesc(SECURITY_INFORMATION * pSecInfo) throw();
	HRESULT SetSecurityDesc(SECURITY_INFORMATION SecInfo) throw();

	HRESULT GenRandom(ULONG nLength, BYTE* pbBuffer ) throw();

	inline HCRYPTPROV GetHandle() throw()
	{
		return m_hProv;
	}
}; // class CCryptProv


// class CCryptHash
// Provides base functionality of hashes.
class CCryptHash
{
protected:
	HCRYPTHASH m_hHash;

public:
	CCryptHash() throw();
	CCryptHash( const CCryptHash& hash ) throw();
	explicit CCryptHash( HCRYPTHASH hHash, BOOL bTakeOwnership = FALSE ) throw();
	~CCryptHash() throw();

	void Attach( HCRYPTHASH hHash, BOOL bTakeOwnership = FALSE ) throw();
	void Destroy() throw();
	HCRYPTHASH Detach() throw();
	HCRYPTHASH Duplicate() const throw();

	HRESULT Uninitialize() throw();
	HRESULT Detach(HCRYPTHASH * phHash) throw();
	HRESULT AddData(const BYTE * pbData, DWORD dwDataLen, DWORD dwFlags = 0) throw();
	HRESULT AddString(LPCTSTR szData, DWORD dwFlags = 0) throw();
	HRESULT GetParam(DWORD dwParam, BYTE * pbData, DWORD * pdwDataLen, DWORD dwFlags = 0) throw();
	HRESULT SetParam(DWORD dwParam, BYTE * pbData, DWORD dwFlags = 0) throw();
	HRESULT GetAlgId(ALG_ID * pAlgId) throw();
	HRESULT GetSize(DWORD * pdwSize) throw();
	HRESULT GetValue(BYTE * pBuf, DWORD * pdwSize) throw();
	HRESULT SetValue(BYTE * pBuf) throw();
	HRESULT Sign(
		BYTE * pbSignature,
		DWORD * pdwSigLen,
		DWORD dwFlags = 0,
		DWORD dwKeySpec = AT_SIGNATURE) throw();
	HRESULT VerifySignature(
		const BYTE * pbSignature,
		DWORD pdwSignLen,
		CCryptKey &PubKey,
		DWORD dwFlags = 0) throw();

	inline HCRYPTHASH GetHandle()
	{
		return m_hHash;
	}
	static CCryptHash EmptyHash;

}; // class CCryptHash

// class CCryptKey
// Provides the functionality for cryptographic keys, i.e. encrypting, decrypting.
class CCryptKey
{
protected:
	HCRYPTKEY m_hKey;

public:
	CCryptKey() throw();
	CCryptKey( const CCryptKey& key ) throw();
	explicit CCryptKey( HCRYPTKEY hKey, BOOL bTakeOwnership = FALSE ) throw();
	~CCryptKey() throw();

	void Attach( HCRYPTKEY hKey, BOOL bTakeOwnership = FALSE ) throw();
	void Destroy() throw();
	HCRYPTKEY Detach() throw();
	HCRYPTKEY Duplicate() const throw();

	HRESULT Uninitialize() throw();
	HRESULT Encrypt(
		BOOL final,
		BYTE * pbData,
		DWORD * pdwDataLen,
		DWORD dwBufLen,
		CCryptHash &Hash = CCryptHash::EmptyHash) throw();

	HRESULT Encrypt(
		const BYTE * pbPlainText,
		DWORD dwPlainTextLen,
		BYTE * pbCipherText,
		DWORD * pdwCipherTextLen,
		CCryptHash &Hash = CCryptHash::EmptyHash) throw();

	HRESULT Decrypt(
		BOOL final,
		BYTE * pbData,
		DWORD * pdwDataLen,
		CCryptHash &Hash = CCryptHash::EmptyHash) throw();
	HRESULT Decrypt(
		const BYTE * pbCipherText,
		DWORD dwCipherTextLen,
		BYTE * pbPlainText,
		DWORD * pdwPlainTextLen,
		CCryptHash &Hash = CCryptHash::EmptyHash) throw();
	HRESULT EncryptString(
		LPCTSTR szPlainText,
		BYTE * pbCipherText,
		DWORD * pdwCipherTextLen,
		CCryptHash &Hash = CCryptHash::EmptyHash) throw();
	HRESULT ExportSimpleBlob(
		CCryptKey &ExpKey,
		DWORD dwFlags,
		BYTE * pbData,
		DWORD * pdwDataLen) throw();
	HRESULT ExportPublicKeyBlob(
		CCryptKey &ExpKey,
		DWORD dwFlags,
		BYTE * pbData,
		DWORD * pdwDataLen) throw();
	HRESULT ExportPrivateKeyBlob(
		CCryptKey &ExpKey,
		DWORD dwFlags,
		BYTE * pbData,
		DWORD * pdwDataLen) throw();
	HRESULT GetParam(DWORD dwParam, BYTE * pbData, DWORD * pdwDataLen, DWORD dwFlags = 0) throw();
	HRESULT SetParam(DWORD dwParam, BYTE * pbData, DWORD dwFlags = 0) throw();
	HRESULT GetAlgId(ALG_ID * pAlgId) throw();
	HRESULT SetAlgId(ALG_ID AlgId, DWORD dwFlags) throw();
	HRESULT GetBlockLength(DWORD * pdwBlockLen) throw();
	HRESULT GetKeyLength(DWORD * pdwKeyLen) throw();
	HRESULT GetSalt(BYTE * pbSalt, DWORD * pdwLength) throw();
	HRESULT SetSalt(BYTE * pbSalt) throw();
	HRESULT SetSaltEx(_CRYPTOAPI_BLOB * pBlobSalt) throw();
	HRESULT GetPermissions(DWORD * pdwPerms) throw();
	HRESULT SetPermissions(DWORD dwPerms) throw();
	HRESULT GetP(BYTE * pbP, DWORD * pdwLength) throw();
	HRESULT SetP(_CRYPTOAPI_BLOB * pBlobP) throw();
	HRESULT SetP(BYTE * pbP, DWORD dwLength) throw();
	HRESULT GetQ(BYTE * pbQ, DWORD * pdwLength) throw();
	HRESULT SetQ(_CRYPTOAPI_BLOB * pBlobQ) throw();
	HRESULT SetQ(BYTE * pbQ, DWORD dwLength) throw();
	HRESULT GetG(BYTE * pbG, DWORD * pdwLength) throw();
	HRESULT SetG(_CRYPTOAPI_BLOB * pBlobG) throw();
	HRESULT SetG(BYTE * pbG, DWORD dwLength) throw();
	HRESULT SetX() throw();
	HRESULT GetEffKeyLen(DWORD * pdwEffKeyLen) throw();
	HRESULT SetEffKeyLen(DWORD dwEffKeyLen) throw();
	HRESULT GetPadding(DWORD * pdwPadding) throw();
	HRESULT SetPadding(DWORD dwPadding) throw();
	HRESULT GetIV(BYTE * pbIV, DWORD * pdwLength) throw();
	HRESULT SetIV(BYTE * pbIV) throw();
	HRESULT GetMode(DWORD * pdwMode) throw();
	HRESULT SetMode(DWORD dwMode) throw();
	HRESULT GetModeBits(DWORD * pdwModeBits) throw();
	HRESULT SetModeBits(DWORD dwModeBits) throw();

	inline HCRYPTKEY GetHandle() throw()
	{
		return m_hKey;
	}

	static CCryptKey EmptyKey;
}; // class CCryptKey



// Specific instances of Keys and Hashes

// class CCryptDerivedKey
// A key that is derived from a hashed password.  Two keys derived 
// from the same password will be identical.
class CCryptDerivedKey : public CCryptKey
{
public:
	HRESULT Initialize(
		CCryptProv &Prov,
		CCryptHash &Hash,
		ALG_ID algid = CALG_RC4,
		DWORD dwFlags = CRYPT_EXPORTABLE) throw();
}; // class CCryptDerivedKey

// class CCryptRandomKey
// A randomly generated key.  Can be used internally by a program 
// to protect data during execution, or can be exported with Crypt.Export
//
// Currently it is possible to pass in AT_KEYEXCHANGE or AT_SIGNATURE 
// for algid, but these two will generate keys for the current key set, and 
// the resulting handle can only be used for exporting and importing keys or 
// signing hashes.
class CCryptRandomKey : public CCryptKey
{
public:
	HRESULT Initialize(
		CCryptProv &Prov,
		ALG_ID algid = CALG_RC4,
		DWORD dwFlags = CRYPT_EXPORTABLE) throw();
}; // class CCryptRandomKey

// class CCryptUserExKey
// Obtains the user's key exchange key pair.
class CCryptUserExKey : public CCryptKey
{
public:
	HRESULT Initialize(CCryptProv &Prov) throw();
	HRESULT Create(CCryptProv &Prov) throw();
}; // class CCryptUserExKey

// class CCryptUserSigKey
// Obtains the user's signature key pair
class CCryptUserSigKey : public CCryptKey
{
public:
	HRESULT Initialize(CCryptProv &Prov) throw();
	HRESULT Create(CCryptProv &Prov) throw();
}; // class CCryptUserSigKey

// class CCryptImportKey
// Forms a key from an imported key blob
class CCryptImportKey : public CCryptKey
{
public:
	HRESULT Initialize(
		CCryptProv &Prov,
		BYTE * pbData,
		DWORD dwDataLen,
		CCryptKey &PubKey,
		DWORD dwFlags) throw();
}; // class CCryptImportKey


// class CCryptHash
// A generic hash that may or may not take a key.  
class CCryptKeyedHash : public CCryptHash
{
public:

	HRESULT Initialize(CCryptProv &Prov, ALG_ID Algid, CCryptKey &Key, DWORD dwFlags) throw();
}; // class CCryptKeyedHash

// class CCryptMD5Hash
// RSA's MD5 hash (RSA's most recent hash as of 9/7/99);
class CCryptMD5Hash : public CCryptHash
{
public:

	HRESULT Initialize(CCryptProv &Prov, LPCTSTR szText = NULL) throw();
}; // class CCryptMD5Hash

// class CCryptMD4Hash
// RSA's MD4 hash
class CCryptMD4Hash : public CCryptHash
{
public:

	HRESULT Initialize(CCryptProv &Prov, LPCTSTR szText = NULL) throw();
}; // class CCryptMD4Hash


// class CCryptMD2Hash
// RSA's MD2 hash
class CCryptMD2Hash : public CCryptHash
{
public:

	HRESULT Initialize(CCryptProv &Prov, LPCTSTR szText = NULL) throw();
}; // class CCryptMD2Hash


// class CCryptSHAHash
// The Secure Hash Algorithm hash, from NIST and NSA.  Technically, SHA-1.
class CCryptSHAHash : public CCryptHash
{
public:

	HRESULT Initialize(CCryptProv &Prov, LPCTSTR szText = NULL) throw();
}; // class CCryptSHAHash

// The Secure Hash Algorithm, from NIST and NSA.  Identical to CCryptSHA
typedef CCryptSHAHash CCryptSHA1Hash;


// class CCryptHMACHash
// Hash-base Message Authentication Code keyed hash
class CCryptHMACHash : public CCryptHash
{
public:
	HRESULT Initialize(CCryptProv &Prov, CCryptKey &Key, LPCTSTR szText = NULL) throw();
}; // class CCryptHMACHash

// class CCryptMACHash
// Message Authentication Code keyed hash.  Believed to be less secure than HMAC
class CCryptMACHash : public CCryptHash
{
public:
	HRESULT Initialize(CCryptProv &Prov, CCryptKey &Key, LPCTSTR szText = NULL) throw();
}; // class CCryptMACHash

// class CCryptSSL3SHAMD5Hash
// Hash algorithm used by Secure Socket Layer
class CCryptSSL3SHAMD5Hash : public CCryptHash
{
public:
	HRESULT Initialize(CCryptProv &Prov, CCryptKey &Key, LPCTSTR szText = NULL) throw();
}; // class CCryptSSl3SHAMD5Hash

}; // namespace ATL
 

#include <atlcrypt.inl>
#pragma pack(pop)
#endif  // __ATLCRYPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlconv.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCONV_H__
#define __ATLCONV_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable: 4127) // unreachable code
#endif //!_ATL_NO_PRAGMA_WARNINGS

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atldef.h>
#include <stddef.h>
#ifdef _WIN32_WCE
#include <altcecrt.h>
#endif // _WIN32_WCE
#include <atlalloc.h>
#include <atlosapice.h>

#ifndef __wtypes_h__

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_IX86)
#define _X86_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_AMD64)
#define _AMD64_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_M68K)
#define _68K_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_MPPC)
#define _MPPC_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_M_IX86) && !defined(_AMD64_) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <winnls.h>

#if defined(_WIN32) && !defined(OLE2ANSI)

typedef WCHAR OLECHAR;
typedef OLECHAR  *LPOLESTR;
typedef const OLECHAR  *LPCOLESTR;
#define OLESTR(str) L##str

#else

typedef char      OLECHAR;
typedef LPSTR     LPOLESTR;
typedef LPCSTR    LPCOLESTR;
#define OLESTR(str) str

#endif	// _WIN32 && !OLE2ANSI
#endif	// __wtypes_h__

#ifndef _OLEAUTO_H_
typedef LPWSTR BSTR;// must (semantically) match typedef in oleauto.h

extern "C"
{
__declspec(dllimport) BSTR __stdcall SysAllocString(const OLECHAR *);
__declspec(dllimport) BSTR __stdcall SysAllocStringLen(const OLECHAR *, UINT);
__declspec(dllimport) INT  __stdcall SysReAllocStringLen(BSTR *, const OLECHAR *, UINT);
__declspec(dllimport) void __stdcall SysFreeString(BSTR);
}
#endif

// we use our own implementation of InterlockedExchangePointer because of problems with the one in system headers
#if defined(_M_IX86) && (_WIN32_WCE < 0x600)
#undef InterlockedExchangePointer
inline void* WINAPI InterlockedExchangePointer(void** pp, void* pNew) throw()
{
	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );
}
#endif

#define ATLCONV_DEADLAND_FILL _SECURECRT_FILL_BUFFER_PATTERN

#pragma pack(push,_ATL_PACKING)
namespace ATL
{
#ifndef _CONVERSION_DONT_USE_THREAD_LOCALE
typedef UINT (WINAPI *ATLGETTHREADACP)();

inline UINT WINAPI _AtlGetThreadACPFake() throw()
{
	UINT nACP = 0;

	LCID lcidThread = ATL::GetThreadLocale();

	char szACP[7];
	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
	// executed on Windows 2000.
	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)
	{
		char* pch = szACP;
		while (*pch != '\0')
		{
			nACP *= 10;
			nACP += *pch++ - '0';
		}
	}
	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
	if (nACP == 0)
		nACP = ::GetACP();

	return nACP;
}

inline UINT WINAPI _AtlGetThreadACPReal() throw()
{
	return( CP_THREAD_ACP );
}

extern ATLGETTHREADACP g_pfnGetThreadACP;

#pragma managed(push, off)
inline UINT WINAPI _AtlGetThreadACPThunk() throw()
{
	OSVERSIONINFO ver;
	ATLGETTHREADACP pfnGetThreadACP;

	ver.dwOSVersionInfoSize = sizeof( ver );
	::GetVersionEx( &ver );
	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )
	{
		// On Win2K, CP_THREAD_ACP is supported
		pfnGetThreadACP = _AtlGetThreadACPReal;
	}
	else
	{
		pfnGetThreadACP = _AtlGetThreadACPFake;
	}
	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), reinterpret_cast< void** >(pfnGetThreadACP) );

	return( g_pfnGetThreadACP() );
}
#pragma managed(pop)

__declspec( selectany ) ATLGETTHREADACP g_pfnGetThreadACP = _AtlGetThreadACPThunk;

inline UINT WINAPI _AtlGetConversionACP() throw()
{
	return( g_pfnGetThreadACP() );
}

#else

inline UINT WINAPI _AtlGetConversionACP() throw()
{
	return( CP_ACP );
}

#endif  // _CONVERSION_DONT_USE_THREAD_LOCALE
template <class _CharType>
inline  void AtlConvAllocMemory(__deref_ecount_opt(nLength) _CharType** ppBuff,__in int nLength,__inout_ecount(nFixedBufferLength) _CharType* pszFixedBuffer,__in int nFixedBufferLength)
{
	ATLENSURE_THROW(ppBuff != NULL, E_INVALIDARG);
	ATLENSURE_THROW(nLength >= 0, E_INVALIDARG);
	ATLENSURE_THROW(pszFixedBuffer != NULL, E_INVALIDARG);

	//if buffer malloced, try to realloc.
	if (*ppBuff != pszFixedBuffer)
	{
		if( nLength > nFixedBufferLength )
		{
			_CharType* ppReallocBuf = static_cast< _CharType* >( _recalloc(*ppBuff, nLength,sizeof( _CharType ) ) );
			if (ppReallocBuf == NULL) 
			{
				AtlThrow( E_OUTOFMEMORY );
			}
			*ppBuff = ppReallocBuf;
		} else
		{
			free(*ppBuff);
			*ppBuff=pszFixedBuffer;
		}

	} else //Buffer is not currently malloced.
	{
		if( nLength > nFixedBufferLength )
		{
			*ppBuff = static_cast< _CharType* >( calloc(nLength,sizeof( _CharType ) ) );
		} else
		{			
			*ppBuff=pszFixedBuffer;
		}
	}

	if (*ppBuff == NULL)
	{
		AtlThrow( E_OUTOFMEMORY );
	}

}

template <class _CharType>
inline void AtlConvFreeMemory(_CharType* pBuff,_CharType* pszFixedBuffer,int nFixedBufferLength)
{
	(nFixedBufferLength);
	if( pBuff != pszFixedBuffer )
	{
		free( pBuff );
	} 	
#ifdef _DEBUG
	else
	{		
		memset(pszFixedBuffer,ATLCONV_DEADLAND_FILL,nFixedBufferLength*sizeof(_CharType));
	}
#endif

}

template< int t_nBufferLength = 128 >
class CW2WEX
{
public:
	CW2WEX( __in_opt LPCWSTR psz ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz );
	}
	CW2WEX( __in_opt LPCWSTR psz, UINT nCodePage ) throw(...) :
		m_psz( m_szBuffer )
	{
		(void)nCodePage;  // Code page doesn't matter

		Init( psz );
	}
	~CW2WEX() throw()
	{
		AtlConvFreeMemory(m_psz,m_szBuffer,t_nBufferLength);
	}

	operator LPWSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init( __in_opt LPCWSTR psz ) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLength = lstrlenW( psz )+1;
		AtlConvAllocMemory(&m_psz,nLength,m_szBuffer,t_nBufferLength);
		Checked::memcpy_s( m_psz, nLength*sizeof( wchar_t ), psz, nLength*sizeof( wchar_t ));
	}

public:
	LPWSTR m_psz;
	wchar_t m_szBuffer[t_nBufferLength];

private:
	CW2WEX( const CW2WEX& ) throw();
	CW2WEX& operator=( const CW2WEX& ) throw();
};
typedef CW2WEX<> CW2W;

template< int t_nBufferLength = 128 >
class CA2AEX
{
public:
	CA2AEX( __in_opt LPCSTR psz ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz );
	}
	CA2AEX( __in_opt LPCSTR psz, UINT nCodePage ) throw(...) :
		m_psz( m_szBuffer )
	{
		(void)nCodePage;  // Code page doesn't matter

		Init( psz );
	}
	~CA2AEX() throw()
	{
		AtlConvFreeMemory(m_psz,m_szBuffer,t_nBufferLength);
	}

	operator LPSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init( __in_opt LPCSTR psz ) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLength = lstrlenA( psz )+1;
		AtlConvAllocMemory(&m_psz,nLength,m_szBuffer,t_nBufferLength);		
		Checked::memcpy_s( m_psz, nLength*sizeof( char ), psz, nLength*sizeof( char ));
	}

public:
	LPSTR m_psz;
	char m_szBuffer[t_nBufferLength];

private:
	CA2AEX( const CA2AEX& ) throw();
	CA2AEX& operator=( const CA2AEX& ) throw();
};
typedef CA2AEX<> CA2A;

template< int t_nBufferLength = 128 >
class CA2CAEX
{
public:
	CA2CAEX( __in LPCSTR psz ) throw(...) :
		m_psz( psz )
	{
	}
	CA2CAEX( __in LPCSTR psz, UINT nCodePage ) throw(...) :
		m_psz( psz )
	{
		(void)nCodePage;
	}
	~CA2CAEX() throw()
	{
	}

	operator LPCSTR() const throw()
	{
		return( m_psz );
	}

public:
	LPCSTR m_psz;

private:
	CA2CAEX( const CA2CAEX& ) throw();
	CA2CAEX& operator=( const CA2CAEX& ) throw();
};
typedef CA2CAEX<> CA2CA;

template< int t_nBufferLength = 128 >
class CW2CWEX
{
public:
	CW2CWEX( __in LPCWSTR psz ) throw(...) :
		m_psz( psz )
	{
	}
	CW2CWEX( __in LPCWSTR psz, UINT nCodePage ) throw(...) :
		m_psz( psz )
	{
		(void)nCodePage;
	}
	~CW2CWEX() throw()
	{
	}

	operator LPCWSTR() const throw()
	{
		return( m_psz );
	}

public:
	LPCWSTR m_psz;

private:
	CW2CWEX( const CW2CWEX& ) throw();
	CW2CWEX& operator=( const CW2CWEX& ) throw();
};
typedef CW2CWEX<> CW2CW;

template< int t_nBufferLength = 128 >
class CA2WEX
{
public:
	CA2WEX( __in_opt LPCSTR psz ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, _AtlGetConversionACP() );
	}
	CA2WEX( __in_opt LPCSTR psz, UINT nCodePage ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, nCodePage );
	}
	~CA2WEX() throw()
	{
		AtlConvFreeMemory(m_psz,m_szBuffer,t_nBufferLength);
	}

	operator LPWSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init( __in_opt LPCSTR psz, UINT nCodePage ) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLengthA = lstrlenA( psz )+1;
		int nLengthW = nLengthA;

		AtlConvAllocMemory(&m_psz,nLengthW,m_szBuffer,t_nBufferLength);

		BOOL bFailed=(0 == ::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, m_psz, nLengthW ) );
		if (bFailed)
		{
			if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
			{
				nLengthW = ::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, NULL, 0);
				AtlConvAllocMemory(&m_psz,nLengthW,m_szBuffer,t_nBufferLength);
				bFailed=(0 == ::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, m_psz, nLengthW ) );
			}			
		}
		if (bFailed)
		{
			AtlThrowLastWin32();
		}		
	}

public:
	LPWSTR m_psz;
	wchar_t m_szBuffer[t_nBufferLength];

private:
	CA2WEX( const CA2WEX& ) throw();
	CA2WEX& operator=( const CA2WEX& ) throw();
};
typedef CA2WEX<> CA2W;

template< int t_nBufferLength = 128 >
class CW2AEX
{
public:
	CW2AEX( __in_opt LPCWSTR psz ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, _AtlGetConversionACP() );
	}
	CW2AEX( __in_opt LPCWSTR psz, UINT nCodePage ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, nCodePage );
	}
	~CW2AEX() throw()
	{		
		AtlConvFreeMemory(m_psz,m_szBuffer,t_nBufferLength);
	}

	operator LPSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init( __in_opt LPCWSTR psz, __in UINT nConvertCodePage ) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLengthW = lstrlenW( psz )+1;		 
		int nLengthA = nLengthW*4;
		
		AtlConvAllocMemory(&m_psz,nLengthA,m_szBuffer,t_nBufferLength);

		BOOL bFailed=(0 == ::WideCharToMultiByte( nConvertCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ));
		if (bFailed)
		{
			if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
			{
				nLengthA = ::WideCharToMultiByte( nConvertCodePage, 0, psz, nLengthW, NULL, 0, NULL, NULL );
				AtlConvAllocMemory(&m_psz,nLengthA,m_szBuffer,t_nBufferLength);
				bFailed=(0 == ::WideCharToMultiByte( nConvertCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ));
			}			
		}
		if (bFailed)
		{
			AtlThrowLastWin32();
		}
	}

public:
	LPSTR m_psz;
	char m_szBuffer[t_nBufferLength];

private:
	CW2AEX( const CW2AEX& ) throw();
	CW2AEX& operator=( const CW2AEX& ) throw();
};
typedef CW2AEX<> CW2A;

#ifdef _UNICODE

	#define CW2T CW2W
	#define CW2TEX CW2WEX
	#define CW2CT CW2CW
	#define CW2CTEX CW2CWEX
	#define CT2W CW2W
	#define CT2WEX CW2WEX
	#define CT2CW CW2CW
	#define CT2CWEX CW2CWEX

	#define CA2T CA2W
	#define CA2TEX CA2WEX
	#define CA2CT CA2W
	#define CA2CTEX CA2WEX
	#define CT2A CW2A
	#define CT2AEX CW2AEX
	#define CT2CA CW2A
	#define CT2CAEX CW2AEX

#else  // !_UNICODE

	#define CW2T CW2A
	#define CW2TEX CW2AEX
	#define CW2CT CW2A
	#define CW2CTEX CW2AEX
	#define CT2W CA2W
	#define CT2WEX CA2WEX
	#define CT2CW CA2W
	#define CT2CWEX CA2WEX

	#define CA2T CA2A
	#define CA2TEX CA2AEX
	#define CA2CT CA2CA
	#define CA2CTEX CA2CAEX
	#define CT2A CA2A
	#define CT2AEX CA2AEX
	#define CT2CA CA2CA
	#define CT2CAEX CA2CAEX

#endif  // !_UNICODE

#define COLE2T CW2T
#define COLE2TEX CW2TEX
#define COLE2CT CW2CT
#define COLE2CTEX CW2CTEX
#define CT2OLE CT2W
#define CT2OLEEX CT2WEX
#define CT2COLE CT2CW
#define CT2COLEEX CT2CWEX

};  // namespace ATL
#pragma pack(pop)

#pragma pack(push,8)

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#ifndef _DEBUG
	#define USES_CONVERSION int _convert; (_convert); UINT _acp = ATL::_AtlGetConversionACP() /*CP_THREAD_ACP*/; (_acp); LPCWSTR _lpw; (_lpw); LPCSTR _lpa; (_lpa)
#else
	#define USES_CONVERSION int _convert = 0; (_convert); UINT _acp = ATL::_AtlGetConversionACP() /*CP_THREAD_ACP*/; (_acp); LPCWSTR _lpw = NULL; (_lpw); LPCSTR _lpa = NULL; (_lpa)
#endif

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#ifndef _DEBUG
	#define USES_CONVERSION_EX int _convert_ex; (_convert_ex); UINT _acp_ex = ATL::_AtlGetConversionACP(); (_acp_ex); LPCWSTR _lpw_ex; (_lpw_ex); LPCSTR _lpa_ex; (_lpa_ex); USES_ATL_SAFE_ALLOCA
#else
	#define USES_CONVERSION_EX int _convert_ex = 0; (_convert_ex); UINT _acp_ex = ATL::_AtlGetConversionACP(); (_acp_ex); LPCWSTR _lpw_ex = NULL; (_lpw_ex); LPCSTR _lpa_ex = NULL; (_lpa_ex); USES_ATL_SAFE_ALLOCA
#endif

#ifdef _WINGDI_
	ATLAPI_(LPDEVMODEA) AtlDevModeW2A(LPDEVMODEA lpDevModeA, const DEVMODEW* lpDevModeW);
#endif

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers
inline LPWSTR WINAPI AtlA2WHelper(__out_ecount(nChars) LPWSTR lpw, __in LPCSTR lpa, __in int nChars, __in UINT acp) throw()
{
	ATLASSERT(lpa != NULL);
	ATLASSERT(lpw != NULL);
	if (lpw == NULL || lpa == NULL)
		return NULL;
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);
	if(ret == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}		
	return lpw;
}

inline LPSTR WINAPI AtlW2AHelper(__out_ecount(nChars) LPSTR lpa, __in LPCWSTR lpw, __in int nChars, __in UINT acp) throw()
{
	ATLASSERT(lpw != NULL);
	ATLASSERT(lpa != NULL);
	if (lpa == NULL || lpw == NULL)
		return NULL;
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);
	if(ret == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}
	return lpa;
}
inline LPWSTR WINAPI AtlA2WHelper(__out_ecount(nChars) LPWSTR lpw, __in LPCSTR lpa, __in int nChars) throw()
{
	return AtlA2WHelper(lpw, lpa, nChars, CP_ACP);
}

inline LPSTR WINAPI AtlW2AHelper(__out_ecount(nChars) LPSTR lpa, __in LPCWSTR lpw, __in int nChars) throw()
{
	return AtlW2AHelper(lpa, lpw, nChars, CP_ACP);
}

#ifndef _CONVERSION_DONT_USE_THREAD_LOCALE
	#ifdef ATLA2WHELPER
		#undef ATLA2WHELPER
		#undef ATLW2AHELPER
	#endif
	#define ATLA2WHELPER AtlA2WHelper
	#define ATLW2AHELPER AtlW2AHelper
#else
	#ifndef ATLA2WHELPER
		#define ATLA2WHELPER AtlA2WHelper
		#define ATLW2AHELPER AtlW2AHelper
	#endif
#endif

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define A2W(lpa) (\
	((_lpa = lpa) == NULL) ? NULL : (\
		_convert = (ATL::lstrlenA(_lpa)+1),\
		(INT_MAX/2<_convert)? NULL :  \
		ATLA2WHELPER((LPWSTR) alloca(_convert*sizeof(WCHAR)), _lpa, _convert, _acp)))

#define W2A(lpw) (\
	((_lpw = lpw) == NULL) ? NULL : (\
		(_convert = (ATL::lstrlenW(_lpw)+1), \
		(_convert>INT_MAX/2) ? NULL : \
		ATLW2AHELPER((LPSTR) alloca(_convert*sizeof(WCHAR)), _lpw, _convert*sizeof(WCHAR), _acp))))


#define A2W_CP(lpa, cp) (\
	((_lpa = lpa) == NULL) ? NULL : (\
		_convert = (lstrlenA(_lpa)+1),\
		(INT_MAX/2<_convert)? NULL : \
		ATLA2WHELPER((LPWSTR) alloca(_convert*sizeof(WCHAR)), _lpa, _convert, (cp)))

#define W2A_CP(lpw, cp) (\
	((_lpw = lpw) == NULL) ? NULL : (\
		(_convert = (lstrlenW(_lpw)+1), \
		(_convert>INT_MAX/2) ? NULL : \
		ATLW2AHELPER((LPSTR) alloca(_convert*sizeof(WCHAR)), _lpw, _convert*sizeof(WCHAR), (cp))))

#endif

// The call to _alloca will not cause stack overflow if _AtlVerifyStackAvailable returns TRUE.
#define A2W_EX(lpa, nChars) (\
	((_lpa_ex = lpa) == NULL) ? NULL : (\
		_convert_ex = (ATL::lstrlenA(_lpa_ex)+1),\
		FAILED(::ATL::AtlMultiply(&_convert_ex, _convert_ex, static_cast<int>(sizeof(WCHAR)))) ? NULL : \
		ATLA2WHELPER(	\
		(LPWSTR)_ATL_SAFE_ALLOCA(_convert_ex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), \
			_lpa_ex, \
			_convert_ex, \
			_acp_ex)))

#define A2W_EX_DEF(lpa) A2W_EX(lpa, _ATL_SAFE_ALLOCA_DEF_THRESHOLD)

#define W2A_EX(lpw, nChars) (\
	((_lpw_ex = lpw) == NULL) ? NULL : (\
		_convert_ex = (ATL::lstrlenW(_lpw_ex)+1),\
		FAILED(::ATL::AtlMultiply(&_convert_ex, _convert_ex, static_cast<int>(sizeof(WCHAR)))) ? NULL : \
		ATLW2AHELPER(	\
			(LPSTR)_ATL_SAFE_ALLOCA(_convert_ex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), \
			_lpw_ex, \
			_convert_ex, \
			_acp_ex)))

#define W2A_EX_DEF(lpa) W2A_EX(lpa, _ATL_SAFE_ALLOCA_DEF_THRESHOLD)

#define A2W_CP_EX(lpa, nChars, cp) (\
	((_lpa_ex = lpa) == NULL) ? NULL : (\
		_convert_ex = (lstrlenA(_lpa_ex)+1),\
		FAILED(::ATL::AtlMultiply(&_convert_ex, _convert_ex, static_cast<int>(sizeof(WCHAR)))) ? NULL : \
		ATLA2WHELPER(	\
			(LPWSTR)_ATL_SAFE_ALLOCA(_convert_ex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), \
			_lpa_ex, \
			_convert_ex, \
			(cp))))

#define W2A_CP_EX(lpw, nChars, cp) (\
	((_lpw_ex = lpw) == NULL) ? NULL : (\
		_convert_ex = (lstrlenW(_lpw_ex)+1),\
		FAILED(::ATL::AtlMultiply(&_convert_ex, _convert_ex, static_cast<int>(sizeof(WCHAR)))) ? NULL : \
		ATLW2AHELPER(	\
			(LPSTR)_ATL_SAFE_ALLOCA(_convert_ex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), \
			_lpw_ex, \
			_convert_ex, \
			(cp))))

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))

#define A2CW_CP(lpa, cp) ((LPCWSTR)A2W_CP(lpa, (cp)))
#define W2CA_CP(lpw, cp) ((LPCSTR)W2A_CP(lpw, (cp)))

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#define A2CW_EX(lpa, nChar) ((LPCWSTR)A2W_EX(lpa, nChar))
#define A2CW_EX_DEF(lpa) ((LPCWSTR)A2W_EX_DEF(lpa))
#define W2CA_EX(lpw, nChar) ((LPCSTR)W2A_EX(lpw, nChar))
#define W2CA_EX_DEF(lpw) ((LPCSTR)W2A_EX_DEF(lpw))

#define A2CW_CP_EX(lpa, nChar, cp) ((LPCWSTR)A2W_CP_EX(lpa, nChar, (cp)))
#define W2CA_CP_EX(lpw, nChar, cp) ((LPCSTR)W2A_CP_EX(lpw, nChar, (cp)))

	inline int ocslen(__in_z LPCOLESTR x) throw() { return ATL::lstrlenW(x); }

#if _SECURE_ATL
	inline bool ocscpy_s(__out_ecount_z(maxSize) LPOLESTR dest, __in size_t maxSize, __in_z LPCOLESTR src) throw() 
		{ return 0 == memcpy_s(dest, maxSize*sizeof(WCHAR), src, (ocslen(src)+1)*sizeof(WCHAR)); }
	inline bool ocscat_s(__out_ecount_z(maxSize) LPOLESTR dest, __in size_t maxSize, __in_z LPCOLESTR src) throw() 
		{ return 0 == wcscat_s(dest, maxSize,src); }
#else
	inline bool ocscpy_s(__out_ecount_z(maxSize) LPOLESTR dest, __in size_t maxSize, __in_z LPCOLESTR src) throw() 
		{ (void)maxSize; memcpy(dest, src, (ocslen(src)+1)*sizeof(WCHAR)); return true; }
	inline bool ocscat_s(__out_ecount_z(maxSize) LPOLESTR dest, __in size_t maxSize, __in_z LPCOLESTR src) throw() 
		{ (void)maxSize; wcscat(dest, src); }
#endif

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
#if _SECURE_ATL
	_ATL_INSECURE_DEPRECATE("ocscpy is not safe. Intead, use ocscpy_s")
	inline OLECHAR* ocscpy(__out_z LPOLESTR dest, __in_z LPCOLESTR src) throw()
	{
#pragma warning(push)
#pragma warning(disable:4996)
		return wcscpy(dest, src);
#pragma warning(pop)
	}
	_ATL_INSECURE_DEPRECATE("ocscat is not safe. Intead, use ocscat_s")
	inline OLECHAR* ocscat(__out_z LPOLESTR dest, __in_z LPCOLESTR src) throw()
	{
#pragma warning(push)
#pragma warning(disable:4996)
		return wcscat(dest, src);
#pragma warning(pop)
	}
#else
	inline OLECHAR* ocscpy(__out_z LPOLESTR dest, __in_z LPCOLESTR src) throw() { return lstrcpyW(dest, src); }
	inline OLECHAR* ocscat(__out_z LPOLESTR dest, __in_z LPCOLESTR src) throw() { return lstrcatW(dest, src); }
#endif

	inline LPCOLESTR T2COLE_EX(__in_opt LPCTSTR lp, UINT) { return lp; }
	inline LPCOLESTR T2COLE_EX_DEF(__in_opt LPCTSTR lp) { return lp; }
	inline LPCTSTR OLE2CT_EX(__in_opt LPCOLESTR lp, UINT) { return lp; }
	inline LPCTSTR OLE2CT_EX_DEF(__in_opt LPCOLESTR lp) { return lp; }
	inline LPOLESTR T2OLE_EX(__in_opt LPTSTR lp, UINT) { return lp; }
	inline LPOLESTR T2OLE_EX_DEF(__in_opt LPTSTR lp) { return lp; }
	inline LPTSTR OLE2T_EX(__in_opt LPOLESTR lp, UINT) { return lp; }	
	inline LPTSTR OLE2T_EX_DEF(__in_opt LPOLESTR lp) { return lp; }	

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

	inline LPCOLESTR T2COLE(__in_opt LPCTSTR lp) { return lp; }
	inline LPCTSTR OLE2CT(__in_opt LPCOLESTR lp) { return lp; }
	inline LPOLESTR T2OLE(__in_opt LPTSTR lp) { return lp; }
	inline LPTSTR OLE2T(__in_opt LPOLESTR lp) { return lp; }
	inline LPOLESTR CharNextO(__in LPCOLESTR lp) throw() {return CharNextW(lp);}

#endif	 // _ATL_EX_CONVERSION_MACROS_ONLY

#else // !defined(_UNICODE)

#if _SECURE_ATL

	_ATL_INSECURE_DEPRECATE("ocscpy is not safe. Intead, use ocscpy_s")
	inline OLECHAR* ocscpy(__out_z LPOLESTR dest, __in_z LPCOLESTR src) throw()
	{
#pragma warning(push)
#pragma warning(disable:4996)
		return (LPOLESTR) memcpy(dest, src, (lstrlenW(src)+1)*sizeof(WCHAR));
#pragma warning(pop)
	}
	_ATL_INSECURE_DEPRECATE("ocscat is not safe. Intead, use ocscat_s")
	inline OLECHAR* ocscat(__inout_z LPOLESTR dest, __in_z LPCOLESTR src) throw()
	{
#pragma warning(push)
#pragma warning(disable:4996)
		return ocscpy(dest+ocslen(dest), src);
#pragma warning(pop)
	}

#else

	//lstrcpyW doesn't work on Win95, so we do this
	inline OLECHAR* ocscpy(__out_z LPOLESTR dest, __in_z LPCOLESTR src) throw()
	{
		return (LPOLESTR) memcpy(dest, src, (ATL::lstrlenW(src)+1)*sizeof(WCHAR));
	}
	inline OLECHAR* ocscat(__out_z LPOLESTR dest, __in_z LPCOLESTR src) throw()
	{
		return ocscpy(dest+ocslen(dest), src);
	}

#endif

	//CharNextW doesn't work on Win95 so we use this
	
	#define T2COLE_EX(lpa, nChar) A2CW_EX(lpa, nChar)
	#define T2COLE_EX_DEF(lpa) A2CW_EX_DEF(lpa)
	#define T2OLE_EX(lpa, nChar) A2W_EX(lpa, nChar)
	#define T2OLE_EX_DEF(lpa) A2W_EX_DEF(lpa)
	#define OLE2CT_EX(lpo, nChar) W2CA_EX(lpo, nChar)
	#define OLE2CT_EX_DEF(lpo) W2CA_EX_DEF(lpo)
	#define OLE2T_EX(lpo, nChar) W2A_EX(lpo, nChar)
	#define OLE2T_EX_DEF(lpo) W2A_EX_DEF(lpo)

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

	#define T2COLE(lpa) A2CW(lpa)
	#define T2OLE(lpa) A2W(lpa)
	#define OLE2CT(lpo) W2CA(lpo)
	#define OLE2T(lpo) W2A(lpo)

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

	inline LPOLESTR CharNextO(LPCOLESTR lp) throw() {return (LPOLESTR) ((*lp) ? (lp+1) : lp);}

#endif // defined(_UNICODE)

	inline LPOLESTR W2OLE_EX(__in_opt LPWSTR lp, UINT) { return lp; }
	inline LPOLESTR W2OLE_EX_DEF(__in_opt LPWSTR lp) { return lp; }
	inline LPWSTR OLE2W_EX(__in_opt LPOLESTR lp, UINT) { return lp; }
	inline LPWSTR OLE2W_EX_DEF(__in_opt LPOLESTR lp) { return lp; }
	#define A2OLE_EX A2W_EX
	#define A2OLE_EX_DEF A2W_EX_DEF
	#define OLE2A_EX W2A_EX
	#define OLE2A_EX_DEF W2A_EX_DEF
	inline LPCOLESTR W2COLE_EX(__in_opt LPCWSTR lp, UINT) { return lp; }
	inline LPCOLESTR W2COLE_EX_DEF(__in_opt LPCWSTR lp) { return lp; }
	inline LPCWSTR OLE2CW_EX(__in_opt LPCOLESTR lp, UINT) { return lp; }
	inline LPCWSTR OLE2CW_EX_DEF(__in_opt LPCOLESTR lp) { return lp; }
	#define A2COLE_EX A2CW_EX
	#define A2COLE_EX_DEF A2CW_EX_DEF
	#define OLE2CA_EX W2CA_EX
	#define OLE2CA_EX_DEF W2CA_EX_DEF

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

	inline LPOLESTR W2OLE(__in_opt LPWSTR lp) { return lp; }
	inline LPWSTR OLE2W(__in_opt LPOLESTR lp) { return lp; }
	#define A2OLE A2W
	#define OLE2A W2A
	inline LPCOLESTR W2COLE(__in_opt LPCWSTR lp) { return lp; }
	inline LPCWSTR OLE2CW(__in_opt LPCOLESTR lp) { return lp; }
	#define A2COLE A2CW
	#define OLE2CA W2CA
	
#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#if defined(_UNICODE)

	#define T2A_EX W2A_EX
	#define T2A_EX_DEF W2A_EX_DEF
	#define A2T_EX A2W_EX
	#define A2T_EX_DEF A2W_EX_DEF
	inline LPWSTR T2W_EX(__in_opt LPTSTR lp, UINT) { return lp; }
	inline LPWSTR T2W_EX_DEF(__in_opt LPTSTR lp) { return lp; }
	inline LPTSTR W2T_EX(__in_opt LPWSTR lp, UINT) { return lp; }
	inline LPTSTR W2T_DEF(__in_opt LPWSTR lp) { return lp; }
	#define T2CA_EX W2CA_EX
	#define T2CA_EX_DEF W2CA_EX_DEF
	#define A2CT_EX A2CW_EX
	#define A2CT_EX_DEF A2CW_EX_DEF
	inline LPCWSTR T2CW_EX(__in_opt LPCTSTR lp, UINT) { return lp; }
	inline LPCWSTR T2CW_EX_DEF(__in_opt LPCTSTR lp) { return lp; }
	inline LPCTSTR W2CT_EX(__in_opt LPCWSTR lp, UINT) { return lp; }
	inline LPCTSTR W2CT_EX_DEF(__in_opt LPCWSTR lp) { return lp; }

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

	#define T2A W2A
	#define A2T A2W
	inline LPWSTR T2W(__in_opt LPTSTR lp) { return lp; }
	inline LPTSTR W2T(__in_opt LPWSTR lp) { return lp; }
	#define T2CA W2CA
	#define A2CT A2CW
	inline LPCWSTR T2CW(__in_opt LPCTSTR lp) { return lp; }
	inline LPCTSTR W2CT(__in_opt LPCWSTR lp) { return lp; }

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY
	
#else // !defined(_UNICODE)

	#define T2W_EX A2W_EX
	#define T2W_EX_DEF A2W_EX_DEF
	#define W2T_EX W2A_EX
	#define W2T_EX_DEF W2A_EX_DEF
	inline LPSTR T2A_EX(__in_opt LPTSTR lp, UINT) { return lp; }
	inline LPSTR T2A_EX_DEF(__in_opt LPTSTR lp) { return lp; }
	inline LPTSTR A2T_EX(__in_opt LPSTR lp, UINT) { return lp; }
	inline LPTSTR A2T_EX_DEF(__in_opt LPSTR lp) { return lp; }
	#define T2CW_EX A2CW_EX
	#define T2CW_EX_DEF A2CW_EX_DEF
	#define W2CT_EX W2CA_EX
	#define W2CT_EX_DEF W2CA_EX_DEF
	inline LPCSTR T2CA_EX(__in_opt LPCTSTR lp, UINT) { return lp; }
	inline LPCSTR T2CA_EX_DEF(__in_opt LPCTSTR lp) { return lp; }
	inline LPCTSTR A2CT_EX(__in_opt LPCSTR lp, UINT) { return lp; }
	inline LPCTSTR A2CT_EX_DEF(__in_opt LPCSTR lp) { return lp; }

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

	#define T2W A2W
	#define W2T W2A
	inline LPSTR T2A(__in_opt LPTSTR lp) { return lp; }
	inline LPTSTR A2T(__in_opt LPSTR lp) { return lp; }
	#define T2CW A2CW
	#define W2CT W2CA
	inline LPCSTR T2CA(__in_opt LPCTSTR lp) { return lp; }
	inline LPCTSTR A2CT(__in_opt LPCSTR lp) { return lp; }

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#endif // defined(_UNICODE)

inline __checkReturn BSTR A2WBSTR(__in_opt LPCSTR lp, int nLen = -1)
{
	if (lp == NULL || nLen == 0)
		return NULL;
	USES_CONVERSION_EX;
	BSTR str = NULL;
	int nConvertedLen = MultiByteToWideChar(_acp_ex, 0, lp,
		nLen, NULL, NULL);
	int nAllocLen = nConvertedLen;
	if (nLen == -1)
		nAllocLen -= 1;  // Don't allocate terminating '\0'
	str = ::SysAllocStringLen(NULL, nAllocLen);

	if (str != NULL)
	{
		int nResult;
		nResult = MultiByteToWideChar(_acp_ex, 0, lp, nLen, str, nConvertedLen);
		ATLASSERT(nResult == nConvertedLen);
		if(nResult != nConvertedLen)
		{
			SysFreeString(str);
			return NULL;
		}

	}
	return str;
}

inline BSTR OLE2BSTR(__in_opt LPCOLESTR lp) {return ::SysAllocString(lp);}
#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline BSTR T2BSTR_EX(__in_opt LPCTSTR lp) {return ::SysAllocString(lp);}
	inline BSTR A2BSTR_EX(__in_opt LPCSTR lp) {return A2WBSTR(lp);}
	inline BSTR W2BSTR_EX(__in_opt LPCWSTR lp) {return ::SysAllocString(lp);}

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

	inline BSTR T2BSTR(__in_opt LPCTSTR lp) {return ::SysAllocString(lp);}
	inline BSTR A2BSTR(__in_opt LPCSTR lp) {return A2WBSTR(lp);}
	inline BSTR W2BSTR(__in_opt LPCWSTR lp) {return ::SysAllocString(lp);}
	
#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#else // !defined(_UNICODE)
	inline BSTR T2BSTR_EX(__in_opt LPCTSTR lp) {return A2WBSTR(lp);}
	inline BSTR A2BSTR_EX(__in_opt LPCSTR lp) {return A2WBSTR(lp);}
	inline BSTR W2BSTR_EX(__in_opt LPCWSTR lp) {return ::SysAllocString(lp);}
	
#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

	inline BSTR T2BSTR(__in_opt LPCTSTR lp) {return A2WBSTR(lp);}
	inline BSTR A2BSTR(__in_opt LPCSTR lp) {return A2WBSTR(lp);}
	inline BSTR W2BSTR(__in_opt LPCWSTR lp) {return ::SysAllocString(lp);}

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#endif // defined(_UNICODE)

#ifdef _WINGDI_

#ifndef _WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers
inline LPDEVMODEW AtlDevModeA2W(__out LPDEVMODEW lpDevModeW, __in const DEVMODEA* lpDevModeA)
{
	USES_CONVERSION_EX;
	ATLASSERT(lpDevModeW != NULL);
	if (lpDevModeA == NULL || lpDevModeW == NULL)
	{
		return NULL;
	}

	AtlA2WHelper(lpDevModeW->dmDeviceName, (LPCSTR)lpDevModeA->dmDeviceName, 32, _acp_ex);

#if _SECURE_ATL
	if(0 != memcpy_s(&lpDevModeW->dmSpecVersion, offsetof(DEVMODEW, dmFormName) - offsetof(DEVMODEW, dmSpecVersion),
		&lpDevModeA->dmSpecVersion, offsetof(DEVMODEW, dmFormName) - offsetof(DEVMODEW, dmSpecVersion)))
	{
		return NULL;
	}
#else
	memcpy(&lpDevModeW->dmSpecVersion, &lpDevModeA->dmSpecVersion,
		offsetof(DEVMODEW, dmFormName) - offsetof(DEVMODEW, dmSpecVersion));
#endif

	AtlA2WHelper(lpDevModeW->dmFormName, (LPCSTR)lpDevModeA->dmFormName, 32, _acp_ex);

#if _SECURE_ATL
	if(0 != memcpy_s(&lpDevModeW->dmLogPixels, sizeof(DEVMODEW) - offsetof(DEVMODEW, dmLogPixels),
		&lpDevModeA->dmLogPixels, sizeof(DEVMODEW) - offsetof(DEVMODEW, dmLogPixels)))
	{
		return NULL;
	}
#else
	memcpy(&lpDevModeW->dmLogPixels, &lpDevModeA->dmLogPixels,
		sizeof(DEVMODEW) - offsetof(DEVMODEW, dmLogPixels));
#endif

	if (lpDevModeA->dmDriverExtra != 0)
	{
		// lpDevModeW holds more info
#pragma warning(push)
#pragma warning(disable:26000)
#if _SECURE_ATL
		if(0 != memcpy_s(lpDevModeW+1, lpDevModeA->dmDriverExtra, lpDevModeA+1, lpDevModeA->dmDriverExtra))
		{
			return NULL;
		}
#else
		memcpy(lpDevModeW+1, lpDevModeA+1, lpDevModeA->dmDriverExtra);
#endif
#pragma warning(pop)
	}
	lpDevModeW->dmSize = sizeof(DEVMODEW);
	return lpDevModeW;
}

inline LPTEXTMETRICW AtlTextMetricA2W(__out LPTEXTMETRICW lptmW, __in LPTEXTMETRICA lptmA)
{
	USES_CONVERSION_EX;
	ATLASSERT(lptmW != NULL);
	if (lptmA == NULL || lptmW == NULL)
		return NULL;

#if _SECURE_ATL
	if(0 != memcpy_s(lptmW, sizeof(LONG) * 11, lptmA, sizeof(LONG) * 11))
	{
		return NULL;
	}
#else
	memcpy(lptmW, lptmA, sizeof(LONG) * 11);
#endif

#if _SECURE_ATL
	if(0 != memcpy_s(&lptmW->tmItalic, sizeof(BYTE) * 5, &lptmA->tmItalic, sizeof(BYTE) * 5))
	{
		return NULL;
	}
#else
	memcpy(&lptmW->tmItalic, &lptmA->tmItalic, sizeof(BYTE) * 5);
#endif

	if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmFirstChar, 1, &lptmW->tmFirstChar, 1) == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}
		
	if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmLastChar, 1, &lptmW->tmLastChar, 1) == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}
		
	if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmDefaultChar, 1, &lptmW->tmDefaultChar, 1)== 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}
		
	if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmBreakChar, 1, &lptmW->tmBreakChar, 1) == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}
	
	return lptmW;
}

inline LPTEXTMETRICA AtlTextMetricW2A(__out LPTEXTMETRICA lptmA, __in LPTEXTMETRICW lptmW)
{
	USES_CONVERSION_EX;
	ATLASSERT(lptmA != NULL);
	if (lptmW == NULL || lptmA == NULL)
	{
		return NULL;
	}

#if _SECURE_ATL
	if(0 != memcpy_s(lptmA, sizeof(LONG) * 11, lptmW, sizeof(LONG) * 11))
	{
		return NULL;
	}
#else
	memcpy(lptmA, lptmW, sizeof(LONG) * 11);
#endif

#if _SECURE_ATL
	if(0 != memcpy_s(&lptmA->tmItalic, sizeof(BYTE) * 5, &lptmW->tmItalic, sizeof(BYTE) * 5))
	{
		return NULL;
	}
#else
	memcpy(&lptmA->tmItalic, &lptmW->tmItalic, sizeof(BYTE) * 5);
#endif
	
	if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmFirstChar, 1, (LPSTR)&lptmA->tmFirstChar, 1, NULL, NULL) == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}

	if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmLastChar, 1, (LPSTR)&lptmA->tmLastChar, 1, NULL, NULL) == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}

	if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmDefaultChar, 1, (LPSTR)&lptmA->tmDefaultChar, 1, NULL, NULL) == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}

	if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmBreakChar, 1, (LPSTR)&lptmA->tmBreakChar, 1, NULL, NULL) == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}

	return lptmA;
}

#ifndef ATLDEVMODEA2W
#define ATLDEVMODEA2W AtlDevModeA2W
#define ATLDEVMODEW2A AtlDevModeW2A
#define ATLTEXTMETRICA2W AtlTextMetricA2W
#define ATLTEXTMETRICW2A AtlTextMetricW2A
#endif

// Requires USES_CONVERSION_EX or USES_ATL_SAFE_ALLOCA macro before using the _EX versions of the macros
#define DEVMODEW2A_EX(lpw)\
	(((lpw) == NULL) ? NULL : ATLDEVMODEW2A((LPDEVMODEA)_ATL_SAFE_ALLOCA(sizeof(DEVMODEA)+(lpw)->dmDriverExtra, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), (lpw)))
#define DEVMODEA2W_EX(lpa)\
	(((lpa) == NULL) ? NULL : ATLDEVMODEA2W((LPDEVMODEW)_ATL_SAFE_ALLOCA(sizeof(DEVMODEW)+(lpa)->dmDriverExtra, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), (lpa)))
#define TEXTMETRICW2A_EX(lptmw)\
	(((lptmw) == NULL) ? NULL : ATLTEXTMETRICW2A((LPTEXTMETRICA)_ATL_SAFE_ALLOCA(sizeof(TEXTMETRICA), _ATL_SAFE_ALLOCA_DEF_THRESHOLD), (lptmw)))
#define TEXTMETRICA2W_EX(lptma)\
	(((lptma) == NULL) ? NULL : ATLTEXTMETRICA2W((LPTEXTMETRICW)_ATL_SAFE_ALLOCA(sizeof(TEXTMETRICW), _ATL_SAFE_ALLOCA_DEF_THRESHOLD), (lptma)))

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define DEVMODEW2A(lpw)\
	((lpw == NULL) ? NULL : ATLDEVMODEW2A((LPDEVMODEA)alloca(sizeof(DEVMODEA)+lpw->dmDriverExtra), lpw))
#define DEVMODEA2W(lpa)\
	((lpa == NULL) ? NULL : ATLDEVMODEA2W((LPDEVMODEW)alloca(sizeof(DEVMODEW)+lpa->dmDriverExtra), lpa))
#define TEXTMETRICW2A(lptmw)\
	((lptmw == NULL) ? NULL : ATLTEXTMETRICW2A((LPTEXTMETRICA)alloca(sizeof(TEXTMETRICA)), lptmw))
#define TEXTMETRICA2W(lptma)\
	((lptma == NULL) ? NULL : ATLTEXTMETRICA2W((LPTEXTMETRICW)alloca(sizeof(TEXTMETRICW)), lptma))

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#endif // _WIN32_WCE

#define DEVMODEOLE DEVMODEW
#define LPDEVMODEOLE LPDEVMODEW
#define TEXTMETRICOLE TEXTMETRICW
#define LPTEXTMETRICOLE LPTEXTMETRICW

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline LPDEVMODEW DEVMODEOLE2T_EX(LPDEVMODEOLE lp) { return lp; }
	inline LPDEVMODEOLE DEVMODET2OLE_EX(LPDEVMODEW lp) { return lp; }
	inline LPTEXTMETRICW TEXTMETRICOLE2T_EX(LPTEXTMETRICOLE lp) { return lp; }
	inline LPTEXTMETRICOLE TEXTMETRICT2OLE_EX(LPTEXTMETRICW lp) { return lp; }
#ifndef _ATL_EX_CONVERSION_MACROS_ONLY
	inline LPDEVMODEW DEVMODEOLE2T(LPDEVMODEOLE lp) { return lp; }
	inline LPDEVMODEOLE DEVMODET2OLE(LPDEVMODEW lp) { return lp; }
	inline LPTEXTMETRICW TEXTMETRICOLE2T(LPTEXTMETRICOLE lp) { return lp; }
	inline LPTEXTMETRICOLE TEXTMETRICT2OLE(LPTEXTMETRICW lp) { return lp; }
#endif	// _ATL_EX_CONVERSION_MACROS_ONLY
	
#else // !defined(_UNICODE)
	#define DEVMODEOLE2T_EX(lpo) DEVMODEW2A_EX(lpo)
	#define DEVMODET2OLE_EX(lpa) DEVMODEA2W_EX(lpa)
	#define TEXTMETRICOLE2T_EX(lptmw) TEXTMETRICW2A_EX(lptmw)
	#define TEXTMETRICT2OLE_EX(lptma) TEXTMETRICA2W_EX(lptma)
#ifndef _ATL_EX_CONVERSION_MACROS_ONLY
	#define DEVMODEOLE2T(lpo) DEVMODEW2A(lpo)
	#define DEVMODET2OLE(lpa) DEVMODEA2W(lpa)
	#define TEXTMETRICOLE2T(lptmw) TEXTMETRICW2A(lptmw)
	#define TEXTMETRICT2OLE(lptma) TEXTMETRICA2W(lptma)
#endif	// _ATL_EX_CONVERSION_MACROS_ONLY	

#endif // defined(_UNICODE)

#endif //_WINGDI_

#pragma pack(pop)

/////////////////////////////////////////////////////////////////////////////

#ifndef _ATL_DLL

#if defined(_WINGDI_) && !defined(_WIN32_WCE)

ATLINLINE ATLAPI_(LPDEVMODEA) AtlDevModeW2A(__out LPDEVMODEA lpDevModeA, __in const DEVMODEW* lpDevModeW)
{
	USES_CONVERSION_EX;
	ATLASSERT(lpDevModeA != NULL);
	if (lpDevModeW == NULL || lpDevModeA == NULL)
		return NULL;

	AtlW2AHelper((LPSTR)lpDevModeA->dmDeviceName, lpDevModeW->dmDeviceName, 32, _acp_ex);

#if _SECURE_ATL
	if(0 != memcpy_s(&lpDevModeA->dmSpecVersion, offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion), 
		&lpDevModeW->dmSpecVersion, offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion)))
	{
		return NULL;
	}
#else
	memcpy(&lpDevModeA->dmSpecVersion, &lpDevModeW->dmSpecVersion,
		offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion));
#endif

	AtlW2AHelper((LPSTR)lpDevModeA->dmFormName, lpDevModeW->dmFormName, 32, _acp_ex);

#if _SECURE_ATL
	if(0 != memcpy_s(&lpDevModeA->dmLogPixels, sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels),
		&lpDevModeW->dmLogPixels, sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels)))
	{
		return NULL;
	}
#else
	memcpy(&lpDevModeA->dmLogPixels, &lpDevModeW->dmLogPixels,
		sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels));
#endif

	if (lpDevModeW->dmDriverExtra != 0)
	{
		// lpDevModeW holds more info
#pragma warning(push)
#pragma warning(disable:26000)
#if _SECURE_ATL
		if(0 != memcpy_s(lpDevModeA+1, lpDevModeW->dmDriverExtra, lpDevModeW+1, lpDevModeW->dmDriverExtra))
		{
			return NULL;
		}
#else
		memcpy(lpDevModeA+1, lpDevModeW+1, lpDevModeW->dmDriverExtra);
#endif
#pragma warning(pop)
	}
	
	lpDevModeA->dmSize = sizeof(DEVMODEA);
	return lpDevModeA;
}

#endif // defined(_WINGDI_) && !defined(_WIN32_WCE)

#endif // !_ATL_DLL

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif //!_ATL_NO_PRAGMA_WARNINGS

#endif // __ATLCONV_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlcur.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCUR_H__
#define __ATLCUR_H__

#pragma once

#ifdef _WIN32_WCE
	#error atlcur.h is not supported on Windows CE (_WIN32_WCE is defined)
#endif //_WIN32_WCE

#include <atlbase.h>


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

const LONGLONG CY_MIN_INTEGER	= -922337203685477;
const LONGLONG CY_MAX_INTEGER	= 922337203685477;
const SHORT CY_MIN_FRACTION		= -9999;
const SHORT CY_MAX_FRACTION		= 9999;
const SHORT CY_SCALE			= 10000;

class CComCurrency
{
public:

// constructors
	CComCurrency() throw()
	{
		 m_currency.int64 = 0;
	}
	CComCurrency(CURRENCY cySrc) throw()
	{
		m_currency.int64 = cySrc.int64;
	}
	CComCurrency(const CComCurrency& curSrc) throw()
	{
		*this = curSrc;
	}
	CComCurrency(LONGLONG nInteger, SHORT nFraction)
	{
		m_currency.int64 = 0;
		HRESULT hRes = SetInteger(nInteger);
		if (FAILED(hRes))
			AtlThrow(hRes);
		hRes = SetFraction(nFraction);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	CComCurrency(BYTE bSrc)
	{
		*this = bSrc;
	}
	CComCurrency(SHORT sSrc)
	{
		*this = sSrc;
	}
	CComCurrency(LONG lSrc)
	{
		*this = lSrc;
	}
	CComCurrency(FLOAT fSrc)
	{
		*this = fSrc;
	}
	CComCurrency(DOUBLE dSrc)
	{
		*this = dSrc;
	}
	CComCurrency(CHAR cSrc)
	{
		*this = cSrc;
	}
	CComCurrency(USHORT usSrc)
	{
		*this = usSrc;
	}
	CComCurrency(ULONG ulSrc)
	{
		*this = ulSrc;
	}
	CComCurrency(DECIMAL dSrc)
	{
		*this = dSrc;
	}
	explicit CComCurrency(LPCSTR szSrc)
	{
		ATLASSERT(szSrc);
		if( szSrc == NULL )
			AtlThrow(E_INVALIDARG);

		USES_CONVERSION_EX;
		LPOLESTR p = A2OLE_EX(szSrc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		if( p == NULL )
			AtlThrow(E_OUTOFMEMORY);

		HRESULT hRes = VarCyFromStr(p, ATL::GetThreadLocale(), LOCALE_NOUSEROVERRIDE, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	explicit CComCurrency(LPCWSTR szSrc)
	{
		ATLASSERT(szSrc);
		HRESULT hRes = VarCyFromStr(const_cast<LPWSTR>(szSrc), ATL::GetThreadLocale(), LOCALE_NOUSEROVERRIDE, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	explicit CComCurrency(const VARIANT& varSrc)
	{
		VARIANT var;
		VariantInit(&var);
		HRESULT hRes = VariantChangeType(&var, const_cast<VARIANT*>(&varSrc), 0, VT_CY);
		if (FAILED(hRes))
			AtlThrow(hRes);
		m_currency.int64 = V_CY(&var).int64;
	}
	explicit CComCurrency(LPDISPATCH pDispSrc)
	{
		ATLASSERT(pDispSrc);
		HRESULT hRes = VarCyFromDisp(pDispSrc, ATL::GetThreadLocale(), &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}

// assignment operators
	const CComCurrency& operator=(CURRENCY cySrc) throw()
	{
		m_currency.int64 = cySrc.int64;
		return *this;
	}
	const CComCurrency& operator=(const CComCurrency& curSrc) throw()
	{
		m_currency.int64 = curSrc.m_currency.int64;
		return *this;
	}
	const CComCurrency& operator=(BYTE bSrc)
	{
		HRESULT hRes = VarCyFromUI1(bSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(SHORT sSrc)
	{
		HRESULT hRes = VarCyFromI2(sSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(LONG lSrc)
	{
		HRESULT hRes = VarCyFromI4(lSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(FLOAT fSrc)
	{
		HRESULT hRes = VarCyFromR4(fSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(DOUBLE dSrc)
	{
		HRESULT hRes = VarCyFromR8(dSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(CHAR cSrc)
	{
		HRESULT hRes = VarCyFromI1(cSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(USHORT usSrc)
	{
		HRESULT hRes = VarCyFromUI2(usSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(ULONG ulSrc)
	{
		HRESULT hRes = VarCyFromUI4(ulSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator=(DECIMAL dSrc)
	{
		HRESULT hRes = VarCyFromDec(&dSrc, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}

// comparison operators
	bool operator==(const CComCurrency& cur) const
	{
		return (static_cast<HRESULT>(VARCMP_EQ) == VarCyCmp(m_currency, cur.m_currency));
	}
	bool operator!=(const CComCurrency& cur) const
	{
		return (static_cast<HRESULT>(VARCMP_EQ) != VarCyCmp(m_currency, cur.m_currency));
	}
	bool operator<(const CComCurrency& cur) const
	{
		return (static_cast<HRESULT>(VARCMP_LT) == VarCyCmp(m_currency, cur.m_currency));
	}
	bool operator>(const CComCurrency& cur) const
	{
		return (static_cast<HRESULT>(VARCMP_GT) == VarCyCmp(m_currency, cur.m_currency));
	}
	bool operator<=(const CComCurrency& cur) const
	{
		HRESULT hRes = VarCyCmp(m_currency, cur.m_currency);
		return (static_cast<HRESULT>(VARCMP_LT) == hRes || (HRESULT)VARCMP_EQ == hRes);
	}
	bool operator>=(const CComCurrency& cur) const
	{
		HRESULT hRes = VarCyCmp(m_currency, cur.m_currency);
		return (static_cast<HRESULT>(VARCMP_GT) == hRes || static_cast<HRESULT>(VARCMP_EQ) == hRes);
	}

// math operators
	CComCurrency operator+(const CComCurrency& cur) const
	{
		CURRENCY cy;
		HRESULT hRes = VarCyAdd(m_currency, cur.m_currency, &cy);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return cy;
	}
	CComCurrency operator-(const CComCurrency& cur) const
	{
		CURRENCY cy;
		HRESULT hRes = VarCySub(m_currency, cur.m_currency, &cy);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return cy;
	}
	const CComCurrency& operator+=(const CComCurrency& cur)
	{
		HRESULT hRes = VarCyAdd(m_currency, cur.m_currency, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	const CComCurrency& operator-=(const CComCurrency& cur)
	{
		HRESULT hRes = VarCySub(m_currency, cur.m_currency, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	CComCurrency operator*(const CComCurrency& cur) const
	{
		CURRENCY cy;
		HRESULT hRes = VarCyMul(m_currency, cur.m_currency, &cy);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return cy;
	}
	const CComCurrency& operator*=(const CComCurrency& cur)
	{
		HRESULT hRes = VarCyMul(m_currency, cur.m_currency, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	CComCurrency operator*(long nOperand) const
	{
		CURRENCY cy;
		HRESULT hRes = VarCyMulI4(m_currency, nOperand, &cy);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return cy;
	}
	const CComCurrency& operator*=(long nOperand)
	{
		HRESULT hRes = VarCyMulI4(m_currency, nOperand, &m_currency);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	CComCurrency operator-() const
	{
		CURRENCY cy;
		HRESULT hRes = VarCyNeg(m_currency, &cy);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return cy;
	}
	CComCurrency operator/(long nOperand) const
	{
		ATLASSERT(nOperand);
		if( nOperand == 0 )
			AtlThrow(E_INVALIDARG);

		CURRENCY cy;
		cy.int64 = m_currency.int64 / nOperand;
		return cy;
	}
	const CComCurrency& operator/=(long nOperand)
	{
		ATLASSERT(nOperand);
		if( nOperand == 0 )
			AtlThrow(E_INVALIDARG);

		m_currency.int64 /= nOperand;
		return *this;
	}

// cast operators
	operator CURRENCY&() throw()
	{
		return m_currency;
	}
	operator const CURRENCY&() const throw()
	{
		return m_currency;
	}
	CURRENCY* GetCurrencyPtr() throw()
	{
		return &m_currency;
	}

// misc functions
	HRESULT Round(int nDecimals)
	{
		ATLASSERT(nDecimals >= 0 && nDecimals <= 4);
		if( nDecimals < 0 || nDecimals > 4 )
			return E_INVALIDARG;

		return VarCyRound(m_currency, nDecimals, &m_currency);
	}

	HRESULT SetInteger(LONGLONG nInteger)
	{
		// check if within range
		ATLASSERT(nInteger >= CY_MIN_INTEGER && nInteger <= CY_MAX_INTEGER);
		if( nInteger < CY_MIN_INTEGER || nInteger > CY_MAX_INTEGER )
			return E_INVALIDARG;

		if (m_currency.int64)
		{
			// signs must match
			if ((m_currency.int64 < 0 && nInteger > 0) ||
				(m_currency.int64 > 0 && nInteger < 0))
				return TYPE_E_TYPEMISMATCH;

			CURRENCY cyTemp;
			// get fractional part
			cyTemp.int64 = m_currency.int64 % CY_SCALE;
			// check if within range again
			if ((nInteger == CY_MAX_INTEGER && cyTemp.int64 > 5807) ||
				(nInteger == CY_MIN_INTEGER && cyTemp.int64 < -5808))
				return TYPE_E_OUTOFBOUNDS;
			// set to fractional part, wiping out integer part
			m_currency.int64 = cyTemp.int64;
		}
		// add new integer part scaled by CY_SCALE
		m_currency.int64 += nInteger * CY_SCALE;
		return S_OK;
	}

	// Based on 4 digits.  To set .2, pass 2000, to set .0002, pass a 2
	HRESULT SetFraction(SHORT nFraction)
	{
		// check if within range
		ATLASSERT(nFraction >= CY_MIN_FRACTION && nFraction <= CY_MAX_FRACTION);
		if( nFraction < CY_MIN_FRACTION || nFraction > CY_MAX_FRACTION )
			return E_INVALIDARG;

		if (m_currency.int64)
		{
			// signs must match
			if ((m_currency.int64 < 0 && nFraction > 0) ||
				(m_currency.int64 > 0 && nFraction < 0))
				return TYPE_E_TYPEMISMATCH;

			CURRENCY cyTemp;
			// get integer part, wiping out fractional part
			cyTemp.int64 = m_currency.int64 / CY_SCALE;
			// check if within range again
			if ((cyTemp.int64 == CY_MAX_INTEGER && nFraction > 5807) ||
				(cyTemp.int64 == CY_MIN_INTEGER && nFraction < -5808))
				return TYPE_E_OUTOFBOUNDS;
			// scale to CY_SCALE
			m_currency.int64 = cyTemp.int64 * CY_SCALE;
		}
		m_currency.int64 += nFraction;
		return S_OK;
	}

	LONGLONG GetInteger() const
	{
		if (m_currency.int64)
			return (m_currency.int64 / CY_SCALE);
		else
			return 0;		
	}

	SHORT GetFraction() const
	{
		if (m_currency.int64)
			// get fractional part
			return static_cast<SHORT>(m_currency.int64 % CY_SCALE);
		else
			return 0;
	}

	CURRENCY m_currency;
};

}; //namespace ATL
#pragma pack(pop)
#endif //__ATLSAFE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlcore.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#ifndef __ATLCORE_H__
#define __ATLCORE_H__

#pragma once

#ifdef _ATL_ALL_WARNINGS
#pragma warning( push )
#endif

#pragma warning(disable: 4786) // identifier was truncated in the debug information

#include <atldef.h>
#include <windows.h>
#include <ole2.h>

#include <limits.h>
#include <tchar.h>
#ifndef _WIN32_WCE
#include <mbstring.h>
#endif

#ifdef _WIN32_WCE
#include <altcecrt.h>
#endif

namespace ATL
{

// Allow AtlGetThisModuleHandle to be overriden on WinCE implementations.
// This may be necessary if the application needs to use a custom entry point.
#if !defined(_WIN32_WCE) || !defined(AtlGetThisModuleHandle)

/////////////////////////////////////////////////////////////////////////////
// _AtlGetThisModuleHandle

#if !defined(_delayimp_h) && !defined(_WIN32_WCE)
extern "C" IMAGE_DOS_HEADER __ImageBase;
#endif

#ifdef _WIN32_WCE
extern HINSTANCE _AtlModuleInstance;
#endif

inline HINSTANCE _AtlGetThisModuleHandle()
{
#ifndef _WIN32_WCE
	return reinterpret_cast<HINSTANCE>(&__ImageBase);
#else // _WIN32_WCE
	// If _AtlModuleInstance is NULL then the 'this' module is the .exe for for the process.
	if(_AtlModuleInstance == NULL)
	{
		return GetModuleHandle(NULL);
	}
	else // else _AtlModuleInstance has the handle for the 'this' module
	{
		return _AtlModuleInstance;
	}
#endif // _WIN32_WCE
}

#define AtlGetThisModuleHandle _AtlGetThisModuleHandle

#endif // !defined(_WIN32_WCE) || !defined(AtlGetThisModuleHandle)

#if defined(_ATL_STATIC_LIB_IMPL) || defined(_ATL_DLL_IMPL)

HRESULT CoDisconnectObject(LPUNKNOWN pUnk, DWORD dwReserved);

HRESULT CoInitialize(LPVOID pvReserved);

HRESULT CoRevokeClassObject(DWORD dwRegister);

HRESULT CoRegisterClassObject(REFCLSID rclsid, LPUNKNOWN pUnk, DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister);

HRESULT CoMarshalInterface(LPSTREAM pStm, REFIID riid, LPUNKNOWN pUnk, DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);

HRESULT CoUnmarshalInterface(LPSTREAM pStm, REFIID riid, LPVOID FAR* ppv);

HRESULT CoReleaseMarshalData(LPSTREAM pStm);

#endif // defined(_ATL_STATIC_LIB_IMPL) || defined(_ATL_DLL_IMPL)

#if defined(_ATL_STATIC_LIB_IMPL) || defined(_ATL_DLL_IMPL) || !defined(_CE_DCOM)

HRESULT OleSaveToStream(LPPERSISTSTREAM pPStm, LPSTREAM pStm);

HRESULT OleLoadFromStream(LPSTREAM pStm, REFIID iidInterface, LPVOID FAR* ppvObj);

#endif // defined(_ATL_STATIC_LIB_IMPL) || defined(_ATL_DLL_IMPL) || !defined(_CE_DCOM)

} // namespace ATL

#include <atlchecked.h>
#include <atlsimpcoll.h>
#include <atlosapice.h>

#pragma pack(push,_ATL_PACKING)
namespace ATL
{
/////////////////////////////////////////////////////////////////////////////
// Verify that a null-terminated string points to valid memory
inline BOOL AtlIsValidString(LPCWSTR psz, size_t nMaxLength = INT_MAX)
{
	(nMaxLength);
	return (psz != NULL);
}

// Verify that a null-terminated string points to valid memory
inline BOOL AtlIsValidString(LPCSTR psz, size_t nMaxLength = UINT_MAX)
{
	(nMaxLength);
	return (psz != NULL);
}

// Verify that a pointer points to valid memory
inline BOOL AtlIsValidAddress(const void* p, size_t nBytes,
	BOOL bReadWrite = TRUE)
{
	(bReadWrite);
	(nBytes);
	return (p != NULL);
}

template<typename T>
inline void AtlAssertValidObject(const T *pOb)
{
	ATLASSERT(pOb);
	ATLASSERT(AtlIsValidAddress(pOb, sizeof(T)));
	if(pOb)
		pOb->AssertValid();
}
#ifdef _DEBUG
#define ATLASSERT_VALID(x) ATL::AtlAssertValidObject(x)
#else
#define ATLASSERT_VALID(x) __noop;
#endif

// COM Sync Classes
class CComCriticalSection
{
public:
	CComCriticalSection() throw()
	{
		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));
	}
	~CComCriticalSection()
	{
	}
	HRESULT Lock() throw()
	{
		EnterCriticalSection(&m_sec);
		return S_OK;
	}
	HRESULT Unlock() throw()
	{
		LeaveCriticalSection(&m_sec);
		return S_OK;
	}
	HRESULT Init() throw()
	{
		HRESULT hRes = E_FAIL;
		__try
		{
			InitializeCriticalSection(&m_sec);
			hRes = S_OK;
		}
		// structured exception may be raised in low memory situations
		__except(STATUS_NO_MEMORY == GetExceptionCode())
		{			
			hRes = E_OUTOFMEMORY;		
		}
		return hRes;
	}

	HRESULT Term() throw()
	{
		DeleteCriticalSection(&m_sec);
		return S_OK;
	}	
	CRITICAL_SECTION m_sec;
};

class CComAutoCriticalSection : public CComCriticalSection
{
public:
	CComAutoCriticalSection()
	{
		HRESULT hr = CComCriticalSection::Init();
		if (FAILED(hr))
			AtlThrow(hr);
	}
	~CComAutoCriticalSection() throw()
	{
		CComCriticalSection::Term();
	}
private :
	HRESULT Init(); // Not implemented. CComAutoCriticalSection::Init should never be called
	HRESULT Term(); // Not implemented. CComAutoCriticalSection::Term should never be called
};

class CComSafeDeleteCriticalSection : public CComCriticalSection
{
public:
	CComSafeDeleteCriticalSection(): m_bInitialized(false) 
	{
	}

	~CComSafeDeleteCriticalSection() throw()
	{
		if (!m_bInitialized)
		{
			return;
		}
		m_bInitialized = false;
		CComCriticalSection::Term();
	}

	HRESULT Init() throw()
	{
		ATLASSERT( !m_bInitialized );
		HRESULT hr = CComCriticalSection::Init();
		if (SUCCEEDED(hr))
		{
			m_bInitialized = true;
		}
		return hr;
	}

	HRESULT Term() throw()
	{
		if (!m_bInitialized)
		{
			return S_OK;
		}
		m_bInitialized = false;
		return CComCriticalSection::Term();
	}

	HRESULT Lock()
	{
		// CComSafeDeleteCriticalSection::Init or CComAutoDeleteCriticalSection::Init
		// not called or failed.
		// m_critsec member of CComObjectRootEx is now of type 
		// CComAutoDeleteCriticalSection. It has to be initialized
		// by calling CComObjectRootEx::_AtlInitialConstruct
		ATLASSUME(m_bInitialized);
		return CComCriticalSection::Lock();
	}

private:
	bool m_bInitialized;
};

class CComAutoDeleteCriticalSection : public CComSafeDeleteCriticalSection
{
private:
	// CComAutoDeleteCriticalSection::Term should never be called
	HRESULT Term() throw();
};

class CComFakeCriticalSection
{
public:
	HRESULT Lock() throw() { return S_OK; }
	HRESULT Unlock() throw() { return S_OK; }
	HRESULT Init() throw() { return S_OK; }
	HRESULT Term() throw() { return S_OK; }
};

/////////////////////////////////////////////////////////////////////////////
// Module 

// Used by any project that uses ATL
struct _ATL_BASE_MODULE70
{
	UINT cbSize;
	HINSTANCE m_hInst;
	HINSTANCE m_hInstResource;
#ifndef _WIN32_WCE
	bool m_bNT5orWin98;
#endif // _WIN32_WCE
	DWORD dwAtlBuildVer;
	const GUID* pguidVer;
	CComCriticalSection m_csResource;
	CSimpleArray<HINSTANCE> m_rgResourceInstance;
};
typedef _ATL_BASE_MODULE70 _ATL_BASE_MODULE;

class CAtlBaseModule : public _ATL_BASE_MODULE
{
public :
	static bool m_bInitFailed;
	CAtlBaseModule() throw();
	~CAtlBaseModule() throw ();

	HINSTANCE GetModuleInstance() throw()
	{
		return m_hInst;
	}
	HINSTANCE GetResourceInstance() throw()
	{
		return m_hInstResource;
	}
	HINSTANCE SetResourceInstance(HINSTANCE hInst) throw()
	{
		return static_cast< HINSTANCE >(InterlockedExchangePointer((void**)&m_hInstResource, hInst));
	}

	bool AddResourceInstance(HINSTANCE hInst) throw();
	bool RemoveResourceInstance(HINSTANCE hInst) throw();
	HINSTANCE GetHInstanceAt(int i) throw();
};

__declspec(selectany) bool CAtlBaseModule::m_bInitFailed = false;
extern CAtlBaseModule _AtlBaseModule;

/////////////////////////////////////////////////////////////////////////////
// String resource helpers

#pragma warning(push)
#pragma warning(disable: 4200)
	struct ATLSTRINGRESOURCEIMAGE
	{
		WORD nLength;
		WCHAR achString[];
	};
#pragma warning(pop)	// C4200

inline const ATLSTRINGRESOURCEIMAGE* _AtlGetStringResourceImage( HINSTANCE hInstance, HRSRC hResource, UINT id ) throw()
{
	const ATLSTRINGRESOURCEIMAGE* pImage;
	const ATLSTRINGRESOURCEIMAGE* pImageEnd;
	ULONG nResourceSize;
	HGLOBAL hGlobal;
	UINT iIndex;

	hGlobal = ::LoadResource( hInstance, hResource );
	if( hGlobal == NULL )
	{
		return( NULL );
	}

	pImage = (const ATLSTRINGRESOURCEIMAGE*)::LockResource( hGlobal );
	if( pImage == NULL )
	{
		return( NULL );
	}

	nResourceSize = ::SizeofResource( hInstance, hResource );
	pImageEnd = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+nResourceSize);
	iIndex = id&0x000f;

	while( (iIndex > 0) && (pImage < pImageEnd) )
	{
		pImage = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+(sizeof( ATLSTRINGRESOURCEIMAGE )+(pImage->nLength*sizeof( WCHAR ))));
		iIndex--;
	}
	if( pImage >= pImageEnd )
	{
		return( NULL );
	}
	if( pImage->nLength == 0 )
	{
		return( NULL );
	}

	return( pImage );
}

inline const ATLSTRINGRESOURCEIMAGE* AtlGetStringResourceImage( HINSTANCE hInstance, UINT id ) throw()
{
	HRSRC hResource;

	hResource = ::FindResource( hInstance, MAKEINTRESOURCE( ((id>>4)+1) ), RT_STRING );
	if( hResource == NULL )
	{
		return( NULL );
	}

	return _AtlGetStringResourceImage( hInstance, hResource, id );
}

#ifndef _WIN32_WCE
inline const ATLSTRINGRESOURCEIMAGE* AtlGetStringResourceImage( HINSTANCE hInstance, UINT id, WORD wLanguage ) throw()
{
	HRSRC hResource;

	hResource = ::FindResourceEx( hInstance, RT_STRING, MAKEINTRESOURCE( ((id>>4)+1) ), wLanguage );
	if( hResource == NULL )
	{
		return( NULL );
	}

	return _AtlGetStringResourceImage( hInstance, hResource, id );
}
#endif // _WIN32_WCE

inline const ATLSTRINGRESOURCEIMAGE* AtlGetStringResourceImage( UINT id ) throw()
{
	const ATLSTRINGRESOURCEIMAGE* p = NULL;
	HINSTANCE hInst = _AtlBaseModule.GetHInstanceAt(0);

	for (int i = 1; hInst != NULL && p == NULL; hInst = _AtlBaseModule.GetHInstanceAt(i++))
	{
		p = AtlGetStringResourceImage(hInst, id);
	}
	return p;
}

#ifndef _WIN32_WCE
inline const ATLSTRINGRESOURCEIMAGE* AtlGetStringResourceImage( UINT id, WORD wLanguage ) throw()
{
	const ATLSTRINGRESOURCEIMAGE* p = NULL;
	HINSTANCE hInst = _AtlBaseModule.GetHInstanceAt(0);

	for (int i = 1; hInst != NULL && p == NULL; hInst = _AtlBaseModule.GetHInstanceAt(i++))
	{
		p = AtlGetStringResourceImage(hInst, id, wLanguage);
	}
	return p;
}
#endif // _WIN32_WCE

inline int AtlLoadString(__in UINT nID, __out_ecount_part_z(nBufferMax, return + 1) LPTSTR lpBuffer, __in int nBufferMax) throw()
{
	HINSTANCE hInst = _AtlBaseModule.GetHInstanceAt(0);
	int nRet = 0;

	for (int i = 1; hInst != NULL && nRet == 0; hInst = _AtlBaseModule.GetHInstanceAt(i++))
	{
		nRet = LoadString(hInst, nID, lpBuffer, nBufferMax);
	}
	return nRet;
}

inline HINSTANCE AtlFindResourceInstance(LPCTSTR lpName, LPCTSTR lpType, WORD wLanguage = 0) throw()
{
	ATLASSERT(lpType != RT_STRING);	// Call AtlFindStringResourceInstance to find the string
	if (lpType == RT_STRING)
		return NULL;

	if (ATL_IS_INTRESOURCE(lpType))
	{
		/* Prefast false warnings caused by bad-shaped definition of MAKEINTRESOURCE macro from PSDK */
		if (lpType == ATL_RT_ICON)
		{
			lpType = ATL_RT_GROUP_ICON;
		}
		else if (lpType == ATL_RT_CURSOR)
		{
			lpType = ATL_RT_GROUP_CURSOR;
		}
	}

	HINSTANCE hInst = _AtlBaseModule.GetHInstanceAt(0);
	HRSRC hResource = NULL;

	for (int i = 1; hInst != NULL; hInst = _AtlBaseModule.GetHInstanceAt(i++))
	{
#ifndef _WIN32_WCE
		hResource = ::FindResourceEx(hInst, lpType, lpName, wLanguage);
#else // _WIN32_WCE
		(wLanguage);
		hResource = ::FindResource(hInst, lpName, lpType);
#endif // _WIN32_WCE
		if (hResource != NULL)
		{
			return hInst;
		}
	}

	return NULL;
}

inline HINSTANCE AtlFindResourceInstance(UINT nID, LPCTSTR lpType, WORD wLanguage = 0) throw()
{
	return AtlFindResourceInstance(MAKEINTRESOURCE(nID), lpType, wLanguage);
}

inline HINSTANCE AtlFindStringResourceInstance(UINT nID, WORD wLanguage = 0) throw()
{
	const ATLSTRINGRESOURCEIMAGE* p = NULL;
	HINSTANCE hInst = _AtlBaseModule.GetHInstanceAt(0);

	for (int i = 1; hInst != NULL && p == NULL; hInst = _AtlBaseModule.GetHInstanceAt(i++))
	{
#ifndef _WIN32_WCE
		p = AtlGetStringResourceImage(hInst, nID, wLanguage);
#else // _WIN32_WCE
		(wLanguage);
		p = AtlGetStringResourceImage(hInst, nID);
#endif // _WIN32_WCE
		if (p != NULL)
			return hInst;
	}

	return NULL;
}

/* 
Needed by both atlcomcli and atlsafe, so needs to be in here 
*/
inline HRESULT AtlSafeArrayGetActualVartype
(
    SAFEARRAY *psaArray,
    VARTYPE *pvtType
)
{
    HRESULT hrSystem=ATL::SafeArrayGetVartype(psaArray, pvtType);

    /*
    For Windows CE, SafeArrayGetVartype only supports SAFEARRAY's 
    with a VARTYPE of VT_BSTR, VT_VARIANT, VT_UNKNOWN, and VT_DISPATCH
    */

#ifndef _WIN32_WCE
    if(FAILED(hrSystem))
    {
        return hrSystem;
    }

    /* 
    When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
    it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
    This isn't necessary for Windows CE, as VT_DISPATCH is always returned if
    FADF_DISPATCH regardless of whether FADF_HAVEIID is set.
    */
    if(pvtType && *pvtType==VT_UNKNOWN)
    {
        if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))
        {
            if(psaArray->fFeatures & FADF_DISPATCH)
            {
                *pvtType=VT_DISPATCH;
            }
        }
    }
#endif // _WIN32_WCE

    return hrSystem;
}
template <typename _CharType>
inline _CharType* AtlCharNext(const _CharType* p) throw()
{
	ATLASSUME(p != NULL);	// Too expensive to check separately here 
#ifndef _WIN32_WCE
	if (*p == '\0')  // ::CharNextA won't increment if we're at a \0 already
#endif // _WIN32_WCE
		return const_cast<_CharType*>(p+1);
#ifndef _WIN32_WCE // This will only work for ANSI not MBCS, but MBCS isn't supported on CE.
	else
		return ::CharNextA(p);
#endif // _WIN32_WCE
}

template <>
inline wchar_t* AtlCharNext<wchar_t>(const wchar_t* p) throw()
{
	return const_cast< wchar_t* >( p+1 );
}
template<typename CharType>
inline const CharType* AtlstrchrT(const CharType* p, CharType ch) throw()
{
	ATLASSERT(p != NULL);	
	if(p==NULL)
	{
		return NULL;
	}
	while( *p != 0 )
	{
		if (*p == ch)
		{
			return p;
		}
		p = AtlCharNext(p);
	}
	//strchr for '\0' should succeed - the while loop terminates 
	//*p == 0, but ch also == 0, so NULL terminator address is returned
	return (*p == ch) ? p : NULL;
}
//Ansi and Unicode versions of printf, used with templated CharType trait classes.
#pragma warning(push)
#pragma warning(disable : 4793)
template<typename CharType>
inline int AtlprintfT(const CharType* pszFormat,... ) throw()
{
	int retval=0;
	va_list argList;
	va_start( argList, pszFormat );
	retval=vprintf(pszFormat,argList);
	va_end( argList );
	return retval;
}
#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 4793)
template<>
inline int AtlprintfT(const wchar_t* pszFormat,... ) throw()
{
	int retval=0;
	va_list argList;
	va_start( argList, pszFormat );
	retval=vwprintf(pszFormat,	argList);
	va_end( argList );
	return retval;
}
#pragma warning(pop)

inline BOOL AtlConvertSystemTimeToVariantTime(const SYSTEMTIME& systimeSrc,double* pVarDtTm)
{
	ATLENSURE(pVarDtTm!=NULL);
	//Convert using ::SystemTimeToVariantTime and store the result in pVarDtTm then
	//convert variant time back to system time and compare to original system time.	
	BOOL ok = ::SystemTimeToVariantTime(const_cast<SYSTEMTIME*>(&systimeSrc), pVarDtTm);
	SYSTEMTIME sysTime;
	::ZeroMemory(&sysTime, sizeof(SYSTEMTIME));

	ok = ok && ::VariantTimeToSystemTime(*pVarDtTm, &sysTime);
	ok = ok && (systimeSrc.wYear == sysTime.wYear &&
			systimeSrc.wMonth == sysTime.wMonth &&
			systimeSrc.wDay == sysTime.wDay &&
			systimeSrc.wHour == sysTime.wHour &&
			systimeSrc.wMinute == sysTime.wMinute && 
			systimeSrc.wSecond == sysTime.wSecond);

	return ok;
}
/////////////////////////////////////////////////////////////////////////////
//

#if !defined(_WIN32_WCE) || (!defined(_ATL_CE_VALIDATE_THREADID) && (defined(_CE_DCOM) ||defined(_ATL_NO_CE_VALIDATE_THREADID)))

#define DECLARE_CE_THREADID_VALIDATION
#define CE_VALIDATE_THREADID() (void(0))
#define CE_VALIDATE_THREADID_ASSERT() (void(0))
#define CE_VALIDATE_THREADID_RETURN(r) (void(0))
#define CE_VALIDATE_THREADID_THROW(e) (void(0))

#else // !defined(_WIN32_WCE) || defined(_ATL_NO_CE_VALIDATE_THREADID)

#ifdef _ATL_NO_CE_VALIDATE_THREADID
	#undef _ATL_NO_CE_VALIDATE_THREADID
	#pragma message("_ATL_NO_CE_VALIDATE_THREADID undefined due _ATL_CE_VALIDATE_THREADID being defined")
#endif // _ATL_CE_VALIDATE_THREADID

class CAtlCEValidateThreadIDDefault
{
public:
	CAtlCEValidateThreadIDDefault() :
		m_threadID(GetCurrentThreadId())
	{
	}
	bool Validate()
	{
		return (GetCurrentThreadId() == m_threadID);
	}
private:
	DWORD m_threadID;
};

#define _ATL_CE_VALIDATE_THREADID

#ifndef DECLARE_CE_THREADID_VALIDATION
#define DECLARE_CE_THREADID_VALIDATION CAtlCEValidateThreadIDDefault m_threadValidator;
#endif

#ifndef CE_VALIDATE_THREADID
#define CE_VALIDATE_THREADID() (m_threadValidator.Validate())
#endif

#define CE_VALIDATE_THREADID_ASSERT() \
	(ATLASSERT(CE_VALIDATE_THREADID()))
	
#define CE_VALIDATE_THREADID_RETURN(r) \
	if(CE_VALIDATE_THREADID()) return r
		
#define CE_VALIDATE_THREADID_THROW(e) \
	if(CE_VALIDATE_THREADID()) throw e
		
#endif // !defined(_WIN32_WCE) || defined(_ATL_NO_CE_VALIDATE_THREADID)

#if !defined(_WIN32_WCE) || (!defined(_ATL_STATIC_LIB_IMPL) && !defined(_ATL_DLL_IMPL) && defined(_CE_DCOM))
using ::CoDisconnectObject;
using ::CoInitialize;
using ::CoRevokeClassObject;
using ::CoRegisterClassObject;
using ::CoReleaseMarshalData;
using ::CoMarshalInterface;
using ::CoUnmarshalInterface;
using ::OleSaveToStream;
using ::OleLoadFromStream;
#endif // !defined(_WIN32_WCE) || (!defined(_ATL_STATIC_LIB_IMPL) && !defined(_ATL_DLL_IMPL) && defined(_CE_DCOM))

}	// namespace ATL
#pragma pack(pop)

#ifdef _ATL_ALL_WARNINGS
#pragma warning( pop )
#endif

#endif	// __ATLCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atldbcli.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// ATLDBCLI.H : ATL consumer code for OLEDB

#ifndef __ATLDBCLI_H__
#define __ATLDBCLI_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifdef _WIN32_WCE
	#error atldbcli.h is not supported on Windows CE (_WIN32_WCE is defined)
#endif //_WIN32_WCE
#ifndef __ATLBASE_H__
#include <atlbase.h>
#endif

#include <atlsimpstr.h>

#ifndef __oledb_h__
#include <oledb.h>
#endif // __oledb_h__

#include <oledberr.h>
#include <msdaguid.h>
#include <msdasc.h>

#pragma warning(push)

#pragma warning(disable: 4244)
#pragma warning(disable: 4127)  // conditional expression constant

#ifndef _CPPUNWIND
#pragma warning(disable: 4702) // unreachable code
#endif


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

#define DEFINE_OLEDB_TYPE_FUNCTION(ctype, oledbtype) \
	inline DBTYPE _GetOleDBType(ctype&) throw ()\
	{ \
		return oledbtype; \
	}
	inline DBTYPE _GetOleDBType(BYTE[]) throw ()
	{
		return DBTYPE_BYTES;
	}
	inline DBTYPE _GetOleDBType(CHAR[]) throw ()
	{
		return DBTYPE_STR;
	}
	inline DBTYPE _GetOleDBType(WCHAR[]) throw()
	{
		return DBTYPE_WSTR;
	}

	DEFINE_OLEDB_TYPE_FUNCTION(const WCHAR*, DBTYPE_WSTR | DBTYPE_BYREF)
	DEFINE_OLEDB_TYPE_FUNCTION(const CHAR*, DBTYPE_STR | DBTYPE_BYREF)

	DEFINE_OLEDB_TYPE_FUNCTION(CComBSTR, DBTYPE_BSTR)

	//DEFINE_OLEDB_TYPE_FUNCTION(__int8, DBTYPE_I1)
	//DEFINE_OLEDB_TYPE_FUNCTION(__int16, DBTYPE_I2)
	//DEFINE_OLEDB_TYPE_FUNCTION(__int32, DBTYPE_I4)
	DEFINE_OLEDB_TYPE_FUNCTION(__int64, DBTYPE_I8)
	//DEFINE_OLEDB_TYPE_FUNCTION(unsigned __int8, DBTYPE_UI1)
	//DEFINE_OLEDB_TYPE_FUNCTION(unsigned __int16, DBTYPE_UI2)
	//DEFINE_OLEDB_TYPE_FUNCTION(unsigned __int32, DBTYPE_UI4)
	DEFINE_OLEDB_TYPE_FUNCTION(unsigned __int64, DBTYPE_UI8)

	DEFINE_OLEDB_TYPE_FUNCTION(signed char      ,DBTYPE_I1)
	DEFINE_OLEDB_TYPE_FUNCTION(SHORT            ,DBTYPE_I2)     // DBTYPE_BOOL
	DEFINE_OLEDB_TYPE_FUNCTION(int              ,DBTYPE_I4)
	DEFINE_OLEDB_TYPE_FUNCTION(LONG             ,DBTYPE_I4)     // DBTYPE_ERROR (SCODE)
	DEFINE_OLEDB_TYPE_FUNCTION(LARGE_INTEGER    ,DBTYPE_I8)     // DBTYPE_CY
	DEFINE_OLEDB_TYPE_FUNCTION(CURRENCY		    ,DBTYPE_CY)     // DBTYPE_CY
	DEFINE_OLEDB_TYPE_FUNCTION(BYTE             ,DBTYPE_UI1)
	DEFINE_OLEDB_TYPE_FUNCTION(unsigned short   ,DBTYPE_UI2)
	DEFINE_OLEDB_TYPE_FUNCTION(unsigned int     ,DBTYPE_UI4)
	DEFINE_OLEDB_TYPE_FUNCTION(unsigned long    ,DBTYPE_UI4)
	DEFINE_OLEDB_TYPE_FUNCTION(ULARGE_INTEGER   ,DBTYPE_UI8)
	DEFINE_OLEDB_TYPE_FUNCTION(float            ,DBTYPE_R4)
	DEFINE_OLEDB_TYPE_FUNCTION(double           ,DBTYPE_R8)     // DBTYPE_DATE
	DEFINE_OLEDB_TYPE_FUNCTION(DECIMAL          ,DBTYPE_DECIMAL)
	DEFINE_OLEDB_TYPE_FUNCTION(DB_NUMERIC       ,DBTYPE_NUMERIC)
	DEFINE_OLEDB_TYPE_FUNCTION(VARIANT          ,DBTYPE_VARIANT)
	DEFINE_OLEDB_TYPE_FUNCTION(IDispatch*       ,DBTYPE_IDISPATCH)
	DEFINE_OLEDB_TYPE_FUNCTION(IUnknown*        ,DBTYPE_IUNKNOWN)
	DEFINE_OLEDB_TYPE_FUNCTION(GUID             ,DBTYPE_GUID)
	DEFINE_OLEDB_TYPE_FUNCTION(SAFEARRAY*       ,DBTYPE_ARRAY)
	DEFINE_OLEDB_TYPE_FUNCTION(DBVECTOR         ,DBTYPE_VECTOR)
	DEFINE_OLEDB_TYPE_FUNCTION(DBDATE           ,DBTYPE_DBDATE)
	DEFINE_OLEDB_TYPE_FUNCTION(DBTIME           ,DBTYPE_DBTIME)
	DEFINE_OLEDB_TYPE_FUNCTION(DBTIMESTAMP      ,DBTYPE_DBTIMESTAMP)
 	DEFINE_OLEDB_TYPE_FUNCTION(FILETIME			,DBTYPE_FILETIME)
	DEFINE_OLEDB_TYPE_FUNCTION(PROPVARIANT		,DBTYPE_PROPVARIANT)
	DEFINE_OLEDB_TYPE_FUNCTION(DB_VARNUMERIC	,DBTYPE_VARNUMERIC)

// Internal structure containing the accessor handle and a flag
// indicating whether the data for the accessor is automatically
// retrieved
struct _ATL_ACCESSOR_INFO
{
	HACCESSOR   hAccessor;
	bool        bAutoAccessor;
};

class _CNoOutputColumns
{
public:
	static bool HasOutputColumns() throw ()
	{
		return false;
	}
	static ULONG _GetNumAccessors() throw ()
	{
		return 0;
	}
	static HRESULT _GetBindEntries(LPOLESTR*, DBORDINAL*, DBBINDING*, ULONG, bool*, BYTE* pBuffer = NULL, bool bClearOnly = false) throw ()
	{
		(bClearOnly);
		(pBuffer);
		return E_FAIL;
	}
};

class _CNoParameters
{
public:
	static bool HasParameters() throw ()
	{
		return false;
	}
	static HRESULT _GetParamEntries(LPOLESTR*, DBORDINAL*, DBBINDING*, BYTE* pBuffer = NULL, bool bClearOnly = false) throw ()
	{
		(bClearOnly);
		(pBuffer);
		return E_FAIL;
	}
};

class _CNoCommand
{
public:
	static HRESULT GetDefaultCommand(LPCWSTR* /*ppszCommand*/) throw ()
	{
		return S_OK;
	}
};

typedef _CNoOutputColumns   _OutputColumnsClass;
typedef _CNoParameters      _ParamClass;
typedef _CNoCommand         _CommandClass;

#define BEGIN_ACCESSOR_MAP(x, num) \
	public: \
	typedef x _classtype; \
	typedef x _OutputColumnsClass; \
	static ULONG _GetNumAccessors() throw()\
	{ \
		return num;  \
	} \
	static bool HasOutputColumns() throw () { return true; } \
	/* If pBindings == NULL means we only return the column number */ \
	/* If pBuffer != NULL then it points to the accessor buffer and */ \
	/* we release any appropriate memory e.g. BSTR's or interface pointers */ \
	inline static HRESULT _GetBindEntries(LPOLESTR* pColumnNames, \
											DBORDINAL* pColumns, \
											DBBINDING *pBinding, \
											ULONG nAccessor, \
											bool* pAuto, \
											BYTE* pBuffer = NULL, \
											bool bClearOnly = false) \
	{ \
		ATLENSURE(pColumns != NULL); \
		DBPARAMIO eParamIO = DBPARAMIO_NOTPARAM; \
		DBORDINAL nColumns = 0; \
		(pBuffer);\

#define BEGIN_ACCESSOR(num, bAuto) \
	if (nAccessor == num) \
	{ \
		if (pBinding != NULL) \
			*pAuto = bAuto;

#define END_ACCESSOR() \
	} \
	else

#define END_ACCESSOR_MAP() \
		; \
		*pColumns = nColumns; \
		return S_OK; \
	}

#define BEGIN_COLUMN_MAP(x) \
	BEGIN_ACCESSOR_MAP(x, 1) \
		BEGIN_ACCESSOR(0, true)

#define END_COLUMN_MAP() \
		END_ACCESSOR() \
	END_ACCESSOR_MAP()

#define offsetbuf(m) offsetof(_classtype, m)
#define _OLEDB_TYPE(data) ATL::_GetOleDBType(((_classtype*)0)->data)
#define _SIZE_TYPE(data) sizeof(((_classtype*)0)->data)

#define _COLUMN_ENTRY_CODE(nOrdinal, wType, nLength, nPrecision, nScale, dataOffset, lengthOffset, statusOffset) \
	if (pBuffer != NULL) \
	{ \
		if (!bClearOnly) \
			ATL::CAccessorBase::FreeType(wType, pBuffer + dataOffset); \
		memset(pBuffer + dataOffset, 0, nLength); \
	} \
	else if (pBinding != NULL) \
	{ \
		ATLENSURE( pColumnNames != NULL ); \
		*pColumnNames = NULL; \
		ATL::CAccessorBase::Bind(pBinding, nOrdinal, wType, nLength, nPrecision, nScale, eParamIO, \
			dataOffset, lengthOffset, statusOffset); \
		pColumnNames++; \
		pBinding++; \
	} \
	nColumns++;

#define _COLUMN_NAME_CODE(pszName, wType, nLength, nPrecision, nScale, dataOffset, lengthOffset, statusOffset) \
	if (pBuffer != NULL) \
	{ \
		if (!bClearOnly) \
			ATL::CAccessorBase::FreeType(wType, pBuffer + dataOffset); \
		memset(pBuffer + dataOffset, 0, nLength); \
	} \
	else if (pBinding != NULL) \
	{ \
		ATLASSERT( pColumnNames != NULL ); \
		*pColumnNames = pszName; \
		ATL::CAccessorBase::Bind(pBinding, 0, wType, nLength, nPrecision, nScale, eParamIO, \
			dataOffset, lengthOffset, statusOffset); \
		pColumnNames++; \
		pBinding++; \
	} \
	nColumns++;

///////////////////////////////////////////////////////////////////////////
// the following tweleve macros are used for binding column by the column ordinal number

#define COLUMN_ENTRY_EX(nOrdinal, wType, nLength, nPrecision, nScale, data, length, status) \
	_COLUMN_ENTRY_CODE(nOrdinal, wType, nLength, nPrecision, nScale, offsetbuf(data), offsetbuf(length), offsetbuf(status))

#define COLUMN_ENTRY_TYPE(nOrdinal, wType, data) \
	COLUMN_ENTRY_TYPE_SIZE(nOrdinal, wType, _SIZE_TYPE(data), data)

#define COLUMN_ENTRY_TYPE_SIZE(nOrdinal, wType, nLength, data) \
	_COLUMN_ENTRY_CODE(nOrdinal, wType, nLength, 0, 0, offsetbuf(data), 0, 0)

#define COLUMN_ENTRY_TYPE_STATUS(nOrdinal, wType, status, data) \
	_COLUMN_ENTRY_CODE(nOrdinal, wType, _SIZE_TYPE(data), 0, 0, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_ENTRY_TYPE_PS(nOrdinal, wType, nPrecision, nScale, data) \
	_COLUMN_ENTRY_CODE(nOrdinal, wType, _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, 0)

// Standard macros where type and size is worked out
#define COLUMN_ENTRY(nOrdinal, data) \
	COLUMN_ENTRY_TYPE(nOrdinal, _OLEDB_TYPE(data), data)

#define COLUMN_ENTRY_LENGTH(nOrdinal, data, length) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), offsetbuf(length), 0)

#define COLUMN_ENTRY_STATUS(nOrdinal, data, status) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_ENTRY_LENGTH_STATUS(nOrdinal, data, length, status) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), offsetbuf(length), offsetbuf(status))

// Follow macros are used if precision and scale need to be specified
#define COLUMN_ENTRY_PS(nOrdinal, nPrecision, nScale, data) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, 0)

#define COLUMN_ENTRY_PS_LENGTH(nOrdinal, nPrecision, nScale, data, length) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), offsetbuf(length), 0)

#define COLUMN_ENTRY_PS_STATUS(nOrdinal, nPrecision, nScale, data, status) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_ENTRY_PS_LENGTH_STATUS(nOrdinal, nPrecision, nScale, data, length, status) \
	_COLUMN_ENTRY_CODE(nOrdinal, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), offsetbuf(length), offsetbuf(status))

///////////////////////////////////////////////////////////////////////////
// the following tweleve macros are used for binding column by the column name

#define COLUMN_NAME_EX(pszName, wType, nLength, nPrecision, nScale, data, length, status) \
	_COLUMN_NAME_CODE(pszName, wType, nLength, nPrecision, nScale, offsetbuf(data), offsetbuf(length), offsetbuf(status))

#define COLUMN_NAME_TYPE(pszName, wType, data) \
	COLUMN_NAME_TYPE_SIZE(pszName, wType, _SIZE_TYPE(data), data)

#define COLUMN_NAME_TYPE_SIZE(pszName, wType, nLength, data) \
	_COLUMN_NAME_CODE(pszName, wType, nLength, 0, 0, offsetbuf(data), 0, 0)

#define COLUMN_NAME_TYPE_STATUS(pszName, wType, status, data) \
	_COLUMN_NAME_CODE(pszName, wType, _SIZE_TYPE(data), 0, 0, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_NAME_TYPE_PS(pszName, wType, nPrecision, nScale, data) \
	_COLUMN_NAME_CODE(pszName, wType, _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, 0)

// Standard macros where type and size is worked out
#define COLUMN_NAME(pszName, data) \
	COLUMN_NAME_TYPE(pszName, _OLEDB_TYPE(data), data)

#define COLUMN_NAME_LENGTH(pszName, data, length) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), offsetbuf(length), 0)

#define COLUMN_NAME_STATUS(pszName, data, status) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_NAME_LENGTH_STATUS(pszName, data, length, status) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), 0, 0, offsetbuf(data), offsetbuf(length), offsetbuf(status))

// Follow macros are used if precision and scale need to be specified
#define COLUMN_NAME_PS(pszName, nPrecision, nScale, data) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, 0)

#define COLUMN_NAME_PS_LENGTH(pszName, nPrecision, nScale, data, length) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), offsetbuf(length), 0)

#define COLUMN_NAME_PS_STATUS(pszName, nPrecision, nScale, data, status) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), 0, offsetbuf(status))

#define COLUMN_NAME_PS_LENGTH_STATUS(pszName, nPrecision, nScale, data, length, status) \
	_COLUMN_NAME_CODE(pszName, _OLEDB_TYPE(data), _SIZE_TYPE(data), nPrecision, nScale, offsetbuf(data), offsetbuf(length), offsetbuf(status))



#define BOOKMARK_ENTRY(variable) \
	COLUMN_ENTRY_TYPE_SIZE(0, DBTYPE_BYTES, _SIZE_TYPE(variable##.m_rgBuffer), variable##.m_rgBuffer)

#define _BLOB_ENTRY_CODE(nOrdinal, IID, flags, dataOffset, lengthOffset, statusOffset) \
	if (pBuffer != NULL) \
	{ \
		if (!bClearOnly) \
			ATL::CAccessorBase::FreeType(DBTYPE_IUNKNOWN, pBuffer + dataOffset); \
		memset(pBuffer + dataOffset, 0, sizeof(IUnknown*)); \
	} \
	else if (pBinding != NULL) \
	{ \
		ATLASSERT( pColumnNames != NULL ); \
		DBOBJECT* pObject = NULL; \
		ATLTRY(pObject = new DBOBJECT); \
		if (pObject == NULL) \
			return E_OUTOFMEMORY; \
		pObject->dwFlags = flags; \
		pObject->iid     = IID; \
		*pColumnNames = NULL; \
		ATL::CAccessorBase::Bind(pBinding, nOrdinal, DBTYPE_IUNKNOWN, sizeof(IUnknown*), 0, 0, eParamIO, \
			dataOffset, lengthOffset, statusOffset, pObject); \
		pColumnNames++; \
		pBinding++; \
	} \
	nColumns++;

#define _BLOB_NAME_CODE(pszName, IID, flags, dataOffset, lengthOffset, statusOffset) \
	if (pBuffer != NULL) \
	{ \
		if (!bClearOnly) \
			ATL::CAccessorBase::FreeType(DBTYPE_IUNKNOWN, pBuffer + dataOffset); \
		memset(pBuffer + dataOffset, 0, sizeof(IUnknown*)); \
	} \
	else if (pBinding != NULL) \
	{ \
		ATLASSERT( pColumnNames != NULL ); \
		DBOBJECT* pObject = NULL; \
		ATLTRY(pObject = new DBOBJECT); \
		if (pObject == NULL) \
			return E_OUTOFMEMORY; \
		pObject->dwFlags = flags; \
		pObject->iid     = IID; \
		*pColumnNames = pszName; \
		ATL::CAccessorBase::Bind(pBinding, 0, DBTYPE_IUNKNOWN, sizeof(IUnknown*), 0, 0, eParamIO, \
			dataOffset, lengthOffset, statusOffset, pObject); \
		pColumnNames++; \
		pBinding++; \
	} \
	nColumns++;

#define BLOB_ENTRY(nOrdinal, IID, flags, data) \
	_BLOB_ENTRY_CODE(nOrdinal, IID, flags, offsetbuf(data), 0, 0);

#define BLOB_ENTRY_STATUS(nOrdinal, IID, flags, data, status) \
	_BLOB_ENTRY_CODE(nOrdinal, IID, flags, offsetbuf(data), 0, offsetbuf(status));

#define BLOB_ENTRY_LENGTH(nOrdinal, IID, flags, data, length) \
	_BLOB_ENTRY_CODE(nOrdinal, IID, flags, offsetbuf(data), offsetbuf(length), 0);

#define BLOB_ENTRY_LENGTH_STATUS(nOrdinal, IID, flags, data, length, status) \
	_BLOB_ENTRY_CODE(nOrdinal, IID, flags, offsetbuf(data), offsetbuf(length), offsetbuf(status));

#define BLOB_NAME(pszName, IID, flags, data) \
	_BLOB_NAME_CODE(pszName, IID, flags, offsetbuf(data), 0, 0);

#define BLOB_NAME_STATUS(pszName, IID, flags, data, status) \
	_BLOB_NAME_CODE(pszName, IID, flags, offsetbuf(data), 0, offsetbuf(status));

#define BLOB_NAME_LENGTH(pszName, IID, flags, data, length) \
	_BLOB_NAME_CODE(pszName, IID, flags, offsetbuf(data), offsetbuf(length), 0);

#define BLOB_NAME_LENGTH_STATUS(pszName, IID, flags, data, length, status) \
	_BLOB_NAME_CODE(pszName, IID, flags, offsetbuf(data), offsetbuf(length), offsetbuf(status));

#define BEGIN_PARAM_MAP(x) \
	public: \
	typedef x _classtype; \
	typedef x _ParamClass; \
	static bool HasParameters() throw () { return true; } \
	static HRESULT _GetParamEntries(LPOLESTR* pColumnNames, \
									DBORDINAL* pColumns, \
									DBBINDING *pBinding, \
									BYTE* pBuffer = NULL, \
									bool bClearOnly = false) \
	{ \
		ATLENSURE(pColumns != NULL); \
		DBPARAMIO eParamIO = DBPARAMIO_INPUT; \
		int nColumns = 0; \
		(pBuffer);

#define END_PARAM_MAP() \
		*pColumns = nColumns; \
		return S_OK; \
	}

#define SET_PARAM_TYPE(type) \
	eParamIO = type;

#ifdef _UNICODE
#define DEFINE_COMMAND(x, szCommand) \
	typedef x _CommandClass; \
	static HRESULT GetDefaultCommand(LPCWSTR* ppwszCommand) throw () \
	{ \
		*ppwszCommand = szCommand; \
		return S_OK; \
	}
#else // !_UNICODE
#define DEFINE_COMMAND(x, szCommand) \
	typedef x _CommandClass; \
	static HRESULT GetDefaultCommand(LPCWSTR* ppwszCommand) throw () \
	{ \
		static CA2WEX<sizeof(szCommand)> szCmd(szCommand); \
		*ppwszCommand = szCmd; \
		return S_OK; \
	}
#endif // !_UNICODE

#pragma deprecated("DEFINE_COMMAND") // Use DEFINE_COMMAND_EX instead!

#define DEFINE_COMMAND_EX(x, wszCommand) \
	typedef x _CommandClass; \
	static HRESULT GetDefaultCommand(LPCWSTR* ppwszCommand) throw () \
	{ \
		*ppwszCommand = wszCommand; \
		return S_OK; \
	}


///////////////////////////////////////////////////////////////////////////
// class CDBErrorInfo

class CDBErrorInfo
{
public:
	// Use to get the number of error record when you want to explicitly check that
	// the passed interface set the error information
	HRESULT GetErrorRecords(IUnknown* pUnk, const IID& iid, ULONG* pcRecords) throw()
	{
		CComPtr<ISupportErrorInfo> spSupportErrorInfo;
		HRESULT hr = pUnk->QueryInterface(&spSupportErrorInfo);
		if (FAILED(hr))
			return hr;

		hr = spSupportErrorInfo->InterfaceSupportsErrorInfo(iid);
		if (FAILED(hr))
			return hr;

		return GetErrorRecords(pcRecords);
	}
	// Use to get the number of error records
	HRESULT GetErrorRecords(ULONG* pcRecords) throw ()
	{
		ATLENSURE_RETURN(pcRecords != NULL);
		HRESULT hr;
		m_spErrorInfo.Release();
		m_spErrorRecords.Release();
		hr = ::GetErrorInfo(0, &m_spErrorInfo);
		if (hr == S_FALSE)
			return E_FAIL;

		hr = m_spErrorInfo->QueryInterface(__uuidof(IErrorRecords), (void**)&m_spErrorRecords);
		if (FAILED(hr))
		{
			// Well we got the IErrorInfo so we'll just treat that as
			// the one record
			*pcRecords = 1;
			return S_OK;
		}

		return m_spErrorRecords->GetRecordCount(pcRecords);
	}
	// Get the error information for the passed record number. GetErrorRecords must
	// be called before this function is called.
	HRESULT GetAllErrorInfo(ULONG ulRecordNum, LCID lcid, BSTR* pbstrDescription,
		BSTR* pbstrSource = NULL, GUID* pguid = NULL, DWORD* pdwHelpContext = NULL,
		BSTR* pbstrHelpFile = NULL) const throw() 
	{
		CComPtr<IErrorInfo> spErrorInfo;

		// If we have the IErrorRecords interface pointer then use it, otherwise
		// we'll just default to the IErrorInfo we have already retrieved in the call
		// to GetErrorRecords
		if (m_spErrorRecords != NULL)
		{
			HRESULT hr = m_spErrorRecords->GetErrorInfo(ulRecordNum, lcid, &spErrorInfo);
			if (FAILED(hr))
				return hr;
		}
		else
		{
			ATLASSUME(m_spErrorInfo != NULL);
			spErrorInfo = m_spErrorInfo;
		}

		if (pbstrDescription != NULL)
			spErrorInfo->GetDescription(pbstrDescription);

		if (pguid != NULL)
			spErrorInfo->GetGUID(pguid);

		if (pdwHelpContext != NULL)
			spErrorInfo->GetHelpContext(pdwHelpContext);

		if (pbstrHelpFile != NULL)
			spErrorInfo->GetHelpFile(pbstrHelpFile);

		if (pbstrSource != NULL)
			spErrorInfo->GetSource(pbstrSource);

		return S_OK;
	}
	// Get the error information for the passed record number
	HRESULT GetBasicErrorInfo(ULONG ulRecordNum, ERRORINFO* pErrorInfo) const throw ()
	{
		return m_spErrorRecords->GetBasicErrorInfo(ulRecordNum, pErrorInfo);
	}
	// Get the custom error object for the passed record number
	HRESULT GetCustomErrorObject(ULONG ulRecordNum, REFIID riid, IUnknown** ppObject) const throw ()
	{
		return m_spErrorRecords->GetCustomErrorObject(ulRecordNum, riid, ppObject);
	}
	// Get the IErrorInfo interface for the passed record number
	HRESULT GetErrorInfo(ULONG ulRecordNum, LCID lcid, IErrorInfo** ppErrorInfo) const throw () 
	{
		return m_spErrorRecords->GetErrorInfo(ulRecordNum, lcid, ppErrorInfo);
	}
	// Get the error parameters for the passed record number
	HRESULT GetErrorParameters(ULONG ulRecordNum, DISPPARAMS* pdispparams) const throw () 
	{
		return m_spErrorRecords->GetErrorParameters(ulRecordNum, pdispparams);
	}

// Implementation
	CComPtr<IErrorInfo>     m_spErrorInfo;
	CComPtr<IErrorRecords>  m_spErrorRecords;
};

#ifdef _DEBUG
inline void AtlTraceErrorRecords(HRESULT hrErr = S_OK)
{
	CDBErrorInfo ErrorInfo;
	ULONG        cRecords;
	HRESULT      hr;
	ULONG        i;
	CComBSTR     bstrDesc, bstrHelpFile, bstrSource;
	GUID         guid;
	DWORD        dwHelpContext;
	WCHAR        wszGuid[40];

	// If the user passed in an HRESULT then trace it
	if (hrErr != S_OK)
	{
		ATLTRACE(atlTraceDBClient, 0, _T("OLE DB Error Record dump for hr = 0x%x\n"), hrErr);
	}

	LCID lcLocale = GetSystemDefaultLCID();

	hr = ErrorInfo.GetErrorRecords(&cRecords);
	if (FAILED(hr) && ErrorInfo.m_spErrorInfo == NULL)
	{
		ATLTRACE(atlTraceDBClient, 0, _T("No OLE DB Error Information found: hr = 0x%x\n"), hr);
	}
	else
	{
		for (i = 0; i < cRecords; i++)
		{
			hr = ErrorInfo.GetAllErrorInfo(i, lcLocale, &bstrDesc, &bstrSource, &guid,
										&dwHelpContext, &bstrHelpFile);
			if (FAILED(hr))
			{
				ATLTRACE(atlTraceDBClient, 0,
					_T("OLE DB Error Record dump retrieval failed: hr = 0x%x\n"), hr);
				return;
			}
			StringFromGUID2(guid, wszGuid, sizeof(wszGuid) / sizeof(WCHAR));
			ATLTRACE(atlTraceDBClient, 0,
				_T("Row #: %4d Source: \"%s\" Description: \"%s\" Help File: \"%s\" Help Context: %4d GUID: %s\n"),
				i, static_cast<TCHAR*>(COLE2T(bstrSource)), static_cast<TCHAR*>(COLE2T(bstrDesc)), static_cast<TCHAR*>(COLE2T(bstrHelpFile)), dwHelpContext, static_cast<TCHAR*>(COLE2T(wszGuid)));
			bstrSource.Empty();
			bstrDesc.Empty();
			bstrHelpFile.Empty();
		}
		ATLTRACE(atlTraceDBClient, 0, _T("OLE DB Error Record dump end\n"));
	}
}
#else
inline void AtlTraceErrorRecords(HRESULT hrErr = S_OK) throw() { (hrErr); }
#endif


///////////////////////////////////////////////////////////////////////////
// class CDBPropSet

class CDBPropSet : public tagDBPROPSET
{
public:
	CDBPropSet()
	{
		rgProperties    = NULL;
		cProperties     = 0;
	}
	CDBPropSet(const GUID& guid)
	{
		rgProperties    = NULL;
		cProperties     = 0;
		guidPropertySet = guid;
	}
	CDBPropSet(const CDBPropSet& propset)
	{
		InternalCopy(propset);
	}
	~CDBPropSet()
	{
		for (ULONG i = 0; i < cProperties; i++)
			VariantClear(&rgProperties[i].vValue);

		CoTaskMemFree(rgProperties);
	}
	CDBPropSet& operator=(CDBPropSet& propset) throw()
	{
		if(this!=&propset)
		{
			this->~CDBPropSet();
			InternalCopy(propset);
        	}
		return *this;
	}
	// Set the GUID of the property set this class represents.
	// Use if you didn't pass the GUID to the constructor.
	void SetGUID(const GUID& guid) throw()
	{
		guidPropertySet = guid;
	}
	// Add the passed property to the property set
	bool __checkReturn AddProperty(DWORD dwPropertyID, const VARIANT& var, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		HRESULT hr;
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID   = dwPropertyID;
		hr = ::VariantCopy(&(rgProperties[cProperties].vValue), const_cast<VARIANT*>(&var));
		if (FAILED(hr))
			return false;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool __checkReturn AddProperty(DWORD dwPropertyID, LPCSTR szValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		if (!Add(propoptions))
		{
			return false;
		}
		rgProperties[cProperties].dwPropertyID   = dwPropertyID;
		rgProperties[cProperties].vValue.vt      = VT_BSTR;
		rgProperties[cProperties].vValue.bstrVal = CComBSTR(szValue).Detach();
#pragma warning(push)
#pragma warning(disable:4068)
#pragma prefast(push)
#pragma prefast(disable:325, "We are deliberately checking if this has already been allocated")
		if (rgProperties[cProperties].vValue.bstrVal == NULL)
		{
			return false;
		}
#pragma prefast(pop)
#pragma warning(pop)
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool __checkReturn AddProperty(DWORD dwPropertyID, LPCWSTR szValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		if (!Add(propoptions))
		{
			return false;
		}
		rgProperties[cProperties].dwPropertyID   = dwPropertyID;
		rgProperties[cProperties].vValue.vt      = VT_BSTR;
		rgProperties[cProperties].vValue.bstrVal = CComBSTR(szValue).Detach();
#pragma warning(push)
#pragma warning(disable:4068)
#pragma prefast(push)
#pragma prefast(disable:325, "We are deliberately checking if this has already been allocated")
		if (rgProperties[cProperties].vValue.bstrVal == NULL)
		{
			return false;
		}
#pragma prefast(pop)
#pragma warning(pop)
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool __checkReturn AddProperty(DWORD dwPropertyID, bool bValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID   = dwPropertyID;
		rgProperties[cProperties].vValue.vt      = VT_BOOL;
		rgProperties[cProperties].vValue.boolVal = (bValue) ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool __checkReturn AddProperty(DWORD dwPropertyID, BYTE bValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED)
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_UI1;
		rgProperties[cProperties].vValue.bVal   = bValue;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool __checkReturn AddProperty(DWORD dwPropertyID, short nValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED)
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_I2;
		rgProperties[cProperties].vValue.iVal   = nValue;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool __checkReturn AddProperty(DWORD dwPropertyID, long nValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED)
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_I4;
		rgProperties[cProperties].vValue.lVal   = nValue;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool __checkReturn AddProperty(DWORD dwPropertyID, float fltValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED)
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_R4;
		rgProperties[cProperties].vValue.fltVal = fltValue;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool __checkReturn AddProperty(DWORD dwPropertyID, double dblValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_R8;
		rgProperties[cProperties].vValue.dblVal = dblValue;
		cProperties++;
		return true;
	}
	// Add the passed property to the property set
	bool __checkReturn AddProperty(DWORD dwPropertyID, CY cyValue, DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		if (!Add(propoptions))
			return false;
		rgProperties[cProperties].dwPropertyID  = dwPropertyID;
		rgProperties[cProperties].vValue.vt     = VT_CY;
		rgProperties[cProperties].vValue.cyVal  = cyValue;
		cProperties++;
		return true;
	}
// Implementation
	// Create memory to add a new property
	bool __checkReturn Add(DBPROPOPTIONS propoptions = DBPROPOPTIONS_REQUIRED) throw()
	{
		if (((cProperties + 1) < cProperties))
		{
			return false;
		}
		DBPROP* rgTemp = (DBPROP*)::ATL::AtlCoTaskMemRecalloc(rgProperties, (cProperties + 1), sizeof(DBPROP));
		if (rgTemp == NULL)
			return false;
		rgProperties = rgTemp;
		rgProperties[cProperties].dwOptions = propoptions;
		rgProperties[cProperties].colid     = DB_NULLID;
		rgProperties[cProperties].vValue.vt = VT_EMPTY;
		return true;
	}
	// Copies in the passed value now it this value been cleared
	void InternalCopy(const CDBPropSet& propset) throw()
	{
		cProperties     = propset.cProperties;
		rgProperties    = (DBPROP*)::ATL::AtlCoTaskMemCAlloc(cProperties, static_cast<ULONG>(sizeof(DBPROP)));
		if (rgProperties != NULL)
		{
			guidPropertySet = propset.guidPropertySet;
			for (ULONG i = 0; i < cProperties; i++)
			{
				rgProperties[i].dwPropertyID = propset.rgProperties[i].dwPropertyID;
				if( propset.rgProperties[i].dwOptions == DBPROPOPTIONS_OPTIONAL )
					rgProperties[i].dwOptions = DBPROPOPTIONS_OPTIONAL;
				else
					rgProperties[i].dwOptions = DBPROPOPTIONS_REQUIRED;
				rgProperties[i].colid        = DB_NULLID;
				rgProperties[i].vValue.vt    = VT_EMPTY;
				HRESULT hr = VariantCopy(&rgProperties[i].vValue, &propset.rgProperties[i].vValue);
				ATLASSERT( SUCCEEDED(hr) );
				if( FAILED(hr) )
					VariantInit( &rgProperties[i].vValue );
			}
		}
		else
		{
			// The memory allocation failed so set the count
			// of properties to zero
			cProperties = 0;
		}
	}
};


///////////////////////////////////////////////////////////////////////////
// class CDBPropIDSet

class CDBPropIDSet : public tagDBPROPIDSET
{
// Constructors and Destructors
public:
	CDBPropIDSet()
	{
		rgPropertyIDs   = NULL;
		cPropertyIDs    = 0;
	}
	CDBPropIDSet(const GUID& guid)
	{
		rgPropertyIDs   = NULL;
		cPropertyIDs    = 0;
		guidPropertySet = guid;
	}
	CDBPropIDSet(const CDBPropIDSet& propidset)
	{
		InternalCopy(propidset);
	}
	~CDBPropIDSet()
	{
		free(rgPropertyIDs);
	}
	CDBPropIDSet& operator=(CDBPropIDSet& propset) throw()
	{
		this->~CDBPropIDSet();
		InternalCopy(propset);
		return *this;
	}
	// Set the GUID of the property ID set
	void SetGUID(const GUID& guid) throw()
	{
		guidPropertySet = guid;
	}
	// Add a property ID to the set
	bool AddPropertyID(DBPROPID propid) throw()
	{
		if (!Add())
			return false;
		rgPropertyIDs[cPropertyIDs] = propid;
		cPropertyIDs++;
		return true;
	}
// Implementation
	bool Add() throw()
	{
		DBPROPID* pTempID  = (DBPROPID*)_recalloc(rgPropertyIDs, (cPropertyIDs + 1), sizeof(DBPROPID));
		if (pTempID == NULL)
			return false;

		rgPropertyIDs = pTempID;
		return true;
	}
	void InternalCopy(const CDBPropIDSet& propidset) throw()
	{
		cPropertyIDs    = propidset.cPropertyIDs;
		rgPropertyIDs   = NULL;
		ATLTRY(rgPropertyIDs   = (DBPROPID*)calloc(cPropertyIDs, sizeof(DBPROPID)));
		if (rgPropertyIDs != NULL)
		{
			guidPropertySet = propidset.guidPropertySet;
			for (ULONG i = 0; i < cPropertyIDs; i++)
				rgPropertyIDs[i] = propidset.rgPropertyIDs[i];
		}
		else
		{
			// The memory allocation failed so set the count
			// of properties to zero
			cPropertyIDs = 0;
		}
	}
};


///////////////////////////////////////////////////////////////////////////
// class CBookmarkBase

class ATL_NO_VTABLE CBookmarkBase
{
public:
	virtual DBLENGTH GetSize() const = 0;
	virtual BYTE* GetBuffer() const = 0;
};


///////////////////////////////////////////////////////////////////////////
// class CBookmark

template <DBLENGTH nSize = 0>
class CBookmark : public CBookmarkBase
{
public:
	virtual DBLENGTH   GetSize() const throw() { return nSize; }
	virtual BYTE*   GetBuffer() const throw() { return (BYTE*)m_rgBuffer; }

// Implementation
	BYTE m_rgBuffer[nSize];
};


// Size of 0 means that the memory for the bookmark will be allocated
// at run time.
template <>
class CBookmark<0> : public CBookmarkBase
{
public:
	CBookmark()
	{
		m_nSize = 0;
		m_pBuffer = NULL;
	}
	CBookmark(DBLENGTH nSize)
	{
		m_pBuffer = NULL;
		ATLTRY(m_pBuffer = new BYTE[nSize]);
		m_nSize = (m_pBuffer == NULL) ? 0 : nSize;
	}
	virtual ~CBookmark()
	{
		delete [] m_pBuffer;
	}
	CBookmark& operator=(const CBookmark& bookmark) throw()
	{
		if(this!=&bookmark)
		{
			SetBookmark(bookmark.GetSize(), bookmark.GetBuffer());
		}
		return *this;
	}
	virtual DBLENGTH GetSize() const throw() { return m_nSize; }
	virtual BYTE* GetBuffer() const throw() { return m_pBuffer; }
	// Sets the bookmark to the passed value
	HRESULT SetBookmark(DBLENGTH nSize, BYTE* pBuffer) throw()
	{
		ATLASSERT(pBuffer != NULL);
		delete [] m_pBuffer;
		m_pBuffer = NULL;
		ATLTRY(m_pBuffer = new BYTE[nSize]);
		if (m_pBuffer != NULL)
		{
			Checked::memcpy_s(m_pBuffer, nSize, pBuffer, nSize);
			m_nSize = nSize;
			return S_OK;
		}
		else
		{
			m_nSize = 0;
			return E_OUTOFMEMORY;
		}
	}
	DBLENGTH  m_nSize;
	BYTE*   m_pBuffer;
};


///////////////////////////////////////////////////////////////////////////
// class CAccessorBase

class CAccessorBase
{
public:
	CAccessorBase()
	{
		m_pAccessorInfo  = NULL;
		m_nAccessors     = 0;
		m_pBuffer        = NULL;
	}
	void Close() throw()
	{
		// If Close is called then ReleaseAccessors must have been
		// called first
		ATLASSUME(m_nAccessors == 0);
		ATLASSUME(m_pAccessorInfo == NULL);
	}
	// Get the number of accessors that have been created
	ULONG GetNumAccessors() const throw() { return m_nAccessors; }
	// Get the handle of the passed accessor (offset from 0)
	HACCESSOR GetHAccessor(ULONG nAccessor) const throw() 
	{
		ATLASSERT(nAccessor<m_nAccessors);
		return m_pAccessorInfo[nAccessor].hAccessor;
	};
	// Called during Close to release the accessor information
	HRESULT ReleaseAccessors(IUnknown* pUnk) throw()
	{
		ATLENSURE_RETURN(pUnk != NULL);
		HRESULT hr = S_OK;
		if (m_nAccessors > 0)
		{
			CComPtr<IAccessor> spAccessor;
			hr = pUnk->QueryInterface(__uuidof(IAccessor), (void**)&spAccessor);
			if (SUCCEEDED(hr))
			{
				ATLENSURE_RETURN(m_pAccessorInfo != NULL);
				for (ULONG i = 0; i < m_nAccessors; i++)
					spAccessor->ReleaseAccessor(m_pAccessorInfo[i].hAccessor, NULL);
			}
			m_nAccessors = 0;
			delete [] m_pAccessorInfo;
			m_pAccessorInfo = NULL;
		}
		return hr;
	}
	// Returns true or false depending upon whether data should be
	// automatically retrieved for the passed accessor.
	bool IsAutoAccessor(ULONG nAccessor) const 
	{
		ATLASSERT(nAccessor < m_nAccessors);
		ATLENSURE(m_pAccessorInfo != NULL);
		return m_pAccessorInfo[nAccessor].bAutoAccessor;
	}

// Implementation
	// Used by the rowset class to find out where to place the data
	BYTE* GetBuffer() const throw() 
	{
		return m_pBuffer;
	}
	// Set the buffer that is used to retrieve the data
	void SetBuffer(BYTE* pBuffer) throw()
	{
		m_pBuffer = pBuffer;
	}

	bool NoBindOnNullRowset() const throw()
	{
		return false;
	}

	// Allocate internal memory for the passed number of accessors
	HRESULT AllocateAccessorMemory(int nAccessors) throw()
	{
		// Can't be called twice without calling ReleaseAccessors first
		ATLASSUME(m_pAccessorInfo == NULL);
		m_pAccessorInfo = NULL;
		ATLTRY(m_pAccessorInfo = new _ATL_ACCESSOR_INFO[nAccessors]);
		if (m_pAccessorInfo == NULL)
			return E_OUTOFMEMORY;
		m_nAccessors    = nAccessors;
		return S_OK;
	}
	// BindParameters will be overriden if parameters are used
	HRESULT BindParameters(HACCESSOR*, ICommand*, void**) throw() { return S_OK; }

	// Create an accessor for the passed binding information. The created accessor is
	// returned through the pHAccessor parameter.
	static HRESULT BindEntries(DBBINDING* pBindings, DBORDINAL nColumns, HACCESSOR* pHAccessor,
		DBLENGTH nSize, IAccessor* pAccessor) throw()
	{
		ATLENSURE_RETURN(pBindings  != NULL);
		ATLENSURE_RETURN(pHAccessor != NULL);
		ATLENSURE_RETURN(pAccessor  != NULL);
		HRESULT hr;
		DBORDINAL i;
		DWORD dwAccessorFlags = (pBindings->eParamIO == DBPARAMIO_NOTPARAM) ?
			DBACCESSOR_ROWDATA : DBACCESSOR_PARAMETERDATA;

#ifdef _DEBUG
		// In debug builds we will retrieve the status flags and trace out
		// any errors that may occur.
		CAutoVectorPtr<DBBINDSTATUS> spStatus;
		spStatus.Allocate( nColumns );
		hr = pAccessor->CreateAccessor(dwAccessorFlags, nColumns,
			pBindings, nSize, pHAccessor, spStatus);
		if (FAILED(hr) && (DBBINDSTATUS*)spStatus)
		{
			for (i=0; i<nColumns; i++)
			{
				if (spStatus[i] != DBBINDSTATUS_OK)
					ATLTRACE(atlTraceDBClient, 0, _T("Binding entry %d failed. Status: %d\n"), i, spStatus[i]);
			}
		}
#else
		hr = pAccessor->CreateAccessor(dwAccessorFlags, nColumns,
			pBindings, nSize, pHAccessor, NULL);
#endif
		for (i=0; i<nColumns; i++)
			delete pBindings[i].pObject;

		return hr;
	}

	// Set up the binding structure pointed to by pBindings based upon
	// the other passed parameters.
	static void Bind(DBBINDING* pBinding, DBORDINAL nOrdinal, DBTYPE wType,
		DBLENGTH nLength, BYTE nPrecision, BYTE nScale, DBPARAMIO eParamIO,
		DBBYTEOFFSET nDataOffset, DBBYTEOFFSET nLengthOffset = NULL, DBBYTEOFFSET nStatusOffset = NULL,
		DBOBJECT* pdbobject = NULL)
	{
		ATLENSURE(pBinding != NULL);

		// If we are getting a pointer to the data then let the provider
		// own the memory
		if (wType & DBTYPE_BYREF)
			pBinding->dwMemOwner = DBMEMOWNER_PROVIDEROWNED;
		else
			pBinding->dwMemOwner = DBMEMOWNER_CLIENTOWNED;

		pBinding->pObject   = pdbobject;

		pBinding->eParamIO      = eParamIO;
		pBinding->iOrdinal      = nOrdinal;
		pBinding->wType         = wType;
		pBinding->bPrecision    = nPrecision;
		pBinding->bScale        = nScale;
		pBinding->dwFlags       = 0;

		pBinding->obValue       = nDataOffset;
		pBinding->obLength      = 0;
		pBinding->obStatus      = 0;
		pBinding->pTypeInfo     = NULL;
		pBinding->pBindExt      = NULL;
		pBinding->cbMaxLen      = nLength;

		pBinding->dwPart = DBPART_VALUE;
		if (nLengthOffset != NULL)
		{
			pBinding->dwPart |= DBPART_LENGTH;
			pBinding->obLength = nLengthOffset;
		}
		if (nStatusOffset != NULL)
		{
			pBinding->dwPart |= DBPART_STATUS;
			pBinding->obStatus = nStatusOffset;
		}
	}

	// Free memory if appropriate
	static inline void FreeType(DBTYPE wType, BYTE* pValue, IRowset* pRowset = NULL) throw()
	{
		if (pValue == NULL)
			return;

		if( wType & DBTYPE_ARRAY )
		{
			SAFEARRAY** ppSafeArray = (SAFEARRAY**)pValue;
			if( (*ppSafeArray) != NULL )
			{
				SafeArrayDestroy(*ppSafeArray);
				*ppSafeArray = NULL;
			}
		}
		else
		{
			switch (wType)
			{
				case DBTYPE_BSTR:
					SysFreeString(*((BSTR*)pValue));
					*((BSTR*)pValue) = NULL;
				break;
				case DBTYPE_VARIANT:
					VariantClear((VARIANT*)pValue);
				break;
				case DBTYPE_IUNKNOWN:
				case DBTYPE_IDISPATCH:
					if( (*(IUnknown**)pValue) != NULL )
					{
						(*(IUnknown**)pValue)->Release();
						*(IUnknown**)pValue = NULL;
					}
				break;

				case DBTYPE_HCHAPTER:
					CComQIPtr<IChapteredRowset> spChapteredRowset = pRowset;
					if (spChapteredRowset != NULL)
						spChapteredRowset->ReleaseChapter(*(HCHAPTER*)pValue, NULL);
				break;
			}
		}
		if ((wType & DBTYPE_VECTOR) && ~(wType & DBTYPE_BYREF))
			CoTaskMemFree(((DBVECTOR*)pValue)->ptr);
	}

	void FreeRecordMemory(IRowset* /*pRowset*/) throw()
	{
	}

	_ATL_ACCESSOR_INFO* m_pAccessorInfo;
	ULONG               m_nAccessors;
	BYTE*               m_pBuffer;
};

class CXMLAccessor;

///////////////////////////////////////////////////////////////////////////
// class CRowset

template <class TAccessor = CAccessorBase>
class CRowset
{
// Constructors and Destructors
public:
	CRowset()
	{
		m_pXMLAccessor = NULL;
		m_pAccessor = NULL;
		m_hRow      = NULL;
	}
	CRowset(IRowset* pRowset)
	{
		m_pXMLAccessor = NULL;
		m_pAccessor = NULL;
		m_hRow      = NULL;
		m_spRowset  = pRowset;
	}
	~CRowset()
	{
		Close();
	}

	HRESULT GetXMLColumnInfo( CSimpleStringW& strOutput ) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		HRESULT hr;
		if( m_pXMLAccessor == NULL )
		{
			ATLTRY(m_pXMLAccessor = new CXMLAccessor);
			if( m_pXMLAccessor == NULL )
				return E_OUTOFMEMORY;
			hr = m_pXMLAccessor->BindColumns( m_spRowset );
			if( FAILED(hr) )
			{
				delete m_pXMLAccessor;
				m_pXMLAccessor = NULL;
				return hr;
			}
		}

		ATLASSUME( m_pXMLAccessor != NULL );

		return m_pXMLAccessor->GetXMLColumnData( strOutput );
	}

	HRESULT GetXMLRow( CSimpleStringW& strOutput, bool bAppend = false ) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_hRow != NULL);

		HRESULT hr;
		if( m_pXMLAccessor == NULL )
		{
			ATLTRY(m_pXMLAccessor = new CXMLAccessor);
			if( m_pXMLAccessor == NULL )
				return E_OUTOFMEMORY;
			hr = m_pXMLAccessor->BindColumns( m_spRowset );
			if( FAILED(hr) )
			{
				delete m_pXMLAccessor;
				m_pXMLAccessor = NULL;
				return hr;
			}
		}

		ATLASSUME( m_pXMLAccessor != NULL );

		hr = m_spRowset->GetData(m_hRow, m_pXMLAccessor->GetHAccessor(0), m_pXMLAccessor->GetBuffer());
		if( FAILED(hr) )
			return hr;

		hr = m_pXMLAccessor->GetXMLRowData( strOutput, bAppend );

		m_pXMLAccessor->FreeRecordMemory( GetInterface() );
		return hr;
	}

	// Release any retrieved row handles and then release the rowset
	void Close() throw()
	{
		if( m_pXMLAccessor != NULL )
		{
			if (m_spRowset != NULL)
				m_pXMLAccessor->ReleaseAccessors( m_spRowset );
			delete m_pXMLAccessor;
			m_pXMLAccessor = NULL;
		}
		if (m_spRowset != NULL)
		{
			m_pAccessor->FreeRecordMemory(m_spRowset);
			ReleaseRows();
			m_spRowset.Release();
			m_spRowsetChange.Release();
		}
	}
	// Addref the current row
	HRESULT AddRefRows() throw()
	{
		ATLASSUME(m_spRowset != NULL);
		return m_spRowset->AddRefRows(1, &m_hRow, NULL, NULL);
	}
	// Release the current row
	HRESULT ReleaseRows() throw()
	{
		ATLASSUME(m_spRowset != NULL);
		HRESULT hr = S_OK;

		if (m_hRow != NULL)
		{
			hr = m_spRowset->ReleaseRows(1, &m_hRow, NULL, NULL, NULL);
			m_hRow = NULL;
		}
		return hr;
	}

	CRowset<>* GetRowsetBase() throw()
	{
		return (CRowset<>*)this;
	}

	// Compare two bookmarks with each other
	HRESULT Compare(const CBookmarkBase& bookmark1, const CBookmarkBase& bookmark2, DBCOMPARE* pComparison) const throw()
	{
		ATLASSUME(m_spRowset != NULL);
		CComPtr<IRowsetLocate> spLocate;
		HRESULT hr = m_spRowset.QueryInterface(&spLocate);
		if (FAILED(hr))
			return hr;

		return spLocate->Compare(NULL, bookmark1.GetSize(), bookmark1.GetBuffer(),
			bookmark2.GetSize(), bookmark2.GetBuffer(), pComparison);
	}

	// Compare the passed hRow with the current row
	HRESULT IsSameRow(HROW hRow) const throw() 
	{
		ATLASSUME(m_spRowset != NULL);
		if (m_hRow == hRow)
			return S_OK;

		CComPtr<IRowsetIdentity> spRowsetIdentity;
		HRESULT hr = m_spRowset.QueryInterface(&spRowsetIdentity);
		if (FAILED(hr))
			return hr;

		return spRowsetIdentity->IsSameRow(m_hRow, hRow);
	}

	// Move to the previous record
	HRESULT MovePrev() throw()
	{
		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		return MoveNext(-2);
	}

	// Move to the next record
	HRESULT MoveNext() throw()
	{
		return MoveNext(0);
	}

	// Move lSkip records forward or backward
	HRESULT MoveNext(LONG lSkip, bool bForward = true) throw()
	{
		HRESULT hr;
		DBCOUNTITEM ulRowsFetched = 0;

		// Check the data was opened successfully and the accessor
		// has been set.
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_pAccessor != NULL);

		m_pAccessor->FreeRecordMemory(m_spRowset);
		// Release a row if one is already around
		ReleaseRows();

		// Get the row handle
		HROW* phRow = &m_hRow;
		hr = m_spRowset->GetNextRows(NULL, lSkip, (bForward) ? 1 : -1, &ulRowsFetched, &phRow);
		if (hr != S_OK)
			return hr;

		// Get the data
		hr = GetData();
		if (FAILED(hr))
		{
			ATLTRACE(atlTraceDBClient, 0, _T("GetData failed - HRESULT = 0x%X\n"),hr);
			ReleaseRows();
		}
		return hr;
	}

	// Move to the first record
	HRESULT MoveFirst() throw()
	{
		HRESULT hr;

		// Check the data was opened successfully and the accessor
		// has been set.
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_pAccessor != NULL);

		m_pAccessor->FreeRecordMemory(m_spRowset);
		// Release a row if one is already around
		ReleaseRows();

		// the call to RestartPosition may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		hr = m_spRowset->RestartPosition(NULL);
		if (FAILED(hr))
			return hr;

		// Get the data
		return MoveNext();
	}

	// Move to the last record
	HRESULT MoveLast() throw()
	{
		// Check the data was opened successfully and the accessor
		// has been set.
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_pAccessor != NULL);

		// Release a row if one is already around
		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();

		HRESULT hr;
		DBCOUNTITEM ulRowsFetched = 0;
		HROW* phRow = &m_hRow;

		// Restart the rowset position and then move backwards

		// the call to RestartPosition may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		m_spRowset->RestartPosition(NULL);
		hr = m_spRowset->GetNextRows(NULL, -1, 1, &ulRowsFetched, &phRow);
		if (hr != S_OK)
			return hr;

		// Get the data
		hr = GetData();
		if (FAILED(hr))
		{
			ATLTRACE(atlTraceDBClient, 0, _T("GetData from MoveLast failed - HRESULT = 0x%X\n"),hr);
			ReleaseRows();
		}

		return S_OK;
	}
	// Move to the passed bookmark
	HRESULT MoveToBookmark(const CBookmarkBase& bookmark, LONG lSkip = 0) throw()
	{
		// Check the data was opened successfully and the accessor
		// has been set.
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_pAccessor != NULL);

		CComPtr<IRowsetLocate> spLocate;
		HRESULT hr = m_spRowset.QueryInterface(&spLocate);
		if (FAILED(hr))
			return hr;

		m_pAccessor->FreeRecordMemory(m_spRowset);
		// Release a row if one is already around
		ReleaseRows();

		DBCOUNTITEM ulRowsFetched = 0;
		HROW* phRow = &m_hRow;
		hr = spLocate->GetRowsAt(NULL, NULL, bookmark.GetSize(), bookmark.GetBuffer(),
			lSkip, 1, &ulRowsFetched, &phRow);
		// Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
		if (hr != S_OK)
			return hr;

		// Get the data
		hr = GetData();
		if (FAILED(hr))
		{
			ATLTRACE(atlTraceDBClient, 0, _T("GetData from Bookmark failed - HRESULT = 0x%X\n"),hr);
			ReleaseRows();
		}

		return S_OK;
	}

	// Get the data for the current record
	HRESULT GetData() throw()
	{
		HRESULT hr = S_OK;
		ATLASSUME(m_pAccessor != NULL);

		ULONG nAccessors = m_pAccessor->GetNumAccessors();
		for (ULONG i=0; i<nAccessors; i++)
		{
			if (m_pAccessor->IsAutoAccessor(i))
			{
				hr = GetData(i);
				if (FAILED(hr))
					return hr;
			}
		}
		return hr;
	}

	// Get the data for the passed accessor. Use for a non-auto accessor
	HRESULT GetData(int nAccessor) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_pAccessor != NULL);
		ATLASSUME(m_hRow != NULL);

		// Note that we are using the specified buffer if it has been set,
		// otherwise we use the accessor for the data.
		return m_spRowset->GetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor), m_pAccessor->GetBuffer());
	}

	// Get the data for the passed accessor. Use for a non-auto accessor
	HRESULT GetDataHere(int nAccessor, void* pBuffer) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_pAccessor != NULL);
		ATLASSUME(m_hRow != NULL);

		// Note that we are using the specified buffer if it has been set,
		// otherwise we use the accessor for the data.
		return m_spRowset->GetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor), pBuffer);
	}

	HRESULT GetDataHere(void* pBuffer) throw()
	{
		HRESULT hr = S_OK;

		ULONG nAccessors = m_pAccessor->GetNumAccessors();
		for (ULONG i=0; i<nAccessors; i++)
		{
			hr = GetDataHere(i, pBuffer);
			if (FAILED(hr))
				return hr;
		}
		return hr;
	}

	// Insert the current record
	HRESULT Insert(int nAccessor = 0, bool bGetHRow = false) throw()
	{
		ATLASSUME(m_pAccessor != NULL);
		HRESULT hr;
		if (m_spRowsetChange != NULL)
		{
			HROW* pHRow;
			if (bGetHRow)
			{
				ReleaseRows();
				pHRow = &m_hRow;
			}
			else
				pHRow = NULL;

			hr = m_spRowsetChange->InsertRow(NULL, m_pAccessor->GetHAccessor(nAccessor),
					m_pAccessor->GetBuffer(), pHRow);

		}
		else
			hr = E_NOINTERFACE;

		return hr;
	}

	// Delete the current record
	HRESULT Delete() const throw() 
	{
		ATLASSUME(m_pAccessor != NULL);
		HRESULT hr;
		if (m_spRowsetChange != NULL)
			hr = m_spRowsetChange->DeleteRows(NULL, 1, &m_hRow, NULL);
		else
			hr = E_NOINTERFACE;

		return hr;
	}

	// Update the current record
	HRESULT SetData() const throw()
	{
		ATLASSUME(m_pAccessor != NULL);
		HRESULT hr = S_OK;

		ULONG nAccessors = m_pAccessor->GetNumAccessors();
		for (ULONG i=0; i<nAccessors; i++)
		{
			hr = SetData(i);
			if (FAILED(hr))
				return hr;
		}
		return hr;
	}

	// Update the current record with the data in the passed accessor
	HRESULT SetData(int nAccessor) const throw()
	{
		ATLASSUME(m_pAccessor != NULL);
		HRESULT hr;
		if (m_spRowsetChange != NULL)
		{
			hr = m_spRowsetChange->SetData(m_hRow, m_pAccessor->GetHAccessor(nAccessor),
				m_pAccessor->GetBuffer());
		}
		else
			hr = E_NOINTERFACE;

		return hr;
	}

	// Get the data most recently fetched from or transmitted to the data source.
	// Does not get values based on pending changes.
	HRESULT GetOriginalData() throw()
	{
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_pAccessor != NULL);

		HRESULT hr = S_OK;
		CComPtr<IRowsetUpdate> spRowsetUpdate;
		hr = m_spRowset->QueryInterface(&spRowsetUpdate);
		if (FAILED(hr))
			return hr;

		ULONG nAccessors = m_pAccessor->GetNumAccessors();
		for (ULONG i = 0; i < nAccessors; i++)
		{
			hr = spRowsetUpdate->GetOriginalData(m_hRow, m_pAccessor->GetHAccessor(i), m_pAccessor->GetBuffer());
			if (FAILED(hr))
				return hr;
		}
		return hr;
	}

	// Get the status of the current row
	HRESULT GetRowStatus(DBPENDINGSTATUS* pStatus) const throw()
	{
		ATLASSUME(m_spRowset != NULL);
		ATLASSERT(pStatus != NULL);

		CComPtr<IRowsetUpdate> spRowsetUpdate;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
		if (FAILED(hr))
			return hr;

		return spRowsetUpdate->GetRowStatus(NULL, 1, &m_hRow, pStatus);
	}

	// Undo any changes made to the current row since it was last fetched or Update
	// was called for it
	HRESULT Undo(DBCOUNTITEM* pcRows = NULL, HROW* phRow = NULL, DBROWSTATUS* pStatus = NULL) throw()
	{
		ATLASSUME(m_spRowset != NULL);

		CComPtr<IRowsetUpdate> spRowsetUpdate;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
		if (FAILED(hr))
			return hr;

		CComHeapPtr<HROW> sprgRows;
		CComHeapPtr<DBROWSTATUS> spRowStatus;

		if (phRow != NULL)
			hr = spRowsetUpdate->Undo(NULL, 1, &m_hRow, pcRows, &sprgRows, &spRowStatus);
		else
			hr = spRowsetUpdate->Undo(NULL, 1, &m_hRow, pcRows, NULL, &spRowStatus);

		if (phRow != NULL && sprgRows != NULL)
			*phRow = *sprgRows;

		if (pStatus != NULL && spRowStatus != NULL)
			*pStatus = *spRowStatus;

		return hr;
	}

	// Transmits any pending changes made to a row since it was last fetched or Update was
	// called for it. Also see SetData.
	HRESULT Update(DBCOUNTITEM* pcRows = NULL, HROW* phRow = NULL, DBROWSTATUS* pStatus = NULL) throw()
	{
		ATLASSUME(m_spRowset != NULL);

		CComPtr<IRowsetUpdate> spRowsetUpdate;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
		if (FAILED(hr))
			return hr;

		CComHeapPtr<HROW>           sprgRows;
		CComHeapPtr<DBROWSTATUS>    spRowStatus;

		if (phRow != NULL)
			hr = spRowsetUpdate->Update(NULL, 1, &m_hRow, pcRows, &sprgRows, &spRowStatus);
		else
			hr = spRowsetUpdate->Update(NULL, 1, &m_hRow, pcRows, NULL, &spRowStatus);

		if (phRow != NULL && sprgRows != NULL)
			*phRow = *sprgRows;

		if (pStatus != NULL && spRowStatus != NULL)
			*pStatus = *spRowStatus;

		return hr;
	}
	// Transmits any pending changes to all rows made since it was last fetched or Update was
	// alled for it.  Differs from Update in that it will do every row (even if we don't hold
	// the handle for it).  
	HRESULT UpdateAll(DBCOUNTITEM* pcRows = NULL, HROW** pphRow = NULL, DBROWSTATUS** ppStatus = NULL) throw()
	{
		ATLASSUME(m_spRowset != NULL);

		CComPtr<IRowsetUpdate> spRowsetUpdate;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetUpdate);
		if (FAILED(hr))
			return hr;

		// Create some temporary variables to help with debugging.
		DBCOUNTITEM		cRowsReturned = 0;
		CComHeapPtr<HROW>			sprgRows;
		CComHeapPtr<DBROWSTATUS>	spRowStatus;

		// Passing zero for the 2nd parameter tells the provider to update ALL pending rows.
		// The 3rd parameter, prghRows is ignored.  
		hr =  spRowsetUpdate->Update(NULL, 0, NULL, &cRowsReturned, &sprgRows, &spRowStatus);

		// NOTE, the user must CoTaskMemFree *pphRow and *ppStatus after return, if they 
		// are non-NULL.  Otherwise, we'll CoTaskMemFree if they are NULL.
		if (pcRows != NULL)
			*pcRows = cRowsReturned;

		if (pphRow != NULL)
			*pphRow = sprgRows.Detach();

		if (ppStatus != NULL)
			*ppStatus = spRowStatus.Detach();

		return hr;
	}

	// Get the approximate position of the row corresponding to the passed bookmark
	HRESULT GetApproximatePosition(const CBookmarkBase* pBookmark, DBCOUNTITEM* pPosition, DBCOUNTITEM* pcRows) throw()
	{
		ATLASSUME(m_spRowset != NULL);

		CComPtr<IRowsetScroll> spRowsetScroll;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetScroll);
		if (SUCCEEDED(hr))
		{
			if (pBookmark != NULL)
				hr = spRowsetScroll->GetApproximatePosition(NULL, pBookmark->GetSize(), pBookmark->GetBuffer(),
						pPosition, pcRows);
			else
				hr = spRowsetScroll->GetApproximatePosition(NULL, 0, NULL, pPosition, pcRows);

		}
		return hr;

	}
	// Move to a fractional position in the rowset
	HRESULT MoveToRatio(DBCOUNTITEM nNumerator, DBCOUNTITEM nDenominator, bool bForward = true) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		DBCOUNTITEM nRowsFetched;

		CComPtr<IRowsetScroll> spRowsetScroll;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetScroll);
		if (FAILED(hr))
			return hr;

		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();
		HROW* phRow = &m_hRow;
		hr = spRowsetScroll->GetRowsAtRatio(NULL, NULL, nNumerator, nDenominator, (bForward) ? 1 : -1,
			&nRowsFetched, &phRow);
		// Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
		if (hr == S_OK)
			hr = GetData();

		return hr;
	}

	HRESULT FindNextRow(DBCOMPAREOP op, BYTE* pData, DBTYPE wType, DBLENGTH nLength,
		BYTE bPrecision, BYTE bScale, BOOL bSkipCurrent = TRUE, CBookmarkBase* pBookmark = NULL) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		DBBINDING   binding;
		HRESULT     hr;
		HACCESSOR   hAccessor;
		DBCOUNTITEM ulRowsFetched = 0;
		HROW*       phRow = &m_hRow;
		DBLENGTH    cbBookmark;
		BYTE*       pBookmarkBuffer;
		CComQIPtr<IAccessor, &__uuidof(IAccessor)>        spAccessor(m_spRowset);
		CComQIPtr<IRowsetFind, &__uuidof(IRowsetFind)>    spRowsetFind(m_spRowset);

		if (spAccessor == NULL || spRowsetFind == NULL)
			return E_NOINTERFACE;

		TAccessor::Bind(&binding, 1, wType, nLength, bPrecision, bScale, DBPARAMIO_NOTPARAM, 0);
		hr = CAccessorBase::BindEntries(&binding, 1, &hAccessor, nLength, spAccessor);
		if (FAILED(hr))
			return hr;

		if (pBookmark == NULL)
		{
			cbBookmark = 0;
			pBookmarkBuffer = NULL;
		}
		else
		{
			cbBookmark = pBookmark->GetSize();
			pBookmarkBuffer = pBookmark->GetBuffer();
		}

		hr = spRowsetFind->FindNextRow(DB_NULL_HCHAPTER, hAccessor, pData, op, cbBookmark, pBookmarkBuffer,
					bSkipCurrent, 1,  &ulRowsFetched, &phRow);
		// Note we're not using SUCCEEDED here, because we could get DB_S_ENDOFROWSET
		if (hr != S_OK)
			return hr;

		// Get the data
		hr = GetData();
		spAccessor->ReleaseAccessor(hAccessor, NULL);
		if (FAILED(hr))
		{
			ATLTRACE(_T("ATL: GetData from FindNextRows failed - HRESULT = 0x%X\n"),hr);
			ReleaseRows();
		}
		return S_OK;
	}

// Implementation
	static const IID& GetIID() throw()
	{
		return __uuidof(IRowset);
	}

	IRowset* GetInterface() const throw() 
	{
		return m_spRowset;
	}

	IRowset** GetInterfacePtr() throw()
	{
		return &m_spRowset;
	}

	void SetupOptionalRowsetInterfaces() throw()
	{
		// Cache IRowsetChange if available
		if (m_spRowset != NULL)
			m_spRowset->QueryInterface(&m_spRowsetChange);
	}

	HRESULT BindFinished() const throw() 
	{ 
		return S_OK; 
	}

	void SetAccessor(TAccessor* pAccessor) throw()
	{
		m_pAccessor = pAccessor;
	}

	CComPtr<IRowset>        m_spRowset;
	CComPtr<IRowsetChange>  m_spRowsetChange;
	TAccessor*				m_pAccessor;
	HROW                    m_hRow;
	CXMLAccessor* m_pXMLAccessor;
};

///////////////////////////////////////////////////////////////////////////
// class CBulkRowset

template <class TAccessor>
class CBulkRowset : public CRowset<TAccessor>
{
public:
	CBulkRowset()
	{
		// Default the number of rows to bulk fetch to 10
		m_nRows = 10;
		m_hr    = S_OK;
		m_phRow = NULL;
	}

	~CBulkRowset()
	{
		Close();
	}

	void Close() throw()
	{
		if (m_spRowset != NULL)
		{
			m_pAccessor->FreeRecordMemory(m_spRowset);
			ReleaseRows();
		}
		CRowset<TAccessor>::Close();

		delete [] m_phRow;
		m_phRow = NULL;

		m_hr = S_OK;
	}
	// Set the number of row handles that will be retrieved in each
	// bulk row fetch. The default is 10 and this function must be called
	// before Open if you wish to change it.
	void SetRows(DBROWCOUNT nRows) throw()
	{
		if (nRows == 0)
			nRows = 10;
		if (nRows != m_nRows)
		{
			// This function must be called before the memory is allocated
			// during binding or between a Close() and a Open()
			delete m_phRow;
			m_phRow = NULL;
			m_nRows = nRows;
		}
	}
	// AddRef all the currently retrieved row handles
	HRESULT AddRefRows() throw()
	{
		ATLASSUME(m_spRowset != NULL);
		return m_spRowset->AddRefRows(m_nCurrentRows, m_phRow, NULL, NULL);
	}
	// Release all the currently retrieved row handles
	HRESULT ReleaseRows() throw()
	{
		ATLASSUME(m_spRowset != NULL);
		// We're going to Release the rows so reset the current row position
		m_nCurrentRow = 0;
		m_hRow        = NULL;
		DBCOUNTITEM nCurrentRows = m_nCurrentRows;
		m_nCurrentRows = 0;
		return m_spRowset->ReleaseRows(nCurrentRows, m_phRow, NULL, NULL, NULL);
	}
	// Move to the first record
	HRESULT MoveFirst() throw()
	{
		ATLASSUME(m_spRowset != NULL);

		m_hr = S_OK;
		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();
		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		HRESULT hr = m_spRowset->RestartPosition(NULL);
		if (FAILED(hr))
			return hr;

		// Get the data
		return MoveNext(0);
	}
	// Move to the last record
	HRESULT MoveLast() throw()
	{
		m_hr = S_OK;
		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();
		m_hr = S_OK;
		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		return CRowset<TAccessor>::MoveLast();
	}
	// Move to the next record
	HRESULT MoveNext() throw()
	{
		return MoveNext(0);
	}
	// Move to the previous record
	HRESULT MovePrev() throw()
	{
		// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
		// DBPROP_CANSCROLLBACKWARDS properties have not been set.
		return MoveNext(-2);
	}
	// Move lSkip records forward or backward
	HRESULT MoveNext(DBROWOFFSET lSkip, bool bForward = true) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		ATLASSUME(m_phRow    != NULL);

		m_pAccessor->FreeRecordMemory(m_spRowset);

		// Calculate the record index in the buffer
		DBROWOFFSET nNewRow = m_nCurrentRow + lSkip + (bForward ? 1 : -1);

		bool bFetchNewRows = false;
		// Is the row in the buffer?
		// else adjust the skip value
		if (m_nCurrentRows == 0)
		{
			//lSkip = 0;
			bFetchNewRows = true;
		}
		else if (nNewRow >= (DBROWOFFSET)m_nCurrentRows)
		{
			bFetchNewRows = true;
			lSkip = nNewRow - m_nCurrentRows + (bForward ? 0 : (2 - m_nRows));
		}
		else if (nNewRow < 0)
		{
			lSkip = nNewRow - (m_nCurrentRows - m_nCurrentRow) + (bForward ? 0 : (2 - m_nRows));
			bFetchNewRows = true;
		}

		if (bFetchNewRows)
		{
			nNewRow = 0;
			// If we've reached the end of the buffer and we had a non S_OK HRESULT from
			// the last call to GetNextRows then return that HRESULT now.
			if (m_hr != S_OK && m_hr != DB_S_ROWLIMITEXCEEDED)
				return m_hr;

			// We've finished with these rows so we need some more
			// First release any HROWs that we have
			ReleaseRows();

			// the following line of code may fail if the DBPROP_CANFETCHBACKWARDS and/or
			// DBPROP_CANSCROLLBACKWARDS properties have not been set and the lSkip offset is negative.
			m_hr = m_spRowset->GetNextRows(NULL, lSkip, m_nRows, &m_nCurrentRows, &m_phRow);

			// If we have an error HRESULT or we haven't retrieved any rows then return
			// the HRESULT now.
			if (FAILED(m_hr) || m_nCurrentRows == 0)
				return m_hr;
			if (!bForward)
				nNewRow = m_nCurrentRows - 1;
		}

		// Get the data for the current row
		m_hRow = m_phRow[m_nCurrentRow = nNewRow];
		return GetData();
	}
	// Move to the passed bookmark
	HRESULT MoveToBookmark(const CBookmarkBase& bookmark, DBCOUNTITEM lSkip = 0) throw()
	{
		ATLASSUME(m_spRowset != NULL);
		CComPtr<IRowsetLocate> spLocate;
		HRESULT hr = m_spRowset->QueryInterface(&spLocate);
		if (FAILED(hr))
			return hr;

		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();
		m_hr = spLocate->GetRowsAt(NULL, NULL, bookmark.GetSize(), bookmark.GetBuffer(),
			lSkip, m_nRows, &m_nCurrentRows, &m_phRow);
		if( (m_hr != S_OK || m_nCurrentRows == 0 ) && m_hr != DB_S_ENDOFROWSET)
			return m_hr;

		// Get the data
		m_hRow = m_phRow[m_nCurrentRow];
		return GetData();
	}
	// Move to a fractional position in the rowset
	HRESULT MoveToRatio(DBCOUNTITEM nNumerator, DBCOUNTITEM nDenominator) throw()
	{
		ATLASSUME(m_spRowset != NULL);

		CComPtr<IRowsetScroll> spRowsetScroll;
		HRESULT hr = m_spRowset->QueryInterface(&spRowsetScroll);
		if (FAILED(hr))
			return hr;

		m_pAccessor->FreeRecordMemory(m_spRowset);
		ReleaseRows();
		m_hr = spRowsetScroll->GetRowsAtRatio(NULL, NULL, nNumerator, nDenominator, m_nRows, &m_nCurrentRows, &m_phRow);
		if (m_hr != S_OK || m_nCurrentRows == 0)
			return m_hr;

		// Get the data
		m_hRow = m_phRow[m_nCurrentRow];
		return GetData();
	}
	// Insert the current record
	HRESULT Insert(int nAccessor = 0, bool bGetHRow = false) throw()
	{
		ReleaseRows();
		return CRowset< TAccessor >::Insert(nAccessor, bGetHRow);
	}

// Implementation
	HRESULT BindFinished() throw()
	{
		// No rows in the buffer yet
		m_nCurrentRows = 0;
		// Cause MoveNext to automatically perform a new bulk fetch the first time
		m_nCurrentRow  = 0;
		m_hr = S_OK;

		// Do not allocate if the buffer has been allocated by a previous call to BindFinished.
		if (m_phRow == NULL)
		{
			ATLTRY(m_phRow = new HROW[m_nRows]);
			if (m_phRow == NULL)
				return E_OUTOFMEMORY;
		}

		return S_OK;
	}

	HRESULT m_hr;           // HRESULT to return from MoveNext at end of buffer
	HROW*   m_phRow;        // Pointer to array of HROWs for each row in buffer
	DBROWCOUNT   m_nRows;        // Number of rows that will fit in the buffer
	DBCOUNTITEM  m_nCurrentRows; // Number of rows currently in the buffer
	DBCOUNTITEM  m_nCurrentRow;
};

/////////////////////////////////////////////////////////////////////////////
// Large Block Allocation Helper - CVBufHelper & CVirtualBuffer
template <class T>
class CVBufHelper
{
public:
	virtual T* operator()(T* pCurrent) {return pCurrent;}
};

template <class T>
class CVirtualBuffer
{
protected:
	CVirtualBuffer() {}
	T* m_pTop;
	int m_nMaxElements;
public:
	T* m_pBase;
	T* m_pCurrent;
	CVirtualBuffer(int nMaxElements)
	{
		//in case of overflow throw exception
		ATLENSURE(nMaxElements>=0);
			
		ATLENSURE(nMaxElements <=size_t(-1)/sizeof(T)); //overflow check
		m_nMaxElements = nMaxElements;
 		m_pBase = (T*) VirtualAlloc(NULL,sizeof(T)*nMaxElements,	MEM_RESERVE, PAGE_READWRITE);
		if(m_pBase == NULL)
		{
			_AtlRaiseException((DWORD)STATUS_NO_MEMORY);
		}
		m_pTop = m_pCurrent = m_pBase;
		// Commit first page - chances are this is all that will be used
		VirtualAlloc(m_pBase, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
	}
	~CVirtualBuffer()
	{
		VirtualFree(m_pBase, 0, MEM_RELEASE);
	}
	int Except(LPEXCEPTION_POINTERS lpEP)
	{
		EXCEPTION_RECORD* pExcept = lpEP->ExceptionRecord;
		if (pExcept->ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
			return EXCEPTION_CONTINUE_SEARCH;
		BYTE* pAddress = (LPBYTE) pExcept->ExceptionInformation[1];
		VirtualAlloc(pAddress, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
		return EXCEPTION_CONTINUE_EXECUTION;
	}
	bool Seek(int nElement)
	{
		ATLASSERT(nElement >= 0 && nElement < m_nMaxElements);
		if(nElement < 0 || nElement >= m_nMaxElements)
			return false;
		m_pCurrent = &m_pBase[nElement];
		return true;
	}
	void SetAt(int nElement, const T& Element)
	{
		ATLASSERT(nElement >= 0 && nElement < m_nMaxElements);
		__try
		{
			T* p = &m_pBase[nElement];
			*p = Element;
			m_pTop = p++ > m_pTop ? p : m_pTop;
		}
		__except(Except(GetExceptionInformation()))
		{
		}

	}
	template <class Q>
	void WriteBulk(Q& helper)
	{
		__try
		{
			m_pCurrent = helper(m_pBase);
			m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
		}
		__except(Except(GetExceptionInformation()))
		{
		}
	}
	void Write(const T& Element)
	{
		__try
		{
			*m_pCurrent = Element;
			m_pCurrent++;
			m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
		}
		__except(Except(GetExceptionInformation()))
		{
		}
	}
	T& Read()
	{
		return *m_pCurrent;
	}
	operator BSTR()
	{
		BSTR bstrTemp = NULL ;
		__try
		{
			bstrTemp = SysAllocStringByteLen((char*) m_pBase,
				(UINT) ((BYTE*)m_pTop - (BYTE*)m_pBase));
		}
		__except(Except(GetExceptionInformation()))
		{
		}
		return bstrTemp;
	}
	const T& operator[](int nElement) const
	{
		if(nElement < 0 || nElement >= m_nMaxElements)
			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);		
	
		return m_pBase[nElement];
	}
	operator T*()
	{
		return m_pBase;
	}
};

typedef CVirtualBuffer<BYTE> CVirtualBytes;

///////////////////////////////////////////////////////////////////////////
// class CArrayRowset
//
// Allows you to access a rowset with an array syntax. TAccessor must be a
// CAccessor<> type class

template <class TAccessor>
class CArrayRowset :
	public CVirtualBuffer<typename TAccessor::DataClass>,
	protected CBulkRowset<TAccessor>
{
public:
	CArrayRowset(int nMax = 100000) : CVirtualBuffer<TAccessor::DataClass>(nMax)
	{
		m_nRowsRead = 0;
	}
	typename TAccessor::DataClass& operator[](int nRow)
	{
		ATLASSERT(nRow >= 0);
		if( nRow < 0 )
			AtlThrow(E_INVALIDARG);

		HRESULT hr = S_OK;
		TAccessor::DataClass* pCurrent = m_pBase + m_nRowsRead;

		// Retrieve the row if we haven't retrieved it already
		while ((ULONG)nRow >= m_nRowsRead)
		{
			m_pAccessor->SetBuffer(reinterpret_cast<BYTE*>(pCurrent));
			__try
			{
				// Get the row
				hr = MoveNext();
				if (hr != S_OK)
					break;
			}
			__except(Except(GetExceptionInformation()))
			{
			}
			m_nRowsRead++;
			pCurrent++;
		}

		if(hr != S_OK)
		{
			ATLASSERT(hr != DB_S_ENDOFROWSET);	// if you're getting this assertion, then
												// most likely you are trying to access an
												// out of bounds element of CArrayRowset
												// (ex. table[100].data where table has only 
												// 50 records)
			AtlThrow(hr);
		}

		return *(m_pBase + nRow);
	}

	HRESULT Snapshot() throw()
	{
		HRESULT hr = S_FALSE;
		ATLASSUME(m_nRowsRead == 0);
		ATLASSUME(m_spRowset != NULL);
		TAccessor::DataClass* pCurrent = m_pBase;
		m_pAccessor->SetBuffer(reinterpret_cast<BYTE*>(pCurrent));
		__try
		{
			hr = MoveFirst();
		}
		__except(Except(GetExceptionInformation()))
		{
		}
		if (FAILED(hr))
			return hr;
		do
		{
			m_nRowsRead++;
			pCurrent++;
			m_pAccessor->SetBuffer(reinterpret_cast<BYTE*>(pCurrent));
			__try
			{
				hr = MoveNext();
			}
			__except(Except(GetExceptionInformation()))
			{
			}
		} while (SUCCEEDED(hr) &&  hr != DB_S_ENDOFROWSET);

		return (hr == DB_S_ENDOFROWSET) ? S_OK : hr;
	}
	ULONG   m_nRowsRead;
};

// Used when you don't need any parameters or output columns
class CNoAccessor
{
public:
	// We don't need any typedef's here as the default
	// global typedef is not to have any parameters and
	// output columns.
	HRESULT BindColumns(IUnknown*) throw() { return S_OK; }
	HRESULT BindParameters(HACCESSOR*, ICommand*, void**) throw() { return S_OK; }
	void    Close() throw() { }
	HRESULT ReleaseAccessors(IUnknown*) throw() { return S_OK; }
	void FreeRecordMemory(IRowset* /*pRowset*/) throw() { }
	void FreeRecordMemory(int /*nAccessor*/, IRowset* /*pRowset*/) throw() { }
	HRESULT GetColumnInfo(IRowset*, DBORDINAL*, DBCOLUMNINFO**) throw() { return E_FAIL; }
	ULONG GetNumAccessors() const throw() { return 0; }
	bool IsAutoAccessor(ULONG /*nAccessor*/) const throw() { return false; }
	HACCESSOR GetHAccessor(ULONG /*nAccessor*/) const throw() { return NULL; }
	BYTE* GetBuffer() const throw() { ATLASSERT(FALSE); return NULL; }
	static void Bind(DBBINDING*, DBORDINAL, DBTYPE, DBLENGTH, BYTE, BYTE, DBPARAMIO,
		DBBYTEOFFSET, DBBYTEOFFSET = NULL, DBBYTEOFFSET = NULL, DBOBJECT* = NULL) throw()
	{ ATLASSERT(FALSE); }
	bool NoBindOnNullRowset() const throw() { return false; }
};

// Used when a rowset will not be returned from the command
template <class TAccessor = CAccessorBase>
class CNoRowset
{
public:
	HRESULT             BindFinished() throw() { return S_OK; }
	void                Close() throw() { }
	static const IID&   GetIID() throw() { return IID_NULL; }
	IRowset*            GetInterface() const throw() { return NULL; }
	IRowset**           GetInterfacePtr() throw() { return NULL; }
	void                SetAccessor(void*) throw() { }
	void                SetupOptionalRowsetInterfaces() throw() { }

};

// Used with SQL Server 2000, a rowset will not be returned from the command, but instead
// we get an ISequentialStream object and use it to read the data.
template <class TAccessor = CAccessorBase>
class CStreamRowset
{
public:
	// Constructors & destructors
	CStreamRowset()
	{
		m_spStream = NULL;
	}

	~CStreamRowset()
	{
		Close();
	}

	// Methods
	void Close()
	{
		if (m_spStream != NULL)
			m_spStream.Release();
	}


	// Implementation
	static const IID& GetIID()
	{
		return IID_ISequentialStream;
	}
	ISequentialStream* GetInterface() const
	{
		return m_spStream;
	}
	ISequentialStream** GetInterfacePtr()
	{
		return &m_spStream;
	}

	HRESULT             BindFinished() throw() { return S_OK; }
	void                SetAccessor(void*) throw() { }
	void                SetupOptionalRowsetInterfaces() throw() { }

	CComPtr<ISequentialStream> m_spStream;
};


///////////////////////////////////////////////////////////////////////////
// class CAccessor

// T is the class that contains the data that will be accessed.
template <class T>
class CAccessor :
	public CAccessorBase,
	public T
{
public:
	typedef T DataClass;

// Implementation
	HRESULT ReleaseAccessors(IUnknown* pUnk) throw()
	{
		FreeRecordMemory( (IRowset*) pUnk );
		return CAccessorBase::ReleaseAccessors(pUnk);
	}

	// Free's any columns in the current record that need to be freed.
	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
	void FreeRecordMemory(int nAccessor, IRowset* /* pRowset */) throw() 
	{
		(nAccessor);
		__if_exists(_GetBindEntries)
		{
			DBORDINAL nColumns;

			// Passing in m_pBuffer tells the column entry maps to free the
			// memory for the types if appropriate
			_GetBindEntries(NULL, &nColumns, NULL, nAccessor, NULL, m_pBuffer);
		}
	}
	void FreeRecordMemory(IRowset* pRowset) throw()
	{
		for (ULONG i = 0; i < GetNumAccessors(); i++)
			FreeRecordMemory(i, pRowset);
	}

	HRESULT GetColumnInfo(IRowset*, DBORDINAL*, DBCOLUMNINFO**) throw() { return E_FAIL; }

	void ClearRecordMemory() throw()
	{
		__if_exists(_GetBindEntries)
		{
			for (ULONG i = 0; i < _OutputColumnsClass::_GetNumAccessors(); i++)
			{
				DBORDINAL nColumns;
				_GetBindEntries(NULL, &nColumns, NULL, i, NULL, m_pBuffer, true);
			}
		}
	}

	HRESULT BindColumns(IUnknown* pUnk) throw()
	{
		HRESULT hr;
		ULONG   nAccessors;
		DBLENGTH  nSize;
		nAccessors = _OutputColumnsClass::_GetNumAccessors();

		SetBuffer((BYTE*)(T*)this);
		ClearRecordMemory();

		nSize = sizeof(T);
		hr = BindAccessors(nAccessors, nSize, pUnk);
		return hr;
	}
	HRESULT BindAccessors(ULONG nAccessors, DBLENGTH nSize, IUnknown* pUnk) throw()
	{
		ATLENSURE_RETURN(pUnk != NULL);
		HRESULT hr;

		CComPtr<IAccessor> spAccessor;
		hr = pUnk->QueryInterface(&spAccessor);
		if (SUCCEEDED(hr))
		{
			// Allocate the accessor memory if we haven't done so yet
			if (m_pAccessorInfo == NULL)
			{
				hr = AllocateAccessorMemory(nAccessors);
				if (FAILED(hr))
					return hr;
			}

			for (ULONG i=0; i<nAccessors && SUCCEEDED(hr); i++)
				hr = BindAccessor(spAccessor, i, nSize);
		}

		return hr;
	}

	HRESULT BindAccessor(IAccessor* pAccessor, ULONG nAccessor, DBLENGTH nSize) throw()
	{
		CAutoVectorPtr<DBBINDING>	spBindings;
		CAutoVectorPtr<LPOLESTR>	spColumnNames;
		DBORDINAL					nColumns;
		bool						bAuto = false;
		HRESULT						hr;
		CComHeapPtr<DBCOLUMNINFO>	spColumnInfo;
		DBORDINAL					nColumnInfoCount = 0;
		CComHeapPtr<OLECHAR>		spStringsBuffer;

		// First time just get the number of entries by passing in &nColumns
		_OutputColumnsClass::_GetBindEntries(NULL, &nColumns, NULL, nAccessor, NULL);

		// Allocate the binding structures
		if( !spBindings.Allocate(nColumns) )
			return E_OUTOFMEMORY;

		for( ULONG i = 0; i < nColumns; i++ )
			spBindings[i].pObject = NULL;

		// Allocate the column names strings array
		if( !spColumnNames.Allocate(nColumns) )
			return E_OUTOFMEMORY;

		// Now get the bind entries
		hr = _OutputColumnsClass::_GetBindEntries(spColumnNames, &nColumns, spBindings, nAccessor, &bAuto);
		if (SUCCEEDED(hr))
		{
			// translate the columns names to oridinals if necessary
			for( ULONG i = 0; i < nColumns; i++ )
				if( spColumnNames[i] != NULL ) // if a column name was given, translate it to oridinal
				{
					// if necessary, get the column information
					if( spColumnInfo == NULL )
					{
						if( FAILED( GetColumnNames( pAccessor, &spColumnInfo, &spStringsBuffer, &nColumnInfoCount ) ) )
						{
							ATLASSERT( FALSE ); // unable to get columns information
							return E_FAIL;
						}
					}
					if( ! GetOridinalColumnNo(spColumnNames[i], spBindings[i].iOrdinal, spColumnInfo, nColumnInfoCount ) )
					{
						ATLASSERT(FALSE); // unable to match column name to an oridinal !!!
						return E_FAIL;
					}
				}

			m_pAccessorInfo[nAccessor].bAutoAccessor = bAuto;
			hr = BindEntries(spBindings, nColumns, &m_pAccessorInfo[nAccessor].hAccessor, nSize, pAccessor);
		}
		else
		{
			// free any DBBINDING::pObject's
			for( ULONG i = 0; i < nColumns; i++ )
				delete spBindings[i].pObject;

		}
		return hr;
	}

	HRESULT BindParameters(HACCESSOR* pHAccessor, ICommand* pCommand, void** ppParameterBuffer) throw()
	{
		HRESULT				hr = S_OK;

		// In the static accessor case, the parameter buffer will be T plus the size of CAccessorBase
		*ppParameterBuffer = static_cast<T*>(this);

		// Only bind the parameters if we haven't already done it
		if (*pHAccessor == NULL)
		{
			DBORDINAL					nColumns = 0;
			CAutoVectorPtr<DBBINDING>	spBinding;
			CAutoVectorPtr<LPOLESTR>	spColumnNames;

			CComHeapPtr<DBPARAMINFO>	spParameterInfo;
			DB_UPARAMS					nParameterInfoCount = 0;
			CComHeapPtr<OLECHAR>		spStringsBuffer;

			_ParamClass::_GetParamEntries(NULL, &nColumns, NULL);

			// Allocate the DBPARAMINFO array
			if( !spBinding.Allocate(nColumns) )
				return E_OUTOFMEMORY;

			// Allocate the column names strings array
			if( !spColumnNames.Allocate(nColumns) )
				return E_OUTOFMEMORY;

			hr = _ParamClass::_GetParamEntries(spColumnNames, &nColumns, spBinding);
			if (SUCCEEDED(hr))
			{
				for( ULONG i = 0; i < nColumns; i++ )
				{
					// For bindings in parameter accessors, consumer-owned memory must always be used.
					spBinding[i].dwMemOwner = DBMEMOWNER_CLIENTOWNED;

					// translate the columns names to oridinals if necessary
					if( spColumnNames[i] != NULL ) // if a column name was given, translate it to oridinal
					{
						// if necessary, get the column information
						if( spParameterInfo == NULL )
						{
							if( FAILED( GetParameterNames( pCommand, &spParameterInfo, &spStringsBuffer, &nParameterInfoCount ) ) )
							{
								ATLASSERT( FALSE ); // unable to get columns information
								return E_FAIL;
							}
						}
						if( ! GetOridinalParameterNo(spColumnNames[i], spBinding[i].iOrdinal, spParameterInfo, nParameterInfoCount ) )
						{
							ATLASSERT(FALSE); // unable to match parameter name to an oridinal !!!
							return E_FAIL;
						}
					}
				}

				// Get the IAccessor from the passed ICommand
				ATLENSURE_RETURN(pCommand != NULL);
				CComPtr<IAccessor> spAccessor;
				hr = pCommand->QueryInterface(&spAccessor);
				if (SUCCEEDED(hr))
				{
					hr = BindEntries(spBinding, nColumns, pHAccessor, sizeof(T), spAccessor);
				}
			}
		}
		return hr;
	}

protected:
	bool GetOridinalColumnNo(LPCOLESTR pOleColumnName, DBORDINAL& nColumn, DBCOLUMNINFO* pColumnInfo, DBORDINAL nColumns ) throw()
	{
		ATLASSERT(pOleColumnName != NULL);
		ATLASSERT(pColumnInfo != NULL);

		if( pOleColumnName == NULL || pColumnInfo == NULL )
			return false;

		// Search through the columns trying to find a match
		for (ULONG i = 0; i < nColumns; i++)
		{
			if (pColumnInfo[i].pwszName != NULL && wcscmp(pColumnInfo[i].pwszName, pOleColumnName) == 0)
			{
				nColumn = pColumnInfo[i].iOrdinal;
				return true;
			}
		}
		return false;   // Not Found
	}

	HRESULT GetColumnNames( IAccessor* pAccessor, DBCOLUMNINFO** ppColumnInfo, OLECHAR** ppStringsBuffer, DBORDINAL* pnColumns ) throw()
	{
		ATLASSERT( ppColumnInfo != NULL );
		ATLASSERT( ppStringsBuffer != NULL );
		ATLASSERT( pnColumns != NULL );
		ATLASSERT( pAccessor != NULL );

		if( ppColumnInfo == NULL || ppStringsBuffer == NULL || pnColumns == NULL || pAccessor == NULL )
			return E_FAIL;

		CComPtr<IColumnsInfo> spColumnsInfo;
		HRESULT hr = pAccessor->QueryInterface(&spColumnsInfo);
		if (FAILED(hr))
			return hr;

		hr = spColumnsInfo->GetColumnInfo(pnColumns, ppColumnInfo, ppStringsBuffer);
		if (FAILED(hr))
			return hr;

		return S_OK;
	}

	bool GetOridinalParameterNo(LPCOLESTR pOleParameterName, DB_UPARAMS& nParameter, DBPARAMINFO* pParameterInfo, DB_UPARAMS nParameters ) throw()
	{
		ATLASSERT(pOleParameterName != NULL);
		ATLASSERT(pParameterInfo != NULL);

		if( pOleParameterName == NULL || pParameterInfo == NULL )
			return false;

		// Search through the columns trying to find a match
		for (ULONG i = 0; i < nParameters; i++)
		{
			if (pParameterInfo[i].pwszName != NULL && wcscmp(pParameterInfo[i].pwszName, pOleParameterName) == 0)
			{
				nParameter = pParameterInfo[i].iOrdinal;
				return true;
			}
		}
		return false;   // Not Found
	}

	HRESULT GetParameterNames( ICommand* pCmd, DBPARAMINFO** ppParameterInfo, OLECHAR** ppStringsBuffer, DB_UPARAMS* pnParameters ) throw()
	{
		ATLASSERT( ppParameterInfo != NULL );
		ATLASSERT( ppStringsBuffer != NULL );
		ATLASSERT( pnParameters != NULL );
		ATLASSERT( pCmd != NULL );

		if( ppParameterInfo == NULL || ppStringsBuffer == NULL || pnParameters == NULL || pCmd == NULL )
			return E_FAIL;

		CComPtr<ICommandWithParameters> spCommandWithParameters;
		HRESULT hr = pCmd->QueryInterface(&spCommandWithParameters);
		if (FAILED(hr))
			return hr;

		hr = spCommandWithParameters->GetParameterInfo(pnParameters, ppParameterInfo, ppStringsBuffer);
		if (FAILED(hr))
			return hr;

		return S_OK;
	}

};


enum DBBLOBHANDLINGENUM
{
	DBBLOBHANDLING_DEFAULT,
	DBBLOBHANDLING_NOSTREAMS,
	DBBLOBHANDLING_SKIP
};

///////////////////////////////////////////////////////////////////////////
// CDynamicAccessor

class CDynamicAccessor :
	public CAccessorBase
{
public:
	CDynamicAccessor( DBBLOBHANDLINGENUM eBlobHandling = DBBLOBHANDLING_DEFAULT, DBLENGTH nBlobSize = 8000 )
	{
		ATLASSERT( eBlobHandling == DBBLOBHANDLING_DEFAULT || 
				   eBlobHandling == DBBLOBHANDLING_NOSTREAMS || 
				   eBlobHandling == DBBLOBHANDLING_SKIP );

		m_nColumns        = 0;
		m_pColumnInfo     = NULL;
		m_pStringsBuffer  = NULL;
		m_eBlobHandling   = eBlobHandling;
		m_nBlobSize       = nBlobSize;
		m_pfClientOwnedMemRef = NULL;
	};

	~CDynamicAccessor()
	{
		Close();
	}

	HRESULT ReleaseAccessors(IUnknown* pUnk) throw()
	{
		FreeRecordMemory( (IRowset*) pUnk );
		return CAccessorBase::ReleaseAccessors(pUnk);
	}

	bool SetBlobHandling( DBBLOBHANDLINGENUM eBlobHandling )
	{
		switch( eBlobHandling )
		{
		case DBBLOBHANDLING_DEFAULT:
		case DBBLOBHANDLING_NOSTREAMS:
		case DBBLOBHANDLING_SKIP:
			m_eBlobHandling = eBlobHandling;
			return true;
		default:
			ATLASSERT( FALSE ); // invalid blob handling mode!!!
			return false;
		}
	}

	const DBBLOBHANDLINGENUM GetBlobHandling() const
	{
		return m_eBlobHandling;
	}

	void SetBlobSizeLimit( DBLENGTH nBlobSize )
	{
		m_nBlobSize = nBlobSize;
	}

	const DBLENGTH GetBlobSizeLimit() const
	{
		return m_nBlobSize;
	}

//	void FreeRecordMemory(int , IRowset* ) throw() {}

	void Close() throw()
	{
		CoTaskMemFree(m_pColumnInfo);
		m_pColumnInfo = NULL;

		// Free the memory for the string buffer returned by IColumnsInfo::GetColumnInfo,
		// if necessary
		CoTaskMemFree(m_pStringsBuffer);
		m_pStringsBuffer = NULL;

		delete [] m_pBuffer;
		m_pBuffer = NULL;

		delete [] m_pfClientOwnedMemRef;
		m_pfClientOwnedMemRef = NULL;

		m_nColumns = 0;

		CAccessorBase::Close();
	}

	bool GetColumnType(DBORDINAL nColumn, DBTYPE* pType) const throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			*pType = m_pColumnInfo[nColumn].wType;
			return true;
		}
		else
			return false;
	}

	bool GetColumnFlags(DBORDINAL nColumn, DBCOLUMNFLAGS* pFlags) const throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			*pFlags = m_pColumnInfo[nColumn].dwFlags;
			return true;
		}
		else
			return false;
	}
	bool GetOrdinal(const CHAR* pColumnName, DBORDINAL* pOrdinal) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			*pOrdinal = m_pColumnInfo[nColumn].iOrdinal;
			return true;
		}
		else
			return false;
	}
	bool GetOrdinal(const WCHAR* pColumnName, DBORDINAL* pOrdinal) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			*pOrdinal = m_pColumnInfo[nColumn].iOrdinal;
			return true;
		}
		else
			return false;
	}

	void* GetValue(DBORDINAL nColumn) const throw()
	{
		if (TranslateColumnNo(nColumn))
			return _GetDataPtr(nColumn);
		else
			return NULL;
	}

	void* GetValue(const CHAR* pColumnName) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
			return _GetDataPtr(nColumn);
		else
			return NULL;    // Not Found
	}

	void* GetValue(const WCHAR* pColumnName) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
			return _GetDataPtr(nColumn);
		else
			return NULL;    // Not Found
	}

	template <class ctype>
	void _GetValue(DBORDINAL nColumn, ctype* pData) const throw()
	{
		ATLASSERT(pData != NULL);
		ATLASSUME(m_pColumnInfo[nColumn].ulColumnSize == sizeof(ctype));
		ctype* pBuffer = (ctype*)_GetDataPtr(nColumn);
		*pData = *pBuffer;
	}
	template <class ctype>
	void _SetValue(DBORDINAL nColumn, const ctype& data) throw()
	{
		ATLASSUME(m_pColumnInfo[nColumn].ulColumnSize == sizeof(ctype));
		ctype* pBuffer = (ctype*)_GetDataPtr(nColumn);
		*pBuffer = (ctype)data;
	}
	template <class ctype>
	bool GetValue(DBORDINAL nColumn, ctype* pData) const throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			_GetValue(nColumn, pData);
			return true;
		}
		return false;
	}
	template <class ctype>
	bool SetValue(DBORDINAL nColumn, const ctype& data) throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			_SetValue(nColumn, data);
			return true;
		}
		return false;
	}
	template <class ctype>
	bool GetValue(const CHAR *pColumnName, ctype* pData) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			_GetValue(nColumn, pData);
			return true;
		}
		return false;
	}
	template <class ctype>
	bool GetValue(const WCHAR *pColumnName, ctype* pData) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			_GetValue(nColumn, pData);
			return true;
		}
		return false;
	}
	template <class ctype>
	bool SetValue(const CHAR *pColumnName, const ctype& data) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			_SetValue(nColumn, data);
			return true;
		}
		return false;
	}
	template <class ctype>
	bool SetValue(const WCHAR *pColumnName, const ctype& data) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			_SetValue(nColumn, data);
			return true;
		}
		return false;
	}
	bool GetLength(DBORDINAL nColumn, DBLENGTH* pLength) const
	{
		ATLENSURE(pLength != NULL);
		if (TranslateColumnNo(nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*pLength = *(DBLENGTH*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool SetLength(DBORDINAL nColumn, DBLENGTH nLength) throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
			return true;
		}
		else
			return false;
	}
	bool GetLength(const CHAR* pColumnName, DBLENGTH* pLength) const 
	{
		ATLASSERT(pColumnName != NULL);
		ATLENSURE(pLength != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*pLength = *(DBLENGTH*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool GetLength(const WCHAR* pColumnName, DBLENGTH* pLength) const 
	{
		ATLASSERT(pColumnName != NULL);
		ATLENSURE(pLength != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*pLength = *(DBLENGTH*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool SetLength(const CHAR* pColumnName, DBLENGTH nLength) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
			return true;
		}
		else
			return false;
	}
	bool SetLength(const WCHAR* pColumnName, DBLENGTH nLength) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
			return true;
		}
		else
			return false;
	}
	bool GetStatus(DBORDINAL nColumn, DBSTATUS* pStatus) const 
	{
		ATLENSURE(pStatus != NULL);
		if (TranslateColumnNo(nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*pStatus = *(DBSTATUS*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool SetStatus(DBORDINAL nColumn, DBSTATUS status) throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*(DBSTATUS*)( m_pBuffer + nOffset ) = status;
			return true;
		}
		else
			return false;
	}
	bool GetStatus(const CHAR* pColumnName, DBSTATUS* pStatus) const
	{
		ATLASSERT(pColumnName != NULL);
		ATLENSURE(pStatus != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*pStatus = *(DBSTATUS*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool GetStatus(const WCHAR* pColumnName, DBSTATUS* pStatus) const
	{
		ATLASSERT(pColumnName != NULL);
		ATLENSURE(pStatus != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*pStatus = *(DBSTATUS*)( m_pBuffer + nOffset );
			return true;
		}
		else
			return false;
	}
	bool SetStatus(const CHAR* pColumnName, DBSTATUS status) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*(DBSTATUS*)( m_pBuffer + nOffset ) = status;
			return true;
		}
		else
			return false;
	}
	bool SetStatus(const WCHAR* pColumnName, DBSTATUS status) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
			IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
			IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
			*(DBSTATUS*)( m_pBuffer + nOffset ) = status;
			return true;
		}
		else
			return false;
	}

	// Returns true if a bookmark is available
	HRESULT GetBookmark(CBookmark<>* pBookmark) const throw()
	{
		HRESULT hr;
		if (m_pColumnInfo->iOrdinal == 0)
			hr = pBookmark->SetBookmark(m_pColumnInfo->ulColumnSize, (BYTE*)_GetDataPtr(0));
		else
			hr = E_FAIL;
		return hr;
	}

	DBORDINAL GetColumnCount() const throw()
	{
		return m_nColumns;
	}

	LPOLESTR GetColumnName(DBORDINAL nColumn) const throw()
	{
		if (TranslateColumnNo(nColumn))
			return m_pColumnInfo[nColumn].pwszName;
		else
			return NULL;
	}

	ATL_DEPRECATED("CDynamicAccessor::GetColumnInfo must be passed an array of string buffers too.")
	HRESULT GetColumnInfo(IRowset* pRowset, DBORDINAL* pColumns, DBCOLUMNINFO** ppColumnInfo);

	HRESULT GetColumnInfo(IRowset* pRowset, DBORDINAL* pColumns, DBCOLUMNINFO** ppColumnInfo, OLECHAR** ppStringsBuffer) throw()
	{
		CComPtr<IColumnsInfo> spColumnsInfo;
		HRESULT hr = pRowset->QueryInterface(&spColumnsInfo);
		if (SUCCEEDED(hr))
			hr = spColumnsInfo->GetColumnInfo(pColumns, ppColumnInfo, ppStringsBuffer);

		return hr;
	}

	HRESULT AddBindEntry(const DBCOLUMNINFO& info) throw()
	{
		if ((m_nColumns + 1 < m_nColumns))
		{
			return E_OUTOFMEMORY;
		}
		DBCOLUMNINFO* pTempInfo = (DBCOLUMNINFO*)::ATL::AtlCoTaskMemRecalloc(m_pColumnInfo, (m_nColumns + 1), sizeof(DBCOLUMNINFO));
		if (pTempInfo == NULL)
			return E_OUTOFMEMORY;
		m_pColumnInfo = pTempInfo;
		m_pColumnInfo[m_nColumns] = info;
		m_nColumns++;

		return S_OK;
	}

	bool NoBindOnNullRowset() const throw()
	{
		return true;
	}

// Implementation
	// Free's any columns in the current record that need to be freed.
	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
	void FreeRecordMemory(IRowset* pRowset) throw()
	{
		ULONG i;

		for (i = 0; i < m_nColumns; i++)
		{
			if( m_pfClientOwnedMemRef != NULL && m_pfClientOwnedMemRef[i] == true )
			{
				DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[i].pTypeInfo;
				IncrementAndAlignOffset( nOffset, m_pColumnInfo[i].ulColumnSize, __alignof(DBLENGTH) );
				IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
				if( *(DBSTATUS*)( m_pBuffer + nOffset ) != DBSTATUS_S_ISNULL )
				{
					void* pRef = _GetDataPtr(i);

					if( pRef != NULL && *(void**)pRef != NULL )
					{
						CoTaskMemFree( *(void**)_GetDataPtr(i) );
						*(void**)pRef = NULL;
					}
				}
			}
			else if( m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN || m_pColumnInfo[i].wType == DBTYPE_IDISPATCH )
			{
				DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[i].pTypeInfo;
				IncrementAndAlignOffset( nOffset, m_pColumnInfo[i].ulColumnSize, __alignof(DBLENGTH) );
				IncrementAndAlignOffset( nOffset, sizeof(DBLENGTH), __alignof(DBSTATUS) );
				if( *(DBSTATUS*)( m_pBuffer + nOffset ) == DBSTATUS_S_OK )
					CAccessorBase::FreeType(m_pColumnInfo[i].wType, (BYTE*)_GetDataPtr(i), pRowset);
			}
			else
			{
				CAccessorBase::FreeType(m_pColumnInfo[i].wType, (BYTE*)_GetDataPtr(i), pRowset);
			}
		}
	}
	void ClearRecordMemory() throw()
	{
		for (ULONG i = 0; i < m_nColumns; i++)
		{
			DBLENGTH uLength = m_pColumnInfo[i].ulColumnSize;
			switch (m_pColumnInfo[i].wType)
			{
			case DBTYPE_STR :
				uLength += 1;
				break;
			case DBTYPE_WSTR :
				uLength = (uLength + 1) * 2;
				break;
			}
			memset((BYTE*)_GetDataPtr(i), 0, uLength);
		}
	}

	void* _GetDataPtr(DBORDINAL nColumn) const throw()
	{
		return m_pBuffer + (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
	}
	bool GetInternalColumnNo(const CHAR* pColumnName, DBORDINAL* pColumn) const
	{
		ATLENSURE(pColumnName != NULL);
		ATLENSURE(pColumn != NULL);
		ULONG       i;
		size_t      nSize = (lstrlenA(pColumnName) + 1) * sizeof(OLECHAR);
		CComBSTR	bstrColumnName(pColumnName);

		// Search through the columns trying to find a match
		for (i = 0; i < m_nColumns; i++)
		{
			ATLASSUME(m_pColumnInfo != NULL);
			if (m_pColumnInfo[i].pwszName != NULL &&
				memcmp(m_pColumnInfo[i].pwszName, bstrColumnName.m_str, nSize) == 0)
			{
				break;
			}
		}
		if (i < m_nColumns && pColumn)
		{
			*pColumn = i;
			return true;
		}
		else
		{
			return false;   // Not Found
		}
	}
	bool GetInternalColumnNo(const WCHAR* pColumnName, DBORDINAL* pColumn) const
	{
		ATLENSURE(pColumnName != NULL);
		ATLASSERT(pColumn != NULL);
		ULONG       i;
		size_t      nSize = (wcslen(pColumnName) + 1) * sizeof(OLECHAR);
		LPCOLESTR	pOleColumnName = CComBSTR(pColumnName);

		// Search through the columns trying to find a match
		for (i = 0; i < m_nColumns; i++)
		{
			ATLASSUME(m_pColumnInfo != NULL);
			if (m_pColumnInfo[i].pwszName != NULL &&
				memcmp(m_pColumnInfo[i].pwszName, pOleColumnName, nSize) == 0)
				break;
		}
		
		if (i < m_nColumns && pColumn)
		{
			*pColumn = i;
			return true;
		}

		return false;   // Not Found
	}

	// Set up the binding structure pointed to by pBindings based upon
	// the other passed parameters.
	static void BindEx(DBBINDING* pBinding, DBORDINAL nOrdinal, DBTYPE wType,
		DBLENGTH nLength, BYTE nPrecision, BYTE nScale, DBPARAMIO eParamIO,
		DBBYTEOFFSET nDataOffset, DBBYTEOFFSET nLengthOffset, DBBYTEOFFSET nStatusOffset,
		DBOBJECT* pdbobject, DBMEMOWNER dwMemOwner, bool fSkipData = false )
	{
		ATLENSURE(pBinding != NULL);

		pBinding->dwMemOwner    = dwMemOwner;

		pBinding->pObject       = pdbobject;

		pBinding->eParamIO      = eParamIO;
		pBinding->iOrdinal      = nOrdinal;
		pBinding->wType         = wType;
		pBinding->bPrecision    = nPrecision;
		pBinding->bScale        = nScale;
		pBinding->dwFlags       = 0;

		pBinding->obValue       = 0;
		pBinding->obLength      = 0;
		pBinding->obStatus      = 0;
		pBinding->pTypeInfo     = NULL;
		pBinding->pBindExt      = NULL;
		pBinding->cbMaxLen      = nLength;

		pBinding->dwPart = 0;

		if ( ! fSkipData ) // skip column data
		{
			pBinding->dwPart |= DBPART_VALUE;
			pBinding->obValue = nDataOffset;
		}
		if (nLengthOffset != NULL) // skip length
		{
			pBinding->dwPart |= DBPART_LENGTH;
			pBinding->obLength = nLengthOffset;
		}
		if (nStatusOffset != NULL) // skip status
		{
			pBinding->dwPart |= DBPART_STATUS;
			pBinding->obStatus = nStatusOffset;
		}
	}


	HRESULT GetRowsetProperties( IUnknown* pUnk, DBPROPID* prgPropertyIDs, BOOL* pbValues, ULONG nPropCount ) throw()
	{
		ULONG t;

		ATLENSURE_RETURN(pUnk != NULL);
		ATLENSURE_RETURN(pbValues != NULL);
		ATLASSERT(prgPropertyIDs != NULL);
		ATLASSERT(nPropCount > 0);

		CComPtr<IRowsetInfo> spRowsetInfo;
		HRESULT hr = pUnk->QueryInterface(&spRowsetInfo);

		for( t = 0; t < nPropCount; t++ )
			pbValues[t] = FALSE;

		if (FAILED(hr))
			ATLASSERT(0); // unable to retrieve IRowsetInfo interface
		else
		{
			DBPROPIDSET            rgPropertyIDSets[1];
			ULONG                  cPropSets        = 0;
			CComHeapPtr<DBPROPSET> rgPropSets;

			// Set up the Property ID Set.
			rgPropertyIDSets[0].rgPropertyIDs       = prgPropertyIDs;
			rgPropertyIDSets[0].cPropertyIDs        = nPropCount;
			rgPropertyIDSets[0].guidPropertySet     = DBPROPSET_ROWSET;

			hr = spRowsetInfo->GetProperties(	1,					// cPropertyIDSets
												rgPropertyIDSets,	// rgPropertyIDSets
												&cPropSets,         // pcPropSets
												&rgPropSets );      // prgPropSets

			if( SUCCEEDED(hr) )
			{
				for( t = 0; t < __min(rgPropSets[0].cProperties, nPropCount); t++ )
					pbValues[t] = V_BOOL(&rgPropSets[0].rgProperties[t].vValue);

				if( rgPropSets[0].rgProperties )
					CoTaskMemFree(rgPropSets[0].rgProperties);
			}
		}

		return hr;
	}

	HRESULT BindColumns(IUnknown* pUnk) throw()
	{
		IID iidStreamToUse = __uuidof(ISequentialStream);
		bool fIStreamSupportTested = false;

		ATLENSURE_RETURN(pUnk != NULL);
		CComPtr<IAccessor> spAccessor;
		HRESULT hr = pUnk->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		ULONG   i;
		DBBYTEOFFSET   nOffset = 0, nDataOffset, nLengthOffset, nStatusOffset;

		// If the user hasn't specifed the column information to bind by calling AddBindEntry then
		// we get it ourselves
		if (m_pColumnInfo == NULL)
		{
			CComPtr<IColumnsInfo> spColumnsInfo;
			hr = pUnk->QueryInterface(&spColumnsInfo);
			if (FAILED(hr))
				return hr;

			hr = spColumnsInfo->GetColumnInfo(&m_nColumns, &m_pColumnInfo, &m_pStringsBuffer);
			if (FAILED(hr))
				return hr;

			m_bOverride = false;
		}
		else
			m_bOverride = true;

		DBBINDING* pBinding = NULL;
		ATLTRY( pBinding = new DBBINDING[m_nColumns] );
		if( pBinding == NULL )
			return E_OUTOFMEMORY;

		CAutoVectorPtr<DBBINDING> spBinding(pBinding);

		ATLASSUME(m_pfClientOwnedMemRef == NULL);
		ATLTRY(m_pfClientOwnedMemRef = new bool[m_nColumns]);
		if( m_pfClientOwnedMemRef == NULL )
		{
			return E_OUTOFMEMORY;
		}

#ifdef _DEBUG
		ATLTRACE( "CDynamicAccessor::BindColumns\n" );
		ATLTRACE( "Number of columns: %d\n", m_nColumns );
		ATLTRACE( "Blob Handling Mode: " );
		switch( m_eBlobHandling )
		{
		case DBBLOBHANDLING_DEFAULT:
			ATLTRACE( "DBBLOBHANDLING_DEFAULT\n" );
			break;
		case DBBLOBHANDLING_NOSTREAMS:
			ATLTRACE( "DBBLOBHANDLING_NOSTREAMS\n" );
			break;
		case DBBLOBHANDLING_SKIP:
			ATLTRACE( "DBBLOBHANDLING_SKIP\n" );
			break;
		default:
			ATLTRACE( "IVALID HANDLING MODE!!!\n" );
		}
#endif
		DBBINDING* pCurrent = pBinding;
		DBOBJECT*  pObject;
		for (i = 0; i < m_nColumns; i++)
		{
			// If it's a BLOB or the column size is large enough for us to treat it as
			// a BLOB then we also need to set up the DBOBJECT structure.
			m_pfClientOwnedMemRef[i] = false;
			if (m_pColumnInfo[i].ulColumnSize > m_nBlobSize && m_pColumnInfo[i].wType != DBTYPE_IUNKNOWN )
			{
				if( m_eBlobHandling == DBBLOBHANDLING_SKIP )
				{
					// Calculate the column data offset
					nDataOffset = 0;
					// Calculate the column length offset
					nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
					// Calculate the column status offset
					nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
					//If ulColumnSize is not zeroed, GetLength and GetStatus will not access the correct offset in buffer.
					//As they add ulColumnSize to skip the data.
					m_pColumnInfo[i].ulColumnSize = 0;
					ATLTRACE( "%d. Column ordinal %d: Binding length and status ONLY\n", i, m_pColumnInfo[i].iOrdinal );

					BindEx(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
						m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
						DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, NULL, DBMEMOWNER_CLIENTOWNED, true );
					pCurrent++;
				}
				else if( m_eBlobHandling == DBBLOBHANDLING_NOSTREAMS )
				{
					// get the value by reference
					m_pColumnInfo[i].wType |= DBTYPE_BYREF;
					m_pColumnInfo[i].ulColumnSize   = sizeof(WCHAR*);
					m_pfClientOwnedMemRef[i] = true;

					// Calculate the column data offset
					nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );
					// Calculate the column length offset
					nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
					// Calculate the column status offset
					nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

					ATLTRACE( "%d. Column ordinal %d: Binding by reference in provider allocated, consumer owned memory\n", i, m_pColumnInfo[i].iOrdinal );

					BindEx(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
						m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
						DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, NULL, DBMEMOWNER_CLIENTOWNED);
					pCurrent++;

				}
				else // if( m_eBlobHandling == DBBLOBHANDLING_DEFAULT )
				{
					// we will try to bind blobs as streams
					// if we have not tested if the rowset supports streams, do it now
					if( ! fIStreamSupportTested )
					{
						ATLTRACE( "Testing streams support... " );

						DBPROPID rgPropertyIDs[2] = { DBPROP_ISequentialStream, DBPROP_IStream };
						BOOL     rgStreamsSupported[2] = {FALSE, FALSE};

						// check if the rowset supports IStream* interfaces
						hr = GetRowsetProperties( pUnk, rgPropertyIDs, rgStreamsSupported, 2 );
						ATLASSERT( SUCCEEDED( hr ) );

						if( rgStreamsSupported[0] )
						{
							iidStreamToUse = __uuidof(ISequentialStream);

							ATLTRACE( "ISequentialStream is supported\n" );
						}
						else if( rgStreamsSupported[1] )
						{
							iidStreamToUse = __uuidof(IStream);

							ATLTRACE( "IStream is supported\n" );
						}
						else
						{

							ATLTRACE( "neither ISequentialStream nor IStream are supported!\n" );

							ATLASSERT(FALSE); // the stream interfaces are not supported!!!
						}

						fIStreamSupportTested = true;
					}

					pObject = NULL;
					ATLTRY(pObject = new DBOBJECT);
					if (pObject == NULL)
					{
						for( ULONG t = 0; t < i; t++ )
							delete pBinding[t].pObject;

						delete [] m_pfClientOwnedMemRef;
						m_pfClientOwnedMemRef = NULL;

						return E_OUTOFMEMORY;
					}
					pObject->dwFlags = STGM_READ;
					pObject->iid     = iidStreamToUse;
					m_pColumnInfo[i].wType      = DBTYPE_IUNKNOWN;
					m_pColumnInfo[i].ulColumnSize   = sizeof(IUnknown*);

					// Calculate the column data offset
					nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );
					// Calculate the column length offset
					nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
					// Calculate the column status offset
					nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

#ifdef _DEBUG
					if( iidStreamToUse == __uuidof(ISequentialStream) )
						ATLTRACE( "%d. Column ordinal %d: Binding as an ISequentialStream object\n", i, m_pColumnInfo[i].iOrdinal );
					else
						ATLTRACE( "%d. Column ordinal %d: Binding as an IStream object\n", i, m_pColumnInfo[i].iOrdinal );
#endif
					Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
						m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
						DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
					pCurrent++;

				}
			}
			// else if it's a COM object
			else if( m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN)
			{
				pObject = NULL;
				ATLTRY(pObject = new DBOBJECT);
				if (pObject == NULL)
				{
					for( ULONG t = 0; t < i; t++ )
						delete pBinding[t].pObject;

					delete [] m_pfClientOwnedMemRef;
					m_pfClientOwnedMemRef = NULL;

					return E_OUTOFMEMORY;
				}
				pObject->dwFlags = STGM_READ;
				pObject->iid     = __uuidof(IUnknown); // iidPersistToUse;
				m_pColumnInfo[i].wType      = DBTYPE_IUNKNOWN;
				m_pColumnInfo[i].ulColumnSize   = sizeof(IUnknown*);

				// Calculate the column data offset
				nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );

				// Calculate the column length offset
				nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );

				// Calculate the column status offset
				nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

				ATLTRACE( "%d. Column ordinal %d: Binding a COM object\n", i, m_pColumnInfo[i].iOrdinal );

				Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
					m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
					DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
				pCurrent++;

			}
			// else if it's not a BLOB or COM object
			else
			{
				pObject = NULL;

				// Calculate the size needed if it's a string
				// including the NULL terminator.
				if (m_pColumnInfo[i].wType == DBTYPE_STR)
					m_pColumnInfo[i].ulColumnSize += 1;

				if (m_pColumnInfo[i].wType == DBTYPE_WSTR)
					m_pColumnInfo[i].ulColumnSize = m_pColumnInfo[i].ulColumnSize*2 + 2;

				// Calculate the column data offset
				nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( m_pColumnInfo[i].wType ) );

				// Calculate the column length offset
				nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );

				// Calculate the column status offset
				nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

				ATLTRACE( "%d. Column ordinal %d: Binding as native data type\n", i, m_pColumnInfo[i].iOrdinal );

				Bind(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
					m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
					DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
				pCurrent++;
			}

			// Note that, as we're not using this for anything else, we're using the
			// pTypeInfo element to store the offset to our data.
			m_pColumnInfo[i].pTypeInfo = (ITypeInfo*)(ULONG_PTR)nDataOffset;
		}
		// Allocate the accessor memory if we haven't done so yet
		if (m_pAccessorInfo == NULL)
		{
			hr = AllocateAccessorMemory(1); // We only have one accessor
			if (FAILED(hr))
			{
				for( ULONG t = 0; t < m_nColumns; t++ )
					delete pBinding[t].pObject;

				delete [] m_pfClientOwnedMemRef;
				m_pfClientOwnedMemRef = NULL;

				return hr;
			}
			m_pAccessorInfo->bAutoAccessor = true;
		}

		// Allocate enough memory for the data buffer and tell the rowset
		// Note that the rowset will free the memory in its destructor.
		m_pBuffer = NULL;
		ATLTRY(m_pBuffer = new BYTE[nOffset]);
		if (m_pBuffer == NULL)
		{
			for( ULONG t = 0; t < m_nColumns; t++ )
				delete pBinding[t].pObject;

			delete [] m_pfClientOwnedMemRef;
			m_pfClientOwnedMemRef = NULL;

			return E_OUTOFMEMORY;
		}
		memset(m_pBuffer, 0, nOffset);
		hr = BindEntries(pBinding, m_nColumns, &m_pAccessorInfo->hAccessor,
				nOffset, spAccessor);

		if( FAILED(hr))
		{
			delete [] m_pfClientOwnedMemRef;
			m_pfClientOwnedMemRef = NULL;
		}

		return hr;
	}

	// Translate the column number to the index into the column info array
	bool TranslateColumnNo(DBORDINAL& nColumn) const throw()
	{
		ATLASSUME(m_pColumnInfo != NULL);
		// If the user has overriden the binding then we need to search
		// through the column info for the ordinal number
		if (m_bOverride)
		{
			for (ULONG i = 0; i < m_nColumns; i++)
			{
				if (m_pColumnInfo[i].iOrdinal == nColumn)
				{
					nColumn = i;
					return true;
				}
			}
			return false;
		}
		else
		{
			// Note that m_pColumnInfo->iOrdinal will be zero if have bound
			// a bookmark as the first entry, otherwise it will be 1.
			// If the column is out of range then return false
			if (nColumn > (m_nColumns - 1 + m_pColumnInfo->iOrdinal))
				return false;

			// otherwise translate the column to an index into our internal
			// binding entries array
			nColumn -= m_pColumnInfo->iOrdinal;
			return true;
		}
	}

	static size_t GetAlignment(DBTYPE bType) throw()
	{
		if( bType & DBTYPE_BYREF )
			return __alignof(void*);

		if( bType & DBTYPE_ARRAY )
			return __alignof(SAFEARRAY*);

		if( bType & DBTYPE_VECTOR )
			return __alignof(DBVECTOR);

		switch( bType )
		{
		case DBTYPE_I2:
			return __alignof(signed short);
			break;

		case DBTYPE_I4:
			return __alignof(signed int);
			break;

		case DBTYPE_R4:
			return __alignof(float);
			break;

		case DBTYPE_R8:
			return __alignof(double);
			break;

		case DBTYPE_CY:
			return __alignof(__int64);
			break;

		case DBTYPE_DATE:
			return __alignof(DATE);
			break;

		case DBTYPE_BSTR:
			return __alignof(BSTR*);
			break;

		case DBTYPE_IDISPATCH:
			return __alignof(IDispatch*);
			break;

		case DBTYPE_ERROR:
			return __alignof(SCODE);
			break;

		case DBTYPE_BOOL:
			return __alignof(VARIANT_BOOL);
			break;

		case DBTYPE_VARIANT:
			return __alignof(VARIANT);
			break;

		case DBTYPE_IUNKNOWN:
			return __alignof(IUnknown*);
			break;

		case DBTYPE_DECIMAL:
			return __alignof(DECIMAL);
			break;

		case DBTYPE_UI1:
			return __alignof(unsigned char);
			break;

		case DBTYPE_I1:
			return __alignof(signed char);
			break;

		case DBTYPE_UI2:
			return __alignof(unsigned short);
			break;

		case DBTYPE_UI4:
			return __alignof(unsigned int);
			break;

		case DBTYPE_I8:
			return __alignof(signed char);
			break;

		case DBTYPE_UI8:
			return __alignof(unsigned char);
			break;

		case DBTYPE_GUID:
			return __alignof(GUID);
			break;

		case DBTYPE_BYTES:
			return __alignof(BYTE);
			break;

		case DBTYPE_STR:
			return __alignof(char);
			break;

		case DBTYPE_WSTR:
			return __alignof(short);
			break;

		case DBTYPE_NUMERIC:
			return __alignof(DB_NUMERIC);
			break;

		case DBTYPE_DBDATE:
			return __alignof(DBDATE);
			break;

		case DBTYPE_DBTIME:
			return __alignof(DBTIME);
			break;

		case DBTYPE_DBTIMESTAMP:
			return __alignof(DBTIMESTAMP);
			break;

		default:
			return __alignof(__int64);
		}
	}

	inline static DBBYTEOFFSET AlignAndIncrementOffset( DBBYTEOFFSET& nOffset, DBLENGTH nSize, size_t nAlign ) throw()
	{
		DBBYTEOFFSET nResult;

		nOffset = AtlAlignUp( nOffset, (ULONG)nAlign );
		nResult = nOffset;
		nOffset += nSize;

		return nResult;
	}

	inline static void IncrementAndAlignOffset( DBBYTEOFFSET& nOffset, DBLENGTH nSize, size_t nAlign ) throw()
	{
		nOffset += nSize;
		nOffset = AtlAlignUp( nOffset, (ULONG)nAlign );
	}

	typedef CDynamicAccessor _OutputColumnsClass;
	static bool HasOutputColumns() throw() { return true; }

	DBORDINAL           m_nColumns;
	bool*				m_pfClientOwnedMemRef;
	DBCOLUMNINFO*       m_pColumnInfo;
	OLECHAR*            m_pStringsBuffer;
	bool                m_bOverride;

	protected:
	DBBLOBHANDLINGENUM  m_eBlobHandling;
	DBLENGTH            m_nBlobSize;
};

#if _SECURE_ATL

template< typename BaseType > 
inline void strcpyT( BaseType *strDest, size_t maxCount, const BaseType *strSource)
{
	return NULL;
}

#else

template< typename BaseType > 
inline BaseType* strcpyT( BaseType *strDest, const BaseType *strSource )
{
	return NULL;
}

template< typename BaseType > 
inline BaseType* strncpyT( BaseType *strDest, const BaseType *strSource, size_t count )
{
	return NULL;
}

#endif

template< typename BaseType > 
inline size_t strlenT( const BaseType *string )
{
	return NULL;
}

#if _SECURE_ATL

template<> 
inline void strcpyT<CHAR>( __out_ecount_z(maxCount) CHAR *strDest, __in size_t maxCount, __in const CHAR *strSource)
{
	Checked::strcpy_s( strDest, maxCount, strSource);
}

#else

template<> 
inline CHAR* strcpyT<CHAR>( __out_z CHAR *strDest, __in_z const CHAR *strSource )
{
	return strcpy( strDest, strSource );
}

template<> 
inline CHAR* strncpyT<CHAR>( __out_ecount(count) CHAR *strDest, __in const CHAR *strSource, __in size_t count )
{
	return strncpy( strDest, strSource, count );
}

#endif

template<> 
inline size_t strlenT<CHAR>( __in_z const CHAR *string )
{
	return strlen( string );
}

#if _SECURE_ATL

template<> 
inline void strcpyT<WCHAR>( __out_ecount_z(maxCount) WCHAR *strDest, __in size_t maxCount, __in const WCHAR *strSource)
{
	Checked::wcscpy_s( strDest, maxCount, strSource);
}

#else

template<> 
inline WCHAR* strcpyT<WCHAR>( __out_z WCHAR *strDest, __in_z const WCHAR *strSource )
{
	return wcscpy( strDest, strSource );
}

template<> 
inline WCHAR* strncpyT<WCHAR>( __out_ecount(count) WCHAR *strDest, __in const WCHAR *strSource, __in size_t count )
{
	return wcsncpy( strDest, strSource, count );
}

#endif

template<> 
inline size_t strlenT<WCHAR>( __in_z const WCHAR *string )
{
	return wcslen( string );
}

template< typename BaseType, DBTYPEENUM OleDbType >
class CDynamicStringAccessorT : public CDynamicAccessor
{
public:
	explicit CDynamicStringAccessorT(DBLENGTH nBlobSize = 8000)
		: CDynamicAccessor( DBBLOBHANDLING_DEFAULT, nBlobSize )
	{
	}

	HRESULT BindColumns(IUnknown* pUnk) throw()
	{
		ATLENSURE_RETURN(pUnk != NULL);
		CComPtr<IAccessor> spAccessor;
		HRESULT hr = pUnk->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		ULONG   i;
		DBBYTEOFFSET nOffset = 0, nDataOffset, nLengthOffset, nStatusOffset;
		DBLENGTH nLength;

		// If the user hasn't specifed the column information to bind by calling AddBindEntry then
		// we get it ourselves
		if (m_pColumnInfo == NULL)
		{
			CComPtr<IColumnsInfo> spColumnsInfo;
			hr = pUnk->QueryInterface(&spColumnsInfo);
			if (FAILED(hr))
				return hr;

			hr = spColumnsInfo->GetColumnInfo(&m_nColumns, &m_pColumnInfo, &m_pStringsBuffer);
			if (FAILED(hr))
				return hr;

			m_bOverride = false;
		}
		else
			m_bOverride = true;

		DBBINDING* pBinding = NULL;
		ATLTRY(pBinding= new DBBINDING[m_nColumns]);
		if (pBinding == NULL)
			return E_OUTOFMEMORY;

		ATLASSUME(m_pfClientOwnedMemRef == NULL);
		ATLTRY(m_pfClientOwnedMemRef = new bool[m_nColumns]);
		if( m_pfClientOwnedMemRef == NULL )
		{
			delete [] pBinding;
			pBinding = NULL;
			return E_OUTOFMEMORY;
		}

		DBBINDING* pCurrent = pBinding;

		for (i = 0; i < m_nColumns; i++)
		{
			m_pfClientOwnedMemRef[i] = false;

			// If it's a IPersist* object or the column size is large enough for us to treat it as
			// a BLOB then we will request references (in client owned memory) to a string
			if (m_pColumnInfo[i].ulColumnSize > m_nBlobSize || m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN)
			{
				m_pColumnInfo[i].wType      = OleDbType | DBTYPE_BYREF;
				m_pColumnInfo[i].ulColumnSize   = sizeof(BaseType*);
				m_pfClientOwnedMemRef[i] = true;
			}
			else // We're treating everything as a string so add 1 for the NULL byte.
			{
				switch (m_pColumnInfo[i].wType)
				{
				case DBTYPE_BOOL:
					nLength = 2;
					break;
				case DBTYPE_BYTES:
					nLength = m_pColumnInfo[i].ulColumnSize * 2;
					break;
				case DBTYPE_BSTR:
					nLength = m_pColumnInfo[i].ulColumnSize;
					break;
				case DBTYPE_STR:
					nLength = m_pColumnInfo[i].ulColumnSize;
					break;
				case DBTYPE_WSTR:
					nLength = m_pColumnInfo[i].ulColumnSize;
					break;
				case DBTYPE_I1:
					nLength = 5;
					break;
				case DBTYPE_I2:
					nLength = 7;
					break;
				case DBTYPE_I4:
					nLength = 12;
					break;
				case DBTYPE_I8:
					nLength = 22;
					break;
				case DBTYPE_UI1:
					nLength = 4;
					break;
				case DBTYPE_UI2:
					nLength = 6;
					break;
				case DBTYPE_UI4:
					nLength = 11;
					break;
				case DBTYPE_UI8:
					nLength = 21;
					break;
				case DBTYPE_R4:
					nLength = 13;
					break;
				case DBTYPE_R8:
					nLength = 23;		// maybe 9
					break;
				case DBTYPE_DECIMAL:
					nLength = 23;
					break;
				case DBTYPE_NUMERIC:
					nLength = 23;
					break;
				case DBTYPE_VARIANT:
					nLength = 20;
					break;
				case DBTYPE_IDISPATCH:
					nLength = 32;
					break;
				case DBTYPE_IUNKNOWN:
					nLength = 32;
					break;
				case DBTYPE_GUID:
					nLength = 38;
					break;
				case DBTYPE_ARRAY:
					nLength = 32;
					break;
				case DBTYPE_VECTOR:
					nLength = 32;
					break;
				case DBTYPE_DATE:
					nLength = 32;
					break;
				case DBTYPE_DBDATE:
					nLength = 32;
					break;
				case DBTYPE_DBTIME:
					nLength = 32;
					break;
				case DBTYPE_DBTIMESTAMP:
					nLength = 32;
					break;
				case DBTYPE_FILETIME:
					nLength = 32;
					break;
				case DBTYPE_PROPVARIANT:
					nLength = 32;
					break;
				case DBTYPE_VARNUMERIC:
					nLength = 32;
					break;
				case DBTYPE_CY:
					nLength = 32;
					break;
				default:
					ATLASSERT(FALSE); // unhandled column type
					nLength = 32;
				}
				m_pColumnInfo[i].ulColumnSize = (nLength + 1) * sizeof(BaseType);
				m_pColumnInfo[i].wType = OleDbType;
			}

			// Calculate the column data offset
			nDataOffset = AlignAndIncrementOffset( nOffset, m_pColumnInfo[i].ulColumnSize, GetAlignment( OleDbType ) );

			// Calculate the column length offset
			nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );

			// Calculate the column status offset
			nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );

			BindEx(pCurrent, m_pColumnInfo[i].iOrdinal, m_pColumnInfo[i].wType,
				m_pColumnInfo[i].ulColumnSize, m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
				DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, NULL, DBMEMOWNER_CLIENTOWNED);

			pCurrent++;

			// Note that, as we're not using this for anything else, we're using the
			// pTypeInfo element to store the offset to our data.
			m_pColumnInfo[i].pTypeInfo = (ITypeInfo*)(ULONG_PTR)nDataOffset;
		}

		// Allocate the accessor memory if we haven't done so yet
		if (m_pAccessorInfo == NULL)
		{
			hr = AllocateAccessorMemory(1); // We only have one accessor
			if (FAILED(hr))
			{
				delete [] pBinding;
				delete [] m_pfClientOwnedMemRef;
				m_pfClientOwnedMemRef = NULL;
				return hr;
			}
			m_pAccessorInfo->bAutoAccessor = true;
		}

		// Allocate enough memory for the data buffer and tell the rowset
		// Note that the rowset will free the memory in its destructor.
		m_pBuffer = NULL;
		ATLTRY(m_pBuffer = new BYTE[nOffset]);
		if (m_pBuffer == NULL)
		{
			delete [] pBinding;
			delete [] m_pfClientOwnedMemRef;
			m_pfClientOwnedMemRef = NULL;
			return E_OUTOFMEMORY;
		}

		memset(m_pBuffer, 0, nOffset);
		hr = BindEntries(pBinding, m_nColumns, &m_pAccessorInfo->hAccessor,
				nOffset, spAccessor);

		delete [] pBinding;

		if( FAILED(hr) )
		{
			delete [] m_pfClientOwnedMemRef;
			m_pfClientOwnedMemRef = NULL;
		}

		return hr;
	}

	BaseType* GetString(DBORDINAL nColumn) const throw()
	{
		if (TranslateColumnNo(nColumn))
		{
			if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
				return *(BaseType**)_GetDataPtr(nColumn);
			else
				return (BaseType*)_GetDataPtr(nColumn);
		}
		else
			return NULL;
	}

	BaseType* GetString(const CHAR* pColumnName) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
				return *(BaseType**)_GetDataPtr(nColumn);
			else
				return (BaseType*)_GetDataPtr(nColumn);
		}
		else
			return NULL;    // Not Found
	}

	BaseType* GetString(const WCHAR* pColumnName) const throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
		{
			if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
				return *(BaseType**)_GetDataPtr(nColumn);
			else
				return (BaseType*)_GetDataPtr(nColumn);
		}
		else
			return NULL;    // Not Found
	}

	void _SetLength(DBORDINAL nColumn, DBLENGTH nLength ) throw()
	{
		DBBYTEOFFSET nOffset = (DBBYTEOFFSET)(ULONG_PTR)m_pColumnInfo[nColumn].pTypeInfo;
		IncrementAndAlignOffset( nOffset, m_pColumnInfo[nColumn].ulColumnSize, __alignof(DBLENGTH) );
		*(DBLENGTH*)( m_pBuffer + nOffset ) = nLength;
	}

	HRESULT _SetString(DBORDINAL nColumn, BaseType* data) throw()
	{
		DBLENGTH stringLen = (DBLENGTH)strlenT<BaseType>( data );

		if( m_pColumnInfo[nColumn].wType & DBTYPE_BYREF )
		{
			BaseType** pBuffer = (BaseType**)_GetDataPtr(nColumn);

        
     
			//in case of overflow throw exception
			if (stringLen + 1>(size_t(-1)/sizeof(BaseType)))                       
			{
				return(E_FAIL);//arithmetic overflow 
			}
		
			BaseType* pNewBuffer = (BaseType*)::ATL::AtlCoTaskMemRecalloc( *pBuffer, (stringLen + 1), sizeof(BaseType));
			if( pNewBuffer == NULL )
				return E_OUTOFMEMORY;

			*pBuffer = pNewBuffer;
#if _SECURE_ATL
			strcpyT<BaseType>( pNewBuffer, stringLen+1, data);
#else
			strcpyT<BaseType>( pNewBuffer, data );
#endif
			_SetLength( nColumn, stringLen * sizeof(BaseType) );
		}
		else
		{
			BaseType* pBuffer = (BaseType*)_GetDataPtr(nColumn);
			if( stringLen >= m_pColumnInfo[nColumn].ulColumnSize )
			{
#if _SECURE_ATL
				strcpyT<BaseType>( pBuffer, m_pColumnInfo[nColumn].ulColumnSize - 1, data);
#else
				strncpyT<BaseType>( pBuffer, data, m_pColumnInfo[nColumn].ulColumnSize - 1 );
#endif
				pBuffer[m_pColumnInfo[nColumn].ulColumnSize - 1] = 0;
				_SetLength( nColumn, ( m_pColumnInfo[nColumn].ulColumnSize - 1 ) * sizeof(BaseType) );
				return DBSTATUS_S_TRUNCATED;
			}
			else
			{
#if _SECURE_ATL
				strcpyT<BaseType>( pBuffer, m_pColumnInfo[nColumn].ulColumnSize, data);
#else
				strcpyT<BaseType>( pBuffer, data );
#endif
				_SetLength( nColumn, stringLen * sizeof(BaseType) );
			}
		}
		return S_OK;
	}

	HRESULT SetString(DBORDINAL nColumn, BaseType* data) throw()
	{
		if (TranslateColumnNo(nColumn))
			return _SetString(nColumn, data);
		else
			return DB_S_ERRORSOCCURRED;
	}
	HRESULT SetString(const CHAR* pColumnName, BaseType* data) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
			return _SetString(nColumn, data);
		else
			return DB_S_ERRORSOCCURRED;
	}
	HRESULT SetString(const WCHAR* pColumnName, BaseType* data) throw()
	{
		ATLASSERT(pColumnName != NULL);
		DBORDINAL nColumn;
		if (GetInternalColumnNo(pColumnName, &nColumn))
			return _SetString(nColumn, data);
		else
			return DB_S_ERRORSOCCURRED;
	}
};


typedef CDynamicStringAccessorT<CHAR, DBTYPE_STR> CDynamicStringAccessorA;
typedef CDynamicStringAccessorT<WCHAR, DBTYPE_WSTR> CDynamicStringAccessorW;

#ifdef _UNICODE
typedef CDynamicStringAccessorW CDynamicStringAccessor;
#else
typedef CDynamicStringAccessorA CDynamicStringAccessor;
#endif

class CXMLAccessor : public CDynamicStringAccessorW
{
public:

	HRESULT GetXMLColumnData(CSimpleStringW& strOutput) throw()
	{
		_ATLTRY
		{
			strOutput = L"<columninfo>\n";
			DBTYPE wType;
			DBORDINAL nColumns = m_nColumns;
			//If Bookmark column -> index is 0 based starting at bookmark - index 0.
			if (m_pColumnInfo->iOrdinal == 0 && m_nColumns > 0)
			{	
				--nColumns;
			}
			for (ULONG i=1; i <= nColumns; i++)
			{
				strOutput += L"<column type=\"";
				if( !GetColumnType(i, &wType) )
					return E_FAIL;

				wType &= ~DBTYPE_BYREF;
				wType &= ~DBTYPE_ARRAY;
				wType &= ~DBTYPE_VECTOR;

				switch (wType)
				{
				case DBTYPE_BOOL:
					strOutput += L"BOOL";
					break;
				case DBTYPE_STR:
				case DBTYPE_WSTR:
					strOutput += L"STRING";
					break;
				case DBTYPE_I1:
					strOutput += L"I1";
					break;
				case DBTYPE_I2:
					strOutput += L"I2";
					break;
				case DBTYPE_I4:
					strOutput += L"I4";
					break;
				case DBTYPE_I8:
					strOutput += L"I8";
					break;
				case DBTYPE_UI1:
					strOutput += L"UI1";
					break;
				case DBTYPE_UI2:
					strOutput += L"UI2";
					break;
				case DBTYPE_UI4:
					strOutput += L"UI4";
					break;
				case DBTYPE_UI8:
					strOutput += L"UI8";
					break;
				case DBTYPE_R4:
					strOutput += L"R4";
					break;
				case DBTYPE_R8:
					strOutput += L"R8";
					break;
				case DBTYPE_DECIMAL:
					strOutput += L"DECIMAL";
					break;
				case DBTYPE_NUMERIC:
					strOutput += L"NUMERIC";
					break;
				case DBTYPE_VARIANT:
					strOutput += L"VARIANT";
					break;
				case DBTYPE_IDISPATCH:
					strOutput += L"DISPATCH";
					break;
				case DBTYPE_IUNKNOWN:
					strOutput += L"IUNKNOWN";
					break;
				case DBTYPE_GUID:
					strOutput += L"GUID";
					break;
				case DBTYPE_DBDATE:
					strOutput += L"DBDATE";
					break;
				case DBTYPE_DBTIME:
					strOutput += L"DBTIME";
					break;
				case DBTYPE_DBTIMESTAMP:
					strOutput += L"DBTIMESTAMP";
					break;
				case DBTYPE_FILETIME:
					strOutput += L"FILETIME";
					break;
				case DBTYPE_PROPVARIANT:
					strOutput += L"PROPVARIANT";
					break;
				case DBTYPE_VARNUMERIC:
					strOutput += L"VARNUMERIC";
					break;
				}
				strOutput += L"\">";
				strOutput += GetColumnName(i);
				strOutput += L"</column>\n";
			}
			strOutput += L"</columninfo>\n";
			return S_OK;
		}
		_ATLCATCH(e)
		{
			_ATLDELETEEXCEPTION(e)
			return E_FAIL;
		}
	}

	HRESULT GetXMLRowData(CSimpleStringW& strOutput, bool bAppend = false) throw()
	{
		_ATLTRY
		{
			LPOLESTR pszName;
			if (!bAppend)
				strOutput.Empty();
			strOutput += L"<row>";
			DBORDINAL nColumns = m_nColumns;
			//If Bookmark column -> index is 0 based starting at bookmark - index 0.
			if (m_pColumnInfo->iOrdinal == 0 && m_nColumns > 0)
			{	
				--nColumns;
			}
			for (ULONG i=1; i<=nColumns; i++)
			{
				pszName = GetColumnName(i);
				strOutput += L"<";
				strOutput += pszName;
				strOutput += L">";
				DBSTATUS dbStatus=DBSTATUS_S_ISNULL;
				if( !GetStatus(i, &dbStatus) )
					return E_FAIL;

				if (dbStatus!=DBSTATUS_S_ISNULL)
					strOutput += GetString(i);

				strOutput += L"</";
				strOutput += pszName;
				strOutput += L">";
			}
			strOutput += L"</row>";
			return S_OK;
		}
		_ATLCATCH(e)
		{
			_ATLDELETEEXCEPTION(e)
			return E_FAIL;
		}
	}
};

// Like CDynamicAccessor but everything is bound as a DBTYPE_VARIANT
class CDynamicVariantAccessor : public CDynamicAccessor
{
public:
	HRESULT BindColumns(IUnknown* pUnk) throw()
	{
		ATLENSURE_RETURN(pUnk != NULL);
		CComPtr<IAccessor> spAccessor;
		HRESULT hr = pUnk->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		ULONG   i;
		DBBYTEOFFSET   nOffset = 0, nDataOffset, nLengthOffset, nStatusOffset;

		// If the user hasn't specifed the column information to bind by calling AddBindEntry then
		// we get it ourselves
		if (m_pColumnInfo == NULL)
		{
			CComPtr<IColumnsInfo> spColumnsInfo;
			hr = pUnk->QueryInterface(&spColumnsInfo);
			if (FAILED(hr))
				return hr;

			hr = spColumnsInfo->GetColumnInfo(&m_nColumns, &m_pColumnInfo, &m_pStringsBuffer);
			if (FAILED(hr))
				return hr;

			m_bOverride = false;
		}
		else
			m_bOverride = true;

		DBBINDING* pBinding = NULL;

		ATLTRY(pBinding= new DBBINDING[m_nColumns]);

		if (pBinding == NULL)
			return E_OUTOFMEMORY;

		CAutoVectorPtr<DBBINDING> spBinding(pBinding);

		DBBINDING* pCurrent = pBinding;
		DBOBJECT*  pObject;
		for (i = 0; i < m_nColumns; i++)
		{
			// If it's a BLOB or the column size is large enough for us to treat it as
			// a BLOB then we also need to set up the DBOBJECT structure.
			if (m_pColumnInfo[i].ulColumnSize > m_nBlobSize || m_pColumnInfo[i].wType == DBTYPE_IUNKNOWN)
			{
				pObject = NULL;
				ATLTRY(pObject = new DBOBJECT);
				if (pObject == NULL)
				{
					for( UINT t = 0; t < i; t++ )
						delete pBinding[t].pObject;
					return E_OUTOFMEMORY;
				}
				pObject->dwFlags = STGM_READ;
				pObject->iid     = __uuidof(ISequentialStream);
				m_pColumnInfo[i].wType      = DBTYPE_IUNKNOWN;
				m_pColumnInfo[i].ulColumnSize   = sizeof(IUnknown*);
			}
			else
				pObject = NULL;

			m_pColumnInfo[i].ulColumnSize = sizeof(VARIANT);

			// Calculate the column data offset
			nDataOffset = AlignAndIncrementOffset(nOffset, sizeof(VARIANT), __alignof(VARIANT));

			// Calculate the column length offset
			nLengthOffset = AlignAndIncrementOffset(nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH));

			// Calculate the column status offset
			nStatusOffset = AlignAndIncrementOffset(nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS));

			Bind(pCurrent, m_pColumnInfo[i].iOrdinal, DBTYPE_VARIANT,
				sizeof(VARIANT), m_pColumnInfo[i].bPrecision, m_pColumnInfo[i].bScale,
				DBPARAMIO_NOTPARAM, nDataOffset, nLengthOffset, nStatusOffset, pObject);
			pCurrent++;

			// Note that, as we're not using this for anything else, we're using the
			// pTypeInfo element to store the offset to our data.
			m_pColumnInfo[i].pTypeInfo = (ITypeInfo*)(ULONG_PTR)nDataOffset;
		}
		// Allocate the accessor memory if we haven't done so yet
		if (m_pAccessorInfo == NULL)
		{
			hr = AllocateAccessorMemory(1); // We only have one accessor
			if (FAILED(hr))
			{
				for( UINT t = 0; t < m_nColumns; t++ )
					delete pBinding[t].pObject;
				return hr;
			}
			m_pAccessorInfo->bAutoAccessor = true;
		}

		// Allocate enough memory for the data buffer and tell the rowset
		// Note that the rowset will free the memory in its destructor.
		m_pBuffer = NULL;
		ATLTRY(m_pBuffer = new BYTE[nOffset]);
		if (m_pBuffer == NULL)
		{
			for( UINT t = 0; t < m_nColumns; t++ )
				delete pBinding[t].pObject;
			return E_OUTOFMEMORY;
		}
		memset(m_pBuffer, 0, nOffset);
		hr = BindEntries(pBinding, m_nColumns, &m_pAccessorInfo->hAccessor,
				nOffset, spAccessor);

		return hr;
	}
};

///////////////////////////////////////////////////////////////////////////
// class CDynamicParameterAccessor

class CDynamicParameterAccessor : public CDynamicAccessor
{
// Constructors and Destructors
public:
	typedef CDynamicParameterAccessor _ParamClass;
	CDynamicParameterAccessor( DBBLOBHANDLINGENUM eBlobHandling = DBBLOBHANDLING_DEFAULT, DBLENGTH nBlobSize = 8000 )
		: CDynamicAccessor( eBlobHandling, nBlobSize )
	{
		m_pParameterEntry       = NULL;
		m_pParameterBuffer      = NULL;
		m_ppParamName           = NULL;
		m_nParameterBufferSize  = 0;
		m_nParams               = 0;
	};

	~CDynamicParameterAccessor()
	{
		delete [] m_pParameterEntry;
		if (m_ppParamName != NULL)
		{
			CoTaskMemFree(*m_ppParamName);
			delete [] m_ppParamName;
		}
		delete m_pParameterBuffer;
	};

	bool GetParamSize(DBORDINAL nParam, DBLENGTH *pLength) const
	{
		ATLENSURE( pLength != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		*pLength = m_pParameterEntry[nParam].cbMaxLen;
		return true;
	}

	bool GetParamIO(DBORDINAL nParam, DBPARAMIO *pParamIO) const
	{
		ATLENSURE( pParamIO != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		*pParamIO = m_pParameterEntry[nParam].eParamIO;
		return true;
	}

	bool GetParamType(DBORDINAL nParam, DBTYPE *pType) const 
	{
		ATLENSURE( pType != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		*pType = m_pParameterEntry[nParam].wType;
		return true;
	}
	bool GetParamLength(DBORDINAL nParam, DBLENGTH *pLength)
	{
		ATLENSURE( pLength != NULL );

		DBLENGTH* pBuffer = GetParamLength(nParam);
		if (pBuffer == NULL)
			return false;
		*pLength = *pBuffer;
		return true;
	}
	bool SetParamLength(DBORDINAL nParam, DBLENGTH length)
	{
		DBLENGTH* pBuffer = GetParamLength(nParam);
		if (pBuffer == NULL)
			return false;
		*pBuffer = length;
		return true;
	}
	bool GetParamStatus(DBORDINAL nParam, DBSTATUS *pStatus)
	{
		ATLENSURE( pStatus != NULL );

		DBSTATUS* pBuffer = GetParamStatus(nParam);
		if (pBuffer == NULL)
			return false;
		*pStatus = *pBuffer;
		return true;
	}
	bool SetParamStatus(DBORDINAL nParam, DBSTATUS status)
	{
		DBSTATUS* pBuffer = GetParamStatus(nParam);
		if (pBuffer == NULL)
			return false;
		*pBuffer = status;
		return true;
	}
	template <class ctype>
	bool GetParam(DBORDINAL nParam, ctype* pData) const throw()
	{
		ATLASSERT( pData != NULL );
		ctype* pBuffer = (ctype*)GetParam(nParam);
		if (pBuffer == NULL)
			return false;
		*pData = *pBuffer;
		return true;
	}

	bool GetParamString(DBORDINAL nParam, CSimpleStringA& strOutput ) throw()
	{
		CHAR* pData = (CHAR*)GetParam(nParam);
		if (pData == NULL)
			return false;

		strOutput = pData;
		return true;
	}

	bool GetParamString(DBORDINAL nParam, CSimpleStringW& strOutput ) throw()
	{
		WCHAR* pData = (WCHAR*)GetParam(nParam);
		if (pData == NULL)
			return false;

		strOutput = pData;
		return true;
	}

	bool GetParamString(__in DBORDINAL nParam, __out_ecount_part_z_opt(*pMaxLen, *pMaxLen) CHAR* pBuffer, __inout size_t* pMaxLen) throw()
	{
		ATLASSERT( pMaxLen != NULL );

		CHAR* pData = (CHAR*)GetParam(nParam);
		if (pData == NULL)
			return false;

		size_t nStrLen = strlen( pData );

		if( pBuffer == NULL )
		{
			*pMaxLen = nStrLen + 1;
			return true;
		}

		if( ( *pMaxLen ) < ( nStrLen + 1 ) )
		{
			return false;
		}

		Checked::strcpy_s( pBuffer, *pMaxLen, pData);
		return true;
	}

	bool GetParamString(__in DBORDINAL nParam, __out_ecount_part_z_opt(*pMaxLen, *pMaxLen) WCHAR* pBuffer, __inout size_t* pMaxLen) throw()
	{
		ATLASSERT( pMaxLen != NULL );

		WCHAR* pData = (WCHAR*)GetParam(nParam);
		if (pData == NULL)
			return false;

		size_t nStrLen = wcslen( pData );

		if( pBuffer == NULL )
		{
			*pMaxLen = nStrLen + 1;
			return true;
		}

		if( ( * pMaxLen ) < ( nStrLen + 1 ) )
		{
			return false;
		}

		Checked::wcscpy_s( pBuffer, *pMaxLen, pData);
		return true;
	}

	template <class ctype>
	bool SetParam(DBORDINAL nParam, const ctype* pData, DBSTATUS status = DBSTATUS_S_OK )
	{
		ATLENSURE( pData != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		ctype* pBuffer = (ctype*)_GetParam(nParam);
		if (pBuffer == NULL)
			return false;

		*pBuffer = *pData;

		DBSTATUS *pStatus = _GetParamStatus( nParam );
		if( pStatus != NULL )
			*pStatus = status;

		return true;
	}

	bool SetParamString(DBORDINAL nParam, const CHAR* pString, DBSTATUS status = DBSTATUS_S_OK ) 
	{
		ATLENSURE( pString != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		CHAR* pBuffer = (CHAR*)_GetParam(nParam);
		if (pBuffer == NULL)
			return false;

		size_t nMaxLen = m_pParameterEntry[nParam].cbMaxLen;
		if( strlen( pString ) >= nMaxLen )
			return false;

		Checked::strcpy_s(pBuffer, nMaxLen, pString);

		DBSTATUS *pStatus = _GetParamStatus( nParam );
		if( pStatus != NULL )
			*pStatus = status;
		DBLENGTH *pLength = _GetParamLength( nParam );
		if( pLength != NULL )
			*pLength = (DBLENGTH)(strlen(pBuffer));

		return true;
	}

	bool SetParamString(DBORDINAL nParam, const WCHAR* pString, DBSTATUS status = DBSTATUS_S_OK ) throw()
	{
		ATLASSERT( pString != NULL );

		if( !TranslateParameterNo( nParam ) )
			return false;

		WCHAR* pBuffer = (WCHAR*)_GetParam(nParam);
		if (pBuffer == NULL)
			return false;

		size_t nMaxLen = m_pParameterEntry[nParam].cbMaxLen / 2;
		if( Checked::wcsnlen( pString, nMaxLen ) >= nMaxLen )
			return false;

		Checked::wcscpy_s( pBuffer, nMaxLen, pString);

		DBSTATUS *pStatus = _GetParamStatus( nParam );
		if( pStatus != NULL )
			*pStatus = status;
		DBLENGTH *pLength = _GetParamLength( nParam );
		if( pLength != NULL )
			*pLength = (DBLENGTH)( sizeof(WCHAR) * wcslen(pBuffer));

		return true;
	}

	template <class ctype>
	bool GetParam(__in_z TCHAR* pParamName, __out ctype* pData) const throw()
	{
		ATLASSERT( pData != NULL );

		DBORDINAL nParam;
		if( !_GetParameterNo( pParamName, nParam ) )
			return NULL;

		ctype* pBuffer = (ctype*)_GetParam(nParam);
		if (pBuffer == NULL)
			return false;

		*pData = *pBuffer;
		return true;
	}

	template <class ctype>
	bool SetParam(__in_z TCHAR* pParamName, __in const ctype* pData, __in DBSTATUS status = DBSTATUS_S_OK ) throw()
	{
		ATLASSERT( pData != NULL );

		DBORDINAL nParam;
		if( !_GetParameterNo( pParamName, nParam ) )
			return NULL;

		ctype* pBuffer = (ctype*)_GetParam(nParam);
		if (pBuffer == NULL)
			return false;

		*pBuffer = *pData;

		DBSTATUS *pStatus = _GetParamStatus( nParam );
		if( pStatus != NULL )
			*pStatus = status;
		//DBLENGTH *pLength = _GetParamLength( nParam );
		//if( pLength != NULL )
		//	*pLength = sizeof(ctype);

		return true;
	}

	void* GetParam(DBORDINAL nParam) const throw()
	{
		if( !TranslateParameterNo( nParam ) )
			return NULL;

		return _GetParam( nParam );
	}

	DBLENGTH* GetParamLength(DBORDINAL nParam) const throw()
	{
		if( !TranslateParameterNo( nParam ) )
			return NULL;

		return _GetParamLength( nParam );
	}

	DBSTATUS* GetParamStatus(DBORDINAL nParam) const throw()
	{
		if( !TranslateParameterNo( nParam ) )
			return NULL;

		return _GetParamStatus( nParam );
	}

	void* GetParam(TCHAR* pParamName) const throw()
	{
		DBORDINAL nParam;
		if( !_GetParameterNo( pParamName, nParam ) )
			return NULL;

		return _GetParam( nParam );
	}

	// Get the number of parameters
	DB_UPARAMS GetParamCount() const throw()
	{
		return m_nParams;
	}

	// Get the parameter name for the passed parameter number
	LPOLESTR GetParamName(DBORDINAL nParam) const throw()
	{
		if( !TranslateParameterNo( nParam ) )
			return NULL;

		return m_ppParamName[nParam];
	}

	bool TranslateParameterNo( DBORDINAL& nParam ) const throw()
	{
		for( DBORDINAL i = 0; i < m_nParams; i++ )
		{
			if( m_pParameterEntry[i].iOrdinal == nParam )
			{
				nParam = i;
				return true;
			}
		}

		return false;
	}

	bool _GetParameterNo(__in_z  TCHAR* pParamName, __in DBORDINAL& nParam ) const throw()
	{
		if( pParamName == NULL )
			return false;

		DBORDINAL i;
		size_t    nSize = (lstrlen(pParamName) + 1) * sizeof(OLECHAR);
		CComBSTR  bstrParamName(pParamName);

		for (i=0; i<m_nParams; i++)
		{
			if (memcmp(m_ppParamName[i], bstrParamName.m_str, nSize) == 0)
			{
				nParam = i;
				return true;
			}
		}

		return false;    // Not Found
	}

	void* _GetParam(DBORDINAL nParam) const throw()
	{
		return m_pParameterBuffer + m_pParameterEntry[nParam].obValue;
	}

	DBLENGTH* _GetParamLength(DBORDINAL nParam) const throw()
	{
		if( m_pParameterEntry[nParam].obLength == 0 )
			return NULL;
		else
			return (DBLENGTH*)(m_pParameterBuffer + m_pParameterEntry[nParam].obLength);
	}

	DBSTATUS* _GetParamStatus(DBORDINAL nParam) const throw()
	{
		if( m_pParameterEntry[nParam].obStatus == 0 )
			return NULL;
		else
			return (DBSTATUS*)(m_pParameterBuffer + m_pParameterEntry[nParam].obStatus);
	}

// Implementation
	HRESULT BindParameters(HACCESSOR* pHAccessor, ICommand* pCommand,
				void** ppParameterBuffer, bool fBindLength = false, bool fBindStatus = false ) throw()
	{
		// If we have already bound the parameters then just return
		// the pointer to the parameter buffer
		if (*pHAccessor != NULL)
		{
			*ppParameterBuffer = m_pParameterBuffer;
			return S_OK;
		}

		CComPtr<IAccessor> spAccessor;
		ATLENSURE_RETURN(pCommand != NULL);
		HRESULT hr = pCommand->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		// Try to bind parameters if available
		CComPtr<ICommandWithParameters> spCommandParameters;
		hr = pCommand->QueryInterface(&spCommandParameters);
		if (FAILED(hr))
			return hr;

		DB_UPARAMS ulParams     = 0;
		CComHeapPtr<DBPARAMINFO>    spParamInfo;
		LPOLESTR pNamesBuffer;

		// Get Parameter Information
		hr = spCommandParameters->GetParameterInfo(&ulParams, &spParamInfo,
				&pNamesBuffer);
		if (FAILED(hr))
			return hr;

		// Create the parameter information for binding
		hr = AllocateParameterInfo(ulParams);
		if (FAILED(hr))
		{
			CoTaskMemFree(pNamesBuffer);
			return hr;
		}

		DBBYTEOFFSET nOffset = 0;
		DBBYTEOFFSET nDataOffset = 0;
		DBBYTEOFFSET nLengthOffset = 0;
		DBBYTEOFFSET nStatusOffset = 0;

		DBBINDING* pCurrent = m_pParameterEntry;
		for (ULONG l=0; l<ulParams; l++)
		{
			m_pParameterEntry[l].eParamIO = 0;

			if (spParamInfo[l].dwFlags & DBPARAMFLAGS_ISINPUT)
				m_pParameterEntry[l].eParamIO |= DBPARAMIO_INPUT;

			if (spParamInfo[l].dwFlags & DBPARAMFLAGS_ISOUTPUT)
				m_pParameterEntry[l].eParamIO |= DBPARAMIO_OUTPUT;

			// if this is a BLOB, truncate column length to m_nBlobSize (like 8000 bytes)
			if( spParamInfo[l].ulParamSize > m_nBlobSize )
				spParamInfo[l].ulParamSize = m_nBlobSize;

			// if this is a string, recalculate column size in bytes
			DBLENGTH colLength = spParamInfo[l].ulParamSize;
			if (spParamInfo[l].wType == DBTYPE_STR)
				colLength += 1;
			if (spParamInfo[l].wType == DBTYPE_WSTR)
				colLength = colLength*2 + 2;

			// Calculate the column data offset
			nDataOffset = AlignAndIncrementOffset( nOffset, colLength, GetAlignment( spParamInfo[l].wType ) );

			if( fBindLength )
			{
				// Calculate the column length offset
				nLengthOffset = AlignAndIncrementOffset( nOffset, sizeof(DBLENGTH), __alignof(DBLENGTH) );
			}

			if( fBindStatus )
			{
				// Calculate the column status offset
				nStatusOffset = AlignAndIncrementOffset( nOffset, sizeof(DBSTATUS), __alignof(DBSTATUS) );
			}

			Bind(pCurrent, spParamInfo[l].iOrdinal, spParamInfo[l].wType,
				colLength, spParamInfo[l].bPrecision, spParamInfo[l].bScale,
				m_pParameterEntry[l].eParamIO, nDataOffset, nLengthOffset, nStatusOffset );

			pCurrent++;

			m_ppParamName[l] = pNamesBuffer;
			if (pNamesBuffer && *pNamesBuffer)
			{
				// Search for the NULL termination character
				while (*pNamesBuffer++)
					;
			}
		}

		// Allocate memory for the new buffer
		m_pParameterBuffer = NULL;
		ATLTRY(m_pParameterBuffer = new BYTE[nOffset]);
		if (m_pParameterBuffer == NULL)
		{
			// Note that pNamesBuffer will be freed in the destructor
			// by freeing *m_ppParamName
			return E_OUTOFMEMORY;
		}
		*ppParameterBuffer = m_pParameterBuffer;
		m_nParameterBufferSize = nOffset;
		m_nParams = ulParams;
		BindEntries(m_pParameterEntry, ulParams, pHAccessor, nOffset, spAccessor);

		return S_OK;
	}
	bool HasParameters() const throw()
	{
		return true;
	}
	HRESULT AllocateParameterInfo(DB_UPARAMS nParamEntries) throw()
	{
		// Allocate memory for the bind structures
		m_pParameterEntry = NULL;
		ATLTRY(m_pParameterEntry = new DBBINDING[nParamEntries]);
		if (m_pParameterEntry == NULL)
			return E_OUTOFMEMORY;

		// Allocate memory to store the field names
		m_ppParamName = NULL;
		ATLTRY(m_ppParamName = new OLECHAR*[nParamEntries]);
		if (m_ppParamName == NULL)
		{
			delete [] m_pParameterEntry;
			m_pParameterEntry = NULL;
			return E_OUTOFMEMORY;
		}
		return S_OK;
	}

// Data Members
	// Number of parameters
	DB_UPARAMS          m_nParams;
	// A pointer to the entry structures for each parameter
	DBBINDING*          m_pParameterEntry;
	// String names for the parameters
	OLECHAR**           m_ppParamName;
	// The size of the buffer where the parameters are stored
	DBLENGTH            m_nParameterBufferSize;
	// A pointer to the buffer where the parameters are stored
	BYTE*               m_pParameterBuffer;
};


///////////////////////////////////////////////////////////////////////////
// class CManualAccessor

class CManualAccessor :
	public CAccessorBase
{
public:
	CManualAccessor()
	{
		// By default we don't have any parameters unless CreateParameterAccessor 
		// is called
		m_pEntry          = NULL;
		m_nParameters     = 0;
		m_pParameterEntry = NULL;
		m_nColumns        = 0;
		m_pParameterBuffer = NULL;
	}
	~CManualAccessor()
	{
		delete [] m_pEntry;
		delete [] m_pParameterEntry;
	}

	HRESULT ReleaseAccessors(IUnknown* pUnk) throw()
	{
		FreeRecordMemory( (IRowset*) pUnk );
		return CAccessorBase::ReleaseAccessors(pUnk);
	}

	HRESULT CreateAccessor(int nBindEntries, void* pBuffer, DBLENGTH nBufferSize) throw()
	{
		m_pBuffer     = (BYTE*)pBuffer;
		m_nBufferSize = nBufferSize;
		m_nColumns    = 0;
		m_nEntry      = 0;
		memset(pBuffer, 0, nBufferSize);

		// If they've previously created some entries then free them
		delete [] m_pEntry;
		m_pEntry = NULL;

		// Allocate memory for the bind structures
		ATLTRY(m_pEntry = new DBBINDING[nBindEntries]);
		if (m_pEntry == NULL)
			return E_OUTOFMEMORY;

		m_nColumns    = nBindEntries;

		return S_OK;
	}
	HRESULT CreateParameterAccessor(int nBindEntries, void* pBuffer, DBLENGTH nBufferSize) throw()
	{
		// Should be called only once.  But, if you really insist on doing this...
		if (m_pParameterEntry != NULL)
		{
			delete [] m_pParameterEntry;
			m_pParameterEntry = NULL;
		}

		m_pParameterBuffer     = (BYTE*)pBuffer;
		m_nParameterBufferSize = nBufferSize;
		m_nParameters          = 0;
		m_nCurrentParameter    = 0;

		// Allocate memory for the bind structures
		ATLTRY(m_pParameterEntry = new DBBINDING[nBindEntries]);
		if (m_pParameterEntry == NULL)
			return E_OUTOFMEMORY;

		m_nParameters          = nBindEntries;

		return S_OK;
	}
	void AddBindEntry(DBORDINAL nOrdinal, DBTYPE wType, DBLENGTH nColumnSize,
			void* pData, void* pLength = NULL, void* pStatus = NULL) throw()
	{
		ATLASSUME(m_nEntry < m_nColumns);
		DBBYTEOFFSET   nLengthOffset, nStatusOffset;

		if (pStatus != NULL)
			nStatusOffset = (BYTE*)pStatus - m_pBuffer;
		else
			nStatusOffset = 0;

		if (pLength != NULL)
			nLengthOffset = (BYTE*)pLength - m_pBuffer;
		else
			nLengthOffset = 0;

		Bind(m_pEntry+m_nEntry, nOrdinal, wType, nColumnSize, 0, 0, DBPARAMIO_NOTPARAM,
			(BYTE*)pData - m_pBuffer, nLengthOffset, nStatusOffset);

		m_nEntry++;
	}
	void AddParameterEntry(DBORDINAL nOrdinal, DBTYPE wType, DBLENGTH nColumnSize,
			void* pData, void* pLength = NULL, void* pStatus = NULL,
			DBPARAMIO eParamIO = DBPARAMIO_INPUT) throw()
	{
		ATLASSUME(m_nCurrentParameter < m_nParameters);
		DBBYTEOFFSET nLengthOffset, nStatusOffset;

		if (pStatus != NULL)
			nStatusOffset = (BYTE*)pStatus - m_pParameterBuffer;
		else
			nStatusOffset = 0;

		if (pLength != NULL)
			nLengthOffset = (BYTE*)pLength - m_pParameterBuffer;
		else
			nLengthOffset = 0;

		Bind(m_pParameterEntry + m_nCurrentParameter, nOrdinal, wType, nColumnSize, 0, 0,
			eParamIO, (BYTE*)pData - m_pParameterBuffer, nLengthOffset, nStatusOffset);

		m_nCurrentParameter++;
	}

// Implementation
	// Free's any columns in the current record that need to be freed.
	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
	void FreeRecordMemory(IRowset* pRowset) throw ()
	{
		ULONG i;

		for (i = 0; i < m_nColumns; i++)
			CAccessorBase::FreeType(m_pEntry[i].wType, m_pBuffer + m_pEntry[i].obValue, pRowset);
	}

	void ClearRecordMemory() throw()
	{
		memset(m_pBuffer, 0, m_nBufferSize);
	}

	HRESULT BindColumns(IUnknown* pUnk) throw()
	{
		ATLENSURE_RETURN(pUnk != NULL);
		CComPtr<IAccessor> spAccessor;
		HRESULT hr = pUnk->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		// Allocate the accessor memory if we haven't done so yet
		if (m_pAccessorInfo == NULL)
		{
			hr = AllocateAccessorMemory(1); // We only have one accessor
			if (FAILED(hr))
				return hr;
			m_pAccessorInfo->bAutoAccessor = true;
		}

		return BindEntries(m_pEntry, m_nColumns, &m_pAccessorInfo->hAccessor, m_nBufferSize, spAccessor);
	}

	HRESULT BindParameters(HACCESSOR* pHAccessor, ICommand* pCommand, void** ppParameterBuffer) throw()
	{
		HRESULT hr;
		*ppParameterBuffer = m_pParameterBuffer;

		// Only bind the parameter if we haven't done so yet
		if (*pHAccessor == NULL)
		{
			// Get the IAccessor from the passed IUnknown
			CComPtr<IAccessor> spAccessor;
			ATLENSURE_RETURN(pCommand != NULL);
			hr = pCommand->QueryInterface(&spAccessor);
			if (SUCCEEDED(hr))
			{
				hr = BindEntries(m_pParameterEntry, m_nParameters, pHAccessor,
						m_nParameterBufferSize, spAccessor);
			}
		}
		else
			hr = S_OK;

		return hr;
	}
	typedef CManualAccessor _ParamClass;
	bool HasParameters() throw() { return (m_nParameters > 0); }
	typedef CManualAccessor _OutputColumnsClass;
	bool HasOutputColumns() throw() { return (m_nColumns > 0); }
	DBORDINAL GetColumnCount() const throw()
	{
		return m_nColumns;
	}

	// The binding structure for the output columns
	DBBINDING*          m_pEntry;
	// The number of output columns
	DBORDINAL           m_nColumns;
	// The number of the current entry for the output columns
	DBORDINAL           m_nEntry;
	// The size of the data buffer for the output columns
	DBLENGTH            m_nBufferSize;
	// The number of parameters columns
	DBORDINAL           m_nParameters;
	// The number of the parameter column to bind next
	DBORDINAL           m_nCurrentParameter;
	// A pointer to the entry structures for each parameter
	DBBINDING*          m_pParameterEntry;
	// The size of the buffer where the parameters are stored
	DBLENGTH            m_nParameterBufferSize;
	// A pointer to the buffer where the parameters are stored
	BYTE*               m_pParameterBuffer;
};

class _ATL_COLUMN_PARAM_INFO
{
public:
	_ATL_COLUMN_PARAM_INFO()
	{
		m_pParams = NULL;
		m_pBuffer = NULL;
	}
	~_ATL_COLUMN_PARAM_INFO()
	{
		delete m_pParams;
	}
	BOOL AddBinding(DBBINDING& binding)
	{
		return m_rgBinding.Add(binding);
	}

	CSimpleArray<DBBINDING, CSimpleArrayEqualHelperFalse<DBBINDING> >	m_rgBinding;	// The binding for each parameter
	DBPARAMS*				m_pParams;
	BYTE*					m_pBuffer;
};

///////////////////////////////////////////////////////////////////////////
// CColumnAccessor
class CColumnAccessor : public CAccessorBase
{
public:
	CColumnAccessor()
	{
		m_pParamInfo = NULL;
	}
	~CColumnAccessor()
	{
		delete m_pParamInfo;
	}

	HRESULT ReleaseAccessors(IUnknown* pUnk) throw()
	{
		FreeRecordMemory( (IRowset*) pUnk );
		return CAccessorBase::ReleaseAccessors(pUnk);
	}

	// pUnk is the interface the accessor will be created upon
	HRESULT CreateAccessor(IUnknown* pUnk, DBORDINAL nOrdinal, DBTYPE wType, DBLENGTH nColumnSize,
			BYTE nPrecision, BYTE nScale, void* pData) throw()
	{
		(nPrecision);
		(nScale);
		ATLENSURE_RETURN(pUnk != NULL);
		DBBINDING binding;

		Bind(&binding, nOrdinal, wType, nColumnSize, 0, 0, DBPARAMIO_NOTPARAM,
			(BYTE*)pData - m_pBuffer);

		CComPtr<IAccessor> spAccessor;
		HRESULT hr = pUnk->QueryInterface(&spAccessor);
		if (FAILED(hr))
			return hr;

		// Add another accessor info structure
		AddAccessorInfo();
		_ATL_ACCESSOR_INFO* pAccessorInfo = m_pAccessorInfo + m_nAccessors - 1;

		pAccessorInfo->bAutoAccessor = true;	// Always auto

		// Bind it
		return BindEntries(&binding, 1, &pAccessorInfo->hAccessor, nColumnSize, spAccessor);
	}
	// Bind columns doesn't have to do anything here as we bind each accessor when
	// CreateAccessor is called
	HRESULT BindColumns(IUnknown*) throw()
	{
		return S_OK;
	}
	HRESULT SetParameterBuffer(BYTE* pBuffer) throw()
	{
		// This should only be called once.
		ATLASSUME(m_pParamInfo == NULL);

		ATLTRY(m_pParamInfo = new _ATL_COLUMN_PARAM_INFO);
		if (m_pParamInfo == NULL)
			return E_OUTOFMEMORY;

		m_pParamInfo->m_pBuffer = pBuffer;
		return S_OK;
	}
	HRESULT AddParameter(DBPARAMIO paramio, DBORDINAL nOrdinal, DBTYPE wType, DBLENGTH nColumnSize,
			BYTE /* nPrecision*/, BYTE /* nScale */, void* pData) throw()
	{
		ATLASSUME(m_pParamInfo != NULL);

		DBBINDING binding;

		Bind(&binding, nOrdinal, wType, nColumnSize, 0, 0, paramio,
			(BYTE*)pData - m_pParamInfo->m_pBuffer);

		if (m_pParamInfo->AddBinding(binding) == FALSE)
			return E_OUTOFMEMORY;

		return S_OK;
	}
	bool HasOutputColumns() throw()
	{
		if( m_nAccessors )
			return true;
		else
			return false;
	}
	bool HasParameters() const throw()
	{
		return (m_pParamInfo != NULL) ? true : false;
	}
	// Called to bind the parameters created
	HRESULT BindParameters(HACCESSOR* pHAccessor, ICommand* pCommand, void** ppParameterBuffer)
	{
		ATLASSUME(m_pParamInfo != NULL);
		HRESULT hr = S_OK;

		// Only bind the parameters if we haven't already done it
		if (*pHAccessor == NULL)
		{
			// Get the IAccessor from the passed ICommand
			CComPtr<IAccessor> spAccessor;
			ATLENSURE_RETURN(pCommand != NULL);
			hr = pCommand->QueryInterface(&spAccessor);
			if (SUCCEEDED(hr))
			{
				*ppParameterBuffer = m_pParamInfo->m_pBuffer;
				// size isn't being passed here
				hr = BindEntries(&m_pParamInfo->m_rgBinding[0], m_pParamInfo->m_rgBinding.GetSize(),
					pHAccessor, 4, spAccessor);
			}

		}
		return hr;
	}
// Implementation
	typedef CColumnAccessor _ParamClass;
	typedef CColumnAccessor _OutputColumnsClass;
	HRESULT AddAccessorInfo() throw()
	{
		_ATL_ACCESSOR_INFO* pAccessorInfo = NULL;
		ATLTRY( pAccessorInfo = new _ATL_ACCESSOR_INFO[m_nAccessors + 1]; )
		if (pAccessorInfo == NULL)
			return E_OUTOFMEMORY;

		// Now copy the current accessor information to the new buffer
		Checked::memcpy_s(pAccessorInfo, sizeof(_ATL_ACCESSOR_INFO) * m_nAccessors, m_pAccessorInfo, sizeof(_ATL_ACCESSOR_INFO) * m_nAccessors);
		m_nAccessors++;

		// Now delete the old memory and use the new one
		delete [] m_pAccessorInfo;
		m_pAccessorInfo = pAccessorInfo;
		return S_OK;
	}
	_ATL_COLUMN_PARAM_INFO* m_pParamInfo;
};

///////////////////////////////////////////////////////////////////////////
// CAccessorRowset

template <class TAccessor = CNoAccessor, template <typename T> class TRowset = CRowset>
class CAccessorRowset :
	public TAccessor,
	public TRowset<TAccessor>
{
public:
	CAccessorRowset()
	{
		// Give the rowset a pointer to the accessor
		__if_exists(m_nAccessors)
		{
			SetAccessor(this);
		}
	}
	~CAccessorRowset()
	{
		Close();
	}
	// Used to get the column information from the opened rowset. The user is responsible
	// for freeing the returned column information and string buffer.
	HRESULT GetColumnInfo(DBORDINAL* pulColumns,
		DBCOLUMNINFO** ppColumnInfo, LPOLESTR* ppStrings) const throw()
	{
		if (ppColumnInfo == NULL || pulColumns == NULL || ppStrings == NULL)
			return E_POINTER;

		ATLASSERT(GetInterface() != NULL);
		if (GetInterface() == NULL)
			return E_FAIL;
		CComPtr<IColumnsInfo> spColumns;
		HRESULT hr = GetInterface()->QueryInterface(&spColumns);
		if (SUCCEEDED(hr))
			hr = spColumns->GetColumnInfo(pulColumns, ppColumnInfo, ppStrings);

		return hr;
	}

	// Used to get the column information when overriding the bindings using CDynamicAccessor
	// The user should CoTaskMemFree the column information pointer that is returned.
	HRESULT GetColumnInfo(DBORDINAL* pColumns, DBCOLUMNINFO** ppColumnInfo) throw()
	{
		// If you get a compilation here, then you are most likely calling this function
		// from a class that is not using CDynamicAccessor.
		ATLASSERT(GetInterface() != NULL);
		if (GetInterface() == NULL)
			return E_FAIL;
		return TAccessor::GetColumnInfo(GetInterface(), pColumns, ppColumnInfo);
	}

	// Call to bind the output columns
	HRESULT Bind() throw()
	{
		// Bind should only be called when we've successfully opened the rowset
		ATLASSERT(GetInterface() != NULL);
		if (GetInterface() == NULL)
			return E_FAIL;
		HRESULT hr = TAccessor::BindColumns(GetInterface());
		if (SUCCEEDED(hr))
			hr = BindFinished();
		return hr;
	}
	// Close the opened rowset and release the created accessors for the output columns
	void Close() throw()
	{
		if (GetInterface() != NULL)
		{
			ReleaseAccessors(GetInterface());
			TAccessor::Close();
			TRowset<TAccessor>::Close();
		}
	}
	// Free's any columns in the current record that need to be freed.
	// E.g. Calls SysFreeString on any BSTR's and Release on any interfaces.
	void FreeRecordMemory() throw()
	{
		TAccessor::FreeRecordMemory(m_spRowset);
	}
	void FreeRecordMemory(int nAccessor) throw()
	{
		TAccessor::FreeRecordMemory(nAccessor, m_spRowset);
	}
};


///////////////////////////////////////////////////////////////////////////
// class CEnumeratorAccessor

class CEnumeratorAccessor
{
public:
	WCHAR           m_szName[129];
	WCHAR           m_szParseName[129];
	WCHAR           m_szDescription[129];
	USHORT          m_nType;
	VARIANT_BOOL    m_bIsParent;

// Binding Maps
BEGIN_COLUMN_MAP(CEnumeratorAccessor)
	COLUMN_ENTRY(1, m_szName)
	COLUMN_ENTRY(2, m_szParseName)
	COLUMN_ENTRY(3, m_szDescription)
	COLUMN_ENTRY(4, m_nType)
	COLUMN_ENTRY(5, m_bIsParent)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CEnumerator

class CEnumerator : public CAccessorRowset<CAccessor<CEnumeratorAccessor> >
{
public:
	HRESULT Open(LPMONIKER pMoniker) throw()
	{
		if (pMoniker == NULL)
			return E_FAIL;

		// Bind the moniker for the sources rowset
		if (FAILED(BindMoniker(pMoniker, 0, __uuidof(ISourcesRowset),
					(void**)&m_spSourcesRowset)))
			return E_FAIL;

		// Enumerate the data sources
		if (FAILED(m_spSourcesRowset->GetSourcesRowset(NULL, __uuidof(IRowset), 0,
			NULL, (IUnknown**)&m_spRowset)))
			return E_FAIL;

		return Bind();
	}
	HRESULT Open(const CEnumerator& enumerator) throw()
	{
		HRESULT hr;
		CComPtr<IMoniker> spMoniker;

		hr = enumerator.GetMoniker(&spMoniker);
		if (FAILED(hr))
			return hr;

		return Open(spMoniker);
	}
	HRESULT Open(const CLSID* pClsid = &CLSID_OLEDB_ENUMERATOR) throw()
	{
		if (pClsid == NULL)
			return E_FAIL;

		HRESULT hr;
		// Create the enumerator
		hr = CoCreateInstance(*pClsid, NULL, CLSCTX_INPROC_SERVER,
				__uuidof(ISourcesRowset), (LPVOID*)&m_spSourcesRowset);
		if (FAILED(hr))
			return hr;

		// Get the rowset so we can enumerate the data sources
		hr = m_spSourcesRowset->GetSourcesRowset(NULL, __uuidof(IRowset), 0,
			NULL, (IUnknown**)&m_spRowset);
		if (FAILED(hr))
			return hr;

		return Bind();
	}

	void Close() throw()
	{
		// Close the rowset pointer
		if (m_spSourcesRowset != NULL)
			m_spSourcesRowset.Release();

		// Close the base class pointers
		CAccessorRowset<CAccessor<CEnumeratorAccessor> >::Close();
	}

	HRESULT GetMoniker(LPMONIKER* ppMoniker) const throw()
	{
		CComPtr<IParseDisplayName> spParse;
		HRESULT hr;
		ULONG   chEaten;

		if (ppMoniker == NULL)
			return E_POINTER;

		if (m_spSourcesRowset == NULL)
			return E_FAIL;

		hr = m_spSourcesRowset->QueryInterface(__uuidof(IParseDisplayName), (void**)&spParse);
		if (FAILED(hr))
			return hr;

		hr = spParse->ParseDisplayName(NULL, (LPOLESTR)m_szParseName,
				&chEaten, ppMoniker);
		return hr;
	}

	HRESULT GetMoniker(LPMONIKER* ppMoniker, LPCTSTR lpszDisplayName) const throw()
	{
		CComPtr<IParseDisplayName> spParse;
		HRESULT hr;
		ULONG   chEaten;

		if (ppMoniker == NULL || lpszDisplayName == NULL)
			return E_POINTER;

		if (m_spSourcesRowset == NULL)
			return E_FAIL;

		hr = m_spSourcesRowset->QueryInterface(__uuidof(IParseDisplayName), (void**)&spParse);
		if (FAILED(hr))
			return hr;

		hr = spParse->ParseDisplayName(NULL, (LPOLESTR)CComBSTR(lpszDisplayName),
				&chEaten, ppMoniker);
		return hr;
	}

	bool Find(TCHAR* szSearchName) throw()
	{
		WCHAR *wszSearchName = CT2W(szSearchName);

		// Loop through the providers looking for the passed name
		while (MoveNext()==S_OK && lstrcmpW(m_szName, wszSearchName))
		{
			ATLTRACE(atlTraceDBClient, 2, _T("%s, %s, %d\n"), m_szName, m_szParseName, m_nType);
		}
		if (lstrcmpW(m_szName, wszSearchName))
			return false;
		else
			return true;
	}

	CComPtr<ISourcesRowset> m_spSourcesRowset;
};


///////////////////////////////////////////////////////////////////////////
// CDataSource

class CDataSource
{
public:
	HRESULT Open(const CLSID& clsid, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1) throw()
	{
		HRESULT hr;

		m_spInit.Release();
		hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, __uuidof(IDBInitialize),
				(void**)&m_spInit);
		if (FAILED(hr))
			return hr;

		// Initialize the provider
		return OpenWithProperties(pPropSet, nPropertySets);
	}
	HRESULT Open(const CLSID& clsid, LPCTSTR pName, LPCTSTR pUserName = NULL,
		LPCTSTR pPassword = NULL, long nInitMode = 0) throw()
	{
		HRESULT   hr;

		m_spInit.Release();
		hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, __uuidof(IDBInitialize),
				(void**)&m_spInit);
		if (FAILED(hr))
			return hr;

		return OpenWithNameUserPassword(pName, pUserName, pPassword, nInitMode);
	}
	HRESULT Open(LPCSTR szProgID, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1) throw()
	{
		HRESULT hr;
		CLSID   clsid;

		hr = CLSIDFromProgID(CComBSTR(szProgID), &clsid);
		if (FAILED(hr))
		{
			return hr;
		}

		return Open(clsid, pPropSet, nPropertySets);
	}
	HRESULT Open(LPCWSTR szProgID, LPCTSTR pName, LPCTSTR pUserName = NULL,
		LPCTSTR pPassword = NULL, long nInitMode = 0) throw()
	{
		HRESULT hr;
		CLSID   clsid;

		hr = CLSIDFromProgID(szProgID, &clsid);
		if (FAILED(hr))
			return hr;

		return Open(clsid, pName, pUserName, pPassword, nInitMode);
	}
	HRESULT Open(LPCWSTR szProgID, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1) throw()
	{
		HRESULT hr;
		CLSID   clsid;

		hr = CLSIDFromProgID(szProgID, &clsid);
		if (FAILED(hr))
			return hr;

		return Open(clsid, pPropSet, nPropertySets);
	}
	HRESULT Open(LPCSTR szProgID, LPCTSTR pName, LPCTSTR pUserName = NULL,
		LPCTSTR pPassword = NULL, long nInitMode = 0) throw()
	{
		HRESULT hr;
		CLSID   clsid;

		hr = CLSIDFromProgID(CComBSTR(szProgID), &clsid);
		if (FAILED(hr))
		{
			return hr;
		}

		return Open(clsid, pName, pUserName, pPassword, nInitMode);
	}
	HRESULT Open(const CEnumerator& enumerator, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1) throw()
	{
		CComPtr<IMoniker> spMoniker;
		HRESULT   hr;

		hr = enumerator.GetMoniker(&spMoniker);
		if (FAILED(hr))
			return hr;

		m_spInit.Release();
		//  Now bind the moniker
		hr = BindMoniker(spMoniker, 0, __uuidof(IDBInitialize), (void**)&m_spInit);
		if (FAILED(hr))
			return hr;

		return OpenWithProperties(pPropSet, nPropertySets);
	}
	HRESULT Open(const CEnumerator& enumerator, LPCTSTR pName, LPCTSTR pUserName = NULL,
		LPCTSTR pPassword = NULL, long nInitMode = 0) throw()
	{
		CComPtr<IMoniker> spMoniker;
		HRESULT   hr;

		hr = enumerator.GetMoniker(&spMoniker);
		if (FAILED(hr))
			return hr;

		m_spInit.Release();
		//  Now bind the moniker
		hr = BindMoniker(spMoniker, 0, __uuidof(IDBInitialize), (void**)&m_spInit);
		if (FAILED(hr))
			return hr;

		return OpenWithNameUserPassword(pName, pUserName, pPassword, nInitMode);
	}
	// Invoke the data links dialog and open the selected database
	HRESULT Open(HWND hWnd = GetActiveWindow(), DBPROMPTOPTIONS dwPromptOptions = DBPROMPTOPTIONS_WIZARDSHEET) throw()
	{
		CComPtr<IDBPromptInitialize> spDBInit;

		HRESULT hr = CoCreateInstance(__uuidof(DataLinks), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDBPromptInitialize), (void**) &spDBInit);
		if (FAILED(hr))
			return hr;

		CComPtr<IDBProperties> spIDBProperties;
		hr = spDBInit->PromptDataSource(NULL, hWnd, dwPromptOptions, 0, NULL, NULL,
			__uuidof(IDBProperties), (IUnknown**)&spIDBProperties);

		if (hr == S_OK)
		{
			hr = spIDBProperties->QueryInterface(&m_spInit);
			if (SUCCEEDED(hr))
				hr = m_spInit->Initialize();
		}
		return hr;
	}
	// Opens a data source using the service components
	HRESULT OpenWithServiceComponents(const CLSID& clsid, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1) throw()
	{
		CComPtr<IDataInitialize> spDataInit;
		HRESULT hr;

		hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER, 
			__uuidof(IDataInitialize), (void**)&spDataInit);
		if (FAILED(hr))
			return hr;

		m_spInit.Release();
		hr = spDataInit->CreateDBInstance(clsid, NULL, CLSCTX_INPROC_SERVER, NULL, 
			__uuidof(IDBInitialize), (IUnknown**)&m_spInit);
		if (FAILED(hr))
			return hr;

		// Initialize the provider
		return OpenWithProperties(pPropSet, nPropertySets);
	}
	// Opens a data source using the service components
	HRESULT OpenWithServiceComponents(LPCTSTR szProgID, DBPROPSET* pPropSet = NULL, ULONG nPropertySets=1) throw()
	{
		HRESULT hr;
		CLSID   clsid;

		hr = CLSIDFromProgID(CComBSTR(szProgID), &clsid);
		if (FAILED(hr))
			return hr;

		return OpenWithServiceComponents(clsid, pPropSet, nPropertySets);
	}
	// Bring up the "Organize Dialog" which allows the user to select a previously created data link
	// file (.UDL file). The selected file will be used to open the datbase.
	HRESULT OpenWithPromptFileName(HWND hWnd = GetActiveWindow(), DBPROMPTOPTIONS dwPromptOptions = DBPROMPTOPTIONS_NONE,
		LPCOLESTR szInitialDirectory = NULL) throw()
	{
		CComPtr<IDBPromptInitialize> spDBInit;

		HRESULT hr = CoCreateInstance(__uuidof(DataLinks), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDBPromptInitialize), (void**) &spDBInit);
		if (FAILED(hr))
		{
			return hr;
		}

		CComPtr<IDBProperties> spIDBProperties;
		LPOLESTR szSelected;

		hr = spDBInit->PromptFileName(hWnd, dwPromptOptions, szInitialDirectory, L"*.udl", &szSelected);

		if (hr == S_OK)
		{
			hr = OpenFromFileName(szSelected);
		}
		else if (hr == S_FALSE)
		{
			hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_CANCELLED);  // The user clicked cancel
		}

		return hr;
	}
	// Open the datasource specified by the passed filename, typically a .UDL file
	HRESULT OpenFromFileName(LPCOLESTR szFileName) throw()
	{
		CComPtr<IDataInitialize> spDataInit;
		CComHeapPtr<OLECHAR>     spszInitString;

		HRESULT hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDataInitialize), (void**)&spDataInit);
		if (FAILED(hr))
			return hr;

		hr = spDataInit->LoadStringFromStorage(szFileName, &spszInitString);
		if (FAILED(hr))
			return hr;

		return OpenFromInitializationString(spszInitString);
	}
	// Open the datasource specified by the passed initialization string
	HRESULT OpenFromInitializationString(LPCOLESTR szInitializationString, bool fPromptForInfo = false) throw()
	{
		CComPtr<IDataInitialize> spDataInit;

		HRESULT hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDataInitialize), (void**)&spDataInit);
		if (FAILED(hr))
			return hr;

		hr = spDataInit->GetDataSource(NULL, CLSCTX_INPROC_SERVER, szInitializationString,
			__uuidof(IDBInitialize), (IUnknown**)&m_spInit);
		if (FAILED(hr))
			return hr;

		if( fPromptForInfo )
		{
			CComPtr<IDBProperties> spIDBProperties;
			hr = m_spInit->QueryInterface( &spIDBProperties );

			DBPROP rgProperties[1];
			DBPROPSET rgPropertySets[1];

			VariantInit(&rgProperties[0].vValue);
			rgProperties[0].dwOptions = DBPROPOPTIONS_REQUIRED;
			rgProperties[0].colid = DB_NULLID;
			rgProperties[0].dwPropertyID = DBPROP_INIT_PROMPT;
			rgProperties[0].vValue.vt = VT_I2;
			rgProperties[0].vValue.lVal = DBPROMPT_COMPLETEREQUIRED;

			rgPropertySets[0].rgProperties = rgProperties;
			rgPropertySets[0].cProperties = 1;
			rgPropertySets[0].guidPropertySet = DBPROPSET_DBINIT;

			hr = spIDBProperties->SetProperties( 1, rgPropertySets );
			if (FAILED(hr))
				return hr;
		}

		return m_spInit->Initialize();
	}
	// Get the initialization string from the currently open data source. The returned string
	// must be CoTaskMemFree'd when finished with.
	HRESULT GetInitializationString(BSTR* pInitializationString, bool bIncludePassword=false) throw()
	{
		// If the datasource isn't open then we're not going to get an init string
		ATLASSUME(m_spInit != NULL);
		CComPtr<IDataInitialize> spDataInit;
		LPOLESTR    szInitString;

		HRESULT hr = CoCreateInstance(__uuidof(MSDAINITIALIZE), NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IDataInitialize), (void**)&spDataInit);
		if (FAILED(hr))
			return hr;

		hr = spDataInit->GetInitializationString(m_spInit, bIncludePassword, &szInitString);

		if (SUCCEEDED(hr))
		{
			*pInitializationString = ::SysAllocString(szInitString);
			if (*pInitializationString == NULL && szInitString != NULL)
				hr = E_OUTOFMEMORY;
			CoTaskMemFree(szInitString);
		}

		return hr;
	}
	HRESULT GetProperties(ULONG ulPropIDSets, const DBPROPIDSET* pPropIDSet,
				ULONG* pulPropertySets, DBPROPSET** ppPropsets) const throw()
	{
		CComPtr<IDBProperties> spProperties;

		// Check that we are connected
		ATLASSUME(m_spInit != NULL);

		HRESULT hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
		if (FAILED(hr))
			return hr;

		hr = spProperties->GetProperties(ulPropIDSets, pPropIDSet, pulPropertySets,
				ppPropsets);
		return hr;
	}

	HRESULT GetProperty(const GUID& guid, DBPROPID propid, VARIANT* pVariant) const throw()
	{
		ATLASSERT(pVariant != NULL);
		CComPtr<IDBProperties> spProperties;

		// Check that we are connected
		ATLASSUME(m_spInit != NULL);

		HRESULT hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
		if (FAILED(hr))
			return hr;

		CDBPropIDSet set(guid);
		if(!set.AddPropertyID(propid))
		{
			return E_FAIL;
		}
		CComHeapPtr<DBPROPSET> spPropSet;
		ULONG ulPropSet = 0;
		hr = spProperties->GetProperties(1, &set, &ulPropSet, &spPropSet);
		if (FAILED(hr))
			return hr;

		ATLASSERT(ulPropSet == 1);
		hr = VariantCopy(pVariant, &(spPropSet->rgProperties[0].vValue));
		VariantClear(&(spPropSet->rgProperties[0].vValue));
		CoTaskMemFree(spPropSet->rgProperties);

		return hr;
	}
	void Close() throw()
	{
		m_spInit.Release();
	}

// Implementation
	HRESULT OpenFromIDBProperties(IDBProperties* pIDBProperties) throw()
	{
		CComPtr<IPersist> spPersist;
		CLSID   clsid;
		HRESULT hr;

		hr = pIDBProperties->QueryInterface(__uuidof(IPersist), (void**)&spPersist);
		if (FAILED(hr))
			return hr;

		spPersist->GetClassID(&clsid);

		ULONG       ulPropSets=0;
		CDBPropSet* pPropSets=NULL;
		pIDBProperties->GetProperties(0, NULL, &ulPropSets, (DBPROPSET**)&pPropSets);

		hr = Open(clsid, &pPropSets[0], ulPropSets);

		for (ULONG i=0; i < ulPropSets; i++)
			(pPropSets+i)->~CDBPropSet();
		CoTaskMemFree(pPropSets);

		return hr;
	}

	HRESULT OpenWithNameUserPassword(LPCTSTR pName, LPCTSTR pUserName, LPCTSTR pPassword, long nInitMode = 0) throw()
	{
		ATLASSUME(m_spInit != NULL);
		CComPtr<IDBProperties>  spProperties;
		HRESULT                 hr;

		hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
		if (FAILED(hr))
			return hr;

		// Set connection properties
		CDBPropSet propSet(DBPROPSET_DBINIT);

		// Add Datbase name, User name and Password
		if (pName != NULL)
		{
			if(!propSet.AddProperty(DBPROP_INIT_DATASOURCE, pName))
			{
				return E_FAIL;
			}
		}

		if (pUserName != NULL)
		{
			if(!propSet.AddProperty(DBPROP_AUTH_USERID, pUserName))
			{
				return E_FAIL;
			}
		}

		if (pPassword != NULL)
		{
			if(!propSet.AddProperty(DBPROP_AUTH_PASSWORD, pPassword))
			{
				return E_FAIL;
			}
		}

		if (nInitMode)
		{
			if(!propSet.AddProperty(DBPROP_INIT_MODE, nInitMode))
			{
				return E_FAIL;
			}
		}

		hr = spProperties->SetProperties(1, &propSet);
		if (FAILED(hr))
			return hr;

		// Initialize the provider
		return m_spInit->Initialize();
	}
	HRESULT OpenWithProperties(DBPROPSET* pPropSet, ULONG nPropertySets=1) throw()
	{
		ATLASSUME(m_spInit != NULL);

		// Set the properties if there are some to set
		if (pPropSet != NULL)
		{
			CComPtr<IDBProperties>  spProperties;
			HRESULT                 hr;

			hr = m_spInit->QueryInterface(__uuidof(IDBProperties), (void**)&spProperties);
			if (FAILED(hr))
				return hr;

			hr = spProperties->SetProperties(nPropertySets, pPropSet);
			if (FAILED(hr))
				return hr;
		}

		// Initialize the provider
		return m_spInit->Initialize();
	}

	CComPtr<IDBInitialize>  m_spInit;
};


///////////////////////////////////////////////////////////////////////////
// class CSession

class CSession
{
public:
	~CSession()
	{
		Close();
	}

	// Create a session on the passed datasource
	HRESULT Open(const CDataSource& ds, DBPROPSET *pPropSet = NULL, ULONG ulPropSets = 0) throw()
	{
		CComPtr<IDBCreateSession> spSession;

		// Check we have connected to the database
		ATLASSERT(ds.m_spInit != NULL);

		HRESULT hr = ds.m_spInit->QueryInterface(__uuidof(IDBCreateSession), (void**)&spSession);
		if (FAILED(hr))
			return hr;

		hr = spSession->CreateSession(NULL, __uuidof(IOpenRowset), (IUnknown**)&m_spOpenRowset);

		if( pPropSet != NULL && SUCCEEDED(hr) && m_spOpenRowset != NULL )
		{
			// If the user didn't specify the default parameter, use one
			if (pPropSet != NULL && ulPropSets == 0)
				ulPropSets = 1;

			CComPtr<ISessionProperties> spSessionProperties;
			hr = m_spOpenRowset->QueryInterface(__uuidof(ISessionProperties), (void**)&spSessionProperties);
			if(FAILED(hr))
				return hr;

			hr = spSessionProperties->SetProperties( ulPropSets, pPropSet );
		}
		return hr;
	}

	// Close the session
	void Close() throw()
	{
		m_spOpenRowset.Release();
	}
	// Start a transaction
	HRESULT StartTransaction(ISOLEVEL isoLevel = ISOLATIONLEVEL_READCOMMITTED, ULONG isoFlags = 0,
		ITransactionOptions* pOtherOptions = NULL, ULONG* pulTransactionLevel = NULL) const throw()
	{
		ATLASSUME(m_spOpenRowset != NULL);
		CComPtr<ITransactionLocal> spTransactionLocal;
		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransactionLocal);

		if (SUCCEEDED(hr))
			hr = spTransactionLocal->StartTransaction(isoLevel, isoFlags, pOtherOptions, pulTransactionLevel);

		return hr;
	}
	// Abort the current transaction
	HRESULT Abort(BOID* pboidReason = NULL, BOOL bRetaining = FALSE, BOOL bAsync = FALSE) const throw()
	{
		ATLASSUME(m_spOpenRowset != NULL);
		CComPtr<ITransaction> spTransaction;
		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransaction);

		if (SUCCEEDED(hr))
			hr = spTransaction->Abort(pboidReason, bRetaining, bAsync);

		return hr;
	}
	// Commit the current transaction
	HRESULT Commit(BOOL bRetaining = FALSE, DWORD grfTC = XACTTC_SYNC, DWORD grfRM = 0) const throw()
	{
		ATLASSUME(m_spOpenRowset != NULL);
		CComPtr<ITransaction> spTransaction;
		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransaction);

		if (SUCCEEDED(hr))
			hr = spTransaction->Commit(bRetaining, grfTC, grfRM);

		return hr;
	}
	// Get information for the current transaction
	HRESULT GetTransactionInfo(XACTTRANSINFO* pInfo) const throw()
	{
		ATLASSUME(m_spOpenRowset != NULL);
		CComPtr<ITransaction> spTransaction;
		HRESULT hr = m_spOpenRowset->QueryInterface(&spTransaction);

		if (SUCCEEDED(hr))
			hr = spTransaction->GetTransactionInfo(pInfo);

		return hr;
	}
// Implementation
	CComPtr<IOpenRowset> m_spOpenRowset;
};

///////////////////////////////////////////////////////////////////////////
// class CDataConnection

class CDataConnection
{
public:
	CDataConnection()
	{
	}

	CDataConnection(const CDataConnection &ds)
	{
		Copy(ds);
	}

	CDataConnection& Copy(const CDataConnection &ds) throw()
	{
		m_source.m_spInit = ds.m_source.m_spInit;
		m_session.m_spOpenRowset = ds.m_session.m_spOpenRowset;
		return *this;
	}

	HRESULT Open(LPCOLESTR szInitString) throw()
	{
		HRESULT hr = E_FAIL;
		hr = m_source.OpenFromInitializationString(szInitString);
		if (hr == S_OK)
		{
			hr = m_session.Open(m_source);
		}
		return hr;
	}

	HRESULT OpenNewSession(CSession &session) throw()
	{
		return session.Open(m_source);
	}

	operator const CSession&() throw()
	{
		return m_session;
	}

	operator const CSession*() throw()
	{
		return &m_session;
	}

	operator const CDataSource&() throw()
	{
		return m_source;
	}

	operator const CDataSource*() throw()
	{
		return &m_source;
	}

	CDataConnection& operator=(const CDataConnection &ds) throw()
	{
		return Copy(ds);
	}

	operator BOOL() throw()
	{
		return m_session.m_spOpenRowset != NULL ? TRUE : FALSE;
	}

	operator bool() throw()
	{
		return m_session.m_spOpenRowset != NULL ? true : false;
	}

	void CloseDataSource() throw()
	{
		m_session.Close();
		m_source.Close();
	} 

	CSession m_session;
	CDataSource m_source;
};

///////////////////////////////////////////////////////////////////////////
// CTable

template <class TAccessor = CNoAccessor, template <typename T> class TRowset = CRowset>
class CTable : public CAccessorRowset<TAccessor, TRowset>
{
public:
	// Open a rowset on the passed name
	HRESULT Open(const CSession& session, LPCWSTR wszTableName, DBPROPSET* pPropSet = NULL, 
				ULONG ulPropSets = 0) throw()
	{
		DBID    idTable;

		idTable.eKind           = DBKIND_NAME;
		idTable.uName.pwszName  = (LPOLESTR)wszTableName;

		return Open(session, idTable, pPropSet, ulPropSets);
	}

	HRESULT Open(const CSession& session, LPCSTR szTableName, DBPROPSET* pPropSet = NULL, 
				ULONG ulPropSets = 0) throw()
	{
		return Open( session, CComBSTR(szTableName), pPropSet, ulPropSets );
	}

	// Open the a rowset on the passed DBID
	HRESULT Open(const CSession& session, DBID& dbid, DBPROPSET* pPropSet = NULL,
				ULONG ulPropSets = 0) throw()
	{
		// Check the session is valid
		ATLASSERT(session.m_spOpenRowset != NULL);
		HRESULT hr;

		// If the user didn't specify the default parameter, use one for 
		// backward compatibility
		if (pPropSet != NULL && ulPropSets == 0)
			ulPropSets = 1;

		hr = session.m_spOpenRowset->OpenRowset(NULL, &dbid, NULL, GetIID(),
			ulPropSets, pPropSet, (IUnknown**)GetInterfacePtr());
		if (SUCCEEDED(hr))
		{
			SetupOptionalRowsetInterfaces();

			// If we have output columns then bind
			if (_OutputColumnsClass::HasOutputColumns())
				hr = Bind();
		}

		return hr;
	}
};

#if (OLEDBVER < 0x0150)
#define DBGUID_DEFAULT DBGUID_DBSQL
#endif


///////////////////////////////////////////////////////////////////////////
// CCommandBase

class CCommandBase
{
public:
	CCommandBase()
	{
		m_hParameterAccessor = NULL;
	}

	~CCommandBase()
	{
		ReleaseCommand();
	}
	// Create the command
	HRESULT CreateCommand(const CSession& session) throw()
	{
		// Before creating the command, release the old one if necessary.
		ReleaseCommand();

		// Check the session is valid
		ATLASSERT(session.m_spOpenRowset != NULL);

		CComPtr<IDBCreateCommand> spCreateCommand;

		HRESULT hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBCreateCommand), (void**)&spCreateCommand);
		if (FAILED(hr))
			return hr;

		return spCreateCommand->CreateCommand(NULL, __uuidof(ICommand), (IUnknown**)&m_spCommand);
	}
	// Prepare the command
	HRESULT Prepare(ULONG cExpectedRuns = 0) throw()
	{
		CComPtr<ICommandPrepare> spCommandPrepare;
		HRESULT hr = m_spCommand->QueryInterface(&spCommandPrepare);
		if (SUCCEEDED(hr))
			hr = spCommandPrepare->Prepare(cExpectedRuns);

		return hr;
	}
	// Unprepare the command
	HRESULT Unprepare() throw()
	{
		CComPtr<ICommandPrepare> spCommandPrepare;
		HRESULT hr = m_spCommand->QueryInterface(&spCommandPrepare);
		if (SUCCEEDED(hr))
			hr = spCommandPrepare->Unprepare();

		return hr;
	}
	// Create the command and set the command text
	HRESULT Create(const CSession& session, LPCWSTR wszCommand,
		REFGUID guidCommand = DBGUID_DEFAULT) throw()
	{
		HRESULT hr;

		hr = CreateCommand(session);
		if (SUCCEEDED(hr))
		{
			CComPtr<ICommandText> spCommandText;
			hr = m_spCommand->QueryInterface(&spCommandText);
			if (SUCCEEDED(hr))
				hr = spCommandText->SetCommandText(guidCommand, wszCommand);
		}
		return hr;
	}
	HRESULT Create(const CSession& session, LPCSTR szCommand,
		REFGUID guidCommand = DBGUID_DEFAULT) throw()
	{
		return Create( session, CComBSTR(szCommand), guidCommand );
	}

	// Release the command
	void ReleaseCommand() throw()
	{
		// Release the parameter accessor if necessary, before releasing the command
		if (m_hParameterAccessor != NULL && m_spCommand != NULL )
		{
			CComPtr<IAccessor> spAccessor;
			HRESULT hr = m_spCommand->QueryInterface(&spAccessor);
			if (SUCCEEDED(hr))
			{
				spAccessor->ReleaseAccessor(m_hParameterAccessor, NULL); \
				m_hParameterAccessor = NULL;
			}
		}
		m_spCommand.Release();
	}
	// Get the parameter information from the command
	HRESULT GetParameterInfo(DB_UPARAMS* pParams, DBPARAMINFO** ppParamInfo,
				OLECHAR** ppNamesBuffer) throw()
	{
		CComPtr<ICommandWithParameters> spCommandParameters;
		HRESULT hr = m_spCommand->QueryInterface(&spCommandParameters);
		if (SUCCEEDED(hr))
		{
			// Get the parameter information
			hr = spCommandParameters->GetParameterInfo(pParams, ppParamInfo,
					ppNamesBuffer);
		}
		return hr;
	}
	// Set the parameter information for the command
	HRESULT SetParameterInfo(DB_UPARAMS ulParams, const DBORDINAL* pOrdinals,
				const DBPARAMBINDINFO* pParamInfo) throw()
	{
		CComPtr<ICommandWithParameters> spCommandParameters;
		HRESULT hr = m_spCommand->QueryInterface(&spCommandParameters);
		if (SUCCEEDED(hr))
		{
			// Set the parameter information
			hr = spCommandParameters->SetParameterInfo(ulParams, pOrdinals,
				pParamInfo);
		}
		return hr;
	}

	CComPtr<ICommand>   m_spCommand;
	HACCESSOR           m_hParameterAccessor;
};

// Used to turn on multiple result set support in CCommand
class CMultipleResults
{
public:
	bool UseMultipleResults() throw() { return true; }
	IMultipleResults** GetMultiplePtrAddress() throw() { return &m_spMultipleResults.p; }
	IMultipleResults* GetMultiplePtr() throw() { return m_spMultipleResults; }

	CComPtr<IMultipleResults> m_spMultipleResults;
};

// Used to turn off multiple result set support in CCommand
class CNoMultipleResults
{
public:
	bool UseMultipleResults() throw() { return false; }
	IMultipleResults** GetMultiplePtrAddress() throw() { return NULL; }
	IMultipleResults* GetMultiplePtr() throw() { return NULL; }
};


///////////////////////////////////////////////////////////////////////////
// CCommand

template <class TAccessor = CNoAccessor, template <typename T> class TRowset = CRowset, 
			class TMultiple = CNoMultipleResults>
class CCommand :
	public CAccessorRowset<TAccessor, TRowset>,
	public CCommandBase,
	public TMultiple
{
public:
	// Create a command on the session and execute it
	HRESULT Open(const CSession& session, LPCWSTR wszCommand,
		DBPROPSET *pPropSet = NULL, DBROWCOUNT* pRowsAffected = NULL,
		REFGUID guidCommand = DBGUID_DEFAULT, bool bBind = true,
		ULONG ulPropSets = 0) throw()
	{
		HRESULT hr;
		if (wszCommand == NULL)
		{
			hr = _CommandClass::GetDefaultCommand(&wszCommand);
			if (FAILED(hr))
				return hr;
		}
		hr = Create(session, wszCommand, guidCommand);
		if (FAILED(hr))
			return hr;

		return Open(pPropSet, pRowsAffected, bBind, ulPropSets);
	}

	HRESULT Open(const CSession& session, LPCSTR szCommand,
		DBPROPSET *pPropSet = NULL, DBROWCOUNT* pRowsAffected = NULL,
		REFGUID guidCommand = DBGUID_DEFAULT, bool bBind = true,
		ULONG ulPropSets = 0) throw()
	{
		if( szCommand == NULL )
		{
			return Open( session, (LPCWSTR)NULL, pPropSet, pRowsAffected, guidCommand, bBind, ulPropSets );
		}
		else
		{
			return Open( session, CComBSTR(szCommand), pPropSet, pRowsAffected, guidCommand, bBind, ulPropSets );
		}
	}

	// this version of Open, takes an INT instead of a string pointer.
	// this is to resolve an ambiguity when calling 
	// Open( session, NULL, ... ) or Open( session )
	HRESULT Open(const CSession& session, INT szCommand = NULL,
		DBPROPSET *pPropSet = NULL, DBROWCOUNT* pRowsAffected = NULL,
		REFGUID guidCommand = DBGUID_DEFAULT, bool bBind = true,
		ULONG ulPropSets = 0) throw()
	{
		szCommand;
		ATLASSERT( szCommand == NULL );

		return Open( session, (LPCWSTR)NULL, pPropSet, pRowsAffected, guidCommand, bBind, ulPropSets );
	}

	// Used if you have previously created the command
	HRESULT Open(DBPROPSET *pPropSet = NULL, DBROWCOUNT* pRowsAffected = NULL, 
		bool bBind = true, ULONG ulPropSets = 0) throw()
	{
		HRESULT     hr;
		DBPARAMS    params;
		DBPARAMS    *pParams;

		// Bind the parameters if we have some
		if (_ParamClass::HasParameters())
		{
			// Bind the parameters in the accessor if they haven't already been bound
			hr = BindParameters(&m_hParameterAccessor, m_spCommand, &params.pData);
			if (FAILED(hr))
				return hr;

			// Setup the DBPARAMS structure
			params.cParamSets = 1;
			params.hAccessor = m_hParameterAccessor;
			pParams = &params;
		}
		else
			pParams = NULL;

		return ExecuteAndBind(pParams, pPropSet, pRowsAffected, bBind, ulPropSets);
	}
	// Get the next rowset when using multiple result sets
	HRESULT GetNextResult(DBROWCOUNT* pulRowsAffected, bool bBind = true) throw()
	{
		// This function should only be called if CMultipleResults is being
		// used as the third template parameter
		ATLASSERT(GetMultiplePtrAddress() != NULL);

		// If user calls GetNextResult but the interface is not available
		// return E_FAIL.
		if (GetMultiplePtr() == NULL)
			return E_FAIL;

		// Close the existing rowset in preparation for opening the next one
		Close();

		HRESULT hr = GetMultiplePtr()->GetResult(NULL, 0, GetIID(),
			pulRowsAffected, (IUnknown**)GetInterfacePtr());
		if (FAILED(hr))
			return hr;

		if (bBind && GetInterface() != NULL)
			return Bind();
		else
			return hr;
	}

// Implementation
	HRESULT ExecuteAndBind(DBPARAMS* pParams, DBPROPSET* pPropSet = NULL, 
		DBROWCOUNT* pRowsAffected = NULL, bool bBind = true, ULONG ulPropSets = 0) throw()
	{
		HRESULT hr = Execute((IUnknown**)GetInterfacePtr(), pParams, pPropSet, 
							pRowsAffected, ulPropSets);
		if (FAILED(hr))
			return hr;

		// Only bind if we have been asked to and we have output columns
		if (bBind && _OutputColumnsClass::HasOutputColumns())
		{
			// for dynamic accessors we don't want to automatically call Bind if we got no rowset in return
			if( NoBindOnNullRowset() && GetInterface() == NULL )
				return hr;
			else
				return Bind();
		}
		else
			return hr;

	}

	HRESULT Execute(IRowset** ppRowset, DBPARAMS* pParams, DBPROPSET *pPropSet, 
		DBROWCOUNT* pRowsAffected, ULONG ulPropSets = 0) throw()
	{
		return Execute( (IUnknown**)ppRowset, pParams, pPropSet, pRowsAffected, ulPropSets );
	}

	HRESULT Execute(IUnknown** ppInterface, DBPARAMS* pParams, DBPROPSET *pPropSet, 
		DBROWCOUNT* pRowsAffected, ULONG ulPropSets = 0) throw()
	{
		HRESULT hr;

		// Specify the properties if we have some
		if (pPropSet)
		{
			// For backward compatibility, if the default parameter is not
			// specified, then set it to one if a property set exists
			if (ulPropSets == 0)
				ulPropSets = 1;

			CComPtr<ICommandProperties> spCommandProperties;
			hr = m_spCommand->QueryInterface(&spCommandProperties);
			if (FAILED(hr))
				return hr;

			hr = spCommandProperties->SetProperties(ulPropSets, pPropSet);
			if (FAILED(hr))
				return hr;
		}

		// If the user want the rows affected then return it back, otherwise
		// just point to our local variable here.
		DBROWCOUNT nAffected, *pAffected;
		if (pRowsAffected)
			pAffected = pRowsAffected;
		else
			pAffected = &nAffected;

		if (UseMultipleResults())
		{
			hr = m_spCommand->Execute(NULL, __uuidof(IMultipleResults), pParams,
				pAffected, (IUnknown**)GetMultiplePtrAddress());

			if (SUCCEEDED(hr))
				hr = GetNextResult(pAffected, false);
			else
				// If we can't get IMultipleResults then just try to get IRowset
				hr = m_spCommand->Execute(NULL, GetIID(), pParams, pAffected,
					ppInterface);
		}
		else
		{
			hr = m_spCommand->Execute(NULL, GetIID(), pParams, pAffected,
				ppInterface);
		}
		if (SUCCEEDED(hr))
			SetupOptionalRowsetInterfaces();

		return hr;
	}
};


// This class can be used to implement the IRowsetNotify interface.
// It is supplied so that if you only want to implement one of the
// notifications you don't have to supply empty functions for the
// other methods.
class ATL_NO_VTABLE IRowsetNotifyImpl : public IRowsetNotify
{
public:
	STDMETHOD(OnFieldChange)(
			/* [in] */ IRowset* /* pRowset */,
			/* [in] */ HROW /* hRow */,
			/* [in] */ DBORDINAL /* cColumns */,
			/* [size_is][in] */ DBORDINAL /* rgColumns*/ [] ,
			/* [in] */ DBREASON /* eReason */,
			/* [in] */ DBEVENTPHASE /* ePhase */,
			/* [in] */ BOOL /* fCantDeny */)
	{
		ATLTRACENOTIMPL(_T("IRowsetNotifyImpl::OnFieldChange"));
	}
	STDMETHOD(OnRowChange)(
			/* [in] */ IRowset* /* pRowset */,
			/* [in] */ DBCOUNTITEM /* cRows */,
			/* [size_is][in] */ const HROW /* rghRows*/ [] ,
			/* [in] */ DBREASON /* eReason */,
			/* [in] */ DBEVENTPHASE /* ePhase */,
			/* [in] */ BOOL /* fCantDeny */)
	{
		ATLTRACENOTIMPL(_T("IRowsetNotifyImpl::OnRowChange"));
	}
	STDMETHOD(OnRowsetChange)(
		/* [in] */ IRowset* /* pRowset */,
		/* [in] */ DBREASON /* eReason */,
		/* [in] */ DBEVENTPHASE /* ePhase */,
		/* [in] */ BOOL /* fCantDeny*/)
	{
		ATLTRACENOTIMPL(_T("IRowsetNotifyImpl::OnRowsetChange"));
	}
};


}; //namespace ATL

#pragma pack(pop)
#pragma warning(pop)

#endif // __ATLDBCLI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atldb.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLDB_H__
#define __ATLDB_H__

#pragma once

#ifdef _WIN32_WCE
	#error atldb.h is not supported on Windows CE (_WIN32_WCE is defined)
#endif //_WIN32_WCE
#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable: 4702) // unreachable code
#endif //!_ATL_NO_PRAGMA_WARNINGS

// OLE DB Provider Support

// Interface Impl Classes
//
// Data Source Object
//
// -Mandatory Interfaces:
//	IDBCreateSession
//	IDBInitialize
//	IDBProperties
//	IPersist
//
// Session Object
//
// -Mandatory Interfaces:
//	IGetDataSource
//	IOpenRowset
//	ISessionProperties
//
// -Optional Interfaces:
//	IDBCreateCommand
//	IDBSchemaRowset
//
// Rowset Object
//
// -Mandatory Interfaces:
//	IAccessor
//	IColumnsInfo
//	IConvertType
//	IRowset
//	IRowsetInfo
//
// -Optional Interfaces:
//	IRowsetIdentity
//
// Command Object
//
// -Mandatory Interfaces:
// ICommand)
// IAccessor)
// ICommandProperties
// ICommandText - derives from ICommand
// IColumnsInfo
// IConvertType

#include <oledb.h>
#include <limits.h>
#include <oledberr.h>
#include <msdadc.h>
#include <atldbcli.h>
#include <atlcoll.h>

#pragma warning(disable: 4244)


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

inline DBROWCOUNT AbsVal( DBROWCOUNT val )
{
	if( val < 0 )
		return -val;
	else
		return val;
}

///////////////////////////////////////////////////////////////////////////
// Forwards 
template <class T> class CUtlPropInfo;
class CColumnIds;

///////////////////////////////////////////////////////////////////////////
// Additional Property Flag needed internally
const int	DBPROPFLAGS_CHANGE	= 0x40000000;

///////////////////////////////////////////////////////////////////////////
// ATL Provider Property Definitions
#define ATLDB_NO_STRING		0x01000011	// Arbitrary value for AtlDumpProperty

///////////////////////////////////////////////////////////////////////////
// ATL Provider Property Debugging Support

inline void WINAPI AtlDumpPropsetIID(REFIID iid, DWORD dwStatus)
{
	USES_CONVERSION_EX;
	// Handle the most common ones
	TCHAR szPropertySetName[100];

	if(InlineIsEqualGUID(iid, DBPROPSET_DATASOURCEALL))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_DATASOURCEALL -"));
	}
	else if(InlineIsEqualGUID(iid, DBPROPSET_DATASOURCEINFOALL))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_DATASOURCEINFOALL -"));
	}
	else if(InlineIsEqualGUID(iid, DBPROPSET_ROWSETALL))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_ROWSETALL -"));
	}
	else if(InlineIsEqualGUID(iid,DBPROPSET_DBINITALL))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_DBINITALL -"));
	}
	else if(InlineIsEqualGUID(iid,DBPROPSET_SESSIONALL))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_SESSIONALL -"));
	}
	if(InlineIsEqualGUID(iid, DBPROPSET_DATASOURCE))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_DATASOURCE -"));	
	}
	else if(InlineIsEqualGUID(iid, DBPROPSET_DATASOURCEINFO))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_DATASOURCEINFO -"));
	}
	else if(InlineIsEqualGUID(iid, DBPROPSET_ROWSET))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_ROWSET -"));
	}
	else if(InlineIsEqualGUID(iid,DBPROPSET_DBINIT))
	{		
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_DBINIT -"));
	}
	else if(InlineIsEqualGUID(iid,DBPROPSET_SESSION))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_SESSION -"));
	}
	else
	{
		LPOLESTR lpszName = NULL;
		if (SUCCEEDED(StringFromCLSID(iid, &lpszName)))
		{
			Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName), OLE2T_EX(lpszName, _ATL_SAFE_ALLOCA_DEF_THRESHOLD));
		}
		else
		{
			Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName), _T("Unknown DBPROPSET -"));
		}			
	}

	if (dwStatus & 0x04 /* GETPROP_ERRORSOCCURRED */)
	{
		Checked::tcscat_s(szPropertySetName, _countof(szPropertySetName), _T(" NOT FOUND\n"));
	}
	else
	{
		Checked::tcscat_s(szPropertySetName, _countof(szPropertySetName), _T(" FOUND\n"));
	}

	OutputDebugString(szPropertySetName);
}


inline void WINAPI AtlDumpProperty(DWORD dwPropertyID, DWORD dwStatus)
{
	TCHAR szProperty[100];
	TCHAR szStatus[24];

	switch(dwStatus)
	{
	case DBPROPSTATUS_OK:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("FOUND"));
		break;
	case DBPROPSTATUS_NOTSUPPORTED:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("NOT SUPPORTED"));
		break;
	case DBPROPSTATUS_BADVALUE:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("BAD VALUE"));
		break;
	case DBPROPSTATUS_BADOPTION:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("BAD OPTION"));
		break;
	case DBPROPSTATUS_BADCOLUMN:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("BAD COLUMN"));
		break;
	case DBPROPSTATUS_NOTALLSETTABLE:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("NOT ALL SETTABLE"));
		break;
	case DBPROPSTATUS_NOTSETTABLE:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("NOT SETTABLE"));
		break;
	case DBPROPSTATUS_NOTSET:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("NOT SET"));
		break;
	case DBPROPSTATUS_CONFLICTING:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("CONFLICTED"));
		break;
	case ATLDB_NO_STRING:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("WARNING!  NO RESOURCE STRING FOR THIS PROPERTY!  ADD IDS_<PROP_NAME>"));
		break;
	default:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("INDETERMINATE"));		
		break;
	}	

#if _SECURE_ATL && !defined(_ATL_MIN_CRT)
	_stprintf_s(szProperty, _countof(szProperty), _T("Property 0x%lxL -- %s\n"), dwPropertyID, szStatus);
#else
	wsprintf(szProperty, _T("Property 0x%lxL -- %s\n"), dwPropertyID, szStatus);
#endif
	OutputDebugString(szProperty);
}


///////////////////////////////////////////////////////////////////////////
// Defines for debugging properties

#ifdef _ATL_DEBUG_PROVIDER_PROPS
#define _ATLDUMPPROPSETIID(iid, dwStatus)	AtlDumpPropsetIID(iid, dwStatus)
#define _ATLDUMPPROPERTY(dwPropertyID, dwStatus) AtlDumpProperty(dwPropertyID, dwStatus)
#else
#define _ATLDUMPPROPSETIID(iid, dwStatus)
#define _ATLDUMPPROPERTY(dwPropertyID, dwStatus)
#endif // _ATL_DEBUG_PROVIDER_PROPS

// -------------  STRUCTURE DEFINITIONS -----------------------------------

struct UPROPVAL
{
	DBPROPOPTIONS	dwOption;
	CColumnIds*		pCColumnIds;
	DWORD			dwFlags;
	VARIANT			vValue;
};

struct UPROPINFO
{
	DBPROPID	dwPropId;
	ULONG		ulIDS;
	VARTYPE		VarType;
	DBPROPFLAGS	dwFlags;
	union
	{
		DWORD_PTR dwVal;
		LPOLESTR szVal;
	};
	DBPROPOPTIONS dwOption;
};

struct UPROP
{
	ULONG			cPropIds;
	UPROPINFO**		rgpUPropInfo;
	UPROPVAL*		pUPropVal;
};

struct PROPCOLID
{
	DBID			dbidProperty;	// The column id information
	DBPROPOPTIONS	dwOption;		
	VARIANT			vValue;
};

typedef PROPCOLID* PPROPCOLID;

struct UPROPSET
{
	const GUID* pPropSet;
	ULONG cUPropInfo;
	UPROPINFO* pUPropInfo;
	DWORD dwFlags;
	bool bIsChained;
};

struct ATLBINDINGS
{
	DBBINDING* pBindings;
	DWORD dwRef;//DBREFCOUNT dwRef;
	DBCOUNTITEM cBindings;
	DBACCESSORFLAGS dwAccessorFlags;
};

struct ATLCOLUMNINFO
{
	LPOLESTR pwszName;
	ITypeInfo *pTypeInfo;
	DBORDINAL iOrdinal;
	DBCOLUMNFLAGS dwFlags;
	DBLENGTH ulColumnSize;
	DBTYPE wType;
	BYTE bPrecision;
	BYTE bScale;
	DBID columnid;
	DBBYTEOFFSET cbOffset;
};

//
// The following very large sections of defines are to implement auto determination
// of Property map constants based on a stringized prop name.  There is one set for
// Type (VT_), one for Init Value, and one for Property flags.
//

#define ABORTPRESERVE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define ACTIVESESSIONS_Flags  ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define APPENDONLY_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define ASYNCTXNABORT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define ASYNCTXNCOMMIT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define AUTH_CACHE_AUTHINFO_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_ENCRYPT_PASSWORD_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_INTEGRATED_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_MASK_PASSWORD_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_PASSWORD_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define AUTH_PERSIST_ENCRYPTED_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define AUTH_PERSIST_SENSITIVE_AUTHINFO_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define AUTH_USERID_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define BLOCKINGSTORAGEOBJECTS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define BOOKMARKS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE)
#define BOOKMARKSKIPPED_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE) 
#define BOOKMARKTYPE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE) 
#define BYREFACCESSORS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define CACHEDEFERRED_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define CANFETCHBACKWARDS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define CANHOLDROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define CANSCROLLBACKWARDS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define CATALOGLOCATION_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define CATALOGTERM_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define CATALOGUSAGE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define CHANGEINSERTEDROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_CHANGE )
#define COL_AUTOINCREMENT_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define COL_DEFAULT_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define COL_DESCRIPTION_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define COL_FIXEDLENGTH_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define COL_NULLABLE_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define COL_PRIMARYKEY_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define COL_UNIQUE_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define COLUMNDEFINITION_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define COLUMNRESTRICT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define COMMANDTIMEOUT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COMMITPRESERVE_Flags ( DBPROPFLAGS_ROWSET| DBPROPFLAGS_READ | DBPROPFLAGS_WRITE) 
#define CONCATNULLBEHAVIOR_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define CURRENTCATALOG_Flags ( DBPROPFLAGS_DATASOURCE | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define DATASOURCENAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define DATASOURCEREADONLY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define DBMSNAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define DBMSVER_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define DEFERRED_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define DELAYSTORAGEOBJECTS_Flags  ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define DSOTHREADMODEL_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define GROUPBY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define HETEROGENEOUSTABLES_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define IAccessor_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IColumnsInfo_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define IColumnsRowset_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define IConnectionPointContainer_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE) 
#define IConvertType_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define IRowset_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowsetChange_Flags  ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define IRowsetIdentity_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define IRowsetIndex_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define IRowsetInfo_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define IRowsetLocate_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE) 
#define IRowsetResynch_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define IRowsetScroll_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE) 
#define IRowsetUpdate_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE) 
#define ISupportErrorInfo_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define ILockBytes_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define ISequentialStream_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IStorage_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define IStream_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define IDENTIFIERCASE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define IMMOBILEROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define INDEX_AUTOUPDATE_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define INDEX_CLUSTERED_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define INDEX_FILLFACTOR_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define INDEX_INITIALSIZE_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define INDEX_NULLCOLLATION_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define INDEX_NULLS_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define INDEX_PRIMARYKEY_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define INDEX_SORTBOOKMARKS_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define INDEX_TEMPINDEX_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define INDEX_TYPE_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define INDEX_UNIQUE_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define INIT_DATASOURCE_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_HWND_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_IMPERSONATION_LEVEL_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_LCID_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_LOCATION_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_MODE_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_PROMPT_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_PROTECTION_LEVEL_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_PROVIDERSTRING_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_TIMEOUT_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define LITERALBOOKMARKS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define LITERALIDENTITY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define MAXINDEXSIZE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define MAXOPENROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define MAXPENDINGROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE) 
#define MAXROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define MAXROWSIZE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define MAXROWSIZEINCLUDESBLOB_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define MAXTABLESINSELECT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define MAYWRITECOLUMN_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define MEMORYUSAGE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define MULTIPLEPARAMSETS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define MULTIPLERESULTS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define MULTIPLESTORAGEOBJECTS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define MULTITABLEUPDATE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define NOTIFICATIONGRANULARITY_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE) 
#define NOTIFICATIONPHASES_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define NOTIFYCOLUMNSET_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define NOTIFYROWDELETE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define NOTIFYROWFIRSTCHANGE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define NOTIFYROWINSERT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define NOTIFYROWRESYNCH_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define NOTIFYROWSETRELEASE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define NOTIFYROWSETFETCHPOSITIONCHANGE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define NOTIFYROWUNDOCHANGE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define NOTIFYROWUNDODELETE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define NOTIFYROWUNDOINSERT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define NOTIFYROWUPDATE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define NULLCOLLATION_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define OLEOBJECTS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define ORDERBYCOLUMNSINSELECT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define ORDEREDBOOKMARKS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define OTHERINSERT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define OTHERUPDATEDELETE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define OUTPUTPARAMETERAVAILABILITY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define OWNINSERT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define OWNUPDATEDELETE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define PERSISTENTIDTYPE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define PREPAREABORTBEHAVIOR_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define PREPARECOMMITBEHAVIOR_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define PROCEDURETERM_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define PROVIDERNAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define PROVIDEROLEDBVER_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define PROVIDERVER_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define QUICKRESTART_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define QUOTEDIDENTIFIERCASE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define REENTRANTEVENTS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define REMOVEDELETED_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define REPORTMULTIPLECHANGES_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_CHANGE ) 
#define RETURNPENDINGINSERTS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define ROWRESTRICT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define ROWSETCONVERSIONSONCOMMAND_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define ROWTHREADMODEL_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define SCHEMATERM_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define SCHEMAUSAGE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define SERVERCURSOR_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define SESS_AUTOCOMMITISOLEVELS_Flags ( DBPROPFLAGS_SESSION | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE) 
#define SQLSUPPORT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define STRONGIDENTITY_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define STRUCTUREDSTORAGE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define SUBQUERIES_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define SUPPORTEDTXNDDL_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define SUPPORTEDTXNISOLEVELS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define SUPPORTEDTXNISORETAIN_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define TABLETERM_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
#define TBL_TEMPTABLE_Flags ( DBPROPFLAGS_TABLE | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) 
#define TRANSACTEDOBJECT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ ) 
#define UPDATABILITY_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define USERNAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ ) 
// 1.5
#define FILTERCOMPAREOPS_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ )
#define FINDCOMPAREOPS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IChapteredRowset_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IDBAsynchStatus_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IRowsetFind_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IRowsetView_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IViewChapter_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IViewFilter_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IViewRowset_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IViewSort_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_ASYNCH_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define MAXOPENCHAPTERS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MAXORSINFILTER_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ )
#define MAXSORTCOLUMNS_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ )
#define ROWSET_ASYNCH_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define SORTONINDEX_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ )
// 2.0
#define IMultipleResults_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define DATASOURCE_TYPE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
//MDPROP
#define AXES_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define FLATTENING_SUPPORT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_JOINCUBES_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NAMED_LEVELS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
//#define RANGEROWSET_Flags (  )
#define MDX_SLICER_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
//#define MDX_CUBEQUALIFICATION_Flags (  )
#define MDX_OUTERREFERENCE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_QUERYBYPROPERTY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_CASESUPPORT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_STRING_COMPOP_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_DESCFLAGS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_SET_FUNCTIONS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_MEMBER_FUNCTIONS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_NUMERIC_FUNCTIONS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_FORMULAS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define AGGREGATECELL_UPDATE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
//#define MDX_AGGREGATECELL_UPDATE_Flags (  )
#define MDX_OBJQUALIFICATION_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_NONMEASURE_EXPRESSONS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
// DBPROP
#define ACCESSORDER_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define BOOKMARKINFO_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define INIT_CATALOG_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define ROW_BULKOPS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) //!!!
#define PROVIDERFRIENDLYNAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define LOCKMODE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define MULTIPLECONNECTIONS_Flags ( DBPROPFLAGS_DATASOURCE | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define UNIQUEROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define SERVERDATAONINSERT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
//#define STORAGEFLAGS_Flags (  )
#define CONNECTIONSTATUS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define ALTERCOLUMN_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define COLUMNLCID_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ )
#define RESETDATASOURCE_Flags ( DBPROPFLAGS_DATASOURCE | DBPROPFLAGS_WRITE )
#define INIT_OLEDBSERVICES_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IRowsetRefresh_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define SERVERNAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define IParentRowset_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define HIDDENCOLUMNS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define PROVIDERMEMORY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define CLIENTCURSOR_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
// 2.1
#define TRUSTEE_USERNAME_Flags ( DBPROPFLAGS_TRUSTEE | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define TRUSTEE_AUTHENTICATION_Flags ( DBPROPFLAGS_TRUSTEE | DBPROPFLAGS_WRITE )
#define TRUSTEE_NEWAUTHENTICATION_Flags ( DBPROPFLAGS_TRUSTEE | DBPROPFLAGS_WRITE )
#define IRow_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IRowChange_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IRowSchemaChange_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IGetRow_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IScopedOperations_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IBindResource_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define ICreateRow_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_BINDFLAGS_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_LOCKOWNER_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define GENERATEURL_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
//#define IDBBinderProperties_Flags (  )
#define IColumnsInfo2_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
//#define IRegisterProvider_Flags (  )
#define IGetSession_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IGetSourceRow_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IRowsetCurrentIndex_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define OPENROWSETSUPPORT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define COL_ISLONG_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
// 2.5
#define COL_SEED_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COL_INCREMENT_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_GENERALTIMEOUT_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COMSERVICES_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
// 2.6
#define OUTPUTSTREAM_Flags ( DBPROPFLAGS_STREAM | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define OUTPUTENCODING_Flags ( DBPROPFLAGS_STREAM | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define TABLESTATISTICS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define SKIPROWCOUNTRESULTS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IRowsetBookmark_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define VISUALMODE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_WRITE )


#define ABORTPRESERVE_Type VT_BOOL 
#define ACTIVESESSIONS_Type VT_I4 
#define APPENDONLY_Type VT_BOOL 
#define ASYNCTXNABORT_Type VT_BOOL 
#define ASYNCTXNCOMMIT_Type VT_BOOL 
#define AUTH_CACHE_AUTHINFO_Type VT_BOOL 
#define AUTH_ENCRYPT_PASSWORD_Type VT_BOOL 
#define AUTH_INTEGRATED_Type VT_BSTR 
#define AUTH_MASK_PASSWORD_Type VT_BOOL 
#define AUTH_PASSWORD_Type VT_BSTR 
#define AUTH_PERSIST_ENCRYPTED_Type VT_BOOL 
#define AUTH_PERSIST_SENSITIVE_AUTHINFO_Type VT_BOOL
#define AUTH_USERID_Type VT_BSTR 
#define BLOCKINGSTORAGEOBJECTS_Type VT_BOOL 
#define BOOKMARKS_Type VT_BOOL 
#define BOOKMARKSKIPPED_Type VT_BOOL 
#define BOOKMARKTYPE_Type VT_I4 
#define BYREFACCESSORS_Type VT_BOOL 
#define CACHEDEFERRED_Type VT_BOOL 
#define CANFETCHBACKWARDS_Type VT_BOOL 
#define CANHOLDROWS_Type VT_BOOL 
#define CANSCROLLBACKWARDS_Type VT_BOOL 
#define CATALOGLOCATION_Type VT_I4 
#define CATALOGTERM_Type VT_BSTR 
#define CATALOGUSAGE_Type VT_I4 
#define CHANGEINSERTEDROWS_Type VT_BOOL 
#define COL_AUTOINCREMENT_Type VT_BOOL 
#define COL_DEFAULT_Type VT_BSTR 
#define COL_DESCRIPTION_Type VT_BSTR 
#define COL_FIXEDLENGTH_Type VT_BOOL 
#define COL_NULLABLE_Type VT_BOOL 
#define COL_PRIMARYKEY_Type VT_BOOL 
#define COL_UNIQUE_Type VT_BOOL 
#define COLUMNDEFINITION_Type VT_I4 
#define COLUMNRESTRICT_Type VT_BOOL 
#define COMMANDTIMEOUT_Type VT_I4 
#define COMMITPRESERVE_Type VT_BOOL 
#define CONCATNULLBEHAVIOR_Type VT_I4 
#define CURRENTCATALOG_Type VT_BSTR 
#define DATASOURCENAME_Type VT_BSTR 
#define DATASOURCEREADONLY_Type VT_BOOL 
#define DBMSNAME_Type VT_BSTR 
#define DBMSVER_Type VT_BSTR 
#define DEFERRED_Type VT_BOOL
#define DELAYSTORAGEOBJECTS_Type VT_BOOL 
#define DSOTHREADMODEL_Type VT_I4 
#define GROUPBY_Type VT_I4 
#define HETEROGENEOUSTABLES_Type VT_I4
#define IAccessor_Type VT_BOOL 
#define IColumnsInfo_Type VT_BOOL 
#define IColumnsRowset_Type VT_BOOL 
#define IConnectionPointContainer_Type VT_BOOL 
#define IConvertType_Type VT_BOOL 
#define IRowset_Type VT_BOOL 
#define IRowsetChange_Type VT_BOOL 
#define IRowsetIdentity_Type VT_BOOL 
#define IRowsetIndex_Type VT_BOOL 
#define IRowsetInfo_Type VT_BOOL 
#define IRowsetLocate_Type VT_BOOL 
#define IRowsetResynch_Type VT_BOOL 
#define IRowsetScroll_Type VT_BOOL 
#define IRowsetUpdate_Type VT_BOOL 
#define ISupportErrorInfo_Type VT_BOOL 
#define ILockBytes_Type VT_BOOL 
#define ISequentialStream_Type VT_BOOL 
#define IStorage_Type VT_BOOL 
#define IStream_Type VT_BOOL 
#define IDENTIFIERCASE_Type VT_I4 
#define IMMOBILEROWS_Type VT_BOOL 
#define INDEX_AUTOUPDATE_Type VT_BOOL 
#define INDEX_CLUSTERED_Type VT_BOOL 
#define INDEX_FILLFACTOR_Type VT_I4 
#define INDEX_INITIALSIZE_Type VT_I4 
#define INDEX_NULLCOLLATION_Type VT_I4 
#define INDEX_NULLS_Type VT_I4 
#define INDEX_PRIMARYKEY_Type VT_BOOL 
#define INDEX_SORTBOOKMARKS_Type VT_BOOL 
#define INDEX_TEMPINDEX_Type VT_BOOL 
#define INDEX_TYPE_Type VT_I4 
#define INDEX_UNIQUE_Type VT_BOOL 
#define INIT_DATASOURCE_Type VT_BSTR 
#define INIT_HWND_Type VT_I4 
#define INIT_IMPERSONATION_LEVEL_Type VT_I4 
#define INIT_LCID_Type VT_I4 
#define INIT_LOCATION_Type VT_BSTR 
#define INIT_MODE_Type VT_I4 
#define INIT_PROMPT_Type VT_I2 
#define INIT_PROTECTION_LEVEL_Type VT_I4 
#define INIT_PROVIDERSTRING_Type VT_BSTR 
#define INIT_TIMEOUT_Type VT_I4 
#define LITERALBOOKMARKS_Type VT_BOOL 
#define LITERALIDENTITY_Type VT_BOOL 
#define MAXINDEXSIZE_Type VT_I4 
#define MAXOPENROWS_Type VT_I4 
#define MAXPENDINGROWS_Type VT_I4 
#define MAXROWS_Type VT_I4 
#define MAXROWSIZE_Type VT_I4
#define MAXROWSIZEINCLUDESBLOB_Type VT_BOOL 
#define MAXTABLESINSELECT_Type VT_I4 
#define MAYWRITECOLUMN_Type VT_BOOL 
#define MEMORYUSAGE_Type VT_I4 
#define MULTIPLEPARAMSETS_Type VT_BOOL 
#define MULTIPLERESULTS_Type VT_I4 
#define MULTIPLESTORAGEOBJECTS_Type VT_BOOL  
#define MULTITABLEUPDATE_Type VT_BOOL 
#define NOTIFICATIONGRANULARITY_Type VT_I4
#define NOTIFICATIONPHASES_Type VT_I4 
#define NOTIFYCOLUMNSET_Type VT_I4 
#define NOTIFYROWDELETE_Type VT_I4 
#define NOTIFYROWFIRSTCHANGE_Type VT_I4 
#define NOTIFYROWINSERT_Type VT_I4 
#define NOTIFYROWRESYNCH_Type VT_I4 
#define NOTIFYROWSETRELEASE_Type VT_I4 
#define NOTIFYROWSETFETCHPOSITIONCHANGE_Type VT_I4 
#define NOTIFYROWUNDOCHANGE_Type VT_I4 
#define NOTIFYROWUNDODELETE_Type VT_I4 
#define NOTIFYROWUNDOINSERT_Type VT_I4 
#define NOTIFYROWUPDATE_Type VT_I4 
#define NULLCOLLATION_Type VT_I4 
#define OLEOBJECTS_Type VT_I4
#define ORDERBYCOLUMNSINSELECT_Type VT_BOOL 
#define ORDEREDBOOKMARKS_Type VT_BOOL 
#define OTHERINSERT_Type VT_BOOL 
#define OTHERUPDATEDELETE_Type VT_BOOL
#define OUTPUTPARAMETERAVAILABILITY_Type VT_I4 
#define OWNINSERT_Type VT_BOOL 
#define OWNUPDATEDELETE_Type VT_BOOL 
#define PERSISTENTIDTYPE_Type VT_I4 
#define PREPAREABORTBEHAVIOR_Type VT_I4 
#define PREPARECOMMITBEHAVIOR_Type VT_I4 
#define PROCEDURETERM_Type VT_BSTR 
#define PROVIDERNAME_Type VT_BSTR 
#define PROVIDEROLEDBVER_Type VT_BSTR 
#define PROVIDERVER_Type VT_BSTR 
#define QUICKRESTART_Type VT_BOOL 
#define QUOTEDIDENTIFIERCASE_Type VT_I4 
#define REENTRANTEVENTS_Type VT_BOOL 
#define REMOVEDELETED_Type VT_BOOL 
#define REPORTMULTIPLECHANGES_Type VT_BOOL 
#define RETURNPENDINGINSERTS_Type VT_BOOL 
#define ROWRESTRICT_Type VT_BOOL 
#define ROWSETCONVERSIONSONCOMMAND_Type VT_BOOL 
#define ROWTHREADMODEL_Type VT_I4 
#define SCHEMATERM_Type VT_BSTR 
#define SCHEMAUSAGE_Type VT_I4 
#define SERVERCURSOR_Type VT_BOOL
#define SESS_AUTOCOMMITISOLEVELS_Type VT_I4 
#define SQLSUPPORT_Type VT_I4 
#define STRONGIDENTITY_Type VT_BOOL 
#define STRUCTUREDSTORAGE_Type VT_I4 
#define SUBQUERIES_Type VT_I4 
#define SUPPORTEDTXNDDL_Type VT_I4 
#define SUPPORTEDTXNISOLEVELS_Type VT_I4 
#define SUPPORTEDTXNISORETAIN_Type VT_I4 
#define TABLETERM_Type VT_BSTR 
#define TBL_TEMPTABLE_Type VT_BOOL 
#define TRANSACTEDOBJECT_Type VT_BOOL 
#define UPDATABILITY_Type VT_I4 
#define USERNAME_Type VT_BSTR 
// 1.5
#define FILTERCOMPAREOPS_Type VT_I4
#define FINDCOMPAREOPS_Type VT_I4
#define IChapteredRowset_Type VT_BOOL
#define IDBAsynchStatus_Type VT_BOOL
#define IRowsetFind_Type VT_BOOL
#define IRowsetView_Type VT_BOOL
#define IViewChapter_Type VT_BOOL
#define IViewFilter_Type VT_BOOL
#define IViewRowset_Type VT_BOOL
#define IViewSort_Type VT_BOOL
#define INIT_ASYNCH_Type VT_I4
#define MAXOPENCHAPTERS_Type VT_I4
#define MAXORSINFILTER_Type VT_I4
#define MAXSORTCOLUMNS_Type VT_I4
#define ROWSET_ASYNCH_Type VT_I4
#define SORTONINDEX_Type VT_BOOL
// 2.0
#define IMultipleResults_Flags_Type VT_BOOL
#define DATASOURCE_TYPE_Flags_Type VT_I4
//MDPROP
#define AXES_Type VT_I4
#define FLATTENING_SUPPORT_Type VT_I4
#define MDX_JOINCUBES_Type VT_I4
#define NAMED_LEVELS_Type VT_I4
//#define RANGEROWSET_Type 
#define MDX_SLICER_Type VT_I4
//#define MDX_CUBEQUALIFICATION_Type 
#define MDX_OUTERREFERENCE_Type VT_I4
#define MDX_QUERYBYPROPERTY_Type VT_BOOL
#define MDX_CASESUPPORT_Type VT_I4
#define MDX_STRING_COMPOP_Type VT_I4
#define MDX_DESCFLAGS_Type VT_I4
#define MDX_SET_FUNCTIONS_Type VT_I4
#define MDX_MEMBER_FUNCTIONS_Type VT_I4
#define MDX_NUMERIC_FUNCTIONS_Type VT_I4
#define MDX_FORMULAS_Type VT_I4
#define AGGREGATECELL_UPDATE_Type VT_I4
//#define MDX_AGGREGATECELL_UPDATE_Type 
#define MDX_OBJQUALIFICATION_Type VT_I4
#define MDX_NONMEASURE_EXPRESSONS_Type VT_I4
// DBPROP
#define ACCESSORDER_Type VT_I4
#define BOOKMARKINFO_Type VT_I4
#define INIT_CATALOG_Type VT_BSTR
#define ROW_BULKOPS_Type VT_I4
#define PROVIDERFRIENDLYNAME_Type VT_BSTR
#define LOCKMODE_Type VT_I4
#define MULTIPLECONNECTIONS_Type VT_BOOL
#define UNIQUEROWS_Type VT_BOOL
#define SERVERDATAONINSERT_Type VT_BOOL
//#define STORAGEFLAGS_Type 
#define CONNECTIONSTATUS_Type VT_I4
#define ALTERCOLUMN_Type VT_I4
#define COLUMNLCID_Type VT_I4
#define RESETDATASOURCE_Type VT_I4
#define INIT_OLEDBSERVICES_Type VT_I4
#define IRowsetRefresh_Type VT_BOOL
#define SERVERNAME_Type VT_BSTR
#define IParentRowset_Type VT_BOOL
#define HIDDENCOLUMNS_Type VT_I4
#define PROVIDERMEMORY_Type VT_BOOL
#define CLIENTCURSOR_Type VT_BOOL
// 2.1
#define TRUSTEE_USERNAME_Type VT_BSTR
#define TRUSTEE_AUTHENTICATION_Type VT_BSTR
#define TRUSTEE_NEWAUTHENTICATION_Type VT_BSTR
#define IRow_Type VT_BOOL
#define IRowChange_Type VT_BOOL
#define IRowSchemaChange_Type VT_BOOL
#define IGetRow_Type VT_BOOL
#define IScopedOperations_Type VT_BOOL
#define IBindResource_Type VT_BOOL
#define ICreateRow_Type VT_BOOL
#define INIT_BINDFLAGS_Type VT_I4
#define INIT_LOCKOWNER_Type VT_BSTR
#define GENERATEURL_Type VT_I4
//#define IDBBinderProperties_Type 
#define IColumnsInfo2_Type VT_BOOL
//#define IRegisterProvider_Type 
#define IGetSession_Type VT_BOOL
#define IGetSourceRow_Type VT_BOOL
#define IRowsetCurrentIndex_Type VT_BOOL
#define OPENROWSETSUPPORT_Type VT_I4
#define COL_ISLONG_Type VT_BOOL
// 2.5
//#define COL_SEED_Type VT_VARIANT //!!!
//#define COL_INCREMENT_Type VT_VARIANT //!!!
#define INIT_GENERALTIMEOUT_Type VT_I4
#define COMSERVICES_Type VT_I4
// 2.6
#define OUTPUTSTREAM_Type VT_UNKNOWN
#define OUTPUTENCODING_Type VT_BSTR
#define TABLESTATISTICS_Type VT_I4
#define SKIPROWCOUNTRESULTS_Type VT_BOOL
#define IRowsetBookmark_Type VT_BOOL
#define VISUALMODE_Type VT_I4



#define ABORTPRESERVE_Value ATL_VARIANT_FALSE 
#define ACTIVESESSIONS_Value 0 
#define APPENDONLY_Value ATL_VARIANT_FALSE 
#define ASYNCTXNABORT_Value ATL_VARIANT_FALSE 
#define ASYNCTXNCOMMIT_Value ATL_VARIANT_FALSE 
#define AUTH_CACHE_AUTHINFO_Value ATL_VARIANT_FALSE 
#define AUTH_ENCRYPT_PASSWORD_Value ATL_VARIANT_FALSE 
#define AUTH_INTEGRATED_Value OLESTR("") 
#define AUTH_MASK_PASSWORD_Value ATL_VARIANT_FALSE 
#define AUTH_PASSWORD_Value OLESTR("") 
#define AUTH_PERSIST_ENCRYPTED_Value ATL_VARIANT_FALSE 
#define AUTH_PERSIST_SENSITIVE_AUTHINFO_Value ATL_VARIANT_FALSE
#define AUTH_USERID_Value OLESTR("") 
#define BLOCKINGSTORAGEOBJECTS_Value ATL_VARIANT_FALSE 
#define BOOKMARKS_Value ATL_VARIANT_FALSE 
#define BOOKMARKSKIPPED_Value ATL_VARIANT_FALSE 
#define BOOKMARKTYPE_Value 0 
#define BYREFACCESSORS_Value ATL_VARIANT_FALSE 
#define CACHEDEFERRED_Value ATL_VARIANT_FALSE 
#define CANFETCHBACKWARDS_Value ATL_VARIANT_TRUE 
#define CANHOLDROWS_Value ATL_VARIANT_TRUE 
#define CANSCROLLBACKWARDS_Value ATL_VARIANT_TRUE 
#define CATALOGLOCATION_Value 0 
#define CATALOGTERM_Value OLESTR("") 
#define CATALOGUSAGE_Value 0 
#define CHANGEINSERTEDROWS_Value ATL_VARIANT_FALSE 
#define COL_AUTOINCREMENT_Value ATL_VARIANT_FALSE 
#define COL_DEFAULT_Value OLESTR("") 
#define COL_DESCRIPTION_Value OLESTR("") 
#define COL_FIXEDLENGTH_Value ATL_VARIANT_FALSE 
#define COL_NULLABLE_Value ATL_VARIANT_FALSE 
#define COL_PRIMARYKEY_Value ATL_VARIANT_FALSE 
#define COL_UNIQUE_Value ATL_VARIANT_FALSE 
#define COLUMNDEFINITION_Value 0 
#define COLUMNRESTRICT_Value ATL_VARIANT_FALSE 
#define COMMANDTIMEOUT_Value 0 
#define COMMITPRESERVE_Value ATL_VARIANT_FALSE 
#define CONCATNULLBEHAVIOR_Value 0 
#define CURRENTCATALOG_Value OLESTR("") 
#define DATASOURCENAME_Value OLESTR("") 
#define DATASOURCEREADONLY_Value ATL_VARIANT_TRUE 
#define DBMSNAME_Value OLESTR("") 
#define DBMSVER_Value OLESTR("") 
#define DEFERRED_Value ATL_VARIANT_FALSE
#define DELAYSTORAGEOBJECTS_Value ATL_VARIANT_FALSE 
#define DSOTHREADMODEL_Value DBPROPVAL_RT_APTMTTHREAD 
#define GROUPBY_Value 0 
#define HETEROGENEOUSTABLES_Value 0
#define IAccessor_Value ATL_VARIANT_TRUE 
#define IColumnsInfo_Value ATL_VARIANT_TRUE 
#define IColumnsRowset_Value ATL_VARIANT_FALSE 
#define IConnectionPointContainer_Value ATL_VARIANT_FALSE 
#define IConvertType_Value ATL_VARIANT_TRUE 
#define IRowset_Value ATL_VARIANT_TRUE 
#define IRowsetChange_Value ATL_VARIANT_FALSE 
#define IRowsetIdentity_Value ATL_VARIANT_TRUE 
#define IRowsetIndex_Value ATL_VARIANT_FALSE 
#define IRowsetInfo_Value ATL_VARIANT_TRUE 
#define IRowsetLocate_Value ATL_VARIANT_FALSE 
#define IRowsetResynch_Value ATL_VARIANT_FALSE 
#define IRowsetScroll_Value ATL_VARIANT_FALSE 
#define IRowsetUpdate_Value ATL_VARIANT_FALSE 
#define ISupportErrorInfo_Value ATL_VARIANT_FALSE 
#define ILockBytes_Value ATL_VARIANT_FALSE 
#define ISequentialStream_Value ATL_VARIANT_FALSE 
#define IStorage_Value ATL_VARIANT_FALSE 
#define IStream_Value ATL_VARIANT_FALSE 
#define IDENTIFIERCASE_Value 0 
#define IMMOBILEROWS_Value ATL_VARIANT_FALSE 
#define INDEX_AUTOUPDATE_Value ATL_VARIANT_FALSE 
#define INDEX_CLUSTERED_Value ATL_VARIANT_FALSE 
#define INDEX_FILLFACTOR_Value 0 
#define INDEX_INITIALSIZE_Value 0 
#define INDEX_NULLCOLLATION_Value 0 
#define INDEX_NULLS_Value 0 
#define INDEX_PRIMARYKEY_Value ATL_VARIANT_FALSE 
#define INDEX_SORTBOOKMARKS_Value ATL_VARIANT_FALSE 
#define INDEX_TEMPINDEX_Value ATL_VARIANT_FALSE 
#define INDEX_TYPE_Value 0 
#define INDEX_UNIQUE_Value ATL_VARIANT_FALSE 
#define INIT_DATASOURCE_Value OLESTR("") 
#define INIT_HWND_Value 0 
#define INIT_IMPERSONATION_LEVEL_Value 0 
#define INIT_LCID_Value 0 
#define INIT_LOCATION_Value OLESTR("") 
#define INIT_MODE_Value DB_MODE_READ 
#define INIT_PROMPT_Value DBPROMPT_NOPROMPT 
#define INIT_PROTECTION_LEVEL_Value 0 
#define INIT_PROVIDERSTRING_Value OLESTR("") 
#define INIT_TIMEOUT_Value 0 
#define LITERALBOOKMARKS_Value ATL_VARIANT_FALSE 
#define LITERALIDENTITY_Value ATL_VARIANT_FALSE 
#define MAXINDEXSIZE_Value 0 
#define MAXOPENROWS_Value 0 
#define MAXPENDINGROWS_Value 0 
#define MAXROWS_Value 0 
#define MAXROWSIZE_Value 0
#define MAXROWSIZEINCLUDESBLOB_Value ATL_VARIANT_FALSE 
#define MAXTABLESINSELECT_Value 0 
#define MAYWRITECOLUMN_Value ATL_VARIANT_FALSE 
#define MEMORYUSAGE_Value 0 
#define MULTIPLEPARAMSETS_Value ATL_VARIANT_FALSE 
#define MULTIPLERESULTS_Value 0 
#define MULTIPLESTORAGEOBJECTS_Value ATL_VARIANT_FALSE  
#define MULTITABLEUPDATE_Value ATL_VARIANT_FALSE 
#define NOTIFICATIONGRANULARITY_Value DBPROPVAL_NT_SINGLEROW
#define NOTIFICATIONPHASES_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER | DBPROPVAL_NP_FAILEDTODO | DBPROPVAL_NP_DIDEVENT
#define NOTIFYCOLUMNSET_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWDELETE_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWFIRSTCHANGE_Value DBPROPVAL_NP_OKTODO | DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWINSERT_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWRESYNCH_Value 0
#define NOTIFYROWSETRELEASE_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWSETFETCHPOSITIONCHANGE_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWUNDOCHANGE_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWUNDODELETE_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWUNDOINSERT_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWUPDATE_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NULLCOLLATION_Value 0 
#define OLEOBJECTS_Value 0
#define ORDERBYCOLUMNSINSELECT_Value ATL_VARIANT_FALSE 
#define ORDEREDBOOKMARKS_Value ATL_VARIANT_FALSE 
#define OTHERINSERT_Value ATL_VARIANT_FALSE 
#define OTHERUPDATEDELETE_Value ATL_VARIANT_FALSE
#define OUTPUTPARAMETERAVAILABILITY_Value 0 
#define OWNINSERT_Value ATL_VARIANT_FALSE 
#define OWNUPDATEDELETE_Value ATL_VARIANT_FALSE 
#define PERSISTENTIDTYPE_Value 0 
#define PREPAREABORTBEHAVIOR_Value 0 
#define PREPARECOMMITBEHAVIOR_Value 0 
#define PROCEDURETERM_Value OLESTR("") 
#define PROVIDERNAME_Value OLESTR("") 
#define PROVIDEROLEDBVER_Value OLESTR("02.60") 
#define PROVIDERVER_Value OLESTR("01.00") 
#define QUICKRESTART_Value ATL_VARIANT_FALSE 
#define QUOTEDIDENTIFIERCASE_Value 0 
#define REENTRANTEVENTS_Value ATL_VARIANT_FALSE 
#define REMOVEDELETED_Value ATL_VARIANT_FALSE 
#define REPORTMULTIPLECHANGES_Value ATL_VARIANT_FALSE 
#define RETURNPENDINGINSERTS_Value ATL_VARIANT_FALSE 
#define ROWRESTRICT_Value ATL_VARIANT_FALSE 
#define ROWSETCONVERSIONSONCOMMAND_Value ATL_VARIANT_TRUE 
#define ROWTHREADMODEL_Value 0 
#define SCHEMATERM_Value OLESTR("") 
#define SCHEMAUSAGE_Value 0 
#define SERVERCURSOR_Value ATL_VARIANT_FALSE
#define SESS_AUTOCOMMITISOLEVELS_Value 0 
#define SQLSUPPORT_Value 0 
#define STRONGIDENTITY_Value ATL_VARIANT_FALSE 
#define STRUCTUREDSTORAGE_Value 0 
#define SUBQUERIES_Value 0 
#define SUPPORTEDTXNDDL_Value 0 
#define SUPPORTEDTXNISOLEVELS_Value 0 
#define SUPPORTEDTXNISORETAIN_Value 0 
#define TABLETERM_Value OLESTR("") 
#define TBL_TEMPTABLE_Value ATL_VARIANT_FALSE 
#define TRANSACTEDOBJECT_Value ATL_VARIANT_FALSE 
#define UPDATABILITY_Value 0 
#define USERNAME_Value OLESTR("") 
// 1.5
#define FILTERCOMPAREOPS_Value 0
#define FINDCOMPAREOPS_Value 0
#define IChapteredRowset_Value ATL_VARIANT_FALSE
#define IDBAsynchStatus_Value ATL_VARIANT_FALSE
#define IRowsetFind_Value ATL_VARIANT_FALSE
#define IRowsetView_Value ATL_VARIANT_FALSE
#define IViewChapter_Value ATL_VARIANT_FALSE
#define IViewFilter_Value ATL_VARIANT_FALSE
#define IViewRowset_Value ATL_VARIANT_FALSE
#define IViewSort_Value ATL_VARIANT_FALSE
#define INIT_ASYNCH_Value 0
#define MAXOPENCHAPTERS_Value 0
#define MAXORSINFILTER_Value 0
#define MAXSORTCOLUMNS_Value 0
#define ROWSET_ASYNCH_Value 0
#define SORTONINDEX_Value ATL_VARIANT_FALSE
// 2.0
#define IMultipleResults_Value ATL_VARIANT_FALSE
#define DATASOURCE_TYPE_Value 0
//MDPROP
#define AXES_Value 0
#define FLATTENING_SUPPORT_Value 0
#define MDX_JOINCUBES_Value 0
#define NAMED_LEVELS_Value 0
//#define RANGEROWSET_Value 0
#define MDX_SLICER_Value 0
//#define MDX_CUBEQUALIFICATION_Value 
#define MDX_OUTERREFERENCE_Value 0
#define MDX_QUERYBYPROPERTY_Value ATL_VARIANT_FALSE
#define MDX_CASESUPPORT_Value 0
#define MDX_STRING_COMPOP_Value 0
#define MDX_DESCFLAGS_Value 0
#define MDX_SET_FUNCTIONS_Value 0
#define MDX_MEMBER_FUNCTIONS_Value 0
#define MDX_NUMERIC_FUNCTIONS_Value 0
#define MDX_FORMULAS_Value 0
#define AGGREGATECELL_UPDATE_Value 0
//#define MDX_AGGREGATECELL_UPDATE_Value 
#define MDX_OBJQUALIFICATION_Value 0
#define MDX_NONMEASURE_EXPRESSONS_Value 0
// DBPROP
#define ACCESSORDER_Value 0
#define BOOKMARKINFO_Value 0
#define INIT_CATALOG_Value OLESTR("") 
#define ROW_BULKOPS_Value 0
#define PROVIDERFRIENDLYNAME_Value OLESTR("") 
#define LOCKMODE_Value 0
#define MULTIPLECONNECTIONS_Value ATL_VARIANT_FALSE
#define UNIQUEROWS_Value ATL_VARIANT_FALSE
#define SERVERDATAONINSERT_Value ATL_VARIANT_FALSE
//#define STORAGEFLAGS_Value 
#define CONNECTIONSTATUS_Value 0
#define ALTERCOLUMN_Value 0
#define COLUMNLCID_Value 0
#define RESETDATASOURCE_Value 0
#define INIT_OLEDBSERVICES_Value 0
#define IRowsetRefresh_Value ATL_VARIANT_FALSE
#define SERVERNAME_Value OLESTR("") 
#define IParentRowset_Value ATL_VARIANT_FALSE
#define HIDDENCOLUMNS_Value 0
#define PROVIDERMEMORY_Value ATL_VARIANT_FALSE
#define CLIENTCURSOR_Value ATL_VARIANT_FALSE
// 2.1
#define TRUSTEE_USERNAME_Value OLESTR("") 
#define TRUSTEE_AUTHENTICATION_Value OLESTR("") 
#define TRUSTEE_NEWAUTHENTICATION_Value OLESTR("") 
#define IRow_Value ATL_VARIANT_FALSE
#define IRowChange_Value ATL_VARIANT_FALSE
#define IRowSchemaChange_Value ATL_VARIANT_FALSE
#define IGetRow_Value ATL_VARIANT_FALSE
#define IScopedOperations_Value ATL_VARIANT_FALSE
#define IBindResource_Value ATL_VARIANT_FALSE
#define ICreateRow_Value ATL_VARIANT_FALSE
#define INIT_BINDFLAGS_Value 0
#define INIT_LOCKOWNER_Value OLESTR("") 
#define GENERATEURL_Value 0
//#define IDBBinderProperties_Value 
#define IColumnsInfo2_Value ATL_VARIANT_FALSE
//#define IRegisterProvider_Value 
#define IGetSession_Value ATL_VARIANT_FALSE
#define IGetSourceRow_Value ATL_VARIANT_FALSE
#define IRowsetCurrentIndex_Value ATL_VARIANT_FALSE
#define OPENROWSETSUPPORT_Value 0
#define COL_ISLONG_Value ATL_VARIANT_FALSE
// 2.5
//#define COL_SEED_Value 
//#define COL_INCREMENT_Value 
#define INIT_GENERALTIMEOUT_Value 0
#define COMSERVICES_Value 0
// 2.6
#define OUTPUTSTREAM_Value NULL
#define OUTPUTENCODING_Value NULL
#define TABLESTATISTICS_Value 0
#define SKIPROWCOUNTRESULTS_Value ATL_VARIANT_FALSE
#define IRowsetBookmark_Value ATL_VARIANT_FALSE
#define VISUALMODE_Value MDPROPVAL_VISUAL_MODE_DEFAULT


#define OUT_OF_LINE virtual

#define BEGIN_PROPSET_MAP(Class) \
static ATL::UPROPSET* _GetPropSet(ULONG* pNumPropSets, ULONG* pcElemPerSupported, ATL::UPROPSET* pSet = NULL, GUID* pguidSet = NULL) \
{ \
	typedef Class _PropSetClass; \
	USES_ATL_SAFE_ALLOCA;\
	ULONG& cElemsMax = *pcElemPerSupported; \
	cElemsMax = 0; \
	ULONG nCurProp = 0; \
	int cRemainder = 0; \
	if (pguidSet == NULL) \
		pguidSet = (GUID*)&GUID_NULL;

#define BEGIN_PROPERTY_SET_EX(guid, flags) \
if (pNumPropSets != NULL) \
{ \
	pSet[nCurProp].pPropSet = &guid; \
	pSet[nCurProp].dwFlags = flags; \
	pSet[nCurProp].bIsChained = false; \
} \
static const ATL::UPROPINFO aProperty##guid[] = \
{

#define BEGIN_PROPERTY_SET(guid) BEGIN_PROPERTY_SET_EX(guid, 0)

//DBPROP_ macros

#define PROPERTY_INFO_ENTRY_EX(dwPropID, vt, dwFlags, value, options) DBPROP_##dwPropID, IDS_DBPROP_##dwPropID, vt, dwFlags, (DWORD_PTR)value, (DBPROPOPTIONS)options,

#define PROPERTY_INFO_ENTRY_VALUE(dwPropID, value) PROPERTY_INFO_ENTRY_EX(dwPropID, dwPropID##_Type, dwPropID##_Flags, value, 0)

#define PROPERTY_INFO_ENTRY_VALUE_FLAGS(dwPropID, value, dwFlags) PROPERTY_INFO_ENTRY_EX(dwPropID, dwPropID##_Type, dwFlags, value, 0)

#define PROPERTY_INFO_ENTRY(dwPropID) PROPERTY_INFO_ENTRY_VALUE(dwPropID, dwPropID##_Value)


//MDPROP_ macros

#define MDPROPERTY_INFO_ENTRY_EX(dwPropID, vt, dwFlags, value, options) MDPROP_##dwPropID, IDS_MDPROP_##dwPropID, vt, dwFlags, (DWORD_PTR)value, (DBPROPOPTIONS)options,

#define MDPROPERTY_INFO_ENTRY_VALUE(dwPropID, value) MDPROPERTY_INFO_ENTRY_EX(dwPropID, dwPropID##_Type, dwPropID##_Flags, value, 0)

#define MDPROPERTY_INFO_ENTRY_VALUE_FLAGS(dwPropID, value, dwFlags) MDPROPERTY_INFO_ENTRY_EX(dwPropID, dwPropID##_Type, dwFlags, value, 0)

#define MDPROPERTY_INFO_ENTRY(dwPropID) MDPROPERTY_INFO_ENTRY_VALUE(dwPropID, dwPropID##_Value)


#define END_PROPERTY_SET(guid) \
		}; \
		if (pNumPropSets != NULL) \
		{ \
			pSet[nCurProp].pUPropInfo = (ATL::UPROPINFO*)aProperty##guid; \
			pSet[nCurProp].cUPropInfo = sizeof(aProperty##guid) / sizeof(ATL::UPROPINFO); \
			cRemainder = (pSet[nCurProp].cUPropInfo % 32) ? 1 : 0; \
			if (cElemsMax < (pSet[nCurProp].cUPropInfo / 32 + cRemainder)) \
			{ \
				cElemsMax = (pSet[nCurProp].cUPropInfo / 32 + cRemainder); \
			} \
		} \
		nCurProp++;

#define CHAIN_PROPERTY_SET(ChainClass) \
		ULONG cPropSets##ChainClass, cElsSupported##ChainClass; \
		int cSets##ChainClass = (int)(DWORD_PTR)ChainClass::_GetPropSet(NULL, &cElsSupported##ChainClass); \
		if (pNumPropSets != NULL) \
		{ \
			ATL::UPROPSET* pSetA=(ATL::UPROPSET*)_ATL_SAFE_ALLOCA(::ATL::AtlMultiplyThrow(static_cast<int>(sizeof(ATL::UPROPSET)),cSets##ChainClass),_ATL_SAFE_ALLOCA_DEF_THRESHOLD);\
			ATL::UPROPSET* pSetTemp = ChainClass::_GetPropSet(&cPropSets##ChainClass, &cElsSupported##ChainClass, pSetA); \
			cElemsMax = (cElemsMax < cElsSupported##ChainClass) ? cElsSupported##ChainClass : cElemsMax; \
			ATLENSURE(pSetTemp); \
			for (ULONG iSet = nCurProp; iSet < nCurProp+cPropSets##ChainClass; iSet++) \
			{ \
				pSet[iSet].pPropSet = pSetTemp[iSet-nCurProp].pPropSet; \
				pSet[iSet].dwFlags = pSetTemp[iSet-nCurProp].dwFlags; \
				pSet[iSet].pUPropInfo = pSetTemp[iSet-nCurProp].pUPropInfo; \
				pSet[iSet].cUPropInfo = pSetTemp[iSet-nCurProp].cUPropInfo; \
				pSet[iSet].bIsChained = true; \
			} \
		} \
		nCurProp += cSets##ChainClass;

#define END_PROPSET_MAP() \
	if (pNumPropSets != NULL) \
	{ \
		if (IsEqualGUID(*pguidSet, GUID_NULL)) \
		{ \
			*pNumPropSets = nCurProp; \
			return pSet; \
		} \
		else \
		{ \
			*pNumPropSets = 1; \
			UINT i = 0; \
			for (; i < nCurProp && IsEqualGUID(*(pSet[i].pPropSet), *pguidSet); i++); \
			return (i == nCurProp ) ? &pSet[0] : &pSet[i]; \
		} \
	} \
	return (ATL::UPROPSET*)(DWORD_PTR)nCurProp; \
	}


// For DataSource flags IDBInitialize::m_dwStatus
enum DATASOURCE_FLAGS {
	DSF_MASK_INIT			= 0xFFFFF00F,	// Mask for stuff lasting over init/uninit.
	DSF_PERSIST_DIRTY		= 0x00000001,	// Set if init string changes.
	DSF_INITIALIZED			= 0x00000010,	// Have we been initialized.
};


#define DBID_USE_GUID_OR_PGUID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_GUID \
	| 1<<DBKIND_GUID_NAME \
	| 1<<DBKIND_GUID_PROPID \
	| 1<<DBKIND_PGUID_NAME \
	| 1<<DBKIND_PGUID_PROPID ))

#define DBID_USE_GUID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_GUID \
	| 1<<DBKIND_GUID_NAME \
	| 1<<DBKIND_GUID_PROPID ))

#define DBID_USE_PGUID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_PGUID_NAME \
	| 1<<DBKIND_PGUID_PROPID ))

#define DBID_USE_NAME(e) \
	((1<<(e)) & \
	( 1<<DBKIND_NAME \
	| 1<<DBKIND_GUID_NAME \
	| 1<<DBKIND_PGUID_NAME ))

#define DBID_USE_PROPID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_PROPID \
	| 1<<DBKIND_GUID_PROPID \
	| 1<<DBKIND_PGUID_PROPID ))

// Bookmark can be either guid or pguid.
#define DBID_IS_BOOKMARK(dbid) \
	(  DBID_USE_GUID(dbid.eKind)  &&  dbid.uGuid.guid  == DBCOL_SPECIALCOL \
	|| DBID_USE_PGUID(dbid.eKind) && *dbid.uGuid.pguid == DBCOL_SPECIALCOL )

#define DivDword(dw) (dw >> 5)		// dw / 32 = dw / (sizeof(DWORD)*8)
#define ModDword(dw) (dw & (32-1))	// dw % 32
#define DwordSizeofBits(nBits) (nBits/32+1)	// Use in array declarations
#define CLEARBITARRAY( rgdwFlags ) memset( rgdwFlags, 0, sizeof(rgdwFlags) )

template <class T>
BOOL InRange(const T& val, const T& valMin, const T& valMax)
{
	return ( valMin <= val && val <= valMax );
}
// Implementation Class 
class CBitFieldOps
{
public:
	void SETBIT( DWORD rgdwFlags[], const DWORD dwBit )
	{
		rgdwFlags[DivDword(dwBit)] |= 1 << ModDword(dwBit);
	}

	void CLEARBIT( DWORD rgdwFlags[], const DWORD dwBit )
	{
		rgdwFlags[DivDword(dwBit)] &= ~( 1 << ModDword(dwBit) );
	}

	DWORD TESTBIT( const DWORD rgdwFlags[], const DWORD dwBit )
	{
		//old//Note: Not {0,1}, but from {0...2^32-1}.
		// Note: Now returns {0,1}.
		return ( rgdwFlags[DivDword(dwBit)] & ( 1 << ModDword(dwBit) ) ) != 0;
	}
};

// Implementation Class 
class CDBIDOps
{
public:
	HRESULT CompareDBIDs(const DBID* pdbid1, const DBID* pdbid2)
	{
		// Array of valid eKind matches, in addition to matching exactly.
		static const BYTE s_rgbKind[] =
		{
			DBKIND_PGUID_NAME,		// DBKIND_GUID_NAME
			DBKIND_PGUID_PROPID,	// DBKIND_GUID_PROPID
			DBKIND_NAME,			// DBKIND_NAME
			DBKIND_GUID_NAME,		// DBKIND_PGUID_NAME
			DBKIND_GUID_PROPID,		// DBKIND_PGUID_PROPID
			DBKIND_PROPID,			// DBKIND_PROPID
			DBKIND_GUID				// DBKIND_GUID
		};

		if( !pdbid1 || !pdbid2 )
			return S_FALSE;

		// Assume a match, and discard early if we can.
		DBKIND tmp1 = 0;
		DBKIND tmp2 = (DBKIND)(sizeof(s_rgbKind)/sizeof(*s_rgbKind) - 1);
		if (!InRange(pdbid2->eKind, tmp1, tmp2))
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("Column ID out of Range\n"));
			return E_FAIL;
		}
		if (pdbid1->eKind != pdbid2->eKind
		&&  pdbid1->eKind != s_rgbKind[pdbid2->eKind])
			return S_FALSE;

		if (DBID_USE_GUID_OR_PGUID(pdbid1->eKind))
		{
			if (!DBID_USE_GUID_OR_PGUID(pdbid2->eKind))
				return S_FALSE;
			// Compare GUIDs.
			// Note that _GUID_ is equivalent to _PGUID_.
			if (!InlineIsEqualGUID(
					DBID_USE_PGUID(pdbid1->eKind) ? *(pdbid1->uGuid.pguid) : pdbid1->uGuid.guid,
					DBID_USE_PGUID(pdbid2->eKind) ? *(pdbid2->uGuid.pguid) : pdbid2->uGuid.guid ))
				return S_FALSE;
		}
		if (DBID_USE_NAME(pdbid1->eKind))
		{
			if (!DBID_USE_NAME(pdbid2->eKind))
				return S_FALSE;
			// Compare names.
			// Need to check if 1 is null and the other is not.
			if ((pdbid1->uName.pwszName == NULL) != (pdbid2->uName.pwszName == NULL)) 
				 return S_FALSE;
			// Since the above check does not rule out both being null, which is
			// a valid comparison, and wcscmp will GPF if they were, we need
			// to check for valid pointers
			if( pdbid1->uName.pwszName && pdbid2->uName.pwszName )
			{
				// Assume null-terminated.
				// Assume LCID match is OK (note diff with lstrcmp(), CompareString().)
				if (wcscmp(pdbid1->uName.pwszName, pdbid2->uName.pwszName) != 0)
					return S_FALSE;
			}
		}
		if (DBID_USE_PROPID(pdbid1->eKind))
		{
			if (!DBID_USE_PROPID(pdbid2->eKind))
				return S_FALSE;
			// Compare PROPID.
			if (pdbid1->uName.ulPropid != pdbid2->uName.ulPropid)
				return S_FALSE;
		}

		// No reason to discard, so must have matched each field successfully.
		return S_OK;
	}

	static HRESULT IsValidDBID(const DBID*	pdbid1)
	{
		ATLASSERT( pdbid1 );

		if( pdbid1 &&
			((pdbid1->eKind == DBKIND_GUID_NAME) ||
			(pdbid1->eKind == DBKIND_GUID_PROPID) ||
			(pdbid1->eKind == DBKIND_NAME) ||
			(pdbid1->eKind == DBKIND_PGUID_NAME) ||
			(pdbid1->eKind == DBKIND_PGUID_PROPID) ||
			(pdbid1->eKind == DBKIND_PROPID) ||
			(pdbid1->eKind == DBKIND_GUID)) )
			return S_OK;
		else
			return S_FALSE;
	}
	HRESULT CopyDBIDs(DBID*	pdbidDest,	const DBID*	pdbidSrc)
	{
		ULONG cwchBuffer;

		ATLASSERT( pdbidDest || pdbidSrc );

		if( !pdbidDest || !pdbidSrc )
			return S_FALSE;

		// Save eKind
		pdbidDest->eKind = pdbidSrc->eKind;

		switch( pdbidSrc->eKind )
		{

			case DBKIND_GUID_NAME:
				pdbidDest->uGuid.guid = pdbidSrc->uGuid.guid;
				cwchBuffer = ocslen(pdbidSrc->uName.pwszName);
				cwchBuffer++;
				pdbidDest->uName.pwszName = (PWSTR)::ATL::AtlCoTaskMemCAlloc(cwchBuffer, static_cast<ULONG>(sizeof(WCHAR)));
				if( pdbidDest->uName.pwszName ) 
				{
					Checked::memcpy_s(pdbidDest->uName.pwszName, cwchBuffer * sizeof(WCHAR), pdbidSrc->uName.pwszName, cwchBuffer*sizeof(WCHAR));
				}
				else
				{
					return E_OUTOFMEMORY;
				}
				break;

			case DBKIND_GUID_PROPID:
				pdbidDest->uGuid.guid = pdbidSrc->uGuid.guid;
				pdbidDest->uName.ulPropid = pdbidSrc->uName.ulPropid;
				break;
			case DBKIND_NAME:
				cwchBuffer = ocslen(pdbidSrc->uName.pwszName);
				cwchBuffer++;
				pdbidDest->uName.pwszName = (PWSTR)::ATL::AtlCoTaskMemCAlloc(cwchBuffer, static_cast<ULONG>(sizeof(WCHAR)));
				if( pdbidDest->uName.pwszName ) 
				{
					Checked::memcpy_s(pdbidDest->uName.pwszName, cwchBuffer*sizeof(WCHAR), pdbidSrc->uName.pwszName, cwchBuffer*sizeof(WCHAR));
				}
				else
				{
					return E_OUTOFMEMORY;
				}
				break;
			case DBKIND_PGUID_NAME:
				pdbidDest->uGuid.pguid = (GUID*)CoTaskMemAlloc(sizeof(GUID));
				if( pdbidDest->uGuid.pguid )
				{
					*(pdbidDest->uGuid.pguid) = *(pdbidSrc->uGuid.pguid); 
					cwchBuffer = ocslen(pdbidSrc->uName.pwszName);
					cwchBuffer++;
					pdbidDest->uName.pwszName = (PWSTR)::ATL::AtlCoTaskMemCAlloc(cwchBuffer, static_cast<ULONG>(sizeof(WCHAR)));
					if( pdbidDest->uName.pwszName ) 
					{
						Checked::memcpy_s(pdbidDest->uName.pwszName, cwchBuffer*sizeof(WCHAR), pdbidSrc->uName.pwszName, cwchBuffer*sizeof(WCHAR));
						break;
					}
					else
					{
						CoTaskMemFree(pdbidDest->uGuid.pguid); 
						pdbidDest->uGuid.pguid = NULL;
					}
				}
				return E_OUTOFMEMORY;
			case DBKIND_PGUID_PROPID:
				pdbidDest->uGuid.pguid = (GUID*)CoTaskMemAlloc(sizeof(GUID));
				if( pdbidDest->uGuid.pguid )
					*(pdbidDest->uGuid.pguid) = *(pdbidSrc->uGuid.pguid); 
				else
					return E_OUTOFMEMORY;
				pdbidDest->uName.ulPropid = pdbidSrc->uName.ulPropid;
				break;
			case DBKIND_PROPID:
				pdbidDest->uName.ulPropid = pdbidSrc->uName.ulPropid;
				break;
			case DBKIND_GUID:
				pdbidDest->uGuid.guid = pdbidSrc->uGuid.guid;
				break;
			default:
				ATLASSERT(L"Unhandled dbid1.ekind");
				return S_FALSE;
		}

		return S_OK;
	}
	static GUID* GetDBIDpGuid(DBID& dbid)
	{
		GUID* pGuid;
		switch (dbid.eKind)
		{
		case DBKIND_PGUID_NAME:
		case DBKIND_PGUID_PROPID:
			pGuid = dbid.uGuid.pguid;
			break;
		case DBKIND_GUID_NAME:
		case DBKIND_GUID_PROPID:
		case DBKIND_GUID:
			pGuid = &(dbid.uGuid.guid);
			break;
		default:
			pGuid = NULL;
		}

		return pGuid;
	}
	static ULONG GetPropIDFromDBID(DBID& dbid)
	{
		switch (dbid.eKind)
		{
		case DBKIND_GUID_PROPID:
		case DBKIND_PGUID_PROPID:
		case DBKIND_PROPID:
			return dbid.uName.ulPropid;
		default:
			return 0;
		}
	}
	void FreeDBIDs(DBID* pdbidSrc)
	{
		switch( pdbidSrc->eKind )
		{

			case DBKIND_GUID_NAME:
				CoTaskMemFree(pdbidSrc->uName.pwszName); 
				break;
			case DBKIND_NAME:
				CoTaskMemFree(pdbidSrc->uName.pwszName); 
				break;
			case DBKIND_PGUID_NAME:
				CoTaskMemFree(pdbidSrc->uGuid.pguid); 
				CoTaskMemFree(pdbidSrc->uName.pwszName); 
				break;
			case DBKIND_PGUID_PROPID:
				CoTaskMemFree(pdbidSrc->uGuid.pguid); 
				break;
			case DBKIND_GUID_PROPID:
			case DBKIND_PROPID:
			case DBKIND_GUID:
				break;
			default:
				ATLASSERT(L"Unhandled dbid1.ekind");
				break;
		}
	}
};

class CConvertHelper
{
public:
	CConvertHelper() {}
	HRESULT FinalConstruct()
	{
		HRESULT hr = ::CoCreateInstance(CLSID_OLEDB_CONVERSIONLIBRARY, NULL, 
			CLSCTX_INPROC_SERVER, __uuidof(IDataConvert), (void**)&m_spConvert);

		if (FAILED(hr))
			return hr;

		// Check to see if the data conversion routine is 2.0 capable, if so.  Initialize
		// the conversion routine to be 2.0.
		DCINFO rgInfo[] = {{DCINFOTYPE_VERSION, {VT_UI4, 0, 0, 0, 0x0}}};
		CComPtr<IDCInfo> spIDCInfo;

		hr = m_spConvert->QueryInterface(&spIDCInfo);
		if (hr == S_OK)
		{
			V_UI4(&rgInfo->vData) = 0x200;  // OLEDB Version 02.00
			spIDCInfo->SetInfo(1, rgInfo);
		}

		return hr;
	}
	CComPtr<IDataConvert> m_spConvert;
};

// IDBCreateSessionImpl
template <class T, class SessionClass>
class ATL_NO_VTABLE IDBCreateSessionImpl : public IDBCreateSession
{
public:
	STDMETHOD(CreateSession)(IUnknown *pUnkOuter,
							 REFIID riid,
							 IUnknown **ppDBSession)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBCreateSessionImpl::CreateSession\n"));
		if (ppDBSession == NULL)
			return E_INVALIDARG;
		*ppDBSession = NULL;
		T* pT = (T*)this;
		if (!(pT->m_dwStatus & DSF_INITIALIZED))
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("IDBCreateSessionImpl::CreateSession : Error not initialized\n"));
			*ppDBSession = NULL;
			return E_UNEXPECTED;
		}
		CComPolyObject<SessionClass> *pSession;

		// You can't QI for an interface other than IUnknown when aggregating 
		// and creating the object.  You might ask for your own interface, 
		// which would be bad.  Note, we return DB_E_NOAGGREGATION instead of
		// CLASS_E_NOAGGREGATION due to OLE DB constraints.
		if (pUnkOuter != NULL && !InlineIsEqualUnknown(riid))
			return DB_E_NOAGGREGATION;

		HRESULT hr = CComPolyObject<SessionClass>::CreateInstance(pUnkOuter, &pSession);
		if (SUCCEEDED(hr))
		{
			CComPtr<IObjectWithSite> spCreator;
			hr = pSession->QueryInterface(__uuidof(IObjectWithSite), (void**)&spCreator);
			if (SUCCEEDED(hr))
			{
				CComPtr<IUnknown> spOuterUnk;
				hr = pT->QueryInterface(__uuidof(IUnknown), (void**)&spOuterUnk);
				if (SUCCEEDED(hr))
				{
					hr = spCreator->SetSite(spOuterUnk);
					if (SUCCEEDED(hr))
					{
						hr = pSession->QueryInterface(riid, (void**)ppDBSession);
					}
				}
			}
			else
			{
				delete pSession;
			}
		}
		return hr;
	}
};

// IDBInitializeImpl
template <class T>
class ATL_NO_VTABLE IDBInitializeImpl : public IDBInitialize
{
public:
	IDBInitializeImpl()
	{
		m_dwStatus = 0; 
		m_pCUtlPropInfo = NULL;
		m_cSessionsOpen = 0;
	}
	~IDBInitializeImpl()
	{
		delete m_pCUtlPropInfo;
	}

	STDMETHOD(Uninitialize)(void)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBInitializeImpl::Uninitialize\n"));
		T* pT = (T*)this;
		T::ObjectLock lock(pT);
		if (pT->m_cSessionsOpen != 0)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("Uninitialized called with Open Sessions\n"));
			return DB_E_OBJECTOPEN;
		}
		delete m_pCUtlPropInfo;
		m_pCUtlPropInfo = NULL;
		pT->m_dwStatus |= DSF_PERSIST_DIRTY;
		pT->m_dwStatus &= DSF_MASK_INIT;	// Clear all non-init flags.
		return S_OK;

	}

	DWORD m_dwStatus;
	CUtlPropInfo<T>* m_pCUtlPropInfo;
	LONG m_cSessionsOpen;

	STDMETHOD(Initialize)(void)
	{

		ATLTRACE(atlTraceDBProvider, 2, _T("IDBInitializeImpl::Initialize\n"));
		T *pT = (T*)(this);
		T::ObjectLock lock(pT);
		HRESULT hr;
		if (pT->m_dwStatus & DSF_INITIALIZED)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("IDBInitializeImpl::Initialize Error : Already Initialized\n"));
			return DB_E_ALREADYINITIALIZED;
		}
		delete m_pCUtlPropInfo;
		m_pCUtlPropInfo = NULL;
		ATLTRY(m_pCUtlPropInfo = new CUtlPropInfo<T>())
		if (m_pCUtlPropInfo == NULL)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("IDBInitializeImpl::Initialize Error : OOM\n"));
			return E_OUTOFMEMORY;
		}
		hr = m_pCUtlPropInfo->FInit();
		if (hr == S_OK)
		{
			pT->m_dwStatus |= DSF_INITIALIZED;
		}
		else
		{
			delete m_pCUtlPropInfo;
			m_pCUtlPropInfo = NULL;
		}
		return hr;
	}

};


// Implementation Class 

class CPropColID : 
	public PROPCOLID,
	public CDBIDOps
{
public:
	CPropColID()
	{
		VariantInit(&vValue);
	}
	~CPropColID()
	{
		FreeDBIDs(&dbidProperty);
		VariantClear(&vValue);
	}
	bool operator==(const CPropColID& colId)
	{
		return (CompareDBIDs(&dbidProperty, &(colId.dbidProperty)) == S_OK) ? true : false;
	}

};

class CColumnIds : 
	public CDBIDOps,
	public CAtlArray<CPropColID>

{
public:
	PPROPCOLID AddNode()
	{
		CPropColID colID;
		_ATLTRY
		{
			Add(colID);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e )
			return NULL;
		}
		return &(GetAt(GetCount()-1));
	}
	HRESULT	RemoveColumnId(const DBID* pdbidProp)
	{
		for (size_t i = 0; i < GetCount(); i++)
		{
			if (CompareDBIDs(pdbidProp, &(GetAt(i).dbidProperty)) == S_OK)
			{
				if( i < 0 || i >= GetCount() )
					return E_FAIL;
				RemoveAt(i);
				return S_OK;
			}
		}

		return E_FAIL;
	}
	HRESULT	AddColumnId(DBPROP* pProp)
	{
		CPropColID colID;
		HRESULT hr = CopyDBIDs(&(colID.dbidProperty),&(pProp->colid));
		if(FAILED(hr))
			return hr;
		colID.dwOption = pProp->dwOptions;
		hr = VariantCopy(&(colID.vValue),&(pProp->vValue));
		if(FAILED(hr))
			return hr;
		//return (Add(colID)) ? S_OK : E_OUTOFMEMORY;
		_ATLTRY
		{
			Add(colID);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e );
			return E_OUTOFMEMORY;
		}
		return S_OK;
	}
	HRESULT	AddColumnId(PPROPCOLID pPropNode)
	{
		CPropColID colID;
		HRESULT hr = CopyDBIDs(&(colID.dbidProperty),&(pPropNode->dbidProperty));
		if(FAILED(hr))
			return hr;
		colID.dwOption = pPropNode->dwOption;
		hr = VariantCopy(&(colID.vValue),&(pPropNode->vValue));
		if(FAILED(hr))
			return hr;
		//return (Add(colID)) ? S_OK : E_OUTOFMEMORY;
		_ATLTRY
		{
			Add(colID);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e );
			return E_OUTOFMEMORY;
		}
		return S_OK;
	}
	ULONG GetCountOfPropColids(){ return (ULONG)GetCount();}
	PPROPCOLID FindColumnId(const DBID* pdbidProp)
	{
		for (size_t i = 0; i < GetCount(); i++)
		{
			if (CompareDBIDs(pdbidProp, &(GetAt(i).dbidProperty)) == S_OK)
				return &(GetAt(i));
		}

		return NULL;
	}
	HRESULT GetValue(size_t iColId, DWORD* pdwOptions, DBID* pColid, VARIANT* pvValue)
	{
		HRESULT		hr;

		ATLENSURE_RETURN(pdwOptions && pColid && pvValue);
		ATLASSERT(iColId >= 0 && iColId < GetCount());

		CPropColID& colId = GetAt(iColId);
		*pdwOptions = colId.dwOption;
		hr = CopyDBIDs( pColid, &(colId.dbidProperty) );
		if(FAILED(hr) || hr == S_FALSE)
		{
			return hr;
		}
		if(FAILED(hr = VariantCopy(pvValue, &(colId.vValue))))
			return hr;
		return S_OK;
	}
};

const ULONG		cchDescBuffSize = 256;
const DWORD		DBINTERNFLAGS_CHANGED		= 0x00000001;
// Rules for GetPropertiesArgChk
const DWORD		ARGCHK_PROPERTIESINERROR	= 0x00000001;

// Implementation Class 
template <class T>
class CUtlPropInfo : public CBitFieldOps, public CDBIDOps
{
public:
	enum EnumGetPropInfo
	{
		GETPROPINFO_ALLPROPIDS		= 0x0001,
		GETPROPINFO_NOTSUPPORTED	= 0x0002,
		GETPROPINFO_ERRORSOCCURRED	= 0x0004,
		GETPROPINFO_VALIDPROP		= 0x0008
	};

	CUtlPropInfo()
	{
		m_cUPropSet		 = 0;
		m_pUPropSet		 = NULL;

		m_cPropSetDex	= 0;

		m_cElemPerSupported = 0;
	}
	~CUtlPropInfo()
	{
		CoTaskMemFree(m_pUPropSet);
	}

	//Determine the number of description buffers needed
	ULONG CalcDescripBuffers(ULONG cPropInfoSet, DBPROPINFOSET* pPropInfoSet)
	{
		ULONG	cBuffers = 0;

		ATLASSUME(m_pUPropSet);
		ATLENSURE(cPropInfoSet && pPropInfoSet);

		for(ULONG ulSet=0; ulSet<cPropInfoSet; ulSet++)
		{
			if( GetPropertySetIndex(&(pPropInfoSet[ulSet].guidPropertySet)) == S_OK)
			{
				if( pPropInfoSet[ulSet].cPropertyInfos == 0 )
				{
					for(ULONG ul=0; ul<m_cPropSetDex; ul++)
					{
						cBuffers += m_pUPropSet[m_rgiPropSetDex[ul]].cUPropInfo;
					}
				}
				else
				{
					cBuffers += pPropInfoSet[ulSet].cPropertyInfos;
				}
			}
		}

		return cBuffers;
	}
	//Retrieve the property set indexes that match this property set.
	HRESULT	GetPropertySetIndex(const GUID* pPropertySet)
	{
		DWORD	dwFlag = 0;
		ULONG	ulSet;

		ATLASSUME(m_cUPropSet && m_pUPropSet);
		ATLASSUME(m_rgiPropSetDex);
		ATLASSERT(pPropertySet);

		m_cPropSetDex = 0;

		if(InlineIsEqualGUID(*pPropertySet, DBPROPSET_DATASOURCEALL))
		{
			dwFlag = DBPROPFLAGS_DATASOURCE;
		}
		else if(InlineIsEqualGUID(*pPropertySet, DBPROPSET_DATASOURCEINFOALL))
		{
			dwFlag = DBPROPFLAGS_DATASOURCEINFO;
		}
		else if(InlineIsEqualGUID(*pPropertySet, DBPROPSET_ROWSETALL))
		{
			dwFlag = DBPROPFLAGS_ROWSET;
		}
		else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_DBINITALL))
		{
			dwFlag = DBPROPFLAGS_DBINIT;
		}
		else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_SESSIONALL))
		{
			dwFlag = DBPROPFLAGS_SESSION;
		}
		else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_COLUMNALL))
		{
			dwFlag = DBPROPFLAGS_COLUMN;
		}
		else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_INDEXALL))
		{
			dwFlag = DBPROPFLAGS_INDEX;
		}
		else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_TABLEALL))
		{
			dwFlag = DBPROPFLAGS_TABLE;
		}
		else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_TRUSTEEALL))
		{
			dwFlag = DBPROPFLAGS_TRUSTEE;
		}
		else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_VIEWALL))
		{
			dwFlag = DBPROPFLAGS_VIEW;
		}
		else // No scan required, just look for match.
		{
			for(ulSet=0; ulSet<m_cUPropSet; ulSet++)
			{
				if( *(m_pUPropSet[ulSet].pPropSet) == *pPropertySet )
				{
					m_rgiPropSetDex[m_cPropSetDex] = ulSet;
					m_cPropSetDex++;
					break;
				}
			}
			goto EXIT;
		}

		// Scan through the property sets looking for matching attributes
		for(ulSet=0; ulSet<m_cUPropSet; ulSet++)
		{
			if( m_pUPropSet[ulSet].pUPropInfo[0].dwFlags & dwFlag )
			{
				m_rgiPropSetDex[m_cPropSetDex] = ulSet;
				m_cPropSetDex++;
			}
		}

	EXIT:
		return (m_cPropSetDex) ? S_OK : S_FALSE;

	}
	//Retrieve the property id pointer 
	HRESULT	GetUPropInfoPtr(ULONG iPropSetDex, DBPROPID dwPropertyId, UPROPINFO** ppUPropInfo)
	{
		// Scan through the property sets looking for matching attributes
		for(ULONG ulProps=0; ulProps<m_pUPropSet[iPropSetDex].cUPropInfo; ulProps++)
		{
			if( m_pUPropSet[iPropSetDex].pUPropInfo[ulProps].dwPropId == dwPropertyId )
			{
				*ppUPropInfo = &(m_pUPropSet[iPropSetDex].pUPropInfo[ulProps]);
				// Test to see if the property is supported for this
				// instantiation
				return (TESTBIT(&(m_rgdwSupported[iPropSetDex * m_cElemPerSupported]), ulProps)) ? S_OK : S_FALSE;
			}
		}
		return S_FALSE;
	}
	HRESULT	FInit(GUID* pguidSet = (GUID*)&GUID_NULL)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		HRESULT hr;

		hr = InitAvailUPropSets(&m_cUPropSet, &m_pUPropSet, &m_cElemPerSupported, pguidSet);
		if (FAILED(hr))
			return hr;
		ATLASSERT((m_cUPropSet != 0) && (m_cElemPerSupported != 0));
		if(!m_cUPropSet || !m_cElemPerSupported)
			return E_FAIL;

		ATLTRY(m_rgdwSupported.Allocate(::ATL::AtlMultiplyThrow(m_cUPropSet, m_cElemPerSupported)));
		if(m_rgdwSupported == NULL)
		{
			m_cUPropSet=0;
			m_cElemPerSupported=0;
			return E_OUTOFMEMORY;
		}

		if(FAILED(hr = InitUPropSetsSupported()))
		{
			m_cUPropSet=0;
			m_cElemPerSupported=0;
			m_rgdwSupported.Free();
			return hr;
		}
		if(m_cUPropSet)
		{
			ATLTRY(m_rgiPropSetDex.Allocate(m_cUPropSet))
			if(m_rgiPropSetDex == NULL)
			{
				m_cUPropSet=0;
				m_cElemPerSupported=0;
				m_rgdwSupported.Free();
				return E_OUTOFMEMORY;
			}
		}
		return S_OK;
	}
	HRESULT	GetPropertyInfo(__in ULONG cPropertySets, 
						__in_ecount_opt(cPropertySets) const DBPROPIDSET rgPropertySets[], __out ULONG* pcPropertyInfoSets,
						__deref_opt_out_ecount(*pcPropertyInfoSets) DBPROPINFOSET**	prgPropertyInfoSets, 
						__deref_opt_out_opt WCHAR** ppDescBuffer, __in bool bInitialized = true, 
						__in_opt const GUID* pGuid = NULL)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		HRESULT	hr = S_OK;
		ULONG ul, ulSet, ulNext, ulEnd;
		ULONG ulOutIndex;
		ULONG cSets;
		ULONG cPropInfos;
		//ULONG ulIndex = 0;
		ULONG cBuffers = 0;
		DWORD dwStatus = 0;
		DBPROPINFO*	pPropInfo = NULL;
		DBPROPINFO*	pCurPropInfo = NULL;
		WCHAR* pDescBuffer = NULL;
		WCHAR* pDescBufferEnd = NULL;
		DBPROPINFOSET* pPropInfoSet = NULL;
		UPROPINFO* pUPropInfo = NULL;
		WCHAR wszBuff[256];
		int	cch;
		CAtlArray<ULONG> rgInitPropsetIndexes;

		// If the consumer does not restrict the property sets
		// by specify an array of property sets and a cPropertySets
		// greater than 0, then we need to make sure we 
		// have some to return
		if(cPropertySets == 0)
		{
			// Determine the number of property sets supported
			// In this case, it usually the enumerator or data source asking for 
			// DBPROPSET_DBINIT information.

			if (pGuid != NULL)
			{
				// Need to determine if there are any UPROPSET_USERINIT sets here
				// they should be added to DBINIT.
				ULONG ulUserInitSets = 0;
				for (ULONG l=0; l<m_cUPropSet; l++)
					if (m_pUPropSet[l].dwFlags & UPROPSET_USERINIT)
						ulUserInitSets++;

				cSets = 1 + ulUserInitSets;		// one for DBINIT which is required
			}
			else
			{
				cSets = m_cUPropSet;
			}
		}
		else
		{
			cSets = 0;

			// Determine number of property sets required 
			// This is only required when any of the "special" property set GUIDs were specified
			for(ulSet=0; ulSet<cPropertySets; ulSet++)
			{
				if (GetPropertySetIndex(&(rgPropertySets[ulSet].guidPropertySet)) == S_OK)
					cSets += m_cPropSetDex;
				else
					cSets++;
			}
		}
		ATLASSERT(cSets);

		// Allocate the DBPROPINFOSET structures
		pPropInfoSet = (DBPROPINFOSET*)::ATL::AtlCoTaskMemCAlloc(cSets, static_cast<ULONG>(sizeof(DBPROPINFOSET)));
		if(pPropInfoSet == NULL)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("Could not allocate DBPROPSET array for GetProperties\n"));
			hr =  E_OUTOFMEMORY;
			goto EXIT;
		}

		memset(pPropInfoSet, 0, cSets * sizeof(DBPROPINFOSET));

		ulOutIndex = 0;
		ULONG ulTempPropsetIndex = 0;
		ulEnd = cPropertySets == 0 ? cSets : cPropertySets; 
		// Fill in the output array
		for(ulSet=0; ulSet<ulEnd; ulSet++)
		{
 			// Depending of if Property sets are specified store the
			// return property set.
			if (cPropertySets == 0)
			{
				if (pGuid != NULL)
				{
					// Need to change this: set the guidPropertySet to the maching
					// initialization property group (not DBINITALL).
					for (ULONG ulCurrentInitSet = ulTempPropsetIndex; ulCurrentInitSet < m_cUPropSet; ulCurrentInitSet++)
					{
						// We need to locate either the DBINIT or USERINIT property sets here
						// and set the property set index up correctly.
						if (InlineIsEqualGUID(*(m_pUPropSet[ulCurrentInitSet].pPropSet), DBPROPSET_DBINIT) ||
							(m_pUPropSet[ulCurrentInitSet].dwFlags & UPROPSET_USERINIT))
						{
							rgInitPropsetIndexes.Add(ulCurrentInitSet);
							ulTempPropsetIndex = ulCurrentInitSet + 1;
							//ulIndex = ulCurrentInitSet;
							//pPropInfoSet[ulSet].guidPropertySet = *pGuid;
							pPropInfoSet[ulSet].guidPropertySet = *(m_pUPropSet[ulCurrentInitSet].pPropSet);
							GetPropertySetIndex(&pPropInfoSet[ulSet].guidPropertySet);	// Need to set the m_cPropSetDex variable
							break;
						}
					}
					//if (ulCurrentInitSet == m_cUPropSet)
					//{
					//	ulIndex = 0;
					//}

				}
				else
				{
					pPropInfoSet[ulSet].guidPropertySet = *(m_pUPropSet[ulSet].pPropSet);
				}
			}
			else
			{
				GUID const& guidSet = rgPropertySets[ulSet].guidPropertySet;
				if( (InlineIsEqualGUID(guidSet, DBPROPSET_DATASOURCEALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_DATASOURCEINFOALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_DBINITALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_SESSIONALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_COLUMNALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_CONSTRAINTALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_INDEXALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_TABLEALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_TRUSTEEALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_VIEWALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_ROWSETALL)) &&
					GetPropertySetIndex(&guidSet) == S_OK )
				{
					for(ul=0; ul<m_cPropSetDex; ul++,ulOutIndex++)
					{
						pPropInfoSet[ulOutIndex].guidPropertySet	= *(m_pUPropSet[m_rgiPropSetDex[ul]].pPropSet);
						pPropInfoSet[ulOutIndex].cPropertyInfos		= 0;
					}
				}
				else
				{
					// Handle non-category property sets
					// Handle unknown property sets
					pPropInfoSet[ulOutIndex].guidPropertySet = guidSet; 
					pPropInfoSet[ulOutIndex].cPropertyInfos	 = rgPropertySets[ulSet].cPropertyIDs; 
					ulOutIndex++;
				}
			}
		}

		// Allocate a Description Buffer if needed
		if( ppDescBuffer )
		{
			cBuffers = CalcDescripBuffers(cSets, pPropInfoSet);
			if( cBuffers != 0 )
			{
				SIZE_T uDescBuffersByteSize = cBuffers * cchDescBuffSize * sizeof(WCHAR);
				if (uDescBuffersByteSize / (cchDescBuffSize * sizeof(WCHAR)) != cBuffers)
				{
					hr = E_FAIL;
					goto EXIT;
				}
				pDescBuffer = (WCHAR*)CoTaskMemAlloc(uDescBuffersByteSize);
				if(pDescBuffer == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto EXIT;
				}
				*ppDescBuffer = pDescBuffer;
				pDescBufferEnd = pDescBuffer + uDescBuffersByteSize;
				memset(pDescBuffer, 0, uDescBuffersByteSize);
			}
		}



		// Process requested or derived Property sets
		dwStatus = 0;
		for(ulSet=0; ulSet<cSets; ulSet++)
		{
			ulNext=0;
			cPropInfos = 0;
			pPropInfo = NULL;
			dwStatus &= (GETPROPINFO_ERRORSOCCURRED | GETPROPINFO_VALIDPROP);

			// Calculate the number of property nodes needed for this
			// property set.
			if( cPropertySets == 0 )
			{
				ULONG ulTempSet;
				if (pGuid != NULL)
				{
					ATLASSERT( ulSet < rgInitPropsetIndexes.GetCount() );
					ulTempSet = rgInitPropsetIndexes[ulSet]; // ulIndex;
				}
				else
					ulTempSet = ulSet;

				cPropInfos = m_pUPropSet[ulTempSet].cUPropInfo;
				dwStatus |= GETPROPINFO_ALLPROPIDS;
				m_rgiPropSetDex[0] = ulTempSet;
				m_cPropSetDex = 1; 
				_ATLDUMPPROPSETIID(*m_pUPropSet[ulTempSet].pPropSet, dwStatus);
			}
			else
			{
				// If the count of PROPIDs is 0 (NOTE: the above routine already determined
				// if it belonged to a category and if so set the count of properties to 0 for
				// each propset in that category.
				if( pPropInfoSet[ulSet].cPropertyInfos == 0 )
				{
					dwStatus |= GETPROPINFO_ALLPROPIDS;
					// We have to determine if the property set is supported and if so
					// the count of properties in the set.
					if( (GetPropertySetIndex(&(pPropInfoSet[ulSet].guidPropertySet)) == S_FALSE)
						|| (!bInitialized && 
						!(InlineIsEqualGUID(pPropInfoSet[ulSet].guidPropertySet, DBPROPSET_DBINIT)) &&
						!(InlineIsEqualGUID(pPropInfoSet[ulSet].guidPropertySet, DBPROPSET_DBINITALL))))
					{
						dwStatus |= GETPROPINFO_NOTSUPPORTED;
						dwStatus |= GETPROPINFO_ERRORSOCCURRED;
						_ATLDUMPPROPSETIID(pPropInfoSet[ulSet].guidPropertySet, dwStatus);
						goto NEXT_SET;
					}
					else						
					{
						ATLASSUME( m_cPropSetDex == 1 );
						cPropInfos += m_pUPropSet[m_rgiPropSetDex[0]].cUPropInfo;
						_ATLDUMPPROPSETIID(pPropInfoSet[ulSet].guidPropertySet, dwStatus);
					}
				}
				else
				{
					// We also handle the case here where the user has requested
					// a non-initialization group property info set while the
					// provider is not initialized.  In this case, properties should
					// not be set.
					cPropInfos = pPropInfoSet[ulSet].cPropertyInfos;
					if( (GetPropertySetIndex(&(pPropInfoSet[ulSet].guidPropertySet)) == S_FALSE)
						|| (!bInitialized && 
						!(InlineIsEqualGUID(pPropInfoSet[ulSet].guidPropertySet, DBPROPSET_DBINIT)) &&
						!(InlineIsEqualGUID(pPropInfoSet[ulSet].guidPropertySet, DBPROPSET_DBINITALL))))
					{
						dwStatus |= GETPROPINFO_NOTSUPPORTED;
						dwStatus |= GETPROPINFO_ERRORSOCCURRED;
						_ATLDUMPPROPSETIID(pPropInfoSet[ulSet].guidPropertySet, dwStatus);
					}
				}
			}


			// Allocate DBPROP array
			ATLASSERT( cPropInfos != 0 );
			pPropInfo = (DBPROPINFO*)::ATL::AtlCoTaskMemCAlloc(cPropInfos, static_cast<ULONG>(sizeof(DBPROPINFO)));
			if( pPropInfo )
			{
				// Initialize Buffer
				memset(pPropInfo, 0, cPropInfos * sizeof(DBPROPINFO));
				for(ULONG ulProp=0; ulProp<cPropInfos; ulProp++)
				{
					VariantInit(&(pPropInfo[ulProp].vValues));
					if( dwStatus & GETPROPINFO_NOTSUPPORTED )
					{
						// Not supported, thus we need to mark all as NOT_SUPPORTED
						pPropInfo[ulProp].dwPropertyID = rgPropertySets[ulSet].rgPropertyIDs[ulProp];
						pPropInfo[ulProp].dwFlags = DBPROPFLAGS_NOTSUPPORTED;
						dwStatus |= GETPROPINFO_ERRORSOCCURRED;
						_ATLDUMPPROPERTY(pPropInfo[ulProp].dwPropertyID, pPropInfo[ulProp].dwFlags);
					}					
				}
				// Make sure we support the property set
				if( dwStatus & GETPROPINFO_NOTSUPPORTED )
				{
					ulNext = cPropInfos;
					goto NEXT_SET;
				}

				// Retrieve the property information for this property set
				for(ul=0; ul<m_cPropSetDex; ul++)
				{
					pUPropInfo = (m_pUPropSet[m_rgiPropSetDex[ul]].pUPropInfo);
					ATLENSURE_RETURN( pUPropInfo );

					// Retrieve current value of properties
					if( dwStatus & GETPROPINFO_ALLPROPIDS )
					{
						for(ULONG ulProp=0; ulProp<m_pUPropSet[m_rgiPropSetDex[ul]].cUPropInfo; ulProp++)
						{
							// Verify property is supported, if not do not return 
							if( !TESTBIT(&(m_rgdwSupported[m_rgiPropSetDex[ul] * m_cElemPerSupported]), ulProp) )
								continue;

							pCurPropInfo = &(pPropInfo[ulNext]);

							// If the ppDescBuffer pointer was not NULL, then
							// we need supply description of the properties
							if( ppDescBuffer )
							{
								// Set Buffer pointer
								pCurPropInfo->pwszDescription = pDescBuffer;

								// Load the string into temp buffer
								cch = LoadDescription(pUPropInfo[ulProp].ulIDS, wszBuff, (sizeof(wszBuff)/sizeof(*wszBuff)));
								if( cch )
								{
									// Adjust for '\0'
									cch++;

									// Transfer to official buffer if room
#if _SECURE_ATL
									if (pDescBuffer > pDescBufferEnd)
									{ 
										return E_FAIL;
									}
#endif
									Checked::memcpy_s(pDescBuffer, (pDescBufferEnd-pDescBuffer)*sizeof(WCHAR), wszBuff, cch * sizeof(WCHAR));
									pDescBuffer += cch;
								}
								else
								{
#if _SECURE_ATL
									if(pDescBuffer > pDescBufferEnd) 
									{
										return E_FAIL;
									}
#endif
									Checked::wcscpy_s(pDescBuffer, pDescBufferEnd-pDescBuffer, L"UNKNOWN");
									pDescBuffer += (wcslen(L"UNKNOWN") + 1);
									_ATLDUMPPROPERTY(pCurPropInfo->dwPropertyID, ATLDB_NO_STRING);
								}
							}

							pCurPropInfo->dwPropertyID = pUPropInfo[ulProp].dwPropId;

							// Strip out any user defined flags that may be around.  Note,
							// this isn't a full-proof thing because properties change.  It
							// won't work in OLE DB 2.5 if someone does a property like 0x40000
							DWORD dwFlags = pUPropInfo[ulProp].dwFlags & 0xfffff;

							pCurPropInfo->dwFlags = dwFlags;
							pCurPropInfo->vtType = pUPropInfo[ulProp].VarType;
							pCurPropInfo->vValues.vt = VT_EMPTY;

							dwStatus |= GETPROPINFO_VALIDPROP;
							// Increment to next available buffer
							ulNext++;
							_ATLDUMPPROPERTY(pCurPropInfo->dwPropertyID, pCurPropInfo->dwFlags);
						}
					}
					else
					{
						ATLASSUME( m_cPropSetDex == 1 );
						ULONG cIterations = ((cPropInfos>cBuffers) && (ppDescBuffer)) ? cBuffers : cPropInfos;

						for( ULONG ulProp = 0; ulProp < cIterations; ulProp++, ulNext++ )
						{
							pCurPropInfo = &(pPropInfo[ulNext]);

							// Process Properties based on Restriction array.
							pCurPropInfo->dwPropertyID = rgPropertySets[ulSet].rgPropertyIDs[ulProp];

							if( GetUPropInfoPtr(m_rgiPropSetDex[ul], pCurPropInfo->dwPropertyID, &pUPropInfo)
								== S_OK )
							{
								// If the ppDescBuffer pointer was not NULL, then
								// we need supply description of the properties
								if( ppDescBuffer )
								{
									// Set Buffer pointer
									pCurPropInfo->pwszDescription = pDescBuffer;

									// Load the string into temp buffer
									cch = LoadDescription(pUPropInfo->ulIDS, wszBuff, (sizeof(wszBuff)/sizeof(*wszBuff)));
									if( cch )
									{
										// Adjust for '\0'
										cch++;

										// Transfer to official buffer if room
#if _SECURE_ATL
										if(pDescBuffer > pDescBufferEnd) 
											return E_FAIL;
#endif
										Checked::memcpy_s(pDescBuffer, (pDescBufferEnd-pDescBuffer)*sizeof(WCHAR), wszBuff, cch * sizeof(WCHAR));
										pDescBuffer += cch;
									}
									else
									{
#if _SECURE_ATL
										if(pDescBuffer > pDescBufferEnd) 
										{
											return E_FAIL;
										}
#endif
										Checked::wcscpy_s(pDescBuffer, pDescBufferEnd-pDescBuffer, L"UNKNOWN");
										pDescBuffer += (wcslen(L"UNKNOWN") + 1);
										_ATLDUMPPROPERTY(pCurPropInfo->dwPropertyID, ATLDB_NO_STRING);
									}
								}

								pCurPropInfo->dwPropertyID = pUPropInfo->dwPropId;

								// Strip out any user defined flags that may be around.  Note,
								// this isn't a full-proof thing because properties change.  It
								// won't work in OLE DB 2.5 if someone does a property like 0x40000
								DWORD dwFlags = pUPropInfo->dwFlags & 0xfffff;

								pCurPropInfo->dwFlags = dwFlags;
								pCurPropInfo->vtType = pUPropInfo->VarType;

								dwStatus |= GETPROPINFO_VALIDPROP;
							}
							else
							{
								// Not Supported
								pCurPropInfo->dwFlags = DBPROPFLAGS_NOTSUPPORTED;
								dwStatus |= GETPROPINFO_ERRORSOCCURRED;
							}
							_ATLDUMPPROPERTY(pCurPropInfo->dwPropertyID, pCurPropInfo->dwFlags);
						}
					}
				}
			}
			else
			{
				hr = E_OUTOFMEMORY;
				goto EXIT;
			}

NEXT_SET:
			pPropInfoSet[ulSet].cPropertyInfos = ulNext;
			pPropInfoSet[ulSet].rgPropertyInfos = pPropInfo;
		}

		// Success, set return values
		*pcPropertyInfoSets = cSets;
		*prgPropertyInfoSets = pPropInfoSet;

		// At least one propid was marked as not S_OK
		if( dwStatus & GETPROPINFO_ERRORSOCCURRED )
		{
			// If at least 1 property was set
			if( dwStatus & GETPROPINFO_VALIDPROP )
				return DB_S_ERRORSOCCURRED;
			else
			{
				// Do not free any of the rgPropertyInfoSets, but
				// do free the ppDescBuffer
				if( pDescBuffer )
				{
					ATLASSERT( ppDescBuffer );
					CoTaskMemFree(pDescBuffer);
					*ppDescBuffer = NULL;
				}
				return DB_E_ERRORSOCCURRED;
			}
		}

		return S_OK;
EXIT:
		// Check if failure and clean up any allocated memory
		if( FAILED(hr) && 
			(hr != DB_E_ERRORSOCCURRED) )
		{
			// Free Description Buffer
			if( pDescBuffer )
			{
				ATLASSERT( ppDescBuffer );

				CoTaskMemFree(pDescBuffer);
				*ppDescBuffer = NULL;
			}

			if( pPropInfoSet )
			{
				// Loop through Property Sets
				for(ulSet=0; ulSet<cSets; ulSet++)
					CoTaskMemFree(pPropInfoSet[ulSet].rgPropertyInfos);
				CoTaskMemFree(pPropInfoSet);
			}
		}

		return hr;
	}

	CComAutoCriticalSection m_oCriticalSection; // critical section to synchronize access to the class
	ULONG m_cUPropSet; //count of UPropSet items
	UPROPSET* m_pUPropSet; //Pointer to UPropset items
	ULONG m_cPropSetDex; 	//count of UPropSet Indexes
	CAutoVectorPtr<ULONG> m_rgiPropSetDex;//array of UPropSet Index values
	ULONG m_cElemPerSupported; //number of DWORDS per UPropSet to indicate supported UPropIds
	CAutoVectorPtr<DWORD> m_rgdwSupported;//array of DWORDs indicating supported UPropIds 

	enum EnumUPropSetFlags
	{
		UPROPSET_HIDDEN				= 0x1,
		UPROPSET_PASSTHROUGH		= 0x2,
		UPROPSET_USERINIT			= 0x4
	};

	HRESULT	InitAvailUPropSets(ULONG* pcUPropSet, UPROPSET** ppUPropSet, ULONG* pcElemPerSupported, GUID* pguid)
	{
		ATLENSURE_RETURN(pcUPropSet && ppUPropSet);
		CoTaskMemFree(*ppUPropSet);
		*ppUPropSet = NULL;
		int cSets = (int)(ULONG_PTR)T::_GetPropSet(NULL, pcElemPerSupported);
		UPROPSET* pSet = (UPROPSET*)::ATL::AtlCoTaskMemCAlloc(static_cast<ULONG>(sizeof(UPROPSET)), cSets);
		if (pSet == NULL) 
		{
			*pcUPropSet=0;
			*ppUPropSet=NULL;
			*pcElemPerSupported=0;
			return E_OUTOFMEMORY;
		}
		*ppUPropSet = T::_GetPropSet(pcUPropSet, pcElemPerSupported, pSet, pguid);
		return S_OK;
	}
	OUT_OF_LINE HRESULT	InitUPropSetsSupported()
	{
		ULONG cPropSet = 0, cElemsPerSupported = 0;
		int cSets = (int)(ULONG_PTR)T::_GetPropSet(NULL, &cElemsPerSupported);
		UPROPSET* pSet = (UPROPSET*)::ATL::AtlCoTaskMemCAlloc(static_cast<ULONG>(sizeof(UPROPSET)), cSets);
		if (pSet == NULL) 
			return E_OUTOFMEMORY;
		pSet = T::_GetPropSet(&cPropSet, &cElemsPerSupported, pSet);
		memset(m_rgdwSupported, 0xFFFF, cPropSet * cElemsPerSupported * sizeof(DWORD));
		CoTaskMemFree(pSet);
		return S_OK;
	}
	//Load a localized description
	int	LoadDescription(__in ULONG ids, __out_ecount_part_z(nLen, return + 1) PWSTR pwszBuff, __in ULONG cchBuff)
	{
		USES_CONVERSION_EX;
		CTempBuffer<TCHAR> tmpBuffer;
		TCHAR* pszBuf = tmpBuffer.Allocate(cchBuff);
		if (pszBuf == NULL)
			return 0;
		int nTemp = LoadString(_AtlBaseModule.GetResourceInstance(), ids, pszBuf, cchBuff);
		if (nTemp != 0)
		{
			Checked::wcscpy_s(pwszBuff, cchBuff, T2W_EX_DEF(pszBuf));
		}
		return nTemp;
	}
};

class ATL_NO_VTABLE CUtlPropsBase : public CBitFieldOps, public CDBIDOps
{
public:

	CComAutoCriticalSection m_oCriticalSection; // critical section to synchronize access to the class
	ULONG m_cUPropSet; //count of UPropSet items
	UPROPSET* m_pUPropSet; //Pointer to UPropset items
	CAutoVectorPtr< UPROP > m_pUProp;
	ULONG m_cUPropSetHidden; //Count of Hidden items
	DWORD m_dwFlags; //Configuration flags
	ULONG m_cPropSetDex; //count of UPropSet Indexes
	CAutoVectorPtr< ULONG > m_rgiPropSetDex; //pointer to Array of UPropSet Index values
	ULONG m_cElemPerSupported;//number of DWORDS per UPropSet to indicate supported UPropIds
	CAutoVectorPtr< DWORD > m_rgdwSupported; //pointer to array of DWORDs indicating supported UPropIds 
	CAutoVectorPtr< DWORD > m_rgdwPropsInError;//pointer to array of DWORDs indicating if property is in error

	enum EnumUPropSetFlags
	{
		UPROPSET_HIDDEN				= 0x1,
		UPROPSET_PASSTHROUGH		= 0x2,
		UPROPSET_USERINIT			= 0x4
	};
	enum EnumGetProp
	{
		GETPROP_ALLPROPIDS			= 0x0001,
		GETPROP_NOTSUPPORTED		= 0x0002,
		GETPROP_ERRORSOCCURRED		= 0x0004,
		GETPROP_VALIDPROP			= 0x0008,
		GETPROP_PROPSINERROR		= 0x0010
	};

	enum EnumSetProp
	{
		SETPROP_BADOPTION			= 0x0001,
		SETPROP_NOTSUPPORTED		= 0x0002,
		SETPROP_VALIDPROP			= 0x0004,
		SETPROP_ERRORS				= 0x0008,
		SETPROP_COLUMN_LEVEL		= 0x0010,
		SETPROP_WAS_REQUIRED		= 0x0020
	};

	HRESULT	SetPassThrough(const DBPROPSET* pPropSet)
	{
		ATLENSURE_RETURN(pPropSet);

		DBPROP*	pProp = pPropSet->rgProperties;

		//Default implementation just sets all properties as NOTSUPPORTED
		for( ULONG ul=0; ul<pPropSet->cProperties; ul++, pProp++ )
			pProp->dwStatus = DBPROPSTATUS_NOTSUPPORTED;

		return DB_E_ERRORSOCCURRED;
	}

	HRESULT	GetIndexofPropIdinPropSet(ULONG iCurSet, DBPROPID dwPropertyId, ULONG* piCurPropId)
	{
		ATLENSURE_RETURN(piCurPropId);
		UPROPINFO* pUPropInfo = m_pUPropSet[iCurSet].pUPropInfo;
		for(ULONG ul=0; ul<m_pUPropSet[iCurSet].cUPropInfo; ul++)
		{
			if( dwPropertyId == pUPropInfo[ul].dwPropId )
			{
				*piCurPropId = ul;
				// Test to see if the property is supported for this
				// instantiation
				return (TESTBIT(&(m_rgdwSupported[iCurSet * m_cElemPerSupported]), ul)) ? S_OK : S_FALSE;
			}
		}

		return S_FALSE;
	}

	virtual HRESULT	IsValidValue(ULONG /*iCurSet*/, DBPROP* pDBProp)
	{
		ATLENSURE_RETURN(pDBProp != NULL);
		CComVariant var = pDBProp->vValue;
		if (var.vt == VT_BOOL)
		{
			if (var.boolVal != ATL_VARIANT_TRUE && var.boolVal != ATL_VARIANT_FALSE)
				return S_FALSE;
		}

		return S_OK;
	}

	virtual HRESULT OnInterfaceRequested(REFIID	riid)
	{
		// This function exists as part of the change in the OLE DB spec.  If
		// a consumer opens an object and requests an optional interface, the
		// provider should automatically set the property representating that
		// interface to true.
		CDBPropSet propset(DBPROPSET_ROWSET);
		const GUID* ppGuid[1];
		ppGuid[0] = &DBPROPSET_ROWSET;

		if (InlineIsEqualGUID(riid, __uuidof(IRowsetChange)))
		{
			if(!propset.AddProperty(DBPROP_IRowsetChange, true))
			{
				return E_FAIL;
			}
		}
		else if (InlineIsEqualGUID(riid, __uuidof(IRowsetUpdate)))
		{
			if(!propset.AddProperty(DBPROP_IRowsetUpdate, true))
			{
				return E_FAIL;
			}
		}
		else if (InlineIsEqualGUID(riid, __uuidof(IRowsetLocate)))
		{
			if(!propset.AddProperty(DBPROP_IRowsetLocate, true))
			{
				return E_FAIL;
			}
		}
		else if (InlineIsEqualGUID(riid, __uuidof(IConnectionPointContainer)))
		{
			if(!propset.AddProperty(DBPROP_IConnectionPointContainer, true))
			{
				return E_FAIL;
			}
		}
		else if (InlineIsEqualGUID(riid, __uuidof(IRowsetScroll)))
		{
			if(!propset.AddProperty(DBPROP_IRowsetScroll, true))
			{
				return E_FAIL;
			}
		}

		if (propset.cProperties > 0)
			return SetProperties(0, 1, &propset, 1, ppGuid);

		return S_OK;
	}

	virtual HRESULT OnPropertyChanged(ULONG /*iCurSet*/, DBPROP* /*pDBProp*/) = 0;

#pragma warning(push)
#pragma warning(disable: 6014)
	/* prefast noise VSW 498981 */
	HRESULT	SetProperty(ULONG iCurSet, ULONG iCurProp, DBPROP* pDBProp)
	{
		HRESULT	hr = S_OK;
		UPROP* pUProp;
		UPROPVAL* pUPropVal;
		UPROPINFO* pUPropInfo;
		ULONG iUProp;

		ATLENSURE_RETURN( pDBProp );

		// Set pointer to correct set
		pUProp = &(m_pUProp[iCurSet]);
		ATLENSURE_RETURN( pUProp );

		pUPropInfo = &(m_pUPropSet[iCurSet].pUPropInfo[iCurProp]);
		ATLENSURE_RETURN( pUPropInfo );

		// Determine the index within m_pUProp	
		for(iUProp=0; iUProp<pUProp->cPropIds; iUProp++)
		{
			if( (pUProp->rgpUPropInfo[iUProp])->dwPropId == pDBProp->dwPropertyID )
				break; 
		}

		if( iUProp >= pUProp->cPropIds )
		{
			ATLASSERT( !"Should have found index of property to set" );
			hr = E_FAIL;
			pDBProp->dwStatus = DBPROPSTATUS_NOTSUPPORTED;
			goto EXIT;
		}

		//Get the UPROPVAL node pointer within that propset.
		pUPropVal = &(pUProp->pUPropVal[iUProp]);
		ATLENSURE_RETURN( pUPropVal );

		// Handle VT_EMPTY, which indicates to the provider to 
		// reset this property to the providers default
		if( pDBProp->vValue.vt == VT_EMPTY )
		{
			if( pUPropInfo->dwFlags & DBPROPFLAGS_COLUMNOK )
			{
				// Remove any nodes, because the default applies to 
				// all columns
				delete pUPropVal->pCColumnIds;			
				pUPropVal->pCColumnIds = NULL;			
			}

			// Should clear here, since previous values may already
			// have been cached and need to be replaced.
			VariantClear(&(pUPropVal->vValue));

			pUPropVal->dwFlags &= ~DBINTERNFLAGS_CHANGED;
			hr = GetDefaultValue(iCurSet, pDBProp->dwPropertyID, 
				&(pUPropVal->dwOption), &(pUPropVal->vValue));

			goto EXIT;
		}


		// Column Level
		if( pUPropInfo->dwFlags & DBPROPFLAGS_COLUMNOK )
		{
			// Check to see if it applies to all
			if( (CompareDBIDs(&(pDBProp->colid), &DB_NULLID) == S_OK) )
			{
				// Remove the Columns Storage object
				delete pUPropVal->pCColumnIds;
				pUPropVal->pCColumnIds = NULL;			
				pUPropVal->dwOption = pDBProp->dwOptions;
				if( FAILED(hr = VariantCopy(&(pUPropVal->vValue), 
					&(pDBProp->vValue))) )
					goto EXIT;
				pUPropVal->dwFlags |= DBINTERNFLAGS_CHANGED;
			}	
			else // Does not apply to all columns
			{
				if( pUPropVal->pCColumnIds == NULL )
				{
					ATLTRY(pUPropVal->pCColumnIds = new CColumnIds)
				}

				if( pUPropVal->pCColumnIds )
				{
					if( FAILED(hr = (pUPropVal->pCColumnIds)->AddColumnId(pDBProp)) )
						goto EXIT;
					pUPropVal->dwFlags |= DBINTERNFLAGS_CHANGED;
				}			
				else
				{
					hr = E_OUTOFMEMORY;
					goto EXIT;
				}

			}
		}	
		else
		{
			// Set for non-column level properties
			pUPropVal->dwOption = pDBProp->dwOptions;

			// Our provider has no limit on the maximum number of rows 
			// that can have pending changes, therefore the value of the
			// DBPROP_MAXPENDINGROWS property will always be zero (default),
			// regardless of what the user attempts to set it to.
			// In the code below, we modify the property value only if 
			// this is not the DBPROP_MAXPENDINGROWS property.
			if( pDBProp->dwPropertyID != DBPROP_MAXPENDINGROWS )
			{
				if( FAILED(hr = VariantCopy(&(pUPropVal->vValue), 
					&(pDBProp->vValue))) )
					goto EXIT;
			}
			if( FAILED(hr = OnPropertyChanged(iCurSet, pDBProp)))
				goto EXIT;
			pUPropVal->dwFlags |= DBINTERNFLAGS_CHANGED;
		}

EXIT:
		if( hr == S_OK )
			pDBProp->dwStatus = DBPROPSTATUS_OK;

		return hr;
	}
#pragma warning(pop)

	HRESULT	SetProperties(const DWORD /*dwStatus*/, const ULONG cPropertySets, 
			const DBPROPSET rgPropertySets[], const ULONG cSelectProps = 1, 
			const GUID* const ppGuid[] = NULL, bool bIsCreating = false)
	{
		DWORD dwState = 0;
		ULONG ulCurSet, ulCurProp, ulProp;
		DBPROP*	rgDBProp;
		UPROPINFO* pUPropInfo;
		CComVariant vDefaultValue;
		DWORD dwOption;

		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);

		// ppGuid specifies the property sets that the consumer can set based
		// on the interface that called this function.
		ATLENSURE_RETURN(ppGuid != NULL);

		if ((cPropertySets != 0) && (rgPropertySets == NULL))
			return E_INVALIDARG;

		// Process property sets
		for(ULONG ulSet=0; ulSet<cPropertySets; ulSet++)
		{
			if ((rgPropertySets[ulSet].cProperties != 0) && (rgPropertySets[ulSet].rgProperties == NULL))
				return E_INVALIDARG;

			bool bAvailable = false;
			for (ULONG l=0; l<cSelectProps; l++)
			{
				if (InlineIsEqualGUID(*ppGuid[l], rgPropertySets[ulSet].guidPropertySet))
					bAvailable |= true;
			}

			// Make sure we support the property set
			if( !bAvailable || 
				(GetIndexofPropSet(&(rgPropertySets[ulSet].guidPropertySet), &ulCurSet) == S_FALSE ))
			{
				// Not supported, thus we need to mark all as NOT_SUPPORTED
				rgDBProp = rgPropertySets[ulSet].rgProperties;
				for(ulProp=0; ulProp<rgPropertySets[ulSet].cProperties; ulProp++)
				{
					dwState |= SETPROP_ERRORS;
					dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
					rgDBProp[ulProp].dwStatus = DBPROPSTATUS_NOTSUPPORTED; 
					_ATLDUMPPROPSETIID(rgPropertySets[ulSet].guidPropertySet, dwState);
				}
				continue;
			}

			// Handle property sets marked as pass through
			if( m_pUPropSet[ulCurSet].dwFlags & UPROPSET_PASSTHROUGH )
			{
				HRESULT hr = SetPassThrough(&rgPropertySets[ulSet]);
				if( hr == DB_E_ERRORSOCCURRED )
				{
					dwState |= SETPROP_ERRORS;
					dwState |= SETPROP_WAS_REQUIRED;
				}
				else if( hr == DB_S_ERRORSOCCURRED )
				{
					dwState |= SETPROP_ERRORS;	
					dwState |= SETPROP_VALIDPROP; 
				}
				else
				{
					ATLASSERT( hr == S_OK );
					dwState |= SETPROP_VALIDPROP; 
				}

				continue;
			}		

			// Handle properties of a supported property set
			rgDBProp = rgPropertySets[ulSet].rgProperties;
			for(ulProp=0; ulProp<rgPropertySets[ulSet].cProperties; ulProp++)
			{
				// Is this a supported PROPID for this property set
				if( GetIndexofPropIdinPropSet(ulCurSet, rgDBProp[ulProp].dwPropertyID, 
					&ulCurProp) == S_FALSE)
				{
					dwState |= SETPROP_ERRORS;
					dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
					rgDBProp[ulProp].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
					_ATLDUMPPROPERTY(rgDBProp[ulProp].dwPropertyID, rgDBProp[ulProp].dwStatus);
					continue;
				}

				// Set the pUPropInfo pointer
				pUPropInfo = &(m_pUPropSet[ulCurSet].pUPropInfo[ulCurProp]); 
				ATLENSURE_RETURN( pUPropInfo );

				// check dwOption for a valid option
				if( (rgDBProp[ulProp].dwOptions != DBPROPOPTIONS_REQUIRED)  &&
					(rgDBProp[ulProp].dwOptions != DBPROPOPTIONS_SETIFCHEAP) )
				{
					ATLTRACE(atlTraceDBProvider, 0, _T("SetProperties dwOptions Invalid: %u\n"), rgDBProp[ulProp].dwOptions);
					dwState |= SETPROP_ERRORS;
					dwState |= SETPROP_WAS_REQUIRED;
					rgDBProp[ulProp].dwStatus = DBPROPSTATUS_BADOPTION;
					_ATLDUMPPROPERTY(rgDBProp[ulProp].dwPropertyID, rgDBProp[ulProp].dwStatus);
					continue;
				}

				// Check that the property is settable
				// We do not check against DBPROPFLAGS_CHANGE here
				if( (pUPropInfo->dwFlags & DBPROPFLAGS_WRITE) == 0 )
				{
					rgDBProp[ulProp].dwStatus = DBPROPSTATUS_OK;

					vDefaultValue.Clear();

					// VT_EMPTY against a read only property should be a no-op since
					// the VT_EMPTY means the default.
					if( V_VT(&rgDBProp[ulProp].vValue) == VT_EMPTY )
					{
						dwState |= SETPROP_VALIDPROP;
						continue;
					}

					if( SUCCEEDED(GetDefaultValue(ulCurSet, rgDBProp[ulProp].dwPropertyID, 
							&dwOption, &(vDefaultValue))) )
					{
						if( V_VT(&rgDBProp[ulProp].vValue) ==  V_VT(&vDefaultValue) )
						{
							switch( V_VT(&vDefaultValue) )
							{
								case VT_BOOL:
									if( V_BOOL(&rgDBProp[ulProp].vValue) == V_BOOL(&vDefaultValue) )
									{
										dwState |= SETPROP_VALIDPROP;
										continue;
									}
									break;
								case VT_I2:
									if( V_I2(&rgDBProp[ulProp].vValue) == V_I2(&vDefaultValue) )
									{
										dwState |= SETPROP_VALIDPROP;
										continue;
									}
									break;
								case VT_I4:
									if( V_I4(&rgDBProp[ulProp].vValue) == V_I4(&vDefaultValue) )
									{
										dwState |= SETPROP_VALIDPROP;
										continue;
									}
									break;
								case VT_BSTR:
									if( wcscmp(V_BSTR(&rgDBProp[ulProp].vValue), V_BSTR(&vDefaultValue)) == 0 )
									{
										dwState |= SETPROP_VALIDPROP;
										continue;
									}
									break;
							}
						}
					}

					dwState |= SETPROP_ERRORS;
					dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
					rgDBProp[ulProp].dwStatus = (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_OPTIONAL) ? DBPROPSTATUS_NOTSET : DBPROPSTATUS_NOTSETTABLE;
					_ATLDUMPPROPERTY(rgDBProp[ulProp].dwPropertyID, rgDBProp[ulProp].dwStatus);
					continue;
				}

				// Check that the property is being set with the correct VARTYPE
				if( (rgDBProp[ulProp].vValue.vt != pUPropInfo->VarType) && 
					(rgDBProp[ulProp].vValue.vt != VT_EMPTY) )
				{
					dwState |= SETPROP_ERRORS;
					dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
					rgDBProp[ulProp].dwStatus = DBPROPSTATUS_BADVALUE;
					_ATLDUMPPROPERTY(rgDBProp[ulProp].dwPropertyID, rgDBProp[ulProp].dwStatus);
					continue;
				}

				// Check that the value is legal
				if( (rgDBProp[ulProp].vValue.vt != VT_EMPTY) && 
					IsValidValue(ulCurSet, &(rgDBProp[ulProp])) == S_FALSE )
				{
					dwState |= SETPROP_ERRORS;
					dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
					rgDBProp[ulProp].dwStatus = DBPROPSTATUS_BADVALUE;
					_ATLDUMPPROPERTY(rgDBProp[ulProp].dwPropertyID, rgDBProp[ulProp].dwStatus);
					continue;
				}


				// Check for a bad COLID, we only catch bad DBIDs
				if( pUPropInfo->dwFlags & DBPROPFLAGS_COLUMNOK )
				{
					if( CDBIDOps::IsValidDBID(&(rgDBProp[ulProp].colid)) == S_FALSE )
					{
						dwState |= SETPROP_ERRORS;
						dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
						rgDBProp[ulProp].dwStatus = DBPROPSTATUS_BADCOLUMN;
						_ATLDUMPPROPERTY(rgDBProp[ulProp].dwPropertyID, rgDBProp[ulProp].dwStatus);
						continue;
					}
					dwState |= SETPROP_COLUMN_LEVEL;

				}

				if(SetProperty(ulCurSet, ulCurProp, /*pUPropInfo,*/ &(rgDBProp[ulProp])) == S_OK)
				{
					dwState |= SETPROP_VALIDPROP;
				}
				else
				{
					dwState |= SETPROP_ERRORS;
					dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
				}
				_ATLDUMPPROPERTY(rgDBProp[ulProp].dwPropertyID, rgDBProp[ulProp].dwStatus);
			}
		}

		vDefaultValue.Clear();

		// At least one propid was marked as not S_OK
		if( dwState & SETPROP_ERRORS )
		{
			if (!bIsCreating)
			{
				return (dwState & SETPROP_VALIDPROP) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED;
			}
			else
			{
				return (dwState & SETPROP_WAS_REQUIRED) ? DB_E_ERRORSOCCURRED : DB_S_ERRORSOCCURRED;
			}
		}

		return S_OK;
	}

	OUT_OF_LINE HRESULT	CopyUPropVal(ULONG iPropSet, UPROPVAL* rgUPropVal)
	{
		HRESULT	hr = S_OK;
		UPROP* pUProp;
		UPROPVAL* pUPropVal;
		DBPROP dbProp;

		ATLENSURE_RETURN(rgUPropVal);
		ATLASSERT(iPropSet < m_cUPropSet);

		VariantInit(&dbProp.vValue);

		pUProp = &(m_pUProp[iPropSet]);
		for(ULONG ul=0; ul<pUProp->cPropIds; ul++)
		{
			pUPropVal = &(pUProp->pUPropVal[ul]);

			// Transfer dwOptions
			rgUPropVal[ul].dwOption = pUPropVal->dwOption;

			// Transfer Flags
			rgUPropVal[ul].dwFlags = pUPropVal->dwFlags;

			// Transfer Column Properties
			if( pUPropVal->pCColumnIds )
			{
				ATLTRY(rgUPropVal[ul].pCColumnIds = new CColumnIds)
				if( rgUPropVal[ul].pCColumnIds )
				{
					CColumnIds* pColIds = pUPropVal->pCColumnIds;
					for (size_t i = 0; i < pColIds->GetCount(); i++)
					{
						hr = (pUPropVal->pCColumnIds)->GetValue(i, &(dbProp.dwOptions),&(dbProp.colid), &(dbProp.vValue));
						if( FAILED(hr) )
							goto EXIT;												
						if( FAILED(hr = (rgUPropVal[ul].pCColumnIds)->AddColumnId(&dbProp)) )
							goto EXIT;
					}
				}
				else
				{
					hr = E_OUTOFMEMORY;
					goto EXIT;		
				}
			}
			else
			{
				rgUPropVal[ul].pCColumnIds = NULL;
			}

			// Transfer value
			VariantInit(&(rgUPropVal[ul].vValue));
			if( FAILED(hr = VariantCopy(&(rgUPropVal[ul].vValue), 
				&(pUPropVal->vValue))) )
				goto EXIT;
		}

EXIT:	
		VariantClear(&(dbProp.vValue));
		return hr;
	}
	void ClearPropertyInError()
	{
		ATLASSUME( m_rgdwPropsInError );
		memset(m_rgdwPropsInError, 0, m_cUPropSet * m_cElemPerSupported * sizeof(DWORD)); 
	}

	void CopyUPropSetsSupported(DWORD* rgdwSupported)
	{
		Checked::memcpy_s(rgdwSupported, m_cUPropSet * m_cElemPerSupported * sizeof(DWORD), 
			m_rgdwSupported, m_cUPropSet * m_cElemPerSupported * sizeof(DWORD));
	}

	virtual HRESULT	InitUPropSetsSupported() = 0;

	virtual HRESULT	GetIndexofPropSet(const GUID* pPropSet, ULONG* pulCurSet) = 0;

	ULONG GetCountofWritablePropsInPropSet(ULONG iPropSet)
	{
		ULONG cWritable = 0;
		UPROPINFO* pUPropInfo;

		ATLENSURE( m_pUPropSet );
		ATLASSERT( iPropSet < m_cUPropSet );

		pUPropInfo = m_pUPropSet[iPropSet].pUPropInfo;

		for(ULONG ul=0; ul<m_pUPropSet[iPropSet].cUPropInfo; ul++)
		{
			if( pUPropInfo[ul].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
				cWritable++;
		}

		return cWritable;
	}

	void CopyUPropInfo(ULONG iPropSet, UPROPINFO** rgpUPropInfo)
	{
		ATLASSERT( rgpUPropInfo );
		ATLASSERT( iPropSet < m_cUPropSet );
		Checked::memcpy_s(rgpUPropInfo, m_pUProp[iPropSet].cPropIds * sizeof(UPROPINFO*), 
			m_pUProp[iPropSet].rgpUPropInfo, m_pUProp[iPropSet].cPropIds * sizeof(UPROPINFO*));
	}

	virtual HRESULT	GetDefaultValue(ULONG iPropSet, DBPROPID dwPropId, DWORD* pdwOption, VARIANT* pVar) = 0;

	typedef UPROPSET* (*PGetPropSet)(ULONG* pNumPropSets, ULONG* pcElemPerSupported, UPROPSET* pSet, GUID* pguidSet);

	HRESULT	InternalInitUPropSetsSupported(PGetPropSet pfnGetSet)
	{
		ULONG cPropSet = 0, cElemsPerSupported = 0;
		int cSets = (int)(DWORD_PTR)(*pfnGetSet)(NULL, &cElemsPerSupported, NULL, (GUID*)&GUID_NULL);
		UPROPSET* pPropSet = (UPROPSET*)::ATL::AtlCoTaskMemCAlloc(static_cast<ULONG>(sizeof(UPROPSET)), cSets);
		if (pPropSet == NULL) 
			return E_OUTOFMEMORY;
		pPropSet = (*pfnGetSet)(&cPropSet, &cElemsPerSupported, pPropSet, (GUID*)&GUID_NULL);
		memset(m_rgdwSupported, 0xFFFF, cPropSet * cElemsPerSupported * sizeof(DWORD));
		CoTaskMemFree(pPropSet);
		return S_OK;
	}

	HRESULT	InternalGetDefaultValue(PGetPropSet pfnGetSet, ULONG iPropSet, DBPROPID dwPropId, DWORD* pdwOption, VARIANT* pVar)
	{
		if (pdwOption == NULL || pVar == NULL)
			return E_INVALIDARG;

		ULONG cUPropSet = 0, cElemPerSupported =0;

		int cSets = (int)(DWORD_PTR)(*pfnGetSet)(NULL, &cElemPerSupported, NULL, (GUID*)&GUID_NULL);
		UPROPSET* pPropSet = (UPROPSET*)::ATL::AtlCoTaskMemCAlloc(static_cast<ULONG>(sizeof(UPROPSET)), cSets);
		if (pPropSet == NULL) 
			return E_OUTOFMEMORY;
		pPropSet = (*pfnGetSet)(&cUPropSet, &cElemPerSupported, pPropSet, (GUID*)&GUID_NULL);

		ATLASSERT(iPropSet < cUPropSet);
		for (ULONG iProp = 0; iProp < pPropSet[iPropSet].cUPropInfo; iProp++)
		{
			UPROPINFO& rInfo = pPropSet[iPropSet].pUPropInfo[iProp];
			if (rInfo.dwPropId == dwPropId)
			{
				HRESULT hr = S_OK;
				pVar->vt = rInfo.VarType;
				*pdwOption = rInfo.dwOption;
				switch(rInfo.VarType)
				{
				case VT_BSTR:
					pVar->bstrVal = SysAllocString(rInfo.szVal);
					if (pVar->bstrVal == NULL && rInfo.szVal != NULL)
						hr = E_OUTOFMEMORY;
					break;
				default:
					pVar->lVal = (DWORD)rInfo.dwVal;
					break;
				}
				CoTaskMemFree(pPropSet);
				return hr;
			}
		}
		CoTaskMemFree(pPropSet);
		return E_FAIL;  
	}

	HRESULT InternalFInit(PGetPropSet pfnGetSet, CUtlPropsBase* pCopyMe = NULL)
	{
		HRESULT		hr;
		ULONG		ulPropId;
		ULONG		cPropIds;
		ULONG		iPropSet;
		ULONG		iNewDex;
		UPROPINFO*	pUPropInfo;

		// If a pointer is passed in, we should copy that property object
		if( pCopyMe )
		{
			// Establish some base values
			m_cUPropSet = pCopyMe->m_cUPropSet;
			CoTaskMemFree(m_pUPropSet);
			m_pUPropSet = (UPROPSET*)::ATL::AtlCoTaskMemCAlloc(static_cast<ULONG>(sizeof(UPROPSET)), m_cUPropSet);
			if (m_pUPropSet == NULL) 
				return E_OUTOFMEMORY;
			Checked::memcpy_s(m_pUPropSet, sizeof(UPROPSET) * m_cUPropSet, pCopyMe->m_pUPropSet, sizeof(UPROPSET) * m_cUPropSet);
			m_cElemPerSupported = pCopyMe->m_cElemPerSupported;
			ATLASSERT( (m_cUPropSet != 0)  && (m_cElemPerSupported != 0) );
			// Retrieve Supported Bitmask
			ATLTRY(m_rgdwSupported.Allocate(::ATL::AtlMultiplyThrow(m_cUPropSet, m_cElemPerSupported)));
			ATLTRY(m_rgdwPropsInError.Allocate(::ATL::AtlMultiplyThrow(m_cUPropSet, m_cElemPerSupported)));
			if( m_rgdwSupported == NULL|| m_rgdwPropsInError == NULL)
			{
				m_rgdwSupported.Free();
				m_rgdwPropsInError.Free();
				return E_OUTOFMEMORY;
			}
			ClearPropertyInError();
			pCopyMe->CopyUPropSetsSupported(m_rgdwSupported);

		}
		else
		{
			int cSets = (int)(DWORD_PTR)(*pfnGetSet)(NULL, &m_cElemPerSupported, NULL, (GUID*)&GUID_NULL);
			UPROPSET* pSet = (UPROPSET*)::ATL::AtlCoTaskMemCAlloc(static_cast<ULONG>(sizeof(UPROPSET)), cSets);
			if (pSet == NULL) 
				return E_OUTOFMEMORY;
			pSet = (*pfnGetSet)(&m_cUPropSet, &m_cElemPerSupported, pSet, (GUID*)&GUID_NULL);
			CoTaskMemFree(m_pUPropSet);
			m_pUPropSet = pSet;
			ATLASSERT( (m_cUPropSet != 0)  && (m_cElemPerSupported != 0) );
			if( !m_cUPropSet || !m_cElemPerSupported )
				return E_FAIL;

			ATLTRY(m_rgdwSupported.Allocate(::ATL::AtlMultiplyThrow(m_cUPropSet, m_cElemPerSupported)));
			ATLTRY(m_rgdwPropsInError.Allocate(::ATL::AtlMultiplyThrow(m_cUPropSet, m_cElemPerSupported)));
			if( m_rgdwSupported == NULL || m_rgdwPropsInError == NULL)
			{
				m_rgdwSupported.Free();
				m_rgdwPropsInError.Free();
				return E_OUTOFMEMORY;
			}
			else
				ClearPropertyInError();

			if( FAILED(hr = InitUPropSetsSupported()) )
			{
				m_rgdwSupported.Free();
				return hr;
			}
		}

		// Allocate UPROPS structures for the count of Property sets
		ATLTRY(m_pUProp.Allocate(m_cUPropSet));
		if( m_pUProp)
		{
			memset(m_pUProp, 0, m_cUPropSet * sizeof(UPROP));
		}
		else
		{
			m_cUPropSet = 0;
			return E_OUTOFMEMORY;
		}

		// With in the UPROPS Structure allocate and intialize the
		// Property IDs that belong to this property set.
		for(iPropSet=0; iPropSet<m_cUPropSet; iPropSet++)
		{
			cPropIds = GetCountofWritablePropsInPropSet(iPropSet);

			if( cPropIds > 0 )
			{
				CAutoVectorPtr< UPROPINFO* > rgpUPropInfo;
				CAutoVectorPtr< UPROPVAL > rgUPropVal;

				rgpUPropInfo.Allocate( cPropIds );
				rgUPropVal.Allocate( cPropIds );
				if ( (rgpUPropInfo == NULL) || (rgUPropVal == NULL) )
				{
					return E_OUTOFMEMORY;
				}
				if( pCopyMe )
				{
					pCopyMe->CopyUPropInfo(iPropSet, rgpUPropInfo);
					if( FAILED(hr = pCopyMe->CopyUPropVal(iPropSet, rgUPropVal)) )
						return hr;
				}
				else
				{
					// Clear Pointer Array
					memset(rgpUPropInfo, 0, cPropIds * sizeof(UPROPINFO*));

					// Set Pointer to correct property ids with a property set
					pUPropInfo = m_pUPropSet[iPropSet].pUPropInfo;

					// Set up the writable property buffers
					iNewDex = 0;
					for(ulPropId=0; ulPropId<m_pUPropSet[iPropSet].cUPropInfo; ulPropId++)
					{
						if( pUPropInfo[ulPropId].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
						{
							// Following ATLASSERT indicates that the are more
							// writable properties then space allocated
							ATLASSERT(iNewDex < cPropIds);

							rgpUPropInfo[iNewDex] = &(pUPropInfo[ulPropId]);
							rgUPropVal[iNewDex].dwOption = DBPROPOPTIONS_SETIFCHEAP;
							rgUPropVal[iNewDex].pCColumnIds = NULL;
							rgUPropVal[iNewDex].dwFlags = 0;
							VariantInit(&(rgUPropVal[iNewDex].vValue));
							GetDefaultValue(iPropSet, pUPropInfo[ulPropId].dwPropId, 
								&(rgUPropVal[iNewDex].dwOption), &(rgUPropVal[iNewDex].vValue));
							iNewDex++;
						}
					}

					ATLASSERT(cPropIds == iNewDex);
				}


				m_pUProp[iPropSet].rgpUPropInfo = rgpUPropInfo.Detach();
				m_pUProp[iPropSet].pUPropVal = rgUPropVal.Detach();
				m_pUProp[iPropSet].cPropIds = cPropIds;
			}
		}

		// Finally determine if there are any hidden property sets..  Those
		// that do not show up in GetPropertyInfo and should not be returns on 
		// a 0, NULL call to GetProperties
		for(iPropSet=0; iPropSet<m_cUPropSet; iPropSet++)
		{
			if( m_pUPropSet[iPropSet].dwFlags & UPROPSET_HIDDEN )
				m_cUPropSetHidden++;
		}

		return S_OK;
	}
	//Check the arguments for Set Properties
	static HRESULT SetPropertiesArgChk(const ULONG cPropertySets, const DBPROPSET rgPropertySets[])
	{
		if( cPropertySets > 0 && !rgPropertySets )
			return E_INVALIDARG;

		// New argument check for > 1 cPropertyIDs and NULL pointer for 
		// array of property ids.
		for(ULONG ul=0; ul<cPropertySets; ul++)
		{
			if( rgPropertySets[ul].cProperties && !(rgPropertySets[ul].rgProperties) )
				return E_INVALIDARG;
		}

		return S_OK;
	}
	HRESULT	GetProperties(const ULONG cPropertySets, const DBPROPIDSET rgPropertySets[], 
						  ULONG* pcProperties, DBPROPSET** prgProperties, 
						  const ULONG cSelectProps = 1, const GUID* const ppGuid[] = NULL)
	{
		UPROPVAL*		pUPropVal;
		ULONG			ulCurProp;
		ULONG			cTmpPropertySets = cPropertySets;
		HRESULT			hr = S_OK;
		ULONG			ulSet = 0;
		ULONG			ulNext = 0;
		ULONG			cSets = 0;
		ULONG			cProps = 0;
		ULONG			ulProp = 0;
		DWORD			dwStatus = 0;
		DBPROP*			pProp = NULL;
		DBPROP*			pCurProp = NULL;
		DBPROPSET*		pPropSet = NULL;
		UPROPINFO*		pUPropInfo = NULL;
		ULONG			ulCurSet = 0;
		ULONG			iPropSet;
		CAutoVectorPtr< ULONG > piIndex;

		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);

		// ppGuid contains an array of GUIDs that the consumer can retrieve.
		// This is based upon the interface calling this function
		ATLENSURE_RETURN(ppGuid != NULL);

		// We need to have special handling for DBPROPSET_PROPERTIESINERROR..
		// Turn on a flags to indicate this mode and make cTmpPropertySets
		// appear to be 0
		if( (m_dwFlags & ARGCHK_PROPERTIESINERROR) &&
			rgPropertySets && 
			(rgPropertySets[0].guidPropertySet == DBPROPSET_PROPERTIESINERROR) )
		{
			cTmpPropertySets = 0;
			dwStatus |= GETPROP_PROPSINERROR;
		}

		// If the consumer does not restrict the property sets
		// by specify an array of property sets and a cTmpPropertySets
		// greater than 0, then we need to make sure we 
		// have some to return
		if( cTmpPropertySets == 0 )
		{
			// There are times when we are called from IRowsetInfo, ISessionProperties, etc.
			// where we should return only the appropriate rowset when cTmpPropertySets is
			// zero.  This solves the problem if the user has more than one set specified in
			// their PROPSET_MAP.

			// Determine the number of property sets supported
			if (ppGuid == NULL)
			{
				cSets = m_cUPropSet;
			}
			else
			{
				ULONG ulActualProps = 0;
				CAutoVectorPtr < ULONG > piSetIndex;

				piSetIndex.Allocate( cSelectProps );
				if (piSetIndex == NULL)
					return E_OUTOFMEMORY;

				// Also, find the index for the set we are looking for
				ULONG l;
				for (l=0; l<cSelectProps; l++)
				{
					for (piSetIndex[l]=0; piSetIndex[l]<m_cUPropSet; piSetIndex[l]++)
					{
						if (InlineIsEqualGUID(*m_pUPropSet[piSetIndex[l]].pPropSet, *ppGuid[l]))
						{
							ulActualProps++;
							break;
						}
					}
				}

				cSets = ulActualProps;
				ulActualProps = 0;
				piIndex.Allocate( cSets );
				if (piIndex == NULL)
					return E_OUTOFMEMORY;
				for (l=0; l<cSelectProps; l++)
				{
					if (piSetIndex[l] != m_cUPropSet) // this is an invalid index
						piIndex[ulActualProps++] = piSetIndex[l];
				}

			}
		}
		else
		{
			// Since special property set guids are not supported by
			// GetProperties, we can just use the count of property
			// sets given to us.
			cSets = cTmpPropertySets;
		}							

		// If no properties set, then return
		if( cSets == 0 )
			return S_OK;

		// Allocate the DBPROPSET structures
		pPropSet = (DBPROPSET*)::ATL::AtlCoTaskMemCAlloc(cSets, static_cast<ULONG>(sizeof(DBPROPSET)));
		if(pPropSet)
		{
			memset(pPropSet, 0, cSets * sizeof(DBPROPSET));

			// Fill in the output array
			iPropSet = 0;
			for(ulSet=0; ulSet<cSets; ulSet++)
			{
				// Depending of if Property sets are specified store the
				// return property set.
				if( cTmpPropertySets == 0 )
				{
					ULONG lSet;

					if (ppGuid[ulSet] == NULL)
						lSet = ulSet;
					else
						lSet = piIndex[ulSet];
					if( m_pUPropSet[lSet].dwFlags & UPROPSET_HIDDEN )
						continue;

					pPropSet[iPropSet].guidPropertySet = *(m_pUPropSet[lSet].pPropSet);

				}
				else
				{
					pPropSet[iPropSet].guidPropertySet = rgPropertySets[ulSet].guidPropertySet; 		
				}
				iPropSet++;
			}
		}
		else
		{
			ATLTRACE(atlTraceDBProvider, 0, 
				"Could not allocate DBPROPSET array for GetProperties\n");
			return E_OUTOFMEMORY;
		}

		// Process requested or derived Property sets
		iPropSet=0;
		for(ulSet=0; ulSet<cSets; ulSet++)
		{
			cProps	= 0;
			pProp	= NULL;
			ulNext	= 0;
			dwStatus &= (GETPROP_ERRORSOCCURRED | GETPROP_VALIDPROP | GETPROP_PROPSINERROR);

			// Calculate the number of property nodes needed for this
			// property set.
			if( cTmpPropertySets == 0 )
			{
				ULONG lSet;

				if (ppGuid[ulSet] == NULL)
					lSet = ulSet;
				else
					lSet = piIndex[ulSet];

				// If processing requesting all property sets, do not
				// return the hidden sets.
				if( m_pUPropSet[lSet].dwFlags & UPROPSET_HIDDEN )
					continue;

				cProps = m_pUPropSet[lSet].cUPropInfo;

				// Add Enough space for node that are colid specific
				cProps += GetCountofColids(&(m_pUProp[lSet]));
				dwStatus |= GETPROP_ALLPROPIDS;
				ulCurSet = lSet;
			}
			else
			{
				ATLASSERT(ulSet == iPropSet);

				// If the count of PROPIDs is 0 or It is a special property set, then 
				// the consumer is requesting all propids for this property set.
				if(rgPropertySets[ulSet].cPropertyIDs == 0)
				{
					dwStatus |= GETPROP_ALLPROPIDS;
					// We have to determine if the property set is supported and if so
					// the count of properties in the set.
					BOOL bAvailable = false;
					for (ULONG l=0; l<cSelectProps; l++)
					{
						if (InlineIsEqualGUID(*ppGuid[l], rgPropertySets[ulSet].guidPropertySet))
							bAvailable |= true;
					}

					if (bAvailable && 
							GetIndexofPropSet(&(pPropSet[iPropSet].guidPropertySet), &ulCurSet) == S_OK)
					{
						cProps += m_pUPropSet[ulCurSet].cUPropInfo;
						// Add Enough space for node that are colid specific
						cProps += GetCountofColids(&m_pUProp[ulCurSet]);
						_ATLDUMPPROPSETIID(pPropSet[iPropSet].guidPropertySet, dwStatus);
					}
					else
					{
						// Not Supported					
						dwStatus |= GETPROP_ERRORSOCCURRED;
						_ATLDUMPPROPSETIID(pPropSet[iPropSet].guidPropertySet, dwStatus);
						goto NEXT_SET;
					}
				}
				else
				{
					cProps = rgPropertySets[ulSet].cPropertyIDs;
					// Check to see if this is a supported interface based on ppGuid.
					BOOL bAvailable = false;
					for (ULONG l=0; l<cSelectProps; l++)
					{
						if (InlineIsEqualGUID(*ppGuid[l], rgPropertySets[ulSet].guidPropertySet))
							bAvailable |= true;
					}

					if (!bAvailable || 
						(GetIndexofPropSet(&(pPropSet[iPropSet].guidPropertySet), &ulCurSet) != S_OK))
					{
						dwStatus |= GETPROP_NOTSUPPORTED;
						dwStatus |= GETPROP_ERRORSOCCURRED;
					}

					_ATLDUMPPROPSETIID(pPropSet[iPropSet].guidPropertySet, dwStatus);

				}
			}


			// Allocate DBPROP array
			if( cProps == 0 )			//Possible with Hidden Passthrough sets
				goto NEXT_SET;

			pProp = (DBPROP*)::ATL::AtlCoTaskMemCAlloc(cProps, static_cast<ULONG>(sizeof(DBPROP)));
			if( pProp )
			{
				// Initialize Buffer
				memset(pProp, 0, cProps * sizeof(DBPROP));
				for(ulProp=0; ulProp<cProps; ulProp++)
				{
					VariantInit(&(pProp[ulProp].vValue));
					if( dwStatus & GETPROP_NOTSUPPORTED )
					{
						// Not supported, thus we need to mark all as NOT_SUPPORTED
						pProp[ulProp].dwPropertyID	= rgPropertySets[ulSet].rgPropertyIDs[ulProp];
						pProp[ulProp].dwStatus		= DBPROPSTATUS_NOTSUPPORTED;
						_ATLDUMPPROPERTY(pProp[ulProp].dwPropertyID, pProp[ulProp].dwStatus);
					}					
				}
				// Make sure we support the property set
				if( dwStatus & GETPROP_NOTSUPPORTED )
				{
					ulNext = cProps;
					goto NEXT_SET;
				}

				// Now that we have determined we can support the property set, we
				// need to gather current property values
				for(ulProp=0; ulProp<cProps; ulProp++)
				{
					pCurProp = &(pProp[ulNext]);

					//Initialize Variant Value
					pCurProp->dwStatus = DBPROPSTATUS_OK;

					// Retrieve current value of properties
					if( dwStatus & GETPROP_ALLPROPIDS )
					{
						// Verify property is supported, if not do not return 
						if(!TESTBIT(&(m_rgdwSupported[ulCurSet * m_cElemPerSupported]), ulProp) )
							continue;

						// If we are looking for properties in error, then we should ignore all
						// that are not in error.
						if( (dwStatus & GETPROP_PROPSINERROR) &&
							!TESTBIT(&(m_rgdwPropsInError[ulCurSet * m_cElemPerSupported]), ulProp) )
							continue;

						pUPropInfo = &(m_pUPropSet[ulCurSet].pUPropInfo[ulProp]);

						ATLENSURE_RETURN( pUPropInfo );

						pCurProp->dwPropertyID = pUPropInfo->dwPropId;
						pCurProp->colid = DB_NULLID;

						// If the property is WRITEABLE or CHANGABLE, then the value will
						// be gotten from the UPROPVAL array, else it will be
						// derive from the GetDefaultValue
						if( pUPropInfo->dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
						{
							pUPropVal = &(m_pUProp[ulCurSet].
								pUPropVal[GetUPropValIndex(ulCurSet, pCurProp->dwPropertyID)]);
							ATLENSURE_RETURN( pUPropVal );

							// Check to see if this property supports column level,
							// if so, dump those nodes
							if( pUPropInfo->dwFlags & DBPROPFLAGS_COLUMNOK )
							{
								if( pUPropVal->pCColumnIds )
								{
									RetrieveColumnIdProps(pProp, pUPropVal, &ulNext);
									continue;
								}
							}

							pCurProp->dwOptions = pUPropVal->dwOption;
							hr = VariantCopy(&(pCurProp->vValue), &(pUPropVal->vValue));
						}
						else
						{
							GetDefaultValue(ulCurSet, pUPropInfo->dwPropId, 
								&(pCurProp->dwOptions), &(pCurProp->vValue));
						}

						// Return all Properties in Error with CONFLICT status
						if( dwStatus & GETPROP_PROPSINERROR )
							pCurProp->dwStatus = DBPROPSTATUS_CONFLICTING;

						dwStatus |= GETPROP_VALIDPROP;
					}
					else
					{
						// Process Properties based on Restriction array.

						pCurProp->dwPropertyID = rgPropertySets[ulSet].rgPropertyIDs[ulProp];
						pCurProp->colid = DB_NULLID;

						if( GetIndexofPropIdinPropSet(ulCurSet, pCurProp->dwPropertyID, 
							&ulCurProp) == S_OK)
						{
							// Supported
							pUPropInfo = &(m_pUPropSet[ulCurSet].pUPropInfo[ulCurProp]);
							ATLENSURE_RETURN( pUPropInfo );

							// If the property is WRITEABLE, then the value will
							// be gotten from the UPROPVAL array, else it will be
							// derive from the GetDefaultValue
							if( pUPropInfo->dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
							{
								pUPropVal = &(m_pUProp[ulCurSet].
									pUPropVal[GetUPropValIndex(ulCurSet, pCurProp->dwPropertyID)]);
								ATLENSURE_RETURN( pUPropVal );

								// Check to see if this property supports column level,
								// if so, dump those nodes
								if( pUPropInfo->dwFlags & DBPROPFLAGS_COLUMNOK )
								{
									if( pUPropVal->pCColumnIds )
									{
										RetrieveColumnIdProps(pProp, pUPropVal, &ulNext);
										continue;
									}
								}
								pCurProp->dwOptions = pUPropVal->dwOption;
								hr = VariantCopy(&(pCurProp->vValue), &(pUPropVal->vValue));
							}
							else
							{
								GetDefaultValue(ulCurSet, pUPropInfo->dwPropId, 
									&(pCurProp->dwOptions), &(pCurProp->vValue));

							}

							dwStatus |= GETPROP_VALIDPROP;
						}
						else
						{
							// Not Supported
							pCurProp->dwStatus = DBPROPSTATUS_NOTSUPPORTED;
							dwStatus |= GETPROP_ERRORSOCCURRED;
						}
					}

					_ATLDUMPPROPERTY(pCurProp->dwPropertyID, pCurProp->dwStatus);
					// Increment return nodes count
					ulNext++;
				}
			}
			else
			{
				ATLTRACE(atlTraceDBProvider, 0, _T("Could not allocate DBPROP array for GetProperties\n"));
				if( pPropSet )
				{
					//Since we have no properties to return, then we
					//need to free allocated memory and return 0,NULL
					for(ulSet=0; ulSet<cSets; ulSet++)
					{
						// Need to loop through all the VARIANTS and clear them
						for(ulProp=0; ulProp<pPropSet[ulSet].cProperties; ulProp++)
							VariantClear(&(pPropSet[ulSet].rgProperties[ulProp].vValue));
						CoTaskMemFree(pPropSet[ulSet].rgProperties);
					}

					// Free DBPROPSET
					CoTaskMemFree(pPropSet);
				}
				*pcProperties = 0;
				*prgProperties = NULL;
				return E_OUTOFMEMORY;
			}

NEXT_SET:
			// It is possible that all properties are not supported,
			// thus we should delete that memory and set rgProperties
			// to NULL
			if( ulNext == 0 && pProp )
			{
				CoTaskMemFree(pProp);
				pProp = NULL;
			}

			pPropSet[iPropSet].cProperties = ulNext;
			pPropSet[iPropSet].rgProperties = pProp;
			iPropSet++;
		}

		*pcProperties = iPropSet;
		*prgProperties = pPropSet;

		piIndex.Free();

		// At least one propid was marked as not S_OK
		if( dwStatus & GETPROP_ERRORSOCCURRED )
		{
			// If at least 1 property was set
			if( dwStatus & GETPROP_VALIDPROP )
				return DB_S_ERRORSOCCURRED;
			else
			{
				// Do not free any of the memory on a DB_E_
				return DB_E_ERRORSOCCURRED;
			}
		}

		return S_OK;
	}

	ULONG GetCountofColids(UPROP* pUProp)
	{
		ULONG	cExtra=0;
		ATLENSURE(pUProp);
		for(ULONG ul=0; ul<pUProp->cPropIds; ul++)
		{
			if( pUProp->pUPropVal[ul].pCColumnIds )
				cExtra += (pUProp->pUPropVal[ul].pCColumnIds)->GetCountOfPropColids();
		}
		return cExtra;
	}

	ULONG GetUPropValIndex(ULONG iCurSet, DBPROPID dwPropId)
	{
		for(ULONG ul=0; ul<m_pUProp[iCurSet].cPropIds; ul++)
		{
			if( (m_pUProp[iCurSet].rgpUPropInfo[ul])->dwPropId == dwPropId )
				return ul;
		}
		return 0;
	}

	void RetrieveColumnIdProps(DBPROP* pCurProp, UPROPVAL* pUPropVal, ULONG* pulNext)
	{
		// Reset to first Node
		CColumnIds* pColIds = pUPropVal->pCColumnIds;
		HRESULT hr = E_FAIL;
		for (size_t i = 0; i < pColIds->GetCount(); i++)
		{
			CPropColID colId; 
			hr = pColIds->GetValue(i, &(pCurProp->dwOptions), &(pCurProp->colid),&(pCurProp->vValue));
			if (SUCCEEDED(hr))
				pCurProp = &(pCurProp[++(*pulNext)]);
		}
		(*pulNext)++;
	}

	//Check the arguments for Retrieve Properties
	HRESULT	GetPropertiesArgChk(const ULONG cPropertySets, const DBPROPIDSET rgPropertySets[], 
								ULONG* pcProperties, DBPROPSET** prgProperties)
	{
		// Initialize values
		if(pcProperties)
			*pcProperties = 0;
		if(prgProperties)
			*prgProperties = NULL;	

		// Check Arguments
		if( ((cPropertySets > 0) && !rgPropertySets) || !pcProperties || !prgProperties )
			return E_INVALIDARG;

		// New argument check for > 1 cPropertyIDs and NULL pointer for 
		// array of property ids.
		for(ULONG ul=0; ul<cPropertySets; ul++)
		{
			if( rgPropertySets[ul].cPropertyIDs && !(rgPropertySets[ul].rgPropertyIDs) )
				return E_INVALIDARG;

			// Check for propper formation of DBPROPSET_PROPERTIESINERROR
			if( (m_dwFlags & ARGCHK_PROPERTIESINERROR) &&
				rgPropertySets[ul].guidPropertySet == DBPROPSET_PROPERTIESINERROR )
			{
				if( (cPropertySets > 1) ||
					(rgPropertySets[ul].cPropertyIDs != 0) ||
					(rgPropertySets[ul].rgPropertyIDs != NULL) )
					return E_INVALIDARG;
			}
		}

		return S_OK;
	}

	OUT_OF_LINE HRESULT	FInit(CUtlPropsBase* pCopyMe = NULL) = 0;
};

// Implementation Class 
template <class T>
class ATL_NO_VTABLE CUtlProps : public CUtlPropsBase
{
public:

	CUtlProps(DWORD dwFlags = 0)
	{
		ClearMemberVars();
		m_dwFlags = dwFlags;
	}
	~CUtlProps()
	{
		FreeMemory();
	}
	void FreeMemory()
	{
		// Remove Property Information
		if( m_pUProp )
		{
			for(ULONG ulPropSet=0; ulPropSet<m_cUPropSet; ulPropSet++)
			{
				UPROPVAL* pUPropVal = m_pUProp[ulPropSet].pUPropVal;
				for(ULONG ulPropId=0; ulPropId<m_pUProp[ulPropSet].cPropIds; ulPropId++)
				{
					delete pUPropVal[ulPropId].pCColumnIds;
					VariantClear(&(pUPropVal[ulPropId].vValue));
				}
				delete[] m_pUProp[ulPropSet].rgpUPropInfo;
				delete[] m_pUProp[ulPropSet].pUPropVal;
			}

		}

		m_pUProp.Free();
		m_rgdwSupported.Free();
		m_rgdwPropsInError.Free();
		m_rgiPropSetDex.Free();
		CoTaskMemFree(m_pUPropSet);
		ClearMemberVars();
	}
	void ClearMemberVars()
	{
		m_cPropSetDex		= 0;
		m_cUPropSet			= 0;
		m_cUPropSetHidden	= 0;
		m_pUPropSet			= NULL;

		m_dwFlags			= 0;

		m_cElemPerSupported	= 0;
	}

	//Retrieve the property set indexes that match this property set.
	HRESULT	GetPropertySetIndex(GUID* pPropertySet)
	{
		DWORD	dwFlag = 0;
		ULONG	ulSet;

		ATLASSUME( m_cUPropSet && m_pUPropSet );
		ATLASSUME( m_rgiPropSetDex );
		ATLASSERT( pPropertySet );

		m_cPropSetDex = 0;

		if( *pPropertySet == DBPROPSET_DATASOURCEALL )
		{
			dwFlag = DBPROPFLAGS_DATASOURCE;
		}
		else if( *pPropertySet == DBPROPSET_DATASOURCEINFOALL )
		{
			dwFlag = DBPROPFLAGS_DATASOURCEINFO;
		}
		else if( *pPropertySet == DBPROPSET_ROWSETALL )
		{
			dwFlag = DBPROPFLAGS_ROWSET;
		}
		else if( *pPropertySet == DBPROPSET_DBINITALL )
		{
			dwFlag = DBPROPFLAGS_DBINIT;
		}
		else if( *pPropertySet == DBPROPSET_SESSIONALL )
		{
			dwFlag = DBPROPFLAGS_SESSION;
		}
		else if( *pPropertySet == DBPROPSET_COLUMNALL)
		{
			dwFlag = DBPROPFLAGS_COLUMN;
		}
		else if( *pPropertySet == DBPROPSET_INDEXALL)
		{
			dwFlag = DBPROPFLAGS_INDEX;
		}
		else if( *pPropertySet == DBPROPSET_TABLEALL)
		{
			dwFlag = DBPROPFLAGS_TABLE;
		}
		else if( *pPropertySet == DBPROPSET_TRUSTEEALL)
		{
			dwFlag = DBPROPFLAGS_TRUSTEE;
		}
		else if( *pPropertySet == DBPROPSET_VIEWALL)
		{
			dwFlag = DBPROPFLAGS_VIEW;
		}
		else // No scan required, just look for match.
		{
			for(ulSet=0; ulSet<m_cUPropSet; ulSet++)
			{
				if( *(m_pUPropSet[ulSet].pPropSet) == *pPropertySet )
				{
					m_rgiPropSetDex[m_cPropSetDex] = ulSet;
					m_cPropSetDex++;
					break;
				}
			}
			goto EXIT;
		}

		// Scan through the property sets looking for matching attributes
		for(ulSet=0; ulSet<m_cUPropSet; ulSet++)
		{
			if( m_pUPropSet[ulSet].pUPropInfo[0].dwFlags & dwFlag )
			{
				m_rgiPropSetDex[m_cPropSetDex] = ulSet;
				m_cPropSetDex++;
			}
		}

EXIT:
		return (m_cPropSetDex) ? S_OK : S_FALSE;
	}

	OUT_OF_LINE HRESULT	GetDefaultValue(ULONG iPropSet, DBPROPID dwPropId, DWORD* pdwOption, VARIANT* pVar)
	{
		return InternalGetDefaultValue(T::_GetPropSet, iPropSet, dwPropId, pdwOption, pVar);
	}

	OUT_OF_LINE HRESULT	FInit(CUtlPropsBase* pCopyMe = NULL)
	{
		return InternalFInit(T::_GetPropSet, pCopyMe);
	}
	HRESULT	FillDefaultValues(ULONG ulPropSetTarget = ULONG_MAX)
	{
		HRESULT		hr;
		ULONG		ulPropId;
		ULONG		iPropSet;
		ULONG		iNewDex;

		// Fill in all the actual values.
		// Typically because we now have an hdbc with which to get them.
		// (Or we no longer have an hdbc, so must clear them.)
		// Note that the UPROP (with values) array may be a subset of the UPROPINFO array.
		// Only writable properties are in UPROP array.

		// Maybe restrict to a single PropSet if within valid range [0...m_cUPropSet-1].
		// Otherwise do all propsets.
		iPropSet = (ulPropSetTarget < m_cUPropSet) ? ulPropSetTarget : 0;

		for( ; iPropSet<m_cUPropSet; iPropSet++)
		{
			iNewDex = 0;
			for(ulPropId=0; ulPropId<m_pUPropSet[iPropSet].cUPropInfo; ulPropId++)
			{
				if( m_pUPropSet[iPropSet].pUPropInfo[ulPropId].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
				{
					//Initialize dwFlags element of UPropVal
					m_pUProp[iPropSet].pUPropVal[iNewDex].dwFlags = 0;

					// Don't need this since SetProperties() resets these.
					//ATLASSUME( m_pUProp[iPropSet].pUPropVal[iNewDex].dwOption == DBPROPOPTIONS_SETIFCHEAP);
					ATLASSUME( m_pUProp[iPropSet].pUPropVal[iNewDex].pCColumnIds == NULL);

					VariantClear(&m_pUProp[iPropSet].pUPropVal[iNewDex].vValue);
					hr = GetDefaultValue(
							iPropSet, 
							m_pUPropSet[iPropSet].pUPropInfo[ulPropId].dwPropId, 
							&m_pUProp[iPropSet].pUPropVal[iNewDex].dwOption, 
							&m_pUProp[iPropSet].pUPropVal[iNewDex].vValue );
					if (FAILED(hr))
						return hr;
					iNewDex++;
				}
			}

			// We're through if restricting to single PropSet.
			if (ulPropSetTarget < m_cUPropSet)
				break;
		}
		return NOERROR;
	}

	// Translate Rowset IIDs to PROPSET structures ready to pass to SetProperties
	HRESULT	ConvertRowsetIIDtoDBPROPSET(const IID* piid, DBPROPSET* pPropSet)
	{
		HRESULT		hr = S_OK;
		DBPROP*		pProp;

		ATLASSERT( piid || pPropSet );
		ATLASSERT( (pPropSet->cProperties == 1) || (pPropSet->rgProperties) );

		pProp = &(pPropSet->rgProperties[0]);

		if(InlineIsEqualGUID(*piid, __uuidof(IAccessor)))
			pProp->dwPropertyID = DBPROP_IAccessor;
		else if(InlineIsEqualGUID(*piid,__uuidof(IColumnsInfo)))
			pProp->dwPropertyID = DBPROP_IColumnsInfo;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowset)))
			pProp->dwPropertyID = DBPROP_IRowset;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetInfo)))
			pProp->dwPropertyID = DBPROP_IRowsetInfo;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetLocate)))
			pProp->dwPropertyID = DBPROP_IRowsetLocate;
		else if(InlineIsEqualGUID(*piid , __uuidof(IColumnsRowset)))
			pProp->dwPropertyID = DBPROP_IColumnsRowset;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetResynch)))
			pProp->dwPropertyID = DBPROP_IRowsetResynch;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetScroll)))
			pProp->dwPropertyID = DBPROP_IRowsetScroll;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetChange)))
			pProp->dwPropertyID = DBPROP_IRowsetChange;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetUpdate)))
			pProp->dwPropertyID = DBPROP_IRowsetUpdate;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetIdentity)))
			pProp->dwPropertyID = DBPROP_IRowsetIdentity;
		else if(InlineIsEqualGUID(*piid , __uuidof(IConnectionPointContainer)))
			pProp->dwPropertyID = DBPROP_IConnectionPointContainer;
		else if(InlineIsEqualGUID(*piid , __uuidof(ISupportErrorInfo)))
			pProp->dwPropertyID = DBPROP_ISupportErrorInfo;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetIndex)))
			pProp->dwPropertyID = DBPROP_IRowsetIndex;
	#if( OLEDBVER >= 0x0200 )
		else if(InlineIsEqualGUID(*piid , __uuidof(IProvideMoniker)))
			pProp->dwPropertyID = DBPROP_IProvideMoniker;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetNotify)))
			pProp->dwPropertyID = DBPROP_IRowsetNotify;
		else if(InlineIsEqualGUID(*piid , __uuidof(IReadData)))
			pProp->dwPropertyID = DBPROP_IReadData;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetExactScroll)))
			pProp->dwPropertyID = DBPROP_IRowsetExactScroll;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetNextRowset)))
			pProp->dwPropertyID = DBPROP_IRowsetNextRowset;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetNewRowAfter)))
			pProp->dwPropertyID = DBPROP_IRowsetNewRowAfter;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetWithParameters)))
			pProp->dwPropertyID = DBPROP_IRowsetWithParameters;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetFind)))
			pProp->dwPropertyID = DBPROP_IRowsetFind;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetAsynch)))
			pProp->dwPropertyID = DBPROP_IRowsetAsynch;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetKeys)))
			pProp->dwPropertyID = DBPROP_IRowsetKeys;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetWatchAll)))
			pProp->dwPropertyID = DBPROP_IRowsetWatchAll;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetWatchNotify)))
			pProp->dwPropertyID = DBPROP_IRowsetWatchNotify;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetWatchRegion)))
			pProp->dwPropertyID = DBPROP_IRowsetWatchRegion;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetCopyRows)))
			pProp->dwPropertyID = DBPROP_IRowsetCopyRows;
	#endif //#if( OLEDBVER >= 0x0200 )
		else
			hr = S_FALSE;

		// If the IID can be mapped to a DBPROPID, the
		// we need to initialize the vValue to TRUE
		if(hr == S_OK)
		{
			// Set PropertySet
			pPropSet->guidPropertySet = DBPROPSET_ROWSET;

			// Set Property 
			pProp->dwOptions = DBPROPOPTIONS_REQUIRED;
			pProp->dwStatus = 0; 
			pProp->colid = DB_NULLID;

			VariantInit(&(pProp->vValue));
			pProp->vValue.vt = VT_BOOL;
			V_BOOL(&(pProp->vValue)) = ATL_VARIANT_TRUE;
		}

		return hr;
	}


	void SetPropertyInError(const ULONG iPropSet, const ULONG iPropId)
	{
		SETBIT(&(m_rgdwPropsInError[iPropSet * m_cElemPerSupported]), iPropId);
	}

	BOOL IsPropSet(const GUID* pguidPropSet, DBPROPID dwPropId)
	{
		HRESULT		hr;
		ULONG		iPropSet;
		ULONG		iPropId;
		VARIANT		vValue;
		DWORD		dwOptions;

		VariantInit(&vValue);

		if( GetIndexofPropSet(pguidPropSet, &iPropSet) == S_OK )
		{
			if( GetIndexofPropIdinPropSet(iPropSet, dwPropId, &iPropId) == S_OK )
			{		
				if( m_pUPropSet[iPropSet].pUPropInfo[iPropId].dwFlags & 
					(DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
				{
					ULONG iPropVal = GetUPropValIndex(iPropSet, dwPropId);

					dwOptions = m_pUProp[iPropSet].pUPropVal[iPropVal].dwOption;
					hr = VariantCopy(&vValue, &(m_pUProp[iPropSet].
						pUPropVal[iPropVal].vValue));
				}
				else
				{
					hr = GetDefaultValue(iPropSet, dwPropId, 
						&dwOptions, &vValue);
				}

				if( dwOptions == DBPROPOPTIONS_REQUIRED )
				{
					ATLASSERT( vValue.vt == VT_BOOL );
					if( SUCCEEDED(hr) && 
						(V_BOOL(&vValue) != ATL_VARIANT_FALSE) )
					{
						VariantClear(&vValue);
						return TRUE;
					}
				}
			}
		}

		VariantClear(&vValue);
		return FALSE;
	}
	OUT_OF_LINE HRESULT	GetPropValue(const GUID* pguidPropSet, DBPROPID dwPropId, VARIANT* pvValue)
	{
		HRESULT		hr = E_FAIL;
		ULONG		iPropSet;
		ULONG		iPropId;
		DWORD		dwOptions;
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);

		if( GetIndexofPropSet(pguidPropSet, &iPropSet) == S_OK )
		{
			if( GetIndexofPropIdinPropSet(iPropSet, dwPropId, &iPropId) == S_OK )
			{		
				if( m_pUPropSet[iPropSet].pUPropInfo[iPropId].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
				{
					hr = VariantCopy(pvValue, &(m_pUProp[iPropSet].pUPropVal[
						GetUPropValIndex(iPropSet, dwPropId)].vValue));
				}
				else
				{
					VariantClear(pvValue);

					hr = GetDefaultValue(iPropSet, dwPropId, 
						&dwOptions, pvValue);
				}
			}
		}

		return hr;
	}
	HRESULT	SetPropValue(const GUID* pguidPropSet,DBPROPID dwPropId, VARIANT* pvValue)
	{
		HRESULT		hr = E_FAIL;
		ULONG		iPropSet;
		ULONG		iPropId;
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);

		if( GetIndexofPropSet(pguidPropSet, &iPropSet) == S_OK )
		{
			if( GetIndexofPropIdinPropSet(iPropSet, dwPropId, &iPropId) == S_OK )
			{		
				ATLASSUME( m_pUPropSet[iPropSet].pUPropInfo[iPropId].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) );

				hr = VariantCopy(&(m_pUProp[iPropSet].pUPropVal[
						GetUPropValIndex(iPropSet, dwPropId)].vValue), pvValue);
			}
		}

		return hr;
	}


	//Pointer to properties in error mask
	DWORD* GetPropsInErrorPtr(){return m_rgdwPropsInError;}
	ULONG GetUPropSetCount() {return m_cUPropSet;}
	void SetUPropSetCount(ULONG c) {m_cUPropSet = c;}

	// NOTE: The following functions depend on all prior
	// properties in the array being writable.
	// This is because the UPROP array contains only writable elements,
	// and the UPROPINFO array contains writable and read-only elements.
	// (If this is a problem, we would need to define which one it came from
	// and add the appropriate ATLASSERTs...)

	//Get DBPROPOPTIONS_xx
	DWORD GetPropOption(ULONG iPropSet, ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		return m_pUProp[iPropSet].pUPropVal[iProp].dwOption;
	}
	//Set DBPROPOPTIONS_xx
	void SetPropOption(ULONG iPropSet, ULONG iProp, DWORD dwOption)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		m_pUProp[iPropSet].pUPropVal[iProp].dwOption = dwOption;
	}
	//Determine if property is required and variant_true
	BOOL IsRequiredTrue(ULONG iPropSet, ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		ATLASSUME(m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_BOOL);

		return( (m_pUProp[iPropSet].pUPropVal[iProp].dwOption == DBPROPOPTIONS_REQUIRED) &&
				(V_BOOL(&m_pUProp[iPropSet].pUPropVal[iProp].vValue) != ATL_VARIANT_FALSE) );
	}
	DWORD GetInternalFlags(ULONG iPropSet, ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		return m_pUProp[iPropSet].pUPropVal[iProp].dwFlags;
	}
	void AddInternalFlags(ULONG iPropSet, ULONG iProp, DWORD dwFlags)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		m_pUProp[iPropSet].pUPropVal[iProp].dwFlags |= dwFlags;
	}
	void RemoveInternalFlags(ULONG iPropSet, ULONG iProp, DWORD dwFlags)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		m_pUProp[iPropSet].pUPropVal[iProp].dwFlags &= ~dwFlags;
	}
	VARIANT * GetVariant(ULONG iPropSet, ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		return & m_pUProp[iPropSet].pUPropVal[iProp].vValue;
	}
	HRESULT SetVariant(ULONG iPropSet, ULONG iProp, VARIANT *pv )
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		// Does VariantClear first.
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		return VariantCopy( &m_pUProp[iPropSet].pUPropVal[iProp].vValue, pv );
	}
	void SetValEmpty(ULONG iPropSet, ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		VariantClear( &m_pUProp[iPropSet].pUPropVal[iProp].vValue );
	}
	BOOL IsEmpty(ULONG iPropSet, ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		return ( m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_EMPTY);
	}
	void SetValBool(ULONG iPropSet, ULONG iProp, VARIANT_BOOL bVal)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		// Note that we accept any "true" value.
		VariantClear(&m_pUProp[iPropSet].pUPropVal[iProp].vValue);
		m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt = VT_BOOL;
		V_BOOL(&m_pUProp[iPropSet].pUPropVal[iProp].vValue) = (bVal ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
	}
	VARIANT_BOOL GetValBool(ULONG iPropSet, ULONG iProp)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		ATLASSUME(m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_BOOL);
		return V_BOOL(&m_pUProp[iPropSet].pUPropVal[iProp].vValue);
	}
	void SetValShort(ULONG iPropSet, ULONG iProp, SHORT iVal )
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		VariantClear(&m_pUProp[iPropSet].pUPropVal[iProp].vValue);
		m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt = VT_I2;
		m_pUProp[iPropSet].pUPropVal[iProp].vValue.iVal = iVal;
	}
	SHORT GetValShort(ULONG iPropSet, ULONG iProp)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		ATLASSUME(m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_I2);
		return m_pUProp[iPropSet].pUPropVal[iProp].vValue.iVal;
	}
	void SetValLong(ULONG iPropSet, ULONG iProp, LONG lVal)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		VariantClear(&m_pUProp[iPropSet].pUPropVal[iProp].vValue);
		m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt = VT_I4;
		m_pUProp[iPropSet].pUPropVal[iProp].vValue.lVal = lVal;
	}
	LONG GetValLong(ULONG iPropSet, ULONG iProp)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		ATLASSUME(m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_I4);
		return m_pUProp[iPropSet].pUPropVal[iProp].vValue.lVal;
	}
	HRESULT SetValString(ULONG iPropSet, ULONG iProp, const WCHAR *pwsz)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		VARIANT *pv = &m_pUProp[iPropSet].pUPropVal[iProp].vValue;
		VariantClear(pv);
		pv->bstrVal = SysAllocString(pwsz);
		if (pv->bstrVal)
			pv->vt = VT_BSTR;
		else
			return E_FAIL;

		// See if this was used for non-string type.
		// Typically this is an easy way to pass integer as a string.
		if (GetExpectedVarType(iPropSet,iProp) == VT_BSTR)
			return NOERROR;
		if (pwsz[0] != L'\0')
		{
			HRESULT hr=VariantChangeType( pv, pv, 0, GetExpectedVarType(iPropSet,iProp) );
			if(FAILED(hr))
			{
				pv->vt = VT_EMPTY;
			}
			return hr;
		}

		// Set to "", which for non-string means empty.
		SysFreeString(pv->bstrVal);
		return NOERROR;
	}
	const WCHAR * GetValString(ULONG iPropSet, ULONG iProp)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		ATLASSUME(m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_BSTR);
		return m_pUProp[iPropSet].pUPropVal[iProp].vValue.bstrVal;
	}
	const GUID * GetGuid(ULONG iPropSet)
	{
		ATLASSERT(iPropSet < m_cUPropSet);
		return m_pUPropSet[iPropSet].pPropSet;
	}
	DWORD GetPropID(ULONG iPropSet, ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		return m_pUPropSet[iPropSet].pUPropInfo[iProp].dwPropId;
	}
	VARTYPE GetExpectedVarType(ULONG iPropSet, ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		return m_pUPropSet[iPropSet].pUPropInfo[iProp].VarType;
	}
	virtual HRESULT	GetIndexofPropSet(const GUID* pPropSet, ULONG* pulCurSet)
	{
		ATLENSURE_RETURN(pPropSet && pulCurSet);

		for(ULONG ul=0; ul<m_cUPropSet; ul++)
		{
			if( *pPropSet == *(m_pUPropSet[ul].pPropSet) )
			{
				*pulCurSet = ul;
				return S_OK;
			}
		}
		return S_FALSE;
	}


	virtual HRESULT OnPropertyChanged(ULONG /*iCurSet*/, DBPROP* pDBProp)
	{
		// Prevent Level 4 warnings.
		pDBProp;
__if_exists(T::CreateAccessor)
{
		ATLENSURE_RETURN(pDBProp != NULL);
		DWORD dwPropertyID = pDBProp->dwPropertyID;
		CComVariant var = pDBProp->vValue;

		switch(dwPropertyID)
		{
		case DBPROP_IRowsetLocate:
		case DBPROP_LITERALBOOKMARKS:
		case DBPROP_ORDEREDBOOKMARKS:
			{
				CDBPropSet set(DBPROPSET_ROWSET);
				CComVariant newVar;
				bool bVal;
				if (var.boolVal == ATL_VARIANT_TRUE)
					bVal = true;
				else
					bVal = false;

				newVar = bVal;

				// Set the bookmarks property as they are chained.  We also need to
				// turn off IRowsetLocate if we're setting BOOKMARKS to false (see
				// the DBPROP_BOOKMARKS case statement.  
				if (var.boolVal == ATL_VARIANT_FALSE)	
					SetPropValue(&DBPROPSET_ROWSET, DBPROP_IRowsetLocate, &newVar);

				SetPropValue(&DBPROPSET_ROWSET, DBPROP_BOOKMARKS, &newVar);

				// If you set IRowsetLocate to true, then the rowset can
				// handle backward scrolling
				if (dwPropertyID == DBPROP_IRowsetLocate)
					SetPropValue(&DBPROPSET_ROWSET, DBPROP_CANSCROLLBACKWARDS, &newVar);

				return S_OK;
			}
			break;

		case DBPROP_IRowsetScroll:
			{
				CDBPropSet set(DBPROPSET_ROWSET);

				if (var.boolVal == ATL_VARIANT_TRUE)
				{
					if(!set.AddProperty(DBPROP_IRowsetLocate, true))
					{
						return E_FAIL;
					}
					if(!set.AddProperty(DBPROP_BOOKMARKS, true))
					{
						return E_FAIL;
					}
					if(!set.AddProperty(DBPROP_CANSCROLLBACKWARDS, true))
					{
						return E_FAIL;
					}
				}

				const GUID* ppGuid[1];
				ppGuid[0] = &DBPROPSET_ROWSET;

				return SetProperties(0, 1, &set, 1, ppGuid);
			}
			break;

		case DBPROP_BOOKMARKS:
			{
				if (var.boolVal == ATL_VARIANT_FALSE)
				{
					// Since we support bookmarks, if someone sets DBPROP_BOOKMARKS
					// to ATL_VARIANT_FALSE and DBPROP_IRowsetLocate is ATL_VARIANT_TRUE,
					// then we should return an error.  This is an invalid 
					// combination of properties.
					CComVariant locateVar;
					HRESULT hr = GetPropValue(&DBPROPSET_ROWSET, 
						DBPROP_IRowsetLocate, &locateVar);
					if (SUCCEEDED(hr) && locateVar.boolVal == ATL_VARIANT_TRUE)
					{
						// If the DBPROP_BOOKMARKS is set to required, return
						// DB_E_ERRORSOCCURRED.  Otherwise, set it to 
						// DB_S_ERRORSOCCURRED.  Note, we won't reset the property
						// since setting IRowsetLocate to ATL_VARIANT_TRUE will
						// set DBPROP_BOOKMARKS to ATL_VARIANT_TRUE
						pDBProp->dwStatus = DBPROPSTATUS_CONFLICTING;

						if (pDBProp->dwOptions == DBPROPOPTIONS_REQUIRED)
							return DB_E_ERRORSOCCURRED;
						else
							return DB_S_ERRORSOCCURRED;
					}
				}
			}
			break;

		// This code should only be included if you are a command or rowset.
		case DBPROP_UPDATABILITY:
			{
				if (var.lVal != 0)
				{
					CComVariant changeVar;
					HRESULT hr = GetPropValue(&DBPROPSET_ROWSET, 
						DBPROP_IRowsetChange, &changeVar);
					if (FAILED(hr) || changeVar.boolVal == ATL_VARIANT_FALSE)
					{
						// It doesn't make sense to set DBPROP_UPDATABILITY
						// if DBPROP_IRowsetChange is FALSE (i.e. no updates)
						pDBProp->dwStatus = DBPROPSTATUS_CONFLICTING;

						if (pDBProp->dwOptions == DBPROPOPTIONS_REQUIRED)
							return DB_E_ERRORSOCCURRED;
						else
							return DB_S_ERRORSOCCURRED;
					}
				}
			}

			// Update the IAccessor::m_bIsChangeable flag as necessary

			// Hold off on this for now, it appears to be causing a GPF becuase
			// we're writing this off the session.
//			pT->m_bIsChangeable = (var.iVal & DBPROPVAL_UP_INSERT);
			break;

		case DBPROP_IRowsetUpdate:
			{	
				// Set the DBPROP_IRowsetChange and DBPROP_IRowsetUpdate flags.
				// Setting DBPROP_IRowsetUpdate to true sets DBPROP_IRowsetChange
				// to true

				if (var.boolVal == ATL_VARIANT_TRUE)
				{
					CComVariant changeVar(true);
					CDBPropSet set(DBPROPSET_ROWSET);
					if(!set.AddProperty(DBPROP_IRowsetChange, changeVar))
					{
						return E_FAIL;
					}

					const GUID* ppGuid[1];
					ppGuid[0] = &DBPROPSET_ROWSET;

					return SetProperties(0, 1, &set, 1, ppGuid);
				}
			}
			break;

		default:
			break;
		}
}

		return S_OK;
	}

	virtual HRESULT	InitUPropSetsSupported()
	{
		return InternalInitUPropSetsSupported(T::_GetPropSet);
	}

	HRESULT GetIndexOfPropertyInSet(const GUID* pPropSet, DBPROPID dwPropertyId, ULONG* piCurPropId, ULONG* piCurSet)
	{
		HRESULT hr = GetIndexofPropSet(pPropSet, piCurSet);
		if (hr == S_FALSE)
			return hr;
		UPROPINFO* pUPropInfo = m_pUPropSet[*piCurSet].pUPropInfo;
		for(ULONG ul=0; ul<m_pUPropSet[*piCurSet].cUPropInfo; ul++)
		{
			if( dwPropertyId == pUPropInfo[ul].dwPropId )
				*piCurPropId = ul;
			return S_OK;
		}

		return S_FALSE;
	}
	HRESULT SetSupportedBit(const GUID* pPropSet, DBPROPID dwPropertyId)
	{
		ULONG iCurPropId, iCurSet;

		if (GetIndexOfPropertyInSet(pPropSet, dwPropertyId, &iCurPropId, &iCurSet) == S_OK)
		{
			m_rgdwSupported[iCurSet * m_cElemPerSupported] |= 1 << iCurPropId;
			return S_OK;
		}
		return S_FALSE;
	}

	HRESULT ClearSupportedBit(const GUID* pPropSet, DBPROPID dwPropertyId)
	{
		ULONG iCurPropId, iCurSet;

		if (GetIndexOfPropertyInSet(pPropSet, dwPropertyId, &iCurPropId, &iCurSet) == S_OK)
		{
			m_rgdwSupported[iCurSet * m_cElemPerSupported] &= ~( 1 << iCurPropId);
			return S_OK;
		}
		return S_FALSE;
	}

	HRESULT TestSupportedBit(const GUID* pPropSet, DBPROPID dwPropertyId, bool& bSet)
	{
		ULONG iCurPropId, iCurSet;

		if (GetIndexOfPropertyInSet(pPropSet, dwPropertyId, &iCurPropId, &iCurSet) == S_OK)
		{
			bSet = (m_rgdwSupported[iCurSet * m_cElemPerSupported] & ( 1 << iCurPropId)) != 0;
			return S_OK;
		}
		return S_FALSE;
	}
	void CopyPropsInError(DWORD* rgdwSupported)
	{
		Checked::memcpy_s(rgdwSupported, m_cUPropSet * m_cElemPerSupported * sizeof(DWORD), 
			m_rgdwPropsInError, m_cUPropSet * m_cElemPerSupported * sizeof(DWORD));
	}
};

// IDBPropertiesImpl
// IDBProperties <- IUnknown
template <class T>
class ATL_NO_VTABLE IDBPropertiesImpl : public IDBProperties, public CUtlProps<T>
{
public:
	STDMETHOD(GetProperties)(ULONG cPropertySets,
							 const DBPROPIDSET rgPropertySets[],
							 ULONG *pcProperties,
							 DBPROPSET **prgProperties)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBPropertiesImpl::GetProperties\n"));
		T* pT = (T*)this;

		// You can get PROPERTIESINERROR on IDBProperties::GetProperties so do the 
		// appropriate argument checking for it.
		m_dwFlags |= ARGCHK_PROPERTIESINERROR;
		HRESULT hr = GetPropertiesArgChk(cPropertySets, rgPropertySets, pcProperties, prgProperties);
		if (FAILED(hr))
			return hr;

		if (SUCCEEDED(hr))
		{
			// To allow user defined property groups, we'll scan the property
			// sets.  

			ULONG ulPropSets = 0;
			ULONG ulPropElems = 0;
			ULONG ulPropInits = 0;
			UPROPSET* pSetA = NULL;
			UPROPSET* pSetTemp = NULL;
			ULONG l=0;
			ULONG cSets = (ULONG)(ULONG_PTR)pT->_GetPropSet(NULL, &ulPropElems);

			CTempBuffer<UPROPSET> tmpBuffer;
			pSetA = tmpBuffer.Allocate(cSets);
			if (pSetA == NULL)
				return E_OUTOFMEMORY;  // We shouldn't get this but...
			pSetTemp = pT->_GetPropSet(&ulPropSets, &ulPropElems, pSetA);

			typedef const GUID* PCGUID;

			if (pT->m_dwStatus & DSF_INITIALIZED)
			{
				for(l=0; l<cSets; l++)
				{
					if (pSetTemp[l].bIsChained != true)
						ulPropInits++;
				}

				CTempBuffer<PCGUID> tmpBuffer2;
				PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
				if (ppGuid == NULL)
					return E_OUTOFMEMORY;

				ulPropInits = 0;
				for (l=0; l<cSets; l++)
				{
					if (pSetTemp[l].bIsChained != true)
						ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
				}

				hr = CUtlProps<T>::GetProperties(cPropertySets, rgPropertySets,
							pcProperties, prgProperties, ulPropInits, ppGuid);
			}
			else
			{
				// Only pass through initialization groups
				for(l=0; l<cSets; l++)
				{
					if (IsEqualGUID(*pSetTemp[l].pPropSet, DBPROPSET_DBINIT) ||
						pSetTemp[l].dwFlags & UPROPSET_USERINIT)
						ulPropInits++;
				}
				CTempBuffer<PCGUID> tmpBuffer2;
				PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
				if (ppGuid == NULL)
					return E_OUTOFMEMORY;

				ulPropInits = 0;
				for(l=0; l<cSets; l++)
				{
					if (IsEqualGUID(*pSetTemp[l].pPropSet, DBPROPSET_DBINIT) ||
						pSetTemp[l].dwFlags & UPROPSET_USERINIT)
						ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
				}

				hr = CUtlProps<T>::GetProperties(cPropertySets, rgPropertySets, 
							pcProperties, prgProperties, ulPropInits, ppGuid);
			}
		}

		m_dwFlags |= ~ARGCHK_PROPERTIESINERROR;
		return hr;
	}

	STDMETHOD(GetPropertyInfo)(ULONG cPropertySets,
							   const DBPROPIDSET rgPropertySets[],
							   ULONG *pcPropertyInfoSets,
							   DBPROPINFOSET **prgPropertyInfoSets,
							   OLECHAR **ppDescBuffer)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBPropertiesImpl::GetPropertyInfo\n"));
		T* pT = static_cast<T*>(this);
		T::ObjectLock cab(pT);

		if (pT->m_pCUtlPropInfo == NULL)
		{
			// Go ahead and create the m_pCUtlPropInfo but do not change the
			// Initialized status of the provider (see IDBInitialize::Initialize).
			ATLTRACE(atlTraceDBProvider, 2, _T("m_pCUtlPropInfo == NULL\n"));
			delete pT->m_pCUtlPropInfo;
			ATLTRY(pT->m_pCUtlPropInfo = new CUtlPropInfo<T>())
			if (pT->m_pCUtlPropInfo == NULL)
			{
				ATLTRACE(atlTraceDBProvider, 0, _T("IDBProperties::GetPropertyInfo Error : OOM\n"));
				return E_OUTOFMEMORY;
			}
			HRESULT hr = pT->m_pCUtlPropInfo->FInit();
			if (hr != S_OK)
			{
				delete pT->m_pCUtlPropInfo;
				pT->m_pCUtlPropInfo = NULL;
				return E_FAIL;
			}
		}

		// Initialize 
		if( pcPropertyInfoSets )
			*pcPropertyInfoSets = 0;
		if( prgPropertyInfoSets )
			*prgPropertyInfoSets = NULL;
		if( ppDescBuffer )
			*ppDescBuffer = NULL;

		// Check Arguments
		if( ((cPropertySets > 0) && !rgPropertySets) ||
			!pcPropertyInfoSets || !prgPropertyInfoSets )
			return E_INVALIDARG;

		// New argument check for > 1 cPropertyIDs and NULL pointer for 
		// array of property ids.
		const DWORD SPECIAL_GROUP		= 1;
		const DWORD SPECIAL_SINGLE		= 2;
		const DWORD SPECIALS			= SPECIAL_GROUP | SPECIAL_SINGLE;
		DWORD dwSpecial = 0;
		for(ULONG ul=0; ul<cPropertySets; ul++)
		{
			if( (rgPropertySets[ul].guidPropertySet == DBPROPSET_DATASOURCEALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_DATASOURCEINFOALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_DBINITALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_SESSIONALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_ROWSETALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_COLUMNALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_CONSTRAINTALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_INDEXALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_TABLEALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_TRUSTEEALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_VIEWALL))
				dwSpecial |= SPECIAL_GROUP;
			else
				dwSpecial |= SPECIAL_SINGLE;

			// Check for property sets containing both singles and groups
			// Check for cPropertyIDs != 0 & rgPropertyIDs == NULL
			if( (dwSpecial == SPECIALS) ||
				(rgPropertySets[ul].cPropertyIDs && !(rgPropertySets[ul].rgPropertyIDs)) )
				return E_INVALIDARG;
		}

		if (pT->m_dwStatus & DSF_INITIALIZED)
			return pT->m_pCUtlPropInfo->GetPropertyInfo(cPropertySets, rgPropertySets, 
											  pcPropertyInfoSets, prgPropertyInfoSets, 
											  ppDescBuffer, true);
		else
			return pT->m_pCUtlPropInfo->GetPropertyInfo(cPropertySets, rgPropertySets, 
											  pcPropertyInfoSets, prgPropertyInfoSets, 
											  ppDescBuffer, false, &DBPROPSET_DBINITALL);

	}

	STDMETHOD(SetProperties)(ULONG cPropertySets,
							 DBPROPSET rgPropertySets[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBPropertiesImpl::SetProperties\n"));
		HRESULT	hr;
		CAutoVectorPtr < DBPROPSET > pdbPropSet;
		ULONG iProp;
		typedef const GUID* PCGUID;
		T* pT = static_cast<T*>(this);

		// Quick return if the Count of Properties is 0
		if( cPropertySets == 0 )
			return S_OK;

		// Determine how many sets are in the current map
		T::ObjectLock lock(pT);
		UPROPSET* pSetA = NULL;
		UPROPSET* pSetTemp = NULL;
		ULONG l=0;
		ULONG ulPropSets = 0;
		ULONG ulPropElems = 0;
		ULONG ulPropInits = 0;
		ULONG cSets = (ULONG)(ULONG_PTR)pT->_GetPropSet(NULL, &ulPropElems);
		ULONG iNewSet, iSet;

		CTempBuffer<UPROPSET> tmpBuffer;
		pSetA = tmpBuffer.Allocate(cSets);
		if (pSetA == NULL)
			return E_OUTOFMEMORY;  // We shouldn't get this but...

		pSetTemp = pT->_GetPropSet(&ulPropSets, &ulPropElems, pSetA);

		hr = CUtlProps<T>::SetPropertiesArgChk(cPropertySets, rgPropertySets);
		if(SUCCEEDED(hr))
		{
			// We need to handle the DBINIT properties specially after being initialized.
			// - they should be treated as NOTSETTABLE at this point.
			if( pT->m_dwStatus & DSF_INITIALIZED )
			{
				ATLASSERT(cPropertySets);

				BOOL fFoundDBINIT = FALSE;

				// Allocate a DBPROPSET structure of equal size
				pdbPropSet.Allocate( cPropertySets );
				if( pdbPropSet == NULL )
					return E_OUTOFMEMORY;

				for(iNewSet=0,iSet=0; iSet<cPropertySets; iSet++)
				{
					// Remove any DBPROPSET_DBINIT values and mark them all
					// as not settable
					if( (rgPropertySets[iSet].guidPropertySet == DBPROPSET_DBINIT))
					{
						fFoundDBINIT = TRUE;
						for(iProp=0; iProp<rgPropertySets[iSet].cProperties; iProp++)
							rgPropertySets[iSet].rgProperties[iProp].dwStatus = DBPROPSTATUS_NOTSETTABLE;
					}
					else
					{
						// If not DBPROPSET_DBINIT then copy the DBPROPSET values
						pdbPropSet[iNewSet++] = rgPropertySets[iSet];
					}
				}

				// If we have no propertyset to pass on to the property handler, we
				// can exit
				if( iNewSet == 0 )
				{
					return DB_E_ERRORSOCCURRED;
				}

				for(l=0; l<cSets; l++)
				{
					if (pSetTemp[l].bIsChained != true)
						ulPropInits++;
				}

				CTempBuffer<PCGUID> tmpBuffer2;
				PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
				if (ppGuid == NULL)
					return E_OUTOFMEMORY;

				ulPropInits = 0;
				for (l=0; l<cSets; l++)
				{
					if (pSetTemp[l].bIsChained != true)
						ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
				}

				hr = CUtlProps<T>::SetProperties(0, iNewSet, pdbPropSet, ulPropInits, ppGuid);

				// If we have determined that one of the property sets was DBINIT, we may
				// need to fixup the returned hr value.
				if( fFoundDBINIT && SUCCEEDED(hr))
					hr = DB_S_ERRORSOCCURRED;
			}
			else
			{
				// Note that m_pCUtlProps knows about initialization,
				// so we don't have to here. Only pass DBPROPSET_DBINIT or custom
				// initialization groups

				for(l=0; l<cSets; l++)
				{
					if (IsEqualGUID(*pSetTemp[l].pPropSet, DBPROPSET_DBINIT) ||
						pSetTemp[l].dwFlags & UPROPSET_USERINIT)
						ulPropInits++;
				}

				CTempBuffer<PCGUID> tmpBuffer2;
				PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
				if (ppGuid == NULL)
					return E_OUTOFMEMORY;

				ulPropInits = 0;
				for(l=0; l<cSets; l++)
				{
					if (IsEqualGUID(*pSetTemp[l].pPropSet, DBPROPSET_DBINIT) ||
						pSetTemp[l].dwFlags & UPROPSET_USERINIT)
						ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
				}

				hr = CUtlProps<T>::SetProperties(0, cPropertySets, rgPropertySets,
						ulPropInits, ppGuid);
			}
		}

		return hr;
	}
};


#define BEGIN_SCHEMA_MAP(SchemaClass) \
	typedef SchemaClass _SchemaClass; \
	HRESULT _SchemaSupport(GUID** ppGuid, \
						   IUnknown *pUnkOuter, \
		 				   REFIID rguidSchema, \
						   ULONG cRestrictions, \
						   const VARIANT rgRestrictions[], \
						   REFIID riid, \
						   ULONG cPropertySets, \
						   DBPROPSET rgPropertySets[], \
						   IUnknown **ppRowset) \
	{ \
	int cGuids = 0; \
	HRESULT hr = S_OK; \
	if (ppGuid != NULL) \
		*ppGuid = NULL;

#define SCHEMA_ENTRY(guid, rowsetClass) \
	if (ppGuid != NULL && SUCCEEDED(hr)) \
	{ \
		cGuids++; \
		*ppGuid = ATL::AtlSafeRealloc<GUID, ATL::CComAllocator>(*ppGuid, cGuids); \
		hr = (*ppGuid == NULL) ? E_OUTOFMEMORY : S_OK; \
		if (SUCCEEDED(hr)) \
			(*ppGuid)[cGuids - 1] = guid; \
		else \
			return hr; \
	} \
	else \
	{ \
		if (InlineIsEqualGUID(guid, rguidSchema)) \
		{ \
			rowsetClass* pRowset; \
			hr = CheckRestrictions(rguidSchema, cRestrictions, rgRestrictions); \
			if (FAILED(hr)) \
				return E_INVALIDARG; \
			hr =  CreateSchemaRowset(pUnkOuter, cRestrictions, \
							   rgRestrictions, riid, cPropertySets, \
							   rgPropertySets, ppRowset, pRowset); \
			return hr; \
		} \
	}

#define END_SCHEMA_MAP() \
		if (ppGuid != NULL) \
			return hr; \
		return E_INVALIDARG; \
	}


template <class SessionClass>
class  ATL_NO_VTABLE IDBSchemaRowsetImpl: public IDBSchemaRowset
{
public:

	OUT_OF_LINE HRESULT InternalCreateSchemaRowset(IUnknown *pUnkOuter, ULONG /*cRestrictions*/,
							   const VARIANT /*rgRestrictions*/[], REFIID riid, 
							   ULONG cPropertySets, DBPROPSET rgPropertySets[],
							   IUnknown** ppRowset, IUnknown* pUnkThis, CUtlPropsBase* pProps,
							   IUnknown* pUnkSession)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBSchemaRowsetImpl::InternalCreateSchemaRowset\n"));

		HRESULT hr, hrProps = S_OK;
		if (ppRowset != NULL)
			*ppRowset = NULL;
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return DB_E_NOAGGREGATION;
		CComPtr<IUnknown> spUnk;
		hr = pUnkThis->QueryInterface(__uuidof(IUnknown), (void**)&spUnk);
		if (FAILED(hr))
			return hr;

		hr = pProps->FInit();
		if (FAILED(hr))
			return hr;
		hr = pProps->SetPropertiesArgChk(cPropertySets, rgPropertySets);
		if (FAILED(hr))
			return hr;
		const GUID* ppGuid[1]; 
		ppGuid[0] = &DBPROPSET_ROWSET; 

		// Call SetProperties.  The true in the last parameter indicates 
		// the special behavior that takes place on rowset creation (i.e.
		// it succeeds as long as any of the properties were not marked
		// as DBPROPS_REQUIRED.

		hrProps = pProps->SetProperties(0, cPropertySets, rgPropertySets, 
											1, ppGuid, true);
		if (FAILED(hrProps))
			return hrProps;

		CComQIPtr<IObjectWithSite> spSite = spUnk;
		ATLASSERT(spSite != NULL);
		hr = spSite->SetSite(pUnkSession);
		if (FAILED(hr))
			return hr;
		if (InlineIsEqualGUID(riid, IID_NULL))
			return E_NOINTERFACE;
		if(ppRowset)
		{
			hr = spUnk->QueryInterface(riid, (void**)ppRowset);
		}
		if (FAILED(hr))
		{
			if(ppRowset)
			{
				*ppRowset = NULL;
			}
			return hr;
		}
		return (hrProps == DB_S_ERRORSOCCURRED) ? hrProps : hr;
	}

	template <class SchemaRowsetClass>
	HRESULT CreateSchemaRowset(IUnknown *pUnkOuter, ULONG cRestrictions,
							   const VARIANT rgRestrictions[], REFIID riid, 
							   ULONG cPropertySets, DBPROPSET rgPropertySets[],
							   IUnknown** ppRowset, SchemaRowsetClass*& pSchemaRowset)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBSchemaRowsetImpl::CreateSchemaRowset\n"));

		HRESULT hrProps, hr = S_OK;
		CComPolyObject<SchemaRowsetClass>* pPolyObj; 
		SessionClass* pT = (SessionClass*) this;
		if (FAILED(hr = CComPolyObject<SchemaRowsetClass>::CreateInstance(pUnkOuter, &pPolyObj)))
			return hr;
		pSchemaRowset = &(pPolyObj->m_contained);
		CComPtr<IUnknown> spOuterUnk;
		(pT->GetUnknown())->QueryInterface(__uuidof(IUnknown), (void**)&spOuterUnk);
		SchemaRowsetClass* myPT = (SchemaRowsetClass*) pSchemaRowset;
		hr = InternalCreateSchemaRowset(pUnkOuter, cRestrictions, rgRestrictions, 
										riid, cPropertySets, rgPropertySets, ppRowset, 
										pPolyObj, myPT, spOuterUnk);
		// Ref the created COM object and Auto release it on failure
		if (FAILED(hr))
		{
			delete pPolyObj;
			return hr;
		}

		hrProps = hr;
		// Get a pointer to the Rowset instance
		DBROWCOUNT cRowsAffected;
		hr = pSchemaRowset->Execute(&cRowsAffected, cRestrictions, rgRestrictions);
		if (FAILED(hr))
			return hr;


		return (hrProps == DB_S_ERRORSOCCURRED) ? hrProps : hr;
	}


	void SetRestrictions(ULONG cRestrictions, GUID* /*rguidSchema*/, ULONG* rgRestrictions)
	{
		memset(rgRestrictions, 0, sizeof(ULONG) * cRestrictions);
	}

	STDMETHOD(GetSchemas)(ULONG * pcSchemas, GUID ** prgSchemas, ULONG** prgRest)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBSchemaRowsetImpl::GetSchemas\n"));
		if (pcSchemas != NULL)
			*pcSchemas = 0;
		if (prgSchemas != NULL)
			*prgSchemas = NULL;
		if (pcSchemas == NULL || prgSchemas == NULL) 
			return E_INVALIDARG;

		SessionClass* pT = (SessionClass*)this;

		HRESULT hr = pT->_SchemaSupport(prgSchemas, NULL, GUID_NULL, 0, 
										NULL, GUID_NULL, 0, NULL, NULL);
		if (FAILED(hr))
			return hr;

		CComPtr<IMalloc> spMalloc;
		hr = CoGetMalloc(1, &spMalloc);
		if (FAILED(hr))
		{
			CoTaskMemFree(*prgSchemas);
			*prgSchemas = NULL;
			return hr;
		}
		*pcSchemas = (ULONG)(spMalloc->GetSize(*prgSchemas) / sizeof(GUID));

		if (prgRest != NULL)
		{
			// The OLE DB spec states that if prgRest == NULL not to return array
			// but it also says that is E_INVALIDARG, so doing first
			size_t nBytes=0;
			if( FAILED(hr=::ATL::AtlMultiply(&nBytes, sizeof(ULONG), static_cast<size_t>(*pcSchemas))))
			{
				spMalloc->Free(*prgSchemas);
				*prgSchemas = NULL;
				return hr;
			}
			*prgRest = (ULONG*) spMalloc->Alloc(nBytes);
			if (*prgRest == NULL)
			{
				spMalloc->Free(*prgSchemas);
				*prgSchemas = NULL;
				return E_OUTOFMEMORY;
			}
			pT->SetRestrictions(*pcSchemas, *prgSchemas, *prgRest);
		}
		return hr;
	}
	STDMETHOD(GetRowset)(IUnknown *pUnkOuter, REFGUID rguidSchema, ULONG cRestrictions,
						 const VARIANT rgRestrictions[], REFIID riid, ULONG cPropertySets,
						 DBPROPSET rgPropertySets[], IUnknown **ppRowset)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBSchemaRowsetImpl::GetRowset\n"));
		SessionClass* pT = (SessionClass*)this;

		// You must specify a rowset pointer per the specification
		if (ppRowset == NULL || (cRestrictions > 0 && rgRestrictions == NULL) ||
			(cPropertySets > 0 && rgPropertySets == NULL))
			return E_INVALIDARG;

		if (rgPropertySets != NULL)
		{
			for (ULONG ulSet = 0; ulSet < cPropertySets; ulSet++)
			{
				if (rgPropertySets[ulSet].cProperties > 0 &&
					rgPropertySets[ulSet].rgProperties == NULL)
					return E_INVALIDARG;
			}
		}

		return  pT->_SchemaSupport(NULL, pUnkOuter, rguidSchema, cRestrictions,
								   rgRestrictions, riid, cPropertySets,
								   rgPropertySets, ppRowset);

	}

	HRESULT CheckRestrictions(REFGUID rguidSchema, ULONG cRestrictions, 
				const VARIANT rgRestrictions[])
	{
		// Use this function to help check the validity of restrictions
		// against a schema rowset.
		const VARTYPE rgRestrictionTypes[3][4] = {
			{ VT_BSTR, VT_BSTR, VT_BSTR, VT_BSTR },		// DBSCHEMA_TABLES
			{ VT_BSTR, VT_BSTR, VT_BSTR, VT_BSTR },		// DBSCHEMA_COLUMNS
			{ VT_UI2, VT_BOOL, VT_EMPTY, VT_EMPTY }};	// DBSCHEMA_PROVIDER_TYPES
		const ULONG ulMaxRestrictions[3] = { 4, 4, 2};

		ULONG ulRes = 0;
		ULONG ulType = 3;

		if (InlineIsEqualGUID(rguidSchema, DBSCHEMA_TABLES))
			ulType = 0;
		else if (InlineIsEqualGUID(rguidSchema, DBSCHEMA_COLUMNS))
			ulType = 1;
		else if (InlineIsEqualGUID(rguidSchema, DBSCHEMA_PROVIDER_TYPES))
			ulType = 2;

		if (ulType < 3)		// I.E. we found one of our supported rowsets
		{
			ULONG ulCurrentRestrictions = 0x00;
			ULONG ulCurrentMask = 0x01;

			// Ask the provider's session object for its list of restrictions
			SessionClass* pT = (SessionClass*)this;
			pT->SetRestrictions(1, (GUID*)&rguidSchema, &ulCurrentRestrictions);

			ATLASSERT(ulType >= 0 && ulType < 3);
			// We allow VT_EMPTY through in case the consumer wanted to ignore this
			// restriction (basically a way to pass in 'NULL').
			if (cRestrictions > ulMaxRestrictions[ulType])
				return E_INVALIDARG;

			for (ulRes = 0; ulRes < cRestrictions; ulRes++)
			{
				// Check for obviously invalid types
				if (rgRestrictions[ulRes].vt != rgRestrictionTypes[ulType][ulRes] &&
					rgRestrictions[ulRes].vt != DBTYPE_EMPTY &&
					rgRestrictions[ulRes].vt != VT_NULL )
					return E_INVALIDARG;

				// Check for restrictions the provider doesn't support.
				if (!(ulCurrentMask & ulCurrentRestrictions) &&
					(rgRestrictions[ulRes].vt != DBTYPE_EMPTY))
					return E_INVALIDARG;

				ulCurrentMask <<= 1;		// Increase mask by * 2;
			}
		}

		return S_OK;
	}
};

// IDBCreateCommandImpl
template <class T, class CommandClass>
class ATL_NO_VTABLE IDBCreateCommandImpl : public IDBCreateCommand
{
public:
	STDMETHOD(CreateCommand)(IUnknown *pUnkOuter,
							 REFIID riid,
							 IUnknown **ppvCommand)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBCreateCommandImpl::CreateCommand\n"));
		T* pT = (T*) this;

		if (ppvCommand == NULL)
			return E_INVALIDARG;
		else
			*ppvCommand = NULL;

		HRESULT hr;
		CComPolyObject<CommandClass>* pCommand;

		// You can't QI for an interface other than IUnknown when aggregating 
		// and creating the object.  You might ask for your own interface, 
		// which would be bad.  Note, we return DB_E_NOAGGREGATION instead of
		// CLASS_E_NOAGGREGATION due to OLE DB constraints.
		if (pUnkOuter != NULL && !InlineIsEqualUnknown(riid))
			return DB_E_NOAGGREGATION;

		hr = CComPolyObject<CommandClass>::CreateInstance(pUnkOuter, &pCommand);
		if (FAILED(hr))
			return hr;
		// Ref the created COM object and Auto release it on failure
		CComPtr<IUnknown> spUnk;
		hr = pCommand->QueryInterface(&spUnk);
		if (FAILED(hr))
		{
			delete pCommand; // must hand delete as it is not ref'd
			return hr;
		}
		ATLASSERT(pCommand->m_contained.m_spUnkSite == NULL);
		CComPtr<IUnknown> spOuterUnk;
		hr = pT->QueryInterface(__uuidof(IUnknown), (void**)&spOuterUnk);
		if (SUCCEEDED(hr))
		{
			hr = pCommand->m_contained.SetSite(spOuterUnk);
			if (SUCCEEDED(hr))
			{
				hr = pCommand->QueryInterface(riid, (void**)ppvCommand);
			}
		}
		return hr;
	}

};


// IGetDataSourceImpl
template <class T>
class ATL_NO_VTABLE IGetDataSourceImpl : public IGetDataSource
{
public:
	STDMETHOD(GetDataSource)(REFIID riid,
							 IUnknown **ppDataSource)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IGetDataSourceImpl::GetDataSource\n"));
		if (ppDataSource == NULL)
			return E_INVALIDARG;
		T* pT = (T*) this;
		ATLASSERT(pT->m_spUnkSite != NULL);
		return pT->m_spUnkSite->QueryInterface(riid, (void**)ppDataSource);
	}
};


// IOpenRowsetImpl
template <class SessionClass>
class IOpenRowsetImpl : public IOpenRowset
{
public:
	template <class RowsetClass>
	HRESULT CreateRowset(IUnknown* pUnkOuter, 
						 DBID *pTableID, DBID *pIndexID,
						 REFIID riid, 
						 ULONG cPropertySets, DBPROPSET rgPropertySets[],
						 IUnknown** ppRowset, 
						 RowsetClass*& pRowsetObj)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IOpenRowsetImpl::CreateRowset\n"));

		HRESULT hr, hrProps = S_OK;
		if (ppRowset != NULL)
			*ppRowset = NULL;
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return DB_E_NOAGGREGATION;
		CComPolyObject<RowsetClass>* pPolyObj; 
		if (FAILED(hr = CComPolyObject<RowsetClass>::CreateInstance(pUnkOuter, &pPolyObj)))
			return hr;
		// Ref the created COM object and Auto release it on failure
		CComPtr<IUnknown> spUnk;
		hr = pPolyObj->QueryInterface(&spUnk);
		if (FAILED(hr))
		{
			delete pPolyObj; // must hand delete as it is not ref'd
			return hr;
		}
		// Get a pointer to the Rowset instance
		pRowsetObj = &(pPolyObj->m_contained);
		hr = pRowsetObj->FInit();
		if (FAILED(hr))
			return hr;
		hr = pRowsetObj->SetPropertiesArgChk(cPropertySets, rgPropertySets);
		if (FAILED(hr))
			return hr;

		const GUID* ppGuid[1]; 
		ppGuid[0] = &DBPROPSET_ROWSET; 

		// Call SetProperties.  The true in the last parameter indicates 
		// the special behavior that takes place on rowset creation (i.e.
		// it succeeds as long as any of the properties were not marked
		// as DBPROPS_REQUIRED.

		hrProps = pRowsetObj->SetProperties(0, cPropertySets, rgPropertySets, 
											1, ppGuid, true);
		if (FAILED(hrProps))
			return hrProps;
		CComPtr<IUnknown> spOuterUnk;
		hr = ((SessionClass*)this)->QueryInterface(__uuidof(IUnknown), (void**)&spOuterUnk);
		if (FAILED(hr))
		{
			return hr;
		}

		hr = pRowsetObj->SetSite(spOuterUnk);
		if (FAILED(hr))
		{
			return hr;
		}

		hr = pRowsetObj->SetCommandText(pTableID, pIndexID);
		if (FAILED(hr))
			return hr;
		DBROWCOUNT cRowsAffected;

		// Check to make sure we set any 'post' properties based on the riid
		// requested.
		if (FAILED(pRowsetObj->OnInterfaceRequested(riid)))
			return hr;

		HRESULT hrExecute;
		if (FAILED(hrExecute = pRowsetObj->Execute(NULL, &cRowsAffected)))
			return hrExecute;
/*
		CComVariant varMaxRows;
		if (SUCCEEDED(pRowsetObj->GetPropValue(&DBPROPSET_ROWSET, DBPROP_MAXROWS, &varMaxRows)))
		{
			if( varMaxRows.lVal > 0 )
			{
				if( pRowsetObj->m_rgRowData.GetCount() > (size_t)varMaxRows.lVal )
				{
					pRowsetObj->m_rgRowData.RemoveAt( varMaxRows.lVal, 
														pRowsetObj->m_rgRowData.GetCount() - varMaxRows.lVal );
				}
			}
		}
*/
		if (InlineIsEqualGUID(riid, IID_NULL))
		{
			return E_NOINTERFACE;
		}
		else
		{
			if (ppRowset == NULL)
				//return (hrProps == DB_S_ERRORSOCCURRED) ? DB_E_ERRORSOCCURRED : hr;
				return hrProps;
			hr = pPolyObj->QueryInterface(riid, (void**)ppRowset);

		}

		if (FAILED(hr))
		{
			*ppRowset = NULL;
			return hr;
		}

		return (hrProps == DB_S_ERRORSOCCURRED && hrExecute != DB_S_STOPLIMITREACHED) ? hrProps : hrExecute;
	}
};

// IColumnsInfoImpl
template <class T>
class ATL_NO_VTABLE IColumnsInfoImpl : 
	public IColumnsInfo,
	public CDBIDOps
{
public:

	HRESULT CheckCommandText(IUnknown* pUnkThis)
	{
		HRESULT hr = E_FAIL;
		CComPtr<ICommandText> spText;
		if (SUCCEEDED(hr = pUnkThis->QueryInterface(__uuidof(ICommandText), (void**)&spText)))
		{
			LPOLESTR szCommand;
			hr = spText->GetCommandText(NULL, &szCommand);
			if (SUCCEEDED(hr))
				CoTaskMemFree(szCommand);
		}
		return hr;
	}
	OUT_OF_LINE HRESULT InternalGetColumnInfo(DBORDINAL *pcColumns, ATLCOLUMNINFO** ppInfo) 
	{
		ATLENSURE_RETURN(ppInfo != NULL);
		T* pT = (T*) this;
		if (pT->CheckCommandText(pT->GetUnknown()) == DB_E_NOCOMMAND)
			return DB_E_NOCOMMAND;
		*ppInfo = T::GetColumnInfo(pT, pcColumns);
		return S_OK;

	}
	STDMETHOD(GetColumnInfo)(DBORDINAL *pcColumns,
							 DBCOLUMNINFO **prgInfo,
							 OLECHAR **ppStringsBuffer)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IColumnsInfoImpl::GetColumnInfo\n"));
		if (pcColumns == NULL || prgInfo == NULL || ppStringsBuffer == NULL)
		{
			if (prgInfo != NULL)
				*prgInfo = NULL;
			if (ppStringsBuffer != NULL)
				*ppStringsBuffer = NULL;
			if (pcColumns != NULL)
				*pcColumns = NULL;
			return E_INVALIDARG;
		}

		// NULL out pointers in case of an error
		*prgInfo = NULL;
		*ppStringsBuffer = NULL;
		*pcColumns = 0;

		ATLCOLUMNINFO* pInfo;
		HRESULT hr = InternalGetColumnInfo(pcColumns, &pInfo);
		if (FAILED(hr))
			return hr;
		*prgInfo = (DBCOLUMNINFO*)::ATL::AtlCoTaskMemCAlloc(*pcColumns, static_cast<ULONG>(sizeof(DBCOLUMNINFO)));
		if (*prgInfo != NULL)
		{
			ULONG cwRequired;
			DBORDINAL iCol;
			for (iCol = 0, cwRequired = 0; iCol < *pcColumns; iCol++)
			{
				(*prgInfo)[iCol].pwszName = pInfo[iCol].pwszName;
				(*prgInfo)[iCol].pTypeInfo = pInfo[iCol].pTypeInfo;
				(*prgInfo)[iCol].iOrdinal = pInfo[iCol].iOrdinal;
				(*prgInfo)[iCol].dwFlags = pInfo[iCol].dwFlags;
				(*prgInfo)[iCol].ulColumnSize = pInfo[iCol].ulColumnSize;
				(*prgInfo)[iCol].wType = pInfo[iCol].wType;
				(*prgInfo)[iCol].bPrecision = pInfo[iCol].bPrecision;
				(*prgInfo)[iCol].bScale = pInfo[iCol].bScale;
				(*prgInfo)[iCol].columnid = pInfo[iCol].columnid;

				if (pInfo[iCol].pwszName)
				{
					cwRequired += static_cast<ULONG>(wcslen(pInfo[iCol].pwszName) + 1);
				}
			}
			*ppStringsBuffer = (OLECHAR*)::ATL::AtlCoTaskMemCAlloc(cwRequired, static_cast<ULONG>(sizeof(OLECHAR)));
			if (*ppStringsBuffer)
			{
				DBORDINAL iColStrings;
				size_t iOffset;
				for (iColStrings = 0, iOffset = 0; iColStrings < *pcColumns; iColStrings++)
				{
					if (pInfo[iColStrings].pwszName)
					{
						if(!ocscpy_s(*ppStringsBuffer + iOffset, cwRequired-iOffset, pInfo[iColStrings].pwszName))
						{
							return E_FAIL;
						}
						(*prgInfo)[iColStrings].pwszName = *ppStringsBuffer + iOffset;
						if ((pInfo[iColStrings].columnid.eKind == DBKIND_GUID_NAME || 
							 pInfo[iColStrings].columnid.eKind == DBKIND_NAME ||
							 pInfo[iColStrings].columnid.eKind == DBKIND_PGUID_NAME))
						{
							(*prgInfo)[iColStrings].columnid.uName.pwszName  = *ppStringsBuffer + iOffset;
						}
						iOffset += wcslen(*ppStringsBuffer + iOffset) + 1;
					}
				}
				return S_OK;
			}
			else
			{
				ATLTRACE(atlTraceDBProvider, 0, _T("Failed to allocate string buffer\n"));
				CoTaskMemFree(*prgInfo);
				*prgInfo = NULL;
				*pcColumns = 0;
				return E_OUTOFMEMORY;
			}
		}
		else
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("Failed to allocate ColumnInfo array\n"));
			*prgInfo = NULL;
			*pcColumns = 0;
			return E_OUTOFMEMORY;
		}

	}

	STDMETHOD(MapColumnIDs)(DBORDINAL cColumnIDs,
							const DBID rgColumnIDs[],
							DBORDINAL rgColumns[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IColumnsInfoImpl::MapColumnIDs\n"));
		if ((cColumnIDs != 0 && rgColumnIDs == NULL) || rgColumns == NULL)
			return E_INVALIDARG;
		DBORDINAL cCols = 0;
		DBORDINAL cColsInError = 0;
		HRESULT hr = S_OK;
		ATLCOLUMNINFO* pInfo;
		for (DBORDINAL iColId = 0; iColId < cColumnIDs; iColId++)
		{
			hr = InternalGetColumnInfo(&cCols, &pInfo);
			if (hr == DB_E_NOCOMMAND)
				return hr;
			DBORDINAL iColMapCur = 0;
			BOOL bDone = FALSE;
			while(iColMapCur < cCols && !bDone)
			{
				hr = CompareDBIDs(&(pInfo[iColMapCur].columnid), &(rgColumnIDs[iColId]));
				bDone = (hr == S_OK || FAILED(hr));
				if (hr == S_OK)
					rgColumns[iColId] = pInfo[iColMapCur].iOrdinal;
				iColMapCur++;
			}
			if (!bDone || FAILED(hr))
			{
				rgColumns[iColId] = DB_INVALIDCOLUMN;
				cColsInError++;
			}

		}
		if (cColsInError > 0 && cColumnIDs == cColsInError) 
			return DB_E_ERRORSOCCURRED;
		if (cColsInError > 0 && cColsInError < cColumnIDs)
			return DB_S_ERRORSOCCURRED;
		return S_OK;
	}
};

//IConvertTypeImpl
template <class T>
class ATL_NO_VTABLE IConvertTypeImpl : public IConvertType, public CConvertHelper
{
public:
	HRESULT InternalCanConvert(DBTYPE wFromType, DBTYPE wToType, DBCONVERTFLAGS dwConvertFlags,
								   bool bIsCommand, bool bHasParamaters, IObjectWithSite* pSite)
	{

		// Determine if new 2.x flags are valid
		if((dwConvertFlags & ~(DBCONVERTFLAGS_ISLONG | DBCONVERTFLAGS_ISFIXEDLENGTH | DBCONVERTFLAGS_FROMVARIANT)) != DBCONVERTFLAGS_COLUMN
			&& (dwConvertFlags & ~(DBCONVERTFLAGS_ISLONG | DBCONVERTFLAGS_ISFIXEDLENGTH | DBCONVERTFLAGS_FROMVARIANT)) != DBCONVERTFLAGS_PARAMETER )
			return DB_E_BADCONVERTFLAG;

		// If the convert flags are for DBCONVERTFLAGS_FROMVARIANT, check to see
		// that the type is a variant type
		if (dwConvertFlags & DBCONVERTFLAGS_FROMVARIANT)
		{
			if ((wFromType == DBTYPE_BYTES) ||
				(wFromType == DBTYPE_STR) ||
				(wFromType == DBTYPE_WSTR) ||
				(wFromType == DBTYPE_NUMERIC) ||
				(wFromType == DBTYPE_UDT) ||
				(wFromType == DBTYPE_DBDATE) ||
				(wFromType == DBTYPE_DBTIME) ||
				(wFromType == DBTYPE_DBTIMESTAMP) ||
				(wFromType == DBTYPE_HCHAPTER) ||
				(wFromType == DBTYPE_PROPVARIANT) ||
				(wFromType == DBTYPE_VARNUMERIC))
				return DB_E_BADTYPE;
		}

		// Note, if the convert flag is either ISLONG or ISFIXEDLENGTH, then we should
		// make sure we are not dealing with an OLE DB 1.x provider.  However, since 
		// we default to 2.x providers, we don't check this.  If you, change the 
		// DBPROP_PROVIDEROLEDBVER property in the DATASOURCEINFO group, you need to
		// check the property value and return a DB_E_BADCONVERTFLAG if it is a 1.x
		// provider.

		// Do we have ISLONG on a fixed length data type?
		DBTYPE dbtype = (DBTYPE) (wFromType & ~(DBTYPE_BYREF|DBTYPE_VECTOR|DBTYPE_ARRAY|DBTYPE_RESERVED));
		if ((dwConvertFlags & DBCONVERTFLAGS_ISLONG) && 
			(dbtype != DBTYPE_WSTR && dbtype != DBTYPE_STR && dbtype != DBTYPE_BYTES && dbtype != DBTYPE_VARNUMERIC))
			return DB_E_BADCONVERTFLAG;

		DBCONVERTFLAGS dwBaseFlags = (DBCONVERTFLAGS)(dwConvertFlags & ~(DBCONVERTFLAGS_ISLONG | DBCONVERTFLAGS_ISFIXEDLENGTH | DBCONVERTFLAGS_FROMVARIANT));

		// Check if this should be an & or an ==
		if (dwBaseFlags == DBCONVERTFLAGS_PARAMETER)
		{
			// In the case where we are a rowset and ask for a parameter 
			// conversion, return DB_E_BADCONVERTFLAG
			if (!bIsCommand)
				return DB_E_BADCONVERTFLAG;

			// In the case where we are a command and ask for a parameter 
			// conversion and ICommandWithParameters is not supported, return 
			// DB_E_BADCONVERTFLAG.  We used to return S_FALSE, but spec says
			// return DB_E_BADCONVERTFLAG if not supported.
			if (!bHasParamaters)
				return DB_E_BADCONVERTFLAG;
		}

		// If we deal with a command and the user asks for a conversion on a rowset
		// the DBPROP_ROWSETCONVERSIONSONCOMMAND must be supported and set to TRUE.
		if (bIsCommand && (dwBaseFlags == DBCONVERTFLAGS_COLUMN))
		{
			CDBPropIDSet set(DBPROPSET_DATASOURCEINFO);
			if(!set.AddPropertyID(DBPROP_ROWSETCONVERSIONSONCOMMAND))
			{
				return E_FAIL;
			}
			DBPROPSET* pPropSet = NULL;
			ULONG ulPropSet = 0;

			// Get a pointer into the session
			CComPtr<IGetDataSource> spDataSource;
			CComPtr<IDBProperties> spProps;

			// if any of these calls fail, we're either unable to retrieve the
			// property or it is unsupported.  Since the property is only on
			// the data source object, we use the IObjectWithSite interface to
			// get the session object and then the GetDataSource method to get
			// the data source object itself.
			if (FAILED(pSite->GetSite(__uuidof(IGetDataSource), (void**)&spDataSource)))
				return DB_E_BADCONVERTFLAG;
			if (FAILED(spDataSource->GetDataSource(__uuidof(IDBProperties), 
				(IUnknown**)&spProps)))
				return DB_E_BADCONVERTFLAG;
			if (FAILED(spProps->GetProperties(1, &set, &ulPropSet, &pPropSet)))
				return DB_E_BADCONVERTFLAG;

			if (pPropSet != NULL)
			{
				CComVariant var = pPropSet->rgProperties[0].vValue;
				CoTaskMemFree(pPropSet->rgProperties);
				CoTaskMemFree(pPropSet);

				if (var.boolVal == ATL_VARIANT_FALSE)
					return DB_E_BADCONVERTFLAG;
			}
		}
		HRESULT hr = E_FAIL;
		if (m_spConvert != NULL)
		{
			hr = m_spConvert->CanConvert(wFromType, wToType);
			if (hr == E_INVALIDARG)
			{
				// Data Conversion library said the types specified were invalid
				// however, in OLE DB 2.X, the value for this changed from
				// E_INVALIDARG to S_FALSE
				hr = S_FALSE;
			}
		}	
		return hr;
	}
	STDMETHOD(CanConvert)(DBTYPE wFromType, DBTYPE wToType, DBCONVERTFLAGS dwConvertFlags)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IConvertTypeImpl::CanConvert\n"));
		T* pT = (T*)this;
		return pT->InternalCanConvert(wFromType, wToType, dwConvertFlags, pT->m_bIsCommand, pT->m_bHasParamaters, pT);
	}
};

template <class T, class PropClass = T>
class ATL_NO_VTABLE ICommandPropertiesImpl : 
	public ICommandProperties, 
	public CUtlProps<PropClass>
{
public:
	typedef PropClass _PropClass;

	STDMETHOD(GetProperties)(const ULONG cPropertyIDSets,
							 const DBPROPIDSET rgPropertyIDSets[],
							 ULONG *pcPropertySets,
							 DBPROPSET **prgPropertySets)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ICommandPropertiesImpl::GetProperties\n"));

		T* pT;
		pT = static_cast<T*>(this);
		m_dwFlags |= ARGCHK_PROPERTIESINERROR;
		HRESULT hr = GetPropertiesArgChk(cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
		if(SUCCEEDED(hr))
		{
			// Scan property sets to allow user defined properies
			ULONG ulPropSets = 0;
			ULONG ulPropElems = 0;
			ULONG ulPropInits = 0;
			UPROPSET* pSetA = NULL;
			UPROPSET* pSetTemp = NULL;
			ULONG l=0;
			ULONG cSets = (ULONG)(ULONG_PTR)pT->_GetPropSet(NULL, &ulPropElems);

			CTempBuffer<UPROPSET> tmpBuffer;
			pSetA = tmpBuffer.Allocate(cSets);
			if (pSetA == NULL)
				return E_OUTOFMEMORY;  // We shouldn't get this but...
			pSetTemp = pT->_GetPropSet(&ulPropSets, &ulPropElems, pSetA);

			typedef const GUID* PCGUID;

			for(l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ulPropInits++;
			}

			CTempBuffer<PCGUID> tmpBuffer2;
			PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
			if (ppGuid == NULL)
				return E_OUTOFMEMORY;
			ulPropInits = 0;
			for (l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
			}

			hr = CUtlProps<PropClass>::GetProperties(cPropertyIDSets, 
					rgPropertyIDSets, pcPropertySets, prgPropertySets, 
					ulPropInits, ppGuid);
		}
		m_dwFlags |= ~ARGCHK_PROPERTIESINERROR;
		return hr;

	}

	STDMETHOD(SetProperties)(ULONG cPropertySets,
							 DBPROPSET rgPropertySets[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ICommandPropertiesImpl::SetProperties\n"));
		T* pT = (T*)this;

		if (pT->m_cRowsetsOpen > 0)
			return DB_E_OBJECTOPEN;	// Don't allow property sets on an open rowset

		HRESULT hr = SetPropertiesArgChk(cPropertySets, rgPropertySets);
		if(SUCCEEDED(hr))
		{
			// Scan property sets to allow user defined properies
			ULONG ulPropSets = 0;
			ULONG ulPropElems = 0;
			ULONG ulPropInits = 0;
			UPROPSET* pSetA = NULL;
			UPROPSET* pSetTemp = NULL;
			ULONG l=0;
			ULONG cSets = (ULONG)(ULONG_PTR)pT->_GetPropSet(NULL, &ulPropElems);

			CTempBuffer<UPROPSET> tmpBuffer;
			pSetA = tmpBuffer.Allocate(cSets);
			if (pSetA == NULL)
				return E_OUTOFMEMORY;  // We shouldn't get this but...
			pSetTemp = pT->_GetPropSet(&ulPropSets, &ulPropElems, pSetA);

			typedef const GUID* PCGUID;

			for(l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ulPropInits++;
			}

			CTempBuffer<PCGUID> tmpBuffer2;
			PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
			if (ppGuid == NULL)
				return E_OUTOFMEMORY;
			ulPropInits = 0;
			for (l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
			}

			hr = CUtlProps<PropClass>::SetProperties(0, cPropertySets, 
					rgPropertySets, ulPropInits, ppGuid);
		}
		return hr;
	}
};


template <class T, class CommandBase = ICommand>
class ATL_NO_VTABLE ICommandImpl : public CommandBase
{
public:
	ICommandImpl() 
	{
		m_bIsExecuting = FALSE;
		m_bCancelWhenExecuting = TRUE;
		m_bCancel = FALSE;
	}
	HRESULT CancelExecution()
	{
		T* pT = (T*)this;
		pT->Lock();
		m_bCancel = TRUE;
		pT->Unlock();
		return S_OK;
	}
	STDMETHOD(Cancel)()
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ICommandImpl::Cancel\n"));
		HRESULT hr = S_OK;
		T* pT = (T*)this;

		if (m_bIsExecuting && m_bCancelWhenExecuting)
		{
			hr = pT->CancelExecution();
			return hr;
		}
		if (m_bIsExecuting && !m_bCancelWhenExecuting)
			hr = DB_E_CANTCANCEL;
		return hr;
	}
	STDMETHOD(GetDBSession)(REFIID riid, IUnknown ** ppSession)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ICommandImpl::GetDBSession\n"));
		if( ppSession == NULL )
			return E_INVALIDARG;
		T* pT = (T*)this;
		ATLASSERT(pT->m_spUnkSite != NULL);
		return pT->m_spUnkSite->QueryInterface(riid, (void**) ppSession);
	}

	template <class RowsetClass>
	HRESULT CreateRowset(IUnknown* pUnkOuter, REFIID riid, 
						 DBPARAMS * pParams, DBROWCOUNT * pcRowsAffected, 
						 IUnknown** ppRowset, 
						 RowsetClass*& pRowsetObj)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ICommandImpl::CreateRowset\n"));

		HRESULT hr;
		T* pT = (T*)this;

		if (pT->m_strCommandText.Length() == 0)
		{
			ATLTRACE(atlTraceDBProvider, 2, _T("ICommandImpl::No command text specified.\n"));
			return DB_E_NOCOMMAND;
		}
		if (InlineIsEqualGUID(IID_NULL, riid))
		{
			ATLTRACE(atlTraceDBProvider, 2, _T("IID_NULL was specified in Execute, returning S_OK"));
			return S_OK;
		}
		if (ppRowset != NULL)
			*ppRowset = NULL;
		else
			return E_INVALIDARG;
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return DB_E_NOAGGREGATION;
		CComPolyObject<RowsetClass>* pPolyObj; 
		if (FAILED(hr = CComPolyObject<RowsetClass>::CreateInstance(pUnkOuter, &pPolyObj)))
			return hr;
		// Ref the created COM object and Auto release it on failure
		CComPtr<IUnknown> spUnk;
		hr = pPolyObj->QueryInterface(&spUnk);
		if (FAILED(hr))
		{
			delete pPolyObj; // must hand delete as it is not ref'd
			return hr;
		}
		// Get a pointer to the Rowset instance
		pRowsetObj = &(pPolyObj->m_contained);

		if (FAILED(hr = pRowsetObj->FInit(pT)))
			return hr;
		CComPtr<IUnknown> spOuterUnk;
		hr = pT->QueryInterface(__uuidof(IUnknown), (void**)&spOuterUnk);
		if (FAILED(hr))
		{
			return hr;
		}
		hr = pRowsetObj->SetSite(spOuterUnk);
		if (FAILED(hr))
		{
			return hr;
		}
		pRowsetObj->m_strCommandText = pT->m_strCommandText;

		// Check to make sure we set any 'post' properties based on the riid
		// requested.  Do this before calling Execute in case provider has
		// property specific processing.
		if (FAILED(pRowsetObj->OnInterfaceRequested(riid)))
			return hr;

		POSITION pos = pT->m_rgBindings.GetStartPosition();
		while( pos != NULL )
		{
			T::_BindingVector::CPair *pPair = pT->m_rgBindings.GetNext(pos);
			ATLENSURE_RETURN( pPair != NULL );
			T::_BindType* pBind = NULL;
			T::_BindType* pBindSrc = NULL;
			ATLTRY(pBind = new T::_BindType);
			CAutoPtr<T::_BindType> amr(pBind);
			if (pBind == NULL)
			{
				ATLTRACE(atlTraceDBProvider, 2, _T("Failed to allocate memory for new Binding\n"));
				return E_OUTOFMEMORY;
			}
			pBindSrc = pPair->m_value;
			if (pBindSrc == NULL)
			{
				ATLTRACE(atlTraceDBProvider, 2, _T("The map appears to be corrupted, failing!!\n"));
				return E_FAIL;
			}
			_ATLTRY
			{
				pRowsetObj->m_rgBindings.SetAt(pPair->m_key, pBind);
			}
			_ATLCATCH( e )
			{
				_ATLDELETEEXCEPTION( e );
				ATLTRACE(atlTraceDBProvider, 2, _T("Failed to add hAccessor to Map\n"));
				return E_OUTOFMEMORY;
			}
			if (pBindSrc->cBindings)
			{
				ATLTRY(pBind->pBindings = new DBBINDING[pBindSrc->cBindings])
				if (pBind->pBindings == NULL)
				{
					ATLTRACE(atlTraceDBProvider, 2, _T("Failed to Allocate dbbinding Array\n"));
					// We added it, must now remove on failure
					pRowsetObj->m_rgBindings.RemoveKey(pPair->m_key);
					return E_OUTOFMEMORY;
				}
			}
			else
			{
				pBind->pBindings = NULL; // NULL Accessor
			}

			pBind->dwAccessorFlags = pBindSrc->dwAccessorFlags;
			pBind->cBindings = pBindSrc->cBindings;
			pBind->dwRef = 1;
			Checked::memcpy_s(pBind->pBindings, pBind->cBindings*sizeof(DBBINDING), pBindSrc->pBindings, pBindSrc->cBindings*sizeof(DBBINDING));
			amr.Detach();
		}

		// Execute the command.
		// By default, we'll always return a rowset.  If you do not wish to
		// return a rowset, set this value to false in your Execute function.
		// If you return false, we will not return a rowset pointer, regardless
		// of whether the user requests one.
		m_bRowsetReturned = true;	

		HRESULT hrExecute;
		if (FAILED(hrExecute = pRowsetObj->Execute(pParams, pcRowsAffected)))
			return hrExecute;
		if (InlineIsEqualGUID(riid, IID_NULL) || ppRowset == NULL)
		{
			if (ppRowset != NULL)
				*ppRowset = NULL;
			return hrExecute;
		}

		if (m_bRowsetReturned != false)
			hr = pPolyObj->QueryInterface(riid, (void**)ppRowset);
		else 
			return hr;

		if (FAILED(hr))
			return hr;

		return hrExecute;
	}

	unsigned m_bIsExecuting:1;
	unsigned m_bCancelWhenExecuting:1;
	unsigned m_bCancel:1;
	unsigned m_bRowsetReturned:1;
};


template <class T>
class ATL_NO_VTABLE ICommandTextImpl : public ICommandImpl<T, ICommandText>
{
public:

	ICommandTextImpl()
	{
		m_guidDialect = DBGUID_DEFAULT;
		m_cRowsetsOpen = 0;
	}

	STDMETHOD(GetCommandText)(GUID *pguidDialect,LPOLESTR * ppwszCommand)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ICommandTextImpl::GetCommandText\n"));

		T* pT = (T*)this;
		T::ObjectLock cab(pT);

		GUID guidOrig = IID_NULL;

		if (pguidDialect != NULL)
		{
			guidOrig = *pguidDialect;
			*pguidDialect = GUID_NULL;
		}
		if (ppwszCommand == NULL)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("ICommandTextImpl::GetCommandText Bad Command buffer\n"));
			return E_INVALIDARG;
		}
		if (m_strCommandText.m_str == NULL || *(m_strCommandText.m_str) == NULL)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("ICommandTextImpl::GetCommandText Bad Command buffer\n"));
			return DB_E_NOCOMMAND;
		}

		*ppwszCommand = AtlAllocTaskWideString(m_strCommandText.m_str);
		if( ppwszCommand != NULL )
		{
			HRESULT hrDialect = S_OK;
			if ( pguidDialect != NULL)
			{
				if(!InlineIsEqualGUID(guidOrig, m_guidDialect))
					hrDialect = DB_S_DIALECTIGNORED;
				*pguidDialect = m_guidDialect;
			}
			return hrDialect;
		}
		else
			return E_OUTOFMEMORY;
	}

	STDMETHOD(SetCommandText)(REFGUID rguidDialect,LPCOLESTR pwszCommand)
	{
		_ATLTRY
		{
			T* pT = (T*)this;
			T::ObjectLock cab(pT);

			ATLTRACE(atlTraceDBProvider, 2, _T("ICommandTextImpl::SetCommandText\n"));

			if (m_cRowsetsOpen > 0)
				return DB_E_OBJECTOPEN;

			if (InlineIsEqualGUID(rguidDialect, DBGUID_SQL))
			{
				// Get a pointer into the session
				CComPtr<IGetDataSource> spDataSource;
				CComPtr<IDBProperties> spProps;
				if( SUCCEEDED( pT->GetSite( __uuidof(IGetDataSource), (void**)&spDataSource ) ) &&
					SUCCEEDED( spDataSource->GetDataSource( __uuidof(IDBProperties), (IUnknown**)&spProps ) ) )
				{
					CDBPropIDSet set(DBPROPSET_DATASOURCEINFO);
					if(!set.AddPropertyID(DBPROP_SQLSUPPORT))
					{
						return E_FAIL;
					}
					DBPROPSET* pPropSet = NULL;
					ULONG ulPropSet = 0;
					HRESULT hr = spProps->GetProperties(1, &set, &ulPropSet, &pPropSet);
					if( SUCCEEDED(hr) && pPropSet != NULL )
					{
						CComVariant var = pPropSet->rgProperties[0].vValue;
						CoTaskMemFree(pPropSet->rgProperties);
						CoTaskMemFree(pPropSet);

						if( var.lVal == DBPROPVAL_SQL_NONE )
							return DB_E_BADCONVERTFLAG;
					}
					else
						return DB_E_BADCONVERTFLAG;
				}
				return DB_E_BADCONVERTFLAG;
			}
			if (InlineIsEqualGUID(rguidDialect, GUID_NULL))
				return DB_E_DIALECTNOTSUPPORTED;			
			m_guidDialect = rguidDialect;
			m_strCommandText = pwszCommand;
		}
		_ATLCATCHALL()
		{
			return E_FAIL;
		}
		return S_OK;
	}

	LONG m_cRowsetsOpen;
	CComBSTR m_strCommandText;
	GUID m_guidDialect;
};

// ISessionPropertiesImpl
template <class T, class PropClass = T>
class ATL_NO_VTABLE ISessionPropertiesImpl : 
	public ISessionProperties, 
	public CUtlProps<PropClass>
{
public:
	typedef PropClass _PropClass;

	STDMETHOD(GetProperties)(ULONG cPropertyIDSets,
							 const DBPROPIDSET rgPropertyIDSets[],
							 ULONG *pcPropertySets,
							 DBPROPSET **prgPropertySets)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ISessionPropertiesImpl::GetProperties\n"));
		T* pT;
		pT = static_cast<T*>(this);

		// You can't retrieve PROPERTIESINERROR here (it would be processed
		// like any other property set.  Therefore, turn checking off
		m_dwFlags |= ~ARGCHK_PROPERTIESINERROR;
		HRESULT hr = GetPropertiesArgChk(cPropertyIDSets, rgPropertyIDSets, 
			pcPropertySets, prgPropertySets);

		if(SUCCEEDED(hr))
		{
			// Scan property sets to allow user defined properies
			ULONG ulPropSets = 0;
			ULONG ulPropElems = 0;
			ULONG ulPropInits = 0;
			UPROPSET* pSetA = NULL;
			UPROPSET* pSetTemp = NULL;
			ULONG l=0;
			ULONG cSets = (ULONG)(ULONG_PTR)pT->_GetPropSet(NULL, &ulPropElems);

			CTempBuffer<UPROPSET> tmpBuffer;
			pSetA = tmpBuffer.Allocate(cSets);
			if (pSetA == NULL)
				return E_OUTOFMEMORY;  // We shouldn't get this but...
			pSetTemp = pT->_GetPropSet(&ulPropSets, &ulPropElems, pSetA);

			typedef const GUID* PCGUID;

			for(l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ulPropInits++;
			}

			CTempBuffer<PCGUID> tmpBuffer2;
			PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
			if (ppGuid == NULL)
				return E_OUTOFMEMORY;
			ulPropInits = 0;
			for (l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
			}

			hr = CUtlProps<PropClass>::GetProperties(cPropertyIDSets,
					rgPropertyIDSets, pcPropertySets, prgPropertySets, 
					ulPropInits, ppGuid);
		}
		return hr;

	}

	STDMETHOD(SetProperties)(ULONG cPropertySets,
							 DBPROPSET rgPropertySets[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ISessionPropertiesImpl::SetProperties"));
		T* pT;
		pT = static_cast<T*>(this);
		HRESULT hr = SetPropertiesArgChk(cPropertySets, rgPropertySets);

		if(SUCCEEDED(hr))
		{
			// Scan property sets to allow user defined properies
			ULONG ulPropSets = 0;
			ULONG ulPropElems = 0;
			ULONG ulPropInits = 0;
			UPROPSET* pSetA = NULL;
			UPROPSET* pSetTemp = NULL;
			ULONG l=0;
			ULONG cSets = (ULONG)(ULONG_PTR)pT->_GetPropSet(NULL, &ulPropElems);

			CTempBuffer<UPROPSET> tmpBuffer;
			pSetA = tmpBuffer.Allocate(cSets);
			if (pSetA == NULL)
				return E_OUTOFMEMORY;  // We shouldn't get this but...
			pSetTemp = pT->_GetPropSet(&ulPropSets, &ulPropElems, pSetA);

			typedef const GUID* PCGUID;

			for(l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ulPropInits++;
			}

			CTempBuffer<PCGUID> tmpBuffer2;
			PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
			if (ppGuid == NULL)
				return E_OUTOFMEMORY;
			ulPropInits = 0;
			for (l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
			}

			hr = CUtlProps<PropClass>::SetProperties(0, cPropertySets, rgPropertySets,
					ulPropInits, ppGuid);
		}
		return hr;
	}
};

// Implementation Class 
template <class BindType>
class ATL_NO_VTABLE IAccessorImplBase : public IAccessor
{
public:

	STDMETHOD(CreateAccessor)(DBACCESSORFLAGS dwAccessorFlags,
							  DBCOUNTITEM cBindings,
							  const DBBINDING rgBindings[],
							  DBLENGTH /*cbRowSize*/,
							  HACCESSOR *phAccessor,
							  DBBINDSTATUS rgStatus[])
	{
		if (!(dwAccessorFlags & DBACCESSOR_PARAMETERDATA) && !(dwAccessorFlags & DBACCESSOR_ROWDATA))
			return DB_E_BADACCESSORFLAGS;
		if (dwAccessorFlags == DBACCESSOR_INVALID)
			return DB_E_BADACCESSORFLAGS;
		if (dwAccessorFlags > 0x000F)
			return DB_E_BADACCESSORFLAGS;
		BindType *pBind = NULL;
		ATLTRY(pBind = new BindType)
		if (pBind == NULL)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("Failed to allocate ATL Binding struct\n"));
			return E_OUTOFMEMORY;
		}
		if (cBindings)
		{
			ATLTRY(pBind->pBindings = new DBBINDING[cBindings])
			if (pBind->pBindings == NULL)
			{
				delete pBind;
				return E_OUTOFMEMORY;
			}
		}
		else
			pBind->pBindings = NULL; // NULL Accessor

		pBind->dwAccessorFlags = dwAccessorFlags;
		pBind->cBindings = cBindings;
		pBind->dwRef = 1;
		Checked::memcpy_s(pBind->pBindings, pBind->cBindings*sizeof(DBBINDING), rgBindings, cBindings*sizeof(DBBINDING));
		DBBINDSTATUS status = DBBINDSTATUS_OK;
		memset (rgStatus, status, sizeof(DBBINDSTATUS)*cBindings);
		*phAccessor = (ULONG_PTR)pBind;
		return S_OK;
	}
	BOOL HasFlag(DBTYPE dbToCheck, DBTYPE dbCombo)
	{
		return ( (dbToCheck & dbCombo) == dbCombo );
	}
	HRESULT ValidateBindings(DBCOUNTITEM cBindings, const DBBINDING rgBindings[], 
				DBBINDSTATUS rgStatus[], bool bHasBookmarks)
	{
		HRESULT hr = S_OK;

		for (ULONG iBinding = 0; iBinding < cBindings; iBinding++)
		{
			const DBBINDING& rBindCur = rgBindings[iBinding];
			if (rBindCur.iOrdinal == 0)
			{
				if (!m_bIsCommand && !bHasBookmarks)
				{
					hr = DB_E_ERRORSOCCURRED;
					rgStatus[iBinding] = DBBINDSTATUS_BADORDINAL;
					continue;
				}
			}
			if (rBindCur.dwPart == 0) // nothing to bind to
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}
			if (HasFlag(rBindCur.wType, (DBTYPE_BYREF | DBTYPE_ARRAY)))
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}
			if (HasFlag(rBindCur.wType, (DBTYPE_BYREF | DBTYPE_VECTOR)))
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}
			if (HasFlag(rBindCur.wType, (DBTYPE_VECTOR | DBTYPE_ARRAY)))
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}
			if (rBindCur.wType == DBTYPE_NULL || rBindCur.wType == DBTYPE_EMPTY)
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}
			if (HasFlag(rBindCur.wType, DBTYPE_RESERVED))
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}
			// DBTYPE_BYREF must be accompanied by other valid type
			if (rBindCur.wType == (DBTYPE_BYREF | DBTYPE_EMPTY) 
				|| rBindCur.wType == (DBTYPE_BYREF | DBTYPE_NULL) 
				|| rBindCur.wType == DBTYPE_BYREF)
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}

			// If someone attempts to set DBBINDFLAG_HTML on a non-string
			// column, generate a BADBINDINFO error.
			if (rBindCur.wType != DBTYPE_STR && rBindCur.wType != DBTYPE_WSTR &&
				rBindCur.dwFlags & DBBINDFLAG_HTML)
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}

			// the dwFlags parameter must be 0 or DBBINDFLAG_HTML, 
			// all other values will return an error.
			if (rBindCur.dwFlags != 0 && rBindCur.dwFlags != DBBINDFLAG_HTML)
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}

			if (rBindCur.dwMemOwner == DBMEMOWNER_PROVIDEROWNED)
			{
				BOOL bIsPointerType = HasFlag(rBindCur.wType, DBTYPE_BYREF) ||
									  HasFlag(rBindCur.wType, DBTYPE_VECTOR) ||
									  HasFlag(rBindCur.wType, DBTYPE_ARRAY) ||
									  HasFlag( (DBTYPE) (~(DBTYPE_BYREF) & rBindCur.wType), DBTYPE_BSTR);
				if (!bIsPointerType)
				{
					hr = DB_E_ERRORSOCCURRED;
					rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
					continue;
				}
			}
			else if (rBindCur.dwMemOwner != DBMEMOWNER_CLIENTOWNED)
			{
				// the dwMemOwner flag is supposed to be ignored for reference accessors
				// (see the description of DBBINDING structure in MSDN), otherwise dwMemOwner
				// should have a value of DBMEMOWNER_CLIENTOWNED or DBMEMOWNER_PROVIDEROWNED
				if (!HasFlag(rBindCur.wType, DBTYPE_BYREF))
				{
					hr = DB_E_ERRORSOCCURRED;
					rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
					continue;
				}
			}
		}
		return hr;
	}

	unsigned  m_bIsCommand:1;
	unsigned  m_bHasParamaters:1;
	unsigned  m_bIsChangeable:1;
};

// IAccessorImpl
template <class T, class BindType = ATLBINDINGS, 
			class BindingVector = CAtlMap < HACCESSOR, BindType* > >
class ATL_NO_VTABLE IAccessorImpl : public IAccessorImplBase<BindType>
{
public:
	typedef BindType _BindType;
	typedef BindingVector _BindingVector;
	IAccessorImpl()
	{
		m_bIsCommand = FALSE;
		m_bHasParamaters = FALSE;
		m_bIsChangeable = FALSE;
	}
	OUT_OF_LINE HRESULT InternalFinalConstruct(IUnknown* /*pUnkThis*/)
	{
		CComPtr<ICommand> spCommand;
		CComPtr<ICommandWithParameters> spCommandWithParameters;
		T* pT = (T*)this;

		pT->_InternalQueryInterface(IID_ICommand,(void **) &spCommand);

		if (spCommand !=NULL)  // It's a command
		{
			m_bIsCommand = TRUE;
			pT->_InternalQueryInterface(IID_ICommandWithParameters, (void **) &spCommandWithParameters);
			m_bHasParamaters =  spCommandWithParameters != NULL;

		}
		return S_OK;
	}
	HRESULT FinalConstruct()
	{
		T* pT = (T*)this;
		return InternalFinalConstruct(pT->GetUnknown());
	}
	void FinalRelease()
	{
#ifdef _DEBUG
		if (m_rgBindings.GetCount())
			ATLTRACE(atlTraceDBProvider, 0, _T("IAccessorImpl::~IAccessorImpl Bindings still in vector, removing\n"));
#endif //_DEBUG
		while (m_rgBindings.GetCount()) 
			ReleaseAccessor((HACCESSOR)m_rgBindings.GetKeyAt(m_rgBindings.GetStartPosition()), NULL);
	}
	STDMETHOD(AddRefAccessor)(HACCESSOR hAccessor,
							  DBREFCOUNT *pcRefCount)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IAccessorImpl::AddRefAccessor\n"));
		if (hAccessor == NULL)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("AddRefAccessor : Bad hAccessor\n"));
			return DB_E_BADACCESSORHANDLE;
		}
		BindType* pBind;
		if( ! m_rgBindings.Lookup(hAccessor, pBind ) )
			return DB_E_BADACCESSORHANDLE;

		ATLENSURE_RETURN( pBind );
		ULONG cRefCount = T::_ThreadModel::Increment((LONG*)&pBind->dwRef);

		if (pcRefCount != NULL)
			*pcRefCount = cRefCount;

		return S_OK;
	}
	OUT_OF_LINE ATLCOLUMNINFO* ValidateHelper(DBORDINAL* pcCols, CComPtr<IDataConvert> & rspConvert)
	{
		T* pT = (T*)this;
		rspConvert = pT->m_spConvert;
		return T::GetColumnInfo(pT, pcCols);
	}
	OUT_OF_LINE HRESULT ValidateBindingsFromMetaData(DBCOUNTITEM cBindings, const DBBINDING rgBindings[], 
				DBBINDSTATUS rgStatus[], bool bHasBookmarks)
	{
		HRESULT hr = S_OK;
		DBORDINAL cCols;
		CComPtr<IDataConvert> spConvert;
		ATLCOLUMNINFO* pColInfo = ValidateHelper(&cCols, spConvert);
		ATLENSURE_RETURN(pColInfo != NULL);
		for (DBCOUNTITEM iBinding = 0; iBinding < cBindings; iBinding++)
		{
			const DBBINDING& rBindCur = rgBindings[iBinding];
			DBORDINAL iOrdAdjusted;
			if (bHasBookmarks)
				iOrdAdjusted = rBindCur.iOrdinal;	// Bookmarks start with ordinal 0
			else
				iOrdAdjusted = rBindCur.iOrdinal - 1; // Non-bookmarks start w/ ordinal 1
			if (rBindCur.iOrdinal > cCols)
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADORDINAL;
				continue;
			}

			// If a binding specifies provider owned memory, and specifies type 
			// X | BYREF, and the provider's copy is not X or X | BYREF, return 
			// DBBINDSTATUS_BADBINDINFO

			if (rBindCur.dwMemOwner == DBMEMOWNER_PROVIDEROWNED)
			{
				if ((rBindCur.wType & DBTYPE_BYREF) != 0 &&
					((rBindCur.wType & (~DBTYPE_BYREF)) != 
						(pColInfo[iOrdAdjusted].wType & (~DBTYPE_BYREF))))
				{
					hr = DB_E_ERRORSOCCURRED;
					rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
					continue;
				}
			}

			ATLASSERT(spConvert != NULL);
			HRESULT hrConvert = spConvert->CanConvert(pColInfo[iOrdAdjusted].wType, rBindCur.wType);
			if (FAILED(hrConvert) || hrConvert == S_FALSE)
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_UNSUPPORTEDCONVERSION;
				continue;
			}
		}
		return hr;
	}
	STDMETHOD(CreateAccessor)(DBACCESSORFLAGS dwAccessorFlags,
							  DBCOUNTITEM cBindings,
							  const DBBINDING rgBindings[],
							  DBLENGTH cbRowSize,
							  HACCESSOR *phAccessor,
							  DBBINDSTATUS rgStatus[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IAccessorImpl::CreateAccessor\n"));
		T* pT = (T*)this;
		T::ObjectLock cab(pT);

		if (!phAccessor)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("IAccessorImpl::CreateAccessor : Inavlid NULL Parameter for HACCESSOR*\n"));
			return E_INVALIDARG;
		}
		*phAccessor = NULL;
		if (cBindings != 0 && rgBindings == NULL)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("IAccessorImpl::CreateAccessor  : Bad Binding array\n"));
			return E_INVALIDARG;
		}
		if (dwAccessorFlags & DBACCESSOR_PASSBYREF)
		{
			CComVariant varByRef;
			HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET, 
				DBPROP_BYREFACCESSORS, &varByRef);
			if (FAILED(hr) || varByRef.boolVal == ATL_VARIANT_FALSE)
				return DB_E_BYREFACCESSORNOTSUPPORTED;
		}
		if (!m_bHasParamaters)
		{
			if (dwAccessorFlags & DBACCESSOR_PARAMETERDATA)
				return DB_E_BADACCESSORFLAGS;
		}

		// since our accessor does not provide any further restrictions or optimizations based
		// on the DBACCESSOR_OPTIMIZED flag, the flag will be ignored.  In particular we will 
		// not be returning this flag in the call to IAccessor::GetBindings.  This way we will
		// be complient with the OLEDB specifications and we will not have to prevent the 
		// client from creating additional accessors after the first row is fetched.
		DBACCESSORFLAGS dwMask = DBACCESSOR_OPTIMIZED;
		dwAccessorFlags &= ~dwMask;

		CComVariant varUpdate;
		HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_UPDATABILITY, &varUpdate);
		m_bIsChangeable = (SUCCEEDED(hr) && (varUpdate.iVal & DBPROPVAL_UP_INSERT));

		if (m_bIsCommand || !m_bIsChangeable)
		{
			if (cBindings == 0) // No NULL Accessors on the command
				return DB_E_NULLACCESSORNOTSUPPORTED;
		}

		CTempBuffer<DBBINDSTATUS> tmpBuffer;
		if (rgStatus == NULL && cBindings) // Create a fake status array 
			rgStatus = tmpBuffer.Allocate(cBindings);

		// Validate the Binding passed
		bool bHasBookmarks = false;
		CComVariant varBookmarks;
		HRESULT hrLocal = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_BOOKMARKS, &varBookmarks);
		bHasBookmarks = (hrLocal == S_OK &&  varBookmarks.boolVal != ATL_VARIANT_FALSE);

		hr = ValidateBindings(cBindings, rgBindings, rgStatus, bHasBookmarks);
		if (FAILED(hr))
			return hr;
		if (!m_bIsCommand)
		{
			hr = ValidateBindingsFromMetaData(cBindings, rgBindings, rgStatus, 
					bHasBookmarks);
			if (FAILED(hr))
				return hr;
		}
		hr = IAccessorImplBase<BindType>::CreateAccessor(dwAccessorFlags, cBindings,
			rgBindings, cbRowSize, phAccessor,rgStatus);
		if (SUCCEEDED(hr))
		{
			ATLASSERT(*phAccessor != NULL);
			BindType* pBind = (BindType*)*phAccessor;
			ATLENSURE_RETURN(pBind);
			_ATLTRY
			{
				m_rgBindings.SetAt((HACCESSOR)pBind, pBind);
				hr = S_OK;
			}
			_ATLCATCH( e )
			{
				_ATLDELETEEXCEPTION( e );
				hr = E_OUTOFMEMORY;
			}
		}
		return hr;

	}

	STDMETHOD(GetBindings)(HACCESSOR hAccessor,
						   DBACCESSORFLAGS *pdwAccessorFlags,
						   DBCOUNTITEM *pcBindings,
						   DBBINDING **prgBindings)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IAccessorImpl::GetBindings\n"));

		// Zero output parameters in case of failure
		if (pdwAccessorFlags != NULL)
			*pdwAccessorFlags = NULL;

		if (pcBindings != NULL)
			*pcBindings = NULL;

		if (prgBindings != NULL)
			*prgBindings = NULL;

		// Check if any of the out params are NULL pointers
		if ((pdwAccessorFlags && pcBindings && prgBindings) == NULL)
			return E_INVALIDARG;

		BindType* pBind;
		bool bFound = m_rgBindings.Lookup((INT_PTR)hAccessor, pBind);
		HRESULT hr = DB_E_BADACCESSORHANDLE; 
		if (bFound && pBind != NULL)
		{
			*pdwAccessorFlags = pBind->dwAccessorFlags;
			*pcBindings = pBind->cBindings;
			// Get NULL for NULL Accessor
			*prgBindings = (pBind->cBindings) ? (DBBINDING*)::ATL::AtlCoTaskMemCAlloc(*pcBindings, static_cast<ULONG>(sizeof(DBBINDING))) : NULL;
			if (*prgBindings == NULL && pBind->cBindings) // No Error if NULL Accessor
				return E_OUTOFMEMORY;
			Checked::memcpy_s(*prgBindings, *pcBindings * sizeof(DBBINDING), pBind->pBindings, *pcBindings * sizeof(DBBINDING));
			hr = S_OK;
		}
		return hr;
	}

	STDMETHOD(ReleaseAccessor)(HACCESSOR hAccessor,
							   DBREFCOUNT *pcRefCount)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IAccessorImpl::ReleaseAccessor\n"));
		T::ObjectLock cab((T*)this);
		BindType* pBind;
		bool bFound = m_rgBindings.Lookup((INT_PTR)hAccessor, pBind);
		if (!bFound || pBind == NULL)
			return DB_E_BADACCESSORHANDLE;
		DBREFCOUNT cRefCount = T::_ThreadModel::Decrement((LONG*)&pBind->dwRef);
		if (pcRefCount != NULL)
			*pcRefCount = cRefCount;
		if (cRefCount == 0)
		{
			delete [] pBind->pBindings;
			delete pBind;
			return m_rgBindings.RemoveKey(hAccessor) ? S_OK : DB_E_BADACCESSORHANDLE;
		}
		return S_OK;
	}

	BindingVector m_rgBindings;
};

#define BEGIN_PROVIDER_COLUMN_MAP(theClass) \
	typedef theClass _Class; \
	template <class T> \
	static ATL::ATLCOLUMNINFO* GetColumnInfo(T* pv, DBORDINAL* pcCols) \
	{ \
	pv; \
	static ATL::ATLCOLUMNINFO _rgColumns [] = \
	{

#define SIZEOF_MEMBER(memberOf, member) \
	sizeof(((memberOf*)0)->member)
#define EXPANDGUID(guid) \
	{ guid.Data1, guid.Data2, guid.Data3, \
	{ guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7] } }

#define PROVIDER_COLUMN_ENTRY_GN(name, ordinal, flags, colSize, dbtype, precision, scale, guid) \
{ (LPOLESTR)name, (ITypeInfo*)NULL, (DBORDINAL)ordinal, (DBCOLUMNFLAGS)flags, (DBLENGTH)colSize, (DBTYPE)dbtype, (BYTE)precision, (BYTE)scale, { EXPANDGUID(guid), (DWORD)0, (LPOLESTR) name}, 0},

#define PROVIDER_COLUMN_ENTRY_EX(name, typeinfo, ordinal, flags, colSize, dbtype, precision, scale, guid, member) \
	{ \
		(LPOLESTR)OLESTR(name), \
		typeinfo, \
		(DBORDINAL)ordinal, \
		flags, \
		colSize, \
		dbtype, \
		(BYTE)precision, \
		(BYTE)scale, \
		{ \
			EXPANDGUID(guid), \
			(DWORD)DBKIND_NAME, \
			(LPOLESTR)OLESTR(name) \
		}, \
		offsetof(_Class, member) \
	},

#define PROVIDER_COLUMN_ENTRY(name, ordinal, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, DBCOLUMNFLAGS_ISFIXEDLENGTH, (DBLENGTH)SIZEOF_MEMBER(_Class, member), ATL::_GetOleDBType(((_Class*)0)->member), 0, 0, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_PS(name, ordinal, precision, scale, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, DBCOLUMNFLAGS_ISFIXEDLENGTH, (DBLENGTH)SIZEOF_MEMBER(_Class, member), ATL::_GetOleDBType(((_Class*)0)->member), precision, scale, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_LENGTH(name, ordinal, size, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, DBCOLUMNFLAGS_ISFIXEDLENGTH, size, ATL::_GetOleDBType(((_Class*)0)->member), 0, 0, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_TYPE_LENGTH(name, ordinal, type, size, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, DBCOLUMNFLAGS_ISFIXEDLENGTH, size, type, 0, 0, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_TYPE(name, ordinal, type, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, DBCOLUMNFLAGS_ISFIXEDLENGTH, (DBLENGTH)SIZEOF_MEMBER(_Class, member), type, 0, 0, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_TYPE_PS(name, ordinal, type, precision, scale, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, DBCOLUMNFLAGS_ISFIXEDLENGTH, (DBLENGTH)SIZEOF_MEMBER(_Class, member), type, precision, scale, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_FIXED(name, ordinal, type, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, DBCOLUMNFLAGS_ISFIXEDLENGTH, (DBLENGTH)SIZEOF_MEMBER(_Class, member), type, 0, 0, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_STR(name, ordinal, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, 0, (DBLENGTH)SIZEOF_MEMBER(_Class, member), DBTYPE_STR, 255, 255, GUID_NULL, member)

#define PROVIDER_COLUMN_ENTRY_WSTR(name, ordinal, member) \
	PROVIDER_COLUMN_ENTRY_EX(name, NULL, ordinal, 0, (DBLENGTH)SIZEOF_MEMBER(_Class, member), DBTYPE_WSTR, 255, 255, GUID_NULL, member)

#define END_PROVIDER_COLUMN_MAP() \
}; *pcCols = sizeof(_rgColumns)/sizeof(ATL::ATLCOLUMNINFO); return _rgColumns;}

class CDynColumnInfo: public CAtlArray<ATLCOLUMNINFO>
{
public:
	HRESULT Add(LPOLESTR szName, DBORDINAL ordinal, DBLENGTH colSize, 
			 DBTYPE type, BYTE precision, BYTE scale, 
			 DBBYTEOFFSET offset, DWORD flags = DBCOLUMNFLAGS_ISFIXEDLENGTH)
	{
		ATLCOLUMNINFO col;
		col.pwszName = szName; 
		col.pTypeInfo = NULL; 
		col.iOrdinal = ordinal; 
		col.dwFlags = flags; 
		col.ulColumnSize = colSize; 
		col.wType = type; 
		col.bPrecision = precision; 
		col.bScale = scale; 
		col.cbOffset = offset; 
		memset(&(col.columnid), 0, sizeof(DBID)); 
		col.columnid.uName.pwszName = (LPOLESTR)szName;
		_ATLTRY
		{
			CAtlArray<ATLCOLUMNINFO>::Add(col);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e );
			return E_OUTOFMEMORY;
		}
		return S_OK;
	}

	HRESULT AddString(LPOLESTR szName, DBORDINAL ordinal, DBLENGTH colSize, DBBYTEOFFSET offset)
	{
		return Add(szName,ordinal, colSize, DBTYPE_STR, 0xFF, 0xFF, offset);
	}
};

// Implementation Class 
class CSimpleRow
{
public:
	typedef DBCOUNTITEM KeyType;

	CSimpleRow(DBCOUNTITEM iRowsetCur) 
	{ 
		m_dwRef = 0;
		m_pData = NULL;
		m_iRowset = iRowsetCur; 
		m_iOriginalRowset = iRowsetCur; // used for stronger identity tests
		m_status = 0;
	}
	~CSimpleRow()
	{
		m_pData = NULL;	// Data will be freed seperately
	}
	DWORD AddRefRow() { return CComObjectThreadModel::Increment((LPLONG)&m_dwRef); } 
	DWORD ReleaseRow() { return CComObjectThreadModel::Decrement((LPLONG)&m_dwRef); }

	HRESULT Compare(CSimpleRow* pRow)
	{
		ATLENSURE_RETURN(pRow != NULL);
		return (m_iRowset == pRow->m_iRowset) ? S_OK : S_FALSE;
	}

	DWORD	m_dwRef;
	void*	m_pData;			// NEW:  For IRowsetChange & IRowsetUpdate
	DBPENDINGSTATUS m_status;	// NEW:  For IRowsetUpdate
	KeyType m_iOriginalRowset;	// NEW:  For IRowsetChange & IRowsetUpdate
	KeyType m_iRowset;
};

template <class T>
inline void SendColumnSetFailureNotification( T* pT, HROW hNotifyRow, typename T::_BindType* pBinding, 
												 CAtlArray<DBORDINAL>& rgColumns )
{
	pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings, 
		rgColumns.GetData(), DBREASON_COLUMN_SET, 
		DBEVENTPHASE_FAILEDTODO, TRUE);
}

template <class T, class RowClass>
inline void SendRowsFirstChangeFailureNotification( T* pT, RowClass* pRow, HROW *phNotifyRow, bool bDeferred )
{
	ATLENSURE(pRow);
	if (bDeferred)
	{
		// Determine if we are really in a first row change 
		if (pRow->m_status != DBPENDINGSTATUS_CHANGED && 
			pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
		{
			pT->Fire_OnRowChange(pT, 1, phNotifyRow, 
				DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_FAILEDTODO, TRUE);
		}
	}
}

template <class T, class RowClass, class MapClass>
HRESULT TransferData(T* pT, bool bReading, void* pData, 
					 RowClass* pRow, MapClass* /*pMap*/, HACCESSOR hAccessor)
{
	ATLTRACE(atlTraceDBProvider, 2, _T("TransferData\n"));
	bool bFailed = false;
	bool bSucceeded = false;
	HRESULT hr = S_OK;

	__if_exists(T::Fire_OnFieldChange)
	{
		CAtlArray<DBORDINAL> rgColumns;
		HROW hNotifyRow = NULL;
		//HROW hNotifyRow = pT->m_rgRowHandles.ReverseLookup(pRow);
		{
			POSITION pos = pT->m_rgRowHandles.GetStartPosition();
			while( pos != NULL )
			{
				MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext( pos );
				ATLASSERT( pPair != NULL );
				if( pPair->m_value == pRow )
				{
					hNotifyRow = pPair->m_key;
					break;
				}
			}
		}
	}

	__if_exists(T::Fire_OnRowChange)
	{
		// We need to send the DBREASON_ROW_FIRSTCHANGE notification's
		// SYNCHAFTER phase in this function.  IFF. we're deferred and
		// we have a newly changed row.

		CComVariant varDeferred;
		bool bDeferred;
		hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_IRowsetUpdate, 
							&varDeferred);
		(FAILED(hr) || varDeferred.boolVal == ATL_VARIANT_FALSE) ? bDeferred = false : bDeferred = true;
	}

	// Check for a deleted row
	if( pRow->m_iRowset >= pT->m_rgRowData.GetCount() )
	{
		__if_exists(T::Fire_OnFieldChange)
		{
			if( !bReading )
			{
				SendRowsFirstChangeFailureNotification( pT, pRow, &hNotifyRow, bDeferred );
			}
		}
		return DB_E_DELETEDROW;
	}

	// NOTE: This was checking against DBPENDINGSTATUS_DELETED.  Instead, it 
	// should check for DBPENDINGSTATUS_INVALIDROW (means a forced deleted
	// row).

	if (pRow->m_status == DBPENDINGSTATUS_INVALIDROW)
	{
		__if_exists(T::Fire_OnFieldChange)
		{
			if( !bReading )
			{
				SendRowsFirstChangeFailureNotification( pT, pRow, &hNotifyRow, bDeferred );
			}
		}
		return DB_E_DELETEDROW;
	}

	T::_BindType* pBinding;
	bool bFound = pT->m_rgBindings.Lookup((INT_PTR)hAccessor, pBinding);
	if (!bFound || pBinding == NULL)
	{
		__if_exists(T::Fire_OnFieldChange)
		{
			if( !bReading )
			{
				SendRowsFirstChangeFailureNotification( pT, pRow, &hNotifyRow, bDeferred );
			}
		}
		return DB_E_BADACCESSORHANDLE;
	}

	if (pData == NULL && pBinding->cBindings != 0)
	{
		__if_exists(T::Fire_OnFieldChange)
		{
			if( !bReading )
			{
				SendRowsFirstChangeFailureNotification( pT, pRow, &hNotifyRow, bDeferred );
			}
		}
		return E_INVALIDARG;
	}

	void* pDstData;
	void* pSrcData;
	if (bReading)
	{
		pDstData = pData;
		pSrcData = (void*)&(pT->m_rgRowData[(LONG)pRow->m_iRowset]);
	}
	else
	{
		pSrcData = pData;
		pDstData = (void*)&(pT->m_rgRowData[(LONG)pRow->m_iRowset]);
	}

	if (!bReading)
	{
		// Send the OKTODO notification
		__if_exists(T::Fire_OnFieldChange)
		{
			if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
				pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
			{
				HRESULT hrNotify;
				for (DBORDINAL l=0; l<pBinding->cBindings; l++)
				{
					_ATLTRY
					{
						rgColumns.Add(pBinding->pBindings[l].iOrdinal);
					}
					_ATLCATCH( e )
					{
						_ATLDELETEEXCEPTION( e );
						return E_FAIL;
					}
				}

				hrNotify = pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings, 
					rgColumns.GetData(), DBREASON_COLUMN_SET, 
					DBEVENTPHASE_OKTODO, FALSE);
				if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
				{
					__if_exists(T::Fire_OnRowChange)
					{
						if (bDeferred)
							pT->Fire_OnRowChange(pT, 1, &hNotifyRow, 
								DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_FAILEDTODO, TRUE);
						return DB_E_CANCELED;
					}
				}

				hrNotify = pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
					rgColumns.GetData(), DBREASON_COLUMN_SET, DBEVENTPHASE_ABOUTTODO, 
					FALSE);
				if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
				{
					__if_exists(T::Fire_OnRowChange)
					{
						if (bDeferred)
							pT->Fire_OnRowChange(pT, 1, &hNotifyRow, 
								DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_FAILEDTODO, TRUE);
						return DB_E_CANCELED;
					}
				}

				hrNotify = pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings, 
					rgColumns.GetData(), DBREASON_COLUMN_SET, 
					DBEVENTPHASE_SYNCHAFTER, FALSE);
				if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
				{
					__if_exists(T::Fire_OnRowChange)
					{
						if (bDeferred)
							pT->Fire_OnRowChange(pT, 1, &hNotifyRow, 
								DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_FAILEDTODO, TRUE);
						return DB_E_CANCELED;
					}
				}
			}
		}

		__if_exists(T::Fire_OnRowChange)
		{
			if(bDeferred && pRow->m_status != DBPENDINGSTATUS_CHANGED &&
				pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
			{
				HRESULT hrNotify = pT->Fire_OnRowChange(pT, 1, &hNotifyRow, 
					DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_SYNCHAFTER, FALSE);

				if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
				{
					__if_exists(T::Fire_OnFieldChange)
					{
						pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings, 
							rgColumns.GetData(), DBREASON_COLUMN_SET, 
							DBEVENTPHASE_FAILEDTODO, TRUE);
					}
					return DB_E_CANCELED;
				}
			}
		}
	}


	DBORDINAL cCols;
	ATLCOLUMNINFO* pColInfo = T::GetColumnInfo(pT, &cCols);
	ATLENSURE_RETURN(pColInfo);
	for (DBORDINAL iBind =0; iBind < pBinding->cBindings; iBind++)
	{
		DBBINDING* pBindCur = &(pBinding->pBindings[iBind]);
		DBORDINAL iColInfo;
		for (iColInfo = 0; 
			 iColInfo < cCols && pBindCur->iOrdinal != pColInfo[iColInfo].iOrdinal;
			 iColInfo++);
		if (iColInfo == cCols)
		{
			__if_exists(T::Fire_OnFieldChange)
			{
				if( !bReading )
				{
					SendColumnSetFailureNotification( pT, hNotifyRow, pBinding, rgColumns );
					SendRowsFirstChangeFailureNotification( pT, pRow, &hNotifyRow, bDeferred );
				}
			}
			return DB_E_BADORDINAL;
		}
		ATLCOLUMNINFO* pColCur = &(pColInfo[iColInfo]);
		// Ordinal found at iColInfo

		BYTE* pSrcTemp = (bReading) ? (BYTE*)pSrcData + pColCur->cbOffset : 
									  (BYTE*)pSrcData + pBindCur->obValue;

		BYTE* pDstTemp = NULL;
		if (pBindCur->dwPart & DBPART_VALUE)
			pDstTemp = (bReading) ? (BYTE*)pDstData + pBindCur->obValue : 
						 (BYTE*)pDstData + pColCur->cbOffset;


		if (!bReading)
		{
			// Check to see that the appropriate data parts are available
			if ((pBindCur->dwPart & DBPART_LENGTH) &&
				!(pBindCur->dwPart & DBPART_VALUE) &&
				!(pBindCur->dwPart & DBPART_STATUS))
			{
				__if_exists(T::Fire_OnFieldChange)
				{
					if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
						pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
					{
						pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
							rgColumns.GetData(), DBREASON_COLUMN_SET, DBEVENTPHASE_FAILEDTODO, 
							TRUE);
					}
				}

				// Not sure why you would want to run SetData here!
				bFailed = true;
				continue;
			}
		}

		// Handle the the status for any consumer issues
		DBSTATUS dbStat = DBSTATUS_S_OK;
		if (bReading)
		{
			dbStat = pT->GetDBStatus(pRow, pColCur);

			if (dbStat == DBSTATUS_S_ISNULL)
			{
				if (pBindCur->dwPart & DBPART_STATUS)
					*((DBSTATUS*)((BYTE*)(pDstData) + pBindCur->obStatus)) = dbStat; 

				// Set the length to 0 as reqiured by the spec.
				if (pBindCur->dwPart & DBPART_LENGTH)
					*((DBLENGTH*)((BYTE*)(pDstData) + pBindCur->obLength)) = 0;

				// Set the destination value to NULL
				if (pBindCur->dwPart & DBPART_VALUE)
				{

					ATLENSURE_RETURN(pDstTemp);
					*pDstTemp = NULL;
				}

				continue;
			}
		}
		else
		{
			// Allow the provider to do checking for DBSTATUS_S_ISNULL
			if (pBindCur->dwPart & DBPART_STATUS)
			{
				dbStat = *((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus));

				// Return DBSTATUS_E_UNAVAILABLE if the status is DBSTATUS_S_OK
				//	and either the value part is not bound or the length part is
				//	bound and the type is DBTYPE_BYTES.

				// There was another entry of code here with LENGTH, NO VALUE,
				//	and status was not DBSTATUS_S_ISNULL.  May need to regenerate that
				if (dbStat == DBSTATUS_S_OK)
				{
					if (!(pBindCur->dwPart & DBPART_VALUE) ||
						((pBindCur->dwPart & DBPART_LENGTH) && (pBindCur->wType == DBTYPE_BYTES)))
					{
						// Can't set non-null columns w/o a value part
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings,
									rgColumns.GetData(), DBREASON_COLUMN_SET, DBEVENTPHASE_FAILEDTODO, 
									TRUE);
							}
						}

						bFailed = true;
						*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = DBSTATUS_E_UNAVAILABLE;
						continue;
					}
				}

				switch (dbStat)
				{
				case DBSTATUS_S_ISNULL:
					if (!(pColCur->dwFlags & DBCOLUMNFLAGS_ISNULLABLE) ||
						FAILED(pT->SetDBStatus(&dbStat, pRow, pColCur)))
					{
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow, 
									pBinding->cBindings, rgColumns.GetData(), 
									DBREASON_COLUMN_SET, DBEVENTPHASE_FAILEDTODO, 
									TRUE);
							}
						}

						// Special processing for attempting to write, read-only columns
						if (!(pColCur->dwFlags & DBCOLUMNFLAGS_ISNULLABLE))
							*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = DBSTATUS_E_INTEGRITYVIOLATION;

						bFailed = true;
					}
					else
					{
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow, 1, &iBind, 
									DBREASON_COLUMN_SET, DBEVENTPHASE_DIDEVENT, TRUE);
							}
						}
						bSucceeded = true;
						dbStat = DBSTATUS_S_OK;
						if (pBindCur->dwPart & DBPART_VALUE)
						{
							ATLENSURE_RETURN(pDstTemp);
							*pDstTemp = NULL;
						}
					}
					continue;
					break;
				case DBSTATUS_S_DEFAULT:
				case DBSTATUS_S_IGNORE:
				{
					HRESULT hrStatus = pT->SetDBStatus(&dbStat, pRow, pColCur);
					*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = dbStat;

					if (FAILED(hrStatus))
					{
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings, 
									rgColumns.GetData(), DBREASON_COLUMN_SET, 
									DBEVENTPHASE_FAILEDTODO, TRUE);
							}
						}

						// Note, status should be set by SetDBStatus
						bFailed = true;
					}
					else
					{
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings, 
									rgColumns.GetData(), DBREASON_COLUMN_SET, 
									DBEVENTPHASE_DIDEVENT, TRUE);
							}
						}
						bSucceeded = true;
					}
					continue;
					break;
				}
				case DBSTATUS_S_OK:
					// Still call SetDBStatus here as they may have locks on 
					// integrity contstraints to observe
					if (FAILED(pT->SetDBStatus(&dbStat, pRow, pColCur)))
					{
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings, 
									rgColumns.GetData(), DBREASON_COLUMN_SET, 
									DBEVENTPHASE_FAILEDTODO, TRUE);
							}
						}

						bFailed = true;
						*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = dbStat;
						continue;
					}
					break;
				default:
					*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = DBSTATUS_E_BADSTATUS;

					__if_exists(T::Fire_OnFieldChange)
					{
						if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
							pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
						{
							pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings, 
								rgColumns.GetData(), DBREASON_COLUMN_SET, 
								DBEVENTPHASE_FAILEDTODO, TRUE);
						}
					}

					bFailed = true;
					continue;
					break;
				}
			}
		}


		// Determine sizes of input and output columns
		DBLENGTH cbCol = 0;
		DBLENGTH cbDst;
		if (bReading)
			cbDst = pBindCur->cbMaxLen;
		else
			cbDst = pColCur->ulColumnSize;

		switch (pColCur->wType)
		{
		case DBTYPE_STR:
			if (bReading)
				cbCol = lstrlenA((LPSTR)(((BYTE*)pSrcData) + pColCur->cbOffset));
			else
			{
				// Use the length field when setting data 
				if (pBindCur->dwPart & DBPART_LENGTH)
					cbCol = *((DBLENGTH*)((BYTE*)(pSrcData) + pBindCur->obLength));
				else
					cbCol = lstrlenA((LPSTR)(pSrcTemp));	// was cbDst

				if (cbCol >= cbDst)
				{
					if (cbCol > (cbDst + 1)) // over maximum case
					{
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings, 
									rgColumns.GetData(), DBREASON_COLUMN_SET, 
									DBEVENTPHASE_FAILEDTODO, TRUE);
							}
						}

						bFailed = true;
						if (pBindCur->dwPart & DBPART_STATUS)
							*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = DBSTATUS_E_CANTCONVERTVALUE;
						continue;
					}
				}
				cbCol = cbDst;	// Leave room for NULL term. need to copy for WSTR
			}
			break;
		case DBTYPE_WSTR:
		case DBTYPE_BSTR:
			if (bReading)
				cbCol = lstrlenW((LPWSTR)(((BYTE*)pSrcData) + pColCur->cbOffset)) * sizeof(WCHAR);
			else
			{
				if (pBindCur->dwPart & DBPART_LENGTH)
					cbCol = *((DBLENGTH*)((BYTE*)(pSrcData) + pBindCur->obLength)); 
				else
					cbCol = lstrlenW((LPWSTR)(pSrcData)) * sizeof(WCHAR);

				if (cbCol >= cbDst)
				{
					if (cbCol > (cbDst + 1)) // over maximum case
					{
						__if_exists(T::Fire_OnFieldChange)
						{
							if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
								pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
							{
								pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings, 
									rgColumns.GetData(), DBREASON_COLUMN_SET, 
									DBEVENTPHASE_FAILEDTODO, TRUE);
							}
						}

						bFailed = true;
						if (pBindCur->dwPart & DBPART_STATUS)
							*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = DBSTATUS_E_CANTCONVERTVALUE;
						continue;
					}
				}
				cbCol = cbDst;	// Leave room for NULL term. need to copy for WSTR
			}
			break;
		case DBTYPE_BYTES:
			if (bReading)
				cbCol = pColCur->ulColumnSize;
			else
			{
				if (pBindCur->dwPart & DBPART_LENGTH)
					cbCol = *((DBLENGTH *)((BYTE*)(pSrcData) + pBindCur->obLength)); 
				else
				{
					__if_exists(T::Fire_OnFieldChange)
					{
						if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
							pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
						{
							pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings, 
								rgColumns.GetData(), DBREASON_COLUMN_SET, 
								DBEVENTPHASE_FAILEDTODO, TRUE);
						}
					}

					// If no length part is bound for DBTYPE_BYTES, it is an error
					bFailed = true;
					continue;
				}

				if (cbCol >= cbDst)
					cbCol = cbDst;	// Leave room for NULL term. need to copy for WSTR
			}
			break;
		default:
			if (bReading)
				cbCol = pColCur->ulColumnSize;
			else
				cbDst = pColCur->ulColumnSize;

			break;
		}
		cbDst=cbCol; 

		// Handle cases where we have provider owned memory.  Note, these should be
		// with DBTYPE_BYREF (otherwise, it doesn't make sense).
		if (pBindCur->dwPart & DBPART_VALUE)
		{
			if (pBindCur->dwMemOwner == DBMEMOWNER_PROVIDEROWNED 
				&& pBindCur->wType & DBTYPE_BYREF)
			{
				ATLENSURE_RETURN(pDstTemp);
				*(BYTE**)pDstTemp = pSrcTemp;
			}
			else
			{
				ATLASSERT(pT->m_spConvert != NULL);
				hr = pT->m_spConvert->DataConvert(pColCur->wType, pBindCur->wType, 
						cbCol, &cbDst, pSrcTemp, pDstTemp, pBindCur->cbMaxLen, 
						dbStat, &dbStat, pBindCur->bPrecision, pBindCur->bScale,0);
			}
		}
		if (pBindCur->dwPart & DBPART_LENGTH)
		{
			if (bReading)
				*((DBLENGTH*)((BYTE*)(pDstData) + pBindCur->obLength)) = (dbStat == DBSTATUS_S_ISNULL) ? 0 : cbDst;
			else
				*((DBLENGTH*)((BYTE*)(pSrcData) + pBindCur->obLength)) = cbDst;
		}
		if (pBindCur->dwPart & DBPART_STATUS)
		{
			if (bReading)
				*((DBSTATUS*)((BYTE*)(pDstData) + pBindCur->obStatus)) = dbStat; 
			else
				*((DBSTATUS*)((BYTE*)(pSrcData) + pBindCur->obStatus)) = dbStat; 
		}

		if (FAILED(hr))
		{
			if (!bReading)
			{
				__if_exists(T::Fire_OnFieldChange)
				{
					if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
						pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
					{
						pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings, 
							rgColumns.GetData(), DBREASON_COLUMN_SET, 
							DBEVENTPHASE_FAILEDTODO, TRUE);
					}
				}
			}

			bFailed = true;
		}
		else
		{
			bSucceeded = true;
		}
	}

	// Return error codes to the consumer
	if (bFailed)
	{
		__if_exists(T::Fire_OnFieldChange)
		{
			if( !bReading )
			{
//				SendColumnSetFailureNotification( pT, hNotifyRow, pBinding, rgColumns );
				SendRowsFirstChangeFailureNotification( pT, pRow, &hNotifyRow, bDeferred );
			}
		}
		return (bSucceeded != false) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED;
	}
	else
	{
		if (!bReading)
		{
			__if_exists(T::Fire_OnFieldChange)
			{
				if (/* pRow->m_status != DBPENDINGSTATUS_NEW && */
					pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
				{
					pT->Fire_OnFieldChange(pT, hNotifyRow, pBinding->cBindings, 
						rgColumns.GetData(), DBREASON_COLUMN_SET, 
						DBEVENTPHASE_DIDEVENT, TRUE);
				}
			}
		}

		return hr;
	}
}

template <class T, class Storage, 
		  class BaseInterface = IRowsetChange,
		  class RowClass = CSimpleRow, 
		  class MapClass = CAtlMap < RowClass::KeyType, RowClass* > >
class ATL_NO_VTABLE IRowsetChangeImpl : public BaseInterface
{
public:
	// IRowsetChange Methods
	STDMETHOD (DeleteRows)(HCHAPTER /*hReserved*/, DBCOUNTITEM cRows, 
					const HROW rghRows[], DBROWSTATUS rgRowStatus[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetChangeImpl::DeleteRows"));

		T* pT = (T*)this;
		T::ObjectLock lock(pT);

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		BOOL bSuccess = false;
		BOOL bFailed = false;
		// Check to see if the DBPROP_UPDATABILITY value DBPROPVAL_UP_CHANGE
		// is set.  If not, then this method should return DB_E_NOTSUPPORTED.
		CComVariant varChange;
		HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_UPDATABILITY, 
							&varChange);
		if (!(varChange.iVal & DBPROPVAL_UP_DELETE))
			return DB_E_NOTSUPPORTED;

		// NO-OP if cRows is zero
		if (cRows == 0)
			return S_OK;

		if (rghRows == NULL && cRows >= 1)
			return E_INVALIDARG;

		// Determine if we're in immediate or deferred mode
		CComVariant varDeferred;
		bool bDeferred;
		hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_IRowsetUpdate, 
							&varDeferred);
		(FAILED(hr) || varDeferred.boolVal == ATL_VARIANT_FALSE) ? bDeferred = false : bDeferred = true;


		// Loop through and delete rows
		for (DBCOUNTITEM l=0; l<cRows; l++)
		{
			HROW hRow = rghRows[l];
			RowClass* pRow;
			DBROWSTATUS rowStat = DBROWSTATUS_S_OK;

			// Handle events
			__if_exists(T::Fire_OnRowChange)
			{
				HRESULT hrNotify = pT->Fire_OnRowChange(pT, 1, &rghRows[l],
					DBREASON_ROW_DELETE, DBEVENTPHASE_OKTODO, FALSE); 
				if (hrNotify == S_FALSE)
				{
					bFailed |= true;
					if (rgRowStatus != NULL)
						rgRowStatus[l] = DBROWSTATUS_E_CANCELED;
					continue;
				}
				else
				{
					hrNotify = pT->Fire_OnRowChange(pT, 1, &rghRows[l], 
						DBREASON_ROW_DELETE, DBEVENTPHASE_ABOUTTODO, FALSE);
					if (hrNotify == S_FALSE)
					{
						bFailed |= true;
						if (rgRowStatus != NULL)
							rgRowStatus[l] = DBROWSTATUS_E_CANCELED;

						continue;
					}
				}

				// Send sync after now as it gets tricky to replace stuff once 
				// we're in the method.
				hrNotify = pT->Fire_OnRowChange(pT, 1, &rghRows[l], 
					DBREASON_ROW_DELETE, DBEVENTPHASE_SYNCHAFTER, FALSE);
				if (hrNotify == S_FALSE)
				{
					bFailed |= true;
					if (rgRowStatus != NULL)
						rgRowStatus[l] = DBROWSTATUS_E_CANCELED;

					continue;
				}
			}

			// Attempt to locate the row in our map
			bool bFound = pT->m_rgRowHandles.Lookup(hRow, pRow);
			if (!bFound || pRow == NULL)
			{
				bFailed |= true;
				if (rgRowStatus != NULL)
					rgRowStatus[l] = DBROWSTATUS_E_INVALID;
				continue;
			}

			// Check if the row has already been deleted.  Note, we
			// use DBPENDINGSTATUS_DELETED in the immediate case as
			// well.
			if (pRow->m_status == DBPENDINGSTATUS_DELETED)
			{
				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, &rghRows[l],
						DBREASON_ROW_DELETE, DBEVENTPHASE_FAILEDTODO, 
						TRUE);
				}

				if (rgRowStatus != NULL)
					rgRowStatus[l] = DBROWSTATUS_E_DELETED;
				bFailed |= true;
				continue;
			}


			// Delete the row
			if (bDeferred)
			{
				// Mark the row as deleted but do not remove it until 
				// IRowsetUpdate::Update is called.
				if (pRow->m_status != DBPENDINGSTATUS_INVALIDROW)
				{
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, &rghRows[l], DBREASON_ROW_DELETE,
							DBEVENTPHASE_DIDEVENT, FALSE);
					}
					bSuccess |= true;
					rowStat = DBROWSTATUS_S_OK;
				}
				else
				{
					__if_exists(T::OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, &rghRows[l],
							DBREASON_ROW_DELETE, DBEVENTPHASE_FAILEDTODO, 
							FALSE);
					}

					bFailed |= true;
					// unsigned high bit signified neg. number
					if (pRow->m_dwRef & 0x80000000)		
						rowStat = DBROWSTATUS_E_INVALID;
					else
						rowStat = DBROWSTATUS_E_DELETED;
				}
			}
			else
			{
				// Remove the m_rgRowData and m_rgRowLink entries.  The 
				// HROW will be released in IRowset::ReleaseRows.  
				// Remove the link by NULLing out the pointer
				if( pRow->m_iRowset < 0 || pRow->m_iRowset >= pT->m_rgRowData.GetCount() )
				{
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, &rghRows[l],
							DBREASON_ROW_DELETE, DBEVENTPHASE_FAILEDTODO, 
							FALSE);
					}

					rowStat = DBROWSTATUS_E_INVALID;
					bFailed |= true;
				}
				else
				{
					pT->m_rgRowData.RemoveAt(pRow->m_iRowset);

					// Perform the actual delete of the row.  Send notificaitons
					// to inform the consumer of the change.

					// Need to update any outstanding pRow->m_iRowset
					// variables
					POSITION pos = pT->m_rgRowHandles.GetStartPosition();
					while (pos != NULL)
					{
						MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext( pos );
						ATLENSURE_RETURN( pPair != NULL );
						RowClass* pCheckRow = pPair->m_value;
						if (pCheckRow != NULL && 
							pCheckRow->m_iRowset > pRow->m_iRowset)
							pCheckRow->m_iRowset--;
					}

					__if_exists(T::GetRowsAt)
					{	
						// If we support bookmarks, then ensure our bookmark array
						// is solid
						for (size_t k=0; k<pT->m_rgBookmarks.GetCount(); k++)
						{
							if (pT->m_rgBookmarks[k] == (DBROWCOUNT)(pRow->m_iRowset + 1))
								pT->m_rgBookmarks[k] = -1;		// Value for invalid bookmark

							if (pT->m_rgBookmarks[k] > (DBROWCOUNT)(pRow->m_iRowset + 1))
								pT->m_rgBookmarks[k] = (pT->m_rgBookmarks[k] - 1);
						}
					}

					if (FAILED(pT->FlushData(rghRows[l], NULL)))
					{
						__if_exists(T::Fire_OnRowChange)
						{
							pT->Fire_OnRowChange(pT, 1, &rghRows[l],
								DBREASON_ROW_DELETE, DBEVENTPHASE_FAILEDTODO, 
								FALSE);
						}
						bFailed |= true;
						rowStat = DBROWSTATUS_E_FAIL;
					}
					else
					{
						// Send DIDEVENT
						__if_exists(T::Fire_OnRowChange)
						{
							pT->Fire_OnRowChange(pT, 1, &rghRows[l],
								DBREASON_ROW_DELETE, DBEVENTPHASE_DIDEVENT, FALSE);
						}
						rowStat = DBROWSTATUS_S_OK;
						bSuccess |= true;
					}
				}
			}

			// We use the status even in immediate mode to determine if a
			// row has been deleted from the cache but not release
			if (pRow->m_status == DBPENDINGSTATUS_NEW)
				pRow->m_status = DBPENDINGSTATUS_INVALIDROW;
			else
			{
				if (pRow->m_status != DBPENDINGSTATUS_INVALIDROW)
					pRow->m_status = DBPENDINGSTATUS_DELETED;
			}


			if (rgRowStatus != NULL)
				rgRowStatus[l] = rowStat;
		}



		hr = S_OK;
		if (bFailed)
			(bSuccess) ? hr = DB_S_ERRORSOCCURRED : hr = DB_E_ERRORSOCCURRED;

		return hr;
	}

	STDMETHOD (SetData)(HROW hRow, HACCESSOR hAccessor, void* pSrcData)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetChangeImpl::SetData\n"));

		T* pT = (T*)this;
		T::ObjectLock lock(pT);

		__if_exists(T::Fire_OnFieldChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		RowClass* pRow;

		// Check to see if the DBPROP_UPDATABILITY value DBPROPVAL_UP_CHANGE
		// is set.  If not, then this method should return DB_E_NOTSUPPORTED.
		CComVariant varChange;
		HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_UPDATABILITY, 
							&varChange);
		if (!(varChange.iVal & DBPROPVAL_UP_CHANGE))
			return DB_E_NOTSUPPORTED;


		if (hRow == NULL)
			return DB_E_BADROWHANDLE;
		if( ! pT->m_rgRowHandles.Lookup(hRow, pRow) )
			return DB_E_BADROWHANDLE;
		if (hRow == NULL || pRow == NULL)
			return DB_E_BADROWHANDLE;
		hr = TransferData<T, RowClass, MapClass>
								 (pT, false, pSrcData, pRow, &(pT->m_rgRowHandles), hAccessor);
		if (FAILED(hr))
			return hr;

		// Flush Users Data
		HRESULT hrFlush = pT->FlushData(hRow, hAccessor);

		if (SUCCEEDED(hrFlush))
			return hr;	// note: we could have DB_S_ERRORSOCCURRED from TransferData
		else
			return hrFlush;
	}

	STDMETHOD (InsertRow)(HCHAPTER /*hReserved*/, HACCESSOR hAccessor, 
					void* pData, HROW* phRow)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetChangeImpl::InsertRow\n"));

		T* pT = (T*) this;
		T::ObjectLock lock(pT);

		__if_exists(T::Fire_OnRowChange)
		{
			HRESULT hrNotify = S_OK;	// Used for responses to notifications

			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
			{
				// Note, we can't set this above because we may inadvertantly
				// step on someone elses *phRow
				if (phRow != NULL)
					*phRow = NULL;
				return DB_E_NOTREENTRANT;
			}
			else
				pT->DecrementMutex();
		}

		// Check to see if the DBPROP_UPDATABILITY value DBPROPVAL_UP_CHANGE
		// is set.  If not, then this method should return DB_E_NOTSUPPORTED.
		CComVariant varChange;
		HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_UPDATABILITY, 
							&varChange);
		if (!(varChange.iVal & DBPROPVAL_UP_INSERT))
			return DB_E_NOTSUPPORTED;


		if (phRow != NULL)
			*phRow = NULL;

		// validate that the hAccessor is valid
		T::_BindType* pBinding;
		bool bFound = pT->m_rgBindings.Lookup((INT_PTR)hAccessor, pBinding);
		if (!bFound || pBinding == NULL)
			return DB_E_BADACCESSORHANDLE;

		// validate parameters
		if (pData == NULL && pBinding->cBindings != 0)
			return E_INVALIDARG;

		// Check to see if DBPROP_CANHOLDROWS is set to false.  In this case,
		// return a DB_E_ROWSNOTRELEASED if there are any pending changes.
		CComVariant varHoldRows;
		hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_CANHOLDROWS, 
			&varHoldRows);

		if (FAILED(hr) || varHoldRows.boolVal == ATL_VARIANT_FALSE)
		{
			if (pT->m_rgRowHandles.GetCount() > 0)
			{
				RowClass* pCheckRow = NULL;
				POSITION pos = pT->m_rgRowHandles.GetStartPosition();

				while (pos != NULL)
				{
					MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(pos);
					ATLENSURE_RETURN( pPair != NULL );
					HROW hCheckRow = pPair->m_key;
					bool bFoundHandle = pT->m_rgRowHandles.Lookup(hCheckRow, pCheckRow);

					if (bFoundHandle && pCheckRow != NULL && 
						pCheckRow->m_status != DBPENDINGSTATUS_UNCHANGED)
						return DB_E_ROWSNOTRELEASED;
				}
			}
		}

		// We should check DBPROP_IMMOBILEROWS and then call an
		//		ordering routine in the user's code.
		// Create a row and place into m_rgRowData
		Storage newRow;		// Create an instance of the users data
		CComVariant var;
		HRESULT hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, 
			DBPROP_BOOKMARKS, &var);
		if (SUCCEEDED(hrProps) && var.boolVal != ATL_VARIANT_FALSE)
		{
			DBORDINAL cCols;
			ATLCOLUMNINFO* pInfo = T::GetColumnInfo(pT, &cCols);
			ATLASSERT(pInfo != NULL);
			for (DBORDINAL i = 0;i < cCols; i++)
			{
				if (pInfo[i].iOrdinal == 0)
				{
					switch(pInfo[i].wType)
					{
					case DBTYPE_BYTES:
						*((DBBKMARK*)(&newRow + pInfo[i].cbOffset)) = (ULONG_PTR)(pT->m_rgRowData.GetCount() + 1);
						break;
					default:
						ATLASSERT(FALSE);
					};
				}
			}
		}

		// Call CreateRow to make a new hRow
		HROW hInsertedRow = NULL;
		DBCOUNTITEM ulRowsObtained = 0;

		size_t lSize = pT->m_rgRowData.GetCount();

		hr = pT->CreateRow((LONG_PTR)lSize, ulRowsObtained, &hInsertedRow);

		if (FAILED(hr))
		{
			return hr;
		}
		else
		{
			__if_exists(T::Fire_OnRowChange)
			{
				hrNotify = pT->Fire_OnRowChange(pT, 1, &hInsertedRow, DBREASON_ROW_INSERT,
					DBEVENTPHASE_OKTODO, FALSE);
				if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
				{
					pT->m_rgRowHandles.RemoveKey((RowClass::KeyType)hInsertedRow);
					return DB_E_CANCELED;
				}

				hrNotify = pT->Fire_OnRowChange(pT, 1, &hInsertedRow, DBREASON_ROW_INSERT,
					DBEVENTPHASE_ABOUTTODO, FALSE);
				if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
				{
					pT->m_rgRowHandles.RemoveKey((RowClass::KeyType)hInsertedRow);
					return DB_E_CANCELED;
				}
			}
		}

		// Add in the storage and linkeage for the row 
		CComVariant varOrderedInsert;

		// Need to determine if we want ordered insertions
		bool bOrderedInsert;
		hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_IMMOBILEROWS, 
							&varOrderedInsert);
		(FAILED(hr) || varOrderedInsert.boolVal != ATL_VARIANT_FALSE) ? 
			bOrderedInsert = false : bOrderedInsert = true;

		//if (!pT->m_rgRowData.Add(newRow))
		//{
		//	ATLTRACE(atlTraceDBProvider, 0, _T("Failed to add record Out of Memory"));
		//	return E_OUTOFMEMORY;
		//}
		_ATLTRY
		{
			pT->m_rgRowData.Add(newRow);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e );
			ATLTRACE(atlTraceDBProvider, 0, _T("Failed to add record Out of Memory"));
			return E_OUTOFMEMORY;
		}

		// Set the inserted row's status to DBPENDINGSTATUS_NEW if it is deferred.
		// This will prevent a spurious Notification for ROW_FIRSTCHANGE from 
		// firing in IRowsetUpdateImpl::SetData.
		CComVariant varDeferred;
		bool bDeferred;
		HRESULT hrDeferred = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_IRowsetUpdate, 
							&varDeferred);
		(FAILED(hrDeferred) || varDeferred.boolVal == ATL_VARIANT_FALSE) ? bDeferred = false : bDeferred = true;

		RowClass* pRow;
		ATLVERIFY( pT->m_rgRowHandles.Lookup(hInsertedRow, pRow) );
		ATLENSURE_RETURN(pRow != NULL);

		// Set the status to NEW + UNCHANGED so we don't generate COLUMN_SET or 
		// FIRSTCHANGE events in SetData. We'll switch it back to zero after the 
		// operation.
		pRow->m_status = DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED;

		// Call SetData, if necessary
		if (pData != NULL)
		{
			hr = SetData(hInsertedRow, hAccessor, pData);
			if (FAILED(hr))
			{
				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, &hInsertedRow, DBREASON_ROW_INSERT,
						DBEVENTPHASE_FAILEDTODO, TRUE);
				}
			}
		}

		if (!bDeferred)
			pRow->m_status = 0;
		else
			pRow->m_status = DBPENDINGSTATUS_NEW;

		__if_exists(T::Fire_OnRowChange)
		{
			hrNotify = pT->Fire_OnRowChange(pT, 1, &hInsertedRow, DBREASON_ROW_INSERT,
				DBEVENTPHASE_SYNCHAFTER, FALSE);
			if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
			{
				// Remove storage
				RowClass* pRowInserted;
				ATLVERIFY( pT->m_rgRowHandles.Lookup(hInsertedRow, pRowInserted) );
				ATLENSURE_RETURN( pRowInserted != NULL );
				pT->m_rgRowData.RemoveAt(pRowInserted->m_iRowset);

				// Remove Handle
				pT->m_rgRowHandles.RemoveKey((RowClass::KeyType)hInsertedRow);

				return DB_E_CANCELED;
			}

			pT->Fire_OnRowChange(pT, 1, &hInsertedRow, DBREASON_ROW_INSERT,
				DBEVENTPHASE_DIDEVENT, TRUE);
		}

		if (phRow != NULL && SUCCEEDED(hr))
			*phRow = hInsertedRow;

		return hr;
 	}		


	// Callbacks to Provider
	HRESULT FlushData(HROW, HACCESSOR)
	{
		// The provider overrides this function to commit data to its store
		return S_OK;
	}
};


// IRowsetImpl
template <class T, class RowsetInterface, 
		  class RowClass = CSimpleRow, 
		  class MapClass = CAtlMap < RowClass::KeyType, RowClass* > >
class ATL_NO_VTABLE IRowsetImpl : public RowsetInterface
{
public:
	typedef RowClass _HRowClass;
	IRowsetImpl()
	{
		m_iRowset = 0;
		m_bCanScrollBack = false;
		m_bCanFetchBack = false;
		m_bRemoveDeleted = true;
		m_bIRowsetUpdate = false;
		m_bReset = true;
		m_bExternalFetch = false;
	}
	~IRowsetImpl()
	{
		//for (int i = 0; i < m_rgRowHandles.GetCount(); i++)
		//	delete (m_rgRowHandles.GetValueAt(i));
		POSITION pos = m_rgRowHandles.GetStartPosition();
		while( pos != NULL )
		{
			MapClass::CPair *pPair = m_rgRowHandles.GetNext(pos);
			if(pPair!=NULL)
			{
				delete pPair->m_value;
			}
			else
			{
				ATLASSERT(FALSE);
			}
		}
	}
	HRESULT RefRows(DBCOUNTITEM cRows, const HROW rghRows[], DBREFCOUNT rgRefCounts[],
					DBROWSTATUS rgRowStatus[], BOOL bAdd)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetImpl::AddRefRows\n"));
		if (cRows == 0)
			return S_OK;
		if (rghRows == NULL)
			return E_INVALIDARG;
		T::ObjectLock cab((T*)this);
		BOOL bSuccess1 = FALSE;
		BOOL bFailed1 = FALSE;
		DBROWSTATUS rs;
		DWORD dwRef;

		__if_exists(T::Fire_OnRowChange)
		{
			// Maintain an array of handles w/ zero ref counts for notification
			CAtlArray<HROW>  arrZeroHandles;
		}

		for (ULONG iRow = 0; iRow < cRows; iRow++)
		{
			HROW hRowCur = rghRows[iRow];
			RowClass* pRow;
			bool bFoundCur = m_rgRowHandles.Lookup((RowClass::KeyType)hRowCur, pRow);
			if (!bFoundCur || pRow == NULL)
			{
				ATLTRACE(atlTraceDBProvider, 0, _T("Could not find HANDLE %x in list\n"), hRowCur);
				rs = DBROWSTATUS_E_INVALID;
				dwRef = 0;
				bFailed1 = TRUE;
			}
			else
			{

				if (pRow->m_status != DBPENDINGSTATUS_UNCHANGED &&
					pRow->m_status != DBPENDINGSTATUS_INVALIDROW &&
					pRow->m_dwRef == 0 && !bAdd)
				{
					if (rgRefCounts)
						rgRefCounts[iRow] = 0;
					if (rgRowStatus != NULL)
						rgRowStatus[iRow] = DBROWSTATUS_E_INVALID;
					bFailed1 = TRUE;
					continue;
				}

				// Check if we're in immediate or deferred mode
				CComVariant varDeferred;
				bool bDeferred;
				T* pT = (T*)this;
				HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET, 
					DBPROP_IRowsetUpdate, &varDeferred);
				(FAILED(hr) || varDeferred.boolVal == ATL_VARIANT_FALSE) ? 
					bDeferred = false : bDeferred = true;

				if (!bDeferred && bAdd &&
					pRow->m_status == DBPENDINGSTATUS_DELETED)
				{
					bFailed1 = TRUE;
					if (rgRowStatus != NULL)
						rgRowStatus[iRow] = DBROWSTATUS_E_DELETED;
					continue;
				}

				if (bAdd)
					dwRef = pRow->AddRefRow();
				else
				{
					dwRef = pRow->ReleaseRow();
					if ((pRow->m_status != DBPENDINGSTATUS_UNCHANGED &&
						pRow->m_status != 0 &&
						pRow->m_status != DBPENDINGSTATUS_INVALIDROW) &&
						bDeferred)
					{
						if (rgRefCounts)
							rgRefCounts[iRow] = dwRef;
						if (rgRowStatus != NULL)
							rgRowStatus[iRow] = DBROWSTATUS_S_PENDINGCHANGES;
						bSuccess1 = TRUE;
						continue;
					}

					if (dwRef == 0)
					{
						__if_exists(T::Fire_OnRowsetChange)
						{
							_ATLTRY
							{
								arrZeroHandles.Add(hRowCur);
							}
							_ATLCATCH( e )
							{
								_ATLDELETEEXCEPTION( e );
								return E_FAIL;
							}
						}

						// Now determine if the DBPROP_REMOVEDELETED property
						// is ATL_VARIANT_FALSE.  If so, then do NOT remove the
						// row.
						hr = pT->GetPropValue(&DBPROPSET_ROWSET, 
							DBPROP_REMOVEDELETED, &varDeferred);
						if (FAILED(hr) || varDeferred.boolVal != ATL_VARIANT_FALSE)
						{
							delete pRow;
							m_rgRowHandles.RemoveKey((RowClass::KeyType)hRowCur);
						}
					}
				}
				bSuccess1 = TRUE;
				rs = DBROWSTATUS_S_OK;
			}
			if (rgRefCounts)
				rgRefCounts[iRow] = dwRef;
			if (rgRowStatus != NULL)
				rgRowStatus[iRow] = rs;
		}

		__if_exists(T::Fire_OnRowsetChange)
		{
			if (!bAdd && arrZeroHandles.GetCount() > 0)
			{
				T* pT = (T*)this;
				pT->Fire_OnRowChange(pT, (ULONG_PTR)arrZeroHandles.GetCount(), arrZeroHandles.GetData(), 
					DBREASON_ROW_RELEASE, DBEVENTPHASE_DIDEVENT, FALSE); 
			}
		}

		if (!bSuccess1 && !bFailed1)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("IRowsetImpl::RefRows Unexpected state\n"));
			return E_FAIL;
		}
		HRESULT hr = S_OK;
		if (bSuccess1 && bFailed1)
			hr = DB_S_ERRORSOCCURRED;
		if (!bSuccess1 && bFailed1)
			hr = DB_E_ERRORSOCCURRED;
		return hr;
	}

	STDMETHOD(AddRefRows)(DBCOUNTITEM cRows,
						  const HROW rghRows[],
						  DBREFCOUNT rgRefCounts[],
						  DBROWSTATUS rgRowStatus[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetImpl::AddRefRows\n"));
		if (cRows == 0)
			return S_OK;
		return RefRows(cRows, rghRows, rgRefCounts, rgRowStatus, TRUE);
	}
	virtual DBSTATUS GetDBStatus(RowClass* , ATLCOLUMNINFO*)
	{
		return DBSTATUS_S_OK;
	}
	virtual HRESULT SetDBStatus(DBSTATUS*, RowClass* , ATLCOLUMNINFO*)
	{
		// The provider overrides this function to handle special processing
		// for DBSTATUS_S_ISNULL and DBSTATUS_S_DEFAULT.  
		return S_OK;
	}

	OUT_OF_LINE HRESULT GetDataHelper(HACCESSOR hAccessor,
									  ATLCOLUMNINFO*& rpInfo,
									  void** ppBinding,
									  void*& rpSrcData,
									  DBORDINAL& rcCols, 
								  	  CComPtr<IDataConvert>& rspConvert,
									  RowClass* pRow)
	{
		ATLENSURE_RETURN(ppBinding != NULL);
		T* pT = (T*) this;
		T::_BindingVector::CPair* pPair = pT->m_rgBindings.Lookup( hAccessor );
		if (pPair == NULL || pPair->m_value == NULL)
			return DB_E_BADACCESSORHANDLE;
		*ppBinding = pPair->m_value;
		rpSrcData = (void*)&(pT->m_rgRowData[pRow->m_iRowset]);
		rpInfo = T::GetColumnInfo((T*)this, &rcCols);
		rspConvert = pT->m_spConvert;
		return S_OK;

	}
	STDMETHOD(GetData)(HROW hRow,
					   HACCESSOR hAccessor,
					   void *pDstData)
	{
		T* pT = (T*)this;
		RowClass* pRow;
		if (hRow == NULL )
			return DB_E_BADROWHANDLE;

		if( !pT->m_rgRowHandles.Lookup((INT_PTR)hRow, pRow))
			return DB_E_BADROWHANDLE;

		if (pRow == NULL)
			return DB_E_BADROWHANDLE;

		return TransferData<T, RowClass, MapClass>
						   (pT, true, pDstData, pRow, &(pT->m_rgRowHandles), hAccessor);
	}

	HRESULT CreateRow(DBROWOFFSET lRowsOffset, DBCOUNTITEM& cRowsObtained, HROW* rgRows)
	{
		RowClass* pRow = NULL;
		ATLASSERT(lRowsOffset >= 0);
		RowClass::KeyType key = lRowsOffset+1;
		ATLASSERT(key > 0);
		bool bFound = m_rgRowHandles.Lookup(key,pRow);
		if (!bFound || pRow == NULL)
		{
			ATLTRY(pRow = new RowClass(lRowsOffset))
			if (pRow == NULL)
				return E_OUTOFMEMORY;
			_ATLTRY
			{
				m_rgRowHandles.SetAt(key, pRow);
			}
			_ATLCATCH( e )
			{
				_ATLDELETEEXCEPTION( e );
				delete pRow;
				pRow = NULL;
				return E_OUTOFMEMORY;
			}
		}
		pRow->AddRefRow();
		m_bReset = false;
		rgRows[cRowsObtained++] = (HROW)key;
		return S_OK;
	}

	HRESULT GetNextRowsSkipDeleted(HCHAPTER /*hReserved*/,
									DBROWOFFSET lRowsOffset,
									DBROWCOUNT cRows,
									DBCOUNTITEM *pcRowsObtained,
									HROW **prghRows)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetImpl::GetNextRows\n"));
		T* pT = (T*) this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
			{
				// Note, we can't set this above this block because we may
				// inadvertantly reset somebody else's pcRowsObtained
				if (pcRowsObtained != NULL)
					*pcRowsObtained = 0;
				return DB_E_NOTREENTRANT;
			}
			else
				pT->DecrementMutex();
		}

		if (pcRowsObtained != NULL)
			*pcRowsObtained = 0;
		if (prghRows == NULL || pcRowsObtained == NULL)
			return E_INVALIDARG;
		if (cRows == 0)
			return S_OK;
		HRESULT hr = S_OK;
		T::ObjectLock cab(pT);
		if (lRowsOffset < 0 && !m_bCanScrollBack)
			return DB_E_CANTSCROLLBACKWARDS;
		if (cRows < 0  && !m_bCanFetchBack)
			return DB_E_CANTFETCHBACKWARDS;

		DBROWOFFSET cRowsInSet = (DBROWOFFSET)pT->m_rgRowData.GetCount();

		DBROWOFFSET iStepSize = cRows >= 0 ? 1 : -1;
		// If cRows == MINLONG_PTR, we can't use ABS on it.  Therefore, we reset it
		// to a value just greater than cRowsInSet
		if (cRows == MINLONG_PTR && cRowsInSet != MINLONG_PTR)
			cRows = cRowsInSet + 2;	// set the value to something we can deal with
		else
			cRows = AbsVal(cRows);

		// First, simulate the operation, skipping over any deleted rows, calculate the number of rows retrieved,
		// and return an error code if appropriate

		DBROWOFFSET nCurrentRow = m_iRowset;

		// Note, if m_bReset, m_iRowset must be 0
		if ( m_bReset && (lRowsOffset < 0 || ( lRowsOffset == 0 && iStepSize < 0 ) ) )
			nCurrentRow = cRowsInSet;

		// skip the rows according to the lRowsOffset value
		if( lRowsOffset > 0 )
		{
			DBROWOFFSET nRowsToSkip = lRowsOffset;

			while( nRowsToSkip > 0 && nCurrentRow <= cRowsInSet )
			{
				RowClass* pRow = NULL;
				RowClass::KeyType key = nCurrentRow + 1;
				bool bFound = m_rgRowHandles.Lookup(key,pRow);
				if( bFound && pRow != NULL )
				{
					if( pRow->m_status == DBPENDINGSTATUS_DELETED )
					{
						nCurrentRow++;
						continue;
					}
				}
				nCurrentRow++;
				nRowsToSkip--;
			}

			if( nCurrentRow > cRowsInSet )
				return DB_S_ENDOFROWSET;
		}
		else if( lRowsOffset < 0 )
		{
			DBROWOFFSET nRowsToSkip = lRowsOffset;
			if (nRowsToSkip == MINLONG_PTR && cRowsInSet != MINLONG_PTR)
				nRowsToSkip = cRowsInSet + 2;	// set the value to something we can deal with
			else
				nRowsToSkip = -nRowsToSkip;

			while( nRowsToSkip > 0 && nCurrentRow > 0 )
			{
				nCurrentRow--;

				RowClass* pRow = NULL;
				RowClass::KeyType key = nCurrentRow + 1;
				bool bFound = m_rgRowHandles.Lookup(key,pRow);
				if( bFound && pRow != NULL )
				{
					if( pRow->m_status == DBPENDINGSTATUS_DELETED )
					{
						continue;
					}
				}
				nRowsToSkip--;
			}

			if( nCurrentRow < 0 )
				return DB_S_ENDOFROWSET;
		}

		DBROWOFFSET nFetchStartPosition = nCurrentRow;

		// now fetch the rows
		DBROWOFFSET cRowsToFetch = cRows;
		DBROWOFFSET cRowsFetched = 0;
		if( iStepSize == 1 )
		{
			while( cRowsToFetch > 0 && nCurrentRow < cRowsInSet )
			{
				RowClass* pRow = NULL;
				RowClass::KeyType key = nCurrentRow + 1;
				bool bFound = m_rgRowHandles.Lookup(key,pRow);
				if( bFound && pRow != NULL )
				{
					if( pRow->m_status == DBPENDINGSTATUS_DELETED )
					{
						nCurrentRow++;
						continue;
					}
				}
				// now we would fetch the row
				cRowsFetched++;
				cRowsToFetch--;
				nCurrentRow++;
			}
		}
		else
		{
			while( cRowsToFetch > 0 && nCurrentRow > 0 )
			{
				nCurrentRow--;
				RowClass* pRow = NULL;
				RowClass::KeyType key = nCurrentRow + 1;
				bool bFound = m_rgRowHandles.Lookup(key,pRow);
				if( bFound && pRow != NULL )
				{
					if( pRow->m_status == DBPENDINGSTATUS_DELETED )
					{
						continue;
					}
				}
				// now we would fetch the row
				cRowsFetched++;
				cRowsToFetch--;
			}
		}

		//  we could not fetch any rows
		if( cRowsFetched == 0 )
			return DB_S_ENDOFROWSET;

		// Simulation completed... no problems detected... we can now perform the real fetching

		// Fire events for OKTODO and ABOUTTODO after all validation has taken
		// place but before any permanent changes to the rowset state take place
		__if_exists(T::Fire_OnRowsetChange)
		{
			// Only fire these events if we're not being called by a bookmark
			// operation (which is why m_bExternalFetch would be set to true)
			if(!m_bExternalFetch)	
			{
				HRESULT hrNotify = pT->Fire_OnRowsetChange(pT, 
					DBREASON_ROWSET_FETCHPOSITIONCHANGE, DBEVENTPHASE_OKTODO, FALSE); 
				if (hrNotify == S_FALSE)
					return DB_E_CANCELED;
				else
				{
					hrNotify = pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
						DBEVENTPHASE_ABOUTTODO, FALSE);
					if (hrNotify == S_FALSE)
						return DB_E_CANCELED;
					else
					{
						hrNotify = pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
							DBEVENTPHASE_SYNCHAFTER, FALSE);
						if (hrNotify == S_FALSE)
							return DB_E_CANCELED;
					}
				}
			}
		}

		nCurrentRow = nFetchStartPosition; // we already calculated the 'start fetch position' in the simulation stage
		ATLASSERT( nCurrentRow >= 0 && nCurrentRow <= cRowsInSet );

		*pcRowsObtained = 0;
		CComHeapPtr<HROW> rghRowsAllocated;
		if (*prghRows == NULL)
		{
			DBROWOFFSET cHandlesToAlloc = cRowsFetched;

			rghRowsAllocated.Allocate(cHandlesToAlloc);
			if(rghRowsAllocated == NULL)
				return E_OUTOFMEMORY;

			*prghRows = rghRowsAllocated;
		}

		// now fetch the rows
		cRowsToFetch = cRows;

		while( cRowsToFetch > 0 && nCurrentRow >= 0 && nCurrentRow <= cRowsInSet )
		{
			if( ( iStepSize == 1 && nCurrentRow == cRowsInSet ) ||
				( iStepSize == -1 && nCurrentRow == 0 ) )
				break;

			DBROWOFFSET lRow = nCurrentRow;

			if( iStepSize > 0 )
			{
				while(true)
				{
					RowClass* pRow = NULL;
					RowClass::KeyType key = lRow + 1;
					bool bFound = m_rgRowHandles.Lookup(key,pRow);
					if( bFound && pRow != NULL )
					{
						if( pRow->m_status == DBPENDINGSTATUS_DELETED )
						{
							lRow++;
							ATLASSERT( lRow < cRowsInSet );
							continue;
						}
					}
					break;
				}
			}
			else
			{
				while(true)
				{
					lRow--;
					RowClass* pRow = NULL;
					RowClass::KeyType key = lRow + 1;
					bool bFound = m_rgRowHandles.Lookup(key,pRow);
					if( bFound && pRow != NULL )
					{
						if( pRow->m_status == DBPENDINGSTATUS_DELETED )
						{
							ATLASSERT( lRow >= 0 );
							continue;
						}
					}
					break;
				}
			}

			ATLASSERT( lRow >= 0 && lRow < cRowsInSet );

			hr = pT->CreateRow(lRow, *pcRowsObtained, *prghRows);

			if (FAILED(hr))
			{
				RefRows(*pcRowsObtained, *prghRows, NULL, NULL, FALSE);
				for (ULONG iRowDel = 0; iRowDel < *pcRowsObtained; iRowDel++)
					*prghRows[iRowDel] = NULL;
				*pcRowsObtained = 0; 
				return hr;
			}

			__if_exists(T::Fire_OnRowsetChange)
			{
				if (!m_bExternalFetch)
					pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
						DBEVENTPHASE_DIDEVENT, TRUE);
			}

			cRowsToFetch--;
			if( iStepSize > 0 )
				nCurrentRow = lRow + iStepSize;
			else
				nCurrentRow = lRow;
		} // while

		// If we have multiple rows fetched, return one event, per the specification
		// containing all rows activated.
		if (*pcRowsObtained >= 1)
		{
			__if_exists(T::Fire_OnRowsetChange)
			{
				CAtlArray<HROW> rgActivated;
				for (size_t ulActivated = 0; ulActivated < *pcRowsObtained; ulActivated++)
				{
					// This is a bit of an assumption that all newly activated
					// rows would have the ref count as 1.  Another way to solve this
					// problem would be to modify the signature of CreateRow to take
					// a CAtlArray<HROW> as a parameter and store the activated rows.
					RowClass* pActiveRow;
					if( m_rgRowHandles.Lookup((*prghRows)[ulActivated], pActiveRow ) &&
						(pActiveRow != NULL && pActiveRow->m_dwRef == 1) )
					{
						_ATLTRY
						{
							rgActivated.Add((*prghRows)[ulActivated]);
						}
						_ATLCATCH( e )
						{
							_ATLDELETEEXCEPTION( e );
							return E_OUTOFMEMORY;
						}
					}
				}
				if (rgActivated.GetCount() > 0)
				{
					pT->Fire_OnRowChange(pT, (DBCOUNTITEM)rgActivated.GetCount(), rgActivated.GetData(), 
						DBREASON_ROW_ACTIVATE, DBEVENTPHASE_DIDEVENT, FALSE); 
				}
			}
		}

		m_iRowset = nCurrentRow;
		if( *pcRowsObtained < (DBCOUNTITEM)cRows ) // we could not fetch the requested # of rows
			hr = DB_S_ENDOFROWSET;

		if (SUCCEEDED(hr))
			rghRowsAllocated.Detach();

		return hr;
	}

	STDMETHOD(GetNextRows)(HCHAPTER hReserved,
						   DBROWOFFSET lRowsOffset,
						   DBROWCOUNT cRows,
						   DBCOUNTITEM *pcRowsObtained,
						   HROW **prghRows)
	{

		if( m_bRemoveDeleted && m_bIRowsetUpdate )
			return GetNextRowsSkipDeleted( hReserved, lRowsOffset, cRows, pcRowsObtained, prghRows );

		DBROWOFFSET lTmpRows = lRowsOffset;
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetImpl::GetNextRows\n"));
		T* pT = (T*) this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
			{
				// Note, we can't set this above this block because we may
				// inadvertantly reset somebody else's pcRowsObtained
				if (pcRowsObtained != NULL)
					*pcRowsObtained = 0;
				return DB_E_NOTREENTRANT;
			}
			else
				pT->DecrementMutex();
		}

		if (pcRowsObtained != NULL)
			*pcRowsObtained = 0;
		if (prghRows == NULL || pcRowsObtained == NULL)
			return E_INVALIDARG;
		if (cRows == 0)
			return S_OK;
		HRESULT hr = S_OK;
		T::ObjectLock cab(pT);
		if (lRowsOffset < 0 && !m_bCanScrollBack)
			return DB_E_CANTSCROLLBACKWARDS;
		if (cRows < 0  && !m_bCanFetchBack)
			return DB_E_CANTFETCHBACKWARDS;

		// Calculate # of rows in set and the base fetch position.  If the rowset
		// is at its head position, then lRowOffset < 0 means moving from the BACK 
		// of the rowset and not the front.

		DBROWOFFSET cRowsInSet = (DBROWOFFSET)pT->m_rgRowData.GetCount();

		if (((lRowsOffset == MINLONG_PTR) && (cRowsInSet != MINLONG_PTR))
			|| AbsVal(lRowsOffset) > cRowsInSet ||
			( AbsVal(lRowsOffset) == cRowsInSet && lRowsOffset < 0 && cRows < 0 ) ||
			( AbsVal(lRowsOffset) == cRowsInSet && lRowsOffset > 0 && cRows > 0 ))
			return DB_S_ENDOFROWSET;

		// In the case where the user is moving backwards after moving forwards,
		// we do not wrap around to the end of the rowset.
		if ((m_iRowset == 0 && !m_bReset && cRows < 0) ||
			((m_iRowset + lRowsOffset) > cRowsInSet) ||
			(m_iRowset == cRowsInSet && lRowsOffset >= 0 && cRows > 0))
			return DB_S_ENDOFROWSET;

		// Fire events for OKTODO and ABOUTTODO after all validation has taken
		// place but before any permanent changes to the rowset state take place
		__if_exists(T::Fire_OnRowsetChange)
		{
			// Only fire these events if we're not being called by a bookmark
			// operation (which is why m_bExternalFetch would be set to true)
			if(!m_bExternalFetch)	
			{
				HRESULT hrNotify = pT->Fire_OnRowsetChange(pT, 
					DBREASON_ROWSET_FETCHPOSITIONCHANGE, DBEVENTPHASE_OKTODO, FALSE); 
				if (hrNotify == S_FALSE)
					return DB_E_CANCELED;
				else
				{
					hrNotify = pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
						DBEVENTPHASE_ABOUTTODO, FALSE);
					if (hrNotify == S_FALSE)
						return DB_E_CANCELED;
					else
					{
						hrNotify = pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
							DBEVENTPHASE_SYNCHAFTER, FALSE);
						if (hrNotify == S_FALSE)
							return DB_E_CANCELED;
					}
				}
			}
		}

		// Note, if m_bReset, m_iRowset must be 0
		if (lRowsOffset < 0 && m_bReset)
			m_iRowset = cRowsInSet;

		int iStepSize = cRows >= 0 ? 1 : -1;

		// If cRows == MINLONG_PTR, we can't use ABS on it.  Therefore, we reset it
		// to a value just greater than cRowsInSet
		if (cRows == MINLONG_PTR && cRowsInSet != MINLONG_PTR)
			cRows = cRowsInSet + 2;	// set the value to something we can deal with
		else
			cRows = AbsVal(cRows);

		if (iStepSize < 0 && m_iRowset == 0 && m_bReset && lRowsOffset <= 0)
			m_iRowset = cRowsInSet; 

		lRowsOffset += m_iRowset;

		*pcRowsObtained = 0;
		CComHeapPtr<HROW> rghRowsAllocated;
		if (*prghRows == NULL)
		{
			DBROWOFFSET cHandlesToAlloc = __min(cRowsInSet, cRows);
			if (iStepSize == 1 && (cRowsInSet - lRowsOffset) < cHandlesToAlloc)
				cHandlesToAlloc = cRowsInSet - lRowsOffset;
			if (iStepSize == -1 && lRowsOffset < cHandlesToAlloc)
				cHandlesToAlloc = lRowsOffset;

			rghRowsAllocated.Allocate(cHandlesToAlloc);
			if(rghRowsAllocated == NULL)
				return E_OUTOFMEMORY;			
			*prghRows = rghRowsAllocated;
		}

		while ((lRowsOffset >= 0 && cRows != 0) &&
			((lRowsOffset < cRowsInSet) || (lRowsOffset <= cRowsInSet && iStepSize < 0))) 
		{
			// cRows > cRowsInSet && iStepSize < 0
			if (lRowsOffset == 0 && cRows > 0 && iStepSize < 0)
				break;

			// in the case where we have iStepSize < 0, move the row back
			// further because we want the previous row
			DBROWOFFSET lRow = lRowsOffset;
			if ((lRowsOffset == 0) && (lTmpRows == 0) && (iStepSize < 0))
				lRow = cRowsInSet;

			if (iStepSize < 0)
				lRow += iStepSize;

			hr = pT->CreateRow(lRow, *pcRowsObtained, *prghRows);

			if (FAILED(hr))
			{
				RefRows(*pcRowsObtained, *prghRows, NULL, NULL, FALSE);
				for (ULONG iRowDel = 0; iRowDel < *pcRowsObtained; iRowDel++)
					*prghRows[iRowDel] = NULL;
				*pcRowsObtained = 0; 
				return hr;
			}

			__if_exists(T::Fire_OnRowsetChange)
			{
				if (!m_bExternalFetch)
					pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
						DBEVENTPHASE_DIDEVENT, TRUE);
			}

			cRows--;
			lRowsOffset += iStepSize;
		}

		// If we have multiple rows fetched, return one event, per the specification
		// containing all rows activated.
		if (*pcRowsObtained >= 1)
		{
			__if_exists(T::Fire_OnRowsetChange)
			{
				CAtlArray<HROW> rgActivated;
				for (size_t ulActivated = 0; ulActivated < *pcRowsObtained; ulActivated++)
				{
					// This is a bit of an assumption that all newly activated
					// rows would have the ref count as 1.  Another way to solve this
					// problem would be to modify the signature of CreateRow to take
					// a CAtlArray<HROW> as a parameter and store the activated rows.
					RowClass* pActiveRow;
					if( m_rgRowHandles.Lookup((*prghRows)[ulActivated], pActiveRow ) &&
						(pActiveRow != NULL && pActiveRow->m_dwRef == 1) )
					{
						_ATLTRY
						{
							rgActivated.Add((*prghRows)[ulActivated]);
						}
						_ATLCATCH( e )
						{
							_ATLDELETEEXCEPTION( e );
							return E_OUTOFMEMORY;
						}
					}
				}
				if (rgActivated.GetCount() > 0)
				{
					pT->Fire_OnRowChange(pT, (DBCOUNTITEM)rgActivated.GetCount(), rgActivated.GetData(), 
						DBREASON_ROW_ACTIVATE, DBEVENTPHASE_DIDEVENT, FALSE); 
				}
			}
		}

		m_iRowset = lRowsOffset;
		if ((lRowsOffset >= cRowsInSet && cRows) || (lRowsOffset < 0 && cRows)  ||
			(lRowsOffset == 0 && cRows > 0 && iStepSize < 0))
			hr = DB_S_ENDOFROWSET;

		if (SUCCEEDED(hr))
			rghRowsAllocated.Detach();
		return hr;
	}

	STDMETHOD(ReleaseRows)(DBCOUNTITEM cRows,
						   const HROW rghRows[],
						   DBROWOPTIONS rgRowOptions[],
						   DBREFCOUNT rgRefCounts[],
						   DBROWSTATUS rgRowStatus[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetImpl::ReleaseRows\n"));

		__if_exists(T::Fire_OnRowChange)
		{
			T* pT = (T*) this;

			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		if (cRows == 0)
			return S_OK;
		rgRowOptions;
		return RefRows(cRows, rghRows, rgRefCounts, rgRowStatus, FALSE);
	}

	STDMETHOD(RestartPosition)(HCHAPTER /*hReserved*/)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetImpl::RestartPosition\n"));

		T* pT = (T*) this;

		__if_exists(T::Fire_OnRowsetChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();


			bool bNeedEvents = ((m_iRowset != 0 || !m_bReset)) ? true : false;

			// Only fire the events iff. we are actually causing a reset
			if (bNeedEvents)
			{
				HRESULT hrNotify = pT->Fire_OnRowsetChange(pT, 
					DBREASON_ROWSET_FETCHPOSITIONCHANGE, DBEVENTPHASE_OKTODO, FALSE); 
				if (hrNotify == S_FALSE)
					return DB_E_CANCELED;
				else
				{
					hrNotify = pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
						DBEVENTPHASE_ABOUTTODO, FALSE);
					if (hrNotify == S_FALSE)
						return DB_E_CANCELED;
					else
					{
						hrNotify = pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE,
							DBEVENTPHASE_SYNCHAFTER, FALSE);
						if (hrNotify == S_FALSE)
							return DB_E_CANCELED;
					}
				}

			}
		}

		// Check to see if DBPROP_CANHOLDROWS is set to false.  In this case,
		// return a DB_E_ROWSNOTRELEASED.
		CComVariant varHoldRows;
		HRESULT hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_CANHOLDROWS, 
			&varHoldRows);

		if (FAILED(hr) || varHoldRows.boolVal == ATL_VARIANT_FALSE)
		{
			if (m_rgRowHandles.GetCount() > 0)
			{
				RowClass* pRow = NULL;
				POSITION pos = pT->m_rgRowHandles.GetStartPosition();

				while (pos != NULL)
				{
					MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(pos);
					ATLENSURE_RETURN( pPair != NULL );
					HROW hRow = pPair->m_key;
					bool bFound = pT->m_rgRowHandles.Lookup(hRow, pRow);

					if (bFound && pRow != NULL && 
						pRow->m_status != DBPENDINGSTATUS_UNCHANGED)
					{
						__if_exists(T::Fire_OnRowsetChange)
						{
							if (bNeedEvents)
							{
								pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE, 
										DBEVENTPHASE_FAILEDTODO, TRUE); 
							}
						}

						return DB_E_ROWSNOTRELEASED;
					}
				}
			}
		}

		m_iRowset = 0;
		m_bReset = true;
		__if_exists(T::Fire_OnRowsetChange)
		{
			// listener must comply so blow off ret val.
			if (bNeedEvents)
				pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_FETCHPOSITIONCHANGE, 
						DBEVENTPHASE_DIDEVENT, TRUE); 
		}
		return S_OK;
	}

	MapClass  m_rgRowHandles;
	DBROWOFFSET m_iRowset; // cursor
	unsigned  m_bCanScrollBack:1;
	unsigned  m_bCanFetchBack:1;
	unsigned  m_bRemoveDeleted:1; // DBPROP_REMOVEDELETED
	unsigned  m_bIRowsetUpdate:1; // DBPROP_IRowsetUpdate
	unsigned  m_bReset:1;
	unsigned  m_bExternalFetch:1;
};


template <class T, class RowsetInterface, 
		  class RowClass = CSimpleRow, 
		  class MapClass = CAtlMap < RowClass::KeyType, RowClass* >,
		  class BookmarkKeyType = LONG, class BookmarkType = LONG,
		  class BookmarkMapClass = CAtlMap < RowClass::KeyType, RowClass* > >
class ATL_NO_VTABLE IRowsetLocateImpl : public IRowsetImpl<T, RowsetInterface, RowClass, MapClass> 
{
public:
	STDMETHOD (Compare)(HCHAPTER /*hReserved*/, DBBKMARK cbBookmark1, 
		const BYTE * pBookmark1, DBBKMARK cbBookmark2, const BYTE * pBookmark2,
		DBCOMPARE * pComparison)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetLocateImpl::Compare\n"));

		T* pT = (T*)this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}


		// Validate input parameters
		if (pComparison == NULL)
			return E_INVALIDARG;

		// ValidateBookmark catches the cbBookmark == 0 and the 
		//		pBookmark == NULL -- E_INVALIDARG cases
		HRESULT hr = ValidateBookmark(cbBookmark1, pBookmark1);
		if (hr != S_OK)
			return hr;

		hr = ValidateBookmark(cbBookmark2, pBookmark2);
		if (hr != S_OK)
			return hr;

		// Return the value based on the bookmark values.  Be sure that
		// they are not specials in which case go below
		if ((*pBookmark1 == *pBookmark2) && (cbBookmark1 != 1) && (cbBookmark2 != 1))
		{
			*pComparison = DBCOMPARE_EQ;
			return S_OK;
		}

		// Determine if we are using ordered or unorder bookmarks
		CComVariant varOrdered;
		HRESULT hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_ORDEREDBOOKMARKS, 
			&varOrdered);

		if ((*pBookmark1 == DBBMK_FIRST && cbBookmark1 == 1) || 
			(*pBookmark1 == DBBMK_LAST  && cbBookmark1 == 1) ||
			(*pBookmark2 == DBBMK_FIRST && cbBookmark2 == 1) ||
			(*pBookmark2 == DBBMK_LAST  && cbBookmark2 == 1) ||
			(FAILED(hrProps)) || 
			(varOrdered.boolVal == ATL_VARIANT_FALSE))
		{
			// If the bookmarks are 'specials' DBBMK_FIRST or DBBMK_LAST or the
			// bookmarks are unordered, then we return NE instead of GT or LT.
			if (*pBookmark1 == *pBookmark2)
				*pComparison = DBCOMPARE_EQ;
			else
				*pComparison = DBCOMPARE_NE;
		}
		else
		{
			// We have valid bookmarks which are not special values.  
			// Since we assume that bookmarks are ordered, we'll return
			// the 
			if (*(DBBKMARK*)pBookmark1 < *(DBBKMARK*)pBookmark2)
				*pComparison = DBCOMPARE_LT;
			else if (*(DBBKMARK*)pBookmark1 > *(DBBKMARK*)pBookmark2)
				*pComparison = DBCOMPARE_GT;
			else
				*pComparison = DBCOMPARE_EQ;
		}

		return S_OK;
	}

	STDMETHOD (GetRowsAt)(HWATCHREGION /*hReserved1*/, HCHAPTER hReserved2,
		DBBKMARK cbBookmark, const BYTE * pBookmark, DBROWOFFSET lRowsOffset,
		DBROWCOUNT cRows, DBCOUNTITEM * pcRowsObtained, HROW ** prghRows)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetLocateImpl::GetRowsAt\n"));

		T* pT = (T*)this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		T::ObjectLock cab(pT);

		// Check input parameters
		if (pcRowsObtained == NULL)
			return E_INVALIDARG;

		*pcRowsObtained = 0;

		if (cbBookmark == 0 || pBookmark == NULL || prghRows == NULL)
			return E_INVALIDARG;

		// Check bookmark
		HRESULT hr = ValidateBookmark(cbBookmark, pBookmark);
		if (hr != S_OK)
			return hr;

		// Set the current row position to the bookmark.  Handle any
		// normal values

		// We need to handle the offset as the start position is defined
		// as the bookmark + offset.  If the offset is negative, and we
		// do not have m_bCanScrollBack then return an error.  The 
		// GetNextRows function handles the case where cRows is negative
		// and we don't have m_bCanFetchBack set.
		if (lRowsOffset < 0 && !m_bCanScrollBack)
			return DB_E_CANTSCROLLBACKWARDS;

		DBROWOFFSET iRowsetTemp = m_iRowset;  // Cache the current rowset 

		// Determine if this row is deleted or not.
		size_t lBookmarkIndex = (size_t)(*pBookmark);

		// -1 is uniform value for a deleted bookmark
		if( cbBookmark != 1 )
		{
			if (m_rgBookmarks[lBookmarkIndex] == -1)
			{
				m_iRowset = iRowsetTemp;
				return DB_E_BADBOOKMARK;
			}
			else
			{
				m_iRowset = m_rgBookmarks[lBookmarkIndex];
			}
		}

		if ((cbBookmark == 1) && (*pBookmark == DBBMK_FIRST))
			m_iRowset = 1;

		if ((cbBookmark == 1) && (*pBookmark == DBBMK_LAST))
			m_iRowset = (DBROWOFFSET)pT->m_rgRowData.GetCount();

		// Set the start position to m_iRowset + lRowsOffset
		m_iRowset += lRowsOffset;

		if (lRowsOffset >= 0)
			(cRows >= 0) ? m_iRowset -= 1 : m_iRowset +=0;
		else
			(cRows >= 0) ? m_iRowset -= 1 : m_iRowset +=0;
//		(lRowsOffset >= 0) ? m_iRowset -= 1 : m_iRowset += 1;

		// BUG: If we get DBBMK_FIRST and lRowsOffset == -1, then we set
		// m_iRowset to 0xFFFFFFFF.

		if (m_iRowset < 0 || m_iRowset > (DBROWOFFSET)pT->m_rgRowData.GetCount())
		{
			m_iRowset = iRowsetTemp;
			return DB_S_ENDOFROWSET;
		}

		// Call IRowsetImpl::GetNextRows to actually get the rows.
		m_bExternalFetch = true;
		hr = GetNextRows(hReserved2, 0, cRows, pcRowsObtained, prghRows);
		m_bExternalFetch = false;

		// If we have multiple rows fetched, return one event, per the specification
		// containing all rows activated.
		if (*pcRowsObtained >= 1)
		{
			__if_exists(T::Fire_OnRowsetChange)
			{
				CAtlArray<HROW> rgActivated;
				for (ULONG ulActivated = 0; ulActivated < *pcRowsObtained; ulActivated++)
				{
					// This is a bit of an assumption that all newly activated
					// rows would have the ref count as 1.  Another way to solve this
					// problem would be to modify the signature of CreateRow to take
					// a CAtlArray<HROW> as a parameter and store the activated rows.
					RowClass* pActiveRow;
					bool bFound = m_rgRowHandles.Lookup((*prghRows)[ulActivated], pActiveRow);
					if ( bFound && pActiveRow != NULL && pActiveRow->m_dwRef == 1)
					{
						_ATLTRY
						{
							rgActivated.Add((*prghRows)[ulActivated]);
						}
						_ATLCATCH( e )
						{
							_ATLDELETEEXCEPTION( e );
							return E_OUTOFMEMORY;
						}
					}
				}
				if (rgActivated.GetCount() > 0)
				{
					pT->Fire_OnRowChange(pT, (DBCOUNTITEM)rgActivated.GetCount(), rgActivated.GetData(), 
						DBREASON_ROW_ACTIVATE, DBEVENTPHASE_DIDEVENT, FALSE); 
				}
			}
		}

		m_iRowset = iRowsetTemp;
		return hr;
	}

	STDMETHOD (GetRowsByBookmark)(HCHAPTER /*hReserved*/, DBCOUNTITEM cRows,
		const DBBKMARK rgcbBookmarks[], const BYTE * rgpBookmarks[],
		HROW rghRows[], DBROWSTATUS rgRowStatus[])
	{
		HRESULT hr = S_OK;
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetLocateImpl::GetRowsByBookmark\n"));
		bool bErrors = false;
		bool bSuccess = false;

		T* pT = (T*)this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		T::ObjectLock cab(pT);
		if (rgcbBookmarks == NULL || rgpBookmarks == NULL || rghRows == NULL)
			return E_INVALIDARG;

		if (cRows == 0)
			return S_OK;	// No rows fetched in this case.

		memset(rghRows, 0, sizeof(HROW)*cRows);
		for (size_t l=0; l<cRows; l++)
		{
			// Validate each bookmark before fetching the row.  Note, it is
			// an error for the bookmark to be one of the standard values
			const BYTE* pBookmark = rgpBookmarks[l];
			hr = ValidateBookmark(rgcbBookmarks[l], pBookmark);
			if ((hr != S_OK) ||
				(*pBookmark == DBBMK_FIRST && rgcbBookmarks[l] == 1) ||
				(*pBookmark == DBBMK_LAST && rgcbBookmarks[l] == 1))
			{
				bErrors |= true;
				if (rgRowStatus != NULL)
				{
					rgRowStatus[l] = DBROWSTATUS_E_INVALID;
					continue;
				}
			}

			// Determine if this row is deleted or not by first looking in our cache
			DBROWCOUNT lBookmarkIndex = *(DBROWCOUNT*)pBookmark;
			if (m_rgBookmarks[lBookmarkIndex] == -1) // Uniform value for invalid row
			{
				if (rgRowStatus != NULL)
					rgRowStatus[l] = DBROWSTATUS_E_INVALID;

				bErrors |= true;
				continue;
			}

			// Fetch the row, we now that it is a valid row after validation.
			DBCOUNTITEM ulRowsObtained = 0;
			DBROWCOUNT lRow = m_rgBookmarks[lBookmarkIndex] - 1;
//			if (((long)*rgpBookmarks[l]) != 0)
//				lRow = ((long)*rgpBookmarks[l]) - 1;

			// Attempt to create the row
			if (CreateRow(lRow, ulRowsObtained, &rghRows[l]) != S_OK)
			{
				bErrors |= true;
			}
			else
			{
				if (rgRowStatus != NULL)
					rgRowStatus[l] = DBROWSTATUS_S_OK;

				bSuccess |= true;
			}
		}

		__if_exists(T::Fire_OnRowsetChange)
		{
			CAtlArray<HROW> rgActivated;
			for (size_t ulActivated = 0; ulActivated < cRows; ulActivated++)
			{
				// This is a bit of an assumption that all newly activated
				// rows would have the ref count as 1.  Another way to solve this
				// problem would be to modify the signature of CreateRow to take
				// a CAtlArray<HROW> as a parameter and store the activated rows.
				RowClass* pActiveRow;
				bool bFound = m_rgRowHandles.Lookup(rghRows[ulActivated], pActiveRow);
				if (bFound && pActiveRow != NULL && pActiveRow->m_dwRef == 1)
				{
					_ATLTRY
					{
						rgActivated.Add(rghRows[ulActivated]);
					}
					_ATLCATCH( e )
					{
						_ATLDELETEEXCEPTION( e );
						return E_OUTOFMEMORY;
					}
				}
			}
			if (rgActivated.GetCount() > 0)
			{
				pT->Fire_OnRowChange(pT, (DBCOUNTITEM)rgActivated.GetCount(), rgActivated.GetData(), 
					DBREASON_ROW_ACTIVATE, DBEVENTPHASE_DIDEVENT, FALSE); 
			}
		}

		if (bErrors)
			return (bSuccess != false) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED;
		else
			return hr;
	}

	STDMETHOD (Hash)(HCHAPTER /*hReserved*/, DBBKMARK cBookmarks,
		const DBBKMARK rgcbBookmarks[], const BYTE * rgpBookmarks[],
		DBHASHVALUE rgHashedValues[], DBROWSTATUS rgBookmarkStatus[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetLocateImpl::Hash\n"));

		bool bSuccess = false;
		bool bErrors = false;

		__if_exists(T::Fire_OnRowChange)
		{
			T* pT = (T*)this;
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		HRESULT hr = E_FAIL;
		// validate parameters
		if (cBookmarks != 0 && (rgcbBookmarks == NULL || rgpBookmarks == NULL ||
			rgHashedValues == NULL))
			return E_INVALIDARG;

		// hash values
		for (size_t i=0; i<cBookmarks; i++)
		{
			// Check the bookmarks
			const BYTE* pBookmark = rgpBookmarks[i];
			hr = ValidateBookmark(rgcbBookmarks[i], pBookmark);
			if (FAILED(hr) || 
				(*pBookmark == DBBMK_LAST && rgcbBookmarks[i] == 1) || 
				(*pBookmark == DBBMK_FIRST && rgcbBookmarks[i] == 1))
			{
				if (rgBookmarkStatus != NULL)
					rgBookmarkStatus[i] = DBROWSTATUS_E_INVALID;
				bErrors |= true;
				continue;
			}

			rgHashedValues[i] = (DBHASHVALUE)(*(rgpBookmarks[i]));

			if (rgBookmarkStatus != NULL)
				rgBookmarkStatus[i] = DBROWSTATUS_S_OK;
			bSuccess |= true;

		}

		if (bErrors)
			return (bSuccess != false) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED;
		else
			return S_OK;
	}

	// Data members
	CAtlArray<DBROWCOUNT> m_rgBookmarks;

	// Implementation
	protected:
	HRESULT ValidateBookmark(DBBKMARK cbBookmark, const BYTE* pBookmark)
	{
		T* pT = (T*)this;
		if (cbBookmark == 0 || pBookmark == NULL)
			return E_INVALIDARG;

		// All of our bookmarks are DBBKMARKs, if they are anything other than 
		// sizeof(DBBKMARK) then we have an invalid bookmark
		if ((cbBookmark != sizeof(DBBKMARK)) && (cbBookmark != 1))
		{
			ATLTRACE(atlTraceDBProvider, 2, _T("Bookmarks are invalid length, should be DBBKMARKs"));
			return DB_E_BADBOOKMARK;
		}

		// If our bookmark is a special (i.e. cbBookmark == 1), then it should
		// be one of the accepted values. 
		if ((cbBookmark == 1) && (*pBookmark != DBBMK_FIRST && *pBookmark != DBBMK_LAST))
		{
			ATLTRACE(atlTraceDBProvider, 2, _T("Bookmark is invalid"));
			return DB_E_BADBOOKMARK;
		}

		// If the contents of our bookmarks are less than 0 or greater than
		// rowcount, then they are invalid
		DBCOUNTITEM nRows = (ULONG_PTR)pT->m_rgBookmarks.GetCount();
		DBROWOFFSET lBookmarkIndex = (DBROWOFFSET)(*pBookmark);
		if (lBookmarkIndex <= -1 || lBookmarkIndex > (DBROWOFFSET)nRows )
		{
			ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetLocateImpl::Bookmark has invalid range"));
			return DB_E_BADBOOKMARK;
		}

		return S_OK;
	}
};

///////////////////////////////////////////////////////////////////////////
// IRowsetIdentityImpl 
template <class T, class RowClass = CSimpleRow>
class ATL_NO_VTABLE IRowsetIdentityImpl : public IRowsetIdentity
{
public:
	STDMETHOD(IsSameRow)(HROW hThisRow, HROW hThatRow)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetIdentityImpl::IsSameRow\n"));		
		T* pT = (T*)this;

		// Validate row handles
		RowClass* pRow1;
		if( ! pT->m_rgRowHandles.Lookup((RowClass::KeyType)hThisRow, pRow1) )
			return DB_E_BADROWHANDLE;

		RowClass* pRow2;
		if( ! pT->m_rgRowHandles.Lookup((RowClass::KeyType)hThatRow, pRow2) )
			return DB_E_BADROWHANDLE;

		if (pRow1->m_status == DBPENDINGSTATUS_DELETED ||
			pRow2->m_status == DBPENDINGSTATUS_DELETED)
			return DB_E_DELETEDROW;

		HRESULT hr = pRow1->Compare(pRow2);
__if_not_exists(T::InsertRow)
{
		return hr;
}

__if_exists(T::InsertRow)
{
		if (hr != S_OK)
			return hr;

		// Add one more test for providers who support IRowsetChange or Update.
		// It is possible for a series of inserts & deletes to occur to make
		// CSimpleRow appear as if it were equivalent (when it is not).  To
		// fix this, we've added an m_iOriginalRowset variable that never gets
		// changed.
		return (pRow1->m_iOriginalRowset == pRow2->m_iOriginalRowset) ? S_OK : S_FALSE;
}
	};
};

template <class T>
class ATL_NO_VTABLE IInternalConnectionImpl : public IInternalConnection
{
public:
	STDMETHOD(AddConnection)()
	{
		T* pT = (T*)this;
		T::_ThreadModel::Increment(&pT->m_cSessionsOpen);
		return S_OK;
	}
	STDMETHOD(ReleaseConnection)()
	{
		T* pT = (T*)this;
		T::_ThreadModel::Decrement(&pT->m_cSessionsOpen);
		return S_OK;
	}
};

template <class T>
class ATL_NO_VTABLE IInternalCommandConnectionImpl : public IInternalConnection
{
public:
	STDMETHOD(AddConnection)()
	{
		T* pT = (T*)this;
		T::_ThreadModel::Increment(&pT->m_cRowsetsOpen);
		return S_OK;
	}
	STDMETHOD(ReleaseConnection)()
	{
		T* pT = (T*)this;
		T::_ThreadModel::Decrement(&pT->m_cRowsetsOpen);
		return S_OK;
	}
};

template <class T>
class ATL_NO_VTABLE IObjectWithSiteSessionImpl : public IObjectWithSiteImpl< T > 
{
public:

	~IObjectWithSiteSessionImpl()
	{
		CComPtr<IInternalConnection> pConn;
		if (m_spUnkSite != NULL)
		{
			if (SUCCEEDED(m_spUnkSite->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn)))
				pConn->ReleaseConnection();
		}
	}
	STDMETHOD(SetSite)(IUnknown* pCreator)
	{
		HRESULT hr = S_OK;
		T* pT = (T*)this;
		pT->Lock();
		m_spUnkSite = pCreator;
		pT->Unlock();
		CComPtr<IInternalConnection> pConn;
		if (pCreator != NULL)
		{
			hr = pCreator->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn);
			if (SUCCEEDED(hr))
				hr = pConn->AddConnection();
		}
		return hr;
	}

	LONG m_cSessionsOpen;

};

template <class T>
class ATL_NO_VTABLE IRowsetCreatorImpl : public IObjectWithSiteImpl< T >
{
public:

	~IRowsetCreatorImpl()
	{
		CComPtr<IInternalConnection> pConn;
		if (m_spUnkSite != NULL)
		{
			if (SUCCEEDED(m_spUnkSite->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn)))
				pConn->ReleaseConnection();
		}
	}

	STDMETHOD(SetSite)(IUnknown* pCreator)
	{
		T* pT = (T*)this;
		HRESULT hr = S_OK;
		pT->Lock();
		m_spUnkSite = pCreator;
		pT->Unlock();
		CComVariant varPropScroll, varPropFetch, varPropRemove, varPropUpdate;
		HRESULT hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_CANSCROLLBACKWARDS, &varPropScroll);
		if (SUCCEEDED(hrProps))
			pT->m_bCanScrollBack = (varPropScroll.boolVal != ATL_VARIANT_FALSE);
		hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_CANFETCHBACKWARDS, &varPropFetch);
		if (SUCCEEDED(hrProps))
			pT->m_bCanFetchBack = (varPropFetch.boolVal != ATL_VARIANT_FALSE);
		hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_REMOVEDELETED, &varPropRemove);
		if (SUCCEEDED(hrProps))
			pT->m_bRemoveDeleted = (varPropRemove.boolVal != ATL_VARIANT_FALSE);
		hrProps = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_IRowsetUpdate, &varPropUpdate);
		if (SUCCEEDED(hrProps))
			pT->m_bIRowsetUpdate = (varPropUpdate.boolVal != ATL_VARIANT_FALSE);
		CComPtr<IInternalConnection> pConn;
		if (pCreator != NULL)
		{
			if (SUCCEEDED(pCreator->QueryInterface(__uuidof(IInternalConnection), (void**)&pConn)))
				hr = pConn->AddConnection();
		}
		return hr;
	}

	LONG m_cRowsetsOpen;

};

// IRowsetInfoImpl
template <class T, class PropClass = T>
class ATL_NO_VTABLE IRowsetInfoImpl : 
	public IRowsetInfo, 
	public CUtlProps<PropClass>
{
public:
	static UPROPSET* _GetPropSet(ULONG* pNumPropSets, ULONG* pcElemPerSupported, UPROPSET* pSet = NULL, GUID* pguidSet = NULL)
	{
		return PropClass::_GetPropSet(pNumPropSets, pcElemPerSupported, pSet, pguidSet);
	}
	STDMETHOD(GetProperties)(const ULONG cPropertyIDSets,
							 const DBPROPIDSET rgPropertyIDSets[],
							 ULONG *pcPropertySets,
							 DBPROPSET **prgPropertySets)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetInfoImpl::GetProperties\n"));
		T* pT = (T*)this;
		// Prevent Level 4 warning
		pT;

		// IRowsetInfo can't return PROPERTIESINERROR.  Therefore, disable
		// checking for it.  Instead, treat it as any normal property set.
		m_dwFlags |= ~ARGCHK_PROPERTIESINERROR;
		HRESULT hr = GetPropertiesArgChk(cPropertyIDSets, rgPropertyIDSets, 
			pcPropertySets, prgPropertySets);
		if(SUCCEEDED(hr))
		{
			// Scan property sets to allow user defined properies
			ULONG ulPropSets = 0;
			ULONG ulPropElems = 0;
			ULONG ulPropInits = 0;
			UPROPSET* pSetA = NULL;
			UPROPSET* pSetTemp = NULL;
			ULONG l=0;
			ULONG cSets = (ULONG)(ULONG_PTR)pT->_GetPropSet(NULL, &ulPropElems);

			CTempBuffer<UPROPSET> tmpBuffer;
			pSetA = tmpBuffer.Allocate(cSets);
			if (pSetA == NULL)
				return E_OUTOFMEMORY;  // We shouldn't get this but...
			pSetTemp = pT->_GetPropSet(&ulPropSets, &ulPropElems, pSetA);

			typedef const GUID* PCGUID;

			for(l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ulPropInits++;
			}

			CTempBuffer<PCGUID> tmpBuffer2;
			PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
			if (ppGuid == NULL)
				return E_OUTOFMEMORY;
			ulPropInits = 0;
			for (l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
			}

			return CUtlProps<PropClass>::GetProperties(cPropertyIDSets, 
					rgPropertyIDSets, pcPropertySets, prgPropertySets, 
					ulPropInits, ppGuid);
		}
		else
			return hr;
	}

	OUT_OF_LINE ATLCOLUMNINFO* InternalGetColumnInfo(DBORDINAL* pcCols)
	{
		return T::GetColumnInfo((T*)this, pcCols);
	}

	STDMETHOD(GetReferencedRowset)(DBORDINAL iOrdinal,
								   REFIID riid,
								   IUnknown **ppReferencedRowset)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetInfoImpl::GetReferencedRowset\n"));
		DBORDINAL cCols=0;

		// Check Arguments
		if( ppReferencedRowset == NULL )
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("IRowsetInfoImpl::GetReferencedRowset : Error NULL IUnk output Param\n"));
			return E_INVALIDARG;
		}
		*ppReferencedRowset = NULL;

		// Check to see if column in question is a bookmark
		ATLCOLUMNINFO* pColInfo = InternalGetColumnInfo(&cCols);
		DBORDINAL iColInfo;
		for (iColInfo = 0; 
			 iColInfo < cCols && iOrdinal != pColInfo[iColInfo].iOrdinal;
			 iColInfo++);
		if (iColInfo == cCols)
			return DB_E_BADORDINAL;
		ATLCOLUMNINFO* pColCur = &(pColInfo[iColInfo]);

		if ((pColCur->dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) == 0)
			return DB_E_NOTAREFERENCECOLUMN;

		// Query for requested interface
		return QueryInterface(riid, (void**)ppReferencedRowset);
	}

	STDMETHOD(GetSpecification)(REFIID riid,
								IUnknown **ppSpecification)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetInfoImpl::GetSpecification\n"));

		if (ppSpecification == NULL)
			return E_INVALIDARG;
		T* pT = (T*) this;
		T::ObjectLock cab(pT);
		ATLASSERT(pT->m_spUnkSite != NULL);
		return pT->m_spUnkSite->QueryInterface(riid, (void**)ppSpecification);
	}
};

/*
template <class Storage, class ContainedArray = CAtlArray<Storage> >
class CUpdateArray : public ContainedArray
{
public:

	void RemoveAll()
	{
		ContainedArray::RemoveAll();
		m_rgRowLink.RemoveAll();
	}

	BOOL Add(Storage& rStorage)
	{
		if (ContainedArray::Add(rStorage))
		{
			if (!m_rgRowLink.Add(GetCount() - 1))
			{
				RemoveAt(GetCount() - 1);
				return FALSE;
			}
			return TRUE;
		}
		return FALSE;
	}

	BOOL RemoveAt(int nIndex)
	{
		if (ContainedArray::RemoveAt(m_rgRowLink[nIndex]))
		{
			// Decrement any links following the current row
			for (long l=nIndex+1; l<m_rgRowLink.GetCount(); l++)
			{
				long* pElem = &(m_rgRowLink.m_aT[l]);
				ATLASSERT(pElem != NULL);
				(*pElem)--;
			}
			return m_rgRowLink.RemoveAt(nIndex);
		}
		return FALSE;
	}

	ContainedArray::_ArrayElementType& operator[] (int nIndex)
	{
		ATLASSERT(nIndex >= 0 && nIndex < GetCount());
		return ContainedArray::operator[](m_rgRowLink[nIndex]);
	}

	const ContainedArray::_ArrayElementType& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < GetCount());
		return ContainedArray::operator[](m_rgRowLink[nIndex]);
	}

	CSimpleValArray<long> m_rgRowLink;
};
*/

class CComSharedMutex
{
public:
	CComSharedMutex()
	{
		m_lInterlockedVariable = -1;
	};

	inline bool IncrementMutex() 
	{ 
		long lAvailable = ::InterlockedIncrement(&m_lInterlockedVariable);
		if (lAvailable > 0)
		{
			// Mutex is held, decrement and return false
			DecrementMutex();
			return false;
		}
		else
			return true;
	};
	inline void DecrementMutex() 
	{
		::InterlockedDecrement(&m_lInterlockedVariable);
	};

	long m_lInterlockedVariable;
};


template <class T, class ReentrantEventSync = CComSharedMutex>
class IRowsetNotifyCP : public IConnectionPointImpl<T, &__uuidof(IRowsetNotify), CComDynamicUnkArray>,
	public ReentrantEventSync
{
public:
	HRESULT Fire_OnFieldChange(IRowset * pRowset, HROW hRow, DBORDINAL cColumns, 
				DBORDINAL* rgColumns, DBREASON eReason, DBEVENTPHASE ePhase, 
				BOOL fCantDeny)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetNotifyCP::Fire_OnFieldChange\n"));

		IncrementMutex();	// Lock the event handler so other's can't call methods
		HRESULT ret = S_OK;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IRowsetNotify* pIRowsetNotify = reinterpret_cast<IRowsetNotify*>(sp.p);
			if (pIRowsetNotify != NULL)
				ret = pIRowsetNotify->OnFieldChange(pRowset, hRow, cColumns,
					rgColumns, eReason, ePhase, fCantDeny);
			switch(ePhase)
			{
			case DBEVENTPHASE_OKTODO:
				if (ret == S_FALSE  && fCantDeny == FALSE)
				{
					// if we get an S_FALSE back, a consumer has vetoed the
					// request.  In this case, we should send a FAILEDTODO
					// to ONLY those consumers already notified.
					for (int nFailedIndex = 0; nFailedIndex <= nConnectionIndex; nFailedIndex++)
					{
						pT->Lock();
						CComPtr<IUnknown> spFailed = m_vec.GetAt(nFailedIndex);
						pT->Unlock();
						IRowsetNotify* pIFailedNotify = reinterpret_cast<IRowsetNotify*>(spFailed.p);
						if (pIFailedNotify != NULL)
							pIFailedNotify->OnFieldChange(pRowset, hRow, cColumns, rgColumns, 
								eReason, DBEVENTPHASE_FAILEDTODO, FALSE);
					}
					// Terminate the loop as no further consumers should be
					// notified.
					DecrementMutex();
					return ret;
				}
				else
				{
					if (ret != S_OK)
						ret = S_OK;
				}
				break;
			case DBEVENTPHASE_ABOUTTODO:
			case DBEVENTPHASE_SYNCHAFTER:
				if (ret == S_FALSE && fCantDeny == FALSE)
				{
					Fire_OnFieldChange(pRowset, hRow, cColumns, rgColumns,
						eReason, DBEVENTPHASE_FAILEDTODO, FALSE);
					DecrementMutex();
					return ret;
				}
				else
				{
					if (ret != S_OK)
						ret = S_OK;
				}
				break;
			case DBEVENTPHASE_FAILEDTODO:
			case DBEVENTPHASE_DIDEVENT:
				break; // Nothing todo
			default:
				ATLTRACE(atlTraceDBProvider, 0, _T("IRowsetNotifyCP::Fire_OnFieldChange: Unknown Phase requested\n"));
				ATLASSERT(FALSE);
				DecrementMutex();
				return E_FAIL;
			};
		}	
		DecrementMutex();
		if( ret != S_OK && ret != S_FALSE )
			ret = S_OK;
		return ret;

	}
	HRESULT Fire_OnRowChange(IRowset * pRowset, DBCOUNTITEM cRows, const HROW rghRows[], 
		DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetNotifyCP::Fire_OnRowChange\n"));
		IncrementMutex();  // Lock the handler so other's can't call methods
		HRESULT ret = S_OK;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IRowsetNotify* pIRowsetNotify = reinterpret_cast<IRowsetNotify*>(sp.p);
			if (pIRowsetNotify != NULL)
			{
				ret = pIRowsetNotify->OnRowChange(pRowset, cRows, rghRows, eReason, ePhase, fCantDeny);
			}
			switch(ePhase)
			{
			case DBEVENTPHASE_OKTODO:
				if (ret == S_FALSE && fCantDeny == FALSE)
				{
					// if we get an S_FALSE back, a consumer has vetoed the
					// request.  In this case, we should send a FAILEDTODO
					// to ONLY those consumers already notified.
					for (int nFailedIndex = 0; nFailedIndex <= nConnectionIndex; nFailedIndex++)
					{
						pT->Lock();
						CComPtr<IUnknown> spFailed = m_vec.GetAt(nFailedIndex);
						pT->Unlock();
						IRowsetNotify* pIFailedNotify = reinterpret_cast<IRowsetNotify*>(spFailed.p);
						if (pIFailedNotify != NULL)
							pIFailedNotify->OnRowChange(pRowset, cRows, rghRows, eReason,
								DBEVENTPHASE_FAILEDTODO, FALSE);
					}
					// Terminate the loop as no further consumers should be
					// notified.
					DecrementMutex();
					return ret;
				}
				break;
			case DBEVENTPHASE_SYNCHAFTER:
			case DBEVENTPHASE_ABOUTTODO:
				if (ret	== S_FALSE && fCantDeny == FALSE)
				{
					Fire_OnRowChange(pRowset, cRows, rghRows, eReason,
						DBEVENTPHASE_FAILEDTODO, FALSE);
					DecrementMutex();
					return ret;
				}
				break;
			case DBEVENTPHASE_FAILEDTODO:
			case DBEVENTPHASE_DIDEVENT:
				break; // Nothing todo
			default:
				ATLTRACE(atlTraceDBProvider, 0, _T("IRowsetNotifyCP::Fire_OnRowChange: Unknown Phase requested\n"));
				ATLASSERT(FALSE);
				DecrementMutex();
				return E_FAIL;
			};
		}	
		DecrementMutex();
		if( ret != S_OK && ret != S_FALSE )
			ret = S_OK;
		return ret;

	}
	HRESULT Fire_OnRowsetChange(IRowset* pRowset, DBREASON eReason, 
		DBEVENTPHASE ePhase, BOOL fCantDeny)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetNotifyCP::Fire_OnRowsetChange\n"));
		IncrementMutex(); // Lock the handler so others can't call methods
		HRESULT ret = S_OK;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IRowsetNotify* pIRowsetNotify = reinterpret_cast<IRowsetNotify*>(sp.p);
			if (pIRowsetNotify != NULL)
				ret = pIRowsetNotify->OnRowsetChange(pRowset, eReason, ePhase, fCantDeny);
			switch(ePhase)
			{
			case DBEVENTPHASE_OKTODO:
				if (ret == S_FALSE && fCantDeny == FALSE)
				{
					// if we get an S_FALSE back, a consumer has vetoed the
					// request.  In this case, we should send a FAILEDTODO
					// to ONLY those consumers already notified.
					for (int nFailedIndex = 0; nFailedIndex <= nConnectionIndex; nFailedIndex++)
					{
						pT->Lock();
						CComPtr<IUnknown> spFailed = m_vec.GetAt(nFailedIndex);
						pT->Unlock();
						IRowsetNotify* pIFailedNotify = reinterpret_cast<IRowsetNotify*>(spFailed.p);
						if (pIFailedNotify != NULL)
							pIFailedNotify->OnRowsetChange(pRowset, eReason, 
								DBEVENTPHASE_FAILEDTODO, FALSE);
					}
					// Terminate the loop as no further consumers should be
					// notified. 
					DecrementMutex();
					return ret;
				}
				break;
			case DBEVENTPHASE_ABOUTTODO:
			case DBEVENTPHASE_SYNCHAFTER:
				if (ret == S_FALSE && fCantDeny == FALSE)
				{
					Fire_OnRowsetChange(pRowset, eReason, DBEVENTPHASE_FAILEDTODO, 
						FALSE);
					DecrementMutex();
					return ret;
				}
				break;
			case DBEVENTPHASE_FAILEDTODO:
			case DBEVENTPHASE_DIDEVENT:
				break; // Nothing todo
			default:
				ATLTRACE(atlTraceDBProvider, 0, _T("IRowsetNotifyCP::Fire_OnRowChange: Unknown Phase requested\n"));
				ATLASSERT(FALSE);
				DecrementMutex();
				return E_FAIL;
			};
		}
		DecrementMutex();
		if( ret != S_OK && ret != S_FALSE )
			ret = S_OK;
		return ret;

	}
};


template <class T, class Storage, 
		  class ArrayType = CAtlArray<Storage>, 
		  class RowsetInterface = IRowsetImpl < T, IRowset >,
		  class RowClass = CSimpleRow >
class CRowsetBaseImpl :
	public IAccessorImpl<T>,
	public IRowsetIdentityImpl<T, RowClass>,
	public IRowsetCreatorImpl<T>,
	public IColumnsInfoImpl<T>,
	public IConvertTypeImpl<T>,
	public RowsetInterface
{
public:
	HRESULT NameFromDBID(DBID* pDBID, CComBSTR& bstr, bool bIndex)
	{

		if (pDBID->uName.pwszName != NULL)
		{
			bstr = pDBID->uName.pwszName;
			if (bstr == (BSTR)NULL)
				return E_OUTOFMEMORY;
			return S_OK;
		}

		return (bIndex) ? DB_E_NOINDEX : DB_E_NOTABLE;
	}

	HRESULT GetCommandFromID(DBID* pTableID, DBID* pIndexID)
	{
		HRESULT hr;

		if (pTableID == NULL && pIndexID == NULL)
			return E_INVALIDARG;

		if (pTableID != NULL && pTableID->eKind == DBKIND_NAME)
		{
			hr = NameFromDBID(pTableID, m_strCommandText, true);
			if (FAILED(hr))
				return hr;
			if (pIndexID != NULL)
			{
				if (pIndexID->eKind == DBKIND_NAME)
				{
					hr = NameFromDBID(pIndexID, m_strIndexText, false);
					if (FAILED(hr))
					{
						m_strCommandText.Empty();
						return hr;
					}
				}
				else
				{
					m_strCommandText.Empty();
					return DB_E_NOINDEX;
				}
			}
			return S_OK;
		}
		if (pIndexID != NULL && pIndexID->eKind == DBKIND_NAME)
			return NameFromDBID(pIndexID, m_strIndexText, false);

		return S_OK;
	}

	HRESULT ValidateCommandID(DBID* pTableID, DBID* pIndexID)
	{
		HRESULT hr = S_OK;

		if (pTableID != NULL)
		{
			hr = CUtlProps<T>::IsValidDBID(pTableID);

			if (hr != S_OK)
				return hr;

			// Check for a NULL TABLE ID (where its a valid pointer but NULL)
			if ((pTableID->eKind == DBKIND_GUID_NAME || 
				pTableID->eKind == DBKIND_NAME ||
				pTableID->eKind == DBKIND_PGUID_NAME)
				&& pTableID->uName.pwszName == NULL)
				return DB_E_NOTABLE;
		}

		if (pIndexID != NULL)
			hr = CUtlProps<T>::IsValidDBID(pIndexID);

		return hr;
	}

	HRESULT SetCommandText(DBID* pTableID, DBID* pIndexID)
	{
		T* pT = (T*)this;
		HRESULT hr = pT->ValidateCommandID(pTableID, pIndexID);
		if (FAILED(hr))
			return hr;
		hr = pT->GetCommandFromID(pTableID, pIndexID);
		return hr;
	}

	static ATLCOLUMNINFO* GetColumnInfo(T* pv, DBORDINAL* pcCols)
	{
		return Storage::GetColumnInfo(pv,pcCols);
	}

	CComBSTR m_strCommandText;
	CComBSTR m_strIndexText;

	ArrayType m_rgRowData;
};


template <class T, class Storage, class CreatorClass, 
		  class ArrayType = CAtlArray<Storage>, 
  		  class RowClass = CSimpleRow,
		  class RowsetInterface = IRowsetImpl < T, IRowset > >
class CRowsetImpl : 
	public CComObjectRootEx<typename CreatorClass::_ThreadModel>,
	public CRowsetBaseImpl<T, Storage, ArrayType, RowsetInterface, RowClass>,
	public IRowsetInfoImpl<T, typename CreatorClass::_PropClass>
{
public:
	typedef CRowsetImpl< T, Storage, CreatorClass, ArrayType, RowClass, RowsetInterface> _RowsetBaseClass;
	typedef ArrayType _RowsetArrayType;
	typedef Storage _StorageClass;
	typedef CreatorClass _RowsetCreatorClass;

BEGIN_COM_MAP(CRowsetImpl)
	COM_INTERFACE_ENTRY(IRowsetInfo)
	COM_INTERFACE_ENTRY(IAccessor)
	COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IColumnsInfo)
	COM_INTERFACE_ENTRY(IConvertType)
	COM_INTERFACE_ENTRY(IRowsetIdentity)
	COM_INTERFACE_ENTRY(IRowset)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		HRESULT hr = IAccessorImpl<T>::FinalConstruct();
		if (FAILED(hr))
			return hr;
		return CConvertHelper::FinalConstruct();
	}

	void FinalRelease()
	{
		m_rgRowData.RemoveAll();
		IAccessorImpl<T>::FinalRelease();
		__if_exists(T::Fire_OnRowsetChange)
		{
			T* pT = (T*)this;
			pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_RELEASE, DBEVENTPHASE_DIDEVENT, TRUE);
		}
	}
};


template <class T, class Storage, class CreatorClass, 
		  class ArrayType = CAtlArray<Storage>, 
  		  class RowClass = CSimpleRow,
		  class RowsetInterface = IRowsetImpl < T, IRowset > >
class CSchemaRowsetImpl : 
	public CComObjectRootEx<typename CreatorClass::_ThreadModel>,
	public CRowsetBaseImpl<T, Storage, ArrayType, RowsetInterface, RowClass>,
	public IRowsetInfoImpl<T>
{
public:
	typedef CSchemaRowsetImpl< T, Storage, CreatorClass, ArrayType, RowClass, RowsetInterface> _RowsetBaseClass;
	typedef ArrayType _RowsetArrayType;
	typedef Storage _StorageClass;
	typedef CreatorClass _RowsetCreatorClass;

BEGIN_COM_MAP(CSchemaRowsetImpl)
	COM_INTERFACE_ENTRY(IRowsetInfo)
	COM_INTERFACE_ENTRY(IAccessor)
	COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IColumnsInfo)
	COM_INTERFACE_ENTRY(IConvertType)
	COM_INTERFACE_ENTRY(IRowsetIdentity)
	COM_INTERFACE_ENTRY(IRowset)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		HRESULT hr = IAccessorImpl<T>::FinalConstruct();
		if (FAILED(hr))
			return hr;
		return CConvertHelper::FinalConstruct();
	}

	void FinalRelease()
	{
		m_rgRowData.RemoveAll();
		__if_exists(T::Fire_OnRowsetChange)
		{
			T* pT = (T*)this;
			pT->Fire_OnRowsetChange(pT, DBREASON_ROWSET_RELEASE, DBEVENTPHASE_DIDEVENT, TRUE);
		}
	}
};


template <const GUID* pguidProvider>
class CErrorReporterHelper
{
public:

	HRESULT PostError(HRESULT hrErr, IID* piid)
	{
		HRESULT	hr = S_OK;
		if (piid == NULL)
			return E_INVALIDARG;

		CComPtr<ICreateErrorInfo>	spCrtErrInfo;
		CComPtr<IErrorInfo>			spIErrorInfo;
		CComPtr<IErrorRecords>		spIErrorRecords;

		hr = CreateErrorInfo(&spCrtErrInfo);
		if (SUCCEEDED(hr))
		{
			ERRORINFO		errorinfo;
			memset(&errorinfo, 0, sizeof(ERRORINFO));
			errorinfo.clsid		= *pguidProvider;
			errorinfo.dispid	= NULL;
			errorinfo.dwMinor	= 0;
			errorinfo.hrError	= hrErr;
			errorinfo.iid		= *piid;

			spCrtErrInfo->SetGUID(errorinfo.iid)
			spCrtErrInfo->SetSource(OLESTR("Provider PROGID"));
			spCrtErrInfo->SetDescription(OLESTR("Error Description"));
			spCrtErrInfo->SetHelpFile(OLESTR("provider.hlp"));
			spCrtErrInfo->SetHelpContext(1);

			//Obtain the error object or create a new one if none exists
			GetErrorInfo(0, &spIErrorInfo);
			if( spIErrorInfo == NULL )
			{
				hr = spIErrorInfo->CoCreateInstance(CLSID_EXTENDEDERRORINFO);
				if( FAILED(hr))
					return hr;
			}

			// Obtain the IErrorRecord Interface
			hr = spIErrorInfo->QueryInterface(__uuidof(IErrorRecords), &spIErrorRecords));
			if( SUCCEEDED(hr))
			{
				hr = spIErrorRecords->AddErrorRecord(&errorinfo, 0, NULL, &spICrtErrInfo, 0);
				if( FAILED(hr))
					return hr;
			}
		}

		if( spIErrorInfo != NULL)
			SetErrorInfo(0, &spIErrorInfo);

		return hr;
	}


};

struct ATLERRORINFO
{
	ERRORINFO*		  pInfo;
	DISPPARAMS		  dispparams;
	CComPtr<IUnknown> spCustError;
	DWORD			  dwLookupID;

};

template <class T, class RecordClass = ATLERRORINFO>
class IErrorRecordsImpl : public IErrorRecords
{
public:
	STDMETHOD(AddErrorRecord)( ERRORINFO *pErrorInfo, DWORD dwLookupID, DISPPARAMS *pdispparams, IUnknown *punkCustomError, DWORD)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::AddErrorRecord\n"));
		if (pErrorInfo == NULL)
			return E_INVALIDARG;
		ATLERRORINFO err;

		err.pInfo = pErrorInfo;
		err.dispparams = *pdispparams;
		err.spCustError = punkCustomError;
		err.dwLookupID = dwLookupID;

		//if (!m_rgErrors.Add(err)) 
		//	return E_OUTOFMEMORY;
		_ATLTRY
		{
			m_rgErrors.Add(err);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e );
			return E_OUTOFMEMORY;
		}

		return S_OK;
	}

	STDMETHOD(GetBasicErrorInfo)( ULONG ulRecordNum, ERRORINFO *pErrorInfo)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::GetBasicErrorInfo\n"));
		if (pErrorInfo == NULL)
			return E_INVALIDARG;
		if ((LONG)ulRecordNum >= m_rgErrors.GetCount())
			return DB_E_BADRECORDNUM;

		*pErrorInfo = *(m_rgErrors[ulRecordNum].pInfo);
		return S_OK;
	}

	STDMETHOD(GetCustomErrorObject)( ULONG ulRecordNum, REFIID riid, IUnknown **ppObject)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::GetCustomErrorObject\n"));
		if (ppObject == NULL)
			return E_INVALIDARG;
		if ((LONG)ulRecordNum >= m_rgErrors.GetCount())
			return DB_E_BADRECORDNUM;

		CComPtr<IUnknown> spUnkCust;
		spUnkCust = m_rgErrors[ulRecordNum].spCustError;
		return spUnkCust->QueryInterface(riid, (void**)ppObject);

	}

	STDMETHOD(GetErrorInfo)( ULONG ulRecordNum, LCID, IErrorInfo **ppErrorInfo)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::GetErrorInfo\n"));

		if (ppErrorInfo == NULL)
			return E_INVALIDARG;
		if ((LONG)ulRecordNum >= m_rgErrors.GetCount())
			return DB_E_BADRECORDNUM;


		CComPtr<ICreateErrorInfo> spErrorInfo;

		if (FAILED(CreateErrorInfo(&spErrorInfo)))
			return E_OUTOFMEMORY;

		ERRORINFO& rInfo = *(m_rgErrors[ulRecordNum].pInfo);
		T* pT = (T*)this;
		spErrorInfo->SetDescription(pT->GetErrorDescriptionString(rInfo));
		spErrorInfo->SetGUID(pT->GetErrorGUID(rInfo)); 
		spErrorInfo->SetHelpContext(pT->GetErrorHelpContext(rInfo));
		spErrorInfo->SetHelpFile(pT->GetErrorHelpFile(rInfo));
		spErrorInfo->SetSource(pT->GetErrorSource(rInfo));
		return spErrorInfo->QueryInterface(__uuidof(IErrorInfo), (void**)ppErrorInfo);

	}

	STDMETHOD(GetErrorParameters)( ULONG ulRecordNum, DISPPARAMS *pdispparams)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::AddErrorRecord\n"));
		if (pdispparams == NULL)
			return E_INVALIDARG;
		if ((LONG)ulRecordNum >= m_rgErrors.GetCount())
			return DB_E_BADRECORDNUM;

		*pdispparams = m_rgErrors[ulRecordNum].dispparams;
		return S_OK;
	}

	STDMETHOD(GetRecordCount)(ULONG *pcRecords)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IErrorRecordsImpl::GetErrorParameters\n"));
		if (pcRecords == NULL)
			return E_INVALIDARG;
		*pcRecords = m_rgErrors.GetCount();
		return S_OK;
	}

	LPOLESTR GetErrorDescriptionString(ERRORINFO&)
	{
		return OLESTR("The Error Description String");
	}

	REFGUID GetErrorGUID(ERRORINFO&)
	{
		return GUID_NULL;
	}

	DWORD GetErrorHelpContext(ERRORINFO&)
	{
		return 0;
	}

	LPOLESTR GetErrorHelpFile(ERRORINFO&)
	{
		return OLESTR("The Error Help File");
	}

	LPOLESTR GetErrorSource(ERRORINFO&)
	{
		return OLESTR("The ErrorInfo");
	}

	CAtlArray<RecordClass> m_rgErrors;
};



class CTABLESRow
{
public:

	WCHAR m_szCatalog[129];
	WCHAR m_szSchema[129];
	WCHAR m_szTable[129];
	WCHAR m_szType[129];
	WCHAR m_szDesc[129];
	GUID  m_guid;
	ULONG m_ulPropID;
	DATE m_DateCreated;
	DATE m_DateModified;

	CTABLESRow()
	{
		Checked::wcscpy_s(m_szCatalog, _countof(m_szCatalog), L"");
		Checked::wcscpy_s(m_szSchema, _countof(m_szSchema), L"");
		Checked::wcscpy_s(m_szTable, _countof(m_szTable), L"");
		Checked::wcscpy_s(m_szType, _countof(m_szType), L"");
		Checked::wcscpy_s(m_szDesc, _countof(m_szDesc), L"");
		m_guid = GUID_NULL;
		m_ulPropID = 0;
		m_DateCreated = 0.0;
		m_DateModified = 0.0;
	}

BEGIN_PROVIDER_COLUMN_MAP(CTABLESRow)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_CATALOG", 1, m_szCatalog)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_SCHEMA", 2, m_szSchema)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_NAME", 3, m_szTable)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_TYPE", 4, m_szType)
	PROVIDER_COLUMN_ENTRY_PS("TABLE_GUID", 5, 0xFF, 0xFF, m_guid)
	PROVIDER_COLUMN_ENTRY_WSTR("DESCRIPTION", 6, m_szDesc)
	PROVIDER_COLUMN_ENTRY_PS("TABLE_PROPID", 7, 10, 0xFF, m_ulPropID)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("DATE_CREATED", 8, DBTYPE_DATE, 0xFF, 0xFF, m_DateCreated)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("DATE_MODIFIED", 9, DBTYPE_DATE, 0xFF, 0xFF, m_DateModified)
END_PROVIDER_COLUMN_MAP()

};


class CCOLUMNSRow
{
public:

	WCHAR			m_szTableCatalog[129];
	WCHAR			m_szTableSchema[129];
	WCHAR			m_szTableName[129];
	WCHAR			m_szColumnName[129];
	GUID			m_guidColumn;
	ULONG			m_ulColumnPropID;
	ULONG			m_ulOrdinalPosition;
	VARIANT_BOOL	m_bColumnHasDefault;
	WCHAR			m_szColumnDefault[129];
	ULONG			m_ulColumnFlags;
	VARIANT_BOOL	m_bIsNullable;
	USHORT			m_nDataType;
	GUID			m_guidType;
	ULONG			m_ulCharMaxLength;
	ULONG			m_ulCharOctetLength;
	USHORT			m_nNumericPrecision;
	short			m_nNumericScale;
	ULONG			m_ulDateTimePrecision;
	WCHAR			m_szCharSetCatalog[129];
	WCHAR			m_szCharSetSchema[129];
	WCHAR			m_szCharSetName[129];
	WCHAR			m_szCollationCatalog[129];
	WCHAR			m_szCollationSchema[129];
	WCHAR			m_szCollationName[129];
	WCHAR			m_szDomainCatalog[129];
	WCHAR			m_szDomainSchema[129];
	WCHAR			m_szDomainName[129];
	WCHAR			m_szDescription[129];

	CCOLUMNSRow()
	{
		ClearMembers();
	}

	void ClearMembers()
	{
		m_szTableCatalog[0] = NULL;
		m_szTableSchema[0] = NULL;
		m_szTableName[0] = NULL;
		m_szColumnName[0] = NULL;
		m_guidColumn = GUID_NULL;
		m_ulColumnPropID = 0;
		m_ulOrdinalPosition = 0;
		m_bColumnHasDefault = ATL_VARIANT_FALSE;
		m_szColumnDefault[0] = NULL;
		m_ulColumnFlags = 0;
		m_bIsNullable = ATL_VARIANT_FALSE;
		m_nDataType = 0;
		m_guidType = GUID_NULL;
		m_ulCharMaxLength = 0;
		m_ulCharOctetLength = 0;
		m_nNumericPrecision = 0;
		m_nNumericScale = 0;
		m_ulDateTimePrecision = 0;
		m_szCharSetCatalog[0] = NULL;
		m_szCharSetSchema[0] = NULL;
		m_szCharSetName[0] = NULL;
		m_szCollationCatalog[0] = NULL;
		m_szCollationSchema[0] = NULL;
		m_szCollationName[0] = NULL;
		m_szDomainCatalog[0] = NULL;
		m_szDomainSchema[0] = NULL;
		m_szDomainName[0] = NULL;
		m_szDescription[0] = NULL;
	}


BEGIN_PROVIDER_COLUMN_MAP(CCOLUMNSRow)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_CATALOG", 1, m_szTableCatalog)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_SCHEMA", 2, m_szTableSchema)
	PROVIDER_COLUMN_ENTRY_WSTR("TABLE_NAME", 3, m_szTableName)
	PROVIDER_COLUMN_ENTRY_WSTR("COLUMN_NAME", 4, m_szColumnName)
	PROVIDER_COLUMN_ENTRY_PS("COLUMN_GUID", 5, 0xFF, 0xFF, m_guidColumn)
	PROVIDER_COLUMN_ENTRY_PS("COLUMN_PROPID",6, 10, 0xFF, m_ulColumnPropID)
	PROVIDER_COLUMN_ENTRY_PS("ORDINAL_POSITION",7, 10, 0xFF, m_ulOrdinalPosition)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("COLUMN_HASDEFAULT",8, DBTYPE_BOOL, 0xFF, 0xFF, m_bColumnHasDefault)
	PROVIDER_COLUMN_ENTRY_PS("COLUMN_DEFAULT",9, 0xFF, 0xFF, m_szColumnDefault)
	PROVIDER_COLUMN_ENTRY_PS("COLUMN_FLAGS",10, 10, 0xFF, m_ulColumnFlags)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("IS_NULLABLE",11, DBTYPE_BOOL, 0xFF, 0xFF, m_bIsNullable)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("DATA_TYPE",12, DBTYPE_UI2, 5, 0xFF, m_nDataType)
	PROVIDER_COLUMN_ENTRY_PS("TYPE_GUID",13, 0xFF, 0xFF, m_guidType)
	PROVIDER_COLUMN_ENTRY_PS("CHARACTER_MAXIMUM_LENGTH",14, 10, 0xFF, m_ulCharMaxLength)
	PROVIDER_COLUMN_ENTRY_PS("CHARACTER_OCTET_LENGTH",15, 10, 0xFF, m_ulCharOctetLength)
	PROVIDER_COLUMN_ENTRY_PS("NUMERIC_PRECISION",16, 5, 0xFF, m_nNumericPrecision)
	PROVIDER_COLUMN_ENTRY_PS("NUMERIC_SCALE",17, 5, 0xFF, m_nNumericScale)
	PROVIDER_COLUMN_ENTRY_PS("DATETIME_PRECISION",18, 10, 0xFF, m_ulDateTimePrecision)
	PROVIDER_COLUMN_ENTRY_WSTR("CHARACTER_SET_CATALOG", 19, m_szCharSetCatalog)
	PROVIDER_COLUMN_ENTRY_WSTR("CHARACTER_SET_SCHEMA", 20, m_szCharSetSchema)
	PROVIDER_COLUMN_ENTRY_WSTR("CHARACTER_SET_NAME", 21, m_szCharSetName)
	PROVIDER_COLUMN_ENTRY_WSTR("COLLATION_CATALOG", 22, m_szCollationCatalog)
	PROVIDER_COLUMN_ENTRY_WSTR("COLLATION_SCHEMA", 23, m_szCollationSchema)
	PROVIDER_COLUMN_ENTRY_WSTR("COLLATION_NAME", 24, m_szCollationName)
	PROVIDER_COLUMN_ENTRY_WSTR("DOMAIN_CATALOG", 25, m_szDomainCatalog)
	PROVIDER_COLUMN_ENTRY_WSTR("DOMAIN_SCHEMA", 26, m_szDomainSchema)
	PROVIDER_COLUMN_ENTRY_WSTR("DOMAIN_NAME", 27, m_szDomainName)
	PROVIDER_COLUMN_ENTRY_WSTR("DESCRIPTION", 28, m_szDescription)
END_PROVIDER_COLUMN_MAP()
};

template <class ArrayClass>
HRESULT InitFromRowset(ArrayClass& rgData, DBID* pTableID, DBID* pIndexID, IUnknown* pSession, LONG* pcRowsAffected)
{
	CComQIPtr<IOpenRowset> spOpenRowset = pSession;
	if (spOpenRowset == NULL)
		return E_FAIL;
	CComPtr<IColumnsInfo> spColInfo;
	HRESULT hr = spOpenRowset->OpenRowset(NULL, pTableID, pIndexID, __uuidof(IColumnsInfo), 0, NULL, (IUnknown**)&spColInfo);
	if (FAILED(hr))
		return hr;
	LPOLESTR szColumns = NULL;
	ULONG cColumns = 0;
	DBCOLUMNINFO* pColInfo = NULL;
	hr = spColInfo->GetColumnInfo(&cColumns, &pColInfo, &szColumns);
	if (FAILED(hr))
		return hr;
	*pcRowsAffected = 0;
	for (ULONG iCol = 0; iCol < cColumns;  iCol++)
	{
		CCOLUMNSRow crData;
		DBCOLUMNINFO& rColCur = pColInfo[iCol];
		Checked::wcsncpy_s(crData.m_szTableName, _countof(crData.m_szTableName), pTableID->uName.pwszName, _TRUNCATE);
		Checked::wcsncpy_s(crData.m_szColumnName, _countof(crData.m_szColumnName), rColCur.pwszName, _TRUNCATE);
		Checked::wcsncpy_s(crData.m_szDescription, _countof(crData.m_szDescription), rColCur.pwszName, _TRUNCATE);
		GUID* pGuidCol = CDBIDOps::GetDBIDpGuid(rColCur.columnid);
		if (pGuidCol)
			crData.m_guidColumn = *pGuidCol;
		else
			crData.m_guidColumn = GUID_NULL;
		crData.m_ulColumnPropID = CDBIDOps::GetPropIDFromDBID(rColCur.columnid);
		crData.m_ulOrdinalPosition = rColCur.iOrdinal;
		crData.m_ulColumnFlags = rColCur.dwFlags;					
		crData.m_bIsNullable = (rColCur.dwFlags & DBCOLUMNFLAGS_ISNULLABLE) ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		crData.m_nDataType = rColCur.wType;
		crData.m_ulCharMaxLength = rColCur.ulColumnSize;
		crData.m_nNumericPrecision = rColCur.bPrecision;
		crData.m_nNumericScale = rColCur.bScale;
		//if (!rgData.Add(crData))
		//{
		//	CoTaskMemFree(pColInfo);
		//	CoTaskMemFree(szColumns);
		//	return E_OUTOFMEMORY;
		//}
		_ATLTRY
		{
			rgData.Add(crData);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e );
			CoTaskMemFree(pColInfo);
			CoTaskMemFree(szColumns);
			return E_OUTOFMEMORY;
		}

		(*pcRowsAffected)++;
	}

	CoTaskMemFree(pColInfo);
	CoTaskMemFree(szColumns);
	return S_OK;
}

class CPROVIDER_TYPERow
{
public:
// Attributes
	WCHAR			m_szName[129];
	USHORT			m_nType;
	ULONG			m_ulSize;
	WCHAR			m_szPrefix[129];
	WCHAR			m_szSuffix[129];
	WCHAR			m_szCreateParams[129];
	VARIANT_BOOL	m_bIsNullable;
	VARIANT_BOOL	m_bCaseSensitive;
	ULONG			m_ulSearchable;
	VARIANT_BOOL	m_bUnsignedAttribute;
	VARIANT_BOOL	m_bFixedPrecScale;
	VARIANT_BOOL	m_bAutoUniqueValue;
	WCHAR			m_szLocalTypeName[129];
	short			m_nMinScale;
	short			m_nMaxScale;
	GUID			m_guidType;
	WCHAR			m_szTypeLib[129];
	WCHAR			m_szVersion[129];
	VARIANT_BOOL	m_bIsLong;
	VARIANT_BOOL	m_bBestMatch;
	VARIANT_BOOL	m_bIsFixedLength;


	CPROVIDER_TYPERow()
	{
		m_szName[0] = NULL;
		m_nType = 0;
		m_ulSize = 0;
		m_szPrefix[0] = NULL;
		m_szSuffix[0] = NULL;
		m_szCreateParams[0] = NULL;
		m_bIsNullable = ATL_VARIANT_FALSE;
		m_bCaseSensitive = ATL_VARIANT_FALSE;
		m_ulSearchable = DB_UNSEARCHABLE;
		m_bUnsignedAttribute = ATL_VARIANT_FALSE;
		m_bFixedPrecScale = ATL_VARIANT_FALSE;
		m_bAutoUniqueValue = ATL_VARIANT_FALSE;
		m_szLocalTypeName[0] = NULL;
		m_nMinScale = 0;
		m_nMaxScale = 0;
		m_guidType = GUID_NULL;
		m_szTypeLib[0] = NULL;
		m_szVersion[0] = NULL;
		m_bIsLong = ATL_VARIANT_FALSE;
		m_bBestMatch = ATL_VARIANT_FALSE;
		m_bIsFixedLength = ATL_VARIANT_FALSE;
	}
// Binding Maps
BEGIN_PROVIDER_COLUMN_MAP(CPROVIDER_TYPERow)
	PROVIDER_COLUMN_ENTRY_WSTR("TYPE_NAME", 1, m_szName)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("DATA_TYPE", 2, DBTYPE_UI2, 5, 0xFF, m_nType)
	PROVIDER_COLUMN_ENTRY_PS("COLUMN_SIZE", 3, 10, 0xFF, m_ulSize)
	PROVIDER_COLUMN_ENTRY_WSTR("LITERAL_PREFIX", 4, m_szPrefix)
	PROVIDER_COLUMN_ENTRY_WSTR("LITERAL_SUFFIX", 5, m_szSuffix)
	PROVIDER_COLUMN_ENTRY_WSTR("CREATE_PARAMS", 6, m_szCreateParams)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("IS_NULLABLE", 7, DBTYPE_BOOL, 0xFF, 0xFF, m_bIsNullable)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("CASE_SENSITIVE", 8, DBTYPE_BOOL, 0xFF, 0xFF, m_bCaseSensitive)
	PROVIDER_COLUMN_ENTRY_PS("SEARCHABLE", 9, 10, 0xFF, m_ulSearchable)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("UNSIGNED_ATTRIBUTE", 10, DBTYPE_BOOL, 0xFF, 0xFF, m_bUnsignedAttribute)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("FIXED_PREC_SCALE", 11, DBTYPE_BOOL, 0xFF, 0xFF, m_bFixedPrecScale)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("AUTO_UNIQUE_VALUE", 12, DBTYPE_BOOL, 0xFF, 0xFF, m_bAutoUniqueValue)
	PROVIDER_COLUMN_ENTRY_WSTR("LOCAL_TYPE_NAME", 13, m_szLocalTypeName)
	PROVIDER_COLUMN_ENTRY_PS("MINIMUM_SCALE", 14, 5, 0xFF, m_nMinScale)
	PROVIDER_COLUMN_ENTRY_PS("MAXIMUM_SCALE", 15, 5, 0xFF, m_nMaxScale)
	PROVIDER_COLUMN_ENTRY_PS("GUID", 16, 0xFF, 0xFF, m_guidType)
	PROVIDER_COLUMN_ENTRY_WSTR("TYPELIB", 17, m_szTypeLib)
	PROVIDER_COLUMN_ENTRY_WSTR("VERSION", 18, m_szVersion)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("IS_LONG", 19, DBTYPE_BOOL, 0xFF, 0xFF, m_bIsLong)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("BEST_MATCH", 20, DBTYPE_BOOL, 0xFF, 0xFF, m_bBestMatch)
	PROVIDER_COLUMN_ENTRY_TYPE_PS("IS_FIXEDLENGTH", 21, DBTYPE_BOOL, 0xFF, 0xFF, m_bIsFixedLength)
END_PROVIDER_COLUMN_MAP()
};


class CEnumRowsetImpl
{
public:

	WCHAR m_szSourcesName[256];
	WCHAR m_szSourcesParseName[256];
	WCHAR m_szSourcesDescription[256];
	unsigned short m_iType;
	VARIANT_BOOL m_bIsParent;

BEGIN_PROVIDER_COLUMN_MAP(CEnumRowsetImpl)
	PROVIDER_COLUMN_ENTRY("SOURCES_NAME", 1, m_szSourcesName)
	PROVIDER_COLUMN_ENTRY("SOURCES_PARSENAME", 2, m_szSourcesParseName)
	PROVIDER_COLUMN_ENTRY("SOURCES_DESCRIPTION", 3, m_szSourcesDescription)
	PROVIDER_COLUMN_ENTRY("SOURCES_TYPE", 4, m_iType)
	PROVIDER_COLUMN_ENTRY("SOURCES_ISPARENT", 5, m_bIsParent)
END_PROVIDER_COLUMN_MAP()

};


///////////////////////////////////////////////////////////////////////////
// class IRowsetUpdateImpl

template <class T, class Storage, 
			class UpdateArray = CAtlArray<Storage>, 
			class RowClass = CSimpleRow, 
			class MapClass = CAtlMap < RowClass::KeyType, RowClass* > >
class IRowsetUpdateImpl : public IRowsetChangeImpl<T, Storage, IRowsetUpdate, RowClass, MapClass>
{
public:
	// Destructor
	~IRowsetUpdateImpl()
	{
		m_mapCachedData.RemoveAll();
	}

	// IRowsetChange Methods
	STDMETHOD (SetData)(HROW hRow, HACCESSOR hAccessor, void* pSrcData)
	{
		T* pT = (T*)this;

		__if_exists(T::Fire_OnFieldChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		// We provide this implementation for use as it adds more 
		// complexity to the SetData function to handle both 
		// immediate and deferred processing.  It also allows us to 
		// cache the original data w/o increasing the size of 
		// IRowsetChangeImpl
		RowClass* pRow;
		HRESULT hr; 

		// Determine if we are in immediate or deferred mode, if we are in
		// immediate mode call FlushData.  Otherwise, add the orginal data
		// to the cache
		CComVariant varDeferred;
		bool bDeferred;
		hr = pT->GetPropValue(&DBPROPSET_ROWSET, DBPROP_IRowsetUpdate, 
							&varDeferred);
		(FAILED(hr) || varDeferred.boolVal == ATL_VARIANT_FALSE) ? bDeferred = false : bDeferred = true;

		if( ! pT->m_rgRowHandles.Lookup(hRow, pRow) )
			return DB_E_BADROWHANDLE;

		if (hRow == NULL || pRow == NULL)
			return DB_E_BADROWHANDLE;

		// If we've deleted the row (or are pending) then SetData should fail
		if (pRow->m_status == DBPENDINGSTATUS_DELETED)
			return DB_E_DELETEDROW;

		if (bDeferred)
		{
			__if_exists(T::Fire_OnRowChange)
			{
				if (pRow->m_status != DBPENDINGSTATUS_CHANGED && 
					pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
				{
					HRESULT hrNotify = pT->Fire_OnRowChange(pT, 1, &hRow, 
						DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_OKTODO, FALSE); 
					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
						return DB_E_CANCELED;

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRow, 
						DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_ABOUTTODO, FALSE); 
					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
						return DB_E_CANCELED;
				}
			}

			// If a row is soft inserted (i.e. haven't called update yet)
			// then ignore this section.  An undo will cause the row to
			// delete.
			if (pRow->m_status != DBPENDINGSTATUS_NEW)
			{
				// See if row is already cached, don't make any changes
				//void* pData = (void*)m_mapCachedData.Lookup(hRow, pTemp);
				Storage* pData;
				if (! m_mapCachedData.Lookup(hRow, pData) )
				{
					Storage* pam = NULL;
					ATLTRY(pam = new Storage);
					if (pam == NULL)
						return E_OUTOFMEMORY;
					Checked::memcpy_s(pam, sizeof(Storage), &pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage));

					_ATLTRY
					{
						m_mapCachedData.SetAt(hRow, pam);
					}
					_ATLCATCH( e )
					{
						_ATLDELETEEXCEPTION( e );
						return E_FAIL;
					}
				}
			}
		}

		// NOTE: TransferData will send the SYNCHAFTER phase of the FIRSTCHANGE
		// notification message.  It will handle a veto internally.
		hr = TransferData<T, RowClass, MapClass>
						(pT, false, pSrcData, pRow, &(pT->m_rgRowHandles), hAccessor);
		if (FAILED(hr))
			return hr;

		// Flush Users Data, if in immediate mode
		if (!bDeferred)
		{
			HRESULT hrFlush = pT->FlushData(hRow, hAccessor);
			if (hrFlush == S_OK)
				return hr;  // TransferData may have returned DB_S_ERRORSOCCURRED
			else
				return hrFlush;
		}
		else
		{
			__if_exists(T::Fire_OnRowChange)
			{
				if (pRow->m_status != DBPENDINGSTATUS_CHANGED && 
					pRow->m_status != (DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_UNCHANGED))
				{
					pT->Fire_OnRowChange(pT, 1, &hRow, 
						DBREASON_ROW_FIRSTCHANGE, DBEVENTPHASE_DIDEVENT, TRUE);
				}
			}

			if (pRow->m_status != DBPENDINGSTATUS_NEW)
				pRow->m_status = DBPENDINGSTATUS_CHANGED;
			return hr;	// TransferData may have returned DB_S_ERRORSOCCURRED
		}
	}


	// IRowsetUpdate Methods
	STDMETHOD (GetOriginalData)(HROW hRow, HACCESSOR hAccessor, void* pData)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetUpdateImpl::GetOriginalData\n"));

		T* pT = (T*)this;

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
				return DB_E_NOTREENTRANT;
			else
				pT->DecrementMutex();
		}

		// Validate input parameters
		T::_BindType* pBinding;
		bool bFound = pT->m_rgBindings.Lookup((INT_PTR)hAccessor, pBinding);
		if (!bFound || pBinding == NULL)
			return DB_E_BADACCESSORHANDLE;

		if (pData == NULL && pBinding->cBindings != 0)
			return E_INVALIDARG;		

		RowClass* pRow;
		if (! pT->m_rgRowHandles.Lookup(hRow, pRow))
			return DB_E_BADROWHANDLE;
		if (hRow == NULL || pRow == NULL)
			return DB_E_BADROWHANDLE;

		// If the status is DBPENDINGSTATUS_INVALIDROW, the row has been
		// deleted and the change transmitted to the data source.  In 
		// this case, we can't get the original data so return
		// DB_E_DELETEDROW.
		if (pRow->m_status == DBPENDINGSTATUS_INVALIDROW)
			return DB_E_DELETEDROW;

		// Note, need to determine if accessor is not a row accessor


		// Determine if we have a pending insert. In this case, the
		// spec says revert to default values, and if defaults,
		// are not available, then NULLs.

		if (pRow->m_status == DBPENDINGSTATUS_NEW)
		{
			ATLCOLUMNINFO* pInfo;
			bool bSucceeded = true;
			bool bFailed = false;
			DBORDINAL ulColumns;
			Storage temp;
			Checked::memcpy_s(&temp, sizeof(Storage), &pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage));

			pInfo = T::GetColumnInfo(pT, &ulColumns);

			for (ULONG lBind=0; lBind<pBinding->cBindings; lBind++)
			{
				DBBINDING* pBindCur = &(pBinding->pBindings[lBind]);
				ULONG lColInfo;
				for (lColInfo=0; lColInfo<ulColumns && 
					pBindCur->iOrdinal != pInfo[lColInfo].iOrdinal; lColInfo++);
				if (lColInfo == ulColumns)
					return DB_E_BADORDINAL;

				ATLCOLUMNINFO* pColCur = &(pInfo[lColInfo]);
				DBSTATUS dbStat = DBSTATUS_S_DEFAULT;

				// Try to get the default value.  if that doesn't work, then
				// attempt to do a NULL value
				if (FAILED(pT->SetDBStatus(&dbStat, pRow, pColCur)))
				{
					if ((pColCur->dwFlags & DBCOLUMNFLAGS_ISNULLABLE) ||
						(pColCur->dwFlags & DBCOLUMNFLAGS_MAYBENULL))
					{
						BYTE* pDstTemp = (BYTE*)(&(pT->m_rgRowData[pRow->m_iRowset]) + pColCur->cbOffset);
						*pDstTemp = NULL;
						if (pBindCur->dwPart & DBPART_STATUS)
							*((DBSTATUS*)((BYTE*)(pData) + pBindCur->obStatus)) = DBSTATUS_S_ISNULL;
						bSucceeded |= true;
						continue;
					}
					else
					{
						if (pBindCur->dwPart & DBPART_STATUS)
							*((DBSTATUS*)((BYTE*)(pData) + pBindCur->obStatus)) = DBSTATUS_E_UNAVAILABLE;
						bFailed = true;
						continue;
					}
				}
				else
				{
					if (pBindCur->dwPart & DBPART_STATUS)
						*((DBSTATUS*)((BYTE*)(pData) + pBindCur->obStatus)) = DBSTATUS_S_OK;
					bSucceeded |= true;
					continue;
				}
			}

			TransferData<T, RowClass, MapClass>
					(pT, true, pData, pRow, &(pT->m_rgRowHandles), hAccessor);

			Checked::memcpy_s(&pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage), &temp, sizeof(Storage));
			if (!bFailed)
				return S_OK;
			else
				return (bSucceeded ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED);
		}

		// Determine if the row is cached, if so, we'll temporarily replace
		// it in m_rgRowData and call TransferData to handle the accessor.
		// It is kind of strange but it saves us from having to reimplement
		// TransferData					

		Storage* pam;
		bFound = m_mapCachedData.Lookup(hRow, pam);
		Storage temp;

		if (bFound && pam != NULL)
		{
			Checked::memcpy_s(&temp, sizeof(Storage), &pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage));
			Checked::memcpy_s(&pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage), pam, sizeof(Storage));
		}

		// We need to trick TransferData to thinking a non-transmitted 
		// deleted row is still alive.  This will be its final state after
		// we return anyway.
		if (pRow->m_status == DBPENDINGSTATUS_DELETED)
			pRow->m_status = DBPENDINGSTATUS_UNCHANGED;

		HRESULT hr = TransferData<T, RowClass, MapClass>
						(pT, true, pData, pRow, &(pT->m_rgRowHandles), hAccessor);

		if (bFound && pam != NULL)
		{
			Checked::memcpy_s(&pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage), &temp, sizeof(Storage));
		}

		pRow->m_status = DBPENDINGSTATUS_UNCHANGED;
		return hr;
	}

	STDMETHOD (GetPendingRows)(HCHAPTER /*hReserved*/, DBPENDINGSTATUS dwRowStatus,
			DBCOUNTITEM * pcPendingRows, HROW **prgPendingRows, 
			DBPENDINGSTATUS **prgPendingStatus)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetUpdateImpl::GetPendingRows\n"));
		T* pT = (T*)this;
		bool bPending = false;
		RowClass* pRow = NULL;
		//DBROWCOUNT ulRowHandles = (DBROWCOUNT)pT->m_rgRowHandles.GetCount();

		if (pcPendingRows != NULL)
		{
			*pcPendingRows = 0;

			if (prgPendingRows != NULL)
				*prgPendingRows = NULL;

			if (prgPendingStatus != NULL)
				*prgPendingStatus = NULL;
		}

		// Validate input parameters
		if ((dwRowStatus & 
			~(DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_CHANGED | DBPENDINGSTATUS_DELETED)) != 0)
			return E_INVALIDARG;

		// Validate input parameters
		if ((dwRowStatus & 
			~(DBPENDINGSTATUS_NEW | DBPENDINGSTATUS_CHANGED | DBPENDINGSTATUS_DELETED)) != 0)
			return E_INVALIDARG;

		// Determine how many rows we'll need to return

		POSITION pos = pT->m_rgRowHandles.GetStartPosition();
		while( pos != NULL )
		{
			MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext( pos );
			ATLASSERT( pPair != NULL );
			if(!pPair)
			{
				return E_FAIL;
			}

			// Check to see if a row has a pending status
			pRow = pPair->m_value;

			if (pRow->m_status & dwRowStatus)
			{
				if (pcPendingRows != NULL)
					(*pcPendingRows)++;
				bPending = true;
			}
		}

		// In this case, there are no pending rows that match, just exit out
		if (!bPending)
		{
			// There are no pending rows so exit immediately
			return S_FALSE;
		}
		else
		{
			// Here' the consumer just wants to see if there are pending rows
			// we know that so we can exit
			if (pcPendingRows == NULL)
				return S_OK;
		}

		// Allocate arrays for pending rows
		if (prgPendingRows != NULL)
		{
			*prgPendingRows = (HROW*)::ATL::AtlCoTaskMemCAlloc(*pcPendingRows, static_cast<ULONG>(sizeof(HROW)));
			if (*prgPendingRows == NULL)
			{
				*pcPendingRows = 0;
				return E_OUTOFMEMORY;
			}
		}

		if (prgPendingStatus != NULL)
		{
			*prgPendingStatus = (DBPENDINGSTATUS*)::ATL::AtlCoTaskMemCAlloc(*pcPendingRows, static_cast<ULONG>(sizeof(DBPENDINGSTATUS)));
			if (*prgPendingStatus == NULL)
			{
				*pcPendingRows = 0;
				CoTaskMemFree(*prgPendingRows);
				*prgPendingRows = NULL;
				return E_OUTOFMEMORY;
			}
			memset(*prgPendingStatus, 0, *pcPendingRows * sizeof(DBPENDINGSTATUS));
		}

		if (prgPendingRows || prgPendingStatus)
		{
			ULONG ulRows = 0;
			pos = pT->m_rgRowHandles.GetStartPosition();
			while( pos != NULL )
			{
				MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext( pos );
				ATLASSERT( pPair != NULL );

				pRow = pPair->m_value;
				if (pRow->m_status & dwRowStatus)
				{
					// Add the output row
					pRow->AddRefRow();
					if (prgPendingRows)
						((*prgPendingRows)[ulRows]) = /*(HROW)*/pPair->m_key;
					if (prgPendingStatus)
						((*prgPendingStatus)[ulRows]) = (DBPENDINGSTATUS)pRow->m_status;
					ulRows++;
				}
			}
			/*
			for (iRowset = 0; iRowset < ulRowHandles; iRowset++)
			{
				pRow = pT->m_rgRowHandles.GetValueAt(iRowset);
				if (pRow->m_status & dwRowStatus)
				{
					// Add the output row
					pRow->AddRefRow();
					if (prgPendingRows)
						((*prgPendingRows)[ulRows]) = (HROW)pT->m_rgRowHandles.GetKeyAt(iRowset);
					if (prgPendingStatus)
						((*prgPendingStatus)[ulRows]) = (DBPENDINGSTATUS)pRow->m_status;
					ulRows++;
				}
			}
			*/
			if (pcPendingRows != NULL)
				*pcPendingRows = ulRows;
		}

		// Return code depending on
		return S_OK;
	}

	STDMETHOD (GetRowStatus)(HCHAPTER /*hReserved*/, DBCOUNTITEM cRows, 
		const HROW rghRows[], DBPENDINGSTATUS rgPendingStatus[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetUpdateImpl::GetRowStatus\n"));
		T* pT = (T*)this;

		bool bSucceeded = true;
		ULONG ulFetched = 0;

		if (cRows != 0)
		{
			// check for correct pointers
			if (rghRows == NULL || rgPendingStatus == NULL)
				return E_INVALIDARG;

			for (ULONG ulRows=0; ulRows < cRows; ulRows++)
			{
				RowClass* pRow;
				bool bFound = pT->m_rgRowHandles.Lookup(rghRows[ulRows], pRow);
				if ((! bFound || pRow == NULL) || (pRow->m_status == DBPENDINGSTATUS_INVALIDROW))
				{
					rgPendingStatus[ulRows] = DBPENDINGSTATUS_INVALIDROW;
					bSucceeded = false;
					continue;
				}
				if (pRow->m_status != 0)
					rgPendingStatus[ulRows] = pRow->m_status;
				else
					rgPendingStatus[ulRows] = DBPENDINGSTATUS_UNCHANGED;

				ulFetched++;
			}
		}

		if (bSucceeded)
		{
			return S_OK;
		}
		else
		{
			if (ulFetched > 0)
				return DB_S_ERRORSOCCURRED;
			else
				return DB_E_ERRORSOCCURRED;
		}
	}

	STDMETHOD (Undo)(HCHAPTER /*hReserved*/, DBCOUNTITEM cRows, const HROW rghRows[ ],
		DBCOUNTITEM *pcRowsUndone, HROW **prgRowsUndone, 
		DBROWSTATUS **prgRowStatus)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetUpdateImpl::Undo\n"));

		T* pT = (T*)this;
		T::ObjectLock lock(pT);

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
			{
				// Note, we can't set this up above as we may inadvertantly 
				// step on the pcRowsUndone variable.
				if (pcRowsUndone != NULL)
					*pcRowsUndone = NULL;			
				return DB_E_NOTREENTRANT;
			}
			else
				pT->DecrementMutex();
		}

		DBCOUNTITEM ulRows = 0;
		bool bSucceeded = false;
		bool bFailed = false;
		bool bIgnore = false;
		ULONG ulUndone = 0;	

		// the following lines are used to fix the two _alloca calls below.  Those calls are risky 
		// because we may be allocating huge amounts of data.  So instead I'll allocate that data on heap.
		// But if you use _alloca you don't have to worry about cleaning this memory.  So we will use these
		// temporary variables to allocate memory on heap.  As soon as we exit the function, the memory will
		// be cleaned up, just as if we were using alloca. So now, instead of calling alloca, I'll alloc
		// memory on heap using the two smnart pointers below, and then assing it to the actual pointers.
		CHeapPtr<HROW> spTempRowsUndone;
		CHeapPtr<DBROWSTATUS> spTempRowStatus;

		__if_exists(T::Fire_OnRowChange)
		{
			HRESULT hrNotify = S_OK;
			int nReason = 0;
		}

		// Ignore prgRowsUndone/prgRowStatus if pcRowsUndone is NULL and
		// cRows == 0.
		if (pcRowsUndone != NULL || cRows != 0)
		{
			if (prgRowsUndone != NULL)
				*prgRowsUndone = NULL;

			if (prgRowStatus != NULL)
				*prgRowStatus = NULL;		
		}
		else
		{
			bIgnore = true;		// Don't do status or row arrays
		}

		// Check to see how many changes we'll undo 
		if (pcRowsUndone != NULL)
		{
			*pcRowsUndone = NULL;
			 if (prgRowsUndone == NULL)
				 return E_INVALIDARG;
		}


		if (cRows != 0)
		{
			if (rghRows == NULL)
				return E_INVALIDARG;

			ulRows = cRows;
		}
		else
			ulRows = (DBCOUNTITEM)pT->m_rgRowHandles.GetCount();

		// NULL out pointers
		if (prgRowsUndone != NULL && ulRows != 0 && bIgnore == false)
		{
			// Make a temporary buffer as we may not fill up everything
			// in the case where cRows == 0
			if (cRows != 0)
				*prgRowsUndone = (HROW*)::ATL::AtlCoTaskMemCAlloc(ulRows, static_cast<ULONG>(sizeof(HROW)));
			else
			{
				spTempRowsUndone.Allocate(ulRows);
				*prgRowsUndone = spTempRowsUndone;
			}

			if (*prgRowsUndone == NULL)
				return E_OUTOFMEMORY;
		}
		else
		{
			if (prgRowsUndone != NULL && bIgnore == false)
				*prgRowsUndone = NULL;
		}

		if (prgRowStatus != NULL && ulRows != 0 && bIgnore == false)
		{
			if (cRows != 0)
				*prgRowStatus = (DBROWSTATUS*)::ATL::AtlCoTaskMemCAlloc(ulRows, static_cast<ULONG>(sizeof(DBROWSTATUS)));
			else
			{
				spTempRowStatus.Allocate(ulRows);
				*prgRowStatus = spTempRowStatus;
			}

			if (*prgRowStatus == NULL)
			{
				if (cRows != 0)
					CoTaskMemFree(*prgRowsUndone);
				*prgRowsUndone = NULL;
				return E_OUTOFMEMORY;
			}
		}
		else
		{
			if (prgRowStatus != NULL && bIgnore == false)
				*prgRowStatus = NULL;
		}

		POSITION pos = pT->m_rgRowHandles.GetStartPosition();
		RowClass* pRow = NULL;
		for (ULONG ulUndoRow = 0; ulUndoRow < ulRows; ulUndoRow++)
		{
			HROW hRowUndo = NULL;
			ULONG ulCurrentRow = ulUndone;

			if (rghRows != NULL && cRows != 0)
			{
				hRowUndo = rghRows[ulUndoRow];
			}
			else
			{
				ATLASSERT(ulUndoRow < (ULONG)pT->m_rgRowHandles.GetCount());
				ATLASSERT( pos != NULL );
				MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(pos);
				ATLASSERT( pPair != NULL );
				if(!pPair)
				{
					return E_FAIL;
				}
				hRowUndo = pPair->m_key;
			}

			if (prgRowsUndone != NULL && bIgnore == false)
				(*prgRowsUndone)[ulCurrentRow] = hRowUndo;

			// Fetch the RowClass and determine if it is valid
			bool bFound = pT->m_rgRowHandles.Lookup(hRowUndo, pRow);
			if (!bFound || pRow == NULL)
			{
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_INVALID;
				bFailed = true;
				ulUndone++;
				continue;
			}

			// If cRows is zero we'll go through all rows fetched.  We shouldn't
			// increment the count for rows that haven't been modified.

			if (cRows != 0 || (pRow != NULL &&
				pRow->m_status != 0 && pRow->m_status != DBPENDINGSTATUS_UNCHANGED
				&& pRow->m_status != DBPENDINGSTATUS_INVALIDROW))
				ulUndone++;
			else
				continue;


			// AddRef the row if cRows is zero (we will be returning it to the
			// consumer)
			if (cRows == 0)
				pRow->AddRefRow();

			// Fetch the data, note, this may be NULL in several cases
			Storage* pData;
			if(! m_mapCachedData.Lookup(hRowUndo, pData) )
				pData = NULL;

			switch (pRow->m_status)
			{
			case DBPENDINGSTATUS_INVALIDROW:	// Row has already been hard deleted
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_DELETED;
				bFailed = true;
				continue;
				break;

			case DBPENDINGSTATUS_NEW:			// Row has been soft inserted
				// If the row is newly inserted, go ahead and mark its
				// row as INVALID (according to the specification).

				__if_exists(T::Fire_OnRowChange)
				{
					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
						DBREASON_ROW_UNDOINSERT, DBEVENTPHASE_OKTODO, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
						DBREASON_ROW_UNDOINSERT, DBEVENTPHASE_ABOUTTODO, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
						DBREASON_ROW_UNDOINSERT, DBEVENTPHASE_SYNCHAFTER, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}
				}

				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_S_OK;
				pT->m_rgRowData.RemoveAt(pRow->m_iRowset);

				// Move any other subsequent rows up in the chain
				{
					POSITION posRow = pT->m_rgRowHandles.GetStartPosition();
					while(posRow != NULL)
					{
						MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(posRow);
						ATLASSERT( pPair != NULL );
						if(!pPair)
						{
							return E_FAIL;
						}
						RowClass* pCheckRow = pPair->m_value;
						if (pCheckRow != NULL && 
							pCheckRow->m_iRowset > pRow->m_iRowset)
							pCheckRow->m_iRowset--;
					}
				}

				pRow->m_status = DBPENDINGSTATUS_INVALIDROW;
				bSucceeded = true;

				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, &hRowUndo, DBREASON_ROW_UNDOINSERT,
						DBEVENTPHASE_DIDEVENT, TRUE);
				}

				continue;
				break;

			case 0:								// Row has just been fetched
			case DBPENDINGSTATUS_DELETED:		// Row has been soft deleted
			case DBPENDINGSTATUS_UNCHANGED:		// Row is not changed
				__if_exists(T::Fire_OnRowChange)
				{
					if (pRow->m_status == DBPENDINGSTATUS_DELETED)
					{
						nReason = 1;
						hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
							DBREASON_ROW_UNDODELETE, DBEVENTPHASE_OKTODO, FALSE);

						if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
						{
							if (prgRowStatus != NULL && bIgnore == false)
								(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
							bFailed = true;
							continue;
						}

						hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
							DBREASON_ROW_UNDODELETE, DBEVENTPHASE_ABOUTTODO, FALSE);

						if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
						{
							if (prgRowStatus != NULL && bIgnore == false)
								(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
							bFailed = true;
							continue;
						}

						hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
							DBREASON_ROW_UNDODELETE, DBEVENTPHASE_SYNCHAFTER, FALSE);

						if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
						{
							if (prgRowStatus != NULL && bIgnore == false)
								(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
							bFailed = true;
							continue;
						}
					}
				}

				pRow->m_status = DBPENDINGSTATUS_UNCHANGED;

				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_S_OK;
				bSucceeded = true;

				// Somebody set, then deleted a row most likely
				if (pData != NULL)
				{
					Checked::memcpy_s(&pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage), pData, sizeof(Storage));
				}

				__if_exists(T::Fire_OnRowChange)
				{
					if (nReason == 1)
					{
						pT->Fire_OnRowChange(pT, 1, &hRowUndo, DBREASON_ROW_UNDODELETE,
							DBEVENTPHASE_DIDEVENT, TRUE);
						nReason = 0;
					}
				}
				continue;
				break;

			default:							// Row has been changed
				__if_exists(T::Fire_OnRowChange)
				{
					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
						DBREASON_ROW_UNDOCHANGE, DBEVENTPHASE_OKTODO, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
						DBREASON_ROW_UNDOCHANGE, DBEVENTPHASE_ABOUTTODO, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUndo, 
						DBREASON_ROW_UNDOCHANGE, DBEVENTPHASE_SYNCHAFTER, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}
				}

				if (pData == NULL)
				{
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, &hRowUndo, DBREASON_ROW_UNDOCHANGE,
							DBEVENTPHASE_FAILEDTODO, FALSE);
					}

					if (prgRowStatus != NULL && bIgnore == false)
						(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_INVALID;
					bFailed = true;
					continue;
				}

				// Copy data back
				Checked::memcpy_s(&pT->m_rgRowData[pRow->m_iRowset], sizeof(Storage), pData, sizeof(Storage));
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_S_OK;
				pRow->m_status = DBPENDINGSTATUS_UNCHANGED;
				bSucceeded = true;

				// Remove undo buffer
				m_mapCachedData.RemoveKey(hRowUndo);

				// Check if we need to release the row because it's ref was 0
				// See the IRowset::ReleaseRows section in the spec for more
				// information
				if (pRow->m_dwRef == 0)
				{
					pRow->AddRefRow();	// Artifically bump this to remove it
					if( FAILED( pT->RefRows(1, &hRowUndo, NULL, NULL, false) ) )
						return E_FAIL;
				}

				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, &hRowUndo, DBREASON_ROW_UNDOCHANGE,
						DBEVENTPHASE_DIDEVENT, TRUE);
				}

				break;
			}
		}


		// Set the output for rows undone.
		if (pcRowsUndone)
			*pcRowsUndone = ulUndone;

		// In the case where cRows == 0, we need to allocate the final
		// array of data.
		if (cRows == 0)
		{
			HROW* prowTemp = NULL;
			DBROWSTATUS* prowStatus = NULL;

			if (prgRowsUndone != NULL && ulUndone != 0 && bIgnore == false)
			{
				prowTemp = (HROW*)::ATL::AtlCoTaskMemCAlloc(ulUndone, static_cast<ULONG>(sizeof(HROW)));
				if (prowTemp == NULL)
				{
					// Free prgRowsUndone
					if (cRows != 0 && prgRowsUndone != NULL)
						CoTaskMemFree(*prgRowsUndone);

					if (cRows != 0 && prgRowStatus != NULL)
						CoTaskMemFree(*prgRowStatus);

					return E_OUTOFMEMORY;
				}

				Checked::memcpy_s(prowTemp, (sizeof(HROW)*ulUndone), *prgRowsUndone, (sizeof(HROW)*ulUndone));
				if (cRows != 0)
					CoTaskMemFree(*prgRowsUndone);  // we're finished w/ the temp array
				*prgRowsUndone = prowTemp;
			}
			else
			{
				if (prgRowsUndone != NULL && bIgnore == false)
					*prgRowsUndone = NULL;
			}

			if (prgRowStatus != NULL && ulUndone != 0 && bIgnore == false)
			{
				prowStatus = (DBROWSTATUS*)::ATL::AtlCoTaskMemCAlloc(ulUndone, static_cast<ULONG>(sizeof(DBROWSTATUS)));
				if (prowStatus == NULL)
				{
					if (cRows != 0 && prgRowsUndone != NULL)
						CoTaskMemFree(*prgRowsUndone);

					if (prgRowStatus != NULL && cRows != 0)
						CoTaskMemFree(*prgRowStatus);

					return E_OUTOFMEMORY;
				}

				Checked::memcpy_s(prowStatus, (sizeof(DBROWSTATUS)*ulUndone), *prgRowStatus, (sizeof(DBROWSTATUS)*ulUndone));
				if (cRows != 0)
					CoTaskMemFree(*prgRowStatus);
				*prgRowStatus = prowStatus;
			}
			else
			{
				if (prgRowStatus != NULL && bIgnore == false)
					*prgRowStatus = NULL;
			}
		}

		// Send the return value
		if (!bFailed)
			return S_OK;
		else
		{
			if (!bSucceeded)
				return DB_E_ERRORSOCCURRED;
			else
				return DB_S_ERRORSOCCURRED;
		}
	}

	STDMETHOD (Update)(HCHAPTER /*hReserved*/, DBCOUNTITEM cRows,
		const HROW rghRows[], DBCOUNTITEM *pcRows, HROW **prgRows,
		DBROWSTATUS **prgRowStatus)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IRowsetUpdateImpl::Update\n"));

		T* pT = (T*)this;
		T::ObjectLock lock(pT);

		__if_exists(T::Fire_OnRowChange)
		{
			// Check to see if someone is in an event handler.  If we do, then 
			// we should return DB_E_NOTREENTRANT.
			if (!pT->IncrementMutex())
			{
				if (pcRows != NULL)
					*pcRows = NULL;
				return DB_E_NOTREENTRANT;
			}
			else
				pT->DecrementMutex();
		}

		bool bSucceeded = false;
		bool bFailed = false;
		bool bIgnore = false;
		ULONG ulCount = 0;
		DBCOUNTITEM ulRowUpdate = 0;

		// the following lines are used to fix the two _alloca calls below.  Those calls are risky 
		// because we may be allocating huge amounts of data.  So instead I'll allocate that data on heap.
		// But if you use _alloca you don't have to worry about cleaning this memory.  So we will use these
		// temporary variables to allocate memory on heap.  As soon as we exit the function, the memory will
		// be cleaned up, just as if we were using alloca. So now, instead of calling alloca, I'll alloc
		// memory on heap using the two smnart pointers below, and then assing it to the actual pointers.
		CHeapPtr<HROW> spTempRows;
		CHeapPtr<DBROWSTATUS> spTempRowStatus;

		if (pcRows != NULL || cRows != 0)
		{
			if (prgRows != NULL)
				*prgRows = NULL;

			if (prgRowStatus != NULL)
				*prgRowStatus = NULL;
		}
		else
		{
			bIgnore = true;
		}

		if (pcRows != NULL)
		{
			*pcRows = NULL;
			if (prgRows == NULL)
				return E_INVALIDARG;
		}

		if (cRows != 0)
		{
			if (rghRows == NULL)
				return E_INVALIDARG;

			ulRowUpdate = cRows;
		}
		else
			ulRowUpdate = (DBCOUNTITEM)pT->m_rgRowHandles.GetCount();

		// NULL out pointers
		if (prgRows != NULL && ulRowUpdate != 0  && bIgnore == false)
		{
			if (cRows != 0)
				*prgRows = (HROW*)::ATL::AtlCoTaskMemCAlloc(ulRowUpdate, static_cast<ULONG>(sizeof(HROW)));
			else
			{
				spTempRows.Allocate(ulRowUpdate);
				*prgRows = spTempRows;
			}

			if (*prgRows == NULL)
				return E_OUTOFMEMORY;
		}
		else
		{
			if (prgRows != NULL && bIgnore == false)
				*prgRows = NULL;
		}

		if (prgRowStatus != NULL && ulRowUpdate != 0  && bIgnore == false)
		{
			if (cRows != 0)
				*prgRowStatus = (DBROWSTATUS*)::ATL::AtlCoTaskMemCAlloc(ulRowUpdate, static_cast<ULONG>(sizeof(DBROWSTATUS)));
			else
			{
				spTempRowStatus.Allocate(ulRowUpdate);
				*prgRowStatus = spTempRowStatus;
			}

			if (*prgRowStatus == NULL)
			{
				if(prgRows && *prgRows)
				{
					CoTaskMemFree(*prgRows);
					*prgRows = NULL;
				}
				return E_OUTOFMEMORY;
			}
		}
		else
		{
			if (prgRowStatus != NULL && bIgnore == false)
				*prgRowStatus = NULL;
		}

		// NOTE:  If cRows is zero, then we should ignore rghRows and 
		// update all of the rows in the cached map.
		RowClass* pRow = NULL;
		POSITION pos = pT->m_rgRowHandles.GetStartPosition();
		for (ULONG ulRow = 0; ulRow < ulRowUpdate; ulRow++)
		{
			void* pData = NULL;
			HROW hRowUpdate = NULL;
			ULONG ulAlreadyProcessed = 0;
			bool bDupRow = false;
			LONG ulCurrentRow = ulCount;

			// Fetch the HROW, RowClass, and Data for the row.  Perform
			// Validation as necessiary
			if (cRows != 0)
			{
				hRowUpdate = rghRows[ulRow];

				for (ULONG ulCheckDup = 0; ulCheckDup < ulRow; ulCheckDup++)
				{
					if (pT->IsSameRow(hRowUpdate, rghRows[ulCheckDup]) == S_OK)
					{
						ulAlreadyProcessed = ulCheckDup;
						bDupRow = true;
						break;
					}
				}
			}
			else
			{
				ATLASSERT(ulRow < (ULONG)pT->m_rgRowHandles.GetCount());
				ATLASSERT( pos != NULL );
				MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(pos);
				ATLASSERT( pPair != NULL );
				if(!pPair)
				{
					return E_FAIL;
				}
				hRowUpdate = pPair->m_key;
			}

			if (prgRows != NULL && bIgnore == false)
				(*prgRows)[ulCurrentRow] = hRowUpdate;


			if (bDupRow != false)
			{
				// We've already set the row before, just copy status and
				// continue processing
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = (*prgRowStatus)[ulAlreadyProcessed];

				ulCount++;
				continue;
			}

			bool bFound = pT->m_rgRowHandles.Lookup(hRowUpdate, pRow);
			if (!bFound || pRow == NULL)
			{
				if (prgRowStatus != NULL  && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_INVALID;
				bFailed = true;
				ulCount++;
				continue;
			}

			// If the row is not UNCHANGED, send preliminary notifications before beginning processing
			if( pRow->m_status != 0 &&
				pRow->m_status != DBPENDINGSTATUS_UNCHANGED )
			{
				__if_exists(T::Fire_OnRowChange)
				{

					HRESULT hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUpdate, DBREASON_ROW_UPDATE, 
															DBEVENTPHASE_OKTODO, FALSE); 
					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, &hRowUpdate, DBREASON_ROW_UPDATE, 
															DBEVENTPHASE_ABOUTTODO, FALSE); 
					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}

					hrNotify = pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE, 
															DBEVENTPHASE_SYNCHAFTER, FALSE);

					if ((hrNotify != S_OK) && (hrNotify != E_FAIL))
					{
						if (prgRowStatus != NULL && bIgnore == false)
							(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_CANCELED;
						bFailed = true;
						continue;
					}
				}
			}

			// If cRows is zero we'll go through all rows fetched.  We
			// shouldn't increment the attempted count for rows that are
			// not changed
			if (cRows != 0 || (pRow != NULL && 
				pRow->m_status !=0 && pRow->m_status != DBPENDINGSTATUS_UNCHANGED
				&& pRow->m_status != DBPENDINGSTATUS_INVALIDROW))
				ulCount++;
			else
				continue;


			switch(pRow->m_status)
			{
			case DBPENDINGSTATUS_INVALIDROW:		// Row is bad or deleted
				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE, 
						DBEVENTPHASE_FAILEDTODO, TRUE); 
				}
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_DELETED;
				bFailed = true;
				continue;
				break;

			case DBPENDINGSTATUS_UNCHANGED:
			case 0:
				// If the row's status is not changed, then just put S_OK
				// and continue.  The spec says we should not transmit the
				// request to the data source (as nothing would change).
				//__if_exists(T::Fire_OnRowChange)
				//{
				//	pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE, 
				//		DBEVENTPHASE_DIDEVENT, TRUE); 
				//}
				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_S_OK;
				bSucceeded = true;
				continue;
				break;

			default:
				pData = &pT->m_rgRowData[pRow->m_iRowset]; 

				if (pData == NULL)
				{
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE, 
							DBEVENTPHASE_FAILEDTODO, TRUE); 
					}
					if (prgRowStatus != NULL && bIgnore == false)
						(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_INVALID;
					bFailed = true;
					continue;
				}

				// If the rghRows variable is NULL, we now add the row to 
				// prgRows.  We do this because we have determined that the
				// row has changed. AddRef the row as it may not be held by 
				// the consumer.
				if (cRows == 0)
					pRow->AddRefRow();

				// Ask the provider if it is OK to change this row.
				DBROWSTATUS status = DBROWSTATUS_S_OK;
				if (FAILED(IsUpdateAllowed(pRow->m_status, hRowUpdate, &status)))
				{
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE, 
							DBEVENTPHASE_FAILEDTODO, TRUE); 
					}
					if (prgRowStatus != NULL && bIgnore == false)
						(*prgRowStatus)[ulCurrentRow] = status;
					bFailed = true;
					continue;
				}

				if (pRow->m_status == DBPENDINGSTATUS_DELETED)
				{
					pT->m_rgRowData.RemoveAt(pRow->m_iRowset);
					// Need to update any outstanding pRow->m_iRowset
					// variables
					POSITION posRow = pT->m_rgRowHandles.GetStartPosition();
					while( posRow != NULL )
					{
						MapClass::CPair* pPair = pT->m_rgRowHandles.GetNext(posRow);
						ATLASSERT( pPair != NULL );
						RowClass* pCheckRow = pPair->m_value;
						if (pCheckRow != NULL && 
							pCheckRow->m_iRowset > pRow->m_iRowset)
							pCheckRow->m_iRowset--;
					}

					// Per the specification, deleted rows transmitted
					// to the data source are set to 
					// DBPENDINGSTATUS_INVALIDROW
					pRow->m_status = DBPENDINGSTATUS_INVALIDROW;
				}

				// Copy data back
				if (FAILED(pT->FlushData(hRowUpdate, NULL)))
				{
					if (prgRowStatus != NULL && bIgnore == false)
						(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_E_FAIL;
					__if_exists(T::Fire_OnRowChange)
					{
						pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE, 
							DBEVENTPHASE_FAILEDTODO, TRUE); 
					}
					bFailed = true;
					continue;
				}

				if (prgRowStatus != NULL && bIgnore == false)
					(*prgRowStatus)[ulCurrentRow] = DBROWSTATUS_S_OK;
				bSucceeded = true;

				if (pRow->m_status != DBPENDINGSTATUS_DELETED)
				{
					if (pRow->m_status != DBPENDINGSTATUS_INVALIDROW)
						pRow->m_status = DBPENDINGSTATUS_UNCHANGED;
				}

				// Remove undo buffer.  
				if (m_mapCachedData.Lookup(hRowUpdate) != NULL)
					m_mapCachedData.RemoveKey(hRowUpdate);

				// Check if we need to release the row because it's ref was 0
				// See the IRowset::ReleaseRows section in the spec for more
				// information
				if (pRow->m_dwRef == 0)
				{
					pRow->AddRefRow();	// Artifically bump this to remove it
					if( FAILED( pT->RefRows(1, &hRowUpdate, NULL, NULL, false) ) )
						return E_FAIL;
				}

				__if_exists(T::Fire_OnRowChange)
				{
					pT->Fire_OnRowChange(pT, 1, (HROW*)&hRowUpdate, DBREASON_ROW_UPDATE, 
						DBEVENTPHASE_DIDEVENT, TRUE); 
				}

				break;

			}
		}

		// Set the output for rows undone.
		if (pcRows)
		{
			if( cRows==0 )
				*pcRows = ulCount;
			else
				*pcRows = cRows;
		}

		// In the case where cRows == 0, we need to allocate the final
		// array of HROWs and status values.
		if (cRows == 0)
		{
			HROW* prowTemp;
			DBROWSTATUS* prowStatus;

			if (prgRows != NULL && ulCount != 0 && bIgnore == false)
			{
				prowTemp = (HROW*)::ATL::AtlCoTaskMemCAlloc(ulCount, static_cast<ULONG>(sizeof(HROW)));
				if (prowTemp == NULL)
				{
					if (cRows != 0 && prgRows != NULL)
						CoTaskMemFree(*prgRows);

					if (cRows != 0 && prgRowStatus != NULL)
						CoTaskMemFree(*prgRowStatus);

					return E_OUTOFMEMORY;
				}

				Checked::memcpy_s(prowTemp, sizeof(HROW) * ulCount, *prgRows, sizeof(HROW) * ulCount);
				if (cRows != 0)
					CoTaskMemFree(*prgRows);
				*prgRows = prowTemp;
			}
			else
			{
				if (prgRows != NULL && bIgnore == false)
					*prgRows = NULL;
			}

			if (prgRowStatus != NULL && ulCount != 0 && bIgnore == false)
			{
				prowStatus = (DBROWSTATUS*)::ATL::AtlCoTaskMemCAlloc(ulCount, static_cast<ULONG>(sizeof(DBROWSTATUS)));
				if (prowStatus == NULL)
				{
					if (cRows != 0 && prgRows != NULL)
						CoTaskMemFree(*prgRows);

					if (cRows != 0 && prgRowStatus != NULL)
						CoTaskMemFree(*prgRowStatus);

					return E_OUTOFMEMORY;
				}

				Checked::memcpy_s(prowStatus, sizeof(DBROWSTATUS)*ulCount, *prgRowStatus, sizeof(DBROWSTATUS)*ulCount);
				if (cRows != 0)
					CoTaskMemFree(*prgRowStatus);
				*prgRowStatus = prowStatus;
			}
			else
			{
				if (prgRowStatus != NULL && bIgnore == false)
					*prgRowStatus = NULL;
			}
		}

		// Send the return value
		if (!bFailed)
			return S_OK;
		else
		{
			if (!bSucceeded)
				return DB_E_ERRORSOCCURRED;
			else
				return DB_S_ERRORSOCCURRED;
		}
	}


	// Callback functions
	HRESULT IsUpdateAllowed(DBPENDINGSTATUS /* [in] *//*status*/, 
				/*[in] */ HROW /*hRowUpdate*/, 
				/* [out] */ DBROWSTATUS* /*pRowStatus*/)
	{
		// If you need to perform any checks for security, integrity
		// violations, etc. as a result of an update, override this
		// method.

		// Make sure you put the appropriate status in the pRowStatus
		// as it will be returned to the user.
		return S_OK;
	}

	// Map containing original data for deferred operation
	CAtlMap<HROW, Storage*> m_mapCachedData;
};

}; //namespace ATL	
#pragma pack(pop)
#pragma warning(pop)

#endif //__ATLDB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atldbsch.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

///////////////////////////////////////////////////////////////////////////
// ATLDBSCH.H : Declarations for OLE DB Schema Rowset Consumer Support
//

#ifndef __ATLDBSCH_H__
#define __ATLDBSCH_H__

#pragma once

#ifdef _WIN32_WCE
	#error atldbsch.h is not supported on Windows CE (_WIN32_WCE is defined)
#endif //_WIN32_WCE

#pragma pack(push,_ATL_PACKING)
namespace ATL
{

template <short nRestrictions>
class _CStoreRestrictions
{
public:
	_CStoreRestrictions()
	{
		m_pvarRestrictions = NULL;
		ATLENSURE(m_pvarRestrictions = new CComVariant[nRestrictions]);
	}
	~_CStoreRestrictions()
	{
		delete [] m_pvarRestrictions;
	}
	HRESULT GetRowset(const CSession& session, const GUID& guidSchema, IRowset** ppRowset)
	{
		ATLASSERT(session.m_spOpenRowset != NULL);
		CComPtr<IDBSchemaRowset> spSchemaRowset;
		HRESULT hr;

		hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBSchemaRowset), (void**)&spSchemaRowset);
		if (FAILED(hr))
			return hr;

		return spSchemaRowset->GetRowset(NULL, guidSchema, nRestrictions,
			m_pvarRestrictions, __uuidof(IRowset), 0, NULL, (IUnknown**)ppRowset);
	}

	CComVariant* m_pvarRestrictions;
};

template <>
class _CStoreRestrictions<0>
{
public:
	HRESULT GetRowset(const CSession& session, const GUID& guidSchema, IRowset** ppRowset)
	{
		ATLASSERT(session.m_spOpenRowset != NULL);
		CComPtr<IDBSchemaRowset> spSchemaRowset;
		HRESULT hr;

		hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBSchemaRowset), (void**)&spSchemaRowset);
		if (FAILED(hr))
			return hr;

		return spSchemaRowset->GetRowset(NULL, guidSchema, 0,
			NULL, __uuidof(IRowset), 0, NULL, (IUnknown**)ppRowset);
	}
};

///////////////////////////////////////////////////////////////////////////
// class CSchemaRowset
template <class T, short nRestrictions, template <typename T> class TRowset = CRowset>
class CSchemaRowset :
	public CAccessorRowset<T, TRowset>,
	public _CStoreRestrictions<nRestrictions>
{
public:
// Operations
	HRESULT Open(const CSession& session, const GUID& guidSchema, bool bBind = true )
	{
		HRESULT hr;

		hr = GetRowset(session, guidSchema, &m_spRowset);
		if ( SUCCEEDED(hr) && bBind )
			hr = Bind();

		return hr;
	}
};

 ///////////////////////////////////////////////////////////////////////////
// class CRestrictions

template <class T, short nRestrictions, const GUID* pguid>
class CRestrictions : public CSchemaRowset<T, nRestrictions>
{
public:
	HRESULT Open(const CSession& session, LPCTSTR lpszParam1 = NULL, LPCTSTR lpszParam2 = NULL,
			LPCTSTR lpszParam3 = NULL, LPCTSTR lpszParam4 = NULL,
			LPCTSTR lpszParam5 = NULL, LPCTSTR lpszParam6 = NULL,
			LPCTSTR lpszParam7 = NULL, bool bBind = true )
	{
		USES_CONVERSION_EX;
		CComVariant* pVariant;

		if (m_pvarRestrictions == NULL)
			return E_OUTOFMEMORY;

		if (lpszParam1 != NULL)
		{
			m_pvarRestrictions->vt = VT_BSTR;
			m_pvarRestrictions->bstrVal = ::SysAllocString(T2COLE_EX_DEF(lpszParam1));
			if (m_pvarRestrictions->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam2 != NULL)
		{
			pVariant = m_pvarRestrictions + 1;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE_EX_DEF(lpszParam2));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam3 != NULL)
		{
			pVariant = m_pvarRestrictions + 2;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE_EX_DEF(lpszParam3));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam4 != NULL)
		{
			pVariant = m_pvarRestrictions + 3;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE_EX_DEF(lpszParam4));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam5 != NULL)
		{
			pVariant = m_pvarRestrictions + 4;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE_EX_DEF(lpszParam5));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam6 != NULL)
		{
			pVariant = m_pvarRestrictions + 5;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE_EX_DEF(lpszParam6));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		if (lpszParam7 != NULL)
		{
			pVariant = m_pvarRestrictions + 6;
			pVariant->vt = VT_BSTR;
			pVariant->bstrVal = ::SysAllocString(T2COLE_EX_DEF(lpszParam7));
			if (pVariant->bstrVal == NULL)
				return E_OUTOFMEMORY;
		}

		return CSchemaRowset<T, nRestrictions>::Open(session, *pguid, bBind);
	}
};


///////////////////////////////////////////////////////////////////////////
// CSchemas

class CSchemas
{
public:
	CSchemas()
	{
		m_nSchemas          = 0;
		m_pSchemaGuids      = NULL;
		m_pulRestrictions   = NULL;
	};

	~CSchemas()
	{
		// Clean up allocated memory
		CoTaskMemFree(m_pSchemaGuids);
		CoTaskMemFree(m_pulRestrictions);
	};

// Operations
	HRESULT GetSchemas(const CSession& session)
	{
		CComPtr<IDBSchemaRowset> spSchemaRowset;
		HRESULT hr;

		ATLASSERT(session.m_spOpenRowset != NULL);

		hr = session.m_spOpenRowset->QueryInterface(__uuidof(IDBSchemaRowset),
			(void**)&spSchemaRowset);
		if (FAILED(hr))
			return hr;

		return spSchemaRowset->GetSchemas(&m_nSchemas, &m_pSchemaGuids,
				&m_pulRestrictions);
	};

// Attributes
	ULONG   m_nSchemas;
	LPGUID  m_pSchemaGuids;
	ULONG*  m_pulRestrictions;
};


///////////////////////////////////////////////////////////////////////////
// CAssertionInfo

class CAssertionInfo
{
public:
	CAssertionInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	VARIANT_BOOL    m_bIsDeferrable;
	VARIANT_BOOL    m_bInitiallyDeferred;
	TCHAR           m_szDescription[129];

// Binding Map
BEGIN_COLUMN_MAP(CAssertionInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_bIsDeferrable)
	COLUMN_ENTRY(5, m_bInitiallyDeferred)
	COLUMN_ENTRY(6, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCatalogInfo

class CCatalogInfo
{
public:
	CCatalogInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szName[129];
	TCHAR   m_szDescription[129];

// Binding Info
BEGIN_COLUMN_MAP(CCatalogInfo)
	COLUMN_ENTRY(1, m_szName)
	COLUMN_ENTRY(2, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCharacterSetInfo

class CCharacterSetInfo
{
public:
	CCharacterSetInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	TCHAR           m_szFormOfUse[129];
	LARGE_INTEGER   m_nNumCharacters;
	TCHAR           m_szCollateCatalog[129];
	TCHAR           m_szCollateSchema[129];
	TCHAR           m_szCollateName[129];

// Binding Info
BEGIN_COLUMN_MAP(CCharacterSetInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szFormOfUse)
	COLUMN_ENTRY(5, m_nNumCharacters)
	COLUMN_ENTRY(6, m_szCollateCatalog)
	COLUMN_ENTRY(7, m_szCollateSchema)
	COLUMN_ENTRY(8, m_szCollateName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCheckConstraintInfo

class CCheckConstraintInfo
{
public:
	CCheckConstraintInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szCheckClause[129];
	TCHAR   m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CCheckConstraintInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szCheckClause)
	COLUMN_ENTRY(5, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CCollationInfo

class CCollationInfo
{
public:
// Constructors
	CCollationInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szCharSetCatalog[129];
	TCHAR   m_szCharSetSchema[129];
	TCHAR   m_szCharSetName[129];
	TCHAR   m_szPadAttribute[10];

// Binding Maps
BEGIN_COLUMN_MAP(CCollationInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szCharSetCatalog)
	COLUMN_ENTRY(5, m_szCharSetSchema)
	COLUMN_ENTRY(6, m_szCharSetName)
	COLUMN_ENTRY(7, m_szPadAttribute)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CColumnDomainUsageInfo

class CColumnDomainUsageInfo
{
public:
// Constructor
	CColumnDomainUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_nColumnPropID;

// Binding Maps
BEGIN_COLUMN_MAP(CColumnDomainUsageInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szTableCatalog)
	COLUMN_ENTRY(5, m_szTableSchema)
	COLUMN_ENTRY(6, m_szTableName)
	COLUMN_ENTRY(7, m_szColumnName)
	COLUMN_ENTRY(8, m_guidColumn)
	COLUMN_ENTRY(9, m_nColumnPropID)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CColumnPrivilegeInfo

class CColumnPrivilegeInfo
{
public:
// Constructor
	CColumnPrivilegeInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szGrantor[129];
	TCHAR           m_szGrantee[129];
	TCHAR           m_szTableCatalog[129];
	TCHAR           m_szTableSchema[129];
	TCHAR           m_szTableName[129];
	TCHAR           m_szColumnName[129];
	GUID            m_guidColumn;
	ULONG           m_nColumnPropID;
	TCHAR           m_szPrivilegeType[20];
	VARIANT_BOOL    m_bIsGrantable;

// Binding Maps
BEGIN_COLUMN_MAP(CColumnPrivilegeInfo)
	COLUMN_ENTRY(1,  m_szGrantor)
	COLUMN_ENTRY(2,  m_szGrantee)
	COLUMN_ENTRY(3,  m_szTableCatalog)
	COLUMN_ENTRY(4,  m_szTableSchema)
	COLUMN_ENTRY(5,  m_szTableName)
	COLUMN_ENTRY(6,  m_szColumnName)
	COLUMN_ENTRY(7,  m_guidColumn)
	COLUMN_ENTRY(8,  m_nColumnPropID)
	COLUMN_ENTRY(9,  m_szPrivilegeType)
	COLUMN_ENTRY(10, m_bIsGrantable)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CColumnsInfo

class CColumnsInfo
{
public:
// Constructors and Destructors
	CColumnsInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Operations
	TCHAR           m_szTableCatalog[129];
	TCHAR           m_szTableSchema[129];
	TCHAR           m_szTableName[129];
	TCHAR           m_szColumnName[129];
	GUID            m_guidColumn;
	ULONG           m_nColumnPropID;
	ULONG           m_nOrdinalPosition;
	VARIANT_BOOL    m_bColumnHasDefault;
	TCHAR           m_szColumnDefault[129];
	ULONG           m_nColumnFlags;
	VARIANT_BOOL    m_bIsNullable;
	USHORT          m_nDataType;
	GUID            m_guidType;
	ULONG           m_nMaxLength;
	ULONG           m_nOctetLength;
	USHORT          m_nNumericPrecision;
	SHORT           m_nNumericScale;
	ULONG           m_nDateTimePrecision;
	TCHAR           m_szCharSetCatalog[129];
	TCHAR           m_szCharSetSchema[129];
	TCHAR           m_szCharSetName[129];
	TCHAR           m_szCollationCatalog[129];
	TCHAR           m_szCollationSchema[129];
	TCHAR           m_szCollationName[129];
	TCHAR           m_szDomainCatalog[129];
	TCHAR           m_szDomainSchema[129];
	TCHAR           m_szDomainName[129];
	TCHAR           m_szDescription[129];

BEGIN_COLUMN_MAP(CColumnsInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szColumnName)
	COLUMN_ENTRY(5, m_guidColumn)
	COLUMN_ENTRY(6, m_nColumnPropID)
	COLUMN_ENTRY(7, m_nOrdinalPosition)
	COLUMN_ENTRY(8, m_bColumnHasDefault)
	COLUMN_ENTRY(9, m_szColumnDefault)
	COLUMN_ENTRY(10, m_nColumnFlags)
	COLUMN_ENTRY(11, m_bIsNullable)
	COLUMN_ENTRY(12, m_nDataType)
	COLUMN_ENTRY(13, m_guidType)
	COLUMN_ENTRY(14, m_nMaxLength)
	COLUMN_ENTRY(15, m_nOctetLength)
	COLUMN_ENTRY(16, m_nNumericPrecision)
	COLUMN_ENTRY(17, m_nNumericScale)
	COLUMN_ENTRY(18, m_nDateTimePrecision)
	COLUMN_ENTRY(19, m_szCharSetCatalog)
	COLUMN_ENTRY(20, m_szCharSetSchema)
	COLUMN_ENTRY(21, m_szCharSetName)
	COLUMN_ENTRY(22, m_szCollationCatalog)
	COLUMN_ENTRY(23, m_szCollationSchema)
	COLUMN_ENTRY(24, m_szCollationName)
	COLUMN_ENTRY(25, m_szDomainCatalog)
	COLUMN_ENTRY(26, m_szDomainSchema)
	COLUMN_ENTRY(27, m_szDomainName)
	COLUMN_ENTRY(28, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CConstraintColumnUsageInfo

class CConstraintColumnUsageInfo
{
public:
// Constructor
	CConstraintColumnUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_nColumnPropID;
	TCHAR   m_szConstraintCatalog[129];
	TCHAR   m_szConstraintSchema[129];
	TCHAR   m_szConstraintName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CConstraintColumnUsageInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szColumnName)
	COLUMN_ENTRY(5, m_guidColumn)
	COLUMN_ENTRY(6, m_nColumnPropID)
	COLUMN_ENTRY(7, m_szConstraintCatalog)
	COLUMN_ENTRY(8, m_szConstraintSchema)
	COLUMN_ENTRY(9, m_szConstraintName)
END_COLUMN_MAP()
};

///////////////////////////////////////////////////////////////////////////
// class CConstraintColumnUsageInfo

class CConstraintTableUsageInfo
{
public:
// Constructor
	CConstraintTableUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szConstraintCatalog[129];
	TCHAR   m_szConstraintSchema[129];
	TCHAR   m_szConstraintName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CConstraintTableUsageInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szConstraintCatalog)
	COLUMN_ENTRY(5, m_szConstraintSchema)
	COLUMN_ENTRY(6, m_szConstraintName)
END_COLUMN_MAP()
};

///////////////////////////////////////////////////////////////////////////
// class CForeignKeysInfo

class CForeignKeysInfo
{
public:
// Constructor
	CForeignKeysInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szPKTableCatalog[129];
	TCHAR   m_szPKTableSchema[129];
	TCHAR   m_szPKTableName[129];
	TCHAR   m_szPKColumnName[129];
	GUID    m_guidPKColumn;
	ULONG   m_nPKColumnPropID;
	TCHAR   m_szFKTableCatalog[129];
	TCHAR   m_szFKTableSchema[129];
	TCHAR   m_szFKTableName[129];
	TCHAR   m_szFKColumnName[129];
	GUID    m_guidFKColumn;
	ULONG   m_nFKColumnPropID;
	ULONG   m_nOrdinal;
	TCHAR   m_szUpdateRule[12];
	TCHAR   m_szDeleteRule[12];

// Binding Info
BEGIN_COLUMN_MAP(CForeignKeysInfo)
	COLUMN_ENTRY(1, m_szPKTableCatalog)
	COLUMN_ENTRY(2, m_szPKTableSchema)
	COLUMN_ENTRY(3, m_szPKTableName)
	COLUMN_ENTRY(4, m_szPKColumnName)
	COLUMN_ENTRY(5, m_guidPKColumn)
	COLUMN_ENTRY(6, m_nPKColumnPropID)
	COLUMN_ENTRY(7, m_szFKTableCatalog)
	COLUMN_ENTRY(8, m_szFKTableSchema)
	COLUMN_ENTRY(9, m_szFKTableName)
	COLUMN_ENTRY(10, m_szFKColumnName)
	COLUMN_ENTRY(11, m_guidFKColumn)
	COLUMN_ENTRY(12, m_nFKColumnPropID)
	COLUMN_ENTRY(13, m_nOrdinal)
	COLUMN_ENTRY(14, m_szUpdateRule)
	COLUMN_ENTRY(15, m_szDeleteRule)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CIndexesInfo

class CIndexesInfo
{
public:
// Constructors
	CIndexesInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szTableCatalog[129];
	TCHAR           m_szTableSchema[129];
	TCHAR           m_szTableName[129];
	TCHAR           m_szIndexCatalog[129];
	TCHAR           m_szIndexSchema[129];
	TCHAR           m_szIndexName[129];
	VARIANT_BOOL    m_bPrimaryKey;
	VARIANT_BOOL    m_bUnique;
	VARIANT_BOOL    m_bClustered;
	USHORT          m_nType;
	LONG            m_nFillFactor;
	LONG            m_nInitialSize;
	LONG            m_nNulls;
	VARIANT_BOOL    m_bSortBookmarks;
	VARIANT_BOOL    m_bAutoUpdate;
	LONG            m_nNullCollation;
	ULONG           m_nOrdinalPosition;
	TCHAR           m_szColumnName[129];
	GUID            m_guidColumn;
	ULONG           m_nColumnPropID;
	SHORT           m_nCollation;
	LONG            m_nCardinality;
	LONG            m_nPages;
	TCHAR           m_szFilterCondition[129];

// Binding Maps
BEGIN_COLUMN_MAP(CIndexesInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szIndexCatalog)
	COLUMN_ENTRY(5, m_szIndexSchema)
	COLUMN_ENTRY(6, m_szIndexName)
	COLUMN_ENTRY(7, m_bPrimaryKey)
	COLUMN_ENTRY(8, m_bUnique)
	COLUMN_ENTRY(9, m_bClustered)
	COLUMN_ENTRY(10, m_nType)
	COLUMN_ENTRY(11, m_nFillFactor)
	COLUMN_ENTRY(12, m_nInitialSize)
	COLUMN_ENTRY(13, m_nNulls)
	COLUMN_ENTRY(14, m_bSortBookmarks)
	COLUMN_ENTRY(15, m_bAutoUpdate)
	COLUMN_ENTRY(16, m_nNullCollation)
	COLUMN_ENTRY(17, m_nOrdinalPosition)
	COLUMN_ENTRY(18, m_szColumnName)
	COLUMN_ENTRY(19, m_guidColumn)
	COLUMN_ENTRY(20, m_nColumnPropID)
	COLUMN_ENTRY(21, m_nCollation)
	COLUMN_ENTRY(22, m_nCardinality)
	COLUMN_ENTRY(23, m_nPages)
	COLUMN_ENTRY(25, m_szFilterCondition)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CKeyColumnUsageInfo

class CKeyColumnUsageInfo
{
public:
// Constructors
	CKeyColumnUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szConstraintCatalog[129];
	TCHAR   m_szConstraintSchema[129];
	TCHAR   m_szConstraintName[129];
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_nColumnPropID;
	ULONG   m_nOrdinalPosition;

// Binding Maps
BEGIN_COLUMN_MAP(CKeyColumnUsageInfo)
	COLUMN_ENTRY(1,  m_szConstraintCatalog)
	COLUMN_ENTRY(2,  m_szConstraintSchema)
	COLUMN_ENTRY(3,  m_szConstraintName)
	COLUMN_ENTRY(4,  m_szTableCatalog)
	COLUMN_ENTRY(5,  m_szTableSchema)
	COLUMN_ENTRY(6,  m_szTableName)
	COLUMN_ENTRY(7,  m_szColumnName)
	COLUMN_ENTRY(8,  m_guidColumn)
	COLUMN_ENTRY(9,  m_nColumnPropID)
	COLUMN_ENTRY(10, m_nOrdinalPosition)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CPrimaryKeyInfo

class CPrimaryKeyInfo
{
public:
// Constructors
	CPrimaryKeyInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_nColumnPropID;
	ULONG   m_nOrdinal;

// Binding Maps
BEGIN_COLUMN_MAP(CPrimaryKeyInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szColumnName)
	COLUMN_ENTRY(5, m_guidColumn)
	COLUMN_ENTRY(6, m_nColumnPropID)
	COLUMN_ENTRY(7, m_nOrdinal)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProcedureColumnInfo

class CProcedureColumnInfo
{
public:
// Constructors
	CProcedureColumnInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	TCHAR           m_szColumnName[129];
	GUID            m_guidColumn;
	ULONG           m_nColumnPropID;
	ULONG           m_nRowsetNumber;
	ULONG           m_nOrdinalPosition;
	VARIANT_BOOL    m_bIsNullable;
	USHORT          m_nDataType;
	GUID            m_guidType;
	ULONG           m_nMaxLength;
	ULONG           m_nOctetLength;
	USHORT          m_nPrecision;
	SHORT           m_nScale;
	TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CProcedureColumnInfo)
	COLUMN_ENTRY(1,  m_szCatalog)
	COLUMN_ENTRY(2,  m_szSchema)
	COLUMN_ENTRY(3,  m_szName)
	COLUMN_ENTRY(4,  m_szColumnName)
	COLUMN_ENTRY(5,  m_guidColumn)
	COLUMN_ENTRY(6,  m_nColumnPropID)
	COLUMN_ENTRY(7,  m_nRowsetNumber)
	COLUMN_ENTRY(8,  m_nOrdinalPosition)
	COLUMN_ENTRY(9,  m_bIsNullable)
	COLUMN_ENTRY(10, m_nDataType)
	COLUMN_ENTRY(11, m_guidType)
	COLUMN_ENTRY(12, m_nMaxLength)
	COLUMN_ENTRY(13, m_nOctetLength)
	COLUMN_ENTRY(14, m_nPrecision)
	COLUMN_ENTRY(15, m_nScale)
	COLUMN_ENTRY(16, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProcedureParameterInfo

class CProcedureParameterInfo
{
public:
// Constructors
	CProcedureParameterInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	TCHAR           m_szParameterName[129];
	USHORT          m_nOrdinalPosition;
	USHORT          m_nType;
	VARIANT_BOOL    m_bHasDefault;
	TCHAR           m_szDefault[129];
	VARIANT_BOOL    m_bIsNullable;
	USHORT          m_nDataType;
	ULONG           m_nMaxLength;
	ULONG           m_nOctetLength;
	USHORT          m_nPrecision;
	SHORT           m_nScale;
	TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CProcedureParameterInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szParameterName)
	COLUMN_ENTRY(5, m_nOrdinalPosition)
	COLUMN_ENTRY(6, m_nType)
	COLUMN_ENTRY(7, m_bHasDefault)
	COLUMN_ENTRY(8, m_szDefault)
	COLUMN_ENTRY(9, m_bIsNullable)
	COLUMN_ENTRY(10, m_nDataType)
	COLUMN_ENTRY(11, m_nMaxLength)
	COLUMN_ENTRY(12, m_nOctetLength)
	COLUMN_ENTRY(13, m_nPrecision)
	COLUMN_ENTRY(14, m_nScale)
	COLUMN_ENTRY(15, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProcedureInfo

class CProcedureInfo
{
public:
// Constructors
	CProcedureInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	SHORT   m_nType;
	TCHAR   m_szDefinition[129];
	TCHAR   m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CProcedureInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_nType)
	COLUMN_ENTRY(5, m_szDefinition)
	COLUMN_ENTRY(6, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CProviderTypeInfo

class CProviderTypeInfo
{
public:
// Constructors
	CProviderTypeInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szTypeName[129];
	USHORT          m_nDataType;
	ULONG           m_nColumnSize;
	TCHAR           m_szLiteralPrefix[129];
	TCHAR           m_szLiteralSuffix[129];
	TCHAR           m_szCreateParams[129];
	VARIANT_BOOL    m_bIsNullable;
	VARIANT_BOOL    m_bCaseSensitive;
	ULONG           m_nSearchable;
	VARIANT_BOOL    m_bUnsignedAttribute;
	VARIANT_BOOL    m_bFixedPrecScale;
	VARIANT_BOOL    m_bAutoUniqueValue;
	TCHAR           m_szLocalTypeName[129];
	SHORT           m_nMinScale;
	SHORT           m_nMaxScale;
	GUID            m_guidType;
	TCHAR           m_szTypeLib[129];
	TCHAR           m_szVersion[129];
	VARIANT_BOOL    m_bIsLong;
	VARIANT_BOOL    m_bBestMatch;
	VARIANT_BOOL    m_bIsFixedLength;

// Binding Maps
BEGIN_COLUMN_MAP(CProviderTypeInfo)
	COLUMN_ENTRY(1, m_szTypeName)
	COLUMN_ENTRY(2, m_nDataType)
	COLUMN_ENTRY(3, m_nColumnSize)
	COLUMN_ENTRY(4, m_szLiteralPrefix)
	COLUMN_ENTRY(5, m_szLiteralSuffix)
	COLUMN_ENTRY(6, m_szCreateParams)
	COLUMN_ENTRY(7, m_bIsNullable)
	COLUMN_ENTRY(8, m_bCaseSensitive)
	COLUMN_ENTRY(9, m_nSearchable)
	COLUMN_ENTRY(10, m_bUnsignedAttribute)
	COLUMN_ENTRY(11, m_bFixedPrecScale)
	COLUMN_ENTRY(12, m_bAutoUniqueValue)
	COLUMN_ENTRY(13, m_szLocalTypeName)
	COLUMN_ENTRY(14, m_nMinScale)
	COLUMN_ENTRY(15, m_nMaxScale)
	COLUMN_ENTRY(16, m_guidType)
	COLUMN_ENTRY(17, m_szTypeLib)
	COLUMN_ENTRY(18, m_szVersion)
	COLUMN_ENTRY(19, m_bIsLong)
	COLUMN_ENTRY(20, m_bBestMatch)
	COLUMN_ENTRY(21, m_bIsFixedLength)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CReferentialConstraintInfo

class CReferentialConstraintInfo
{
public:
// Constructors
	CReferentialConstraintInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szUniqueCatalog[129];
	TCHAR   m_szUniqueSchema[129];
	TCHAR   m_szUniqueName[129];
	TCHAR   m_szMatchOption[8];
	TCHAR   m_szUpdateRule[12];
	TCHAR   m_szDeleteRule[12];
	TCHAR   m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CReferentialConstraintInfo)
	COLUMN_ENTRY(1,  m_szCatalog)
	COLUMN_ENTRY(2,  m_szSchema)
	COLUMN_ENTRY(3,  m_szName)
	COLUMN_ENTRY(4,  m_szUniqueCatalog)
	COLUMN_ENTRY(5,  m_szUniqueSchema)
	COLUMN_ENTRY(6,  m_szUniqueName)
	COLUMN_ENTRY(7,  m_szMatchOption)
	COLUMN_ENTRY(8,  m_szUpdateRule)
	COLUMN_ENTRY(9,  m_szDeleteRule)
	COLUMN_ENTRY(10, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CSchemataInfo

class CSchemataInfo
{
public:
// Constructors
	CSchemataInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szName[129];
	TCHAR   m_szOwner[129];
	TCHAR   m_szCharCatalog[129];
	TCHAR   m_szCharSchema[129];
	TCHAR   m_szCharName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CSchemataInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szName)
	COLUMN_ENTRY(3, m_szOwner)
	COLUMN_ENTRY(4, m_szCharCatalog)
	COLUMN_ENTRY(5, m_szCharSchema)
	COLUMN_ENTRY(6, m_szCharName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CSQLLangugageInfo

class CSQLLanguageInfo
{
public:
// Constructors
	CSQLLanguageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szSource[10];
	TCHAR   m_szYear[5];
	TCHAR   m_szConformance[13];
	TCHAR   m_szIntegrity[4];
	TCHAR   m_szImplementation[24];
	TCHAR   m_szBindingStyle[10];
	TCHAR   m_szProgrammingLanguage[10];

// Binding Maps
BEGIN_COLUMN_MAP(CSQLLanguageInfo)
	COLUMN_ENTRY(1, m_szSource)
	COLUMN_ENTRY(2, m_szYear)
	COLUMN_ENTRY(3, m_szConformance)
	COLUMN_ENTRY(4, m_szIntegrity)
	COLUMN_ENTRY(5, m_szImplementation)
	COLUMN_ENTRY(6, m_szBindingStyle)
	COLUMN_ENTRY(7, m_szProgrammingLanguage)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CStatisticInfo

class CStatisticInfo
{
public:
// Constructors
	CStatisticInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	LONG    m_nCardinality;

// Binding Maps
BEGIN_COLUMN_MAP(CStatisticInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_nCardinality)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CTableConstraintInfo

class CTableConstraintInfo
{
public:
// Constructors
	CTableConstraintInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	TCHAR           m_szTableCatalog[129];
	TCHAR           m_szTableSchema[129];
	TCHAR           m_szTableName[129];
	TCHAR           m_szType[12];
	VARIANT_BOOL    m_bIsDeferrable;
	VARIANT_BOOL    m_bInitiallyDeferred;
	TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CTableConstraintInfo)
	COLUMN_ENTRY(1,  m_szCatalog)
	COLUMN_ENTRY(2,  m_szSchema)
	COLUMN_ENTRY(3,  m_szName)
	COLUMN_ENTRY(4,  m_szTableCatalog)
	COLUMN_ENTRY(5,  m_szTableSchema)
	COLUMN_ENTRY(6,  m_szTableName)
	COLUMN_ENTRY(7,  m_szType)
	COLUMN_ENTRY(8,  m_bIsDeferrable)
	COLUMN_ENTRY(9,  m_bInitiallyDeferred)
	COLUMN_ENTRY(10, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CTablePrivilegeInfo

class CTablePrivilegeInfo
{
public:
// Constructors
	CTablePrivilegeInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szGrantor[129];
	TCHAR           m_szGrantee[129];
	TCHAR           m_szCatalog[129];
	TCHAR           m_szSchema[129];
	TCHAR           m_szName[129];
	TCHAR           m_szType[12];
	VARIANT_BOOL    m_bIsGrantable;

// Binding Maps
BEGIN_COLUMN_MAP(CTablePrivilegeInfo)
	COLUMN_ENTRY(1, m_szGrantor)
	COLUMN_ENTRY(2, m_szGrantee)
	COLUMN_ENTRY(3, m_szCatalog)
	COLUMN_ENTRY(4, m_szSchema)
	COLUMN_ENTRY(5, m_szName)
	COLUMN_ENTRY(6, m_szType)
	COLUMN_ENTRY(7, m_bIsGrantable)
END_COLUMN_MAP()
};



///////////////////////////////////////////////////////////////////////////
// class CTableInfo

class CTableInfo
{
public:
// Constructors
	CTableInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szType[129];
	GUID    m_guidTable;
	TCHAR   m_szDescription[129];


// Binding Map
BEGIN_COLUMN_MAP(CTableInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szType)
	COLUMN_ENTRY(5, m_guidTable)
	COLUMN_ENTRY(6, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CTranslationInfo

class CTranslationInfo
{
public:
// Constructors
	CTranslationInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szSourceCatalog[129];
	TCHAR   m_szSourceSchema[129];
	TCHAR   m_szSourceName[129];
	TCHAR   m_szTargetCatalog[129];
	TCHAR   m_szTargetSchema[129];
	TCHAR   m_szTargetName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CTranslationInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szSourceCatalog)
	COLUMN_ENTRY(5, m_szSourceSchema)
	COLUMN_ENTRY(6, m_szSourceName)
	COLUMN_ENTRY(7, m_szTargetCatalog)
	COLUMN_ENTRY(8, m_szTargetSchema)
	COLUMN_ENTRY(9, m_szTargetName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CUsagePrivilegeInfo

class CUsagePrivilegeInfo
{
public:
// Constructors
	CUsagePrivilegeInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szGrantor[129];
	TCHAR   m_szGrantee[129];
	TCHAR   m_szObjectCatalog[129];
	TCHAR   m_szObjectSchema[129];
	TCHAR   m_szObjectName[129];
	TCHAR   m_szObjectType[12];
	TCHAR   m_szPrivilegeType[6];
	VARIANT_BOOL    m_bIsGrantable;

// Binding Maps
BEGIN_COLUMN_MAP(CUsagePrivilegeInfo)
	COLUMN_ENTRY(1, m_szGrantor)
	COLUMN_ENTRY(2, m_szGrantee)
	COLUMN_ENTRY(3, m_szObjectCatalog)
	COLUMN_ENTRY(4, m_szObjectSchema)
	COLUMN_ENTRY(5, m_szObjectName)
	COLUMN_ENTRY(6, m_szObjectType)
	COLUMN_ENTRY(7, m_szPrivilegeType)
	COLUMN_ENTRY(8, m_bIsGrantable)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CViewColumnUsageInfo

class CViewColumnUsageInfo
{
public:
// Constructors
	CViewColumnUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];
	TCHAR   m_szColumnName[129];
	GUID    m_guidColumn;
	ULONG   m_nColumnPropID;

// Binding Maps
BEGIN_COLUMN_MAP(CViewColumnUsageInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szTableCatalog)
	COLUMN_ENTRY(5, m_szTableSchema)
	COLUMN_ENTRY(6, m_szTableName)
	COLUMN_ENTRY(7, m_szColumnName)
	COLUMN_ENTRY(8, m_guidColumn)
	COLUMN_ENTRY(9, m_nColumnPropID)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CViewTableUsageInfo

class CViewTableUsageInfo
{
public:
// Constructors
	CViewTableUsageInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR   m_szCatalog[129];
	TCHAR   m_szSchema[129];
	TCHAR   m_szName[129];
	TCHAR   m_szTableCatalog[129];
	TCHAR   m_szTableSchema[129];
	TCHAR   m_szTableName[129];

// Binding Maps
BEGIN_COLUMN_MAP(CViewTableUsageInfo)
	COLUMN_ENTRY(1, m_szCatalog)
	COLUMN_ENTRY(2, m_szSchema)
	COLUMN_ENTRY(3, m_szName)
	COLUMN_ENTRY(4, m_szTableCatalog)
	COLUMN_ENTRY(5, m_szTableSchema)
	COLUMN_ENTRY(6, m_szTableName)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// class CViewInfo

class CViewInfo
{
public:
// Constructors
	CViewInfo()
	{
		memset(this, 0, sizeof(*this));
	}

// Attributes
	TCHAR           m_szTableCatalog[129];
	TCHAR           m_szTableSchema[129];
	TCHAR           m_szTableName[129];
	TCHAR           m_szDefinition[129];
	VARIANT_BOOL    m_bCheckOption;
	VARIANT_BOOL    m_bIsUpdatable;
	TCHAR           m_szDescription[129];

// Binding Maps
BEGIN_COLUMN_MAP(CViewInfo)
	COLUMN_ENTRY(1, m_szTableCatalog)
	COLUMN_ENTRY(2, m_szTableSchema)
	COLUMN_ENTRY(3, m_szTableName)
	COLUMN_ENTRY(4, m_szDefinition)
	COLUMN_ENTRY(5, m_bCheckOption)
	COLUMN_ENTRY(6, m_bIsUpdatable)
	COLUMN_ENTRY(7, m_szDescription)
END_COLUMN_MAP()
};


///////////////////////////////////////////////////////////////////////////
// typedefs

typedef CRestrictions<CAccessor<CAssertionInfo>,            3, &DBSCHEMA_ASSERTIONS>                CAssertions;
typedef CRestrictions<CAccessor<CCatalogInfo>,              1, &DBSCHEMA_CATALOGS >                 CCatalogs;
typedef CRestrictions<CAccessor<CCharacterSetInfo>,         3, &DBSCHEMA_CHARACTER_SETS>            CCharacterSets;
typedef CRestrictions<CAccessor<CCheckConstraintInfo>,      3, &DBSCHEMA_CHECK_CONSTRAINTS>         CCheckConstraints;
typedef CRestrictions<CAccessor<CCollationInfo>,            3, &DBSCHEMA_COLLATIONS>                CCollations;
typedef CRestrictions<CAccessor<CColumnDomainUsageInfo>,    4, &DBSCHEMA_COLUMN_DOMAIN_USAGE>       CColumnDomainUsage;
typedef CRestrictions<CAccessor<CColumnPrivilegeInfo>,      6, &DBSCHEMA_COLUMN_PRIVILEGES>         CColumnPrivileges;
typedef CRestrictions<CAccessor<CColumnsInfo>,              4, &DBSCHEMA_COLUMNS>                   CColumns;
typedef CRestrictions<CAccessor<CConstraintColumnUsageInfo>,4, &DBSCHEMA_CONSTRAINT_COLUMN_USAGE>   CConstraintColumnUsage;
typedef CRestrictions<CAccessor<CConstraintTableUsageInfo>, 3, &DBSCHEMA_CONSTRAINT_TABLE_USAGE>    CConstraintTableUsage;
typedef CRestrictions<CAccessor<CForeignKeysInfo>,          6, &DBSCHEMA_FOREIGN_KEYS>              CForeignKeys;
typedef CRestrictions<CAccessor<CIndexesInfo>,              5, &DBSCHEMA_INDEXES>                   CIndexes;
typedef CRestrictions<CAccessor<CKeyColumnUsageInfo>,       7, &DBSCHEMA_KEY_COLUMN_USAGE>          CKeyColumnUsage;
typedef CRestrictions<CAccessor<CPrimaryKeyInfo>,           3, &DBSCHEMA_PRIMARY_KEYS>              CPrimaryKeys;
typedef CRestrictions<CAccessor<CProcedureColumnInfo>,      4, &DBSCHEMA_PROCEDURE_COLUMNS>         CProcedureColumns;
typedef CRestrictions<CAccessor<CProcedureParameterInfo>,   4, &DBSCHEMA_PROCEDURE_PARAMETERS>      CProcedureParameters;
typedef CRestrictions<CAccessor<CProcedureInfo>,            4, &DBSCHEMA_PROCEDURES>                CProcedures;
typedef CRestrictions<CAccessor<CProviderTypeInfo>,         2, &DBSCHEMA_PROVIDER_TYPES>            CProviderTypes;
typedef CRestrictions<CAccessor<CReferentialConstraintInfo>,3, &DBSCHEMA_REFERENTIAL_CONSTRAINTS>   CReferentialConstraints;
typedef CRestrictions<CAccessor<CSchemataInfo>,             3, &DBSCHEMA_SCHEMATA>                  CSchemata;
typedef CRestrictions<CAccessor<CSQLLanguageInfo>,          0, &DBSCHEMA_SQL_LANGUAGES>             CSQLLanguages;
typedef CRestrictions<CAccessor<CStatisticInfo>,            3, &DBSCHEMA_STATISTICS>                CStatistics ;
typedef CRestrictions<CAccessor<CTableConstraintInfo>,      7, &DBSCHEMA_TABLE_CONSTRAINTS>         CTableConstraints;
typedef CRestrictions<CAccessor<CTablePrivilegeInfo>,       5, &DBSCHEMA_TABLE_PRIVILEGES>          CTablePrivileges;
typedef CRestrictions<CAccessor<CTableInfo>,                4, &DBSCHEMA_TABLES>                    CTables;
typedef CRestrictions<CAccessor<CTranslationInfo>,          3, &DBSCHEMA_TRANSLATIONS>              CTranslations;
typedef CRestrictions<CAccessor<CUsagePrivilegeInfo>,       6, &DBSCHEMA_USAGE_PRIVILEGES>          CUsagePrivileges;
typedef CRestrictions<CAccessor<CViewColumnUsageInfo>,      3, &DBSCHEMA_VIEW_COLUMN_USAGE>         CViewColumnUsage;
typedef CRestrictions<CAccessor<CViewTableUsageInfo>,       3, &DBSCHEMA_VIEW_TABLE_USAGE>          CViewTableUsage;
typedef CRestrictions<CAccessor<CViewInfo>,                 3, &DBSCHEMA_VIEWS>                     CViews;

///////////////////////////////////////////////////////////////////////////

}; //namespace ATL

#pragma pack(pop)
#endif // __ATLDBSCH_H__

///////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atldebugapi.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.


#ifndef __ATLDEBUGAPI_H__
#define __ATLDEBUGAPI_H__

#pragma once

#ifdef __cplusplus

#pragma pack(push,_ATL_PACKING)
namespace ATL
{
extern "C" {
#endif
#define ATL_TRACE_MAX_NAME_SIZE 64

typedef enum ATLTRACESTATUS
{
	ATLTRACESTATUS_INHERIT, ATLTRACESTATUS_ENABLED, ATLTRACESTATUS_DISABLED
} ATLTRACESTATUS;

DWORD_PTR __stdcall AtlTraceOpenProcess( DWORD idProcess );
void __stdcall AtlTraceCloseProcess( DWORD_PTR dwProcess );
void __stdcall AtlTraceSnapshotProcess( DWORD_PTR dwProcess );

DWORD_PTR __stdcall AtlTraceRegister(HINSTANCE hInst,
#ifndef _WIN32_WCE
	int (__cdecl *fnCrtDbgReport)(int,const char *,int,const char *,const char *,...));
#else // _WIN32_WCE
	int (__cdecl *fnCrtDbgReport)(int,const wchar_t *,int,const wchar_t *,const wchar_t *,...));
#endif // _WIN32_WCE
BOOL __stdcall AtlTraceUnregister(DWORD_PTR dwModule);

#ifndef _WIN32_WCE
DWORD_PTR __stdcall AtlTraceRegisterCategoryA(DWORD_PTR dwModule, const CHAR szCategoryName[ATL_TRACE_MAX_NAME_SIZE]);
#endif // _WIN32_WCE
DWORD_PTR __stdcall AtlTraceRegisterCategoryU(DWORD_PTR dwModule, const WCHAR szCategoryName[ATL_TRACE_MAX_NAME_SIZE]);

BOOL __stdcall AtlTraceModifyProcess(DWORD_PTR dwProcess, UINT nLevel, BOOL bEnabled, BOOL bFuncAndCategoryNames, BOOL bFileNameAndLineNo);
BOOL __stdcall AtlTraceModifyModule(DWORD_PTR dwProcess, DWORD_PTR dwModule, UINT nLevel, ATLTRACESTATUS eStatus);
BOOL __stdcall AtlTraceModifyCategory(DWORD_PTR dwProcess, DWORD_PTR dwCategory, UINT nLevel, ATLTRACESTATUS eStatus);
BOOL __stdcall AtlTraceGetProcess(DWORD_PTR dwProcess, UINT *pnLevel, BOOL *pbEnabled, BOOL *pbFuncAndCategoryNames, BOOL *pbFileNameAndLineNo);
BOOL __stdcall AtlTraceGetModule(DWORD_PTR dwProcess, DWORD_PTR dwModule, UINT *pnLevel, ATLTRACESTATUS *pStatus);
BOOL __stdcall AtlTraceGetCategory(DWORD_PTR dwProcess, DWORD_PTR dwCategory, UINT *pnLevel, ATLTRACESTATUS *pStatus);

_ATL_INSECURE_DEPRECATE("AtlTraceGetUpdateEventNameA is unsafe. Instead use AtlTraceGetUpdateEventNameA_s") 
void __stdcall AtlTraceGetUpdateEventNameA(__out_z CHAR *pszEventName);
_ATL_INSECURE_DEPRECATE("AtlTraceGetUpdateEventNameU is unsafe. Instead use AtlTraceGetUpdateEventNameU_s") 
void __stdcall AtlTraceGetUpdateEventNameU(__out_z WCHAR *pszEventName);

void __stdcall AtlTraceGetUpdateEventNameA_s(__out_ecount_z(cchEventName) CHAR *pszEventName, __in size_t cchEventName);
void __stdcall AtlTraceGetUpdateEventNameU_s(__out_ecount_z(cchEventName) WCHAR *pszEventName, __in size_t cchEventName);


#ifndef _WIN32_WCE
void __cdecl AtlTraceVA(DWORD_PTR dwModule, const char *pszFileName, int nLineNo,
						DWORD_PTR dwCategory, UINT nLevel, const CHAR *pszFormat, va_list ptr);
#endif // _WIN32_WCE
void __cdecl AtlTraceVU(DWORD_PTR dwModule,const char *pszFileName, int nLineNo,
						DWORD_PTR dwCategory, UINT nLevel, const WCHAR *pszFormat, va_list ptr);

#ifndef _WIN32_WCE
BOOL __stdcall AtlTraceLoadSettingsA(const CHAR *pszFileName, DWORD_PTR dwProcess = 0);
BOOL __stdcall AtlTraceLoadSettingsU(const WCHAR *pszFileName, DWORD_PTR dwProcess = 0);
BOOL __stdcall AtlTraceSaveSettingsA(const CHAR *pszFileName, DWORD_PTR dwProcess = 0);
BOOL __stdcall AtlTraceSaveSettingsU(const WCHAR *pszFileName, DWORD_PTR dwProcess = 0);
#endif // _WIN32_WCE

typedef struct ATLTRACESETTINGS
{
	UINT nLevel;
	ATLTRACESTATUS eStatus;
} ATLTRACESETTINGS;

typedef struct ATLTRACEPROCESSSETTINGS
{
	UINT nLevel;
	BOOL bEnabled, bFuncAndCategoryNames, bFileNameAndLineNo;
} ATLTRACEPROCESSSETTINGS;

typedef struct ATLTRACEPROCESSINFO
{
	WCHAR szName[ATL_TRACE_MAX_NAME_SIZE], szPath[MAX_PATH];
	DWORD dwId;
	ATLTRACEPROCESSSETTINGS settings;
	int nModules;
} ATLTRACEPROCESSINFO;

typedef struct ATLTRACEMODULEINFO
{
	WCHAR szName[ATL_TRACE_MAX_NAME_SIZE], szPath[MAX_PATH];
	ATLTRACESETTINGS settings;
	DWORD_PTR dwModule;
	int nCategories;
} ATLTRACEMODULEINFO;

typedef struct ATLTRACECATEGORYINFO
{
	WCHAR szName[ATL_TRACE_MAX_NAME_SIZE];
	ATLTRACESETTINGS settings;
	DWORD_PTR dwCategory;
} ATLTRACECATEGORYINFO;

BOOL __stdcall AtlTraceGetProcessInfo(DWORD_PTR dwProcess, ATLTRACEPROCESSINFO* pProcessInfo);
void __stdcall AtlTraceGetModuleInfo(DWORD_PTR dwProcess, int iModule, ATLTRACEMODULEINFO* pModuleInfo);
void __stdcall AtlTraceGetCategoryInfo(DWORD_PTR dwProcess, DWORD_PTR dwModule, int iCategory, ATLTRACECATEGORYINFO* pAtlTraceCategoryInfo);

#ifdef UNICODE
#define AtlTraceRegisterCategory AtlTraceRegisterCategoryU
#define AtlTraceGetUpdateEventName AtlTraceGetUpdateEventNameU
#define AtlTraceGetUpdateEventName_s AtlTraceGetUpdateEventNameU_s
#define AtlTrace AtlTraceU
#define AtlTraceV AtlTraceVU
#define AtlTraceLoadSettings AtlTraceLoadSettingsU
#define AtlTraceSaveSettings AtlTraceSaveSettingsU

#else
#define AtlTraceRegisterCategory AtlTraceRegisterCategoryA
#define AtlTraceGetUpdateEventName AtlTraceGetUpdateEventNameA
#define AtlTraceGetUpdateEventName_s AtlTraceGetUpdateEventNameA_s
#define AtlTrace AtlTraceA
#define AtlTraceV AtlTraceVA
#define AtlTraceLoadSettings AtlTraceLoadSettingsA
#define AtlTraceSaveSettings AtlTraceSaveSettingsA

#endif

#ifdef __cplusplus
};

};  // namespace ATL
#pragma pack(pop)
#endif

#endif  // __ATLDEBUGAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atldef.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLDEF_H__
#define __ATLDEF_H__

#pragma once

#pragma warning(disable : 4619)	// there is no warning number

#ifdef _WIN32_WCE
#include <atldefce.h>
#endif

#include <atlrc.h>
#ifndef _WIN32_WCE
#include <errno.h>
#include <sal.h>
#endif

#ifndef RC_INVOKED

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef _WIN32_WCE // Win CE has no managed C++ support

// If you are mixing compilation units that are built as
// native code with those that are built /clr, you must define
// the symbol '_ATL_MIXED'. _ATL_MIXED must be defined for all 
// compilation units in an executable or it must be defined for none of them.
#if !defined(_ATL_MIXED)
namespace Inconsistent_definition_of_symbol__ATL_MIXED
{
	struct _Please_define_it_the_same_throughout_your_project { };
}
#else
namespace Inconsistent_definition_of_symbol__ATL_MIXED
{
#ifdef _M_IX86
#pragma comment(linker, "/include:??3@YAXPAX@Z")
#else
#pragma comment(linker, "/include:??3@YAXPEAX@Z")
#endif
	struct _Please_define_it_the_same_throughout_your_project { virtual void one(){} };
}
#endif
namespace Inconsistent_definition_of_symbol__ATL_MIXED
{
	__declspec(selectany) _Please_define_it_the_same_throughout_your_project clash = _Please_define_it_the_same_throughout_your_project ();
}

#if !defined(_ATL_MIXED)
namespace Define_the_symbol__ATL_MIXED
{
#if defined(_M_CEE)
	struct Thank_you { };
#else
#ifdef _M_IX86
#pragma comment(linker, "/include:??3@YAXPAX@Z")
#else
#pragma comment(linker, "/include:??3@YAXPEAX@Z")
#endif
	struct Thank_you { virtual void one(){} };
#endif
	__declspec(selectany) Thank_you clash = Thank_you();
}
#endif
#endif // _WIN32_WCE

#if defined(_ATL_MIXED)
#define _ATL_NATIVE_INITIALIZATION
#endif

#if !defined(_M_CEE)
#define _ATL_NATIVE_INITIALIZATION
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifdef _WIN64
#define _ATL_SUPPORT_VT_I8  // Always support VT_I8 on Win64.
#endif

#if !defined(UNALIGNED)
#if defined(_M_IA64) || defined(_M_AMD64) || defined(_M_ARM) || defined(_M_MRX000) || defined(_M_SH)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif
#endif

#if !defined(_countof)
#if !defined(__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else
extern "C++"
{
template <typename _CountofType, size_t _SizeOfArray>
char (*__countof_helper(UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
#define _countof(_Array) sizeof(*__countof_helper(_Array))
}
#endif
#endif

#ifndef AtlThrow
#ifndef _ATL_CUSTOM_THROW
#define AtlThrow ATL::AtlThrowImpl
#endif
#endif // AtlThrow

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif // ATLASSERT

/* 
Why does ATLASSUME exist?

ATL 8 has two existing validation models

ATLASSERT/ATLVERIFY - These are used to make sure a debug build reports a problem with the expression/invariant
ATLENSURE - Debug is the same as ATLVERIFY, retail throws a C++ exception

We added ATLENSURE because there were too many unreported error paths in ATL and we wanted to bail out of more
error conditions rather than just trying to continue in retail.

There might be a case for changing 'lots' of ATLASSERT to ATLENSURE, but we chose an incremental approach and only
changed over where we saw a problem with code reported from a customer or test case. This reduces code churn in our
code for this version.

In general, our approach is to try to make sure that when something goes wrong
- the client does not continue to run, because we report an error condition
- debug builds see an assertion about the problem

Sometimes we have code like

HRESULT ComMethod(void)
{
	ATLASSUME(m_pFoo);
	return m_pFoo->Method();
}

We could add
	if(!m_pFoo) return E_POINTER;

But this is very unlikely to help, since it removes the ability of the developer to debug this problem if it's seen in a retail
build of the application. 

We could try something more severe

	if(!m_pFoo) terminate(); // or your favourite shutdown function

This would ensure good reporting (because VC8 terminate generates a Windows Error Report and crash dump), but hardly seems a big win 
over the previous crash.

ATLENSURE might seem slightly better. It is debuggable and consistent with ATL in general. In fact, many parts of ATL do just this. 
But in this specific context, it doesn't look like a great choice. COM methods should not in general be emitting native C++ exceptions 
as an error reporting strategy. 

So we find ourselves in a quandry. For these kinds of methods, the traditional code (ATLASSERT followed by a crash), seems be the most 
debuggable thing to do in this situation. At least for VS8, we have decided to stick with this shape.

---

Now consider the impact of cl /analyze. We want cl /analyze to not warn about our potential dereferences when they refer to member variables
whose state was previously validated by another method. But we do want to see the impact of function contracts on the parameters of the
function. 

So we've done a broad replace of all the member-related ATLASSERT to ATLASSUME. 

*/

#ifndef ATLASSUME
#define ATLASSUME(expr) do { ATLASSERT(expr); __analysis_assume(!!(expr)); } while(0)
#endif // ATLASSERT

#ifndef ATLVERIFY
#ifdef _DEBUG
#define ATLVERIFY(expr) ATLASSERT(expr)
#else
#define ATLVERIFY(expr) (expr)
#endif // DEBUG
#endif // ATLVERIFY

#ifndef ATLENSURE_THROW
#define ATLENSURE_THROW(expr, hr)          \
do {                                       \
	int __atl_condVal=!!(expr);            \
	ATLASSERT(__atl_condVal);              \
	if(!(__atl_condVal)) AtlThrow(hr);     \
} while (0)
#endif // ATLENSURE

#ifndef ATLENSURE
#define ATLENSURE(expr) ATLENSURE_THROW(expr, E_FAIL)
#endif // ATLENSURE

#ifndef ATLENSURE_SUCCEEDED
#define ATLENSURE_SUCCEEDED(hr) ATLENSURE_THROW(SUCCEEDED(hr), hr)
#endif // ATLENSURE

/* Used inside COM methods that do not want to throw */
#ifndef ATLENSURE_RETURN_HR
#define ATLENSURE_RETURN_HR(expr, hr)          \
do {                                           \
	int __atl_condVal=!!(expr);                \
	ATLASSERT(__atl_condVal);                  \
	if(!(__atl_condVal)) return hr;            \
} while (0) 
#endif 

/* Used inside COM methods that do not want to throw */
#ifndef ATLENSURE_RETURN
#define ATLENSURE_RETURN(expr) ATLENSURE_RETURN_HR(expr, E_FAIL)
#endif 

#ifndef _SECURE_ATL
#define _SECURE_ATL 1
#endif // _SECURE_ATL

#if _SECURE_ATL

#ifndef ATL_CRT_ERRORCHECK
#define ATL_CRT_ERRORCHECK(expr) AtlCrtErrorCheck(expr)
#endif // ATL_CRT_ERRORCHECK

#ifndef ATL_CRT_ERRORCHECK_SPRINTF
#define ATL_CRT_ERRORCHECK_SPRINTF(expr) \
do { \
	errno_t _saveErrno = errno; \
	errno = 0; \
	(expr); \
	if(0 != errno) \
	{ \
		AtlCrtErrorCheck(errno); \
	} \
	else \
	{ \
		errno = _saveErrno; \
	} \
} while (0)
#endif // ATL_CRT_ERRORCHECK_SPRINTF

#else // !_SECURE_ATL

#define ATL_CRT_ERRORCHECK(expr) do { expr; } while (0)
#define ATL_CRT_ERRORCHECK_SPRINTF(expr) do { expr; } while (0)

#endif // _SECURE_ATL

///////////////////////////////////////////////////////////////////////////////
// __declspec(novtable) is used on a class declaration to prevent the vtable
// pointer from being initialized in the constructor and destructor for the
// class.  This has many benefits because the linker can now eliminate the
// vtable and all the functions pointed to by the vtable.  Also, the actual
// constructor and destructor code are now smaller.
///////////////////////////////////////////////////////////////////////////////
// This should only be used on a class that is not directly createable but is
// rather only used as a base class.  Additionally, the constructor and
// destructor (if provided by the user) should not call anything that may cause
// a virtual function call to occur back on the object.
///////////////////////////////////////////////////////////////////////////////
// By default, the wizards will generate new ATL object classes with this
// attribute (through the ATL_NO_VTABLE macro).  This is normally safe as long
// the restriction mentioned above is followed.  It is always safe to remove
// this macro from your class, so if in doubt, remove it.
///////////////////////////////////////////////////////////////////////////////

#ifdef _ATL_DISABLE_NO_VTABLE
#define ATL_NO_VTABLE
#else
#define ATL_NO_VTABLE __declspec(novtable)
#endif

#ifdef _ATL_DISABLE_NOTHROW
#define ATL_NOTHROW
#else
#define ATL_NOTHROW __declspec(nothrow)
#endif

#ifdef _ATL_DISABLE_FORCEINLINE
#define ATL_FORCEINLINE
#else
#define ATL_FORCEINLINE __forceinline
#endif

#ifdef _ATL_DISABLE_NOINLINE
#define ATL_NOINLINE
#else
#define ATL_NOINLINE __declspec( noinline )
#endif

#ifdef _ATL_DISABLE_DEPRECATED
#define ATL_DEPRECATED(_Message)
#else
#define ATL_DEPRECATED(_Message) __declspec( deprecated(_Message) )
#endif

// If ATL80.DLL is being used then _ATL_STATIC_REGISTRY doesn't really make sense
#ifdef _ATL_DLL
#undef _ATL_STATIC_REGISTRY
#else
// If not linking to ATL80.DLL, use the static registrar and not building atl.dll
#ifndef _ATL_DLL_IMPL
#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif
#endif
#endif

#ifdef _ATL_DEBUG_REFCOUNT
#ifndef _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_INTERFACES
#endif
#endif

#ifdef _DEBUG
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _DEBUG

#ifdef _ATL_DEBUG_INTERFACES
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _ATL_DEBUG_INTERFACES

#ifndef _ATL_HEAPFLAGS
#ifdef _MALLOC_ZEROINIT
#define _ATL_HEAPFLAGS HEAP_ZERO_MEMORY
#else
#define _ATL_HEAPFLAGS 0
#endif
#endif

#ifndef _ATL_PACKING
#define _ATL_PACKING 8
#endif

#if defined(_ATL_DLL)
	#define ATLAPI extern "C" HRESULT __declspec(dllimport) __stdcall
	#define ATLAPI_(x) extern "C" __declspec(dllimport) x __stdcall
	#define ATLINLINE
	#define ATLAPIINL extern "C" inline HRESULT __stdcall
	#define ATLAPIINL_(x) extern "C" inline x __stdcall
#elif defined(_ATL_DLL_IMPL)
	#define ATLAPI extern "C" inline HRESULT __stdcall
	#define ATLAPI_(x) extern "C" inline x __stdcall
	#define ATLAPIINL ATLAPI
	#define ATLAPIINL_(x) ATLAPI_(x)
	#define ATLINLINE
#else
	#define ATLAPI __declspec(nothrow) HRESULT __stdcall
	#define ATLAPI_(x) __declspec(nothrow) x __stdcall
	#define ATLAPIINL ATLAPI
	#define ATLAPIINL_(x) ATLAPI_(x)
	#define ATLINLINE inline
#endif

#ifdef _ATL_NO_EXCEPTIONS
	#ifdef _AFX
	#error MFC projects cannot define _ATL_NO_EXCEPTIONS
	#endif
#else
	#ifndef _CPPUNWIND
	#define _ATL_NO_EXCEPTIONS
	#endif
#endif

#ifdef _CPPUNWIND

#ifndef ATLTRYALLOC

#ifdef _AFX
#define ATLTRYALLOC(x) try{x;} catch(CException* e){e->Delete();}
#else
/* prefast noise VSW 489981 */
#define ATLTRYALLOC(x) __pragma(warning(push)) __pragma(warning(disable: 4571)) try{x;} catch(...) {} __pragma(warning(pop))
#endif	//__AFX

#endif	//ATLTRYALLOC

// If you define _ATLTRY before including this file, then
// you should define _ATLCATCH and _ATLRETHROW as well.
#ifndef _ATLTRY
#define _ATLTRY try
#ifdef _AFX
#define _ATLCATCH( e ) catch( CException* e )
#else
#define _ATLCATCH( e ) catch( CAtlException e )
#endif

#define _ATLCATCHALL() __pragma(warning(push)) __pragma(warning(disable: 4571)) catch( ... ) __pragma(warning(pop))

#ifdef _AFX
#define _ATLDELETEEXCEPTION(e) e->Delete();
#else
#define _ATLDELETEEXCEPTION(e) e;
#endif

#define _ATLRETHROW throw
#endif	// _ATLTRY

/* 
COM functions should not throw. Which means we should protect their callers from C++ exceptions leaking out. These macros
can help with that, though they have not yet been applied to the whole of ATL, which uses a variety of patterns to achieve
this end
*/
 
#ifndef _ATL_COM_BEGIN 
#define _ATL_COM_BEGIN \
	HRESULT __hrAtlComMethod=S_OK; \
	try \
	{
#endif

#ifdef _AFX
/* Nice to do something more complex here in future to translate an MFC exception to a better HR */
#define _AFX_COM_END_PART \
	catch(CException *e) \
	{ \
		if(e) \
		{ \
			e->Delete(); \
		} \
		__hrAtlComMethod=E_FAIL; \
	}
#else
#define _AFX_COM_END_PART \
	catch(CAtlException e) \
	{ \
		__hrAtlComMethod=e.m_hr; \
	}
#endif

#ifndef _ATL_COM_END 
#define _ATL_COM_END \
	_AFX_COM_END_PART \
	catch(...) \
	{ \
		__hrAtlComMethod=E_FAIL; \
	} \
	return hr; 
#endif



#else //_CPPUNWIND

#ifndef ATLTRYALLOC
#define ATLTRYALLOC(x) x;
#endif	//ATLTRYALLOC

// if _ATLTRY is defined before including this file then 
// _ATLCATCH and _ATLRETHROW should be defined as well.
#ifndef _ATLTRY
#define _ATLTRY
#define _ATLCATCH( e ) __pragma(warning(push)) __pragma(warning(disable: 4127)) if( false ) __pragma(warning(pop))
#define _ATLCATCHALL() __pragma(warning(push)) __pragma(warning(disable: 4127)) if( false ) __pragma(warning(pop))
#define _ATLDELETEEXCEPTION(e)
#define _ATLRETHROW
#endif	// _ATLTRY

#endif	//_CPPUNWIND

#ifndef ATLTRY
#define ATLTRY(x) ATLTRYALLOC(x)
#endif	//ATLTRY

#define offsetofclass(base, derived) ((DWORD_PTR)(static_cast<base*>((derived*)_ATL_PACKING))-_ATL_PACKING)

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _ATL     1      // Active Template Library
#define _ATL_VER 0x0800 // Active Template Library version 8.00

/////////////////////////////////////////////////////////////////////////////
// Threading

#ifndef _ATL_SINGLE_THREADED
#ifndef _ATL_APARTMENT_THREADED
#ifndef _ATL_FREE_THREADED
#define _ATL_FREE_THREADED
#endif
#endif
#endif

// UUIDOF
#ifndef _ATL_NO_UUIDOF
#define _ATL_IIDOF(x) __uuidof(x)
#else
#define _ATL_IIDOF(x) IID_##x
#endif

// Lean and mean
#ifndef ATL_NO_LEAN_AND_MEAN
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMCX
#define NOMCX
#endif
#endif	// ATL_NO_LEAN_AND_MEAN

#ifdef NOSERVICE
#ifndef _ATL_NO_SERVICE
#define _ATL_NO_SERVICE
#endif	// _ATL_NO_SERVICE
#else
#ifdef _ATL_NO_SERVICE
#ifndef NOSERVICE
#define NOSERVICE
#endif	// NOSERVICE
#endif	// _ATL_NO_SERVICE
#endif	// NOSERVICE

#include <malloc.h>
#ifdef _DEBUG
#include <stdlib.h>
#endif
#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the ATLASSERT(x) macro
// in order to compile ATL
	#include <crtdbg.h>
#endif

#endif // RC_INVOKED

#define ATLAXWIN_CLASS	"AtlAxWin80"
#define ATLAXWINLIC_CLASS "AtlAxWinLic80"

// _ATL_INSECURE_DEPRECATE define
#ifndef _ATL_INSECURE_DEPRECATE
#ifdef _ATL_SECURE_NO_DEPRECATE
#define _ATL_INSECURE_DEPRECATE(_Message)
#else
#define _ATL_INSECURE_DEPRECATE(_Message) __declspec(deprecated(_Message))
#endif // _ATL_SECURE_NO_DEPRECATE
#endif // _ATL_INSECURE_DEPRECATE

/*
This is called when something really bad happens -- so bad
that we consider it dangerous to even throw an exception
*/
#ifndef _ATL_FATAL_SHUTDOWN
#define _ATL_FATAL_SHUTDOWN do { ::TerminateProcess(::GetCurrentProcess(), 0); } while(0);
#endif

//ATL/MFC code should use standard pointer to member standard syntax &MyClass::MyMethod, instead
//of the legacy non-standard syntax - MyMethod.
#ifdef _ATL_ENABLE_PTM_WARNING
#define PTM_WARNING_DISABLE
#define PTM_WARNING_RESTORE
#else
#define PTM_WARNING_DISABLE \
	__pragma(warning( push )) \
	__pragma(warning( disable : 4867 ))
#define PTM_WARNING_RESTORE \
	__pragma(warning( pop ))
#endif //_ATL_ENABLE_PTM_WARNING

/* we have to define our own versions of MAKEINTRESOURCE and IS_INTRESOURCE to 
 * fix warning 6268. At least until those macros are not cleanend in PSDK.
   Same comes true for those definitions of constants which use the above macros
*/
#define ATL_MAKEINTRESOURCEA(i) ((LPSTR)((ULONG_PTR)((WORD)(i))))
#define ATL_MAKEINTRESOURCEW(i) ((LPWSTR)((ULONG_PTR)((WORD)(i))))
#ifdef UNICODE
#define ATL_MAKEINTRESOURCE  ATL_MAKEINTRESOURCEW
#else
#define ATL_MAKEINTRESOURCE  ATL_MAKEINTRESOURCEA
#endif // !UNICODE
#define ATL_IS_INTRESOURCE(_r) ((((ULONG_PTR)(_r)) >> 16) == 0)

// No ActiveX hosting if GUI support is disabled
#ifdef _ATL_CE_NO_GUI
#define _ATL_NO_HOSTING
#endif

/*
 * Predefined Resource Types
 */
#define ATL_RT_CURSOR           ATL_MAKEINTRESOURCE(1)
#define ATL_RT_BITMAP           ATL_MAKEINTRESOURCE(2)
#define ATL_RT_ICON             ATL_MAKEINTRESOURCE(3)
#define ATL_RT_MENU             ATL_MAKEINTRESOURCE(4)
#define ATL_RT_DIALOG           ATL_MAKEINTRESOURCE(5)
#define ATL_RT_STRING           ATL_MAKEINTRESOURCE(6)
#define ATL_RT_FONTDIR          ATL_MAKEINTRESOURCE(7)
#define ATL_RT_FONT             ATL_MAKEINTRESOURCE(8)
#define ATL_RT_ACCELERATOR      ATL_MAKEINTRESOURCE(9)
#define ATL_RT_RCDATA           ATL_MAKEINTRESOURCE(10)
#define ATL_RT_MESSAGETABLE     ATL_MAKEINTRESOURCE(11)

#define ATL_DIFFERENCE     11
#define ATL_RT_GROUP_CURSOR ATL_MAKEINTRESOURCE((ULONG_PTR)ATL_RT_CURSOR + ATL_DIFFERENCE)
#define ATL_RT_GROUP_ICON   ATL_MAKEINTRESOURCE((ULONG_PTR)ATL_RT_ICON + ATL_DIFFERENCE)
#define ATL_RT_VERSION      ATL_MAKEINTRESOURCE(16)
#define ATL_RT_DLGINCLUDE   ATL_MAKEINTRESOURCE(17)
#if(WINVER >= 0x0400)
#define ATL_RT_PLUGPLAY     ATL_MAKEINTRESOURCE(19)
#define ATL_RT_VXD          ATL_MAKEINTRESOURCE(20)
#define ATL_RT_ANICURSOR    ATL_MAKEINTRESOURCE(21)
#define ATL_RT_ANIICON      ATL_MAKEINTRESOURCE(22)
#endif /* WINVER >= 0x0400 */
#define ATL_RT_HTML         ATL_MAKEINTRESOURCE(23)
#ifdef RC_INVOKED
#define ATL_RT_MANIFEST                        24
#define ATL_CREATEPROCESS_MANIFEST_RESOURCE_ID  1
#define ATL_ISOLATIONAWARE_MANIFEST_RESOURCE_ID 2
#define ATL_ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID 3
#define ATL_MINIMUM_RESERVED_MANIFEST_RESOURCE_ID 1   /* inclusive */
#define ATL_MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID 16  /* inclusive */
#else  /* RC_INVOKED */
#define ATL_RT_MANIFEST                        ATL_MAKEINTRESOURCE(24)
#define ATL_CREATEPROCESS_MANIFEST_RESOURCE_ID ATL_MAKEINTRESOURCE( 1)
#define ATL_ISOLATIONAWARE_MANIFEST_RESOURCE_ID ATL_MAKEINTRESOURCE(2)
#define ATL_ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID ATL_MAKEINTRESOURCE(3)
#define ATL_MINIMUM_RESERVED_MANIFEST_RESOURCE_ID ATL_MAKEINTRESOURCE( 1 /*inclusive*/)
#define ATL_MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID ATL_MAKEINTRESOURCE(16 /*inclusive*/)
#endif /* RC_INVOKED */


/* sal.h stuff that is not in the current LKG */
#ifndef __out_ecount_part_z
#define __out_ecount_part_z(size,length)                        __out_ecount_part(size,length) __post __nullterminated
#endif

#ifndef __out_ecount_part_z_opt
#define __out_ecount_part_z_opt(size,length)                    __out_ecount_part_opt(size,length) __post __nullterminated
#endif

#ifndef _WIN32_WCE
// This stuff directly uses the checked in sal.h for WinCE

#ifndef __deref_opt_out_z
#define __deref_opt_out_z                                       __deref_opt_out __post __deref __nullterminated
#endif

#endif // _WIN32_WCE

#ifndef __out_bcount_part_z
#define __out_bcount_part_z(size,length)                        __out_bcount_part(size,length) __post __nullterminated
#endif


#endif // __ATLDEF_H__

/////////////////////////////////////////////////////////////////////////////
	
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLDEF_H__
#define __ATLDEF_H__

#pragma once

#pragma warning(disable : 4619)	// there is no warning number

#ifdef _WIN32_WCE
#include <atldefce.h>
#endif

#include <atlrc.h>
#ifndef _WIN32_WCE
#include <errno.h>
#include <sal.h>
#endif

#ifndef RC_INVOKED

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

// If you are mixing compilation units that are built as
// native code with those that are built /clr, you must define
// the symbol '_ATL_MIXED'. _ATL_MIXED must be defined for all 
// compilation units in an executable or it must be defined for none of them.
#if !defined(_ATL_MIXED)
namespace Inconsistent_definition_of_symbol__ATL_MIXED
{
	struct _Please_define_it_the_same_throughout_your_project { };
}
#else
namespace Inconsistent_definition_of_symbol__ATL_MIXED
{
#ifdef _M_IX86
#pragma comment(linker, "/include:??3@YAXPAX@Z")
#else
#pragma comment(linker, "/include:??3@YAXPEAX@Z")
#endif
	struct _Please_define_it_the_same_throughout_your_project { virtual void one(){} };
}
#endif
namespace Inconsistent_definition_of_symbol__ATL_MIXED
{
	__declspec(selectany) _Please_define_it_the_same_throughout_your_project clash = _Please_define_it_the_same_throughout_your_project ();
}

#if !defined(_ATL_MIXED)
namespace Define_the_symbol__ATL_MIXED
{
#if defined(_M_CEE)
	struct Thank_you { };
#else
#ifdef _M_IX86
#pragma comment(linker, "/include:??3@YAXPAX@Z")
#else
#pragma comment(linker, "/include:??3@YAXPEAX@Z")
#endif
	struct Thank_you { virtual void one(){} };
#endif
	__declspec(selectany) Thank_you clash = Thank_you();
}
#endif

#if defined(_ATL_MIXED)
#define _ATL_NATIVE_INITIALIZATION
#endif

#if !defined(_M_CEE)
#define _ATL_NATIVE_INITIALIZATION
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifdef _WIN64
#define _ATL_SUPPORT_VT_I8  // Always support VT_I8 on Win64.
#endif

#if !defined(UNALIGNED)
#if defined(_M_IA64) || defined(_M_AMD64) || defined(_M_ARM) || defined(_M_MRX000) || defined(_M_SH)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif
#endif

#if !defined(_countof)
#if !defined(__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else
extern "C++"
{
template <typename _CountofType, size_t _SizeOfArray>
char (*__countof_helper(UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
#define _countof(_Array) sizeof(*__countof_helper(_Array))
}
#endif
#endif

#ifndef AtlThrow
#ifndef _ATL_CUSTOM_THROW
#define AtlThrow ATL::AtlThrowImpl
#endif
#endif // AtlThrow

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif // ATLASSERT

/* 
Why does ATLASSUME exist?

ATL 8 has two existing validation models

ATLASSERT/ATLVERIFY - These are used to make sure a debug build reports a problem with the expression/invariant
ATLENSURE - Debug is the same as ATLVERIFY, retail throws a C++ exception

We added ATLENSURE because there were too many unreported error paths in ATL and we wanted to bail out of more
error conditions rather than just trying to continue in retail.

There might be a case for changing 'lots' of ATLASSERT to ATLENSURE, but we chose an incremental approach and only
changed over where we saw a problem with code reported from a customer or test case. This reduces code churn in our
code for this version.

In general, our approach is to try to make sure that when something goes wrong
- the client does not continue to run, because we report an error condition
- debug builds see an assertion about the problem

Sometimes we have code like

HRESULT ComMethod(void)
{
	ATLASSUME(m_pFoo);
	return m_pFoo->Method();
}

We could add
	if(!m_pFoo) return E_POINTER;

But this is very unlikely to help, since it removes the ability of the developer to debug this problem if it's seen in a retail
build of the application. 

We could try something more severe

	if(!m_pFoo) terminate(); // or your favourite shutdown function

This would ensure good reporting (because VC8 terminate generates a Windows Error Report and crash dump), but hardly seems a big win 
over the previous crash.

ATLENSURE might seem slightly better. It is debuggable and consistent with ATL in general. In fact, many parts of ATL do just this. 
But in this specific context, it doesn't look like a great choice. COM methods should not in general be emitting native C++ exceptions 
as an error reporting strategy. 

So we find ourselves in a quandry. For these kinds of methods, the traditional code (ATLASSERT followed by a crash), seems be the most 
debuggable thing to do in this situation. At least for VS8, we have decided to stick with this shape.

---

Now consider the impact of cl /analyze. We want cl /analyze to not warn about our potential dereferences when they refer to member variables
whose state was previously validated by another method. But we do want to see the impact of function contracts on the parameters of the
function. 

So we've done a broad replace of all the member-related ATLASSERT to ATLASSUME. 

*/

#ifndef ATLASSUME
#define ATLASSUME(expr) do { ATLASSERT(expr); __analysis_assume(!!(expr)); } while(0)
#endif // ATLASSERT

#ifndef ATLVERIFY
#ifdef _DEBUG
#define ATLVERIFY(expr) ATLASSERT(expr)
#else
#define ATLVERIFY(expr) (expr)
#endif // DEBUG
#endif // ATLVERIFY

#ifndef ATLENSURE_THROW
#define ATLENSURE_THROW(expr, hr)          \
do {                                       \
	int __atl_condVal=!!(expr);            \
	ATLASSERT(__atl_condVal);              \
	if(!(__atl_condVal)) AtlThrow(hr);     \
} while (0)
#endif // ATLENSURE

#ifndef ATLENSURE
#define ATLENSURE(expr) ATLENSURE_THROW(expr, E_FAIL)
#endif // ATLENSURE

#ifndef ATLENSURE_SUCCEEDED
#define ATLENSURE_SUCCEEDED(hr) ATLENSURE_THROW(SUCCEEDED(hr), hr)
#endif // ATLENSURE

/* Used inside COM methods that do not want to throw */
#ifndef ATLENSURE_RETURN_HR
#define ATLENSURE_RETURN_HR(expr, hr)          \
do {                                           \
	int __atl_condVal=!!(expr);                \
	ATLASSERT(__atl_condVal);                  \
	if(!(__atl_condVal)) return hr;            \
} while (0) 
#endif 

/* Used inside COM methods that do not want to throw */
#ifndef ATLENSURE_RETURN
#define ATLENSURE_RETURN(expr) ATLENSURE_RETURN_HR(expr, E_FAIL)
#endif 

#ifndef _SECURE_ATL
#define _SECURE_ATL 1
#endif // _SECURE_ATL

#if _SECURE_ATL

#ifndef ATL_CRT_ERRORCHECK
#define ATL_CRT_ERRORCHECK(expr) AtlCrtErrorCheck(expr)
#endif // ATL_CRT_ERRORCHECK

#ifndef ATL_CRT_ERRORCHECK_SPRINTF
#define ATL_CRT_ERRORCHECK_SPRINTF(expr) \
do { \
	errno_t _saveErrno = errno; \
	errno = 0; \
	(expr); \
	if(0 != errno) \
	{ \
		AtlCrtErrorCheck(errno); \
	} \
	else \
	{ \
		errno = _saveErrno; \
	} \
} while (0)
#endif // ATL_CRT_ERRORCHECK_SPRINTF

#else // !_SECURE_ATL

#define ATL_CRT_ERRORCHECK(expr) do { expr; } while (0)
#define ATL_CRT_ERRORCHECK_SPRINTF(expr) do { expr; } while (0)

#endif // _SECURE_ATL

///////////////////////////////////////////////////////////////////////////////
// __declspec(novtable) is used on a class declaration to prevent the vtable
// pointer from being initialized in the constructor and destructor for the
// class.  This has many benefits because the linker can now eliminate the
// vtable and all the functions pointed to by the vtable.  Also, the actual
// constructor and destructor code are now smaller.
///////////////////////////////////////////////////////////////////////////////
// This should only be used on a class that is not directly createable but is
// rather only used as a base class.  Additionally, the constructor and
// destructor (if provided by the user) should not call anything that may cause
// a virtual function call to occur back on the object.
///////////////////////////////////////////////////////////////////////////////
// By default, the wizards will generate new ATL object classes with this
// attribute (through the ATL_NO_VTABLE macro).  This is normally safe as long
// the restriction mentioned above is followed.  It is always safe to remove
// this macro from your class, so if in doubt, remove it.
///////////////////////////////////////////////////////////////////////////////

#ifdef _ATL_DISABLE_NO_VTABLE
#define ATL_NO_VTABLE
#else
#define ATL_NO_VTABLE __declspec(novtable)
#endif

#ifdef _ATL_DISABLE_NOTHROW
#define ATL_NOTHROW
#else
#define ATL_NOTHROW __declspec(nothrow)
#endif

#ifdef _ATL_DISABLE_FORCEINLINE
#define ATL_FORCEINLINE
#else
#define ATL_FORCEINLINE __forceinline
#endif

#ifdef _ATL_DISABLE_NOINLINE
#define ATL_NOINLINE
#else
#define ATL_NOINLINE __declspec( noinline )
#endif

#ifdef _ATL_DISABLE_DEPRECATED
#define ATL_DEPRECATED(_Message)
#else
#define ATL_DEPRECATED(_Message) __declspec( deprecated(_Message) )
#endif

// If ATL80.DLL is being used then _ATL_STATIC_REGISTRY doesn't really make sense
#ifdef _ATL_DLL
#undef _ATL_STATIC_REGISTRY
#else
// If not linking to ATL80.DLL, use the static registrar and not building atl.dll
#ifndef _ATL_DLL_IMPL
#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif
#endif
#endif

#ifdef _ATL_DEBUG_REFCOUNT
#ifndef _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_INTERFACES
#endif
#endif

#ifdef _DEBUG
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _DEBUG

#ifdef _ATL_DEBUG_INTERFACES
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _ATL_DEBUG_INTERFACES

#ifndef _ATL_HEAPFLAGS
#ifdef _MALLOC_ZEROINIT
#define _ATL_HEAPFLAGS HEAP_ZERO_MEMORY
#else
#define _ATL_HEAPFLAGS 0
#endif
#endif

#ifndef _ATL_PACKING
#define _ATL_PACKING 8
#endif

#if defined(_ATL_DLL)
	#define ATLAPI extern "C" HRESULT __declspec(dllimport) __stdcall
	#define ATLAPI_(x) extern "C" __declspec(dllimport) x __stdcall
	#define ATLINLINE
	#define ATLAPIINL extern "C" inline HRESULT __stdcall
	#define ATLAPIINL_(x) extern "C" inline x __stdcall
#elif defined(_ATL_DLL_IMPL)
	#define ATLAPI extern "C" inline HRESULT __stdcall
	#define ATLAPI_(x) extern "C" inline x __stdcall
	#define ATLAPIINL ATLAPI
	#define ATLAPIINL_(x) ATLAPI_(x)
	#define ATLINLINE
#else
	#define ATLAPI __declspec(nothrow) HRESULT __stdcall
	#define ATLAPI_(x) __declspec(nothrow) x __stdcall
	#define ATLAPIINL ATLAPI
	#define ATLAPIINL_(x) ATLAPI_(x)
	#define ATLINLINE inline
#endif

#ifdef _ATL_NO_EXCEPTIONS
	#ifdef _AFX
	#error MFC projects cannot define _ATL_NO_EXCEPTIONS
	#endif
#else
	#ifndef _CPPUNWIND
	#define _ATL_NO_EXCEPTIONS
	#endif
#endif

#ifdef _CPPUNWIND

#ifndef ATLTRYALLOC

#ifdef _AFX
#define ATLTRYALLOC(x) try{x;} catch(CException* e){e->Delete();}
#else
/* prefast noise VSW 489981 */
#define ATLTRYALLOC(x) __pragma(warning(push)) __pragma(warning(disable: 4571)) try{x;} catch(...) {} __pragma(warning(pop))
#endif	//__AFX

#endif	//ATLTRYALLOC

// If you define _ATLTRY before including this file, then
// you should define _ATLCATCH and _ATLRETHROW as well.
#ifndef _ATLTRY
#define _ATLTRY try
#ifdef _AFX
#define _ATLCATCH( e ) catch( CException* e )
#else
#define _ATLCATCH( e ) catch( CAtlException e )
#endif

#define _ATLCATCHALL() __pragma(warning(push)) __pragma(warning(disable: 4571)) catch( ... ) __pragma(warning(pop))

#ifdef _AFX
#define _ATLDELETEEXCEPTION(e) e->Delete();
#else
#define _ATLDELETEEXCEPTION(e) e;
#endif

#define _ATLRETHROW throw
#endif	// _ATLTRY

/* 
COM functions should not throw. Which means we should protect their callers from C++ exceptions leaking out. These macros
can help with that, though they have not yet been applied to the whole of ATL, which uses a variety of patterns to achieve
this end
*/
 
#ifndef _ATL_COM_BEGIN 
#define _ATL_COM_BEGIN \
	HRESULT __hrAtlComMethod=S_OK; \
	try \
	{
#endif

#ifdef _AFX
/* Nice to do something more complex here in future to translate an MFC exception to a better HR */
#define _AFX_COM_END_PART \
	catch(CException *e) \
	{ \
		if(e) \
		{ \
			e->Delete(); \
		} \
		__hrAtlComMethod=E_FAIL; \
	}
#else
#define _AFX_COM_END_PART \
	catch(CAtlException e) \
	{ \
		__hrAtlComMethod=e.m_hr; \
	}
#endif

#ifndef _ATL_COM_END 
#define _ATL_COM_END \
	_AFX_COM_END_PART \
	catch(...) \
	{ \
		__hrAtlComMethod=E_FAIL; \
	} \
	return hr; 
#endif



#else //_CPPUNWIND

#ifndef ATLTRYALLOC
#define ATLTRYALLOC(x) x;
#endif	//ATLTRYALLOC

// if _ATLTRY is defined before including this file then 
// _ATLCATCH and _ATLRETHROW should be defined as well.
#ifndef _ATLTRY
#define _ATLTRY
#define _ATLCATCH( e ) __pragma(warning(push)) __pragma(warning(disable: 4127)) if( false ) __pragma(warning(pop))
#define _ATLCATCHALL() __pragma(warning(push)) __pragma(warning(disable: 4127)) if( false ) __pragma(warning(pop))
#define _ATLDELETEEXCEPTION(e)
#define _ATLRETHROW
#endif	// _ATLTRY

#endif	//_CPPUNWIND

#ifndef ATLTRY
#define ATLTRY(x) ATLTRYALLOC(x)
#endif	//ATLTRY

#define offsetofclass(base, derived) ((DWORD_PTR)(static_cast<base*>((derived*)_ATL_PACKING))-_ATL_PACKING)

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _ATL     1      // Active Template Library
#define _ATL_VER 0x0800 // Active Template Library version 8.00

/////////////////////////////////////////////////////////////////////////////
// Threading

#ifndef _ATL_SINGLE_THREADED
#ifndef _ATL_APARTMENT_THREADED
#ifndef _ATL_FREE_THREADED
#define _ATL_FREE_THREADED
#endif
#endif
#endif

// UUIDOF
#ifndef _ATL_NO_UUIDOF
#define _ATL_IIDOF(x) __uuidof(x)
#else
#define _ATL_IIDOF(x) IID_##x
#endif

// Lean and mean
#ifndef ATL_NO_LEAN_AND_MEAN
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMCX
#define NOMCX
#endif
#endif	// ATL_NO_LEAN_AND_MEAN

#ifdef NOSERVICE
#ifndef _ATL_NO_SERVICE
#define _ATL_NO_SERVICE
#endif	// _ATL_NO_SERVICE
#else
#ifdef _ATL_NO_SERVICE
#ifndef NOSERVICE
#define NOSERVICE
#endif	// NOSERVICE
#endif	// _ATL_NO_SERVICE
#endif	// NOSERVICE

#include <malloc.h>
#ifdef _DEBUG
#include <stdlib.h>
#endif
#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the ATLASSERT(x) macro
// in order to compile ATL
	#include <crtdbg.h>
#endif

#endif // RC_INVOKED

#define ATLAXWIN_CLASS	"AtlAxWin80"
#define ATLAXWINLIC_CLASS "AtlAxWinLic80"

// _ATL_INSECURE_DEPRECATE define
#ifndef _ATL_INSECURE_DEPRECATE
#ifdef _ATL_SECURE_NO_DEPRECATE
#define _ATL_INSECURE_DEPRECATE(_Message)
#else
#define _ATL_INSECURE_DEPRECATE(_Message) __declspec(deprecated(_Message))
#endif // _ATL_SECURE_NO_DEPRECATE
#endif // _ATL_INSECURE_DEPRECATE

/*
This is called when something really bad happens -- so bad
that we consider it dangerous to even throw an exception
*/
#ifndef _ATL_FATAL_SHUTDOWN
#define _ATL_FATAL_SHUTDOWN do { ::TerminateProcess(::GetCurrentProcess(), 0); } while(0);
#endif

//ATL/MFC code should use standard pointer to member standard syntax &MyClass::MyMethod, instead
//of the legacy non-standard syntax - MyMethod.
#ifdef _ATL_ENABLE_PTM_WARNING
#define PTM_WARNING_DISABLE
#define PTM_WARNING_RESTORE
#else
#define PTM_WARNING_DISABLE \
	__pragma(warning( push )) \
	__pragma(warning( disable : 4867 ))
#define PTM_WARNING_RESTORE \
	__pragma(warning( pop ))
#endif //_ATL_ENABLE_PTM_WARNING

/* we have to define our own versions of MAKEINTRESOURCE and IS_INTRESOURCE to 
 * fix warning 6268. At least until those macros are not cleanend in PSDK.
   Same comes true for those definitions of constants which use the above macros
*/
#define ATL_MAKEINTRESOURCEA(i) ((LPSTR)((ULONG_PTR)((WORD)(i))))
#define ATL_MAKEINTRESOURCEW(i) ((LPWSTR)((ULONG_PTR)((WORD)(i))))
#ifdef UNICODE
#define ATL_MAKEINTRESOURCE  ATL_MAKEINTRESOURCEW
#else
#define ATL_MAKEINTRESOURCE  ATL_MAKEINTRESOURCEA
#endif // !UNICODE
#define ATL_IS_INTRESOURCE(_r) ((((ULONG_PTR)(_r)) >> 16) == 0)

// No ActiveX hosting if GUI support is disabled
#ifdef _ATL_CE_NO_GUI
#define _ATL_NO_HOSTING
#endif

/*
 * Predefined Resource Types
 */
#define ATL_RT_CURSOR           ATL_MAKEINTRESOURCE(1)
#define ATL_RT_BITMAP           ATL_MAKEINTRESOURCE(2)
#define ATL_RT_ICON             ATL_MAKEINTRESOURCE(3)
#define ATL_RT_MENU             ATL_MAKEINTRESOURCE(4)
#define ATL_RT_DIALOG           ATL_MAKEINTRESOURCE(5)
#define ATL_RT_STRING           ATL_MAKEINTRESOURCE(6)
#define ATL_RT_FONTDIR          ATL_MAKEINTRESOURCE(7)
#define ATL_RT_FONT             ATL_MAKEINTRESOURCE(8)
#define ATL_RT_ACCELERATOR      ATL_MAKEINTRESOURCE(9)
#define ATL_RT_RCDATA           ATL_MAKEINTRESOURCE(10)
#define ATL_RT_MESSAGETABLE     ATL_MAKEINTRESOURCE(11)

#define ATL_DIFFERENCE     11
#define ATL_RT_GROUP_CURSOR ATL_MAKEINTRESOURCE((ULONG_PTR)ATL_RT_CURSOR + ATL_DIFFERENCE)
#define ATL_RT_GROUP_ICON   ATL_MAKEINTRESOURCE((ULONG_PTR)ATL_RT_ICON + ATL_DIFFERENCE)
#define ATL_RT_VERSION      ATL_MAKEINTRESOURCE(16)
#define ATL_RT_DLGINCLUDE   ATL_MAKEINTRESOURCE(17)
#if(WINVER >= 0x0400)
#define ATL_RT_PLUGPLAY     ATL_MAKEINTRESOURCE(19)
#define ATL_RT_VXD          ATL_MAKEINTRESOURCE(20)
#define ATL_RT_ANICURSOR    ATL_MAKEINTRESOURCE(21)
#define ATL_RT_ANIICON      ATL_MAKEINTRESOURCE(22)
#endif /* WINVER >= 0x0400 */
#define ATL_RT_HTML         ATL_MAKEINTRESOURCE(23)
#ifdef RC_INVOKED
#define ATL_RT_MANIFEST                        24
#define ATL_CREATEPROCESS_MANIFEST_RESOURCE_ID  1
#define ATL_ISOLATIONAWARE_MANIFEST_RESOURCE_ID 2
#define ATL_ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID 3
#define ATL_MINIMUM_RESERVED_MANIFEST_RESOURCE_ID 1   /* inclusive */
#define ATL_MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID 16  /* inclusive */
#else  /* RC_INVOKED */
#define ATL_RT_MANIFEST                        ATL_MAKEINTRESOURCE(24)
#define ATL_CREATEPROCESS_MANIFEST_RESOURCE_ID ATL_MAKEINTRESOURCE( 1)
#define ATL_ISOLATIONAWARE_MANIFEST_RESOURCE_ID ATL_MAKEINTRESOURCE(2)
#define ATL_ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID ATL_MAKEINTRESOURCE(3)
#define ATL_MINIMUM_RESERVED_MANIFEST_RESOURCE_ID ATL_MAKEINTRESOURCE( 1 /*inclusive*/)
#define ATL_MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID ATL_MAKEINTRESOURCE(16 /*inclusive*/)
#endif /* RC_INVOKED */


/* sal.h stuff that is not in the current LKG */
#ifndef __out_ecount_part_z
#define __out_ecount_part_z(size,length)                        __out_ecount_part(size,length) __post __nullterminated
#endif

#ifndef __out_ecount_part_z_opt
#define __out_ecount_part_z_opt(size,length)                    __out_ecount_part_opt(size,length) __post __nullterminated
#endif

#ifndef _WIN32_WCE
// This stuff directly uses the checked in sal.h for WinCE

#ifndef __deref_opt_out_z
#define __deref_opt_out_z                                       __deref_opt_out __post __deref __nullterminated
#endif

#endif // _WIN32_WCE

#ifndef __out_bcount_part_z
#define __out_bcount_part_z(size,length)                        __out_bcount_part(size,length) __post __nullterminated
#endif


#endif // __ATLDEF_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atldbgmem.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#if defined(__ATLBASE_H__) || defined (_INC_CRTDBG)
#error <atldbgmem.h> must be included before other ATL and CRT headers
#endif

#ifdef __AFX_H__
#error <atldbgmem.h> cannot be used in MFC projects. See AfxEnableMemoryTracking
#endif

#ifndef __ATLDBGMEM_H__
#define __ATLDBGMEM_H__

#pragma once

#pragma warning(push)

#pragma warning(disable: 4273)
#pragma warning(disable: 4127) // conditional expression is constant
#pragma warning(disable: 4201) // nameless unions are part of C++

#define _MFC_OVERRIDES_NEW
#define _CRTDBG_MAP_ALLOC
#include <new.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#ifndef _WIN32_WCE
#include <crtdbg.h>
#endif // _WIN32_WCE
#include <stddef.h>
#include <tchar.h>
#include <atltrace.h>
#include <atlchecked.h>

#define ATLDBG_UNUSED(x) x

#pragma pack(push,_ATL_PACKING)
namespace ATL
{

const DWORD atlDbgMemTrackIndividualAllocations = 0x1;
const DWORD atlDbgMemTrackAggregateStats        = 0x2;
const DWORD atlDbgMemTrackAll                   = 0x3;

struct AtlAllocRecord
{
	char szPath[MAX_PATH];
	int nLine;
	size_t nSize;
	int nAllocations;
};

__declspec(selectany) DWORD g_dwFlags = atlDbgMemTrackIndividualAllocations;
__declspec(selectany) HANDLE g_hReportFile = INVALID_HANDLE_VALUE;
__declspec(selectany) HANDLE g_hMemMutex = NULL;
__declspec(selectany) AtlAllocRecord* g_pMemStats = NULL;
__declspec(selectany) int g_nAllocedRecords = 0;
__declspec(selectany) int g_nRecords = 0;

inline int __cdecl AtlNewHandler(size_t /* nSize */)
{
	return 0;
}

__declspec(selectany) _PNH _atlNewHandler = &AtlNewHandler;

inline _PNH AtlGetNewHandler(void)
{
	return _atlNewHandler;
}

inline _PNH AtlSetNewHandler(_PNH pfnNewHandler)
{
	_PNH pfnOldHandler = _atlNewHandler;
	_atlNewHandler = pfnNewHandler;
	return pfnOldHandler;
}

extern __declspec(selectany) const _PNH _pfnUninitialized = (_PNH)-1;

}; // namespace ATL
#pragma pack(pop)

inline void* __cdecl operator new(size_t nSize)
{
	void* pResult;
	for (;;)
	{
#if !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
		pResult = _malloc_dbg(nSize, _NORMAL_BLOCK, NULL, 0);
#else
		pResult = malloc(nSize);
#endif // !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
		if (pResult != NULL)
			return pResult;

		if (ATL::_atlNewHandler == NULL || (*ATL::_atlNewHandler)(nSize) == 0)
			break;
	}
	return pResult;
}

inline void __cdecl operator delete(void* p)
{
#if !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
		_free_dbg(p, _NORMAL_BLOCK);
#else
		free(p);
#endif // !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
}

inline void* __cdecl operator new[](size_t nSize)
{
	return ::operator new(nSize);
}

inline void __cdecl operator delete[](void* p)
{
	::operator delete(p);
}

inline void* __cdecl operator new(size_t nSize, int nType, LPCSTR lpszFileName, int nLine)
{
	ATLDBG_UNUSED(nType);
	ATLDBG_UNUSED(lpszFileName);
	ATLDBG_UNUSED(nLine);

#ifdef _ATL_NO_DEBUG_CRT
	return ::operator new(nSize);
#else
	void* pResult;
	for (;;)
	{
		pResult = _malloc_dbg(nSize, nType, lpszFileName, nLine);
		if (pResult != NULL)
			return pResult;

		if (ATL::_atlNewHandler == NULL || (*ATL::_atlNewHandler)(nSize) == 0)
			break;
	}
	return pResult;
#endif // _ATL_NO_DEBUG_CRT
}

inline void __cdecl operator delete(void* p, int nType, LPCSTR /* lpszFileName */, int /* nLine */)
{
	ATLDBG_UNUSED(nType);
#if !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
		_free_dbg(p, nType);
#else
		free(p);
#endif // !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
}

inline void* __cdecl operator new[](size_t nSize, int nType, LPCSTR lpszFileName, int nLine)
{
	return ::operator new(nSize, nType, lpszFileName, nLine);
}

inline void __cdecl operator delete[](void* p, int nType, LPCSTR lpszFileName, int nLine)
{
	::operator delete(p, nType, lpszFileName, nLine);
}

inline void* __cdecl operator new(size_t nSize, LPCSTR lpszFileName, int nLine)
{
	return ::operator new(nSize, _NORMAL_BLOCK, lpszFileName, nLine);
}

inline void* __cdecl operator new[](size_t nSize, LPCSTR lpszFileName, int nLine)
{
	return ::operator new[](nSize, _NORMAL_BLOCK, lpszFileName, nLine);
}

inline void __cdecl operator delete(void* pData, LPCSTR /* lpszFileName */, int /* nLine */)
{
	::operator delete(pData);
}

inline void __cdecl operator delete[](void* pData, LPCSTR /* lpszFileName */, int /* nLine */)
{
	::operator delete(pData);
}


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

inline void* AtlAllocMemoryDebug(size_t nSize, LPCSTR lpszFileName, int nLine)
{
	ATLDBG_UNUSED(lpszFileName);
	ATLDBG_UNUSED(nLine);
	return _malloc_dbg(nSize, _NORMAL_BLOCK, lpszFileName, nLine);
}

inline void AtlFreeMemoryDebug(void* pbData)
{
	_free_dbg(pbData, _NORMAL_BLOCK);
}

#define new new(__FILE__, __LINE__)

/////////////////////////////////////////////////////////////////////////////
// allocation failure hook, tracking turn on

inline void _AtlDbgMemTrace(LPCSTR szBuf, int nLen)
{
	ATLTRACE(atlTraceAllocation, 0, szBuf);

	if (g_hReportFile != INVALID_HANDLE_VALUE)
	{
		 DWORD dwRet = WaitForSingleObject(g_hMemMutex, INFINITE);
		 if (dwRet == WAIT_OBJECT_0 || dwRet == WAIT_ABANDONED)
		{
			DWORD bytes;
			WriteFile(g_hReportFile, szBuf, nLen, &bytes, NULL);
			ReleaseMutex(g_hMemMutex);
		}
	}
}

inline void _AtlRecordAllocation(LPCSTR szFileName, int nLine, LPCSTR szAllocType, size_t nSize, int nRequest = 0)
{
	const int c_nSize = 512;
	char szBuf[c_nSize];
	int nLen;

#if _SECURE_ATL && !defined(_WIN32_WCE)
	if (szFileName)
		nLen = sprintf_s(szBuf, c_nSize, "%s(%d): Memory operation: %s a %d-byte block (# %ld)\r\n",
			szFileName, nLine, szAllocType, nSize, nRequest);
	else
		nLen = sprintf_s(szBuf, c_nSize, "Memory operation: %s a %d-byte block (# %ld)\r\n", szAllocType, nSize, nRequest);
#else
	if (szFileName)
		nLen = _snprintf(szBuf, c_nSize, "%s(%d): Memory operation: %s a %d-byte block (# %ld)\r\n",
			szFileName, nLine, szAllocType, nSize, nRequest);
	else
		nLen = _snprintf(szBuf, c_nSize, "Memory operation: %s a %d-byte block (# %ld)\r\n", szAllocType, nSize, nRequest);
#endif

	if(nLen == -1 || nLen >= c_nSize)
	{
		// Truncate it
		szBuf[c_nSize -1] = '\0';
	}
	
	if (g_dwFlags & atlDbgMemTrackIndividualAllocations)
		_AtlDbgMemTrace(szBuf, nLen);

	if (g_pMemStats && WaitForSingleObject(g_hMemMutex, INFINITE) == WAIT_OBJECT_0)
	{
		if (!szFileName)
			szFileName = "(null)";
		int nIndex = 0;
		while (nIndex < g_nRecords)
		{
			if (strncmp(g_pMemStats[nIndex].szPath, szFileName, MAX_PATH) == 0 && g_pMemStats[nIndex].nLine == nLine && g_pMemStats[nIndex].nSize == nSize)
			{
				g_pMemStats[nIndex].nAllocations++;
				break;
			}
			nIndex++;
		}

		if (nIndex == g_nRecords)
		{
			if (g_nAllocedRecords == g_nRecords)
			{
				int nNewAllocSize = g_nAllocedRecords * 2;
				if ((nNewAllocSize<0) || 
					(nNewAllocSize>(INT_MAX/sizeof(AtlAllocRecord))))
				{
					ATLASSERT(FALSE);
					ReleaseMutex(g_hMemMutex);
					return; // out of memory
				}
				AtlAllocRecord* p = (AtlAllocRecord*) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, g_pMemStats, nNewAllocSize*sizeof(AtlAllocRecord));
				if (p == NULL)
				{
					ATLASSERT(FALSE);
					ReleaseMutex(g_hMemMutex);
					return; // out of memory
				}
				g_pMemStats = p;
				g_nAllocedRecords = nNewAllocSize;
			}
			Checked::strncpy_s(g_pMemStats[nIndex].szPath, MAX_PATH, szFileName, _TRUNCATE);
			g_pMemStats[nIndex].szPath[MAX_PATH-1] = 0;
			g_pMemStats[nIndex].nLine = nLine;
			g_pMemStats[nIndex].nSize = nSize;
			g_pMemStats[nIndex].nAllocations = 1;
			g_nRecords++;
		}

		ReleaseMutex(g_hMemMutex);
	}
}

inline int __cdecl _AtlAllocReportHook(int nAllocType, void* /* pvData */, size_t nSize, int nBlockUse, long lRequest,
	const unsigned char* szFileName, int nLine)
{
	char *operation[] = { "", "allocating", "re-allocating", "freeing" };

	if (nBlockUse == _CRT_BLOCK)   // Ignore internal C runtime library allocations
		return TRUE;

#pragma warning(disable: 4127)
	_ASSERTE((nAllocType > 0) && (nAllocType < 4));
	_ASSERTE((nBlockUse >= 0) && (nBlockUse < 5));

	_AtlRecordAllocation((LPCSTR) szFileName, nLine, operation[nAllocType], nSize, lRequest);

	return TRUE;         // Allow the memory operation to proceed
}

extern __declspec(selectany) _CRT_ALLOC_HOOK pfnCrtAllocHook = NULL;

inline void AtlSetAllocHook()
{
	if (pfnCrtAllocHook == NULL)
		pfnCrtAllocHook = _CrtSetAllocHook(_AtlAllocReportHook);
}

inline void AtlSetReportFile(HANDLE hReportFile)
{
	if (g_hMemMutex == NULL)
		g_hMemMutex = CreateMutex(NULL, FALSE, NULL);

	if (g_hMemMutex != NULL)
		g_hReportFile = hReportFile;
}

inline void AtlEnableAllocationTracking(DWORD dwFlags = atlDbgMemTrackAll)
{
	g_dwFlags = dwFlags;

	if (dwFlags & atlDbgMemTrackAggregateStats)
	{
		if (g_hMemMutex == NULL)
			g_hMemMutex = CreateMutex(NULL, FALSE, NULL);

		if (g_pMemStats == NULL && g_hMemMutex != NULL)
		{
			g_pMemStats = (AtlAllocRecord*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 128*sizeof(AtlAllocRecord));
			g_nAllocedRecords = 128;
			g_nRecords = 0;
		}
	}
}

inline BOOL AtlDumpMemoryStats()
{
	if (g_pMemStats && WaitForSingleObject(g_hMemMutex, INFINITE) == WAIT_OBJECT_0)
	{
		const int nSize = 512;
		char szBuf[nSize];

#if _SECURE_ATL && !defined(_WIN32_WCE)
		int nLen = sprintf_s(szBuf, nSize, "%d records in dump:\r\n", g_nRecords);
#else
		int nLen = _snprintf(szBuf, nSize, "%d records in dump:\r\n", g_nRecords);
#endif
		if(nLen == -1 || nLen >= _countof(szBuf))
		{
			szBuf[nSize - 1] = '\0';
		}
		_AtlDbgMemTrace(szBuf, nLen);

		for (int n=0; n<g_nRecords; n++)
		{
#if _SECURE_ATL && !defined(_WIN32_WCE)
			int nLen = sprintf_s(szBuf, nSize, "%s(%d): %d operations of size %d\r\n",
				g_pMemStats[n].szPath,
				g_pMemStats[n].nLine,
				g_pMemStats[n].nAllocations,
				g_pMemStats[n].nSize);
#else
			int nLen = _snprintf(szBuf, nSize, "%s(%d): %d operations of size %d\r\n",
				g_pMemStats[n].szPath,
				g_pMemStats[n].nLine,
				g_pMemStats[n].nAllocations,
				g_pMemStats[n].nSize);
#endif
			if(nLen == -1 || nLen >= _countof(szBuf))
			{
				szBuf[nSize - 1] = '\0';
			}

			_AtlDbgMemTrace(szBuf, nLen);
		}
		ReleaseMutex(g_hMemMutex);
	}

	return TRUE;
}

// This can be set to TRUE to override all AtlEnableMemoryTracking calls,
// allowing all allocations to be tracked.
BOOL _atlMemoryLeakOverride = FALSE;

inline BOOL AtlEnableMemoryTracking(BOOL bTrack)
{
	if (_atlMemoryLeakOverride)
		return TRUE;

	int nOldState = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
	if (bTrack)
		_CrtSetDbgFlag(nOldState | _CRTDBG_ALLOC_MEM_DF);
	else
		_CrtSetDbgFlag(nOldState & ~_CRTDBG_ALLOC_MEM_DF);
	return nOldState & _CRTDBG_ALLOC_MEM_DF;
}

/////////////////////////////////////////////////////////////////////////////
// stop on a specific memory request

// Obsolete API
inline void AtlSetAllocStop(LONG lRequestNumber)
{
	ATLDBG_UNUSED(lRequestNumber);
	_CrtSetBreakAlloc(lRequestNumber);
}

// check all of memory (look for memory tromps)
inline BOOL AtlCheckMemory()
{
	return _CrtCheckMemory();
}

// -- true if block of exact size, allocated on the heap
// -- set *plRequestNumber to request number (or 0)
inline BOOL AtlIsMemoryBlock(const void* pData, UINT nBytes,
		LONG* plRequestNumber)
{
	ATLDBG_UNUSED(plRequestNumber);
	ATLDBG_UNUSED(nBytes);
	ATLDBG_UNUSED(pData);
	return _CrtIsMemoryBlock(pData, nBytes, plRequestNumber, NULL, NULL);
}

inline BOOL AtlDumpMemoryLeaks()
{
	return _CrtDumpMemoryLeaks();
}

/////////////////////////////////////////////////////////////////////////////

inline HANDLE __stdcall _AtlHeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "HeapCreate", 0);
	return HeapCreate(flOptions, dwInitialSize, dwMaximumSize);
}

inline BOOL __stdcall _AtlHeapDestroy(HANDLE hHeap, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "HeapDestroy", 0);
	return HeapDestroy(hHeap);
}

inline LPVOID __stdcall _AtlHeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T nSize, LPCSTR lpszFileName, int nLine)
{
	LPVOID p = NULL;
#ifndef _ATL_NO_TRACK_HEAP
	hHeap; // unused
	dwFlags; // unused
	p = _malloc_dbg(nSize, _NORMAL_BLOCK, lpszFileName, nLine);
#else
	p = HeapAlloc(hHeap, dwFlags, nSize);
#endif
	_AtlRecordAllocation(lpszFileName, nLine, "HeapAlloc", nSize);
	return p;
}

inline LPVOID __stdcall _AtlHeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T nSize, LPCSTR lpszFileName, int nLine)
{
	LPVOID p = NULL;
#ifndef _ATL_NO_TRACK_HEAP
	hHeap; // unused
	dwFlags; // unused
	p = _realloc_dbg(lpMem, nSize, _NORMAL_BLOCK, lpszFileName, nLine);
#else
	p = HeapReAlloc(hHeap, dwFlags, lpMem, nSize);
#endif

	_AtlRecordAllocation(lpszFileName, nLine, "HeapReAlloc", nSize);
	return p;
}

inline BOOL __stdcall _AtlHeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "HeapFree", 0);
#ifndef _ATL_NO_TRACK_HEAP
	hHeap; // unused
	dwFlags; // unused
	_free_dbg(lpMem, _NORMAL_BLOCK);
	return TRUE;
#else
	return HeapFree(hHeap, dwFlags, lpMem);
#endif
}

inline SIZE_T __stdcall _AtlHeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "HeapSize", 0);
	return HeapSize(hHeap, dwFlags, lpMem);
}

inline BOOL __stdcall _AtlHeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "HeapValidate", 0);
	return HeapValidate(hHeap, dwFlags, lpMem);
}

inline LPVOID __stdcall _AtlVirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "VirtualAlloc", dwSize);
	return VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);
}

inline BOOL __stdcall _AtlVirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "VirtualFree", 0);
	return VirtualFree(lpAddress, dwSize, dwFreeType);
}

inline SIZE_T __stdcall _AtlVirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, DWORD dwLength, LPCSTR lpszFileName, int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "VirtualQuery", 0);
	return VirtualQuery(lpAddress, lpBuffer, dwLength);
}

#define HeapCreate(flOptions, dwInitialSize, dwMaximumSize) ATL::_AtlHeapCreate(flOptions, dwInitialSize, dwMaximumSize, __FILE__, __LINE__)
#define HeapDestroy(hHeap) ATL::_AtlHeapDestroy(hHeap, __FILE__, __LINE__)
#define HeapAlloc(hHeap, dwFlags, nSize) ATL::_AtlHeapAlloc(hHeap, dwFlags, nSize, __FILE__, __LINE__)
#define HeapReAlloc(hHeap, dwFlags, lpMem, nSize) ATL::_AtlHeapReAlloc(hHeap, dwFlags, lpMem, nSize, __FILE__, __LINE__)
#define HeapFree(hHeap, dwFlags, lpMem) ATL::_AtlHeapFree(hHeap, dwFlags, lpMem, __FILE__, __LINE__)
#define HeapSize(hHeap, dwFlags, lpMem) ATL::_AtlHeapSize(hHeap, dwFlags, lpMem, __FILE__, __LINE__)
#define HeapValidate(hHeap, dwFlags, lpMem) ATL::_AtlHeapValidate(hHeap, dwFlags, lpMem, __FILE__, __LINE__)
#define VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect) ATL::_AtlVirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect, __FILE__, __LINE__)
#define VirtualFree(lpAddress,  dwSize, dwFreeType) ATL::_AtlVirtualFree(lpAddress,  dwSize, dwFreeType, __FILE__, __LINE__)
#define VirtualQuery(lpAddress, lpBuffer, dwLength) ATL::_AtlVirtualQuery(lpAddress, lpBuffer, dwLength, __FILE__, __LINE__)

}; // namespace ATL
#pragma pack(pop)

#pragma warning(pop)

#undef ATLDBG_UNUSED

#endif // __ATLDBGMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlenc.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLENC_H__
#define __ATLENC_H__

#pragma once

#include <atlbase.h>
#include <stdio.h>

#pragma pack(push,_ATL_PACKING)
namespace ATL {

#ifndef ATL_UUENCODE_END
#define ATL_UUENCODE_END "end\r\n"
#endif//ATL_UUENCODE_END

//Not including CRLFs
//NOTE: For BASE64 and UUENCODE, this actually
//represents the amount of unencoded characters
//per line
#define ATLSMTP_MAX_QP_LINE_LENGTH       76
#define ATLSMTP_MAX_BASE64_LINE_LENGTH   57
#define ATLSMTP_MAX_UUENCODE_LINE_LENGTH 45


//=======================================================================
// Base64Encode/Base64Decode
// compliant with RFC 2045
//=======================================================================
//
#define ATL_BASE64_FLAG_NONE	0
#define ATL_BASE64_FLAG_NOPAD	1
#define ATL_BASE64_FLAG_NOCRLF  2

inline int Base64EncodeGetRequiredLength(int nSrcLen, DWORD dwFlags=ATL_BASE64_FLAG_NONE)
{
	__int64 nSrcLen4=static_cast<__int64>(nSrcLen)*4;
	ATLENSURE(nSrcLen4 <= INT_MAX);

	int nRet = static_cast<int>(nSrcLen4/3);

	if ((dwFlags & ATL_BASE64_FLAG_NOPAD) == 0)
		nRet += nSrcLen % 3;

	int nCRLFs = nRet / 76 + 1;
	int nOnLastLine = nRet % 76;

	if (nOnLastLine)
	{
		if (nOnLastLine % 4)
			nRet += 4-(nOnLastLine % 4);
	}

	nCRLFs *= 2;

	if ((dwFlags & ATL_BASE64_FLAG_NOCRLF) == 0)
		nRet += nCRLFs;

	return nRet;
}

inline int Base64DecodeGetRequiredLength(int nSrcLen) throw()
{
	return nSrcLen;
}

inline BOOL Base64Encode(
	__in_ecount(nSrcLen) const BYTE *pbSrcData,
	__in int nSrcLen,
	__out_ecount_part_z(*pnDestLen, *pnDestLen) LPSTR szDest,
	__inout int *pnDestLen,
	__in DWORD dwFlags = ATL_BASE64_FLAG_NONE) throw()
{
	static const char s_chBase64EncodingTable[64] = {
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',
		'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',	'h',
		'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
		'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/' };

	if (!pbSrcData || !szDest || !pnDestLen)
	{
		return FALSE;
	}

	if(*pnDestLen < Base64EncodeGetRequiredLength(nSrcLen, dwFlags))
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	int nWritten( 0 );
	int nLen1( (nSrcLen/3)*4 );
	int nLen2( nLen1/76 );
	int nLen3( 19 );

	for (int i=0; i<=nLen2; i++)
	{
		if (i==nLen2)
			nLen3 = (nLen1%76)/4;

		for (int j=0; j<nLen3; j++)
		{
			DWORD dwCurr(0);
			for (int n=0; n<3; n++)
			{
				dwCurr |= *pbSrcData++;
				dwCurr <<= 8;
			}
			for (int k=0; k<4; k++)
			{
				BYTE b = (BYTE)(dwCurr>>26);
				*szDest++ = s_chBase64EncodingTable[b];
				dwCurr <<= 6;
			}
		}
		nWritten+= nLen3*4;

		if ((dwFlags & ATL_BASE64_FLAG_NOCRLF)==0)
		{
			*szDest++ = '\r';
			*szDest++ = '\n';
			nWritten+= 2;
		}
	}

	if (nWritten && (dwFlags & ATL_BASE64_FLAG_NOCRLF)==0)
	{
		szDest-= 2;
		nWritten -= 2;
	}

	nLen2 = (nSrcLen%3) ? (nSrcLen%3 + 1) : 0;
	if (nLen2)
	{
		DWORD dwCurr(0);
		for (int n=0; n<3; n++)
		{
			if (n<(nSrcLen%3))
				dwCurr |= *pbSrcData++;
			dwCurr <<= 8;
		}
		for (int k=0; k<nLen2; k++)
		{
			BYTE b = (BYTE)(dwCurr>>26);
			*szDest++ = s_chBase64EncodingTable[b];
			dwCurr <<= 6;
		}
		nWritten+= nLen2;
		if ((dwFlags & ATL_BASE64_FLAG_NOPAD)==0)
		{
			nLen3 = nLen2 ? 4-nLen2 : 0;
			for (int j=0; j<nLen3; j++)
			{
				*szDest++ = '=';
			}
			nWritten+= nLen3;
		}
	}

	*pnDestLen = nWritten;
	return TRUE;
}

inline int DecodeBase64Char(unsigned int ch) throw()
{
	// returns -1 if the character is invalid
	// or should be skipped
	// otherwise, returns the 6-bit code for the character
	// from the encoding table
	if (ch >= 'A' && ch <= 'Z')
		return ch - 'A' + 0;	// 0 range starts at 'A'
	if (ch >= 'a' && ch <= 'z')
		return ch - 'a' + 26;	// 26 range starts at 'a'
	if (ch >= '0' && ch <= '9')
		return ch - '0' + 52;	// 52 range starts at '0'
	if (ch == '+')
		return 62;
	if (ch == '/')
		return 63;
	return -1;
}

inline BOOL Base64Decode(LPCSTR szSrc, int nSrcLen, BYTE *pbDest, int *pnDestLen) throw()
{
	// walk the source buffer
	// each four character sequence is converted to 3 bytes
	// CRLFs and =, and any characters not in the encoding table
	// are skiped

	if (szSrc == NULL || pnDestLen == NULL)
	{
		ATLASSERT(FALSE);
		return FALSE;
	}
	
	LPCSTR szSrcEnd = szSrc + nSrcLen;
	int nWritten = 0;
	
	BOOL bOverflow = (pbDest == NULL) ? TRUE : FALSE;
	
	while (szSrc < szSrcEnd &&(*szSrc) != 0)
	{
		DWORD dwCurr = 0;
		int i;
		int nBits = 0;
		for (i=0; i<4; i++)
		{
			if (szSrc >= szSrcEnd)
				break;
			int nCh = DecodeBase64Char(*szSrc);
			szSrc++;
			if (nCh == -1)
			{
				// skip this char
				i--;
				continue;
			}
			dwCurr <<= 6;
			dwCurr |= nCh;
			nBits += 6;
		}

		if(!bOverflow && nWritten + (nBits/8) > (*pnDestLen))
			bOverflow = TRUE;

		// dwCurr has the 3 bytes to write to the output buffer
		// left to right
		dwCurr <<= 24-nBits;
		for (i=0; i<nBits/8; i++)
		{
			if(!bOverflow)
			{
				*pbDest = (BYTE) ((dwCurr & 0x00ff0000) >> 16);
				pbDest++;
			}
			dwCurr <<= 8;
			nWritten++;
		}

	}
	
	*pnDestLen = nWritten;
	
	if(bOverflow)
	{
		if(pbDest != NULL)
		{
			ATLASSERT(FALSE);
		}
	
		return FALSE;
	}
	
	return TRUE;
}


//=======================================================================
// UUEncode/UUDecode
// compliant with POSIX P1003.2b/D11
//=======================================================================
//
//Flag to determine whether or not we should encode the header
#define ATLSMTP_UUENCODE_HEADER 1

//Flag to determine whether or not we should encode the end
#define ATLSMTP_UUENCODE_END    2

//Flag to determine whether or not we should do data stuffing
#define ATLSMTP_UUENCODE_DOT    4

//The the (rough) required length of the uuencoded stream based
//on input of length nSrcLen
inline int UUEncodeGetRequiredLength(int nSrcLen)
{
	__int64 nRet64=static_cast<__int64>(nSrcLen)*4/3;	
	nRet64 += 3*(nSrcLen/ATLSMTP_MAX_UUENCODE_LINE_LENGTH);
	nRet64 += 12+MAX_PATH; // "begin" statement
	nRet64 += 8; // "end" statement
	nRet64 += 1; // dot-stuffing
	ATLENSURE(nRet64 <= INT_MAX && nRet64 >= INT_MIN);
	int nRet = static_cast<int>(nRet64);
	return nRet;
}

//Get the decode required length
inline int UUDecodeGetRequiredLength(int nSrcLen) throw()
{
	return nSrcLen;
}

#define UUENCODE(ch) ((ch) ? ((ch) & 0x3F ) + ' ' : '`')

//encode a chunk of data
inline BOOL UUEncode(
	__in_ecount(nSrcLen) const BYTE* pbSrcData,
	__in int nSrcLen,
	__out_ecount_part_z(*pnDestLen, *pnDestLen) LPSTR szDest,
	__inout int* pnDestLen,
	__in LPCTSTR lpszFile = _T("file"),
	__in DWORD dwFlags = 0) throw()
{	
	//The UUencode character set
	static const char s_chUUEncodeChars[64] = {
		'`','!','"','#','$','%','&','\'','(',')','*','+',',',
		'-','.','/','0','1','2','3','4','5','6','7','8','9',
		':',';','<','=','>','?','@','A','B','C','D','E','F',
		'G','H','I','J','K','L','M','N','O','P','Q','R','S',
		'T','U','V','W','X','Y','Z','[','\\',']','^','_'
	};

	if (!pbSrcData || !szDest || !pnDestLen)
	{
		return FALSE;
	}

	ATLASSERT(*pnDestLen >= UUEncodeGetRequiredLength(nSrcLen));

	BYTE ch1 = 0, ch2 = 0, ch3 = 0;
	int nTotal = 0, nCurr = 0, nWritten = 0, nCnt = 0;

	//if ATL_UUENCODE_HEADER
	//header
	if (dwFlags & ATLSMTP_UUENCODE_HEADER)
	{
		if (!lpszFile || _tcslen(lpszFile) >= MAX_PATH)
		{
			return FALSE;
		}

		//default permission is 666
#if _SECURE_ATL && !defined(_WIN32_WCE)
		nWritten = sprintf_s(szDest, *pnDestLen, "begin 666 %s\r\n", (LPCSTR)(CT2CAEX<MAX_PATH+1>( lpszFile )));
#else
		nWritten = _snprintf(szDest, *pnDestLen, "begin 666 %s\r\n", (LPCSTR)(CT2CAEX<MAX_PATH+1>( lpszFile )));
#endif
		if (nWritten < 0)
		{
			if(*pnDestLen>0)
			{
				szDest[0]='\0';
			}
			return FALSE;
		}

		szDest += nWritten;
	}

	//while we haven't reached the end of the data
	while (nTotal < nSrcLen)
	{
		//If the amount of data is greater than MAX_UUENCODE_LINE_LENGTH
		//cut off at MAX_UUENCODE_LINE_LENGTH
		nCurr = __min(nSrcLen-nTotal, ATLSMTP_MAX_UUENCODE_LINE_LENGTH);
		*szDest = UUENCODE((unsigned char)(nCurr));
		nCurr++;
		nCnt = 1;

		nWritten++;
		//if we need to stuff an extra dot (e.g. when we are sending via SMTP), do it
		if ((dwFlags & ATLSMTP_UUENCODE_DOT) && *szDest == '.')
		{
			*(++szDest) = '.';
			nWritten++;
		}
		szDest++;
		while (nCnt < nCurr)
		{
			//Set to 0 in the uuencoding alphabet
			ch1 = ch2 = ch3 = ' ';
			ch1 = *pbSrcData++;
			nCnt++; 
			nTotal++; 
			if (nTotal < nSrcLen)
			{
				ch2 = *pbSrcData++;
				nCnt++; 
				nTotal++;
			}
			if (nTotal < nSrcLen)
			{
				ch3 = *pbSrcData++;
				nCnt++; 
				nTotal++;
			}

			//encode the first 6 bits of ch1
			*szDest++ = s_chUUEncodeChars[(ch1 >> 2) & 0x3F];
			//encode the last 2 bits of ch1 and the first 4 bits of ch2
			*szDest++ = s_chUUEncodeChars[((ch1 << 4) & 0x30) | ((ch2 >> 4) & 0x0F)];
			//encode the last 4 bits of ch2 and the first 2 bits of ch3
			*szDest++ = s_chUUEncodeChars[((ch2 << 2) & 0x3C) | ((ch3 >> 6) & 0x03)];
			//encode the last 6 bits of ch3
			*szDest++ = s_chUUEncodeChars[ch3 & 0x3F];
			nWritten += 4;
		}
		//output a CRLF
		*szDest++ = '\r'; 
		*szDest++ = '\n'; 
		nWritten += 2;
	}

	//if we need to encode the end, do it
	if (dwFlags & ATLSMTP_UUENCODE_END)
	{
		*szDest++ = '`'; 
		*szDest++ = '\r';
		*szDest++ = '\n';
		nWritten += 3;
		Checked::memcpy_s(szDest, *pnDestLen-nWritten, ATL_UUENCODE_END, sizeof(ATL_UUENCODE_END)-1);
		nWritten += sizeof("end\r\n")-1;
	}
	*pnDestLen = nWritten;
	return TRUE;
}

#define UUDECODE(ch) (((ch) == '`') ? '\0' : ((ch) - ' ') & 0x3F)

inline BOOL UUDecode(
	BYTE* pbSrcData,
	int nSrcLen,
	BYTE* pbDest,
	int* pnDestLen)
{
	if (!pbSrcData || !pbDest || !pnDestLen)
	{
		return FALSE;
	}
	BYTE* pbDestEnd=pbDest+*pnDestLen;
	int nConvert = 0;
	int nScan = 0;

	int nWritten = 0;
	int fSkipLine = 0;
	int nLineLen = 0;

	char chars[4];
	char ch;

	while (nSrcLen > 0)
	{
		if (*pbSrcData == '\r' || *pbSrcData == '\n')
		{
			fSkipLine = 0;
			pbSrcData++;
			nSrcLen--;
			nLineLen = 0;
			continue;
		}
		if (fSkipLine)
		{	
			pbSrcData++;
			nSrcLen--;
			continue;
		}

		// skip begin/end lines
		if ((nSrcLen >= sizeof("begin")-1 && !_strnicmp((char *)pbSrcData, "begin", sizeof("begin")-1)) ||
			(nSrcLen >= sizeof("end")-1 && !_strnicmp((char *)pbSrcData, "end", sizeof("end")-1)))
		{
			fSkipLine = 1;
			continue;
		}

		// skip first character on line 
		nLineLen = UUDECODE(*pbSrcData);
		pbSrcData++;
		nSrcLen--;

		nConvert = 0;
		nScan = 0;

		while (nScan < nLineLen)
		{
			if (nSrcLen > 0)
			{
				if (*pbSrcData == '\r' || *pbSrcData == '\n')
				{
					// invalid uuencoding
					return FALSE;
				}
				ch = *pbSrcData++;
				nSrcLen--;
			}
			else
			{
				ch = ' ';
			}

			chars[nConvert++] = UUDECODE(ch);

			if (nConvert == 4)
			{
				if (nScan++ < nLineLen)
				{
					ATLENSURE(pbDest < pbDestEnd);
					*pbDest++ = (BYTE)(((chars[0] & 0x3F) << 2) | ((chars[1] & 0x3F) >> 4));
				}
				if (nScan++ < nLineLen)
				{
					ATLENSURE(pbDest < pbDestEnd);
					*pbDest++ = (BYTE)(((chars[1] & 0x3F) << 4) | ((chars[2] & 0x3F) >> 2));
				}
				if (nScan++ < nLineLen)
				{
					ATLENSURE(pbDest < pbDestEnd);
					*pbDest++ = (BYTE)(((chars[2] & 0x3F) << 6) | (chars[3] & 0x3F));
				}

				nConvert = 0;
			}
		}
		nWritten+= nLineLen;
	}

	*pnDestLen = nWritten;
	return TRUE;
}

//=======================================================================
// Quoted Printable encode/decode
// compliant with RFC 2045
//=======================================================================
//
inline int QPEncodeGetRequiredLength(int nSrcLen)
{	
	__int64 nRet64 = 3*((3*static_cast<__int64>(nSrcLen))/(ATLSMTP_MAX_QP_LINE_LENGTH-8));
	nRet64 += 3*static_cast<__int64>(nSrcLen);
	nRet64 += 3;
	ATLENSURE(nRet64 <= INT_MAX && nRet64 >= INT_MIN);
	int nRet = static_cast<int>(nRet64);
	return nRet;
}

inline int QPDecodeGetRequiredLength(int nSrcLen) throw()
{
	return nSrcLen;
}


#define ATLSMTP_QPENCODE_DOT 1
#define ATLSMTP_QPENCODE_TRAILING_SOFT 2

inline BOOL QPEncode(__in_ecount(nSrcLen) BYTE* pbSrcData, __in int nSrcLen, __out_ecount_part_z(*pnDestLen, *pnDestLen) LPSTR szDest, __inout int* pnDestLen, __in DWORD dwFlags = 0) throw()
{
	//The hexadecimal character set
	static const char s_chHexChars[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
								'A', 'B', 'C', 'D', 'E', 'F'};

	if (!pbSrcData || !szDest || !pnDestLen)
	{
		return FALSE;
	}

	ATLASSERT(*pnDestLen >= QPEncodeGetRequiredLength(nSrcLen));

	int nRead = 0, nWritten = 0, nLineLen = 0;
	char ch;
	while (nRead < nSrcLen)
	{
		ch = *pbSrcData++;
		nRead++;
		if (nLineLen == 0 && ch == '.' && (dwFlags & ATLSMTP_QPENCODE_DOT))
		{
			*szDest++ = '.';
			nWritten++;
			nLineLen++;
		}
		if ((ch > 32 && ch < 61) || (ch > 61 && ch < 127))
		{
			*szDest++ = ch;
			nWritten++;
			nLineLen++;
		}
		else if ((ch == ' ' || ch == '\t') && (nLineLen < (ATLSMTP_MAX_QP_LINE_LENGTH-12)))
		{
			*szDest++ = ch;
			nWritten++;
			nLineLen++;
		}	
		else
		{
			*szDest++ = '=';
			*szDest++ = s_chHexChars[(ch >> 4) & 0x0F];
			*szDest++ = s_chHexChars[ch & 0x0F];
			nWritten += 3;
			nLineLen += 3;
		}
		if (nLineLen >= (ATLSMTP_MAX_QP_LINE_LENGTH-11))
		{
			*szDest++ = '=';
			*szDest++ = '\r';
			*szDest++ = '\n';
			nLineLen = 0;
			nWritten += 3;
		}
	}
	if (dwFlags & ATLSMTP_QPENCODE_TRAILING_SOFT)
	{
		*szDest++ = '=';
		*szDest++ = '\r';
		*szDest++ = '\n';
		nWritten += 3;
	}

	*pnDestLen = nWritten;

	return TRUE;
}


inline BOOL QPDecode(__in_ecount(nSrcLen) BYTE* pbSrcData, __in int nSrcLen, __out_ecount_part_z(*pnDestLen, *pnDestLen) LPSTR szDest, __inout int* pnDestLen, __in DWORD dwFlags = 0)
{
	if (!pbSrcData || !szDest || !pnDestLen)
	{
		return FALSE;
	}
	
	LPSTR szDestEnd=szDest + *pnDestLen;
	int nRead = 0, nWritten = 0, nLineLen = -1;
	char ch;
	while (nRead <= nSrcLen)
	{
		ch = *pbSrcData++;
		nRead++;
		nLineLen++;
		if (ch == '=')
		{
			//if the next character is a digit or a character, convert
			if (nRead < nSrcLen && (isdigit(static_cast<unsigned char>(*pbSrcData)) || isalpha(static_cast<unsigned char>(*pbSrcData))))
			{
				char szBuf[5];
				szBuf[0] = *pbSrcData++;
				szBuf[1] = *pbSrcData++;
				szBuf[2] = '\0';
				char* tmp = '\0';
				ATLENSURE(szDest < szDestEnd);
				*szDest++ = (BYTE)strtoul(szBuf, &tmp, 16);
				nWritten++;
				nRead += 2;
				continue;
			}
			//if the next character is a carriage return or line break, eat it
			if (nRead < nSrcLen && *pbSrcData == '\r' && (nRead+1 < nSrcLen) && *(pbSrcData+1)=='\n')
			{
				pbSrcData++;
				nRead++;
				nLineLen = -1;
				continue;
			}
			return FALSE;
		}
		if (ch == '\r' || ch == '\n')
		{
			nLineLen = -1;
			continue;
		}
		if ((dwFlags & ATLSMTP_QPENCODE_DOT) && ch == '.' && nLineLen == 0)
		{
			continue;
		}
		ATLENSURE(szDest < szDestEnd);
		*szDest++ = ch;
		nWritten++;
	}

	*pnDestLen = nWritten-1;
	return TRUE;
}

//=======================================================================
// Q and B encoding (for encoding MIME header information)
// compliant with RFC 2047
//=======================================================================

inline int IsExtendedChar(char ch) throw()
{
	return ((ch > 126 || ch < 32) && ch != '\t' && ch != '\n' && ch != '\r');
}

inline int GetExtendedChars(LPCSTR szSrc, int nSrcLen) 
{
	ATLENSURE( szSrc );

	int nChars(0);

	for (int i=0; i<nSrcLen; i++)
	{
		if (IsExtendedChar(*szSrc++))
			nChars++;
	}

	return nChars;
}

#ifndef ATL_MAX_ENC_CHARSET_LENGTH
#define ATL_MAX_ENC_CHARSET_LENGTH 50
#endif

//Get the required length to hold this encoding based on nSrcLen
inline int QEncodeGetRequiredLength(int nSrcLen, int nCharsetLen) throw()
{
	return QPEncodeGetRequiredLength(nSrcLen)+7+nCharsetLen;
}

inline BOOL IsBufferWriteSafe(__in int nNumOfCharsAboutToWrite, __in int nBuffSize)
{
	if(nNumOfCharsAboutToWrite >= nBuffSize)
	{
		ATLASSERT(FALSE);
		return FALSE;
	}
	return TRUE;
}

//QEncode pbSrcData with the charset specified by pszCharSet
inline BOOL QEncode(
	__in_ecount(nSrcLen) BYTE* pbSrcData,
	__in int nSrcLen,
	__out_ecount_part_z(*pnDestLen, *pnDestLen) LPSTR szDest,
	__inout int* pnDestLen,
	__in LPCSTR pszCharSet,
	__out_opt int* pnNumEncoded = NULL) throw()
{
	//The hexadecimal character set
	static const char s_chHexChars[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
								'A', 'B', 'C', 'D', 'E', 'F'};

	if (!pbSrcData || !szDest || !pszCharSet || !pnDestLen)
	{
		return FALSE;
	}

	if(*pnDestLen < QEncodeGetRequiredLength(nSrcLen, ATL_MAX_ENC_CHARSET_LENGTH))
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	int nRead = 0, nWritten = 0, nEncCnt = 0;
	char ch;

	if (!IsBufferWriteSafe(nWritten+2, *pnDestLen))
	{
		return FALSE;
	}
	*szDest++ = '=';
	*szDest++ = '?';
	nWritten = 2;
	
	//output the charset
	while(nWritten < *pnDestLen && *pszCharSet != '\0')
	{
		*szDest++ = *pszCharSet++;
		nWritten++;
	}

	if (!IsBufferWriteSafe(nWritten+3, *pnDestLen))
	{
		return FALSE;
	}
	*szDest++ = '?';
	*szDest++ = 'Q';
	*szDest++ = '?';
	nWritten += 3;
	
	while (nRead < nSrcLen)
	{
		ch = *pbSrcData++;
		nRead++;
		if (((ch > 32 && ch < 61) || (ch > 61 && ch < 127)) && ch != '?' && ch != '_')
		{
			if (!IsBufferWriteSafe(nWritten+1, *pnDestLen))
			{	
					return FALSE;
			}
			*szDest++ = ch;
			nWritten++;
			continue;
					}
		//otherwise it is an unprintable/unsafe character
		if (!IsBufferWriteSafe(nWritten+3, *pnDestLen))
		{
			return FALSE;
		}
		*szDest++ = '=';
		*szDest++ = s_chHexChars[(ch >> 4) & 0x0F];
		*szDest++ = s_chHexChars[ch & 0x0F];
		if (ch < 32 || ch > 126)
			nEncCnt++;
		nWritten += 3;
	}
	if (!IsBufferWriteSafe(nWritten+2, *pnDestLen))
	{
		return FALSE;
	}
	*szDest++ = '?';
	*szDest++ = '=';
	*szDest = 0;
	nWritten += 2;

	*pnDestLen = nWritten;

	if (pnNumEncoded)
		*pnNumEncoded = nEncCnt;

	return TRUE;
}

#define BENCODE_ADDITION_SIZE 7 // size of prefix+suffix added by the encoding.

//Get the required length to hold this encoding based on nSrcLen
inline int BEncodeGetRequiredLength(int nSrcLen, int nCharsetLen) throw()
{
	return Base64EncodeGetRequiredLength(nSrcLen)+BENCODE_ADDITION_SIZE+nCharsetLen;
}

//BEncode pbSrcData with the charset specified by pszCharSet
inline BOOL BEncode(__in_ecount(nSrcLen) BYTE* pbSrcData, __in int nSrcLen, __out_ecount_part_z(*pnDestLen, *pnDestLen) LPSTR szDest, __inout int* pnDestLen, __in LPCSTR pszCharSet) throw()
{
	if (!pbSrcData || !szDest || !pszCharSet || !pnDestLen)
	{
		return FALSE;
	}

	if(*pnDestLen < BEncodeGetRequiredLength(nSrcLen, ATL_MAX_ENC_CHARSET_LENGTH))
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	int nWritten = 0;

	if (!IsBufferWriteSafe(nWritten+2, *pnDestLen))
	{
		return FALSE;
	}
	*szDest++ = '=';
	*szDest++ = '?';
	nWritten = 2;

	//output the charset
	while(nWritten < *pnDestLen && *pszCharSet != '\0')
	{
		*szDest++ = *pszCharSet++;
		nWritten++;
	}

	if (!IsBufferWriteSafe(nWritten+3, *pnDestLen))
	{
		return FALSE;
	}
	*szDest++ = '?';
	*szDest++ = 'B';
	*szDest++ = '?';
	nWritten += 3;

	// the buffer size is *pnDestLen - size of the header and the tail. 
	int DataDestLen = *pnDestLen - BENCODE_ADDITION_SIZE;
	BOOL bRet = Base64Encode(pbSrcData, nSrcLen, szDest, &DataDestLen, ATL_BASE64_FLAG_NOCRLF);
	if (!bRet)
		return FALSE;

	nWritten += DataDestLen;
	szDest += DataDestLen;
	if (!IsBufferWriteSafe(nWritten+2, *pnDestLen))
	{
		return FALSE;
	}
	*szDest++ = '?';
	*szDest++ = '=';
	*szDest = 0;
	nWritten += 2;
	
	*pnDestLen = nWritten;
	return TRUE;
}

//=======================================================================
// AtlUnicodeToUTF8
//
// Support for converting UNICODE strings to UTF8 
// (WideCharToMultiByte does not support UTF8 in Win98)
//
// This function is from the SDK implementation of 
// WideCharToMultiByte with the CP_UTF8 codepage
//
//=======================================================================
//
#define ATL_ASCII                 0x007f

#define ATL_UTF8_2_MAX            0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define ATL_UTF8_1ST_OF_2         0xc0    // 110x xxxx
#define ATL_UTF8_1ST_OF_3         0xe0    // 1110 xxxx
#define ATL_UTF8_1ST_OF_4         0xf0    // 1111 xxxx
#define ATL_UTF8_TRAIL            0x80    // 10xx xxxx

#define ATL_HIGHER_6_BIT(u)       ((u) >> 12)
#define ATL_MIDDLE_6_BIT(u)       (((u) & 0x0fc0) >> 6)
#define ATL_LOWER_6_BIT(u)        ((u) & 0x003f)


#define ATL_HIGH_SURROGATE_START  0xd800
#define ATL_HIGH_SURROGATE_END    0xdbff
#define ATL_LOW_SURROGATE_START   0xdc00
#define ATL_LOW_SURROGATE_END     0xdfff

ATL_NOINLINE inline 
int AtlUnicodeToUTF8(
	__in_ecount(nSrc) LPCWSTR wszSrc,
	__in int nSrc,
	__out_ecount_part_z_opt(nDest, return + 1) LPSTR szDest,
	__in int nDest)
{
	LPCWSTR pwszSrc = wszSrc;
	int     nU8 = 0;                // # of UTF8 chars generated
	DWORD   dwSurrogateChar;
	WCHAR   wchHighSurrogate = 0;
	BOOL    bHandled;

	while ((nSrc--) && ((nDest == 0) || (nU8 < nDest)))
	{
		bHandled = FALSE;

		// Check if high surrogate is available
		if ((*pwszSrc >= ATL_HIGH_SURROGATE_START) && (*pwszSrc <= ATL_HIGH_SURROGATE_END))
		{
			if (nDest)
			{
				// Another high surrogate, then treat the 1st as normal Unicode character.
				if (wchHighSurrogate)
				{
					if (((nU8 + 2) > nU8) && (nU8 + 2) < nDest)
					{
						szDest[nU8++] = (char)(ATL_UTF8_1ST_OF_3 | ATL_HIGHER_6_BIT(wchHighSurrogate));
						szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_MIDDLE_6_BIT(wchHighSurrogate));
						szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_LOWER_6_BIT(wchHighSurrogate));
					}
					else
					{
						// not enough buffer
						nSrc++;
						break;
					}
				}
			}
			else
			{
				if ((nU8 + 3) < nU8)
				{
					// not enough buffer
					nSrc++;
					break;
				}
				nU8 += 3;
			}
			wchHighSurrogate = *pwszSrc;
			bHandled = TRUE;
		}

		if (!bHandled && wchHighSurrogate)
		{
			if ((*pwszSrc >= ATL_LOW_SURROGATE_START) && (*pwszSrc <= ATL_LOW_SURROGATE_END))
			{
				 // valid surrogate pairs
				 if (nDest)
				 {
					 if (((nU8 + 3) > nU8) && ((nU8 + 3) < nDest))
					 {
						 dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*pwszSrc - 0xDC00) + 0x10000);
						 szDest[nU8++] = (ATL_UTF8_1ST_OF_4 |
											   (unsigned char)(dwSurrogateChar >> 18));           // 3 bits from 1st byte
						 szDest[nU8++] =  (ATL_UTF8_TRAIL |
												(unsigned char)((dwSurrogateChar >> 12) & 0x3f)); // 6 bits from 2nd byte
						 szDest[nU8++] = (ATL_UTF8_TRAIL |
											   (unsigned char)((dwSurrogateChar >> 6) & 0x3f));   // 6 bits from 3rd byte
						 szDest[nU8++] = (ATL_UTF8_TRAIL |
											   (unsigned char)(0x3f & dwSurrogateChar));          // 6 bits from 4th byte
					 }
					 else
					 {
						// not enough buffer
						nSrc++;
						break;
					 }
				 }
				 else
				 {
					 // we already counted 3 previously (in high surrogate)
					 if (nU8 + 1 < nU8)
					 {
						// not enough buffer
						nSrc++;
						break;
					 }
					 nU8 += 1;
				 }
				 bHandled = TRUE;
			}
			else
			{
				 // Bad Surrogate pair : ERROR
				 // Just process wchHighSurrogate , and the code below will
				 // process the current code point
				 if (nDest)
				 {
					 if (((nU8 + 2) > nU8) && ((nU8 + 2) < nDest))
					 {
						szDest[nU8++] = (char)(ATL_UTF8_1ST_OF_3 | ATL_HIGHER_6_BIT(wchHighSurrogate));
						szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_MIDDLE_6_BIT(wchHighSurrogate));
						szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_LOWER_6_BIT(wchHighSurrogate));
					 }
					 else
					 {
						// not enough buffer
						nSrc++;
						break;
					 }
				 }
			}
			wchHighSurrogate = 0;
		}

		if (!bHandled)
		{
			if (*pwszSrc <= ATL_ASCII)
			{
				//  Found ASCII.
				if (nDest)
				{
					szDest[nU8] = (char)*pwszSrc;
				}
				if ((nU8 + 1) < nU8)
				{
					// not enough buffer
					nSrc++;
					break;
				}
				nU8++;
			}
			else if (*pwszSrc <= ATL_UTF8_2_MAX)
			{
				//  Found 2 byte sequence if < 0x07ff (11 bits).
				if (nDest)
				{
					if (((nU8 + 1) > nU8) && ((nU8 + 1) < nDest))
					{
						//  Use upper 5 bits in first byte.
						//  Use lower 6 bits in second byte.
						szDest[nU8++] = (char)(ATL_UTF8_1ST_OF_2 | (*pwszSrc >> 6));
						szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_LOWER_6_BIT(*pwszSrc));
					}
					else
					{
						//  Error - buffer too small.
						nSrc++;
						break;
					}
				}
				else
				{
					if ((nU8 + 2) < nU8)
					{
						// not enough buffer
						nSrc++;
						break;
					}
					nU8 += 2;
				}
			}
			else
			{
				//  Found 3 byte sequence.
				if (nDest)
				{
					if (((nU8 + 2) > nU8) && ((nU8 + 2) < nDest))
					{
						//  Use upper  4 bits in first byte.
						//  Use middle 6 bits in second byte.
						//  Use lower  6 bits in third byte.
						szDest[nU8++] = (char)(ATL_UTF8_1ST_OF_3 | ATL_HIGHER_6_BIT(*pwszSrc));
						szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_MIDDLE_6_BIT(*pwszSrc));
						szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_LOWER_6_BIT(*pwszSrc));
					}
					else
					{
						//  Error - buffer too small.
						nSrc++;
						break;
					}
				}
				else
				{
					if ((nU8 + 3) < nU8)
					{
						// not enough buffer
						nSrc++;
						break;
					}
					nU8 += 3;
				}
			}
		}
		pwszSrc++;
	}

	// If the last character was a high surrogate, then handle it as a normal unicode character.
	if ((nSrc < 0) && (wchHighSurrogate != 0))
	{
		if (nDest)
		{
			if (((nU8 + 2) > nU8) && ((nU8 + 2) < nDest))
			{
				szDest[nU8++] = (char)(ATL_UTF8_1ST_OF_3 | ATL_HIGHER_6_BIT(wchHighSurrogate));
				szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_MIDDLE_6_BIT(wchHighSurrogate));
				szDest[nU8++] = (char)(ATL_UTF8_TRAIL    | ATL_LOWER_6_BIT(wchHighSurrogate));
			}
			else
			{
				nSrc++;
			}
		}
	}

	//  Make sure the destination buffer was large enough.
	if (nDest && (nSrc >= 0))
	{
		return 0;
	}

	ATLENSURE(nU8>=0);
	//  Return the number of UTF-8 characters written.
	return nU8;
}


//=======================================================================
// EscapeXML
//
// Support for escaping strings for use in XML documents
//=======================================================================
//

#define ATL_ESC_FLAG_NONE 0
#define ATL_ESC_FLAG_ATTR 1 // escape for attribute values

inline int _AtlCopyNCR(wchar_t wch, wchar_t *wszEsc) throw()
{
	wchar_t szHex[9];
#if _SECURE_ATL && !defined(_WIN32_WCE)
	int nRet = swprintf_s(szHex, _countof(szHex), L"&#x%04X;", wch);
#else
	int nRet = _snwprintf(szHex, _countof(szHex), L"&#x%04X;", wch);
#endif
	Checked::memcpy_s(wszEsc, 9*sizeof(wchar_t), szHex, 8*sizeof(wchar_t));
	return nRet;
}

inline int _AtlCopyNCRPair(DWORD dw, wchar_t *wszEsc) throw()
{
	wchar_t szHex[11];
#if _SECURE_ATL && !defined(_WIN32_WCE)
	int nRet = swprintf_s(szHex, _countof(szHex), L"&#x%06X;", dw);
#else
	int nRet = _snwprintf(szHex, _countof(szHex), L"&#x%06X;", dw);
#endif
	Checked::memcpy_s(wszEsc, 11*sizeof(wchar_t), szHex, 10*sizeof(wchar_t));
	return nRet;
}

// wide-char version
inline int EscapeXML(__in_ecount(nSrcLen) const wchar_t *szIn, __in int nSrcLen, __out_ecount_part_z_opt(nDestLen, return + 1) wchar_t *szEsc, __in int nDestLen, __in DWORD dwFlags = ATL_ESC_FLAG_NONE)
{
	ATLENSURE( szIn != NULL );

	int nCnt(0);
	int nCurrLen(nDestLen);
	int nInc(0);
	wchar_t wchHighSurrogate = 0;
	BOOL bHandled;

	while (nSrcLen--)
	{
		bHandled = FALSE;
		nInc = 0;
		switch (*szIn)
		{
		case L'<': case L'>':
			if ((szEsc != NULL) && (3 < nCurrLen))
			{
				*szEsc++ = L'&';
				*szEsc++ = (*szIn==L'<' ? L'l' : L'g');
				*szEsc++ = L't';	
				*szEsc++ = L';';	
			}
			nInc = 4;
			break;

		case L'&':
			if ((szEsc != NULL) && (4 < nCurrLen))
			{
				Checked::memcpy_s(szEsc, nCurrLen*sizeof(wchar_t), L"&amp;", 5*sizeof(wchar_t));
				szEsc+= 5;
			}
			nInc = 5;
			break;

		case L'\'': case L'\"': // escaping for attribute values
			if (dwFlags & ATL_ESC_FLAG_ATTR)
			{
				if ((szEsc != NULL) && (5 < nCurrLen))
				{
					Checked::memcpy_s(szEsc, nCurrLen*sizeof(wchar_t), (*szIn == L'\'' ? L"&apos;" : L"&quot;"), 6*sizeof(wchar_t));
					szEsc+= 6;
				}
				nInc = 6;
				break;
			}
			// fall through

		default:
			// check if high surrogate is available
			if ((*szIn >= ATL_HIGH_SURROGATE_START) && (*szIn <= ATL_HIGH_SURROGATE_END))
			{
				// another high surrogate, then treat the 1st as normal unicode character
				if (wchHighSurrogate)
				{
					if ((szEsc != NULL) && (7 < nCurrLen))
					{
						_AtlCopyNCR(wchHighSurrogate, szEsc);
						szEsc+= 8;
					}
					nInc = 8;
				}
				wchHighSurrogate = *szIn;
				bHandled = TRUE;
			}
			if ((!bHandled) && (wchHighSurrogate))
			{
				if ((*szIn >= ATL_LOW_SURROGATE_START) && (*szIn <= ATL_LOW_SURROGATE_END))
				{
					// valid surrogate pairs
					DWORD dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*szIn - 0xDC00) + 0x10000);
					if ((szEsc != NULL) && (9 < nCurrLen))
					{
						_AtlCopyNCRPair(dwSurrogateChar, szEsc);
						szEsc+= 10;
					}
					nInc = 10;
					bHandled = TRUE;
				}
				else
				{
					// bad surrogate pair: ERROR
					// just process wchHighSurrogate, and the code below will
					// process the current code point
					if ((szEsc != NULL) && (7 < nCurrLen))
					{
						_AtlCopyNCR(wchHighSurrogate, szEsc);
						szEsc+= 8;
					}
					nCurrLen-= 8;
					nCnt+= 8;
				}
				wchHighSurrogate = 0;
			}
			if (!bHandled)
			{
				if ((*szIn < 0x0020) || (*szIn > 0x007E))
				{
					if ((szEsc != NULL) && (7 < nCurrLen))
					{
						_AtlCopyNCR(*szIn, szEsc);
						szEsc+= 8;
					}
					nInc = 8;
				}
				else
				{
					if ((szEsc != NULL) && (0 < nCurrLen))
					{
						*szEsc++ = *szIn;
					}
					nInc = 1;
				}
			}
		}

		nCurrLen -= nInc;
		nCnt+= nInc;

		szIn++;
	}

	// If the last character was a high surrogate, then handle it as a normal unicode character.
	if (wchHighSurrogate != 0)
	{
		if ((wchHighSurrogate < 0x0020) || (wchHighSurrogate > 0x007E))
		{
			if ((szEsc != NULL) && (7 < nCurrLen))
			{
				_AtlCopyNCR(wchHighSurrogate, szEsc);
			}
			nCurrLen -= 8;
			nCnt+= 8;
		}
		else
		{
			if ((szEsc != NULL) && (0 < nCurrLen))
			{
				*szEsc = wchHighSurrogate;
			}
			nCurrLen--;
			nCnt++;
		}
	}


	if ((szEsc != NULL) && (nCurrLen < 0))
	{
		return 0;
	}

	return nCnt;
}

//=======================================================================
// HexEncode, HexDecode
//
// Support for encoding/decoding binary XML datatypes with hex encoding
//=======================================================================
//

inline int AtlHexEncodeGetRequiredLength(int nSrcLen)
{
	__int64 nRet64=2*static_cast<__int64>(nSrcLen)+1;
	ATLENSURE(nRet64 <= INT_MAX && nRet64 >= INT_MIN);
	int nRet = static_cast<int>(nRet64);	
	return nRet;
}

inline int AtlHexDecodeGetRequiredLength(int nSrcLen) throw()
{
	return nSrcLen/2;
}

inline BOOL AtlHexEncode(
	__in_ecount(nSrcLen) const BYTE *pbSrcData,
	__in int nSrcLen,
	__out_ecount_part_z(*pnDestLen, *pnDestLen) LPSTR szDest,
	__inout int *pnDestLen) throw()
{
	static const char s_chHexChars[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
										  'A', 'B', 'C', 'D', 'E', 'F'};

	if (!pbSrcData || !szDest || !pnDestLen)
	{
		return FALSE;
	}
	
	if(*pnDestLen < AtlHexEncodeGetRequiredLength(nSrcLen))
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	int nRead = 0;
	int nWritten = 0;
	BYTE ch;
	while (nRead < nSrcLen)
	{
		ch = *pbSrcData++;
		nRead++;
		*szDest++ = s_chHexChars[(ch >> 4) & 0x0F];
		*szDest++ = s_chHexChars[ch & 0x0F];
		nWritten += 2;
	}

	*pnDestLen = nWritten;

	return TRUE;
}

#ifdef _CHAR_UNSIGNED
#define ATL_HEX_INVALID CHAR_MAX
#else
/* In pre-V8 this was always the value, which meant we didn't compile clean with /J */
#define ATL_HEX_INVALID ((char)(-1))
#endif

//Get the decimal value of a hexadecimal character
inline char AtlGetHexValue(char ch) throw()
{
	if (ch >= '0' && ch <= '9')
		return (ch - '0');
	if (ch >= 'A' && ch <= 'F')
		return (ch - 'A' + 10);
	if (ch >= 'a' && ch <= 'f')
		return (ch - 'a' + 10);
	return ATL_HEX_INVALID;	
}

inline BOOL AtlHexDecode(
	LPCSTR pSrcData, 
	int nSrcLen, 
	LPBYTE pbDest, 
	int* pnDestLen) throw()
{
	if (!pSrcData || !pbDest || !pnDestLen)
	{
		return FALSE;
	}

	if(*pnDestLen < AtlHexDecodeGetRequiredLength(nSrcLen))
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	int nRead = 0;
	int nWritten = 0;
	while (nRead < nSrcLen)
	{
		char ch1 = AtlGetHexValue((char)*pSrcData++);
		char ch2 = AtlGetHexValue((char)*pSrcData++);
		if ((ch1==ATL_HEX_INVALID) || (ch2==ATL_HEX_INVALID))
		{
			return FALSE;
		}
		*pbDest++ = (BYTE)(16*ch1+ch2);
		nWritten++;
		nRead += 2;
	}

	*pnDestLen = nWritten;
	return TRUE;
}

} // namespace ATL
#pragma pack(pop)

#endif // __ATLENC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atldefce.h ===
// This is a part of the Active Template Library and the 
// Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library and Microsoft Foundation Classes 
// Reference and related electronic documentation provided 
// with the libraries.
// See these sources for detailed information regarding the
// Active Template Library and Microsoft Foundation Classes
// products.

#ifndef __ATLDEFCE_H__
#define __ATLDEFCE_H__

//#pragma once

#ifndef _WIN32_WCE
	#error atldefce.h requires _WIN32_WCE to be defined and altdefce.h will automatically be included if _WIN32_WCE is defined
#endif

#ifndef _ATL_WINCEINTERNAL
#include <ceconfig.h>
#endif

//
// Determine the level of support the Windows CE SDK includes
//

#undef _CE_BASE
#undef _CE_COM
#undef _CE_OLE
#undef _CE_DCOM
#undef _CE_WIN
#undef _CE_ACTIVEX

#if !defined(_ATL_DLL_IMPL) && !defined(_ATL_STATIC_LIB_IMPL) && !defined(_ATL_WINCEINTERNAL)

#if defined(_WIN32_WCE) && (_WIN32_WCE >= 0x420)
#define _CE_BASE
#endif

#if defined(_CE_BASE) && defined(DCOM_MODULES_OLE32) && defined(DCOM_MODULES_OLEAUT32) && defined(DCOM_MODULES_UUID) && defined(OLE32_MCOMBASE) && defined(OLE32_MCOMMEM) && defined(OLE32_MCOMSTR) && defined(OLEAUT32_OAALL ) && defined(CE_MODULES_FILESYS) && ( defined(COREDLL_CORELOC) || defined(COREDLL_LOCUSA) )
#define _CE_COM
#endif

#if defined(_CE_COM) && defined(OLE32_MCOMMON) && (defined(OLE32_MCOMSTM) || defined(OLE32_STG)) && defined(OLE32_DOCFILE) && defined(OLE32_OLE232)
#define _CE_OLE
#endif

#if defined(_CE_BASE) && defined(DCOM_MODULES_OLE32) && defined(DCOM_MODULES_OLEAUT32) && defined(DCOM_MODULES_UUID) && defined(OLE32_DCOMOLE) && defined(OLEAUT32_OAALL) && defined(OLEAUT32_IDISPPROXY)
#define _CE_DCOM
#endif

#if !defined(_CE_OLE) && !defined(_CE_DCOM)
	#error This Windows CE SDK does not support mini-COM with OLE or the full DCOM.  One of these is required inorder to use ATL.
#endif

#if (defined(_CE_DCOM) || defined(_CE_OLE)) && defined(CE_MODULES_GWES) && defined(GWES_WMBASE) && defined(GWES_MSGQUE) && defined(GWES_WINMGR) && defined(GWES_DRAWMBAR) && defined(GWES_TIMER) && defined(GWES_DLGMGR) && defined(GWES_SBCMN) && defined(GWES_CARET) && defined(GWES_CLIPBD) && defined(GWES_BTNCTL) && defined(GWES_EDCTL) && defined(GWES_LBCTL) && defined(GWES_MSGBOX) && defined(GWES_SCBCTL) && defined(GWES_STCCTL) && (defined(GWES_MGTT) || defined(GWES_MGRAST) || defined(GWES_GDIFONTS) || defined(GWES_PGDI)) && (defined(GWES_MGBASE) || defined(GWES_PGDI)) && (defined(GWES_MGBLT) || defined(GWES_PGDI)) && (defined(COREDLL_GDI_C) || defined(COREDLL_MGDI_C)) && (defined(GWES_MGBLT2) || defined(GWES_PGDI)) && (defined(GWES_MGDRAW) || defined(GWES_PGDI)) && defined(GWES_LOADIMG) && defined(COREDLL_RECTAPI) && defined(GWES_FOREGND) && (defined(GWES_CURSOR) || defined(GWES_MCURSOR)) && defined(GWES_KBDUI) && defined(GWES_CMBCTL)
#define _CE_WIN
#else
	#pragma message("_CE_WIN was not defined because this Windows CE SDK does not support the necessary GUI components.")
#endif

#if defined(_CE_WIN) && (defined(_CE_DCOM) || defined(_CE_ALLOW_SINGLE_THREADED_OBJECTS_IN_MTA))
#define _CE_ACTIVEX
#elif !defined(_CE_DCOM)
	#pragma message("_CE_ACTIVEX was not defined because this Windows CE SDK does not have DCOM.")
	#pragma message("\t_CE_ACTIVEX could be caused to be defined by defining _CE_ALLOW_SINGLE_THREADED_OBJECTS_IN_MTA, but it is recommended that this be done only for single-threaded apps.")
#endif

#else // !defined(_ATL_DLL_IMPL) && !defined(_ATL_STATIC_LIB_IMPL) && !defined(_ATL_WINCEINTERNAL)

// Turn on highest support levels for the internal build of ATL
#define _CE_BASE
#ifndef _ATL_NO_DCOM_IMPL
#define _CE_DCOM
#endif // !_ATL_NO_DCOM_IMPL
#define _CE_WIN
#define _CE_ACTIVEX

#endif // !defined(_ATL_DLL_IMPL) && !defined(_ATL_STATIC_LIB_IMPL) && !defined(_ATL_WINCEINTERNAL)

#if defined(SHELLW_MODULES_IEXPLORE)
#define _CE_PIE
#else
#if defined(IE_MODULES_UUID) || defined(_ATL_WINCEINTERNAL)
#define _CE_IE
#endif
#endif

#ifdef _CE_DCOM

#ifdef _CE_ALLOW_SINGLE_THREADED_OBJECTS_IN_MTA
	#undef _CE_ALLOW_SINGLE_THREADED_OBJECTS_IN_MTA
	#pragma message("_CE_ALLOW_SINGLE_THREADED_OBJECTS_IN_MTA was undefined because this Windows CE SDK has DCOM support")
#endif // _CE_ALLOW_SINGLE_THREADED_OBJECTS_IN_MTA

#else // _CE_DCOM

// _CE_DCOM not defined, so all objects live in the MTA
#ifndef _ATL_FREE_THREADED 
#define _ATL_FREE_THREADED
#endif

#ifdef _ATL_APARTMENT_THREADED
	#undef _ATL_APARTMENT_THREADED
	#pragma message("_ATL_APARTMENT_THREADED was undefined and _ATL_FREE_THREADED was defined because this Windows CE SDK does not have DCOM support")
#endif

#ifdef _ATL_SINGLE_THREADED
	#undef _ATL_SINGLE_THREADED
	#pragma message("_ATL_SINGLE_THREADED was undefined and _ATL_FREE_THREADED was defined because this Windows CE SDK does not have DCOM support")
#endif

#endif // _CE_DCOM

#if !defined(_CE_ACTIVEX) && !defined(_ATL_NO_HOSTING)
	#define _ATL_NO_HOSTING
	#pragma message("_ATL_NO_HOSTING was defined because _CE_ACTIVEX was not defined.")
#endif

#if !defined(_CE_WIN) && !defined(_ATL_CE_NO_GUI)
	#define _ATL_CE_NO_GUI
	#pragma message("_ATL_CE_NO_GUI was defined because _CE_WIN was not defined.")
#endif

#if defined(_CE_WIN) && !defined(_WINGDI_)
// _CE_WIN is defined, so define _WINGDI_ since it is not defined in Windows CE's wingdi.h 
// and it is needed in atlconv.h
#define _WINGDI_
#endif

#if !defined(WINVER) || (WINVER < 0x0400)
	#undef WINVER
	#define WINVER 0x0400 // This is value is not strongly correlated to the OS version being targeted
	#pragma message("WINVER was defined to be 0x0400, as it was either not set or set to a lower value")
#endif // WINVER

#if defined(_WIN32_WINDOWS)
	#undef _WIN32_WINDOWS
	#pragma message("_WIN32_WINDOWS was undefined as it is not supported for Windows CE")
#endif // WINVER

#if defined(_WIN32_WINNT)
	#undef _WIN32_WINNT
	#pragma message("_WIN32_WINNT was undefined as it is not supported for Windows CE")
#endif // WINVER

#ifdef _ATL_MIN_CRT
	#undef _ATL_MIN_CRT
	#pragma message("_ATL_MIN_CRT was undefined because atlmincrt.lib is not supported for Windows CE")
#endif // _ATL_MIN_CRT

// Windows CE SDKs do no include the correct API's to support the CRT based CStrings.
#ifndef _ATL_CSTRING_NO_CRT
#define _ATL_CSTRING_NO_CRT
#endif

// Windows CE SDKs don't include a debug version of the CRT, nor do Windows CE images.
#ifndef _ATL_NO_DEBUG_CRT
#define _ATL_NO_DEBUG_CRT
#endif

// Don't utilize thread locales, as they are unsupported on Windows CE.
#ifndef _CONVERSION_DONT_USE_THREAD_LOCALE
#define _CONVERSION_DONT_USE_THREAD_LOCALE
#endif

// The semantics of Windows CE services are not compatible with those of Windows services
#ifndef _ATL_NO_SERVICE
#define _ATL_NO_SERVICE
#endif

// Make sure Unicode is turned on, as ANSI/MBCS is largely unsupported on Windows CE
// and ATLMFC is Unicode only.
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by Visual C++ library headers
#endif

#ifdef _MBCS
	#undef _MBCS
	#pragma message("_MBCS was undefined because only Unicode is support for ATLMFC on Windows CE")
#endif // _MBCS

// The methods associated with NO_SHLWAPI_PATH are only provided by IE (not Pocket IE).
#if !defined(_CE_IE) || defined(_ATL_DLL_IMPL) || defined(_ATL_STATIC_LIB_IMPL)
#define NO_SHLWAPI_PATH
#endif

// The Imagehelp APIs are not supported by Windows CE.
#ifndef _ATL_NO_IMAGEHLP
#define _ATL_NO_IMAGEHLP
#endif

// ACLs are not supported by Windows CE.
#ifndef ATL_NO_ACLAPI
#define ATL_NO_ACLAPI
#endif

// CSoapMSXMLInetClient CoCreates a ServerXMLHTTP30, which does not appear to be supported on OSes with only PocketIE.
// Exclude for all platforms as it isn't necessary for just consuming web services, which is all that is supported in ATL Server for CE.
#ifndef ATLSOAP_NOMSXML_INET
#define ATLSOAP_NOMSXML_INET
#endif

#ifdef _M_IX86

#ifndef x86
#define x86 1
#endif

#ifndef _X86_
#define _X86_ 1
#endif

#elif _M_ARM

#ifndef ARM
#define ARM 1
#endif

#ifndef _ARM_
#define _ARM_ 1
#endif

#elif _M_MRX000

#ifndef MIPS
#define MIPS 1
#endif

#ifndef _MIPS_
#define _MIPS_ 1
#endif

#elif (_M_SH==4)

#ifndef SHx
#define SHx 1
#endif

#ifndef _SHX_
#define _SHX_ 1
#endif

#ifndef SH4
#define SH4 1
#endif

#else
	#error Only supported for X86, ARM, MIPS, and SH4.
#endif

#endif  //__ATLDEFCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlevent.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLEVENT_H__
#define __ATLEVENT_H__

#define __ATLEVENT_VER 3

#pragma once

#ifndef __cplusplus
		#error ATL requires C++ compilation (use a .cpp suffix)
#endif

struct __EventingCriticalSectionStub {
   void Lock() {}
   void Unlock() {}
};

struct __EventingCriticalSectionAuto {
	void EmitError(__in_z TCHAR* csError) {
		static const int nMax = 256;
		static const TCHAR szMessage[] = _T("cannot initialize critical section(Error ");
		static const int nMessageLen = sizeof(szMessage)/sizeof(szMessage[0]) - 1;
		TCHAR buf[nMax];
		::ATL::Checked::tcscpy_s( buf, _countof(buf), szMessage ); // the buffer is large enough, no need to check the return value
		::ATL::Checked::tcsncpy_s( buf + nMessageLen, _countof(buf) - nMessageLen, csError, _TRUNCATE);
		MessageBox(0, buf, 0, MB_OK | MB_ICONHAND);
	}
	void Lock() {
		__try {
			EnterCriticalSection(&m_sec);
		} __except(STATUS_NO_MEMORY == GetExceptionCode()) {
			TCHAR* csError = _T("E_OUTOFMEMORY");
			EmitError(csError);
		}
	}
	void Unlock() {
		LeaveCriticalSection(&m_sec);
	}
	__EventingCriticalSectionAuto() {
		__try {
			InitializeCriticalSection(&m_sec);
		} __except(STATUS_NO_MEMORY == GetExceptionCode()) {
			TCHAR* csError = _T("E_OUTOFMEMORY");
			EmitError(csError);
		}
	}
	~__EventingCriticalSectionAuto() { 
		DeleteCriticalSection(&m_sec); 
	}
	CRITICAL_SECTION m_sec;
};

template <class T>
struct __eventingGetAddr {
	typedef void (T::*pmfn_type) ();
	typedef void (*pgfn_type) ();
	union U {
		void *addr;
		void (T::*pmfn)();
		void (*pgfn)();
	};
	static pmfn_type __getMAddr(void *addr) {
		U u;
		u.addr = addr;
		return u.pmfn;
	}
	static void* __getVAddr(pmfn_type pmfn) {
		U u;
		u.pmfn = pmfn;
		return u.addr;
	}
	static pgfn_type __getSMAddr(void *addr) {
		U u;
		u.addr = addr;
		return u.pgfn;
	}
	static void* __getSVAddr(pgfn_type pgfn) {
		U u;
		u.pgfn = pgfn;
		return u.addr;
	}
};

struct __eventNode {
	virtual int __isEqual(void*, void*) = 0;
	virtual int __isEqual(void*) = 0;
	__eventNode* next;
};

struct __eventMainNode {
	int key;
	__eventNode* root_node;
	__eventMainNode* next_event;
};

//
// pvargSrc should only contain the memory for a VARIANT
//
inline HRESULT WINAPI __VariantChangeType(/*[in,out]*/VARIANTARG*& pvargDest, /*[in]*/VARIANTARG* pvargSrc, VARTYPE vt) {
	ATLASSERT(pvargDest != 0 && pvargSrc != 0);
	if( pvargDest == 0 || pvargSrc == 0 )
		return E_INVALIDARG;
	ATLTRACE(_T("ATLEVENT: __VariantChangeType(pvargDest->vt=%d,vt=%d)\n"), pvargDest->vt, vt);

	::VariantInit(pvargSrc);
	HRESULT hr = ::VariantChangeType(pvargSrc, pvargDest, 0, vt);
	if (FAILED(hr)) {
		if (hr == DISP_E_TYPEMISMATCH && (vt & VT_ARRAY) != 0 && (pvargDest->vt & ~VT_BYREF) == (VT_ARRAY | VT_VARIANT)) {
			return S_OK; // you're on your own
		}
	} else {
		::VariantClear(pvargDest);
		*pvargDest = *pvargSrc;
	}
	return hr;
}

HRESULT WINAPI _com_handle_excepinfo(EXCEPINFO& excepInfo, IErrorInfo** pperrinfo);

#pragma pack(push,_ATL_PACKING)
namespace ATL {

    inline HRESULT AtlExcepInfoFromErrorInfo(HRESULT hrInvoke, EXCEPINFO *pExcepInfo)
    {
        if (pExcepInfo == NULL)
        {
            return E_POINTER;
        }
        pExcepInfo->pfnDeferredFillIn = NULL;
        pExcepInfo->scode = hrInvoke;
        CComPtr<IErrorInfo> spErrInfo;
        HRESULT hr = GetErrorInfo(0, &spErrInfo);
        if (SUCCEEDED(hr))
        {
            // Set up ErrInfo object
            // Ignore any errors. If additional error information is not
            // available then corresponding pointer will be NULL or 0
            spErrInfo->GetSource(&pExcepInfo->bstrSource);
            spErrInfo->GetDescription(&pExcepInfo->bstrDescription);
            spErrInfo->GetHelpFile(&pExcepInfo->bstrHelpFile);
            spErrInfo->GetHelpContext(&pExcepInfo->dwHelpContext);
        }
        return hr;
    }

	inline HRESULT
	__ComInvokeEventHandler(IDispatch* pDispatch, DISPID id, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult) {
		if (pVarResult != 0) {
			::VariantInit(pVarResult);
		}
		EXCEPINFO excepInfo;
		memset(&excepInfo, 0, sizeof excepInfo);
		UINT nArgErr = (UINT)-1;
		HRESULT hr = pDispatch->Invoke(id, IID_NULL, LOCALE_USER_DEFAULT, wFlags, pDispParams, pVarResult, &excepInfo, &nArgErr);
		if (FAILED(hr)) {
			IErrorInfo* perrinfo = 0;
			if (SUCCEEDED(_com_handle_excepinfo(excepInfo, &perrinfo)))
			{
				SetErrorInfo(0, perrinfo);
				perrinfo->Release();
			}
		}
		return hr;
	}

	struct __EventHandlerProxy {
		virtual HRESULT CDECL __eventHandlerProxy(int idx, ...) = 0;
	};
	struct __EventHandlerNodeProxy {
		virtual int __Index(int i) = 0;
	};
	template <typename T /*super*/>
	class __ComEventingImpl : public __EventHandlerProxy {
		enum { __InvalidIndex = -1 };
		struct __ComEventingNode : __EventHandlerNodeProxy {
			__ComEventingNode(T* pThis = 0, IUnknown* pSource = 0, IUnknown* pSink = 0,
				const _GUID* pGuid = 0, int nSize = 0) {
				__pThis = pThis;
				__nHooks = 0;
				__dwAdvise = 0;
				__pSource = pSource;
				__pSink = pSink;
				__pNext = 0;
				__pGuid = const_cast<_GUID*> (pGuid);
				__nArraySize = nSize;
				__proxyIndex = NULL;
				__proxyIndex = new int[__nArraySize];
				memset(__proxyIndex, 0xff, __nArraySize*sizeof(int));
			}
			int __Index(int i) {
				return __proxyIndex[i];
			}
			T* __pThis;
			int *__proxyIndex;
			int __nArraySize;
			int __nHooks;
			unsigned long __dwAdvise;
			CComPtr<IUnknown> __pSource;
			IUnknown* __pSink;
			_GUID* __pGuid;
			__ComEventingNode* __pNext;
		};
		__ComEventingNode* __pFirst;
		__ComEventingNode* __pLast;
		__ComEventingNode* __pCurrent;
	public:
		__ComEventingImpl() {
			__pCurrent = __pFirst = __pLast = 0;
		}
		~__ComEventingImpl() {
			if (__pFirst != 0) {
				__pCurrent = __pFirst;
				while (__pCurrent != 0) {
					__pCurrent->__pSink->Release();
					delete [] __pCurrent->__proxyIndex;
					__pFirst = __pCurrent;
					__pCurrent = __pCurrent->__pNext;
					delete __pFirst;
				}
			}
		}
		template <typename U /*interface*/>
		HRESULT __WhichThis(IUnknown* pS, T* pThis, int nSize, bool bNext, int idx) {
			if (bNext) {
				 if (__pCurrent != 0) {
					 __pCurrent = __pCurrent->__pNext;
				 }
			} else {
				__pCurrent = __pFirst;
			}
			if (__pCurrent == 0
				|| !__pCurrent->__pSource.IsEqualObject(pS)
				|| __pCurrent->__pThis != pThis
				|| !IsEqualGUID(*U::Guid(), *__pCurrent->__pGuid)) {
				if (__pCurrent != 0) {
					__ComEventingNode* pTheOne = 0;
					while ((__pCurrent = __pCurrent->__pNext) != 0) {
						if (__pCurrent->__pSource.IsEqualObject(pS)
							&& (__pCurrent->__pThis == pThis)
							&& IsEqualGUID(*U::Guid(), *__pCurrent->__pGuid)) {
							if (nSize > 0 || __pCurrent->__proxyIndex[idx] != __InvalidIndex) {
								pTheOne = __pCurrent;
								if (nSize > 0) {
									break;
								}
							}
						 }
					 }
					 if (pTheOne != 0) {
						 __pCurrent = pTheOne;
						 return S_OK;
					 }
				}
				if (nSize > 0) {
					CComObject<U>* pSink;
					HRESULT hr = CComObject<U>::CreateInstance(&pSink);
					if (FAILED(hr)) {
						return hr;
					}
					pSink->AddRef();
					pSink->__pThis = pThis;
					ATLTRY( pSink->__pThat = __pCurrent = new __ComEventingNode(pThis, pS, pSink, U::Guid(), nSize) );
					if( pSink->__pThat == NULL )
						return E_OUTOFMEMORY;
					if (__pLast != 0) {
						__pLast->__pNext = __pCurrent;
					} else {
						__pFirst = __pCurrent;
					}
					__pLast = __pCurrent;
				}
			}
			return S_OK;
		}
		template <typename U /*interface*/>
		HRESULT __AddHandler(T* pThis, int idxSink, IUnknown* pS, int idx, int nSize) {
			if (pS == 0 || pThis == 0) {
				return E_FAIL;
			}
			bool bNext = false;
			bool bDone = false;
			while (!bDone) {
				HRESULT hr = __WhichThis<U>(pS, pThis, nSize, bNext, idx);
				if (SUCCEEDED(hr)) {
					if (__pCurrent->__proxyIndex[idx] == __InvalidIndex) {
						__pCurrent->__proxyIndex[idx] = idxSink;
						++__pCurrent->__nHooks;
						__pCurrent->__pThis = pThis;
						bDone = true;
					}
					if (__pCurrent->__dwAdvise == 0) {
						return AtlAdvise(pS, __pCurrent->__pSink, *U::Guid(), &__pCurrent->__dwAdvise);
					}
					bNext = true;
				} else {
					return hr;
				}
			}
			return S_OK;
		}
		template <typename U /*interface*/>
		HRESULT __RemoveHandler(T* pThis, IUnknown* pS, int idx) {
			bool bNext = false;
			bool bDone = false;
			while (!bDone) {
				__WhichThis<U>(pS, pThis, 0, bNext, idx);
				if (__pCurrent == 0) {
					return E_FAIL;
				}
				if (__pCurrent->__proxyIndex[idx] != __InvalidIndex) {
					__pCurrent->__proxyIndex[idx] = __InvalidIndex;
					--__pCurrent->__nHooks;
					bDone = true;
				}
				if (__pCurrent->__dwAdvise != 0 && __pCurrent->__nHooks == 0) {
					HRESULT hr = AtlUnadvise(pS, *U::Guid(), __pCurrent->__dwAdvise);
					if (SUCCEEDED(hr)) {
						__pCurrent->__pSource.Release();
						__pCurrent->__dwAdvise = 0;
					}
					return hr;
				}
				bNext = true;
			}
			return S_OK;
		}
		HRESULT __RemoveAllHandlers(IUnknown* pS, const _GUID* pIID) {
			HRESULT hr = E_FAIL;
			__pCurrent = __pFirst;
			while (1) {
				if (__pCurrent == 0) {
					return hr;
				} else if ((pS == 0 || __pCurrent->__pSource.IsEqualObject(pS)
					&& (pIID == 0 || IsEqualGUID(*pIID, *__pCurrent->__pGuid)))
					&& __pCurrent->__dwAdvise != 0) {
					hr = AtlUnadvise(__pCurrent->__pSource, *__pCurrent->__pGuid, __pCurrent->__dwAdvise);
					if (SUCCEEDED(hr)) {
						__pCurrent->__pSource.Release();
						__pCurrent->__dwAdvise = 0;
						memset(__pCurrent->__proxyIndex, 0xff, __pCurrent->__nArraySize*sizeof(int));
						__pCurrent->__nHooks = 0;
					}
				}
				__pCurrent = __pCurrent->__pNext;
			}
		}
	};

	class __ComEventingImpl_LD {
		struct __EventCookieNode {
			__EventCookieNode(IUnknown* pS = 0, const _GUID* pG = 0) {
				__nextCookie = 0;
				__dwAdvise = 0;
				__pSource = pS;
				__pGuid = const_cast<_GUID*> (pG);
			}
			__EventCookieNode* __nextCookie;
			unsigned long __dwAdvise;
			CComPtr<IUnknown> __pSource;
			_GUID* __pGuid;
		} *__EventCookies;
	public:
		HRESULT __Advise(IUnknown* pSrc, IUnknown* pSink, const IID& iid) {
			__EventCookieNode* pRoot = __EventCookies;
			while (pRoot != 0) {
				if (pRoot->__pSource.IsEqualObject(pSrc)
					&& IsEqualGUID(iid, *pRoot->__pGuid)
					&& pRoot->__dwAdvise == 0) {
					break;
				}
				pRoot = pRoot->__nextCookie;
			}
			if (pRoot == 0) {
				ATLTRY( pRoot = new __EventCookieNode(pSrc, &iid) );
				if( pRoot == NULL )
					return E_OUTOFMEMORY;
				pRoot->__nextCookie = __EventCookies;
				__EventCookies = pRoot;
			}
			return AtlAdvise(pSrc, pSink, iid, &pRoot->__dwAdvise);
		}
		HRESULT __Unadvise(IUnknown* pSrc, const IID& iid) {
			__EventCookieNode* pRoot = __EventCookies;
			__EventCookieNode* pTheOne = 0;
			while (pRoot != 0) {
				if (pRoot->__pSource.IsEqualObject(pSrc)
					&& IsEqualGUID(iid, *pRoot->__pGuid)
					&& pRoot->__dwAdvise != 0) {
					pTheOne = pRoot;
				}
				pRoot = pRoot->__nextCookie;
			}
			HRESULT hr = E_FAIL;
			if (pTheOne != 0) {
				hr = AtlUnadvise(pSrc, iid, pTheOne->__dwAdvise);
				if (SUCCEEDED(hr)) {
					pTheOne->__pSource.Release();
					pTheOne->__dwAdvise = 0;
				}
			}
			return hr;
		}
		__ComEventingImpl_LD() {
			__EventCookies = 0;
		}
		~__ComEventingImpl_LD() {
			while (__EventCookies != 0) {
				__EventCookieNode* pDead = __EventCookies;
				__EventCookies = __EventCookies->__nextCookie;
				delete pDead;
			}
		}
	};
}

#pragma pack(pop)
#endif // __ATLEVENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlhost.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLHOST_H__
#define __ATLHOST_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4127) // conditional expression constant
#pragma warning(disable: 4571) //catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include <urlmon.h>
#include <mshtmhst.h>
#if !defined(_WIN32_WCE) || defined(_CE_IE)
#include <mshtml.h>
#include <exdisp.h>
#endif

#ifndef _ATL_AXHOST
#define _ATL_AXHOST
#endif //_ATL_AXHOST

#include <atlwin.h>
#include <atlcom.h>

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifdef _ATL_NO_HOSTING
#if defined(_WIN32_WCE) && !defined(_CE_DCOM) && !defined(_CE_ALLOW_SINGLE_THREADED_OBJECTS_IN_MTA)
	#error atlhost.h requires Hosting support (_ATL_NO_HOSTING is defined).  For Windows CE platforms without DCOM support, _CE_ALLOW_SINGLE_THREADED_OBJECTS_IN_MTA needs to be defined.
#else
	#error atlhost.h requires Hosting support (_ATL_NO_HOSTING is defined)
#endif
#endif //_ATL_NO_HOSTING


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

#ifndef _WIN32_WCE
#define ATL_RDW_WHOLE_WINDOW (RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME)
#else // _WIN32_WCE
#define ATL_RDW_WHOLE_WINDOW (RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT)
#endif // _WIN32_WCE

//AtlAxWinTerm is not exported
inline BOOL AtlAxWinTerm()
{
#ifndef _ATL_DLL //don't unregister DLL's version
	UnregisterClass(CAxWindow::GetWndClassName(), _AtlBaseModule.GetModuleInstance());
	UnregisterClass(CAxWindow2::GetWndClassName(), _AtlBaseModule.GetModuleInstance());
#endif
	return TRUE;
}


// Define this to host SHDOCVW rather than MSHTML
#define SHDOCVW

UINT __declspec(selectany) WM_ATLGETHOST = 0;
UINT __declspec(selectany) WM_ATLGETCONTROL = 0;

typedef HRESULT (__stdcall *typeMkParseDisplayName)(IBindCtx*, LPCWSTR , ULONG*, LPMONIKER*);

static HRESULT CreateNormalizedObject(LPCOLESTR lpszTricsData, REFIID riid, void** ppvObj, bool& bWasHTML, BSTR bstrLicKey)
{
	ATLASSERT(ppvObj);
	if (ppvObj == NULL)
	{
		return E_POINTER;
	}
	*ppvObj = NULL;

	CLSID clsid;
	HRESULT hr = E_FAIL;

	bWasHTML = false;

	if (lpszTricsData == NULL || lpszTricsData[0] == 0)
	{
		return S_OK;
	}

	// Is it HTML ?
	if ((lpszTricsData[0] == OLECHAR('M') || lpszTricsData[0] == OLECHAR('m')) &&
		(lpszTricsData[1] == OLECHAR('S') || lpszTricsData[1] == OLECHAR('s')) &&
		(lpszTricsData[2] == OLECHAR('H') || lpszTricsData[2] == OLECHAR('h')) &&
		(lpszTricsData[3] == OLECHAR('T') || lpszTricsData[3] == OLECHAR('t')) &&
		(lpszTricsData[4] == OLECHAR('M') || lpszTricsData[4] == OLECHAR('m')) &&
		(lpszTricsData[5] == OLECHAR('L') || lpszTricsData[5] == OLECHAR('l')) &&
		(lpszTricsData[6] == OLECHAR(':')))
	{
#if !defined(_WIN32_WCE) || defined(_CE_IE)
		// It's HTML, so let's create mshtml
		hr = CoCreateInstance(__uuidof(HTMLDocument), NULL, CLSCTX_INPROC_SERVER, riid, ppvObj);
#else // !defined(_WIN32_WCE) || defined(_CE_IE)
#ifdef _CE_PIE
		ATLTRACE(atlTraceHosting, 0, L"PocketIE does not support the HTMLDocument class");
#else
		ATLTRACE(atlTraceHosting, 0, L"The HTMLDocument class is not supported by the current SDK");
#endif
		hr = E_UNEXPECTED;
#endif // !defined(_WIN32_WCE) || defined(_CE_IE)
		bWasHTML = true;
	}
	// Is it a URL?
	else if (CAtlModule::FindOneOf(OLE2CT(lpszTricsData), _T(":")))
	{
#if !defined(_WIN32_WCE) || defined(_CE_IE)
		// URL so let's create shdocvw
		hr = CoCreateInstance(__uuidof(WebBrowser), NULL, CLSCTX_INPROC_SERVER, riid, ppvObj);
#else // !defined(_WIN32_WCE) || defined(_CE_IE)
#ifdef _CE_PIE
		ATLTRACE(atlTraceHosting, 0, L"PocketIE does not support the WebBrowser class");
#else
		ATLTRACE(atlTraceHosting, 0, L"The WebBrowser class is not supported by the current SDK");
#endif
		hr = E_UNEXPECTED;
#endif // !defined(_WIN32_WCE) || defined(_CE_IE)
		bWasHTML = true;
	}
	// assume ProgID or CLSID
	else
	{
		// Can't be clsid, or progid if length is greater than 255
		if (ocslen(lpszTricsData) < 255)
		{
			if (lpszTricsData[0] == '{') // Is it a CLSID?
			{
				hr = CLSIDFromString((LPOLESTR)lpszTricsData, &clsid);
			}
			else
			{
				hr = CLSIDFromProgID((LPOLESTR)lpszTricsData, &clsid); // How about a ProgID?
			}
		}
		if (SUCCEEDED(hr))
		{
			// If the license key is present
			// Create using IClassFactory2.
            if (::SysStringLen(bstrLicKey) != 0)
			{
				CComPtr<IClassFactory2> spClassFactory;
				hr = CoGetClassObject(clsid, CLSCTX_INPROC_SERVER, NULL, __uuidof(IClassFactory2), (void**)&spClassFactory);
				if (SUCCEEDED(hr))
				{
					hr = spClassFactory->CreateInstanceLic(NULL, NULL, riid, bstrLicKey, ppvObj);
				}
			}
			else
			{
				hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, riid, ppvObj);
			}
		}
	}
	return hr;
}


class ATL_NO_VTABLE CAxFrameWindow : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CWindowImpl<CAxFrameWindow>,
	public IOleInPlaceFrame
{
public:
	CAxFrameWindow()
	{
	}
	void FinalRelease()
	{
		m_spActiveObject.Release();
		if (m_hWnd)
			DestroyWindow();
	}

	DECLARE_POLY_AGGREGATABLE(CAxFrameWindow)

	BEGIN_COM_MAP(CAxFrameWindow)
		COM_INTERFACE_ENTRY(IOleInPlaceFrame)
		COM_INTERFACE_ENTRY(IOleInPlaceUIWindow)
		COM_INTERFACE_ENTRY(IOleWindow)
	END_COM_MAP()

	DECLARE_EMPTY_MSG_MAP()

// IOleWindow
	STDMETHOD(GetWindow)(HWND* phwnd)
	{
		ATLASSERT(phwnd != NULL);
		if (phwnd == NULL)
			return E_POINTER;

		if (m_hWnd == NULL)
			Create(NULL, NULL, _T("AXWIN Frame Window"), WS_OVERLAPPEDWINDOW, 0, (UINT)NULL);
		*phwnd = m_hWnd;
		return S_OK;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /*fEnterMode*/)
	{
		return S_OK;
	}

// IOleInPlaceUIWindow
	STDMETHOD(GetBorder)(LPRECT /*lprectBorder*/)
	{
		return S_OK;
	}

	STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
	{
		return INPLACE_E_NOTOOLSPACE;
	}

	STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
	{
		return S_OK;
	}

	STDMETHOD(SetActiveObject)(IOleInPlaceActiveObject* pActiveObject, LPCOLESTR /*pszObjName*/)
	{
		m_spActiveObject = pActiveObject;
		return S_OK;
	}

// IOleInPlaceFrameWindow
	STDMETHOD(InsertMenus)(HMENU /*hmenuShared*/, LPOLEMENUGROUPWIDTHS /*lpMenuWidths*/)
	{
		return S_OK;
	}

	STDMETHOD(SetMenu)(HMENU /*hmenuShared*/, HOLEMENU /*holemenu*/, HWND /*hwndActiveObject*/)
	{
		return S_OK;
	}

	STDMETHOD(RemoveMenus)(HMENU /*hmenuShared*/)
	{
		return S_OK;
	}

	STDMETHOD(SetStatusText)(LPCOLESTR /*pszStatusText*/)
	{
		return S_OK;
	}

	STDMETHOD(EnableModeless)(BOOL /*fEnable*/)
	{
		return S_OK;
	}

	STDMETHOD(TranslateAccelerator)(LPMSG /*lpMsg*/, WORD /*wID*/)
	{
		return S_FALSE;
	}

	CComPtr<IOleInPlaceActiveObject> m_spActiveObject;
};


class ATL_NO_VTABLE CAxUIWindow : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CWindowImpl<CAxUIWindow>,
	public IOleInPlaceUIWindow
{
public:
	CAxUIWindow()
	{
	}

	void FinalRelease()
	{
		m_spActiveObject.Release();
		if (m_hWnd)
			DestroyWindow();
	}

	DECLARE_POLY_AGGREGATABLE(CAxUIWindow)

	BEGIN_COM_MAP(CAxUIWindow)
		COM_INTERFACE_ENTRY(IOleInPlaceUIWindow)
		COM_INTERFACE_ENTRY(IOleWindow)
	END_COM_MAP()

	DECLARE_EMPTY_MSG_MAP()

// IOleWindow
	STDMETHOD(GetWindow)(HWND* phwnd)
	{
		if (m_hWnd == NULL)
			Create(NULL, NULL, _T("AXWIN UI Window"), WS_OVERLAPPEDWINDOW, 0, (UINT)NULL);
		*phwnd = m_hWnd;
		return S_OK;
	}

	STDMETHOD(ContextSensitiveHelp)(BOOL /*fEnterMode*/)
	{
		return S_OK;
	}

// IOleInPlaceUIWindow
	STDMETHOD(GetBorder)(LPRECT /*lprectBorder*/)
	{
		return S_OK;
	}

	STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
	{
		return INPLACE_E_NOTOOLSPACE;
	}

	STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
	{
		return S_OK;
	}

	STDMETHOD(SetActiveObject)(IOleInPlaceActiveObject* pActiveObject, LPCOLESTR /*pszObjName*/)
	{
		m_spActiveObject = pActiveObject;
		return S_OK;
	}

	CComPtr<IOleInPlaceActiveObject> m_spActiveObject;
};


/////////////////////////////////////////////////////////////////////////////
// CAxHostWindow
// This class is not cocreateable

class ATL_NO_VTABLE CAxHostWindow : 
		public CComCoClass<CAxHostWindow , &CLSID_NULL>,
		public CComObjectRootEx<CComSingleThreadModel>,
		public CWindowImpl<CAxHostWindow>,
		public IAxWinHostWindowLic,
		public IOleClientSite,
		public IOleInPlaceSiteWindowless,
		public IOleControlSite,
		public IOleContainer,
		public IObjectWithSiteImpl<CAxHostWindow>,
		public IServiceProvider,
		public IAdviseSink,
#ifndef _ATL_NO_DOCHOSTUIHANDLER
		public IDocHostUIHandler,
#endif
		public IDispatchImpl<IAxWinAmbientDispatchEx, &__uuidof(IAxWinAmbientDispatchEx), &CAtlModule::m_libid, 0xFFFF, 0xFFFF>
{
public:
// ctor/dtor
	CAxHostWindow()
	{
		m_bInPlaceActive = FALSE;
		m_bUIActive = FALSE;
		m_bMDIApp = FALSE;
		m_bWindowless = FALSE;
		m_bCapture = FALSE;
		m_bHaveFocus = FALSE;

		// Initialize ambient properties
		m_bCanWindowlessActivate = TRUE;
		m_bUserMode = TRUE;
		m_bDisplayAsDefault = FALSE;
		m_clrBackground = NULL;
		m_clrForeground = GetSysColor(COLOR_WINDOWTEXT);
		m_lcidLocaleID = LOCALE_USER_DEFAULT;
		m_bMessageReflect = true;

		m_bReleaseAll = FALSE;
		m_bLocked = FALSE;

		m_bSubclassed = FALSE;

		m_dwViewObjectType = 0;
		m_dwAdviseSink = 0xCDCDCDCD;
		m_dwDocHostFlags = DOCHOSTUIFLAG_NO3DBORDER;
		m_dwDocHostDoubleClickFlags = DOCHOSTUIDBLCLK_DEFAULT;
		m_bAllowContextMenu = true;
		m_bAllowShowUI = false;
		m_hDCScreen = NULL;
		m_bDCReleased = true;

		m_dwOleObject = 0;
		m_dwMiscStatus = 0;

		m_hmSize.cx = 0;
		m_hmSize.cy = 0;
		m_pxSize.cx = 0;
		m_pxSize.cy = 0;
		
		m_hAccel = NULL;

		m_rcPos.left = 0;
		m_rcPos.right = 0;
		m_rcPos.top = 0;
		m_rcPos.bottom = 0;
	}

	~CAxHostWindow()
	{
	}
	void FinalRelease()
	{
		CE_VALIDATE_THREADID_ASSERT();
		ReleaseAll();
	}

	virtual void OnFinalMessage(HWND /*hWnd*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		GetControllingUnknown()->Release();
	}

	DECLARE_NO_REGISTRY()
	DECLARE_POLY_AGGREGATABLE(CAxHostWindow)
	DECLARE_GET_CONTROLLING_UNKNOWN()

	BEGIN_COM_MAP(CAxHostWindow)
		COM_INTERFACE_ENTRY2(IDispatch, IAxWinAmbientDispatchEx)
		COM_INTERFACE_ENTRY(IAxWinHostWindow)
		COM_INTERFACE_ENTRY(IAxWinHostWindowLic)
		COM_INTERFACE_ENTRY(IOleClientSite)
		COM_INTERFACE_ENTRY(IOleInPlaceSiteWindowless)
		COM_INTERFACE_ENTRY(IOleInPlaceSiteEx)
		COM_INTERFACE_ENTRY(IOleInPlaceSite)
		COM_INTERFACE_ENTRY(IOleWindow)
		COM_INTERFACE_ENTRY(IOleControlSite)
		COM_INTERFACE_ENTRY(IOleContainer)
		COM_INTERFACE_ENTRY(IObjectWithSite)
		COM_INTERFACE_ENTRY(IServiceProvider)
		COM_INTERFACE_ENTRY(IAxWinAmbientDispatchEx)
		COM_INTERFACE_ENTRY(IAxWinAmbientDispatch)
#ifndef _ATL_NO_DOCHOSTUIHANDLER
		COM_INTERFACE_ENTRY(IDocHostUIHandler)
#endif
		COM_INTERFACE_ENTRY(IAdviseSink)
	END_COM_MAP()

	static CWndClassInfo& GetWndClassInfo()
	{
		static CWndClassInfo wc =
		{
#ifndef _WIN32_WCE
			{ sizeof(WNDCLASSEX), 0, StartWindowProc,
			  0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW + 1), 0, _T(ATLAXWIN_CLASS), 0 },
#else // _WIN32_WCE
			{ 0, StartWindowProc,
			  0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW + 1), 0, _T(ATLAXWIN_CLASS) },
#endif // _WIN32_WCE
			NULL, NULL, IDC_ARROW, TRUE, 0, _T("")
		};
		return wc;
	}

	BEGIN_MSG_MAP(CAxHostWindow)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
#ifndef _WIN32_WCE
		MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
#endif // _WIN32_WCE
		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
		MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
		if (m_bWindowless && uMsg >= WM_MOUSEFIRST && uMsg <= WM_MOUSELAST)
		{
			// Mouse messages handled when a windowless control has captured the cursor
			// or if the cursor is over the control
			DWORD dwHitResult = m_bCapture ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			if (dwHitResult == HITRESULT_OUTSIDE && m_spViewObject != NULL && m_dwViewObjectType == 7)
			{
				POINT ptMouse = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
				m_spViewObject->QueryHitPoint(DVASPECT_CONTENT, &m_rcPos, ptMouse, 0, &dwHitResult);
			}
			if (dwHitResult == HITRESULT_HIT)
			{
				MESSAGE_HANDLER(WM_MOUSEMOVE, OnWindowlessMouseMessage)				
				MESSAGE_HANDLER(WM_LBUTTONUP, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_RBUTTONUP, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_MBUTTONUP, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_LBUTTONDOWN, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_RBUTTONDOWN, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_MBUTTONDOWN, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_RBUTTONDBLCLK, OnWindowlessMouseMessage)
				MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnWindowlessMouseMessage)
			}
		}
		if (m_bWindowless & m_bHaveFocus)
		{
			// Keyboard messages handled only when a windowless control has the focus
			MESSAGE_HANDLER(WM_KEYDOWN, OnWindowMessage)
			MESSAGE_HANDLER(WM_KEYUP, OnWindowMessage)
			MESSAGE_HANDLER(WM_CHAR, OnWindowMessage)
			MESSAGE_HANDLER(WM_DEADCHAR, OnWindowMessage)
			MESSAGE_HANDLER(WM_SYSKEYDOWN, OnWindowMessage)
			MESSAGE_HANDLER(WM_SYSKEYUP, OnWindowMessage)
			MESSAGE_HANDLER(WM_SYSDEADCHAR, OnWindowMessage)
			MESSAGE_HANDLER(WM_HELP, OnWindowMessage)
			MESSAGE_HANDLER(WM_CANCELMODE, OnWindowMessage)
			MESSAGE_HANDLER(WM_IME_CHAR, OnWindowMessage)
			MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnWindowMessage)
			MESSAGE_RANGE_HANDLER(WM_IME_SETCONTEXT, WM_IME_KEYUP, OnWindowMessage)
		}
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
		if (m_bMessageReflect)
		{
			bHandled = TRUE;
			lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled);
			if(bHandled)
				return TRUE;
		}
		MESSAGE_HANDLER(WM_ATLGETHOST, OnGetUnknown)
		MESSAGE_HANDLER(WM_ATLGETCONTROL, OnGetControl)
		MESSAGE_HANDLER(WM_FORWARDMSG, OnForwardMsg)
	END_MSG_MAP()

	LRESULT OnForwardMsg(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(lParam != 0);
		LPMSG lpMsg = (LPMSG)lParam;
		CComQIPtr<IOleInPlaceActiveObject, &__uuidof(IOleInPlaceActiveObject)> spInPlaceActiveObject(m_spUnknown);
		if(spInPlaceActiveObject)
		{
			if(spInPlaceActiveObject->TranslateAccelerator(lpMsg) == S_OK)
				return 1;
		}
		return 0;
	}

	LRESULT OnGetUnknown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		IUnknown* pUnk = GetControllingUnknown();
		pUnk->AddRef();
		return (LRESULT)pUnk;
	}
	LRESULT OnGetControl(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		IUnknown* pUnk = m_spUnknown;
		if (pUnk)
			pUnk->AddRef();
		return (LRESULT)pUnk;
	}

	void ReleaseAll()
	{
		CE_VALIDATE_THREADID_ASSERT();
		if (m_bReleaseAll)
			return;
		m_bReleaseAll = TRUE;

		if (m_spViewObject != NULL)
			m_spViewObject->SetAdvise(DVASPECT_CONTENT, 0, NULL);

		if(m_dwAdviseSink != 0xCDCDCDCD)
		{
			AtlUnadvise(m_spUnknown, m_iidSink, m_dwAdviseSink);
			m_dwAdviseSink = 0xCDCDCDCD;
		}

		if (m_spOleObject)
		{
			m_spOleObject->Unadvise(m_dwOleObject);
			m_spOleObject->Close(OLECLOSE_NOSAVE);
			m_spOleObject->SetClientSite(NULL);
		}

		if (m_spUnknown != NULL)
		{
			CComPtr<IObjectWithSite> spSite;
			m_spUnknown->QueryInterface(__uuidof(IObjectWithSite), (void**)&spSite);
			if (spSite != NULL)
				spSite->SetSite(NULL);
		}

		m_spViewObject.Release();
		m_dwViewObjectType = 0;

		m_spInPlaceObjectWindowless.Release();
		m_spOleObject.Release();
		m_spUnknown.Release();

		m_spInPlaceUIWindow.Release();
		m_spInPlaceFrame.Release();

		m_bInPlaceActive = FALSE;
		m_bWindowless = FALSE;
		m_bInPlaceActive = FALSE;
		m_bUIActive = FALSE;
		m_bCapture = FALSE;
		m_bReleaseAll = FALSE;

		if (m_hAccel != NULL)
		{
			DestroyAcceleratorTable(m_hAccel);
			m_hAccel = NULL;
		}
	}


// window message handlers
	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		CE_VALIDATE_THREADID_ASSERT();
		if (m_spViewObject == NULL)
			bHandled = false;

		return 1;
	}

#ifndef _WIN32_WCE
	LRESULT OnMouseActivate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		bHandled = FALSE;
		if (m_dwMiscStatus & OLEMISC_NOUIACTIVATE)
		{
			if (m_spOleObject != NULL && !m_bInPlaceActive)
			{
				CComPtr<IOleClientSite> spClientSite;
				GetControllingUnknown()->QueryInterface(__uuidof(IOleClientSite), (void**)&spClientSite);
				if (spClientSite != NULL)
					m_spOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
			}
		}
		else
		{
			BOOL b;
			OnSetFocus(0, 0, 0, b);
		}
		return 0;
	}
#endif // _WIN32_WCE

	LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bHaveFocus = TRUE;
		if (!m_bReleaseAll)
		{
			if (m_spOleObject != NULL && !m_bUIActive)
			{
				CComPtr<IOleClientSite> spClientSite;
				GetControllingUnknown()->QueryInterface(__uuidof(IOleClientSite), (void**)&spClientSite);
				if (spClientSite != NULL)
					m_spOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
			}
			if (m_bWindowless)
				::SetFocus(m_hWnd);
			else if(!IsChild(::GetFocus()))
				::SetFocus(::GetWindow(m_hWnd, GW_CHILD));
		}
		bHandled = FALSE;
		return 0;
	}
	LRESULT OnKillFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bHaveFocus = FALSE;
		bHandled = FALSE;
		return 0;
	}
	LRESULT OnSize(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		CE_VALIDATE_THREADID_ASSERT();
		int nWidth = GET_X_LPARAM(lParam);  // width of client area
		int nHeight = GET_Y_LPARAM(lParam); // height of client area

		m_rcPos.right = m_rcPos.left + nWidth;
		m_rcPos.bottom = m_rcPos.top + nHeight;
		m_pxSize.cx = m_rcPos.right - m_rcPos.left;
		m_pxSize.cy = m_rcPos.bottom - m_rcPos.top;
		AtlPixelToHiMetric(&m_pxSize, &m_hmSize);

		if (m_spOleObject)
			m_spOleObject->SetExtent(DVASPECT_CONTENT, &m_hmSize);
		if (m_spInPlaceObjectWindowless)
			m_spInPlaceObjectWindowless->SetObjectRects(&m_rcPos, &m_rcPos);
		if (m_bWindowless)
			InvalidateRect(NULL, TRUE);
		bHandled = FALSE;
		return 0;
	}
	LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		CE_VALIDATE_THREADID_ASSERT();
		GetControllingUnknown()->AddRef();
		DefWindowProc(uMsg, wParam, lParam);
		ReleaseAll();
		bHandled = FALSE;
		return 0;
	}
	LRESULT OnWindowMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		CE_VALIDATE_THREADID_ASSERT();
		LRESULT lRes = 0;
		HRESULT hr = S_FALSE;
		if (m_bInPlaceActive && m_bWindowless && m_spInPlaceObjectWindowless)
			hr = m_spInPlaceObjectWindowless->OnWindowMessage(uMsg, wParam, lParam, &lRes);
		if (hr == S_FALSE)
			bHandled = FALSE;
		return lRes;
	}
	LRESULT OnWindowlessMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		CE_VALIDATE_THREADID_ASSERT();
		LRESULT lRes = 0;
		if (m_bInPlaceActive && m_bWindowless && m_spInPlaceObjectWindowless)
			m_spInPlaceObjectWindowless->OnWindowMessage(uMsg, wParam, lParam, &lRes);
		bHandled = FALSE;
		return lRes;
	}
	LRESULT OnPaint(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		CE_VALIDATE_THREADID_ASSERT();
		if (m_spViewObject == NULL)
		{
			PAINTSTRUCT ps;
			HDC hdc = ::BeginPaint(m_hWnd, &ps);
			if (hdc == NULL)
				return 0;
			RECT rcClient;
			GetClientRect(&rcClient);
			HBRUSH hbrBack = CreateSolidBrush(m_clrBackground);
			if (hbrBack != NULL)
			{
				FillRect(hdc, &rcClient, hbrBack);
				DeleteObject(hbrBack);
			}
			::EndPaint(m_hWnd, &ps);
			return 1;
		}
		if (m_spViewObject && m_bWindowless)
		{
			PAINTSTRUCT ps;
			HDC hdc = ::BeginPaint(m_hWnd, &ps);

			if (hdc == NULL)
				return 0;

			RECT rcClient;
			GetClientRect(&rcClient);

			HBITMAP hBitmap = CreateCompatibleBitmap(hdc, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
			if (hBitmap != NULL)
			{
				HDC hdcCompatible = ::CreateCompatibleDC(hdc);
				if (hdcCompatible != NULL)
				{
					HBITMAP hBitmapOld = (HBITMAP)SelectObject(hdcCompatible, hBitmap); 
					if (hBitmapOld != NULL)
					{
						HBRUSH hbrBack = CreateSolidBrush(m_clrBackground);
						if (hbrBack != NULL)
						{
							FillRect(hdcCompatible, &rcClient, hbrBack);
							DeleteObject(hbrBack);

							m_spViewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL, hdcCompatible, (RECTL*)&m_rcPos, (RECTL*)&m_rcPos, NULL, NULL); 

							::BitBlt(hdc, 0, 0, rcClient.right, rcClient.bottom,  hdcCompatible, 0, 0, SRCCOPY);
						}
						::SelectObject(hdcCompatible, hBitmapOld); 
					}
					::DeleteDC(hdcCompatible);
				}
				::DeleteObject(hBitmap);
			}
			::EndPaint(m_hWnd, &ps);
		}
		else
		{
			bHandled = FALSE;
			return 0;
		}
		return 1;
	}

// IAxWinHostWindow
	STDMETHOD(CreateControl)(LPCOLESTR lpTricsData, HWND hWnd, IStream* pStream)
	{
		CE_VALIDATE_THREADID_ASSERT();
		CComPtr<IUnknown> p;
		return CreateControlLicEx(lpTricsData, hWnd, pStream, &p, IID_NULL, NULL, NULL);
	}
	STDMETHOD(CreateControlEx)(LPCOLESTR lpszTricsData, HWND hWnd, IStream* pStream, IUnknown** ppUnk, REFIID iidAdvise, IUnknown* punkSink)
	{
		CE_VALIDATE_THREADID_ASSERT();
		return CreateControlLicEx(lpszTricsData, hWnd, pStream, ppUnk, iidAdvise, punkSink, NULL);
	}
	STDMETHOD(AttachControl)(IUnknown* pUnkControl, HWND hWnd)
	{
		CE_VALIDATE_THREADID_ASSERT();
		HRESULT hr = S_FALSE;

		ReleaseAll();

		bool bReleaseWindowOnFailure = false; // Used to keep track of whether we subclass the window

		if ((m_hWnd != NULL) && (m_hWnd != hWnd)) // Don't release the window if it's the same as the one we already subclass/own
		{
			RedrawWindow(NULL, NULL, ATL_RDW_WHOLE_WINDOW);
			ReleaseWindow();
		}

		if (::IsWindow(hWnd))
		{
			if (m_hWnd != hWnd) // Don't need to subclass the window if we already own it
			{
				SubclassWindow(hWnd);
				bReleaseWindowOnFailure = true;
			}

			hr = ActivateAx(pUnkControl, true, NULL);

			if (FAILED(hr))
			{
				ReleaseAll();

				if (m_hWnd != NULL)
				{
					RedrawWindow(NULL, NULL, ATL_RDW_WHOLE_WINDOW);
					if (bReleaseWindowOnFailure) // We subclassed the window in an attempt to create this control, so we unsubclass on failure
						ReleaseWindow();
				}
			}
		}
		return hr;
	}
	STDMETHOD(QueryControl)(REFIID riid, void** ppvObject)
	{
		CE_VALIDATE_THREADID_ASSERT();
		HRESULT hr = E_POINTER;
		if (ppvObject)
		{
			if (m_spUnknown)
			{
				hr = m_spUnknown->QueryInterface(riid, ppvObject);
			}
			else
			{
				*ppvObject = NULL;
				hr = OLE_E_NOCONNECTION;
			}
		}
		return hr;
	}
	STDMETHOD(SetExternalDispatch)(IDispatch* pDisp)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_spExternalDispatch = pDisp;
		return S_OK;
	}
	STDMETHOD(SetExternalUIHandler)(IDocHostUIHandlerDispatch* pUIHandler)
	{
		CE_VALIDATE_THREADID_ASSERT();
#ifndef _ATL_NO_DOCHOSTUIHANDLER
		m_spIDocHostUIHandlerDispatch = pUIHandler;
#endif
		return S_OK;
	}

	STDMETHOD(CreateControlLic)(LPCOLESTR lpTricsData, HWND hWnd, IStream* pStream, BSTR bstrLic)
	{
		CE_VALIDATE_THREADID_ASSERT();
		CComPtr<IUnknown> p;
		return CreateControlLicEx(lpTricsData, hWnd, pStream, &p, IID_NULL, NULL, bstrLic);
	}
	STDMETHOD(CreateControlLicEx)(LPCOLESTR lpszTricsData, HWND hWnd, IStream* pStream, IUnknown** ppUnk, REFIID iidAdvise, IUnknown* punkSink, BSTR bstrLic)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(ppUnk != NULL);
		if (ppUnk == NULL)
			return E_POINTER;
		*ppUnk = NULL;
		HRESULT hr = S_FALSE;
		bool bReleaseWindowOnFailure = false; // Used to keep track of whether we subclass the window

		ReleaseAll();

		if ((m_hWnd != NULL) && (m_hWnd != hWnd)) // Don't release the window if it's the same as the one we already subclass/own
		{
#ifndef _WIN32_WCE
			RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
#else // _WIN32_WCE
			RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT);
#endif // _WIN32_WCE
			ReleaseWindow();
		}

		if (::IsWindow(hWnd))
		{
			if (m_hWnd != hWnd) // Don't need to subclass the window if we already own it
			{
				SubclassWindow(hWnd);
				bReleaseWindowOnFailure = true;
			}
			if (m_clrBackground == NULL)
			{
				if (IsParentDialog())
				{
					m_clrBackground = GetSysColor(COLOR_BTNFACE);
				}
				else
				{
					m_clrBackground = GetSysColor(COLOR_WINDOW);
				}
			}

			bool bWasHTML = false;

			hr = CreateNormalizedObject(lpszTricsData, __uuidof(IUnknown), (void**)ppUnk, bWasHTML, bstrLic);

			if (SUCCEEDED(hr))
			{
				hr = ActivateAx(*ppUnk, false, pStream);
			}

			// Try to hook up any sink the user might have given us.
			m_iidSink = iidAdvise;
			if(SUCCEEDED(hr) && *ppUnk && punkSink)
			{
				AtlAdvise(*ppUnk, punkSink, m_iidSink, &m_dwAdviseSink);
			}

			if (SUCCEEDED(hr) && bWasHTML && *ppUnk != NULL)
			{
				if ((GetStyle() & (WS_VSCROLL | WS_HSCROLL)) == 0)
				{
					m_dwDocHostFlags |= DOCHOSTUIFLAG_SCROLL_NO;
				}
				else
				{
					DWORD dwStyle = GetStyle();
					SetWindowLong(GWL_STYLE, dwStyle & ~(WS_VSCROLL | WS_HSCROLL));
					SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOSIZE | SWP_FRAMECHANGED | SWP_DRAWFRAME);
				}

				CComPtr<IUnknown> spUnk(*ppUnk);
				// Is it just plain HTML?
				if ((lpszTricsData[0] == OLECHAR('M') || lpszTricsData[0] == OLECHAR('m')) &&
					(lpszTricsData[1] == OLECHAR('S') || lpszTricsData[1] == OLECHAR('s')) &&
					(lpszTricsData[2] == OLECHAR('H') || lpszTricsData[2] == OLECHAR('h')) &&
					(lpszTricsData[3] == OLECHAR('T') || lpszTricsData[3] == OLECHAR('t')) &&
					(lpszTricsData[4] == OLECHAR('M') || lpszTricsData[4] == OLECHAR('m')) &&
					(lpszTricsData[5] == OLECHAR('L') || lpszTricsData[5] == OLECHAR('l')) &&
					(lpszTricsData[6] == OLECHAR(':')))
				{
					// Just HTML: load the HTML data into the document
					UINT nCreateSize = (static_cast<UINT>(ocslen(lpszTricsData)) - 7) * sizeof(OLECHAR);
					HGLOBAL hGlobal = GlobalAlloc(GHND, nCreateSize);
					if (hGlobal)
					{
						CComPtr<IStream> spStream;
						BYTE* pBytes = (BYTE*) GlobalLock(hGlobal);
						Checked::memcpy_s(pBytes, nCreateSize, lpszTricsData + 7, nCreateSize);
						GlobalUnlock(hGlobal);
						hr = CreateStreamOnHGlobal(hGlobal, TRUE, &spStream);
						if (SUCCEEDED(hr))
						{
							CComPtr<IPersistStreamInit> spPSI;
							hr = spUnk->QueryInterface(__uuidof(IPersistStreamInit), (void**)&spPSI);
							if (SUCCEEDED(hr))
							{
								hr = spPSI->Load(spStream);
							}
						}
					}
					else
					{
						hr = E_OUTOFMEMORY;
					}
				}
				else
				{
#if !defined(_WIN32_WCE) || defined(_CE_IE)
					CComPtr<IWebBrowser2> spBrowser;
					spUnk->QueryInterface(__uuidof(IWebBrowser2), (void**)&spBrowser);
					if (spBrowser)
					{
						CComVariant ve;
						CComVariant vurl(lpszTricsData);
						spBrowser->put_Visible(ATL_VARIANT_TRUE);
						spBrowser->Navigate2(&vurl, &ve, &ve, &ve, &ve);
					}
#else // !defined(_WIN32_WCE) || defined(_CE_IE)
#ifdef _CE_PIE
					ATLTRACE(atlTraceHosting, 0, L"PocketIE does not support the IWebBrowser2 interface");
#else
					ATLTRACE(atlTraceHosting, 0, L"The IWebBrowser2 interface is not supported by the current SDK");
#endif
					hr = E_UNEXPECTED;
#endif // !defined(_WIN32_WCE) || defined(_CE_IE)
				}

			}
			if (FAILED(hr) || m_spUnknown == NULL)
			{
				// We don't have a control or something failed so release
				ReleaseAll();

				if (m_hWnd != NULL)
				{
					RedrawWindow(NULL, NULL, ATL_RDW_WHOLE_WINDOW);
					if (FAILED(hr) && bReleaseWindowOnFailure) // We subclassed the window in an attempt to create this control, so we unsubclass on failure
					{
						ReleaseWindow();
					}
				}
			}
		}
		return hr;
	}



#ifndef _ATL_NO_DOCHOSTUIHANDLER
// IDocHostUIHandler
	// MSHTML requests to display its context menu
	STDMETHOD(ShowContextMenu)(DWORD dwID, POINT* pptPosition, IUnknown* pCommandTarget, IDispatch* pDispatchObjectHit)
	{
		CE_VALIDATE_THREADID_ASSERT();
		HRESULT hr = m_bAllowContextMenu ? S_FALSE : S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			m_spIDocHostUIHandlerDispatch->ShowContextMenu(
				dwID,
				pptPosition->x,
				pptPosition->y,
				pCommandTarget,
				pDispatchObjectHit,
				&hr);
		return hr;
	}
	// Called at initialisation to find UI styles from container
	STDMETHOD(GetHostInfo)(DOCHOSTUIINFO* pInfo)
	{
		CE_VALIDATE_THREADID_ASSERT();
		if (pInfo == NULL)
			return E_POINTER;

		if (m_spIDocHostUIHandlerDispatch != NULL)
			return m_spIDocHostUIHandlerDispatch->GetHostInfo(&pInfo->dwFlags, &pInfo->dwDoubleClick);

		pInfo->dwFlags = m_dwDocHostFlags;
		pInfo->dwDoubleClick = m_dwDocHostDoubleClickFlags;

		return S_OK;
	}
	// Allows the host to replace the IE4/MSHTML menus and toolbars. 
	STDMETHOD(ShowUI)(DWORD dwID, IOleInPlaceActiveObject* pActiveObject, IOleCommandTarget* pCommandTarget, IOleInPlaceFrame* pFrame, IOleInPlaceUIWindow* pDoc)
	{
		CE_VALIDATE_THREADID_ASSERT();
		HRESULT hr = m_bAllowShowUI ? S_FALSE : S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			m_spIDocHostUIHandlerDispatch->ShowUI(
				dwID,
				pActiveObject, 
				pCommandTarget, 
				pFrame, 
				pDoc,
				&hr);
		return hr;
	}
	// Called when IE4/MSHTML removes its menus and toolbars. 
	STDMETHOD(HideUI)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->HideUI();
		return hr;
	}
	// Notifies the host that the command state has changed. 
	STDMETHOD(UpdateUI)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->UpdateUI();
		return hr;
	}
	// Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::EnableModeless
	STDMETHOD(EnableModeless)(BOOL fEnable)
	{
		CE_VALIDATE_THREADID_ASSERT();
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->EnableModeless(fEnable ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
		return hr;
	}
	// Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::OnDocWindowActivate
	STDMETHOD(OnDocWindowActivate)(BOOL fActivate)
	{
		CE_VALIDATE_THREADID_ASSERT();
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->OnDocWindowActivate(fActivate ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
		return hr;
	}
	// Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::OnFrameWindowActivate. 
	STDMETHOD(OnFrameWindowActivate)(BOOL fActivate)
	{
		CE_VALIDATE_THREADID_ASSERT();
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->OnFrameWindowActivate(fActivate ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
		return hr;
	}
	// Called from the IE4/MSHTML implementation of IOleInPlaceActiveObject::ResizeBorder.
	STDMETHOD(ResizeBorder)(LPCRECT prcBorder, IOleInPlaceUIWindow* pUIWindow, BOOL fFrameWindow)
	{
		CE_VALIDATE_THREADID_ASSERT();
		HRESULT hr = S_OK;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			hr = m_spIDocHostUIHandlerDispatch->ResizeBorder(
				prcBorder->left,
				prcBorder->top,
				prcBorder->right,
				prcBorder->bottom,
				pUIWindow,
				fFrameWindow ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
		return hr;
	}
	// Called by IE4/MSHTML when IOleInPlaceActiveObject::TranslateAccelerator or IOleControlSite::TranslateAccelerator is called. 
	STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, const GUID* pguidCmdGroup, DWORD nCmdID)
	{
		CE_VALIDATE_THREADID_ASSERT();
		HRESULT hr = S_FALSE;
		if (m_spIDocHostUIHandlerDispatch != NULL)
			m_spIDocHostUIHandlerDispatch->TranslateAccelerator(
				(DWORD_PTR) lpMsg->hwnd,
				lpMsg->message,
				lpMsg->wParam,
				lpMsg->lParam,
				CComBSTR(*pguidCmdGroup), 
				nCmdID,
				&hr);
		return hr;
	}
	// Returns the registry key under which IE4/MSHTML stores user preferences. 
	// Returns S_OK if successful, or S_FALSE otherwise. If S_FALSE, IE4/MSHTML will default to its own user options.
	STDMETHOD(GetOptionKeyPath)(LPOLESTR* pchKey, DWORD dwReserved)
	{
		CE_VALIDATE_THREADID_ASSERT();
		HRESULT hr = S_FALSE;
		if (pchKey == NULL)
        {
			return E_POINTER;
        }
		*pchKey = NULL;
		if (m_spIDocHostUIHandlerDispatch != NULL)
		{
			hr = m_spIDocHostUIHandlerDispatch->GetOptionKeyPath(pchKey, dwReserved);
			if (FAILED(hr) || *pchKey == NULL)
				hr = S_FALSE;
		}
		else
		{
            if (m_bstrOptionKeyPath.Length() != 0)
			{
				UINT nByteLength = m_bstrOptionKeyPath.ByteLength();
				LPOLESTR pStr = (LPOLESTR)CoTaskMemAlloc(nByteLength + sizeof(OLECHAR));
				if (pStr == NULL)
                {
					return E_OUTOFMEMORY;
                }
				if(!ocscpy_s(pStr, nByteLength + sizeof(OLECHAR), m_bstrOptionKeyPath.m_str))
				{
					return E_FAIL;
				}
				*pchKey = pStr;
				hr = S_OK;
			}
		}
		return hr;
	}
	// Called by IE4/MSHTML when it is being used as a drop target to allow the host to supply an alternative IDropTarget
	STDMETHOD(GetDropTarget)(IDropTarget* pDropTarget, IDropTarget** ppDropTarget)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(ppDropTarget != NULL);
		if (ppDropTarget == NULL)
			return E_POINTER;
		*ppDropTarget = NULL;

		HRESULT hr = E_NOTIMPL;
		if (m_spIDocHostUIHandlerDispatch != NULL)
		{
			CComPtr<IUnknown> spUnk;
			hr = m_spIDocHostUIHandlerDispatch->GetDropTarget(pDropTarget, &spUnk);
			if (spUnk)
				hr = spUnk->QueryInterface(__uuidof(IDropTarget), (void**)ppDropTarget);
			if (FAILED(hr) || *ppDropTarget == NULL)
				hr = S_FALSE;
		}
		return hr;
	}
	// Called by IE4/MSHTML to obtain the host's IDispatch interface
	STDMETHOD(GetExternal)(IDispatch** ppDispatch)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(ppDispatch != NULL);
		if (ppDispatch == NULL)
			return E_POINTER;
		*ppDispatch = NULL;

		HRESULT hr = E_NOINTERFACE;
		if (m_spIDocHostUIHandlerDispatch != NULL)
		{
			hr = m_spIDocHostUIHandlerDispatch->GetExternal(ppDispatch);
			if (FAILED(hr) || *ppDispatch == NULL)
				hr = E_NOINTERFACE;
		}
		else
		{
			// return the IDispatch we have for extending the object Model
			if (ppDispatch != NULL)
			{
				hr=m_spExternalDispatch.CopyTo(ppDispatch);
			}
			else
				hr = E_POINTER;
		}
		return hr;
	}
	// Called by IE4/MSHTML to allow the host an opportunity to modify the URL to be loaded
	STDMETHOD(TranslateUrl)(DWORD dwTranslate, OLECHAR* pchURLIn, OLECHAR** ppchURLOut)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(ppchURLOut != NULL);
		if (ppchURLOut == NULL)
        {
			return E_POINTER;
        }
		*ppchURLOut = NULL;

		HRESULT hr = S_FALSE;
		if (m_spIDocHostUIHandlerDispatch != NULL)
		{
			CComBSTR bstrURLOut;
			hr = m_spIDocHostUIHandlerDispatch->TranslateUrl(dwTranslate, CComBSTR(pchURLIn), &bstrURLOut);
			if (SUCCEEDED(hr) && bstrURLOut.Length() != 0)
			{
				UINT nLen = (bstrURLOut.Length() + 1) * 2;
				*ppchURLOut = (OLECHAR*) CoTaskMemAlloc(nLen);
				if (*ppchURLOut == NULL)
                {
					return E_OUTOFMEMORY;
                }
				Checked::memcpy_s(*ppchURLOut, nLen, bstrURLOut.m_str, nLen);
			}
			else
            {
				hr = S_FALSE;
            }
		}
		return hr;
	}
	// Called on the host by IE4/MSHTML to allow the host to replace IE4/MSHTML's data object.
	// This allows the host to block certain clipboard formats or support additional clipboard formats. 
	STDMETHOD(FilterDataObject)(IDataObject* pDO, IDataObject** ppDORet)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(ppDORet != NULL);
		if (ppDORet == NULL)
			return E_POINTER;
		*ppDORet = NULL;

		HRESULT hr = S_FALSE;
		if (m_spIDocHostUIHandlerDispatch != NULL)
		{
			CComPtr<IUnknown> spUnk;
			hr = m_spIDocHostUIHandlerDispatch->FilterDataObject(pDO, &spUnk);
			if (spUnk)
				hr = QueryInterface(__uuidof(IDataObject), (void**)ppDORet);
			if (FAILED(hr) || *ppDORet == NULL)
				hr = S_FALSE;
		}
		return hr;
	}
#endif

	HRESULT FireAmbientPropertyChange(DISPID dispChanged)
	{
		CE_VALIDATE_THREADID_ASSERT();
		HRESULT hr = S_OK;
		CComQIPtr<IOleControl, &__uuidof(IOleControl)> spOleControl(m_spUnknown);
		if (spOleControl != NULL)
			hr = spOleControl->OnAmbientPropertyChange(dispChanged);
		return hr;
	}

// IAxWinAmbientDispatch

	CComPtr<IDispatch> m_spAmbientDispatch;

	STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
			VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
	{
		CE_VALIDATE_THREADID_ASSERT();
		HRESULT hr = IDispatchImpl<IAxWinAmbientDispatchEx, &__uuidof(IAxWinAmbientDispatchEx), &CAtlModule::m_libid, 0xFFFF, 0xFFFF>::Invoke
			(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
		if ((hr == DISP_E_MEMBERNOTFOUND || hr == TYPE_E_ELEMENTNOTFOUND) && m_spAmbientDispatch != NULL)
		{
			hr = m_spAmbientDispatch->Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
			if (SUCCEEDED(hr) && (wFlags & DISPATCH_PROPERTYPUT) != 0)
			{
				hr = FireAmbientPropertyChange(dispIdMember);
			}
		}
		return hr;
	}

	STDMETHOD(put_AllowWindowlessActivation)(VARIANT_BOOL bAllowWindowless)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bCanWindowlessActivate = bAllowWindowless;
		return S_OK;
	}
	STDMETHOD(get_AllowWindowlessActivation)(VARIANT_BOOL* pbAllowWindowless)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(pbAllowWindowless != NULL);
		if (pbAllowWindowless == NULL)
			return E_POINTER;

		*pbAllowWindowless = m_bCanWindowlessActivate ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_BackColor)(OLE_COLOR clrBackground)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_clrBackground = clrBackground;
		FireAmbientPropertyChange(DISPID_AMBIENT_BACKCOLOR);
		InvalidateRect(0, FALSE);
		return S_OK;
	}
	STDMETHOD(get_BackColor)(OLE_COLOR* pclrBackground)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(pclrBackground != NULL);
		if (pclrBackground == NULL)
			return E_POINTER;

		*pclrBackground = m_clrBackground;
		return S_OK;
	}
	STDMETHOD(put_ForeColor)(OLE_COLOR clrForeground)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_clrForeground = clrForeground;
		FireAmbientPropertyChange(DISPID_AMBIENT_FORECOLOR);
		return S_OK;
	}
	STDMETHOD(get_ForeColor)(OLE_COLOR* pclrForeground)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(pclrForeground != NULL);
		if (pclrForeground == NULL)
			return E_POINTER;

		*pclrForeground = m_clrForeground;
		return S_OK;
	}
	STDMETHOD(put_LocaleID)(LCID lcidLocaleID)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_lcidLocaleID = lcidLocaleID;
		FireAmbientPropertyChange(DISPID_AMBIENT_LOCALEID);
		return S_OK;
	}
	STDMETHOD(get_LocaleID)(LCID* plcidLocaleID)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(plcidLocaleID != NULL);
		if (plcidLocaleID == NULL)
			return E_POINTER;

		*plcidLocaleID = m_lcidLocaleID;
		return S_OK;
	}
	STDMETHOD(put_UserMode)(VARIANT_BOOL bUserMode)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bUserMode = bUserMode;
		FireAmbientPropertyChange(DISPID_AMBIENT_USERMODE);
		return S_OK;
	}
	STDMETHOD(get_UserMode)(VARIANT_BOOL* pbUserMode)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(pbUserMode != NULL);
		if (pbUserMode == NULL)
			return E_POINTER;

		*pbUserMode = m_bUserMode ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_DisplayAsDefault)(VARIANT_BOOL bDisplayAsDefault)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bDisplayAsDefault = bDisplayAsDefault;
		FireAmbientPropertyChange(DISPID_AMBIENT_DISPLAYASDEFAULT);
		return S_OK;
	}
	STDMETHOD(get_DisplayAsDefault)(VARIANT_BOOL* pbDisplayAsDefault)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(pbDisplayAsDefault != NULL);
		if (pbDisplayAsDefault == NULL)
			return E_POINTER;

		*pbDisplayAsDefault = m_bDisplayAsDefault ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_Font)(IFontDisp* pFont)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_spFont = pFont;
		FireAmbientPropertyChange(DISPID_AMBIENT_FONT);
		return S_OK;
	}
	STDMETHOD(get_Font)(IFontDisp** pFont)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(pFont != NULL);
		if (pFont == NULL)
			return E_POINTER;
		*pFont = NULL;

		if (m_spFont == NULL)
		{
#ifndef _WIN32_WCE
			USES_CONVERSION_EX;
			HFONT hSystemFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
			if (hSystemFont == NULL)
				hSystemFont = (HFONT) GetStockObject(SYSTEM_FONT);
			if (hSystemFont == NULL)
				return AtlHresultFromLastError();
			LOGFONT logfont;
			GetObject(hSystemFont, sizeof(logfont), &logfont);
			FONTDESC fd;
			fd.cbSizeofstruct = sizeof(FONTDESC);
			fd.lpstrName = T2OLE_EX_DEF(logfont.lfFaceName);
			fd.sWeight = (short)logfont.lfWeight;
			fd.sCharset = logfont.lfCharSet;
			fd.fItalic = logfont.lfItalic;
			fd.fUnderline = logfont.lfUnderline;
			fd.fStrikethrough = logfont.lfStrikeOut;

			long lfHeight = logfont.lfHeight;
			if (lfHeight < 0)
				lfHeight = -lfHeight;

			int ppi;
			HDC hdc;
			if (m_hWnd)
			{
				hdc = ::GetDC(m_hWnd);
				if (hdc == NULL)
					return AtlHresultFromLastError();
				ppi = GetDeviceCaps(hdc, LOGPIXELSY);
				::ReleaseDC(m_hWnd, hdc);
			}
			else
			{
				hdc = ::GetDC(GetDesktopWindow());
				if (hdc == NULL)
					return AtlHresultFromLastError();
				ppi = GetDeviceCaps(hdc, LOGPIXELSY);
				::ReleaseDC(GetDesktopWindow(), hdc);
			}
			fd.cySize.Lo = lfHeight * 720000 / ppi;
			fd.cySize.Hi = 0;

			OleCreateFontIndirect(&fd, __uuidof(IFontDisp), (void**) &m_spFont);
#else
			(pFont);
			ATLTRACENOTIMPL(L"CAxHostWindow::get_Font");
			return E_NOTIMPL;
#endif // _WIN32_WCE
		}

		return m_spFont.CopyTo(pFont);
	}
	STDMETHOD(put_MessageReflect)(VARIANT_BOOL bMessageReflect)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bMessageReflect = bMessageReflect;
		FireAmbientPropertyChange(DISPID_AMBIENT_MESSAGEREFLECT);
		return S_OK;
	}
	STDMETHOD(get_MessageReflect)(VARIANT_BOOL* pbMessageReflect)
	{
		CE_VALIDATE_THREADID_ASSERT();

		ATLASSERT(pbMessageReflect != NULL);
		if (pbMessageReflect == NULL)
			return E_POINTER;

		*pbMessageReflect = m_bMessageReflect ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(get_ShowGrabHandles)(VARIANT_BOOL* pbShowGrabHandles)
	{
		CE_VALIDATE_THREADID_ASSERT();
		*pbShowGrabHandles = ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(get_ShowHatching)(VARIANT_BOOL* pbShowHatching)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(pbShowHatching != NULL);
		if (pbShowHatching == NULL)
			return E_POINTER;

		*pbShowHatching = ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_DocHostFlags)(DWORD dwDocHostFlags)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_dwDocHostFlags = dwDocHostFlags;
		FireAmbientPropertyChange(DISPID_UNKNOWN);
		return S_OK;
	}
	STDMETHOD(get_DocHostFlags)(DWORD* pdwDocHostFlags)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(pdwDocHostFlags != NULL);
		if (pdwDocHostFlags == NULL)
			return E_POINTER;

		*pdwDocHostFlags = m_dwDocHostFlags;
		return S_OK;
	}
	STDMETHOD(put_DocHostDoubleClickFlags)(DWORD dwDocHostDoubleClickFlags)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_dwDocHostDoubleClickFlags = dwDocHostDoubleClickFlags;
		return S_OK;
	}
	STDMETHOD(get_DocHostDoubleClickFlags)(DWORD* pdwDocHostDoubleClickFlags)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(pdwDocHostDoubleClickFlags != NULL);
		if (pdwDocHostDoubleClickFlags == NULL)
			return E_POINTER;

		*pdwDocHostDoubleClickFlags = m_dwDocHostDoubleClickFlags;
		return S_OK;
	}
	STDMETHOD(put_AllowContextMenu)(VARIANT_BOOL bAllowContextMenu)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bAllowContextMenu = bAllowContextMenu;
		return S_OK;
	}
	STDMETHOD(get_AllowContextMenu)(VARIANT_BOOL* pbAllowContextMenu)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(pbAllowContextMenu != NULL);
		if (pbAllowContextMenu == NULL)
			return E_POINTER;

		*pbAllowContextMenu = m_bAllowContextMenu ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_AllowShowUI)(VARIANT_BOOL bAllowShowUI)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bAllowShowUI = bAllowShowUI;
		return S_OK;
	}
	STDMETHOD(get_AllowShowUI)(VARIANT_BOOL* pbAllowShowUI)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(pbAllowShowUI != NULL);
		if (pbAllowShowUI == NULL)
			return E_POINTER;

		*pbAllowShowUI = m_bAllowShowUI ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return S_OK;
	}
	STDMETHOD(put_OptionKeyPath)(BSTR bstrOptionKeyPath) throw()
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bstrOptionKeyPath = bstrOptionKeyPath;
		return S_OK;
	}
	STDMETHOD(get_OptionKeyPath)(BSTR* pbstrOptionKeyPath)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(pbstrOptionKeyPath != NULL);
		if (pbstrOptionKeyPath == NULL)
			return E_POINTER;

		*pbstrOptionKeyPath = m_bstrOptionKeyPath;
		return S_OK;
	}

	STDMETHOD(SetAmbientDispatch)(IDispatch* pDispatch)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_spAmbientDispatch = pDispatch;
		return S_OK;
	}

// IObjectWithSite
	STDMETHOD(SetSite)(IUnknown* pUnkSite)
	{
		CE_VALIDATE_THREADID_ASSERT();
		HRESULT hr = IObjectWithSiteImpl<CAxHostWindow>::SetSite(pUnkSite);

		if (SUCCEEDED(hr) && m_spUnkSite)
		{
			// Look for "outer" IServiceProvider
			hr = m_spUnkSite->QueryInterface(__uuidof(IServiceProvider), (void**)&m_spServices);
			ATLASSERT( SUCCEEDED(hr) && "No ServiceProvider!" );
		}

		if (pUnkSite == NULL)
			m_spServices.Release();

		return hr;
	}

// IOleClientSite
	STDMETHOD(SaveObject)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLTRACENOTIMPL(_T("IOleClientSite::SaveObject"));
	}
	STDMETHOD(GetMoniker)(DWORD /*dwAssign*/, DWORD /*dwWhichMoniker*/, IMoniker** /*ppmk*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLTRACENOTIMPL(_T("IOleClientSite::GetMoniker"));
	}
	STDMETHOD(GetContainer)(IOleContainer** ppContainer)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLTRACE(atlTraceHosting, 2, _T("IOleClientSite::GetContainer\n"));
		ATLASSERT(ppContainer != NULL);

		HRESULT hr = E_POINTER;
		if (ppContainer)
		{
			hr = E_NOTIMPL;
			(*ppContainer) = NULL;
			if (m_spUnkSite)
				hr = m_spUnkSite->QueryInterface(__uuidof(IOleContainer), (void**)ppContainer);
			if (FAILED(hr))
				hr = QueryInterface(__uuidof(IOleContainer), (void**)ppContainer);
		}
		return hr;
	}
	STDMETHOD(ShowObject)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLTRACE(atlTraceHosting, 2, _T("IOleClientSite::ShowObject\r\n"));

		HDC hdc = CWindowImpl<CAxHostWindow>::GetDC();
		if (hdc == NULL)
			return E_FAIL;
		if (m_spViewObject)
			m_spViewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL, hdc, (RECTL*)&m_rcPos, (RECTL*)&m_rcPos, NULL, NULL); 
		CWindowImpl<CAxHostWindow>::ReleaseDC(hdc);
		return S_OK;
	}
	STDMETHOD(OnShowWindow)(BOOL /*fShow*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLTRACENOTIMPL(_T("IOleClientSite::OnShowWindow"));
	}
	STDMETHOD(RequestNewObjectLayout)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLTRACENOTIMPL(_T("IOleClientSite::RequestNewObjectLayout"));
	}

// IOleInPlaceSite
	STDMETHOD(GetWindow)(HWND* phwnd)
	{
		CE_VALIDATE_THREADID_ASSERT();
		*phwnd = m_hWnd;
		return S_OK;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /*fEnterMode*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLTRACENOTIMPL(_T("IOleInPlaceSite::ContextSensitiveHelp"));
	}
	STDMETHOD(CanInPlaceActivate)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		return S_OK;
	}
	STDMETHOD(OnInPlaceActivate)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		// should only be called once the first time control is inplace-activated
		ATLASSUME(m_bInPlaceActive == FALSE);
		ATLASSUME(m_spInPlaceObjectWindowless == NULL);

		m_bInPlaceActive = TRUE;
#ifndef _WIN32_WCE
		OleLockRunning(m_spOleObject, TRUE, FALSE);
#endif // _WIN32_WCE
		m_bWindowless = FALSE;
		m_spOleObject->QueryInterface(__uuidof(IOleInPlaceObject), (void**) &m_spInPlaceObjectWindowless);
		return S_OK;
	}
	STDMETHOD(OnUIActivate)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLTRACE(atlTraceHosting, 2, _T("IOleInPlaceSite::OnUIActivate\n"));
		m_bUIActive = TRUE;
		return S_OK;
	}
	STDMETHOD(GetWindowContext)(IOleInPlaceFrame** ppFrame, IOleInPlaceUIWindow** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO pFrameInfo)
	{
		CE_VALIDATE_THREADID_ASSERT();
		if (ppFrame != NULL)
			*ppFrame = NULL;
		if (ppDoc != NULL)
			*ppDoc = NULL;
		if (ppFrame == NULL || ppDoc == NULL || lprcPosRect == NULL || lprcClipRect == NULL)
		{
			ATLASSERT(false);
			return E_POINTER;
		}

		if (!m_spInPlaceFrame)
		{
			CComObject<CAxFrameWindow>* pFrameWindow;
			CComObject<CAxFrameWindow>::CreateInstance(&pFrameWindow);
			pFrameWindow->QueryInterface(__uuidof(IOleInPlaceFrame), (void**) &m_spInPlaceFrame);
			ATLASSUME(m_spInPlaceFrame);
		}
		if (!m_spInPlaceUIWindow)
		{
			CComObject<CAxUIWindow>* pUIWindow;
			CComObject<CAxUIWindow>::CreateInstance(&pUIWindow);
			pUIWindow->QueryInterface(__uuidof(IOleInPlaceUIWindow), (void**) &m_spInPlaceUIWindow);
			ATLASSUME(m_spInPlaceUIWindow);
		}
		HRESULT hr=S_OK;
		hr=m_spInPlaceFrame.CopyTo(ppFrame);
		if(FAILED(hr))
		{
			return hr;
		}
		hr=m_spInPlaceUIWindow.CopyTo(ppDoc);
		if(FAILED(hr))
		{
			return hr;
		}
		GetClientRect(lprcPosRect);
		GetClientRect(lprcClipRect);

		if (m_hAccel == NULL)
		{
			ACCEL ac = { 0,0,0 };
			m_hAccel = CreateAcceleratorTable(&ac, 1);
		}
		pFrameInfo->cb = sizeof(OLEINPLACEFRAMEINFO);
		pFrameInfo->fMDIApp = m_bMDIApp;
		pFrameInfo->hwndFrame = GetParent();
		pFrameInfo->haccel = m_hAccel;
		pFrameInfo->cAccelEntries = (m_hAccel != NULL) ? 1 : 0;

		return hr;
	}
	STDMETHOD(Scroll)(SIZE /*scrollExtant*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLTRACENOTIMPL(_T("IOleInPlaceSite::Scroll"));
	}
	STDMETHOD(OnUIDeactivate)(BOOL /*fUndoable*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLTRACE(atlTraceHosting, 2, _T("IOleInPlaceSite::OnUIDeactivate\n"));
		m_bUIActive = FALSE;
		return S_OK;
	}
	STDMETHOD(OnInPlaceDeactivate)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bInPlaceActive = FALSE;
		m_spInPlaceObjectWindowless.Release();
		return S_OK;
	}
	STDMETHOD(DiscardUndoState)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLTRACENOTIMPL(_T("IOleInPlaceSite::DiscardUndoState"));
	}
	STDMETHOD(DeactivateAndUndo)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLTRACENOTIMPL(_T("IOleInPlaceSite::DeactivateAndUndo"));
	}
	STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect)
	{		
		ATLTRACE2(atlTraceHosting, 0, 	_T("IOleInPlaceSite::OnPosRectChange"));
		if (lprcPosRect==NULL) { return E_POINTER; }

		// Use MoveWindow() to resize the CAxHostWindow.
		// The CAxHostWindow handler for OnSize() will
		// take care of calling IOleInPlaceObject::SetObjectRects().

		// Convert to parent window coordinates for MoveWindow().
		RECT rect = *lprcPosRect;
		ClientToScreen( &rect );
		HWND hWnd = GetParent();

		// Check to make sure it's a non-top-level window.
		if(hWnd != NULL)
		{
			CWindow wndParent(hWnd);
			wndParent.ScreenToClient(&rect);
			wndParent.Detach ();
		}
		// Do the actual move.
		MoveWindow( &rect);
		
		return S_OK;	
	}

// IOleInPlaceSiteEx
	STDMETHOD(OnInPlaceActivateEx)(BOOL* /*pfNoRedraw*/, DWORD dwFlags)
	{
		CE_VALIDATE_THREADID_ASSERT();
		// should only be called once the first time control is inplace-activated
		ATLASSUME(m_bInPlaceActive == FALSE);
		ATLASSUME(m_spInPlaceObjectWindowless == NULL);

		m_bInPlaceActive = TRUE;
#ifndef _WIN32_WCE
		OleLockRunning(m_spOleObject, TRUE, FALSE);
#endif // _WIN32_WCE
		HRESULT hr = E_FAIL;
		if (dwFlags & ACTIVATE_WINDOWLESS)
		{
			m_bWindowless = TRUE;
			hr = m_spOleObject->QueryInterface(__uuidof(IOleInPlaceObjectWindowless), (void**) &m_spInPlaceObjectWindowless);
		}
		if (FAILED(hr))
		{
			m_bWindowless = FALSE;
			hr = m_spOleObject->QueryInterface(__uuidof(IOleInPlaceObject), (void**) &m_spInPlaceObjectWindowless);
		}
		if (m_spInPlaceObjectWindowless)
			m_spInPlaceObjectWindowless->SetObjectRects(&m_rcPos, &m_rcPos);
		return S_OK;
	}
	STDMETHOD(OnInPlaceDeactivateEx)(BOOL /*fNoRedraw*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bInPlaceActive = FALSE;
		m_spInPlaceObjectWindowless.Release();
		return S_OK;
	}
	STDMETHOD(RequestUIActivate)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		return S_OK;
	}

// IOleInPlaceSiteWindowless
	HDC m_hDCScreen;
	bool m_bDCReleased;

	STDMETHOD(CanWindowlessActivate)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		return m_bCanWindowlessActivate ? S_OK : S_FALSE;
	}
	STDMETHOD(GetCapture)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		return m_bCapture ? S_OK : S_FALSE;
	}
	STDMETHOD(SetCapture)(BOOL fCapture)
	{
		CE_VALIDATE_THREADID_ASSERT();
		if (fCapture)
		{
			CWindow::SetCapture();
			m_bCapture = TRUE;
		}
		else
		{
			ReleaseCapture();
			m_bCapture = FALSE;
		}
		return S_OK;
	}
	STDMETHOD(GetFocus)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		return m_bHaveFocus ? S_OK : S_FALSE;
	}
	STDMETHOD(SetFocus)(BOOL fGotFocus)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bHaveFocus = fGotFocus;
		return S_OK;
	}
	STDMETHOD(GetDC)(LPCRECT /*pRect*/, DWORD grfFlags, HDC* phDC)
	{
		CE_VALIDATE_THREADID_ASSERT();
		if (phDC == NULL)
			return E_POINTER;
		if (!m_bDCReleased)
			return E_FAIL;

		*phDC = CWindowImpl<CAxHostWindow>::GetDC();
		if (*phDC == NULL)
			return E_FAIL;

		m_bDCReleased = false;

		if (grfFlags & OLEDC_NODRAW)
			return S_OK;

		RECT rect;
		GetClientRect(&rect);
		if (grfFlags & OLEDC_OFFSCREEN)
		{
			HDC hDCOffscreen = CreateCompatibleDC(*phDC);
			if (hDCOffscreen != NULL)
			{
				HBITMAP hBitmap = CreateCompatibleBitmap(*phDC, rect.right - rect.left, rect.bottom - rect.top);
				if (hBitmap == NULL)
					DeleteDC(hDCOffscreen);
				else
				{
					HGDIOBJ hOldBitmap = SelectObject(hDCOffscreen, hBitmap);
					if (hOldBitmap == NULL)
					{
						DeleteObject(hBitmap);
						DeleteDC(hDCOffscreen);
					}
					else
					{
						DeleteObject(hOldBitmap);
						m_hDCScreen = *phDC;
						*phDC = hDCOffscreen;
					}
				}
			}
		}

		if (grfFlags & OLEDC_PAINTBKGND)
			::FillRect(*phDC, &rect, (HBRUSH) (COLOR_WINDOW+1));
		return S_OK;
	}
	STDMETHOD(ReleaseDC)(HDC hDC)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bDCReleased = true;
		if (m_hDCScreen != NULL)
		{
			RECT rect;
			GetClientRect(&rect);
			// Offscreen DC has to be copied to screen DC before releasing the screen dc;
			BitBlt(m_hDCScreen, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, hDC, 0, 0, SRCCOPY);
			DeleteDC(hDC);
			hDC = m_hDCScreen;
		}

		CWindowImpl<CAxHostWindow>::ReleaseDC(hDC);
		return S_OK;
	}
	STDMETHOD(InvalidateRect)(LPCRECT pRect, BOOL fErase)
	{
		CE_VALIDATE_THREADID_ASSERT();
		CWindowImpl<CAxHostWindow>::InvalidateRect(pRect, fErase);
		return S_OK;
	}
	STDMETHOD(InvalidateRgn)(HRGN hRGN, BOOL fErase)
	{
		CE_VALIDATE_THREADID_ASSERT();
		CWindowImpl<CAxHostWindow>::InvalidateRgn(hRGN, fErase);
		return S_OK;
	}
	STDMETHOD(ScrollRect)(INT /*dx*/, INT /*dy*/, LPCRECT /*pRectScroll*/, LPCRECT /*pRectClip*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		return S_OK;
	}
	STDMETHOD(AdjustRect)(LPRECT /*prc*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		return S_OK;
	}
	STDMETHOD(OnDefWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult)
	{
		CE_VALIDATE_THREADID_ASSERT();
		*plResult = DefWindowProc(msg, wParam, lParam);
		return S_OK;
	}

// IOleControlSite
	STDMETHOD(OnControlInfoChanged)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		return S_OK;
	}
	STDMETHOD(LockInPlaceActive)(BOOL /*fLock*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		return S_OK;
	}
	STDMETHOD(GetExtendedControl)(IDispatch** ppDisp)
	{
		CE_VALIDATE_THREADID_ASSERT();
		if (ppDisp == NULL)
			return E_POINTER;
		return m_spOleObject.QueryInterface(ppDisp);
	}
	STDMETHOD(TransformCoords)(POINTL* /*pPtlHimetric*/, POINTF* /*pPtfContainer*/, DWORD /*dwFlags*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLTRACENOTIMPL(_T("CAxHostWindow::TransformCoords"));
	}
	STDMETHOD(TranslateAccelerator)(LPMSG /*lpMsg*/, DWORD /*grfModifiers*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		return S_FALSE;
	}
	STDMETHOD(OnFocus)(BOOL fGotFocus)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bHaveFocus = fGotFocus;
		return S_OK;
	}
	STDMETHOD(ShowPropertyFrame)()
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLTRACENOTIMPL(_T("CAxHostWindow::ShowPropertyFrame"));
	}

// IAdviseSink
	STDMETHOD_(void, OnDataChange)(FORMATETC* /*pFormatetc*/, STGMEDIUM* /*pStgmed*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
	}
	STDMETHOD_(void, OnViewChange)(DWORD /*dwAspect*/, LONG /*lindex*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
	}
	STDMETHOD_(void, OnRename)(IMoniker* /*pmk*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
	}
	STDMETHOD_(void, OnSave)()
	{
		CE_VALIDATE_THREADID_ASSERT();
	}
	STDMETHOD_(void, OnClose)()
	{
		CE_VALIDATE_THREADID_ASSERT();
	}

// IOleContainer
	STDMETHOD(ParseDisplayName)(IBindCtx* /*pbc*/, LPOLESTR /*pszDisplayName*/, ULONG* /*pchEaten*/, IMoniker** /*ppmkOut*/)
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLTRACENOTIMPL(_T("CAxHostWindow::ParseDisplayName"));
	}
	STDMETHOD(EnumObjects)(DWORD /*grfFlags*/, IEnumUnknown** ppenum)
	{
		CE_VALIDATE_THREADID_ASSERT();
		if (ppenum == NULL)
			return E_POINTER;
		*ppenum = NULL;
		typedef CComObject<CComEnum<IEnumUnknown, &__uuidof(IEnumUnknown), IUnknown*, _CopyInterface<IUnknown> > > enumunk;
		enumunk* p = NULL;
#pragma warning(push)
#pragma warning(disable: 6014)
		/* prefast noise VSW 489981 */
		ATLTRY(p = new enumunk);
#pragma warning(pop)
		if(p == NULL)
			return E_OUTOFMEMORY;
		IUnknown* pTemp = m_spUnknown;
		// There is always only one object.
		HRESULT hRes = p->Init(reinterpret_cast<IUnknown**>(&pTemp), reinterpret_cast<IUnknown**>(&pTemp + 1), GetControllingUnknown(), AtlFlagCopy);
		if (SUCCEEDED(hRes))
			hRes = p->QueryInterface(__uuidof(IEnumUnknown), (void**)ppenum);
		if (FAILED(hRes))
			delete p;
		return hRes;
	}
	STDMETHOD(LockContainer)(BOOL fLock)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bLocked = fLock;
		return S_OK;
	}

	HRESULT ActivateAx(IUnknown* pUnkControl, bool bInited, IStream* pStream)
	{
		CE_VALIDATE_THREADID_ASSERT();
		if (pUnkControl == NULL)
			return S_OK;

		m_spUnknown = pUnkControl;

		HRESULT hr = S_OK;
		pUnkControl->QueryInterface(__uuidof(IOleObject), (void**)&m_spOleObject);
		if (m_spOleObject)
		{
			m_spOleObject->GetMiscStatus(DVASPECT_CONTENT, &m_dwMiscStatus);
			if (m_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)
			{
				CComQIPtr<IOleClientSite> spClientSite(GetControllingUnknown());
				m_spOleObject->SetClientSite(spClientSite);
			}

			if (!bInited) // If user hasn't initialized the control, initialize/load using IPersistStreamInit or IPersistStream
			{
				CComQIPtr<IPersistStreamInit> spPSI(m_spOleObject);
				if (spPSI)
				{
					if (pStream)
						hr = spPSI->Load(pStream);
					else
						hr = spPSI->InitNew();
				}
				else if (pStream)
				{
					CComQIPtr<IPersistStream> spPS(m_spOleObject);
					if (spPS)
						hr = spPS->Load(pStream);
				}

				if (FAILED(hr)) // If the initialization of the control failed...
				{
					// Clean up and return
					if (m_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)
						m_spOleObject->SetClientSite(NULL);

					m_dwMiscStatus = 0;
					m_spOleObject.Release();
					m_spUnknown.Release();

					return hr;
				}
			}

			if (0 == (m_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST))
			{
				CComQIPtr<IOleClientSite> spClientSite(GetControllingUnknown());
				m_spOleObject->SetClientSite(spClientSite);
			}

			m_dwViewObjectType = 0;
			hr = m_spOleObject->QueryInterface(__uuidof(IViewObjectEx), (void**) &m_spViewObject);
			if (FAILED(hr))
			{
				hr = m_spOleObject->QueryInterface(__uuidof(IViewObject2), (void**) &m_spViewObject);
				if (SUCCEEDED(hr))
					m_dwViewObjectType = 3;
			} else
				m_dwViewObjectType = 7;

			if (FAILED(hr))
			{
				hr = m_spOleObject->QueryInterface(__uuidof(IViewObject), (void**) &m_spViewObject);
				if (SUCCEEDED(hr))
					m_dwViewObjectType = 1;
			}
			CComQIPtr<IAdviseSink> spAdviseSink(GetControllingUnknown());
			m_spOleObject->Advise(spAdviseSink, &m_dwOleObject);
			if (m_spViewObject)
				m_spViewObject->SetAdvise(DVASPECT_CONTENT, 0, spAdviseSink);
			m_spOleObject->SetHostNames(OLESTR("AXWIN"), NULL);

			if ((m_dwMiscStatus & OLEMISC_INVISIBLEATRUNTIME) == 0)
			{
				GetClientRect(&m_rcPos);
				m_pxSize.cx = m_rcPos.right - m_rcPos.left;
				m_pxSize.cy = m_rcPos.bottom - m_rcPos.top;
				AtlPixelToHiMetric(&m_pxSize, &m_hmSize);
				m_spOleObject->SetExtent(DVASPECT_CONTENT, &m_hmSize);
				m_spOleObject->GetExtent(DVASPECT_CONTENT, &m_hmSize);
				AtlHiMetricToPixel(&m_hmSize, &m_pxSize);
				m_rcPos.right = m_rcPos.left + m_pxSize.cx;
				m_rcPos.bottom = m_rcPos.top + m_pxSize.cy;

				CComQIPtr<IOleClientSite> spClientSite(GetControllingUnknown());
				hr = m_spOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
				RedrawWindow(NULL, NULL, ATL_RDW_WHOLE_WINDOW);
			}
		}
		CComPtr<IObjectWithSite> spSite;
		pUnkControl->QueryInterface(__uuidof(IObjectWithSite), (void**)&spSite);
		if (spSite != NULL)
			spSite->SetSite(GetControllingUnknown());

		return hr;
	}


// pointers
	CComPtr<IUnknown> m_spUnknown;
	CComPtr<IOleObject> m_spOleObject;
	CComPtr<IOleInPlaceFrame> m_spInPlaceFrame;
	CComPtr<IOleInPlaceUIWindow> m_spInPlaceUIWindow;
	CComPtr<IViewObjectEx> m_spViewObject;
	CComPtr<IOleInPlaceObjectWindowless> m_spInPlaceObjectWindowless;
	CComPtr<IDispatch> m_spExternalDispatch;
#ifndef _ATL_NO_DOCHOSTUIHANDLER
	CComPtr<IDocHostUIHandlerDispatch> m_spIDocHostUIHandlerDispatch;
#endif
	IID m_iidSink;
	DWORD m_dwViewObjectType;
	DWORD m_dwAdviseSink;

// state
	unsigned long m_bInPlaceActive:1;
	unsigned long m_bUIActive:1;
	unsigned long m_bMDIApp:1;
	unsigned long m_bWindowless:1;
	unsigned long m_bCapture:1;
	unsigned long m_bHaveFocus:1;
	unsigned long m_bReleaseAll:1;
	unsigned long m_bLocked:1;

	DWORD m_dwOleObject;
	DWORD m_dwMiscStatus;
	SIZEL m_hmSize;
	SIZEL m_pxSize;
	RECT m_rcPos;

	// Accelerator table
	HACCEL m_hAccel;

	// Ambient property storage
	unsigned long m_bCanWindowlessActivate:1;
	unsigned long m_bUserMode:1;
	unsigned long m_bDisplayAsDefault:1;
	unsigned long m_bMessageReflect:1;
	unsigned long m_bSubclassed:1;
	unsigned long m_bAllowContextMenu:1;
	unsigned long m_bAllowShowUI:1;
	OLE_COLOR m_clrBackground;
	OLE_COLOR m_clrForeground;
	LCID m_lcidLocaleID;
	CComPtr<IFontDisp> m_spFont;
	CComPtr<IServiceProvider>  m_spServices;
	DWORD m_dwDocHostFlags;
	DWORD m_dwDocHostDoubleClickFlags;
	CComBSTR m_bstrOptionKeyPath;

	void SubclassWindow(HWND hWnd)
	{
		CE_VALIDATE_THREADID_ASSERT();
		m_bSubclassed = CWindowImpl<CAxHostWindow>::SubclassWindow(hWnd);
	}

	void ReleaseWindow()
	{
		CE_VALIDATE_THREADID_ASSERT();
		if (m_bSubclassed)
		{
			if(UnsubclassWindow(TRUE) != NULL)
				m_bSubclassed = FALSE;
		}
		else
			DestroyWindow();
	}

	// Reflection
	LRESULT ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		CE_VALIDATE_THREADID_ASSERT();
		HWND hWndChild = NULL;

		switch(uMsg)
		{
		case WM_COMMAND:
			if(lParam != NULL)	// not from a menu
				hWndChild = (HWND)lParam;
			break;
		case WM_NOTIFY:
			hWndChild = ((LPNMHDR)lParam)->hwndFrom;
			break;
#ifndef _WIN32_WCE
		case WM_PARENTNOTIFY:
			DefWindowProc();
			switch(LOWORD(wParam))
			{
			case WM_CREATE:
			case WM_DESTROY:
				hWndChild = (HWND)lParam;
				break;
			default:
				hWndChild = GetDlgItem(HIWORD(wParam));
				break;
			}
			break;
#endif // _WIN32_WCE
		case WM_DRAWITEM:
			{
				DRAWITEMSTRUCT* pdis = ((LPDRAWITEMSTRUCT)lParam);
				if (pdis->CtlType != ODT_MENU)	// not from a menu
					hWndChild = pdis->hwndItem;
				else							// Status bar control sends this message with type set to ODT_MENU
					if (::IsWindow(pdis->hwndItem))
						hWndChild = pdis->hwndItem;
			}
			break;
		case WM_MEASUREITEM:
			{
				MEASUREITEMSTRUCT* pmis = ((LPMEASUREITEMSTRUCT)lParam);
				if(pmis->CtlType != ODT_MENU)	// not from a menu
					hWndChild = GetDlgItem(pmis->CtlID);
			}
			break;
		case WM_COMPAREITEM:
				// Sent only by combo or list box
					hWndChild =((LPCOMPAREITEMSTRUCT)lParam)->hwndItem;
			break;
		case WM_DELETEITEM:
				// Sent only by combo or list box  
				hWndChild = ((LPDELETEITEMSTRUCT)lParam)->hwndItem; 
			break;
		case WM_VKEYTOITEM:
		case WM_CHARTOITEM:
		case WM_HSCROLL:
		case WM_VSCROLL:
			hWndChild = (HWND)lParam;
			break;
		case WM_CTLCOLORBTN:
		case WM_CTLCOLORDLG:
		case WM_CTLCOLOREDIT:
		case WM_CTLCOLORLISTBOX:
		case WM_CTLCOLORMSGBOX:
		case WM_CTLCOLORSCROLLBAR:
		case WM_CTLCOLORSTATIC:
			hWndChild = (HWND)lParam;
			break;
		default:
			break;
		}

		if(hWndChild == NULL)
		{
			bHandled = FALSE;
			return 1;
		}

		if (m_bWindowless)
		{
			LRESULT lRes = 0;
			if (m_bInPlaceActive && m_spInPlaceObjectWindowless)
				m_spInPlaceObjectWindowless->OnWindowMessage(OCM__BASE + uMsg, wParam, lParam, &lRes);
			return lRes;
		}

		ATLASSERT(::IsWindow(hWndChild));
		return ::SendMessage(hWndChild, OCM__BASE + uMsg, wParam, lParam);
	}

	STDMETHOD(QueryService)( REFGUID rsid, REFIID riid, void** ppvObj) 
	{
		CE_VALIDATE_THREADID_ASSERT();
		ATLASSERT(ppvObj != NULL);
		if (ppvObj == NULL)
			return E_POINTER;
		*ppvObj = NULL;

		HRESULT hr = E_NOINTERFACE;
		// Try for service on this object

		// No services currently

		// If that failed try to find the service on the outer object
		if (FAILED(hr) && m_spServices)
			hr = m_spServices->QueryService(rsid, riid, ppvObj);

		return hr;
	}
};

inline HRESULT AtlOleInitialize()
{
#ifndef _WIN32_WCE
	// This is to make sure drag drop works
	return ::OleInitialize(NULL);
#else // _WIN32_WCE
	// CE does not support drag and drop (or OLE in many ways)
#if defined(_ATL_STATIC_LIB_IMPL) || defined(_ATL_DLL_IMPL)
	// For the ATL binaries first try for STA, then MTA
	HRESULT hr = ATL::CoInitialize(NULL);
	if(E_NOTIMPL == hr)
	{
		// Not DCOM, try for the MTA instead...
		hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED);
	}
#elif defined(_CE_DCOM)
	// if DCOM only try for STA
	HRESULT hr = ::CoInitialize(NULL);
#else // defined(_CE_DCOM) || defined(_ATL_STATIC_LIB_IMPL) || defined(_ATL_DLL_IMPL)
	// if not DCOM only try for MTA
	HRESULT hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED);
#endif // defined(_CE_DCOM) || defined(_ATL_STATIC_LIB_IMPL) || defined(_ATL_DLL_IMPL)
	ATLASSERT(SUCCEEDED(hr)); // Failure indicates the thread was already initialized by to an incompatible threading model
	return hr;
#endif // _WIN32_WCE
}

inline void AtlOleUninitialize()
{
#ifndef _WIN32_WCE
	OleUninitialize();
#else // _WIN32_WCE
	CoUninitialize();
#endif // _WIN32_WCE
}

static LRESULT CALLBACK AtlAxWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg)
	{
	case WM_CREATE:
		{
			// create control from a PROGID in the title
			// This is to make sure drag drop works
			AtlOleInitialize();

			CREATESTRUCT* lpCreate = (CREATESTRUCT*)lParam;
			int nLen = ::GetWindowTextLength(hWnd);
			CAutoStackPtr<TCHAR> spName((TCHAR *)_malloca((nLen + 1) * sizeof(TCHAR)));
			if(!spName)
			{
				return -1;
			}
			::GetWindowText(hWnd, spName, nLen + 1);
			::SetWindowText(hWnd, _T(""));
			IAxWinHostWindow* pAxWindow = NULL;
			int nCreateSize = 0;
			if (lpCreate && lpCreate->lpCreateParams)
				nCreateSize = *((WORD*)lpCreate->lpCreateParams);

			HGLOBAL h = GlobalAlloc(GHND, nCreateSize);
			CComPtr<IStream> spStream;
			if (h && nCreateSize)
			{
				BYTE* pBytes = (BYTE*) GlobalLock(h);
				BYTE* pSource = ((BYTE*)(lpCreate->lpCreateParams)) + sizeof(WORD); 
				//Align to DWORD
				//pSource += (((~((DWORD)pSource)) + 1) & 3);
				Checked::memcpy_s(pBytes, nCreateSize, pSource, nCreateSize);
				GlobalUnlock(h);
				CreateStreamOnHGlobal(h, TRUE, &spStream);
			}

			USES_CONVERSION_EX;
			CComPtr<IUnknown> spUnk;
			HRESULT hRet = AtlAxCreateControlLic(T2COLE_EX_DEF(spName), hWnd, spStream, &spUnk, NULL);
			if(FAILED(hRet))
			{
#ifdef _DEBUG
				LPTSTR pszMsg = NULL;
				::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM, NULL, hRet, 0, (LPTSTR)&pszMsg, 0, NULL);
				ATLTRACE(atlTraceControls, 0, _T("Control creation failed for '%s'\n"), static_cast<TCHAR *>(spName));
				ATLTRACE(atlTraceControls, 0, _T("Error code: 0x%x - %s"), hRet, pszMsg);
				::LocalFree(pszMsg);
#endif
				return -1;	// abort window creation
			}
			hRet = spUnk->QueryInterface(__uuidof(IAxWinHostWindow), (void**)&pAxWindow);
			if(FAILED(hRet))
				return -1;	// abort window creation

			::SetWindowLongPtr(hWnd, GWLP_USERDATA, (DWORD_PTR)pAxWindow);

		// continue with DefWindowProc
		}
		break;
	case WM_NCDESTROY:
		{
			IAxWinHostWindow* pAxWindow = (IAxWinHostWindow*)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
			if(pAxWindow != NULL)
				pAxWindow->Release();
			AtlOleUninitialize();
		}
		break;

#ifndef _WIN32_WCE
	case WM_PARENTNOTIFY:
		{
			if((UINT)wParam == WM_CREATE)
			{
				ATLASSERT(lParam);
				// Set the control parent style for the AxWindow
				DWORD dwExStyle = ::GetWindowLong((HWND)lParam, GWL_EXSTYLE);
				if(dwExStyle & WS_EX_CONTROLPARENT)
				{
					dwExStyle = ::GetWindowLong(hWnd, GWL_EXSTYLE);
					dwExStyle |= WS_EX_CONTROLPARENT;
					::SetWindowLong(hWnd, GWL_EXSTYLE, dwExStyle);
				}
			}
		}
		break;
#endif // _WIN32_WCE
	default:
		break;
	}

	return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
}

static LRESULT CALLBACK AtlAxWindowProc2(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg)
	{
	case WM_CREATE:
		{
		// create control from a PROGID in the title
			AtlOleInitialize();

			CREATESTRUCT* lpCreate = (CREATESTRUCT*)lParam;
			int nLen = ::GetWindowTextLength(hWnd);
			CAutoStackPtr<TCHAR> spName((TCHAR *)_malloca((nLen + 1) * sizeof(TCHAR)));
			if(!spName)
			{
				return -1;
			}
			::GetWindowText(hWnd, spName, nLen + 1);
			::SetWindowText(hWnd, _T(""));
			IAxWinHostWindowLic* pAxWindow = NULL;
			int nCreateSize = 0;
			if (lpCreate && lpCreate->lpCreateParams)
				nCreateSize = *((WORD*)lpCreate->lpCreateParams);

			// Format of data in lpCreateParams
			//	int nCreateSize;	// size of Create data in bytes
			//	WORD nMsg;			//constant used to indicate type of DLGINIT data. See _DialogSplitHelper for values.
			//	DWORD dwLen;		// Length of data strored for control in DLGINIT format in bytes.
			//	DWORD cchLicKey;	// Length of licence key in OLECHAR's
			//  OLECHAR *szLicKey;	// This will be present only if cchLicKey is greater than 0. This is of variable length and will contain cchLicKey OLECHAR's that represent the licence key.
			//	The following two fields will be present only if nMsg is WM_OCC_LOADFROMSTREAM_EX or WM_OCC_LOADFROMSTORAGE_EX. If present this information will be ignored since databinding is not supported.
			//		ULONG cbDataBinding;	// Lenght of databinding information in bytes.
			//		BYTE *pbDataBindingInfo	// cbDataBinding bytes that contain databinding information
			//	BYTE *pbControlData;	// Actual control data persisted by the control.


			HGLOBAL h = GlobalAlloc(GHND, nCreateSize);
			CComPtr<IStream> spStream;
			if (h && nCreateSize)
			{
				BYTE* pBytes = (BYTE*) GlobalLock(h);
				BYTE* pSource = ((BYTE*)(lpCreate->lpCreateParams)) + sizeof(WORD); 
				//Align to DWORD
				//pSource += (((~((DWORD)pSource)) + 1) & 3);
				Checked::memcpy_s(pBytes, nCreateSize, pSource, nCreateSize);
				GlobalUnlock(h);
				CreateStreamOnHGlobal(h, TRUE, &spStream);
			}

			CComBSTR bstrLicKey;
			HRESULT hRet = _DialogSplitHelper::ParseInitData(spStream, &bstrLicKey.m_str);
			if (FAILED(hRet))
				return -1;

			USES_CONVERSION_EX;
			CComPtr<IUnknown> spUnk;
			hRet = AtlAxCreateControlLic(T2COLE_EX_DEF(spName), hWnd, spStream, &spUnk, bstrLicKey);
			if(FAILED(hRet))
			{
#ifdef _DEBUG
				LPTSTR pszMsg = NULL;
				::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM, NULL, hRet, 0, (LPTSTR)&pszMsg, 0, NULL);
				ATLTRACE(atlTraceControls, 0, _T("Control creation failed for '%s'\n"), static_cast<TCHAR *>(spName));
				ATLTRACE(atlTraceControls, 0, _T("Error code: 0x%x - %s"), hRet, pszMsg);
				::LocalFree(pszMsg);
#endif
				return -1;	// abort window creation
			}
			hRet = spUnk->QueryInterface(__uuidof(IAxWinHostWindowLic), (void**)&pAxWindow);
			if(FAILED(hRet))
				return -1;	// abort window creation
			::SetWindowLongPtr(hWnd, GWLP_USERDATA, (DWORD_PTR)pAxWindow);

		// continue with DefWindowProc
		}
		break;
	case WM_NCDESTROY:
		{
			IAxWinHostWindowLic* pAxWindow = (IAxWinHostWindowLic*)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
			if(pAxWindow != NULL)
				pAxWindow->Release();
			AtlOleUninitialize();
		}
		break;

#ifndef _WIN32_WCE
	case WM_PARENTNOTIFY:
		{
			if((UINT)wParam == WM_CREATE)
			{
				ATLASSERT(lParam);
				// Set the control parent style for the AxWindow
				DWORD dwExStyle = ::GetWindowLong((HWND)lParam, GWL_EXSTYLE);
				if(dwExStyle & WS_EX_CONTROLPARENT)
				{
					dwExStyle = ::GetWindowLong(hWnd, GWL_EXSTYLE);
					dwExStyle |= WS_EX_CONTROLPARENT;
					::SetWindowLong(hWnd, GWL_EXSTYLE, dwExStyle);
				}
			}
		}
		break;
#endif // _WIN32_WCE
	default:
		break;
	}

	return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//All exports go here
#ifndef _ATL_DLL

inline HRSRC AtlFindResource(HMODULE hModule, LPCSTR lpName, LPCSTR lpType)
{
	return ::FindResourceA(hModule, lpName, lpType);
}

inline HRSRC AtlFindResource(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
{
	return ::FindResourceW(hModule, lpName, lpType);
}

class _AtlDialogBoxIndirectParamHelper
{
public :
	typedef INT_PTR ReturnType;
	static ReturnType GetInvalidValue()
	{
		return -1;
	}
	static bool IsValidReturnVal(ReturnType nRet)
	{
		return (nRet != 0 && nRet != -1);
	}
};

class _AtlCreateDialogIndirectParamHelper
{
public :
	typedef HWND ReturnType;
	static ReturnType GetInvalidValue()
	{
		return NULL;
	}
	static bool IsValidReturnVal(ReturnType nRet)
	{
		return (nRet != 0);
	}
};

template <class StringType, class Helper, typename Helper::ReturnType (WINAPI *pFunc)(HINSTANCE, LPCDLGTEMPLATE, HWND,DLGPROC, LPARAM)>
typename Helper::ReturnType AtlAxDialogCreateT(HINSTANCE hInstance, StringType lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
	AtlAxWinInit();
	Helper::ReturnType nRet = Helper::GetInvalidValue();

	HRSRC hDlg = AtlFindResource(hInstance, lpTemplateName, (StringType)RT_DIALOG);
	if (hDlg != NULL)
	{
		HRSRC hDlgInit = AtlFindResource(hInstance, lpTemplateName, (StringType)_ATL_RT_DLGINIT);
		HGLOBAL hData = NULL;
		BYTE* pInitData = NULL;

		if (hDlgInit)
		{
			hData = ::LoadResource(hInstance, hDlgInit);
			pInitData = (BYTE*) ::LockResource(hData);
		}

		DWORD dwLastError = 0;
		HGLOBAL hResource = LoadResource(hInstance, hDlg);
		if (hResource != NULL)
		{
			DLGTEMPLATE* pDlg = (DLGTEMPLATE*) LockResource(hResource);
			if (pDlg != NULL)
			{
				LPCDLGTEMPLATE lpDialogTemplate;

				lpDialogTemplate = _DialogSplitHelper::SplitDialogTemplate(pDlg, pInitData);

				nRet = (*pFunc)(hInstance, lpDialogTemplate, hWndParent, lpDialogProc, dwInitParam);
				if (!Helper::IsValidReturnVal(nRet))
				{
					dwLastError = ::GetLastError();
				}
				if (lpDialogTemplate != pDlg)
					GlobalFree(GlobalHandle(lpDialogTemplate));
			}
			else
				dwLastError = ::GetLastError();
		}
		else
			dwLastError = ::GetLastError();

		if (dwLastError != 0)
			SetLastError(dwLastError);
	}
	return nRet;
}

ATLINLINE ATLAPI_(INT_PTR) AtlAxDialogBoxW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
	return AtlAxDialogCreateT<LPCWSTR, _AtlDialogBoxIndirectParamHelper, ::DialogBoxIndirectParamW>(
		hInstance, lpTemplateName, hWndParent, lpDialogProc, dwInitParam);
}

#ifndef _WIN32_WCE

// fix this once compiler is fixed
//ATLINLINE ATLAPI_(INT_PTR) AtlAxDialogBoxA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
ATLINLINE ATLAPI_(INT_PTR) AtlAxDialogBoxA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
	return AtlAxDialogCreateT<LPCSTR, _AtlDialogBoxIndirectParamHelper, ::DialogBoxIndirectParamA>(
		hInstance, lpTemplateName, hWndParent, lpDialogProc, dwInitParam);
}

#endif // _WIN32_WCE

// fix this once compiler is fixed
//ATLINLINE ATLAPI_(HWND) AtlAxCreateDialogW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
ATLINLINE ATLAPI_(HWND) AtlAxCreateDialogW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
	return AtlAxDialogCreateT<LPCWSTR, _AtlCreateDialogIndirectParamHelper, CreateDialogIndirectParamW>(
		hInstance, lpTemplateName, hWndParent, lpDialogProc, dwInitParam);
}

#ifndef _WIN32_WCE

// fix this once compiler is fixed
//ATLINLINE ATLAPI_(HWND) AtlAxCreateDialogA(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
ATLINLINE ATLAPI_(HWND) AtlAxCreateDialogA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam)
{
	return AtlAxDialogCreateT<LPCSTR, _AtlCreateDialogIndirectParamHelper, CreateDialogIndirectParamA>(hInstance, lpTemplateName, hWndParent, lpDialogProc, dwInitParam);
}

#endif // _WIN32_WCE

ATLINLINE ATLAPI AtlAxCreateControl(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer)
{
	return AtlAxCreateControlEx(lpszName, hWnd, pStream, ppUnkContainer, NULL, IID_NULL, NULL);
}

ATLINLINE ATLAPI AtlAxCreateControlEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
		IUnknown** ppUnkContainer, IUnknown** ppUnkControl, REFIID iidSink, IUnknown* punkSink)
{
	return AtlAxCreateControlLicEx(lpszName, hWnd, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink, NULL);
}

ATLINLINE ATLAPI AtlAxCreateControlLic(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer, BSTR bstrLic)
{
	return AtlAxCreateControlLicEx(lpszName, hWnd, pStream, ppUnkContainer, NULL, IID_NULL, NULL, bstrLic);
}

ATLINLINE ATLAPI AtlAxCreateControlLicEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
		IUnknown** ppUnkContainer, IUnknown** ppUnkControl, REFIID iidSink, IUnknown* punkSink, BSTR bstrLic)
{
	AtlAxWinInit();
	HRESULT hr;
	CComPtr<IUnknown> spUnkContainer;
	CComPtr<IUnknown> spUnkControl;

	hr = CAxHostWindow::_CreatorClass::CreateInstance(NULL, __uuidof(IUnknown), (void**)&spUnkContainer);
	if (SUCCEEDED(hr))
	{
		CComPtr<IAxWinHostWindowLic> pAxWindow;
		spUnkContainer->QueryInterface(__uuidof(IAxWinHostWindow), (void**)&pAxWindow);
		CComBSTR bstrName(lpszName);
		hr = pAxWindow->CreateControlLicEx(bstrName, hWnd, pStream, &spUnkControl, iidSink, punkSink, bstrLic);
	}
	if (ppUnkContainer != NULL)
	{
		if (SUCCEEDED(hr))
		{
			*ppUnkContainer = spUnkContainer.p;
			spUnkContainer.p = NULL;
		}
		else
			*ppUnkContainer = NULL;
	}
	if (ppUnkControl != NULL)
	{
		if (SUCCEEDED(hr))
		{
			*ppUnkControl = SUCCEEDED(hr) ? spUnkControl.p : NULL;
			spUnkControl.p = NULL;
		}
		else
			*ppUnkControl = NULL;
	}
	return hr;
}

ATLINLINE ATLAPI AtlAxAttachControl(IUnknown* pControl, HWND hWnd, IUnknown** ppUnkContainer)
{
	AtlAxWinInit();
	if (pControl == NULL)
		return E_INVALIDARG;
	CComPtr<IUnknown> spUnkContainer;

	HRESULT hr = CAxHostWindow::_CreatorClass::CreateInstance(NULL, __uuidof(IUnknown), (void**)&spUnkContainer);
	if (SUCCEEDED(hr))
	{
		CComPtr<IAxWinHostWindow> spAxWindow;
		hr = spUnkContainer.QueryInterface(&spAxWindow);
		if (SUCCEEDED(hr))
			hr = spAxWindow->AttachControl(pControl, hWnd);
	}
	if (ppUnkContainer != NULL)
	{
		*ppUnkContainer = SUCCEEDED(hr) ? spUnkContainer.Detach() : NULL;
	}
	return hr;
}

#ifdef _ATL_DLL_IMPL
// global variable in ATL.DLL to keep track if AtlAxWin window class has been registered in ATL.DLL
bool __declspec(selectany) bAtlAxWinInitialized;
#endif

//This either registers a global class (if AtlAxWinInit is in ATL.DLL)
// or it registers a local class
ATLINLINE ATLAPI_(BOOL) AtlAxWinInit()
{
	CComCritSecLock<CComCriticalSection> lock(_AtlWinModule.m_csWindowCreate, false);
	if (FAILED(lock.Lock()))
	{
		ATLTRACE(atlTraceHosting, 0, _T("ERROR : Unable to lock critical section in AtlAxWinInit\n"));
		ATLASSERT(0);
		return FALSE;
	}
	WM_ATLGETHOST = RegisterWindowMessage(_T("WM_ATLGETHOST"));
	WM_ATLGETCONTROL = RegisterWindowMessage(_T("WM_ATLGETCONTROL"));

// first check if the class is already registered
#ifndef _WIN32_WCE
	WNDCLASSEX wc;
// first check if the class is already registered
	wc.cbSize = sizeof(WNDCLASSEX);
	BOOL bRet = ::GetClassInfoEx(_AtlBaseModule.GetModuleInstance(), CAxWindow::GetWndClassName(), &wc);
#else // _WIN32_WCE
	WNDCLASS wc;
	BOOL bRet = ::GetClassInfo(_AtlBaseModule.GetModuleInstance(), CAxWindow::GetWndClassName(), &wc);
#endif // _WIN32_WCE

// register class if not

	if(!bRet)
	{
#ifndef _WIN32_WCE
		wc.cbSize = sizeof(WNDCLASSEX);
#endif // _WIN32_WCE
#ifdef _ATL_DLL_IMPL
		wc.style = CS_GLOBALCLASS | CS_DBLCLKS;
		bAtlAxWinInitialized = true;
#else
		wc.style = CS_DBLCLKS;
#endif
		wc.lpfnWndProc = AtlAxWindowProc;
		wc.cbClsExtra = 0;
		wc.cbWndExtra = 0;
		wc.hInstance = _AtlBaseModule.GetModuleInstance();
		wc.hIcon = NULL;
		wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
		wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
		wc.lpszMenuName = NULL;
		wc.lpszClassName = CAxWindow::GetWndClassName();
#ifndef _WIN32_WCE
		wc.hIconSm = NULL;
#endif // _WIN32_WCE

#ifndef _WIN32_WCE
		ATOM atom = ::RegisterClassEx(&wc);
#else // _WIN32_WCE
		ATOM atom = ::RegisterClass(&wc);
#endif // _WIN32_WCE
		if (atom)
		{	
		   _AtlWinModule.m_rgWindowClassAtoms.Add(atom);
		   bRet=TRUE;
		}else 
		{
		  bRet=FALSE;
		}

	}

	if (bRet)
	{
		// first check if the class is already registered
#ifndef _WIN32_WCE
		memset(&wc, 0, sizeof(WNDCLASSEX));
		wc.cbSize = sizeof(WNDCLASSEX);
		bRet = ::GetClassInfoEx(_AtlBaseModule.GetModuleInstance(), CAxWindow2::GetWndClassName(), &wc);
#else // _WIN32_WCE
		memset(&wc, 0, sizeof(WNDCLASS));
		bRet = ::GetClassInfo(_AtlBaseModule.GetModuleInstance(), CAxWindow2::GetWndClassName(), &wc);
#endif // _WIN32_WCE

		// register class if not

		if(!bRet)
		{
#ifndef _WIN32_WCE
			wc.cbSize = sizeof(WNDCLASSEX);
#endif // _WIN32_WCE
#ifdef _ATL_DLL_IMPL
			wc.style = CS_GLOBALCLASS | CS_DBLCLKS;
#else
			wc.style = CS_DBLCLKS;
#endif
			wc.lpfnWndProc = AtlAxWindowProc2;
			wc.cbClsExtra = 0;
			wc.cbWndExtra = 0;
			wc.hInstance = _AtlBaseModule.GetModuleInstance();
			wc.hIcon = NULL;
			wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
			wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
			wc.lpszMenuName = NULL;
			wc.lpszClassName = CAxWindow2::GetWndClassName();
#ifndef _WIN32_WCE
			wc.hIconSm = NULL;
#endif // _WIN32_WCE
#ifndef _WIN32_WCE
			ATOM atom = ::RegisterClassEx(&wc);
#else // _WIN32_WCE
			ATOM atom = ::RegisterClass(&wc);
#endif // _WIN32_WCE
			if (atom)
			{	
				_AtlWinModule.m_rgWindowClassAtoms.Add(atom);
				bRet=TRUE;
			}else 
			{
				bRet=FALSE;
			}

		}
	}
	return bRet;
}

ATLINLINE ATLAPI AtlAxGetControl(HWND h, IUnknown** pp)
{
	ATLASSERT(WM_ATLGETCONTROL != 0);
	if (pp == NULL)
		return E_POINTER;
	*pp = (IUnknown*)SendMessage(h, WM_ATLGETCONTROL, 0, 0);
	return (*pp) ? S_OK : E_FAIL;
}

ATLINLINE ATLAPI AtlAxGetHost(HWND h, IUnknown** pp)
{
	ATLASSERT(WM_ATLGETHOST != 0);
	if (pp == NULL)
		return E_POINTER;
	*pp = (IUnknown*)SendMessage(h, WM_ATLGETHOST, 0, 0);
	return (*pp) ? S_OK : E_FAIL;
}

#endif // _ATL_DLL

}; //namespace ATL
#pragma pack(pop)

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif //!_ATL_NO_PRAGMA_WARNINGS

#endif  // __ATLHOST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlexcept.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLEXCEPT_H__
#define __ATLEXCEPT_H__

#pragma once

#include <atldef.h>
#include <atltrace.h>


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Exception raise (for functions that cannot return an error code)

inline void __declspec(noreturn) _AtlRaiseException( DWORD dwExceptionCode, DWORD dwExceptionFlags = EXCEPTION_NONCONTINUABLE )
{
	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );
}

#ifdef _WIN32_WCE
inline void __declspec(noreturn) _AtlRaiseException( NTSTATUS dwExceptionCode, DWORD dwExceptionFlags = EXCEPTION_NONCONTINUABLE )
{
	RaiseException( static_cast<DWORD>(dwExceptionCode), dwExceptionFlags, 0, NULL );
}
#endif // _WIN32_WCE

class CAtlException
{
public:
	CAtlException() throw() :
		m_hr( E_FAIL )
	{
	}

	CAtlException( HRESULT hr ) throw() :
		m_hr( hr )
	{
	}

	operator HRESULT() const throw()
	{
		return( m_hr );
	}

public:
	HRESULT m_hr;
};

#ifndef _ATL_NO_EXCEPTIONS

// Throw a CAtlException with the given HRESULT
#if defined( _ATL_CUSTOM_THROW )  // You can define your own AtlThrow to throw a custom exception.
#ifdef _AFX
#error MFC projects must use default implementation of AtlThrow()
#endif
#else
ATL_NOINLINE __declspec(noreturn) inline void WINAPI AtlThrowImpl( HRESULT hr )
{
	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
#ifdef _AFX
	if( hr == E_OUTOFMEMORY )
	{
		AfxThrowMemoryException();
	}
	else
	{
		AfxThrowOleException( hr );
	}
#else
	throw CAtlException( hr );
#endif
};
#endif

// Throw a CAtlException corresponding to the result of ::GetLastError
ATL_NOINLINE __declspec(noreturn) inline void WINAPI AtlThrowLastWin32()
{
	DWORD dwError = ::GetLastError();
	AtlThrow( HRESULT_FROM_WIN32( dwError ) );
}

#else  // no exception handling

// Throw a CAtlException with th given HRESULT
#if !defined( _ATL_CUSTOM_THROW )  // You can define your own AtlThrow

ATL_NOINLINE inline void WINAPI AtlThrowImpl( HRESULT hr )
{
	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
	ATLASSERT( false );
	DWORD dwExceptionCode;
	switch(hr)
	{
	case E_OUTOFMEMORY:
		dwExceptionCode = static_cast<DWORD>(STATUS_NO_MEMORY);
		break;
	default:
		dwExceptionCode = static_cast<DWORD>(EXCEPTION_ILLEGAL_INSTRUCTION);
	}
	_AtlRaiseException((DWORD)dwExceptionCode);
}
#endif

// Throw a CAtlException corresponding to the result of ::GetLastError
ATL_NOINLINE inline void WINAPI AtlThrowLastWin32()
{
	DWORD dwError = ::GetLastError();
	AtlThrow( HRESULT_FROM_WIN32( dwError ) );
}

#endif  // no exception handling

};  // namespace ATL
#pragma pack(pop)

#endif  // __ATLEXCEPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlextmgmt.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLEXTMGMT_H__
#define __ATLEXTMGMT_H__

#ifdef _WIN32_WCE
	#error atlextmgmt.h is not supported on Windows CE (_WIN32_WCE is defined)
#endif //_WIN32_WCE

#pragma once
#pragma warning(push)
#pragma warning(disable: 4702)
#include <atlsoap.h>
#include <atlutil.h>
#include <atlsrvres.h>
#include <atlsecurity.h>

//
// You can change the local group that is used for authorizing
// site administrators by #define'ing ATL_DEFAULT_AUTH group
// to something else before including this header file. For
// example:
// #define ATL_DEFAULT_AUTHGRP CSid(_T("My Heros"))
//     Verify that the logged on user is a members of
//     the local group 'My Heros' before allowing them to
//     administrate this site.
//
// #define ATL_DEFAULT_AUTHGRP Sids::World
//     Allow everyone access
//
// #define ATL_DEFAULT_AUTHGRP Sids::Null
//     Allow noone access
//
#ifndef ATL_DEFAULT_AUTHGRP
	#define ATL_DEFAULT_AUTHGRP Sids::Admins()
#endif

// If you #define ATL_NO_DEFAULT_AUTHORITY then there will be no authorization
// check before allowing access to management functions. You can also #define
// ATL_NO_DEFAULT_AUTHORITY and then declare you own instance of _Authority
// before #includin'ing atlextmgmt.h to use a different authorization scheme.
#ifndef ATL_NO_DEFAULT_AUTHORITY
	__declspec(selectany) CDefaultAuth _Authority;
#endif

// You can choose which of the management handlers actually get used by
// #defining the following constants before including this header
// _ATL_THREADPOOL_MANAGEMENT (The thread pool manager web service and web based UI)
// _ATL_STENCILCACHE_MANAGEMENT (The stencil cache manager web service and web based UI)
// _ATL_DLLCACHE_MANAGEMENT (The DLL cache manager service and web based UI)

// You can use the following constants to remove the web based UI if you don't
// want to use it.
// _ATL_THREADPOOL_NOUI (removes the thread pool mgr's stencil handler)
// _ATL_STENCILCACHE_NOUI (removes the stencil cache mgr's stencil handler)
// _ATL_DLLCACHE_NOUI (removes the dll cache mgr's stencil handler)

// You can use the following constants to remove the web service management
// components individually
// _ATL_THREADPOOL_NOWEBSERVICE (removes the thread pool mgr's stencil handler)
// _ATL_STENCILCACHE_NOWEBSERVICE (removes the stencil cache mgr's stencil handler)
// _ATL_DLLCACHE_NOWEBSERVICE (removes the dll cache mgr's stencil handler)


// The following constants declare resource names of stencils included
// as resources in the module that uses this header. These stencils are 
// used for the web based UI for the management objects. You can provide
// stencils of your own by including them as resources and redefining these
// constants before including this header.
#ifndef IDR_THREADMGR_SRF
	#define IDR_THREADMGR_SRF "THREADMGR.SRF"
#endif

#ifndef IDR_STENCILMGR_SRF
	#define IDR_STENCILMGR_SRF "STENCILMGR.SRF"
#endif

#ifndef IDR_DLLMGR_SRF
	#define IDR_DLLMGR_SRF "DLLMGR.SRF"
#endif

// A warning so users using the web based UI to manage their extension
// will remember to include the stencil resources n their projects
#if (defined(_ATL_THREADPOOL_MANAGEMENT) && !defined(_ATL_THREADPOOL_NOUI)) ||	(defined(_ATL_STENCILCACHE_MANAGEMENT) && !defined(_ATL_STENCILCACHE_NOUI)) ||	(defined(_ATL_DLLCACHE_MANAGEMENT) && !defined(_ATL_DLLCACHE_NOUI))
#ifndef NO_ATL_MGMT_STENCIL_WARNING
	#pragma message("*************** Please Note ***************")
	#pragma message("Your usage of atlextmgmt.h requires you to include management")
	#pragma message("stencil resources in your module's resource file.")
	#pragma message("Please make sure you include atlsrv.rc in your resource file.\r\n")
#endif
#endif

// These constants define the names used for the handler objects for the
// various services. You can change the names by redefining these constants
// before including this header

#ifndef ID_THREADMGR_WEBSERVICE_NAME
	#define ID_THREADMGR_WEBSERVICE_NAME "ThreadPoolManager"
#endif

#ifndef ID_THREADMGR_WEBSERVICE_URL
	#define ID_THREADMGR_WEBSERVICE_URL "http://www.microsoft.com/vc/atlserver/soap/ThreadPoolManager"
#endif

#ifndef ID_THREADMGR_WEBSERVICE_WSDL
	#define ID_THREADMGR_WEBSERVICE_WSDL "GenThreadPoolManagerWSDL"
#endif

#ifndef ID_THREADMGR_SRFHANDLER_NAME
	#define ID_THREADMGR_SRFHANDLER_NAME "ThreadMgrSrf"
#endif

#ifndef ID_STENCILCACHEMGR_WEBSERVICE_NAME
	#define ID_STENCILCACHEMGR_WEBSERVICE_NAME "StencilCacheManager"
#endif

#ifndef ID_STENCILCACHEMGR_WEBSERVICE_URL
	#define ID_STENCILCACHEMGR_WEBSERVICE_URL "http://www.microsoft.com/vc/atlserver/soap/StencilCacheManager"
#endif

#ifndef ID_STENCILCACHEMGR_WEBSERVICE_WSDL
	#define ID_STENCILCACHEMGR_WEBSERVICE_WSDL "GenStencilCacheManagerWSDL"
#endif

#ifndef ID_STENCILCACHEMGR_SRFHANDLER_NAME
	#define ID_STENCILCACHEMGR_SRFHANDLER_NAME "StencilMgrSrf"
#endif

#ifndef ID_DLLCACHEMGR_WEBSERVICE_NAME
	#define ID_DLLCACHEMGR_WEBSERVICE_NAME "DllCacheManager"
#endif

#ifndef ID_DLLCACHEMGR_WEBSERVICE_URL
	#define ID_DLLCACHEMGR_WEBSERVICE_URL "http://www.microsoft.com/vc/atlserver/soap/DllCacheManager"
#endif

#ifndef ID_DLLCACHEMGR_WEBSERVICE_WSDL
	#define ID_DLLCACHEMGR_WEBSERVICE_WSDL "GenDllCacheManagerWSDL"
#endif


#ifndef ID_DLLCACHEMGR_SRFHANDLER_NAME
	#define ID_DLLCACHEMGR_SRFHANDLER_NAME "DllMgrSrf"
#endif

#pragma pack(push,_ATL_PACKING)
namespace ATL {

[emitidl(restricted)];

#define ATL_COLOR_TR1			RGB(0xd2, 0xff, 0xff)
#define ATL_COLOR_TR2			RGB(0xd2, 0xff, 0xd2)
#define ATL_COLOR_BODYBG		RGB(0xec, 0xf9, 0xec)

// _AtlRedirectToPage builds up a redirect URL from the
// current request plus a Handler= specification and 
// redirects the user's browser to that page.
inline HTTP_CODE _AtlRedirectToPage(
	IHttpServerContext *pContext,
	CHttpRequest& request,
	CHttpResponse& response,
	const char *szHandler)
{
	ATLENSURE(pContext);
	CStringA strRedirect("http://");
	
	char buff[ATL_URL_MAX_URL_LENGTH];
	DWORD dwLen = static_cast<DWORD>(_countof(buff));
	if (!pContext->GetServerVariable("SERVER_NAME", buff, &dwLen))
	{
		return HTTP_FAIL;
	}
	buff[_countof(buff)-1]='\0';
	strRedirect+=buff;

	dwLen = static_cast<DWORD>(_countof(buff));
	if (!request.GetUrl(buff, &dwLen))
	{
		return HTTP_FAIL;	
	}
	buff[_countof(buff)-1]='\0';
	strRedirect+=buff;
	strRedirect+=szHandler;

	if (strRedirect.GetLength() >= ATL_URL_MAX_URL_LENGTH)
	{
		return HTTP_FAIL;
	}
	
	BOOL bOK=response.Redirect(strRedirect.GetString());

	return bOK ? HTTP_SUCCESS_NO_PROCESS : HTTP_FAIL;
}

#ifdef _ATL_THREADPOOL_MANAGEMENT
///////////////////////////////////////////////////////////////////////
// Thread pool management

[ uuid("44e9962a-5207-4d2a-a466-5f08a76e0e5d"), object ]
__interface IThreadPoolMgr
{
	[id(0)] STDMETHOD(SetSize)([in] int nNumThreads);
	[id(1)] STDMETHOD(GetSize)([out,retval] int *pnNumThreads);

};


class CThreadPoolMgrObject
{
public:
	CThreadPoolMgrObject() throw()
	{
	}

	HRESULT SetSize(int nNumThreads) throw()
	{
		if (!m_spThreadPoolConfig)
			return E_UNEXPECTED;

		CRevertThreadToken revert;
		if (!revert.Initialize())
			return E_FAIL;

		HRESULT hr = m_spThreadPoolConfig->SetSize(nNumThreads);

		DWORD dwErr = revert.Restore();
		if (dwErr)
			return AtlHresultFromWin32(dwErr);

		return hr;
	}


	HRESULT GetSize(int *pnNumThreads) throw()
	{	
		if (!m_spThreadPoolConfig)
			return E_UNEXPECTED;

		return m_spThreadPoolConfig->GetSize(pnNumThreads);

	}

	HTTP_CODE Initialize(IServiceProvider *pProvider) throw()
	{
		ATLASSERT(pProvider); // should never be NULL
		if (!pProvider)
			return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

		if (m_spThreadPoolConfig)
			return HTTP_SUCCESS; // already initialized

		pProvider->QueryService(__uuidof(IThreadPoolConfig), &m_spThreadPoolConfig);
		return m_spThreadPoolConfig ? HTTP_SUCCESS : HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);
	}

private:
	CComPtr<IThreadPoolConfig> m_spThreadPoolConfig;
};

#ifndef _ATL_THREADPOOL_NOWEBSERVICE
#pragma warning(push)
#pragma warning(disable:4199)
[
	soap_handler(
					name=      ID_THREADMGR_WEBSERVICE_NAME, 
					namespace= ID_THREADMGR_WEBSERVICE_URL,
					protocol=  "soap"
				),
	request_handler(
					name= ID_THREADMGR_WEBSERVICE_NAME,
					sdl=  ID_THREADMGR_WEBSERVICE_WSDL
					)
]
class CThreadPoolManager :
	public IThreadPoolMgr
{
#pragma warning(pop)
public:
	[soap_method]
	STDMETHOD(SetSize)(int nNumThreads)
	{
		return m_PoolMgr.SetSize(nNumThreads);
	}

	[soap_method]
	STDMETHOD(GetSize)(int *pnNumThreads)
	{	
		return m_PoolMgr.GetSize(pnNumThreads);
	}

	// override HandleRequest to Initialize our m_spServiceProvider
	// and to handle authorizing the client.
	HTTP_CODE HandleRequest(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider)
	{
		HTTP_CODE hcErr = m_PoolMgr.Initialize(pProvider);
		if (hcErr != HTTP_SUCCESS)
			return hcErr;

		// Make sure caller is authorized on this system
__if_exists(_Authority)
{
		hcErr = HTTP_FAIL;
		ATLTRY(hcErr = _Authority.IsAuthorized(pRequestInfo, ATL_DEFAULT_AUTHGRP))
}
		if (hcErr == HTTP_SUCCESS)
		{
			hcErr = __super::HandleRequest(pRequestInfo, pProvider);
		}
		return hcErr;
	}
private:
	CThreadPoolMgrObject m_PoolMgr;
};
#endif //_ATL_THREADPOOL_NOWEBSERVICE

#ifndef _ATL_THREADPOOL_NOUI
#define INVALID_COMMAND_ID -1
#define MAX_COMMAND_ID 64

[request_handler(name=ID_THREADMGR_SRFHANDLER_NAME)]
class CThreadMgrStencil
{
public:
	CThreadMgrStencil() :
		m_nColor(ATL_COLOR_TR1)
	{

	}

	[tag_name("GetSize")]
	HTTP_CODE GetSize()
	{
		int nSize = 0;
		HRESULT hr = m_PoolMgr.GetSize(&nSize);
		if (SUCCEEDED(hr))
		{
			m_HttpResponse << nSize;
		}
		else
			m_HttpResponse << "size not found";

		return HTTP_SUCCESS;
	}

	[tag_name("GetTRColor")]
	HTTP_CODE GetTRColor()
	{
		m_nColor = (m_nColor == ATL_COLOR_TR1) ? ATL_COLOR_TR2 : ATL_COLOR_TR1;
		TCHAR cr[8];
		if (RGBToHtml(m_nColor, cr, sizeof(cr)))
			m_HttpResponse << cr;

		return HTTP_SUCCESS;
	}

	[tag_name("GetBodyColor")]
	HTTP_CODE GetBodyColor()
	{
		TCHAR cr[8];
		if (RGBToHtml(ATL_COLOR_BODYBG, cr, sizeof(cr)))
			m_HttpResponse << cr;
		return HTTP_SUCCESS;
	}


	HTTP_CODE ValidateAndExchange() throw()
	{
		_ATLTRY
		{
			// Initialize the thread pool manager instance. Internally
			// the initialize function will only intialize it's data structures
			// once.
			HTTP_CODE hcErr = m_PoolMgr.Initialize(m_spServiceProvider);
			if (hcErr != HTTP_SUCCESS)
				return hcErr;

__if_exists(_Authority)
{
				// Make sure caller is authorized on this system
				hcErr = HTTP_FAIL;
				ATLTRY(hcErr = _Authority.IsAuthorized(m_pRequestInfo, ATL_DEFAULT_AUTHGRP))
				if (hcErr != HTTP_SUCCESS)
					return hcErr;
}


			m_HttpResponse.SetContentType("text/html");

			CString strHandler, strOptParam;
			int nCmdToExec = INVALID_COMMAND_ID;

			if (m_HttpRequest.GetMethod() == CHttpRequest::HTTP_METHOD_POST)
			{
				// check to see if we have a "Method" form variable and can execute a command
				DWORD dwErr = m_HttpRequest.FormVars.Exchange("Method", &strHandler);
				if (dwErr == VALIDATION_S_OK)
				{
					if (strHandler == _T("ExecuteCommand"))
					{
						// get the value of the command parameter so we can execute it
						dwErr = m_HttpRequest.FormVars.Validate("command", &nCmdToExec, 0, MAX_COMMAND_ID);
						if (dwErr == VALIDATION_S_OK)
						{
							// get the optional parameter if it's there.
							m_HttpRequest.FormVars.Validate("DynValue", &strOptParam, 0, MAX_COMMAND_ID);

							hcErr = ExecCommand(nCmdToExec, strOptParam);
							return hcErr;
						}
					}
				}
			}

			// If we had a proper command to execute, we would have done it by now.
			// Just handle like it's a normal request to view the thread count.
			hcErr = LoadStencilResource(m_hInstHandler, IDR_THREADMGR_SRF);
			return hcErr;

		}
		_ATLCATCHALL()
		{
			return HTTP_FAIL;
		}
	}

	HTTP_CODE ExecCommand(int nCmdToExec, CString& strOptParam)
	{
		switch (nCmdToExec)
		{
		case 0:
			TCHAR *pStop = NULL;
			int nValue = _tcstoul(strOptParam, &pStop, 10);
			m_PoolMgr.SetSize(nValue);
		break;
		};

		return _AtlRedirectToPage(
							m_spServerContext,
							m_HttpRequest,
							m_HttpResponse,
							"?Handler=" ID_THREADMGR_SRFHANDLER_NAME
							);
	}
private:
	CThreadPoolMgrObject m_PoolMgr;
	long m_nColor;
	CString m_strUrl;

};


#endif // _ATL_THREADPOOL_NOUI
#endif // _ATL_THREADPOOL_MANAGEMENT

#ifdef _ATL_STENCILCACHE_MANAGEMENT
//////////////////////////////////////////////////////////////////////
// Stencil cache management
class CStencilCacheMgrObject
{
public:
	CStencilCacheMgrObject()
	{

	}

	HRESULT GetCurrentEntryCount(__int64 *pdwSize)
	{
		ATLASSUME(m_spMemCacheStats);
		if (!pdwSize)
			return E_INVALIDARG;

		DWORD dwValue;
		HRESULT hr = m_spMemCacheStats->GetCurrentEntryCount(&dwValue);		
		if (hr == S_OK)
		{
			*pdwSize = dwValue;
		}
		return hr;
	}

	HRESULT ClearStats()
	{
		ATLENSURE(m_spMemCacheStats);
		return m_spMemCacheStats->ClearStats();		
	}

	HRESULT GetHitCount(__int64 *pdwSize)
	{
		ATLENSURE(m_spMemCacheStats);
		if (!pdwSize)
			return E_INVALIDARG;

		DWORD dwValue;
		HRESULT hr = m_spMemCacheStats->GetHitCount(&dwValue);		
		if (hr == S_OK)
		{
			*pdwSize = dwValue;
		}
		return hr;
	}

	HRESULT GetMissCount(__int64 *pdwSize)
	{
		ATLENSURE(m_spMemCacheStats);
		if (!pdwSize)
			return E_INVALIDARG;

		DWORD dwValue;

		HRESULT hr = m_spMemCacheStats->GetMissCount(&dwValue);		
		if (hr == S_OK)
		{
			*pdwSize = dwValue;
		}
		return hr;	
	}

	HRESULT GetCurrentAllocSize(__int64 *pdwSize)
	{
		ATLENSURE(m_spMemCacheStats);
		if (!pdwSize)
			return E_INVALIDARG;

		DWORD dwValue;

		HRESULT hr = m_spMemCacheStats->GetCurrentAllocSize(&dwValue);
		if (hr == S_OK)
		{
			*pdwSize = dwValue;
		}
		return hr;
	}

	HRESULT GetMaxAllocSize(__int64 *pdwSize)
	{
		ATLENSURE(m_spMemCacheStats);
		if (!pdwSize)
			return E_INVALIDARG;

		DWORD dwValue;

		HRESULT hr = m_spMemCacheStats->GetMaxAllocSize(&dwValue);
		if (hr == S_OK)
		{
			*pdwSize = dwValue;
		}
		return hr;
	}


	HRESULT GetMaxEntryCount(__int64 *pdwSize)
	{
		ATLENSURE(m_spMemCacheStats);
		if (!pdwSize)
			return E_INVALIDARG;

		DWORD dwValue;

		HRESULT hr = m_spMemCacheStats->GetMaxEntryCount(&dwValue);
		if (hr == S_OK)
		{
			*pdwSize = dwValue;
		}
		return hr;
	}


	HRESULT RemoveStencil(__int64 hStencil)
	{
		ATLENSURE(m_spStencilCacheControl);
		return m_spStencilCacheControl->RemoveStencil((const HCACHEITEM)hStencil);		
	}

	HRESULT RemoveStencilByName(BSTR szStencil) throw()
	{
		ATLENSURE(m_spStencilCacheControl);
		return m_spStencilCacheControl->RemoveStencilByName(CW2A(szStencil));
	}


	HRESULT RemoveAllStencils()
	{
		ATLENSURE(m_spStencilCacheControl);
		return m_spStencilCacheControl->RemoveAllStencils();		
	}

	// we show lifespan in milli-seconds in the UI so we have to
	// do the conversion to 100ns intervals here.
	HRESULT SetDefaultLifespan(unsigned __int64 dwdwLifespan)
	{
		ATLENSURE(m_spStencilCacheControl);
		// convert to 100ns intervals
		return m_spStencilCacheControl->SetDefaultLifespan(dwdwLifespan * CFileTime::Millisecond);
	}

	HRESULT GetDefaultLifespan(unsigned __int64 *pdwdwLifespan)
	{
		ATLENSURE(m_spStencilCacheControl);
		ATLENSURE(pdwdwLifespan!=NULL);
		*pdwdwLifespan = 0;
		unsigned __int64 dwls = 0;
		HRESULT hr = m_spStencilCacheControl->GetDefaultLifespan(&dwls);

		// convert to milli seconds
		if (SUCCEEDED(hr))
		{
			dwls /= CFileTime::Millisecond;
			*pdwdwLifespan = dwls;
		}

		return hr;
	}

	HTTP_CODE Initialize(IServiceProvider *pProvider) throw()
	{

		ATLASSERT(pProvider); // should never be NULL
		if (!pProvider)
			return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);


		if (m_spMemCacheStats && m_spStencilCacheControl)
			return HTTP_SUCCESS; // already initialized

		CComPtr<IStencilCache> spStencilCache;
		pProvider->QueryService(__uuidof(IStencilCache), &spStencilCache);
		if (spStencilCache)
		{
			if (!m_spMemCacheStats)
			{
				spStencilCache->QueryInterface(__uuidof(IMemoryCacheStats), 
					(void**)&m_spMemCacheStats);
			}
			if (!m_spStencilCacheControl)
			{
				spStencilCache->QueryInterface(__uuidof(IStencilCacheControl),
					(void**)&m_spStencilCacheControl);
			}
		}

		return (m_spMemCacheStats && m_spStencilCacheControl)
			? HTTP_SUCCESS : HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);
	}

private:
	CComPtr<IMemoryCacheStats> m_spMemCacheStats;
	CComPtr<IStencilCacheControl> m_spStencilCacheControl;
};


#ifndef _ATL_STENCILCACHE_NOWEBSERVICE

[ uuid("3813895C-4C4C-41df-95F4-12220140B164"), object ]
__interface IStencilCacheMgr
{
	// data access
	[id(0)] STDMETHOD(GetCurrentEntryCount)([out,retval] __int64 *pdwSize);
	[id(1)] STDMETHOD(GetHitCount)([out,retval] __int64 *pdwSize);
	[id(2)] STDMETHOD(GetMissCount)([out,retval] __int64 *pdwSize);
	[id(3)] STDMETHOD(GetCurrentAllocSize)([out,retval] __int64 *pdwSize);
	[id(4)] STDMETHOD(GetMaxAllocSize)([out,retval] __int64 *pdwSize);
	[id(5)] STDMETHOD(GetMaxEntryCount)([out,retval] __int64 *pdwSize);
	[id(6)] STDMETHOD(GetDefaultLifespan)([out,retval] unsigned __int64 *pdwdwLifespan);

	// commands
	[id(7)] STDMETHOD(ClearStats)();
	[id(8)] STDMETHOD(RemoveStencil)([in] __int64 hStencil);
	[id(9)] STDMETHOD(RemoveStencilByName)([in] BSTR szStencil);
	[id(10)] STDMETHOD(RemoveAllStencils)();
	[id(11)] STDMETHOD(SetDefaultLifespan)([in] unsigned __int64 dwdwLifespan);
};

#pragma warning(push)
#pragma warning(disable:4199)
[
	soap_handler(	name=		ID_STENCILCACHEMGR_WEBSERVICE_NAME, 
					namespace=	ID_STENCILCACHEMGR_WEBSERVICE_URL,
					protocol=	"soap"
				),
	request_handler(
					name=		ID_STENCILCACHEMGR_WEBSERVICE_NAME,
					sdl=		ID_STENCILCACHEMGR_WEBSERVICE_WSDL )
]
class CStencilCacheManager :
	public IStencilCacheMgr
{
#pragma warning(pop)
public:
	[ soap_method ]
	STDMETHOD(GetCurrentEntryCount)(__int64 *pdwSize)
	{
		return m_MgrObj.GetCurrentEntryCount(pdwSize);		
	}

	[ soap_method ]
	STDMETHOD(ClearStats)()
	{
		return m_MgrObj.ClearStats();		
	}

	[ soap_method ]
	STDMETHOD(GetHitCount)(__int64 *pdwSize)
	{
		return m_MgrObj.GetHitCount(pdwSize);		
	}

	[ soap_method ]
	STDMETHOD(GetMissCount)(__int64 *pdwSize)
	{
		return m_MgrObj.GetMissCount(pdwSize);		
	}

	[ soap_method ]
	STDMETHOD(GetCurrentAllocSize)(__int64 *pdwSize)
	{
		return m_MgrObj.GetCurrentAllocSize(pdwSize);		
	}

	[ soap_method ]
	STDMETHOD(GetMaxAllocSize)(__int64 *pdwSize)
	{
		return m_MgrObj.GetMaxAllocSize(pdwSize);		
	}

	[ soap_method ]
	STDMETHOD(GetMaxEntryCount)(__int64 *pdwSize)
	{
		return m_MgrObj.GetMaxEntryCount(pdwSize);		
	}

	[ soap_method ]
	STDMETHOD(RemoveStencil)(__int64 hStencil)
	{
		return m_MgrObj.RemoveStencil(hStencil);		
	}

	[ soap_method ]
	STDMETHOD(RemoveStencilByName)(BSTR bstrStencil)
	{
		return m_MgrObj.RemoveStencilByName(bstrStencil);
	}

	[ soap_method ]
	STDMETHOD(RemoveAllStencils)()
	{
		return m_MgrObj.RemoveAllStencils();		
	}

	// we show lifespan in milli-seconds in the UI.
	// m_MgrObj handles the conversion to 100ns intervals.
	[ soap_method ]
	STDMETHOD(SetDefaultLifespan)(unsigned __int64 dwdwLifespan)
	{
		return m_MgrObj.SetDefaultLifespan(dwdwLifespan);
	}

	[ soap_method ]
	STDMETHOD(GetDefaultLifespan)(unsigned __int64 *pdwdwLifespan)
	{
		return m_MgrObj.GetDefaultLifespan(pdwdwLifespan);
	}

	HTTP_CODE HandleRequest(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider)
	{
		HTTP_CODE hcErr = m_MgrObj.Initialize(pProvider);
		if (hcErr != HTTP_SUCCESS)
			return hcErr;

__if_exists(_Authority)
{
		// Make sure caller is authorized on this system
		hcErr = HTTP_FAIL;
		ATLTRY(hcErr = _Authority.IsAuthorized(pRequestInfo, ATL_DEFAULT_AUTHGRP))
}
		if (hcErr == HTTP_SUCCESS)
		{
			hcErr = __super::HandleRequest(pRequestInfo, pProvider);
		}
		return hcErr;
	}
private:
	CStencilCacheMgrObject m_MgrObj;
};
#endif //_ATL_STENCILCACHE_NOWEBSERVICE
#ifndef _ATL_STENCILCACHE_NOUI
typedef HRESULT (CStencilCacheMgrObject::*PFNGETDATA)(__int64 *pdwSize);

struct CCache_data
{
	PFNGETDATA m_pfn;
	char m_sz[128];
};

#define INVALID_DATA_PTR ((DWORD_PTR) -1)
#define INVALID_COMMAND_ID -1
#define MAX_COMMAND_ID 64
#define ATL_STENCILCACHECMD_CLEARALLSTATS		0
#define ATL_STENCILCACHECMD_REMOVESTENCIL		1
#define ATL_STENCILCACHECMD_REMOVEALLSTENCILS	2
#define ATL_STENCILCACHECMD_SETDEFLIFESPAN		3

[request_handler(name=ID_STENCILCACHEMGR_SRFHANDLER_NAME)]
class CStencilMgr
{
public:
	CStencilMgr()
	{
		m_pData = (CCache_data*)INVALID_DATA_PTR;
		m_nColor = ATL_COLOR_TR1;
	}

	HTTP_CODE ValidateAndExchange() throw()
	{
		_ATLTRY
		{
			HTTP_CODE hcErr = m_MgrObj.Initialize(m_spServiceProvider);
			if (hcErr != HTTP_SUCCESS)
					return hcErr;

__if_exists(_Authority)
{
				// Make sure caller is authorized on this system
				hcErr = HTTP_FAIL;
				ATLTRY(hcErr = _Authority.IsAuthorized(m_pRequestInfo, ATL_DEFAULT_AUTHGRP))
				if (hcErr != HTTP_SUCCESS)
					return hcErr;
}
			m_HttpResponse.SetContentType("text/html");

			// check to see if we have a "Handler" form variable
			CString strHandler, strOptParam;
			int nCmdToExec;

			if (m_HttpRequest.GetMethod() == CHttpRequest::HTTP_METHOD_POST)
			{
				DWORD dwErr = m_HttpRequest.FormVars.Exchange("Method", &strHandler);
				if (dwErr == VALIDATION_S_OK)
				{
					if (strHandler == _T("ExecuteCommand"))
					{
						// get the value of the command parameter so we can execute it
						dwErr = m_HttpRequest.FormVars.Validate("command", &nCmdToExec, 0, MAX_COMMAND_ID);
						if (dwErr == VALIDATION_S_OK)
						{
							// get the optional parameter if it's there.
							m_HttpRequest.FormVars.Validate("DynValue", &strOptParam, 0, MAX_COMMAND_ID);
							hcErr = ExecCommand(nCmdToExec, strOptParam);
							return hcErr;
						}
					}
				}
			}
			hcErr = LoadStencilResource(m_hInstHandler, IDR_STENCILMGR_SRF);
			return hcErr;
		}
		_ATLCATCHALL()
		{
			return HTTP_FAIL;
		}
	}

	HTTP_CODE ExecCommand(int nCmdToExec, CString& strOptParam)
	{
		switch (nCmdToExec)
		{
		case ATL_STENCILCACHECMD_CLEARALLSTATS:
			m_MgrObj.ClearStats();
		break;

		case ATL_STENCILCACHECMD_REMOVESTENCIL:
			m_MgrObj.RemoveStencilByName(strOptParam.AllocSysString());
		break;

		case ATL_STENCILCACHECMD_REMOVEALLSTENCILS:
			m_MgrObj.RemoveAllStencils();
		break;

		case ATL_STENCILCACHECMD_SETDEFLIFESPAN:
			TCHAR *pStop = NULL;
			m_MgrObj.SetDefaultLifespan(_tcstoul(strOptParam, &pStop, 10));
		break;
		};

		return _AtlRedirectToPage(
									m_spServerContext,
									m_HttpRequest,
									m_HttpResponse,
									"?Handler=" ID_STENCILCACHEMGR_SRFHANDLER_NAME
								 );

	}

	[tag_name("GetNextStencilCacheStats")]
	HTTP_CODE GetNextStencilCacheStats()
	{
		if (m_pData == (CCache_data*)INVALID_DATA_PTR)
		{
			m_pData = GetCacheData();
			return HTTP_SUCCESS;
		}
		m_pData++;

		if (m_pData->m_pfn != NULL)
			return HTTP_SUCCESS;

		m_pData = (CCache_data*)INVALID_DATA_PTR;
		return HTTP_S_FALSE;

	}

	[tag_name("GetCacheValue")]
	HTTP_CODE GetCacheValue()
	{
		ATLENSURE(m_pData);
		ATLENSURE(m_pData != (CCache_data*)INVALID_DATA_PTR);
		m_HttpResponse << m_pData->m_sz;
		return HTTP_SUCCESS;
	}

	[tag_name("GetCacheQuantity")]
	HTTP_CODE GetCacheQuantity()
	{
		ATLENSURE(m_pData);
		ATLENSURE(m_pData != (CCache_data*)INVALID_DATA_PTR);
		__int64 dwValue = 0;
		PFNGETDATA pfn = m_pData->m_pfn;
		ATLENSURE(pfn);
		CStencilCacheMgrObject *pMgr = &m_MgrObj;
		(pMgr->*pfn)(&dwValue);

		m_HttpResponse << dwValue;
		return HTTP_SUCCESS;
	}

	[tag_name("GetTRColor")]
	HTTP_CODE GetTRColor()
	{
		m_nColor = (m_nColor == ATL_COLOR_TR1) ? ATL_COLOR_TR2 : ATL_COLOR_TR1;
		TCHAR cr[8];
		if (RGBToHtml(m_nColor, cr, sizeof(cr)))
			m_HttpResponse << cr;

		return HTTP_SUCCESS;
	}

	[tag_name("GetBodyColor")]
	HTTP_CODE GetBodyColor()
	{
		TCHAR cr[8];
		if (RGBToHtml(ATL_COLOR_BODYBG, cr, sizeof(cr)))
			m_HttpResponse << cr;
		return HTTP_SUCCESS;
	}
private:
	static CCache_data* GetCacheData()
	{
		static CCache_data cache_data[] = 
		{
			{(PFNGETDATA)&CStencilCacheMgrObject::GetCurrentEntryCount, "Current Cache Entry Count(stencils)"},
			{(PFNGETDATA)&CStencilCacheMgrObject::GetHitCount, "Cache Hit Count(stencils)"},
			{(PFNGETDATA)&CStencilCacheMgrObject::GetMissCount, "Cache Miss Count(stencils)"},
			{(PFNGETDATA)&CStencilCacheMgrObject::GetCurrentAllocSize, "Cache memory allocation(bytes)"},
			{(PFNGETDATA)&CStencilCacheMgrObject::GetMaxAllocSize, "Cache maximum allocation size(bytes)"},
			{(PFNGETDATA)&CStencilCacheMgrObject::GetMaxEntryCount, "Cache maximum entry count(stencils)"},
			{(PFNGETDATA)&CStencilCacheMgrObject::GetDefaultLifespan, "Default stencil lifespan(ms)"},
			{NULL, NULL}
		};
		return cache_data;
	}

	CStencilCacheMgrObject m_MgrObj;
	CCache_data *m_pData;
	long m_nColor;
};
//__declspec(selectany) CComObjectGlobal<CStencilCacheManager> CStencilMgr::m_cachemgr;
#endif // _ATL_STENCILCACHE_NOUI
#endif // _ATL_STENCILCACHE_MANAGEMENT

//////////////////////////////////////////////////////////////////////
// DLL cache management
#ifdef _ATL_DLLCACHE_MANAGEMENT


#ifndef _ATL_DLLCACHE_NOWEBSERVICE
[export]
#endif
struct _DLL_CACHE_ENTRY
{
	DWORD hInstDll;
	DWORD dwRefs;
	BSTR szDllName;
};


class CDllMgrObject
{
public:
	HRESULT GetEntries(DWORD dwCount, _DLL_CACHE_ENTRY *pEntries, DWORD *pdwCopied)
	{
		ATLASSUME(m_spDllCache);
		HRESULT hr = E_FAIL;
		DLL_CACHE_ENTRY *pe = NULL;

		if (!m_spDllCache)
			return E_UNEXPECTED;

		if (dwCount != 0 && pEntries == NULL)
			return E_UNEXPECTED; // asking for entries but no place to put them

		if (!pdwCopied)
			return E_POINTER;
		*pdwCopied = 0;

		if (dwCount)
		{
			pe = new DLL_CACHE_ENTRY[dwCount];
			if (!pe)
				return E_OUTOFMEMORY;
		}

		hr = m_spDllCache->GetEntries(dwCount, pe, pdwCopied);
		if (hr == S_OK && dwCount != 0 && pEntries != NULL)
		{
			// SysAllocString our path strings
			for (DWORD i = 0; i<*pdwCopied; i++)
			{
				pEntries[i].hInstDll = (DWORD)(DWORD_PTR)pe[i].hInstDll;
				pEntries[i].dwRefs = pe[i].dwRefs;
				pEntries[i].szDllName = ::SysAllocString(CA2W(pe[i].szDllName));
			}
		}

		delete [] pe;
		return hr;
	}


	HRESULT GetEntryCount(DWORD *pdwCount)
	{
		ATLASSUME(m_spDllCache);
		if (!m_spDllCache)
			return E_UNEXPECTED;

		return m_spDllCache->GetEntries(0, NULL, pdwCount);
	}

	HTTP_CODE Initialize(IServiceProvider *pProvider)
	{
		ATLASSERT(pProvider); // should never be NULL
		if (!pProvider)
			return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

		if (m_spDllCache)
			return HTTP_SUCCESS; // already initialized

		pProvider->QueryService(__uuidof(IDllCache), &m_spDllCache);
		return m_spDllCache ? HTTP_SUCCESS : HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);
	}

private:
	CComPtr<IDllCache> m_spDllCache;

}; // CDllMgrObject


#ifndef _ATL_DLLCACHE_NOWEBSERVICE
// _DLL_CACHE_ENTRY is our own version of DLL_CACHE_ENTRY(atlcache.h) that
// uses a BSTR instead of a fixed length string for the szDllName for compatiblility
// with our SOAP implementation.
[ uuid("A0C00AF8-CEA5-46b9-97ED-FDEE55B583EF"), object ]
__interface IDllCacheMgr
{
	[id(0)] STDMETHOD(GetEntries)([in] DWORD dwCount, [out] _DLL_CACHE_ENTRY *pEntries, [out, retval] DWORD *pdwCopied);
	[id(1)] STDMETHOD(GetEntryCount)([out, retval] DWORD *pdwCount);

};


#pragma warning(push)
#pragma warning(disable:4199)
[
	soap_handler(
					name=		ID_DLLCACHEMGR_WEBSERVICE_NAME, 
					namespace=	ID_DLLCACHEMGR_WEBSERVICE_URL,
					protocol=	"soap"
				),
	request_handler(
					name=		ID_DLLCACHEMGR_WEBSERVICE_NAME,
					sdl=		ID_DLLCACHEMGR_WEBSERVICE_WSDL
					)
]
class CDllCacheManager :
	public IDllCacheMgr
{
#pragma warning(pop)
public:
	[soap_method]
	HRESULT GetEntries(DWORD dwCount, _DLL_CACHE_ENTRY *pEntries, DWORD *pdwCopied)
	{
		return m_MgrObj.GetEntries(dwCount, pEntries, pdwCopied);
	}

	[soap_method]
	STDMETHOD(GetEntryCount)(DWORD *pdwCount)
	{
		return m_MgrObj.GetEntries(0, NULL, pdwCount);
	}

	HTTP_CODE HandleRequest(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider)
	{
		HTTP_CODE hcErr = m_MgrObj.Initialize(pProvider);
		if (hcErr != HTTP_SUCCESS)
			return hcErr;

__if_exists(_Authority)
{
		// Make sure caller is authorized on this system
		hcErr = HTTP_FAIL;
		ATLTRY(hcErr = _Authority.IsAuthorized(pRequestInfo, ATL_DEFAULT_AUTHGRP))
}
		if (hcErr == HTTP_SUCCESS)
		{
			hcErr = __super::HandleRequest(pRequestInfo, pProvider);
		}
		return hcErr;
	}

protected:
	CDllMgrObject m_MgrObj;
};
#endif _ATL_DLLCACHE_NOWEBSERVICE

#ifndef _ATL_DLLCACHE_NOUI
#define INVALID_INDEX -1

[
	request_handler(name=ID_DLLCACHEMGR_SRFHANDLER_NAME)
]
class CDllCacheMgr
{
public:
	CDllCacheMgr() : m_nColor(ATL_COLOR_TR1),
		m_nEnumCount(INVALID_INDEX),
		m_nEnumIndex(INVALID_INDEX),
		m_pEntries(NULL)
	{

	}

	[tag_name("GetTRColor")]
	HTTP_CODE GetTRColor()
	{
		m_nColor = (m_nColor == ATL_COLOR_TR1) ? ATL_COLOR_TR2 : ATL_COLOR_TR1;
		TCHAR cr[8];
		if (RGBToHtml(m_nColor, cr, sizeof(cr)))
			m_HttpResponse << cr;

		return HTTP_SUCCESS;
	}

	[tag_name("GetBodyColor")]
	HTTP_CODE GetBodyColor()
	{
		TCHAR cr[8];
		if (RGBToHtml(ATL_COLOR_BODYBG, cr, sizeof(cr)))
			m_HttpResponse << cr;
		return HTTP_SUCCESS;
	}


	[tag_name("GetNumEntries")]
	HTTP_CODE GetNumEntries()
	{
		DWORD dwEntries = 0;
		m_MgrObj.GetEntryCount(&dwEntries);
		m_HttpResponse << dwEntries;
		return HTTP_SUCCESS;
	}


	[tag_name("EnumEntries")]
	HTTP_CODE EnumEntries()
	{
		// we lock the cache while we enum entries so no entries
		// will be removed during the enumeration request.
		if (m_nEnumIndex == INVALID_INDEX)
		{
			// set up for the iteration
			m_MgrObj.GetEntryCount((DWORD*)&m_nEnumCount);
			if (!m_nEnumCount)
				return HTTP_S_FALSE; // nothing to enum

			m_pEntries = new _DLL_CACHE_ENTRY[m_nEnumCount];
			if (!m_pEntries)
				return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);

			DWORD dwFetched = INVALID_INDEX;

			if (S_OK != m_MgrObj.GetEntries(m_nEnumCount, m_pEntries, &dwFetched))
				return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

			m_nEnumIndex = 0;
			return HTTP_SUCCESS;
		}

		m_nEnumIndex++;
		if (m_nEnumIndex < m_nEnumCount)
			return HTTP_SUCCESS; // continue iterating

		else
		{
			// done, clean up
			for (int i = 0; i< m_nEnumCount; i++)
			{
				::SysFreeString(m_pEntries[i].szDllName);
			}
			delete [] m_pEntries;
			m_pEntries = NULL;
			m_nEnumCount = INVALID_INDEX;
			m_nEnumIndex = INVALID_INDEX;
			return HTTP_S_FALSE; // terminate iterations.
		}
	}

	[tag_name("GetDllName")]
	HTTP_CODE GetDllName()
	{
		m_HttpResponse << m_pEntries[m_nEnumIndex].szDllName;
		return HTTP_SUCCESS;
	}

	[tag_name("GetDllReferences")]
	HTTP_CODE GetDllReferences()
	{
		m_HttpResponse << m_pEntries[m_nEnumIndex].dwRefs;
		return HTTP_SUCCESS;
	}

	HTTP_CODE ValidateAndExchange()
	{

		HTTP_CODE hcErr = m_MgrObj.Initialize(m_spServiceProvider);
		if (hcErr != HTTP_SUCCESS)
			return hcErr;

__if_exists(_Authority)
{
		// Make sure caller is authorized on this system
		hcErr = HTTP_FAIL;
		ATLTRY(hcErr = _Authority.IsAuthorized(m_pRequestInfo, ATL_DEFAULT_AUTHGRP))
		if (hcErr != HTTP_SUCCESS)
			return hcErr;
}
		hcErr = LoadStencilResource(m_hInstHandler, IDR_DLLMGR_SRF);
		m_HttpResponse.SetContentType("text/html");
		return hcErr;

	}

	CDllMgrObject m_MgrObj;
	long m_nColor;
	int m_nEnumCount;
	int m_nEnumIndex;
	_DLL_CACHE_ENTRY *m_pEntries;

};

#endif // _ATL_DLLCACHE_NOUI
#endif // _ATL_DLLCACHE_MANAGEMENT

}; // ATL

#pragma pack(pop)
#pragma warning(pop)
#endif // __ATLEXTMGMT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlhttp.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLHTTP_H__
#define __ATLHTTP_H__

#pragma once
#ifndef __CPPUNWIND
#pragma warning(push)
#pragma warning(disable: 4702)
#endif
#ifndef _WINSOCKAPI_
	#include <winsock2.h>
#endif
#include <atlutil.h>
#include <atlcoll.h>
#include <atlfile.h>
#define SECURITY_WIN32
#include <security.h>
#include <atlenc.h>
#ifndef _ATL_NO_DEFAULT_LIBS
#ifndef _WIN32_WCE
#pragma comment(lib, "ws2_32.lib")
#else // _WIN32_WCE
#pragma comment(lib, "ws2.lib")
#endif // _WIN32_WCE
#pragma comment(lib, "SECUR32.LIB")
#endif  // !_ATL_NO_DEFAULT_LIBS

#include <atlspriv.h>

#pragma warning(push)
#pragma warning(disable: 4625) // copy constructor could not be generated because a base class copy constructor is inaccessible
#pragma warning(disable: 4626) // assignment operator could not be generated because a base class assignment operator is inaccessible

#pragma pack(push,_ATL_PACKING)
namespace ATL {

template <class TSocketClass>
class CAtlHttpClientT;
class CAtlBaseAuthObject;

enum status_headerparse{
				ATL_HEADER_PARSE_COMPLETE=0,
				ATL_HEADER_PARSE_HEADERNOTCOMPLETE,
				ATL_HEADER_PARSE_HEADERERROR
};

enum readstate{rs_init=0, rs_readheader, rs_scanheader, rs_readbody, rs_complete};

#define ATL_HEADER_END "\r\n\r\n"
#define ATL_HEADER_END_LEN 4
#define ATL_FIELDNAME_DELIMITER _T(':')
#define ATL_MAX_FIELDNAME_LEN 1024
#define ATL_MAX_VALUE_LEN 1024
#define ATL_AUTH_HDR_SIZE 1024
#define ATL_READ_BUFF_SIZE 2048
#define ATL_INVALID_STATUS -1
#define ATL_HTTP_HEADER _T(" HTTP/1.1\r\n")
#define ATL_HTTP_HEADER_PROXY _T(" HTTP/1.1\r\n")
#ifndef ATL_HTTP_USERAGENT
	#define ATL_HTTP_USERAGENT _T("User-Agent: Microsoft-ATL-Native/8.00\r\n")
#endif

#define ATL_IS_INVALIDCREDHANDLE(x) ((x.dwLower==0xFFFFFFFF) && (x.dwUpper==0xFFFFFFFF))					
#define ATL_HTTP_AUTHTYPE_NTLM _T("NTLM")
#define ATL_HTTP_AUTHTYPE_BASIC _T("BASIC")
#define ATL_HTTP_METHOD_GET _T("GET")
#define ATL_HTTP_METHOD_POST _T("POST")

#ifndef MAX_REALM_LEN
	#define MAX_REALM_LEN 1024
#endif

#ifndef _ATL_MAX_AUTH_BUFF
	#define _ATL_MAX_AUTH_BUFF 512
#endif

__interface IAuthInfo;
typedef bool (WINAPI *PFNATLCHUNKEDCB)(BYTE** ppData, DWORD *pdwSize, DWORD_PTR dwParam);
typedef bool (WINAPI *PFNATLSTATUSCALLBACK)(DWORD dwBytesSent, DWORD_PTR dwParam);

#define ATL_HTTP_FLAG_AUTO_REDIRECT				0x1
#define ATL_HTTP_FLAG_PROCESS_RESULT			0x2
#define ATL_HTTP_FLAG_SEND_CALLBACK				0x4
#define ATL_HTTP_FLAG_SEND_BLOCKS				0x8
#define ATL_HTTP_FLAG_INVALID_FLAGS				0xFFFFFFFF

#ifndef ATL_HTTP_DEFAULT_BLOCK_SIZE
	#define ATL_HTTP_DEFAULT_BLOCK_SIZE 4096
#endif

#define ATL_HTTP_CLIENT_EMPTY_READ_RETRIES 5

struct ATL_NAVIGATE_DATA
{
	LPCTSTR szExtraHeaders;
	LPCTSTR szMethod;
	LPCTSTR szDataType;
	DWORD dwDataLen;
	DWORD dwFlags;
	DWORD dwTimeout;
	DWORD dwSendBlockSize;
	DWORD dwReadBlockSize;
	DWORD_PTR m_lParamSend;
	DWORD_PTR m_lParamRead;
	DWORD_PTR m_lParamChunkCB;
	short nPort;
	BYTE *pData;
	PFNATLCHUNKEDCB pfnChunkCallback;
	PFNATLSTATUSCALLBACK pfnSendStatusCallback;
	PFNATLSTATUSCALLBACK pfnReadStatusCallback;
};

class CAtlNavigateData : public ATL_NAVIGATE_DATA
{
public:
	CAtlNavigateData() throw(); // public construction
	CAtlNavigateData(const CAtlNavigateData &rhs);
	CAtlNavigateData(const ATL_NAVIGATE_DATA &rhs);
	CAtlNavigateData& operator=(const CAtlNavigateData &rhs);
	CAtlNavigateData& operator=(const ATL_NAVIGATE_DATA &rhs);
	DWORD SetFlags(DWORD dwNewFlags) throw(); // set all flags
	DWORD GetFlags() throw(); // get value of flags
	DWORD AddFlags(DWORD dwFlagsToAdd) throw(); // add one or more flags to existing flags
	DWORD RemoveFlags(DWORD dwFlagsToRemove) throw(); // remove one or more flags from existing flags
	LPCTSTR SetExtraHeaders(LPCTSTR szNewHeaders) throw(); // set the extra request headers
	LPCTSTR GetExtraHeaders() throw(); // get the extra request headers
	LPCTSTR SetMethod(LPCTSTR szNewMethod) throw(); // set the HTTP request method
	LPCTSTR GetMethod() throw(); // get the HTTP request method
	short SetPort(short newPort) throw(); // set the TCP port for this request
	short GetPort() throw(); // get the TCP port for this request
	void SetPostData(BYTE *pData, DWORD dwDataLen, LPCTSTR szDataType) throw(); // Set data to be sent as the reqeust entity body
	DWORD SetSocketTimeout(DWORD dwNewTimeout) throw(); // Set the timeout for this socket
	DWORD GetSocketTimeout() throw(); // Get the timeout for this socket
	DWORD SetSendBlockSize(DWORD dwBlockSize) throw(); // Set the size of the blocks used to send data
	DWORD GetSendBlockSize() throw(); // get the size of the blocks used to send data
	DWORD SetReadBlockSize(DWORD dwBlockSize) throw(); // Set the size of the blocks used to send data
	DWORD GetReadBlockSize() throw(); // get the size of the blocks used to send data
	PFNATLCHUNKEDCB SetChunkCallback(PFNATLCHUNKEDCB pfn, DWORD_PTR dwParam) throw(); // set the callback function used for sending chunked data
	PFNATLCHUNKEDCB GetChunkCallback() throw(); // get the chunked callback function
	PFNATLSTATUSCALLBACK SetSendStatusCallback(PFNATLSTATUSCALLBACK pfn, DWORD_PTR dwData) throw(); // sets a function pointer to be called after bytes are sent over the socket
	PFNATLSTATUSCALLBACK GetSendStatusCallback() throw(); // returns current status callback function
	PFNATLSTATUSCALLBACK SetReadStatusCallback(PFNATLSTATUSCALLBACK pfn, DWORD_PTR dwData) throw();
	PFNATLSTATUSCALLBACK GetReadStatusCallback() throw();
};

template <class TSocketClass>
class CAtlHttpClientT : 
	private TSocketClass
{
public:
	CAtlHttpClientT() throw();
	virtual ~CAtlHttpClientT()
	{
	}

	// Use these functions to send an HTTP request and retrieve
	// the response.
	bool Navigate(
				const CUrl* pUrl,
				ATL_NAVIGATE_DATA *pNavData = NULL
				) throw(...);

	bool Navigate(
				LPCTSTR szServer,
				LPCTSTR szPath,
				ATL_NAVIGATE_DATA *pNavData = NULL
				) throw(...);

	bool Navigate(
				LPCTSTR szURL,
				ATL_NAVIGATE_DATA *pNavData = NULL
				) throw(...);


	// Performs navigation, sending data with Transfer-Coding: chunked
	bool NavigateChunked(
				const CUrl *pUrl,
				ATL_NAVIGATE_DATA *pData
				) throw();

	bool NavigateChunked(
				LPCTSTR szServer,
				LPCTSTR szPath,
				ATL_NAVIGATE_DATA *pNavData
				) throw();

	bool NavigateChunked(
				LPCTSTR szURL,
				ATL_NAVIGATE_DATA *pNavData
				) throw();

	// Use to set/retrieve information about the proxy server used
	// when making this request via a proxy server.
	bool SetProxy(LPCTSTR szProxy = NULL, short nProxyPort = 0) throw();
	void RemoveProxy() throw();
	LPCTSTR GetProxy() const throw();
	short GetProxyPort() const throw();

	// Use these functions to add/remove/find objects that will 
	// be used to authorize request when a 401 Not Authorized response
	// is received. This class maps these objects by scheme name in map.
	// Override NegotiateAuth to change the way authorization negotiation occurs.
	bool AddAuthObj(LPCTSTR szScheme, CAtlBaseAuthObject *pObject, IAuthInfo *pInfo=NULL) throw();
	const CAtlBaseAuthObject* FindAuthObject(LPCTSTR szScheme) throw();
	bool RemoveAuthObject(LPCTSTR szScheme) throw();
	virtual bool NegotiateAuth(bool bProxy) throw();


	// Retrieve the value of a response header
	bool GetHeaderValue(LPCTSTR szName, CString& strValue) const throw(); 
	bool GetHeaderValue(__in_z LPCTSTR szName, __out_ecount_part_z_opt(*pdwLen, *pdwLen) LPTSTR szBuffer, __inout DWORD *pdwLen) const throw();

	DWORD GetResponseLength() throw(); // Get the number of bytes in the response
	const BYTE* GetResponse() throw(); // Get the entire response
	DWORD GetBodyLength() const throw(); // Get the length of the body of the response (everything after the \r\n\r\n)
	const BYTE* GetBody() throw(); // Get the body of the response (length is determined by GetBodyLength())
	DWORD GetRawResponseHeaderLength() throw(); // Get the length of the raw request headers
	bool GetRawResponseHeader(LPBYTE szBuffer, DWORD *pdwLen) throw(); // Get the raw request headers
	LPCURL GetCurrentUrl() const throw(); // Get a pointer to the current URL for this request
	DWORD GetFlags() const throw(); // Retrieve flags used for processing this request
	int GetStatus() throw(); // Get the HTTP status code that resulted from making this request
	LPCTSTR GetMethod() throw(); // Get the HTTP method used for making this request
	BYTE* GetPostData() throw(); // Get a pointer to raw data being sent with this request
	DWORD GetPostDataLen() throw(); // Get the length of the raw data sent with this request
	LPCTSTR GetPostDataType() throw(); // Get the data type (sent as Content-Type header) for this request
	DWORD GetLastError() throw(); // Retrieves errors from the underlying socket
	const SOCKET& GetSocket() throw(); // Retrieves the underlying socket. Be careful!
	void Close() throw(); // Close the connection
	DWORD SetSocketTimeout(DWORD dwNewTimeout) throw(); // Sets a new socket timeout, returns the old timeout.
	DWORD GetSocketTimeout() throw(); // retrieves the current socket timeout
	void AuthProtocolFailed(LPCTSTR szProto) throw(); // notifies us of failure to connect with the named protocol
	const ATL_NAVIGATE_DATA* GetCurrentNavdata();
	enum HTTP_RESPONSE_READ_STATUS
	{
		RR_OK = 0, // response was successfully processed
		RR_FAIL, // an unknown error occurred reading the HTTP response
		RR_STATUS_INVALID, // could not parse the status line
		RR_PARSEHEADERS_FAILED, // failed to parse HTTP response headers
		RR_READSOCKET_FAILED, // failed to read response data from socket
		RR_READBODY_FAILED, // failed to successfully read the entity body of the HTTP response
		RR_READCHUNKEDBODY_FAILED, // failed to read a 'Transfer-Encoding: chunked' response body
		RR_NOT_READ // we haven't started reading the response.
	};
	HTTP_RESPONSE_READ_STATUS GetResponseStatus();


// Implementation
	HTTP_RESPONSE_READ_STATUS ReadHttpResponse() throw();
	void ResetConnection() throw();
	bool ProcessStatus(DWORD dwFlags) throw();
	bool BuildRequest(/*out*/CString *pstrRequest,
						LPCTSTR szDataType=NULL,
						LPCTSTR szExtraHeaders=NULL) throw();

	void SetSilentLogonOk(bool bSet) 
	{ 
		m_bSilentLogonOk = bSet; 
	}
protected:
	DWORD WriteWithNoData(LPCSTR pRequest, DWORD dwRequestLen);
	DWORD WriteWithCallback(LPCSTR pRequest, DWORD dwRequestLen);
	DWORD WriteWithChunks(LPCSTR pRequest, DWORD dwRequestLen);
	DWORD WriteWithData(LPCSTR pRequest, DWORD dwRequestLen);
	bool SetDefaultUrl(LPCTSTR szUrl, short nPortNumber=ATL_URL_DEFAULT_HTTP_PORT) throw();
	bool SetDefaultUrl(LPCURL pUrl, short nPortNumber=ATL_URL_DEFAULT_HTTP_PORT) throw();
	bool SetDefaultMethod(LPCTSTR szMethod) throw();
	void InitializeObject() throw();
	void ResetRequest() throw();
	bool ReadSocket() throw();
	unsigned char* FindHeaderEnd(unsigned char** ppBegin) throw();
	bool LookupRegProxy() throw();
	bool DisconnectIfRequired() throw();
	bool ConnectSocket() throw();

	long GetContentLength() throw();
	LPCSTR NextLine(BYTE* pCurr) throw();
	bool IsMsgBodyChunked() throw();
	LPCSTR FindEndOfHeader(LPCSTR pszStart) throw();
	bool DecodeHeader(LPCSTR pHeaderStart, LPCSTR pHeaderEnd) throw();
	virtual void OnSetCookie(LPCTSTR /*szCookie*/) throw();
	LPCSTR ParseStatusLine(BYTE* pBuffer) throw();
	int CrackResponseHeader(LPCSTR pBuffer, /*out*/ LPCSTR *pEnd) throw();
	bool ReadBody(int nContentLen, int nCurrentBodyLen) throw();
	bool ReadChunkedBody() throw();
	bool ReconnectIfRequired() throw();
	bool CompleteURL(CString& strURL) throw();
	bool ProcessObjectMoved() throw();
	bool _SetDefaultUrl(LPCTSTR szURL, short nPort) throw();

	enum CHUNK_STATE{
		READ_CHUNK_SIZE, // need to read the size of a chunk.
		READ_CHUNK_SIZE_FOOTER,
		READ_CHUNK_DATA, // need to read the actual data
		READ_CHUNK_DATA_FOOTER, // need to read the chunk footer.
		READ_CHUNK_TRAILER, // Read the trailer headers at the end of the chunk data
		READ_CHUNK_TRAILER_FOOTER, // read the final crlf
		CHUNK_READ_DATA_COMPLETE, // done reading chunk data.
	};

	enum CHUNK_LEX_RESULT{
		LEX_OK,
		LEX_OUTOFDATA,
		LEX_ERROR,
		LEX_TRAILER_COMPLETE
	};

	CHUNK_LEX_RESULT get_chunked_size(__deref_inout char *&pBuffStart, __deref_inout char *&pBuffEnd, __inout long* pnChunkSize) throw();
	bool move_leftover_bytes(__in_ecount(nLen) char *pBufferStart, __in int nLen, __deref_inout char *&pBuffStart, __deref_inout char *&pBuffEnd) throw();
	CHUNK_LEX_RESULT get_chunked_data(__deref_inout char *&pBufferStart, __deref_inout char *&pBufferEnd, long nChunkSize,
								  __deref_out_ecount_part(*pnDataLen, *pnDataLen) char **ppDataStart, __inout long *pnDataLen) throw();
	CHUNK_LEX_RESULT consume_chunk_trailer(__deref_inout char *&pBufferStart, __deref_inout char *pBufferEnd) throw();
	CHUNK_LEX_RESULT consume_chunk_footer(__deref_inout char *&pBufferStart, __deref_inout char *&pBufferEnd) throw();

	typedef CAtlMap< 
				CString,
				CString,
				CStringElementTraitsI<CString>,
				CStringElementTraitsI<CString>
			   > HeaderMapType;

	typedef CAtlMap <
				CString,
				CAtlBaseAuthObject*,
				CStringElementTraitsI<CString>
				> AuthMapType;

	typedef CAtlArray<
				CString,
				CStringElementTraitsI<CString>
				> AuthListType;

	HeaderMapType m_HeaderMap; // Map of response headers
	AuthMapType m_AuthMap; // Map of pointers to authorization objects.
	AuthListType m_AuthTypes; // list of authorization types the server is willing to use.
	BOOL m_bSilentLogonOk;
	CAtlIsapiBuffer<> m_current; // The entire response
	CUrl m_urlCurrent; // URL of current request

	CString m_strMethod; // Current request method.
	CString m_strProxy; // Path to current proxy server.
	
	long m_nStatus; // Current response status (from status line)
	short m_nProxyPort; // Port used on current proxy server
	DWORD m_dwBodyLen; // Length of body
	DWORD m_dwHeaderLen; // Length of current raw headers
	DWORD m_dwHeaderStart;
	BYTE *m_pCurrent;
	BYTE *m_pEnd; // the end of the data we've read fromt he socket;
	ATL_NAVIGATE_DATA *m_pNavData;
	HTTP_RESPONSE_READ_STATUS m_LastResponseParseError;
}; //CAtlHttpClientT
typedef CAtlHttpClientT<ZEvtSyncSocket> CAtlHttpClient;


// Interface used to acquire authentication information from clients
__interface IAuthInfo
{
	HRESULT GetPassword(__out_ecount_part_z_opt(*pdwBuffSize, *pdwBuffSize) LPTSTR szPwd, __inout DWORD *pdwBuffSize);
	HRESULT GetUsername(__out_ecount_part_z_opt(*pdwBuffSize, *pdwBuffSize) LPTSTR szUid, __inout DWORD *pdwBuffSize);
	HRESULT GetDomain(__out_ecount_part_z_opt(*pdwBuffSize, *pdwBuffSize) LPTSTR szDomain, __inout DWORD *pdwBuffSize);
};
typedef HRESULT (IAuthInfo::*PFNAUTHFUNC)(LPTSTR szPwd, DWORD *pdwSize);

// pure virtual class that describes required functions for authoriztion
// objects
class CAtlBaseAuthObject
{
public:
	CAtlBaseAuthObject();
	virtual bool Authenticate(LPCTSTR szAuthTypes, bool bProxy) = 0;
	virtual void Init(CAtlHttpClient *pSocket, IAuthInfo *pAuthInfo) = 0;
	bool m_bFailed;
};

// strings used for authentication.
extern __declspec(selectany)const TCHAR * const g_pszWWWAuthenticate = _T("www-authenticate");
extern __declspec(selectany)const TCHAR * const g_pszProxyAuthenticate = _T("proxy-authenticate");

// Performs NTLM authentication
class CNTLMAuthObject :
	public CAtlBaseAuthObject
{
public:
	virtual ~CNTLMAuthObject() throw();
	CNTLMAuthObject() throw();
	CNTLMAuthObject(IAuthInfo *pAuthInfo) throw();
	void SetAuthInfo(IAuthInfo *pAuthInfo) throw();
	bool GetCredentialNames(CString& theName);

// Implementation
	// Called by the CAtlHttpClient class to authenticate a user.
	virtual void Init(CAtlHttpClient *pSocket, IAuthInfo *pAuthInfo=NULL) throw();

	// Called by the CAtlHttpClient class to initialize this authentication object.
	virtual bool Authenticate(LPCTSTR szAuthTypes, bool bProxy) throw();
protected:
	bool AcquireCredHandle() throw();
	// This function creates an NTML Authorization header
	// and sends it to the HTTP server.
	bool SendSecurityInfo(SecBuffer *pSecBuffer, LPSTR *pszBuffer) throw();
	bool DoNTLMAuthenticate() throw();

	IAuthInfo *m_pAuthInfo;
	CAtlHttpClient *m_pSocket;
	CredHandle m_hCredentials;
	int m_nMaxTokenSize;
	TimeStamp m_ts;
	bool m_bProxy;
	static const char * const m_pszFmtWWW;
	static const char * const m_pszFmtProxy;
	CAtlNavigateData m_CurrentRequestData;

}; // CNTLMAuthObject

// Performs BASIC authentication for an CAtlHttpClient
// object. Caller must implement an IAuthInfo interface
// and pass it to this object before this object attempts
// to authenticate or authentication will fail.
class CBasicAuthObject : 
	public CAtlBaseAuthObject
{
public:
	CBasicAuthObject() throw();
	CBasicAuthObject(IAuthInfo *pAuthInfo) throw();
	void SetAuthInfo(IAuthInfo *pAuthInfo) throw();
	LPCTSTR GetRealm() throw(); // Retrieve's the realm being used.

// Implementation
	// Called by the CAtlHttpClient class to authenticate a user.
	virtual bool Authenticate(LPCTSTR szAuthTypes, bool bProxy) throw();

	// Called by the CAtlHttpClient class to initialize this authentication object.
	virtual void Init(CAtlHttpClient *pSocket, IAuthInfo *pAuthInfo=NULL) throw();
protected:
	bool DoBasicAuthenticate() throw();
	bool CrackRealm(LPCTSTR szHeader) throw();

	IAuthInfo *m_pAuthInfo;
	CAtlHttpClient *m_pClient;
	TCHAR m_szRealm[MAX_REALM_LEN];
	bool m_bProxy;
	static const char * const m_pszFmtWWW;
	static const char * const m_pszFmtProxy;
}; // CBasicAuthObject

__declspec(selectany)const char * const CBasicAuthObject::m_pszFmtWWW = "Authorization: Basic ";
__declspec(selectany)const char * const CBasicAuthObject::m_pszFmtProxy = "Proxy-Authorization: Basic ";
__declspec(selectany)const char * const CNTLMAuthObject::m_pszFmtWWW = "Authorization: NTLM %s\r\n";
__declspec(selectany)const char * const CNTLMAuthObject::m_pszFmtProxy = "Proxy-Authorization: NTLM %s\r\n";

typedef CTempBuffer<TCHAR, _ATL_MAX_AUTH_BUFF> CAuthInfoBuffType;
inline bool _AtlGetAuthInfoHelper(IAuthInfo *pObj, PFNAUTHFUNC pFunc, CAuthInfoBuffType& buff, DWORD *dwLen)
{
	ATLENSURE(pObj);
	ATLASSERT(pFunc);
	DWORD dwSize = _ATL_MAX_AUTH_BUFF;
	bool bRet = true;
	TCHAR *szValue = NULL;
	_ATLTRY
	{
		szValue = buff.Allocate(_ATL_MAX_AUTH_BUFF);
		HRESULT hr = E_FAIL;
		if (szValue)
		{
			hr = (pObj->*pFunc)(szValue, &dwSize);
			if (hr != S_OK)
			{
				if (hr == E_OUTOFMEMORY)
				{
					// buffer not big enough, try to allocate
					szValue = buff.Reallocate(dwSize);
					if (szValue)
					{
						// retry the call
						if (S_OK != (pObj->*pFunc)(szValue, &dwSize))
							bRet = false;
					}
					else
						bRet = false;
				}
				else
					bRet = false;
			}
		}
		else
			bRet = false;

	}
	_ATLCATCHALL()
	{
		bRet = false;
	}
	if (bRet)
		*dwLen = (DWORD)_tcslen(szValue);
	else
		*dwLen = 0;
	return bRet;
}

//
// Security Service Provider Interface (sspi) Helper classes
// These classes are used as helpers for structures used in 
// SSPI functions.
//
class CSecAuthIdentity : public SEC_WINNT_AUTH_IDENTITY_EX
{
public:
	CSecAuthIdentity() throw()
	{
		Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
		Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EX);
#ifdef _UNICODE
		Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
#else
		Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
#endif
	}


	bool Init(IAuthInfo *pAuthInfo) throw()
	{
		if (!pAuthInfo)
			return false;

		if (!_AtlGetAuthInfoHelper(pAuthInfo, &IAuthInfo::GetUsername, buffUserName, &UserLength))
			return false;

		if (!_AtlGetAuthInfoHelper(pAuthInfo, &IAuthInfo::GetPassword, buffPassword, &PasswordLength))
			return false;

		if (!_AtlGetAuthInfoHelper(pAuthInfo, &IAuthInfo::GetDomain, buffDomain, &DomainLength))
			return false;

#ifndef _UNICODE
		User = (unsigned char*)(char*)buffUserName;
		Domain = DomainLength > 0 ? (unsigned char*)(char*)buffDomain : 0;
		Password = PasswordLength > 0 ? (unsigned char*)(char*)buffPassword : 0;
#else
		// have to cast to unsigned short *, because SEC_WINNT_AUTH_IDENTITY_EXW
		// uses unsigned short instead of wchar_t
		User = (unsigned short *)(wchar_t*)buffUserName;
		Domain = DomainLength > 0 ? (unsigned short *)(wchar_t*)buffDomain : 0;
		Password = PasswordLength > 0 ? (unsigned short *)(wchar_t*)buffPassword : 0;
#endif
		return true;
	}

protected:
	CAuthInfoBuffType buffUserName;
	CAuthInfoBuffType buffPassword;
	CAuthInfoBuffType buffDomain;
}; // CSecAuthIdentity

class CSecBuffer : public SecBuffer
{
public:
	CSecBuffer() throw()
	{
		cbBuffer = 0;
		BufferType = 0;
		pvBuffer = NULL;
		m_cbAlloc = 0;
	}

	~CSecBuffer() throw()
	{
		delete [] static_cast<unsigned char*>(pvBuffer);
	}

	bool SetSize(unsigned long nSize) throw()
	{
		if (!nSize)
			return false;

		if (pvBuffer)
		{
			delete [] static_cast<unsigned char*>(pvBuffer);
			pvBuffer = NULL;
			cbBuffer = 0;
			m_cbAlloc = 0;
		}

		ATLTRY(pvBuffer = static_cast<void*>(new unsigned char[nSize]));
		if (pvBuffer)
		{
			cbBuffer = nSize;
			BufferType = SECBUFFER_TOKEN;
			m_cbAlloc = cbBuffer;
			return true;
		}
		return false;
	}

	bool ClearBuffer(unsigned long nSize) throw()
	{
		if(nSize > m_cbAlloc)
			return false;
			
		ZeroMemory(pvBuffer, nSize);
		cbBuffer = nSize;
		return true;
	}

	unsigned long Size()
	{
		return cbBuffer;
	}

	unsigned char *Buffer() throw()
	{
		return static_cast<unsigned char*>(pvBuffer);
	}

	operator SecBuffer*() throw()
	{
		return (SecBuffer*)this;
	}
	
protected:
	unsigned long m_cbAlloc;
	
}; // CSecBuffer

class CSecBufferDesc : public SecBufferDesc
{
public:
	CSecBufferDesc() throw()
	{
		ulVersion = SECBUFFER_VERSION;
		cBuffers = 0;
		pBuffers = NULL;
	}

	~CSecBufferDesc() throw()
	{
		cBuffers = 0;

		if (pBuffers)
		{
			CSecBuffer *psb = (CSecBuffer*)pBuffers;
			delete [] psb;
		}
	}

	// index is 0 based
	CSecBuffer* Buffers(unsigned int i) throw()
	{
		if (i < cBuffers)
		{
			return (CSecBuffer*)(&pBuffers[i]);
		}

		return NULL;
	}

	bool AddBuffers(unsigned int nCount, unsigned int nBufferSize) throw()
	{
		if (!nCount)
			return true;

		if (cBuffers == 0)
		{
			CSecBuffer *pSecBuffer = NULL;
			ATLTRY(pSecBuffer = new CSecBuffer[nCount]);
			if (!pSecBuffer)
				return false;
			CAutoVectorPtr<CSecBuffer> spSecBuffer(pSecBuffer);

			for (unsigned int i=0; i<nCount; i++)
			{
				if (!pSecBuffer[i].SetSize(nBufferSize))
					return false;
			}
			cBuffers = nCount;
			pBuffers = (SecBuffer*)spSecBuffer.Detach();
		}
		else // realloc
		{
			CSecBuffer *pSecBuffer = NULL;
			ATLTRY(pSecBuffer = new CSecBuffer[nCount + cBuffers]);
			if (!pSecBuffer)
				return false;
			CAutoVectorPtr<CSecBuffer> spSecBuffer(pSecBuffer);
			Checked::memcpy_s(pSecBuffer, (nCount + cBuffers)*sizeof(CSecBuffer), pBuffers, cBuffers*sizeof(CSecBuffer));
			delete [] pBuffers;
			pBuffers=NULL;

			// initialize new buffers
			for (unsigned int i=0; i<nCount; i++)
			{
				if (!pSecBuffer[cBuffers+i].SetSize(nBufferSize))
					return false;
			}
			pBuffers = spSecBuffer.Detach();
			cBuffers += nCount;
		}
		return true;
	}

	operator PSecBufferDesc() throw()
	{
		return static_cast<PSecBufferDesc>(this);
	}
}; // CSecBufferDesc

} // namespace ATL
 

#include <atlhttp.inl>

#pragma pack(pop)
#pragma warning(pop)

#ifndef __CPPUNWIND
#pragma warning(pop)
#endif

#endif // __ATLHTTP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlfile.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLFILE_H__
#define __ATLFILE_H__

#pragma once

#include <atlbase.h>


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

class CAtlFile : public CHandle
{
public:
	CAtlFile() throw()
	{
	}
	CAtlFile( __in CAtlFile& file ) throw() :
		CHandle( file )  // Transfers ownership
	{
	}
	explicit CAtlFile( __in HANDLE hFile ) throw() :
		CHandle( hFile )  // Takes ownership
	{
	}

	HRESULT Create(
		__in LPCTSTR szFilename,
		__in DWORD dwDesiredAccess,
		__in DWORD dwShareMode,
		__in DWORD dwCreationDisposition,
		__in DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL,
		__in_opt LPSECURITY_ATTRIBUTES lpsa = NULL,
		__in_opt HANDLE hTemplateFile = NULL) throw()
	{
		ATLASSUME(m_h == NULL);

		HANDLE hFile = ::CreateFile(
			szFilename,
			dwDesiredAccess,
			dwShareMode,
			lpsa,
			dwCreationDisposition,
			dwFlagsAndAttributes,
			hTemplateFile);

		if (hFile == INVALID_HANDLE_VALUE)
			return AtlHresultFromLastError();

		Attach(hFile);
		return S_OK;
	}

	HRESULT Read(
		__out_bcount(nBufSize) LPVOID pBuffer,
		DWORD nBufSize) throw()
	{
		ATLASSUME(m_h != NULL);

		DWORD nBytesRead = 0;
		BOOL bSuccess = ::ReadFile(m_h, pBuffer, nBufSize, &nBytesRead, NULL);
		if (!bSuccess )
			return AtlHresultFromLastError();
		if (nBytesRead != nBufSize)
			return HRESULT_FROM_WIN32( ERROR_HANDLE_EOF );

		return S_OK;
	}

	HRESULT Read(
		__out_bcount(nBufSize) LPVOID pBuffer,
		__in DWORD nBufSize,
		__out DWORD& nBytesRead) throw()
	{
		ATLASSUME(m_h != NULL);

		BOOL b = ::ReadFile(m_h, pBuffer, nBufSize, &nBytesRead, NULL);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

#ifndef _WIN32_WCE
	// this function will usually return HRESULT_FROM_WIN32(ERROR_IO_PENDING)
	// indicating succesful queueing of the operation
	HRESULT Read(
		__out_bcount(nBufSize) LPVOID pBuffer,
		__in DWORD nBufSize,
		__in_opt LPOVERLAPPED pOverlapped) throw()
	{
		ATLASSUME(m_h != NULL);

		BOOL b = ::ReadFile(m_h, pBuffer, nBufSize, NULL, pOverlapped);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT Read(
		__in_bcount(nBufSize) LPVOID pBuffer,
		__in DWORD nBufSize,
		__in_opt LPOVERLAPPED pOverlapped,
		__in LPOVERLAPPED_COMPLETION_ROUTINE pfnCompletionRoutine) throw()
	{
		ATLASSUME(m_h != NULL);

		BOOL b = ::ReadFileEx(m_h, pBuffer, nBufSize, pOverlapped, pfnCompletionRoutine);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}
#endif // _WIN32_WCE

	HRESULT Write(
		__in_bcount(nBufSize) LPCVOID pBuffer,
		__in DWORD nBufSize,
		__out_opt DWORD* pnBytesWritten = NULL) throw()
	{
		ATLASSUME(m_h != NULL);

		DWORD nBytesWritten;
		if (pnBytesWritten == NULL)
			pnBytesWritten = &nBytesWritten;
		BOOL b = ::WriteFile(m_h, pBuffer, nBufSize, pnBytesWritten, NULL);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

#ifndef _WIN32_WCE
	// this function will usually return HRESULT_FROM_WIN32(ERROR_IO_PENDING)
	// indicating succesful queueing of the operation
	HRESULT Write(
		__in_bcount(nBufSize) LPCVOID pBuffer,
		__in DWORD nBufSize,
		__in_opt LPOVERLAPPED pOverlapped) throw()
	{
		ATLASSUME(m_h != NULL);

		BOOL b = ::WriteFile(m_h, pBuffer, nBufSize, NULL, pOverlapped);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT Write(
		__in_bcount(nBufSize) LPCVOID pBuffer,
		__in DWORD nBufSize,
		__in_opt LPOVERLAPPED pOverlapped,
		__in LPOVERLAPPED_COMPLETION_ROUTINE pfnCompletionRoutine) throw()
	{
		ATLASSUME(m_h != NULL);

		BOOL b = ::WriteFileEx(m_h, pBuffer, nBufSize, pOverlapped, pfnCompletionRoutine);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}

	// this function returns HRESULT_FROM_WIN32(ERROR_IO_INCOMPLETE)
	// if bWait is false and the operation is still pending
	HRESULT GetOverlappedResult(
		__in LPOVERLAPPED pOverlapped,
		__out DWORD& dwBytesTransferred,
		__in BOOL bWait) throw()
	{
		BOOL b = ::GetOverlappedResult(m_h, pOverlapped, &dwBytesTransferred, bWait);
		if (!b)
			return AtlHresultFromLastError();

		return S_OK;
	}
#endif // _WIN32_WCE

	HRESULT Seek(__in LONGLONG nOffset, __in DWORD dwFrom = FILE_CURRENT) throw()
	{
		ATLASSUME(m_h != NULL);
		ATLASSERT(dwFrom == FILE_BEGIN || dwFrom == FILE_END || dwFrom == FILE_CURRENT);

		LARGE_INTEGER liOffset;
		liOffset.QuadPart = nOffset;
		DWORD nNewPos = ::SetFilePointer(m_h, liOffset.LowPart, &liOffset.HighPart, dwFrom);
		if (nNewPos == INVALID_SET_FILE_POINTER)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			if (FAILED(hr))
				return hr;
		}

		return S_OK;
	}

	HRESULT GetPosition(__out ULONGLONG& nPos) const throw()
	{
		ATLASSUME(m_h != NULL);

		LARGE_INTEGER liOffset;
		liOffset.QuadPart = 0;
		liOffset.LowPart = ::SetFilePointer(m_h, 0, &liOffset.HighPart, FILE_CURRENT);
		if (liOffset.LowPart == INVALID_SET_FILE_POINTER)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			if (FAILED(hr))
				return hr;
		}
		nPos = liOffset.QuadPart;

		return S_OK;
	}

	HRESULT Flush() throw()
	{
		ATLASSUME(m_h != NULL);

		if (!::FlushFileBuffers(m_h))
			return AtlHresultFromLastError();

		return S_OK;
	}

#ifndef _WIN32_WCE
	HRESULT LockRange(ULONGLONG nPos, ULONGLONG nCount) throw()
	{
		ATLASSUME(m_h != NULL);

		LARGE_INTEGER liPos;
		liPos.QuadPart = nPos;

		LARGE_INTEGER liCount;
		liCount.QuadPart = nCount;

		if (!::LockFile(m_h, liPos.LowPart, liPos.HighPart, liCount.LowPart, liCount.HighPart))
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT UnlockRange(__in ULONGLONG nPos, __in ULONGLONG nCount) throw()
	{
		ATLASSUME(m_h != NULL);

		LARGE_INTEGER liPos;
		liPos.QuadPart = nPos;

		LARGE_INTEGER liCount;
		liCount.QuadPart = nCount;

		if (!::UnlockFile(m_h, liPos.LowPart, liPos.HighPart, liCount.LowPart, liCount.HighPart))
			return AtlHresultFromLastError();

		return S_OK;
	}
#endif // _WIN32_WCE

	HRESULT SetSize(__in ULONGLONG nNewLen) throw()
	{
		ATLASSUME(m_h != NULL);

		HRESULT hr = Seek(nNewLen, FILE_BEGIN);
		if (FAILED(hr))
			return hr;

		if (!::SetEndOfFile(m_h))
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT GetSize(__out ULONGLONG& nLen) const throw()
	{
		ATLASSUME(m_h != NULL);

		ULARGE_INTEGER liFileSize;
		liFileSize.LowPart = ::GetFileSize(m_h, &liFileSize.HighPart);
		if (liFileSize.LowPart == INVALID_FILE_SIZE)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			if (FAILED(hr))
				return hr;
		}

		nLen = liFileSize.QuadPart;

		return S_OK;
	}
};

// This class allows the creation of a temporary file that is written to.
// When the entire file has been successfully written it will be closed and given
// it's proper file name if required.
class CAtlTemporaryFile
{
public:
	CAtlTemporaryFile() throw()
	{
	}

	~CAtlTemporaryFile() throw()
	{
		// Ensure that the temporary file is closed and deleted,
		// if necessary.
		if (m_file.m_h != NULL)
		{
			Close();
		}
	}

	HRESULT Create(__in_opt LPCTSTR pszDir = NULL, __in DWORD dwDesiredAccess = GENERIC_WRITE) throw()
	{
		TCHAR szPath[_MAX_PATH]; 
		TCHAR tmpFileName[_MAX_PATH]; 

		ATLASSUME(m_file.m_h == NULL);

		if (pszDir == NULL)
		{
			DWORD dwRet = GetTempPath(_MAX_DIR, szPath);
			if (dwRet == 0)
			{
				// Couldn't find temporary path;
				return AtlHresultFromLastError();
			}
			else if (dwRet > _MAX_DIR)
			{
				return DISP_E_BUFFERTOOSMALL;
			}
		}
		else
		{
			if(Checked::tcsncpy_s(szPath, _countof(szPath), pszDir, _TRUNCATE)==STRUNCATE)
			{
				return DISP_E_BUFFERTOOSMALL;
			}
		}

		if (!GetTempFileName(szPath, _T("TFR"), 0, tmpFileName))
		{
			// Couldn't create temporary filename;
			return AtlHresultFromLastError();
		}
		tmpFileName[_countof(tmpFileName)-1]='\0';

		Checked::tcsncpy_s(m_szTempFileName, _countof(m_szTempFileName), tmpFileName, _TRUNCATE);
		SECURITY_ATTRIBUTES secatt;
		secatt.nLength = sizeof(secatt);
		secatt.lpSecurityDescriptor = NULL;
		secatt.bInheritHandle = TRUE;

		m_dwAccess = dwDesiredAccess;

		return m_file.Create(
			m_szTempFileName,
			m_dwAccess,
			0,
			CREATE_ALWAYS,
#ifndef _WIN32_WCE
			FILE_ATTRIBUTE_NOT_CONTENT_INDEXED | FILE_ATTRIBUTE_TEMPORARY,
#else // _WIN32_WCE
			FILE_ATTRIBUTE_NORMAL,
#endif // _WIN32_WCE
			&secatt);
	}

	HRESULT Close(__in_opt LPCTSTR szNewName = NULL) throw()
	{
		ATLASSUME(m_file.m_h != NULL);

		// This routine is called when we are finished writing to the 
		// temporary file, so we now just want to close it and copy
		// it to the actual filename we want it to be called.

		// So let's close it first.
		m_file.Close();

		// no new name so delete it
		if (szNewName == NULL)
		{
			::DeleteFile(m_szTempFileName);
			return S_OK;
		}

		// delete any existing file and move our temp file into it's place
		if (!::DeleteFile(szNewName))
		{
			DWORD dwError = GetLastError();
			if (dwError != ERROR_FILE_NOT_FOUND)
				return AtlHresultFromWin32(dwError);
		}

		if (!::MoveFile(m_szTempFileName, szNewName))
			return AtlHresultFromLastError();

		return S_OK;
	}

	HRESULT HandsOff() throw()
	{
		m_file.Flush();
		m_file.Close();

		return S_OK;
	}

	HRESULT HandsOn() throw()
	{
		HRESULT hr = m_file.Create(
			m_szTempFileName,
			m_dwAccess,
			0,
			OPEN_EXISTING);
		if (FAILED(hr))
			return hr;

		return m_file.Seek(0, FILE_END);
	}

	HRESULT Read(
		__out_bcount(nBufSize) LPVOID pBuffer,
		__in DWORD nBufSize,
		__out DWORD& nBytesRead) throw()
	{
		return m_file.Read(pBuffer, nBufSize, nBytesRead);
	}

	HRESULT Write(
		__in_bcount(nBufSize) LPCVOID pBuffer,
		__in DWORD nBufSize,
		__out_opt DWORD* pnBytesWritten = NULL) throw()
	{
		return m_file.Write(pBuffer, nBufSize, pnBytesWritten);
	}

	HRESULT Seek(__in LONGLONG nOffset, __in DWORD dwFrom = FILE_CURRENT) throw()
	{
		return m_file.Seek(nOffset, dwFrom);
	}

	HRESULT GetPosition(__out ULONGLONG& nPos) const throw()
	{
		return m_file.GetPosition(nPos);
	}

	HRESULT Flush() throw()
	{
		return m_file.Flush();
	}

#ifndef _WIN32_WCE
	HRESULT LockRange(__in ULONGLONG nPos, __in ULONGLONG nCount) throw()
	{
		return m_file.LockRange(nPos, nCount);
	}

	HRESULT UnlockRange(__in ULONGLONG nPos, __in ULONGLONG nCount) throw()
	{
		return m_file.UnlockRange(nPos, nCount);
	}
#endif // _WIN32_WCE

	HRESULT SetSize(__in ULONGLONG nNewLen) throw()
	{
		return m_file.SetSize(nNewLen);
	}

	HRESULT GetSize(__out ULONGLONG& nLen) const throw()
	{
		return m_file.GetSize(nLen);
	}

	operator HANDLE() throw()
	{
		return m_file;
	}

	LPCTSTR TempFileName() throw()
	{
		return m_szTempFileName;
	}

private:
	CAtlFile m_file;
	TCHAR m_szTempFileName[_MAX_FNAME+1];
	DWORD m_dwAccess;
};

class CAtlFileMappingBase
{
public:
	CAtlFileMappingBase() throw()
	{
		m_pData = NULL;
		m_hMapping = NULL;
	}

	~CAtlFileMappingBase() throw()
	{
		Unmap();
	}

	HRESULT MapFile(
		__in HANDLE hFile,
		__in SIZE_T nMappingSize = 0,
		__in ULONGLONG nOffset = 0,
		__in DWORD dwMappingProtection = PAGE_READONLY,
		__in DWORD dwViewDesiredAccess = FILE_MAP_READ) throw()
	{
		ATLASSUME(m_pData == NULL);
		ATLASSUME(m_hMapping == NULL);
		ATLASSERT(hFile != INVALID_HANDLE_VALUE && hFile != NULL);

		ULARGE_INTEGER liFileSize;
		liFileSize.LowPart = ::GetFileSize(hFile, &liFileSize.HighPart);
		if (liFileSize.QuadPart < nMappingSize)
			liFileSize.QuadPart = nMappingSize;

		m_hMapping = ::CreateFileMapping(hFile, NULL, dwMappingProtection, liFileSize.HighPart, liFileSize.LowPart, 0);
		if (m_hMapping == NULL)
			return AtlHresultFromLastError();

		if (nMappingSize == 0)
			m_nMappingSize = (SIZE_T) (liFileSize.QuadPart - nOffset);
		else
			m_nMappingSize = nMappingSize;

		m_dwViewDesiredAccess = dwViewDesiredAccess;
		m_nOffset.QuadPart = nOffset;

		m_pData = ::MapViewOfFile(m_hMapping, m_dwViewDesiredAccess, m_nOffset.HighPart, m_nOffset.LowPart, m_nMappingSize);
		if (m_pData == NULL)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			::CloseHandle(m_hMapping);
			m_hMapping = NULL;
			return hr;
		}

		return S_OK;
	}

	HRESULT MapSharedMem(
		__in SIZE_T nMappingSize,
		__in LPCTSTR szName,
		__out_opt BOOL* pbAlreadyExisted = NULL,
		__in_opt LPSECURITY_ATTRIBUTES lpsa = NULL,
		__in DWORD dwMappingProtection = PAGE_READWRITE,
		__in DWORD dwViewDesiredAccess = FILE_MAP_ALL_ACCESS) throw()
	{
		ATLASSUME(m_pData == NULL);
		ATLASSUME(m_hMapping == NULL);
		ATLASSERT(nMappingSize > 0);
		ATLASSERT(szName != NULL); // if you just want a regular chunk of memory, use a heap allocator

		m_nMappingSize = nMappingSize;

		ULARGE_INTEGER nSize;
		nSize.QuadPart = nMappingSize;
		m_hMapping = ::CreateFileMapping(INVALID_HANDLE_VALUE, lpsa, dwMappingProtection, nSize.HighPart, nSize.LowPart, szName);
		if (m_hMapping == NULL)
			return AtlHresultFromLastError();

		if (pbAlreadyExisted != NULL)
			*pbAlreadyExisted = (GetLastError() == ERROR_ALREADY_EXISTS);

		m_dwViewDesiredAccess = dwViewDesiredAccess;
		m_nOffset.QuadPart = 0;

		m_pData = ::MapViewOfFile(m_hMapping, m_dwViewDesiredAccess, m_nOffset.HighPart, m_nOffset.LowPart, m_nMappingSize);
		if (m_pData == NULL)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			::CloseHandle(m_hMapping);
			return hr;
		}


		return S_OK;
	}

#ifndef _WIN32_WCE
	HRESULT OpenMapping(
		__in LPCTSTR szName,
		__in SIZE_T nMappingSize,
		__in ULONGLONG nOffset = 0,
		__in DWORD dwViewDesiredAccess = FILE_MAP_ALL_ACCESS) throw()
	{
		ATLASSUME(m_pData == NULL);
		ATLASSUME(m_hMapping == NULL);
		ATLASSERT(szName != NULL); // if you just want a regular chunk of memory, use a heap allocator

		m_nMappingSize = nMappingSize;
		m_dwViewDesiredAccess = dwViewDesiredAccess;

		m_hMapping = ::OpenFileMapping(m_dwViewDesiredAccess, FALSE, szName);
		if (m_hMapping == NULL)
			return AtlHresultFromLastError();

		m_dwViewDesiredAccess = dwViewDesiredAccess;
		m_nOffset.QuadPart = nOffset;

		m_pData = ::MapViewOfFile(m_hMapping, m_dwViewDesiredAccess, m_nOffset.HighPart, m_nOffset.LowPart, m_nMappingSize);
		if (m_pData == NULL)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			::CloseHandle(m_hMapping);
			return hr;
		}


		return S_OK;
	}
#endif // _WIN32_WCE

	HRESULT Unmap() throw()
	{
		HRESULT hr = S_OK;

		if (m_pData != NULL)
		{
			if (!::UnmapViewOfFile(m_pData))
				hr = AtlHresultFromLastError();
			m_pData = NULL;
		}
		if (m_hMapping != NULL)
		{
			if (!::CloseHandle(m_hMapping) && SUCCEEDED(hr))
				hr = AtlHresultFromLastError();
			m_hMapping = NULL;
		}
		return hr;
	}

	void* GetData() const throw()
	{
		return m_pData;
	}

	HANDLE GetHandle() const throw()
	{
		return m_hMapping;
	}

	SIZE_T GetMappingSize() throw()
	{
		return m_nMappingSize;
	}

	HRESULT CopyFrom(__in CAtlFileMappingBase& orig) throw()
	{
		if (this == &orig)
			return S_OK;
		ATLASSUME(m_pData == NULL);
		ATLASSUME(m_hMapping == NULL);
		ATLASSERT(orig.m_pData != NULL);
		ATLASSERT(orig.m_hMapping != NULL);

		m_dwViewDesiredAccess = orig.m_dwViewDesiredAccess;
		m_nOffset.QuadPart = orig.m_nOffset.QuadPart;
		m_nMappingSize = orig.m_nMappingSize;

		if (!::DuplicateHandle(GetCurrentProcess(), orig.m_hMapping, GetCurrentProcess(),
				&m_hMapping, NULL, TRUE, DUPLICATE_SAME_ACCESS))
			return AtlHresultFromLastError();

		m_pData = ::MapViewOfFile(m_hMapping, m_dwViewDesiredAccess, m_nOffset.HighPart, m_nOffset.LowPart, m_nMappingSize);
		if (m_pData == NULL)
		{
			HRESULT hr;

			hr = AtlHresultFromLastError();
			::CloseHandle(m_hMapping);
			m_hMapping = NULL;
			return hr;
		}

		return S_OK;
	}

	CAtlFileMappingBase(__in CAtlFileMappingBase& orig)
	{
		m_pData = NULL;
		m_hMapping = NULL;

		HRESULT hr = CopyFrom(orig);
		if (FAILED(hr))
			AtlThrow(hr);
	}

	CAtlFileMappingBase& operator=(__in CAtlFileMappingBase& orig)
	{
		HRESULT hr = CopyFrom(orig);
		if (FAILED(hr))
			AtlThrow(hr);

		return *this;
	}

private:
	void* m_pData;
	SIZE_T m_nMappingSize;
	HANDLE m_hMapping;
	ULARGE_INTEGER m_nOffset;
	DWORD m_dwViewDesiredAccess;
};

template <typename T = char>
class CAtlFileMapping : public CAtlFileMappingBase
{
public:
	operator T*() const throw()
	{
		return reinterpret_cast<T*>(GetData());
	}
};

}; //namespace ATL

#pragma pack(pop)
#endif //__ATLFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlimpl.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma message("atlimpl.cpp is obsolete. Please remove it from your project.")

/////////////////////////////////////////////////////////////////////////////
// No longer used
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlhtml.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLHTML_H__
#define __ATLHTML_H__

#pragma once

#include <atlstr.h>
#include <atlsiface.h>
#include <atlconv.h>



#pragma pack(push,_ATL_PACKING)
namespace ATL {

#define TAGF_NONE 0
#define TAGF_HASEND 1
#define TAGF_BLOCK  2


struct ATL_HTML_TAG
{
	LPCTSTR szTagName;
	UINT uFlags;
};

enum ATL_HTML_TAGS {
	ATL_HTML_TAG_BODY,
	ATL_HTML_TAG_A,
	ATL_HTML_TAG_B,
	ATL_HTML_TAG_I,
	ATL_HTML_TAG_U,
	ATL_HTML_TAG_FONT,
	ATL_HTML_TAG_IMG,
	ATL_HTML_TAG_HR,
	ATL_HTML_TAG_BR,
	ATL_HTML_TAG_DIV,
	ATL_HTML_TAG_BLOCKQUOTE,
	ATL_HTML_TAG_ADDRESS,
	ATL_HTML_TAG_P,
	ATL_HTML_TAG_H1,
	ATL_HTML_TAG_H2,
	ATL_HTML_TAG_H3,
	ATL_HTML_TAG_H4,
	ATL_HTML_TAG_H5,
	ATL_HTML_TAG_H6,
	ATL_HTML_TAG_PRE,
	ATL_HTML_TAG_Q,
	ATL_HTML_TAG_SUB,
	ATL_HTML_TAG_SUP,
	ATL_HTML_TAG_INS,
	ATL_HTML_TAG_DEL,
	ATL_HTML_TAG_EM,
	ATL_HTML_TAG_STRONG,
	ATL_HTML_TAG_DFN,
	ATL_HTML_TAG_CODE,
	ATL_HTML_TAG_SAMP,
	ATL_HTML_TAG_KBD,
	ATL_HTML_TAG_VAR,
	ATL_HTML_TAG_CITE,
	ATL_HTML_TAG_ABBR,
	ATL_HTML_TAG_ACRONYM,
	ATL_HTML_TAG_OL,
	ATL_HTML_TAG_UL,
	ATL_HTML_TAG_LI,
	ATL_HTML_TAG_DL,
	ATL_HTML_TAG_DT,
	ATL_HTML_TAG_DD,
	ATL_HTML_TAG_TABLE,
	ATL_HTML_TAG_TR,
	ATL_HTML_TAG_TD,
	ATL_HTML_TAG_FORM,
	ATL_HTML_TAG_INPUT,
	ATL_HTML_TAG_SELECT,
	ATL_HTML_TAG_OPTION,
	ATL_HTML_TAG_HEAD,
	ATL_HTML_TAG_HTML,
	ATL_HTML_TAG_MAP,
	ATL_HTML_TAG_AREA,
	ATL_HTML_TAG_BASE,
	ATL_HTML_TAG_BDO,
	ATL_HTML_TAG_BIG,
	ATL_HTML_TAG_BUTTON,
	ATL_HTML_TAG_IFRAME,
	ATL_HTML_TAG_LABEL,
	ATL_HTML_TAG_LINK,
	ATL_HTML_TAG_META,
	ATL_HTML_TAG_NOFRAMES,
	ATL_HTML_TAG_NOSCRIPT,
	ATL_HTML_TAG_COL,
	ATL_HTML_TAG_COLGROUP,
	ATL_HTML_TAG_FIELDSET,
	ATL_HTML_TAG_LEGEND,
	ATL_HTML_TAG_TBODY,
	ATL_HTML_TAG_TEXTAREA,
	ATL_HTML_TAG_TFOOT,
	ATL_HTML_TAG_TH,
	ATL_HTML_TAG_TITLE,
	ATL_HTML_TAG_TT,
	ATL_HTML_TAG_SMALL,
	ATL_HTML_TAG_SPAN,
	ATL_HTML_TAG_OBJECT,
	ATL_HTML_TAG_PARAM,
	ATL_HTML_TAG_LAST };

extern __declspec(selectany) const ATL_HTML_TAG s_tags[] = 
{
	{ _T("body"),  TAGF_HASEND | TAGF_BLOCK },
	{ _T("a"), TAGF_HASEND },
	{ _T("b"), TAGF_HASEND },
	{ _T("i"), TAGF_HASEND },
	{ _T("u"), TAGF_HASEND },
	{ _T("font"), TAGF_HASEND },
	{ _T("img"), TAGF_NONE },
	{ _T("hr"), TAGF_NONE },
	{ _T("br"), TAGF_NONE },
	{ _T("div"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("blockquote"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("adress"), TAGF_HASEND },
	{ _T("p"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("h1"), TAGF_HASEND | TAGF_BLOCK},
	{ _T("h2"), TAGF_HASEND  | TAGF_BLOCK},
	{ _T("h3"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("h4"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("h5"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("h6"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("pre"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("q"), TAGF_HASEND },
	{ _T("sub"), TAGF_HASEND },
	{ _T("sup"), TAGF_HASEND },
	{ _T("ins"), TAGF_HASEND },
	{ _T("del"), TAGF_HASEND },
	{ _T("em"), TAGF_HASEND },
	{ _T("strong"), TAGF_HASEND },
	{ _T("dfn"), TAGF_HASEND },
	{ _T("code"), TAGF_HASEND },
	{ _T("samp"), TAGF_HASEND },
	{ _T("kbd"), TAGF_HASEND },
	{ _T("var"), TAGF_HASEND },
	{ _T("cite"), TAGF_HASEND },
	{ _T("abbr"), TAGF_HASEND },
	{ _T("acronym"), TAGF_HASEND },
	{ _T("ol"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("ul"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("li"), TAGF_HASEND },
	{ _T("dl"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("dt"), TAGF_HASEND },
	{ _T("dd"), TAGF_HASEND },
	{ _T("table"), TAGF_HASEND },
	{ _T("tr"), TAGF_HASEND },
	{ _T("td"), TAGF_HASEND },
	{ _T("form"), TAGF_HASEND },
	{ _T("input"), TAGF_HASEND },
	{ _T("select"), TAGF_HASEND },
	{ _T("option"), TAGF_HASEND },
	{ _T("head"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("html"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("map"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("area"), TAGF_BLOCK },
	{ _T("base"), TAGF_BLOCK },
	{ _T("bdo"), TAGF_HASEND },
	{ _T("big"), TAGF_HASEND },
	{ _T("button"), TAGF_HASEND },
	{ _T("iframe"), TAGF_HASEND },
	{ _T("label"), TAGF_HASEND },
	{ _T("link"), TAGF_NONE },
	{ _T("meta"), TAGF_BLOCK },
	{ _T("noframes"), TAGF_BLOCK },
	{ _T("noscript"), TAGF_BLOCK },
	{ _T("col"), TAGF_BLOCK },
	{ _T("colgroup"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("fieldset"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("legend"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("tbody"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("textarea"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("tfoot"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("th"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("title"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("tt"), TAGF_HASEND },
	{ _T("small"), TAGF_HASEND },
	{ _T("span"), TAGF_HASEND },
	{ _T("object"), TAGF_HASEND | TAGF_BLOCK },
	{ _T("param"), TAGF_NONE },
};

class AtlHtmlAttrs
{
public:
	CString m_strAttrs;

	AtlHtmlAttrs()
	{

	}

#pragma warning(push)
#pragma warning(disable : 4793)
	AtlHtmlAttrs(int nCount, ...)
	{
		va_list args;

		va_start(args, nCount);
		for (int i=0; i<nCount; i++)
		{
			LPCTSTR szName = va_arg(args, LPCTSTR);
			LPCTSTR szVal = va_arg(args, LPCTSTR);
			Add(szName, szVal);
		}
		va_end(args);
	}
#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 4793)
	AtlHtmlAttrs(LPCTSTR szFormat, ...)
	{
		if (!szFormat || !*szFormat)
			return;

		va_list args;

		va_start(args, szFormat);

		CString strTmp;
		strTmp.FormatV(szFormat, args);
		va_end(args);

		m_strAttrs += _T(" ");
		m_strAttrs += strTmp;
	}
#pragma warning(pop)

	BOOL Add(LPCTSTR szName, LPCTSTR szValue)
	{
		if (szValue)
			m_strAttrs.AppendFormat(_T(" %s=\"%s\""), szName, szValue);
		else
			m_strAttrs.AppendFormat(_T(" %s"), szName);
		return TRUE;
	}

#pragma warning(push)
#pragma warning(disable : 4793)
	void AddFormat(LPCTSTR szFormat, ...)
	{
		va_list args;

		va_start(args, szFormat);

		CString strTmp;
		strTmp.FormatV(szFormat, args);
		va_end(args);

		m_strAttrs += _T(" ");
		m_strAttrs += strTmp;
	}
#pragma warning(pop)

	void Set(LPCTSTR szAttrs)
	{
		if (szAttrs)
		{
			m_strAttrs.Empty();
#ifndef UNICODE
			if (!isspace(static_cast<unsigned char>(szAttrs[0])))
#else
			if (!iswspace(szAttrs[0]))
#endif
				m_strAttrs = _T(" ");
			m_strAttrs += szAttrs;
		}
	}

	operator LPCTSTR()
	{
		return m_strAttrs;
	}

};

class CStreamOnWriteStream : public IStream
{
public:
	IWriteStream *m_pWriteStream;

	CStreamOnWriteStream()
	{
		m_pWriteStream = NULL;
	}

	void Init(IWriteStream *pWriteStream)
	{
		m_pWriteStream = pWriteStream;
	}

	// IUnknown methods
	STDMETHOD(QueryInterface)(REFIID riid, void **ppv)
	{
		if (!ppv)
			return E_POINTER;

		*ppv = NULL;

		if (IsEqualGUID(riid, IID_IUnknown) ||
			IsEqualGUID(riid, IID_IStream) ||
			IsEqualGUID(riid, IID_ISequentialStream))
		{
			*ppv = (IStream *) this;
		}
		if (!*ppv)
			return E_NOINTERFACE;
		return S_OK;
	}

	ULONG __stdcall AddRef()
	{
		return 1;
	}

	ULONG __stdcall Release()
	{
		return 1;
	}

	// ISequentialStream methods
	HRESULT STDMETHODCALLTYPE Read(void * /*pDest*/, ULONG /*dwMaxLen*/, ULONG * /*pdwRead*/)
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE Write(const void *pv, ULONG cb, ULONG *pcbWritten)
	{
		ATLASSUME(m_pWriteStream);
		HRESULT hr = m_pWriteStream->WriteStream((const char *) pv, cb, pcbWritten);
		return (hr==S_OK) ? S_OK : STG_E_WRITEFAULT;
	}

	// IStream methods
	HRESULT STDMETHODCALLTYPE Seek(LARGE_INTEGER /*dlibMove*/, DWORD /*dwOrigin*/, ULARGE_INTEGER * /*plibNewPosition*/)
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE SetSize(ULARGE_INTEGER /*libNewSize*/) 
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE CopyTo(IStream * /*pstm*/, ULARGE_INTEGER /*cb*/, ULARGE_INTEGER * /*pcbRead*/, ULARGE_INTEGER * /*pcbWritten*/)
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE Commit(DWORD /*grfCommitFlags*/)
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE Revert(void)
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE LockRegion(ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/, DWORD /*dwLockType*/)
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE UnlockRegion(ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/, DWORD /*dwLockType*/)
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE Stat(STATSTG * /*pstatstg*/, DWORD /*grfStatFlag*/)
	{
		return E_NOTIMPL;
	}


	HRESULT STDMETHODCALLTYPE Clone(IStream ** /*ppstm*/)
	{
		return E_NOTIMPL;
	}
};

class CStreamFormatter
{
protected:
	CStreamOnWriteStream m_sows;
	IStream *m_pStream;
	BOOL m_bAddCRLF;
	BOOL m_bEmitUnicode;
	UINT m_nConversionCodepage;

public:
	CStreamFormatter()
	{
		m_pStream = NULL;
		m_bAddCRLF = TRUE;
		m_bEmitUnicode = FALSE;
		m_nConversionCodepage = _AtlGetConversionACP();
	}

	void Initialize(IStream *pStream, BOOL bAddCRLF=TRUE)
	{
		m_pStream = pStream;
		m_bAddCRLF = bAddCRLF;
	}

	void Initialize(IWriteStream *pWriteStream, BOOL bAddCRLF=TRUE)
	{
		m_bAddCRLF = bAddCRLF;
		m_sows.Init(pWriteStream);
		m_pStream = &m_sows;
	}

	void EmitUnicode(BOOL bEmitUnicode)
	{
		m_bEmitUnicode = bEmitUnicode;
	}

	void SetConversionCodepage(UINT nConversionCodepage)
	{
		m_nConversionCodepage = nConversionCodepage;
	}

	void AddCRLF(bool bNewVal)
	{
		m_bAddCRLF = bNewVal;
	}

	HRESULT WriteRaw(LPCTSTR szString, int nCount=-1)
	{
		ATLENSURE_RETURN(szString != NULL);
		if (!m_pStream)
			return E_FAIL;

		if (m_bEmitUnicode)
		{
#ifdef _UNICODE
			LPCWSTR sz = szString;
			if (nCount == -1)
				nCount = (int) wcslen(szString);
#else
			CA2W sz(szString, m_nConversionCodepage);
			nCount = (int) wcslen(sz);
#endif
			DWORD dwWritten;
			return m_pStream->Write(sz, (DWORD) nCount*sizeof(WCHAR), &dwWritten);
		}
		else
		{
#ifdef _UNICODE
			CW2A sz(szString, m_nConversionCodepage);
			nCount = (int) strlen(sz);
#else
			LPCSTR sz = szString;
			if (nCount == -1)
				nCount = (int) strlen(szString);
#endif
			DWORD dwWritten;
			return m_pStream->Write(sz, (DWORD) nCount, &dwWritten);
		}
	}

	HRESULT StartTag(int nTagIndex, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		if (nTagIndex < 0 || nTagIndex >= ATL_HTML_TAG_LAST)
			return E_INVALIDARG;
		if (m_bAddCRLF && (s_tags[nTagIndex].uFlags & TAGF_BLOCK))
			WriteRaw(_T("\r\n"));
		HRESULT hr = StartTag(s_tags[nTagIndex].szTagName, szContent, szAttrs);
		if (FAILED(hr))
			return hr;
		if (m_bAddCRLF && (s_tags[nTagIndex].uFlags & TAGF_BLOCK))
			WriteRaw(_T("\r\n"));
		return S_OK;
	}

	HRESULT StartTag(LPCTSTR szTag, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		HRESULT hr;
		hr = WriteRaw(_T("<"));
		if (FAILED(hr))
			return hr;
		hr = WriteRaw(szTag);
		if (FAILED(hr))
			return hr;
		hr = WriteAttributes(szAttrs);
		if (FAILED(hr))
			return hr;
		hr = WriteRaw(_T(">"));
		if (FAILED(hr))
			return hr;
		if (szContent && *szContent)
		{
			WriteRaw(szContent);
			EndTag(szTag);
		}
		return S_OK;
	}

	HRESULT EndTag(int nTagIndex)
	{
		if (nTagIndex < 0 || nTagIndex >= ATL_HTML_TAG_LAST)
			return E_INVALIDARG;
		if (m_bAddCRLF && (s_tags[nTagIndex].uFlags & TAGF_BLOCK))
			WriteRaw(_T("\r\n"));
		HRESULT hr = EndTag(s_tags[nTagIndex].szTagName);
		if (FAILED(hr))
			return hr;
		if (m_bAddCRLF && (s_tags[nTagIndex].uFlags & TAGF_BLOCK))
			WriteRaw(_T("\r\n"));
		return S_OK;
	}

	HRESULT EndTag(LPCTSTR szTag)
	{
		HRESULT hr = WriteRaw(_T("</"));
		if (FAILED(hr))
			return hr;
		hr = WriteRaw(szTag);
		if (FAILED(hr))
			return hr;
		return WriteRaw(_T(">"));
	}

	HRESULT WriteAttributes(LPCTSTR szAttrs)
	{
		if (szAttrs && szAttrs[0])
		{
#ifndef UNICODE
			if (!isspace(static_cast<unsigned char>(szAttrs[0])))
#else
			if (!iswspace(szAttrs[0]))
#endif
				WriteRaw(_T(" "));
			return WriteRaw(szAttrs);
		}

		return S_OK;
	}

#ifndef _WIN32_WCE
#pragma warning(push)
#pragma warning(disable : 4793)
	HRESULT WriteFormatted(LPCTSTR szFormat, ...)
	{
		ATLASSERT(szFormat != NULL);
		if (!m_pStream)
			return E_FAIL;

		va_list args;
		va_start(args, szFormat);


		TCHAR buffFixed[1024];
		CTempBuffer<TCHAR> buffHeap;
		TCHAR *szTemp = buffFixed;
#if _SECURE_ATL
		int nCount = _vstprintf_s((LPTSTR)szTemp, _countof(buffFixed), szFormat, args);
#else
		int nCount = _vsntprintf((LPTSTR)szTemp, 1024, szFormat, args);
#endif
		if (nCount < 0)
		{
			// we'll have to dynamically allocate the buffer
			nCount = _vsctprintf(szFormat, args);
			szTemp = NULL;
			ATLTRY(szTemp = buffHeap.Allocate(nCount + 1));
			if (!szTemp)
				return E_OUTOFMEMORY;
#if _SECURE_ATL
			nCount = _vstprintf_s(szTemp, nCount+1, szFormat, args);
#else
			nCount = _vsntprintf(szTemp, nCount+1, szFormat, args);
#endif
		}

		va_end(args);

		if (nCount > 0)
			return WriteRaw(szTemp, (DWORD) nCount);
		return E_UNEXPECTED;
	}
#pragma warning(pop)
#endif // _WIN32_WCE
};

template <typename TData, int nMax=64>
class CSimpleStack
{
public:
	int m_nTop;
	TData m_Data[nMax];

	CSimpleStack()
	{
		m_nTop = -1;
	}

	bool IsEmpty()
	{
		return (m_nTop == -1);
	}

	bool Push(const TData *pData)
	{
		if (m_nTop >= nMax)
			return false;

		m_nTop++;

		m_Data[m_nTop] = *pData;
		return true;
	}

	bool Pop(TData *pData)
	{
		if (m_nTop < 0)
			return false;

		*pData = m_Data[m_nTop];
		m_nTop--;
		return true;
	}
};


struct HTML_SCHEME
{
	CString strBgColor;
	CString strLinkColor;
	CString strVLinkColor;
	CString strALinkColor;
	CString strBackground;
	int nTopMargin;
	int nLeftMargin;

	CString strTdBgColor;
	CString strTableBgColor;
	CString strTrBgColor;

	HTML_SCHEME()
	{
		nTopMargin = -1;
		nLeftMargin = -1;
	}
};

template <class T>
class CHtmlGenBase : public CStreamFormatter
{
public:
	T* GetOuter()
	{
		return static_cast<T*>(this);
	}

	enum ATL_HTML_FORM_METHOD { ATL_HTML_FORM_METHOD_NONE=0, ATL_HTML_FORM_METHOD_GET, ATL_HTML_FORM_METHOD_POST, ATL_HTML_FORM_METHOD_MULTIPART };

	CHtmlGenBase()
	{
		m_nWidthPercent = -1;
		m_nHeightPercent = -1;
		m_nFormMethod = ATL_HTML_FORM_METHOD_NONE;
		m_pScheme = NULL;
	}

	void SetScheme(HTML_SCHEME *pScheme)
	{
		m_pScheme = pScheme;
	}

	HRESULT body(LPCTSTR szBgColor=NULL, LPCTSTR szBackground=NULL, LPCTSTR szTopMargin=NULL, LPCTSTR szLeftMargin=NULL,
		LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szBgColor && *szBgColor)
			Attrs.Add(_T("bgColor"), szBgColor);
		else if (m_pScheme && m_pScheme->strBgColor.GetLength())
			Attrs.Add(_T("bgColor"), m_pScheme->strBgColor);

		if (szBackground && *szBackground)
			Attrs.Add(_T("background"), szBackground);
		else if (m_pScheme && m_pScheme->strBackground.GetLength())
			Attrs.Add(_T("background"), m_pScheme->strBackground);

		if (m_pScheme && m_pScheme->strLinkColor.GetLength())
			Attrs.Add(_T("link"), m_pScheme->strLinkColor);

		if (m_pScheme && m_pScheme->strALinkColor.GetLength())
			Attrs.Add(_T("alink"), m_pScheme->strALinkColor);

		if (m_pScheme && m_pScheme->strVLinkColor.GetLength())
			Attrs.Add(_T("vlink"), m_pScheme->strVLinkColor);

		if (szTopMargin && *szTopMargin)
			Attrs.Add(_T("topmargin"), szTopMargin);
		else if (m_pScheme && m_pScheme->nTopMargin != -1)
			Attrs.AddFormat(_T("topmargin=\"%d\""), m_pScheme->nTopMargin);

		if (szLeftMargin && *szLeftMargin)
			Attrs.Add(_T("leftmargin"), szLeftMargin);
		else if (m_pScheme && m_pScheme->nLeftMargin != -1)
			Attrs.AddFormat(_T("leftmargin=\"%d\""), m_pScheme->nLeftMargin);

		return GetOuter()->StartTag(ATL_HTML_TAG_BODY, NULL, Attrs);
	}

	HRESULT bodyEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_BODY);
	}

	HRESULT a(LPCTSTR szHref, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (m_strState.GetLength()==0)
		{
			if (szHref && *szHref)
				Attrs.Add(_T("href"), szHref);
			return GetOuter()->StartTag(ATL_HTML_TAG_A, szContent, Attrs);
		}

		const TCHAR *szQuestion = NULL;
		if(szHref)
			szQuestion = _tcschr(szHref, '?');

		CString strHref = szHref;
		if (!szQuestion)
			strHref.Append("?");
		else
			strHref.Append("&");

		strHref += m_strState;

		if (szHref && *szHref)
			Attrs.Add(_T("href"), strHref);

		return GetOuter()->StartTag(ATL_HTML_TAG_A, szContent, Attrs);
	}

	HRESULT aEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_A);
	}

	HRESULT b(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_B, szContent, szAttrs);
	}

	HRESULT bEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_B);
	}

	HRESULT i(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_I, szContent, szAttrs);
	}

	HRESULT iEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_I);
	}

	HRESULT u(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_U, szContent, szAttrs);
	}

	HRESULT uEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_U);
	}

	HRESULT font(LPCTSTR szFace, LPCTSTR szSize=NULL, LPCTSTR szColor=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);
		if (szFace && *szFace)
			Attrs.Add(_T("face"), szFace);
		if (szSize && *szSize)
			Attrs.Add(_T("size"), szSize);
		if (szColor && *szColor)
			Attrs.Add(_T("color"), szColor);
		return GetOuter()->StartTag(ATL_HTML_TAG_FONT, NULL, Attrs);
	}

	HRESULT font(COLORREF clrColor, LPCTSTR szAttrs=NULL)
	{
		TCHAR szColor[8];
#if _SECURE_ATL && !defined(_WIN32_WCE)
		_stprintf_s(szColor, _countof(szColor), _T("#%02x%02x%02x"), GetRValue(clrColor), 
			GetGValue(clrColor), GetBValue(clrColor));
#else
		_stprintf(szColor, _T("#%02x%02x%02x"), GetRValue(clrColor), GetGValue(clrColor),
			GetBValue(clrColor));
#endif
		return GetOuter()->font(NULL, NULL, szColor, szAttrs);
	}

	HRESULT fontEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_FONT);
	}

	HRESULT img(LPCTSTR szSrc, LPCTSTR szAttrs=NULL)
	{
		ATLASSERT(szSrc && *szSrc);

		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		Attrs.Add(_T("src"), szSrc);

		return GetOuter()->StartTag(ATL_HTML_TAG_IMG, NULL, Attrs);
	}

	HRESULT br(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_BR, NULL, szAttrs);
	}

	HRESULT hr(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_HR, NULL, szAttrs);
	}

	HRESULT div(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_DIV, szContent, szAttrs);
	}

	HRESULT divEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_DIV);
	}

	HRESULT blockquote(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_BLOCKQUOTE, szContent, szAttrs);
	}

	HRESULT blockquoteEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_BLOCKQUOTE);
	}

	HRESULT address(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_ADDRESS, szContent, szAttrs);
	}

	HRESULT addressEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_ADDRESS);
	}

	HRESULT p(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_P, szContent, szAttrs);
	}

	HRESULT pEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_P);
	}

	HRESULT h(int nLevel=1, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		if (nLevel < 1 || nLevel > 6)
			return E_INVALIDARG;
		return GetOuter()->StartTag(ATL_HTML_TAG_H1+nLevel-1, szContent, szAttrs);
	}

	HRESULT hEnd(int nLevel=1)
	{
		if (nLevel < 1 || nLevel > 6)
			return E_INVALIDARG;
		return GetOuter()->EndTag(ATL_HTML_TAG_H1+nLevel-1);
	}

	HRESULT pre(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_PRE, szContent, szAttrs);
	}

	HRESULT preEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_PRE);
	}

	HRESULT q(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_Q, szContent, szAttrs);
	}

	HRESULT qEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_Q);
	}

	HRESULT sub(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_SUB, szContent, szAttrs);
	}

	HRESULT subEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_SUB);
	}

	HRESULT sup(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_SUP, szContent, szAttrs);
	}

	HRESULT supEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_SUP);
	}

	HRESULT ins(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_INS, szContent, szAttrs);
	}

	HRESULT insEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_INS);
	}

	HRESULT del(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_DEL, szContent, szAttrs);
	}

	HRESULT delEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_DEL);
	}


	HRESULT em(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_EM, szContent, szAttrs);
	}

	HRESULT emEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_EM);
	}

	HRESULT strong(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_STRONG, szContent, szAttrs);
	}

	HRESULT strongEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_STRONG);
	}

	HRESULT dfn(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_DFN, szContent, szAttrs);
	}

	HRESULT dfnEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_DFN);
	}

	HRESULT code(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_CODE, szContent, szAttrs);
	}

	HRESULT codeEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_CODE);
	}

	HRESULT samp(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_SAMP, szContent, szAttrs);
	}

	HRESULT sampEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_SAMP);
	}

	HRESULT kbd(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_KBD, szContent, szAttrs);
	}

	HRESULT kbdEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_KBD);
	}

	HRESULT var(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_VAR, szContent, szAttrs);
	}

	HRESULT varEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_VAR);
	}

	HRESULT cite(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_CITE, szContent, szAttrs);
	}

	HRESULT citeEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_CITE);
	}

	HRESULT abbr(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_ABBR, szContent, szAttrs);
	}

	HRESULT abbrEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_ABBR);
	}

	HRESULT acronym(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_ACRONYM, szContent, szAttrs);
	}

	HRESULT acronymEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_ACRONYM);
	}


	HRESULT ol(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_OL, NULL, szAttrs);
	}

	HRESULT ul(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_UL, NULL, szAttrs);
	}

	HRESULT olEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_OL);
	}

	HRESULT ulEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_UL);
	}

	HRESULT li(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_LI, szContent, szAttrs);
	}

	HRESULT liEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_LI);
	}

	HRESULT dl(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_DL, szContent, szAttrs);
	}

	HRESULT dlEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_DL);
	}

	HRESULT dt(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_DT, szContent, szAttrs);
	}

	HRESULT dtEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_DT);
	}

	HRESULT dd(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_DD, szContent, szAttrs);
	}

	HRESULT ddEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_DD);
	}

	void SetSizePercent(int nWidth, int nHeight)
	{
		m_nWidthPercent = nWidth;
		m_nHeightPercent = nHeight;
	}

	HRESULT table(int nBorderWidth=0, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		m_RowStack.Push(&m_tableState);
		m_tableState.Clear();

		Attrs.AddFormat(_T("border=\"%d\""), nBorderWidth);

		if (m_nWidthPercent != -1)
			Attrs.AddFormat(_T("width=\"%d%%\""), m_nWidthPercent);
		if (m_nHeightPercent != -1)
			Attrs.AddFormat(_T("height=\"%d%%\""), m_nHeightPercent);

		if (m_pScheme && m_pScheme->strTableBgColor.GetLength())
			Attrs.Add(_T("bgcolor"), m_pScheme->strTableBgColor);

		m_nWidthPercent = -1;
		m_nHeightPercent = -1;
		return GetOuter()->StartTag(ATL_HTML_TAG_TABLE, NULL, Attrs);
	}

	HRESULT tableEnd()
	{
		if (m_tableState.m_bRowOpen)
			GetOuter()->trEnd();
		m_RowStack.Pop(&m_tableState);
		return GetOuter()->EndTag(ATL_HTML_TAG_TABLE);
	}

	HRESULT tr(LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (m_RowStack.IsEmpty())
			GetOuter()->table();
		if (m_tableState.m_bRowOpen)
			GetOuter()->trEnd();
		m_tableState.m_bRowOpen = true;

		if (m_pScheme && m_pScheme->strTrBgColor.GetLength())
			Attrs.Add(_T("bgcolor"), m_pScheme->strTrBgColor);
		return GetOuter()->StartTag(ATL_HTML_TAG_TR, NULL, Attrs);
	}

	HRESULT td(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (!m_tableState.m_bRowOpen)
			GetOuter()->tr();
		m_tableState.m_bDataOpen = true;
		if (m_pScheme && m_pScheme->strTdBgColor.GetLength())
			Attrs.Add(_T("bgColor"), m_pScheme->strTdBgColor);

		HRESULT hr = GetOuter()->StartTag(ATL_HTML_TAG_TD, szContent, Attrs);
		if (FAILED(hr))
			return hr;
		if (szContent)
			m_tableState.m_bDataOpen = false;
		return S_OK;
	}

	HRESULT tdEnd()
	{
		if (!m_tableState.m_bDataOpen)
			return S_OK;
		m_tableState.m_bDataOpen = false;
		return GetOuter()->EndTag(ATL_HTML_TAG_TD);
	}

	HRESULT trEnd()
	{
		if (!m_tableState.m_bRowOpen)
			return S_OK;
		if (m_tableState.m_bDataOpen)
			GetOuter()->tdEnd();
		m_tableState.m_bRowOpen = false;
		return GetOuter()->EndTag(ATL_HTML_TAG_TR);
	}

	HRESULT form(LPCTSTR szAction, ATL_HTML_FORM_METHOD nMethod=ATL_HTML_FORM_METHOD_GET, LPCTSTR szAttrs=NULL)
	{
		static const LPCTSTR s_szFormMethods[] = { NULL, _T("get"), _T("post"), _T("multipart-www-url-encoded") };
		return GetOuter()->form(szAction, s_szFormMethods[nMethod], szAttrs);
	}

	HRESULT form(LPCTSTR szAction, LPCTSTR szMethod, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szAction && *szAction)
			Attrs.Add(_T("action"), szAction);
		if (szMethod && *szMethod)
			Attrs.Add(_T("method"), szMethod);

		return GetOuter()->StartTag(ATL_HTML_TAG_FORM, NULL, Attrs);
	}

	HRESULT input(LPCTSTR szType, LPCTSTR szName, LPCTSTR szValue, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szType && *szType)
			Attrs.Add(_T("type"), szType);
		if (szName && *szName)
			Attrs.Add(_T("name"), szName);
		if (szValue && *szValue)
			Attrs.Add(_T("value"), szValue);
		return GetOuter()->StartTag(ATL_HTML_TAG_INPUT, NULL, Attrs);
	}

	HRESULT submit(LPCTSTR szValue=NULL, LPCTSTR szName=NULL, LPCTSTR szAttrs=NULL)
	{
		return input(_T("submit"), szName, szValue, szAttrs);
	}

	HRESULT textarea(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_TEXTAREA, szContent, szAttrs);
	}

	HRESULT textareaEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_TEXTAREA);
	}

	HRESULT formEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_FORM);
	}


	HRESULT select(LPCTSTR szName, BOOL bMultiple=FALSE, LPCTSTR szAttrs=NULL)
	{
		ATLASSERT(szName && *szName);

		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		Attrs.Add(_T("name"), szName);
		if (bMultiple)
			Attrs.Add(_T("multiple"), NULL);
		return GetOuter()->StartTag(ATL_HTML_TAG_SELECT, NULL, Attrs);
	}

	HRESULT option(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_OPTION, szContent, szAttrs);
	}

	HRESULT optionEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_OPTION);
	}

	HRESULT selectEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_SELECT);
	}


	HRESULT head(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_HEAD, NULL, szAttrs);
	}

	HRESULT headEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_HEAD);
	}

	HRESULT html(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_HTML, NULL, szAttrs);
	}

	HRESULT htmlEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_HTML);
	}

	HRESULT map(LPCTSTR szName, LPCTSTR szAttrs=NULL)
	{
		ATLASSERT(szName && *szName);

		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		Attrs.Add(_T("name"), szName);
		return GetOuter()->StartTag(ATL_HTML_TAG_MAP, NULL, Attrs);
	}

	HRESULT mapEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_MAP);
	}

	HRESULT area(LPCTSTR szAlt, LPCTSTR szHref=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szAlt && *szAlt)
			Attrs.Add(_T("alt"), szAlt);
		if (szHref && *szHref)
			Attrs.Add(_T("href"), szHref);
		return GetOuter()->StartTag(ATL_HTML_TAG_AREA, NULL, Attrs);
	}

	HRESULT base(LPCTSTR szHref, LPCTSTR szAttrs=NULL)
	{
		ATLASSERT(szHref && *szHref);

		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		Attrs.Add(_T("href"), szHref);
		return GetOuter()->StartTag(ATL_HTML_TAG_BASE, NULL, Attrs);
	}

	HRESULT bdo(LPCTSTR szDir, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		ATLASSERT(szDir&& *szDir);

		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		Attrs.Add(_T("dir"), szDir);
		return GetOuter()->StartTag(ATL_HTML_TAG_BDO, szContent, Attrs);
	}

	HRESULT bdoEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_BDO);
	}

	HRESULT big(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_BIG, szContent, szAttrs);
	}

	HRESULT bigEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_BIG);
	}

	HRESULT button(LPCTSTR szName=NULL, LPCTSTR szValue=NULL, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szName && *szName)
			Attrs.Add(_T("name"), szName);
		if (szValue && *szValue)
			Attrs.Add(_T("value"), szValue);
		return GetOuter()->StartTag(ATL_HTML_TAG_BUTTON, szContent, Attrs);
	}

	HRESULT buttonEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_BUTTON);
	}

	HRESULT iframe(LPCTSTR szSrc=NULL, LPCTSTR szWidth=NULL, LPCTSTR szHeight=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szSrc && *szSrc)
			Attrs.Add(_T("src"), szSrc);
		if (szWidth && *szWidth)
			Attrs.Add(_T("width"), szWidth);
		if (szHeight && *szHeight)
			Attrs.Add(_T("height"), szHeight);
		return GetOuter()->StartTag(ATL_HTML_TAG_IFRAME, NULL, Attrs);
	}

	HRESULT iframeEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_IFRAME);
	}

	HRESULT label(LPCTSTR szFor=NULL, LPCTSTR szAccessKey=NULL, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szFor && *szFor)
			Attrs.Add(_T("for"), szFor);
		if (szAccessKey && *szAccessKey)
			Attrs.Add(_T("accesskey"), szAccessKey);
		return GetOuter()->StartTag(ATL_HTML_TAG_LABEL, szContent, Attrs);
	}

	HRESULT labelEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_LABEL);
	}

	HRESULT link(LPCTSTR szRel=NULL, LPCTSTR szHref=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szRel && *szRel)
			Attrs.Add(_T("rel"), szRel);
		if (szHref && *szHref)
			Attrs.Add(_T("href"), szHref);
		return GetOuter()->StartTag(ATL_HTML_TAG_LINK, NULL, Attrs);
	}

	HRESULT meta(LPCTSTR szName=NULL, LPCTSTR szContent=NULL, LPCTSTR szHttpEquiv=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (szName && *szName)
			Attrs.Add(_T("name"), szName);
		if (szContent && *szContent)
			Attrs.Add(_T("content"), szContent);
		if (szHttpEquiv && *szHttpEquiv)
			Attrs.Add(_T("http-equiv"), szHttpEquiv);
		return GetOuter()->StartTag(ATL_HTML_TAG_META, NULL, Attrs);
	}

	HRESULT noframes(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_NOFRAMES, szContent, szAttrs);
	}

	HRESULT noframesEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_NOFRAMES);
	}

	HRESULT noscript(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_NOSCRIPT, szContent, szAttrs);
	}

	HRESULT noscriptEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_NOSCRIPT);
	}

	HRESULT col(int nSpan=1, LPCTSTR szWidth=NULL, LPCTSTR szHeight=NULL, LPCTSTR szVAlign=NULL,
		LPCTSTR szHAlign=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);


		if (nSpan != 1)
			Attrs.AddFormat(_T("span"), _T("\"%d\""), nSpan);
		if (szWidth && *szWidth)
			Attrs.Add(_T("width"), szWidth);
		if (szHeight && *szHeight)
			Attrs.Add(_T("height"), szHeight);
		if (szVAlign && *szVAlign)
			Attrs.Add(_T("valign"), szVAlign);
		if (szHAlign && *szHAlign)
			Attrs.Add(_T("align"), szHAlign);
		return GetOuter()->StartTag(ATL_HTML_TAG_COL, NULL, Attrs);
	}

	HRESULT colgroup(int nSpan=1, LPCTSTR szWidth=NULL, LPCTSTR szHeight=NULL, LPCTSTR szVAlign=NULL,
		LPCTSTR szHAlign=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		if (nSpan != 1)
			Attrs.AddFormat(_T("span"), _T("\"%d\""), nSpan);
		if (szWidth && *szWidth)
			Attrs.Add(_T("width"), szWidth);
		if (szHeight && *szHeight)
			Attrs.Add(_T("height"), szHeight);
		if (szVAlign && *szVAlign)
			Attrs.Add(_T("valign"), szVAlign);
		if (szHAlign && *szHAlign)
			Attrs.Add(_T("align"), szHAlign);
		return GetOuter()->StartTag(ATL_HTML_TAG_COL, NULL, Attrs);
	}

	HRESULT colgroupEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_COLGROUP);
	}

	HRESULT fieldset(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_FIELDSET, NULL, szAttrs);
	}

	HRESULT fieldsetEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_FIELDSET);
	}

	HRESULT legend(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_LEGEND, szContent, szAttrs);
	}

	HRESULT legendEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_LEGEND);
	}

	HRESULT tbody(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_TBODY, NULL, szAttrs);
	}

	HRESULT tbodyEnd()
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_TBODY);
	}

	HRESULT tfoot(LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_TFOOT, NULL, szAttrs);
	}

	HRESULT tfootEnd()
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_TFOOT);
	}

	HRESULT th(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		if (!m_tableState.m_bRowOpen)
			GetOuter()->tr();
		m_tableState.m_bDataOpen = true;
		return GetOuter()->StartTag(ATL_HTML_TAG_TH, szContent, szAttrs);
	}

	HRESULT thEnd()
	{
		ATLASSUME(m_tableState.m_bDataOpen);
		m_tableState.m_bDataOpen = false;
		return GetOuter()->EndTag(ATL_HTML_TAG_TH);
	}

	HRESULT title(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_TITLE, szContent, szAttrs);
	}

	HRESULT titleEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_TITLE);
	}

	HRESULT tt(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_TT, szContent, szAttrs);
	}

	HRESULT ttEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_TT);
	}

	// unfortunately, we can't use small since it is defined as char
	// in rpcndr.h!
	HRESULT _small(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_SMALL, szContent, szAttrs);
	}

	HRESULT _smallEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_SMALL);
	}

	HRESULT span(LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		return GetOuter()->StartTag(ATL_HTML_TAG_SPAN, szContent, szAttrs);
	}

	HRESULT spanEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_SPAN);
	}

	HRESULT object(LPCTSTR szClassId, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);
		if (szClassId && *szClassId)
			Attrs.Add(_T("classid"), szClassId);
		return GetOuter()->StartTag(ATL_HTML_TAG_OBJECT, szContent, Attrs);
	}

	HRESULT object(REFCLSID rclsid, LPCTSTR szContent=NULL, LPCTSTR szAttrs=NULL)
	{
		USES_CONVERSION_EX;
		OLECHAR szClsid[64];
		CString strClassId;
		int i = StringFromGUID2(rclsid, szClsid, 64);
		if (!i)
			return E_FAIL;
		szClsid[i-2] = 0; // don't want curly braces
		strClassId.Format(_T("clsid:%s"), OLE2T_EX_DEF(szClsid+1));
		return object(strClassId, szContent, szAttrs);
	}

	HRESULT objectEnd()
	{
		return GetOuter()->EndTag(ATL_HTML_TAG_OBJECT);
	}

	HRESULT param(LPCTSTR szName, LPCTSTR szValue, LPCTSTR szAttrs=NULL)
	{
		ATLASSERT(szName && *szName);

		AtlHtmlAttrs Attrs;
		Attrs.Set(szAttrs);

		Attrs.Add(_T("name"), szName);
		if (szValue && *szValue)
			Attrs.Add(_T("value"), szValue);
		return GetOuter()->StartTag(ATL_HTML_TAG_PARAM, NULL, Attrs);
	}

private:
	CString m_strState;
	HTML_SCHEME *m_pScheme;

	struct TableState
	{
		TableState() : m_bRowOpen(false), m_bDataOpen(false)
		{

		}

		void Clear()
		{
			m_bRowOpen = false;
			m_bDataOpen = false;
		}

		bool m_bRowOpen;
		bool m_bDataOpen;
	};

	ATL_HTML_FORM_METHOD m_nFormMethod;

	TableState m_tableState;
	CSimpleStack<TableState> m_RowStack;

	int m_nWidthPercent;
	int m_nHeightPercent;
};

class CHtmlGen : public CHtmlGenBase<CHtmlGen>
{
public:
};

} // namespace ATL
#pragma pack(pop)

#endif // __ATLHTML_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlhttp.inl ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLHTTP_INL__
#define __ATLHTTP_INL__

#ifndef _WIN32_WCE
#include <errno.h>
#endif // _WIN32_WCE

#pragma warning(push)
#pragma warning(disable: 4061) // enumerate 'enum value' in switch of enum 'enum type' is not explicitly handled by a case label
#pragma warning(disable: 4062) // enumerate 'enum value' in switch of enum 'enum type' is not handled

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////////
//
// CAtlHttpClient
// Implementation of CAtlHttpClient member functions
//
/////////////////////////////////////////////////////////////////////////////////
template <class TSocketClass>
inline CAtlHttpClientT<TSocketClass>::CAtlHttpClientT() throw()
{
	InitializeObject();
}

// Sets this object to a known state.
template <class TSocketClass>
inline void CAtlHttpClientT<TSocketClass>::InitializeObject() throw()
{
	Close(); // will close the socket if it's already open
	ResetRequest();
	SetSilentLogonOk(FALSE);
}

template <class TSocketClass>
inline void CAtlHttpClientT<TSocketClass>::ResetRequest() throw()
{
	// reset all data that has to do with the current request
	m_HeaderMap.RemoveAll();
	m_current.Empty();
	m_urlCurrent.Clear();
	m_strMethod.Empty();
	m_nStatus = ATL_INVALID_STATUS;
	m_dwBodyLen = 0;
	m_dwHeaderLen = 0;
	m_dwHeaderStart = 0;
	m_pCurrent = NULL;
	m_pNavData = NULL;
	m_LastResponseParseError = RR_NOT_READ;
	m_pEnd = NULL;

}


// Use this function to retrieve an entity from a server via an HTTP
// request. This function will either request a connection from the
// server specified in the szURL parameter or request a connection from
// the proxy server. If a proxy server is to be used, you must call
// SetProxy prior to calling this function to specify the proxy server
// being used. Once the connection is established, an HTTP request 
// is built and sent to the HTTP server. An attempt to read the HTTP
// response is then made. If the response is successfully read, the
// response will be parsed and stored in this class instance. The 
// headers can be parsed via the LookupHeader function and the body
// of the response can be retrieved using the GetBody function. You
// can also retrieve the contents of the entire response by calling
// GetResponse.
template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::Navigate(

				LPCTSTR szUrl,
				ATL_NAVIGATE_DATA *pNavData
			) throw(...)
{
	if (!szUrl || *szUrl == _T('\0'))
		return false;

	CUrl url;
	TCHAR szTmp[ATL_URL_MAX_URL_LENGTH];
	if(!AtlEscapeUrl(szUrl,szTmp,0,ATL_URL_MAX_URL_LENGTH-1,ATL_URL_BROWSER_MODE))
		return false;

	if(!url.CrackUrl(szTmp))
		return false;

	// Navigate
	return Navigate(&url, pNavData);
}

template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::Navigate(
			LPCTSTR szServer,
			LPCTSTR szPath, 
			ATL_NAVIGATE_DATA *pNavData
			) throw(...)
{
	// Create a URL
	if (!szServer || *szServer == _T('\0'))
		return false;
	if (!szPath || *szPath == _T('\0'))
		return false;
	CUrl url;
	url.SetScheme(ATL_URL_SCHEME_HTTP);
	url.SetHostName(szServer);
	url.SetUrlPath(szPath);
	if (pNavData)
		url.SetPortNumber(pNavData->nPort); 
	else
		url.SetPortNumber(ATL_URL_DEFAULT_HTTP_PORT);

	TCHAR szUrl[ATL_URL_MAX_URL_LENGTH];
	DWORD dwMaxLen = ATL_URL_MAX_URL_LENGTH;
	if (!url.CreateUrl(szUrl, &dwMaxLen))
		return false;

	// Navigate
	return Navigate(szUrl, pNavData);
}

template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::Navigate(
			const CUrl *pUrl,
			ATL_NAVIGATE_DATA *pData
			)  throw(...)
{
	bool bRet = false;
	if (!pUrl)
		return false;

	ResetRequest();
	
	CAtlNavigateData default_nav_data;
	if (!pData)
		m_pNavData = &default_nav_data;
	else
		m_pNavData = pData;

	ATLASSUME(m_pNavData);

	_ATLTRY
	{
		m_strMethod = m_pNavData->szMethod;
	}
	_ATLCATCHALL()
	{
		return false;
	}

	SetSocketTimeout(m_pNavData->dwTimeout);

	// set m_urlCurrent
	if (!SetDefaultUrl(pUrl, m_pNavData->nPort))
		return false;
	DWORD dwSent = 0;
	CString strRequest;
	CString strExtraInfo;

	if (!BuildRequest(&strRequest, 
					m_pNavData->szMethod,
					m_pNavData->szExtraHeaders))
	{
		return false;
	}

	
	if (!ConnectSocket())
		return false;

	LPCTSTR szTRequest = strRequest;
	CT2CA strARequest(szTRequest);
	DWORD dwRequestLen = (DWORD)strlen(strARequest);
	DWORD dwAvailable = dwRequestLen + m_pNavData->dwDataLen;

	if (m_pNavData->dwFlags & ATL_HTTP_FLAG_SEND_CALLBACK)
	{
		dwSent = WriteWithCallback(strARequest, dwRequestLen);
	}
	else if (!m_pNavData->pData)
		dwSent = WriteWithNoData(strARequest, dwRequestLen);
	else if (m_pNavData->pData && (m_pNavData->dwFlags & ATL_HTTP_FLAG_SEND_BLOCKS))
	{
		dwSent = WriteWithChunks(strARequest, dwRequestLen);
	}
	else if(m_pNavData->pData)
	{
		dwSent = WriteWithData(strARequest, dwRequestLen);
	}


	// make sure everything was sent
	if (dwSent == dwAvailable)
	{
		// Read the response
		if (RR_OK == ReadHttpResponse())
		{
			// if navigation isn't complete, try to complete
			// it based on the status code and flags
			if ((m_pNavData->dwFlags & ATL_HTTP_FLAG_PROCESS_RESULT)&&
				!ProcessStatus(m_pNavData->dwFlags))
			{
				bRet = false;
			}
			else
				bRet = true;
		}
		else
			bRet = false;
	}

	if (!bRet)
		Close(); // some kind of failure happened, close the socket.

	m_pNavData = NULL;
	return bRet;
}

template <class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::WriteWithNoData(LPCSTR pRequest, DWORD dwRequestLen)
{
	ATLASSUME(m_pNavData);
	WSABUF Buffer;
	Buffer.buf = (char*)pRequest;
	Buffer.len = (int)dwRequestLen;
	DWORD dwWritten = 0;
	Write(&Buffer, 1, &dwWritten);
	if (m_pNavData->pfnSendStatusCallback)
		m_pNavData->pfnSendStatusCallback(dwWritten, m_pNavData->m_lParamSend);
	return dwWritten;
}

// The entity body will be retrieved from the client by calling their
// callback function.
template <class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::WriteWithCallback(LPCSTR pRequest, DWORD dwRequestLen)
{
	ATLASSUME(m_pNavData);
	if (!(m_pNavData->pfnChunkCallback &&
		(m_pNavData->dwFlags & ATL_HTTP_FLAG_SEND_CALLBACK)))
		return 0; // error, must have flag set and callback function

	// write the request
	DWORD dwTotalWritten = 0;
	WSABUF Buffer;
	Buffer.buf = (char*)pRequest;
	Buffer.len = (int)dwRequestLen;
	DWORD dwWritten = 0;
	Write(&Buffer, 1, &dwWritten);
	if (m_pNavData->pfnSendStatusCallback)
		if (!m_pNavData->pfnSendStatusCallback(dwWritten, m_pNavData->m_lParamSend))
			return 0;
	if (!dwWritten)
		return 0; // failure
	dwTotalWritten += dwWritten;

	// start writing data;
	while (m_pNavData->pfnChunkCallback((BYTE**)&Buffer.buf, (DWORD*)&Buffer.len, m_pNavData->m_lParamChunkCB) &&
			Buffer.len > 0 &&
			Buffer.buf != NULL)
	{
		Write(&Buffer, 1, &dwWritten);
		if (dwWritten != Buffer.len)
			return 0;
		if (m_pNavData->pfnSendStatusCallback)
			if (!m_pNavData->pfnSendStatusCallback(dwWritten, m_pNavData->m_lParamSend))
				return 0;
		dwTotalWritten += dwWritten;
	}
	return dwTotalWritten;
}

template <class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::WriteWithChunks(LPCSTR pRequest, DWORD dwRequestLen)
{
	ATLASSUME(m_pNavData);
	if (!(m_pNavData->dwSendBlockSize > 0 && (m_pNavData->dwFlags & ATL_HTTP_FLAG_SEND_BLOCKS)))
		return 0; // error, must have flag set and callback function

	// write the request
	DWORD dwTotalWritten = 0;
	WSABUF Buffer;
	Buffer.buf = (char*)pRequest;
	Buffer.len = (int)dwRequestLen;
	DWORD dwWritten = 0;
	Write(&Buffer, 1, &dwWritten);
	if (m_pNavData->pfnSendStatusCallback)
		if (!m_pNavData->pfnSendStatusCallback(dwWritten, m_pNavData->m_lParamSend))
			return 0;
	if (!dwWritten)
		return 0; // failure
	dwTotalWritten += dwWritten;

	// start writing data;
	DWORD dwDataWritten = 0;
	DWORD dwDataLeft = m_pNavData->dwDataLen;
	while (dwDataLeft)
	{
		Buffer.buf = (char*)(m_pNavData->pData + dwDataWritten);
		Buffer.len = __min(dwDataLeft, m_pNavData->dwSendBlockSize);
		Write(&Buffer, 1, &dwWritten);
		if (dwWritten != Buffer.len)
			return 0;
		if (m_pNavData->pfnSendStatusCallback)
			if (!m_pNavData->pfnSendStatusCallback(dwWritten, m_pNavData->m_lParamSend))
				return false;
		dwTotalWritten += dwWritten;
		dwDataWritten += dwWritten;
		dwDataLeft -= dwWritten;
	}
	return dwTotalWritten;
}

template <class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::WriteWithData(LPCSTR pRequest, DWORD dwRequestLen)
{
	WSABUF Buffers[2];
	Buffers[0].buf = (char*)pRequest;
	Buffers[0].len = dwRequestLen;
	Buffers[1].buf = (char*)m_pNavData->pData;
	Buffers[1].len = m_pNavData->dwDataLen;

	DWORD dwWritten = 0;
	Write(Buffers, 2, &dwWritten);
	if (m_pNavData->pfnSendStatusCallback)
		m_pNavData->pfnSendStatusCallback(dwWritten, m_pNavData->m_lParamSend);

	return dwWritten;
}

template <class TSocketClass>
bool CAtlHttpClientT<TSocketClass>::NavigateChunked(
				LPCTSTR szServer,
				LPCTSTR szPath,
				ATL_NAVIGATE_DATA *pNavData
				) throw()
{
	// Create a URL
	if (!szServer || *szServer == _T('\0'))
		return false;
	if (!szPath || *szPath == _T('\0'))
		return false;

	if (!pNavData)
	{
		// To do chunked navigation you must specify an
		// ATL_NAVIGATE_DATA structure that has the pfnChunkCallback
		// member filled out.
		ATLASSERT(FALSE);
		return false;
	}
	CUrl url;
	url.SetScheme(ATL_URL_SCHEME_HTTP);
	url.SetHostName(szServer);
	url.SetUrlPath(szPath);
	if (pNavData)
		url.SetPortNumber(pNavData->nPort); 
	else
		url.SetPortNumber(ATL_URL_DEFAULT_HTTP_PORT);

	TCHAR szUrl[ATL_URL_MAX_URL_LENGTH];
	DWORD dwMaxLen = ATL_URL_MAX_URL_LENGTH;
	if (!url.CreateUrl(szUrl, &dwMaxLen))
		return false;

	// Navigate
	return NavigateChunked(szUrl, pNavData);
}

template <class TSocketClass>
bool CAtlHttpClientT<TSocketClass>::NavigateChunked(
			LPCTSTR szURL,
			ATL_NAVIGATE_DATA *pNavData
			) throw()
{
	if (!szURL || *szURL == _T('\0'))
		return false;

	ResetRequest();

	ATLASSERT(pNavData);

	CUrl url;
	if (!url.CrackUrl(szURL))
		return false;

	// Navigate
	return NavigateChunked(&url, pNavData);
}

template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::NavigateChunked(
		const CUrl *pUrl,
		ATL_NAVIGATE_DATA *pNavData
		) throw()
{
	if (!pUrl)
		return false;

	if (!pNavData)
	{
		// To do chunked navigation you must specify an
		// ATL_NAVIGATE_DATA structure that has the pfnChunkCallback
		// member filled out.
		ATLASSERT(FALSE);
		return false;
	}

	m_pNavData = pNavData;
	if (!pNavData->pfnChunkCallback)
		return false;

	bool bRet = true;
	
	_ATLTRY
	{
		m_strMethod = m_pNavData->szMethod;
	}
	_ATLCATCHALL()
	{
		return false;
	}

	SetSocketTimeout(m_pNavData->dwTimeout);

	// set m_urlCurrent
	if (!SetDefaultUrl(pUrl, m_pNavData->nPort))
		return false;


	DWORD dwSent = 0;
	CString strRequest;
	CString strExtraInfo;

	if (!BuildRequest(&strRequest,
					m_pNavData->szMethod,
					m_pNavData->szExtraHeaders // extra headers
					))
	{
		return false;
	}

	if (!ConnectSocket())
		return false;

	WSABUF Buffers[3];

	_ATLTRY
	{
		CT2A pRequest(strRequest);

		Buffers[0].buf = (char*)pRequest;
		Buffers[0].len = strRequest.GetLength();

		// send the first buffer which is the request
		if (!Write(Buffers, 1, &dwSent))
		{
			Close();
			return false;
		}
	}
	_ATLCATCHALL()
	{
		Close();
		return false;
	}
	Buffers[0].buf = NULL;
	Buffers[0].len = 0;

	CStringA strChunkSize;

	Buffers[2].buf = "\r\n";
	Buffers[2].len = 2;
	int z = 0;

	// start sending the chunks
	do
	{
		z++;
		Buffers[1].buf = NULL;
		Buffers[1].len = 0;
		if (m_pNavData->pfnChunkCallback((BYTE**)&Buffers[1].buf, &Buffers[1].len, 
			m_pNavData->m_lParamChunkCB))
		{
			_ATLTRY
			{
				if (Buffers[1].len > 0)
				{
					// send the chunk
					strChunkSize.Format("%x\r\n", Buffers[1].len);
					Buffers[0].buf = (char*)(LPCSTR)strChunkSize;
					Buffers[0].len = strChunkSize.GetLength();
					if (!Write(Buffers, 3, &dwSent))
					{
						bRet = false;
						break;
					}
				}
				else if (Buffers[1].len == 0)
				{
					strChunkSize = "0\r\n\r\n\r\n";
					Buffers[0].buf = (char*)(LPCSTR)strChunkSize;
					Buffers[0].len = strChunkSize.GetLength();
					if (!Write(Buffers, 1, &dwSent))
					{
						bRet = false;
						break;
					}
					break;
				}
			}
			_ATLCATCHALL()
			{
				bRet = false;
				break;
			}
		}
		else
		{
			bRet = false;
			break; // something went wrong in callback
		}
	}while (Buffers[1].len > 0);

	strRequest.ReleaseBuffer();

	if (bRet)
	{
		// Read the response
		if (RR_OK == ReadHttpResponse())
		{
			// if navigation isn't complete, try to complete
			// it based on the status code and flags
			if ((m_pNavData->dwFlags & ATL_HTTP_FLAG_PROCESS_RESULT)
				&& !ProcessStatus(m_pNavData->dwFlags))
			{
				bRet = false;
			}
			bRet = true;
		}
		else
			bRet = false;
	}

	if (!bRet)
		Close();

	return bRet;
}

template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::ConnectSocket() throw()
{
	bool bRet=false;
	// connect to the correct server
	if (GetProxy())
	{
		//if we're using a proxy connect to the proxy
		bRet=Connect(m_strProxy, m_nProxyPort);
	}
	else
	{
		bRet=Connect(m_urlCurrent.GetHostName(),m_urlCurrent.GetPortNumber()); // connect to the server
	}		
	return bRet;
}


template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::BuildRequest(/*out*/CString *pstrRequest,
										LPCTSTR szMethod,
										LPCTSTR szExtraHeaders)  throw()
{
	if (!m_pNavData)
		return false;
	_ATLTRY
	{
		// build up the request
		CString strRequest = szMethod;
		strRequest += _T(" ");
		if (GetProxy())
		{
			TCHAR buffURL[ATL_URL_MAX_URL_LENGTH];
			DWORD dwSize = ATL_URL_MAX_URL_LENGTH;
			m_urlCurrent.CreateUrl(buffURL, &dwSize);
			strRequest += buffURL;

			strRequest += ATL_HTTP_HEADER_PROXY;
			CString strHost;
			if (m_urlCurrent.GetPortNumber() != ATL_URL_DEFAULT_HTTP_PORT)
				strHost.Format(_T("Host: %s:%d\r\n"), m_urlCurrent.GetHostName(), m_urlCurrent.GetPortNumber());
			else
				strHost.Format(_T("Host: %s\r\n"), m_urlCurrent.GetHostName());
			strRequest += strHost;

			if (m_pNavData->dwDataLen>0)
			{
				CString strCL;
				strCL.Format(_T("Content-Length: %d\r\n"), m_pNavData->dwDataLen);
				strRequest += strCL;
			}

			if (m_pNavData->szDataType)
			{
				strRequest += _T("Content-Type: ");
				strRequest += m_pNavData->szDataType;
				strRequest += _T("\r\n");
			}

			if (m_pNavData->szExtraHeaders)
				strRequest += szExtraHeaders;
			strRequest += ATL_HTTP_USERAGENT;
		}
		else
		{
			strRequest += m_urlCurrent.GetUrlPath();
			strRequest += m_urlCurrent.GetExtraInfo();
			strRequest += ATL_HTTP_HEADER;

			if (m_pNavData->dwDataLen > 0)
			{
				CString strCL;
				strCL.Format(_T("Content-Length: %d\r\n"), m_pNavData->dwDataLen);
				strRequest += strCL;
			}

			if (m_pNavData->szDataType && 
				*m_pNavData->szDataType)
			{
				strRequest += _T("Content-Type: ");
				strRequest += m_pNavData->szDataType;
				strRequest += _T("\r\n");
			}

			if (szExtraHeaders)
				strRequest += szExtraHeaders;


			CString strHost;
			strHost.Format(_T("Host: %s\r\n"), m_urlCurrent.GetHostName());
			strRequest += strHost;
			strRequest += ATL_HTTP_USERAGENT;
		}
		strRequest += _T("\r\n");


		*pstrRequest = strRequest;
		return true;
	}
	_ATLCATCHALL()
	{
		return false;
	}
}

template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::ReadSocket() throw()
{
	bool bRet = false;
	unsigned char read_buff[ATL_READ_BUFF_SIZE];
	int dwSize = ATL_READ_BUFF_SIZE;

	// read some data
	for (int i = 0; i < ATL_HTTP_CLIENT_EMPTY_READ_RETRIES; ++i)
	{
		bRet = Read(read_buff, (DWORD*)&dwSize);
		if (!bRet)
			return bRet;

		// notify user
		if (m_pNavData)
		{
			if (m_pNavData->pfnReadStatusCallback)
				bRet = m_pNavData->pfnReadStatusCallback(dwSize, m_pNavData->m_lParamRead);
			if (!bRet)
				return bRet;
		}

		if (dwSize > 0)
		{
			// append the data to our internal buffer
			// m_current holds bytes (not UNICODE!)
			
			if (!m_current.Append((LPCSTR)read_buff, dwSize))
				return FALSE;

			m_pEnd = ((BYTE*)(LPCSTR)m_current) + m_current.GetLength();
			m_pCurrent = (BYTE*)(LPCSTR)m_current;
			break;
		}
 		bRet = false; // nothing was read
	}

	return bRet;
}

// Starts searching for a complete header set at
// m_pCurrent. This function will only move m_pCurrent
// if a complete set is found. Returns the header beginning
// optionally.
template <class TSocketClass>
inline unsigned char* CAtlHttpClientT<TSocketClass>::FindHeaderEnd(unsigned char** ppBegin) throw()
{
	if (!m_pCurrent)
		return NULL;

	BYTE *pCurr = m_pCurrent;
	BYTE *pBegin = m_pCurrent;
	int nLen = m_current.GetLength();

	if (pCurr >= (BYTE*)(LPCSTR)m_current + m_current.GetLength())
		return NULL; // no more chars in buffer
	// look for the end of the header (the \r\n\r\n)
	while (pCurr <= (pBegin + nLen - ATL_HEADER_END_LEN))
	{
#ifndef _WIN32_WCE
		if (* ((UNALIGNED  DWORD*)pCurr)==ATL_DW_HEADER_END)
#else
		if ((*pCurr == '\r') &&
			(*(pCurr+1) == '\n') &&
			(*(pCurr+2) == '\r') &&
			(*(pCurr+3) == '\n'))
#endif // !_WIN32_WCE
		{
			// set m_pCurrent pointer to the end of the header
			m_pCurrent = pCurr + ATL_HEADER_END_LEN;
			if (ppBegin)
				*ppBegin = pBegin;
			return m_pCurrent;
		}
		pCurr++;
	}
	return NULL;
}

// Call this function after sending an HTTP request over the socket. The complete
// HTTP response will be read. This function will also parse
// response headers into the response header map.
template <class TSocketClass>
inline typename CAtlHttpClientT<TSocketClass>::HTTP_RESPONSE_READ_STATUS CAtlHttpClientT<TSocketClass>::ReadHttpResponse() 
{
	// Read until we at least have the response headers
	HTTP_RESPONSE_READ_STATUS result = RR_OK;
	readstate state = rs_init;
	unsigned char *pBodyBegin = NULL;
	unsigned char *pHeaderBegin = NULL;
	m_current.Empty();
	m_pCurrent = NULL;
	m_LastResponseParseError = RR_OK;

	while (state != rs_complete)
	{
		switch(state)
		{
		case rs_init:
			m_HeaderMap.RemoveAll();
			m_nStatus = ATL_INVALID_STATUS;
			m_dwHeaderLen = 0;
			m_dwBodyLen = 0;
			state = rs_readheader;
			// fall through

		case rs_readheader:

			// read from the socket until we have a complete set of headers.
			pBodyBegin = FindHeaderEnd(&pHeaderBegin);
			if (!pBodyBegin)
			{
				if (!ReadSocket())
				{
					// Either reading from the socket failed, or there
					// was not data to read. Set the nav status to error
					// and change the state to complete.
					state = rs_complete;
					result = RR_READSOCKET_FAILED;
					break;
				}
				else
					break; // loop back and FindHeaderEnd again.
			}
			// we have a complete set of headers
			m_dwHeaderLen = (DWORD)(pBodyBegin-pHeaderBegin);
			m_dwHeaderStart = (DWORD)(pHeaderBegin - (BYTE*)(LPCSTR)m_current);
			// fall through
			state = rs_scanheader;

		case rs_scanheader:
			// set m_nStatus and check for valid status
			ParseStatusLine(pHeaderBegin);
			// failed to set m_nStatus;
			if (m_nStatus == ATL_INVALID_STATUS)
			{
				state = rs_complete;
				result = RR_STATUS_INVALID;
				break;
			}

			else if (m_nStatus == 100) // continue
			{
				state = rs_init;
				break;
			}

			// crack all the headers and put them into a header map. We've already
			// done the check to make sure we have a complete set of headers in 
			// rs_readheader above
			if (ATL_HEADER_PARSE_COMPLETE != CrackResponseHeader((LPCSTR)pHeaderBegin, 
				(LPCSTR*)&pBodyBegin))
			{
				// something bad happened while parsing the headers!
				state = rs_complete;
				result = RR_PARSEHEADERS_FAILED;
				break;
			}
			state = rs_readbody;
			// fall through

		case rs_readbody:
			// headers are parsed and cracked, we're ready to read the rest
			// of the response. 
			if (IsMsgBodyChunked())
			{
				if (!ReadChunkedBody())
				{
					result = RR_READCHUNKEDBODY_FAILED;
					state = rs_complete;
					break;
				}
			}
			else
			if (!ReadBody(GetContentLength(), m_current.GetLength()-(m_dwHeaderStart+m_dwHeaderLen)))
				result = RR_READBODY_FAILED;
			state = rs_complete;
			//fall through

		case rs_complete:
			// clean up the connection if the server requested a close;
			DisconnectIfRequired();
			break;
		}
	}
	m_LastResponseParseError = result;
	return result;
}

template <class TSocketClass>
inline typename CAtlHttpClientT<TSocketClass>::HTTP_RESPONSE_READ_STATUS CAtlHttpClientT<TSocketClass>::GetResponseStatus()
{
	return m_LastResponseParseError;
}

// Checks to see if the server has closed the connection.
// If it has, we create a new socket and reconnect it to
// the current server. This also clears the contents of the
// current response buffer.
template <class TSocketClass>
inline void CAtlHttpClientT<TSocketClass>::ResetConnection() throw()
{
	ReconnectIfRequired();
	m_HeaderMap.RemoveAll();
	m_current.Empty();
	m_nStatus = ATL_INVALID_STATUS;
	m_AuthTypes.RemoveAll(); // the server will keep sending back www-authenticate
							 // headers until the connection is authorized
}

// Takes action based on the flags passed and the current
// status for this object.
template <class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::ProcessStatus(DWORD dwFlags) throw()
{
	switch(m_nStatus)
	{
	case 200: // In all these cases there is no further action
	case 201: // to take. Any additional informaion is returned
	case 202: // in the entity body.
	case 203:
	case 204:
	case 205:
	case 206:
	case 304:
	case 305:
		return true;
		break;
	case 301:
	case 302:
	case 303:
		if (dwFlags & ATL_HTTP_FLAG_AUTO_REDIRECT)
			return ProcessObjectMoved();
		break;
	case 401: // auth required
			return NegotiateAuth(false);
		break;
	case 407: // proxy auth required
			return NegotiateAuth(true);
		break;

	}
	return false;
}

// Looks up the value of a response header in the header map. Call with
// NULL szBuffer to have length of the required buffer placed in 
// pdwLen on output.

// szName is the name of the header to look up.
// szBuffer is the buffer that will contain the looked up string.
// pdwLen contains the length of szBuffer in characters on input and the length
// of the string including NULL terminator in characters on output.
template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::GetHeaderValue(LPCTSTR szName, CString& strValue) const throw()
{
	_ATLTRY
	{
		return m_HeaderMap.Lookup(szName, strValue);
	}
	_ATLCATCHALL()
	{
		return false;
	}
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::GetHeaderValue(__in_z LPCTSTR szName, __out_ecount_part_z_opt(*pdwLen, *pdwLen) LPTSTR szBuffer, __inout DWORD *pdwLen) const throw()
{
	CString strValue;
	bool bRet = GetHeaderValue(szName, strValue);
	DWORD nLen = strValue.GetLength();
	if (!bRet)
		return false;

	if ((pdwLen && *pdwLen < nLen+1) ||
		(!szBuffer && pdwLen) )
	{
		*pdwLen = nLen+1;
		return true;
	}

	if (!szBuffer)
		return false;

	Checked::tcsncpy_s(szBuffer, nLen+1, (LPCTSTR)strValue, _TRUNCATE);
	if (pdwLen)
		*pdwLen = nLen+1;
	return true;
}

// Adds an authorization object to use for a particular scheme.
// This will overwrite an existing entry if an object for the 
// same scheme has already been set.
template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::AddAuthObj(LPCTSTR szScheme,
				CAtlBaseAuthObject *pObject, IAuthInfo *pInfo/*=NULL*/) throw()
{
	if (!pObject)
		return false;

	pObject->Init(this, pInfo);

	_ATLTRY
	{
		POSITION pos = m_AuthMap.SetAt(szScheme, pObject);
		if (!pos)
			return false;
	}
	_ATLCATCHALL()
	{
		return false;
	}

	return true;
}

// Tries to find an authorization object to use for a particular
// scheme
template<class TSocketClass>
inline const CAtlBaseAuthObject* CAtlHttpClientT<TSocketClass>::FindAuthObject(LPCTSTR szScheme) throw()
{
	CAtlBaseAuthObject *pObject = NULL;
	if (m_AuthMap.Lookup(szScheme, pObject))
	{
		return const_cast<const CAtlBaseAuthObject*>(pObject);
	}
	return NULL;
}

// Removes an existing authorization object from the map.
template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::RemoveAuthObject(LPCTSTR szScheme) throw()
{
	return m_AuthMap.RemoveKey(szScheme);
}

// Sets the current proxy server and port
template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::SetProxy(LPCTSTR szProxy, short nProxyPort) throw()
{
	if (!szProxy)
	{
		if (!LookupRegProxy())
			return false;
	}
	else
	{
		_ATLTRY
		{
			m_strProxy = szProxy;
			m_nProxyPort = nProxyPort;
		}
		_ATLCATCHALL()
		{
			return false;
		}
	}
	return true;
}

// Removes the current proxy settings.
template<class TSocketClass>
inline void CAtlHttpClientT<TSocketClass>::RemoveProxy() throw()
{
		m_strProxy.Empty();
		m_nProxyPort = ATL_URL_INVALID_PORT_NUMBER;
}

// retrieves the current proxy
template<class TSocketClass>
inline LPCTSTR CAtlHttpClientT<TSocketClass>::GetProxy() const throw()
{
	if (m_strProxy.GetLength())
		return (LPCTSTR)m_strProxy;
	return NULL;
}

template<class TSocketClass>
inline short CAtlHttpClientT<TSocketClass>::GetProxyPort() const throw()
{
	return m_nProxyPort;
}

// Gets the contents of the entire response buffer.
template<class TSocketClass>
inline const BYTE* CAtlHttpClientT<TSocketClass>::GetResponse() throw()
{
	return (const BYTE*)(LPCSTR)m_current;
}

template<class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::GetResponseLength() throw()
{
	return m_current.GetLength();
}

// Gets the length in bytes of the body of the
// current response
template<class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::GetBodyLength() const throw()
{
	return m_dwBodyLen;
}

// Gets the contents of the body of the current response. This
// is the response without the headers. 
template<class TSocketClass>
inline const BYTE* CAtlHttpClientT<TSocketClass>::GetBody() throw()
{
	return (BYTE*)((LPCSTR)m_current + m_dwHeaderLen + m_dwHeaderStart);
}

// Get the length of the header part of the response in bytes.
template<class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::GetRawResponseHeaderLength() throw()
{
	return m_dwHeaderLen >= 2 ? m_dwHeaderLen-2 : 0; // m_dwHeaderLen includes the final \r\n
}

// buffer must include space for null terminator.
// on input, pdwLen specifies the size of szBuffer,
// on output, pdwLen holds the number of bytes copied
// to szBuffer, or the required size of szBuffer if 
// szBuffer wasn't big enough
template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::GetRawResponseHeader(LPBYTE szBuffer, DWORD *pdwLen) throw()
{
	if (!pdwLen)
		return false;

	DWORD header_len = GetRawResponseHeaderLength();
	if (header_len == 0)
		return false;

	if (!szBuffer || *pdwLen < header_len+1)
	{
		*pdwLen = header_len+1;
		return false;
	}

	Checked::memcpy_s(szBuffer, *pdwLen, (BYTE*)(LPCSTR)m_current, header_len);
	szBuffer[header_len]='\0';

	*pdwLen = header_len+1;
	return true;
}

// Gets the current URL object.
template<class TSocketClass>
inline LPCURL CAtlHttpClientT<TSocketClass>::GetCurrentUrl() const throw()
{
	return (LPCURL)&m_urlCurrent;
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::SetDefaultUrl(  LPCTSTR szUrl, 
											short nPortNumber) throw()
{
	return _SetDefaultUrl(szUrl,nPortNumber);
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::SetDefaultUrl(  LPCURL pUrl, 
											short nPortNumber) throw()
{
	m_urlCurrent = *pUrl;
	return _SetDefaultUrl(NULL, nPortNumber);
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::SetDefaultMethod(LPCTSTR szMethod) throw()

{
	_ATLTRY
	{
		m_strMethod = szMethod;
		return true;
	}
	_ATLCATCHALL()
	{
		return false;
	}
}

template<class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::GetFlags() const throw()
{
	if (m_pNavData)
		return m_pNavData->dwFlags;
	else
		return ATL_HTTP_FLAG_INVALID_FLAGS;
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::LookupRegProxy() throw()
{
	// attempt to look it up from the registry
	CRegKey rkProxy;
	ULONG nChars = ATL_URL_MAX_URL_LENGTH+1;
	TCHAR szUrl[ATL_URL_MAX_URL_LENGTH+1] = { 0 };

	DWORD dwErr = rkProxy.Open(HKEY_CURRENT_USER, 
		_T("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"), KEY_READ);
	if (dwErr == ERROR_SUCCESS)
	{
		dwErr = rkProxy.QueryStringValue(_T("ProxyServer"), szUrl, &nChars);
	}
	if (dwErr == ERROR_SUCCESS)
	{
		CUrl url;
		if (url.CrackUrl(szUrl))
		{
			if (url.GetScheme()==ATL_URL_SCHEME_UNKNOWN)
			{
				// without the scheme name (e.g. proxy:80)
				m_strProxy = url.GetSchemeName();
				m_nProxyPort = (short)_ttoi(url.GetHostName());
				return true;
			}
			else if (url.GetHostName())
			{
				// with the scheme (e.g. http://proxy:80)
				m_strProxy = url.GetHostName();
				m_nProxyPort = url.GetPortNumber();
				return true;
			}
		}
	}
	return false;
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::DisconnectIfRequired() throw()
{
	CString strValue;
	if (GetHeaderValue(_T("Connection"), strValue) && !strValue.CompareNoCase(_T("close")))
	{
		Close();
	}

	return true;
}

#if !defined(_WIN32_WCE)
class CInitializeCOMThread
{
public:
	CInitializeCOMThread()
		: m_bCoInit(FALSE),m_bShouldUninit(FALSE)
	{		
		//At this point the Thread can be uninit, init to STA or init to MTA.
		//CoInitialize can always fail unexpectedly.		
		HRESULT hr = ::CoInitialize(NULL);		
		if (SUCCEEDED(hr))
		{
			m_bCoInit=TRUE;
			m_bShouldUninit=TRUE;
		} else if (hr == RPC_E_CHANGED_MODE)
		{	
			m_bCoInit=TRUE;
		}
	}
	~CInitializeCOMThread()
	{
		if (m_bShouldUninit)
		{
			::CoUninitialize();
		}
	}
	BOOL IsInitialized() {  return m_bCoInit; }
protected:
	BOOL m_bCoInit;
	BOOL m_bShouldUninit;
};
#endif // !defined(_WIN32_WCE)

// Tries to find an authorization object that meets
template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::NegotiateAuth(bool bProxy) throw()
{
#if !defined(_WIN32_WCE)
	//Test if can silently pass user credentials to server.
	if (!m_bSilentLogonOk)
	{	
		//Call CoInit, because ATL Http code cannot assume it has already been called by the user.
		CInitializeCOMThread initThread;
		if (initThread.IsInitialized())
		{
			HRESULT hr = S_OK;
			CComPtr<IInternetSecurityManager> spSecurityMgr;
			
			hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
									IID_IInternetSecurityManager, (void**)&spSecurityMgr);
			if (SUCCEEDED(hr))
			{		
				TCHAR szUrl[ATL_URL_MAX_URL_LENGTH];
				DWORD dwMaxLen = ATL_URL_MAX_URL_LENGTH;
				if (!m_urlCurrent.CreateUrl(szUrl, &dwMaxLen))
				{
					return false;
				}
				
				CStringW strUrlW(szUrl);
				DWORD dwPolicy=0xFFFF;		
				hr=spSecurityMgr->ProcessUrlAction(strUrlW.GetString(),
												URLACTION_CREDENTIALS_USE,
												reinterpret_cast<BYTE*>(&dwPolicy),
												sizeof(dwPolicy),
												NULL,
												0,    
												PUAF_NOUI,
												NULL);

				if (FAILED(hr) || dwPolicy != URLPOLICY_CREDENTIALS_SILENT_LOGON_OK)
				{
					return false;
				}
			}
			else
			{
				// CoCreateInstance failed, return false
				return false;
			}
		}
		else
		{
			// CoInit failed, return false
			return false;
		}
	}
#endif // !defined(_WIN32_WCE)

	// szAuthHeaderValue should contain a comma separated list
	// of authentication types
	CAtlBaseAuthObject *pAuthObj = NULL;
	bool bRet = false;
	for (size_t i = 0; i<m_AuthTypes.GetCount(); i++)
	{
		_ATLTRY
		{
			CString strName = m_AuthTypes[i];
			int nSpace = strName.Find(_T(' '));
			if (nSpace!=-1)
				strName.SetAt(nSpace,0);

			if (m_AuthMap.Lookup(strName, pAuthObj) &&
				!pAuthObj->m_bFailed)
				bRet = pAuthObj->Authenticate(m_AuthTypes[i], bProxy);

			if (bRet)
				return bRet;
		}
		_ATLCATCHALL()
		{
			bRet = false;
		}
	}
	return bRet;
}

template<class TSocketClass>
inline long CAtlHttpClientT<TSocketClass>::GetContentLength() throw()
{
	CString strValue;
	if (GetHeaderValue(_T("Content-Length"), strValue))
	{
		TCHAR *pStop = NULL;
		return _tcstol(strValue, &pStop, 10);
	}
	else
		return -1;
}

template<class TSocketClass>
inline LPCSTR CAtlHttpClientT<TSocketClass>::NextLine(BYTE* pCurr) throw()
{
	if (!pCurr)
		return NULL;

	while ( pCurr < m_pEnd && *pCurr && !(*pCurr == '\r' && *(pCurr+1) == '\n'))
		pCurr++;

	if (pCurr >= m_pEnd)
		return NULL;

//	if (pCurr < m_pEnd-4)
//		if (!memcmp(pCurr, ATL_HEADER_END, 4))
			//return NULL;

	return (LPCSTR)(pCurr+2);
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::IsMsgBodyChunked() throw()
{
	CString strValue;
	return (
			GetHeaderValue(_T("Transfer-Encoding"), strValue) &&
			!strValue.CompareNoCase(_T("chunked"))
			);

}

// finds the end of an individual header field pointed to by
// pszStart. Header fields can be multi-line with multi-line 
// header fields being a line that starts with some kind of 
// white space.
template<class TSocketClass>
inline LPCSTR CAtlHttpClientT<TSocketClass>::FindEndOfHeader(LPCSTR pszStart) throw()
{
	// move through all the lines until we come to one
	// that doesn't start with white space
	LPCSTR pLineStart = pszStart;
	LPCSTR pHeaderEnd = NULL;

	do 
	{
		pLineStart = NextLine((BYTE*)pLineStart);
	}while (pLineStart && isspace(static_cast<unsigned char>(*pLineStart)) && strncmp(pLineStart-2, ATL_HEADER_END, ATL_HEADER_END_LEN));

	if (pLineStart > (LPCSTR)m_pEnd)
		return NULL; // ran out of data in the buffer without finding the end of a line
	                 // or the end of the headers.

	if (pLineStart)
		pHeaderEnd = pLineStart-2;
	else
		pHeaderEnd = NULL;

	return pHeaderEnd;
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::DecodeHeader(LPCSTR pHeaderStart, LPCSTR pHeaderEnd) throw()
{
	_ATLTRY
	{
		if (!pHeaderStart || !pHeaderEnd)
			return false;
		LPCSTR pTemp = pHeaderStart;
		while (*pTemp != ATL_FIELDNAME_DELIMITER && pTemp < pHeaderEnd)
			pTemp++;
		if (*pTemp == ATL_FIELDNAME_DELIMITER)
		{
			char szName[ATL_MAX_FIELDNAME_LEN];
			char szValue[ATL_MAX_VALUE_LEN];
			int nLen = (int)(pTemp-pHeaderStart) ;
			ATLASSERT(nLen < ATL_MAX_FIELDNAME_LEN);
			if (nLen >= ATL_MAX_FIELDNAME_LEN)
				return false; // won't fit in the buffer.
			Checked::memcpy_s(szName, ATL_MAX_FIELDNAME_LEN, pHeaderStart, nLen);
			szName[nLen]=0;

			pTemp++; // move past delimiter;
			while (isspace(static_cast<unsigned char>(*pTemp)) && pTemp < pHeaderEnd)
				pTemp++;

			nLen = (int)(pHeaderEnd-pTemp);
			ATLASSERT(nLen < ATL_MAX_VALUE_LEN);
			if (nLen >= ATL_MAX_VALUE_LEN)
				return false; // won't fit in the buffer
			Checked::memcpy_s(szValue, ATL_MAX_VALUE_LEN, pTemp, nLen);
			szValue[nLen]=0;

			CString strExist;
			CA2T pszName(szName);
			CA2T pszValue(szValue);

			if (!_tcsicmp(pszName, _T("www-authenticate")) ||
				!_tcsicmp(pszName, _T("proxy-authenticate")))
			{
				m_AuthTypes.Add(pszValue);
			}

			if (!m_HeaderMap.Lookup(pszName, strExist))
				m_HeaderMap.SetAt(pszName, pszValue);
			else
			{   
				// field-values for headers with the same name can be appended
				// per rfc2068 4.2, we do the appending so we don't have to
				// store/lookup duplicate keys.
				strExist += ',';
				strExist += pszValue;
				m_HeaderMap.SetAt(pszName, (LPCTSTR)strExist);
			}

			// if it's a set-cookie header notify users so they can do 
			// somthing with it.
			if (!_tcsicmp(pszName, _T("set-cookie")))
				OnSetCookie(pszValue);
		}

		return true;
	}
	_ATLCATCHALL()
	{
		return false;
	}
}

template<class TSocketClass>
inline void CAtlHttpClientT<TSocketClass>::OnSetCookie(LPCTSTR) throw()
{
	return;
}

template<class TSocketClass>
inline LPCSTR CAtlHttpClientT<TSocketClass>::ParseStatusLine(BYTE* pBuffer) throw()
{
	if (!pBuffer)
		return NULL;
	if (m_pEnd <= pBuffer)
		return NULL;

	// find the first space'
	while (pBuffer < m_pEnd && !isspace(static_cast<unsigned char>(*pBuffer)))
		pBuffer++;

	if (pBuffer >= m_pEnd)
		return NULL;

	// move past the space
	while (pBuffer < m_pEnd && isspace(static_cast<unsigned char>(*pBuffer)))
		pBuffer++;

	if (pBuffer >= m_pEnd)
		return NULL;

	// pBuffer better be pointing at the status code now
	LPCSTR pEnd = NULL;
	if (*pBuffer >= '0' && *pBuffer <= '9')
	{
		// probably a good status code
		m_nStatus = strtol((LPSTR)pBuffer, (LPSTR*)&pEnd, 10);
#ifndef _WIN32_WCE
		if (Checked::get_errno() == ERANGE)
#else // _WIN32_WCE
		if (m_nStatus == LONG_MAX || m_nStatus == LONG_MIN)
#endif // _WIN32_WCE
			return NULL; // bad status code
	}
	else 
		return FALSE; // bad status code;

	if (!pEnd)
		return FALSE; // bad status code;

	pBuffer = (BYTE*)pEnd;
	// move to end of line
	while (pBuffer < m_pEnd && *pBuffer !=  '\n')
		pBuffer++;

	if (pBuffer >= m_pEnd)
		return NULL;

	// set the return pointing to the first 
	// character after our status line.
	return (LPCSTR)++pBuffer;
}


// pBuffer should start at the first character
// after the status line.
template<class TSocketClass>
inline int CAtlHttpClientT<TSocketClass>::CrackResponseHeader(LPCSTR pBuffer, /*out*/ LPCSTR *pEnd) throw()
{
	// read up to the double /r/n
	LPCSTR pszStartSearch = pBuffer;
	if (!pEnd)
		return ATL_HEADER_PARSE_HEADERERROR;

	*pEnd = NULL;
	if (pszStartSearch == NULL)
		return ATL_HEADER_PARSE_HEADERERROR;

	// start parsing headers
	LPCSTR pHeaderStart = ParseStatusLine((BYTE*)pBuffer);
	if (!pHeaderStart)
		return ATL_HEADER_PARSE_HEADERERROR;
	LPCSTR pHeaderEnd = NULL;

	while (pHeaderStart && *pHeaderStart && pHeaderStart < (LPCSTR)m_pEnd)
	{
		pHeaderEnd = FindEndOfHeader(pHeaderStart);
		if (!pHeaderEnd)
			break; // error

		DecodeHeader(pHeaderStart, pHeaderEnd);

		if (!strncmp(pHeaderEnd, ATL_HEADER_END, strlen(ATL_HEADER_END)))
		{
			*pEnd = pHeaderEnd + strlen(ATL_HEADER_END);
			break;      // we're done
		}
		else
			pHeaderStart = pHeaderEnd+2;
	}

	return ATL_HEADER_PARSE_COMPLETE;       
}

// Reads the body if the encoding is not chunked.
template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::ReadBody(int nContentLen, int nCurrentBodyLen) throw()
{
	// nCurrentBodyLen is the length of the body that has already been read
	// nContentLen is the value of Content-Length
	// current is the buffer that will contain the entire response
	bool bRet = true;
	ATLASSUME(m_pNavData);
	if (!m_pNavData)
		return false;

	CTempBuffer<BYTE, 512> readbuff;
	DWORD dwReadBuffSize = 0;
	DWORD dwRead = 0;
	if (m_pNavData->dwReadBlockSize)
	{
		ATLTRY(readbuff.Allocate(m_pNavData->dwReadBlockSize));
		dwReadBuffSize = m_pNavData->dwReadBlockSize;
	}
	else
	{
		ATLTRY(readbuff.Allocate(ATL_READ_BUFF_SIZE));
		dwReadBuffSize = ATL_READ_BUFF_SIZE;
	}

	if (readbuff.operator BYTE*() == NULL)
		return false;

	if (nContentLen != -1) // We know the content length.
	{
		// read the rest of the body.
		while (nCurrentBodyLen < nContentLen)
		{
			dwRead = dwReadBuffSize;
			// loop while dwRead == 0
			for (int nRetry = 0; nRetry < ATL_HTTP_CLIENT_EMPTY_READ_RETRIES; ++nRetry)
			{
				if (!Read(readbuff, &dwRead))
					return false;
	
				// notify user
				if (m_pNavData)
				{
					if (m_pNavData->pfnReadStatusCallback)
						if (!m_pNavData->pfnReadStatusCallback(dwRead, m_pNavData->m_lParamRead))
							return false;
				}
	
				if (dwRead == 0)
					continue;
				nCurrentBodyLen += dwRead;
				if (!m_current.Append((LPCSTR)(BYTE*)readbuff, dwRead))
				{
					ATLASSERT(0);
					return false; // error!
				}
				m_pEnd = ((BYTE*)(LPCSTR)m_current) + m_current.GetLength();
				break;
			}
			if (dwRead == 0)
				return false;
		}
		m_dwBodyLen = nCurrentBodyLen;
	}
	else // We don't know content length. All we can do is
	{    // read until there is nothing else to read.
		int nRetries = 0;
		while (1)
		{
			dwRead = dwReadBuffSize;
			if (Read((BYTE*)readbuff, (DWORD*)&dwRead))
			{
				// notify user
				if (m_pNavData)
				{
					if (m_pNavData->pfnReadStatusCallback)
						bRet = m_pNavData->pfnReadStatusCallback(dwRead, m_pNavData->m_lParamRead);
					if (!bRet)
						return bRet;
				}

				if (dwRead == 0)
				{
					if (nRetries++ < ATL_HTTP_CLIENT_EMPTY_READ_RETRIES)
						continue;
					break;
				}

				nRetries = 0;
				nCurrentBodyLen += dwRead;
				if (!m_current.Append((LPCSTR)(BYTE*)readbuff, dwRead))
					return false;
				m_pEnd = ((BYTE*)(LPCSTR)m_current) + m_current.GetLength();
			}
			else 
			{
				// notify user
				if (m_pNavData)
				{
					if (m_pNavData->pfnReadStatusCallback)
						bRet = m_pNavData->pfnReadStatusCallback(dwRead, m_pNavData->m_lParamRead);
					if (!bRet)
						return bRet;
				}

				bRet = true;
				break;
			}
		}
		m_dwBodyLen = nCurrentBodyLen;
	}
	return bRet;
}


// This function moves pBuffStart only on success. On success, pBuffStart is moved
// to the element past the last element we consumed.
template<class TSocketClass>
inline typename CAtlHttpClientT<TSocketClass>::CHUNK_LEX_RESULT CAtlHttpClientT<TSocketClass>::get_chunked_size(char *&pBuffStart, char *&pBuffEnd, long* pnChunkSize)
{
	CHUNK_LEX_RESULT result = LEX_ERROR;
	char *pStop = NULL;

	if (pBuffStart >= pBuffEnd)
		result = LEX_OUTOFDATA;
	else
	{
		long nResult = strtoul(pBuffStart, &pStop, 16);
#ifndef _WIN32_WCE
		if (Checked::get_errno()!= ERANGE &&
#else // _WIN32_WCE
		if (
#endif // _WIN32_WCE
			nResult >= 0 &&
			nResult < 0xFFFFFFFF &&
			pStop <= pBuffEnd &&
			*pStop == '\r')
		{
			// move pBuffStart
			// return chunk size
			*pnChunkSize = nResult;
			pBuffStart = pStop;
			result = LEX_OK;
		}
		if (*pStop != '\r')
		{
			result = LEX_OUTOFDATA; // not enough data in the buffer
		}
	}
	return result;
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::move_leftover_bytes(__in_ecount(nLen) char *pBufferStart, __in int nLen, __deref_inout char *&pBuffStart, __deref_inout char *& pBuffEnd) throw()
{
	bool bRet = true;
	Checked::memcpy_s(pBufferStart, (pBuffEnd-pBuffStart), pBuffStart, nLen);
	return bRet;
}

template<class TSocketClass>
inline typename CAtlHttpClientT<TSocketClass>::CHUNK_LEX_RESULT CAtlHttpClientT<TSocketClass>::get_chunked_data(char *&pBufferStart,
								  char *&pBufferEnd,
								  long nChunkSize,
								  char **ppDataStart,
								  long *pnDataLen) throw()
{
	CHUNK_LEX_RESULT result = LEX_ERROR;
	if (pBufferStart + nChunkSize - 1 < pBufferEnd)
	{
		*ppDataStart = pBufferStart;
		*pnDataLen = nChunkSize;
		pBufferStart = pBufferStart + nChunkSize;
		result = LEX_OK;
	}
	else if (pBufferStart + nChunkSize - 1 >= pBufferEnd)
		result = LEX_OUTOFDATA;

	return result;
}

template<class TSocketClass>
inline typename CAtlHttpClientT<TSocketClass>::CHUNK_LEX_RESULT CAtlHttpClientT<TSocketClass>::consume_chunk_trailer(char *&pBufferStart, char *pBufferEnd)
{
	CHUNK_LEX_RESULT result = LEX_ERROR;
	if (pBufferStart >= pBufferEnd)
		return result;

	char *pHeaderEnd = NULL;
	char *pTemp = pBufferStart;
	// check for empty trailer, this means there are no more trailers
	if ( (pTemp < pBufferEnd && *pTemp == '\r') &&
			(pTemp+1 < pBufferEnd && *(pTemp+1) == '\n'))
	{
		pBufferStart += 2;
		return LEX_TRAILER_COMPLETE;
	}

	while (pTemp <= pBufferEnd)
	{
		if ( (pTemp < pBufferEnd && *pTemp == '\r') &&
			 (pTemp+1 < pBufferEnd && *(pTemp+1) == '\n'))
		{
			 pHeaderEnd = pTemp; // success case
			 result = LEX_OK;
			 break;
		}
		pTemp++;
	}

	if (result == LEX_OK)
	{
		DecodeHeader(pBufferStart, pHeaderEnd);
		pBufferStart = pHeaderEnd + 2;
	}
	else if (result != LEX_OK &&
		pTemp > pBufferEnd)
		result = LEX_OUTOFDATA;
	return result;
}

template<class TSocketClass>
inline typename CAtlHttpClientT<TSocketClass>::CHUNK_LEX_RESULT CAtlHttpClientT<TSocketClass>::consume_chunk_footer(char *&pBufferStart, char *&pBufferEnd)
{
	CHUNK_LEX_RESULT result = LEX_ERROR;
	if (pBufferStart < pBufferEnd &&
		(pBufferStart+1) <= pBufferEnd)
	{
		if ( *pBufferStart == '\r' &&   
			 *(pBufferStart+1) == '\n')
		{
			pBufferStart += 2;
			result = LEX_OK;
		}
	}
	else
		result = LEX_OUTOFDATA;
	return result;
}

#define CHUNK_BUFF_SIZE 2048

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::ReadChunkedBody() throw()
{
	// At this point, m_current contains the headers, up to and including the \r\n\r\n,
	// plus any additional data that might have been read off the socket. So, we need
	// to copy off the additional data into our read buffer before we start parsing the
	// chunks.
#ifdef _DEBUG
	// nReadCount, keeps track of how many socket reads we do.
	int nReadCount = 0;
#endif

	// nChunkBuffCarryOver
	// When we run out of data in the input buffer, this is the
	// count of bytes that are left in the input that could not
	// be lexed into anything useful. We copy this many bytes to
	// the top of the input buffer before we fill the input buffer
	// with more bytes from the socket
	long nChunkBuffCarryOver = 0;

	// nChunkSize
	// The size of the next chunk to be read from the input buffer.
	long nChunkSize = 0;

	// t_chunk_buffer
	// The heap allocated buffer that we holds data
	// read from the socket. We will increase the size
	// of this buffer to 2 times the max chunk size we
	// need to read if we have to.
	CHeapPtr<char> t_chunk_buffer;

	// nTChunkBuffSize
	// Keeps track of the allocated size of t_chunk_buffer.
	// This size will change if we need to read chunks bigger
	// than the currently allocated size of t_chunk_buffer.
	long nTChunkBuffSize = CHUNK_BUFF_SIZE;

	// chunk_buffer & chunk_buffer_end
	// Keeps track of the current location
	// in t_chunk_buffer that we are lexing input from.
	// chunk_buffer_end is the end of the input buffer we
	// are lexing from. chunk_buffer_end is used as a marker
	// to make sure we don't read past the end of our input buffer
	char *chunk_buffer, *chunk_buffer_end;

	// cstate
	// The current state of the chunk parsing state machine. We
	// start out reading the size of the first chunk.
	CHUNK_STATE cstate = READ_CHUNK_SIZE;

	// cresult
	// Holds the value of the result of a lexing operation performed
	// on the input buffer.
	CHUNK_LEX_RESULT cresult = LEX_OK;

	CAtlIsapiBuffer<> result_buffer;

	// Initialize pointers and allocate the chunk buffer.
	chunk_buffer = chunk_buffer_end = NULL;
	if( !t_chunk_buffer.Allocate(nTChunkBuffSize) )
		return false;

	// copy the headers into a temporary buffer.
	result_buffer.Append(m_current + m_dwHeaderStart, m_dwHeaderLen);

	// calculate number of bytes left in m_current past the headers
	long leftover_in_m_current = m_current.GetLength() - (m_dwHeaderStart + m_dwHeaderLen);

	// copy the extra bytes that might have been read into m_current into the chunk buffer
	if (leftover_in_m_current > 0)
	{
		if (leftover_in_m_current > nTChunkBuffSize)
		{
			if( ! t_chunk_buffer.Reallocate(leftover_in_m_current) )
				return false;
		}

		chunk_buffer = (char*)t_chunk_buffer;
		Checked::memcpy_s(chunk_buffer, leftover_in_m_current, ((LPCSTR)m_current)+ m_dwHeaderStart + m_dwHeaderLen, leftover_in_m_current);
		chunk_buffer_end = chunk_buffer + leftover_in_m_current;
	}

	m_current.Empty();
	m_dwBodyLen = 0;
	m_dwHeaderStart = 0;

	// as we start the state machine, we should be either pointing at the first
	// byte of chunked response or nothing, in which case we will need to get 
	// more data from the socket.
	nChunkSize = 0;

	bool bDone = false;

	while(!bDone)
	{
		// if we run out of data during processing, chunk_buffer
		// get set to null
		if (!chunk_buffer ||
			chunk_buffer >= chunk_buffer_end)
		{
			// we ran out of data in our input buffer, we need
			// to read more from the socket.
			DWORD dwReadBuffSize = nTChunkBuffSize - nChunkBuffCarryOver;
			chunk_buffer = t_chunk_buffer;
			if (!Read((const unsigned char*)(chunk_buffer+nChunkBuffCarryOver), &dwReadBuffSize))
			{
				ATLTRACE(_T("ReadChunkedBody: Error reading from socket (%d)\n"), GetLastError());
				return false;
			}
			else if(dwReadBuffSize == 0)
			{
				ATLTRACE(_T("ReadChunkedBody: The socket read timed out and no bytes were read from the socket.\n"));
				return false;
			}
#ifdef _DEBUG
			ATLTRACE(_T("ReadChunkedBody read %d bytes from socket. Reads %d \n"), dwReadBuffSize, ++nReadCount);
#endif
			chunk_buffer_end = chunk_buffer + nChunkBuffCarryOver + dwReadBuffSize;
			nChunkBuffCarryOver = 0;
		}

		switch(cstate)
		{
		case READ_CHUNK_SIZE:
			{
				cresult = get_chunked_size(chunk_buffer, chunk_buffer_end, &nChunkSize);
				switch(cresult)
				{
				case LEX_ERROR:
					ATLTRACE(_T("ReadChunkedBody Failed retrieving chunk size\n"));
					return false;
					break;
				case LEX_OUTOFDATA:
					nChunkBuffCarryOver = (long)(chunk_buffer_end - chunk_buffer);
					if (!move_leftover_bytes((char*)t_chunk_buffer, nChunkBuffCarryOver, 
										chunk_buffer, chunk_buffer_end))
					{
						ATLTRACE(_T("failed to move leftover chunk data to head of buffer\n"));
						return false;
					}
					chunk_buffer = chunk_buffer_end = NULL;
					break;
				case LEX_OK:
					if (nChunkSize == 0)
					{
						cstate = CHUNK_READ_DATA_COMPLETE;
					}
					else if (nChunkSize + 2 > nTChunkBuffSize)
					{
						char *pBuffStart = (char*)t_chunk_buffer;
						int nReadSoFar = (int)(chunk_buffer - pBuffStart);
						int nTotal = (int)(chunk_buffer_end - pBuffStart);			
						if( FAILED(::ATL::AtlMultiply(&nTChunkBuffSize, nChunkSize, 2L)))
						{
							return false;
						}
						t_chunk_buffer.Reallocate(nTChunkBuffSize);
						pBuffStart = (char*)t_chunk_buffer;
						chunk_buffer = pBuffStart + nReadSoFar;
						chunk_buffer_end = pBuffStart + nTotal;
						cstate = READ_CHUNK_SIZE_FOOTER;
						m_dwBodyLen += nChunkSize;
					}
					else
					{
						// everything is OK. move to next state
						cstate = READ_CHUNK_SIZE_FOOTER;
						m_dwBodyLen += nChunkSize;
					}
					break;
				default:
					ATLASSERT(0);
					return false;
					break;
				}
			}
			break;
		case READ_CHUNK_DATA:
			{
				char *pDataStart = NULL;
				long nDataLen = 0;
				cresult = LEX_OK;
				cresult = get_chunked_data(chunk_buffer, chunk_buffer_end,
											nChunkSize, &pDataStart, &nDataLen);
				switch(cresult)
				{
				case LEX_ERROR:
					ATLTRACE(_T("ReadChunkedBody failed to retrieve chunk data\n"));
					return false;
					break;
				case LEX_OUTOFDATA:
					nChunkBuffCarryOver = (long)(chunk_buffer_end - chunk_buffer);
					if (!move_leftover_bytes((char*)t_chunk_buffer, nChunkBuffCarryOver, 
										chunk_buffer, chunk_buffer_end))
					{
						ATLTRACE(_T("failed to move leftover chunk data to head of buffer\n"));
						return false;
					}
					chunk_buffer = chunk_buffer_end = NULL;
					break;
				case LEX_OK:
					result_buffer.Append(pDataStart, nDataLen);
					cstate = READ_CHUNK_DATA_FOOTER;
					break;
				default:
					ATLASSERT(0);
					return false;
				}
			}
			break;
			case READ_CHUNK_SIZE_FOOTER:
			case READ_CHUNK_DATA_FOOTER:
			{
				cresult = consume_chunk_footer(chunk_buffer, chunk_buffer_end);
				switch(cresult)
				{
				case LEX_OK:
					cstate = (cstate == READ_CHUNK_SIZE_FOOTER) ? READ_CHUNK_DATA : READ_CHUNK_SIZE;
					break;
				case LEX_ERROR:
					ATLTRACE(_T("Error consuming chunk footer!\n"));
					return false;
					break;
				case LEX_OUTOFDATA:
					nChunkBuffCarryOver = (long)(chunk_buffer_end - chunk_buffer);
					if (!move_leftover_bytes((char*)t_chunk_buffer, nChunkBuffCarryOver, 
										chunk_buffer, chunk_buffer_end))
					{
						ATLTRACE(_T("failed to move leftover chunk data to head of buffer\n"));
						return false;
					}
					chunk_buffer = chunk_buffer_end = NULL;
					break;
				default:
					ATLASSERT(0);
					return false;

				}
			}
			break;
			case CHUNK_READ_DATA_COMPLETE:
			{
				// We read the chunk of size 0
				// consume the chunk footer.
				DWORD dwLen = 0;
				cresult = consume_chunk_footer(chunk_buffer, chunk_buffer_end);
				if (GetHeaderValue((_T("Trailer")), NULL, &dwLen))
				{
					cstate = READ_CHUNK_TRAILER; // start reading trailer headers
					break;
				}
				else
					bDone = true;
			}
			break;
			case READ_CHUNK_TRAILER:
				cresult = consume_chunk_trailer(chunk_buffer, chunk_buffer_end);
				switch(cresult)
				{
				case LEX_OK:
					cstate = READ_CHUNK_TRAILER; // keep reading
					break;
				case LEX_ERROR:
					ATLTRACE(_T("Error consuming chunk trailers!\n"));
					return false;
					break;
				case LEX_OUTOFDATA:
					nChunkBuffCarryOver = (long)(chunk_buffer_end - chunk_buffer);
					if (!move_leftover_bytes((char*)t_chunk_buffer, nChunkBuffCarryOver, 
										chunk_buffer, chunk_buffer_end))
					{
						ATLTRACE(_T("failed to move leftover chunk data to head of buffer\n"));
						return false;
					}
					chunk_buffer = chunk_buffer_end = NULL;
					break;
				case LEX_TRAILER_COMPLETE:
					return true;
					break;
				default:
					ATLASSERT(0);
					return false;



				}
				break;

		}
	}
	if (!m_current.Append((LPCSTR)result_buffer))
		return false;
		
	m_pEnd = ((BYTE*)(LPCSTR)m_current) + m_current.GetLength();
	
	return true;
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::ReconnectIfRequired() throw()
{
	CString strValue;
	// if we have a keep-alive header then return true
	// else we have to close and re-open the connection
	if (GetHeaderValue(_T("Connection"), strValue))
	{
		if (!strValue.CompareNoCase(_T("keep-alive")))
			return true; // server said keep connection open.
	}
	else
	{
		return true; // there was no 'Connection' header
	}

	if (!strValue.CompareNoCase(_T("close")))
	{
		Close();
		ConnectSocket();
	}   
	return false;
}

// Complete relative URLs and URLs
// that have a missing path. These are common with redirect headers.
// http://www.microsoft.com becomes http://www.microsoft.com/
// localstart.asp becomes whatever our current (m_urlCurrent) 
// path is plus localstart.asp
template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::CompleteURL(CString& strURL) throw()
{
	_ATLTRY
	{
		CString strUrlTemp = strURL;
		strUrlTemp.Trim();
		CUrl url;
		bool bErr = false;
		if (url.CrackUrl(strUrlTemp))
		{
			return true; // URL is already valid
		}


		// if we have a scheme and a host name but no
		// path, then add the path of '/'
		if (url.GetScheme() == ATL_URL_SCHEME_HTTP &&
			url.GetHostNameLength() > 0 &&
			!url.GetUrlPathLength() )
		{
			url.SetUrlPath(_T("/"));
			bErr = true;
		} 
		// if we have leading / (absolute path) (ex: /Test/bbb.asp) we can concatinate it 
		// to it to our current URL (m_urlCurrent) scheme and host 		
		else if (strUrlTemp[0] ==  _T('/'))
		{
			url = m_urlCurrent;
			url.SetUrlPath(strUrlTemp);
			bErr = true;
		}
		// relative path (ex: bbb.asp) - we don't have a valid url
		// and the first char is not /
		// Get the url from our current URL (m_urlCurrent) and add
		// our relative paths
		else
		{
			CString szPath;
			url = m_urlCurrent;

			if (!url.GetUrlPathLength())
			{
				szPath = _T('/'); // current URL has no path!
			}
			else
			{
				szPath = url.GetUrlPath();
			}
				
			// back up to the first / and insert our current url
			int pos = szPath.ReverseFind(_T('/'));
			if(pos == -1)
			{
				return false;
			}
				
			szPath.GetBufferSetLength(pos+1);
			szPath.ReleaseBuffer();

			szPath += strURL;
			url.SetUrlPath(szPath);
			bErr = true;
		}
		if (!bErr)
		{
			return bErr;
		}
		DWORD dwLen = ATL_URL_MAX_PATH_LENGTH;

		return url.CreateUrl(strURL.GetBuffer(ATL_URL_MAX_PATH_LENGTH),
			&dwLen) ? true : false;
	}
	_ATLCATCHALL()
	{
		return false;
	}
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::ProcessObjectMoved() throw()
{
	_ATLTRY
	{
		// look for a location header
		CString strValue;
		CString strURLNew;
		if (GetHeaderValue(_T("Location"), strValue))
		{			
			CString strRedirectReqHeaders=m_pNavData->szExtraHeaders;	
			ReconnectIfRequired();
			m_HeaderMap.RemoveAll();
			m_current.Empty();


			// create a new URL based on what is in the
			// Location header and set it as this object's 
			// default Url
			strURLNew = strValue;
			CompleteURL(strURLNew);
			CString strCurrHostName = m_urlCurrent.GetHostName();
			ATL_URL_PORT nCurrPort=m_urlCurrent.GetPortNumber();
			 
			SetDefaultUrl((LPCTSTR)strURLNew, m_urlCurrent.GetPortNumber());
			//If redirected (new url in strURLNew) to different host (server) or port, need a new socket.
			if (m_urlCurrent.GetHostName()!=strCurrHostName || m_urlCurrent.GetPortNumber()!=nCurrPort)
			{
				Close();
				ConnectSocket();
			}
			// build up a request. 			
			CString strRequest;
			BuildRequest(&strRequest,
						m_strMethod,
						strRedirectReqHeaders.GetString());

			// send the request
			DWORD dwSent = strRequest.GetLength();
			DWORD dwAvailable = dwSent;
			if (!Write((BYTE*)((LPCSTR)CT2A(strRequest.GetBuffer(dwAvailable))), &dwSent))
				return false;
			strRequest.ReleaseBuffer();

			if (dwSent != dwAvailable)
				return false;

			// read the response
			if (RR_OK == ReadHttpResponse())
			{
				if (m_pNavData)
					ProcessStatus(m_pNavData->dwFlags);
			}
		}
		return true;
	}
	_ATLCATCHALL()
	{
		return false;
	}
}

template<class TSocketClass>
inline bool CAtlHttpClientT<TSocketClass>::_SetDefaultUrl(LPCTSTR szURL, short nPort) throw()
{

	if (szURL)
		if (!m_urlCurrent.CrackUrl(szURL)) // re-inits the field of the CUrl first
			return false;

	ATL_URL_SCHEME currScheme = m_urlCurrent.GetScheme();
	if ( currScheme != ATL_URL_SCHEME_HTTP &&
		 !TSocketClass::SupportsScheme(currScheme) )
		return false; // only support HTTP

	if (!m_urlCurrent.GetUrlPathLength())
	{
		// no path, default to /
		m_urlCurrent.SetUrlPath(_T("/"));
	}

	if (!m_urlCurrent.GetHostNameLength())
	{
		// no server name
		return false;
	}

	if (m_urlCurrent.GetPortNumber() == ATL_URL_INVALID_PORT_NUMBER)
		m_urlCurrent.SetPortNumber(nPort);
	return true;
}

template<class TSocketClass>
inline int CAtlHttpClientT<TSocketClass>::GetStatus() throw()
{
	return m_nStatus;
}

template<class TSocketClass>
inline LPCTSTR CAtlHttpClientT<TSocketClass>::GetMethod() throw()
{
	return m_strMethod;
}

template<class TSocketClass>
inline BYTE* CAtlHttpClientT<TSocketClass>::GetPostData() throw()
{
	if (m_pNavData)
		return m_pNavData->pData;
	return NULL;
}

template<class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::GetPostDataLen() throw()
{
	if (m_pNavData)
		return m_pNavData->dwDataLen;
	return 0;
}

template<class TSocketClass>
inline LPCTSTR CAtlHttpClientT<TSocketClass>::GetPostDataType() throw()
{
	if (m_pNavData)
		return m_pNavData->szDataType;
	return NULL;
}

template<class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::GetLastError() throw()
{
	return m_dwLastError;
}

template<class TSocketClass>
inline const SOCKET& CAtlHttpClientT<TSocketClass>::GetSocket() throw()
{
	return const_cast<const SOCKET&>(m_socket);
}

template<class TSocketClass>
inline void CAtlHttpClientT<TSocketClass>::Close() throw()
{
	TSocketClass::Close();
}

template<class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::SetSocketTimeout(DWORD dwNewTimeout) throw()
{
	return TSocketClass::SetSocketTimeout(dwNewTimeout);
}

template<class TSocketClass>
inline DWORD CAtlHttpClientT<TSocketClass>::GetSocketTimeout() throw()
{
	return TSocketClass::GetSocketTimeout();
}

template<class TSocketClass>
inline void CAtlHttpClientT<TSocketClass>::AuthProtocolFailed(LPCTSTR szProto) throw()
{
	CAtlBaseAuthObject *pAuthObj = NULL;
	_ATLTRY
	{
		if (m_AuthMap.Lookup(szProto, pAuthObj) && pAuthObj)
		{
			pAuthObj->m_bFailed = true;
		}
	}
	_ATLCATCHALL()
	{
	}
}

template<class TSocketClass>
inline const ATL_NAVIGATE_DATA* CAtlHttpClientT<TSocketClass>::GetCurrentNavdata()
{
	return m_pNavData;
}


/////////////////////////////////////////////////////////////////////////////////
//
// CNTLMAuthObject
// NTLM Security Authorization functions 
//
/////////////////////////////////////////////////////////////////////////////////
inline CNTLMAuthObject::CNTLMAuthObject() throw() :
	m_pSocket(NULL),
	m_nMaxTokenSize(0),
	m_pAuthInfo(NULL),
	m_bProxy(false)
{
	SecInvalidateHandle(&m_hCredentials)
}

inline CNTLMAuthObject::CNTLMAuthObject(IAuthInfo *pAuthInfo) throw() :
	m_pSocket(NULL),
	m_nMaxTokenSize(0),
	m_pAuthInfo(pAuthInfo)
{
	SecInvalidateHandle(&m_hCredentials)
}

inline CNTLMAuthObject::~CNTLMAuthObject() throw()
{
	if (!ATL_IS_INVALIDCREDHANDLE(m_hCredentials))
		FreeCredentialsHandle(&m_hCredentials);
}

inline void CNTLMAuthObject::Init(CAtlHttpClient *pSocket, IAuthInfo *pAuthInfo) throw()
{
	m_pSocket = pSocket;
	SetAuthInfo(pAuthInfo);
}

inline void CNTLMAuthObject::SetAuthInfo(IAuthInfo *pAuthInfo) throw()
{
	m_pAuthInfo = pAuthInfo;
}

inline bool CNTLMAuthObject::Authenticate(LPCTSTR /*szAuthTypes*/, bool bProxy) throw()
{
	m_bProxy = bProxy;
	if (AcquireCredHandle())
		return DoNTLMAuthenticate();
	return false;
}

inline bool CNTLMAuthObject::AcquireCredHandle() throw()
{
	PSecPkgInfo pPackageInfo = NULL;
	SECURITY_STATUS SecurityStatus = SEC_E_OK;

	// Acquire a credentials handle on the NTLM security package
	SecurityStatus = QuerySecurityPackageInfo(ATL_HTTP_AUTHTYPE_NTLM,
							&pPackageInfo);

	if (SecurityStatus != SEC_E_OK)
		return false;

	void *pAuthData = NULL;
	CSecAuthIdentity CA;
	if (m_pAuthInfo)
	{
		// if m_pAuthInfo has been set then the caller wants us
		// to get credentials from them.
		if (CA.Init(m_pAuthInfo))
			pAuthData = static_cast<void*>(&CA);
	}

	SecurityStatus = AcquireCredentialsHandle(
					0,
					pPackageInfo->Name,
					SECPKG_CRED_OUTBOUND,
					0,
					pAuthData,
					0,
					0,
					&m_hCredentials,
					&m_ts
					);

	m_nMaxTokenSize = pPackageInfo->cbMaxToken;
	FreeContextBuffer(pPackageInfo);
	return SecurityStatus == SEC_E_OK ? true : false;
}

inline bool CNTLMAuthObject::DoNTLMAuthenticate() throw()
{
	bool bRet = false;
						
	m_CurrentRequestData = (*(const_cast<const ATL_NAVIGATE_DATA*>(m_pSocket->GetCurrentNavdata())));
	// make sure we have a good credentials handle
	ATLASSERT(!ATL_IS_INVALIDCREDHANDLE(m_hCredentials));
	if (ATL_IS_INVALIDCREDHANDLE(m_hCredentials))
		return false;

	SECURITY_STATUS SecurityStatus = SEC_E_OK;

	unsigned long ContextAttributes = 0;
	CSecBufferDesc OutBufferDesc;
	CtxtHandle SecurityContext;
	SecInvalidateHandle(&SecurityContext);

	// Create a SecBufferDesc with one buffer of m_nMaxTokenSize
	if (!OutBufferDesc.AddBuffers(1, m_nMaxTokenSize))
		return false;

	SecurityStatus = InitializeSecurityContext(
				&m_hCredentials,
				0,
				NULL,			
				ISC_REQ_CONNECTION,
				0,
				0,
				0,
				0,
				&SecurityContext,
				OutBufferDesc,
				&ContextAttributes,
				&m_ts
				);

	if ( (SecurityStatus == SEC_I_COMPLETE_NEEDED) ||
		 (SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE) )
	{
		SecurityStatus = CompleteAuthToken( &SecurityContext, (PSecBufferDesc)OutBufferDesc);
	}

	if (IS_ERROR(SecurityStatus))
		return false;

	// create an Authentication header with the contents of the
	// security buffer and send it to the HTTP server. The output
	// buffer will be pointing to a buffer that contains the 
	// response from the HTTP server on return.
	LPSTR pszbuff = NULL;
	if (!SendSecurityInfo(OutBufferDesc.Buffers(0), &pszbuff) || !pszbuff)
		return false;

	CString strVal;
	if (!m_pSocket->GetHeaderValue(m_bProxy ? g_pszProxyAuthenticate : g_pszWWWAuthenticate, strVal))
		return false; // wrong authentication type

	LPCTSTR szResponsecode = strVal;
	TCHAR pszcode[ATL_AUTH_HDR_SIZE];
	if (szResponsecode)
	{
		// first four characters better be 'NTLM'
		if (_tcsncicmp(szResponsecode, _T("NTLM"), 4) != 0)
			return false;

		// skip NTLM
		szResponsecode += 4;

		// skip space
		while (*szResponsecode && _AtlIsHttpSpace(*szResponsecode))
			szResponsecode++;

		// find end of header
		LPCTSTR pszend = szResponsecode;
		while (*pszend && *pszend != _T('\r'))
			pszend++;
		bRet = false;
		if (pszend)
		{
			// copy authentication data to our buffer
			// and base64decode it.
			int nlen = (int)(pszend-szResponsecode);
			Checked::memcpy_s(pszcode, ATL_AUTH_HDR_SIZE, szResponsecode, nlen*sizeof(TCHAR));
			pszcode[pszend-szResponsecode]=0;

			// re-use OutBufferDesc here since we'll need to need
			// a SecBufferDesc to pass to the next call to InitializeSecurityContext
			// anyways.
			if(!OutBufferDesc.Buffers(0)->ClearBuffer(m_nMaxTokenSize))
				return false;
				
			_ATLTRY
			{
				CT2A pszcode_a(pszcode);
				bRet = Base64Decode(pszcode_a,
									(int) strlen(pszcode_a), 
									(BYTE*)OutBufferDesc.Buffers(0)->pvBuffer,
									(int*) &OutBufferDesc.Buffers(0)->cbBuffer) != FALSE;
			}
			_ATLCATCHALL()
			{
				bRet = false;
			}
		}

		if (!bRet)
			return false;

		// Create buffers for the challenge data
		CSecBufferDesc *InBufferDesc = &OutBufferDesc;
		CSecBufferDesc OutBufferDesc2;
		if (!OutBufferDesc2.AddBuffers(1, m_nMaxTokenSize))
			return false;

		// Process the challenge response from the server
		SecurityStatus = InitializeSecurityContext(
					0,
					&SecurityContext,
					NULL,
					0,
					0,
					0 ,
					InBufferDesc,
					0,
					&SecurityContext,
					OutBufferDesc2,
					&ContextAttributes,
					&m_ts
					);

		if (IS_ERROR(SecurityStatus))
			return false;

		pszbuff = NULL;
		if (SendSecurityInfo(OutBufferDesc2.Buffers(0), &pszbuff))
		{
			// at this point we should be authenticated and either have the page
			// we requested or be getting re-directed to another page under our
			// authorization. Either way, we don't want to go through authorization
			// code again if we are not authorized to prevent recursive authorization
			// so we tell the client not to try this protocol again.
			if (m_pSocket->GetStatus() == 401 ||
				m_pSocket->GetStatus() == 407)
			{
				// Authorization with this protocol failed.
				// don't try it again.
				m_pSocket->AuthProtocolFailed(_T("NTLM"));
			}
			bRet = m_pSocket->ProcessStatus(m_pSocket->GetFlags());
		}
	}

	return bRet;
}
inline bool CNTLMAuthObject::GetCredentialNames(CString& theName)
{
	if (ATL_IS_INVALIDCREDHANDLE(m_hCredentials))
		return false;

	SecPkgCredentials_Names spcn;
	if(!IS_ERROR(QueryCredentialsAttributes(&m_hCredentials, 
		SECPKG_CRED_ATTR_NAMES, (void*)&spcn)))
	{
		theName = spcn.sUserName;
		return true;
	}
	return false;
}

inline bool CNTLMAuthObject::SendSecurityInfo(SecBuffer *pSecBuffer, LPSTR *pszBuffer) throw()
{
	ATLASSERT(pSecBuffer);
	ATLASSUME(m_pSocket);
	ATLASSERT(pszBuffer);

	int nDest = ATL_AUTH_HDR_SIZE;
	char auth_b64encoded[ATL_AUTH_HDR_SIZE];
	char auth_header[ATL_AUTH_HDR_SIZE];
	const char *pszFmtStr = m_bProxy ? m_pszFmtProxy : m_pszFmtWWW;

	if (!pSecBuffer || !pSecBuffer->pvBuffer || !pszBuffer)
		return false;
	*pszBuffer = 0;

	// Base64Encode will fail gracefully if buffer not big enough
	if (Base64Encode((BYTE*)pSecBuffer->pvBuffer, pSecBuffer->cbBuffer,
		auth_b64encoded, &nDest, ATL_BASE64_FLAG_NOCRLF))
	{
		if (nDest < ATL_AUTH_HDR_SIZE)
		{
			auth_b64encoded[nDest]=0;
			// make sure we have enough room in our header buffer
			if ( (strlen(pszFmtStr)-2 + nDest) < ATL_AUTH_HDR_SIZE)
#if _SECURE_ATL && !defined(_WIN32_WCE)
				sprintf_s(auth_header, ATL_AUTH_HDR_SIZE, pszFmtStr, auth_b64encoded);
#else
				_snprintf(auth_header, ATL_AUTH_HDR_SIZE, pszFmtStr, auth_b64encoded);
#endif
			else
				return false;
		}
		else
			return false;
	}
	else
		return false;

	// reset the connection if required
	m_pSocket->ResetConnection();

	// Resend the request with the authorization information
	LPCURL pUrl = m_pSocket->GetCurrentUrl();   
	bool bRet = false;

	TCHAR szUrl[ATL_URL_MAX_URL_LENGTH];
	DWORD dwMaxLen = ATL_URL_MAX_URL_LENGTH;
	if( ! pUrl->CreateUrl(szUrl, &dwMaxLen) )
		return false;

	_ATLTRY
	{
		CA2CT hdr(auth_header);
		CAtlNavigateData navigate_data(m_CurrentRequestData);
		// append authorization header to extra headers
		CString strHeaders = navigate_data.GetExtraHeaders();
		strHeaders += hdr;
		navigate_data.SetExtraHeaders(strHeaders);
		navigate_data.RemoveFlags(ATL_HTTP_FLAG_PROCESS_RESULT);

		bRet = m_pSocket->Navigate( szUrl, &navigate_data);
	}
	_ATLCATCHALL()
	{
		bRet = false;
	}
	if (bRet)
		*pszBuffer = (LPSTR)m_pSocket->GetResponse();
	return bRet;
}

/////////////////////////////////////////////////////////////////////////////////
//
// CBasicAuthObject
// BASIC Security Authorization functions 
//
/////////////////////////////////////////////////////////////////////////////////
inline bool CBasicAuthObject::DoBasicAuthenticate() throw()
{
	bool bRet = false;
	ATLASSUME(m_pClient);
	ATLASSUME(m_pAuthInfo);
	// Create an authentication string
	CTempBuffer<TCHAR, (_ATL_MAX_AUTH_BUFF*2)+2> auth_string;
	CAuthInfoBuffType buffUID;
	CAuthInfoBuffType buffPWD;

	DWORD dwUID=0,dwPWD=0;
	if (!_AtlGetAuthInfoHelper(m_pAuthInfo, &IAuthInfo::GetPassword, buffPWD, &dwPWD) ||
		!_AtlGetAuthInfoHelper(m_pAuthInfo, &IAuthInfo::GetUsername, buffUID, &dwUID))
		return false;

	_ATLTRY
	{
		if (!auth_string.Allocate((_ATL_MAX_AUTH_BUFF*2)+2))
			return false;

		Checked::tcscpy_s(auth_string, _ATL_MAX_AUTH_BUFF, buffUID);
		Checked::tcscat_s(auth_string, _ATL_MAX_AUTH_BUFF, _T(":"));
		Checked::tcscat_s(auth_string, _ATL_MAX_AUTH_BUFF, buffPWD);

		// Base64 encode the auth string
		char *auth_string_enc = NULL;
		CTempBuffer<char, 512> auth_string_buff;
		CT2A auth_string_a(auth_string);

		int nLen = Base64EncodeGetRequiredLength((int)strlen((LPSTR)auth_string_a));
		auth_string_buff.Allocate(nLen+1);
		if (!((char*)auth_string_buff))
			return false;

		auth_string_enc = (char*)auth_string_buff;
		if (!Base64Encode((const BYTE*)(LPSTR)auth_string_a, (int)strlen((LPSTR)auth_string_a),
						  auth_string_enc, &nLen, ATL_BASE64_FLAG_NOCRLF))
			return false;
		auth_string_buff[nLen]=0;

		// Format the Authentication header
#if _SECURE_ATL
		int nLenFmt = (m_bProxy ? (int)strlen(m_pszFmtProxy) : (int)strlen(m_pszFmtWWW)) + 2;
		nLen += nLenFmt;
#else
		nLen += (m_bProxy ? (int)strlen(m_pszFmtProxy) : (int)strlen(m_pszFmtWWW)) + 2;
#endif

		++nLen; // Space for '\0'
		
		CTempBuffer<char, 512> auth_header_buff;
		ATLTRY(auth_header_buff.Allocate(nLen));
		if (!((char*)auth_header_buff))
			return false;

		char *auth_header = (char*)auth_header_buff;
		Checked::strcpy_s(auth_header, nLen, m_bProxy ? m_pszFmtProxy : m_pszFmtWWW);
		Checked::strcat_s(auth_header, nLen, auth_string_enc);
		Checked::strcat_s(auth_header, nLen, "\r\n");

		// Resend the request with the authorization information
		LPCURL pUrl = m_pClient->GetCurrentUrl();
		TCHAR szUrl[ATL_URL_MAX_URL_LENGTH];
		DWORD dwMaxLen = ATL_URL_MAX_URL_LENGTH;
		pUrl->CreateUrl(szUrl, &dwMaxLen);

		// reset the connection if required
		m_pClient->ResetConnection();

		CA2T hdr(auth_header);
		CAtlNavigateData navigate_data(*(const_cast<const ATL_NAVIGATE_DATA*>(m_pClient->GetCurrentNavdata())));
		// append authorization header to extra headers
		CString strHeaders = navigate_data.GetExtraHeaders();
		strHeaders += hdr;
		navigate_data.SetExtraHeaders(strHeaders);
		navigate_data.RemoveFlags(ATL_HTTP_FLAG_PROCESS_RESULT);
		bRet = m_pClient->Navigate( szUrl,
									&navigate_data);
	}
	_ATLCATCHALL()
	{
		bRet = false;
	}

	if (bRet)
	{
		// Request was successfully sent. Process the result.
		if (m_pClient->GetStatus() == 401 ||
			m_pClient->GetStatus() == 407)
		{
			// Authorization with this protocol failed.
			// don't try it again.
			m_pClient->AuthProtocolFailed(_T("basic"));
		}
		bRet = m_pClient->ProcessStatus(m_pClient->GetFlags());
	}
	return bRet;
}

inline CBasicAuthObject::CBasicAuthObject() throw()
{
	m_pClient = NULL;
	m_pAuthInfo = NULL;
	m_szRealm[0] = 0;
	m_bProxy = false;
}

inline CBasicAuthObject::CBasicAuthObject(IAuthInfo *pAuthInfo) throw()
{
	m_pAuthInfo = pAuthInfo;
	m_pClient = NULL;
}

inline void CBasicAuthObject::SetAuthInfo(IAuthInfo *pAuthInfo) throw()
{
	m_pAuthInfo = pAuthInfo;
}

// Called by the CAtlHttpClient class to 
// authenticate a user.
inline bool CBasicAuthObject::Authenticate(LPCTSTR szAuthTypes, bool bProxy) throw()
{
	if (lstrlen(szAuthTypes) > ATL_AUTH_HDR_SIZE)
		return false;

	m_bProxy = bProxy;

	if (!CrackRealm(szAuthTypes))
		return false;
	return DoBasicAuthenticate();
}

inline LPCTSTR CBasicAuthObject::GetRealm() throw()
{
	return const_cast<LPCTSTR>(m_szRealm);
}

// Called by the CAtlHttpClient class to initialize
// this authentication object.
inline void CBasicAuthObject::Init(CAtlHttpClient *pSocket, IAuthInfo *pAuthInfo) throw()
{
	ATLASSERT(pSocket);
	m_pClient = pSocket;
	if (pAuthInfo)
		SetAuthInfo(pAuthInfo);
}

inline bool CBasicAuthObject::CrackRealm(LPCTSTR szHeader) throw()
{
	// szHeader is pointing at the
	// "basic" in the header
	// see if realm is available
	const TCHAR *pStart = szHeader;

	// skip "basic"
	pStart += 5;

	// skip space
	while (*pStart && _AtlIsHttpSpace(*pStart))
		pStart++;

	// are we pointing at 'realm'?
	if ((*pStart == 'r' || *pStart == 'R') &&
		(*(pStart+1) == 'e' || *(pStart+1) == 'E') &&
		(*(pStart+2) == 'a' || *(pStart+2) == 'A') &&
		(*(pStart+3) == 'l' || *(pStart+3) == 'L') &&
		(*(pStart+4) == 'm' || *(pStart+4) == 'M'))
	{
		// skip 'realm'
		pStart += 5;

		// skip space
		while (*pStart && _AtlIsHttpSpace(*pStart))
			pStart++;

		// skip '='
		if (*pStart && *pStart == _T('='))
			pStart++;
		else
			return false; // invalid realm

		// skip space
		while (*pStart && _AtlIsHttpSpace(*pStart))
			pStart++;

		// skip quotes if they are there
		if (*pStart == '\"')
			pStart++;

		const TCHAR *pEnd = pStart;
		while (*pEnd && *pEnd != '\"')
		{
			if (*pEnd == '\\' && *(pEnd + 1)) // escaped character, skip it
				pEnd += 2;
			else
			   pEnd++;
	   	}

		if (*pEnd == '\"' && *(pEnd+1) != '\0')
			return false; //trailing junk after the quoted realm

		if (*pEnd=='\0' || *pEnd =='\"')
		{
			int nLen = (int)(pEnd-pStart);
			if (nLen < MAX_REALM_LEN)
			{
				Checked::tcsncpy_s(m_szRealm, _countof(m_szRealm), pStart, nLen);
				m_szRealm[nLen]=0;
				if (!AtlUnescapeUrl(m_szRealm, m_szRealm, NULL, MAX_REALM_LEN))
					return false; // error unescaping the string
			}
			else
				return false;
		}
	}
	return true;
}

inline CAtlBaseAuthObject::CAtlBaseAuthObject()
{
	m_bFailed = false;
}


inline CAtlNavigateData::CAtlNavigateData() throw()
{
	dwFlags =   ATL_HTTP_FLAG_AUTO_REDIRECT|
				ATL_HTTP_FLAG_PROCESS_RESULT|
				ATL_HTTP_FLAG_SEND_BLOCKS;
	szExtraHeaders = NULL;
	szMethod = ATL_HTTP_METHOD_GET;
	nPort = ATL_URL_DEFAULT_HTTP_PORT;
	pData = NULL;
	dwDataLen = 0;
	szDataType = NULL;
	dwTimeout = ATL_SOCK_TIMEOUT;
	dwSendBlockSize = ATL_HTTP_DEFAULT_BLOCK_SIZE;
	dwReadBlockSize = ATL_HTTP_DEFAULT_BLOCK_SIZE;
	pfnChunkCallback = NULL;
	pfnSendStatusCallback = NULL;
	pfnReadStatusCallback = NULL;
	m_lParamSend = 0;
	m_lParamRead = 0;
}

inline CAtlNavigateData::CAtlNavigateData(const CAtlNavigateData &rhs)
{
	this->operator=(rhs);
}

inline CAtlNavigateData::CAtlNavigateData(const ATL_NAVIGATE_DATA &rhs)
{
	this->operator=(rhs);
}

inline CAtlNavigateData& CAtlNavigateData::operator=(const CAtlNavigateData &rhs)
{
	return this->operator=(static_cast<const ATL_NAVIGATE_DATA&>(rhs));
}

inline CAtlNavigateData& CAtlNavigateData::operator=(const ATL_NAVIGATE_DATA &rhs)
{
	dwFlags = rhs.dwFlags;
	szExtraHeaders = rhs.szExtraHeaders;
	szMethod = rhs.szMethod;
	nPort = rhs.nPort;
	pData = rhs.pData;
	dwDataLen = rhs.dwDataLen;
	szDataType = rhs.szDataType;
	dwTimeout = rhs.dwTimeout;
	dwSendBlockSize = rhs.dwSendBlockSize;
	dwReadBlockSize = rhs.dwReadBlockSize;
	pfnChunkCallback = rhs.pfnChunkCallback;
	pfnSendStatusCallback = rhs.pfnSendStatusCallback;
	pfnReadStatusCallback = rhs.pfnReadStatusCallback;
	m_lParamSend = rhs.m_lParamSend;
	m_lParamRead = rhs.m_lParamRead;
	return *this;
}

inline DWORD CAtlNavigateData::SetFlags(DWORD dwNewFlags) throw()
{
	// check for mutually exclusive flags
	if ((dwNewFlags & ATL_HTTP_FLAG_SEND_CALLBACK) &&
		(dwNewFlags & ATL_HTTP_FLAG_SEND_BLOCKS))
	{
		ATLASSERT(0);
		return ATL_HTTP_FLAG_INVALID_FLAGS;
	}

	DWORD dwOldFlags = dwFlags;
	dwFlags = dwNewFlags;
	return dwOldFlags;
}

inline DWORD CAtlNavigateData::GetFlags() throw()
{
	return dwFlags;
}

inline DWORD CAtlNavigateData::AddFlags(DWORD dwFlagsToAdd) throw()
{
		// check for mutually exclusive flags
	if (
		((dwFlagsToAdd & ATL_HTTP_FLAG_SEND_CALLBACK) &&
		 (dwFlags & ATL_HTTP_FLAG_SEND_BLOCKS)) ||
		((dwFlagsToAdd & ATL_HTTP_FLAG_SEND_BLOCKS) &&
		 (dwFlags & ATL_HTTP_FLAG_SEND_CALLBACK))
	   )
	{
		ATLASSERT(0);
		return ATL_HTTP_FLAG_INVALID_FLAGS;
	}

	DWORD dwOldFlags = dwFlags;
	dwFlags |= dwFlagsToAdd;
	return dwOldFlags;
}

inline DWORD CAtlNavigateData::RemoveFlags(DWORD dwFlagsToRemove) throw()
{
	DWORD dwOldFlags = dwFlags;
	dwFlags &= ~dwFlagsToRemove;
	return dwOldFlags;
}

inline LPCTSTR CAtlNavigateData::SetExtraHeaders(LPCTSTR szNewHeaders) throw()
{
	LPCTSTR szold = szExtraHeaders;
	szExtraHeaders = szNewHeaders;
	return szold;
}

inline LPCTSTR CAtlNavigateData::GetExtraHeaders() throw()
{
	return szExtraHeaders;  
}
inline LPCTSTR CAtlNavigateData::SetMethod(LPCTSTR szNewMethod) throw()
{
	LPCTSTR szold = szMethod;
	szMethod = szNewMethod;
	return szold;
}
inline LPCTSTR CAtlNavigateData::GetMethod() throw()
{
	return szMethod;
}
inline short CAtlNavigateData::SetPort(short newPort) throw()
{
	short oldport = nPort;
	nPort = newPort;
	return oldport;
}
inline short CAtlNavigateData::GetPort() throw()
{
	return nPort;
}
inline void CAtlNavigateData::SetPostData(BYTE *pd, DWORD len, LPCTSTR type) throw()
{
	pData = pd;
	dwDataLen = len;
	szDataType = type;
}

inline DWORD CAtlNavigateData::SetSocketTimeout(DWORD dwNewTimeout) throw()
{
	DWORD dwold = dwTimeout;
	dwTimeout = dwNewTimeout;
	return dwold;
}
inline DWORD CAtlNavigateData::GetSocketTimeout() throw()
{
	return dwTimeout;
}
inline DWORD CAtlNavigateData::SetSendBlockSize(DWORD dwNewBlockSize) throw()
{
	DWORD dwold = dwSendBlockSize;
	dwSendBlockSize = dwNewBlockSize;
	return dwold;
}
inline DWORD CAtlNavigateData::GetSendBlockSize() throw()
{
	return dwSendBlockSize;
}

inline DWORD CAtlNavigateData::SetReadBlockSize(DWORD dwNewBlockSize) throw()
{
	DWORD dwold = dwReadBlockSize;
	dwReadBlockSize = dwNewBlockSize;
	return dwold;
}

inline DWORD CAtlNavigateData::GetReadBlockSize() throw()
{
	return dwReadBlockSize;
}

inline PFNATLCHUNKEDCB CAtlNavigateData::SetChunkCallback(PFNATLCHUNKEDCB pfn, DWORD_PTR dwParam) throw()
{
	PFNATLCHUNKEDCB pold = pfnChunkCallback;
	pfnChunkCallback = pfn;
	m_lParamChunkCB = dwParam;
	return pold;
}
inline PFNATLCHUNKEDCB CAtlNavigateData::GetChunkCallback() throw()
{
	return pfnChunkCallback;
}

inline PFNATLSTATUSCALLBACK CAtlNavigateData::SetSendStatusCallback(PFNATLSTATUSCALLBACK pfn, DWORD_PTR dwData) throw()
{
	PFNATLSTATUSCALLBACK pold = pfnSendStatusCallback;
	pfnSendStatusCallback = pfn;
	m_lParamSend = dwData;
	return pold;
}

inline PFNATLSTATUSCALLBACK CAtlNavigateData::GetSendStatusCallback() throw()
{
	return pfnSendStatusCallback;
}

inline PFNATLSTATUSCALLBACK CAtlNavigateData::SetReadStatusCallback(PFNATLSTATUSCALLBACK pfn, DWORD_PTR dwData) throw()
{
	PFNATLSTATUSCALLBACK pOld = pfnReadStatusCallback;
	pfnReadStatusCallback = pfn;
	m_lParamRead = dwData;
	return pOld;
}

inline PFNATLSTATUSCALLBACK CAtlNavigateData::GetReadStatusCallback() throw()
{
	return pfnReadStatusCallback;
}

} // namespace ATL

#pragma warning(pop)

#endif // __ATLHTTP_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atliface.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0342 */
/* at Mon Feb 12 21:31:09 2001
 */
/* Compiler settings for atliface.idl:
	Oicf, W1, Zp8, env=Win32 (32b run)
	protocol : dce , ms_ext, c_ext
	error checks: allocation ref bounds_check enum stub_data 
	VC __declspec() decoration level: 
		 __declspec(uuid()), __declspec(selectany), __declspec(novtable)
		 DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __atliface_h__
#define __atliface_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRegistrarBase_FWD_DEFINED__
#define __IRegistrarBase_FWD_DEFINED__
typedef interface IRegistrarBase IRegistrarBase;
#endif 	/* __IRegistrarBase_FWD_DEFINED__ */


#ifndef __IRegistrar_FWD_DEFINED__
#define __IRegistrar_FWD_DEFINED__
typedef interface IRegistrar IRegistrar;
#endif 	/* __IRegistrar_FWD_DEFINED__ */

#if !defined(_WIN32_WCE) || defined(_CE_ACTIVEX)

#ifndef __IDocHostUIHandlerDispatch_FWD_DEFINED__
#define __IDocHostUIHandlerDispatch_FWD_DEFINED__
typedef interface IDocHostUIHandlerDispatch IDocHostUIHandlerDispatch;
#endif 	/* __IDocHostUIHandlerDispatch_FWD_DEFINED__ */


#ifndef __IAxWinHostWindow_FWD_DEFINED__
#define __IAxWinHostWindow_FWD_DEFINED__
typedef interface IAxWinHostWindow IAxWinHostWindow;
#endif 	/* __IAxWinHostWindow_FWD_DEFINED__ */


#ifndef __IAxWinHostWindowLic_FWD_DEFINED__
#define __IAxWinHostWindowLic_FWD_DEFINED__
typedef interface IAxWinHostWindowLic IAxWinHostWindowLic;
#endif 	/* __IAxWinHostWindowLic_FWD_DEFINED__ */


#ifndef __IAxWinAmbientDispatch_FWD_DEFINED__
#define __IAxWinAmbientDispatch_FWD_DEFINED__
typedef interface IAxWinAmbientDispatch IAxWinAmbientDispatch;
#endif 	/* __IAxWinAmbientDispatch_FWD_DEFINED__ */


#ifndef __IAxWinAmbientDispatchEx_FWD_DEFINED__
#define __IAxWinAmbientDispatchEx_FWD_DEFINED__
typedef interface IAxWinAmbientDispatchEx IAxWinAmbientDispatchEx;
#endif 	/* __IAxWinAmbientDispatchEx_FWD_DEFINED__ */

#endif // !defined(_WIN32_WCE) || defined(_CE_ACTIVEX)

#ifndef __IInternalConnection_FWD_DEFINED__
#define __IInternalConnection_FWD_DEFINED__
typedef interface IInternalConnection IInternalConnection;
#endif 	/* __IInternalConnection_FWD_DEFINED__ */


#ifndef __IAccessibleProxy_FWD_DEFINED__
#define __IAccessibleProxy_FWD_DEFINED__
typedef interface IAccessibleProxy IAccessibleProxy;
#endif 	/* __IAccessibleProxy_FWD_DEFINED__ */


#ifndef __IAccessibleServer_FWD_DEFINED__
#define __IAccessibleServer_FWD_DEFINED__
typedef interface IAccessibleServer IAccessibleServer;
#endif 	/* __IAccessibleServer_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#ifdef _WIN32_WCE
// WinCE's version of ocidl.h doesn't not include servprov.h
#include "servprov.h"
#endif // _WIN32_WCE
#include "oleacc.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_atliface_0000 */
/* [local] */ 

EXTERN_C const CLSID CLSID_Registrar;


extern RPC_IF_HANDLE __MIDL_itf_atliface_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_atliface_0000_v0_0_s_ifspec;

#ifndef __IRegistrarBase_INTERFACE_DEFINED__
#define __IRegistrarBase_INTERFACE_DEFINED__

/* interface IRegistrarBase */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRegistrarBase;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("e21f8a85-b05d-4243-8183-c7cb405588f7")
	IRegistrarBase : public IUnknown
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE AddReplacement( 
			/* [in] */ LPCOLESTR key,
			/* [in] */ LPCOLESTR item) = 0;

		virtual HRESULT STDMETHODCALLTYPE ClearReplacements( void) = 0;

	};

#else 	/* C style interface */

	typedef struct IRegistrarBaseVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IRegistrarBase * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IRegistrarBase * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IRegistrarBase * This);

		HRESULT ( STDMETHODCALLTYPE *AddReplacement )( 
			IRegistrarBase * This,
			/* [in] */ LPCOLESTR key,
			/* [in] */ LPCOLESTR item);

		HRESULT ( STDMETHODCALLTYPE *ClearReplacements )( 
			IRegistrarBase * This);

		END_INTERFACE
	} IRegistrarBaseVtbl;

	interface IRegistrarBase
	{
		CONST_VTBL struct IRegistrarBaseVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IRegistrarBase_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegistrarBase_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IRegistrarBase_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IRegistrarBase_AddReplacement(This,key,item)	\
	(This)->lpVtbl -> AddReplacement(This,key,item)

#define IRegistrarBase_ClearReplacements(This)	\
	(This)->lpVtbl -> ClearReplacements(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRegistrarBase_AddReplacement_Proxy( 
	IRegistrarBase * This,
	/* [in] */ LPCOLESTR key,
	/* [in] */ LPCOLESTR item);


void __RPC_STUB IRegistrarBase_AddReplacement_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrarBase_ClearReplacements_Proxy( 
	IRegistrarBase * This);


void __RPC_STUB IRegistrarBase_ClearReplacements_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IRegistrarBase_INTERFACE_DEFINED__ */


#ifndef __IRegistrar_INTERFACE_DEFINED__
#define __IRegistrar_INTERFACE_DEFINED__

/* interface IRegistrar */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("44EC053B-400F-11D0-9DCD-00A0C90391D3")
	IRegistrar : public IRegistrarBase
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE ResourceRegisterSz( 
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ LPCOLESTR szID,
			/* [in] */ LPCOLESTR szType) = 0;

		virtual HRESULT STDMETHODCALLTYPE ResourceUnregisterSz( 
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ LPCOLESTR szID,
			/* [in] */ LPCOLESTR szType) = 0;

		virtual HRESULT STDMETHODCALLTYPE FileRegister( 
			/* [in] */ LPCOLESTR fileName) = 0;

		virtual HRESULT STDMETHODCALLTYPE FileUnregister( 
			/* [in] */ LPCOLESTR fileName) = 0;

		virtual HRESULT STDMETHODCALLTYPE StringRegister( 
			/* [in] */ LPCOLESTR data) = 0;

		virtual HRESULT STDMETHODCALLTYPE StringUnregister( 
			/* [in] */ LPCOLESTR data) = 0;

		virtual HRESULT STDMETHODCALLTYPE ResourceRegister( 
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ UINT nID,
			/* [in] */ LPCOLESTR szType) = 0;

		virtual HRESULT STDMETHODCALLTYPE ResourceUnregister( 
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ UINT nID,
			/* [in] */ LPCOLESTR szType) = 0;

	};

#else 	/* C style interface */

	typedef struct IRegistrarVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IRegistrar * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IRegistrar * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IRegistrar * This);

		HRESULT ( STDMETHODCALLTYPE *AddReplacement )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR key,
			/* [in] */ LPCOLESTR item);

		HRESULT ( STDMETHODCALLTYPE *ClearReplacements )( 
			IRegistrar * This);

		HRESULT ( STDMETHODCALLTYPE *ResourceRegisterSz )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ LPCOLESTR szID,
			/* [in] */ LPCOLESTR szType);

		HRESULT ( STDMETHODCALLTYPE *ResourceUnregisterSz )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ LPCOLESTR szID,
			/* [in] */ LPCOLESTR szType);

		HRESULT ( STDMETHODCALLTYPE *FileRegister )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR fileName);

		HRESULT ( STDMETHODCALLTYPE *FileUnregister )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR fileName);

		HRESULT ( STDMETHODCALLTYPE *StringRegister )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR data);

		HRESULT ( STDMETHODCALLTYPE *StringUnregister )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR data);

		HRESULT ( STDMETHODCALLTYPE *ResourceRegister )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ UINT nID,
			/* [in] */ LPCOLESTR szType);

		HRESULT ( STDMETHODCALLTYPE *ResourceUnregister )( 
			IRegistrar * This,
			/* [in] */ LPCOLESTR resFileName,
			/* [in] */ UINT nID,
			/* [in] */ LPCOLESTR szType);

		END_INTERFACE
	} IRegistrarVtbl;

	interface IRegistrar
	{
		CONST_VTBL struct IRegistrarVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IRegistrar_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegistrar_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IRegistrar_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IRegistrar_AddReplacement(This,key,item)	\
	(This)->lpVtbl -> AddReplacement(This,key,item)

#define IRegistrar_ClearReplacements(This)	\
	(This)->lpVtbl -> ClearReplacements(This)


#define IRegistrar_ResourceRegisterSz(This,resFileName,szID,szType)	\
	(This)->lpVtbl -> ResourceRegisterSz(This,resFileName,szID,szType)

#define IRegistrar_ResourceUnregisterSz(This,resFileName,szID,szType)	\
	(This)->lpVtbl -> ResourceUnregisterSz(This,resFileName,szID,szType)

#define IRegistrar_FileRegister(This,fileName)	\
	(This)->lpVtbl -> FileRegister(This,fileName)

#define IRegistrar_FileUnregister(This,fileName)	\
	(This)->lpVtbl -> FileUnregister(This,fileName)

#define IRegistrar_StringRegister(This,data)	\
	(This)->lpVtbl -> StringRegister(This,data)

#define IRegistrar_StringUnregister(This,data)	\
	(This)->lpVtbl -> StringUnregister(This,data)

#define IRegistrar_ResourceRegister(This,resFileName,nID,szType)	\
	(This)->lpVtbl -> ResourceRegister(This,resFileName,nID,szType)

#define IRegistrar_ResourceUnregister(This,resFileName,nID,szType)	\
	(This)->lpVtbl -> ResourceUnregister(This,resFileName,nID,szType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRegistrar_ResourceRegisterSz_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR resFileName,
	/* [in] */ LPCOLESTR szID,
	/* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceRegisterSz_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_ResourceUnregisterSz_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR resFileName,
	/* [in] */ LPCOLESTR szID,
	/* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceUnregisterSz_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_FileRegister_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR fileName);


void __RPC_STUB IRegistrar_FileRegister_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_FileUnregister_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR fileName);


void __RPC_STUB IRegistrar_FileUnregister_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_StringRegister_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR data);


void __RPC_STUB IRegistrar_StringRegister_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_StringUnregister_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR data);


void __RPC_STUB IRegistrar_StringUnregister_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_ResourceRegister_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR resFileName,
	/* [in] */ UINT nID,
	/* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceRegister_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_ResourceUnregister_Proxy( 
	IRegistrar * This,
	/* [in] */ LPCOLESTR resFileName,
	/* [in] */ UINT nID,
	/* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceUnregister_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IRegistrar_INTERFACE_DEFINED__ */

#if !defined(_WIN32_WCE) || defined(_CE_ACTIVEX)

#ifndef __IDocHostUIHandlerDispatch_INTERFACE_DEFINED__
#define __IDocHostUIHandlerDispatch_INTERFACE_DEFINED__

/* interface IDocHostUIHandlerDispatch */
/* [object][unique][helpstring][uuid][local] */ 

typedef 
enum tagDOCHOSTUIDBLCLKDispatch
	{	docHostUIDblClkDEFAULT	= 0,
	docHostUIDblClkSHOWPROPERTIES	= 1,
	docHostUIDblClkSHOWCODE	= 2
	} 	DOCHOSTUIDBLCLKDispatch;

typedef 
enum tagDocHostUIFlagDispatch
	{	docHostUIFlagDIALOG	= 1,
	docHostUIFlagDISABLE_HELP_MENU	= 2,
	docHostUIFlagNO3DBORDER	= 4,
	docHostUIFlagSCROLL_NO	= 8,
	docHostUIFlagDISABLE_SCRIPT_INACTIVE	= 16,
	docHostUIFlagOPENNEWWIN	= 32,
	docHostUIFlagDISABLE_OFFSCREEN	= 64,
	docHostUIFlagFLAT_SCROLLBAR	= 128,
	docHostUIFlagDIV_BLOCKDEFAULT	= 256,
	docHostUIFlagACTIVATE_CLIENTHIT_ONLY	= 512
	} 	DocHostUIFlagDispatch;


EXTERN_C const IID IID_IDocHostUIHandlerDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("425B5AF0-65F1-11d1-9611-0000F81E0D0D")
	IDocHostUIHandlerDispatch : public IDispatch
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE ShowContextMenu( 
			/* [in] */ DWORD dwID,
			/* [in] */ DWORD x,
			/* [in] */ DWORD y,
			/* [in] */ IUnknown *pcmdtReserved,
			/* [in] */ IDispatch *pdispReserved,
			/* [retval][out] */ HRESULT *dwRetVal) = 0;

		virtual HRESULT STDMETHODCALLTYPE GetHostInfo( 
			/* [out][in] */ DWORD *pdwFlags,
			/* [out][in] */ DWORD *pdwDoubleClick) = 0;

		virtual HRESULT STDMETHODCALLTYPE ShowUI( 
			/* [in] */ DWORD dwID,
			/* [in] */ IUnknown *pActiveObject,
			/* [in] */ IUnknown *pCommandTarget,
			/* [in] */ IUnknown *pFrame,
			/* [in] */ IUnknown *pDoc,
			/* [retval][out] */ HRESULT *dwRetVal) = 0;

		virtual HRESULT STDMETHODCALLTYPE HideUI( void) = 0;

		virtual HRESULT STDMETHODCALLTYPE UpdateUI( void) = 0;

		virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
			/* [in] */ VARIANT_BOOL fEnable) = 0;

		virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate( 
			/* [in] */ VARIANT_BOOL fActivate) = 0;

		virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate( 
			/* [in] */ VARIANT_BOOL fActivate) = 0;

		virtual HRESULT STDMETHODCALLTYPE ResizeBorder( 
			/* [in] */ long left,
			/* [in] */ long top,
			/* [in] */ long right,
			/* [in] */ long bottom,
			/* [in] */ IUnknown *pUIWindow,
			/* [in] */ VARIANT_BOOL fFrameWindow) = 0;

		virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
			/* [in] */ DWORD_PTR hWnd,
			/* [in] */ DWORD nMessage,
			/* [in] */ DWORD_PTR wParam,
			/* [in] */ DWORD_PTR lParam,
			/* [in] */ BSTR bstrGuidCmdGroup,
			/* [in] */ DWORD nCmdID,
			/* [retval][out] */ HRESULT *dwRetVal) = 0;

		virtual HRESULT STDMETHODCALLTYPE GetOptionKeyPath( 
			/* [out] */ BSTR *pbstrKey,
			/* [in] */ DWORD dw) = 0;

		virtual HRESULT STDMETHODCALLTYPE GetDropTarget( 
			/* [in] */ IUnknown *pDropTarget,
			/* [out] */ IUnknown **ppDropTarget) = 0;

		virtual HRESULT STDMETHODCALLTYPE GetExternal( 
			/* [out] */ IDispatch **ppDispatch) = 0;

		virtual HRESULT STDMETHODCALLTYPE TranslateUrl( 
			/* [in] */ DWORD dwTranslate,
			/* [in] */ BSTR bstrURLIn,
			/* [out] */ BSTR *pbstrURLOut) = 0;

		virtual HRESULT STDMETHODCALLTYPE FilterDataObject( 
			/* [in] */ IUnknown *pDO,
			/* [out] */ IUnknown **ppDORet) = 0;

	};

#else 	/* C style interface */

	typedef struct IDocHostUIHandlerDispatchVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IDocHostUIHandlerDispatch * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IDocHostUIHandlerDispatch * This);

		HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
			IDocHostUIHandlerDispatch * This,
			/* [out] */ UINT *pctinfo);

		HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ UINT iTInfo,
			/* [in] */ LCID lcid,
			/* [out] */ ITypeInfo **ppTInfo);

		HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ REFIID riid,
			/* [size_is][in] */ LPOLESTR *rgszNames,
			/* [in] */ UINT cNames,
			/* [in] */ LCID lcid,
			/* [size_is][out] */ DISPID *rgDispId);

		/* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ DISPID dispIdMember,
			/* [in] */ REFIID riid,
			/* [in] */ LCID lcid,
			/* [in] */ WORD wFlags,
			/* [out][in] */ DISPPARAMS *pDispParams,
			/* [out] */ VARIANT *pVarResult,
			/* [out] */ EXCEPINFO *pExcepInfo,
			/* [out] */ UINT *puArgErr);

		HRESULT ( STDMETHODCALLTYPE *ShowContextMenu )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ DWORD dwID,
			/* [in] */ DWORD x,
			/* [in] */ DWORD y,
			/* [in] */ IUnknown *pcmdtReserved,
			/* [in] */ IDispatch *pdispReserved,
			/* [retval][out] */ HRESULT *dwRetVal);

		HRESULT ( STDMETHODCALLTYPE *GetHostInfo )( 
			IDocHostUIHandlerDispatch * This,
			/* [out][in] */ DWORD *pdwFlags,
			/* [out][in] */ DWORD *pdwDoubleClick);

		HRESULT ( STDMETHODCALLTYPE *ShowUI )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ DWORD dwID,
			/* [in] */ IUnknown *pActiveObject,
			/* [in] */ IUnknown *pCommandTarget,
			/* [in] */ IUnknown *pFrame,
			/* [in] */ IUnknown *pDoc,
			/* [retval][out] */ HRESULT *dwRetVal);

		HRESULT ( STDMETHODCALLTYPE *HideUI )( 
			IDocHostUIHandlerDispatch * This);

		HRESULT ( STDMETHODCALLTYPE *UpdateUI )( 
			IDocHostUIHandlerDispatch * This);

		HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ VARIANT_BOOL fEnable);

		HRESULT ( STDMETHODCALLTYPE *OnDocWindowActivate )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ VARIANT_BOOL fActivate);

		HRESULT ( STDMETHODCALLTYPE *OnFrameWindowActivate )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ VARIANT_BOOL fActivate);

		HRESULT ( STDMETHODCALLTYPE *ResizeBorder )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ long left,
			/* [in] */ long top,
			/* [in] */ long right,
			/* [in] */ long bottom,
			/* [in] */ IUnknown *pUIWindow,
			/* [in] */ VARIANT_BOOL fFrameWindow);

		HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ DWORD_PTR hWnd,
			/* [in] */ DWORD nMessage,
			/* [in] */ DWORD_PTR wParam,
			/* [in] */ DWORD_PTR lParam,
			/* [in] */ BSTR bstrGuidCmdGroup,
			/* [in] */ DWORD nCmdID,
			/* [retval][out] */ HRESULT *dwRetVal);

		HRESULT ( STDMETHODCALLTYPE *GetOptionKeyPath )( 
			IDocHostUIHandlerDispatch * This,
			/* [out] */ BSTR *pbstrKey,
			/* [in] */ DWORD dw);

		HRESULT ( STDMETHODCALLTYPE *GetDropTarget )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ IUnknown *pDropTarget,
			/* [out] */ IUnknown **ppDropTarget);

		HRESULT ( STDMETHODCALLTYPE *GetExternal )( 
			IDocHostUIHandlerDispatch * This,
			/* [out] */ IDispatch **ppDispatch);

		HRESULT ( STDMETHODCALLTYPE *TranslateUrl )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ DWORD dwTranslate,
			/* [in] */ BSTR bstrURLIn,
			/* [out] */ BSTR *pbstrURLOut);

		HRESULT ( STDMETHODCALLTYPE *FilterDataObject )( 
			IDocHostUIHandlerDispatch * This,
			/* [in] */ IUnknown *pDO,
			/* [out] */ IUnknown **ppDORet);

		END_INTERFACE
	} IDocHostUIHandlerDispatchVtbl;

	interface IDocHostUIHandlerDispatch
	{
		CONST_VTBL struct IDocHostUIHandlerDispatchVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IDocHostUIHandlerDispatch_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDocHostUIHandlerDispatch_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IDocHostUIHandlerDispatch_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IDocHostUIHandlerDispatch_GetTypeInfoCount(This,pctinfo)	\
	(This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDocHostUIHandlerDispatch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
	(This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDocHostUIHandlerDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
	(This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDocHostUIHandlerDispatch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
	(This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDocHostUIHandlerDispatch_ShowContextMenu(This,dwID,x,y,pcmdtReserved,pdispReserved,dwRetVal)	\
	(This)->lpVtbl -> ShowContextMenu(This,dwID,x,y,pcmdtReserved,pdispReserved,dwRetVal)

#define IDocHostUIHandlerDispatch_GetHostInfo(This,pdwFlags,pdwDoubleClick)	\
	(This)->lpVtbl -> GetHostInfo(This,pdwFlags,pdwDoubleClick)

#define IDocHostUIHandlerDispatch_ShowUI(This,dwID,pActiveObject,pCommandTarget,pFrame,pDoc,dwRetVal)	\
	(This)->lpVtbl -> ShowUI(This,dwID,pActiveObject,pCommandTarget,pFrame,pDoc,dwRetVal)

#define IDocHostUIHandlerDispatch_HideUI(This)	\
	(This)->lpVtbl -> HideUI(This)

#define IDocHostUIHandlerDispatch_UpdateUI(This)	\
	(This)->lpVtbl -> UpdateUI(This)

#define IDocHostUIHandlerDispatch_EnableModeless(This,fEnable)	\
	(This)->lpVtbl -> EnableModeless(This,fEnable)

#define IDocHostUIHandlerDispatch_OnDocWindowActivate(This,fActivate)	\
	(This)->lpVtbl -> OnDocWindowActivate(This,fActivate)

#define IDocHostUIHandlerDispatch_OnFrameWindowActivate(This,fActivate)	\
	(This)->lpVtbl -> OnFrameWindowActivate(This,fActivate)

#define IDocHostUIHandlerDispatch_ResizeBorder(This,left,top,right,bottom,pUIWindow,fFrameWindow)	\
	(This)->lpVtbl -> ResizeBorder(This,left,top,right,bottom,pUIWindow,fFrameWindow)

#define IDocHostUIHandlerDispatch_TranslateAccelerator(This,hWnd,nMessage,wParam,lParam,bstrGuidCmdGroup,nCmdID,dwRetVal)	\
	(This)->lpVtbl -> TranslateAccelerator(This,hWnd,nMessage,wParam,lParam,bstrGuidCmdGroup,nCmdID,dwRetVal)

#define IDocHostUIHandlerDispatch_GetOptionKeyPath(This,pbstrKey,dw)	\
	(This)->lpVtbl -> GetOptionKeyPath(This,pbstrKey,dw)

#define IDocHostUIHandlerDispatch_GetDropTarget(This,pDropTarget,ppDropTarget)	\
	(This)->lpVtbl -> GetDropTarget(This,pDropTarget,ppDropTarget)

#define IDocHostUIHandlerDispatch_GetExternal(This,ppDispatch)	\
	(This)->lpVtbl -> GetExternal(This,ppDispatch)

#define IDocHostUIHandlerDispatch_TranslateUrl(This,dwTranslate,bstrURLIn,pbstrURLOut)	\
	(This)->lpVtbl -> TranslateUrl(This,dwTranslate,bstrURLIn,pbstrURLOut)

#define IDocHostUIHandlerDispatch_FilterDataObject(This,pDO,ppDORet)	\
	(This)->lpVtbl -> FilterDataObject(This,pDO,ppDORet)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_ShowContextMenu_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ DWORD dwID,
	/* [in] */ DWORD x,
	/* [in] */ DWORD y,
	/* [in] */ IUnknown *pcmdtReserved,
	/* [in] */ IDispatch *pdispReserved,
	/* [retval][out] */ HRESULT *dwRetVal);


void __RPC_STUB IDocHostUIHandlerDispatch_ShowContextMenu_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetHostInfo_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [out][in] */ DWORD *pdwFlags,
	/* [out][in] */ DWORD *pdwDoubleClick);


void __RPC_STUB IDocHostUIHandlerDispatch_GetHostInfo_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_ShowUI_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ DWORD dwID,
	/* [in] */ IUnknown *pActiveObject,
	/* [in] */ IUnknown *pCommandTarget,
	/* [in] */ IUnknown *pFrame,
	/* [in] */ IUnknown *pDoc,
	/* [retval][out] */ HRESULT *dwRetVal);


void __RPC_STUB IDocHostUIHandlerDispatch_ShowUI_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_HideUI_Proxy( 
	IDocHostUIHandlerDispatch * This);


void __RPC_STUB IDocHostUIHandlerDispatch_HideUI_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_UpdateUI_Proxy( 
	IDocHostUIHandlerDispatch * This);


void __RPC_STUB IDocHostUIHandlerDispatch_UpdateUI_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_EnableModeless_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ VARIANT_BOOL fEnable);


void __RPC_STUB IDocHostUIHandlerDispatch_EnableModeless_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_OnDocWindowActivate_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ VARIANT_BOOL fActivate);


void __RPC_STUB IDocHostUIHandlerDispatch_OnDocWindowActivate_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_OnFrameWindowActivate_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ VARIANT_BOOL fActivate);


void __RPC_STUB IDocHostUIHandlerDispatch_OnFrameWindowActivate_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_ResizeBorder_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ long left,
	/* [in] */ long top,
	/* [in] */ long right,
	/* [in] */ long bottom,
	/* [in] */ IUnknown *pUIWindow,
	/* [in] */ VARIANT_BOOL fFrameWindow);


void __RPC_STUB IDocHostUIHandlerDispatch_ResizeBorder_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_TranslateAccelerator_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ DWORD_PTR hWnd,
	/* [in] */ DWORD nMessage,
	/* [in] */ DWORD_PTR wParam,
	/* [in] */ DWORD_PTR lParam,
	/* [in] */ BSTR bstrGuidCmdGroup,
	/* [in] */ DWORD nCmdID,
	/* [retval][out] */ HRESULT *dwRetVal);


void __RPC_STUB IDocHostUIHandlerDispatch_TranslateAccelerator_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetOptionKeyPath_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [out] */ BSTR *pbstrKey,
	/* [in] */ DWORD dw);


void __RPC_STUB IDocHostUIHandlerDispatch_GetOptionKeyPath_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetDropTarget_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ IUnknown *pDropTarget,
	/* [out] */ IUnknown **ppDropTarget);


void __RPC_STUB IDocHostUIHandlerDispatch_GetDropTarget_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_GetExternal_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [out] */ IDispatch **ppDispatch);


void __RPC_STUB IDocHostUIHandlerDispatch_GetExternal_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_TranslateUrl_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ DWORD dwTranslate,
	/* [in] */ BSTR bstrURLIn,
	/* [out] */ BSTR *pbstrURLOut);


void __RPC_STUB IDocHostUIHandlerDispatch_TranslateUrl_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandlerDispatch_FilterDataObject_Proxy( 
	IDocHostUIHandlerDispatch * This,
	/* [in] */ IUnknown *pDO,
	/* [out] */ IUnknown **ppDORet);


void __RPC_STUB IDocHostUIHandlerDispatch_FilterDataObject_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IDocHostUIHandlerDispatch_INTERFACE_DEFINED__ */


#ifndef __IAxWinHostWindow_INTERFACE_DEFINED__
#define __IAxWinHostWindow_INTERFACE_DEFINED__

/* interface IAxWinHostWindow */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IAxWinHostWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("B6EA2050-048A-11d1-82B9-00C04FB9942E")
	IAxWinHostWindow : public IUnknown
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE CreateControl( 
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream) = 0;

		virtual HRESULT STDMETHODCALLTYPE CreateControlEx( 
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream,
			/* [out] */ IUnknown **ppUnk,
			/* [in] */ REFIID riidAdvise,
			/* [in] */ IUnknown *punkAdvise) = 0;

		virtual HRESULT STDMETHODCALLTYPE AttachControl( 
			/* [in] */ IUnknown *pUnkControl,
			/* [in] */ HWND hWnd) = 0;

		virtual HRESULT STDMETHODCALLTYPE QueryControl( 
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject) = 0;

		virtual HRESULT STDMETHODCALLTYPE SetExternalDispatch( 
			/* [in] */ IDispatch *pDisp) = 0;

		virtual HRESULT STDMETHODCALLTYPE SetExternalUIHandler( 
			/* [in] */ IDocHostUIHandlerDispatch *pDisp) = 0;

	};

#else 	/* C style interface */

	typedef struct IAxWinHostWindowVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IAxWinHostWindow * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IAxWinHostWindow * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IAxWinHostWindow * This);

		HRESULT ( STDMETHODCALLTYPE *CreateControl )( 
			IAxWinHostWindow * This,
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream);

		HRESULT ( STDMETHODCALLTYPE *CreateControlEx )( 
			IAxWinHostWindow * This,
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream,
			/* [out] */ IUnknown **ppUnk,
			/* [in] */ REFIID riidAdvise,
			/* [in] */ IUnknown *punkAdvise);

		HRESULT ( STDMETHODCALLTYPE *AttachControl )( 
			IAxWinHostWindow * This,
			/* [in] */ IUnknown *pUnkControl,
			/* [in] */ HWND hWnd);

		HRESULT ( STDMETHODCALLTYPE *QueryControl )( 
			IAxWinHostWindow * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		HRESULT ( STDMETHODCALLTYPE *SetExternalDispatch )( 
			IAxWinHostWindow * This,
			/* [in] */ IDispatch *pDisp);

		HRESULT ( STDMETHODCALLTYPE *SetExternalUIHandler )( 
			IAxWinHostWindow * This,
			/* [in] */ IDocHostUIHandlerDispatch *pDisp);

		END_INTERFACE
	} IAxWinHostWindowVtbl;

	interface IAxWinHostWindow
	{
		CONST_VTBL struct IAxWinHostWindowVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IAxWinHostWindow_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinHostWindow_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IAxWinHostWindow_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IAxWinHostWindow_CreateControl(This,lpTricsData,hWnd,pStream)	\
	(This)->lpVtbl -> CreateControl(This,lpTricsData,hWnd,pStream)

#define IAxWinHostWindow_CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)	\
	(This)->lpVtbl -> CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)

#define IAxWinHostWindow_AttachControl(This,pUnkControl,hWnd)	\
	(This)->lpVtbl -> AttachControl(This,pUnkControl,hWnd)

#define IAxWinHostWindow_QueryControl(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryControl(This,riid,ppvObject)

#define IAxWinHostWindow_SetExternalDispatch(This,pDisp)	\
	(This)->lpVtbl -> SetExternalDispatch(This,pDisp)

#define IAxWinHostWindow_SetExternalUIHandler(This,pDisp)	\
	(This)->lpVtbl -> SetExternalUIHandler(This,pDisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAxWinHostWindow_CreateControl_Proxy( 
	IAxWinHostWindow * This,
	/* [in] */ LPCOLESTR lpTricsData,
	/* [in] */ HWND hWnd,
	/* [in] */ IStream *pStream);


void __RPC_STUB IAxWinHostWindow_CreateControl_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_CreateControlEx_Proxy( 
	IAxWinHostWindow * This,
	/* [in] */ LPCOLESTR lpTricsData,
	/* [in] */ HWND hWnd,
	/* [in] */ IStream *pStream,
	/* [out] */ IUnknown **ppUnk,
	/* [in] */ REFIID riidAdvise,
	/* [in] */ IUnknown *punkAdvise);


void __RPC_STUB IAxWinHostWindow_CreateControlEx_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_AttachControl_Proxy( 
	IAxWinHostWindow * This,
	/* [in] */ IUnknown *pUnkControl,
	/* [in] */ HWND hWnd);


void __RPC_STUB IAxWinHostWindow_AttachControl_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_QueryControl_Proxy( 
	IAxWinHostWindow * This,
	/* [in] */ REFIID riid,
	/* [iid_is][out] */ void **ppvObject);


void __RPC_STUB IAxWinHostWindow_QueryControl_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_SetExternalDispatch_Proxy( 
	IAxWinHostWindow * This,
	/* [in] */ IDispatch *pDisp);


void __RPC_STUB IAxWinHostWindow_SetExternalDispatch_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindow_SetExternalUIHandler_Proxy( 
	IAxWinHostWindow * This,
	/* [in] */ IDocHostUIHandlerDispatch *pDisp);


void __RPC_STUB IAxWinHostWindow_SetExternalUIHandler_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IAxWinHostWindow_INTERFACE_DEFINED__ */


#ifndef __IAxWinHostWindowLic_INTERFACE_DEFINED__
#define __IAxWinHostWindowLic_INTERFACE_DEFINED__

/* interface IAxWinHostWindowLic */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IAxWinHostWindowLic;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("3935BDA8-4ED9-495c-8650-E01FC1E38A4B")
	IAxWinHostWindowLic : public IAxWinHostWindow
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE CreateControlLic( 
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream,
			/* [in] */ BSTR bstrLic) = 0;

		virtual HRESULT STDMETHODCALLTYPE CreateControlLicEx( 
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream,
			/* [out] */ IUnknown **ppUnk,
			/* [in] */ REFIID riidAdvise,
			/* [in] */ IUnknown *punkAdvise,
			/* [in] */ BSTR bstrLic) = 0;

	};

#else 	/* C style interface */

	typedef struct IAxWinHostWindowLicVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IAxWinHostWindowLic * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IAxWinHostWindowLic * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IAxWinHostWindowLic * This);

		HRESULT ( STDMETHODCALLTYPE *CreateControl )( 
			IAxWinHostWindowLic * This,
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream);

		HRESULT ( STDMETHODCALLTYPE *CreateControlEx )( 
			IAxWinHostWindowLic * This,
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream,
			/* [out] */ IUnknown **ppUnk,
			/* [in] */ REFIID riidAdvise,
			/* [in] */ IUnknown *punkAdvise);

		HRESULT ( STDMETHODCALLTYPE *AttachControl )( 
			IAxWinHostWindowLic * This,
			/* [in] */ IUnknown *pUnkControl,
			/* [in] */ HWND hWnd);

		HRESULT ( STDMETHODCALLTYPE *QueryControl )( 
			IAxWinHostWindowLic * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		HRESULT ( STDMETHODCALLTYPE *SetExternalDispatch )( 
			IAxWinHostWindowLic * This,
			/* [in] */ IDispatch *pDisp);

		HRESULT ( STDMETHODCALLTYPE *SetExternalUIHandler )( 
			IAxWinHostWindowLic * This,
			/* [in] */ IDocHostUIHandlerDispatch *pDisp);

		HRESULT ( STDMETHODCALLTYPE *CreateControlLic )( 
			IAxWinHostWindowLic * This,
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream,
			/* [in] */ BSTR bstrLic);

		HRESULT ( STDMETHODCALLTYPE *CreateControlLicEx )( 
			IAxWinHostWindowLic * This,
			/* [in] */ LPCOLESTR lpTricsData,
			/* [in] */ HWND hWnd,
			/* [in] */ IStream *pStream,
			/* [out] */ IUnknown **ppUnk,
			/* [in] */ REFIID riidAdvise,
			/* [in] */ IUnknown *punkAdvise,
			/* [in] */ BSTR bstrLic);

		END_INTERFACE
	} IAxWinHostWindowLicVtbl;

	interface IAxWinHostWindowLic
	{
		CONST_VTBL struct IAxWinHostWindowLicVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IAxWinHostWindowLic_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinHostWindowLic_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IAxWinHostWindowLic_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IAxWinHostWindowLic_CreateControl(This,lpTricsData,hWnd,pStream)	\
	(This)->lpVtbl -> CreateControl(This,lpTricsData,hWnd,pStream)

#define IAxWinHostWindowLic_CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)	\
	(This)->lpVtbl -> CreateControlEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise)

#define IAxWinHostWindowLic_AttachControl(This,pUnkControl,hWnd)	\
	(This)->lpVtbl -> AttachControl(This,pUnkControl,hWnd)

#define IAxWinHostWindowLic_QueryControl(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryControl(This,riid,ppvObject)

#define IAxWinHostWindowLic_SetExternalDispatch(This,pDisp)	\
	(This)->lpVtbl -> SetExternalDispatch(This,pDisp)

#define IAxWinHostWindowLic_SetExternalUIHandler(This,pDisp)	\
	(This)->lpVtbl -> SetExternalUIHandler(This,pDisp)


#define IAxWinHostWindowLic_CreateControlLic(This,lpTricsData,hWnd,pStream,bstrLic)	\
	(This)->lpVtbl -> CreateControlLic(This,lpTricsData,hWnd,pStream,bstrLic)

#define IAxWinHostWindowLic_CreateControlLicEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise,bstrLic)	\
	(This)->lpVtbl -> CreateControlLicEx(This,lpTricsData,hWnd,pStream,ppUnk,riidAdvise,punkAdvise,bstrLic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAxWinHostWindowLic_CreateControlLic_Proxy( 
	IAxWinHostWindowLic * This,
	/* [in] */ LPCOLESTR lpTricsData,
	/* [in] */ HWND hWnd,
	/* [in] */ IStream *pStream,
	/* [in] */ BSTR bstrLic);


void __RPC_STUB IAxWinHostWindowLic_CreateControlLic_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAxWinHostWindowLic_CreateControlLicEx_Proxy( 
	IAxWinHostWindowLic * This,
	/* [in] */ LPCOLESTR lpTricsData,
	/* [in] */ HWND hWnd,
	/* [in] */ IStream *pStream,
	/* [out] */ IUnknown **ppUnk,
	/* [in] */ REFIID riidAdvise,
	/* [in] */ IUnknown *punkAdvise,
	/* [in] */ BSTR bstrLic);


void __RPC_STUB IAxWinHostWindowLic_CreateControlLicEx_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IAxWinHostWindowLic_INTERFACE_DEFINED__ */


#ifndef __IAxWinAmbientDispatch_INTERFACE_DEFINED__
#define __IAxWinAmbientDispatch_INTERFACE_DEFINED__

/* interface IAxWinAmbientDispatch */
/* [unique][helpstring][uuid][dual][object] */ 


EXTERN_C const IID IID_IAxWinAmbientDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("B6EA2051-048A-11d1-82B9-00C04FB9942E")
	IAxWinAmbientDispatch : public IDispatch
	{
	public:
		virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowWindowlessActivation( 
			/* [in] */ VARIANT_BOOL bCanWindowlessActivate) = 0;

		virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowWindowlessActivation( 
			/* [retval][out] */ VARIANT_BOOL *pbCanWindowlessActivate) = 0;

		virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
			/* [in] */ OLE_COLOR clrBackground) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
			/* [retval][out] */ OLE_COLOR *pclrBackground) = 0;

		virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
			/* [in] */ OLE_COLOR clrForeground) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
			/* [retval][out] */ OLE_COLOR *pclrForeground) = 0;

		virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_LocaleID( 
			/* [in] */ LCID lcidLocaleID) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LocaleID( 
			/* [retval][out] */ LCID *plcidLocaleID) = 0;

		virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_UserMode( 
			/* [in] */ VARIANT_BOOL bUserMode) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UserMode( 
			/* [retval][out] */ VARIANT_BOOL *pbUserMode) = 0;

		virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DisplayAsDefault( 
			/* [in] */ VARIANT_BOOL bDisplayAsDefault) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayAsDefault( 
			/* [retval][out] */ VARIANT_BOOL *pbDisplayAsDefault) = 0;

		virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Font( 
			/* [in] */ IFontDisp *pFont) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Font( 
			/* [retval][out] */ IFontDisp **pFont) = 0;

		virtual /* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MessageReflect( 
			/* [in] */ VARIANT_BOOL bMsgReflect) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MessageReflect( 
			/* [retval][out] */ VARIANT_BOOL *pbMsgReflect) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ShowGrabHandles( 
			/* [retval][out] */ VARIANT_BOOL *pbShowGrabHandles) = 0;

		virtual /* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ShowHatching( 
			/* [retval][out] */ VARIANT_BOOL *pbShowHatching) = 0;

		virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DocHostFlags( 
			/* [in] */ DWORD dwDocHostFlags) = 0;

		virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DocHostFlags( 
			/* [retval][out] */ DWORD *pdwDocHostFlags) = 0;

		virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DocHostDoubleClickFlags( 
			/* [in] */ DWORD dwDocHostDoubleClickFlags) = 0;

		virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DocHostDoubleClickFlags( 
			/* [retval][out] */ DWORD *pdwDocHostDoubleClickFlags) = 0;

		virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowContextMenu( 
			/* [in] */ VARIANT_BOOL bAllowContextMenu) = 0;

		virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowContextMenu( 
			/* [retval][out] */ VARIANT_BOOL *pbAllowContextMenu) = 0;

		virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowShowUI( 
			/* [in] */ VARIANT_BOOL bAllowShowUI) = 0;

		virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowShowUI( 
			/* [retval][out] */ VARIANT_BOOL *pbAllowShowUI) = 0;

		virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_OptionKeyPath( 
			/* [in] */ BSTR bstrOptionKeyPath) = 0;

		virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OptionKeyPath( 
			/* [retval][out] */ BSTR *pbstrOptionKeyPath) = 0;

	};

#else 	/* C style interface */

	typedef struct IAxWinAmbientDispatchVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IAxWinAmbientDispatch * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IAxWinAmbientDispatch * This);

		HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
			IAxWinAmbientDispatch * This,
			/* [out] */ UINT *pctinfo);

		HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ UINT iTInfo,
			/* [in] */ LCID lcid,
			/* [out] */ ITypeInfo **ppTInfo);

		HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ REFIID riid,
			/* [size_is][in] */ LPOLESTR *rgszNames,
			/* [in] */ UINT cNames,
			/* [in] */ LCID lcid,
			/* [size_is][out] */ DISPID *rgDispId);

		/* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ DISPID dispIdMember,
			/* [in] */ REFIID riid,
			/* [in] */ LCID lcid,
			/* [in] */ WORD wFlags,
			/* [out][in] */ DISPPARAMS *pDispParams,
			/* [out] */ VARIANT *pVarResult,
			/* [out] */ EXCEPINFO *pExcepInfo,
			/* [out] */ UINT *puArgErr);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowWindowlessActivation )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ VARIANT_BOOL bCanWindowlessActivate);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowWindowlessActivation )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbCanWindowlessActivate);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ OLE_COLOR clrBackground);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ OLE_COLOR *pclrBackground);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ OLE_COLOR clrForeground);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ OLE_COLOR *pclrForeground);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocaleID )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ LCID lcidLocaleID);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocaleID )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ LCID *plcidLocaleID);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UserMode )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ VARIANT_BOOL bUserMode);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserMode )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbUserMode);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayAsDefault )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ VARIANT_BOOL bDisplayAsDefault);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayAsDefault )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbDisplayAsDefault);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Font )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ IFontDisp *pFont);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ IFontDisp **pFont);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MessageReflect )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ VARIANT_BOOL bMsgReflect);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageReflect )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbMsgReflect);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowGrabHandles )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbShowGrabHandles);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowHatching )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbShowHatching);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DocHostFlags )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ DWORD dwDocHostFlags);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocHostFlags )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ DWORD *pdwDocHostFlags);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DocHostDoubleClickFlags )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ DWORD dwDocHostDoubleClickFlags);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocHostDoubleClickFlags )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ DWORD *pdwDocHostDoubleClickFlags);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowContextMenu )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ VARIANT_BOOL bAllowContextMenu);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowContextMenu )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbAllowContextMenu);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowShowUI )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ VARIANT_BOOL bAllowShowUI);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowShowUI )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ VARIANT_BOOL *pbAllowShowUI);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OptionKeyPath )( 
			IAxWinAmbientDispatch * This,
			/* [in] */ BSTR bstrOptionKeyPath);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OptionKeyPath )( 
			IAxWinAmbientDispatch * This,
			/* [retval][out] */ BSTR *pbstrOptionKeyPath);

		END_INTERFACE
	} IAxWinAmbientDispatchVtbl;

	interface IAxWinAmbientDispatch
	{
		CONST_VTBL struct IAxWinAmbientDispatchVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IAxWinAmbientDispatch_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinAmbientDispatch_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IAxWinAmbientDispatch_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IAxWinAmbientDispatch_GetTypeInfoCount(This,pctinfo)	\
	(This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAxWinAmbientDispatch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
	(This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAxWinAmbientDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
	(This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAxWinAmbientDispatch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
	(This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAxWinAmbientDispatch_put_AllowWindowlessActivation(This,bCanWindowlessActivate)	\
	(This)->lpVtbl -> put_AllowWindowlessActivation(This,bCanWindowlessActivate)

#define IAxWinAmbientDispatch_get_AllowWindowlessActivation(This,pbCanWindowlessActivate)	\
	(This)->lpVtbl -> get_AllowWindowlessActivation(This,pbCanWindowlessActivate)

#define IAxWinAmbientDispatch_put_BackColor(This,clrBackground)	\
	(This)->lpVtbl -> put_BackColor(This,clrBackground)

#define IAxWinAmbientDispatch_get_BackColor(This,pclrBackground)	\
	(This)->lpVtbl -> get_BackColor(This,pclrBackground)

#define IAxWinAmbientDispatch_put_ForeColor(This,clrForeground)	\
	(This)->lpVtbl -> put_ForeColor(This,clrForeground)

#define IAxWinAmbientDispatch_get_ForeColor(This,pclrForeground)	\
	(This)->lpVtbl -> get_ForeColor(This,pclrForeground)

#define IAxWinAmbientDispatch_put_LocaleID(This,lcidLocaleID)	\
	(This)->lpVtbl -> put_LocaleID(This,lcidLocaleID)

#define IAxWinAmbientDispatch_get_LocaleID(This,plcidLocaleID)	\
	(This)->lpVtbl -> get_LocaleID(This,plcidLocaleID)

#define IAxWinAmbientDispatch_put_UserMode(This,bUserMode)	\
	(This)->lpVtbl -> put_UserMode(This,bUserMode)

#define IAxWinAmbientDispatch_get_UserMode(This,pbUserMode)	\
	(This)->lpVtbl -> get_UserMode(This,pbUserMode)

#define IAxWinAmbientDispatch_put_DisplayAsDefault(This,bDisplayAsDefault)	\
	(This)->lpVtbl -> put_DisplayAsDefault(This,bDisplayAsDefault)

#define IAxWinAmbientDispatch_get_DisplayAsDefault(This,pbDisplayAsDefault)	\
	(This)->lpVtbl -> get_DisplayAsDefault(This,pbDisplayAsDefault)

#define IAxWinAmbientDispatch_put_Font(This,pFont)	\
	(This)->lpVtbl -> put_Font(This,pFont)

#define IAxWinAmbientDispatch_get_Font(This,pFont)	\
	(This)->lpVtbl -> get_Font(This,pFont)

#define IAxWinAmbientDispatch_put_MessageReflect(This,bMsgReflect)	\
	(This)->lpVtbl -> put_MessageReflect(This,bMsgReflect)

#define IAxWinAmbientDispatch_get_MessageReflect(This,pbMsgReflect)	\
	(This)->lpVtbl -> get_MessageReflect(This,pbMsgReflect)

#define IAxWinAmbientDispatch_get_ShowGrabHandles(This,pbShowGrabHandles)	\
	(This)->lpVtbl -> get_ShowGrabHandles(This,pbShowGrabHandles)

#define IAxWinAmbientDispatch_get_ShowHatching(This,pbShowHatching)	\
	(This)->lpVtbl -> get_ShowHatching(This,pbShowHatching)

#define IAxWinAmbientDispatch_put_DocHostFlags(This,dwDocHostFlags)	\
	(This)->lpVtbl -> put_DocHostFlags(This,dwDocHostFlags)

#define IAxWinAmbientDispatch_get_DocHostFlags(This,pdwDocHostFlags)	\
	(This)->lpVtbl -> get_DocHostFlags(This,pdwDocHostFlags)

#define IAxWinAmbientDispatch_put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)	\
	(This)->lpVtbl -> put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatch_get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)	\
	(This)->lpVtbl -> get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatch_put_AllowContextMenu(This,bAllowContextMenu)	\
	(This)->lpVtbl -> put_AllowContextMenu(This,bAllowContextMenu)

#define IAxWinAmbientDispatch_get_AllowContextMenu(This,pbAllowContextMenu)	\
	(This)->lpVtbl -> get_AllowContextMenu(This,pbAllowContextMenu)

#define IAxWinAmbientDispatch_put_AllowShowUI(This,bAllowShowUI)	\
	(This)->lpVtbl -> put_AllowShowUI(This,bAllowShowUI)

#define IAxWinAmbientDispatch_get_AllowShowUI(This,pbAllowShowUI)	\
	(This)->lpVtbl -> get_AllowShowUI(This,pbAllowShowUI)

#define IAxWinAmbientDispatch_put_OptionKeyPath(This,bstrOptionKeyPath)	\
	(This)->lpVtbl -> put_OptionKeyPath(This,bstrOptionKeyPath)

#define IAxWinAmbientDispatch_get_OptionKeyPath(This,pbstrOptionKeyPath)	\
	(This)->lpVtbl -> get_OptionKeyPath(This,pbstrOptionKeyPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_AllowWindowlessActivation_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ VARIANT_BOOL bCanWindowlessActivate);


void __RPC_STUB IAxWinAmbientDispatch_put_AllowWindowlessActivation_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_AllowWindowlessActivation_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbCanWindowlessActivate);


void __RPC_STUB IAxWinAmbientDispatch_get_AllowWindowlessActivation_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_BackColor_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ OLE_COLOR clrBackground);


void __RPC_STUB IAxWinAmbientDispatch_put_BackColor_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_BackColor_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ OLE_COLOR *pclrBackground);


void __RPC_STUB IAxWinAmbientDispatch_get_BackColor_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_ForeColor_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ OLE_COLOR clrForeground);


void __RPC_STUB IAxWinAmbientDispatch_put_ForeColor_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_ForeColor_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ OLE_COLOR *pclrForeground);


void __RPC_STUB IAxWinAmbientDispatch_get_ForeColor_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_LocaleID_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ LCID lcidLocaleID);


void __RPC_STUB IAxWinAmbientDispatch_put_LocaleID_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_LocaleID_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ LCID *plcidLocaleID);


void __RPC_STUB IAxWinAmbientDispatch_get_LocaleID_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_UserMode_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ VARIANT_BOOL bUserMode);


void __RPC_STUB IAxWinAmbientDispatch_put_UserMode_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_UserMode_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbUserMode);


void __RPC_STUB IAxWinAmbientDispatch_get_UserMode_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_DisplayAsDefault_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ VARIANT_BOOL bDisplayAsDefault);


void __RPC_STUB IAxWinAmbientDispatch_put_DisplayAsDefault_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_DisplayAsDefault_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbDisplayAsDefault);


void __RPC_STUB IAxWinAmbientDispatch_get_DisplayAsDefault_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_Font_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ IFontDisp *pFont);


void __RPC_STUB IAxWinAmbientDispatch_put_Font_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_Font_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ IFontDisp **pFont);


void __RPC_STUB IAxWinAmbientDispatch_get_Font_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_MessageReflect_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ VARIANT_BOOL bMsgReflect);


void __RPC_STUB IAxWinAmbientDispatch_put_MessageReflect_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_MessageReflect_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbMsgReflect);


void __RPC_STUB IAxWinAmbientDispatch_get_MessageReflect_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_ShowGrabHandles_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbShowGrabHandles);


void __RPC_STUB IAxWinAmbientDispatch_get_ShowGrabHandles_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [id][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_ShowHatching_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbShowHatching);


void __RPC_STUB IAxWinAmbientDispatch_get_ShowHatching_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_DocHostFlags_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ DWORD dwDocHostFlags);


void __RPC_STUB IAxWinAmbientDispatch_put_DocHostFlags_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_DocHostFlags_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ DWORD *pdwDocHostFlags);


void __RPC_STUB IAxWinAmbientDispatch_get_DocHostFlags_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_DocHostDoubleClickFlags_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ DWORD dwDocHostDoubleClickFlags);


void __RPC_STUB IAxWinAmbientDispatch_put_DocHostDoubleClickFlags_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_DocHostDoubleClickFlags_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ DWORD *pdwDocHostDoubleClickFlags);


void __RPC_STUB IAxWinAmbientDispatch_get_DocHostDoubleClickFlags_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_AllowContextMenu_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ VARIANT_BOOL bAllowContextMenu);


void __RPC_STUB IAxWinAmbientDispatch_put_AllowContextMenu_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_AllowContextMenu_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbAllowContextMenu);


void __RPC_STUB IAxWinAmbientDispatch_get_AllowContextMenu_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_AllowShowUI_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ VARIANT_BOOL bAllowShowUI);


void __RPC_STUB IAxWinAmbientDispatch_put_AllowShowUI_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_AllowShowUI_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ VARIANT_BOOL *pbAllowShowUI);


void __RPC_STUB IAxWinAmbientDispatch_get_AllowShowUI_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_put_OptionKeyPath_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [in] */ BSTR bstrOptionKeyPath);


void __RPC_STUB IAxWinAmbientDispatch_put_OptionKeyPath_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatch_get_OptionKeyPath_Proxy( 
	IAxWinAmbientDispatch * This,
	/* [retval][out] */ BSTR *pbstrOptionKeyPath);


void __RPC_STUB IAxWinAmbientDispatch_get_OptionKeyPath_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IAxWinAmbientDispatch_INTERFACE_DEFINED__ */


#ifndef __IAxWinAmbientDispatchEx_INTERFACE_DEFINED__
#define __IAxWinAmbientDispatchEx_INTERFACE_DEFINED__

/* interface IAxWinAmbientDispatchEx */
/* [unique][helpstring][uuid][dual][object] */ 


EXTERN_C const IID IID_IAxWinAmbientDispatchEx;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("B2D0778B-AC99-4c58-A5C8-E7724E5316B5")
	IAxWinAmbientDispatchEx : public IAxWinAmbientDispatch
	{
	public:
		virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetAmbientDispatch( 
			/* [in] */ IDispatch *pDispatch) = 0;

	};

#else 	/* C style interface */

	typedef struct IAxWinAmbientDispatchExVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IAxWinAmbientDispatchEx * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IAxWinAmbientDispatchEx * This);

		HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
			IAxWinAmbientDispatchEx * This,
			/* [out] */ UINT *pctinfo);

		HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ UINT iTInfo,
			/* [in] */ LCID lcid,
			/* [out] */ ITypeInfo **ppTInfo);

		HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ REFIID riid,
			/* [size_is][in] */ LPOLESTR *rgszNames,
			/* [in] */ UINT cNames,
			/* [in] */ LCID lcid,
			/* [size_is][out] */ DISPID *rgDispId);

		/* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ DISPID dispIdMember,
			/* [in] */ REFIID riid,
			/* [in] */ LCID lcid,
			/* [in] */ WORD wFlags,
			/* [out][in] */ DISPPARAMS *pDispParams,
			/* [out] */ VARIANT *pVarResult,
			/* [out] */ EXCEPINFO *pExcepInfo,
			/* [out] */ UINT *puArgErr);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowWindowlessActivation )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ VARIANT_BOOL bCanWindowlessActivate);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowWindowlessActivation )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbCanWindowlessActivate);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ OLE_COLOR clrBackground);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ OLE_COLOR *pclrBackground);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ OLE_COLOR clrForeground);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ OLE_COLOR *pclrForeground);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocaleID )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ LCID lcidLocaleID);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocaleID )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ LCID *plcidLocaleID);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UserMode )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ VARIANT_BOOL bUserMode);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserMode )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbUserMode);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayAsDefault )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ VARIANT_BOOL bDisplayAsDefault);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayAsDefault )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbDisplayAsDefault);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Font )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ IFontDisp *pFont);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ IFontDisp **pFont);

		/* [id][helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MessageReflect )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ VARIANT_BOOL bMsgReflect);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageReflect )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbMsgReflect);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowGrabHandles )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbShowGrabHandles);

		/* [id][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowHatching )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbShowHatching);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DocHostFlags )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ DWORD dwDocHostFlags);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocHostFlags )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ DWORD *pdwDocHostFlags);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DocHostDoubleClickFlags )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ DWORD dwDocHostDoubleClickFlags);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocHostDoubleClickFlags )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ DWORD *pdwDocHostDoubleClickFlags);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowContextMenu )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ VARIANT_BOOL bAllowContextMenu);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowContextMenu )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbAllowContextMenu);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowShowUI )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ VARIANT_BOOL bAllowShowUI);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowShowUI )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ VARIANT_BOOL *pbAllowShowUI);

		/* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OptionKeyPath )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ BSTR bstrOptionKeyPath);

		/* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OptionKeyPath )( 
			IAxWinAmbientDispatchEx * This,
			/* [retval][out] */ BSTR *pbstrOptionKeyPath);

		/* [id] */ HRESULT ( STDMETHODCALLTYPE *SetAmbientDispatch )( 
			IAxWinAmbientDispatchEx * This,
			/* [in] */ IDispatch *pDispatch);

		END_INTERFACE
	} IAxWinAmbientDispatchExVtbl;

	interface IAxWinAmbientDispatchEx
	{
		CONST_VTBL struct IAxWinAmbientDispatchExVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IAxWinAmbientDispatchEx_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAxWinAmbientDispatchEx_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IAxWinAmbientDispatchEx_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IAxWinAmbientDispatchEx_GetTypeInfoCount(This,pctinfo)	\
	(This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAxWinAmbientDispatchEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
	(This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAxWinAmbientDispatchEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
	(This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAxWinAmbientDispatchEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
	(This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAxWinAmbientDispatchEx_put_AllowWindowlessActivation(This,bCanWindowlessActivate)	\
	(This)->lpVtbl -> put_AllowWindowlessActivation(This,bCanWindowlessActivate)

#define IAxWinAmbientDispatchEx_get_AllowWindowlessActivation(This,pbCanWindowlessActivate)	\
	(This)->lpVtbl -> get_AllowWindowlessActivation(This,pbCanWindowlessActivate)

#define IAxWinAmbientDispatchEx_put_BackColor(This,clrBackground)	\
	(This)->lpVtbl -> put_BackColor(This,clrBackground)

#define IAxWinAmbientDispatchEx_get_BackColor(This,pclrBackground)	\
	(This)->lpVtbl -> get_BackColor(This,pclrBackground)

#define IAxWinAmbientDispatchEx_put_ForeColor(This,clrForeground)	\
	(This)->lpVtbl -> put_ForeColor(This,clrForeground)

#define IAxWinAmbientDispatchEx_get_ForeColor(This,pclrForeground)	\
	(This)->lpVtbl -> get_ForeColor(This,pclrForeground)

#define IAxWinAmbientDispatchEx_put_LocaleID(This,lcidLocaleID)	\
	(This)->lpVtbl -> put_LocaleID(This,lcidLocaleID)

#define IAxWinAmbientDispatchEx_get_LocaleID(This,plcidLocaleID)	\
	(This)->lpVtbl -> get_LocaleID(This,plcidLocaleID)

#define IAxWinAmbientDispatchEx_put_UserMode(This,bUserMode)	\
	(This)->lpVtbl -> put_UserMode(This,bUserMode)

#define IAxWinAmbientDispatchEx_get_UserMode(This,pbUserMode)	\
	(This)->lpVtbl -> get_UserMode(This,pbUserMode)

#define IAxWinAmbientDispatchEx_put_DisplayAsDefault(This,bDisplayAsDefault)	\
	(This)->lpVtbl -> put_DisplayAsDefault(This,bDisplayAsDefault)

#define IAxWinAmbientDispatchEx_get_DisplayAsDefault(This,pbDisplayAsDefault)	\
	(This)->lpVtbl -> get_DisplayAsDefault(This,pbDisplayAsDefault)

#define IAxWinAmbientDispatchEx_put_Font(This,pFont)	\
	(This)->lpVtbl -> put_Font(This,pFont)

#define IAxWinAmbientDispatchEx_get_Font(This,pFont)	\
	(This)->lpVtbl -> get_Font(This,pFont)

#define IAxWinAmbientDispatchEx_put_MessageReflect(This,bMsgReflect)	\
	(This)->lpVtbl -> put_MessageReflect(This,bMsgReflect)

#define IAxWinAmbientDispatchEx_get_MessageReflect(This,pbMsgReflect)	\
	(This)->lpVtbl -> get_MessageReflect(This,pbMsgReflect)

#define IAxWinAmbientDispatchEx_get_ShowGrabHandles(This,pbShowGrabHandles)	\
	(This)->lpVtbl -> get_ShowGrabHandles(This,pbShowGrabHandles)

#define IAxWinAmbientDispatchEx_get_ShowHatching(This,pbShowHatching)	\
	(This)->lpVtbl -> get_ShowHatching(This,pbShowHatching)

#define IAxWinAmbientDispatchEx_put_DocHostFlags(This,dwDocHostFlags)	\
	(This)->lpVtbl -> put_DocHostFlags(This,dwDocHostFlags)

#define IAxWinAmbientDispatchEx_get_DocHostFlags(This,pdwDocHostFlags)	\
	(This)->lpVtbl -> get_DocHostFlags(This,pdwDocHostFlags)

#define IAxWinAmbientDispatchEx_put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)	\
	(This)->lpVtbl -> put_DocHostDoubleClickFlags(This,dwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatchEx_get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)	\
	(This)->lpVtbl -> get_DocHostDoubleClickFlags(This,pdwDocHostDoubleClickFlags)

#define IAxWinAmbientDispatchEx_put_AllowContextMenu(This,bAllowContextMenu)	\
	(This)->lpVtbl -> put_AllowContextMenu(This,bAllowContextMenu)

#define IAxWinAmbientDispatchEx_get_AllowContextMenu(This,pbAllowContextMenu)	\
	(This)->lpVtbl -> get_AllowContextMenu(This,pbAllowContextMenu)

#define IAxWinAmbientDispatchEx_put_AllowShowUI(This,bAllowShowUI)	\
	(This)->lpVtbl -> put_AllowShowUI(This,bAllowShowUI)

#define IAxWinAmbientDispatchEx_get_AllowShowUI(This,pbAllowShowUI)	\
	(This)->lpVtbl -> get_AllowShowUI(This,pbAllowShowUI)

#define IAxWinAmbientDispatchEx_put_OptionKeyPath(This,bstrOptionKeyPath)	\
	(This)->lpVtbl -> put_OptionKeyPath(This,bstrOptionKeyPath)

#define IAxWinAmbientDispatchEx_get_OptionKeyPath(This,pbstrOptionKeyPath)	\
	(This)->lpVtbl -> get_OptionKeyPath(This,pbstrOptionKeyPath)


#define IAxWinAmbientDispatchEx_SetAmbientDispatch(This,pDispatch)	\
	(This)->lpVtbl -> SetAmbientDispatch(This,pDispatch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IAxWinAmbientDispatchEx_SetAmbientDispatch_Proxy( 
	IAxWinAmbientDispatchEx * This,
	/* [in] */ IDispatch *pDispatch);


void __RPC_STUB IAxWinAmbientDispatchEx_SetAmbientDispatch_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IAxWinAmbientDispatchEx_INTERFACE_DEFINED__ */

#endif // !defined(_WIN32_WCE) || defined(_CE_ACTIVEX)

#ifndef __IInternalConnection_INTERFACE_DEFINED__
#define __IInternalConnection_INTERFACE_DEFINED__

/* interface IInternalConnection */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IInternalConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("72AD0770-6A9F-11d1-BCEC-0060088F444E")
	IInternalConnection : public IUnknown
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE AddConnection( void) = 0;

		virtual HRESULT STDMETHODCALLTYPE ReleaseConnection( void) = 0;

	};

#else 	/* C style interface */

	typedef struct IInternalConnectionVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IInternalConnection * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IInternalConnection * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IInternalConnection * This);

		HRESULT ( STDMETHODCALLTYPE *AddConnection )( 
			IInternalConnection * This);

		HRESULT ( STDMETHODCALLTYPE *ReleaseConnection )( 
			IInternalConnection * This);

		END_INTERFACE
	} IInternalConnectionVtbl;

	interface IInternalConnection
	{
		CONST_VTBL struct IInternalConnectionVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IInternalConnection_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternalConnection_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IInternalConnection_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IInternalConnection_AddConnection(This)	\
	(This)->lpVtbl -> AddConnection(This)

#define IInternalConnection_ReleaseConnection(This)	\
	(This)->lpVtbl -> ReleaseConnection(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInternalConnection_AddConnection_Proxy( 
	IInternalConnection * This);


void __RPC_STUB IInternalConnection_AddConnection_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternalConnection_ReleaseConnection_Proxy( 
	IInternalConnection * This);


void __RPC_STUB IInternalConnection_ReleaseConnection_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IInternalConnection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_atliface_0257 */
/* [local] */ 


#pragma pack(push,_ATL_PACKING)
namespace ATL
{
#ifdef __cplusplus
#include <atldef.h>
#else
#define ATLAPI EXTERN_C HRESULT __declspec(dllimport) __stdcall
#define ATLAPI_(x) EXTERN_C __declspec(dllimport) x __stdcall
#define ATLINLINE
#endif	// __cplusplus

ATLAPI_(INT_PTR) AtlAxDialogBoxW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
ATLAPI_(INT_PTR) AtlAxDialogBoxA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
#ifdef UNICODE
#define AtlAxDialogBox AtlAxDialogBoxW
#else
#define AtlAxDialogBox AtlAxDialogBoxA
#endif

ATLAPI_(HWND) AtlAxCreateDialogW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
ATLAPI_(HWND) AtlAxCreateDialogA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogProc, LPARAM dwInitParam);
#ifdef UNICODE
#define AtlAxCreateDialog AtlAxCreateDialogW
#else
#define AtlAxCreateDialog AtlAxCreateDialogA
#endif

ATLAPI AtlAxCreateControl(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer);
#ifdef __cplusplus
ATLAPI AtlAxCreateControlEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
		IUnknown** ppUnkContainer, IUnknown** ppUnkControl, 
		REFIID iidSink=IID_NULL, IUnknown* punkSink=NULL);
ATLAPI AtlAxCreateControlLic(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer, BSTR bstrLic = NULL);
ATLAPI AtlAxCreateControlLicEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
		IUnknown** ppUnkContainer, IUnknown** ppUnkControl, 
		REFIID iidSink=IID_NULL, IUnknown* punkSink=NULL, BSTR bstrLic = NULL);
#else
ATLAPI AtlAxCreateControlEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
		IUnknown** ppUnkContainer, IUnknown** ppUnkControl, 
		REFIID iidSink, IUnknown* punkSink);
ATLAPI AtlAxCreateControlLic(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer, BSTR bstrLic);
ATLAPI AtlAxCreateControlLicEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
		IUnknown** ppUnkContainer, IUnknown** ppUnkControl, 
		REFIID iidSink, IUnknown* punkSink, BSTR bstrLic);
#endif	// __cplusplus
ATLAPI AtlAxAttachControl(IUnknown* pControl, HWND hWnd, IUnknown** ppUnkContainer);
ATLAPI_(BOOL) AtlAxWinInit();

ATLAPI AtlAxGetHost(HWND h, IUnknown** pp);
ATLAPI AtlAxGetControl(HWND h, IUnknown** pp);

}; //namespace ATL
#pragma pack(pop)

extern RPC_IF_HANDLE __MIDL_itf_atliface_0257_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_atliface_0257_v0_0_s_ifspec;

#ifndef __IAccessibleProxy_INTERFACE_DEFINED__
#define __IAccessibleProxy_INTERFACE_DEFINED__

/* interface IAccessibleProxy */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IAccessibleProxy;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("7A7D9DCF-B7A1-4019-9031-258268846980")
	IAccessibleProxy : public IUnknown
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE SetServer( 
			/* [in] */ IAccessible *pAccessible,
			/* [in] */ IAccessibleServer *pServer) = 0;

	};

#else 	/* C style interface */

	typedef struct IAccessibleProxyVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IAccessibleProxy * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IAccessibleProxy * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IAccessibleProxy * This);

		HRESULT ( STDMETHODCALLTYPE *SetServer )( 
			IAccessibleProxy * This,
			/* [in] */ IAccessible *pAccessible,
			/* [in] */ IAccessibleServer *pServer);

		END_INTERFACE
	} IAccessibleProxyVtbl;

	interface IAccessibleProxy
	{
		CONST_VTBL struct IAccessibleProxyVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IAccessibleProxy_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccessibleProxy_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IAccessibleProxy_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IAccessibleProxy_SetServer(This,pAccessible,pServer)	\
	(This)->lpVtbl -> SetServer(This,pAccessible,pServer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAccessibleProxy_SetServer_Proxy( 
	IAccessibleProxy * This,
	/* [in] */ IAccessible *pAccessible,
	/* [in] */ IAccessibleServer *pServer);


void __RPC_STUB IAccessibleProxy_SetServer_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IAccessibleProxy_INTERFACE_DEFINED__ */


#ifndef __IAccessibleServer_INTERFACE_DEFINED__
#define __IAccessibleServer_INTERFACE_DEFINED__

/* interface IAccessibleServer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAccessibleServer;

#if defined(__cplusplus) && !defined(CINTERFACE)

	MIDL_INTERFACE("52C8FB5E-D779-4e77-AE9F-F611FA7E9D7A")
	IAccessibleServer : public IUnknown
	{
	public:
		virtual HRESULT STDMETHODCALLTYPE SetProxy( 
			/* [in] */ IAccessibleProxy *pUnknown) = 0;

		virtual HRESULT STDMETHODCALLTYPE GetHWND( 
			/* [out] */ HWND *phWnd) = 0;

		virtual HRESULT STDMETHODCALLTYPE GetEnumVariant( 
			/* [out] */ IEnumVARIANT **ppEnumVariant) = 0;

	};

#else 	/* C style interface */

	typedef struct IAccessibleServerVtbl
	{
		BEGIN_INTERFACE

		HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
			IAccessibleServer * This,
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ void **ppvObject);

		ULONG ( STDMETHODCALLTYPE *AddRef )( 
			IAccessibleServer * This);

		ULONG ( STDMETHODCALLTYPE *Release )( 
			IAccessibleServer * This);

		HRESULT ( STDMETHODCALLTYPE *SetProxy )( 
			IAccessibleServer * This,
			/* [in] */ IAccessibleProxy *pUnknown);

		HRESULT ( STDMETHODCALLTYPE *GetHWND )( 
			IAccessibleServer * This,
			/* [out] */ HWND *phWnd);

		HRESULT ( STDMETHODCALLTYPE *GetEnumVariant )( 
			IAccessibleServer * This,
			/* [out] */ IEnumVARIANT **ppEnumVariant);

		END_INTERFACE
	} IAccessibleServerVtbl;

	interface IAccessibleServer
	{
		CONST_VTBL struct IAccessibleServerVtbl *lpVtbl;
	};



#ifdef COBJMACROS


#define IAccessibleServer_QueryInterface(This,riid,ppvObject)	\
	(This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccessibleServer_AddRef(This)	\
	(This)->lpVtbl -> AddRef(This)

#define IAccessibleServer_Release(This)	\
	(This)->lpVtbl -> Release(This)


#define IAccessibleServer_SetProxy(This,pUnknown)	\
	(This)->lpVtbl -> SetProxy(This,pUnknown)

#define IAccessibleServer_GetHWND(This,phWnd)	\
	(This)->lpVtbl -> GetHWND(This,phWnd)

#define IAccessibleServer_GetEnumVariant(This,ppEnumVariant)	\
	(This)->lpVtbl -> GetEnumVariant(This,ppEnumVariant)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAccessibleServer_SetProxy_Proxy( 
	IAccessibleServer * This,
	/* [in] */ IAccessibleProxy *pUnknown);


void __RPC_STUB IAccessibleServer_SetProxy_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccessibleServer_GetHWND_Proxy( 
	IAccessibleServer * This,
	/* [out] */ HWND *phWnd);


void __RPC_STUB IAccessibleServer_GetHWND_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccessibleServer_GetEnumVariant_Proxy( 
	IAccessibleServer * This,
	/* [out] */ IEnumVARIANT **ppEnumVariant);


void __RPC_STUB IAccessibleServer_GetEnumVariant_Stub(
	IRpcStubBuffer *This,
	IRpcChannelBuffer *_pRpcChannelBuffer,
	PRPC_MESSAGE _pRpcMessage,
	DWORD *_pdwStubPhase);



#endif 	/* __IAccessibleServer_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlmem.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLMEM_H__
#define __ATLMEM_H__

#pragma once

#include <atlcore.h>
#include <limits.h>


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

template< typename N >
inline N WINAPI AtlAlignUp( N n, ULONG nAlign ) throw()
{
	return( N( (n+(nAlign-1))&~(N( nAlign )-1) ) );
}

template< typename N >
inline N WINAPI AtlAlignDown( N n, ULONG nAlign ) throw()
{
	return( N( n&~(N( nAlign )-1) ) );
}

__interface __declspec(uuid("654F7EF5-CFDF-4df9-A450-6C6A13C622C0")) IAtlMemMgr
{
public:
	void* Allocate( size_t nBytes ) throw();
	void Free( void* p ) throw();
	void* Reallocate( void* p, size_t nBytes ) throw();
	size_t GetSize( void* p ) throw();
};

#ifndef _ATL_MIN_CRT
class CCRTHeap :
	public IAtlMemMgr
{
public:
	virtual void* Allocate( size_t nBytes ) throw()
	{
		return( malloc( nBytes ) );
	}
	virtual void Free( void* p ) throw()
	{
		free( p );
	}
	virtual void* Reallocate( void* p, size_t nBytes ) throw()
	{
		return( realloc( p, nBytes ) );
	}
	virtual size_t GetSize( void* p ) throw()
	{
		return( _msize( p ) );
	}

public:
};

#endif  //!_ATL_MIN_CRT

class CWin32Heap :
	public IAtlMemMgr
{
public:
	CWin32Heap() throw() :
		m_hHeap( NULL ),
		m_bOwnHeap( false )
	{
	}
	CWin32Heap( HANDLE hHeap ) throw() :
		m_hHeap( hHeap ),
		m_bOwnHeap( false )
	{
		ATLASSERT( hHeap != NULL );
	}
	CWin32Heap( DWORD dwFlags, size_t nInitialSize, size_t nMaxSize = 0 ) :
		m_hHeap( NULL ),
		m_bOwnHeap( true )
	{
		ATLASSERT( !(dwFlags&HEAP_GENERATE_EXCEPTIONS) );
		m_hHeap = ::HeapCreate( dwFlags, nInitialSize, nMaxSize );
		if( m_hHeap == NULL )
		{
			AtlThrowLastWin32();
		}
	}
	virtual ~CWin32Heap() throw()
	{
		if( m_bOwnHeap && (m_hHeap != NULL) )
		{
			BOOL bSuccess;

			bSuccess = ::HeapDestroy( m_hHeap );
			ATLASSERT( bSuccess );
		}
	}

	void Attach( HANDLE hHeap, bool bTakeOwnership ) throw()
	{
		ATLASSERT( hHeap != NULL );
		ATLASSUME( m_hHeap == NULL );

		m_hHeap = hHeap;
		m_bOwnHeap = bTakeOwnership;
	}
	HANDLE Detach() throw()
	{
		HANDLE hHeap;

		hHeap = m_hHeap;
		m_hHeap = NULL;
		m_bOwnHeap = false;

		return( hHeap );
	}

// IAtlMemMgr
	virtual void* Allocate( size_t nBytes ) throw()
	{
		return( ::HeapAlloc( m_hHeap, 0, nBytes ) );
	}
	virtual void Free( void* p ) throw()
	{
		if( p != NULL )
		{
			BOOL bSuccess;

			bSuccess = ::HeapFree( m_hHeap, 0, p );
			ATLASSERT( bSuccess );
		}
	}
	virtual void* Reallocate( void* p, size_t nBytes ) throw()
	{
		if( p == NULL )
		{
			return( Allocate( nBytes ) );
		}
		
		if (nBytes==0)
		{
			  Free(p);
			  return NULL;
         
	 
		
		}	  
	 return( ::HeapReAlloc( m_hHeap, 0, p, nBytes ) );
		 
	
		
	}
	virtual size_t GetSize( void* p ) throw()
	{
		return( ::HeapSize( m_hHeap, 0, p ) );
	}

public:
	HANDLE m_hHeap;
	bool m_bOwnHeap;
};

class CLocalHeap :
	public IAtlMemMgr
{
// IAtlMemMgr
public:
	virtual void* Allocate( size_t nBytes ) throw()
	{
		return( ::LocalAlloc( LMEM_FIXED, nBytes ) );
	}
	virtual void Free( void* p ) throw()
	{
		::LocalFree( p );
	}
	virtual void* Reallocate( void* p, size_t nBytes ) throw()
	{

		if (p==NULL)
		{
			return ( Allocate(nBytes) );
		
		}
		if (nBytes==0)
		{
			Free(p);
			return NULL;
		}

		return( ::LocalReAlloc( p, nBytes, 0 ) );
	}
	virtual size_t GetSize( void* p ) throw()
	{
		return( ::LocalSize( p ) );
	}
};

class CGlobalHeap :
	public IAtlMemMgr
{
// IAtlMemMgr
public:
	virtual void* Allocate( size_t nBytes ) throw()
	{
		return( ::GlobalAlloc( LMEM_FIXED, nBytes ) );
	}
	virtual void Free( void* p ) throw()
	{
		::GlobalFree( p );
	}
	virtual void* Reallocate( void* p, size_t nBytes ) throw()
	{

		if (p==NULL)
		{
			return ( Allocate(nBytes) );
		
		}
		if (nBytes==0){
			Free(p);
			return NULL;
		}
		return( ::GlobalReAlloc( p, nBytes, 0 ) );
	}
	virtual size_t GetSize( void* p ) throw()
	{
		return( ::GlobalSize( p ) );
	}
};

};  // namespace ATL
#pragma pack(pop)

#ifdef _OBJBASE_H_
#include <atlcommem.h>
#endif	// _OBJBASE_H_

#endif  //__ATLMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlimage.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLIMAGE_H__
#define __ATLIMAGE_H__

#pragma once

#ifdef _ATL_CE_NO_GUI
	#error atlimage.h requires GUI support (_ATL_CE_NO_GUI is defined)
#endif //_ATL_CE_NO_GUI

#include <atldef.h>
#include <atlbase.h>
#include <atlstr.h>
#include <atlsimpcoll.h>
#include <atltypes.h>

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable : 4820)	// padding added after member
#endif //!_ATL_NO_PRAGMA_WARNINGS

#pragma warning( push, 3 )
#pragma push_macro("new")
#undef new
#ifndef _WIN32_WCE
#include <gdiplus.h>
#endif // _WIN32_WCE
#pragma pop_macro("new")
#pragma warning( pop )

#include <shlwapi.h>

#ifndef _ATL_NO_DEFAULT_LIBS
#ifndef _WIN32_WCE
#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "shlwapi.lib")
#pragma comment(lib, "gdiplus.lib")
#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
#pragma comment(lib, "msimg32.lib")
#endif  // (WINVER >= 0x0500) && !defined(_WIN32_WCE)
#endif // _WIN32_WCE
#endif  // !_ATL_NO_DEFAULT_LIBS

#ifdef _WIN32_WCE
// On WinCE PALETTEINDEX was replaced with PALETTEINDEX2BPP
// So define PALETTEINDEX PALETTEINDEX2BPP
#define PALETTEINDEX(i) PALETTEINDEX2BPP(i)
#endif // _WIN32_WCE

#pragma pack(push, _ATL_PACKING)

namespace ATL
{

const int CIMAGE_DC_CACHE_SIZE = 4;

class CImage;

class CImageDC
{
public:
	CImageDC( const CImage& image ) throw( ... );
	~CImageDC() throw();

	operator HDC() const throw();

private:
	const CImage& m_image;
	HDC m_hDC;
};

class CImage
{
private:
	class CDCCache
	{
	public:
		CDCCache() throw();
		~CDCCache() throw();

		HDC GetDC() throw();
		void ReleaseDC( HDC ) throw();

	private:
		HDC m_ahDCs[CIMAGE_DC_CACHE_SIZE];
	};

#ifndef _WIN32_WCE
	class CInitGDIPlus
	{
	public:
		CInitGDIPlus() throw();
		~CInitGDIPlus() throw();

		bool Init() throw();
		void ReleaseGDIPlus() throw();
		void IncreaseCImageCount() throw();
		void DecreaseCImageCount() throw();

	private:
		ULONG_PTR m_dwToken;
		CRITICAL_SECTION m_sect;
		LONG m_nCImageObjects;
	};
#endif // _WIN32_WCE

public:
	static const DWORD createAlphaChannel = 0x01;

	static const DWORD excludeGIF = 0x01;
	static const DWORD excludeBMP = 0x02;
	static const DWORD excludeEMF = 0x04;
	static const DWORD excludeWMF = 0x08;
	static const DWORD excludeJPEG = 0x10;
	static const DWORD excludePNG = 0x20;
	static const DWORD excludeTIFF = 0x40;
	static const DWORD excludeIcon = 0x80;
	static const DWORD excludeOther = 0x80000000;
	static const DWORD excludeDefaultLoad = 0;
	static const DWORD excludeDefaultSave = excludeIcon|excludeEMF|excludeWMF;
	static const DWORD excludeValid = 0x800000ff;

	enum DIBOrientation
	{
		DIBOR_DEFAULT,
		DIBOR_TOPDOWN,
		DIBOR_BOTTOMUP
	};

public:
	CImage() throw();
	virtual ~CImage() throw();

	operator HBITMAP() const throw();
#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
	BOOL AlphaBlend( HDC hDestDC, int xDest, int yDest, BYTE bSrcAlpha = 0xff, 
		BYTE bBlendOp = AC_SRC_OVER ) const throw();
	BOOL AlphaBlend( HDC hDestDC, const POINT& pointDest, BYTE bSrcAlpha = 0xff, 
		BYTE bBlendOp = AC_SRC_OVER ) const throw();
	BOOL AlphaBlend( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, 
		BYTE bSrcAlpha = 0xff, BYTE bBlendOp = AC_SRC_OVER ) const throw();
	BOOL AlphaBlend( HDC hDestDC, const RECT& rectDest, const RECT& rectSrc, 
		BYTE bSrcAlpha = 0xff, BYTE bBlendOp = AC_SRC_OVER ) const throw();
#endif  // (WINVER >= 0x0500) && !defined(_WIN32_WCE)
	void Attach( HBITMAP hBitmap, DIBOrientation eOrientation = DIBOR_DEFAULT ) throw();
	BOOL BitBlt( HDC hDestDC, int xDest, int yDest, DWORD dwROP = SRCCOPY ) const throw();
	BOOL BitBlt( HDC hDestDC, const POINT& pointDest, DWORD dwROP = SRCCOPY ) const throw();
	BOOL BitBlt( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight, int xSrc, int ySrc, DWORD dwROP = SRCCOPY ) const throw();
	BOOL BitBlt( HDC hDestDC, const RECT& rectDest, const POINT& pointSrc, 
		DWORD dwROP = SRCCOPY ) const throw();
	BOOL Create( int nWidth, int nHeight, int nBPP, DWORD dwFlags = 0 ) throw();
	BOOL CreateEx( int nWidth, int nHeight, int nBPP, DWORD eCompression, 
		const DWORD* pdwBitmasks = NULL, DWORD dwFlags = 0 ) throw();
	void Destroy() throw();
	HBITMAP Detach() throw();
	BOOL Draw( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight ) const throw();
	BOOL Draw( HDC hDestDC, const RECT& rectDest, const RECT& rectSrc ) const throw();
	BOOL Draw( HDC hDestDC, int xDest, int yDest ) const throw();
	BOOL Draw( HDC hDestDC, const POINT& pointDest ) const throw();
	BOOL Draw( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight ) const throw();
	BOOL Draw( HDC hDestDC, const RECT& rectDest ) const throw();
	const void* GetBits() const throw();
	void* GetBits() throw();
	int GetBPP() const throw();
	void GetColorTable( UINT iFirstColor, UINT nColors, RGBQUAD* prgbColors ) const throw();
	HDC GetDC() const throw();
#ifndef _WIN32_WCE
	static HRESULT GetExporterFilterString( CSimpleString& strExporters, 
		CSimpleArray< GUID >& aguidFileTypes, LPCTSTR pszAllFilesDescription = NULL, 
		DWORD dwExclude = excludeDefaultSave, TCHAR chSeparator = _T( '|' ) );
	static HRESULT GetImporterFilterString( CSimpleString& strImporters, 
		CSimpleArray< GUID >& aguidFileTypes, LPCTSTR pszAllFilesDescription = NULL, 
		DWORD dwExclude = excludeDefaultLoad, TCHAR chSeparator = _T( '|' ) );
#endif // _WIN32_WCE
	int GetHeight() const throw();
	int GetMaxColorTableEntries() const throw();
	int GetPitch() const throw();
	const void* GetPixelAddress( int x, int y ) const throw();
	void* GetPixelAddress( int x, int y ) throw();
	COLORREF GetPixel( int x, int y ) const throw();
#ifndef _WIN32_WCE
	LONG GetTransparentColor() const throw();
#endif // _WIN32_WCE
	int GetWidth() const throw();
	bool IsDIBSection() const throw();
	bool IsIndexed() const throw();
	bool IsNull() const throw();
#ifndef _WIN32_WCE
	HRESULT Load( LPCTSTR pszFileName ) throw();
	HRESULT Load( IStream* pStream ) throw();
#endif // _WIN32_WCE
	void LoadFromResource( HINSTANCE hInstance, LPCTSTR pszResourceName ) throw();
	void LoadFromResource( HINSTANCE hInstance, UINT nIDResource ) throw();
	BOOL MaskBlt( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, 
		int yMask, DWORD dwROP = SRCCOPY ) const throw();
	BOOL MaskBlt( HDC hDestDC, const RECT& rectDest, const POINT& pointSrc, 
		HBITMAP hbmMask, const POINT& pointMask, DWORD dwROP = SRCCOPY ) const throw();
	BOOL MaskBlt( HDC hDestDC, int xDest, int yDest, HBITMAP hbmMask, 
		DWORD dwROP = SRCCOPY ) const throw();
	BOOL MaskBlt( HDC hDestDC, const POINT& pointDest, HBITMAP hbmMask, 
		DWORD dwROP = SRCCOPY ) const throw();
#ifndef _WIN32_WCE
	BOOL PlgBlt( HDC hDestDC, const POINT* pPoints, HBITMAP hbmMask = NULL ) const throw();
	BOOL PlgBlt( HDC hDestDC, const POINT* pPoints, int xSrc, int ySrc, 
		int nSrcWidth, int nSrcHeight, HBITMAP hbmMask = NULL, int xMask = 0, 
		int yMask = 0 ) const throw();
	BOOL PlgBlt( HDC hDestDC, const POINT* pPoints, const RECT& rectSrc, 
		HBITMAP hbmMask = NULL, const POINT& pointMask = CPoint( 0, 0 ) ) const throw();
#endif // _WIN32_WCE
	void ReleaseDC() const throw();
#ifndef _WIN32_WCE
	HRESULT Save( IStream* pStream, REFGUID guidFileType ) const throw();
	HRESULT Save( LPCTSTR pszFileName, REFGUID guidFileType = GUID_NULL ) const throw();
#endif // _WIN32_WCE
	void SetColorTable( UINT iFirstColor, UINT nColors, 
		const RGBQUAD* prgbColors ) throw();
	void SetPixel( int x, int y, COLORREF color ) throw();
	void SetPixelIndexed( int x, int y, int iIndex ) throw();
	void SetPixelRGB( int x, int y, BYTE r, BYTE g, BYTE b ) throw();
#ifndef _WIN32_WCE
	LONG SetTransparentColor( LONG iTransparentColor ) throw();
#endif // _WIN32_WCE
	BOOL StretchBlt( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight, DWORD dwROP = SRCCOPY ) const throw();
	BOOL StretchBlt( HDC hDestDC, const RECT& rectDest, DWORD dwROP = SRCCOPY ) const throw();
	BOOL StretchBlt( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight,
		DWORD dwROP = SRCCOPY ) const throw();
	BOOL StretchBlt( HDC hDestDC, const RECT& rectDest, const RECT& rectSrc,
		DWORD dwROP = SRCCOPY ) const throw();
#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
	BOOL TransparentBlt( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
		int nDestHeight, UINT crTransparent = CLR_INVALID ) const throw();
	BOOL TransparentBlt( HDC hDestDC, const RECT& rectDest, 
		UINT crTransparent = CLR_INVALID ) const throw();
	BOOL TransparentBlt( HDC hDestDC, int xDest, int yDest, int nDestWidth,
		int nDestHeight, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight,
		UINT crTransparent = CLR_INVALID ) const throw();
	BOOL TransparentBlt( HDC hDestDC, const RECT& rectDest, const RECT& rectSrc,
		UINT crTransparent = CLR_INVALID ) const throw();
#endif  // (WINVER >= 0x0500) && !defined(_WIN32_WCE)

	static BOOL IsTransparencySupported() throw();

private:
	HBITMAP m_hBitmap;
	void* m_pBits;
	int m_nWidth;
	int m_nHeight;
	int m_nPitch;
	int m_nBPP;
	bool m_bIsDIBSection;
	bool m_bHasAlphaChannel;
#ifndef _WIN32_WCE
	LONG m_iTransparentColor;

	static CInitGDIPlus s_initGDIPlus;

public:
	inline static void ReleaseGDIPlus() { s_initGDIPlus.ReleaseGDIPlus(); }
#endif // _WIN32_WCE


// Implementation
private:
#ifndef _WIN32_WCE
	static CLSID FindCodecForExtension( LPCTSTR pszExtension, const Gdiplus::ImageCodecInfo* pCodecs, UINT nCodecs );
	static CLSID FindCodecForFileType( REFGUID guidFileType, const Gdiplus::ImageCodecInfo* pCodecs, UINT nCodecs );
	static void BuildCodecFilterString( const Gdiplus::ImageCodecInfo* pCodecs, UINT nCodecs, 
		CSimpleString& strFilter, CSimpleArray< GUID >& aguidFileTypes, LPCTSTR pszAllFilesDescription, DWORD dwExclude, TCHAR chSeparator );
#endif // _WIN32_WCE
	static bool ShouldExcludeFormat( REFGUID guidFileType, DWORD dwExclude ) throw();
	void UpdateBitmapInfo( DIBOrientation eOrientation );
#ifndef _WIN32_WCE
	HRESULT CreateFromGdiplusBitmap( Gdiplus::Bitmap& bmSrc ) throw();

	static bool InitGDIPlus() throw();
#endif // _WIN32_WCE

	static int ComputePitch( int nWidth, int nBPP )
	{
		return( (((nWidth*nBPP)+31)/32)*4 );
	}
	static void GenerateHalftonePalette( LPRGBQUAD prgbPalette );
#ifndef _WIN32_WCE
	COLORREF GetTransparentRGB() const;
#endif // _WIN32_WCE

private:
	mutable HDC m_hDC;
	mutable int m_nDCRefCount;
	mutable HBITMAP m_hOldBitmap;

	static CDCCache s_cache;
};

inline CImageDC::CImageDC( const CImage& image ) throw( ... ) :
	m_image( image ),
	m_hDC( image.GetDC() )
{
	if( m_hDC == NULL )
	{
		AtlThrow( E_OUTOFMEMORY );
	}
}

inline CImageDC::~CImageDC() throw()
{
	m_image.ReleaseDC();
}

inline CImageDC::operator HDC() const throw()
{
	return( m_hDC );
}

#ifndef _WIN32_WCE
inline CImage::CInitGDIPlus::CInitGDIPlus() throw() :
	m_dwToken( 0 ), m_nCImageObjects( 0 )
{
	__try
	{
		InitializeCriticalSection(&m_sect);
	}
	__except( STATUS_NO_MEMORY == GetExceptionCode() )
	{
		AtlThrow( E_OUTOFMEMORY );
	}
}

inline CImage::CInitGDIPlus::~CInitGDIPlus() throw()
{
	ReleaseGDIPlus();
	DeleteCriticalSection(&m_sect);
}

inline bool CImage::CInitGDIPlus::Init() throw()
{
	EnterCriticalSection(&m_sect);
	bool fRet = true;
	if( m_dwToken == 0 )
	{
		Gdiplus::GdiplusStartupInput input;
		Gdiplus::GdiplusStartupOutput output;
		Gdiplus::Status status = Gdiplus::GdiplusStartup( &m_dwToken, &input, &output );
		if( status != Gdiplus::Ok )
			fRet = false;
	}
	LeaveCriticalSection(&m_sect);
	return fRet;
}

inline void CImage::CInitGDIPlus::ReleaseGDIPlus() throw()
{
	EnterCriticalSection(&m_sect);
	if( m_dwToken != 0 )
	{
		Gdiplus::GdiplusShutdown( m_dwToken );
	}
	m_dwToken = 0;
	LeaveCriticalSection(&m_sect);
}

inline void CImage::CInitGDIPlus::IncreaseCImageCount() throw()
{
	EnterCriticalSection(&m_sect);
	m_nCImageObjects++;
	LeaveCriticalSection(&m_sect);
}

inline void CImage::CInitGDIPlus::DecreaseCImageCount() throw()
{
	EnterCriticalSection(&m_sect);
	if( --m_nCImageObjects == 0 )
		ReleaseGDIPlus();
	LeaveCriticalSection(&m_sect);
}
#endif // _WIN32_WCE

inline CImage::CDCCache::CDCCache() throw()
{
	int iDC;

	for( iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )
	{
		m_ahDCs[iDC] = NULL;
	}
}

inline CImage::CDCCache::~CDCCache() throw()
{
	int iDC;

	for( iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )
	{
		if( m_ahDCs[iDC] != NULL )
		{
			::DeleteDC( m_ahDCs[iDC] );
		}
	}
}

inline HDC CImage::CDCCache::GetDC() throw()
{
	HDC hDC;

	for( int iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )
	{
		hDC = static_cast< HDC >( InterlockedExchangePointer( reinterpret_cast< void** >(&m_ahDCs[iDC]), NULL ) );
		if( hDC != NULL )
		{
			return( hDC );
		}
	}

	hDC = ::CreateCompatibleDC( NULL );

	return( hDC );
}

inline void CImage::CDCCache::ReleaseDC( HDC hDC ) throw()
{
	for( int iDC = 0; iDC < CIMAGE_DC_CACHE_SIZE; iDC++ )
	{
		HDC hOldDC;

		hOldDC = static_cast< HDC >( InterlockedExchangePointer( reinterpret_cast< void** >(&m_ahDCs[iDC]), hDC ) );
		if( hOldDC == NULL )
		{
			return;
		}
		else
		{
			hDC = hOldDC;
		}
	}
	if( hDC != NULL )
	{
		::DeleteDC( hDC );
	}
}

inline CImage::CImage() throw() :
	m_hBitmap( NULL ),
	m_pBits( NULL ),
	m_hDC( NULL ),
	m_nDCRefCount( 0 ),
	m_hOldBitmap( NULL ),
	m_nWidth( 0 ),
	m_nHeight( 0 ),
	m_nPitch( 0 ),
	m_nBPP( 0 ),
#ifndef _WIN32_WCE
	m_iTransparentColor( -1 ),
#endif // _WIN32_WCE
	m_bHasAlphaChannel( false ),
	m_bIsDIBSection( false )
{
#ifndef _WIN32_WCE
	s_initGDIPlus.IncreaseCImageCount();
#endif // _WIN32_WCE
}

inline CImage::~CImage() throw()
{
	Destroy();
#ifndef _WIN32_WCE
	s_initGDIPlus.DecreaseCImageCount();
#endif // _WIN32_WCE
}

inline CImage::operator HBITMAP() const throw()
{
	return( m_hBitmap );
}

#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
inline BOOL CImage::AlphaBlend( HDC hDestDC, int xDest, int yDest, 
	BYTE bSrcAlpha, BYTE bBlendOp ) const throw()
{
	return( AlphaBlend( hDestDC, xDest, yDest, m_nWidth, m_nHeight, 0, 0, 
		m_nWidth, m_nHeight, bSrcAlpha, bBlendOp ) );
}

inline BOOL CImage::AlphaBlend( HDC hDestDC, const POINT& pointDest, 
   BYTE bSrcAlpha, BYTE bBlendOp ) const throw()
{
	return( AlphaBlend( hDestDC, pointDest.x, pointDest.y, m_nWidth, m_nHeight, 
		0, 0, m_nWidth, m_nHeight, bSrcAlpha, bBlendOp ) );
}

inline BOOL CImage::AlphaBlend( HDC hDestDC, int xDest, int yDest, 
	int nDestWidth, int nDestHeight, int xSrc, int ySrc, int nSrcWidth, 
	int nSrcHeight, BYTE bSrcAlpha, BYTE bBlendOp ) const throw()
{
	BLENDFUNCTION blend;
	BOOL bResult;

	blend.SourceConstantAlpha = bSrcAlpha;
	blend.BlendOp = bBlendOp;
	blend.BlendFlags = 0;
	if( m_bHasAlphaChannel )
	{
		blend.AlphaFormat = AC_SRC_ALPHA;
	}
	else
	{
		blend.AlphaFormat = 0;
	}

	GetDC();

	bResult = ::AlphaBlend( hDestDC, xDest, yDest, nDestWidth, nDestHeight, m_hDC, 
		xSrc, ySrc, nSrcWidth, nSrcHeight, blend );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::AlphaBlend( HDC hDestDC, const RECT& rectDest, 
	const RECT& rectSrc, BYTE bSrcAlpha, BYTE bBlendOp ) const throw()
{
	return( AlphaBlend( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, rectSrc.left, rectSrc.top, 
		rectSrc.right-rectSrc.left, rectSrc.bottom-rectSrc.top, bSrcAlpha, 
		bBlendOp ) );
}
#endif  // (WINVER >= 0x0500) && !defined(_WIN32_WCE)

inline void CImage::Attach( HBITMAP hBitmap, DIBOrientation eOrientation ) throw()
{
	ATLASSUME( m_hBitmap == NULL );
	ATLASSERT( hBitmap != NULL );

	m_hBitmap = hBitmap;

	UpdateBitmapInfo( eOrientation );
}

inline BOOL CImage::BitBlt( HDC hDestDC, int xDest, int yDest, DWORD dwROP ) const throw()
{
	return( BitBlt( hDestDC, xDest, yDest, m_nWidth, m_nHeight, 0, 0, dwROP ) );
}

inline BOOL CImage::BitBlt( HDC hDestDC, const POINT& pointDest, DWORD dwROP ) const throw()
{
	return( BitBlt( hDestDC, pointDest.x, pointDest.y, m_nWidth, m_nHeight,
		0, 0, dwROP ) );
}

inline BOOL CImage::BitBlt( HDC hDestDC, int xDest, int yDest, int nDestWidth, 
	int nDestHeight, int xSrc, int ySrc, DWORD dwROP ) const throw()
{
	BOOL bResult;

	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( hDestDC != NULL );

	GetDC();

	bResult = ::BitBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, m_hDC, 
		xSrc, ySrc, dwROP );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::BitBlt( HDC hDestDC, const RECT& rectDest, 
	const POINT& pointSrc, DWORD dwROP ) const throw()
{
	return( BitBlt( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, pointSrc.x, pointSrc.y, 
		dwROP ) );
}

inline BOOL CImage::Create( int nWidth, int nHeight, int nBPP, DWORD dwFlags ) throw()
{
	return( CreateEx( nWidth, nHeight, nBPP, BI_RGB, NULL, dwFlags ) );
}

inline BOOL CImage::CreateEx( int nWidth, int nHeight, int nBPP, DWORD eCompression, 
	const DWORD* pdwBitfields, DWORD dwFlags ) throw()
{
	USES_ATL_SAFE_ALLOCA;
	LPBITMAPINFO pbmi;
	HBITMAP hBitmap;

	ATLASSERT( (eCompression == BI_RGB) || (eCompression == BI_BITFIELDS) );
	if( dwFlags&createAlphaChannel )
	{
		ATLASSERT( (nBPP == 32) && (eCompression == BI_RGB) );
	}
	
	pbmi = (LPBITMAPINFO)_ATL_SAFE_ALLOCA(sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD)*256, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	if( pbmi == NULL )
		return FALSE;

	memset( &pbmi->bmiHeader, 0, sizeof( pbmi->bmiHeader ) );
	pbmi->bmiHeader.biSize = sizeof( pbmi->bmiHeader );
	pbmi->bmiHeader.biWidth = nWidth;
	pbmi->bmiHeader.biHeight = nHeight;
	pbmi->bmiHeader.biPlanes = 1;
	pbmi->bmiHeader.biBitCount = USHORT( nBPP );
	pbmi->bmiHeader.biCompression = eCompression;
	if( nBPP <= 8 )
	{
		ATLASSERT( eCompression == BI_RGB );
#pragma warning(push)
#pragma warning(disable:4068) //Disable unknown pragma warning that prefast pragma causes.
#pragma prefast(push)
#pragma prefast(disable:203, "no buffer overrun here, buffer was alocated properly")	
		memset( pbmi->bmiColors, 0, 256*sizeof( RGBQUAD ) );
#pragma prefast(pop)
#pragma warning(pop)
	}
	
	else 
	{
		if( eCompression == BI_BITFIELDS )
		{
			ATLASSERT( pdwBitfields != NULL );
			Checked::memcpy_s(pbmi->bmiColors, 3*sizeof( DWORD ), pdwBitfields, 3*sizeof( DWORD ));
		}
	}

	hBitmap = ::CreateDIBSection( NULL, pbmi, DIB_RGB_COLORS, &m_pBits, NULL,
		0 );
	if( hBitmap == NULL )
	{
		return( FALSE );
	}

	Attach( hBitmap, (nHeight < 0) ? DIBOR_TOPDOWN : DIBOR_BOTTOMUP );

	if( dwFlags&createAlphaChannel )
	{
		m_bHasAlphaChannel = true;
	}

	return( TRUE );
}

inline void CImage::Destroy() throw()
{
	HBITMAP hBitmap;

	if( m_hBitmap != NULL )
	{
		hBitmap = Detach();
		::DeleteObject( hBitmap );
	}
}

inline HBITMAP CImage::Detach() throw()
{
	HBITMAP hBitmap;

	ATLASSUME( m_hBitmap != NULL );
	ATLASSUME( m_hDC == NULL );

	hBitmap = m_hBitmap;
	m_hBitmap = NULL;
	m_pBits = NULL;
	m_nWidth = 0;
	m_nHeight = 0;
	m_nBPP = 0;
	m_nPitch = 0;
#ifndef _WIN32_WCE
	m_iTransparentColor = -1;
#endif // _WIN32_WCE
	m_bHasAlphaChannel = false;
	m_bIsDIBSection = false;

	return( hBitmap );
}

inline BOOL CImage::Draw( HDC hDestDC, const RECT& rectDest ) const throw()
{
	return( Draw( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, 0, 0, m_nWidth, 
		m_nHeight ) );
}

inline BOOL CImage::Draw( HDC hDestDC, int xDest, int yDest, int nDestWidth, int nDestHeight ) const throw()
{
	return( Draw( hDestDC, xDest, yDest, nDestWidth, nDestHeight, 0, 0, m_nWidth, m_nHeight ) );
}

inline BOOL CImage::Draw( HDC hDestDC, const POINT& pointDest ) const throw()
{
	return( Draw( hDestDC, pointDest.x, pointDest.y, m_nWidth, m_nHeight, 0, 0, m_nWidth, m_nHeight ) );
}

inline BOOL CImage::Draw( HDC hDestDC, int xDest, int yDest ) const throw()
{
	return( Draw( hDestDC, xDest, yDest, m_nWidth, m_nHeight, 0, 0, m_nWidth, m_nHeight ) );
}

inline BOOL CImage::Draw( HDC hDestDC, const RECT& rectDest, const RECT& rectSrc ) const throw()
{
	return( Draw( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, rectSrc.left, rectSrc.top, 
		rectSrc.right-rectSrc.left, rectSrc.bottom-rectSrc.top ) );
}

inline BOOL CImage::Draw( HDC hDestDC, int xDest, int yDest, int nDestWidth,
	int nDestHeight, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight ) const throw()
{
	BOOL bResult;

	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( hDestDC != NULL );
	ATLASSERT( nDestWidth > 0 );
	ATLASSERT( nDestHeight > 0 );
	ATLASSERT( nSrcWidth > 0 );
	ATLASSERT( nSrcHeight > 0 );

	GetDC();

#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
	if( (m_iTransparentColor != -1) && IsTransparencySupported() )
	{
		bResult = ::TransparentBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight,
			m_hDC, xSrc, ySrc, nSrcWidth, nSrcHeight, GetTransparentRGB() );
	}
	else if( m_bHasAlphaChannel && IsTransparencySupported() )
	{
		BLENDFUNCTION bf;

		bf.BlendOp = AC_SRC_OVER;
		bf.BlendFlags = 0;
		bf.SourceConstantAlpha = 0xff;
		bf.AlphaFormat = AC_SRC_ALPHA;
		bResult = ::AlphaBlend( hDestDC, xDest, yDest, nDestWidth, nDestHeight, 
			m_hDC, xSrc, ySrc, nSrcWidth, nSrcHeight, bf );
	}
	else
#endif  // (WINVER >= 0x0500) && !defined(_WIN32_WCE)
	{
		bResult = ::StretchBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, 
			m_hDC, xSrc, ySrc, nSrcWidth, nSrcHeight, SRCCOPY );
	}

	ReleaseDC();

	return( bResult );
}

inline const void* CImage::GetBits() const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );

	return( m_pBits );
}

inline void* CImage::GetBits() throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );

	return( m_pBits );
}

inline int CImage::GetBPP() const throw()
{
	ATLASSUME( m_hBitmap != NULL );

	return( m_nBPP );
}

inline void CImage::GetColorTable( UINT iFirstColor, UINT nColors, 
	RGBQUAD* prgbColors ) const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSUME( m_pBits != NULL );
	ATLASSERT( IsIndexed() );

	GetDC();

	::GetDIBColorTable( m_hDC, iFirstColor, nColors, prgbColors );

	ReleaseDC();
}

inline HDC CImage::GetDC() const throw()
{
	ATLASSUME( m_hBitmap != NULL );

	m_nDCRefCount++;
	if( m_hDC == NULL )
	{
		m_hDC = s_cache.GetDC();
		m_hOldBitmap = HBITMAP( ::SelectObject( m_hDC, m_hBitmap ) );
	}

	return( m_hDC );
}

#ifndef _WIN32_WCE

inline bool CImage::ShouldExcludeFormat( REFGUID guidFileType, DWORD dwExclude ) throw()
{
	static const GUID* apguidFormats[] =
	{
		&Gdiplus::ImageFormatGIF,
		&Gdiplus::ImageFormatBMP,
		&Gdiplus::ImageFormatEMF,
		&Gdiplus::ImageFormatWMF,
		&Gdiplus::ImageFormatJPEG,
		&Gdiplus::ImageFormatPNG,
		&Gdiplus::ImageFormatTIFF,
		&Gdiplus::ImageFormatIcon,
		NULL
	};

	ATLASSERT( (dwExclude|excludeValid) == excludeValid );
	for( int iFormat = 0; apguidFormats[iFormat] != NULL; iFormat++ )
	{
		if( guidFileType == *apguidFormats[iFormat] )
		{
			return( (dwExclude&(1<<iFormat)) != 0 );
		}
	}

	return( (dwExclude&excludeOther) != 0 );
}

inline void CImage::BuildCodecFilterString( const Gdiplus::ImageCodecInfo* pCodecs, UINT nCodecs,
	CSimpleString& strFilter, CSimpleArray< GUID >& aguidFileTypes, LPCTSTR pszAllFilesDescription, 
	DWORD dwExclude, TCHAR chSeparator )
{
	if( pszAllFilesDescription != NULL )
	{
		aguidFileTypes.Add( GUID_NULL );
	}

	CString strAllExtensions;
	CString strTempFilter;
	for( UINT iCodec = 0; iCodec < nCodecs; iCodec++ )
	{
		const Gdiplus::ImageCodecInfo* pCodec = &pCodecs[iCodec];

		if( !ShouldExcludeFormat( pCodec->FormatID, dwExclude ) )
		{
			CW2CT pwszFilenameExtension( pCodec->FilenameExtension );
			strTempFilter += CW2CT( pCodec->FormatDescription );
			strTempFilter += _T( " (" );
			strTempFilter += pwszFilenameExtension;
			strTempFilter += _T( ")" );
			strTempFilter += chSeparator;
			strTempFilter += pwszFilenameExtension;
			strTempFilter += chSeparator;

			aguidFileTypes.Add( pCodec->FormatID );

			if( !strAllExtensions.IsEmpty() )
			{
				strAllExtensions += _T( ";" );
			}
			strAllExtensions += pwszFilenameExtension;
		}
	}

	if( pszAllFilesDescription != NULL )
	{
		strFilter += pszAllFilesDescription;
		strFilter += chSeparator;
		strFilter += strAllExtensions;
		strFilter += chSeparator;
	}
	strFilter += strTempFilter;

	strFilter += chSeparator;
	if( aguidFileTypes.GetSize() == 0 )
	{
		strFilter += chSeparator;
	}
}

inline HRESULT CImage::GetImporterFilterString( CSimpleString& strImporters, 
	CSimpleArray< GUID >& aguidFileTypes, LPCTSTR pszAllFilesDescription /* = NULL */,
	DWORD dwExclude /* = excludeDefaultLoad */, TCHAR chSeparator /* = '|' */ )
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	UINT nCodecs;
	UINT nSize;
	Gdiplus::Status status;
	Gdiplus::ImageCodecInfo* pCodecs;

	status = Gdiplus::GetImageDecodersSize( &nCodecs, &nSize );
	USES_ATL_SAFE_ALLOCA;
	pCodecs = static_cast< Gdiplus::ImageCodecInfo* >( _ATL_SAFE_ALLOCA(nSize, _ATL_SAFE_ALLOCA_DEF_THRESHOLD) );

	if( pCodecs == NULL )
		return E_OUTOFMEMORY;

	status = Gdiplus::GetImageDecoders( nCodecs, nSize, pCodecs );
	BuildCodecFilterString( pCodecs, nCodecs, strImporters, aguidFileTypes, pszAllFilesDescription, dwExclude, chSeparator );

	return( S_OK );
}

inline HRESULT CImage::GetExporterFilterString( CSimpleString& strExporters, 
	CSimpleArray< GUID >& aguidFileTypes, LPCTSTR pszAllFilesDescription /* = NULL */,
	DWORD dwExclude /* = excludeDefaultSave */, TCHAR chSeparator /* = '|' */ )
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	UINT nCodecs;
	UINT nSize;
	Gdiplus::Status status;
	Gdiplus::ImageCodecInfo* pCodecs;

	status = Gdiplus::GetImageDecodersSize( &nCodecs, &nSize );
	USES_ATL_SAFE_ALLOCA;
	pCodecs = static_cast< Gdiplus::ImageCodecInfo* >( _ATL_SAFE_ALLOCA(nSize, _ATL_SAFE_ALLOCA_DEF_THRESHOLD) );

	if( pCodecs == NULL )
		return E_OUTOFMEMORY;

	status = Gdiplus::GetImageDecoders( nCodecs, nSize, pCodecs );
	BuildCodecFilterString( pCodecs, nCodecs, strExporters, aguidFileTypes, pszAllFilesDescription, dwExclude, chSeparator );

	return( S_OK );
}

#endif // _WIN32_WCE

inline int CImage::GetHeight() const throw()
{
	ATLASSUME( m_hBitmap != NULL );

	return( m_nHeight );
}

inline int CImage::GetMaxColorTableEntries() const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );

	if( IsIndexed() )
	{
		return( 1<<m_nBPP );
	}
	else
	{
		return( 0 );
	}
}

inline int CImage::GetPitch() const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );

	return( m_nPitch );
}

inline COLORREF CImage::GetPixel( int x, int y ) const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( (x >= 0) && (x < m_nWidth) );
	ATLASSERT( (y >= 0) && (y < m_nHeight) );

	GetDC();

	COLORREF clr = ::GetPixel( m_hDC, x, y );

	ReleaseDC();

	return( clr );
}

inline const void* CImage::GetPixelAddress( int x, int y ) const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );
	ATLASSERT( (x >= 0) && (x < m_nWidth) );
	ATLASSERT( (y >= 0) && (y < m_nHeight) );

	return( LPBYTE( m_pBits )+(y*m_nPitch)+((x*m_nBPP)/8) );
}

inline void* CImage::GetPixelAddress( int x, int y ) throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );
	ATLASSERT( (x >= 0) && (x < m_nWidth) );
	ATLASSERT( (y >= 0) && (y < m_nHeight) );

	return( LPBYTE( m_pBits )+(y*m_nPitch)+((x*m_nBPP)/8) );
}

#ifndef _WIN32_WCE
inline LONG CImage::GetTransparentColor() const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( (m_nBPP == 4) || (m_nBPP == 8) );

	return( m_iTransparentColor );
}
#endif // _WIN32_WCE

inline int CImage::GetWidth() const throw()
{
	ATLASSUME( m_hBitmap != NULL );

	return( m_nWidth );
}

inline bool CImage::IsDIBSection() const throw()
{
	return( m_bIsDIBSection );
}

inline bool CImage::IsIndexed() const throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );

	return( m_nBPP <= 8 );
}

inline bool CImage::IsNull() const throw()
{
	return( m_hBitmap == NULL );
}

#ifndef _WIN32_WCE

inline HRESULT CImage::Load( IStream* pStream ) throw()
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	Gdiplus::Bitmap bmSrc( pStream );
	if( bmSrc.GetLastStatus() != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	return( CreateFromGdiplusBitmap( bmSrc ) );
}

inline HRESULT CImage::Load( LPCTSTR pszFileName ) throw()
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	Gdiplus::Bitmap bmSrc( (CT2W)pszFileName );
	if( bmSrc.GetLastStatus() != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	return( CreateFromGdiplusBitmap( bmSrc ) );
}

inline HRESULT CImage::CreateFromGdiplusBitmap( Gdiplus::Bitmap& bmSrc ) throw()
{
	Gdiplus::PixelFormat eSrcPixelFormat = bmSrc.GetPixelFormat();
	UINT nBPP = 32;
	DWORD dwFlags = 0;
	Gdiplus::PixelFormat eDestPixelFormat = PixelFormat32bppRGB;
	if( eSrcPixelFormat&PixelFormatGDI )
	{
		nBPP = Gdiplus::GetPixelFormatSize( eSrcPixelFormat );
		eDestPixelFormat = eSrcPixelFormat;
	}
	if( Gdiplus::IsAlphaPixelFormat( eSrcPixelFormat ) )
	{
		nBPP = 32;
		dwFlags |= createAlphaChannel;
		eDestPixelFormat = PixelFormat32bppARGB;
	}

	BOOL bSuccess = Create( bmSrc.GetWidth(), bmSrc.GetHeight(), nBPP, dwFlags );
	if( !bSuccess )
	{
		return( E_FAIL );
	}
	USES_ATL_SAFE_ALLOCA;
	Gdiplus::ColorPalette* pPalette = NULL;
	if( Gdiplus::IsIndexedPixelFormat( eSrcPixelFormat ) )
	{
		UINT nPaletteSize = bmSrc.GetPaletteSize();
		pPalette = static_cast< Gdiplus::ColorPalette* >( _ATL_SAFE_ALLOCA(nPaletteSize, _ATL_SAFE_ALLOCA_DEF_THRESHOLD) );

		if( pPalette == NULL )
			return E_OUTOFMEMORY;

		bmSrc.GetPalette( pPalette, nPaletteSize );

		RGBQUAD argbPalette[256];
		ATLASSERT( (pPalette->Count > 0) && (pPalette->Count <= 256) );
		for( UINT iColor = 0; iColor < pPalette->Count; iColor++ )
		{
			Gdiplus::ARGB color = pPalette->Entries[iColor];
			argbPalette[iColor].rgbRed = (BYTE)( (color>>RED_SHIFT) & 0xff );
			argbPalette[iColor].rgbGreen = (BYTE)( (color>>GREEN_SHIFT) & 0xff );
			argbPalette[iColor].rgbBlue = (BYTE)( (color>>BLUE_SHIFT) & 0xff );
			argbPalette[iColor].rgbReserved = 0;
		}

		SetColorTable( 0, pPalette->Count, argbPalette );
	}

	if( eDestPixelFormat == eSrcPixelFormat )
	{
		// The pixel formats are identical, so just memcpy the rows.
		Gdiplus::BitmapData data;
		Gdiplus::Rect rect( 0, 0, GetWidth(), GetHeight() );
		if(bmSrc.LockBits( &rect, Gdiplus::ImageLockModeRead, eSrcPixelFormat, &data )!=Gdiplus::Ok)
		{
			return E_OUTOFMEMORY;
		}

		size_t nBytesPerRow = AtlAlignUp( nBPP*GetWidth(), 8 )/8;
		BYTE* pbDestRow = static_cast< BYTE* >( GetBits() );
		BYTE* pbSrcRow = static_cast< BYTE* >( data.Scan0 );
		for( int y = 0; y < GetHeight(); y++ )
		{
			Checked::memcpy_s(pbDestRow, nBytesPerRow, pbSrcRow, nBytesPerRow);
			pbDestRow += GetPitch();
			pbSrcRow += data.Stride;
		}

		bmSrc.UnlockBits( &data );
	}
	else
	{
		// Let GDI+ work its magic
		Gdiplus::Bitmap bmDest( GetWidth(), GetHeight(), GetPitch(), eDestPixelFormat, static_cast< BYTE* >( GetBits() ) );
		Gdiplus::Graphics gDest( &bmDest );

		gDest.DrawImage( &bmSrc, 0, 0 );
	}

	return( S_OK );
}

#endif // _WIN32_WCE

inline void CImage::LoadFromResource( HINSTANCE hInstance, LPCTSTR pszResourceName ) throw()
{
	HBITMAP hBitmap;

#ifndef _WIN32_WCE
	hBitmap = HBITMAP( ::LoadImage( hInstance, pszResourceName, IMAGE_BITMAP, 0, 
		0, LR_CREATEDIBSECTION ) );
#else // _WIN32_WCE
	hBitmap = HBITMAP( ::LoadImage( hInstance, pszResourceName, IMAGE_BITMAP, 0, 
		0, 0 ) );
#endif // _WIN32_WCE

	Attach( hBitmap );
}

inline void CImage::LoadFromResource( HINSTANCE hInstance, UINT nIDResource ) throw()
{
	LoadFromResource( hInstance, MAKEINTRESOURCE( nIDResource ) );
}

inline BOOL CImage::MaskBlt( HDC hDestDC, int xDest, int yDest, int nWidth, 
	int nHeight, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask,
	DWORD dwROP ) const throw()
{
	BOOL bResult;

	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( hDestDC != NULL );

	GetDC();

	bResult = ::MaskBlt( hDestDC, xDest, yDest, nWidth, nHeight, m_hDC, xSrc, 
		ySrc, hbmMask, xMask, yMask, dwROP );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::MaskBlt( HDC hDestDC, const RECT& rectDest, 
	const POINT& pointSrc, HBITMAP hbmMask, const POINT& pointMask, 
	DWORD dwROP ) const throw()
{
	return( MaskBlt( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, pointSrc.x, pointSrc.y, 
		hbmMask, pointMask.x, pointMask.y, dwROP ) );
}

inline BOOL CImage::MaskBlt( HDC hDestDC, int xDest, int yDest, HBITMAP hbmMask, 
	DWORD dwROP ) const throw()
{
	return( MaskBlt( hDestDC, xDest, yDest, m_nWidth, m_nHeight, 0, 0, hbmMask, 
		0, 0, dwROP ) );
}

inline BOOL CImage::MaskBlt( HDC hDestDC, const POINT& pointDest, HBITMAP hbmMask,
	DWORD dwROP ) const throw()
{
	return( MaskBlt( hDestDC, pointDest.x, pointDest.y, m_nWidth, m_nHeight, 0, 
		0, hbmMask, 0, 0, dwROP ) );
}

#ifndef _WIN32_WCE
inline BOOL CImage::PlgBlt( HDC hDestDC, const POINT* pPoints, int xSrc, 
	int ySrc, int nSrcWidth, int nSrcHeight, HBITMAP hbmMask, int xMask, 
	int yMask ) const throw()
{
	BOOL bResult;

	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( hDestDC != NULL );

	GetDC();

	bResult = ::PlgBlt( hDestDC, pPoints, m_hDC, xSrc, ySrc, nSrcWidth, 
		nSrcHeight, hbmMask, xMask, yMask );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::PlgBlt( HDC hDestDC, const POINT* pPoints, 
	const RECT& rectSrc, HBITMAP hbmMask, const POINT& pointMask ) const throw()
{
	return( PlgBlt( hDestDC, pPoints, rectSrc.left, rectSrc.top, rectSrc.right-
		rectSrc.left, rectSrc.bottom-rectSrc.top, hbmMask, pointMask.x, 
		pointMask.y ) );
}

inline BOOL CImage::PlgBlt( HDC hDestDC, const POINT* pPoints, 
	HBITMAP hbmMask ) const throw()
{
	return( PlgBlt( hDestDC, pPoints, 0, 0, m_nWidth, m_nHeight, hbmMask, 0, 
		0 ) );
}
#endif // _WIN32_WCE

inline void CImage::ReleaseDC() const throw()
{
	HBITMAP hBitmap;

	ATLASSUME( m_hDC != NULL );

	m_nDCRefCount--;
	if( m_nDCRefCount == 0 )
	{
		hBitmap = HBITMAP( ::SelectObject( m_hDC, m_hOldBitmap ) );
		ATLASSERT( hBitmap == m_hBitmap );
		s_cache.ReleaseDC( m_hDC );
		m_hDC = NULL;
	}
}

#ifndef _WIN32_WCE

inline CLSID CImage::FindCodecForExtension( LPCTSTR pszExtension, const Gdiplus::ImageCodecInfo* pCodecs, UINT nCodecs )
{
	CT2CW pszExtensionW( pszExtension );

	for( UINT iCodec = 0; iCodec < nCodecs; iCodec++ )
	{
		CStringW strExtensions( pCodecs[iCodec].FilenameExtension );

		int iStart = 0;
		do
		{
			CStringW strExtension = ::PathFindExtensionW( strExtensions.Tokenize( L";", iStart ) );
			if( iStart != -1 )
			{
				if( strExtension.CompareNoCase( pszExtensionW ) == 0 )
				{
					return( pCodecs[iCodec].Clsid );
				}
			}
		} while( iStart != -1 );
	}

	return( CLSID_NULL );
}

inline CLSID CImage::FindCodecForFileType( REFGUID guidFileType, const Gdiplus::ImageCodecInfo* pCodecs, UINT nCodecs )
{
	for( UINT iCodec = 0; iCodec < nCodecs; iCodec++ )
	{
		if( pCodecs[iCodec].FormatID == guidFileType )
		{
			return( pCodecs[iCodec].Clsid );
		}
	}

	return( CLSID_NULL );
}

inline HRESULT CImage::Save( IStream* pStream, REFGUID guidFileType ) const throw()
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	UINT nEncoders;
	UINT nBytes;
	Gdiplus::Status status;

	status = Gdiplus::GetImageEncodersSize( &nEncoders, &nBytes );
	if( status != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	USES_ATL_SAFE_ALLOCA;
	Gdiplus::ImageCodecInfo* pEncoders = static_cast< Gdiplus::ImageCodecInfo* >( _ATL_SAFE_ALLOCA(nBytes, _ATL_SAFE_ALLOCA_DEF_THRESHOLD) );

	if( pEncoders == NULL )
		return E_OUTOFMEMORY;

	status = Gdiplus::GetImageEncoders( nEncoders, nBytes, pEncoders );
	if( status != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	CLSID clsidEncoder = FindCodecForFileType( guidFileType, pEncoders, nEncoders );
	if( clsidEncoder == CLSID_NULL )
	{
		return( E_FAIL );
	}

	if( m_bHasAlphaChannel )
	{
		ATLASSUME( m_nBPP == 32 );
		Gdiplus::Bitmap bm( m_nWidth, m_nHeight, m_nPitch, PixelFormat32bppARGB, static_cast< BYTE* >( m_pBits ) );
		status = bm.Save( pStream, &clsidEncoder, NULL );
		if( status != Gdiplus::Ok )
		{
			return( E_FAIL );
		}
	}
	else
	{
		Gdiplus::Bitmap bm( m_hBitmap, NULL );
		status = bm.Save( pStream, &clsidEncoder, NULL );
		if( status != Gdiplus::Ok )
		{
			return( E_FAIL );
		}
	}

	return( S_OK );
}

inline HRESULT CImage::Save( LPCTSTR pszFileName, REFGUID guidFileType ) const throw()
{
	if( !InitGDIPlus() )
	{
		return( E_FAIL );
	}

	UINT nEncoders;
	UINT nBytes;
	Gdiplus::Status status;

	status = Gdiplus::GetImageEncodersSize( &nEncoders, &nBytes );
	if( status != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	USES_CONVERSION_EX;
	Gdiplus::ImageCodecInfo* pEncoders = static_cast< Gdiplus::ImageCodecInfo* >( _ATL_SAFE_ALLOCA(nBytes, _ATL_SAFE_ALLOCA_DEF_THRESHOLD) );

	if( pEncoders == NULL )
		return E_OUTOFMEMORY;

	status = Gdiplus::GetImageEncoders( nEncoders, nBytes, pEncoders );
	if( status != Gdiplus::Ok )
	{
		return( E_FAIL );
	}

	CLSID clsidEncoder = CLSID_NULL;
	if( guidFileType == GUID_NULL )
	{
		// Determine clsid from extension
		clsidEncoder = FindCodecForExtension( ::PathFindExtension( pszFileName ), pEncoders, nEncoders );
	}
	else
	{
		// Determine clsid from file type
		clsidEncoder = FindCodecForFileType( guidFileType, pEncoders, nEncoders );
	}
	if( clsidEncoder == CLSID_NULL )
	{
		return( E_FAIL );
	}

	LPCWSTR pwszFileName = T2CW_EX( pszFileName, _ATL_SAFE_ALLOCA_DEF_THRESHOLD );
#ifndef _UNICODE
	if( pwszFileName == NULL )
		return E_OUTOFMEMORY;
#endif // _UNICODE
	if( m_bHasAlphaChannel )
	{
		ATLASSUME( m_nBPP == 32 );
		Gdiplus::Bitmap bm( m_nWidth, m_nHeight, m_nPitch, PixelFormat32bppARGB, static_cast< BYTE* >( m_pBits ) );
		status = bm.Save( pwszFileName, &clsidEncoder, NULL );
		if( status != Gdiplus::Ok )
		{
			return( E_FAIL );
		}
	}
	else
	{
		Gdiplus::Bitmap bm( m_hBitmap, NULL );
		status = bm.Save( pwszFileName, &clsidEncoder, NULL );
		if( status != Gdiplus::Ok )
		{
			return( E_FAIL );
		}
	}

	return( S_OK );
}

#endif // _WIN32_WCE

inline void CImage::SetColorTable( UINT iFirstColor, UINT nColors, 
	const RGBQUAD* prgbColors ) throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( IsDIBSection() );
	ATLASSERT( IsIndexed() );

	GetDC();

	::SetDIBColorTable( m_hDC, iFirstColor, nColors, prgbColors );

	ReleaseDC();
}

inline void CImage::SetPixel( int x, int y, COLORREF color ) throw()
{
	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( (x >= 0) && (x < m_nWidth) );
	ATLASSERT( (y >= 0) && (y < m_nHeight) );

	GetDC();

	::SetPixel( m_hDC, x, y, color );

	ReleaseDC();
}

inline void CImage::SetPixelIndexed( int x, int y, int iIndex ) throw()
{
	SetPixel( x, y, PALETTEINDEX( iIndex ) );
}

inline void CImage::SetPixelRGB( int x, int y, BYTE r, BYTE g, BYTE b ) throw()
{
	SetPixel( x, y, RGB( r, g, b ) );
}

#ifndef _WIN32_WCE
inline LONG CImage::SetTransparentColor( LONG iTransparentColor ) throw()
{
	LONG iOldTransparentColor;

	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( (m_nBPP == 4) || (m_nBPP == 8) );
	ATLASSERT( iTransparentColor < GetMaxColorTableEntries() );
	ATLASSERT( iTransparentColor >= -1 );

	iOldTransparentColor = m_iTransparentColor;
	m_iTransparentColor = iTransparentColor;

	return( iOldTransparentColor );
}
#endif // _WIN32_WCE

inline BOOL CImage::StretchBlt( HDC hDestDC, int xDest, int yDest, 
	int nDestWidth, int nDestHeight, DWORD dwROP ) const throw()
{
	return( StretchBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, 0, 0, 
		m_nWidth, m_nHeight, dwROP ) );
}

inline BOOL CImage::StretchBlt( HDC hDestDC, const RECT& rectDest, 
	DWORD dwROP ) const throw()
{
	return( StretchBlt( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, 0, 0, m_nWidth, m_nHeight, 
		dwROP ) );
}

inline BOOL CImage::StretchBlt( HDC hDestDC, int xDest, int yDest, 
	int nDestWidth, int nDestHeight, int xSrc, int ySrc, int nSrcWidth, 
	int nSrcHeight, DWORD dwROP ) const throw()
{
	BOOL bResult;

	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( hDestDC != NULL );

	GetDC();

	bResult = ::StretchBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, m_hDC,
		xSrc, ySrc, nSrcWidth, nSrcHeight, dwROP );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::StretchBlt( HDC hDestDC, const RECT& rectDest, 
	const RECT& rectSrc, DWORD dwROP ) const throw()
{
	return( StretchBlt( hDestDC, rectDest.left, rectDest.top, rectDest.right-
		rectDest.left, rectDest.bottom-rectDest.top, rectSrc.left, rectSrc.top, 
		rectSrc.right-rectSrc.left, rectSrc.bottom-rectSrc.top, dwROP ) );
}

#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
inline BOOL CImage::TransparentBlt( HDC hDestDC, int xDest, int yDest, 
	int nDestWidth, int nDestHeight, UINT crTransparent ) const throw()
{
	return( TransparentBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight, 0, 
		0, m_nWidth, m_nHeight, crTransparent ) );
}

inline BOOL CImage::TransparentBlt( HDC hDestDC, const RECT& rectDest, 
	UINT crTransparent ) const throw()
{
	return( TransparentBlt( hDestDC, rectDest.left, rectDest.top, 
		rectDest.right-rectDest.left, rectDest.bottom-rectDest.top, 
		crTransparent ) );
}

inline BOOL CImage::TransparentBlt( HDC hDestDC, int xDest, int yDest, 
	int nDestWidth, int nDestHeight, int xSrc, int ySrc, int nSrcWidth, 
	int nSrcHeight, UINT crTransparent ) const throw()
{
	BOOL bResult;

	ATLASSUME( m_hBitmap != NULL );
	ATLASSERT( hDestDC != NULL );

	GetDC();

	if( crTransparent == CLR_INVALID )
	{
		crTransparent = GetTransparentRGB();
	}

	bResult = ::TransparentBlt( hDestDC, xDest, yDest, nDestWidth, nDestHeight,
		m_hDC, xSrc, ySrc, nSrcWidth, nSrcHeight, crTransparent );

	ReleaseDC();

	return( bResult );
}

inline BOOL CImage::TransparentBlt( HDC hDestDC, const RECT& rectDest, 
	const RECT& rectSrc, UINT crTransparent ) const throw()
{
	return( TransparentBlt( hDestDC, rectDest.left, rectDest.top, 
		rectDest.right-rectDest.left, rectDest.bottom-rectDest.top, rectSrc.left, 
		rectSrc.top, rectSrc.right-rectSrc.left, rectSrc.bottom-rectSrc.top, 
		crTransparent ) );
}
#endif  // (WINVER >= 0x0500) && !defined(_WIN32_WCE)

inline BOOL CImage::IsTransparencySupported() throw()
{
#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
	return( _AtlBaseModule.m_bNT5orWin98 );
#else  // (WINVER >= 0x0500) && !defined(_WIN32_WCE)
	return( FALSE );
#endif  // (WINVER >= 0x0500) && !defined(_WIN32_WCE)
}

inline void CImage::UpdateBitmapInfo( DIBOrientation eOrientation )
{
	DIBSECTION dibsection;
	int nBytes;

	nBytes = ::GetObject( m_hBitmap, sizeof( DIBSECTION ), &dibsection );
	if( nBytes == sizeof( DIBSECTION ) )
	{
		m_bIsDIBSection = true;
		m_nWidth = dibsection.dsBmih.biWidth;
		m_nHeight = abs( dibsection.dsBmih.biHeight );
		m_nBPP = dibsection.dsBmih.biBitCount;
		m_nPitch = ComputePitch( m_nWidth, m_nBPP );
		m_pBits = dibsection.dsBm.bmBits;
		if( eOrientation == DIBOR_DEFAULT )
		{
			eOrientation = (dibsection.dsBmih.biHeight > 0) ? DIBOR_BOTTOMUP : DIBOR_TOPDOWN;
		}
		if( eOrientation == DIBOR_BOTTOMUP )
		{
			m_pBits = LPBYTE( m_pBits )+((m_nHeight-1)*m_nPitch);
			m_nPitch = -m_nPitch;
		}
	}
	else
	{
		// Non-DIBSection
		ATLASSERT( nBytes == sizeof( BITMAP ) );
		m_bIsDIBSection = false;
		m_nWidth = dibsection.dsBm.bmWidth;
		m_nHeight = dibsection.dsBm.bmHeight;
		m_nBPP = dibsection.dsBm.bmBitsPixel;
		m_nPitch = 0;
		m_pBits = 0;
	}
#ifndef _WIN32_WCE
	m_iTransparentColor = -1;
#endif // _WIN32_WCE
	m_bHasAlphaChannel = false;
}

inline void CImage::GenerateHalftonePalette( LPRGBQUAD prgbPalette )
{
	int r;
	int g;
	int b;
	int gray;
	LPRGBQUAD prgbEntry;

	prgbEntry = prgbPalette;
	for( r = 0; r < 6; r++ )
	{
		for( g = 0; g < 6; g++ )
		{
			for( b = 0; b < 6; b++ )
			{
				prgbEntry->rgbBlue = BYTE( b*255/5 );
				prgbEntry->rgbGreen = BYTE( g*255/5 );
				prgbEntry->rgbRed = BYTE( r*255/5 );
				prgbEntry->rgbReserved = 0;

				prgbEntry++;
			}
		}
	}

	for( gray = 0; gray < 20; gray++ )
	{
		prgbEntry->rgbBlue = BYTE( gray*255/20 );
		prgbEntry->rgbGreen = BYTE( gray*255/20 );
		prgbEntry->rgbRed = BYTE( gray*255/20 );
		prgbEntry->rgbReserved = 0;

		prgbEntry++;
	}
}

#ifndef _WIN32_WCE
inline COLORREF CImage::GetTransparentRGB() const
{
	RGBQUAD rgb;

	ATLASSUME( m_hDC != NULL );  // Must have a DC
	ATLASSUME( m_iTransparentColor != -1 );

	::GetDIBColorTable( m_hDC, m_iTransparentColor, 1, &rgb );

	return( RGB( rgb.rgbRed, rgb.rgbGreen, rgb.rgbBlue ) );
}

inline bool CImage::InitGDIPlus() throw()
{
	bool bSuccess = s_initGDIPlus.Init();
	return( bSuccess );
}
#endif // _WIN32_WCE

};  // namespace ATL

#pragma pack(pop)

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif

#endif  // __ATLIMAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlmime.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLMIME_H__
#define __ATLMIME_H__

#pragma once

#ifdef _WIN32_WCE
	#error atlmime.h is not supported on Windows CE (_WIN32_WCE is defined)
#endif //_WIN32_WCE

#include <tchar.h>
#include <time.h>
#include <atlbase.h>
#include <mlang.h>
#include <atlfile.h>
#include <atlcoll.h>
#include <atlstr.h>
#include <atlsmtputil.h>
#include <atlenc.h>
#include <atlspriv.h>

#pragma warning(push)
#pragma warning(disable: 4625) // copy constructor could not be generated because a base class copy constructor is inaccessible
#pragma warning(disable: 4626) // assignment operator could not be generated because a base class assignment operator is inaccessible

#ifndef _CPPUNWIND
#pragma warning (push)
#pragma warning(disable: 4702) // unreachable code
#endif // _CPPUNWIND

#pragma pack(push,_ATL_PACKING)
namespace ATL {

#ifndef ATLMIME_SEPARATOR
#define ATLMIME_SEPARATOR "\r\n\r\n--"
#endif//ATLMIME_SEPARATOR

#ifndef ATLMIME_VERSION 
#define ATLMIME_VERSION "MIME-Version: 1.0"
#endif//ATLMIME_VERSION

#ifndef ATLMIME_EMAIL
#define ATLMIME_EMAIL "email"
#endif//ATLMIME_EMAIL

extern __declspec(selectany) const DWORD ATL_MIME_BOUNDARYLEN = 32;
extern __declspec(selectany) const DWORD ATL_MIME_DATE_LEN    = 64;

// Called when message is sent - sets the "Date:" field
inline size_t SetRfc822Time(__out_ecount_part_z_opt(dwLen, return) LPSTR szDate, __in size_t dwLen) throw()
{
	// Max buffer size required(including NULL) - 38
	const size_t s_dwMaxBufferLen = 38;
	if (szDate == NULL)
	{
		return s_dwMaxBufferLen;
	}
	
	if (dwLen < 38)
	{
		return 0;
	}
	static const LPCSTR s_months[12] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", 
							   "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

	static const LPCSTR s_days[7] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };

	SYSTEMTIME st;
	DWORD      dwTimeZoneId=TIME_ZONE_ID_UNKNOWN;
	CHAR       cDiff;
	LONG       ltzBias=0;
	LONG       ltzHour;
	LONG       ltzMinute;
	TIME_ZONE_INFORMATION tzi;

	GetLocalTime(&st);

	// Gets TIME_ZONE_INFORMATION
	memset(&tzi, 0, sizeof(tzi));
	dwTimeZoneId = GetTimeZoneInformation(&tzi);
	switch (dwTimeZoneId)
	{
	case TIME_ZONE_ID_STANDARD:
		ltzBias = tzi.Bias + tzi.StandardBias;
		break;

	case TIME_ZONE_ID_DAYLIGHT:
		ltzBias = tzi.Bias + tzi.DaylightBias;
		break;

	case TIME_ZONE_ID_UNKNOWN:
	default:
		ltzBias = tzi.Bias;
		break;
	}

	// Set Hour Minutes and time zone dif
	ltzHour = ltzBias / 60;
	ltzMinute = ltzBias % 60;
	cDiff = (ltzHour < 0) ? '+' : '-';

	int nDay = (st.wDayOfWeek > 6) ? 0 : st.wDayOfWeek;
	int nMonth = st.wMonth = (WORD)((st.wMonth < 1 || st.wMonth > 12) ? 0 : st.wMonth - 1);


	// Constructs RFC 822 format: "ddd, dd mmm yyyy hh:mm:ss +/- hhmm\0"
#if _SECURE_ATL && !defined(_ATL_MIN_CRT)
	sprintf_s(szDate, dwLen, "Date: %3s, %d %3s %4d %02d:%02d:%02d %c%02d%02d",
					  s_days[nDay],                            // "ddd"
					  st.wDay,                                 // "dd"
					  s_months[nMonth],                        // "mmm"
					  st.wYear,                                // "yyyy"
					  st.wHour,                                // "hh"
					  st.wMinute,                              // "mm"
					  st.wSecond,                              // "ss"
					  cDiff,                                   // "+" / "-"
					  abs (ltzHour),                           // "hh"
					  abs (ltzMinute));                        // "mm"
#else
	wsprintfA(szDate, "Date: %3s, %d %3s %4d %02d:%02d:%02d %c%02d%02d",
					  s_days[nDay],                            // "ddd"
					  st.wDay,                                 // "dd"
					  s_months[nMonth],                        // "mmm"
					  st.wYear,                                // "yyyy"
					  st.wHour,                                // "hh"
					  st.wMinute,                              // "mm"
					  st.wSecond,                              // "ss"
					  cDiff,                                   // "+" / "-"
					  abs (ltzHour),                           // "hh"
					  abs (ltzMinute));                        // "mm"
#endif
	return s_dwMaxBufferLen;
}

inline DWORD GetContentTypeFromFileName(LPCTSTR szFileName, CSimpleString& strContentType) throw()
{
	if (szFileName == NULL)
	{
		return ERROR_INVALID_DATA;
	}

	DWORD dwErr = ERROR_PATH_NOT_FOUND;
	_ATLTRY
	{
		// get the file extension
		TCHAR szExt[_MAX_EXT];
		Checked::tsplitpath_s(szFileName, NULL, 0, NULL, 0, NULL, 0, szExt, _countof(szExt));
		if (*szExt)
		{
			// Query the content type from the registry
			CRegKey rkContentType;
			dwErr = rkContentType.Open(HKEY_CLASSES_ROOT, szExt, KEY_READ);
			if (dwErr == ERROR_SUCCESS)
			{
				ULONG nChars=0;
				dwErr = rkContentType.QueryStringValue(_T("Content Type"), NULL, &nChars);
				if (dwErr == ERROR_SUCCESS)
				{
					LPTSTR szBuf = strContentType.GetBuffer(nChars);
					dwErr = rkContentType.QueryStringValue(_T("Content Type"), szBuf, &nChars);
					strContentType.ReleaseBuffer(nChars);
				}
			}
		}

		if (dwErr != ERROR_SUCCESS)
		{
			// default to application/octet-stream
			strContentType.SetString(_T("application/octet-stream"), sizeof("application/octet-stream")-1);
		}
	}
	_ATLCATCHALL()
	{
		dwErr = ERROR_OUTOFMEMORY;
	}

	return dwErr;
}

// CMimeBodyPart is an abstract base class for the body parts
// CMimeAttachment, CMimeText, CMimeHeader.
class CMimeBodyPart
{
public:

	virtual ~CMimeBodyPart() = 0 {}

	// WriteData - pure virtual method to dump the data for a body part.
	virtual BOOL WriteData(HANDLE hFile, LPOVERLAPPED pOverlapped, LPCSTR szBoundary, DWORD dwFlags = 0) = 0;

	// GetContentType - pure virtual method to get the content of a body part
	virtual LPCSTR GetContentType() = 0;

	// GetCharset - virtual method to get the character set of a body part
	// (defaults to ATLSMTP_DEFAULT_CSET).
	virtual LPCSTR GetCharset()
	{
		return ATLSMTP_DEFAULT_CSET;
	}

	virtual CMimeBodyPart* Copy() = 0;

protected:

	// MakeMimeHeader - pure virutal method to create a MIME header for a 
	// body part.
	virtual BOOL MakeMimeHeader(CStringA& header, LPCSTR szBoundary) = 0;
}; // class CMimeBodyPart


// This enum is used with the X-Priority part of the message header
enum ATL_MIME_PRIORITY 
{
	ATL_MIME_HIGH_PRIORITY   = 1, 
	ATL_MIME_NORMAL_PRIORITY = 3, 
	ATL_MIME_LOW_PRIORITY    = 5, 
	ATL_MIME_PRIORITY_ERROR  = 0
};


// CMimeHeader describes the basic RFC 822 message header.
// It also serves as the base class for the CMimeMessage object.
class CMimeHeader : public CMimeBodyPart
{
protected:

	// Pointer to MLANG's IMultiLanguage interface.
	// This is used in doing conversion from code pages
	// to MIME-compatible character sets.
	CComPtr<IMultiLanguage> m_spMultiLanguage;

	//Basic Header Parts
	CStringA        m_strFrom;
	CStringA        m_strTo;
	CStringA        m_strCc;
	CStringA        m_strBcc;
	CStringA        m_strSubject;

	//Extended Header Parts
	ATL_MIME_PRIORITY   m_nPriority;
	CStringA        m_XHeader;

	//Display Names
	CStringA        m_strSenderName;

	//MIME Character Sets
	char            m_szSubjectCharset[ATL_MAX_ENC_CHARSET_LENGTH];
	char            m_szSenderCharset[ATL_MAX_ENC_CHARSET_LENGTH];

	//Recipient and CC charsets are encoded in the Add methods

public:

	CMimeHeader() throw()
		:m_nPriority(ATL_MIME_NORMAL_PRIORITY)
	{
		m_szSubjectCharset[0] = '\0';
		m_szSenderCharset[0] = '\0';
	}

	~CMimeHeader() throw()
	{
	}

	// Initialize MLang for multilanguage support
	inline BOOL Initialize(IMultiLanguage* pMultiLanguage = NULL) throw()
	{
		if (pMultiLanguage != NULL)
		{
			m_spMultiLanguage = pMultiLanguage;
		}
		else
		{
			HRESULT hr = m_spMultiLanguage.CoCreateInstance(__uuidof(CMultiLanguage), NULL, CLSCTX_INPROC_SERVER);
			if (hr != S_OK)
				return FALSE;
		}
		return TRUE;
	}

	// Get the content type
	virtual inline LPCSTR GetContentType() throw()
	{
		return "text/plain";
	}

	// Get the character set
	virtual inline LPCSTR GetCharset() throw()
	{
		return "iso-8859-1";
	}

	virtual ATL_NOINLINE CMimeBodyPart* Copy() throw( ... )
	{
		CAutoPtr<CMimeHeader> pNewHeader;
		ATLTRY(pNewHeader.Attach(new CMimeHeader));
		if (pNewHeader)
			*pNewHeader = *this;

		return pNewHeader.Detach();
	}

	const CMimeHeader& operator=(const CMimeHeader& that) throw( ... )
	{
		if (this != &that)
		{
			m_spMultiLanguage = that.m_spMultiLanguage;
			m_strFrom = that.m_strFrom;
			m_strTo = that.m_strTo;
			m_strCc = that.m_strCc;
			m_strSubject = that.m_strSubject;

			m_nPriority = that.m_nPriority;
			m_XHeader = that.m_XHeader;

			m_strSenderName = that.m_strSenderName;

			Checked::strcpy_s(m_szSubjectCharset, ATL_MAX_ENC_CHARSET_LENGTH, that.m_szSubjectCharset);
			Checked::strcpy_s(m_szSenderCharset, ATL_MAX_ENC_CHARSET_LENGTH, that.m_szSenderCharset);
		}

		return *this;
	}

	// Set the priority of the message
	inline BOOL SetPriority(ATL_MIME_PRIORITY nPriority) throw()
	{
		if (nPriority < 0)
			return FALSE;
		m_nPriority = nPriority;
		return TRUE;
	}

	// Get the priority of the message
	inline ATL_MIME_PRIORITY GetPriority() throw()
	{
		return m_nPriority;
	}

	// Set the display (friendly) name for the header
	inline BOOL SetSenderName(LPCTSTR szName, UINT uiCodePage = 0) throw()
	{
		if (szName == NULL)
			return FALSE;

		CHeapPtr<char> szNamePtr;
		UINT nLen(0);

		BOOL bRet = AtlMimeConvertString(m_spMultiLanguage, uiCodePage, szName, &szNamePtr, &nLen);
		if (bRet)
		{
			_ATLTRY
			{
				m_strSenderName.Empty();
				m_strSenderName.Append(szNamePtr, (int) nLen);
			}
			_ATLCATCHALL()
			{
				return FALSE;
			}
			bRet = AtlMimeCharsetFromCodePage(m_szSenderCharset, uiCodePage, m_spMultiLanguage, ATL_MAX_ENC_CHARSET_LENGTH);
		}

		return bRet;
	}

	// Get the display (friendly) name for the sender
	inline LPCSTR GetSenderName() throw()
	{
		return m_strSenderName;
	}

	// Append a user defined header (should not contain CRLF)
	inline BOOL AppendUserDefinedHeader(LPCTSTR szHeaderName, LPCTSTR szHeader, UINT uiCodePage = 0) throw()
	{
		if ((szHeader == NULL) || (szHeaderName == NULL))
			return FALSE;

		_ATLTRY
		{
			CHeapPtr<char> szName;
			UINT nLen(0);

			BOOL bRet = AtlMimeConvertString(m_spMultiLanguage, uiCodePage, szHeader, &szName, &nLen);
			if (bRet)
			{
				// get the charset
				char szCharset[ATL_MAX_ENC_CHARSET_LENGTH];			
				bRet = AtlMimeCharsetFromCodePage(szCharset, uiCodePage, m_spMultiLanguage, ATL_MAX_ENC_CHARSET_LENGTH);

				if (bRet)
				{
					CStringA str;
					str.Append(szName, (int)nLen);

					// encode the string
					CHeapPtr<char> szBuf;
					DWORD dwReqLen = QEncodeGetRequiredLength(str.GetLength(), 
								ATL_MAX_ENC_CHARSET_LENGTH);

					if (szBuf.Allocate(dwReqLen) == false)
					{
						return FALSE;
					}

					DWORD dwLength(0);
					BOOL bEncoded = FALSE;
					if (!GetEncodedString(str, szCharset, szBuf, dwReqLen, dwLength, bEncoded))
					{
						return FALSE;
					}

					// add to m_XHeader
					m_XHeader += CT2CA(szHeaderName);
					m_XHeader.Append(": ", 2);
					m_XHeader.Append(szBuf, dwLength);
					m_XHeader.Append("\r\n", 2);
				}
			}

			return bRet;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Add a recipient ("To:" line)
	inline BOOL AddRecipient(LPCTSTR szAddress, LPCTSTR szName = NULL, UINT uiCodePage = 0) throw()
	{
		return AddRecipientHelper(m_strTo, szAddress, szName, uiCodePage);
	}

	// Get the recipients string ("To:" line)
	inline LPCSTR GetRecipients() throw()
	{
		return m_strTo;
	}

	// Clear all recipients ("To:" line)
	inline BOOL ClearRecipients() throw()
	{
		m_strTo.Empty();
		return TRUE;
	}

	// Add a recipient ("CC:" line)
	inline BOOL AddCc(LPCTSTR szAddress, LPCTSTR szName = NULL, UINT uiCodePage = 0) throw()
	{
		return AddRecipientHelper(m_strCc, szAddress, szName, uiCodePage);
	}

	// Get the recipients string ("CC:" line)
	inline LPCSTR GetCc() throw()
	{
		return m_strCc;
	}

	// Clear the recipients string ("CC:" line)
	inline BOOL ClearCc() throw()
	{
		m_strCc.Empty();
		return TRUE;
	}

	// Add a Bcc recipient (not output as part of message)
	inline BOOL AddBcc(LPCTSTR szAddress) throw()
	{
		if (szAddress == NULL)
		{
			return FALSE;
		}

		_ATLTRY
		{
			CStringA str = m_strBcc;

			if (m_strBcc.GetLength() > 0)
				str.Append(",", 1);

			str += CT2CA(szAddress);

			m_strBcc = str;

			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Get the recipients string (Bcc part)
	inline LPCSTR GetBcc() throw()
	{
		return m_strBcc;
	}

	// Clear the recipients string (Bcc part)
	inline BOOL ClearBcc() throw()
	{
		m_strBcc.Empty();
		return TRUE;
	}


	inline DWORD GetRequiredRecipientsStringLength() throw()
	{
		DWORD dwRet = m_strTo.GetLength();
		if (m_strCc.GetLength())
		{
			dwRet += dwRet ? 1 : 0;
			dwRet += m_strCc.GetLength();
		}
		if (m_strBcc.GetLength())
		{
			dwRet += dwRet ? 1 : 0;
			dwRet += m_strBcc.GetLength();
		}
		dwRet++;
		return dwRet;
	}

	// returns the recipients string to be (addresses only, in comma separated format)
	ATL_NOINLINE BOOL GetRecipientsString(__out_ecount_part_z(*pdwLen, *pdwLen) LPSTR szRecip, __inout LPDWORD pdwLen) throw()
	{
		if (szRecip == NULL)
		{
			return FALSE;
		}

		if ((pdwLen != NULL) && (*pdwLen < GetRequiredRecipientsStringLength()))
		{
			*pdwLen = GetRequiredRecipientsStringLength();
			return FALSE;
		}

		DWORD dwMaxLen = 0;

		if (pdwLen != NULL)
		{
			dwMaxLen = *pdwLen;
			*pdwLen = 0;
		}

		DWORD dwLen = 0;
		DWORD dwTotalLen = 0;
		if (m_strTo.GetLength() > 0)
		{
			if (AtlMimeMakeRecipientsString(m_strTo, szRecip, &dwLen) != TRUE)
			{
				return FALSE;
			}
			szRecip+= dwLen;
			dwTotalLen = dwLen;
		}

		if (m_strCc.GetLength() > 0)
		{
			if (dwTotalLen)
			{
				*szRecip++ = ',';
				dwTotalLen++;
			}
			if (AtlMimeMakeRecipientsString(m_strCc, szRecip, &dwLen) != TRUE)
			{
				return FALSE;
			}
			szRecip+= dwLen;
			dwTotalLen+= dwLen;
		}

		if (m_strBcc.GetLength() > 0)
		{
			dwLen = m_strBcc.GetLength();
			if (dwTotalLen)
			{
				*szRecip++ = ',';
				dwTotalLen++;
			}
			Checked::memcpy_s(szRecip, dwMaxLen-dwTotalLen, m_strBcc, dwLen);
			szRecip+= dwLen;
			dwTotalLen+= dwLen;
		}

		*szRecip = '\0';
		if (pdwLen != NULL)
		{
			*pdwLen = dwTotalLen;
		}

		return TRUE;
	}


	// Get the sender
	inline LPCSTR GetSender() throw()
	{
		return m_strFrom;
	}

	// Set the sender
	inline BOOL SetSender(LPCTSTR szSender) throw()
	{
		if (szSender == NULL)
			return FALSE;

		_ATLTRY
		{
			m_strFrom = CT2CA(szSender);
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Set the subject
	inline BOOL SetSubject(LPCTSTR szSubject, UINT uiCodePage = 0) throw()
	{
		if (szSubject == NULL)
			return FALSE;

		_ATLTRY
		{
			CHeapPtr<char> szName;
			UINT nLen(0);

			BOOL bRet = AtlMimeConvertString(m_spMultiLanguage, uiCodePage, szSubject, &szName, &nLen);
			if (bRet)
			{
				m_strSubject.Empty();
				m_strSubject.Append(szName, (int)nLen);
				bRet = AtlMimeCharsetFromCodePage(m_szSubjectCharset, uiCodePage, m_spMultiLanguage, ATL_MAX_ENC_CHARSET_LENGTH);
			}

			return bRet;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Get the subject
	inline LPCSTR GetSubject() throw()
	{
		return (LPCSTR)m_strSubject;
	}

	// Dump the header to hFile
	virtual inline BOOL WriteData(HANDLE hFile, LPOVERLAPPED pOverlapped, LPCSTR /*szBoundary*/, DWORD dwFlags = 0) throw()
	{
		if (pOverlapped == NULL)
		{
			return FALSE;
		}

		int nMaxSendLen = GetRequiredBufferSize(ATLSMTP_MAX_LINE_LENGTH-4);
		CHeapPtr<char> spSendBuffer;
		if (!spSendBuffer.Allocate(nMaxSendLen))
			return FALSE;
		
		// choose QEncode here, because the max QEncodeGetRequiredLength will always
		// return a value greater than BEncodeGetRequiredLength
		int nBufLen = __max(QEncodeGetRequiredLength(m_strSubject.GetLength(), 
								ATL_MAX_ENC_CHARSET_LENGTH),
						  QEncodeGetRequiredLength(m_strSenderName.GetLength(), 
								ATL_MAX_ENC_CHARSET_LENGTH)+m_strFrom.GetLength()+2);

		CHeapPtr<char> spBuf;
		if (!spBuf.Allocate(nBufLen))
			return FALSE;

		int nMaxLen = nBufLen;
		DWORD dwOffset = 0;

		char szDate[ATL_MIME_DATE_LEN];

		SetRfc822Time(szDate, ATL_MIME_DATE_LEN);
		char *pSendBuffer = spSendBuffer;

		DWORD dwLength = (DWORD) strlen(szDate);
		
		if(dwLength > ATLSMTP_MAX_LINE_LENGTH -2 -dwOffset )
			return FALSE;
		
		Checked::memcpy_s(pSendBuffer+dwOffset, nMaxSendLen-dwOffset, szDate, dwLength);
		dwOffset += dwLength;
		*(pSendBuffer+dwOffset++) = '\r';
		*(pSendBuffer+dwOffset++) = '\n';

		int dwHeaderPartLength = 0;
		*spBuf = '\0';

		// Get the sender name
		BOOL bRet = TRUE;
		BOOL bEncoded = FALSE;
		if (m_strSenderName.GetLength() > 0)
		{
			bRet = GetEncodedString(m_strSenderName, m_szSenderCharset, spBuf, nBufLen, dwLength, bEncoded);
			dwHeaderPartLength += dwLength;
		}

		// Get the sender email address
		if (bRet && m_strFrom.GetLength() > 0)
		{
				
			if (dwHeaderPartLength != 0)
			{
				if(dwHeaderPartLength + 1 > nBufLen)
					return FALSE;
			
				*(spBuf+dwHeaderPartLength++) = ' ';
			}
			
			if(dwHeaderPartLength + m_strFrom.GetLength() + 2 > nBufLen)
				return FALSE;

			*(spBuf+dwHeaderPartLength++) = '<';
			if (dwHeaderPartLength < 0 || dwHeaderPartLength > nMaxLen)
			{
				return FALSE;
			}
			Checked::memcpy_s(spBuf+dwHeaderPartLength, nMaxLen-dwHeaderPartLength, (LPCSTR)m_strFrom, m_strFrom.GetLength());
			dwHeaderPartLength+= m_strFrom.GetLength();
			*(spBuf+dwHeaderPartLength++) = '>';
		}

		// Output the "From: " line
		if (bRet && dwHeaderPartLength != 0)
		{
			const char szFrom[] = "From: ";
			if(sizeof(szFrom)/sizeof(szFrom[0])-1 > ATLSMTP_MAX_LINE_LENGTH -2 -dwOffset )
				return FALSE;
			if (dwOffset > static_cast<DWORD>(nMaxSendLen))
			{
				return FALSE;
			}
			Checked::memcpy_s(pSendBuffer+dwOffset, nMaxSendLen-dwOffset, szFrom, _countof(szFrom)-1);
			dwOffset+= (sizeof(szFrom)/sizeof(szFrom[0])-1) ;
			DWORD dwWritten = ATLSMTP_MAX_LINE_LENGTH - 2 - dwOffset;
			bRet = FormatField((LPBYTE)(char*)spBuf, dwHeaderPartLength, (LPBYTE)(pSendBuffer+dwOffset), &dwWritten, dwFlags);
			dwOffset += dwWritten;
			*(pSendBuffer+dwOffset++) = '\r';
			*(pSendBuffer+dwOffset++) = '\n';
		}

		// Output the subject
		if (bRet && m_strSubject.GetLength() > 0)
		{
			dwLength = 0;
			bRet = GetEncodedString(m_strSubject, m_szSubjectCharset, spBuf, nBufLen, dwLength, bEncoded);
			if (bRet && dwLength != 0)
			{
				const char szSubject[] = "Subject: ";
				if(sizeof(szSubject)/sizeof(szSubject[0])-1 > ATLSMTP_MAX_LINE_LENGTH -2 -dwOffset )
					return FALSE;
				if (dwOffset > static_cast<DWORD>(nMaxSendLen))
				{
					return FALSE;
				}
				Checked::memcpy_s(pSendBuffer+dwOffset, nMaxSendLen-dwOffset, szSubject, _countof(szSubject)-1);
				dwOffset+= (sizeof(szSubject)/sizeof(szSubject[0])-1);
				DWORD dwWritten = ATLSMTP_MAX_LINE_LENGTH - 2 - dwOffset;
				bRet = FormatField((LPBYTE)(char*)spBuf, dwLength, (LPBYTE)(pSendBuffer+dwOffset), &dwWritten, dwFlags);
				dwOffset += dwWritten;
				*(pSendBuffer+dwOffset++) = '\r';
				*(pSendBuffer+dwOffset++) = '\n';
			}
		}

		// Output the "To:" line
		if (bRet && m_strTo.GetLength() > 0)
		{
			const char szTo[] = "To: ";
			if(sizeof(szTo)/sizeof(szTo[0])-1 > ATLSMTP_MAX_LINE_LENGTH -2 -dwOffset )
					return FALSE;
			if (dwOffset > static_cast<DWORD>(nMaxSendLen))
			{
				return FALSE;
			}
			Checked::memcpy_s(pSendBuffer+dwOffset, nMaxSendLen-dwOffset, szTo, _countof(szTo)-1);
			dwOffset+= (sizeof(szTo)/sizeof(szTo[0]) -1);
			DWORD dwWritten = ATLSMTP_MAX_LINE_LENGTH - 2 - dwOffset;
			bRet = FormatRecipients((LPBYTE)((LPCSTR)m_strTo), m_strTo.GetLength(), (LPBYTE)(pSendBuffer+dwOffset), &dwWritten);
			dwOffset+= dwWritten;
			*(pSendBuffer+dwOffset++) = '\r';
			*(pSendBuffer+dwOffset++) = '\n';
		}

		// Output the "CC:" line
		if (bRet && m_strCc.GetLength() > 0)
		{
			const char szCC[] = "CC: ";
			if(sizeof(szCC)/sizeof(szCC[0])-1 > ATLSMTP_MAX_LINE_LENGTH -2 -dwOffset )
				return FALSE;
			if (dwOffset > static_cast<DWORD>(nMaxSendLen))
			{
				return FALSE;
			}
			Checked::memcpy_s(pSendBuffer+dwOffset, nMaxSendLen-dwOffset, szCC, _countof(szCC)-1);
			dwOffset+= (sizeof(szCC)/sizeof(szCC[0]) -1);
			DWORD dwWritten = ATLSMTP_MAX_LINE_LENGTH - 2 - dwOffset;
			bRet = FormatRecipients((LPBYTE)((LPCSTR)m_strCc), m_strCc.GetLength(), (LPBYTE)(pSendBuffer+dwOffset), &dwWritten);
			dwOffset+= dwWritten;
			*(pSendBuffer+dwOffset++) = '\r';
			*(pSendBuffer+dwOffset++) = '\n';
		}

		// Send the header
		if (bRet && dwOffset)
			bRet = AtlSmtpSendAndWait(hFile, pSendBuffer, dwOffset, pOverlapped);

		return bRet;
	}

protected:

	// Make the mime header
	virtual inline BOOL MakeMimeHeader(CStringA& /*header*/, LPCSTR /*szBoundary*/) throw()
	{
		// The message header does not have its own MIME header
		ATLASSERT(FALSE);
		return TRUE;
	}

	// Get an encoded string for a header field
	inline BOOL GetEncodedString(__in CStringA& headerString, __in LPCSTR szCharset, __out_ecount_part_z(nBufLen, dwLength) LPSTR szBuf, __in int nBufLen, __out DWORD& dwLength, __out BOOL& bEncoded) throw()
	{
//		BOOL bEncoded = FALSE;
		bEncoded = FALSE;
		if (m_spMultiLanguage.p)
		{
			// only encode if there are 8bit characters
			int nExtendedChars = GetExtendedChars(headerString, headerString.GetLength());
			if (nExtendedChars)
			{
				// choose smallest encoding
				if (((nExtendedChars*100)/headerString.GetLength()) < 17)
				{
					int nEncCnt = 0;
					if (!QEncode((LPBYTE)((LPCSTR)headerString), headerString.GetLength(), szBuf, &nBufLen, szCharset, &nEncCnt))
					{
						return FALSE;
					}

					//if no unsafe characters were encountered, just output it
					if (nEncCnt != 0)
					{
						bEncoded = TRUE;
					}
				}
				else
				{
					if (!BEncode((LPBYTE)((LPCSTR)headerString), headerString.GetLength(), szBuf, &nBufLen, szCharset))
					{
						return FALSE;
					}

					bEncoded = TRUE;
				}
			}
		}

		if (!bEncoded)
		{
			// there was no encoding
			dwLength = (DWORD) headerString.GetLength();
			if(dwLength > DWORD(nBufLen))
				return FALSE;
			Checked::memcpy_s(szBuf, nBufLen, headerString, dwLength);
		}
		else
		{
			dwLength = nBufLen;
		}
		return TRUE;
	}


	// Helper function for adding recipients
	inline BOOL AddRecipientHelper(CStringA& str, LPCTSTR szAddress, LPCTSTR szName = NULL, UINT uiCodePage = 0) throw()
	{
		if ((szAddress == NULL) && (szName == NULL))
		{
			return FALSE;
		}

		_ATLTRY
		{
			if (szName)
			{
				CHeapPtr<char> szNamePtr;
				UINT nLen(0);

				BOOL bRet = AtlMimeConvertString(m_spMultiLanguage, uiCodePage, szName, &szNamePtr, &nLen);
				if (bRet)
				{
					CStringA Name(szNamePtr, (int)nLen);

					char szCharset[ATL_MAX_ENC_CHARSET_LENGTH];

					if (!AtlMimeCharsetFromCodePage(szCharset, uiCodePage, m_spMultiLanguage, ATL_MAX_ENC_CHARSET_LENGTH))
					{
						return FALSE;
					}

					CFixedStringT<CStringA, 256> strBuf;

					int nBufLen = QEncodeGetRequiredLength(Name.GetLength(), 
								ATL_MAX_ENC_CHARSET_LENGTH)+1;

					char * szBuf = strBuf.GetBuffer(nBufLen);
					if (szBuf == NULL)
					{
						return FALSE;
					}

					DWORD dwLength = 0;
					BOOL bEncoded = FALSE;
					if (!GetEncodedString(Name, szCharset, szBuf, nBufLen, dwLength, bEncoded))
					{
						strBuf.ReleaseBuffer();
						return FALSE;
					}

					strBuf.ReleaseBuffer(dwLength);

					// append comma if there are existing recipients
					if (str.GetLength() != 0)
					{
						str.Append(", ", 2);
					}

					if (bEncoded == FALSE)
					{
						// need to escape the string if no encoding
						strBuf.Replace("\\", "\\\\");
						strBuf.Replace("\"", "\\\"");

						// wrap the unescaped name in quotes
						str.Append("\"", 1);
					}
					str += strBuf;
					if (bEncoded == FALSE)
					{
						// close quote
						str.Append("\"", 1);
					}
				}
				else
				{
					return bRet;
				}
			}

			if (szAddress)
			{
				if (szName)
				{
					str.Append(" ", 1);
				}
				else
				{
					// append comma if there are existing recipients
					if (str.GetLength() != 0)
					{
						str.Append(", ", 2);
					}
				}
				str.Append("<", 1);
				str += CT2CA(szAddress);
				str.Append(">", 1);
			}
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Get the formatted header information
	inline BOOL FormatField(LPBYTE pbSrcData, int nSrcLen, LPBYTE pbDest, 
		DWORD* pnBufLen, DWORD dwFlags = 0) throw()
	{
		if(pnBufLen == NULL)
			return FALSE;
			
		int nRead = 0;

		// 9 is the length of the maximum field name : "Subject :"
		// we set that here for simplicity
		int nLineLen = 9;
		DWORD nWritten = 0;

		//subtract 2 from these because it's easier for when we have
		//to break lines with a CRLF (and tab if necessary)
		int nMaxLineLength = ATLSMTP_MAX_LINE_LENGTH-3;
		while (nRead < nSrcLen)
		{
			//if we're at the end of the line, break it
			if (nLineLen == nMaxLineLength)
			{
				if( nWritten + 2  > *pnBufLen)
					return FALSE;
					
				*pbDest++ = '\r';
				*pbDest++ = '\n';
				nWritten+= 2;
				nLineLen = -1;

				if ((dwFlags & ATLSMTP_FORMAT_SMTP))
				{
					if(nWritten + 1 > *pnBufLen)
						return FALSE;
						
					*pbDest++ = '\t';
					nWritten++;
					nLineLen++;
				}
			}

			//if we hit a CRLF, reset nLineLen
			if (*pbSrcData == '\n' && nRead > 0 && *(pbSrcData-1) == '\r')
			{
				nLineLen = -1;
			}

			if(nWritten + 1 > *pnBufLen)
				return FALSE;
				
			*pbDest++ = *pbSrcData++;
			nRead++;
			nWritten++;
			nLineLen++;
		}

		*pnBufLen = (DWORD)nWritten;

		return TRUE;
	}


	// Get the formatted recipient information
	inline BOOL FormatRecipients(LPBYTE pbSrcData, int nSrcLen, LPBYTE pbDest, 
		DWORD* pnBufLen) throw()
	{
		
		if(pnBufLen == NULL)
			return FALSE;
			
		int nRead    = 0;
		DWORD nWritten = 0;

		while (nRead < nSrcLen)
		{
			if (*pbSrcData == ',')
			{
				if(nWritten + 4 > *pnBufLen)
					return FALSE;
					
				*pbDest++ = *pbSrcData++;
				nRead++;
				if (nRead+1 <= nSrcLen && *pbSrcData == ' ')
				{
					pbSrcData++;
					nRead++;
				}
				*pbDest++ = '\r';
				*pbDest++ = '\n';
				*pbDest++ = '\t';
				nWritten+= 4;

				continue;
			}

			if(nWritten + 1 > *pnBufLen)
				return FALSE;
				
			*pbDest++ = *pbSrcData++;
			nRead++;
			nWritten++;
		}

		*pnBufLen = nWritten;

		return TRUE;
	}

	// Get the required buffer size for the header
	inline int GetRequiredBufferSize(int nMaxLineLength) throw()
	{
		const static DWORD DATELINE    = 27;
		const static DWORD FROMLINE    = 10;
		const static DWORD TOLINE      = 6;
		const static DWORD CCLINE      = 6;
		const static DWORD SUBJECTLINE = 11;

		//data lengths (QEncoding potentially takes up more space than BEncoding,
		//so default to it)
		int nRequiredLength = QEncodeGetRequiredLength(m_strSenderName.GetLength(), ATL_MAX_ENC_CHARSET_LENGTH)
			+QEncodeGetRequiredLength(m_strSubject.GetLength(), ATL_MAX_ENC_CHARSET_LENGTH);
		nRequiredLength += m_strFrom.GetLength()+m_strTo.GetLength()+m_strCc.GetLength();

		//Add space for date
		nRequiredLength += DATELINE;

		//Add space for From: line
		nRequiredLength += FROMLINE;

		//Add space for To: line
		nRequiredLength += TOLINE;

		//Add space for Cc: line
		nRequiredLength += CCLINE;

		//Add space for Subject: line
		nRequiredLength += SUBJECTLINE;

		//Add space for line breaks and tabs
		nRequiredLength += 3*(nRequiredLength/nMaxLineLength);

		//Trailing CRLF
		nRequiredLength += 2;

		return nRequiredLength;
	}

}; // class CMimeHeader


// CMimeAttachment is an abstract base class for MIME message attachments.
// It serves as a base class for CMimeFileAttachment and CMimeRawAttachment
class CMimeAttachment : public CMimeBodyPart
{
protected:

	// the encoding scheme (ATLSMTP_BASE64_ENCODE, ATLSMTP_UUENCODE, ATLSMTP_QP_ENCODE)
	int      m_nEncodingScheme;

	// the content type of the attachment
	CStringA m_ContentType;

	// the character set
	char     m_szCharset[ATL_MAX_ENC_CHARSET_LENGTH];

	// the encode string ("base64", "quoted-printable", "uuencode")
	char     *m_pszEncodeString;

	// the display name of the attachment
	TCHAR    m_szDisplayName[_MAX_FNAME];

public:
	CMimeAttachment() throw()
		:m_nEncodingScheme(ATLSMTP_BASE64_ENCODE), m_pszEncodeString(NULL)
	{
		m_szCharset[0] = 0;
		m_szDisplayName[0] = 0;
	}

	virtual ~CMimeAttachment() throw()
	{
	}

	// CMimeFileAttachment and CMimeRawAttachment have to handle their own dumping
	virtual inline BOOL WriteData(HANDLE hFile, LPOVERLAPPED pOverlapped, LPCSTR szBoundary, DWORD dwFlags = 0) = 0;

	// Set the encoding scheme of the attachment
	inline BOOL SetEncodingScheme(int nScheme) throw()
	{
		if (nScheme != ATLSMTP_BASE64_ENCODE && nScheme != ATLSMTP_UUENCODE && nScheme != ATLSMTP_QP_ENCODE)
		{
			return FALSE;
		}

		m_nEncodingScheme = nScheme;
		return TRUE;
	}

	// Set the Content-Type of the attachment
	inline BOOL SetContentType(LPCTSTR szContent) throw()
	{
		_ATLTRY
		{
			m_ContentType = CT2CA(szContent);
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Get the content type of the attachment
	virtual inline LPCSTR GetContentType() throw()
	{
		return m_ContentType;
	}

	// Get the character set of the attachment
	virtual inline LPCSTR GetCharset() throw()
	{
		return m_szCharset;
	}

	virtual ATL_NOINLINE CMimeBodyPart* Copy() = 0;

	const CMimeAttachment& operator=(const CMimeAttachment& that) throw( ... )
	{
		if (this != &that)
		{
			m_nEncodingScheme = that.m_nEncodingScheme;
			m_ContentType = that.m_ContentType;
			Checked::strcpy_s(m_szCharset, ATL_MAX_ENC_CHARSET_LENGTH, that.m_szCharset);
			m_pszEncodeString = that.m_pszEncodeString;
			Checked::tcscpy_s(m_szDisplayName, _countof(m_szDisplayName), that.m_szDisplayName);
		}

		return *this;
	}

protected:

	// Make the MIME header for the attachment
	virtual inline BOOL MakeMimeHeader(CStringA& header, LPCSTR szBoundary) throw()
	{
		// if no display name is specified, default to "rawdata"
		return MakeMimeHeader(header, szBoundary, _T("rawdata"));
	}

	// Make the MIME header with the specified filename
	virtual inline BOOL MakeMimeHeader(CStringA& header, LPCSTR szBoundary, LPCTSTR szFileName)
	{
		ATLENSURE(szBoundary != NULL);
		ATLASSERT(szFileName != NULL);
		ATLASSUME(m_pszEncodeString != NULL);

		char szBegin[256];
		if (*szBoundary)
		{
			// this is not the only body part
			Checked::memcpy_s(szBegin, 256, ATLMIME_SEPARATOR, sizeof(ATLMIME_SEPARATOR));
			Checked::memcpy_s(szBegin+6, 250, szBoundary, ATL_MIME_BOUNDARYLEN);
			*(szBegin+(ATL_MIME_BOUNDARYLEN+6)) = '\0';
		}
		else
		{
			// this is the only body part, so output the MIME header
			Checked::memcpy_s(szBegin, 256, ATLMIME_VERSION, sizeof(ATLMIME_VERSION));
		}

		// Get file name with the path stripped out
		TCHAR szFile[MAX_PATH+1];
		TCHAR szExt[_MAX_EXT+1];
		Checked::tsplitpath_s(szFileName, NULL, 0, NULL, 0, szFile, _countof(szFile), szExt, _countof(szExt));
		Checked::tcscat_s(szFile, _countof(szFile), szExt);

		_ATLTRY
		{
			CT2CAEX<MAX_PATH+1> szFileNameA(szFile);

			CStringA szDisplayName(szFile);
			if (m_szDisplayName[0] != '\0')
			{
				szDisplayName = CT2CAEX<_MAX_FNAME+1>(m_szDisplayName);
			}

			header.Format("%s\r\nContent-Type: %s;\r\n\tcharset=\"%s\"\r\n\tname=\"%s\"\r\n"
				"Content-Transfer-Encoding: %s\r\nContent-Disposition: attachment;\r\n\tfilename=\"%s\"\r\n\r\n",
				szBegin, (LPCSTR) m_ContentType, m_szCharset, (LPCSTR) szDisplayName, m_pszEncodeString, (LPCSTR) szFileNameA); 
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Get encoding information
	inline BOOL GetEncodingInformation(int* pnRequiredLength, int* pnLineLength)
	{
		ATLENSURE(pnRequiredLength != NULL);
		ATLENSURE(pnLineLength != NULL);

		switch(m_nEncodingScheme)
		{
			case ATLSMTP_BASE64_ENCODE:
				m_pszEncodeString = "base64";
				*pnLineLength = ATLSMTP_MAX_BASE64_LINE_LENGTH;
				*pnRequiredLength = Base64EncodeGetRequiredLength(ATLSMTP_MAX_BASE64_LINE_LENGTH);
				break;
			case ATLSMTP_UUENCODE:
				m_pszEncodeString ="uuencode";
				*pnLineLength = ATLSMTP_MAX_UUENCODE_LINE_LENGTH;
				*pnRequiredLength = UUEncodeGetRequiredLength(ATLSMTP_MAX_UUENCODE_LINE_LENGTH);
				break;
			case ATLSMTP_QP_ENCODE:
				m_pszEncodeString = "quoted-printable";
				*pnLineLength = ATLSMTP_MAX_QP_LINE_LENGTH;
				*pnRequiredLength = QPEncodeGetRequiredLength(ATLSMTP_MAX_QP_LINE_LENGTH);
				break;
			default:
				return FALSE;
		}
		return TRUE;
	}

}; // class CMimeAttachment


// CMimeFileAttachment represents a MIME file attachment body part
class CMimeFileAttachment : public CMimeAttachment
{

protected:
	// The filename
	TCHAR m_szFileName[MAX_PATH+1];

public:
	CMimeFileAttachment() throw()
	{
		m_szFileName[0] = 0;
	}

	virtual ATL_NOINLINE CMimeBodyPart* Copy() throw( ... )
	{
		CAutoPtr<CMimeFileAttachment> pNewAttachment;
		ATLTRY(pNewAttachment.Attach(new CMimeFileAttachment));
		if (pNewAttachment)
			*pNewAttachment = *this;

		return pNewAttachment.Detach();
	}

	const CMimeFileAttachment& operator=(const CMimeFileAttachment& that) throw( ... )
	{
		if (this != &that)
		{
			CMimeAttachment::operator=(that);
			Checked::tcscpy_s(m_szFileName, _countof(m_szFileName), that.m_szFileName);
		}

		return *this;
	}


	// Initialize the file attachment
	// szFileName - the actual file name
	// szDisplayName - the display name for the file (optional)
	// pMultiLanguage - the IMulitLanguage pointer for codepage to charset conversion (optional)
	// uiCodePage - the code page (optional)
	inline BOOL Initialize(LPCTSTR szFileName, LPCTSTR szDisplayName = NULL, IMultiLanguage* pMultiLanguage = NULL, UINT uiCodePage = 0) throw()
	{
		if (!AtlMimeCharsetFromCodePage(m_szCharset, uiCodePage, pMultiLanguage, ATL_MAX_ENC_CHARSET_LENGTH))
			return FALSE;

		if( _tcslen(szFileName) > MAX_PATH )
		{
			return FALSE;
		}
		Checked::tcscpy_s(m_szFileName, _countof(m_szFileName), szFileName);

		if (szDisplayName)
		{
			// use the user-specified display name
			size_t nLen = _tcslen(szDisplayName)+1;
			if (nLen <= _countof(m_szDisplayName))
			{
				Checked::tcscpy_s(m_szDisplayName, _countof(m_szDisplayName), szDisplayName);
			}
			else
			{
				Checked::tcsncpy_s(m_szDisplayName, _countof(m_szDisplayName), szDisplayName, _countof(m_szDisplayName) - 4);
				Checked::tcscpy_s(m_szDisplayName + _countof(m_szDisplayName) - 4, 4, _T("..."));
			}
		}
		else
		{
			// otherwise there is no display name
			*m_szDisplayName = '\0';
		}
		return TRUE;
	}

	// Dump the data for the file attachment
	virtual inline BOOL WriteData(HANDLE hFile, LPOVERLAPPED pOverlapped, LPCSTR szBoundary, DWORD dwFlags = 0) throw()
	{
		if ((pOverlapped == NULL) || (szBoundary == NULL))
		{
			return FALSE;
		}

		int nLineLength = 0;
		int nRequiredLength = 0;

		if (!GetEncodingInformation(&nRequiredLength, &nLineLength))
			return FALSE;

		//Try to open the file that is being attached
		CAtlFile readFile;
		if (FAILED(readFile.Create(m_szFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING)))
			return FALSE;

		//Make the mime header
		CStringA header;
		if (!MakeMimeHeader(header, szBoundary, m_szFileName))
		{
			return FALSE;
		}

		//Try to send the mime header
		if (!AtlSmtpSendAndWait(hFile, ((LPCSTR)header), header.GetLength(), pOverlapped))
		{
			return FALSE;
		}

		int nGetLines = ATLSMTP_GET_LINES;

		nRequiredLength *= nGetLines;

		//dwToGet is the total number of characters to attempt to get
		DWORD dwToGet = (DWORD)nGetLines*nLineLength;

		//allocate the data array
		CHeapPtr<BYTE> spData;
		if (!spData.Allocate(dwToGet+1))
			return FALSE;

// if double buffering is defined, create two buffers
#ifdef ATLSMTP_DOUBLE_BUFFERED
		CHeapPtr<char> buffer1;
		if (!buffer1.Allocate(nRequiredLength+3))
			return FALSE;

		CHeapPtr<char> buffer2;
		if (!buffer2.Allocate(nRequiredLength+3))
			return FALSE;

		char* currBuffer = buffer1;
		char* prevBuffer = NULL;
		int nCurrBuffer = 0;
		DWORD dwPrevLength = 0;
#else
		CHeapPtr<char> currBuffer;
		if (!currBuffer.Allocate(nRequiredLength+3))
			return FALSE;

#endif // ATLSMTP_DOUBLE_BUFFERED

		int nEncodedLength = nRequiredLength;
		BOOL bRet = FALSE;
		DWORD dwRead = 0;
		DWORD dwTotalRead = 0;
		DWORD dwCurrRead = 0;

		do
		{
			do 
			{
				//Read a chunk of data from the file increment buffer offsets and amount to read
				//based on what's already been read in this iteration of the loop
				HRESULT hr = readFile.Read(((LPBYTE)spData)+dwCurrRead, dwToGet-dwCurrRead, dwRead);
				if (FAILED(hr))
				{
					if (hr != AtlHresultFromWin32(ERROR_MORE_DATA))
					{
						return FALSE;
					}
				}
				dwCurrRead += dwRead;

			} while (dwRead != 0 && dwCurrRead < dwToGet);

			//reset nEncodedLength
			nEncodedLength = nRequiredLength;
			switch (m_nEncodingScheme)
			{
				case ATLSMTP_BASE64_ENCODE:
					//if we are at the end of input (dwCurrRead < dwToGet), output the trailing padding if necessary
					//(ATL_FLAG_NONE)
					bRet = Base64Encode(spData, dwCurrRead, currBuffer, &nEncodedLength, 
						(dwCurrRead < dwToGet ? ATL_BASE64_FLAG_NONE: ATL_BASE64_FLAG_NOPAD));
					//Base64Encoding needs explicit CRLF added
					if (dwCurrRead < dwToGet)
					{
						currBuffer[nEncodedLength++] = '\r';
						currBuffer[nEncodedLength++] = '\n';
					}
					break;
				case ATLSMTP_UUENCODE:
					//if we are at the beginning of the input, output the header (ATL_UUENCODE_HEADER)
					//if we are the end of input (dwCurrRead < dwToGet), output the 'end'
					//we are encoding for purposes of sending mail, so stuff dots (ATL_UUENCODE_DOT)
					bRet = UUEncode(spData, dwCurrRead, currBuffer, &nEncodedLength, m_szFileName,
									(dwTotalRead > 0 ? 0 : ATLSMTP_UUENCODE_HEADER) | 
									(dwCurrRead < dwToGet ? ATLSMTP_UUENCODE_END : 0) | 
									((dwFlags & ATLSMTP_FORMAT_SMTP) ? ATLSMTP_UUENCODE_DOT : 0));
					break;
				case ATLSMTP_QP_ENCODE:
					//we are encoding for purposes of sending mail, so stuff dots
					bRet = QPEncode(spData, dwCurrRead, currBuffer, &nEncodedLength, 
									((dwFlags & ATLSMTP_FORMAT_SMTP) ? ATLSMTP_QPENCODE_DOT : 0) |
									(dwCurrRead < dwToGet ? 0 : ATLSMTP_QPENCODE_TRAILING_SOFT));
					break;
			}
			//try to send the encoded data
#ifdef ATLSMTP_DOUBLE_BUFFERED
			if (bRet)
			{
				bRet = AtlSmtpSendOverlapped(hFile, currBuffer, nEncodedLength, 
					prevBuffer, dwPrevLength, pOverlapped);
			}

			//swap the buffers
			dwPrevLength = nEncodedLength;
			prevBuffer = currBuffer;
			currBuffer = (nCurrBuffer == 0 ? buffer2 : buffer1);
			nCurrBuffer = (nCurrBuffer == 0 ? 1 : 0);
#else
			if (bRet)
			{
				bRet = AtlSmtpSendAndWait(hFile, currBuffer, nEncodedLength, pOverlapped);
			}
#endif // ATLSMTP_DOUBLE_BUFFERED

			dwTotalRead += dwCurrRead;
			if (dwRead != 0)
				dwCurrRead = 0;

			nEncodedLength = nRequiredLength;

		} while (dwRead != 0 && bRet);

		//ensure that the last Send sent all the data
#ifdef ATLSMTP_DOUBLE_BUFFERED
		DWORD dwWritten = 0, dwErr = 0;
		if (!GetOverlappedResult(hFile, pOverlapped, &dwWritten, TRUE))
		{
			if ((dwErr = GetLastError()) != ERROR_IO_PENDING && dwErr != ERROR_IO_INCOMPLETE)
			{
				bRet = FALSE;
			}
			else if (dwWritten < dwPrevLength)
			{
				bRet = AtlSmtpSendAndWait(hFile, prevBuffer+dwWritten, 
					dwPrevLength-dwWritten, pOverlapped);
			}
		}
#endif // ATLSMTP_DOUBLE_BUFFERED

		//for uuencoding, if the last chunk read was of size dwToGet, but it was also the end of the file,
		//the "end" keyword will not get encoded, so a check is necessary
		if (m_nEncodingScheme == ATLSMTP_UUENCODE && dwCurrRead == dwToGet)
		{
			bRet = UUEncode(spData, 0, currBuffer, &nEncodedLength, m_szFileName, 
							(dwFlags & ATLSMTP_FORMAT_SMTP ? ATLSMTP_UUENCODE_DOT : 0) |
							ATLSMTP_UUENCODE_END);
			if (bRet)
			{
				bRet = AtlSmtpSendAndWait(hFile, currBuffer, nEncodedLength, pOverlapped);
			}
		}

		return bRet;
	}
}; // class CMimeFileAttachment

// CMimeRawAttachment represents a file attachment MIME body part.
// The data provided is not a file, but a blob of raw data.
class CMimeRawAttachment : public CMimeAttachment
{
protected:

	//the raw data
	void* m_pvRaw;

	//the length
	DWORD m_dwLength;

	//whether or not we own it
	bool  m_bShared;

public:
	CMimeRawAttachment() throw()
		:m_dwLength(0), m_bShared(false), m_pvRaw(NULL)
	{
	}

	~CMimeRawAttachment() throw()
	{
		//If we own the raw data, free it
		if (!m_bShared && m_pvRaw)
			free(m_pvRaw);
	}

	virtual ATL_NOINLINE CMimeBodyPart* Copy() throw( ... )
	{
		CAutoPtr<CMimeRawAttachment> pNewAttachment;
		ATLTRY(pNewAttachment.Attach(new CMimeRawAttachment));
		if (pNewAttachment)
			*pNewAttachment = *this;

		return pNewAttachment.Detach();
	}

	const CMimeRawAttachment& operator=(const CMimeRawAttachment& that) throw( ... )
	{
		if (this != &that)
		{
			CMimeAttachment::operator=(that);
			if (!m_bShared && m_pvRaw)
				free(m_pvRaw);

			m_bShared = that.m_bShared;
			m_dwLength = that.m_dwLength;

			if (m_bShared)
			{
				m_pvRaw = that.m_pvRaw;
			}
			else
			{
				m_pvRaw = malloc(m_dwLength);
				if (m_pvRaw)
				{
					Checked::memcpy_s(m_pvRaw, m_dwLength, that.m_pvRaw, m_dwLength);
				}
			}
		}

		return *this;
	}

	// Initialize the attachment
	// pData - the data
	// nDataLength - the size of pData in BYTEs
	// bCopyData - flag specifying whether CMimeRawAttachment should make a copy of the data (optional)
	// pMultiLanguage - the IMultiLanguage pointer for codepage to character set conversion (optional)
	// uiCodePage - the codepage (optional)
	inline BOOL Initialize(void* pData, DWORD nDataLength, BOOL bCopyData = TRUE, LPCTSTR szDisplayName = NULL, 
		IMultiLanguage* pMultiLanguage = NULL, UINT uiCodePage = 0) throw()
	{
		// if we're already attached to some data, and it's not shared, free it
		if (m_pvRaw && !m_bShared)
			free(m_pvRaw);
		m_pvRaw = NULL;

		m_dwLength = nDataLength;
		if (bCopyData)
		{
			m_pvRaw = calloc(sizeof(BYTE),m_dwLength);
			if (!m_pvRaw)
			{
				return FALSE;
			}
			Checked::memcpy_s(m_pvRaw, m_dwLength, pData, m_dwLength);
			m_bShared = false;
		}
		else
		{
			m_pvRaw = pData;
			m_bShared = true;
		}

		if (!AtlMimeCharsetFromCodePage(m_szCharset, uiCodePage, pMultiLanguage, ATL_MAX_ENC_CHARSET_LENGTH))
			return FALSE;

		if (szDisplayName)
		{
			// use the user-specified display name
			Checked::tcscpy_s(m_szDisplayName, _countof(m_szDisplayName), szDisplayName);
			m_szDisplayName[_countof(m_szDisplayName)-1] = 0;
		}
		else
		{
			// no display name
			*m_szDisplayName = '\0';
		}
		return TRUE;
	}

	// Output the data--similar to CFileAttachment::WriteData
	// See CFileAttachment::WriteData for comments
	virtual inline BOOL WriteData(HANDLE hFile, LPOVERLAPPED pOverlapped, LPCSTR szBoundary, DWORD dwFlags = 0) throw()
	{
		if ((pOverlapped == NULL) || (szBoundary == NULL))
		{
			return FALSE;
		}

		if (!m_pvRaw)
			return FALSE;

		int nLineLength = 0, nRequiredLength = 0;
		if (!GetEncodingInformation(&nRequiredLength, &nLineLength))
			return FALSE;

		CStringA header;

		if (!MakeMimeHeader(header, szBoundary))
		{
			return FALSE;
		}

		if (!AtlSmtpSendAndWait(hFile, ((LPCSTR)header), header.GetLength(), pOverlapped))
		{
			return FALSE;
		}

		int nGetLines = ATLSMTP_GET_LINES;
		DWORD dwCurrChunk = 0;
		nRequiredLength *= nGetLines;
		DWORD dwToGet = (DWORD)nGetLines*nLineLength;
		int nDestLen = nRequiredLength;
		BOOL bRet = FALSE;
		DWORD dwRead = 0;
#ifdef ATLSMTP_DOUBLE_BUFFERED
		CHeapPtr<char> buffer1;
		if (!buffer1.Allocate(nRequiredLength+3))
			return FALSE;

		CHeapPtr<char> buffer2;
		if (!buffer2.Allocate(nRequiredLength+3))
			return FALSE;

		char* currBuffer = buffer1;
		char* prevBuffer = NULL;
		int nCurrBuffer = 0;
		DWORD dwPrevLength = 0;
#else
		CHeapPtr<char> currBuffer;
		if (!currBuffer.Allocate(nRequiredLength+3))
			return FALSE;
#endif // ATLSMTP_DOUBLE_BUFFERED

		do 
		{
			if ((m_dwLength-dwRead) <= dwToGet)
				dwCurrChunk = m_dwLength-dwRead;
			else
				dwCurrChunk = dwToGet;
			switch(m_nEncodingScheme)
			{
				case ATLSMTP_BASE64_ENCODE:
					bRet = Base64Encode(((LPBYTE)(m_pvRaw))+dwRead, dwCurrChunk, currBuffer, &nDestLen, 
						(dwRead < m_dwLength) ? ATL_BASE64_FLAG_NONE : ATL_BASE64_FLAG_NOPAD);
					if (dwRead+dwCurrChunk == m_dwLength)
					{
						currBuffer[nDestLen++] = '\r';
						currBuffer[nDestLen++] = '\n';
					}
					break;
				case ATLSMTP_UUENCODE:
					bRet = UUEncode(((LPBYTE)(m_pvRaw))+dwRead, dwCurrChunk, currBuffer, &nDestLen, _T("rawdata"), 
									(dwRead > 0 ? 0 : ATLSMTP_UUENCODE_HEADER) | 
									(dwRead+dwCurrChunk == m_dwLength ? ATLSMTP_UUENCODE_END : 0) | 
									((dwFlags & ATLSMTP_FORMAT_SMTP) ? ATLSMTP_UUENCODE_DOT : 0));
					break;
				case ATLSMTP_QP_ENCODE:
					bRet = QPEncode(((LPBYTE)(m_pvRaw))+dwRead, dwCurrChunk, currBuffer, &nDestLen, 
									((dwFlags & ATLSMTP_FORMAT_SMTP) ? ATLSMTP_QPENCODE_DOT : 0) | 
									(dwRead+dwCurrChunk == m_dwLength ? 0 : ATLSMTP_QPENCODE_TRAILING_SOFT));
					break;
			}
			if (!bRet)
				break;
#ifdef ATLSMTP_DOUBLE_BUFFERED
			bRet = AtlSmtpSendOverlapped(hFile, currBuffer, nDestLen, prevBuffer, dwPrevLength, pOverlapped);
			dwPrevLength = (DWORD)nDestLen;
			prevBuffer = currBuffer;
			currBuffer = (nCurrBuffer == 0 ? buffer2 : buffer1);
			nCurrBuffer = (nCurrBuffer == 0 ? 1 : 0);
#else
			bRet = AtlSmtpSendAndWait(hFile, currBuffer, nDestLen, pOverlapped);
#endif // ATLSMTP_DOUBLE_BUFFERED

			nDestLen = nRequiredLength;
			dwRead += dwCurrChunk;
		} while (bRet && (dwRead < m_dwLength));

		//ensure all data is sent from prevBuffer
#ifdef ATLSMTP_DOUBLE_BUFFERED
		DWORD dwWritten = 0, dwErr = 0;
		if (!GetOverlappedResult(hFile, pOverlapped, &dwWritten, TRUE))
		{
			if ((dwErr = GetLastError()) != ERROR_IO_PENDING && dwErr != ERROR_IO_INCOMPLETE)
				bRet = FALSE;
			else if (dwWritten < dwPrevLength)
				bRet = AtlSmtpSendAndWait(hFile, prevBuffer+dwWritten, dwPrevLength-dwWritten, pOverlapped);
		}
#endif // ATLSMTP_DOUBLE_BUFFERED

		return bRet;
	}
}; // class CMimeRawAttachment


// CMimeText - represents a text body part in MIME body
class CMimeText : public CMimeBodyPart
{
protected:

	// the text
	CHeapPtr<char> m_szText;

	// the character set
	char     m_szCharset[ATL_MAX_ENC_CHARSET_LENGTH];

	// the text length
	int      m_nTextLen;

public:
	CMimeText() throw()
		:m_nTextLen(0)
	{
		Checked::strcpy_s(m_szCharset, ATL_MAX_ENC_CHARSET_LENGTH, ATLSMTP_DEFAULT_CSET);
	}

	virtual ~CMimeText() throw()
	{
	}

	// Get the content type
	virtual inline LPCSTR GetContentType() throw()
	{
		return "text/plain";
	}

	// Get the character set
	virtual inline LPCSTR GetCharset() throw()
	{
		return m_szCharset;
	}

	virtual ATL_NOINLINE CMimeBodyPart* Copy() throw( ... )
	{
		CAutoPtr<CMimeText> pNewText;
		ATLTRY(pNewText.Attach(new CMimeText));
		if (pNewText)
			*pNewText = *this;

		return pNewText.Detach();
	}

	const CMimeText& operator=(const CMimeText& that) throw( ... )
	{
		if (this != &that)
		{
			m_nTextLen = that.m_nTextLen;
			Checked::strcpy_s(m_szCharset, ATL_MAX_ENC_CHARSET_LENGTH, that.m_szCharset);
			m_szText.Free();
			if (m_szText.AllocateBytes(m_nTextLen) != false)
			{
				Checked::memcpy_s((char *)m_szText, m_nTextLen, (char *)that.m_szText, m_nTextLen);
			}
		}

		return *this;
	}

	// Initialize the body part
	// szText - the text (required)
	// nTextLen - the text length in bytes (optional--if not specified a _tcslen will be done)
	// pMultiLanguage - the IMultiLanguagte pointer for converting codepages to MIME character sets (optional)
	// uiCodePage - the codepage
	inline BOOL Initialize(LPCTSTR szText, int nTextLen = -1, IMultiLanguage* pMultiLanguage = NULL, UINT uiCodePage = 0) throw()
	{
		BOOL bRet = TRUE;

		// if IMultiLanguage is there, respect the codepage
		if (pMultiLanguage)
		{
			CHeapPtr<char> szTextPtr;
			UINT nLen(0);

			bRet = AtlMimeConvertString(pMultiLanguage, uiCodePage, szText, &szTextPtr, &nLen);
			if (bRet)
			{
				m_szText.Free();
				m_szText.Attach(szTextPtr.Detach());
				m_nTextLen = nLen;
			}
		}
		else // no multilanguage support
		{
			if (nTextLen < 0)
			{
				nTextLen = (int) _tcslen(szText);
				nTextLen*= sizeof(TCHAR);
			}

			m_szText.Free();
			if (m_szText.AllocateBytes(nTextLen) != false)
			{
				Checked::memcpy_s((char *)m_szText, nTextLen, szText, nTextLen);
				m_nTextLen = nTextLen;
			}
		}

		if (bRet)
		{
			bRet = AtlMimeCharsetFromCodePage(m_szCharset, uiCodePage, pMultiLanguage, ATL_MAX_ENC_CHARSET_LENGTH);
		}

		return bRet;
	}

	// Dump the data to hFile
	virtual inline BOOL WriteData(HANDLE hFile, LPOVERLAPPED pOverlapped, LPCSTR szBoundary, DWORD dwFlags = 0) throw()
	{
		if ((pOverlapped == NULL) || (szBoundary == NULL))
		{
			return FALSE;
		}

		CStringA strHeader;
		char sendBuffer[ATLSMTP_READBUFFER_SIZE];
		LPSTR pSendBuffer = sendBuffer;
		LPSTR szText = m_szText;

		if (!MakeMimeHeader(strHeader, szBoundary))
		{
			return FALSE;
		}

		//copy the header into the sendbuffer
		int nWritten = strHeader.GetLength();
		if(nWritten > ATLSMTP_READBUFFER_SIZE)
			return FALSE;
			
		Checked::memcpy_s(pSendBuffer, ATLSMTP_READBUFFER_SIZE, (LPCSTR)strHeader, nWritten);
		pSendBuffer+= nWritten;
		int nRead = 0;
		int nLineLen = 0;

		//subtract 2 from these because it's easier for when we have
		//to break lines with a CRLF
		int nMaxLineLength = ATLSMTP_MAX_LINE_LENGTH-2;
		int nMaxBufferSize = ATLSMTP_READBUFFER_SIZE-2;
		while (nRead <= m_nTextLen)
		{
			//if the buffer is full or we've reached the end of the text, 
			//send it
			if (nWritten >= nMaxBufferSize || nRead == m_nTextLen)
			{
				if (!AtlSmtpSendAndWait(hFile, sendBuffer, nWritten, pOverlapped))
					return FALSE;
				nWritten = 0;
				pSendBuffer = sendBuffer;
			}

			//if we're at the end of the line, break it
			if (nLineLen == nMaxLineLength)
			{
				if(nWritten + 2 > ATLSMTP_READBUFFER_SIZE)
					return FALSE;
				*pSendBuffer++ = '\r';
				*pSendBuffer++ = '\n';
				nWritten+= 2;
				nLineLen = -1;
				continue;
			}

			//stuff dots at the start of the line
			if (nLineLen == 0 && (dwFlags & ATLSMTP_FORMAT_SMTP) && *szText == '.')
			{
				if(nWritten + 1 > ATLSMTP_READBUFFER_SIZE)
					return FALSE;
				*pSendBuffer++ = '.';
				nWritten++;
				nLineLen++;
				continue;
			}

			//if we hit a CRLF, reset nLineLen
			if (*szText == '\n' && nRead > 0 && *(szText-1) == '\r')
				nLineLen = -1;

			if(nWritten + 1 > ATLSMTP_READBUFFER_SIZE)
				return FALSE;
			*pSendBuffer++ = (*szText++);
			nRead++;
			nWritten++;
			nLineLen++;
		}

		return TRUE;
	}

protected:

	// Make the MIME header
	virtual inline BOOL MakeMimeHeader(CStringA& header, LPCSTR szBoundary) throw()
	{
		char szBegin[256];
		if (*szBoundary)
		{
			// this is not the only body part
			Checked::memcpy_s(szBegin, sizeof(szBegin), ATLMIME_SEPARATOR, sizeof(ATLMIME_SEPARATOR));
			Checked::memcpy_s(szBegin+6, sizeof(szBegin)-6, szBoundary, ATL_MIME_BOUNDARYLEN);
			*(szBegin+(ATL_MIME_BOUNDARYLEN+6)) = '\0';
		}
		else
		{
			// this is the only body part, so output the full MIME header
			Checked::memcpy_s(szBegin, sizeof(szBegin), ATLMIME_VERSION, sizeof(ATLMIME_VERSION));
		}

		_ATLTRY
		{
			header.Format("%s\r\nContent-Type: text/plain;\r\n\tcharset=\"%s\"\r\nContent-Transfer-Encoding: 8bit\r\n\r\n", 
				szBegin, m_szCharset);
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}
}; // class CMimeText


// CMimeMessage - the MIME message class.  Represents a full MIME message
class CMimeMessage : public CMimeHeader
{
protected:

	// The list of the MIME body parts
	CAutoPtrList<CMimeBodyPart> m_BodyParts;

	// The display name of the message
	char m_szDisplayName[MAX_PATH+1];

public:
	CMimeMessage(IMultiLanguage *pMultiLanguage = NULL) throw()
	{
		Initialize(pMultiLanguage);
		Checked::memcpy_s(m_szDisplayName, MAX_PATH+1, ATLMIME_EMAIL, sizeof(ATLMIME_EMAIL));
	}

	virtual ~CMimeMessage() throw()
	{
		RemoveParts();
	}

	void RemoveParts() throw()
	{
		m_BodyParts.RemoveAll();
	}


	virtual ATL_NOINLINE CMimeBodyPart* Copy() throw( ... )
	{
		CAutoPtr<CMimeMessage> pNewMessage;
		ATLTRY(pNewMessage.Attach(new CMimeMessage));
		if (pNewMessage)
			*pNewMessage = *this;

		return pNewMessage.Detach();
	}


	const CMimeMessage& operator=(const CMimeMessage& that) throw( ... )
	{
		if (this != &that)
		{
			CMimeHeader::operator=(that);
			Checked::strcpy_s(m_szDisplayName, MAX_PATH+1, that.m_szDisplayName);

			RemoveParts();
			POSITION pos = that.m_BodyParts.GetHeadPosition();
			while (pos != NULL)
			{
				CAutoPtr<CMimeBodyPart> pCopy(that.m_BodyParts.GetNext(pos)->Copy());
				if (pCopy)
				{
					m_BodyParts.AddTail(pCopy);
				}
			}
		}

		return *this;
	}

	// Set the display name of the message
	inline BOOL SetDisplayName(LPCTSTR szDisplayName) throw()
	{
		if (szDisplayName == NULL)
		{
			return FALSE;
		}

		_ATLTRY
		{
			CT2CA szDisplayNameA(szDisplayName);
		 	if (szDisplayNameA == NULL || strlen(szDisplayNameA) > MAX_PATH)
		 		return FALSE;
			Checked::strcpy_s(m_szDisplayName, MAX_PATH+1, szDisplayNameA);
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Add some text to the message at position nPos in the body parts list
	// szText - the text
	// nTextLen - the size of the text in bytes (optional - if not specified a _tcslen will be done)
	// nPos - the position in the message at which to insert the text (optional)
	// uiCodePage - the codepage (optional)
	inline BOOL AddText(LPCTSTR szText, int nTextLen = -1, int nPos = 1, UINT uiCodePage = 0) throw()
	{
		if (szText == NULL)
			return FALSE;

		if (nPos < 1)
		{
			nPos = 1;
		}

		CAutoPtr<CMimeBodyPart> spNewText;
		CMimeText *pNewText = NULL;
		ATLTRY(spNewText.Attach(pNewText = new CMimeText()));
		if (!spNewText || !pNewText)
			return FALSE;

		BOOL bRet = pNewText->Initialize(szText, nTextLen, m_spMultiLanguage, uiCodePage);
		if (bRet)
		{
			_ATLTRY
			{
				POSITION currPos = m_BodyParts.FindIndex(nPos-1);

					if (!currPos)
					{
						if (!m_BodyParts.AddTail(spNewText))
							bRet = FALSE;
					}
					else
					{
						if (!m_BodyParts.InsertBefore(currPos, spNewText))
							bRet = FALSE;
					}

			}
			_ATLCATCHALL()
			{
				bRet = FALSE;
			}
		}

		return bRet;
	}

	// Dump the data
	virtual BOOL WriteData(HANDLE hFile, LPOVERLAPPED pOverlapped, LPCSTR szBoundary=NULL, DWORD dwFlags = 0) throw()
	{	
		if (pOverlapped == NULL)
		{
			return FALSE;
		}

		// Make the MIME boundary for this message
		char szBoundaryBuf[ATL_MIME_BOUNDARYLEN+1];
		if(MakeBoundary(szBoundaryBuf,ATL_MIME_BOUNDARYLEN+1) == FALSE)
			return FALSE;

		// if the passed boundary is valid, this is an attached message
		if (szBoundary && *szBoundary != '\0')
		{
			_ATLTRY
			{
				// output the MIME header for a message attachment
				CStringA strHeader;
				strHeader.Format("\r\n\r\n--%s\r\nContent-Type: message/rfc822\r\n\tname=\"%s\"\r\nContent-Transfer-Encoding: 8bit\r\n"
					"Content-Disposition: attachment;\r\n\tfilename=\"%s\"\r\n\r\n", 
					szBoundary, m_szDisplayName, m_szDisplayName);

				if (!AtlSmtpSendAndWait(hFile, ((LPCSTR)strHeader), strHeader.GetLength(), pOverlapped))
				{
					return FALSE;
				}
			}
			_ATLCATCHALL()
			{
				return FALSE;
			}
		}

		if (!CMimeHeader::WriteData(hFile, pOverlapped, szBoundaryBuf, dwFlags))
			return FALSE;

		// Create and output the header
		CStringA strHeader;

		if (!MakeMimeHeader(strHeader, szBoundaryBuf))
		{
			return FALSE;
		}

		if (!AtlSmtpSendAndWait(hFile, ((LPCSTR)strHeader), strHeader.GetLength(), pOverlapped))
		{
			return FALSE;
		}

		CMimeBodyPart* pCurrPart;
		POSITION currPos = m_BodyParts.GetHeadPosition();

		//Dump the body parts
		while (currPos != NULL)
		{
			pCurrPart = m_BodyParts.GetAt(currPos);
			if (!pCurrPart->WriteData(hFile, pOverlapped, szBoundaryBuf, dwFlags))
			{
				return FALSE;
			}
			m_BodyParts.GetNext(currPos);
		}

		char szBuf[ATL_MIME_BOUNDARYLEN+(sizeof("\r\n\r\n--%s--\r\n"))];
		//output a trailing boundary
		if (*szBoundaryBuf)
		{
#if _SECURE_ATL
			int nBufLen = sprintf_s(szBuf, ATL_MIME_BOUNDARYLEN+(sizeof("\r\n\r\n--%s--\r\n")),
				"\r\n\r\n--%s--\r\n", szBoundaryBuf);
#else
			int nBufLen = _snprintf(szBuf, ATL_MIME_BOUNDARYLEN+(sizeof("\r\n\r\n--%s--\r\n")),
				"\r\n\r\n--%s--\r\n", szBoundaryBuf);
#endif
			if ((nBufLen < 0) || (!AtlSmtpSendAndWait(hFile, szBuf, nBufLen, pOverlapped)))
			{
				return FALSE;
			}
		}

		return TRUE;
	}

	// Attach a file.
	// szFileName - the filename
	// szDisplayName - the display name (optional)
	// szContentType - the content type (optional - defaults to NULL -- lookup will be attempted, otherwise default to application/octet-stream)
	// nEncodingScheme - the encoding scheme to use for the attachment (optional - defaults to base64
	// uiCodePage - the codepage (optional)
	inline BOOL AttachFile(LPCTSTR szFileName, LPCTSTR szDisplayName = NULL, LPCTSTR szContentType = NULL, 
		int nEncodingScheme = ATLSMTP_BASE64_ENCODE, UINT uiCodepage = 0)
	{
		if (szFileName == NULL)
			return FALSE;

		CAutoPtr<CMimeBodyPart> spFileAttach;
		CMimeFileAttachment* pFileAttach = NULL;
		ATLTRY(spFileAttach.Attach(pFileAttach = new CMimeFileAttachment()));
		if (!spFileAttach || !pFileAttach)
			return FALSE;

		BOOL bRet = pFileAttach->Initialize(szFileName, szDisplayName, m_spMultiLanguage, uiCodepage);

		if (bRet)
			bRet = pFileAttach->SetEncodingScheme(nEncodingScheme);

		CString strContentType;
		if (bRet && (szContentType == NULL))
		{
			if (GetContentTypeFromFileName(szFileName, strContentType) != ERROR_OUTOFMEMORY)
			{
				szContentType = strContentType;
			}
			else
			{
				bRet = FALSE;
			}
		}

		_ATLTRY
		{
			if (bRet)
			{
				bRet = pFileAttach->SetContentType(szContentType);
				if (bRet)
				{
					if (!m_BodyParts.AddTail(spFileAttach))
					{
						bRet = FALSE;
					}
				}
			}
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}

		return bRet;
	}

	// Attach some raw data
	// pRawData - the data
	// nDataLength - the size of the data in bytes
	// nEncodingScheme - the encoding scheme to use for the attachment (optional - defaults to base64
	// uiCodePage - the codepage (optional)
	inline BOOL AttachRaw(void* pRawData, DWORD dwDataLength, int nEncodingScheme = ATLSMTP_BASE64_ENCODE, BOOL bCopyData = TRUE, 
		LPCTSTR szDisplayName = NULL, LPCTSTR szContentType = _T("application/octet-stream"), UINT uiCodepage = 0)
	{
		if (!pRawData)
			return FALSE;

		CAutoPtr<CMimeBodyPart> spRawAttach;
		CMimeRawAttachment* pRawAttach;
		ATLTRY(spRawAttach.Attach(pRawAttach = new CMimeRawAttachment()));
		if (!spRawAttach)
		{
			return FALSE;
		}

		BOOL bRet = pRawAttach->Initialize(pRawData, dwDataLength, bCopyData, szDisplayName, m_spMultiLanguage, uiCodepage);

		if (bRet)
			bRet = pRawAttach->SetEncodingScheme(nEncodingScheme);
		if (bRet)
			bRet = pRawAttach->SetContentType(szContentType);

		_ATLTRY
		{
		if (bRet)
			if(!m_BodyParts.AddTail(spRawAttach))
				bRet = FALSE;
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}

		return bRet;
	}

	// Attach a CMimeMessage
	// pMsg - pointer to the Msg object
	inline BOOL AttachMessage(CMimeMessage* pMsg) throw( ... )
	{
		if (!pMsg)
			return FALSE;

		_ATLTRY
		{
			CAutoPtr<CMimeBodyPart> spMsg(pMsg->Copy());
			if (!m_BodyParts.AddTail(spMsg))
				return FALSE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}

		return TRUE;
	}

protected:
	// Make the MIME header
	virtual inline BOOL MakeMimeHeader(CStringA& header, LPCSTR szBoundary) throw()
	{
		_ATLTRY
		{
			if (!*szBoundary)
			{
				header.Format("X-Priority: %d\r\n%s", m_nPriority, (LPCSTR) m_XHeader);
			}
			else if (m_BodyParts.GetCount() > 1)
			{
				header.Format("X-Priority: %d\r\n%sMIME-Version: 1.0\r\nContent-Type: multipart/mixed;\r\n\tboundary=\"%s\"\r\n", 
					m_nPriority, (LPCSTR) m_XHeader, szBoundary);
			}
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	// Make the MIME boundary
	inline BOOL MakeBoundary(__out_ecount_z(nBufLen) LPSTR szBoundary, __in int nBufLen)
	{
		ATLENSURE(szBoundary != NULL);
			
		if(nBufLen < 1)
		{
			return FALSE;
		}

		if (m_BodyParts.GetCount() < 2)
		{
			*szBoundary = '\0';
		}
		else 
		{
#if _SECURE_ATL
			int ret = sprintf_s(szBoundary, nBufLen, "------=_Next_Part_%.10u.%.3u", GetTickCount(), rand()%1000); 
#else
			int ret = _snprintf(szBoundary, nBufLen, "------=_Next_Part_%.10u.%.3u", GetTickCount(), rand()%1000);
#endif
			if (ret == -1 || ret >= nBufLen)
				return FALSE;
		}
		return TRUE;
	}

}; // class CMimeMessage

} // namespace ATL
#pragma pack(pop)

#ifndef _CPPUNWIND
#pragma warning (pop)
#endif //_CPPUNWIND

#pragma warning(pop)

#endif // __ATLMIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlpath.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLPATH_H__
#define __ATLPATH_H__

#pragma once

#ifdef _WIN32_WCE
	#error atlpath.h is not supported on Windows CE (_WIN32_WCE is defined)
#endif //_WIN32_WCE

#ifdef _AFX
#include <afxstr.h>
#else
#include <atlstr.h>
#endif

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "shlwapi.lib")
#endif  // !_ATL_NO_DEFAULT_LIBS


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

namespace ATLPath
{

inline char* AddBackslash( __inout char* pszPath )
{
	return ::PathAddBackslashA( pszPath );
}

inline wchar_t* AddBackslash( __inout wchar_t* pszPath )
{
	return ::PathAddBackslashW( pszPath );
}

inline BOOL AddExtension( __inout char* pszPath, __in const char* pszExtension )
{
	return ::PathAddExtensionA( pszPath, pszExtension );
}

inline BOOL AddExtension( __inout wchar_t* pszPath, __in const wchar_t* pszExtension )
{
	return ::PathAddExtensionW( pszPath, pszExtension );
}

inline BOOL Append( __inout char* pszPath, __in const char* pszMore )
{
	return ::PathAppendA( pszPath, pszMore );
}

inline BOOL Append( __inout wchar_t* pszPath, __in const wchar_t* pszMore )
{
	return ::PathAppendW( pszPath, pszMore );
}

inline char* BuildRoot( __out_ecount(4) char* pszPath, __in int iDrive )
{
	return ::PathBuildRootA( pszPath, iDrive );
}

inline wchar_t* BuildRoot( __out_ecount(4) wchar_t* pszPath, __in int iDrive )
{
	return ::PathBuildRootW( pszPath, iDrive );
}

inline BOOL Canonicalize( __out char* pszDest, __in const char* pszSrc )
{
	return ::PathCanonicalizeA( pszDest, pszSrc );
}

inline BOOL Canonicalize( __out wchar_t* pszDest, __in const wchar_t* pszSrc )
{
	return ::PathCanonicalizeW( pszDest, pszSrc );
}

inline char* Combine( __out char* pszDest, __in const char* pszDir,
	__in const char* pszFile )
{
	return ::PathCombineA( pszDest, pszDir, pszFile );
}

inline wchar_t* Combine( __out wchar_t* pszDest, __in const wchar_t* pszDir,
	__in const wchar_t* pszFile )
{
	return ::PathCombineW( pszDest, pszDir, pszFile );
}

inline int CommonPrefix( __in const char* pszFile1, __in const char* pszFile2,
	__out char* pszDest )
{
	return ::PathCommonPrefixA( pszFile1, pszFile2, pszDest );
}

inline int CommonPrefix( __in const wchar_t* pszFile1, __in const wchar_t* pszFile2,
	__out wchar_t* pszDest )
{
	return ::PathCommonPrefixW( pszFile1, pszFile2, pszDest );
}

inline BOOL FileExists( __in const char* pszPath )
{
	return ::PathFileExistsA( pszPath );
}

inline BOOL FileExists( __in const wchar_t* pszPath )
{
	return ::PathFileExistsW( pszPath );
}

inline char* FindExtension( __in const char* pszPath )
{
	return ::PathFindExtensionA( pszPath );
}

inline wchar_t* FindExtension( __in const wchar_t* pszPath )
{
	return ::PathFindExtensionW( pszPath );
}

inline char* FindFileName( __in const char* pszPath )
{
	return ::PathFindFileNameA( pszPath );
}

inline wchar_t* FindFileName( __in const wchar_t* pszPath )
{
	return ::PathFindFileNameW( pszPath );
}

inline int GetDriveNumber( __in const char* pszPath )
{
	return ::PathGetDriveNumberA( pszPath );
}

inline int GetDriveNumber( __in const wchar_t* pszPath )
{
	return ::PathGetDriveNumberW( pszPath );
}

inline BOOL IsDirectory( __in const char* pszPath )
{
	return ::PathIsDirectoryA( pszPath );
}

inline BOOL IsDirectory( __in const wchar_t* pszPath )
{
	return ::PathIsDirectoryW( pszPath );
}

inline BOOL IsFileSpec( __in const char* pszPath )
{
	return ::PathIsFileSpecA( pszPath );
}

inline BOOL IsFileSpec( __in const wchar_t* pszPath )
{
	return ::PathIsFileSpecW( pszPath );
}

inline BOOL IsPrefix( __in const char* pszPrefix, __in const char* pszPath )
{
	return ::PathIsPrefixA( pszPrefix, pszPath );
}

inline BOOL IsPrefix( __in const wchar_t* pszPrefix, __in const wchar_t* pszPath )
{
	return ::PathIsPrefixW( pszPrefix, pszPath );
}

inline BOOL IsRelative( __in const char* pszPath )
{
	return ::PathIsRelativeA( pszPath );
}

inline BOOL IsRelative( __in const wchar_t* pszPath )
{
	return ::PathIsRelativeW( pszPath );
}

inline BOOL IsRoot( __in const char* pszPath )
{
	return ::PathIsRootA( pszPath );
}

inline BOOL IsRoot( __in const wchar_t* pszPath )
{
	return ::PathIsRootW( pszPath );
}

inline BOOL IsSameRoot( __in const char* pszPath1, __in const char* pszPath2 )
{
	return ::PathIsSameRootA( pszPath1, pszPath2 );
}

inline BOOL IsSameRoot( __in const wchar_t* pszPath1, __in const wchar_t* pszPath2 )
{
	return ::PathIsSameRootW( pszPath1, pszPath2 );
}

inline BOOL IsUNC( __in const char* pszPath )
{
	return ::PathIsUNCA( pszPath );
}

inline BOOL IsUNC( __in const wchar_t* pszPath )
{
	return ::PathIsUNCW( pszPath );
}

inline BOOL IsUNCServer( __in const char* pszPath )
{
	return ::PathIsUNCServerA( pszPath );
}

inline BOOL IsUNCServer( __in const wchar_t* pszPath )
{
	return ::PathIsUNCServerW( pszPath );
}

inline BOOL IsUNCServerShare( __in const char* pszPath )
{
	return ::PathIsUNCServerShareA( pszPath );
}

inline BOOL IsUNCServerShare( __in const wchar_t* pszPath )
{
	return ::PathIsUNCServerShareW( pszPath );
}

inline BOOL MakePretty( __inout char* pszPath )
{
	return ::PathMakePrettyA( pszPath );
}

inline BOOL MakePretty( __inout wchar_t* pszPath )
{
	return ::PathMakePrettyW( pszPath );
}

inline BOOL MatchSpec( __in const char* pszPath, __in const char* pszSpec )
{
	return ::PathMatchSpecA( pszPath, pszSpec );
}

inline BOOL MatchSpec( __in const wchar_t* pszPath, __in const wchar_t* pszSpec )
{
	return ::PathMatchSpecW( pszPath, pszSpec );
}

inline void QuoteSpaces( __inout char* pszPath )
{
	::PathQuoteSpacesA( pszPath );
}

inline void QuoteSpaces( __inout wchar_t* pszPath )
{
	::PathQuoteSpacesW( pszPath );
}

inline BOOL RelativePathTo( __out char* pszPath, __in const char* pszFrom,
	__in DWORD dwAttrFrom, __in const char* pszTo, __in DWORD dwAttrTo )
{
	return ::PathRelativePathToA( pszPath, pszFrom, dwAttrFrom, pszTo, dwAttrTo );
}

inline BOOL RelativePathTo( __out wchar_t* pszPath, __in const wchar_t* pszFrom,
	__in DWORD dwAttrFrom, __in const wchar_t* pszTo, __in DWORD dwAttrTo )
{
	return ::PathRelativePathToW( pszPath, pszFrom, dwAttrFrom, pszTo, dwAttrTo );
}

inline void RemoveArgs( __inout char* pszPath )
{
	::PathRemoveArgsA( pszPath );
}

inline void RemoveArgs( __inout wchar_t* pszPath )
{
	::PathRemoveArgsW( pszPath );
}

inline char* RemoveBackslash( __inout char* pszPath )
{
	return ::PathRemoveBackslashA( pszPath );
}

inline wchar_t* RemoveBackslash( __inout wchar_t* pszPath )
{
	return ::PathRemoveBackslashW( pszPath );
}

inline void RemoveBlanks( __inout char* pszPath )
{
	::PathRemoveBlanksA( pszPath );
}

inline void RemoveBlanks( __inout wchar_t* pszPath )
{
	::PathRemoveBlanksW( pszPath );
}

inline void RemoveExtension( __inout char* pszPath )
{
	::PathRemoveExtensionA( pszPath );
}

inline void RemoveExtension( __inout wchar_t* pszPath )
{
	::PathRemoveExtensionW( pszPath );
}

inline BOOL RemoveFileSpec( __inout char* pszPath )
{
	return ::PathRemoveFileSpecA( pszPath );
}

inline BOOL RemoveFileSpec( __inout wchar_t* pszPath )
{
	return ::PathRemoveFileSpecW( pszPath );
}

inline BOOL RenameExtension( __inout char* pszPath, __in const char* pszExt )
{
	return ::PathRenameExtensionA( pszPath, pszExt );
}

inline BOOL RenameExtension( __inout wchar_t* pszPath, __in const wchar_t* pszExt )
{
	return ::PathRenameExtensionW( pszPath, pszExt );
}

inline char* SkipRoot( __in const char* pszPath )
{
	return ::PathSkipRootA( pszPath );
}

inline wchar_t* SkipRoot( __in const wchar_t* pszPath )
{
	return ::PathSkipRootW( pszPath );
}

inline void StripPath( __inout char* pszPath )
{
	::PathStripPathA( pszPath );
}

inline void StripPath( __inout wchar_t* pszPath )
{
	::PathStripPathW( pszPath );
}

inline BOOL StripToRoot( __inout char* pszPath )
{
	return ::PathStripToRootA( pszPath );
}

inline BOOL StripToRoot( __inout wchar_t* pszPath )
{
	return ::PathStripToRootW( pszPath );
}

inline void UnquoteSpaces( __inout char* pszPath )
{
	::PathUnquoteSpacesA( pszPath );
}

inline void UnquoteSpaces( __inout wchar_t* pszPath )
{
	::PathUnquoteSpacesW( pszPath );
}

inline BOOL CompactPath( __in HDC hDC, __inout char* pszPath, __in UINT dx )
{
	return ::PathCompactPathA( hDC, pszPath, dx );
}

inline BOOL CompactPath( __in HDC hDC, __inout wchar_t* pszPath, __in UINT dx )
{
	return ::PathCompactPathW( hDC, pszPath, dx );
}

inline BOOL CompactPathEx( __out_ecount(nMaxChars) char* pszDest, __in const char* pszSrc,
	__in UINT nMaxChars, __in DWORD dwFlags )
{
	return ::PathCompactPathExA( pszDest, pszSrc, nMaxChars, dwFlags );
}

inline BOOL CompactPathEx( __out_ecount(nMaxChars) wchar_t* pszDest, __in const wchar_t* pszSrc,
	__in UINT nMaxChars, __in DWORD dwFlags )
{
	return ::PathCompactPathExW( pszDest, pszSrc, nMaxChars, dwFlags );
}

};  // namespace ATLPath

template< typename StringType >
class CPathT
{
public:
	typedef typename StringType::XCHAR XCHAR;
	typedef typename StringType::PCXSTR PCXSTR;
	typedef typename StringType::PXSTR PXSTR;

public:
	CPathT() throw()
	{
	}
	CPathT( const CPathT< StringType >& path ) :
		m_strPath( path.m_strPath )
	{
	}
	CPathT( PCXSTR pszPath ) :
		m_strPath( pszPath )
	{
	}

	operator const StringType& () const throw()
	{
		return m_strPath;
	}
	operator StringType& () throw()
	{
		return m_strPath;
	}
	operator PCXSTR() const throw()
	{
		return m_strPath;
	}
	CPathT< StringType >& operator+=( __in PCXSTR pszMore )
	{
		Append( pszMore );

		return *this;
	}

	void AddBackslash()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength()+1 );
		ATLPath::AddBackslash( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	BOOL AddExtension( __in PCXSTR pszExtension )
	{
		PXSTR pszBuffer;
		BOOL bResult;

		// If NULL is passed, shlwapi's PathAddExtension API adds ".EXE"
		int nLenExtension = (pszExtension == NULL) ? 4 : StringType::StringLength(pszExtension);
		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength()+nLenExtension);
		bResult = ATLPath::AddExtension( pszBuffer, pszExtension );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	BOOL Append( __in PCXSTR pszMore )
	{
		PXSTR pszBuffer;
		BOOL bResult;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength()+StringType::StringLength( pszMore )+1 );
		bResult = ATLPath::Append( pszBuffer, pszMore );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	void BuildRoot( __in int iDrive )
	{
		PXSTR pszBuffer;

		ATLASSERT( iDrive >= 0 );
		ATLASSERT( iDrive <= 25 );

		pszBuffer = m_strPath.GetBuffer( 3 );
		ATLPath::BuildRoot( pszBuffer, iDrive );
		m_strPath.ReleaseBuffer();
	}
	void Canonicalize()
	{
		PXSTR pszBuffer;
		StringType strResult;

		pszBuffer = strResult.GetBuffer( m_strPath.GetLength() );
		ATLPath::Canonicalize( pszBuffer, m_strPath );
		strResult.ReleaseBuffer();

		m_strPath = strResult;
	}
	void Combine( __in PCXSTR pszDir, __in PCXSTR pszFile )
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( MAX_PATH );
		ATLPath::Combine( pszBuffer, pszDir, pszFile );
		m_strPath.ReleaseBuffer();
	}
	CPathT< StringType > CommonPrefix( __in PCXSTR pszOther )
	{
		PXSTR pszBuffer;
		int nLength;
		CPathT< StringType > pathResult;

		pszBuffer = pathResult.m_strPath.GetBuffer( __max( m_strPath.GetLength(), StringType::StringLength( pszOther ) ) );
		nLength = ATLPath::CommonPrefix( m_strPath, pszOther, pszBuffer );
		pathResult.m_strPath.ReleaseBuffer( nLength );

		return pathResult;
	}
	BOOL CompactPath( __in HDC hDC, __in UINT nWidth )
	{
		PXSTR pszBuffer;
		BOOL bResult;

		// PathCompactPath can actually _increase_ the length of the path
		pszBuffer = m_strPath.GetBuffer( MAX_PATH );
		bResult = ATLPath::CompactPath( hDC, pszBuffer, nWidth );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	BOOL CompactPathEx( __in UINT nMaxChars, __in DWORD dwFlags = 0 )
	{
		StringType strResult;
		BOOL bResult;
		PXSTR pszBuffer;

		pszBuffer = strResult.GetBuffer( nMaxChars );
		bResult = ATLPath::CompactPathEx( pszBuffer, m_strPath, nMaxChars,
			dwFlags );
		strResult.ReleaseBuffer();

		m_strPath = strResult;

		return bResult;
	}
	BOOL FileExists() const
	{
		return ATLPath::FileExists( m_strPath );
	}
	int FindExtension() const
	{
		PCXSTR pszBuffer;
		PCXSTR pszExtension;

		pszBuffer = m_strPath;
		pszExtension = ATLPath::FindExtension( pszBuffer );
		if( *pszExtension == 0 )
			return -1;
		else
			return int( pszExtension-pszBuffer );
	}
	int FindFileName() const
	{
		PCXSTR pszBuffer;
		PCXSTR pszFileName;

		pszBuffer = m_strPath;
		pszFileName = ATLPath::FindFileName( pszBuffer );
		if( *pszFileName == 0 )
			return -1;
		else
			return int( pszFileName-pszBuffer );
	}
	int GetDriveNumber() const
	{
		return ATLPath::GetDriveNumber( m_strPath );
	}
	StringType GetExtension() const
	{
		int iExtension;
		StringType strExtension;

		iExtension = FindExtension();
		if( iExtension != -1 )
			strExtension = m_strPath.Mid( iExtension );

		return strExtension;
	}
	BOOL IsDirectory() const
	{
		return ATLPath::IsDirectory( m_strPath );
	}

	BOOL IsFileSpec() const
	{
		return ATLPath::IsFileSpec( m_strPath );
	}
	BOOL IsPrefix( PCXSTR pszPrefix ) const
	{
		return ATLPath::IsPrefix( pszPrefix, m_strPath );
	}
	BOOL IsRelative() const
	{
		return ATLPath::IsRelative( m_strPath );
	}
	BOOL IsRoot() const
	{
		return ATLPath::IsRoot( m_strPath );
	}
	BOOL IsSameRoot( PCXSTR pszOther ) const
	{
		return ATLPath::IsSameRoot( m_strPath, pszOther );
	}
	BOOL IsUNC() const
	{
		return ATLPath::IsUNC( m_strPath );
	}
	BOOL IsUNCServer() const
	{
		return ATLPath::IsUNCServer( m_strPath );
	}
	BOOL IsUNCServerShare() const
	{
		return ATLPath::IsUNCServerShare( m_strPath );
	}
	BOOL MakePretty()
	{
		PXSTR pszBuffer;
		BOOL bResult;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		bResult = ATLPath::MakePretty( pszBuffer );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	BOOL MatchSpec( __in PCXSTR pszSpec ) const
	{
		return ATLPath::MatchSpec( m_strPath, pszSpec );
	}
	void QuoteSpaces()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength()+2 );
		ATLPath::QuoteSpaces( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	BOOL RelativePathTo( __in PCXSTR pszFrom, __in DWORD dwAttrFrom, 
		__in PCXSTR pszTo, __in DWORD dwAttrTo )
	{
		PXSTR pszBuffer;
		BOOL bResult;

		pszBuffer = m_strPath.GetBuffer( MAX_PATH );
		bResult = ATLPath::RelativePathTo( pszBuffer, pszFrom, dwAttrFrom,
			pszTo, dwAttrTo );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	void RemoveArgs()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::RemoveArgs( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	void RemoveBackslash()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::RemoveBackslash( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	void RemoveBlanks()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::RemoveBlanks( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	void RemoveExtension()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::RemoveExtension( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	BOOL RemoveFileSpec()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		BOOL bResult = ATLPath::RemoveFileSpec( pszBuffer );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	BOOL RenameExtension( __in PCXSTR pszExtension )
	{
		PXSTR pszBuffer;
		BOOL bResult;

		pszBuffer = m_strPath.GetBuffer( MAX_PATH );
		bResult = ATLPath::RenameExtension( pszBuffer, pszExtension );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	int SkipRoot() const
	{
		PCXSTR pszBuffer;
		PXSTR pszResult;

		pszBuffer = m_strPath;
		pszResult = ATLPath::SkipRoot( pszBuffer );

		return int( pszResult-pszBuffer );
	}
	void StripPath()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::StripPath( pszBuffer );
		m_strPath.ReleaseBuffer();
	}
	BOOL StripToRoot()
	{
		PXSTR pszBuffer;
		BOOL bResult;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		bResult = ATLPath::StripToRoot( pszBuffer );
		m_strPath.ReleaseBuffer();

		return bResult;
	}
	void UnquoteSpaces()
	{
		PXSTR pszBuffer;

		pszBuffer = m_strPath.GetBuffer( m_strPath.GetLength() );
		ATLPath::UnquoteSpaces( pszBuffer );
		m_strPath.ReleaseBuffer();
	}

public:
	StringType m_strPath;
};

typedef CPathT< CString > CPath;
typedef CPathT< CStringA > CPathA;
typedef CPathT< CStringW > CPathW;

};  // namespace ATL
#pragma pack(pop)

#endif  //__ATLPATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlrc.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma once

#ifndef __ATLRC_H__

#define ATL_RESID_BASE						0xD800
#define ATL_STRING_BASE						ATL_RESID_BASE

#define ATL_IDS_DATETIME_INVALID			(ATL_STRING_BASE + 0)
#define ATL_IDS_DATETIMESPAN_INVALID		(ATL_STRING_BASE + 1)

#define ATL_SERVICE_MANAGER_OPEN_ERROR		(ATL_STRING_BASE + 10)
#define ATL_SERVICE_START_ERROR				(ATL_STRING_BASE + 11)
#define ATL_SERVICE_OPEN_ERROR				(ATL_STRING_BASE + 12)
#define ATL_SERVICE_DELETE_ERROR			(ATL_STRING_BASE + 13)
#define ATL_SERVICE_STOP_ERROR				(ATL_STRING_BASE + 14)

#endif	// __ATLRC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlosapice.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#ifndef __ATLOSAPICE_H__
#define __ATLOSAPICE_H__

#pragma once

/////////////////////////////////////////////////////////////////////////////
// The following are provided only to minimize #ifdef's in the ATL code base, which is why they are in the ATL namespace.

#ifdef _WIN32_WCE
#include <ocidl.h>
#if defined(SHELLSDK_MODULES_AYGSHELL) || defined(SHELLW_MODULES_AYGSHELL)
#ifdef SHELLSDK_MODULES_AYGSHELL
#include <shellsdk.h>
#else
#include <aygshell.h>
#endif
#ifndef SHGetMenu
#define SHGetMenu(hWndMB) reinterpret_cast<HMENU>(::SendMessage((hWndMB), SHCMBM_GETMENU, (WPARAM)0, (LPARAM)0));
#endif // !SHGetMenu
#endif // SHELLSDK_MODULES_AYGSHELL || SHELLW_MODULES_AYGSHELL

// Windows CE doesn't support a system menu, but in order to maintain application compatibility a  macro was 
// provided to allow disabling of the close box on the caption; however, this macro causes compile errors for 
// CWnd::GetSystemMenu.
#ifdef GetSystemMenu
#undef GetSystemMenu
inline HMENU GetSystemMenu(HWND hWnd, BOOL /*bRevert*/)
{
	return reinterpret_cast<HMENU>(hWnd);
}
#endif

// PropertySheet
// Current CESDK (Mckendric) utilized for building MFC only define this when MDD_PORT is defined.
// But in Pocket PC 2003 SDK there is no such constraint. 
#ifndef PSCB_GETVERSION
#define PSCB_GETVERSION		3
#endif

#ifndef SM_DBCSENABLED
#define SM_DBCSENABLED		42
#endif

/* WM_PRINT flags */
#ifndef PRF_CHILDREN
#define PRF_CHILDREN            0x00000010L
#endif

#ifndef PRF_CLIENT
#define PRF_CLIENT              0x00000004L
#endif

/* Menu and CommandBar */
// height of CommandBar
#ifndef CB_HEIGHT
#define CB_HEIGHT               26
#endif

// flags to control the appearance and behavior of the new menu item
#ifndef MF_BITMAP
#define MF_BITMAP		0 // tells system to use a bitmap rather than a text string to display a menu item...but it's not a supported flag on Windows CE
#endif

#ifndef MF_DISABLED
#define MF_DISABLED		0
#endif


/* mapping modes */
// Windows CE does not support multiple mapping modes. The only mapping mode is MM_TEXT, which maps logical coordinates 
// to the physical coordinates in a 1:1 ratio from left to right and top to bottom. [From Macallan Help]
#ifndef MM_TEXT
#define MM_TEXT                 1
#endif

#ifndef WM_PRINT
#define WM_PRINT                WM_PAINT
#endif
// WM_NCDESTROY is not a supported message on WINCE, but we want to keep the logic
// (OnNcDestroy mainly) behind it... 
#ifndef WM_NCDESTROY
#define WM_NCDESTROY            (WM_APP - 1)
#endif

#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL         0x00400000L
#endif

#ifndef SW_NORMAL
#define SW_NORMAL               (SW_SHOWNORMAL)
#endif

#ifndef SW_SHOWMINNOACTIVE
#define SW_SHOWMINNOACTIVE      (SW_HIDE)
#endif

#ifndef MB_TYPEMASK
#define MB_TYPEMASK             0x0000000FL
#endif

#ifndef MB_ICONMASK
#define MB_ICONMASK             0x000000F0L
#endif

#ifndef CTLCOLOR_SCROLLBAR
#define CTLCOLOR_SCROLLBAR      CTLCOLOR_EDIT
#endif

#ifndef DEFAULT_GUI_FONT
#define DEFAULT_GUI_FONT        SYSTEM_FONT
#endif

#ifndef PS_DOT
#define PS_DOT                  2
#endif

#ifndef CWP_SKIPINVISIBLE
#define CWP_SKIPINVISIBLE       0x0001
#endif

#ifndef CWP_SKIPDISABLED
#define CWP_SKIPDISABLED        0x0002
#endif

#ifndef SWP_NOREDRAW
#define SWP_NOREDRAW            0
#endif

#ifndef MB_TASKMODAL
#define MB_TASKMODAL            0
#endif

#ifndef MB_SYSTEMMODAL
#define MB_SYSTEMMODAL          MB_APPLMODAL
#endif

#ifndef GMEM_LOCKCOUNT
#define GMEM_LOCKCOUNT          LMEM_LOCKCOUNT
#endif

#ifndef ILS_NORMAL
#define ILS_NORMAL              0x00000000 
#endif

#ifndef LBSELCHSTRING
#define LBSELCHSTRING           TEXT("commdlg_LBSelChangedNotify")
#endif

#ifndef SHAREVISTRING
#define SHAREVISTRING           TEXT("commdlg_ShareViolation")
#endif

#ifndef FILEOKSTRING 
#define FILEOKSTRING            TEXT("commdlg_FileNameOK")
#endif

#ifndef COLOROKSTRING
#define COLOROKSTRING           TEXT("commdlg_ColorOK")
#endif

#ifndef SETRGBSTRING
#define SETRGBSTRING            TEXT("commdlg_SetRGBColor")
#endif

#ifndef HELPMSGSTRING
#define HELPMSGSTRING           TEXT("commdlg_help")
#endif

#ifndef FINDMSGSTRING
#define FINDMSGSTRING           TEXT("commdlg_FindReplace")
#endif

#ifndef DRAGLISTMSGSTRING
#define DRAGLISTMSGSTRING       TEXT("commctrl_DragListMsg")
#endif

#ifndef CDSIZEOF_STRUCT
#define CDSIZEOF_STRUCT(structname, member)    (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))
#endif

#ifndef OPENFILENAME_SIZE_VERSION_400W
#define OPENFILENAME_SIZE_VERSION_400W  CDSIZEOF_STRUCT(OPENFILENAMEW,lpTemplateName)
#endif

#ifndef OPENFILENAME_SIZE_VERSION_400
#define OPENFILENAME_SIZE_VERSION_400  OPENFILENAME_SIZE_VERSION_400W
#endif

extern "C" DWORD GetProcessIndexFromID(HANDLE hProc);
extern "C" HANDLE GetProcessIDFromIndex(DWORD dwIdx);

namespace ATL
{
// These are not provided on Windows CE
#ifndef GWLP_WNDPROC
#define GWLP_WNDPROC GWL_WNDPROC
#endif
#ifndef GWLP_USERDATA
#define GWLP_USERDATA GWL_USERDATA
#endif
#ifndef DWLP_MSGRESULT
#define DWLP_MSGRESULT DWL_MSGRESULT
#endif
#ifndef DWLP_DLGPROC
#define DWLP_DLGPROC DWL_DLGPROC
#endif

#ifndef SetWindowLongPtr 
#define SetWindowLongPtr SetWindowLongPtrW
#endif

#ifndef GetWindowLongPtr 
#define GetWindowLongPtr GetWindowLongPtrW
#endif

// The following are not included in Windows CE SDK headers, but they are included in
// the windows headers, and they are utilized by ATL.

#ifndef IS_INTRESOURCE 
#define IS_INTRESOURCE(_r) (((ULONG_PTR)(_r) >> 16) == 0)
#endif

#ifndef MulDiv
inline int MulDiv(
  int nNumber,
  int nNumerator,
  int nDenominator
)
{
	return static_cast<int>((static_cast<__int64>(nNumber)*static_cast<__int64>(nNumerator))/static_cast<__int64>(nDenominator));
}
#endif

#ifndef VARCMP_LT  
#define VARCMP_LT   0
#endif
#ifndef VARCMP_EQ 
#define VARCMP_EQ   1
#endif
#ifndef VARCMP_GT 
#define VARCMP_GT   2
#endif
#ifndef VARCMP_NULL 
#define VARCMP_NULL 3
#endif

#ifndef VTDATEGRE_MAX
#define VTDATEGRE_MAX 2958465   /* Dec 31, 9999, 0:0:0 in Gregorain Calendar */
#endif

#ifndef VTDATEGRE_MIN
#define VTDATEGRE_MIN -657434   /* Jan  1,  100, 0:0:0 in Gregorain Calendar */
#endif

#ifndef WS_OVERLAPPEDWINDOW
#if defined(WIN32_PLATFORM_PSPC) || defined(WIN32_PLATFORM_WFSP)
#define WS_OVERLAPPEDWINDOW (WS_SYSMENU)
#else
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#endif
#endif

#ifndef _MAX_FNAME
#define _MAX_FNAME                 64
#endif

STDAPI SafeArrayGetVartype(SAFEARRAY * psa, VARTYPE * pvt);
STDAPI VarBstrCat(BSTR bstrLeft, BSTR bstrRight, LPBSTR pbstrResult);
STDAPI VarCmp(LPVARIANT pvarLeft, LPVARIANT pvarRight, LCID lcid, ULONG dwFlags);
STDAPI VarBstrCmp(BSTR bstrLeft, BSTR bstrRight, LCID lcid, ULONG dwFlags); // dwFlags passed to CompareString
STDAPI_(LPWSTR*) CommandLineToArgvW(LPCWSTR lpCmdLine, int* pNumArgs);

// taken from winbase.h
#define MAX_COMPUTERNAME_LENGTH 15

inline BOOL IsWindowUnicode(
	HWND /*hWnd*/)
{
	return TRUE;
}

inline BOOL IsIconic(HWND hWnd)
{
	return !::IsWindowEnabled(hWnd);
}

inline int GetScrollPos(
	HWND hWnd, int nBar)
{
	SCROLLINFO lpsi = {sizeof(SCROLLINFO), SIF_POS};
	if(::GetScrollInfo(hWnd, nBar, &lpsi))
	{
		return lpsi.nPos;
	}
	return 0;
}

inline BOOL GetScrollRange(
	HWND hWnd,
	int nBar,
	LPINT lpMinPos,
	LPINT lpMaxPos)
{
	SCROLLINFO lpsi = {sizeof(SCROLLINFO), SIF_RANGE};

	if (::GetScrollInfo(hWnd, nBar, &lpsi))
	{
		*lpMinPos = lpsi.nMin;
		*lpMaxPos = lpsi.nMax;
		return TRUE;
	}
	return FALSE;
}

inline HWND GetTopWindow(
	HWND hWnd)
{
	return ::GetWindow(hWnd, GW_CHILD);
}

inline HWND GetNextWindow(HWND hWnd, UINT nDirection)
{
	if(!(nDirection & GW_HWNDNEXT|GW_HWNDPREV))
	{
		::SetLastError(ERROR_INVALID_PARAMETER);
		return NULL;
	}
		
	return ::GetWindow(hWnd, nDirection);
}

inline void ScrollChildren(HWND hWnd, int cx, int cy)
{
	// WinCE does not perform any scrolling if the window is
	// not visible. This leaves child windows unscrolled.
	// To account for this oversight, the child windows are moved
	// directly instead.
	HWND hWndChild = ::GetWindow(hWnd, GW_CHILD);
	if (hWndChild != NULL)
	{
		for (; hWndChild != NULL;
			hWndChild = GetNextWindow(hWndChild, GW_HWNDNEXT))
		{
			RECT rect;
			::GetWindowRect(hWndChild, &rect);
			::ScreenToClient(hWnd,(POINT*)&rect.left);
			::SetWindowPos(hWndChild, NULL,	rect.left-cx, rect.top-cy,
				0, 0, SWP_NOSIZE|SWP_NOACTIVATE|SWP_NOZORDER);
		}
	}
}

inline BOOL GetViewportOrgEx(HDC hdc, LPPOINT lpPoint)
{
	if (hdc == NULL)
		return FALSE;

	lpPoint->x = 0;
	lpPoint->y = 0;

	return TRUE;
}

inline BOOL GetViewportExtEx(HDC hdc, LPSIZE lpSize)
{
	if (hdc == NULL)
		return FALSE;

	lpSize->cx = 1;
	lpSize->cy = 1;

	return TRUE;
}

inline BOOL GetWindowOrgEx(HDC hdc, LPPOINT lpPoint)
{
	if (hdc == NULL)
		return FALSE;

	lpPoint->x = 0;
	lpPoint->y = 0;

	return TRUE;
}

inline BOOL GetWindowExtEx(HDC hdc, LPSIZE lpSize)
{
	if (hdc == NULL)
		return FALSE;

	lpSize->cx = 1;
	lpSize->cy = 1;

	return TRUE;
}

inline BOOL DPtoLP(HDC hdc, LPPOINT /*lpPoints*/, int /*nCount*/)
{
	if (hdc == NULL)
		return FALSE;

	return TRUE;
}

inline BOOL LPtoDP(HDC hdc, LPPOINT /*lpPoints*/, int /*nCount*/)
{
	if (hdc == NULL)
		return FALSE;

	return TRUE;
}

inline BOOL PolyPolygon(HDC hdc, const POINT* lpPoints, const int* lpPolyCounts, int nCount)
{
	if (nCount < 2)
		return FALSE;

	BOOL bResult = TRUE;
	for (int nPolygon = 0, nVertex = 0 ; bResult && (nPolygon < nCount) ; nPolygon++, nVertex += lpPolyCounts[nPolygon])
	{
		bResult = (lpPolyCounts[nPolygon] < 2) ? FALSE :
				::Polygon(hdc, &(lpPoints[nVertex]), lpPolyCounts[nPolygon]);
	}
	return bResult;
}

inline BOOL EnumChildWindows(
	HWND hWndParent,
	WNDENUMPROC lpEnumFunc,
	LPARAM lParam)
{
	if(lpEnumFunc == NULL)
	{
		::SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}
	
	HWND hWndChild = ::GetWindow(hWndParent, GW_CHILD);
	if(hWndChild == NULL)
	{
		// Leave last error to whatever GetWindow set it as
		return FALSE;
	}
	
	for(; hWndChild != NULL; hWndChild = ::GetWindow(hWndChild, GW_HWNDNEXT))
	{
		lpEnumFunc(hWndChild, lParam);
		ATL::EnumChildWindows(hWndChild, lpEnumFunc, lParam);
	}

	return TRUE;
}

inline HWND GetLastActivePopup(
	HWND hWnd)
{
	(hWnd);
	return ::GetActiveWindow();
}

inline BOOL ShowScrollBar(
	HWND hWnd,
	int wBar,
	BOOL bShow)
{
	DWORD dwStyle = ::GetWindowLong(hWnd, GWL_STYLE);

	DWORD dwStyleDelta = 0;
	
	switch(wBar)
	{
		case SB_BOTH:
			dwStyleDelta |= WS_HSCROLL | WS_VSCROLL;
			break;

		case SB_HORZ:
			dwStyleDelta |= WS_HSCROLL;
			break;
		case SB_VERT:
			dwStyleDelta |= WS_VSCROLL;
			break;
		default:
			::SetLastError(ERROR_INVALID_PARAMETER);
			return FALSE;
	}
	
	if(bShow)
	{
		dwStyle |= dwStyleDelta;
	}
	else
	{
		dwStyle &= ~dwStyleDelta;
	}
	
	return (::SetWindowLong(hWnd, GWL_STYLE, dwStyle) != 0);
}

inline BOOL IsMenu(HMENU hMenu)
{
	MENUITEMINFO mii;
	ZeroMemory(&mii, sizeof(mii));
	mii.cbSize = sizeof(mii);

	SetLastError(0);
	if (::GetMenuItemInfo(hMenu, 0, TRUE, &mii))
	{
		return TRUE;
	}
	else
	{
		return (::GetLastError() != ERROR_INVALID_MENU_HANDLE);
	}
}

#if defined(SHELLSDK_MODULES_AYGSHELL) || defined(SHELLW_MODULES_AYGSHELL)
inline HMENU GetMenu(HWND hWnd)
{
	HWND hWndMB = ::SHFindMenuBar(hWnd);
	if(hWndMB != NULL)
	{
		return SHGetMenu(hWndMB);
	}
	return NULL;
}
#endif // SHELLSDK_MODULES_AYGSHELL || SHELLW_MODULES_AYGSHELL

inline int GetMenuItemCount(HMENU hMenu)
{
	if(!ATL::IsMenu(hMenu))
	{
		::SetLastError(ERROR_INVALID_HANDLE);
		return -1;
	}
	
	MENUITEMINFO mii;
	memset((char *)&mii, 0, sizeof(mii));
	mii.cbSize = sizeof(mii);

	UINT i = 0;
	
	while(true)
	{
		if(0 == ::GetMenuItemInfo(hMenu, i, TRUE, &mii))
		{
			break;
		}
		++i;
	}

	return i;
}

inline UINT GetMenuItemID(
	HMENU hMenu,
	int nPos)
{
	MENUITEMINFO mii;
	memset((char *)&mii, 0, sizeof(mii));
	mii.cbSize = sizeof(mii); 
	mii.fMask  = MIIM_ID; 
	
	if((0 == ::GetMenuItemInfo(hMenu, nPos, TRUE, &mii)) || (mii.hSubMenu != NULL))
	{
		return 0xFFFFFFFF;
	}

	return mii.wID; 
}

inline BOOL IsByPosition(UINT uFlags)
{
	// MF_BYCOMMAND, which is 0, is the default, but MF_BYPOSITION overrides if both are set
	return (uFlags & MF_BYPOSITION) ? TRUE : FALSE;
}

inline int GetMenuStringW(
	HMENU hMenu, 
	UINT uIDItem, 
	LPWSTR lpString, 
	int nMaxCount, 
	UINT uFlag)
{ 
	MENUITEMINFO mii;
	memset((char *)&mii, 0, sizeof(mii));
	mii.cbSize = sizeof(mii);
	mii.fMask = MIIM_TYPE;
	mii.fType = MFT_STRING;
	mii.dwTypeData = lpString;
	mii.cch = nMaxCount;

	if((0 == ::GetMenuItemInfo(hMenu, uIDItem, IsByPosition(uFlag), &mii)) || (lpString != mii.dwTypeData))
	{
		return 0;
	}

	return (lpString != NULL) ? ::wcslen(lpString) : mii.cch;
}

#ifndef GetMenuString
#define GetMenuString GetMenuStringW
#endif

inline UINT GetMenuState(HMENU hMenu, UINT uId, UINT uFlags)
{
	MENUITEMINFO mii;
	memset((char *)&mii, 0, sizeof(mii));
	mii.cbSize = sizeof(mii);
	mii.fMask  = MIIM_STATE;

	if(0 == ::GetMenuItemInfo(hMenu, uId, IsByPosition(uFlags), &mii))
	{
		return 0;
	}

	return mii.fState;
}


inline BOOL ModifyMenuW(
	HMENU hMenu,
	UINT uPosition,
	UINT uFlags,
	UINT_PTR uIDNewItem,
	LPCWSTR lpNewItem)
{
	if(!IsByPosition(uFlags))
	{	
		MENUITEMINFO mii;
		memset((char *)&mii, 0, sizeof(mii));
		mii.cbSize = sizeof(mii); 
		mii.fMask  = MIIM_ID; 

		UINT uCount = 0;
		while(true)
		{
			if((0 == ::GetMenuItemInfo(hMenu, uCount, TRUE, &mii)) || (mii.wID == uPosition))
			{
				break;  // We rely on DeleteMenu to fiail if we break out due to error on GetMenuItemInfo, since that should mean the uCount is a bogus item
			}
			++uCount;
		}

		if(uCount == 0)
		{
			// GetMenuItemInfo will call SetLastError
			return FALSE;
		}

		// Now we have the position
		uPosition = uCount;
		uFlags |= MF_BYPOSITION;
	}

	if(0 == ::DeleteMenu(hMenu, uPosition, uFlags))
	{
		// DeleteMenu will call SetLastError
		return FALSE;
	}

	// InsertMenu will call SetLastError
	return ::InsertMenu(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
}

#ifndef ModifyMenu 
#define ModifyMenu  ModifyMenuW
#endif

// There is a macro for TrackPopupMenu defined in SDK winuser.h, which could result in compilation errors 
// "not enough actual parameters for macro 'TrackPopupMenu'". redefine it to be a function
#ifdef TrackPopupMenu
#undef TrackPopupMenu
inline BOOL TrackPopupMenu(
	HMENU hMenu,
	UINT uFlags,
	int x,
	int y,
	int nReserved,
	HWND hWnd,
	const RECT* prcRect)
{
	(nReserved, prcRect);
	return TrackPopupMenuEx(hMenu, uFlags, x, y, hWnd, 0);
}
#endif

inline int ExtSelectClipRgn(
	HDC hdc,
	HRGN hrgn,
	int fnMode)
{
	if(hdc == NULL || (hrgn == NULL && fnMode != RGN_COPY))
	{
		return ERROR;
	}

	if(fnMode == RGN_COPY)
	{
		return ::SelectClipRgn(hdc, hrgn);
	}

	HRGN hrgnCurrentClip = CreateRectRgn(0, 0, 1, 1); // bogus region that will get overwritten
	if(-1 == ::GetClipRgn(hdc, hrgnCurrentClip))
	{
		return ERROR;
	}

	HRGN hrgnNewClip = CreateRectRgn(0, 0, 1, 1); // bogus region that will get overwritten
	CombineRgn(hrgnNewClip, hrgnCurrentClip, hrgn, fnMode);

	int nRet = ::SelectClipRgn(hdc, hrgnNewClip);

	if(0 == ::DeleteObject(hrgnNewClip))
	{
		return ERROR;
	}

	return nRet;
}

#ifdef DrawIcon
#undef DrawIcon  // The CE headers define this as a macro with parameters, which causes problems.

inline BOOL DrawIcon(
	HDC hDC, 
	int X, 
	int Y, 
	HICON hIcon
)
{
	return DrawIconEx(hDC,X,Y,hIcon,0,0,0,NULL, DI_NORMAL);
}
#endif

#ifndef PS_DOT
#define PS_DOT              2
#endif

inline HPEN CreatePen(
	int nPenStyle, 
	int nWidth, 
	COLORREF crColor
)
{
	LOGPEN logPen;
	
	logPen.lopnStyle   = (nPenStyle == PS_DOT) ? PS_DASH : nPenStyle;
	logPen.lopnWidth.x = (nWidth == 0) ? 1 : nWidth;
	logPen.lopnWidth.y = 1;
	logPen.lopnColor   = crColor;

	return ::CreatePenIndirect(&logPen); 	
}

inline HBRUSH CreateBrushIndirect(const LOGBRUSH* lplb)
{
	HBRUSH hBrush = NULL;

	if (lplb == NULL)
		return hBrush;

	switch (lplb->lbStyle)
	{
		case BS_SOLID:
			hBrush = ::CreateSolidBrush(lplb->lbColor);
			break;
		
		case BS_NULL:
			hBrush = (HBRUSH)::GetStockObject(NULL_BRUSH);
			break;

		case BS_DIBPATTERNPT:
			if (lplb->lbColor == DIB_RGB_COLORS)
			{
				hBrush = ::CreateDIBPatternBrushPt((void*)lplb->lbHatch, lplb->lbColor);
			}
			break;

		default:
			break;
	}

	return hBrush;
}

// Unlike RegSetValue, RegSetValueEx won't create the specified (sub)key 
// if it doesn't exist at all. What RegSetValueEx does is to create another 
// value under the specified parent key. 
inline LONG RegSetValue(HKEY hKey, 
	LPCTSTR lpKey, 
	DWORD dwType, 
	LPCTSTR lpData, 
	DWORD cbData)
{
	LONG lResult = ERROR_SUCCESS;
	HKEY hSubKey;

	if((lpKey == NULL) || (*lpKey == _T('\0')))
	{
		return ::RegSetValueEx(hKey, lpKey, 0, dwType, (CONST BYTE*)lpData, cbData);
	}

	lResult = RegOpenKeyEx(hKey, lpKey, 0, 0, &hSubKey);
	if(lResult != ERROR_SUCCESS) 
	{	
		DWORD dwType,dwSize;
		lResult = ::RegQueryValueEx(hKey, lpKey, 0, &dwType, NULL, &dwSize);
		if(lResult == ERROR_SUCCESS) 
		{
			// it's a value, keep it.
			return ::RegSetValueEx(hKey, lpKey, 0, dwType, (CONST BYTE*)lpData, cbData);
		}
		else
		{
			// it's empty, create a key
			DWORD dwDisposition;
			lResult = ::RegCreateKeyEx(hKey, lpKey, 0, NULL, NULL, KEY_ALL_ACCESS, NULL, &hSubKey, &dwDisposition);
			if(lResult != ERROR_SUCCESS)
				return lResult;
		}
	}

	lResult = ::RegSetValueEx(hSubKey, _T(""), 0, dwType, (CONST BYTE*)lpData, cbData);
	::RegCloseKey(hSubKey);

	return lResult;
}

inline int WINAPI lstrlenA(LPCSTR lpszString)
{
	// This function is not safe, per the Windows Platform SDK documentation on lstrlen.
	int iLen = 0;

	if(lpszString != NULL)
	{
		for(LPCSTR lpszCur = lpszString; *lpszCur != '\0'; ++lpszCur, ++iLen)
		{
			// intentionally empty
		}
	}
	
	return iLen;
}

#ifndef lstrcmpA
#define lstrcmpA strcmp
#endif

#ifndef lstrcpyA
#define lstrcpyA strcpy
#endif

#ifdef lstrlenW
#undef lstrlenW
inline int WINAPI lstrlenW(const wchar_t *string)
{
	return ((string != NULL) ? ::wcslen(string) : 0);
}
#endif

inline LPWSTR lstrcpynW(LPWSTR lpszString1, LPCWSTR lpszString2, int iMaxLength)
{
	if(iMaxLength <= 0 || lpszString1 == NULL || lpszString2 == NULL)
	{
		return NULL;
	}
	
	::wcsncpy(lpszString1, lpszString2, iMaxLength);
	lpszString1[iMaxLength-1] = '\0';
	
	return lpszString1;
}

#ifndef lstrcpyn
#define lstrcpyn lstrcpynW
#endif

inline int __cdecl wvsprintfW(wchar_t *string, const wchar_t *format, va_list ap)
{
	const size_t maxcount = 1024;
		
	int len = _vsnwprintf(string, maxcount, format, ap);

	// _vsnwprintf returns -1 if buffer is not big enough (or an error occurs)
	if(len < 0)
	{
		// null terminate the string
		// note that maximum size is 1024 characters plus terminating null.
		string[len = maxcount] = 0;
	}

	return len;
}

inline int __cdecl wvsprintfA(char *string, const char *format, va_list ap)
{
	const size_t maxcount = 1024;
		
	int len = _vsnprintf(string, maxcount, format, ap);

	// _vsnprintf returns -1 if buffer is not big enough (or an error occurs)
	if(len < 0)
	{
		// null terminate the string
		// note that maximum size is 1024 characters plus terminating null.
		string[len = maxcount] = 0;
	}

	return len;
}

inline LCID GetThreadLocale(void)
{
	return ::GetSystemDefaultLCID();	
}

#ifdef GetVersion
#undef GetVersion
#endif
inline DWORD GetVersion(void)
{
	OSVERSIONINFO vi;
	ZeroMemory(&vi, sizeof(OSVERSIONINFO));
	vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	::GetVersionEx(&vi);

	return ((DWORD)(LOBYTE(LOWORD(vi.dwMajorVersion))) |
		(DWORD)(LOBYTE(LOWORD(vi.dwMinorVersion))) << 8 | 
		(DWORD)(LOWORD(vi.dwBuildNumber)) << 16 |
		(vi.dwPlatformId != VER_PLATFORM_WIN32_NT) ? 0x80000000 : 0);
}

inline LPWSTR STDAPICALLTYPE PathFindExtensionW(LPCWSTR pszPath)
{
	if(pszPath == NULL)
	{
		::SetLastError(ERROR_INVALID_PARAMETER);
		return NULL;
	}
	
	LPWSTR pszLastDot = NULL;
	LPWSTR pszCh;
	for(pszCh = const_cast<LPWSTR>(pszPath); *pszCh != L'\0'; ++pszCh)
	{
		if(L'.' == *pszCh)
		{
			pszLastDot = pszCh;
		}
	}

	if(pszLastDot != NULL)
	{
		// Make sure there are no \ or / after the dot, or the . doesn't signify the file extension
		for(LPWSTR pszCh2 = pszCh; pszCh2 == pszLastDot; --pszCh2)
		{
			if(L'\\' == *pszCh || L'/' == *pszCh)
			{
				return pszCh;
			}
		}

		// Return the file extension
		return pszLastDot;
	}
	
	return pszCh;
}

#ifndef PathFindExtension 
#define PathFindExtension PathFindExtensionW
#endif

inline void PathRemoveExtension(LPTSTR pszPath)
{
	if (pszPath == NULL)
	{
		return;
	}

	for (LPTSTR pszCh = pszPath ; *pszCh !=  L'\0' ; ++pszCh)
	{
		if (L'.' == *pszCh)
		{
			*pszCh = L'\0';
			return;
		}
	}
}

inline LPTSTR PathFindFileName(LPCTSTR lpszPathName)
{
	LPTSTR lpszFileName = (LPWSTR)lpszPathName;
	for (LPCTSTR lpsz = lpszPathName; *lpsz != '\0'; lpsz = _wcsinc(lpsz))
	{
		// remember last directory/drive separator
		if (*lpsz == '\\' || *lpsz == '/' || *lpsz == ':')
			lpszFileName = (LPTSTR)_wcsinc(lpsz);
	}

	return lpszFileName;
}

inline LPCWSTR FindFilePart(LPCWSTR pszPath, LPCWSTR& pszEnd)
{
	LPCWSTR pszLastSlash = NULL;
	
	for(pszEnd = pszPath; *pszEnd != L'\0'; ++pszEnd)
	{
		if(L'\\' == *pszEnd || L'/' == *pszEnd)
		{
			pszLastSlash = pszEnd;
		}
	}

	if(pszLastSlash == NULL)
	{
		// No slashes, so path is just a filename
		return pszPath;
	}

	++pszLastSlash;

	if(pszLastSlash != L'\0')
	{
		return pszLastSlash;
	}

	// Only got a path without a filename
	return NULL;
}

// This isn't implemented exactly as for Win32, but it's sufficient the needs of ATL and MFC, 
// which pass in a full path, rather then just a filename without the expectation that
// that the current drive and directory be utilized, since that doesn't exist on WinCE.
inline DWORD WINAPI GetFullPathNameW(
    IN LPCWSTR pszFileName,
    IN DWORD nBufferLength,
    OUT LPWSTR pszBuffer,
    OUT LPWSTR *pszFilePart)
{
	if(pszFileName == NULL || pszBuffer == NULL || pszFilePart == NULL)
	{
		::SetLastError(ERROR_INVALID_PARAMETER);
		return 0;
	}
	
	LPCWSTR pszCh = const_cast<LPWSTR>(pszFileName);
	LPCWSTR pszFilePartTemp = FindFilePart(pszFileName, pszCh);

	if(pszFilePartTemp == NULL)
	{
		return 0;
	}

	// Plus 1 to turn diff into count (pszCh points to null terminator)
	DWORD dwLen = pszCh - pszFileName + 1;
	
	// pszBuffer isn't big enough.  Bail!!!
	if(dwLen > nBufferLength)
	{
		return dwLen;
	}

	::wcsncpy(pszBuffer, pszFileName, dwLen);

	// Everything is fine so return the correct values
	*pszFilePart = pszBuffer + (pszFilePartTemp - pszFileName);

	// Minus one to get count chars, which is the correct value to return
	--dwLen;

	return dwLen;
}

#ifndef GetFullPathName
#define GetFullPathName GetFullPathNameW
#endif

// This isn't implemented exactly as for Win32, but it's sufficient for MFC's needs, 
// which only requires spliting of the filename from the rest of the path
inline short GetFileTitleW(
	LPCWSTR lpszFile,
	LPWSTR lpszTitle,
	WORD cbBuf
)
{
	if(lpszFile == NULL || lpszTitle == NULL)
	{
		::SetLastError(ERROR_INVALID_PARAMETER);
		return -1;
	}

	LPCWSTR pszCh = const_cast<LPWSTR>(lpszFile);
	LPCWSTR pszFilePart = FindFilePart(lpszFile, pszCh);

	if(pszFilePart == NULL)
	{
		return -1;
	}

	// Plus 1 to turn diff into count (pszCh points to null terminator)
	unsigned int uLen = pszCh - pszFilePart + 1;
	
	// lpszTitle isn't big enough.  Bail!!!
	if(uLen > cbBuf)
	{
		// If uLen is to big to be cast to a short, then lpszFile isn't valid,
		// and in that case, this API has an unknown return value.
		return static_cast<short>(uLen);
	}

	::wcsncpy(lpszTitle, pszFilePart, uLen);

	return 0;
}

#ifndef GetFileTitle
#define GetFileTitle GetFileTitleW
#endif

//---------------------------------------------------------------------
// Convert encoded RGB colors to "TRUE" RGB colors.  I.E. where the
// high bit is set, the low word is a SysColor index.  Then, where
// hpal != NULL, convert colors to palette-relative colors.
//---------------------------------------------------------------------
inline HRESULT OleTranslateColor(OLE_COLOR clr, HPALETTE hpal, COLORREF *pcolorref)
{

#ifdef _DEBUG
	if(pcolorref != NULL && ::IsBadWritePtr(pcolorref, sizeof(COLORREF)))
	{
		return ResultFromScode(E_INVALIDARG);
	}
#endif

	switch(clr & (0xff000000^SYS_COLOR_INDEX_FLAG))
	{
	case 0x80000000:
	{
		int syscolor = static_cast<int>(clr & (0xFFFF | SYS_COLOR_INDEX_FLAG));

		if(syscolor < SYS_COLOR_INDEX_FLAG || syscolor >= C_SYS_COLOR_TYPES)
		{
			return ResultFromScode(E_INVALIDARG);
		}

		if(pcolorref != NULL)
		{
			clr = ::GetSysColor(syscolor);
		}
		break;
	}

	case 0x01000000:
	{
		if((clr & (0xffff0000^SYS_COLOR_INDEX_FLAG)) != 0x01000000)
		{
			return ResultFromScode(E_INVALIDARG);
		}
         
		// Check validity of index
		if(hpal != NULL)
		{
			PALETTEENTRY pe;
			// Try to get palette entry; if it fails we assume index is invalid
			if(!::GetPaletteEntries(hpal, (UINT)(clr & 0xffff), 1, &pe))
			{
				return ResultFromScode(E_INVALIDARG);
			}
		}
		break;
	}

	case 0x02000000:
		break;

	case 0:
	{
		if(hpal != NULL)
		{
			clr |= 0x02000000;
		}
		break;
	}

	default:
		return ResultFromScode(E_INVALIDARG);
	}

	if (pcolorref != NULL)
	{
		*pcolorref = clr;
	}

	return NOERROR;
}

inline HFONT CreateFont(
	int nHeight, 
	int nWidth, 
	int nEscapement,
	int nOrientation, 
	int nWeight, 
	BYTE bItalic, 
	BYTE bUnderline,
	BYTE cStrikeOut, 
	BYTE nCharSet, 
	BYTE nOutPrecision,
	BYTE nClipPrecision, 
	BYTE nQuality, 
	BYTE nPitchAndFamily,
	LPCTSTR lpszFacename)
{
	LOGFONT logFont;
	logFont.lfHeight = nHeight;
	logFont.lfWidth = nWidth;
	logFont.lfEscapement = nEscapement;
	logFont.lfOrientation = nOrientation;
	logFont.lfWeight = nWeight;
	logFont.lfItalic = bItalic;
	logFont.lfUnderline = bUnderline;
	logFont.lfStrikeOut = cStrikeOut;
	logFont.lfCharSet = nCharSet;
	logFont.lfOutPrecision = nOutPrecision;
	logFont.lfClipPrecision = nClipPrecision;
	logFont.lfQuality = nQuality;
	logFont.lfPitchAndFamily = nPitchAndFamily;
	::wcsncpy_s(logFont.lfFaceName, _countof(logFont.lfFaceName), lpszFacename, _countof(logFont.lfFaceName));

	return ::CreateFontIndirect(&logFont);
}

inline int FrameRect(
	HDC hdc, 
	const RECT* lprc, 
	HBRUSH hbr)
{
	// Fill a "line-size" rectangle for each edge of the frame, using hbr
	// Note that right/bottom borders not painted by FillRect (or FrameRect)
	RECT rectEdge;

	// Top edge of frame
	if (::SetRect(&rectEdge, lprc->left, lprc->top, lprc->right, lprc->top + 1) == FALSE)
		return FALSE;
	if (::FillRect(hdc, &rectEdge, hbr) == FALSE)
		return FALSE;
	
	// Right edge of frame
	if (::SetRect(&rectEdge, lprc->right - 1, lprc->top, lprc->right, lprc->bottom) == FALSE) 
		return FALSE;
	if (::FillRect(hdc, &rectEdge, hbr) == FALSE)
		return FALSE;

	// Bottom edge of frame
	if (::SetRect(&rectEdge, lprc->left, lprc->bottom - 1, lprc->right, lprc->bottom) == FALSE) 
		return FALSE;
	if (::FillRect(hdc, &rectEdge, hbr) == FALSE)
		return FALSE;

	// Left edge of frame
	if (::SetRect(&rectEdge, lprc->left, lprc->top, lprc->left + 1, lprc->bottom) == FALSE) 
		return FALSE;
	return ::FillRect(hdc, &rectEdge, hbr);
}

#ifndef _OLE32_
__inline int InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
      ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
      ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
      ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
      ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);
}
#endif

#include <kfuncs.h>

#define GetCurrentProcessIndex() GetProcessIndexFromID(GetCurrentProcess())

/*

	CePtr's provide encapsulation and manipulation of Windows CE pointers.  

	In CE, the bottom 1 gig of memory is divided into 32 slots of 32 meg each:

		Slot  0, 0x00000000 - 0x01ffffff
		Slot  1, 0x02000000 - 0x03ffffff
		Slot  2, 0x04000000 - 0x05ffffff
		Slot  3, 0x06000000 - 0x07ffffff
			.
			.
			.
		Slot 31, 0x3e000000 - 0x3fffffff
		Slot 32, 0x40000000 - 0x41ffffff


	Note that by laying out the bits of the address carefully, it's possible 
	to determine the slot number.


	Slot 0 and Slot 1 are special.  Slot 0 is reserved for the currently 
	running process.  Slot 1 is reserved for dll's.  All code has to be run in 
	the context of a particular process.  For Slot 0 and Slot 1 addresses, 
	there is no way to determine the associated process by looking at just the 
	bits in the address.

	For other addresses, the slot number uniquely identifies the 
	associated process.  These addresses are often called mapped pointers: 
	their values have been mapped to a particular slot.

	Most applications programmers will never use the details of CE pointers.  
	Pointers will work just like regular C pointers so these routines will not 
	be necessary or particularly useful.  System programmers will need to have 
	some knowledge of how the pointers work however and these routines will be 
	very useful.
	
	System programmers will often need to pass pointers to different processes 
	and deal with pointers that have come in from other processes.
	
	The primary operations on the pointers are:
	
		1.  Encoding the pointer's associated process into the pointer, usually 
		called "mapping the pointer".
		
		2.  Extracting the associated process from a mapped pointer, here called 
		"Unpacking the pointer".


	CePtr's lay out the address so that the bits of the address that 
	correspond to the slot number are easily accessible and modifiable.
	
	Mapping slot 0 addresses is simple: the slot number of the process is set into 
	the appropriate bits of the address.  Mapping slot 1 address is only 
	slightly more complex.  If the incoming address is a slot 1 address, this 
	is remembered by setting a normally unused bit of the address.  The index 
	of the process is then set into the appropriate bits of the address.  
	Addresses in other slots do not need any modifications.  They are already 
	mapped.
	
	Unpacking the mapped pointer is also straightforward.  The OS is queried 
	for the process that corresponds to the index bits of the addres.  Then the 
	dll flag bit is checked.  If the bit is 0, the index of the pointer is set 
	to 0 to form a slot 0 address.  If the bit is 1, the index of the pointer 
	is set to to 1 to form a slot 1 address.

	IMPORTANT: Note that CePtr's are the exact size of C pointers.  This 
	allows them to be passed across processes as regular C pointers.  

*/


inline DWORD GetOsMajorVersion(void)
{
	OSVERSIONINFO vData;
	ZeroMemory(&vData, sizeof(OSVERSIONINFO));
	vData.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if(!::GetVersionEx(&vData))
	{	//default to 0x4
		return 0x04;
	}
	
	return vData.dwMajorVersion;
}

class CePtrBase_t
{
private:
	union
		{
		void*				m_Ptr;
		long				m_PtrLong;
		unsigned long		m_PtrUnsignedLong;
		
#if (_WIN32_WCE < 0x600)
		//We can't store address + process infomation in 32 bits on CE 6.0
		//There is no 32 process restriction and the size of addressable space is
		//much bigger. So this cross process address structure doesn't make sense for
		//CE 6.0 and above.
		struct
			{
			unsigned int	m_Address		: 25;
			unsigned int	m_ProcessIndex	:  6;
			unsigned int	m_IsDllAddress	:  1;
			};
#endif //(_WIN32_WCE < 0x600)
		};


protected:

	/*
		Default CePtr constructor initializes pointer to 0.
	*/
	CePtrBase_t(
		void
		)
	{
		m_Ptr = 0;
	}


	/*
		Create a CePtr from the raw bits of a C pointer.
	*/
	CePtrBase_t(
		void*	p
		)
	{
		m_Ptr = p;
	}


	/*
		Create a CePtr from the raw bits of an unsigned long.
	*/
	CePtrBase_t(
		unsigned long	l
		)
	{
		m_PtrUnsignedLong = l;
	}



	/*
		Create a CePtr from the raw bits of a long.
	*/
	CePtrBase_t(
		long	l
		)
	{
		m_PtrLong = l;
	}


#if (_WIN32_WCE < 0x600)
	/*
		Create a CePtr and map it to the given process.  If the pointer is already 
		mapped, it will not be modified.  If the process handle is 0, the pointer 
		will be mapped to the current process.  
	*/
	CePtrBase_t(
		void*		p,
		HPROCESS	hProcessToMapTo
		)
	{
		m_Ptr = p;
		MapToProcess(hProcessToMapTo);
		return;
	}



	/*
		Unpack the unmapped pointer and process handle from the ceptr.
	*/
	void
	Unpack(
		void**		pUnmapped,
		HPROCESS*	hProcessMappedTo
		) const;

#endif //(_WIN32_WCE < 0x600)

	/*
		Return the pointer as a C++ pointer.
	*/
	void*
	AsCppPtr(
		void
		) const
	{
		return m_Ptr;
	}



public:

#if (_WIN32_WCE < 0x600)
	/*
		Map the ceptr to the given process.  If the pointer is already 
		mapped, it will not be modified.  If the process handle is 0, the pointer 
		will be mapped to the current process.  
	*/
	void
	MapToProcess(
		HPROCESS	hProcessToMapTo
		);


	/*
		Maps a pointer to the current process.  See MapToProcess.
	*/
	void
	MapToCurrentProcess(
		void
		)
	{
		MapToProcess(0);
	}


	/*
		Returns true if the pointer is mapped.
	*/
	bool
	IsMapped(
		void
		) const
	{
		return ( m_Ptr == 0 ) ||
			   ( ( m_ProcessIndex != 0 ) && ( m_ProcessIndex != 1 ) );
	}

	bool
	IsMappedOrDll(
		void
		) const
	{
		return IsMapped() || ( m_ProcessIndex == 1 );
	}



	/*
		Returns true if the pointer is mapped.
		Debug version will assert if the pointer is not mapped.
	*/
	bool
	IsMappedAssert(
		void
		) const;
#endif //(_WIN32_WCE < 0x600)

	/*
		Returns true if the pointer is 0.
	*/
	bool
	IsNull(
		void
		) const
	{
		return m_Ptr == 0;
	}


	/*
		Returns the pointer as a long value.
	*/
	long
	AsLong(
		void
		)
	{
		return m_PtrLong;
	}



};


template <class C_t> class CePtr_t : public CePtrBase_t
{
public:

	CePtr_t<C_t>(
		void
		) : CePtrBase_t()
	{
	}


	explicit
	CePtr_t<C_t>(
		C_t	p
		) : CePtrBase_t(p)
	{
	}


	explicit
	CePtr_t<C_t>(
		unsigned long	l
		) : CePtrBase_t(l)
	{
	}


#if (_WIN32_WCE < 0x600)
	CePtr_t<C_t>(
		C_t			p,
		HPROCESS	hProcessToMapTo
		) : CePtrBase_t(p, hProcessToMapTo)
	{
	}


	void
	Unpack(
		C_t*		pUnmapped,
		HPROCESS*	phProcessMappedTo
		) const
	{
		CePtrBase_t::Unpack(reinterpret_cast<void**>(pUnmapped), phProcessMappedTo);
	}


	CePtr_t<C_t>&
	MapToProcess(
		HPROCESS	hProcessToMapTo
		)
	{
		CePtrBase_t::MapToProcess(hProcessToMapTo);
		return *this;
	}


	CePtr_t<C_t>&
	MapToCurrentProcess(
		void
		)
	{
		CePtrBase_t::MapToProcess(0);
		return *this;
	}

#endif //(_WIN32_WCE < 0x600)

	C_t
	AsCppPtr(
		void
		) const
	{
		return reinterpret_cast<C_t>(CePtrBase_t::AsCppPtr());
	}


#if (_WIN32_WCE < 0x600)
	/*
		Maps the given pointer to the current process.
	*/
	static
	void
	MapToCurrentProcess(
		C_t*	p
		)
	{
		*p = CePtr_t<C_t>(*p,0).AsCppPtr();
		return;
	}
#endif //(_WIN32_WCE < 0x600)

};

#if (_WIN32_WCE < 0x600)
inline bool
CePtrBase_t::
IsMappedAssert(
	void
	) const
{
	bool	PtrIsMapped = IsMapped();

	if ( !PtrIsMapped )
		{
		ATLASSERT(0);
		}

	return PtrIsMapped;
}




inline void
CePtrBase_t::
MapToProcess(
	HPROCESS	hProcessToMapTo
	)
{
	if ( IsMapped() )
		{
		//	Pointer is already mapped.  Leave it alone.
		}
	else
		{
		//	Remember if this is a dll address.
		if ( m_ProcessIndex == 1 )
			{
			m_IsDllAddress = 1;
			}

		if ( hProcessToMapTo == 0 )
			{
			m_ProcessIndex = GetCurrentProcessIndex() + 1;
			}
		else
			{
			m_ProcessIndex = GetProcessIndexFromID(hProcessToMapTo) + 1;
			}
		}

	return;
}



inline void
CePtrBase_t::
Unpack(
	void**		pp,
	HPROCESS*	phProcess
	) const
{
	void*		p = 0;
	HPROCESS	hProcess = 0;

	if ( m_Ptr )
		{
		//	Need to make a copy so that we don't destroy the original.
		CePtrBase_t	CePtr(m_Ptr);

		//	Get the process that this pointer originally came from.
		hProcess = GetProcessIDFromIndex(CePtr.m_ProcessIndex - 1);

		//	If the address was a dll address,
		//	set it back to slot 1,
		//	otherwise, set it back to slot 0.
		if ( CePtr.m_IsDllAddress )
			{
			CePtr.m_ProcessIndex = 1;
			CePtr.m_IsDllAddress = 0;
			}
		else
			{
			CePtr.m_ProcessIndex = 0;
			}

		p = CePtr.m_Ptr;
		}

	if ( phProcess )
		{
		*phProcess = hProcess;
		}

	if ( pp )
		{
		*pp = p;
		}

	return;
	
}
#endif //(_WIN32_WCE < 0x600)

// Unpack the mapped WNDPROC/DLGPROC SetWindowLongPtr and GetWindowLongPtr returns so it can be compared to a standard non-mapped pointer
template <class ProcType_t>
inline ProcType_t _UnpackMappedProc(ProcType_t pProc)
{
	//CE 6.0 doesn't allow cross process subclassing/super classing. So
	//check whether we are CE version 6.0 or higher and take the decision accordingly
	static DWORD dwMajorVer= GetOsMajorVersion();

#if (_WIN32_WCE < 0x600)
	HPROCESS hProcess = NULL;
	if(dwMajorVer < 0x06)
            (CePtr_t<ProcType_t>(pProc)).Unpack(&pProc, &hProcess);
#endif
	return pProc;
}

// Map a standard pointer so it can be passed to CallWindowProc
template <class ProcType_t>
inline ProcType_t _MapProc(ProcType_t pProc)
{
	CePtr_t<ProcType_t> pCePtr(pProc);

	//CE 6.0 doesn't allow cross process subclassing/super classing. So
	//check whether we are CE version 6.0 or higher and take the decision accordingly
	static DWORD dwMajorVer= GetOsMajorVersion();
#if (_WIN32_WCE < 0x600)
	if(dwMajorVer < 0x06)
            pCePtr.MapToCurrentProcess();
#endif
	return pCePtr.AsCppPtr();
}

#else // _WIN32_WCE

using ::IsWindowUnicode;
using ::GetScrollPos;
using ::GetScrollRange;
using ::GetTopWindow;
using ::GetLastActivePopup;
using ::ShowScrollBar;
using ::IsMenu;
using ::GetMenu;
using ::GetMenuStringW;

using ::CreatePen;
using ::GetViewportOrgEx;
using ::GetViewportExtEx;
using ::GetWindowOrgEx;
using ::GetWindowExtEx;
using ::DPtoLP;
using ::LPtoDP;
using ::PolyPolygon;
using ::CreateFont;
using ::FrameRect;

using ::RegSetValue;

using ::lstrlenA;
using ::lstrlenW;
using ::wvsprintfW;
using ::wvsprintfA;

using ::GetThreadLocale;

using ::PathFindExtension;
using ::GetFullPathName;

using ::SafeArrayGetVartype;
using ::VarBstrCat;
using ::VarCmp;
using ::VarBstrCmp;
using ::CommandLineToArgvW;

#define _UnpackMappedProc(pProc) (pProc)
#define _IsMappedProc(pProc) (false)

#endif // _WIN32_WCE

} // namespace ATL


#endif	// __ATLOSAPICE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlperf.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLPERF_H__
#define __ATLPERF_H__

#pragma once

#ifdef _WIN32_WCE
	#error atlpref.h is not supported on Windows CE (_WIN32_WCE is defined)
#endif //_WIN32_WCE

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atlbase.h>
#include <atlcom.h>
#include <atlstr.h>
#include <atlfile.h>
#include <atlsync.h>
#include <winperf.h>
#include <atlcoll.h>
#include <atlsecurity.h>

#ifndef _ATL_PERF_NOXML
#include <atlenc.h>
#include <oaidl.h>
#include <xmldomdid.h>

/* xmldsodid and mshtmdid both have the same identifiers defined, with differing values. So we are renaming the XML ones since there are less identifiers dependent on those.  */
#ifdef DISPID_XOBJ_MIN
/* in case the HTM one was included first, we'll undef these first */
#define _ATL_MSHTMDID_INCLUDED_ALREADY
#undef DISPID_XOBJ_MIN
#undef DISPID_XOBJ_MAX
#undef DISPID_XOBJ_BASE
#endif

#include <xmldsodid.h>
#include <msxmldid.h>

/* re-undef the clashing names, and their direct dependents */
#undef DISPID_XOBJ_MIN
#undef DISPID_XOBJ_MAX
#undef DISPID_XOBJ_BASE
#undef DISPID_XMLDSO
#undef DISPID_XMLELEMENTCOLLECTION

/* re-def the clashing names, and their direct dependents, with un-clashed values */
#define DISPID_XMLDSO_XOBJ_MIN                 0x00010000
#define DISPID_XMLDSO_XOBJ_MAX                 0x0001FFFF
#define DISPID_XMLDSO_XOBJ_BASE                DISPID_XMLDSO_XOBJ_MIN
#define DISPID_XMLDSO			               DISPID_XMLDSO_XOBJ_BASE
#define DISPID_XMLELEMENTCOLLECTION            DISPID_XMLDSO_XOBJ_BASE
#ifdef _ATL_MSHTMDID_INCLUDED_ALREADY

/* redef the clashing names to the HTM values */
#define DISPID_XOBJ_MIN                 0x80010000
#define DISPID_XOBJ_MAX                 0x8001FFFF
#define DISPID_XOBJ_BASE                DISPID_XOBJ_MIN
#endif
#include <msxml.h>
#endif

#pragma warning(push)
#pragma warning(disable: 4625) // copy constructor could not be generated because a base class copy constructor is inaccessible
#pragma warning(disable: 4626) // assignment operator could not be generated because a base class assignment operator is inaccessible


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

const DWORD ATLPERF_SIZE_MASK = 0x00000300;
const DWORD ATLPERF_TYPE_MASK = 0x00000C00;
const DWORD ATLPERF_TEXT_MASK = 0x00010000;

#ifndef ATLPERF_DEFAULT_MAXINSTNAMELENGTH
#define ATLPERF_DEFAULT_MAXINSTNAMELENGTH 64
#endif

// base class for user-defined perf objects
struct CPerfObject
{
	// implementation

	ULONG m_nAllocSize;
	DWORD m_dwCategoryId;
	DWORD m_dwInstance;
	ULONG m_nRefCount;
	ULONG m_nInstanceNameOffset; // byte offset from beginning of PerfObject to LPWSTR szInstanceName
};

class CPerfMon
{
public:
	virtual ~CPerfMon() throw();

#ifdef _ATL_PERF_REGISTER
	// registration
	HRESULT Register(
		LPCTSTR szOpenFunc,
		LPCTSTR szCollectFunc,
		LPCTSTR szCloseFunc,
		HINSTANCE hDllInstance = _AtlBaseModule.GetModuleInstance()) throw();
	HRESULT RegisterStrings(
		LANGID wLanguage = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
		HINSTANCE hResInstance = _AtlBaseModule.GetResourceInstance()) throw();
	HRESULT RegisterAllStrings(HINSTANCE hResInstance = NULL) throw();
	HRESULT Unregister() throw();
#endif

	HRESULT Initialize() throw();
	void UnInitialize() throw();
	HRESULT CreateInstance(
		DWORD dwCategoryId,
		DWORD dwInstance,
		LPCWSTR szInstanceName,
		CPerfObject** ppInstance) throw();
	HRESULT CreateInstanceByName(
		DWORD dwCategoryId,
		LPCWSTR szInstanceName,
		CPerfObject** ppInstance) throw();

	template <class T>
	HRESULT CreateInstance(
		DWORD dwInstance,
		LPCWSTR szInstanceName,
		T** ppInstance) throw()
	{
		// Ensure T derives from CPerfObject
		static_cast<CPerfObject*>(*ppInstance);
		
		return CreateInstance(
			T::kCategoryId,
			dwInstance,
			szInstanceName,
			reinterpret_cast<CPerfObject**>(ppInstance)
			);
	}

	template <class T>
	HRESULT CreateInstanceByName(
		LPCWSTR szInstanceName,
		T** ppInstance) throw()
	{
		// Ensure T derives from CPerfObject
		static_cast<CPerfObject*>(*ppInstance);
		
		return CreateInstanceByName(
			T::kCategoryId,
			szInstanceName,
			reinterpret_cast<CPerfObject**>(ppInstance)
			);
	}

	HRESULT ReleaseInstance(CPerfObject* pInstance) throw();
	HRESULT LockPerf(DWORD dwTimeout = INFINITE) throw();
	void UnlockPerf() throw();

#ifndef _ATL_PERF_NOXML
	HRESULT PersistToXML(IStream *pStream, BOOL bFirst=TRUE, BOOL bLast=TRUE) throw(...);
	HRESULT LoadFromXML(IStream *pStream) throw(...);
#endif

	// implementation

public:
	// PerfMon entry point helpers
	DWORD Open(LPWSTR lpDeviceNames) throw();
	DWORD Collect(__in_z LPWSTR lpwszValue, __deref_inout_bcount(*pcbBytes) LPVOID* lppData, __inout LPDWORD lpcbBytes, __inout LPDWORD lpcObjectTypes) throw();
	DWORD Close() throw();

	// map building routines
	HRESULT AddCategoryDefinition(
		DWORD dwCategoryId,
		LPCTSTR szCategoryName,
		LPCTSTR szHelpString,
		DWORD dwDetailLevel,
		INT nDefaultCounter,
		BOOL bInstanceLess,
		UINT nStructSize,
		UINT nMaxInstanceNameLen = ATLPERF_DEFAULT_MAXINSTNAMELENGTH) throw();
	HRESULT AddCounterDefinition(	
		DWORD dwCounterId,
		LPCTSTR szCounterName,
		LPCTSTR szHelpString,
		DWORD dwDetailLevel,
		DWORD dwCounterType,
		ULONG nMaxCounterSize,
		UINT nOffset,
		INT nDefaultScale) throw();

	// macro helpers
	HRESULT RegisterCategory(
		WORD wLanguage,
		HINSTANCE hResInstance,
		UINT* pSampleRes,
		DWORD dwCategoryId,
		UINT nNameString,
		UINT nHelpString,
		DWORD dwDetail,
		BOOL bInstanceless,
		UINT nStructSize,
		UINT nMaxInstanceNameLen,
		INT nDefaultCounter) throw();
	HRESULT RegisterCategory(
		WORD wLanguage,
		HINSTANCE hResInstance,
		UINT* pSampleRes,
		DWORD dwCategoryId,
		LPCTSTR szNameString,
		LPCTSTR szHelpString,
		DWORD dwDetail,
		BOOL bInstanceless,
		UINT nStructSize,
		UINT nMaxInstanceNameLen,
		INT nDefaultCounter) throw();
	HRESULT RegisterCounter(
		WORD wLanguage,
		HINSTANCE hResInstance,
		DWORD dwCounterId,
		UINT nNameString,
		UINT nHelpString,
		DWORD dwDetail,
		DWORD dwCounterType,
		ULONG nMaxCounterSize,
		UINT nOffset,
		INT nDefaultScale) throw();
	HRESULT RegisterCounter(
		WORD wLanguage,
		HINSTANCE hResInstance,
		DWORD dwCounterId,
		LPCTSTR szNameString,
		LPCTSTR szHelpString,
		DWORD dwDetail,
		DWORD dwCounterType,
		ULONG nMaxCounterSize,
		UINT nOffset,
		INT nDefaultScale) throw();

protected:
	void ClearMap() throw();

	virtual LPCTSTR GetAppName() const throw() = 0;
	virtual HRESULT CreateMap(WORD wLanguage, HINSTANCE hResInstance, UINT* pSampleRes = NULL) throw();
	virtual void OnBlockAlloc(CAtlFileMappingBase* /*pNewBlock*/) { }
#ifdef _ATL_PERF_REGISTER
	static BOOL CALLBACK EnumResLangProc(HINSTANCE hModule, LPCTSTR szType, LPCTSTR szName, LANGID wIDLanguage, LPARAM lParam);
#endif

	// implementation helpers
	struct CounterInfo
	{
		// implementation

		DWORD m_dwCounterId;
		CString m_strName;
		CString m_strHelp;
		DWORD m_dwDetailLevel;

		// the ids that correspond to the name and help strings stored in the registry
		UINT m_nNameId;
		UINT m_nHelpId;

		// counter data

		DWORD m_dwCounterType;
		LONG m_nDefaultScale;

		// the maximum size of the string counter data in characters, including the null terminator
		// ignored if not a string counter
		ULONG m_nMaxCounterSize;

		ULONG m_nDataOffset;

		// cached data to be copied into request
		PERF_COUNTER_DEFINITION m_cache;
	};

	struct CategoryInfo
	{
		// implementation

		DWORD m_dwCategoryId;
		CString m_strName;
		CString m_strHelp;
		DWORD m_dwDetailLevel;

		// the ids that correspond to the name and help strings stored in the registry
		UINT m_nNameId;
		UINT m_nHelpId;

		// category data

		LONG m_nDefaultCounter;
		LONG m_nInstanceLess; // PERF_NO_INSTANCES if instanceless

		// the size of the struct not counting the name and string counters
		ULONG m_nStructSize;

		// in characters including the null terminator
		ULONG m_nMaxInstanceNameLen;

		ULONG m_nAllocSize;

		// cached data to be copied into request
		PERF_OBJECT_TYPE m_cache;
		ULONG m_nCounterBlockSize;

		// counters
		UINT _GetNumCounters() throw();
		CounterInfo* _GetCounterInfo(UINT nIndex) throw();

		CAtlArray<CounterInfo> m_counters;
	};

	LPBYTE _AllocData(LPBYTE& pData, ULONG nBytesAvail, ULONG* pnBytesUsed, size_t nBytesNeeded) throw();
	template<typename T> T* _AllocStruct(LPBYTE& pData, ULONG nBytesAvail, ULONG* pnBytesUsed, T*) throw()
	{
		return reinterpret_cast<T*>(_AllocData(pData, nBytesAvail, pnBytesUsed, sizeof(T)));
	}

	UINT _GetNumCategoriesAndCounters() throw();
	CategoryInfo* _GetCategoryInfo(UINT nIndex) throw();
	UINT _GetNumCategories() throw();
	CPerfObject* _GetFirstInstance(CAtlFileMappingBase* pBlock) throw();
	CPerfObject* _GetNextInstance(CPerfObject* pInstance) throw();
	CAtlFileMappingBase* _GetNextBlock(CAtlFileMappingBase* pBlock) throw();
	CAtlFileMappingBase* _OpenNextBlock(CAtlFileMappingBase* pPrev) throw();
	CAtlFileMappingBase* _AllocNewBlock(CAtlFileMappingBase* pPrev, BOOL* pbExisted = NULL) throw();
	HRESULT _OpenAllBlocks() throw();
	DWORD& _GetBlockId(CAtlFileMappingBase* pBlock) throw();
	CategoryInfo* _FindCategoryInfo(DWORD dwCategoryId) throw();
	CounterInfo* _FindCounterInfo(CategoryInfo* pCategoryInfo, DWORD dwCounterId) throw();
	CounterInfo* _FindCounterInfo(DWORD dwCategoryId, DWORD dwCounterId) throw();
	BOOL _WantCategoryType(__in_z LPWSTR lpwszValue, __in DWORD dwPerfId) throw(...);
	void _FillCategoryType(CategoryInfo* pCategoryInfo) throw();
	void _FillCounterDef(CounterInfo* pCounterInfo, ULONG* pnCounterBlockSize) throw();
	HRESULT CPerfMon::_CollectInstance(
		CategoryInfo* pCategoryInfo,
		LPBYTE& pData,
		ULONG nBytesAvail,
		ULONG* pnBytesUsed,
		CPerfObject* pInstance,
		PERF_OBJECT_TYPE* pObjectType,
		PERF_COUNTER_DEFINITION* pCounterDefs
		) throw();
	HRESULT _CollectInstance(
		CategoryInfo* pCategoryInfo,
		LPBYTE& pData,
		ULONG nBytesAvail,
		ULONG* pnBytesUsed,
		PERF_OBJECT_TYPE* pObjectType,
		PERF_COUNTER_DEFINITION* pCounterDefs
		) throw();
	HRESULT _CollectCategoryType(
		CategoryInfo* pCategoryInfo,
		LPBYTE pData,
		ULONG nBytesAvail,
		ULONG* pnBytesUsed) throw();
	HRESULT _LoadMap(DWORD* pData) throw();
	HRESULT _SaveMap() throw();
	HRESULT _GetAttribute(
		IXMLDOMNode *pNode, 
		LPCWSTR szAttrName, 
		BSTR *pbstrVal) throw();
	HRESULT CPerfMon::_CreateInstance(
		DWORD dwCategoryId,
		DWORD dwInstance,
		LPCWSTR szInstanceName,
		CPerfObject** ppInstance,
		bool bByName) throw();

#ifdef _ATL_PERF_REGISTER
	void _AppendStrings(
		LPTSTR& pszNew,
		CAtlArray<CString>& astrStrings,
		ULONG iFirstIndex
		) throw();
	HRESULT _AppendRegStrings(
		CRegKey& rkLang,
		LPCTSTR szValue,
		CAtlArray<CString>& astrStrings,
		ULONG nNewStringSize,
		ULONG iFirstIndex,
		ULONG iLastIndex) throw();
	HRESULT _RemoveRegStrings(
		CRegKey& rkLang,
		LPCTSTR szValue,
		ULONG iFirstIndex,
		ULONG iLastIndex) throw();
	HRESULT _ReserveStringRange(DWORD& dwFirstCounter, DWORD& dwFirstHelp) throw();
	HRESULT _UnregisterStrings() throw();
	HRESULT _RegisterAllStrings(UINT nRes, HINSTANCE hResInstance) throw();
#endif
private:
	CAtlArray<CategoryInfo> m_categories;
	CAutoPtrArray<CAtlFileMappingBase> m_aMem;
	CMutex m_lock;
	ULONG m_nAllocSize;
	ULONG m_nHeaderSize;
	ULONG m_nSchemaSize;
	CSecurityDesc m_sd;
};

class CPerfLock
{
public:
	CPerfLock(CPerfMon* pPerfMon, DWORD dwTimeout = INFINITE)
	{
		ATLENSURE(pPerfMon != NULL);
		m_pPerfMon = pPerfMon;
		m_hrStatus = m_pPerfMon->LockPerf(dwTimeout);
	}

	~CPerfLock() throw()
	{
		if (SUCCEEDED(m_hrStatus))
			m_pPerfMon->UnlockPerf();
	}

	HRESULT GetStatus() const throw()
	{
		return m_hrStatus;
	}

private:
	CPerfMon* m_pPerfMon;
	HRESULT m_hrStatus;
};

////////////////////////////////////////////////////////////////////////
// map macros

// empty definition just for ease of use with code wizards, etc.
#define BEGIN_PERFREG_MAP()

// empty definition just for ease of use with code wizards, etc.
#define END_PERFREG_MAP()

#if !defined(_ATL_PERF_REGISTER) | defined(_ATL_PERF_NOEXPORT)
#define PERFREG_ENTRY(className)
#endif

#ifdef _ATL_PERF_REGISTER
#define BEGIN_PERF_MAP(AppName) \
	private: \
		LPCTSTR GetAppName() const throw() { return AppName; } \
		HRESULT CreateMap(WORD wLanguage, HINSTANCE hResInstance, UINT* pSampleRes = NULL) throw() \
		{ \
			if (pSampleRes) \
				*pSampleRes = 0; \
			ClearMap();

#define BEGIN_COUNTER_MAP(categoryclass) \
	public: \
		typedef categoryclass _PerfCounterClass; \
		static HRESULT CreateMap(CPerfMon* pPerf, WORD wLanguage, HINSTANCE hResInstance, UINT* pSampleRes) throw() \
		{ \
			HRESULT hr = RegisterCategory(pPerf, wLanguage, hResInstance, pSampleRes); \
			if (FAILED(hr)) \
				return hr;

#define DECLARE_PERF_CATEGORY_EX(dwCategoryId, namestring, helpstring, detail, instanceless, structsize, maxinstnamelen, defcounter) \
		static HRESULT RegisterCategory(CPerfMon* pPerf, WORD wLanguage, HINSTANCE hResInstance, UINT* pSampleRes) throw() \
		{ \
			return pPerf->RegisterCategory(wLanguage, hResInstance, pSampleRes, dwCategoryId, namestring, helpstring, detail, instanceless, structsize, maxinstnamelen, defcounter); \
		} \
		/* NOTE: put a semicolon after your call to DECLARE_PERF_CATEGORY*(...) */ \
		/* this is needed for the code wizards to parse things properly */ \
		static const DWORD kCategoryId = dwCategoryId

#define CHAIN_PERF_CATEGORY(categoryclass) \
			if (FAILED(categoryclass::CreateMap(this, wLanguage, hResInstance, pSampleRes))) \
				return E_FAIL;

// CAssertValidField ensures that the member variable that's being passed to
// DEFINE_COUNTER[_EX] is the proper type. only 32-bit integral types can be used with
// PERF_SIZE_DWORD and only 64-bit integral types can be used with PERF_SIZE_LARGE
template< DWORD t_dwSize >
class CAssertValidField
{
};

template<>
class CAssertValidField< PERF_SIZE_DWORD >
{
public:
	template< class C > static void AssertValidFieldType( ULONG C::* ) throw() { }
	template< class C > static void AssertValidFieldType( LONG C::* ) throw() { }
};

template<>
class CAssertValidField< PERF_SIZE_LARGE >
{
public:
	template< class C > static void AssertValidFieldType( ULONGLONG C::* ) throw() { }
	template< class C > static void AssertValidFieldType( LONGLONG C::* ) throw() { }
};

#define DEFINE_COUNTER_EX(member, dwCounterId, namestring, helpstring, detail, countertype, maxcountersize, defscale) \
			CAssertValidField< (countertype) & ATLPERF_SIZE_MASK >::AssertValidFieldType( &_PerfCounterClass::member ); \
			hr = pPerf->RegisterCounter(wLanguage, hResInstance, dwCounterId, namestring, helpstring, detail, countertype, maxcountersize, (ULONG) offsetof(_PerfCounterClass, member), defscale); \
			if (FAILED(hr)) \
				return hr;

#define END_PERF_MAP() \
			return S_OK; \
		}

#define END_COUNTER_MAP() \
			return S_OK; \
		}

#else // _ATL_PERF_REGISTER

#define BEGIN_PERF_MAP(AppName) \
	private: \
		LPCTSTR GetAppName() const throw() { return AppName; }

#define BEGIN_COUNTER_MAP(objectclass)

#define DECLARE_PERF_CATEGORY_EX(dwCategoryId, namestring, helpstring, detail, instanceless, structsize, maxinstnamelen, defcounter) \
		/* NOTE: put a semicolon after your call to DECLARE_PERF_CATEGORY*(...) */ \
		/* this is needed for the code wizards to parse things properly */ \
		static const DWORD kCategoryId = dwCategoryId

#define CHAIN_PERF_CATEGORY(objectclass)
#define DEFINE_COUNTER_EX(member, dwCounterId, namestring, helpstring, detail, countertype, maxcountersize, defscale)

#define END_PERF_MAP()
#define END_COUNTER_MAP()

#endif // _ATL_PERF_REGISTER

#define DECLARE_PERF_CATEGORY(objectclass, dwCategoryId, namestring, helpstring, defcounter) \
	DECLARE_PERF_CATEGORY_EX(dwCategoryId, namestring, helpstring, PERF_DETAIL_NOVICE, 0, sizeof(objectclass), ATLPERF_DEFAULT_MAXINSTNAMELENGTH, defcounter)
#define DECLARE_PERF_CATEGORY_NO_INSTANCES(objectclass, dwCategoryId, namestring, helpstring, defcounter) \
	DECLARE_PERF_CATEGORY_EX(dwCategoryId, namestring, helpstring, PERF_DETAIL_NOVICE, PERF_NO_INSTANCES, sizeof(objectclass), 0, defcounter)

#define DEFINE_COUNTER(member, namestring, helpstring, countertype, defscale) \
	DEFINE_COUNTER_EX(member, 0, namestring, helpstring, PERF_DETAIL_NOVICE, countertype, 0, defscale)

#pragma deprecated( DECLARE_PERF_OBJECT_EX )
#pragma deprecated( DECLARE_PERF_OBJECT )
#pragma deprecated( DECLARE_PERF_OBJECT_NO_INSTANCES )
#pragma deprecated( CHAIN_PERF_OBJECT )
#define DECLARE_PERF_OBJECT_EX DECLARE_PERF_CATEGORY_EX
#define DECLARE_PERF_OBJECT DECLARE_PERF_CATEGORY
#define DECLARE_PERF_OBJECT_NO_INSTANCES DECLARE_PERF_CATEGORY_NO_INSTANCES
#define CHAIN_PERF_OBJECT CHAIN_PERF_CATEGORY

////////////////////////////////////////////////////////////////////////
// automagic registration stuff

#if defined(_ATL_PERF_REGISTER) & !defined(_ATL_PERF_NOEXPORT)

// define _ATL_PERF_NOEXPORT if you don't want to use the PERFREG map and don't want these
// functions exported from your DLL

// Perf register map stuff
// this is for ease of integration with the module attribute and for the 
// perfmon wizard

#pragma section("ATLP$A", read, shared)
#pragma section("ATLP$Z", read, shared)
#pragma section("ATLP$C", read, shared)
extern "C"
{
__declspec(selectany) __declspec(allocate("ATLP$A")) CPerfMon * __pperfA = NULL;
__declspec(selectany) __declspec(allocate("ATLP$Z")) CPerfMon * __pperfZ = NULL;
}

#if !defined(_M_IA64)
#pragma comment(linker, "/merge:ATLP=.rdata")
#endif

#if defined(_M_IA64) || defined(_M_AMD64)
	#define ATLPERF_FUNCID_OPEN    "OpenPerfMon"
	#define ATLPERF_FUNCID_COLLECT "CollectPerfMon"
	#define ATLPERF_FUNCID_CLOSE   "ClosePerfMon"
#elif defined(_M_IX86)
	#define ATLPERF_FUNCID_OPEN    "_OpenPerfMon@4"
	#define ATLPERF_FUNCID_COLLECT "_CollectPerfMon@16"
	#define ATLPERF_FUNCID_CLOSE   "_ClosePerfMon@0"
#else
#if !defined(ATLPERF_FUNCID_OPEN) || !defined(ATLPERF_FUNCID_COLLECT) || !defined (ATLPERF_FUNCID_CLOSE)
#error "Unknown platform. Define ATLPERF_FUNCID_OPEN, ATLPERF_FUNCID_COLLECT, ATLPERF_FUNCID_CLOSE"
#endif
#endif

HRESULT RegisterPerfMon(HINSTANCE hDllInstance = _AtlBaseModule.GetModuleInstance()) throw();
HRESULT UnregisterPerfMon() throw();

extern "C" DWORD __declspec(dllexport) WINAPI OpenPerfMon(LPWSTR lpDeviceNames) throw();
extern "C" DWORD __declspec(dllexport) WINAPI CollectPerfMon(LPWSTR lpwszValue, LPVOID* lppData,
	LPDWORD lpcbBytes, LPDWORD lpcObjectTypes) throw();
extern "C" DWORD __declspec(dllexport) WINAPI ClosePerfMon() throw();

// this class handles integrating the registration with CComModule
class _CAtlPerfSetFuncPtr
{
public:
	_CAtlPerfSetFuncPtr()
	{
		_pPerfRegFunc = RegisterPerfMon;
		_pPerfUnRegFunc = UnregisterPerfMon;
	}
};

extern "C" { __declspec(selectany) _CAtlPerfSetFuncPtr g_atlperfinit; }

#if defined(_M_IX86)
#pragma comment(linker, "/INCLUDE:_g_atlperfinit")
#elif defined(_M_IA64) || defined(_M_AMD64)
#pragma comment(linker, "/INCLUDE:g_atlperfinit")
#else
#pragma message("Unknown platform.  Make sure the linker includes g_atlperfinit")
#endif

#ifndef PERF_ENTRY_PRAGMA

#if defined(_M_IX86)
#define PERF_ENTRY_PRAGMA(class) __pragma(comment(linker, "/include:___pperf_" #class));
#elif defined(_M_IA64)
#define PERF_ENTRY_PRAGMA(class) __pragma(comment(linker, "/include:__pperf_" #class));
#elif defined(_M_AMD64)
#define PERF_ENTRY_PRAGMA(class) __pragma(comment(linker, "/include:__pperf_" #class));
#else
#error Unknown Platform. define PERF_ENTRY_PRAGMA
#endif

#endif // PERF_ENTRY_PRAGMA

#define PERFREG_ENTRY(className) \
	__declspec(selectany) className __perf_##className; \
	extern "C" __declspec(allocate("ATLP$C")) __declspec(selectany) CPerfMon * const __pperf_##className = \
		static_cast<CPerfMon*>(&__perf_##className); \
	PERF_ENTRY_PRAGMA(className)

#endif // _ATL_PERF_NOEXPORT

} // namespace ATL
 

#include <atlperf.inl>

#pragma pack(pop)
#pragma warning(pop)

#endif // __ATLPERF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlperf.inl ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLPERF_INL__
#define __ATLPERF_INL__

#pragma once
 
#ifndef __ATLPERF_H__
	#error atlperf.inl requires atlperf.h to be included first
#endif

#pragma warning(push)

#ifndef _CPPUNWIND
#pragma warning(disable: 4702) // unreachable code
#endif

namespace ATL
{

extern __declspec(selectany) const TCHAR * const c_szAtlPerfCounter = _T("Counter");
extern __declspec(selectany) const TCHAR * const c_szAtlPerfFirstCounter = _T("First Counter");
extern __declspec(selectany) const TCHAR * const c_szAtlPerfLastCounter = _T("Last Counter");
extern __declspec(selectany) const TCHAR * const c_szAtlPerfHelp = _T("Help");
extern __declspec(selectany) const TCHAR * const c_szAtlPerfFirstHelp = _T("First Help");
extern __declspec(selectany) const TCHAR * const c_szAtlPerfLastHelp = _T("Last Help");

extern __declspec(selectany) const WCHAR * const c_szAtlPerfGlobal = L"Global";
extern __declspec(selectany) const TCHAR * const c_szAtlPerfLibrary = _T("Library");
extern __declspec(selectany) const TCHAR * const c_szAtlPerfOpen = _T("Open");
extern __declspec(selectany) const TCHAR * const c_szAtlPerfCollect = _T("Collect");
extern __declspec(selectany) const TCHAR * const c_szAtlPerfClose = _T("Close");
extern __declspec(selectany) const TCHAR * const c_szAtlPerfLanguages = _T("Languages");
extern __declspec(selectany) const TCHAR * const c_szAtlPerfMap = _T("Map");
extern __declspec(selectany) const TCHAR * const c_szAtlPerfServicesKey = _T("SYSTEM\\CurrentControlSet\\Services");
extern __declspec(selectany) const TCHAR * const c_szAtlPerfPerformanceKey = _T("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance");
extern __declspec(selectany) const TCHAR * const c_szAtlPerfPerfLibKey = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");
extern __declspec(selectany) const TCHAR * const c_szAtlPerfPerfLibLangKey = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\%3.3x");

inline CPerfMon::CounterInfo* CPerfMon::CategoryInfo::_GetCounterInfo(UINT nIndex) throw()
{
	ATLASSERT(nIndex < _GetNumCounters());
	return &m_counters[nIndex];
}

inline UINT CPerfMon::CategoryInfo::_GetNumCounters() throw()
{
	return (UINT) m_counters.GetCount();
}

inline CPerfMon::~CPerfMon() throw()
{
	UnInitialize();
}

inline HRESULT CPerfMon::CreateMap(LANGID language, HINSTANCE hResInstance, UINT* pSampleRes) throw()
{
	(language); // unused
	(hResInstance); // unused
	(pSampleRes); // unused
	return S_OK;
}

inline UINT CPerfMon::_GetNumCategoriesAndCounters() throw()
{
	UINT nResult = _GetNumCategories();
	for (UINT i=0; i<_GetNumCategories(); i++)
	{
		nResult += _GetCategoryInfo(i)->_GetNumCounters();
	}

	return nResult;
}

inline CPerfMon::CategoryInfo* CPerfMon::_GetCategoryInfo(UINT nIndex) throw()
{
	ATLASSERT(nIndex < _GetNumCategories());
	return &m_categories[nIndex];
}

inline UINT CPerfMon::_GetNumCategories() throw()
{
	return (UINT) m_categories.GetCount();
}

inline CPerfObject* CPerfMon::_GetFirstInstance(CAtlFileMappingBase* pBlock)
{
	ATLENSURE(pBlock != NULL);

	// should never happen if Initialize succeeded
	// are you checking return codes?
	ATLASSERT(pBlock->GetData() != NULL);

	return reinterpret_cast<CPerfObject*>(LPBYTE(pBlock->GetData()) + m_nHeaderSize);
}

inline CPerfObject* CPerfMon::_GetNextInstance(CPerfObject* pInstance)
{
	ATLENSURE(pInstance != NULL);

	return reinterpret_cast<CPerfObject*>(LPBYTE(pInstance) + pInstance->m_nAllocSize);
}

inline CAtlFileMappingBase* CPerfMon::_GetNextBlock(CAtlFileMappingBase* pBlock) throw()
{
	// calling _GetNextBlock(NULL) will return the first block
	DWORD dwNextBlockIndex = 0;
	if (pBlock)
		dwNextBlockIndex = _GetBlockId(pBlock)+1;
	if (m_aMem.GetCount() == dwNextBlockIndex)
		return NULL;
	return m_aMem[dwNextBlockIndex];
}

inline CAtlFileMappingBase* CPerfMon::_OpenNextBlock(CAtlFileMappingBase* pPrev) throw()
{
	CAutoPtr<CAtlFileMappingBase> spMem;
	CAtlFileMappingBase* pMem = NULL;
	ATLTRY(spMem.Attach(new CAtlFileMappingBase));
	if (spMem == NULL)
		return NULL;

	// create a unique name for the shared mem segment based on the index
	DWORD dwNextBlockIndex;
	if (pPrev != NULL)
		dwNextBlockIndex = _GetBlockId(pPrev) +1;
	else
	{
		// use the system allocation granularity (65536 currently. may be different in the future)
		SYSTEM_INFO si;
		GetSystemInfo(&si);
		m_nAllocSize = si.dwAllocationGranularity;

		dwNextBlockIndex = 0;
	}

	_ATLTRY
	{
		CString strName;
		strName.Format(_T("Global\\ATLPERF_%s_%3.3d"), GetAppName(), dwNextBlockIndex);

		HRESULT hr = spMem->OpenMapping(strName, m_nAllocSize, 0, FILE_MAP_READ);
		if (FAILED(hr))
			return NULL;

		pMem = spMem;
		m_aMem.Add(spMem);
	}
	_ATLCATCHALL()
	{
		return NULL;
	}

	return pMem;
}

inline CAtlFileMappingBase* CPerfMon::_AllocNewBlock(CAtlFileMappingBase* pPrev, BOOL* pbExisted /* == NULL */) throw()
{
	CAtlFileMappingBase* pMem = NULL;
	_ATLTRY
	{
		CSecurityAttributes sa;
		sa.Set(m_sd);

		CAutoPtr<CAtlFileMappingBase> spMem;
		spMem.Attach(new CAtlFileMappingBase);
		if (spMem == NULL)
		{
			return NULL;
		}

		// create a unique name for the shared mem segment based on the index
		DWORD dwNextBlockIndex;
		if (pPrev != NULL)
		{
			dwNextBlockIndex = _GetBlockId(pPrev) +1;
		}
		else
		{
			// use the system allocation granularity (65536 currently. may be different in the future)
			SYSTEM_INFO si;
			GetSystemInfo(&si);
			m_nAllocSize = si.dwAllocationGranularity;

			dwNextBlockIndex = 0;
		}

		BOOL bExisted = FALSE;
		CString strName;
		strName.Format(_T("Global\\ATLPERF_%s_%3.3d"), GetAppName(), dwNextBlockIndex);

		HRESULT hr = spMem->MapSharedMem(m_nAllocSize, strName, &bExisted, &sa);
		if (FAILED(hr))
		{
			return NULL;
		}

		if(!bExisted)
		{
			memset(spMem->GetData(), 0, m_nAllocSize);
			// save the index of this block
			// don't for first block since we don't know m_nSchemaSize yet
			if (dwNextBlockIndex)
			{
				_GetBlockId(spMem) = dwNextBlockIndex;
			}
		}
		else
		{
			CSid owner;
			CDacl dacl;

			m_sd.GetOwner(&owner);
			m_sd.GetDacl(&dacl);

			// prevent us from using an object someone else has opened
			if (::SetSecurityInfo(spMem->GetHandle(), SE_KERNEL_OBJECT,
					DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
					const_cast<SID*>(owner.GetPSID()),
					NULL,
					const_cast<ACL*>(dacl.GetPACL()),
					NULL) != ERROR_SUCCESS)
			{
				return NULL;
			}
		}

		if (pbExisted)
		{
			*pbExisted = bExisted;
		}

		pMem = spMem;
		m_aMem.Add(spMem);

		OnBlockAlloc(pMem);
	}
	_ATLCATCHALL()
	{
		return NULL;
	}

	return pMem;
}

inline HRESULT CPerfMon::_OpenAllBlocks() throw()
{
	HRESULT hr;

	// if we haven't opened any yet, initialize
	if (m_aMem.GetCount() == 0)
	{
		CAtlFileMappingBase* pMem = _OpenNextBlock(NULL);
		if (pMem == NULL)
			return S_OK;

		hr = _LoadMap(LPDWORD(pMem->GetData()));
		if (FAILED(hr))
		{
			m_aMem.RemoveAll();
			return hr;
		}

		m_nSchemaSize = *LPDWORD(pMem->GetData());
		m_nHeaderSize = m_nSchemaSize + sizeof(DWORD);
		m_nHeaderSize  = AtlAlignUp(m_nHeaderSize,16);
	}

	// open any new blocks
	CAtlFileMappingBase* pMem = m_aMem[m_aMem.GetCount()-1];
	while (pMem)
		pMem = _OpenNextBlock(pMem);

	return S_OK;
}

inline HRESULT CPerfMon::_LoadMap(DWORD* pData) throw()
{
	_ATLTRY
	{
		HRESULT hr;

		ClearMap();

		DWORD dwDataSize = *pData++; // blob size
		DWORD dwNumItems = *pData++; // number of items

		// see if we have name data
		DWORD* pNameData = NULL;
		if (dwDataSize > (2+dwNumItems*9) * sizeof(DWORD))
			pNameData = pData + dwNumItems*9; // blob size and item count already skipped. skip item data

		for (DWORD i=0; i<dwNumItems; i++)
		{
			DWORD dwIsObject = *pData++;
			DWORD dwPerfId = *pData++;
			DWORD dwDetailLevel = *pData++;

			CString strName;
			if (pNameData)
			{
				strName = CString(LPWSTR(pNameData+1), *pNameData);
				pNameData += AtlAlignUp(sizeof(WCHAR) * *pNameData, sizeof(DWORD))/sizeof(DWORD) + 1;
			}

			if (dwIsObject)
			{
				DWORD dwDefaultCounter = *pData++;
				DWORD dwInstanceLess = *pData++;
				DWORD dwStructSize = *pData++;
				DWORD dwMaxInstanceNameLen = *pData++;

				hr = AddCategoryDefinition(
					dwPerfId,
					strName,
					NULL,
					dwDetailLevel,
					dwDefaultCounter,
					dwInstanceLess,
					dwStructSize,
					dwMaxInstanceNameLen);
				if (FAILED(hr))
				{
					ClearMap();
					return hr;
				}

				DWORD dwNameId = *pData++;
				DWORD dwHelpId = *pData++;
				CategoryInfo* pCategoryInfo = _GetCategoryInfo(_GetNumCategories()-1);
				pCategoryInfo->m_nNameId = dwNameId;
				pCategoryInfo->m_nHelpId = dwHelpId;
			}
			else
			{
				DWORD dwCounterType = *pData++;
				DWORD dwMaxCounterSize = *pData++;
				DWORD dwDataOffset = *pData++;
				DWORD dwDefaultScale = *pData++;

				hr = AddCounterDefinition(
					dwPerfId,
					strName,
					NULL,
					dwDetailLevel,
					dwCounterType,
					dwMaxCounterSize,
					dwDataOffset,
					dwDefaultScale);
				if (FAILED(hr))
				{
					ClearMap();
					return hr;
				}

				DWORD dwNameId = *pData++;
				DWORD dwHelpId = *pData++;
				CategoryInfo* pCategoryInfo = _GetCategoryInfo(_GetNumCategories()-1);
				CounterInfo* pCounterInfo = pCategoryInfo->_GetCounterInfo(pCategoryInfo->_GetNumCounters()-1);
				pCounterInfo->m_nNameId = dwNameId;
				pCounterInfo->m_nHelpId = dwHelpId;
			}
		}

		// fill in cache data
		ULONG* pnCounterBlockSize = NULL; // pointer to the object's counter block size
		for (DWORD i=0; i<_GetNumCategories(); i++)
		{
			CategoryInfo* pCategoryInfo = _GetCategoryInfo(i);
			// align at 8 bytes per Q262335
			pCategoryInfo->m_nCounterBlockSize = (ULONG) AtlAlignUp(sizeof(PERF_COUNTER_BLOCK), 8);
			pnCounterBlockSize = &pCategoryInfo->m_nCounterBlockSize;
			_FillCategoryType(pCategoryInfo);
			for (DWORD j=0; j<pCategoryInfo->_GetNumCounters(); j++)
			{
				CounterInfo* pCounterInfo = pCategoryInfo->_GetCounterInfo(j);
				_FillCounterDef(pCounterInfo, pnCounterBlockSize);
			}
			// align at 8 bytes per Q262335
			pCategoryInfo->m_nCounterBlockSize = (ULONG) AtlAlignUp(pCategoryInfo->m_nCounterBlockSize, 8);
		}

		return S_OK;
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
}

inline HRESULT CPerfMon::_SaveMap() throw()
{
	_ATLTRY
	{
		// figure out how much memory we need
		size_t nSize = (2 + 9*_GetNumCategoriesAndCounters()) * sizeof(DWORD);
		for (UINT i=0; i<_GetNumCategories(); i++)
		{
			// if any of the entries have names, they'd better all have names
			CategoryInfo* pCategoryInfo = _GetCategoryInfo(i);
			if (!pCategoryInfo->m_strName.IsEmpty())
			{
				nSize += sizeof(DWORD) + AtlAlignUp(sizeof(WCHAR) * pCategoryInfo->m_strName.GetLength(), sizeof(DWORD));
				for (UINT j=0; j<pCategoryInfo->_GetNumCounters(); j++)
				{
					CounterInfo* pCounterInfo = pCategoryInfo->_GetCounterInfo(j);
					nSize += sizeof(DWORD) + AtlAlignUp(sizeof(WCHAR) * pCounterInfo->m_strName.GetLength(), sizeof(DWORD));
				}
			}
		}

		CHeapPtr<BYTE> blob;
		if (!blob.Allocate(nSize))
			return E_OUTOFMEMORY;

		// start with blob size and number of items in the blob
		DWORD* pCurrent = reinterpret_cast<DWORD*>(blob.m_pData);
		memset(pCurrent, 0, nSize);
		*pCurrent++ = (DWORD) nSize; // blob size
		*pCurrent++ = _GetNumCategoriesAndCounters(); // number of items
#if _SECURE_ATL
		size_t nSizeLast = nSize;
		nSize -= 2 * sizeof(DWORD);
		if(nSize > nSizeLast) return E_FAIL;
#endif

		for (UINT i=0; i<_GetNumCategories(); i++)
		{
			// add all the relevant runtime info to the blob for each item
			CategoryInfo* pCategoryInfo = _GetCategoryInfo(i);

			*pCurrent++ = TRUE; // is object
			*pCurrent++ = pCategoryInfo->m_dwCategoryId;
			*pCurrent++ = pCategoryInfo->m_dwDetailLevel;
			*pCurrent++ = pCategoryInfo->m_nDefaultCounter;
			*pCurrent++ = pCategoryInfo->m_nInstanceLess;
			*pCurrent++ = pCategoryInfo->m_nStructSize;
			*pCurrent++ = pCategoryInfo->m_nMaxInstanceNameLen;
			*pCurrent++ = pCategoryInfo->m_nNameId;
			*pCurrent++ = pCategoryInfo->m_nHelpId;
#if _SECURE_ATL
			nSizeLast = nSize;
			nSize -= 9 * sizeof(DWORD);
			if(nSize > nSizeLast) return E_FAIL;
#endif

			for (UINT j=0; j<pCategoryInfo->_GetNumCounters(); j++)
			{
				CounterInfo* pCounterInfo = pCategoryInfo->_GetCounterInfo(j);

				*pCurrent++ = FALSE; // is object
				*pCurrent++ = pCounterInfo->m_dwCounterId;
				*pCurrent++ = pCounterInfo->m_dwDetailLevel;
				*pCurrent++ = pCounterInfo->m_dwCounterType;
				*pCurrent++ = pCounterInfo->m_nMaxCounterSize;
				*pCurrent++ = pCounterInfo->m_nDataOffset;
				*pCurrent++ = pCounterInfo->m_nDefaultScale;
				*pCurrent++ = pCounterInfo->m_nNameId;
				*pCurrent++ = pCounterInfo->m_nHelpId;
#if _SECURE_ATL
				nSizeLast = nSize;
				nSize -= 9 * sizeof(DWORD);
				if(nSize > nSizeLast) return E_FAIL;
#endif
			}
		}

		// add names to the blob
		for (UINT i=0; i<_GetNumCategories(); i++)
		{
			CategoryInfo* pCategoryInfo = _GetCategoryInfo(i);
			// copy the len of the string (in characters) then the wide-char version of the string
			// pad the string to a dword boundary
			int nLen = pCategoryInfo->m_strName.GetLength();
			*pCurrent++ = nLen;
#if _SECURE_ATL
			nSizeLast = nSize;
			nSize -= sizeof(DWORD);
			if(nSize > nSizeLast) return E_FAIL;
#endif

			Checked::memcpy_s(pCurrent, nSize, CT2CW(pCategoryInfo->m_strName), sizeof(WCHAR)*nLen);
			pCurrent += AtlAlignUp(sizeof(WCHAR) * nLen, sizeof(DWORD))/sizeof(DWORD);
#if _SECURE_ATL
			nSizeLast = nSize;
			nSize -= sizeof(WCHAR)*nLen;
			if(nSize > nSizeLast) return E_FAIL;
#endif

			for (UINT j=0; j<pCategoryInfo->_GetNumCounters(); j++)
			{
				CounterInfo* pCounterInfo = pCategoryInfo->_GetCounterInfo(j);
				// copy the len of the string (in characters) then the wide-char version of the string
				// pad the string to a dword boundary
				int nCounterLen = pCounterInfo->m_strName.GetLength();
				*pCurrent++ = nCounterLen;
#if _SECURE_ATL
				nSizeLast = nSize;
				nSize -= sizeof(DWORD);
				if(nSize > nSizeLast) return E_FAIL;
#endif

				Checked::memcpy_s(pCurrent, nSize, CT2CW(pCounterInfo->m_strName), sizeof(WCHAR)*nCounterLen);
				pCurrent += AtlAlignUp(sizeof(WCHAR) * nCounterLen, sizeof(DWORD))/sizeof(DWORD);
#if _SECURE_ATL
				nSizeLast = nSize;
				nSize -= sizeof(WCHAR)*nCounterLen;
				if(nSize > nSizeLast) return E_FAIL;
#endif
			}
		}

		CRegKey rkApp;
		CString str;
		DWORD dwErr;

		str.Format(c_szAtlPerfPerformanceKey, GetAppName());
		dwErr = rkApp.Open(HKEY_LOCAL_MACHINE, str);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		rkApp.SetBinaryValue(c_szAtlPerfMap, blob, *LPDWORD(blob.m_pData));

		return S_OK;
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
}

inline CPerfMon::CategoryInfo* CPerfMon::_FindCategoryInfo(DWORD dwCategoryId) throw()
{
	for (UINT i=0; i<_GetNumCategories(); i++)
	{
		CategoryInfo* pCategoryInfo = _GetCategoryInfo(i);
		if (pCategoryInfo->m_dwCategoryId == dwCategoryId)
			return pCategoryInfo;
	}

	return NULL;
}

inline CPerfMon::CounterInfo* CPerfMon::_FindCounterInfo(CategoryInfo* pCategoryInfo, DWORD dwCounterId)
{
	ATLENSURE(pCategoryInfo != NULL);

	for (DWORD i=0; i<pCategoryInfo->_GetNumCounters(); i++)
	{
		CounterInfo* pCounter = pCategoryInfo->_GetCounterInfo(i);
		if (pCounter->m_dwCounterId == dwCounterId)
			return pCounter;
	}

	return NULL;
}

inline CPerfMon::CounterInfo* CPerfMon::_FindCounterInfo(DWORD dwCategoryId, DWORD dwCounterId) throw()
{
	CategoryInfo* pCategoryInfo = _FindCategoryInfo(dwCategoryId);
	if (pCategoryInfo != NULL)
		return _FindCounterInfo(pCategoryInfo, dwCounterId);

	return NULL;
}

inline BOOL CPerfMon::_WantCategoryType(__in_z LPWSTR szValue, __in DWORD dwCategoryId) throw(...)
{
	ATLASSERT(szValue != NULL);

	if (lstrcmpiW(c_szAtlPerfGlobal, szValue) == 0)
		return TRUE;

	CString strList(szValue);
	int nStart = 0;

	CString strNum = strList.Tokenize(_T(" "), nStart);
	while (!strNum.IsEmpty())
	{
		if (_ttoi(strNum) == int(dwCategoryId))
			return TRUE;

		strNum = strList.Tokenize(_T(" "), nStart);
	}

	return FALSE;
}

inline LPBYTE CPerfMon::_AllocData(LPBYTE& pData, ULONG nBytesAvail, ULONG* pnBytesUsed, size_t nBytesNeeded)
{
	ATLENSURE(pnBytesUsed != NULL);
	ULONG newSize = *pnBytesUsed+static_cast<ULONG>(nBytesNeeded);

	if ((newSize < *pnBytesUsed) || (newSize < (ULONG) nBytesNeeded) || (nBytesAvail < newSize))
		return NULL;

	LPBYTE p = pData;
	pData += nBytesNeeded;
	*pnBytesUsed += (ULONG) nBytesNeeded;

	return p;
}

inline DWORD& CPerfMon::_GetBlockId(CAtlFileMappingBase* pBlock) 
{
	ATLENSURE(pBlock != NULL);

	return *LPDWORD(LPBYTE(pBlock->GetData()) + m_nSchemaSize);
}

inline void CPerfMon::_FillCategoryType(CategoryInfo* pCategoryInfo) throw()
{
	PERF_OBJECT_TYPE& type = pCategoryInfo->m_cache;
    type.DefinitionLength = sizeof(PERF_OBJECT_TYPE) + sizeof(PERF_COUNTER_DEFINITION) * pCategoryInfo->_GetNumCounters();
    type.TotalByteLength = type.DefinitionLength; // we will add the instance definitions/counter blocks as we go
    type.HeaderLength = sizeof(PERF_OBJECT_TYPE);
    type.ObjectNameTitleIndex = pCategoryInfo->m_nNameId;
    type.ObjectNameTitle = NULL;
    type.ObjectHelpTitleIndex = pCategoryInfo->m_nHelpId;
    type.ObjectHelpTitle = NULL;
    type.DetailLevel = pCategoryInfo->m_dwDetailLevel;
    type.NumCounters = pCategoryInfo->_GetNumCounters();
    type.DefaultCounter = pCategoryInfo->m_nDefaultCounter;
	if (pCategoryInfo->m_nInstanceLess == PERF_NO_INSTANCES)
		type.NumInstances = PERF_NO_INSTANCES;
	else
		type.NumInstances = 0; // this will be calculated as objects are processed
    type.CodePage = 0;
    type.PerfTime.QuadPart = 0;
    QueryPerformanceFrequency (&(type.PerfFreq));
}

inline void CPerfMon::_FillCounterDef(CounterInfo* pCounterInfo, ULONG* pnCounterBlockSize) throw()
{
	PERF_COUNTER_DEFINITION& def = pCounterInfo->m_cache;

	def.ByteLength = sizeof(PERF_COUNTER_DEFINITION);
	def.CounterNameTitleIndex = pCounterInfo->m_nNameId;
	def.CounterNameTitle = NULL;
	def.CounterHelpTitleIndex = pCounterInfo->m_nHelpId;
	def.CounterHelpTitle = NULL;
	def.DefaultScale = pCounterInfo->m_nDefaultScale;
	def.DetailLevel = pCounterInfo->m_dwDetailLevel;
	def.CounterType = pCounterInfo->m_dwCounterType;
	DWORD dwAlignOfCounter=0;
	switch (pCounterInfo->m_dwCounterType & ATLPERF_SIZE_MASK)
	{
	case PERF_SIZE_DWORD:
		def.CounterSize = sizeof(DWORD);
		dwAlignOfCounter = sizeof(DWORD);
		break;
	case PERF_SIZE_LARGE:
		def.CounterSize = sizeof(__int64);
		dwAlignOfCounter = sizeof(__int64);
		break;
	case PERF_SIZE_ZERO:
		def.CounterSize = 0;
		dwAlignOfCounter = 0;
		break;
	case PERF_SIZE_VARIABLE_LEN:
		ATLASSERT((pCounterInfo->m_dwCounterType & ATLPERF_TYPE_MASK) == PERF_TYPE_TEXT);
		if ((pCounterInfo->m_dwCounterType & ATLPERF_TEXT_MASK) == PERF_TEXT_UNICODE)
		{
			def.CounterSize = (DWORD) AtlAlignUp(pCounterInfo->m_nMaxCounterSize * sizeof(WCHAR), sizeof(DWORD));
		}
		else
		{
			def.CounterSize = (DWORD) AtlAlignUp(pCounterInfo->m_nMaxCounterSize * sizeof(char), sizeof(DWORD));
		}
		break;
	}
	*pnCounterBlockSize = AtlAlignUp(*pnCounterBlockSize, dwAlignOfCounter);
	def.CounterOffset = *pnCounterBlockSize;
	*pnCounterBlockSize += def.CounterSize;
}

inline HRESULT CPerfMon::_CollectInstance(
	CategoryInfo* pCategoryInfo,
	LPBYTE& pData,
	ULONG nBytesAvail,
	ULONG* pnBytesUsed,
	CPerfObject* _pInstance,
	PERF_OBJECT_TYPE* pObjectType,
	PERF_COUNTER_DEFINITION* pCounterDefs
	) throw()
{
	DWORD dwInstance = _pInstance->m_dwInstance;

	// grab a snapshot of the object
	USES_ATL_SAFE_ALLOCA;
	CPerfObject* pInstance = (CPerfObject*) _ATL_SAFE_ALLOCA(_pInstance->m_nAllocSize, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	if (pInstance == NULL)
	{
		return E_OUTOFMEMORY;
	}
	Checked::memcpy_s(pInstance, _pInstance->m_nAllocSize, _pInstance, _pInstance->m_nAllocSize);

	// if it was changed or deleted between when we first saw it and when we copied
	// it, then forget about whatever happens to be there for this collection period
	if (pInstance->m_dwCategoryId != pCategoryInfo->m_dwCategoryId ||
			dwInstance != pInstance->m_dwInstance ||
			pInstance->m_nRefCount == 0)
		return S_OK;

	// we have a copy of something that claims to be the object type we're expecting
	// put it into the data blob
	PERF_INSTANCE_DEFINITION* pInstanceDef = NULL;

	if (pCategoryInfo->m_nInstanceLess == PERF_NO_INSTANCES)
		pObjectType->NumInstances = PERF_NO_INSTANCES;
	else
	{
		pObjectType->NumInstances++;

		// create an instance definition
		pInstanceDef = _AllocStruct(pData, nBytesAvail, pnBytesUsed, (PERF_INSTANCE_DEFINITION*) NULL);
		if (pInstanceDef == NULL)
			return E_OUTOFMEMORY;

		pInstanceDef->ParentObjectTitleIndex = 0;
		pInstanceDef->ParentObjectInstance = 0;
		pInstanceDef->UniqueID = PERF_NO_UNIQUE_ID;

		// handle the instance name
		LPCWSTR szInstNameSrc = LPCWSTR(LPBYTE(pInstance)+pInstance->m_nInstanceNameOffset);
		pInstanceDef->NameLength = (ULONG)(wcslen(szInstNameSrc)+1)*sizeof(WCHAR);
		// align at 8 bytes per Q262335
		ULONG nNameAlloc = (ULONG) AtlAlignUp(pInstanceDef->NameLength, 8);
		LPWSTR szInstNameDest = (LPWSTR) _AllocData(pData, nBytesAvail, pnBytesUsed, nNameAlloc);
		if (szInstNameDest == NULL)
			return E_OUTOFMEMORY;

		Checked::memcpy_s(szInstNameDest, nNameAlloc, szInstNameSrc, pInstanceDef->NameLength);
		pInstanceDef->NameOffset = ULONG(LPBYTE(szInstNameDest) - LPBYTE(pInstanceDef));

		pInstanceDef->ByteLength = DWORD(sizeof(PERF_INSTANCE_DEFINITION) + nNameAlloc);
	}

	// create the counter block + data
	LPBYTE pCounterData = _AllocData(pData, nBytesAvail, pnBytesUsed, pCategoryInfo->m_nCounterBlockSize);
	if (pCounterData == NULL)
		return E_OUTOFMEMORY;

	// fill in the counter block header for the data
	PERF_COUNTER_BLOCK* pCounterBlock = (PERF_COUNTER_BLOCK*) pCounterData;
	pCounterBlock->ByteLength = pCategoryInfo->m_nCounterBlockSize;

	// fill in the data
	for (ULONG i=0; i<pObjectType->NumCounters; i++)
	{
		CounterInfo* pCounterInfo = pCategoryInfo->_GetCounterInfo(i);
		PERF_COUNTER_DEFINITION& def = pCounterDefs[i];
		LPBYTE pSrc = LPBYTE(pInstance)+pCounterInfo->m_nDataOffset;
		LPBYTE pDest = pCounterData+def.CounterOffset;
		switch (pCounterInfo->m_dwCounterType & ATLPERF_SIZE_MASK)
		{
		case PERF_SIZE_DWORD:
			*LPDWORD(pDest) = *LPDWORD(pSrc);
			break;
		case PERF_SIZE_LARGE:
			 *(ULONGLONG*)(pDest) =  *(ULONGLONG*)(pSrc);
			break;
		case PERF_SIZE_VARIABLE_LEN:
			if ((pCounterInfo->m_dwCounterType & ATLPERF_TEXT_MASK) == PERF_TEXT_UNICODE)
			{
				LPCWSTR szSrc = reinterpret_cast<LPCWSTR>(pSrc);
				LPWSTR szDest = reinterpret_cast<LPWSTR>(pDest);
				size_t nLen = __min(wcslen(szSrc), pCounterInfo->m_nMaxCounterSize-1);
				Checked::wcsncpy_s(szDest, pCounterInfo->m_nMaxCounterSize-1, szSrc, nLen);
				szDest[nLen] = 0;
			}
			else
			{
				LPCSTR szSrc = reinterpret_cast<LPCSTR>(pSrc);
				LPSTR szDest = reinterpret_cast<LPSTR>(pDest);
				size_t nLen = __min(strlen(szSrc), pCounterInfo->m_nMaxCounterSize-1);
				Checked::strncpy_s(szDest, pCounterInfo->m_nMaxCounterSize-1, szSrc, nLen);
				szDest[nLen] = 0;
			}
			break;
		}
	}

	if (pInstanceDef != NULL)
		pObjectType->TotalByteLength += pInstanceDef->ByteLength;
	pObjectType->TotalByteLength += pCounterBlock->ByteLength;

	return S_OK;
}

inline HRESULT CPerfMon::_CollectInstance(
	CategoryInfo* pCategoryInfo,
	LPBYTE& pData,
	ULONG nBytesAvail,
	ULONG* pnBytesUsed,
	PERF_OBJECT_TYPE* pObjectType,
	PERF_COUNTER_DEFINITION* pCounterDefs
	) throw()
{
	// specialization to collect an instanceless object with no instance data
	ATLASSERT(pCategoryInfo->m_nInstanceLess == PERF_NO_INSTANCES);
	pObjectType->NumInstances = PERF_NO_INSTANCES;

	// create the counter block + data
	LPBYTE pCounterData = _AllocData(pData, nBytesAvail, pnBytesUsed, pCategoryInfo->m_nCounterBlockSize);
	if (pCounterData == NULL)
		return E_OUTOFMEMORY;

	// fill in the counter block header for the data
	PERF_COUNTER_BLOCK* pCounterBlock = (PERF_COUNTER_BLOCK*) pCounterData;
	pCounterBlock->ByteLength = pCategoryInfo->m_nCounterBlockSize;

	// fill in the data
	for (ULONG i=0; i<pObjectType->NumCounters; i++)
	{
		CounterInfo* pCounterInfo = pCategoryInfo->_GetCounterInfo(i);
		PERF_COUNTER_DEFINITION& def = pCounterDefs[i];
		LPBYTE pDest = pCounterData+def.CounterOffset;
		switch (pCounterInfo->m_dwCounterType & ATLPERF_SIZE_MASK)
		{
		case PERF_SIZE_DWORD:
			*LPDWORD(pDest) = 0;
			break;
		case PERF_SIZE_LARGE:
			*PULONGLONG(pDest) = 0;
			break;
		case PERF_SIZE_VARIABLE_LEN:
			if ((pCounterInfo->m_dwCounterType & ATLPERF_TEXT_MASK) == PERF_TEXT_UNICODE)
				memset(pDest, 0, pCounterInfo->m_nMaxCounterSize*sizeof(WCHAR));
			else
				memset(pDest, 0, pCounterInfo->m_nMaxCounterSize*sizeof(CHAR));
			break;
		}
	}

	pObjectType->TotalByteLength += pCounterBlock->ByteLength;

	return S_OK;
}

inline HRESULT CPerfMon::_CollectCategoryType(
	CategoryInfo* pCategoryInfo,
	LPBYTE pData,
	ULONG nBytesAvail,
	ULONG* pnBytesUsed
	) throw()
{
	ATLENSURE_RETURN(pCategoryInfo != NULL);
	ATLASSERT(pnBytesUsed != NULL);

	// write the object definition out
	PERF_OBJECT_TYPE* pObjectType = _AllocStruct(pData, nBytesAvail, pnBytesUsed, (PERF_OBJECT_TYPE*) NULL);
	if (pObjectType == NULL)
		return E_OUTOFMEMORY;

	Checked::memcpy_s(pObjectType, sizeof(PERF_OBJECT_TYPE), &pCategoryInfo->m_cache, sizeof(PERF_OBJECT_TYPE));

	// save a pointer to the first counter entry and counter definition.
	// we'll need them when we create the PERF_COUNTER_BLOCK data
	PERF_COUNTER_DEFINITION* pCounterDefs = reinterpret_cast<PERF_COUNTER_DEFINITION*>(pData);

	// write the counter definitions out
	for (DWORD i=0; i<pCategoryInfo->_GetNumCounters(); i++)
	{
		CounterInfo* pCounterInfo = pCategoryInfo->_GetCounterInfo(i);

		PERF_COUNTER_DEFINITION* pCounterDef = _AllocStruct(pData, nBytesAvail, pnBytesUsed, (PERF_COUNTER_DEFINITION*) NULL);
		if (pCounterDef == NULL)
			return E_OUTOFMEMORY;

		Checked::memcpy_s(pCounterDef, sizeof(PERF_COUNTER_DEFINITION), &pCounterInfo->m_cache, sizeof(PERF_COUNTER_DEFINITION));
	}

	// search for objects of the appropriate type and write out their instance/counter data
	bool bGotInstance = false;

	CAtlFileMappingBase* pCurrentBlock = _GetNextBlock(NULL);
	if (pCurrentBlock != NULL)
	{
		CPerfObject* pInstance = _GetFirstInstance(pCurrentBlock);
		while (pInstance && pInstance->m_nAllocSize != 0)
		{
			if (pInstance->m_dwCategoryId == pCategoryInfo->m_dwCategoryId)
			{
				bGotInstance = true;
				HRESULT hr = _CollectInstance(pCategoryInfo, pData, nBytesAvail,
						pnBytesUsed, pInstance, pObjectType, pCounterDefs);
				if (FAILED(hr))
					return hr;
			}

			pInstance = _GetNextInstance(pInstance);
			if (pInstance->m_nAllocSize == (ULONG) -1)
			{
				pCurrentBlock = _GetNextBlock(pCurrentBlock);
				if (pCurrentBlock == NULL)
					pInstance = NULL;
				else
					pInstance = _GetFirstInstance(pCurrentBlock);
			}
		}
	}

	if (pCategoryInfo->m_nInstanceLess == PERF_NO_INSTANCES && !bGotInstance)
	{
		// we have an instanceless (singleton) object with no data. send zeroed data
		HRESULT hr = _CollectInstance(pCategoryInfo, pData, nBytesAvail,
				pnBytesUsed, pObjectType, pCounterDefs);
		if (FAILED(hr))
			return hr;
	}

	return S_OK;
}

inline DWORD CPerfMon::Open(LPWSTR szDeviceNames) throw()
{
	(szDeviceNames); // unused

	return 0;
}

inline DWORD CPerfMon::Collect(
	__in_z LPWSTR szValue,
	__deref_inout_bcount(*pcbBytes) LPVOID* ppData,
	__inout LPDWORD pcbBytes,
	__inout LPDWORD pcObjectTypes
	) throw()
{

 
 


	_ATLTRY
	{
		if (FAILED(_OpenAllBlocks()))
		{
			*pcbBytes = 0;
			*pcObjectTypes = 0;
			return ERROR_SUCCESS;
		}

		LPBYTE pData = LPBYTE(*ppData);
		ULONG nBytesLeft = *pcbBytes;
		*pcbBytes = 0;

		if (_GetNumCategories() == 0)
		{
			// nothing is providing data. we need to load the map directly
			// from the registry in order to provide category/counter data
			CRegKey rkApp;
			DWORD dwErr;
			CString strAppKey;

			strAppKey.Format(c_szAtlPerfPerformanceKey, GetAppName());

			dwErr = rkApp.Open(HKEY_LOCAL_MACHINE, strAppKey, KEY_READ);
			if (dwErr != ERROR_SUCCESS)
			{
				*pcbBytes = 0;
				*pcObjectTypes = 0;
				return ERROR_SUCCESS;
			}

			ULONG nBytes = 0;
			dwErr = rkApp.QueryBinaryValue(c_szAtlPerfMap, NULL, &nBytes);
			if (dwErr != ERROR_SUCCESS)
			{
				*pcbBytes = 0;
				*pcObjectTypes = 0;
				return ERROR_SUCCESS;
			}

			CHeapPtr<DWORD> buf;
			if (!buf.Allocate((nBytes+3)/4))
			{
				*pcbBytes = 0;
				*pcObjectTypes = 0;
				return ERROR_SUCCESS;
			}

			dwErr = rkApp.QueryBinaryValue(c_szAtlPerfMap, buf, &nBytes);
			if (dwErr != ERROR_SUCCESS)
			{
				*pcbBytes = 0;
				*pcObjectTypes = 0;
				return ERROR_SUCCESS;
			}

			if (FAILED(_LoadMap(buf)))
			{
				*pcbBytes = 0;
				*pcObjectTypes = 0;
				return ERROR_SUCCESS;
			}
		}

		for (UINT i=0; i<_GetNumCategories(); i++)
		{
			CategoryInfo* pCategoryInfo = _GetCategoryInfo(i);
			if (_WantCategoryType(szValue, pCategoryInfo->m_nNameId))
			{
				ULONG nBytesUsed = 0;
				HRESULT hr = _CollectCategoryType(pCategoryInfo, pData, nBytesLeft, &nBytesUsed);
				if (hr == E_OUTOFMEMORY)
				{
					*pcbBytes = 0;
					*pcObjectTypes = 0;
					return ERROR_MORE_DATA;
				}
				else if (FAILED(hr))
				{
					*pcbBytes = 0;
					*pcObjectTypes = 0;
					return ERROR_SUCCESS;
				}

				(*pcObjectTypes)++;
				(*pcbBytes) += nBytesUsed;
				nBytesLeft -= nBytesUsed;
				pData += nBytesUsed;
			}
		}

		*ppData = pData;
		return ERROR_SUCCESS;
	}
	_ATLCATCHALL()
	{
		*pcbBytes = 0;
		*pcObjectTypes = 0;
		return ERROR_SUCCESS;
	}
}

inline DWORD CPerfMon::Close() throw()
{
	UnInitialize();
	return ERROR_SUCCESS;
}

#ifdef _ATL_PERF_REGISTER
#pragma warning (push)
#pragma warning(disable : 4996)

inline void CPerfMon::_AppendStrings(
	LPTSTR& pszNew,
	CAtlArray<CString>& astrStrings,
	ULONG iFirstIndex
	) throw()
{
	for (UINT iString = 0; iString < astrStrings.GetCount(); iString++)
	{
		INT nFormatChars = _stprintf(pszNew, _T("%d"), iFirstIndex+2*iString);
		pszNew += nFormatChars + 1;
		_tcscpy(pszNew, astrStrings[iString]);
		pszNew += astrStrings[iString].GetLength() + 1;
	}
}

#pragma warning (pop)

inline HRESULT CPerfMon::_AppendRegStrings(
	CRegKey& rkLang,
	LPCTSTR szValue,
	CAtlArray<CString>& astrStrings,
	ULONG nNewStringSize,
	ULONG iFirstIndex,
	ULONG iLastIndex
	) throw()
{
	_ATLTRY
	{
		// load the existing strings, add the new data, and resave the strings
		ULONG nCharsOrig = 0;
		ULONG nCharsNew;
		DWORD dwErr;

		dwErr = rkLang.QueryMultiStringValue(szValue, NULL, &nCharsOrig);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		nCharsNew = nCharsOrig + nNewStringSize;

		CString strOrig;
		dwErr = rkLang.QueryMultiStringValue(szValue, CStrBuf(strOrig, nCharsOrig, CStrBuf::SET_LENGTH), &nCharsOrig);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);
		LPCTSTR pszOrig = strOrig;

		CString strNew;
		CStrBuf szNew(strNew, nCharsNew, CStrBuf::SET_LENGTH);
		LPTSTR pszNew = szNew;

		bool bNewStringsAdded = false;

		while (*pszOrig != '\0')
		{
			ULONG iIndex = _ttoi(pszOrig);
			int nLen = (int) _tcslen(pszOrig) + 1; // get the length of the index and null
			nLen += (int) _tcslen(pszOrig+nLen) + 1; // add the length of the description and null

			if (!bNewStringsAdded && iIndex >= iFirstIndex)
			{
#if _SECURE_ATL
				LPTSTR pszOld =pszNew;
#endif
				_AppendStrings(pszNew, astrStrings, iFirstIndex);
				bNewStringsAdded = true;
#if _SECURE_ATL
				ULONG nCharsNewLast = nCharsNew;
				nCharsNew -= ULONG(pszNew-pszOld);
				if(nCharsNew > nCharsNewLast) 
                {
                    return E_FAIL;
                }
#endif
			}

			if (iIndex < iFirstIndex || iIndex > iLastIndex)
			{
				Checked::memmove_s(pszNew, nCharsNew, pszOrig, nLen*sizeof(TCHAR));
				pszNew += nLen;
			}
			pszOrig += nLen;
		}
		if (!bNewStringsAdded)
			_AppendStrings(pszNew, astrStrings, iFirstIndex);

		*pszNew++ = '\0'; // must have 2 null terminators at end of multi_sz

		dwErr = rkLang.SetMultiStringValue(szValue, strNew);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		return S_OK;
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
}

inline HRESULT CPerfMon::_RemoveRegStrings(
	CRegKey& rkLang,
	LPCTSTR szValue,
	ULONG iFirstIndex,
	ULONG iLastIndex
	) throw()
{
	_ATLTRY
	{
		// load the existing strings, remove the data, and resave the strings
		DWORD nChars = 0;
		DWORD dwErr;
		
		dwErr = rkLang.QueryMultiStringValue(szValue, NULL, &nChars);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		CString str;
		CStrBuf szBuf(str, nChars, CStrBuf::SET_LENGTH);
		DWORD nMaxLen = nChars*sizeof(TCHAR);

		dwErr = rkLang.QueryMultiStringValue(szValue, szBuf, &nChars);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		LPCTSTR pszRead = szBuf;
		LPTSTR pszWrite = szBuf;
		while (*pszRead != '\0')
		{
			ULONG iIndex = _ttoi(pszRead);
			int nLen = (int) _tcslen(pszRead) + 1; // get the length of the index and null
			nLen += (int) _tcslen(pszRead+nLen) + 1; // add the length of the description and null
			if (iIndex < iFirstIndex || iIndex > iLastIndex)
			{
				Checked::memmove_s(pszWrite, nMaxLen , pszRead, nLen*sizeof(TCHAR));
#if _SECURE_ATL
				UINT nMaxLenLast = nMaxLen;
				nMaxLen -= nLen*sizeof(TCHAR);
				if(nMaxLen > nMaxLenLast) return E_FAIL;
#endif
				pszWrite += nLen;
			}
			pszRead += nLen;
		}
		*pszWrite++ = '\0'; // must have 2 null terminators at end of multi_sz

		dwErr = rkLang.SetMultiStringValue(szValue, szBuf);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		return S_OK;
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
}

inline HRESULT CPerfMon::_ReserveStringRange(DWORD& dwFirstCounter, DWORD& dwFirstHelp) throw()
{
	CRegKey rkApp;
	CString strAppKey;
	DWORD dwErr;

	_ATLTRY
	{
		strAppKey.Format(c_szAtlPerfPerformanceKey, GetAppName());
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}

	DWORD nNumStrings = _GetNumCategoriesAndCounters();

	dwErr = rkApp.Open(HKEY_LOCAL_MACHINE, strAppKey);
	if (dwErr == ERROR_SUCCESS)
	{
		// see if we already have a sufficient range reserved
		DWORD dwFirstAppCounter;
		DWORD dwFirstAppHelp;
		DWORD dwLastAppCounter;
		DWORD dwLastAppHelp;

		if (rkApp.QueryDWORDValue(c_szAtlPerfFirstCounter, dwFirstAppCounter) == ERROR_SUCCESS &&
				rkApp.QueryDWORDValue(c_szAtlPerfFirstHelp, dwFirstAppHelp) == ERROR_SUCCESS &&
				rkApp.QueryDWORDValue(c_szAtlPerfLastCounter, dwLastAppCounter) == ERROR_SUCCESS &&
				rkApp.QueryDWORDValue(c_szAtlPerfLastHelp, dwLastAppHelp) == ERROR_SUCCESS &&
				dwLastAppCounter-dwFirstAppCounter+2 >= 2*nNumStrings &&
				dwLastAppHelp-dwFirstAppHelp+2 >= 2*nNumStrings)
		{
			dwFirstCounter = dwFirstAppCounter;
			dwFirstHelp = dwFirstAppHelp;
			return S_OK;
		}
	}

	CRegKey rkPerfLib;

	dwErr = rkPerfLib.Open(HKEY_LOCAL_MACHINE, c_szAtlPerfPerfLibKey);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	if (!rkApp)
	{
		dwErr = rkApp.Create(HKEY_LOCAL_MACHINE, strAppKey);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);
	}

	// figure out the counter range
	DWORD dwLastCounter;
	DWORD dwLastHelp;

	dwErr = rkPerfLib.QueryDWORDValue(c_szAtlPerfLastCounter, dwLastCounter);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkPerfLib.QueryDWORDValue(c_szAtlPerfLastHelp, dwLastHelp);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwFirstCounter = dwLastCounter + 2;
	dwFirstHelp = dwLastHelp + 2;
	dwLastCounter += 2*nNumStrings;
	dwLastHelp += 2*nNumStrings;

	dwErr = rkPerfLib.SetDWORDValue(c_szAtlPerfLastCounter, dwLastCounter);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkPerfLib.SetDWORDValue(c_szAtlPerfLastHelp, dwLastHelp);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	// register the used counter range
	dwErr = rkApp.SetDWORDValue(c_szAtlPerfFirstCounter, dwFirstCounter);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.SetDWORDValue(c_szAtlPerfLastCounter, dwLastCounter);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.SetDWORDValue(c_szAtlPerfFirstHelp, dwFirstHelp);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.SetDWORDValue(c_szAtlPerfLastHelp, dwLastHelp);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	return S_OK;
}

inline HRESULT CPerfMon::Register(
	LPCTSTR szOpenFunc,
	LPCTSTR szCollectFunc,
	LPCTSTR szCloseFunc,
	HINSTANCE hDllInstance /* == _AtlBaseModule.GetModuleInstance() */
	) throw()
{
	ATLASSERT(szOpenFunc != NULL);
	ATLASSERT(szCollectFunc != NULL);
	ATLASSERT(szCloseFunc != NULL);

	CString str;
	DWORD dwErr;
	HRESULT hr;
   	hr = CreateMap(LANGIDFROMLCID(GetThreadLocale()), hDllInstance);
	if (FAILED(hr)){
		hr = CreateMap(LANGIDFROMLCID(1033), hDllInstance);
		if (FAILED(hr))
		return hr;
	}

	CString strAppKey;
	_ATLTRY
	{
		strAppKey.Format(c_szAtlPerfPerformanceKey, GetAppName());
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}

	// if we're already registered, unregister so we can redo registration
	_UnregisterStrings();
	
	// reserve a range for our counter and help strings
	DWORD dwFirstCounter = 0;
	DWORD dwFirstHelp = 0;
	hr = _ReserveStringRange(dwFirstCounter, dwFirstHelp);
	if (FAILED(hr))
		return hr;

	DWORD dwCurrentName = dwFirstCounter;
	DWORD dwCurrentHelp = dwFirstHelp;
	for (UINT i=0; i<_GetNumCategories(); i++)
	{
		CategoryInfo* pCategoryInfo = _GetCategoryInfo(i);

		pCategoryInfo->m_nNameId = dwCurrentName;
		dwCurrentName += 2;
		pCategoryInfo->m_nHelpId = dwCurrentHelp;
		dwCurrentHelp += 2;

		for (UINT j=0; j<pCategoryInfo->_GetNumCounters(); j++)
		{
			CounterInfo* pCounterInfo = pCategoryInfo->_GetCounterInfo(j);

			pCounterInfo->m_nNameId = dwCurrentName;
			dwCurrentName += 2;
			pCounterInfo->m_nHelpId = dwCurrentHelp;
			dwCurrentHelp += 2;
		}
	}

	// register the app entry points
	CRegKey rkApp;

	dwErr = rkApp.Create(HKEY_LOCAL_MACHINE, strAppKey);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	_ATLTRY
	{
		DWORD dwFLen = GetModuleFileName(hDllInstance, CStrBuf(str, MAX_PATH), MAX_PATH);
		if( dwFLen == 0 )
			return AtlHresultFromLastError();
		else if( dwFLen == MAX_PATH )
			return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}

	dwErr = rkApp.SetStringValue(c_szAtlPerfLibrary, str);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.SetStringValue(c_szAtlPerfOpen, szOpenFunc);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.SetStringValue(c_szAtlPerfCollect, szCollectFunc);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.SetStringValue(c_szAtlPerfClose, szCloseFunc);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.SetStringValue(c_szAtlPerfLanguages, _T(""));
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	hr = _SaveMap();
	if (FAILED(hr))
		return hr;

	// if the dll is disabled, reenable it since we just reregistered it
	rkApp.DeleteValue(_T("Disable Performance Counters"));

	return S_OK;
}

inline HRESULT CPerfMon::RegisterStrings(
	LANGID language /* = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL) */,
	HINSTANCE hResInstance /* = _AtlBaseModule.GetResourceInstance() */
	) throw()
{
	_ATLTRY
	{
		CString str;
		DWORD dwErr;
		HRESULT hr;
		CRegKey rkLang;
		CRegKey rkApp;

		LANGID wPrimaryLanguage = (LANGID) PRIMARYLANGID(language);

		if (language == MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
		{
			//First try current thread locale
			language = LANGIDFROMLCID(GetThreadLocale());
			wPrimaryLanguage = (LANGID) PRIMARYLANGID(language);

			str.Format(c_szAtlPerfPerfLibLangKey, wPrimaryLanguage);
			dwErr = rkLang.Open(HKEY_LOCAL_MACHINE, str);
			if (dwErr == ERROR_FILE_NOT_FOUND)
			{
				// failed using current thread, so try default system lcid
				language = GetSystemDefaultLangID();
				wPrimaryLanguage = (LANGID) PRIMARYLANGID(language);
				str.Format(c_szAtlPerfPerfLibLangKey, wPrimaryLanguage);
				dwErr = rkLang.Open(HKEY_LOCAL_MACHINE, str);
			}
			if (dwErr == ERROR_FILE_NOT_FOUND)
				return S_FALSE; // the language isn't installed on the system
			if (dwErr != ERROR_SUCCESS)
				return AtlHresultFromWin32(dwErr);
		}

		hr = CreateMap(language, hResInstance);
		if (FAILED(hr))
			return hr;

		// load list of language strings already registered
		str.Format(c_szAtlPerfPerformanceKey, GetAppName());
		dwErr = rkApp.Open(HKEY_LOCAL_MACHINE, str);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		DWORD dwLangsLen = 0;
		CString strLangs;

		dwErr = rkApp.QueryStringValue(c_szAtlPerfLanguages, NULL, &dwLangsLen);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		ULONG nLangsBuffSize = dwLangsLen+4;
		CStrBuf szLangs(strLangs, nLangsBuffSize, CStrBuf::SET_LENGTH); // reserve room for adding new language
		dwErr = rkApp.QueryStringValue(c_szAtlPerfLanguages, szLangs, &dwLangsLen);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);
		dwLangsLen--; // don't count '\0'

		// see if this language has already been registered and if so, return
		TCHAR szNewLang[5];
#if _SECURE_ATL
		_sntprintf_s(szNewLang, _countof(szNewLang), _countof(szNewLang)-1, _T("%3.3x "), wPrimaryLanguage);
#else
		_sntprintf(szNewLang, sizeof(szNewLang)/ sizeof(TCHAR), _T("%3.3x "), wPrimaryLanguage);
#endif
		if (strLangs.Find(szNewLang) != -1)
			return S_OK;

		// load the strings we want to append and figure out how much extra space is needed for them
		// (including up to 5-digit index values and 2 null separators)
		CAtlArray<CString> astrCounters;
		CAtlArray<CString> astrHelp;
		ULONG nNewCounterSize = 0;
		ULONG nNewHelpSize = 0;

		for (UINT i=0; i<_GetNumCategories(); i++)
		{
			CategoryInfo* pCategoryInfo = _GetCategoryInfo(i);

			astrCounters.Add(pCategoryInfo->m_strName);
			astrHelp.Add(pCategoryInfo->m_strHelp);

			for (UINT j=0; j<pCategoryInfo->_GetNumCounters(); j++)
			{
				CounterInfo* pCounterInfo = pCategoryInfo->_GetCounterInfo(j);

				astrCounters.Add(pCounterInfo->m_strName);
				astrHelp.Add(pCounterInfo->m_strHelp);
			}
		}

		for (size_t i=0; i<astrCounters.GetCount(); i++)
		{
			nNewCounterSize += astrCounters[i].GetLength() + 7;
			nNewHelpSize += astrHelp[i].GetLength() + 7;
		}

		DWORD dwFirstCounter;
		DWORD dwFirstHelp;
		DWORD dwLastCounter;
		DWORD dwLastHelp;

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfFirstCounter, dwFirstCounter);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfFirstHelp, dwFirstHelp);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfLastCounter, dwLastCounter);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfLastHelp, dwLastHelp);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		hr = _AppendRegStrings(rkLang, c_szAtlPerfCounter, astrCounters, nNewCounterSize, dwFirstCounter, dwLastCounter);
		if (FAILED(hr))
			return hr;

		hr = _AppendRegStrings(rkLang, c_szAtlPerfHelp, astrHelp, nNewHelpSize, dwFirstHelp, dwLastHelp);
		if (FAILED(hr))
			return hr;

		// add the language to the list of installed languages
		Checked::tcscpy_s(szLangs+dwLangsLen, nLangsBuffSize-dwLangsLen, szNewLang);

		dwErr = rkApp.SetStringValue(c_szAtlPerfLanguages, szLangs);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		return S_OK;
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
}

inline BOOL CPerfMon::EnumResLangProc(
	HINSTANCE hModule,
	LPCTSTR szType,
	LPCTSTR szName,
	LANGID wIDLanguage,
	LPARAM lParam
	) throw()
{
	hModule; // unused
	szType; // unused
	szName; // unused

	CAtlArray<LANGID>* pLangs = reinterpret_cast<CAtlArray<LANGID>*>(lParam);
	_ATLTRY
	{
		pLangs->Add(wIDLanguage);
	}
	_ATLCATCHALL()
	{
		return FALSE;
	}

	return TRUE;
}

inline HRESULT CPerfMon::RegisterAllStrings(
	HINSTANCE hResInstance /* = NULL */
	) throw()
{
	HRESULT hrReturn = S_FALSE;
	HRESULT hr;

	UINT nRes;
	hr = CreateMap(0, hResInstance, &nRes);
	if (FAILED(hr))
		return hr;

	if (nRes == 0)
		return RegisterStrings(0, hResInstance);

	if (hResInstance != NULL)
		return _RegisterAllStrings(nRes, hResInstance);

	for (int i = 0; hResInstance = _AtlBaseModule.GetHInstanceAt(i), hResInstance != NULL; i++)
	{
		hr = _RegisterAllStrings(nRes, hResInstance);
		if (FAILED(hr))
			return hr;
		if (hr == S_OK)
			hrReturn = S_OK;
	}

	return hrReturn;
}

inline HRESULT CPerfMon::_RegisterAllStrings(
	UINT nRes,
	HINSTANCE hResInstance
	) throw()
{
	HRESULT hrReturn = S_FALSE;
	HRESULT hr;

	CAtlArray<LANGID> langs;
	if (!EnumResourceLanguages(hResInstance, RT_STRING, MAKEINTRESOURCE((nRes>>4)+1), EnumResLangProc, reinterpret_cast<LPARAM>(&langs)))
		return AtlHresultFromLastError();

	for (UINT i=0; i<langs.GetCount(); i++)
	{
		hr = RegisterStrings(langs[i], hResInstance);
		if (FAILED(hr))
			return hr;
		if (hr == S_OK)
			hrReturn = S_OK;
	}

	return hrReturn;
}

inline HRESULT CPerfMon::_UnregisterStrings() throw()
{
	_ATLTRY
	{
		CString str;
		HRESULT hr;
		DWORD dwErr;

		// unregister the PerfMon counter and help strings
		CRegKey rkApp;

		str.Format(c_szAtlPerfPerformanceKey, GetAppName());
		dwErr = rkApp.Open(HKEY_LOCAL_MACHINE, str);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		DWORD dwFirstAppCounter;
		DWORD dwFirstAppHelp;
		DWORD dwLastAppCounter;
		DWORD dwLastAppHelp;

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfFirstCounter, dwFirstAppCounter);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfFirstHelp, dwFirstAppHelp);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfLastCounter, dwLastAppCounter);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		dwErr = rkApp.QueryDWORDValue(c_szAtlPerfLastHelp, dwLastAppHelp);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		// iterate through the installed languages and delete them all
		DWORD nChars = 0;
		dwErr = rkApp.QueryStringValue(c_szAtlPerfLanguages, NULL, &nChars);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		CString strLangs;
		dwErr = rkApp.QueryStringValue(c_szAtlPerfLanguages, CStrBuf(strLangs, nChars, CStrBuf::SET_LENGTH), &nChars);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);

		int nIndex = 0;
		CString strLang = strLangs.Tokenize(_T(" "), nIndex);
		while (!strLang.IsEmpty())
		{
			CRegKey rkLang;

			dwErr = rkLang.Open(HKEY_LOCAL_MACHINE, CString(c_szAtlPerfPerfLibKey) + _T("\\") + strLang);
			if (dwErr != ERROR_SUCCESS)
				return AtlHresultFromWin32(dwErr);

			hr = _RemoveRegStrings(rkLang, c_szAtlPerfCounter, dwFirstAppCounter, dwLastAppCounter);
			if (FAILED(hr))
				return hr;

			hr = _RemoveRegStrings(rkLang, c_szAtlPerfHelp, dwFirstAppHelp, dwLastAppHelp);
			if (FAILED(hr))
				return hr;

			strLang = strLangs.Tokenize(_T(" "), nIndex);
		}

		dwErr = rkApp.SetStringValue(c_szAtlPerfLanguages, _T(""));
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);
			
		return S_OK;
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
}

inline HRESULT CPerfMon::Unregister() throw()
{
	CString str;
	HRESULT hr;
	DWORD dwErr;

	CRegKey rkPerfLib;
	CRegKey rkApp;

	hr = _UnregisterStrings();
	if (FAILED(hr))
		return hr;

	dwErr = rkPerfLib.Open(HKEY_LOCAL_MACHINE, c_szAtlPerfPerfLibKey);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	_ATLTRY
	{
		str.Format(c_szAtlPerfPerformanceKey, GetAppName());
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
	dwErr = rkApp.Open(HKEY_LOCAL_MACHINE, str);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	DWORD dwLastCounter;
	DWORD dwLastHelp;
	DWORD dwFirstAppCounter;
	DWORD dwFirstAppHelp;
	DWORD dwLastAppCounter;
	DWORD dwLastAppHelp;

	dwErr = rkPerfLib.QueryDWORDValue(c_szAtlPerfLastCounter, dwLastCounter);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkPerfLib.QueryDWORDValue(c_szAtlPerfLastHelp, dwLastHelp);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.QueryDWORDValue(c_szAtlPerfFirstCounter, dwFirstAppCounter);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.QueryDWORDValue(c_szAtlPerfFirstHelp, dwFirstAppHelp);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.QueryDWORDValue(c_szAtlPerfLastCounter, dwLastAppCounter);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkApp.QueryDWORDValue(c_szAtlPerfLastHelp, dwLastAppHelp);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	// rewind the Last Help/Last Counter values if possible
	if (dwLastCounter == dwLastAppCounter)
	{
		dwErr = rkPerfLib.SetDWORDValue(c_szAtlPerfLastCounter, dwFirstAppCounter-2);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);
	}

	if (dwLastHelp == dwLastAppHelp)
	{
		dwErr = rkPerfLib.SetDWORDValue(c_szAtlPerfLastHelp, dwFirstAppHelp-2);
		if (dwErr != ERROR_SUCCESS)
			return AtlHresultFromWin32(dwErr);
	}

	// delete the app key
	CRegKey rkServices;

	rkApp.Close();
	dwErr = rkServices.Open(HKEY_LOCAL_MACHINE, c_szAtlPerfServicesKey);
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	dwErr = rkServices.RecurseDeleteKey(GetAppName());
	if (dwErr != ERROR_SUCCESS)
		return AtlHresultFromWin32(dwErr);

	return S_OK;
}
#endif

inline HRESULT CPerfMon::Initialize() throw()
{
	CMutex tempLock;
	CString strAppName;
	HRESULT hr;

	_ATLTRY
	{
		strAppName = GetAppName();

		ATLASSUME(m_aMem.GetCount() == 0);

		CAccessToken at;
		if (!at.GetEffectiveToken(TOKEN_QUERY))
			return E_FAIL;

	 
		CSid self;
		if (!at.GetUser(&self))
			return E_FAIL;

		// set up security information for creating the mutex
		CDacl dacl;
		 
 
		dacl.AddAllowedAce(Sids::NetworkService(),GENERIC_READ);  
		dacl.AddAllowedAce(Sids::Admins(), GENERIC_ALL);
		dacl.AddAllowedAce(Sids::System(), GENERIC_ALL);
		dacl.AddAllowedAce(self, GENERIC_ALL);

		m_sd.SetDacl(dacl);
		m_sd.SetOwner(self);

		CSecurityAttributes sa;
		sa.Set(m_sd);

		// create a mutex to handle syncronizing access to the shared memory area
		CString strMutexName;
		strMutexName.Format(_T("Global\\ATLPERF_%s_LOCK"), strAppName);
		tempLock.Create(&sa, FALSE, strMutexName);
		if (tempLock.m_h == NULL)
			return AtlHresultFromLastError();

		if (GetLastError() == ERROR_ALREADY_EXISTS)
		{
			// prevent us from using an object someone else has opened
			if (::SetSecurityInfo(tempLock, SE_KERNEL_OBJECT,
					DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
					const_cast<SID*>(self.GetPSID()),
					NULL,
					const_cast<ACL*>(dacl.GetPACL()),
					NULL) != ERROR_SUCCESS)
				return E_FAIL;
		}

		// now set up the dacl for creating shared memory segments and store it
		dacl.AddAllowedAce(Sids::Interactive(), GENERIC_READ);
		m_sd.SetDacl(dacl);

		// create a shared memory area to share data between the app being measured and the client doing the measuring
		{
			CMutexLock lock(tempLock);

			BOOL bExisted = FALSE;

			CAtlFileMappingBase* pMem;
			pMem = _AllocNewBlock(NULL, &bExisted);
			if (pMem == NULL)
				return E_OUTOFMEMORY;

			if (!bExisted)
			{
				// copy the map from the registry to the shared memory
				CRegKey rkApp;
				DWORD dwErr;
				CString strAppKey;

				strAppKey.Format(c_szAtlPerfPerformanceKey, GetAppName());

				dwErr = rkApp.Open(HKEY_LOCAL_MACHINE, strAppKey, KEY_READ);
				if (dwErr != ERROR_SUCCESS)
				{
					m_aMem.RemoveAll();
					return AtlHresultFromWin32(dwErr);
				}

				ULONG nBytes = m_nAllocSize;
				dwErr = rkApp.QueryBinaryValue(c_szAtlPerfMap, pMem->GetData(), &nBytes);
				if (dwErr != ERROR_SUCCESS)
				{
					m_aMem.RemoveAll();
					return AtlHresultFromWin32(dwErr);
				}
			}

			hr = _LoadMap(LPDWORD(pMem->GetData()));
			if (FAILED(hr))
			{
				m_aMem.RemoveAll();
				return hr;
			}

			m_nSchemaSize = *LPDWORD(pMem->GetData());
			m_nHeaderSize = m_nSchemaSize + sizeof(DWORD);
			m_nHeaderSize  = AtlAlignUp(m_nHeaderSize,16);
		}

		m_lock.Attach(tempLock.Detach());
	}
	_ATLCATCHALL()
	{
		m_aMem.RemoveAll();
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

inline void CPerfMon::UnInitialize() throw()
{
	if (m_lock.m_h != NULL)
		m_lock.Close();
	m_aMem.RemoveAll();
	ClearMap();
}

inline HRESULT CPerfMon::_CreateInstance(
	DWORD dwCategoryId,
	DWORD dwInstance,
	LPCWSTR szInstanceName,
	CPerfObject** ppInstance,
	bool bByName
	) throw()
{
	CPerfObject* pEmptyBlock = NULL;

	if (ppInstance == NULL)
		return E_POINTER;

	CAtlFileMappingBase* pCurrentBlock = _GetNextBlock(NULL);
	if (pCurrentBlock == NULL || pCurrentBlock->GetData() == NULL || m_lock.m_h == NULL)
		return E_UNEXPECTED; // Initialize must succeed before calling CreateInstance

	*ppInstance = NULL;

	CategoryInfo* pCategoryInfo = _FindCategoryInfo(dwCategoryId);
	if (pCategoryInfo == NULL)
		return E_INVALIDARG;
	if (szInstanceName == NULL && bByName)
		return E_INVALIDARG;
	if (pCategoryInfo->m_nInstanceLess == PERF_NO_INSTANCES &&
			(dwInstance != 0 || szInstanceName != NULL))
		return E_INVALIDARG;

	CPerfLock lock(this);
	if (FAILED(lock.GetStatus()))
		return lock.GetStatus();

	CPerfObject* pInstance = _GetFirstInstance(pCurrentBlock);
	ULONG nMaxInstance = 0;
	ULONG nUsedSpace = 0;

	// walk all of the existing objects trying to find one that matches the request
	while (pInstance->m_nAllocSize != 0)
	{
		nUsedSpace += pInstance->m_nAllocSize;

		if (pInstance->m_dwCategoryId == dwCategoryId)
		{
			nMaxInstance = __max(nMaxInstance, pInstance->m_dwInstance);

			// check to see if we've found the one the caller wants
			if (!bByName && pInstance->m_dwInstance == dwInstance &&
				(pCategoryInfo->m_nInstanceLess == PERF_NO_INSTANCES || dwInstance != 0))
			{
				*ppInstance = pInstance;
				pInstance->m_nRefCount++;
				return S_OK;
			}
			if (bByName)
			{
				LPWSTR szInstName = (LPWSTR(LPBYTE(pInstance)+pInstance->m_nInstanceNameOffset));
				if (wcsncmp(szInstName, szInstanceName, pCategoryInfo->m_nMaxInstanceNameLen-1) == 0)
				{
					*ppInstance = pInstance;
					pInstance->m_nRefCount++;
					return S_OK;
				}
			}
		}

		if (pInstance->m_nAllocSize == pCategoryInfo->m_nAllocSize && pInstance->m_nRefCount == 0)
			pEmptyBlock = pInstance;

		pInstance = _GetNextInstance(pInstance);

		if (pInstance->m_nAllocSize == 0 &&
			m_nHeaderSize + nUsedSpace + pCategoryInfo->m_nAllocSize + sizeof(CPerfObject) > m_nAllocSize)
		{
			// we've reached the end of the block and have no room to allocate an object of this
			// type. cap the block with a sentinel
			pInstance->m_nAllocSize = (ULONG) -1;
		}

		// check for an end-of-shared-mem sentinel
		if (pInstance->m_nAllocSize == (ULONG) -1)
		{
			nUsedSpace = 0;
			CAtlFileMappingBase* pNextBlock = _GetNextBlock(pCurrentBlock);
			if (pNextBlock == NULL)
			{
				// we've reached the last block of shared mem.
				// the instance hasn't been found, so either use a
				// previously freed instance block (pEmptyBlock) or allocate a new
				// shared mem block to hold the new instance
				if (pEmptyBlock == NULL)
				{
					pNextBlock = _AllocNewBlock(pCurrentBlock);
					if (pNextBlock == NULL)
						return E_OUTOFMEMORY;
				}
				else
					break;
			}
			pCurrentBlock = pNextBlock;
			pInstance = _GetFirstInstance(pCurrentBlock);
		}
	}

	// allocate a new object
	if (pEmptyBlock != NULL)
		pInstance = pEmptyBlock;
	else
		pInstance->m_nAllocSize = pCategoryInfo->m_nAllocSize;

	if (dwInstance == 0 && pCategoryInfo->m_nInstanceLess != PERF_NO_INSTANCES)
		pInstance->m_dwInstance = nMaxInstance + 1;
	else
		pInstance->m_dwInstance = dwInstance;

	pInstance->m_nRefCount = 1;

	// copy the instance name, truncate if necessary
	if (pCategoryInfo->m_nInstanceLess != PERF_NO_INSTANCES)
	{
		ULONG nNameLen = (ULONG)__min(wcslen(szInstanceName), pCategoryInfo->m_nMaxInstanceNameLen-1);
		ULONG nNameBytes = (nNameLen+1) * sizeof(WCHAR);
		pInstance->m_nInstanceNameOffset = pInstance->m_nAllocSize-nNameBytes;
		Checked::memcpy_s(LPBYTE(pInstance)+pInstance->m_nInstanceNameOffset, pInstance->m_nAllocSize-pInstance->m_nInstanceNameOffset, szInstanceName, nNameBytes);
		LPWSTR(LPBYTE(pInstance)+pInstance->m_nInstanceNameOffset)[nNameLen] = 0;
	}

	// copy the CategoryId last: it won't be collected until this is set
	pInstance->m_dwCategoryId = pCategoryInfo->m_dwCategoryId;

	*ppInstance = pInstance;

	return S_OK;
}

inline HRESULT CPerfMon::CreateInstance(
	DWORD dwCategoryId,
	DWORD dwInstance,
	LPCWSTR szInstanceName,
	CPerfObject** ppInstance
	) throw()
{
	return _CreateInstance(dwCategoryId, dwInstance, szInstanceName, ppInstance, false);
}

inline HRESULT CPerfMon::CreateInstanceByName(
	DWORD dwCategoryId,
	LPCWSTR szInstanceName,
	CPerfObject** ppInstance
	) throw()
{
	return _CreateInstance(dwCategoryId, 0, szInstanceName, ppInstance, true);
}

inline HRESULT CPerfMon::ReleaseInstance(CPerfObject* pInstance) throw()
{
	ATLASSERT(pInstance != NULL);
	if (pInstance == NULL)
		return E_INVALIDARG;

	CPerfLock lock(this);
	if (FAILED(lock.GetStatus()))
		return lock.GetStatus();

	if (--pInstance->m_nRefCount == 0)
	{
		pInstance->m_dwInstance = 0;
		pInstance->m_dwCategoryId = 0;
	}

	return S_OK;
}

inline HRESULT CPerfMon::LockPerf(DWORD dwTimeout /* == INFINITE */) throw()
{
	if (m_lock.m_h == NULL)
		return E_UNEXPECTED;

	DWORD dwRes = WaitForSingleObject(m_lock.m_h, dwTimeout);
	if (dwRes == WAIT_ABANDONED || dwRes == WAIT_OBJECT_0)
		return S_OK;
	if (dwRes == WAIT_TIMEOUT)
		return HRESULT_FROM_WIN32(ERROR_TIMEOUT);
	return AtlHresultFromLastError();
}

inline void CPerfMon::UnlockPerf() throw()
{
	m_lock.Release();
}

// map building routines
inline HRESULT CPerfMon::AddCategoryDefinition(
	DWORD dwCategoryId,
	LPCTSTR szCategoryName,
	LPCTSTR szHelpString,
	DWORD dwDetailLevel,
	INT nDefaultCounter,
	BOOL bInstanceLess,
	UINT nStructSize,
	UINT nMaxInstanceNameLen) throw()
{
	// must have one and only one of these
	ATLASSERT(!bInstanceLess ^ !nMaxInstanceNameLen);

	// get the things that can fail out of the way first
	CString strName;
	CString strHelp;
	_ATLTRY
	{
		strName = szCategoryName;
		strHelp = szHelpString;
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}

	if (!m_categories.SetCount(m_categories.GetCount()+1))
	{
		return E_OUTOFMEMORY;
	}

	// category has been added, set the data
	CategoryInfo* pCategoryInfo = _GetCategoryInfo(_GetNumCategories()-1);

	pCategoryInfo->m_dwCategoryId = dwCategoryId;
	pCategoryInfo->m_dwDetailLevel = dwDetailLevel;
	pCategoryInfo->m_nDefaultCounter = nDefaultCounter;
	pCategoryInfo->m_nInstanceLess = bInstanceLess ? PERF_NO_INSTANCES : 0;
	pCategoryInfo->m_nStructSize = nStructSize;
	pCategoryInfo->m_nMaxInstanceNameLen = nMaxInstanceNameLen;
	pCategoryInfo->m_nAllocSize = nStructSize + nMaxInstanceNameLen*sizeof(WCHAR);
	pCategoryInfo->m_strName = strName;
	pCategoryInfo->m_strHelp = strHelp;
	pCategoryInfo->m_nNameId = 0;
	pCategoryInfo->m_nHelpId = 0;

	return S_OK;
}

inline HRESULT CPerfMon::AddCounterDefinition(
	DWORD dwCounterId,
	LPCTSTR szCounterName,
	LPCTSTR szHelpString,
	DWORD dwDetailLevel,
	DWORD dwCounterType,
	ULONG nMaxCounterSize,
	UINT nOffset,
	INT nDefaultScale) throw()
{
	// must add category BEFORE adding counter!
	ATLASSERT(_GetNumCategories() > 0);

	CounterInfo counter;

	counter.m_dwCounterId = dwCounterId;
	_ATLTRY
	{
		counter.m_strName = szCounterName;
		counter.m_strHelp = szHelpString;
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}
	counter.m_dwDetailLevel = dwDetailLevel;
	counter.m_dwCounterType = dwCounterType;
	counter.m_nDefaultScale = nDefaultScale;
	counter.m_nMaxCounterSize = nMaxCounterSize;
	counter.m_nDataOffset = nOffset;

	counter.m_nNameId = 0;
	counter.m_nHelpId = 0;

	// add the counter to the category
	CategoryInfo* pCategoryInfo = _GetCategoryInfo(_GetNumCategories()-1);
	_ATLTRY
	{
		pCategoryInfo->m_counters.Add(counter);
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}

	if (counter.m_nMaxCounterSize > 0)
	{
		ATLASSERT(counter.m_dwCounterType & PERF_TYPE_TEXT);
		pCategoryInfo->m_nAllocSize += counter.m_nMaxCounterSize * sizeof(WCHAR);
	}

	return S_OK;
}

inline HRESULT CPerfMon::RegisterCategory(
	WORD wLanguage,
	HINSTANCE hResInstance,
	UINT* pSampleRes,
	DWORD dwCategoryId,
	UINT nNameString,
	UINT nHelpString,
	DWORD dwDetail,
	BOOL bInstanceless,
	UINT nStructSize,
	UINT nMaxInstanceNameLen,
	INT nDefaultCounter) throw()
{
	if (pSampleRes)
		*pSampleRes = nNameString;
   
	CString strName;
	CString strHelp;
   
	_ATLTRY
	{
		 
		if (!strName.LoadString(hResInstance, nNameString, wLanguage) ||
			!strHelp.LoadString(hResInstance, nHelpString, wLanguage))
		{
			return E_FAIL;
		}
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}

	return RegisterCategory(
		wLanguage,
		hResInstance,
		pSampleRes,
		dwCategoryId,
		strName,
		strHelp,
		dwDetail,
		bInstanceless,
		nStructSize,
		nMaxInstanceNameLen,
		nDefaultCounter);
}

inline HRESULT CPerfMon::RegisterCategory(
	WORD /* wLanguage */,
	HINSTANCE /* hResInstance */,
	UINT* /* pSampleRes */,
	DWORD dwCategoryId,
	LPCTSTR szNameString,
	LPCTSTR szHelpString,
	DWORD dwDetail,
	BOOL bInstanceless,
	UINT nStructSize,
	UINT nMaxInstanceNameLen,
	INT nDefaultCounter) throw()
{
	return AddCategoryDefinition(
		dwCategoryId,
		szNameString,
		szHelpString,
		dwDetail,
		nDefaultCounter,
		bInstanceless,
		nStructSize,
		nMaxInstanceNameLen);
}

inline HRESULT CPerfMon::RegisterCounter(
	WORD wLanguage,
	HINSTANCE hResInstance,
	DWORD dwCounterId,
	UINT nNameString,
	UINT nHelpString,
	DWORD dwDetail,
	DWORD dwCounterType,
	ULONG nMaxCounterSize,
	UINT nOffset,
	INT nDefaultScale) throw()
{
	CString strName;
	CString strHelp;
  
	_ATLTRY
	{
		 
		if (!strName.LoadString(hResInstance, nNameString, wLanguage) ||
			!strHelp.LoadString(hResInstance, nHelpString, wLanguage))
		{
			return E_FAIL;
		}
	}
	_ATLCATCHALL()
	{
		return E_OUTOFMEMORY;
	}

	return RegisterCounter(
		wLanguage,
		hResInstance,
		dwCounterId,
		strName,
		strHelp,
		dwDetail,
		dwCounterType,
		nMaxCounterSize,
		nOffset,
		nDefaultScale);
}

inline HRESULT CPerfMon::RegisterCounter(
	WORD /* wLanguage */,
	HINSTANCE /* hResInstance */,
	DWORD dwCounterId,
	LPCTSTR szNameString,
	LPCTSTR szHelpString,
	DWORD dwDetail,
	DWORD dwCounterType,
	ULONG nMaxCounterSize,
	UINT nOffset,
	INT nDefaultScale) throw()
{
	return AddCounterDefinition(
		dwCounterId,
		szNameString,
		szHelpString,
		dwDetail,
		dwCounterType,
		nMaxCounterSize,
		nOffset,
		nDefaultScale);
}

inline void CPerfMon::ClearMap() throw()
{
	m_categories.RemoveAll();
}

#ifndef _ATL_PERF_NOXML

ATL_NOINLINE inline HRESULT CPerfMon::PersistToXML(IStream *pStream, BOOL bFirst/*=TRUE*/, BOOL bLast/*=TRUE*/) throw(...)
{
	ATLASSERT(pStream != NULL);
	if (pStream == NULL)
		return E_INVALIDARG;

	CPerfLock lock(this);
	if (FAILED(lock.GetStatus()))
		return ERROR_SUCCESS;

	CStringA strXML;
	HRESULT hr = S_OK;
	ULONG nLen = 0;
	
	if (bFirst)
	{
		strXML = "<?xml version=\"1.0\" ?>\r\n<perfPersist>\r\n";
		hr = pStream->Write(strXML, strXML.GetLength(), &nLen);
		if (hr != S_OK)
			return hr;
	}

	strXML.Format("\t<perfmon name=\"%s\">\r\n", CT2CA(GetAppName()));
	hr = pStream->Write(strXML, strXML.GetLength(), &nLen);

	for (UINT i=0; i<_GetNumCategories(); i++)
	{
		CategoryInfo* pCategoryInfo = _GetCategoryInfo(i);

		CAtlFileMappingBase *pCurrentBlock = _GetNextBlock(NULL);
		CPerfObject *pInstance = _GetFirstInstance(pCurrentBlock);

		strXML.Format("\t\t<perfObject perfid=\"%d\">\r\n", 
			pCategoryInfo->m_dwCategoryId, pCategoryInfo->m_nNameId, pCategoryInfo->m_nHelpId);

		hr = pStream->Write(strXML, strXML.GetLength(), &nLen);
		if (hr != S_OK)
			return E_FAIL;

		while (pInstance && pInstance->m_nAllocSize)
		{
			if (pInstance->m_dwCategoryId == pCategoryInfo->m_dwCategoryId)
			{
				if (pCategoryInfo->m_nInstanceLess != PERF_NO_INSTANCES)
				{
					// handle the instance name
					LPCWSTR wszInstNameSrc = LPCWSTR(LPBYTE(pInstance)+pInstance->m_nInstanceNameOffset);
					int nInstLen = (int) wcslen(wszInstNameSrc);

					// convert to UTF8
					int nLength = AtlUnicodeToUTF8(wszInstNameSrc, nInstLen, NULL, 0);
					CHeapPtr<CHAR> szUTF8;
					if ((nLength < 0) || (nLength+1<nLength) || !szUTF8.Allocate(nLength+1))
						return E_OUTOFMEMORY;
					nLength = AtlUnicodeToUTF8(wszInstNameSrc, nInstLen, szUTF8, nLength);
					szUTF8[nLength] = '\0';

					strXML.Format("\t\t\t<instance name=\"%s\" id=\"%d\">\r\n", szUTF8, pInstance->m_dwInstance);
					hr = pStream->Write(strXML, strXML.GetLength(), &nLen);
					if (hr != S_OK)
						return hr;
				}

				for (UINT j=0; j<pCategoryInfo->_GetNumCounters(); j++)
				{
					CounterInfo *pCounterInfo = pCategoryInfo->_GetCounterInfo(j);
					switch (pCounterInfo->m_dwCounterType & ATLPERF_SIZE_MASK)
					{
						case PERF_SIZE_DWORD:
						{
							strXML.Format("\t\t\t\t<counter type=\"perf_size_dword\" value=\"%d\" offset=\"%d\"/>\r\n",
								*LPDWORD(LPBYTE(pInstance)+pCounterInfo->m_nDataOffset), 
								pCounterInfo->m_nDataOffset);
							break;
						}
						case PERF_SIZE_LARGE:
						{
							strXML.Format("\t\t\t\t<counter type=\"perf_size_large\" value=\"%d\" offset=\"%d\"/>\r\n",
								*PULONGLONG(LPBYTE(pInstance)+pCounterInfo->m_nDataOffset),
								pCounterInfo->m_nDataOffset);
							break;
						}
						case PERF_SIZE_VARIABLE_LEN:
						{
							CHeapPtr<CHAR> szUTF8;
							LPBYTE pSrc = LPBYTE(pInstance)+pCounterInfo->m_nDataOffset;
							if ((pCounterInfo->m_dwCounterType & ATLPERF_TEXT_MASK) == PERF_TEXT_UNICODE)
							{
								ULONG nTextLen = (ULONG)wcslen(LPCWSTR(pSrc));
								// convert to UTF8
								nLen = AtlUnicodeToUTF8(LPCWSTR(pSrc), nTextLen, NULL, 0);
								if (!szUTF8.Allocate(nLen+1))
									return E_OUTOFMEMORY;

								nLen = AtlUnicodeToUTF8(LPCWSTR(pSrc), nTextLen, szUTF8, nLen);	
								szUTF8[nLen] = '\0';
								strXML.Format("\t\t\t\t<counter type=\"perf_size_variable_len_unicode\" value=\"%s\" offset=\"%d\"/>\r\n",
										szUTF8,
										pCounterInfo->m_nDataOffset);
							}
							else
							{
								ULONG nTextLen = (ULONG)strlen(LPCSTR(pSrc));
								if (!szUTF8.Allocate(nTextLen+1))
									return E_OUTOFMEMORY;
								Checked::strcpy_s(szUTF8, nTextLen+1, LPCSTR(pSrc));
								strXML.Format("\t\t\t\t<counter type=\"perf_size_variable_len_ansi\" value=\"%s\" offset=\"%d\"/>\r\n",
										szUTF8,
										pCounterInfo->m_nDataOffset);
							}
							break;
						}
						default:
							// error:
							return E_FAIL;
					}
					hr = pStream->Write(strXML, strXML.GetLength(), &nLen);
					if (hr != S_OK)
						return hr;
				}

				if (pCategoryInfo->m_nInstanceLess != PERF_NO_INSTANCES)
				{
					hr = pStream->Write("\t\t\t</instance>\r\n", sizeof("\t\t\t</instance>\r\n")-1, &nLen);
					if (hr != S_OK)
						return hr;
				}
			}

			pInstance = _GetNextInstance(pInstance);
			if (pInstance->m_nAllocSize == (ULONG)-1)
			{
				pCurrentBlock = _GetNextBlock(pCurrentBlock);
				if (pCurrentBlock == NULL)
					pInstance = NULL;
				else
					pInstance = _GetFirstInstance(pCurrentBlock);
			}
		}

		hr = pStream->Write("\t\t</perfObject>\r\n", sizeof("\t\t</perfObject>\r\n")-1, &nLen);
		if (hr != S_OK)
			return hr;
	}

	hr = pStream->Write("\t</perfmon>\r\n", sizeof("\t</perfmon>\r\n")-1, &nLen);
	if (hr != S_OK)
		return hr;

	if (hr == S_OK && bLast)
		hr = pStream->Write("</perfPersist>", sizeof("</perfPersist>")-1, &nLen);

	return hr;
}

// This function is very lenient with inappropriate XML
ATL_NOINLINE inline HRESULT CPerfMon::LoadFromXML(IStream *pStream) throw(...)
{	
	ATLASSERT(pStream != NULL);
	if (pStream == NULL)
		return E_INVALIDARG;

	// Get a lock
	CPerfLock lock(this);
	if (FAILED(lock.GetStatus()))
		return ERROR_SUCCESS;

	CComPtr<IXMLDOMDocument> spdoc;

	// load the xml
	HRESULT hr = CoCreateInstance(__uuidof(DOMDocument), NULL, CLSCTX_INPROC, __uuidof(IXMLDOMDocument), (void **) &spdoc);
	if (FAILED(hr))
	{
		return hr;
	}

	spdoc->put_async(VARIANT_FALSE);

	CComPtr<IPersistStreamInit> spSI;
	hr = spdoc->QueryInterface(&spSI);
	if (hr != S_OK)
		return hr;
	hr = spSI->Load(pStream);
	if (hr != S_OK)
		return hr;

	// validate that it is a perfPersist stream
	CComPtr<IXMLDOMElement> spRoot;

	hr = spdoc->get_documentElement(&spRoot);
	if (hr != S_OK)
		return hr;

	CComBSTR bstrName;
	hr = spRoot->get_baseName(&bstrName);
	if (wcscmp(bstrName, L"perfPersist"))
		return S_FALSE;

	// find the appropriate perfmon node
	CComPtr<IXMLDOMNode> spChild;
	hr = spRoot->get_firstChild(&spChild);
	while (hr == S_OK)
	{
		bstrName.Empty();
		hr = spChild->get_baseName(&bstrName);
		if (hr == S_OK)
		{
			if (!wcscmp(bstrName, L"perfmon"))
			{
				bstrName.Empty();
				hr = _GetAttribute(spChild, L"name", &bstrName);
				if (hr == S_OK)
				{
					if (!_tcscmp(CW2CT(bstrName), GetAppName()))
						break;
				}
			}
		}

		CComPtr<IXMLDOMNode> spNext;
		hr = spChild->get_nextSibling(&spNext);
		spChild.Attach(spNext.Detach());
	}

	// there is no perfmon node in the XML for the current CPerfMon class
	if (hr != S_OK)
		return S_FALSE;

	CComPtr<IXMLDOMNode> spPerfRoot;
	spPerfRoot.Attach(spChild.Detach());

	// iterate over the objects in the perfmon subtree
	// this is the loop that does the real work
	hr = spPerfRoot->get_firstChild(&spChild);
	while (hr == S_OK)
	{
		// see if it's a perfObject
		bstrName.Empty();
		hr = spChild->get_baseName(&bstrName);
		if (hr != S_OK || wcscmp(bstrName, L"perfObject"))
			return S_FALSE;

		// get the perfid
		bstrName.Empty();
		hr = _GetAttribute(spChild, L"perfid", &bstrName);
		DWORD dwPerfId = _wtoi(bstrName);

		// iterate over children
		CComPtr<IXMLDOMNode> spInstChild;
		hr = spChild->get_firstChild(&spInstChild);
		while (hr == S_OK)
		{
			// see if it's a instance
			bstrName.Empty();
			hr = spInstChild->get_baseName(&bstrName);
			if (hr != S_OK || wcscmp(bstrName, L"instance"))
				return S_FALSE;

			// get the instance name
			bstrName.Empty();
			hr = _GetAttribute(spInstChild, L"name", &bstrName);
			if (hr != S_OK)
				return S_FALSE;

			// get the instance id
			bstrName.Empty();
			hr = _GetAttribute(spChild, L"id", &bstrName);
			if (hr != S_OK)
				return S_FALSE;
			DWORD dwInstance = _wtoi(bstrName);

			// create the instance
			CPerfObject *pInstance = NULL;
			hr = CreateInstance(dwPerfId, dwInstance++, bstrName, &pInstance);
			if (hr != S_OK)
				return S_FALSE;

			// iterate over the counters and set the data
			CComPtr<IXMLDOMNode> spCntrChild;
			hr = spInstChild->get_firstChild(&spCntrChild);
			while (hr == S_OK)
			{
				// get the base name
				bstrName.Empty();
				hr = spCntrChild->get_baseName(&bstrName);
				if (hr != S_OK || wcscmp(bstrName, L"counter"))
					return S_FALSE;

				// get the type
				bstrName.Empty();
				hr = _GetAttribute(spCntrChild, L"type", &bstrName);
				if (hr != S_OK)
					return S_FALSE;

				DWORD dwType;
				if (!wcscmp(bstrName, L"perf_size_dword"))
					dwType = PERF_SIZE_DWORD;
				else if (!wcscmp(bstrName, L"perf_size_large"))
					dwType = PERF_SIZE_LARGE;
				else if (!wcscmp(bstrName, L"perf_size_variable_len_ansi"))
					dwType = PERF_SIZE_VARIABLE_LEN;
				else if (!wcscmp(bstrName, L"perf_size_variable_len_unicode"))
					dwType = PERF_SIZE_VARIABLE_LEN | PERF_TEXT_UNICODE;
				else
					return S_FALSE;

				// get the value
				bstrName.Empty();
				hr = _GetAttribute(spCntrChild, L"value", &bstrName);
				if (hr != S_OK)
					return S_FALSE;

				CComBSTR bstrOffset;
				hr = _GetAttribute(spCntrChild, L"offset", &bstrOffset);
				if (hr != S_OK)
					return S_FALSE;

				WCHAR *pStop = NULL;
				DWORD dwOffset = wcstoul(bstrOffset, &pStop, 10);

				if (dwType == PERF_SIZE_DWORD) // add it as a DWORD
				{
					DWORD dwVal = wcstoul(bstrName, &pStop, 10);
					*LPDWORD(LPBYTE(pInstance)+dwOffset) = dwVal;
				}
				else if (dwType == PERF_SIZE_LARGE) // add it is a ULONGLONG
				{
					ULONGLONG qwVal = _wcstoui64(bstrName, &pStop, 10);
					*PULONGLONG(LPBYTE(pInstance)+dwOffset) = qwVal;
				}
				else if (dwType == PERF_SIZE_VARIABLE_LEN) // add it as an ansi string
				{
					AtlW2AHelper(LPSTR(LPBYTE(pInstance)+dwOffset), bstrName, bstrName.Length(), ATL::_AtlGetConversionACP());
				}
				else // add it as a unicode string
				{
					Checked::memcpy_s(LPBYTE(pInstance)+dwOffset, pInstance->m_nAllocSize-dwOffset, bstrName, bstrName.Length()*sizeof(WCHAR));
				}

				CComPtr<IXMLDOMNode> spCntrNext;
				hr = spCntrChild->get_nextSibling(&spCntrNext);
				spCntrChild.Attach(spCntrNext.Detach());
			}

			CComPtr<IXMLDOMNode> spInstNext;
			hr = spInstChild->get_nextSibling(&spInstNext);
			spInstChild.Attach(spInstNext.Detach());
		}

		CComPtr<IXMLDOMNode> spNext;
		hr = spChild->get_nextSibling(&spNext);
		spChild.Attach(spNext.Detach());
	}

	return S_OK;
}

// a little utility function to retrieve a named attribute from a node
ATL_NOINLINE inline HRESULT CPerfMon::_GetAttribute(IXMLDOMNode *pNode, LPCWSTR szAttrName, BSTR *pbstrVal) throw()
{
	ATLENSURE_RETURN(pNode != NULL);
	ATLASSERT(szAttrName != NULL);
	ATLENSURE_RETURN(pbstrVal != NULL);

	*pbstrVal = NULL;
	CComPtr<IXMLDOMNamedNodeMap> spAttrs;

	HRESULT hr = pNode->get_attributes(&spAttrs);
	if (hr != S_OK)
		return hr;
	
	CComPtr<IXMLDOMNode> spAttr;
	
	hr = spAttrs->getNamedItem((BSTR) szAttrName, &spAttr);
	if (hr != S_OK)
		return hr;
	
	CComVariant varVal;
	hr = spAttr->get_nodeValue(&varVal);
	if (hr != S_OK)
		return hr;
	
	hr = varVal.ChangeType(VT_BSTR);
	if (hr != S_OK)
		return hr;

	*pbstrVal = varVal.bstrVal;
	varVal.vt = VT_EMPTY;

	return S_OK;
}

#endif // _ATL_PERF_NOXML

#if defined(_ATL_PERF_REGISTER) & !defined(_ATL_PERF_NOEXPORT)

ATL_NOINLINE inline HRESULT RegisterPerfMon(HINSTANCE hDllInstance /* = _AtlBaseModule.GetModuleInstance() */) throw() 
{
	CPerfMon **ppPerf = &__pperfA; 
	HRESULT hr = S_OK; 
	while (ppPerf != &__pperfZ) 
	{ 
		if (*ppPerf != NULL) 
		{ 
			hr = (*ppPerf)->Register(_T( ATLPERF_FUNCID_OPEN ), _T( ATLPERF_FUNCID_COLLECT ), _T( ATLPERF_FUNCID_CLOSE ), hDllInstance);
			if (FAILED(hr)) 
				return hr; 
			hr = (*ppPerf)->RegisterAllStrings(hDllInstance);
			if (FAILED(hr)) 
				return hr; 
		} 
		ppPerf++; 
	} 
	return S_OK; 
} 

ATL_NOINLINE inline HRESULT UnregisterPerfMon() throw() 
{ 
	CPerfMon **ppPerf = &__pperfA; 
	HRESULT hr = S_OK; 
	while (ppPerf != &__pperfZ) 
	{ 
		if (*ppPerf != NULL) 
		{ 
			hr = (*ppPerf)->Unregister(); 
			if (FAILED(hr)) 
				return hr; 
		} 
		ppPerf++; 
	} 
	return S_OK; 
} 

extern "C" ATL_NOINLINE inline DWORD __declspec(dllexport) WINAPI OpenPerfMon(LPWSTR lpDeviceNames) throw()
{
	CPerfMon **ppPerf = &__pperfA;
	DWORD dwErr = 0;
	while (ppPerf != &__pperfZ)
	{
		if (*ppPerf != NULL)
		{
			dwErr = (*ppPerf)->Open(lpDeviceNames);
			if (dwErr != 0)
				return dwErr;
		}
		ppPerf++;
	}
	return 0;
}

extern "C" ATL_NOINLINE inline DWORD __declspec(dllexport) WINAPI CollectPerfMon(LPWSTR lpwszValue, LPVOID* lppData,
	LPDWORD lpcbBytes, LPDWORD lpcObjectTypes) throw()
{
	DWORD dwOrigBytes = *lpcbBytes;
	DWORD dwBytesRemaining = *lpcbBytes;
	CPerfMon **ppPerf = &__pperfA;
	DWORD dwErr = 0;
	while (ppPerf != &__pperfZ)
	{
		if (*ppPerf != NULL)
		{
			dwErr = (*ppPerf)->Collect(lpwszValue, lppData, lpcbBytes, lpcObjectTypes);
			if (dwErr != 0)
				return dwErr;
			dwBytesRemaining -= *lpcbBytes;
			*lpcbBytes = dwBytesRemaining;
		}
		ppPerf++;
	}
	*lpcbBytes = dwOrigBytes - dwBytesRemaining;
	return 0;
}

extern "C" ATL_NOINLINE inline DWORD __declspec(dllexport) WINAPI ClosePerfMon() throw()
{
	CPerfMon **ppPerf = &__pperfA;
	while (ppPerf != &__pperfZ)
	{
		if (*ppPerf != NULL)
		{
			(*ppPerf)->Close();
		}
		ppPerf++;
	}
	return 0;
}

#endif // defined(_ATL_PERF_REGISTER) & !defined(_ATL_PERF_NOEXPORT)

} // namespace ATL

#pragma warning(pop)

#endif // __ATLPERF_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlrx.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLRX_H__
#define __ATLRX_H__

#pragma once

#ifdef _WIN32_WCE
	#error atlrx.h is not supported on Windows CE (_WIN32_WCE is defined)
#endif //_WIN32_WCE

#include <atlbase.h>
#include <atlcoll.h>
#include <mbstring.h>

#ifndef ATL_REGEXP_MIN_STACK
#define ATL_REGEXP_MIN_STACK 256
#endif

/* 
	Regular Expression Grammar

	R    - top level grammar rule
	RE   - regular expression
	AltE - Alternative expression
	E    - expression
	SE   - simple expression

	R -> RE
		 '^'RE		(matches begining of string)

	RE -> AltE RE
		  AltE


	AltE -> E
			E '|' AltE
	E -> SE (RepeatOp '?'?)?
	SE -> Arg
		Group
		CharClass
		'\'Abbrev		(see below)
		'\'EscapedChar	(any character including reserved symbols)
		'\'Digit+    (Arg back reference)
		'!'   (not)
		'.'   (any char)
		'$'   (end of input)
		Symbol			(any non-reserved character)
	Arg -> '{'RE'}'
	Group -> '('RE')'
	CharClass -> '[' '^'? CharSet ']'
	CharSet -> CharItem+
	CharItem -> Char('-'Char)?
	RepeatOp ->  '*'
				 '+'
				 '?'
	Abbrev -> Abbreviation defined in CAtlRECharTraits
		Abbrev  Expansion					Meaning
		a		([a-zA-Z0-9])				alpha numeric
		b		([ \\t])					white space (blank)
		c		([a-zA-Z])					alpha
		d		([0-9])						digit
		h		([0-9a-fA-F])				hex digit
		n		(\r|(\r?\n))				newline
		q		(\"[^\"]*\")|(\'[^\']*\')	quoted string
		w		([a-zA-Z]+)					simple word
		z		([0-9]+)					integer
*/

#pragma pack(push,_ATL_PACKING)
namespace ATL {

//Convertion utility classes used to convert char* to RECHAR.
//Used by rx debugging printing.
template <typename RECHARTYPE=char>
class CAToREChar
{
public:
	CAToREChar(const char* psz) throw()
	: m_psz(psz)
	{
	}
	operator const RECHARTYPE*() const throw() { return m_psz; }
	const char* m_psz;
};

template<>
class CAToREChar<wchar_t>
{
public:
	CAToREChar(const char* psz) throw()
	: m_a2w(psz)
	{
	}
	operator const wchar_t*() const throw() { return (wchar_t*)m_a2w; }
	
private:
	CA2W m_a2w;
};

class CAtlRECharTraitsA
{
public:
	typedef char RECHARTYPE;

	static size_t GetBitFieldForRangeArrayIndex(const RECHARTYPE *sz) throw()
	{
#ifndef ATL_NO_CHECK_BIT_FIELD
		ATLASSERT(UseBitFieldForRange());
#endif
		return static_cast<size_t>(static_cast<unsigned char>(*sz));		
	}
	static RECHARTYPE *Next(const RECHARTYPE *sz) throw()
	{
		return (RECHARTYPE *) (sz+1);
	}

	static int Strncmp(const RECHARTYPE *szLeft, const RECHARTYPE *szRight, size_t nCount) throw()
	{
		return strncmp(szLeft, szRight, nCount);
	}

	static int Strnicmp(const RECHARTYPE *szLeft, const RECHARTYPE *szRight, size_t nCount) throw()
	{
		return _strnicmp(szLeft, szRight, nCount);
	}

	_ATL_INSECURE_DEPRECATE("CAtlRECharTraitsA::Strlwr must be passed a buffer size.")
	static RECHARTYPE *Strlwr(RECHARTYPE *sz) throw()
	{
		#pragma warning (push)
		#pragma warning(disable : 4996)
		return _strlwr(sz);
		#pragma warning (pop)
	}

	static RECHARTYPE *Strlwr(RECHARTYPE *sz, int nSize) throw()
	{
		Checked::strlwr_s(sz, nSize);
		return sz;
	}

	static long Strtol(const RECHARTYPE *sz, RECHARTYPE **szEnd, int nBase) throw()
	{
		return strtol(sz, szEnd, nBase);
	}

	static int Isdigit(RECHARTYPE ch) throw()
	{
		return isdigit(static_cast<unsigned char>(ch));
	}

	static const RECHARTYPE** GetAbbrevs()
	{
		static const RECHARTYPE *s_szAbbrevs[] = 
		{
			"a([a-zA-Z0-9])",	// alpha numeric
			"b([ \\t])",		// white space (blank)
			"c([a-zA-Z])",	// alpha
			"d([0-9])",		// digit
			"h([0-9a-fA-F])",	// hex digit
			"n(\r|(\r?\n))",	// newline
			"q(\"[^\"]*\")|(\'[^\']*\')",	// quoted string
			"w([a-zA-Z]+)",	// simple word
			"z([0-9]+)",		// integer
			NULL
		};

		return s_szAbbrevs;
	}

	static BOOL UseBitFieldForRange() throw()
	{
		return TRUE;
	}

	static int ByteLen(const RECHARTYPE *sz) throw()
	{
		return int(strlen(sz));
	}
};

class CAtlRECharTraitsW
{
public:
	typedef WCHAR RECHARTYPE;
	
	static size_t GetBitFieldForRangeArrayIndex(const RECHARTYPE *sz) throw()
	{		
#ifndef ATL_NO_CHECK_BIT_FIELD
		ATLASSERT(UseBitFieldForRange());
#endif
		return static_cast<size_t>(*sz);
	}
	static RECHARTYPE *Next(const RECHARTYPE *sz) throw()
	{
		return (RECHARTYPE *) (sz+1);
	}

	static int Strncmp(const RECHARTYPE *szLeft, const RECHARTYPE *szRight, size_t nCount) throw()
	{
		return wcsncmp(szLeft, szRight, nCount);
	}

	static int Strnicmp(const RECHARTYPE *szLeft, const RECHARTYPE *szRight, size_t nCount) throw()
	{
		return _wcsnicmp(szLeft, szRight, nCount);
	}

	_ATL_INSECURE_DEPRECATE("CAtlRECharTraitsW::Strlwr must be passed a buffer size.")
	static RECHARTYPE *Strlwr(RECHARTYPE *sz) throw()
	{
		#pragma warning (push)
		#pragma warning(disable : 4996)
		return _wcslwr(sz);
		#pragma warning (pop)
	}

	static RECHARTYPE *Strlwr(RECHARTYPE *sz, int nSize) throw()
	{
		Checked::wcslwr_s(sz, nSize);
		return sz;
	}

	static long Strtol(const RECHARTYPE *sz, RECHARTYPE **szEnd, int nBase) throw()
	{
		return wcstol(sz, szEnd, nBase);
	}

	static int Isdigit(RECHARTYPE ch) throw()
	{
		return iswdigit(ch);
	}

	static const RECHARTYPE** GetAbbrevs()
	{
		static const RECHARTYPE *s_szAbbrevs[] = 
		{
			L"a([a-zA-Z0-9])",	// alpha numeric
			L"b([ \\t])",		// white space (blank)
			L"c([a-zA-Z])",	// alpha
			L"d([0-9])",		// digit
			L"h([0-9a-fA-F])",	// hex digit
			L"n(\r|(\r?\n))",	// newline
			L"q(\"[^\"]*\")|(\'[^\']*\')",	// quoted string
			L"w([a-zA-Z]+)",	// simple word
			L"z([0-9]+)",		// integer
			NULL
		};

		return s_szAbbrevs;
	}

	static BOOL UseBitFieldForRange() throw()
	{
		return FALSE;
	}

	static int ByteLen(const RECHARTYPE *sz) throw()
	{
		return int(wcslen(sz)*sizeof(WCHAR));
	}
};

class CAtlRECharTraitsMB
{
public:
	typedef unsigned char RECHARTYPE;

	static size_t GetBitFieldForRangeArrayIndex(const RECHARTYPE *sz) throw()
	{		
#ifndef ATL_NO_CHECK_BIT_FIELD
		ATLASSERT(UseBitFieldForRange());
#endif

		return static_cast<size_t>(*sz);		
	}

	static RECHARTYPE *Next(const RECHARTYPE *sz) throw()
	{
		return _mbsinc(sz);
	}

	static int Strncmp(const RECHARTYPE *szLeft, const RECHARTYPE *szRight, size_t nCount) throw()
	{
		return _mbsncmp(szLeft, szRight, nCount);
	}

	static int Strnicmp(const RECHARTYPE *szLeft, const RECHARTYPE *szRight, size_t nCount) throw()
	{
		return _mbsnicmp(szLeft, szRight, nCount);
	}

	_ATL_INSECURE_DEPRECATE("CAtlRECharTraitsMB::Strlwr must be passed a buffer size.")
	static RECHARTYPE *Strlwr(RECHARTYPE *sz) throw()
	{
		#pragma warning (push)
		#pragma warning(disable : 4996)
		return _mbslwr(sz);
		#pragma warning (pop)
	}

	static RECHARTYPE *Strlwr(RECHARTYPE *sz, int nSize) throw()
	{
		Checked::mbslwr_s(sz, nSize);
		return sz;
	}

	static long Strtol(const RECHARTYPE *sz, RECHARTYPE **szEnd, int nBase) throw()
	{
		return strtol((const char *) sz, (char **) szEnd, nBase);
	}

	static int Isdigit(RECHARTYPE ch) throw()
	{
		return _ismbcdigit((unsigned int) ch);
	}

	static const RECHARTYPE** GetAbbrevs()
	{
		return reinterpret_cast<const RECHARTYPE **>(CAtlRECharTraitsA::GetAbbrevs());
	}

	static BOOL UseBitFieldForRange() throw()
	{
		return FALSE;
	}

	static int ByteLen(const RECHARTYPE *sz) throw()
	{
		return (int)strlen((const char *) sz);
	}
};

#ifndef _UNICODE
typedef CAtlRECharTraitsA CAtlRECharTraits;
#else	// _UNICODE
typedef CAtlRECharTraitsW CAtlRECharTraits;
#endif // !_UNICODE
// Note: If you want to use CAtlRECharTraitsMB you must pass it in
// as a template argument

template <class CharTraits=CAtlRECharTraits>
class CAtlRegExp;	// forward declaration

template <class CharTraits=CAtlRECharTraits>
class CAtlREMatchContext
{
public:
	friend CAtlRegExp<CharTraits>;
	typedef typename CharTraits::RECHARTYPE RECHAR;

	struct MatchGroup
	{
		const RECHAR *szStart;
		const RECHAR *szEnd;
	};

	UINT m_uNumGroups;

	MatchGroup m_Match;

	void GetMatch(UINT nIndex, const RECHAR **szStart, const RECHAR **szEnd)
	{
		ATLENSURE(szStart != NULL);
		ATLENSURE(szEnd != NULL);
		ATLENSURE(nIndex >=0 && nIndex < m_uNumGroups);
		*szStart = m_Matches[nIndex].szStart;
		*szEnd = m_Matches[nIndex].szEnd;
	}

	void GetMatch(UINT nIndex, MatchGroup *pGroup)
	{
		 
		ATLENSURE(pGroup != NULL);
		ATLENSURE(nIndex >=0&&(static_cast<UINT>(nIndex))< m_uNumGroups);
		pGroup->szStart = m_Matches[nIndex].szStart;
		pGroup->szEnd = m_Matches[nIndex].szEnd;
	}

protected:
	CAutoVectorPtr<void *> m_Mem;
	CAutoVectorPtr<MatchGroup> m_Matches;
	CAtlArray<void *> m_stack;
	size_t m_nTos;

public:
	CAtlREMatchContext(size_t nInitStackSize=ATL_REGEXP_MIN_STACK)
	{
		m_uNumGroups = 0;
		m_nTos = 0;
		m_stack.SetCount(nInitStackSize);
		m_Match.szStart = NULL;
		m_Match.szEnd = NULL;
	}

protected:
	BOOL Initialize(UINT uRequiredMem, UINT uNumGroups) throw()
	{
		m_nTos = 0;

		m_uNumGroups = 0;
		m_Matches.Free();

		if (!m_Matches.Allocate(uNumGroups))
			return FALSE;

		m_uNumGroups = uNumGroups;

		m_Mem.Free();

		if (!m_Mem.Allocate(uRequiredMem))
			return FALSE;

		memset(m_Mem.m_p, 0x00, uRequiredMem*sizeof(void *));

		memset(m_Matches, 0x00, m_uNumGroups * sizeof(MatchGroup));
		return TRUE;
	}

	BOOL Push(void *p)
	{
		m_nTos++;
		if (m_stack.GetCount() <= (UINT) m_nTos)
		{
			if (!m_stack.SetCount((m_nTos+1)*2))
			{
				m_nTos--;
				return FALSE;
			}
		}
		m_stack[m_nTos] = p;
		return TRUE;
	}

	BOOL Push(size_t n)
	{
		return Push((void *) n);
	}

	void *Pop() throw()
	{
		if (m_nTos==0)
		{
			// stack underflow
			// this should never happen at match time.
			// (the parsing succeeded when it shouldn't have)
			ATLASSERT(FALSE);
			return NULL;
		}
		void *p = m_stack[m_nTos];
		m_nTos--;
		return p;
	}
};

enum REParseError {
	REPARSE_ERROR_OK = 0,				// No error occurred
	REPARSE_ERROR_OUTOFMEMORY,			// Out of memory
	REPARSE_ERROR_BRACE_EXPECTED,		// A closing brace was expected
	REPARSE_ERROR_PAREN_EXPECTED,		// A closing parenthesis was expected
	REPARSE_ERROR_BRACKET_EXPECTED,		// A closing bracket was expected
	REPARSE_ERROR_UNEXPECTED,			// An unspecified fatal error occurred
	REPARSE_ERROR_EMPTY_RANGE,			// A range expression was empty
	REPARSE_ERROR_INVALID_GROUP,		// A backreference was made to a group
										// that did not exist
	REPARSE_ERROR_INVALID_RANGE,		// An invalid range was specified
	REPARSE_ERROR_EMPTY_REPEATOP,		// A possibly empty * or + was detected
	REPARSE_ERROR_INVALID_INPUT,		// The input string was invalid
};

template <class CharTraits /* =CAtlRECharTraits */>
class CAtlRegExp
{
public:
	CAtlRegExp() throw()
	{
		m_uNumGroups = 0;
		m_uRequiredMem = 0;
		m_bCaseSensitive = TRUE;
		m_LastError = REPARSE_ERROR_OK;
	}

	typedef typename CharTraits::RECHARTYPE RECHAR;

	// CAtlRegExp::Parse
	// Parses the regular expression
	// returns REPARSE_ERROR_OK if successful, an REParseError otherwise
	REParseError Parse(const RECHAR *szRE, BOOL bCaseSensitive=TRUE)
	{
		ATLASSERT(szRE);
		if (!szRE)
			return REPARSE_ERROR_INVALID_INPUT;

		Reset();

		m_bCaseSensitive = bCaseSensitive;

		const RECHAR *szInput = szRE;

		if (!bCaseSensitive)
		{
			// copy the string
			int nSize = CharTraits::ByteLen(szRE)+sizeof(RECHAR);
			szInput = (const RECHAR *) malloc(nSize);
			if (!szInput)
				return REPARSE_ERROR_OUTOFMEMORY;

			Checked::memcpy_s((char *) szInput, nSize, szRE, nSize);

			CharTraits::Strlwr(const_cast<RECHAR *>(szInput), nSize/sizeof(RECHAR));
		}
		const RECHAR *sz = szInput;

		int nCall = AddInstruction(RE_CALL);
		if (nCall < 0)
			return REPARSE_ERROR_OUTOFMEMORY;

		if (*sz == '^')
		{
			if (AddInstruction(RE_FAIL) < 0)
				return REPARSE_ERROR_OUTOFMEMORY;
			sz++;
		}
		else
		{
			if (AddInstruction(RE_ADVANCE) < 0)
				return REPARSE_ERROR_OUTOFMEMORY;
		}

		bool bEmpty = true;
		ParseRE(&sz, bEmpty);
		if (!GetLastParseError())
		{
			GetInstruction(nCall).call.nTarget = 2;

			if (AddInstruction(RE_MATCH) < 0)
				return REPARSE_ERROR_OUTOFMEMORY;
		}

		if (szInput != szRE)
			free((void *) szInput);

		return GetLastParseError();
	}

	BOOL Match(const RECHAR *szIn, CAtlREMatchContext<CharTraits> *pContext, const RECHAR **ppszEnd=NULL)
	{
		ATLASSERT(szIn);
		ATLASSERT(pContext);

		if (!szIn || !pContext)
			return FALSE;

		if (ppszEnd)
			*ppszEnd = NULL;

		const RECHAR *szInput = szIn;

		if (!m_bCaseSensitive)
		{
			int nSize = CharTraits::ByteLen(szIn)+sizeof(RECHAR);
			szInput = (const RECHAR *) malloc(nSize);
			if (!szInput)
				return FALSE;

			Checked::memcpy_s((char *) szInput, nSize, szIn, nSize);
			CharTraits::Strlwr(const_cast<RECHAR *>(szInput), nSize/sizeof(RECHAR));
		}

		if (!pContext->Initialize(m_uRequiredMem, m_uNumGroups))
		{
			if (szInput != szIn)
				free((void *) szInput);
			return FALSE;
		}

		size_t ip = 0;

		const RECHAR *sz = szInput;
		const RECHAR *szCurrInput = szInput;

#pragma warning(push)
#pragma warning(disable:4127) // conditional expression is constant

		while (1)
		{
#ifdef ATLRX_DEBUG
			OnDebugEvent(ip, szInput, sz, pContext);
#endif
			if (ip == 0)
				pContext->m_Match.szStart = sz;

			switch (GetInstruction(ip).type)
 			{
			case RE_NOP:
				ip++;
				break;

			case RE_SYMBOL:
				if (GetInstruction(ip).symbol.nSymbol == static_cast<size_t>(*sz))
				{
					sz = CharTraits::Next(sz);
					ip++;
				}
				else
				{
					ip = (size_t) pContext->Pop();
				}
				break;

			case RE_ANY:
				if (*sz)
				{
					sz = CharTraits::Next(sz);
					ip++;
				}
				else
				{
					ip = (size_t) pContext->Pop();
				}
				break;

			case RE_GROUP_START:
				pContext->m_Matches[GetInstruction(ip).group.nGroup].szStart = sz;
				ip++;
				break;

			case RE_GROUP_END:
				pContext->m_Matches[GetInstruction(ip).group.nGroup].szEnd = sz;
				ip++;
				break;

			case RE_PUSH_CHARPOS:
				pContext->Push((void *) sz);
				ip++;
				break;

			case RE_POP_CHARPOS:
				sz = (RECHAR *) pContext->Pop();
				ip++;
				break;

			case RE_CALL:
				pContext->Push(ip+1);
				ip = GetInstruction(ip).call.nTarget;
				break;

			case RE_JMP:
				ip = GetInstruction(ip).jmp.nTarget;
				break;

			case RE_RETURN:
				ip = (size_t) pContext->Pop();
				break;

			case RE_PUSH_MEMORY:
				pContext->Push((void *) (pContext->m_Mem[GetInstruction(ip).memory.nIndex]));
				ip++;
				break;

			case RE_POP_MEMORY:
				pContext->m_Mem[GetInstruction(ip).memory.nIndex] = pContext->Pop();
				ip++;
				break;

			case RE_STORE_CHARPOS:
				pContext->m_Mem[GetInstruction(ip).memory.nIndex] = (void *) sz;
				ip++;
				break;

			case RE_GET_CHARPOS:
				sz = (RECHAR *) pContext->m_Mem[GetInstruction(ip).memory.nIndex];
				ip++;
				break;

			case RE_STORE_STACKPOS:
				pContext->m_Mem[GetInstruction(ip).memory.nIndex] = (void *) pContext->m_nTos;
				ip++;
				break;

			case RE_GET_STACKPOS:
				pContext->m_nTos = (size_t) pContext->m_Mem[GetInstruction(ip).memory.nIndex];
				ip++;
				break;

			case RE_RET_NOMATCH:
				if (sz == (RECHAR *) pContext->m_Mem[GetInstruction(ip).memory.nIndex])
				{
					// do a return
					ip = (size_t) pContext->Pop();
				}
				else
					ip++;
				break;

			case RE_ADVANCE:
				sz = CharTraits::Next(szCurrInput);
				szCurrInput = sz;
				if (*sz == '\0')
					goto Error;
				ip = 0;
				pContext->m_nTos = 0;
				break;

			case RE_FAIL:
				goto Error;

			case RE_RANGE:
				{
					if (*sz == '\0')
					{
						ip = (size_t) pContext->Pop();
						break;
					}

					RECHAR *pBits = reinterpret_cast<RECHAR *>((&m_Instructions[ip]+1));
					size_t u = CharTraits::GetBitFieldForRangeArrayIndex(sz);
					if (pBits[u >> 3] & 1 << (u & 0x7))
					{
						ip += InstructionsPerRangeBitField();
						ip++;
						sz = CharTraits::Next(sz);
					}
					else
					{
						ip = (size_t) pContext->Pop();
					}
				}
				break;

			case RE_NOTRANGE:
				{
					if (*sz == '\0')
					{
						ip = (size_t) pContext->Pop();
						break;
					}

					RECHAR *pBits = reinterpret_cast<RECHAR *>((&m_Instructions[ip]+1));
					size_t u = static_cast<size_t>(* ((RECHAR *) sz));
					if (pBits[u >> 3] & 1 << (u & 0x7))
					{
						ip = (size_t) pContext->Pop();
					}
					else
					{
						ip += InstructionsPerRangeBitField();
						ip++;
						sz = CharTraits::Next(sz);
					}
				}
				break;

			case RE_RANGE_EX:
				{
					if (*sz == '\0')
					{
						ip = (size_t) pContext->Pop();
						break;
					}

					BOOL bMatch = FALSE;
					size_t inEnd = GetInstruction(ip).range.nTarget;
					ip++;

					while (ip < inEnd)
					{						
						if (static_cast<size_t>(*sz) >= GetInstruction(ip).memory.nIndex && 
							static_cast<size_t>(*sz) <= GetInstruction(ip+1).memory.nIndex)
						{
							// if we match, we jump to the end
							sz = CharTraits::Next(sz);
							ip = inEnd;
							bMatch = TRUE;
						}
						else
						{
							ip += 2;
						}
					}
					if (!bMatch)
					{
						ip = (size_t) pContext->Pop();
					}
				}
				break;

			case RE_NOTRANGE_EX:
				{
					if (*sz == '\0')
					{
						ip = (size_t) pContext->Pop();
						break;
					}

					BOOL bMatch = TRUE;
					size_t inEnd = GetInstruction(ip).range.nTarget;
					ip++;

					while (ip < inEnd)
					{
						if (static_cast<size_t>(*sz) >= GetInstruction(ip).memory.nIndex && 
							static_cast<size_t>(*sz) <= GetInstruction(ip+1).memory.nIndex)
						{
							ip = (size_t) pContext->Pop();
							bMatch = FALSE;
							break;
						}
						else
						{
							// if we match, we jump to the end
							ip += 2;
						}
					}
					if (bMatch)
						sz = CharTraits::Next(sz);
				}
				break;

			case RE_PREVIOUS:
				{
					BOOL bMatch = FALSE;
					if (m_bCaseSensitive)
					{
						bMatch = !CharTraits::Strncmp(sz, pContext->m_Matches[GetInstruction(ip).prev.nGroup].szStart,
							pContext->m_Matches[GetInstruction(ip).prev.nGroup].szEnd-pContext->m_Matches[GetInstruction(ip).prev.nGroup].szStart);
					}
					else
					{
						bMatch = !CharTraits::Strnicmp(sz, pContext->m_Matches[GetInstruction(ip).prev.nGroup].szStart,
							pContext->m_Matches[GetInstruction(ip).prev.nGroup].szEnd-pContext->m_Matches[GetInstruction(ip).prev.nGroup].szStart);
					}
					if (bMatch)
					{
						sz += pContext->m_Matches[GetInstruction(ip).prev.nGroup].szEnd-pContext->m_Matches[GetInstruction(ip).prev.nGroup].szStart;
						ip++;
						break;
					}
					ip = (size_t) pContext->Pop();
				}
				break;

			case RE_MATCH:
				pContext->m_Match.szEnd = sz;
				if (!m_bCaseSensitive)
					FixupMatchContext(pContext, szIn, szInput);
				if (ppszEnd)
					*ppszEnd = szIn + (sz - szInput);
				if (szInput != szIn)
					free((void *) szInput);
				return TRUE;
				break;

			case RE_PUSH_GROUP:
				pContext->Push((void *) pContext->m_Matches[GetInstruction(ip).group.nGroup].szStart);
				pContext->Push((void *) pContext->m_Matches[GetInstruction(ip).group.nGroup].szEnd);
				ip++;
				break;

			case RE_POP_GROUP:
				pContext->m_Matches[GetInstruction(ip).group.nGroup].szEnd = (const RECHAR *) pContext->Pop();
				pContext->m_Matches[GetInstruction(ip).group.nGroup].szStart = (const RECHAR *) pContext->Pop();
				ip++;
				break;

			default:
				ATLASSERT(FALSE);
				break;
			}
		}

#pragma warning(pop) // 4127

		ATLASSERT(FALSE);
Error:
		pContext->m_Match.szEnd = sz;
		if (!m_bCaseSensitive)
			FixupMatchContext(pContext, szIn, szInput);
		if (ppszEnd)
			*ppszEnd = szIn + (sz - szInput);
		if (szInput != szIn)
			free((void *) szInput);
		return FALSE;
	}

protected:
	REParseError m_LastError;

	REParseError GetLastParseError() throw()
	{
		return m_LastError;
	}

	void SetLastParseError(REParseError Error) throw()
	{
		m_LastError = Error;
	}
	// CAtlRegExp::Reset
	// Removes all instructions to allow reparsing into the same instance
	void Reset() throw()
	{
		m_Instructions.RemoveAll();
		m_uRequiredMem = 0;
		m_bCaseSensitive = TRUE;
		m_uNumGroups = 0;
		SetLastParseError(REPARSE_ERROR_OK);
	}


	enum REInstructionType { 
		RE_NOP,
		RE_GROUP_START,
		RE_GROUP_END, 
		RE_SYMBOL,
		RE_ANY,
		RE_RANGE,
		RE_NOTRANGE,
		RE_RANGE_EX,
		RE_NOTRANGE_EX,
		RE_PLUS,
		RE_NG_PLUS,
		RE_QUESTION,
		RE_NG_QUESTION,
		RE_JMP,
		RE_PUSH_CHARPOS,
		RE_POP_CHARPOS,
		RE_CALL,
		RE_RETURN,
		RE_STAR_BEGIN,
		RE_NG_STAR_BEGIN, 
		RE_PUSH_MEMORY,
		RE_POP_MEMORY,
		RE_STORE_CHARPOS,
		RE_STORE_STACKPOS,
		RE_GET_CHARPOS,
		RE_GET_STACKPOS,
		RE_RET_NOMATCH,
		RE_PREVIOUS,
		RE_FAIL,
		RE_ADVANCE,
		RE_MATCH,
		RE_PUSH_GROUP,
		RE_POP_GROUP,
	};

	struct INSTRUCTION_SYMBOL
	{
		size_t nSymbol;
	};

	struct INSTRUCTION_JMP
	{
		size_t nTarget;	
	};

	struct INSTRUCTION_GROUP
	{
		size_t nGroup;
	};

	struct INSTRUCTION_CALL
	{
		size_t nTarget;
	};

	struct INSTRUCTION_MEMORY
	{
		size_t nIndex;
	};

	struct INSTRUCTION_PREVIOUS
	{
		size_t nGroup;
	};

	struct INSTRUCTION_RANGE_EX
	{
		size_t nTarget;
	};

	struct INSTRUCTION
	{
		REInstructionType type;
		union
		{
			INSTRUCTION_SYMBOL symbol;
			INSTRUCTION_JMP jmp;
			INSTRUCTION_GROUP group;
			INSTRUCTION_CALL call;
			INSTRUCTION_MEMORY memory;
			INSTRUCTION_PREVIOUS prev;
			INSTRUCTION_RANGE_EX range;
		};
	};

	inline int InstructionsPerRangeBitField() throw()
	{
		return (256/8) / sizeof(INSTRUCTION) + (((256/8) % sizeof(INSTRUCTION)) ? 1 : 0);
	}

	CAtlArray<INSTRUCTION> m_Instructions;

	UINT m_uNumGroups;
	UINT m_uRequiredMem;
	BOOL m_bCaseSensitive;


	// class used internally to restore
	// parsing state when unwinding
	class CParseState
	{
	public:
		int m_nNumInstructions;
		UINT m_uNumGroups;
		UINT m_uRequiredMem;

		CParseState(CAtlRegExp *pRegExp) throw()
		{
			m_nNumInstructions = (int) pRegExp->m_Instructions.GetCount();
			m_uNumGroups = pRegExp->m_uNumGroups;
			m_uRequiredMem = pRegExp->m_uRequiredMem;
		}

		void Restore(CAtlRegExp *pRegExp)
		{
			pRegExp->m_Instructions.SetCount(m_nNumInstructions);
			pRegExp->m_uNumGroups = m_uNumGroups;
			pRegExp->m_uRequiredMem = m_uRequiredMem;
		}
	};

	int AddInstruction(REInstructionType type)
	{
		if (!m_Instructions.SetCount(m_Instructions.GetCount()+1))
		{
			SetLastParseError(REPARSE_ERROR_OUTOFMEMORY);
			return -1;
		}

		m_Instructions[m_Instructions.GetCount()-1].type = type;
		return (int) m_Instructions.GetCount()-1;
	}

	BOOL PeekToken(const RECHAR **ppszRE, int ch) throw()
	{
		if (**ppszRE != ch)
			return FALSE;
		return TRUE;
	}

	BOOL MatchToken(const RECHAR **ppszRE, int ch) throw()
	{
		if (!PeekToken(ppszRE, ch))
			return FALSE;
		*ppszRE = CharTraits::Next(*ppszRE);
		return TRUE;
	}

	INSTRUCTION &GetInstruction(size_t nIndex) throw()
	{
		return m_Instructions[nIndex];
	}

	// ParseArg: parse grammar rule Arg
	int ParseArg(const RECHAR **ppszRE, bool &bEmpty)
	{
		int nPushGroup = AddInstruction(RE_PUSH_GROUP);
		if (nPushGroup < 0)
			return -1;

		GetInstruction(nPushGroup).group.nGroup = m_uNumGroups;

		int p = AddInstruction(RE_GROUP_START);
		if (p < 0)
			return -1;
		GetInstruction(p).group.nGroup = m_uNumGroups++;

		int nCall = AddInstruction(RE_CALL);
		if (nCall < 0)
			return -1;

		int nPopGroup = AddInstruction(RE_POP_GROUP);
		if (nPopGroup < 0)
			return -1;
		GetInstruction(nPopGroup).group.nGroup = GetInstruction(nPushGroup).group.nGroup;

		if (AddInstruction(RE_RETURN) < 0)
			return -1;

		int nAlt = ParseRE(ppszRE, bEmpty);
		if (nAlt < 0)
		{
			if (GetLastParseError())
				return -1;

			if (!PeekToken(ppszRE, '}'))
			{
				SetLastParseError(REPARSE_ERROR_BRACE_EXPECTED);
				return -1;
			}

			// in the case of an empty group, we add a nop
			nAlt = AddInstruction(RE_NOP);
			if (nAlt < 0)
				return -1;
		}

		GetInstruction(nCall).call.nTarget = nAlt;

		if (!MatchToken(ppszRE, '}'))
		{
			SetLastParseError(REPARSE_ERROR_BRACE_EXPECTED);
			return -1;
		}

		int nEnd = AddInstruction(RE_GROUP_END);
		if (nEnd < 0)
			return -1;
		GetInstruction(nEnd).group.nGroup = GetInstruction(p).group.nGroup;
		return nPushGroup;
	}

	// ParseGroup: parse grammar rule Group
	int ParseGroup(const RECHAR **ppszRE, bool &bEmpty)
	{
		int nCall = AddInstruction(RE_CALL);
		if (nCall < 0)
			return -1;

		if (AddInstruction(RE_RETURN) < 0)
			return -1;

		int nAlt = ParseRE(ppszRE, bEmpty);
		if (nAlt < 0)
		{
			if (GetLastParseError())
				return -1;

			if (!PeekToken(ppszRE, ')'))
			{
				SetLastParseError(REPARSE_ERROR_PAREN_EXPECTED);
				return -1;
			}

			// in the case of an empty group, we add a nop
			nAlt = AddInstruction(RE_NOP);
			if (nAlt < 0)
				return -1;
		}

		GetInstruction(nCall).call.nTarget = nAlt;

		if (!MatchToken(ppszRE, ')'))
		{
			SetLastParseError(REPARSE_ERROR_PAREN_EXPECTED);
			return -1;
		}

		return nCall;
	}

	RECHAR GetEscapedChar(RECHAR ch) throw()
	{
		if (ch == 't')
			return '\t';
		return ch;
	}

	// ParseCharItem: parse grammar rule CharItem
	int ParseCharItem(const RECHAR **ppszRE, RECHAR *pchStartChar, RECHAR *pchEndChar) throw()
	{
		if (**ppszRE == '\\')
		{
			*ppszRE = CharTraits::Next(*ppszRE);
			*pchStartChar = GetEscapedChar(**ppszRE);
		}
		else
			*pchStartChar = **ppszRE;
		*ppszRE = CharTraits::Next(*ppszRE);

		if (!MatchToken(ppszRE, '-'))
		{
			*pchEndChar = *pchStartChar;
			return 0;
		}

		// check for unterminated range
		if (!**ppszRE || PeekToken(ppszRE, ']'))
		{
			SetLastParseError(REPARSE_ERROR_BRACKET_EXPECTED);
			return -1;
		}

		*pchEndChar = **ppszRE;
		*ppszRE = CharTraits::Next(*ppszRE);

		if (*pchEndChar < *pchStartChar)
		{
			SetLastParseError(REPARSE_ERROR_INVALID_RANGE);
			return -1;
		}
		return 0;
	}

	int AddInstructions(int nNumInstructions)
	{
		size_t nCurr = m_Instructions.GetCount();
		if (!m_Instructions.SetCount(nCurr+nNumInstructions))
		{
			SetLastParseError(REPARSE_ERROR_OUTOFMEMORY);
			return -1;
		}
		return (int) nCurr;
	}

	// ParseCharSet: parse grammar rule CharSet
	int ParseCharSet(const RECHAR **ppszRE, BOOL bNot)
	{
		int p = -1;

		unsigned char *pBits = NULL;

		if (CharTraits::UseBitFieldForRange())
		{
			// we use a bit field to represent the characters
			// a 1 bit means match against the character
			// the last 5 bits are used as an index into 
			// the byte array, and the first 3 bits
			// are used to index into the selected byte

			p = AddInstruction(bNot ? RE_NOTRANGE : RE_RANGE);
			if (p < 0)
				return -1;

			// add the required space to hold the character
			// set.  We use one bit per character for ansi
			if (AddInstructions(InstructionsPerRangeBitField()) < 0)
				return -1;

			pBits = (unsigned char *) (&m_Instructions[p+1]);
			memset(pBits, 0x00, 256/8);
		}
		else
		{
			p = AddInstruction(bNot ? RE_NOTRANGE_EX : RE_RANGE_EX);
			if (p < 0)
				return -1;
		}

		RECHAR chStart;
		RECHAR chEnd;

		while (**ppszRE && **ppszRE != ']')
		{
			if (ParseCharItem(ppszRE, &chStart, &chEnd))
				return -1;

			if (CharTraits::UseBitFieldForRange())
			{
				for (int i=chStart; i<=chEnd; i++)
					pBits[i >> 3] |= 1 << (i & 0x7);
			}
			else
			{
				int nStart = AddInstruction(RE_NOP);
				if (nStart < 0)
					return -1;

				int nEnd = AddInstruction(RE_NOP);
				if (nEnd < 0)
					return -1;

				GetInstruction(nStart).memory.nIndex = (int) chStart;
				GetInstruction(nEnd).memory.nIndex = (int) chEnd;
			}
		}

		if (!CharTraits::UseBitFieldForRange())
			GetInstruction(p).range.nTarget = m_Instructions.GetCount();

		return p;
	}

	// ParseCharClass: parse grammar rule CharClass
	int ParseCharClass(const RECHAR **ppszRE, bool &bEmpty)
	{
		bEmpty = false;
		if (MatchToken(ppszRE, ']'))
		{
			SetLastParseError(REPARSE_ERROR_EMPTY_RANGE);
			return -1;
		}

		BOOL bNot = FALSE;
		if (MatchToken(ppszRE, '^'))
			bNot = TRUE;

		if (MatchToken(ppszRE, ']'))
		{
			SetLastParseError(REPARSE_ERROR_EMPTY_RANGE);
			return -1;
		}

		int p = ParseCharSet(ppszRE, bNot);
		if (p < 0)
			return p;
		if (!MatchToken(ppszRE, ']'))
		{
			SetLastParseError(REPARSE_ERROR_BRACKET_EXPECTED);
			return -1;
		}

		return p;
	}

	int AddMemInstruction(REInstructionType type)
	{
		int p = AddInstruction(type);
		if (p < 0)
			return p;
		GetInstruction(p).memory.nIndex = m_uRequiredMem++;
		return p;
	}

	// helper for parsing !SE
	int ParseNot(const RECHAR **ppszRE, bool &bEmpty)
	{
		int nStoreCP = AddMemInstruction(RE_STORE_CHARPOS);
		int nStoreSP = AddMemInstruction(RE_STORE_STACKPOS);

		int nCall = AddInstruction(RE_CALL);
		if (nCall < 0)
			return -1;

		int nGetCP = AddInstruction(RE_GET_CHARPOS);
		if (nGetCP < 0)
			return -1;
		GetInstruction(nGetCP).memory.nIndex = GetInstruction(nStoreCP).memory.nIndex;

		int nGetSP = AddInstruction(RE_GET_STACKPOS);
		if (nGetSP < 0)
			return -1;
		GetInstruction(nGetSP).memory.nIndex = GetInstruction(nStoreSP).memory.nIndex;

		int nJmp = AddInstruction(RE_JMP);
		if (nJmp < 0)
			return -1;

		int nSE = ParseSE(ppszRE, bEmpty);
		if (nSE < 0)
			return nSE;

		// patch the call
		GetInstruction(nCall).call.nTarget = nSE;

		int nGetCP1 = AddInstruction(RE_GET_CHARPOS);
		if (nGetCP1 < 0)
			return -1;
		GetInstruction(nGetCP1).memory.nIndex = GetInstruction(nStoreCP).memory.nIndex;

		int nGetSP1 = AddInstruction(RE_GET_STACKPOS);
		if (nGetSP1 < 0)
			return -1;
		GetInstruction(nGetSP1).memory.nIndex = GetInstruction(nStoreSP).memory.nIndex;

		int nRet = AddInstruction(RE_RETURN);
		if (nRet < 0)
			return -1;

		GetInstruction(nJmp).jmp.nTarget = nRet+1;

		return nStoreCP;
	}

	// ParseAbbrev: parse grammar rule Abbrev
	int ParseAbbrev(const RECHAR **ppszRE, bool &bEmpty)
	{
		const RECHAR **szAbbrevs = CharTraits::GetAbbrevs();

		while (*szAbbrevs)
		{
			if (**ppszRE == **szAbbrevs)
			{
				const RECHAR *szAbbrev = (*szAbbrevs)+1;
				int p = ParseE(&szAbbrev, bEmpty);
				if (p < 0)
				{
					SetLastParseError(REPARSE_ERROR_UNEXPECTED);
					return p;
				}
				*ppszRE = CharTraits::Next(*ppszRE);
				return p;
			}
			szAbbrevs++;
		}
		return -1;
	}

	// ParseSE: parse grammar rule SE (simple expression)
	int ParseSE(const RECHAR **ppszRE, bool &bEmpty)
	{

		if (MatchToken(ppszRE, '{'))
			return ParseArg(ppszRE, bEmpty);
		if (MatchToken(ppszRE, '('))
			return ParseGroup(ppszRE, bEmpty);
		if (MatchToken(ppszRE, '['))
			return ParseCharClass(ppszRE, bEmpty);

		if (MatchToken(ppszRE, '\\'))
		{
			if (!CharTraits::Isdigit(**ppszRE))
			{
				// check for abbreviations
				int p;
				p = ParseAbbrev(ppszRE, bEmpty);
				if (p >= 0)
					return p;

				if (GetLastParseError())
					return -1;

				// escaped char
				p = AddInstruction(RE_SYMBOL);
				if (p < 0)
					return -1;
				GetInstruction(p).symbol.nSymbol = (int) **ppszRE;
				*ppszRE = CharTraits::Next(*ppszRE);
				return p;
			}
			// previous match
			bEmpty = false;
			int nPrev = AddInstruction(RE_PREVIOUS);
			if (nPrev < 0)
				return -1;

			UINT uValue = (UINT) CharTraits::Strtol(*ppszRE, (RECHAR **) ppszRE, 10);
			if (uValue >= m_uNumGroups)
			{
				SetLastParseError(REPARSE_ERROR_INVALID_GROUP);
				return -1;
			}
			GetInstruction(nPrev).prev.nGroup = (size_t) uValue;
			return nPrev;
		}

		if (MatchToken(ppszRE, '!'))
			return ParseNot(ppszRE, bEmpty);

		if (**ppszRE == '}' || **ppszRE == ']' || **ppszRE == ')')
		{
			return -1;
		}

		if (**ppszRE == '\0')
		{
			return -1;
		}

		int p;
		if (**ppszRE == '.')
		{
			p = AddInstruction(RE_ANY);
			if (p < 0)
				return -1;
			bEmpty = false;
		}
		else if (**ppszRE == '$' && (*ppszRE)[1] == '\0')
		{
			p = AddInstruction(RE_SYMBOL);
			if (p < 0)
				return -1;
			GetInstruction(p).symbol.nSymbol = 0;
			bEmpty = false;
		}
		else
		{
			p = AddInstruction(RE_SYMBOL);
			if (p < 0)
				return -1;
			GetInstruction(p).symbol.nSymbol = (int) **ppszRE;
			bEmpty = false;
		}
		*ppszRE = CharTraits::Next(*ppszRE);
		return p;
	}

	// ParseE: parse grammar rule E (expression)
	int ParseE(const RECHAR **ppszRE, bool &bEmpty)
	{
		CParseState ParseState(this);
		const RECHAR *sz = *ppszRE;

		int nSE;

		int nFirst = ParseSE(ppszRE, bEmpty);
		if (nFirst < 0)
			return nFirst;

		REInstructionType type = RE_MATCH;

		if (MatchToken(ppszRE, '*'))
			if(MatchToken(ppszRE, '?'))
				type = RE_NG_STAR_BEGIN;
			else
				type = RE_STAR_BEGIN;


		else if (MatchToken(ppszRE, '+'))
			if(MatchToken(ppszRE, '?'))
				type = RE_NG_PLUS;
			else
				type = RE_PLUS;

		else if (MatchToken(ppszRE, '?'))
			if(MatchToken(ppszRE, '?'))
				type = RE_NG_QUESTION;
			else
				type = RE_QUESTION;


		if (type == RE_MATCH)
			return nFirst;

		if (type == RE_STAR_BEGIN || type == RE_QUESTION|| type == RE_NG_STAR_BEGIN || type == RE_NG_QUESTION)
		{
			ParseState.Restore(this);
		}
		else
		{
			m_uNumGroups = ParseState.m_uNumGroups;
		}
		*ppszRE = sz;

		int nE;

		if (type == RE_NG_STAR_BEGIN || type == RE_NG_PLUS || type == RE_NG_QUESTION) // Non-Greedy
		{			
			int nCall = AddInstruction(RE_CALL);
			if (nCall < 0)
				return -1;

			bEmpty = false;

			nSE = ParseSE(ppszRE, bEmpty);
			if (nSE < 0)
				return nSE;

			if (bEmpty && (type == RE_NG_STAR_BEGIN || type == RE_NG_PLUS))
			{
				SetLastParseError(REPARSE_ERROR_EMPTY_REPEATOP);
				return -1;
			}
			bEmpty = true;

			*ppszRE = CharTraits::Next(*ppszRE);
			*ppszRE = CharTraits::Next(*ppszRE);

			if (type == RE_NG_STAR_BEGIN || type == RE_NG_PLUS)
			{
				int nJmp = AddInstruction(RE_JMP);
				if (nJmp < 0)
					return -1;
				GetInstruction(nCall).call.nTarget = nJmp+1;
				GetInstruction(nJmp).jmp.nTarget = nCall;
			}
			else
				GetInstruction(nCall).call.nTarget = nSE+1;

			if (type == RE_NG_PLUS)
				nE = nFirst;
			else
				nE = nCall;
		}
		else // Greedy
		{

			int nPushMem = AddInstruction(RE_PUSH_MEMORY);
			if (nPushMem < 0)
				return -1;

			int nStore = AddInstruction(RE_STORE_CHARPOS);
			if (nStore < 0)
				return -1;

			if (AddInstruction(RE_PUSH_CHARPOS) < 0)
				return -1;

			int nCall = AddInstruction(RE_CALL);
			if (nCall < 0)
				return -1;

			if (AddInstruction(RE_POP_CHARPOS) < 0)
				return -1;

			int nPopMem = AddInstruction(RE_POP_MEMORY);
			if (nPopMem < 0)
				return -1;

			int nJmp = AddInstruction(RE_JMP);
			if (nJmp < 0)
				return -1;

			GetInstruction(nPushMem).memory.nIndex = m_uRequiredMem++;
			GetInstruction(nStore).memory.nIndex = GetInstruction(nPushMem).memory.nIndex;
			GetInstruction(nCall).call.nTarget = nJmp+1;
			GetInstruction(nPopMem).memory.nIndex = GetInstruction(nPushMem).memory.nIndex;

			bEmpty = false;

			nSE = ParseSE(ppszRE, bEmpty);
			if (nSE < 0)
				return nSE;

			if (bEmpty && (type == RE_STAR_BEGIN || type == RE_PLUS))
			{
				SetLastParseError(REPARSE_ERROR_EMPTY_REPEATOP);
				return -1;
			}

			if (type != RE_PLUS && type != RE_NG_PLUS)
				bEmpty = true;

			*ppszRE = CharTraits::Next(*ppszRE);


			int nRetNoMatch = AddInstruction(RE_RET_NOMATCH);
			if (nRetNoMatch < 0)
				return -1;

			int nStore1 = AddInstruction(RE_STORE_CHARPOS);
			if (nStore1 < 0)
				return -1;

			GetInstruction(nRetNoMatch).memory.nIndex = GetInstruction(nPushMem).memory.nIndex;
			GetInstruction(nStore1).memory.nIndex = GetInstruction(nPushMem).memory.nIndex;

			if (type != RE_QUESTION)
			{
				int nJmp1 = AddInstruction(RE_JMP);
				if (nJmp1 < 0)
					return -1;
				GetInstruction(nJmp1).jmp.nTarget = nPushMem;
			}

			GetInstruction(nJmp).jmp.nTarget = m_Instructions.GetCount();
			if (type == RE_PLUS)
				nE = nFirst;
			else
				nE = nPushMem;
		}

		return nE;
	}


	// ParseAltE: parse grammar rule AltE
	int ParseAltE(const RECHAR **ppszRE, bool &bEmpty)
	{
		const RECHAR *sz = *ppszRE;
		CParseState ParseState(this);

		int nPush = AddInstruction(RE_PUSH_CHARPOS);
		if (nPush < 0)
			return -1;

		int nCall = AddInstruction(RE_CALL);
		if (nCall < 0)
			return -1;

		GetInstruction(nCall).call.nTarget = nPush+4;
		if (AddInstruction(RE_POP_CHARPOS) < 0)
			return -1;

		int nJmpNext = AddInstruction(RE_JMP);
		if (nJmpNext < 0)
			return -1;

		int nE = ParseE(ppszRE, bEmpty);
		if (nE < 0)
		{
			if (GetLastParseError())
				return -1;
			ParseState.Restore(this);
			return nE;
		}

		int nJmpEnd = AddInstruction(RE_JMP);
		if (nJmpEnd < 0)
			return -1;

		GetInstruction(nJmpNext).jmp.nTarget = nJmpEnd+1;

		if (!MatchToken(ppszRE, '|'))
		{
			ParseState.Restore(this);
			*ppszRE = sz;

			return ParseE(ppszRE, bEmpty);
		}

		bool bEmptyAltE;
		int nAltE = ParseAltE(ppszRE, bEmptyAltE);
		GetInstruction(nJmpEnd).jmp.nTarget = m_Instructions.GetCount();
		GetInstruction(nJmpNext).jmp.nTarget = nAltE;
		if (nAltE < 0)
		{
			if (GetLastParseError())
				return -1;
			ParseState.Restore(this);
			return nAltE;
		}
		bEmpty = bEmpty | bEmptyAltE;
		return nPush;
	}

	// ParseRE: parse grammar rule RE (regular expression)
	int ParseRE(const RECHAR **ppszRE, bool &bEmpty)
	{
		if (**ppszRE == '\0')
			return -1;

		int p = ParseAltE(ppszRE, bEmpty);
		if (p < 0)
			return p;

		bool bEmptyRE = true;
		ParseRE(ppszRE, bEmptyRE);
		if (GetLastParseError())
			return -1;
		bEmpty = bEmpty && bEmptyRE;
		return p;
	}

	//pointers to the matched string and matched groups, currently point into an internal allocated 
	//buffer that hold a copy of the input string.
	//This function fix these pointers to point into the original, user supplied buffer (first param to Match method).
	//Example: If a ptr (szStart) currently point to <internal buffer>+3, it is fixed to <user supplied buffer>+3
	void FixupMatchContext(CAtlREMatchContext<CharTraits> *pContext, const RECHAR *szOrig, const RECHAR *szNew) 
	{
		ATLENSURE(pContext);
		ATLASSERT(szOrig);
		ATLASSERT(szNew);

		pContext->m_Match.szStart = szOrig + (pContext->m_Match.szStart - szNew);
		pContext->m_Match.szEnd = szOrig + (pContext->m_Match.szEnd - szNew);
		for (UINT i=0; i<pContext->m_uNumGroups; i++)
		{
			if (pContext->m_Matches[i].szStart==NULL || pContext->m_Matches[i].szEnd==NULL)
			{
				continue; //Do not fix unmatched groups.
			}
			pContext->m_Matches[i].szStart = szOrig + (pContext->m_Matches[i].szStart - szNew);
			pContext->m_Matches[i].szEnd = szOrig + (pContext->m_Matches[i].szEnd - szNew);
		}
	}
	// implementation
	// helpers for dumping and debugging the rx engine
public:
#ifdef ATL_REGEXP_DUMP
	size_t DumpInstruction(size_t ip)
	{
		printf("%08x ", ip);
		switch (GetInstruction(ip).type)
		{
		case RE_NOP:
			printf("NOP\n");
			ip++;
			break;

		case RE_SYMBOL:
			AtlprintfT<RECHAR>(CAToREChar<RECHAR>("Symbol %c\n"),GetInstruction(ip).symbol.nSymbol);			
			ip++;
			break;

		case RE_ANY:
			printf("Any\n");
			ip++;
			break;

		case RE_RANGE:
			printf("Range\n");
			ip++;
			ip += InstructionsPerRangeBitField();
			break;

		case RE_NOTRANGE:
			printf("NOT Range\n");
			ip++;
			ip += InstructionsPerRangeBitField();
			break;

		case RE_RANGE_EX:
			printf("RangeEx %08x\n", GetInstruction(ip).range.nTarget);
			ip++;
			break;

		case RE_NOTRANGE_EX:
			printf("NotRangeEx %08x\n", GetInstruction(ip).range.nTarget);
			ip++;
			break;

		case RE_GROUP_START:
			printf("Start group %d\n", GetInstruction(ip).group.nGroup);
			ip++;
			break;

		case RE_GROUP_END:
			printf("Group end %d\n", GetInstruction(ip).group.nGroup);
			ip++;
			break;

		case RE_PUSH_CHARPOS:
			printf("Push char pos\n");
			ip++;
			break;

		case RE_POP_CHARPOS:
			printf("Pop char pos\n");
			ip++;
			break;

		case RE_STORE_CHARPOS:
			printf("Store char pos %d\n", GetInstruction(ip).memory.nIndex);
			ip++;
			break;

		case RE_GET_CHARPOS:
			printf("Get char pos %d\n", GetInstruction(ip).memory.nIndex);
			ip++;
			break;

		case RE_STORE_STACKPOS:
			printf("Store stack pos %d\n", GetInstruction(ip).memory.nIndex);
			ip++;
			break;

		case RE_GET_STACKPOS:
			printf("Get stack pos %d\n", GetInstruction(ip).memory.nIndex);
			ip++;
			break;

		case RE_CALL:
			printf("Call %08x\n", GetInstruction(ip).call.nTarget);
			ip++;
			break;

		case RE_JMP:
			printf("Jump %08x\n", GetInstruction(ip).jmp.nTarget);
			ip++;
			break;

		case RE_RETURN:
			printf("return\n");
			ip++;
			break;

		case RE_PUSH_MEMORY:
			printf("Push memory %08x\n", GetInstruction(ip).memory.nIndex);
			ip++;
			break;

		case RE_POP_MEMORY:
			printf("Pop memory %08x\n", GetInstruction(ip).memory.nIndex);
			ip++;
			break;

		case RE_RET_NOMATCH:
			printf("Return no match %08x\n", GetInstruction(ip).memory.nIndex);
			ip++;
			break;

		case RE_MATCH:
			printf("END\n");
			ip++;
			break;

		case RE_ADVANCE:
			printf("ADVANCE\n");
			ip++;
			break;

		case RE_FAIL:
			printf("FAIL\n");
			ip++;
			break;

		case RE_PREVIOUS:
			printf("Prev %d\n", GetInstruction(ip).prev.nGroup);
			ip++;
			break;

		case RE_PUSH_GROUP:
			printf("Push group %d\n", GetInstruction(ip).group.nGroup);
			ip++;
			break;

		case RE_POP_GROUP:
			printf("Pop group %d\n", GetInstruction(ip).group.nGroup);
			ip++;
			break;


		default:
			printf("????\n");
			ip++;
			break;
		}
		return ip;
	}

	void Dump(size_t ipCurrent = 0)
	{
		size_t ip = 0;

		while (ip < m_Instructions.GetCount())
		{
			if (ip == ipCurrent)
				printf("->");
			ip = DumpInstruction(ip);
		}
	}
#endif

#ifdef ATLRX_DEBUG
	 void cls( HANDLE hConsole )
	{
		COORD coordScreen = { 0, 0 };    /* here's where we'll home the
											cursor */ 
		BOOL bSuccess;
		DWORD cCharsWritten;
		CONSOLE_SCREEN_BUFFER_INFO csbi; /* to get buffer info */ 
		DWORD dwConSize;                 /* number of character cells in
											the current buffer */ 

		/* get the number of character cells in the current buffer */ 

		bSuccess = GetConsoleScreenBufferInfo( hConsole, &csbi );
		dwConSize = csbi.dwSize.X * csbi.dwSize.Y;

		/* fill the entire screen with blanks */ 

		bSuccess = FillConsoleOutputCharacter( hConsole, (TCHAR) ' ',
		   dwConSize, coordScreen, &cCharsWritten );

		/* get the current text attribute */ 

		bSuccess = GetConsoleScreenBufferInfo( hConsole, &csbi );

		/* now set the buffer's attributes accordingly */ 

		bSuccess = FillConsoleOutputAttribute( hConsole, csbi.wAttributes,
		   dwConSize, coordScreen, &cCharsWritten );

		/* put the cursor at (0, 0) */ 

		bSuccess = SetConsoleCursorPosition( hConsole, coordScreen );
		return;
	} 

	void DumpStack(CAtlREMatchContext<CharTraits> *pContext)
	{
		for (size_t i=pContext->m_nTos; i>0; i--)
		{
			if (pContext->m_stack[i] < (void *) m_Instructions.GetCount())
				printf("0x%p\n", pContext->m_stack[i]);
			else
			{
				// assume a pointer into the input
				AtlprintfT<RECHAR>(CAToREChar<RECHAR>("%s\n"), pContext->m_stack[i]);
			}
		}
	}

	void DumpMemory(CAtlREMatchContext<CharTraits> *pContext)
	{
		for (UINT i=0; i<m_uRequiredMem; i++)
		{
			AtlprintfT<RECHAR>(CAToREChar<RECHAR>("%d: %s\n"), i, pContext->m_Mem.m_p[i]);
		}
	}

	virtual void OnDebugEvent(size_t ip, const RECHAR *szIn, const RECHAR *sz, CAtlREMatchContext<CharTraits> *pContext)
	{
		cls(GetStdHandle(STD_OUTPUT_HANDLE));
		printf("----------Code---------\n");
		Dump(ip);
		printf("----------Input---------\n");		
		AtlprintfT<RECHAR>(CAToREChar<RECHAR>("%s\n"), szIn);
		for (int s=0; szIn+s < sz; s++)
		{
			printf(" ");
		}		
		printf("^\n");
		printf("----------Memory---------\n");
		DumpMemory(pContext);
		printf("----------Stack---------\n");		
		DumpStack(pContext);
		getchar();
	}
#endif

};

} // namespace ATL
#pragma pack(pop)

#endif // __ATLRX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlsafe.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSAFE_H__
#define __ATLSAFE_H__

#pragma once

#include <atlbase.h>


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

// This struct is used with CComSafeArray to set the matching VARTYPE based on
// template argument type passed in to CComSafeArray.
template <typename T>
struct _ATL_AutomationType
{
};

#define DEFINE_AUTOMATION_TYPE_FUNCTION(ctype, typewrapper, oleautomationtype) \
	template <> \
	struct _ATL_AutomationType<ctype> \
	{ \
		typedef typewrapper _typewrapper;\
		enum { type = oleautomationtype }; \
		static void* GetT(const ctype& t) throw() \
		{ \
			return (void*)&t; \
		} \
	};
	// specialization for BSTR so GetT doesn't return &BSTR
	template <>
	struct _ATL_AutomationType<BSTR>
	{
		typedef CComBSTR _typewrapper ;
		enum { type = VT_BSTR};
		static void* GetT(const BSTR& t) throw()
		{
			return t;
		}
	};
	// specialization for LPUNKNOWN so GetT doesn't return &LPUNKNOWN
	template <>
	struct _ATL_AutomationType<LPUNKNOWN>
	{
		typedef CComPtr<IUnknown> _typewrapper;
		enum { type = VT_UNKNOWN};
		static void* GetT(const LPUNKNOWN& t) throw()
		{
			return t;
		}
	};
	// specialization for LPDISPATCH so GetT doesn't return &LPDISPATCH
	template <>
	struct _ATL_AutomationType<LPDISPATCH>
	{
		typedef CComPtr<IDispatch> _typewrapper;
		enum { type = VT_DISPATCH};
		static void* GetT(const LPDISPATCH& t) throw()
		{
			return t;
		}
	};

	DEFINE_AUTOMATION_TYPE_FUNCTION(CHAR		, CHAR			,VT_I1)
	DEFINE_AUTOMATION_TYPE_FUNCTION(SHORT		, SHORT			,VT_I2)
	DEFINE_AUTOMATION_TYPE_FUNCTION(INT			, INT			,VT_I4)
	DEFINE_AUTOMATION_TYPE_FUNCTION(LONG		, LONG			,VT_I4)
#ifndef _WIN32_WCE
	DEFINE_AUTOMATION_TYPE_FUNCTION(LONGLONG	, LONGLONG		,VT_I8)
#endif // _WIN32_WCE
	DEFINE_AUTOMATION_TYPE_FUNCTION(BYTE		, BYTE			,VT_UI1)
	DEFINE_AUTOMATION_TYPE_FUNCTION(USHORT		, USHORT		,VT_UI2)
	DEFINE_AUTOMATION_TYPE_FUNCTION(UINT		, UINT			,VT_UI4)
	DEFINE_AUTOMATION_TYPE_FUNCTION(ULONG		, ULONG			,VT_UI4)
#ifndef _WIN32_WCE
	DEFINE_AUTOMATION_TYPE_FUNCTION(ULONGLONG	, ULONGLONG		,VT_UI8)
#endif // _WIN32_WCE
	DEFINE_AUTOMATION_TYPE_FUNCTION(FLOAT		, FLOAT			,VT_R4)
	DEFINE_AUTOMATION_TYPE_FUNCTION(DOUBLE		, DOUBLE		,VT_R8)
	DEFINE_AUTOMATION_TYPE_FUNCTION(DECIMAL		, DECIMAL		,VT_DECIMAL)
	DEFINE_AUTOMATION_TYPE_FUNCTION(VARIANT		, CComVariant	,VT_VARIANT)
	DEFINE_AUTOMATION_TYPE_FUNCTION(CY			, CY			,VT_CY)

// wrapper for SAFEARRAYBOUND used with CComSafeArray
class CComSafeArrayBound : public SAFEARRAYBOUND
{
public:
	CComSafeArrayBound(ULONG ulCount = 0, LONG lLowerBound = 0) throw()
	{
		cElements = ulCount;
		lLbound = lLowerBound;
	}
	CComSafeArrayBound& operator=(const CComSafeArrayBound& bound) throw()
	{
		cElements = bound.cElements;
		lLbound = bound.lLbound;
		return *this;
	}
	CComSafeArrayBound& operator=(ULONG ulCount) throw() 
	{
		cElements = ulCount;
		lLbound = 0;
		return *this;
	}
	ULONG GetCount() const throw()
	{
		return cElements;
	}
	ULONG SetCount(ULONG ulCount) throw()
	{
		cElements = ulCount;
		return cElements;
	}
	LONG GetLowerBound() const throw()
	{
		return lLbound;
	}
	LONG SetLowerBound(LONG lLowerBound) throw()
	{
		lLbound = lLowerBound;
		return lLbound;
	}
	LONG GetUpperBound() const throw()
	{
		return lLbound + cElements - 1;
	}
};

// wrapper for SAFEARRAY.  T is type stored (e.g. BSTR, VARIANT, etc.)
template <typename T, VARTYPE _vartype = _ATL_AutomationType<T>::type>
class CComSafeArray 
{
public:
// Constructors
	CComSafeArray() throw() : m_psa(NULL)
	{
	}
	// create SAFEARRAY where number of elements = ulCount
	explicit CComSafeArray(ULONG ulCount, LONG lLBound = 0) : m_psa(NULL)
	{
		CComSafeArrayBound bound(ulCount, lLBound);
		HRESULT hRes = Create(&bound);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	explicit CComSafeArray(const SAFEARRAYBOUND& bound) : m_psa(NULL)
	{
		HRESULT hRes = Create(&bound); 
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	// pass an array of SAFEARRAYBOUNDs for multi-dimensional
	explicit CComSafeArray(const SAFEARRAYBOUND *pBound, UINT uDims = 1) : m_psa(NULL)
	{
		ATLASSERT(pBound != NULL);
		ATLASSERT(uDims > 0);
		HRESULT hRes = Create(pBound, uDims);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	CComSafeArray(const SAFEARRAY *psaSrc) : m_psa(NULL)
	{ 
		ATLASSERT(psaSrc != NULL);
		HRESULT hRes = CopyFrom(psaSrc);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	CComSafeArray(const SAFEARRAY& saSrc) : m_psa(NULL)
	{ 
		HRESULT hRes = CopyFrom(&saSrc);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}
	CComSafeArray(const CComSafeArray& saSrc) : m_psa(NULL)
	{
		ATLASSERT(saSrc.m_psa != NULL);
		HRESULT hRes = CopyFrom(saSrc.m_psa);
		if (FAILED(hRes))
			AtlThrow(hRes);
	}

	~CComSafeArray() throw()
	{
		HRESULT hRes = Destroy();
		hRes;
		ATLASSERT(SUCCEEDED(hRes));
	} 

	HRESULT Attach(const SAFEARRAY *psaSrc) 
	{
		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

		VARTYPE vt;
		HRESULT hRes = ::ATL::AtlSafeArrayGetActualVartype(const_cast<LPSAFEARRAY>(psaSrc), &vt);
		ATLENSURE_SUCCEEDED(hRes);
		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

		hRes = Destroy();
		ATLENSURE_SUCCEEDED(hRes);

		m_psa = const_cast<LPSAFEARRAY>(psaSrc);
		hRes = Lock();

		return hRes;
	}
	LPSAFEARRAY Detach()
	{
		Unlock();
		LPSAFEARRAY pTemp = m_psa;
		m_psa = NULL;
		return pTemp;
	} 

// overloaded operators
	CComSafeArray<T>& operator=(const CComSafeArray& saSrc)
	{
		*this = saSrc.m_psa;
		return *this;
	}
	CComSafeArray<T>& operator=(const SAFEARRAY *psaSrc)
	{
		ATLASSERT(psaSrc != NULL);
		HRESULT hRes = CopyFrom(psaSrc);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return *this;
	}
	operator const SAFEARRAY *() const throw()
	{
		return m_psa; 
	}
	operator LPSAFEARRAY() throw()
	{
		return m_psa; 
	}
	LPSAFEARRAY* GetSafeArrayPtr() throw()
	{
		return &m_psa;
	}
	const typename _ATL_AutomationType<T>::_typewrapper& operator[](int nIndex) const
	{
		return GetAt(nIndex);
	}
	typename _ATL_AutomationType<T>::_typewrapper& operator[](int nIndex)
	{
		return GetAt(nIndex);
	}
	const typename _ATL_AutomationType<T>::_typewrapper& operator[](LONG nIndex) const
	{
		return GetAt(nIndex);
	}
	typename _ATL_AutomationType<T>::_typewrapper& operator[](LONG nIndex)
	{
		return GetAt(nIndex);
	}

// info functions
	LONG GetLowerBound(UINT uDim = 0) const
	{
		ATLASSUME(m_psa != NULL);
		LONG lLBound = 0;
		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return lLBound;
	}
	LONG GetUpperBound(UINT uDim = 0) const
	{
		ATLASSUME(m_psa != NULL);
		LONG lUBound = 0;
		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);
		if (FAILED(hRes))
			AtlThrow(hRes);
		return lUBound;
	}
	ULONG GetCount(UINT uDim = 0) const
	{
		ATLASSUME(m_psa != NULL);
		ATLASSERT(uDim < GetDimensions());
		LONG lLBound, lUBound;
		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);
		ATLASSERT(SUCCEEDED(hRes));
		if(FAILED(hRes))
			AtlThrow(hRes);
		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);
		ATLASSERT(SUCCEEDED(hRes));
		if(FAILED(hRes))
			AtlThrow(hRes);
		return (lUBound - lLBound + 1);
	}
	UINT GetDimensions() const
	{
		ATLASSUME(m_psa != NULL);
		return SafeArrayGetDim(m_psa);
	}
	VARTYPE GetType() const throw()
	{
		return _vartype;
	}
	bool IsSizable() const
	{
		ATLASSUME(m_psa != NULL);
		if(m_psa == NULL)
			AtlThrow(E_FAIL);
			
		return (m_psa->fFeatures & FADF_FIXEDSIZE) ? false : true;
	}

// miscellaneous functions
	const typename _ATL_AutomationType<T>::_typewrapper& GetAt(LONG lIndex) const
	{
		ATLASSUME(m_psa != NULL);
		if(m_psa == NULL)
			AtlThrow(E_FAIL);
			
		LONG lLBound = GetLowerBound();
		ATLASSERT(lIndex >= lLBound);
		ATLASSERT(lIndex <= GetUpperBound());
		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))
			AtlThrow(E_INVALIDARG);
			
		return ((_ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];
	}

	typename _ATL_AutomationType<T>::_typewrapper& GetAt(LONG lIndex)
	{
		ATLASSUME(m_psa != NULL);
		if(m_psa == NULL)
			AtlThrow(E_FAIL);
			
		LONG lLBound = GetLowerBound();
		ATLASSERT(lIndex >= lLBound);
		ATLASSERT(lIndex <= GetUpperBound());
		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))
			AtlThrow(E_INVALIDARG);
		
		return ((_ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];
	}
	HRESULT SetAt(LONG lIndex, const T& t, BOOL bCopy = TRUE)
	{
		bCopy;
		ATLASSUME(m_psa != NULL);
		if(m_psa == NULL)
			return E_FAIL;
			
		LONG lLBound = GetLowerBound();
		ATLASSERT(lIndex >= lLBound);
		ATLASSERT(lIndex <= GetUpperBound());
		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))
			return E_INVALIDARG;
			
		((T*)m_psa->pvData)[lIndex-lLBound] = t;
		return S_OK;
	}
	// multi-dimensional version
	HRESULT MultiDimGetAt(const LONG *alIndex, T& t)
	{
		ATLASSUME(m_psa != NULL);
		return SafeArrayGetElement(m_psa, const_cast<LONG*>(alIndex), &t);
	}
	// multi-dimensional version
	HRESULT MultiDimSetAt(const LONG *alIndex, const T& t)
	{
		ATLASSUME(m_psa != NULL);
		return SafeArrayPutElement(m_psa, const_cast<LONG*>(alIndex), _ATL_AutomationType<T>::GetT(t));
	}
	// append an item
	HRESULT Add(const T& t, BOOL bCopy = TRUE)
	{
		HRESULT hRes = S_OK;
		if (NULL == m_psa)
		{
			hRes = Create();
			if (FAILED(hRes))
				return hRes;
		}
		ATLASSERT(GetDimensions() == 1); // not for multi-dimensional
		LONG lLBound = GetLowerBound();
		hRes = Resize(GetCount() + 1, lLBound);
		if (SUCCEEDED(hRes))
			return SetAt(GetCount() - 1 + lLBound, t, bCopy);
		else
			return hRes;
	}
	// appends an array of type T items
	HRESULT Add(ULONG ulCount, const T *pT, BOOL bCopy = TRUE)
	{
		ATLASSERT(pT != NULL);
		ATLASSERT(ulCount > 0);
		if(pT == NULL)
			return E_INVALIDARG;
			
		HRESULT hRes = S_OK;
		if (NULL == m_psa)
		{
			hRes = Create();
			if (FAILED(hRes))
				return hRes;
		}
		ATLASSERT(GetDimensions() == 1); // not for multi-dimensional
		ULONG ulLastIndex = GetCount();
		ULONG ulTotalCount = ulLastIndex + ulCount;
		LONG lLBound = GetLowerBound();
		hRes = Resize(ulTotalCount, lLBound);
		if (SUCCEEDED(hRes))
		{
			for (ULONG ulCntr=0; ulCntr<ulCount; ulCntr++, ulLastIndex++)
			{
				hRes = SetAt(ulLastIndex + lLBound, pT[ulCntr], bCopy);
				if (FAILED(hRes))
					break;
			}
		}
		return hRes;
	}
	// appends items in the safearray
	HRESULT Add(const SAFEARRAY *psaSrc)
	{
		ATLASSERT(psaSrc != NULL);
		// safearrays must only have one dimension
		ATLASSERT(SafeArrayGetDim(const_cast<LPSAFEARRAY>(psaSrc)) == 1);

		HRESULT hRes = S_OK;
		if (NULL == m_psa)
		{
			hRes = Create();
			if (FAILED(hRes))
				return hRes;
		}
		ATLASSERT(GetDimensions() == 1);

		// types must match
		VARTYPE vt;
		hRes = ::ATL::AtlSafeArrayGetActualVartype(const_cast<LPSAFEARRAY>(psaSrc), &vt);
		if(FAILED(hRes))
			return hRes;

		if(GetType() != vt)
		{
			ATLASSERT(FALSE);
			return E_INVALIDARG;
		}

		// resize safearray
		ULONG ulCount = psaSrc->rgsabound[0].cElements;
		ULONG ulLastIndex = GetCount();
		ULONG ulTotalCount = ulLastIndex + ulCount;
		LONG lLBound = GetLowerBound();
		hRes = Resize(ulTotalCount, lLBound);
		if (SUCCEEDED(hRes))
		{
			CComSafeArray saTemp;
			hRes = saTemp.Attach(psaSrc);
			if (FAILED(hRes))
				return hRes;

			LONG lsrcLBound = saTemp.GetLowerBound();
			for(ULONG lCntr = 0; lCntr < ulCount; lCntr++, ulLastIndex++)
			{
				// copy data to end of our safearray
				hRes = SetAt(ulLastIndex + lLBound, saTemp.GetAt(lCntr + lsrcLBound));
				if (FAILED(hRes))
					break;
			}
			saTemp.Detach();
		}
		return hRes;
	}

	// Resize only resizes the right-most dimension
	HRESULT Resize(ULONG ulCount, LONG lLBound = 0)
	{
		ATLASSUME(m_psa != NULL);
		CComSafeArrayBound bound(ulCount, lLBound);
		return Resize(&bound);
	}
	// Resize only resizes the right-most dimension
	HRESULT Resize(const SAFEARRAYBOUND *pBound)
	{
		ATLASSUME(m_psa != NULL);
		ATLASSERT(pBound != NULL);
		if (!IsSizable())
        {
			return E_FAIL;
        }
		HRESULT hRes = Unlock();
		if (SUCCEEDED(hRes))
		{
			hRes = SafeArrayRedim(m_psa, const_cast<LPSAFEARRAYBOUND>(pBound));
			if (SUCCEEDED(hRes))
            {
				hRes = Lock();
            }
		}
		return hRes;
	}
	HRESULT CopyFrom(const SAFEARRAY *psaSrc)
	{
		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

		VARTYPE vt;
		HRESULT hRes = ::ATL::AtlSafeArrayGetActualVartype(const_cast<LPSAFEARRAY>(psaSrc), &vt);
		ATLENSURE_SUCCEEDED(hRes);
		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

		hRes = Destroy();
		ATLENSURE_SUCCEEDED(hRes);

		hRes = SafeArrayCopy( const_cast<LPSAFEARRAY>(psaSrc), &m_psa );
		ATLENSURE_SUCCEEDED(hRes);

		if( m_psa )
		{
			hRes = Lock();
		}
		return hRes;
	}
	HRESULT CopyTo(LPSAFEARRAY *ppArray)
	{
		ATLENSURE_THROW(ppArray != NULL, E_POINTER);
		ATLENSURE(m_psa != NULL);

		return SafeArrayCopy( m_psa, ppArray );
	}
	HRESULT Create(ULONG ulCount = 0, LONG lLBound = 0)
	{
		CComSafeArrayBound bound(ulCount, lLBound);
		return Create(&bound);
	}
	HRESULT Create(const SAFEARRAYBOUND *pBound, UINT uDims = 1)
	{
		ATLASSUME(m_psa == NULL);
		ATLASSERT(uDims > 0);
		if(m_psa != NULL)
			return E_FAIL;
			
		if(pBound == NULL || uDims == 0)
			return E_INVALIDARG;
			
		HRESULT hRes = S_OK;
		m_psa = SafeArrayCreate(_vartype, uDims, const_cast<LPSAFEARRAYBOUND>(pBound));
		if (NULL == m_psa)
			hRes = E_OUTOFMEMORY;
		else
			hRes = Lock();
		return hRes;
	}
	HRESULT Destroy()
	{
		HRESULT hRes = S_OK;
		if (m_psa != NULL)
		{
			hRes = Unlock();
			if (SUCCEEDED(hRes))
			{
				hRes = SafeArrayDestroy(m_psa);
				if (SUCCEEDED(hRes))
					m_psa = NULL;
			}
		}
		return hRes;
	}
protected:
	HRESULT Lock()
	{
		ATLASSUME(m_psa != NULL);
		return SafeArrayLock(m_psa);
	}
	HRESULT Unlock()
	{
		ATLASSUME(m_psa != NULL);
		return SafeArrayUnlock(m_psa);
	}
public:
	LPSAFEARRAY m_psa;
};

template<>
HRESULT CComSafeArray<BSTR>::SetAt(LONG lIndex, const BSTR& strData, BOOL bCopy)
{
	ATLASSERT(strData != NULL);
	if(strData == NULL)
		return E_INVALIDARG;

	ATLASSUME(m_psa != NULL);
	LONG lLBound = GetLowerBound();
	ATLASSERT(lIndex >= lLBound);
	ATLASSERT(lIndex <= GetUpperBound());	

	if((lIndex < lLBound) || (lIndex > GetUpperBound()))
		return E_INVALIDARG;

	BSTR strOrg = ((BSTR*)m_psa->pvData)[lIndex-lLBound];
	if (strOrg)
		::SysFreeString(strOrg);

	if (bCopy)
	{
		BSTR strTemp = ::SysAllocString(strData);
		if (NULL == strTemp)
			return E_OUTOFMEMORY;
		((BSTR*)m_psa->pvData)[lIndex-lLBound] = strTemp;
	}
	else
		((BSTR*)m_psa->pvData)[lIndex-lLBound] = strData;

	return S_OK;
}
template<>
HRESULT CComSafeArray<VARIANT>::SetAt(LONG lIndex, const VARIANT& varData, BOOL bCopy)
{
	ATLASSUME(m_psa != NULL);
	LONG lLBound = GetLowerBound();
	ATLASSERT(lIndex >= lLBound);
	ATLASSERT(lIndex <= GetUpperBound());

	if((lIndex < lLBound) || (lIndex > GetUpperBound()))
		return E_INVALIDARG;

	if (bCopy)
		return VariantCopyInd(&((VARIANT*)m_psa->pvData)[lIndex-lLBound], const_cast<LPVARIANT>(&varData));
	else
	{	
		VARIANT varOrg = ((VARIANT*)m_psa->pvData)[lIndex-lLBound];
		if (V_VT(&varOrg) != VT_EMPTY)
			::VariantClear(&varOrg);
		((VARIANT*)m_psa->pvData)[lIndex-lLBound] = varData;
		return S_OK;
	}
}
template<>
HRESULT CComSafeArray<LPUNKNOWN>::SetAt(LONG lIndex, const LPUNKNOWN& pUnk, BOOL bAddRef)
{
	ATLENSURE_RETURN(pUnk != NULL);
	ATLASSUME(m_psa != NULL);
	LONG lLBound = GetLowerBound();
	ATLASSERT(lIndex >= lLBound);
	ATLASSERT(lIndex <= GetUpperBound());

	if((lIndex < lLBound) || (lIndex > GetUpperBound()))
		return E_INVALIDARG;

	LPUNKNOWN pOrgUnk = ((LPUNKNOWN*)m_psa->pvData)[lIndex-lLBound];
	if (pOrgUnk)
		pOrgUnk->Release();
	if (bAddRef)
		pUnk->AddRef();
	((LPUNKNOWN*)m_psa->pvData)[lIndex-lLBound] = pUnk;
	return S_OK;
}
template<>
HRESULT CComSafeArray<LPDISPATCH>::SetAt(LONG lIndex, const LPDISPATCH& pDisp, BOOL bAddRef)
{
	ATLENSURE_RETURN(pDisp != NULL);
	ATLASSUME(m_psa != NULL);
	LONG lLBound = GetLowerBound();
	ATLASSERT(lIndex >= lLBound);
	ATLASSERT(lIndex <= GetUpperBound());

	if((lIndex < lLBound) || (lIndex > GetUpperBound()))
		return E_INVALIDARG;

	LPDISPATCH pOrgDisp = ((LPDISPATCH*)m_psa->pvData)[lIndex-lLBound];
	if (pOrgDisp)
		pOrgDisp->Release();
	if (bAddRef)
		pDisp->AddRef();
	((LPDISPATCH*)m_psa->pvData)[lIndex-lLBound] = pDisp;
	return S_OK;
}

}; //namespace ATL

#pragma pack(pop)

#endif //__ATLSAFE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlplus.h ===
// This is a part of the Visual C++ COM Library
// Copyright (C) Microsoft Corporation
// All rights reserved.

#ifndef __ATLPLUS_H__
#define __ATLPLUS_H__

#pragma once

#ifndef __cplusplus
	#error The Visual C++ COM Library requires C++ compilation (use a .cpp suffix)
#endif

#include <shellapi.h>
#include "atlevent.h"
#include <atlstr.h>
//Avoid using <atlstr.h> except in the registry templates (for circular dependencies).

[
	provider(name="ATL4", uuid="BC6B4B8A-0E4A-4bc9-B319-9DC2ACFB61EE")
];


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

// Registry

#define rgsopEndOfStream 0
#define rgsopAddKeyNoRemove  1
#define rgsopAddKeyForceRemove 2
#define rgsopAddKey 3
#define rgsopDeleteKey 4
#define rgsopOpenAsParent 5
#define rgsopCloseAsParent 6
#define rgsopOpenRootKey 7
#define rgsopAddStringValue 8
#define rgsopAddMultiStringValue 9
#define rgsopAddDWORDValue 10
#define rgsopAddBinaryValue 11

struct RGSStrings
{
	LPTSTR sz;
	BYTE bHasReplacement;
};
struct RGSDWORD
{
	DWORD dwValueOrIndex;
	BYTE bHasReplacement;
};
struct RGSBinary
{
	BYTE* pBytes;
	DWORD dwLenOrIndex;
	BYTE bHasReplacement;
};

typedef DWORD RGSOps;

enum RDXOperations
{
	eReadFromReg,
	eWriteToReg,
	eDeleteFromReg
};

class CVMExpansionVector : public CSimpleMap<LPTSTR, LPTSTR>
{
public:
	int FindKey(__in LPTSTR& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if (lstrcmpi(m_aKey[i],key) == 0)
				return i;
		}
		return -1;  // not found
	}
	int FindVal(__in LPTSTR& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if (lstrcmpi(m_aVal[i],val) == 0)
				return i;
		}
		return -1;  // not found
	}

	LPTSTR Lookup(__in LPTSTR key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;    // must be able to convert
		return GetValueAt(nIndex);
	}
};


class CRegistryVirtualMachine : public IRegistrarBase
{
public:

	HRESULT STDMETHODCALLTYPE QueryInterface(const IID &riid,void ** ppv)
	{
		if (ppv == NULL)
			return E_POINTER;
		*ppv = NULL;
		if (IsEqualGUID(riid, __uuidof(IUnknown)) || IsEqualGUID(riid, __uuidof(IRegistrarBase)) )
		{
			*ppv = this;
			return S_OK;
		}
		return E_NOINTERFACE;
	}
	ULONG STDMETHODCALLTYPE AddRef(void) { return 1L; }

	ULONG STDMETHODCALLTYPE Release(void) {	return 1L; }
	
#ifndef _UNICODE
	virtual HRESULT STDMETHODCALLTYPE AddReplacement(LPCOLESTR key, LPCOLESTR item)
	{
		HRESULT hr = E_OUTOFMEMORY;
		_ATLTRY
		{
			hr = AddReplacement(COLE2T(key), COLE2T(item));
		}
		_ATLCATCHALL()
		{
		}
		return hr;
	}
#endif

public:
	virtual ~CRegistryVirtualMachine() throw()
	{
		ClearReplacements();
	}

	// Operations
	HRESULT  AddStandardReplacements() throw()
	{
		USES_CONVERSION_EX;

		TCHAR szModule[MAX_PATH];
		HINSTANCE hInst = _AtlBaseModule.GetModuleInstance();
		DWORD dwFLen = GetModuleFileName(hInst , szModule, MAX_PATH);
		if( dwFLen == 0 )
			return AtlHresultFromLastError();
		else if( dwFLen == MAX_PATH )
			return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		
		HRESULT hr;
		bool bIsExe = false;
		if ((hInst == NULL) || (hInst == GetModuleHandle(NULL))) // register as EXE
		{
			// If Registering as an EXE, then we quote the resultant path.
			// We don't do it for a DLL, because LoadLibrary fails if the path is
			// quoted
			bIsExe = true;
			TCHAR szModuleQuote[_MAX_PATH + _ATL_QUOTES_SPACE];
			szModuleQuote[0] = _T('\"');
			Checked::tcscpy_s(szModuleQuote + 1, _countof(szModuleQuote) - 1, szModule);
			int nLen = lstrlen(szModuleQuote);
			szModuleQuote[nLen] = _T('\"');
			szModuleQuote[nLen + 1] = 0;
			hr = AddReplacement(_T("Module"), szModuleQuote);
		}
		else
		{
			hr= AddReplacement(_T("Module"), szModule);
		}	

		if(FAILED(hr))
			return hr;

		hr = AddReplacement(_T("Module_Raw"), szModule);
		if(FAILED(hr))
			return hr;


		OLECHAR* sz;
		hr = StringFromCLSID(CAtlModule::m_libid, &sz);
		if (FAILED(hr))
			return hr;
		hr = AddReplacement(_T("MODULEGUID"), OLE2T_EX_DEF(sz));
		CoTaskMemFree(sz);
		if (FAILED(hr))
			return hr;
		if (!bIsExe)
			hr = AddReplacement(_T("MODULETYPE"), _T("InprocServer32"));
		else
			hr = AddReplacement(_T("MODULETYPE"), _T("LocalServer32"));

		if (SUCCEEDED(hr))
			hr = _pAtlModule->AddCommonRGSReplacements(this);
		return hr;
	}

	virtual HRESULT STDMETHODCALLTYPE AddReplacement(LPCTSTR lpszKey, LPCTSTR lpszItem) throw()
	{
		ATLASSERT(lpszKey != NULL && lpszItem != NULL);
		if (lpszKey == NULL || lpszItem == NULL)
			return E_INVALIDARG;

		HRESULT hr = E_OUTOFMEMORY; // If any of the new's fail.

		m_csMap.Lock();
		DWORD cch = lstrlen(lpszKey) + 1;
		CAutoVectorPtr<TCHAR> szNewKey;
		if (szNewKey.Allocate(cch))
		{			
			Checked::tcscpy_s(szNewKey, cch, lpszKey);
			cch = lstrlen(lpszItem) + 1;
			CAutoVectorPtr<TCHAR> szNewItem;
			if (szNewItem.Allocate(cch))
			{
				Checked::tcscpy_s(szNewItem, cch, lpszItem);
				if (m_RepMap.Add(szNewKey, szNewItem))
				{
					hr = S_OK;
					szNewKey.Detach();
					szNewItem.Detach();
				}
			}
		}
		m_csMap.Unlock();
		return hr;
	}

	HRESULT STDMETHODCALLTYPE ClearReplacements() throw()
	{
		m_csMap.Lock();
		HRESULT hr = S_OK;
		for (int i = 0; i < m_RepMap.GetSize(); i++)
		{
			delete [] m_RepMap.m_aKey[i];
			delete [] m_RepMap.m_aVal[i];
		}
		m_RepMap.RemoveAll();
		m_csMap.Unlock();
		return hr;
	}

	HRESULT VMUpdateRegistry(RGSOps* pOps, RGSStrings* rgStrings, RGSDWORD* rgDWORDS, RGSBinary *rgBinary, BOOL bRegister) throw()
	{
        ATLASSERT(pOps != NULL && rgStrings != NULL);
        if (pOps == NULL || rgStrings == NULL)
            return E_INVALIDARG;
        HRESULT hr = S_OK;
        
        // Handle multiple ROOT keys in the RGS file.
        while ( SUCCEEDED(hr) && *pOps != 0 )
        {
            DWORD code, p1, p2;
            GetOpsFromDWORD(*pOps, code, p1, p2);

            if (code != rgsopOpenRootKey)
            {
                ATLASSERT(FALSE); // Bad parse tree
                return E_FAIL;
            }
            HKEY hKeyBase = (( HKEY ) (ULONG_PTR)((LONG)(p1 | 0x80000000)));
            pOps++;
            hr = VMUpdateRegistryRecurse(hKeyBase, pOps, rgStrings, rgDWORDS, rgBinary, bRegister);
        }
        return hr;
	}

	// Implementation
	inline BYTE ChToByte(const TCHAR ch)
	{
		switch (ch)
		{
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
					return (BYTE) (ch - '0');
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
					return (BYTE) (10 + (ch - 'A'));
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
					return (BYTE) (10 + (ch - 'a'));
			default:
					ATLASSERT(FALSE);
					ATLTRACE(atlTraceRegistrar, 0, _T("Bogus value %c passed as binary Hex value\n"), ch);
					return 0;
		}
	}

	HRESULT GetStringAtLoc(RGSStrings* rgStrings, DWORD iLoc, CSimpleArray<TCHAR>& rgBytes, LPTSTR* pszCur) throw()
	{
		if (pszCur == NULL)
			return E_INVALIDARG;

		LPTSTR& szCur = *pszCur;
		szCur = rgStrings[iLoc].sz;
		if (szCur == NULL)
			return S_FALSE;

		if (rgStrings[iLoc].bHasReplacement)
		{
			rgBytes.RemoveAll();
			LPCTSTR szTemp = szCur;
			szCur = NULL;
			while (*szTemp != NULL) // look for end
			{
				if (*szTemp == _T('%'))
				{
					szTemp = CharNext(szTemp);
					if (*szTemp == _T('%'))
						rgBytes.Add(*szTemp);
					else
					{						
						LPCTSTR lpszNext = AtlstrchrT(szTemp, _T('%'));
						if (lpszNext == NULL)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Error : closing '%%' found\n"));
							return E_FAIL;
						}
						int nLength = (int)(INT_PTR)(lpszNext - szTemp);
						if (nLength > 31)
							return E_FAIL;
						TCHAR buf[32];
						Checked::tcsncpy_s(buf, _countof(buf), szTemp, nLength);
						LPTSTR lpszVar = m_RepMap.Lookup(buf);
						if (lpszVar == NULL)
							return E_FAIL;
						for (int iMapped = 0; lpszVar[iMapped] != NULL; iMapped++)
							rgBytes.Add(lpszVar[iMapped]);
						szTemp = lpszNext;
					}
				}
				else
					rgBytes.Add(*szTemp);
				szTemp = CharNext(szTemp);
			}
			rgBytes.Add(*szTemp);
		}
		return S_OK;
	}
	HRESULT GetDWORDAtLoc(RGSDWORD* rgDWORDS, DWORD iLoc, DWORD& dwValueOrIndex) throw()
	{
		dwValueOrIndex = rgDWORDS[iLoc].dwValueOrIndex;
		return rgDWORDS[iLoc].bHasReplacement == TRUE ? S_FALSE : S_OK;
	}

	HRESULT GetBinaryAtLoc(RGSBinary* rgBinary, DWORD iLoc, BYTE** ppValue, DWORD* pdwLen) throw()
	{
		*ppValue = rgBinary[iLoc].pBytes;
		*pdwLen = rgBinary[iLoc].dwLenOrIndex;
		return rgBinary[iLoc].bHasReplacement == TRUE ? S_FALSE : S_OK;
	}

	HRESULT DeleteKeyWithReplacement(HKEY hKeyParent, DWORD iString, RGSStrings* rgStrings) throw()
	{
		CRegKey rkForceRemove;
		CSimpleArray<TCHAR> rgBytes;
		LPTSTR szReplacement = NULL;
		HRESULT hr = GetStringAtLoc(rgStrings, (DWORD)iString, rgBytes, &szReplacement);
		if (FAILED(hr))
			return hr;
		rkForceRemove.Attach(hKeyParent);
		LONG lRet = ERROR_FILE_NOT_FOUND;
		if (hKeyParent)
			lRet = rkForceRemove.RecurseDeleteKey((szReplacement) ? szReplacement : rgBytes.m_aT);
		if (lRet != ERROR_SUCCESS && lRet != ERROR_FILE_NOT_FOUND && lRet != ERROR_PATH_NOT_FOUND)
		{
			ATLTRACE(atlTraceRegistrar, 0, _T("Failed to delete key %s or one of its subkeys\n"),
				(szReplacement) ? szReplacement : rgBytes.m_aT);
			hr = AtlHresultFromWin32(lRet);
		}
		rkForceRemove.Detach();
		return hr;
	}

	HRESULT AddKeyWithReplacement(HKEY hKeyParent, CRegKey& rkCur, DWORD iString, RGSStrings* rgStrings) throw()
	{
		LPTSTR szReplacement = NULL;
		CSimpleArray<TCHAR> rgBytes;
		HRESULT hr = GetStringAtLoc(rgStrings, (DWORD)iString, rgBytes, &szReplacement);
		if (FAILED(hr))
			return hr;

		if (rkCur.Open(hKeyParent, (szReplacement) ? szReplacement : rgBytes.m_aT, 
					   KEY_READ | KEY_WRITE) != ERROR_SUCCESS)
		{
			LONG lRes = rkCur.Create(hKeyParent, (szReplacement) ? szReplacement : rgBytes.m_aT, REG_NONE, REG_OPTION_NON_VOLATILE , KEY_READ | KEY_WRITE); 
			if (lRes != ERROR_SUCCESS)
				return AtlHresultFromWin32(lRes);
		}
		return S_OK;
	}

	HRESULT VMUpdateRegistryRecurse(HKEY hKeyParent, RGSOps*& pOps, RGSStrings* rgStrings, RGSDWORD* rgDWORDS, RGSBinary *rgBinary, BOOL bRegister) throw()
	{
		CRegKey  rkCur;
		LONG     lRes = ERROR_SUCCESS;
		HRESULT  hr = S_OK;
		bool bNoRemove = false;
		RGSOps opParent = 0;
		DWORD code, p1, p2;
		USES_CONVERSION_EX;

		GetOpsFromDWORD(*pOps, code, p1, p2);
		while (code != rgsopCloseAsParent)
		{
			switch(code)
			{
			case rgsopEndOfStream:
				return S_OK;
			case rgsopAddKeyNoRemove:
				bNoRemove = true;
				if (bRegister)
				{
					hr = AddKeyWithReplacement(hKeyParent, rkCur, p1, rgStrings);
					if (FAILED(hr))
						return hr;
				}
				pOps++; // NoRemove means do nothing during Unreg
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			case rgsopAddKeyForceRemove:
				if (bRegister) 
				{
					hr = DeleteKeyWithReplacement(hKeyParent, p1, rgStrings);
					if (FAILED(hr))
						return hr;
				}
				// fall through to normal add functionality
			case rgsopAddKey:
			{
				if (!bRegister)
				{
					LPTSTR szReplacement = NULL;
					CSimpleArray<TCHAR> rgBytes;
					hr = GetStringAtLoc(rgStrings, p1, rgBytes, &szReplacement);
					if (FAILED(hr))
						return hr;

					lRes = ERROR_FILE_NOT_FOUND;
					if (hKeyParent)
						lRes = rkCur.Open(hKeyParent, (szReplacement) ? szReplacement : rgBytes.m_aT, KEY_READ | KEY_WRITE);
					if (lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)
						return AtlHresultFromWin32(lRes); // Ignore if it is not in the registry and continue.
					opParent = *pOps; // remember this for the delete
				}
				else
				{
					hr = AddKeyWithReplacement(hKeyParent, rkCur, p1, rgStrings);
					if (FAILED(hr))
						return hr;
				}
				pOps++;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			}
			case rgsopDeleteKey:
				ATLASSERT(FALSE); // Not yet implemented
				break;
			case rgsopOpenAsParent:
				pOps++;
				hr = VMUpdateRegistryRecurse(rkCur.m_hKey, pOps, rgStrings, rgDWORDS, rgBinary, bRegister);
				if (FAILED(hr))
					return hr;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				if (!bRegister)
				{
					if (!bNoRemove)
					{
						DWORD codeTemp, p1Temp, p2Temp;
						GetOpsFromDWORD(opParent, codeTemp, p1Temp, p2Temp);
						hr = DeleteKeyWithReplacement(hKeyParent, p1Temp, rgStrings);
						if (FAILED(hr))
							return hr;
					}
					else
						bNoRemove = false; // turn it back off
				}
				break;
			case rgsopCloseAsParent:
				ATLASSERT(FALSE); // Should never get here it is the governing loop constraint
				return E_FAIL;
			case rgsopOpenRootKey:
			{
				HKEY hKeyBase = (( HKEY ) (ULONG_PTR)((LONG)(p1 | 0x80000000)));
				pOps++;
				return VMUpdateRegistryRecurse(hKeyBase, pOps, rgStrings, rgDWORDS, rgBinary, bRegister);
				break;
			}
			case rgsopAddStringValue:
			{
				if (bRegister)
				{
					bool bRestoreRK = false;
					if (rkCur.m_hKey == NULL)
					{
						rkCur.m_hKey = hKeyParent;
						bRestoreRK = true;
					}
					CSimpleArray<TCHAR> rgBytes, rgBytes2;
					LPTSTR szReplacement = NULL;
					LPTSTR szReplacement2 = NULL;
					hr = GetStringAtLoc(rgStrings, p2, rgBytes, &szReplacement);
					if (SUCCEEDED(hr) && p1 != 0)
						hr = GetStringAtLoc(rgStrings, p1, rgBytes2, &szReplacement2);

					CRegKey key;
					if (p1 == 0)
						key.m_hKey = rkCur.m_hKey;
					else
						key.m_hKey = hKeyParent;
					lRes = key.SetStringValue((p1 != 0) ? ((szReplacement2) ? szReplacement2 : rgBytes2.m_aT) : NULL, 
						(szReplacement) ? szReplacement : rgBytes.m_aT); 
					key.m_hKey = NULL;
					if (ERROR_SUCCESS != lRes)
						return AtlHresultFromWin32(lRes);
					if (bRestoreRK)
						rkCur.m_hKey = NULL;
					ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), (szReplacement) ? szReplacement : rgBytes.m_aT, (p1 != 0) ? (szReplacement2) ? szReplacement2 : rgBytes2.m_aT : _T("default"));
				}
				pOps++;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			}
			case rgsopAddMultiStringValue:
			{
				if (bRegister)
				{
					bool bRestoreRK = false;
					if (rkCur.m_hKey == NULL)
					{
						rkCur.m_hKey = hKeyParent;
						bRestoreRK = true;
					}
					CSimpleArray<TCHAR> rgBytes, rgBytes2;
					LPTSTR szReplacement = NULL;
					LPTSTR szReplacement2 = NULL;
					hr = GetStringAtLoc(rgStrings, p2, rgBytes, &szReplacement);
					if (SUCCEEDED(hr) && p1 != 0)
						hr = GetStringAtLoc(rgStrings, p1, rgBytes2, &szReplacement2);

					ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), (szReplacement) ? szReplacement : rgBytes.m_aT, (p1 != 0) ? (szReplacement2) ? szReplacement2 : rgBytes2.m_aT : _T("default"));

					TCHAR* pszValue = (szReplacement) ? szReplacement : rgBytes.m_aT;
					int nLen = lstrlen(pszValue) + 2; //Allocate space for double null termination.
					CTempBuffer <TCHAR, 1024> pszDestValue;
					//nLen should be >= the max size of the target buffer.
					ATLTRY(pszDestValue.Allocate(nLen));
					if (pszDestValue != NULL)
					{
						TCHAR* p = pszDestValue;
						TCHAR* q = pszValue;
						nLen = 0;
						while (*q != _T('\0'))
						{
							TCHAR* r = CharNext(q);
							if (*q == '\\' && *r == '0')
							{
								*p++ = NULL;
								q = CharNext(r);
							}
							else
							{
								*p = *q;
		#ifndef _UNICODE
								if (IsDBCSLeadByte(*q))
								{
									p++;
									q++;
									 //Protect from Lead byte followed by the zero terminator.May skip beyond the end of the string.
									if (*q == _T('\0')) { break; }
									*p = *q;
								}
		#endif
								p++;
								q++;
							}
							nLen ++;
						}
					    //Always terminate with 2 NULLs.
					    *p = NULL;
						p++;
						*p = NULL;
 

						CRegKey key;
						if (p1 == 0)
							key.m_hKey = rkCur.m_hKey;
						else
						key.m_hKey = hKeyParent;						
						lRes = key.SetMultiStringValue((p1 != 0) ? ((szReplacement2) ? szReplacement2 : rgBytes2.m_aT) : NULL, 
							pszDestValue); 
						key.m_hKey = NULL;
						if (ERROR_SUCCESS != lRes)
							return AtlHresultFromWin32(lRes);
						if (bRestoreRK)
							rkCur.m_hKey = NULL;
					}
					else
					{
						return E_OUTOFMEMORY;
					}
				}
				pOps++;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			}

			case rgsopAddDWORDValue:
			{
				if (bRegister)
				{
					bool bRestoreRK = false;
					if (rkCur.m_hKey == NULL)
					{
						rkCur.m_hKey = hKeyParent;
						bRestoreRK = true;
					}
					CSimpleArray<TCHAR> rgBytes, rgBytes2;
					LPTSTR szReplacement = NULL;
					LPTSTR szReplacement2 = NULL;
					DWORD dwValue;
					hr = GetDWORDAtLoc(rgDWORDS, p2, dwValue);
					if (hr == S_FALSE)
					{
						GetStringAtLoc(rgStrings, dwValue, rgBytes, &szReplacement);
						CStringW strW(szReplacement ? szReplacement : rgBytes.m_aT);
						hr = VarUI4FromStr(const_cast<wchar_t *>(static_cast<const wchar_t *>(strW)), 0, 0, &dwValue);
						if (FAILED(hr))
						{
							// Replacement value exceeds max DWORD value
							return E_FAIL;
						}
					}

					if (SUCCEEDED(hr) && p1 != 0)
						hr = GetStringAtLoc(rgStrings, p1, rgBytes2, &szReplacement2);

					CRegKey key;
					if (p1 == 0)
						key.m_hKey = rkCur.m_hKey;
					else
						key.m_hKey = hKeyParent;						
					lRes = key.SetDWORDValue((szReplacement2) ? szReplacement2 : rgBytes2.m_aT, 
						dwValue);
					key.m_hKey = NULL; 
					if (ERROR_SUCCESS != lRes)
						return AtlHresultFromWin32(lRes);
					if (bRestoreRK)
						rkCur.m_hKey = NULL;
					ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), (szReplacement) ? szReplacement : rgBytes.m_aT, (p1 != 0) ? (szReplacement2) ? szReplacement2 : rgBytes2.m_aT : _T("default"));
				}
				pOps++;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			}
			case rgsopAddBinaryValue:
			{
				if (bRegister)
				{
					bool bRestoreRK = false;
					if (rkCur.m_hKey == NULL)
					{
						rkCur.m_hKey = hKeyParent;
						bRestoreRK = true;
					}
					CSimpleArray<TCHAR> rgBytes, rgBytes2;
					LPTSTR szReplacement = NULL;
					LPTSTR szReplacement2 = NULL;
					BYTE* pByte;
					CTempBuffer <BYTE, 1024> pByteTemp;					
					DWORD dwLen;
					hr = GetBinaryAtLoc(rgBinary, p2, &pByte, &dwLen);
					if (hr == S_FALSE)
					{
						GetStringAtLoc(rgStrings, dwLen, rgBytes, &szReplacement);
						if (szReplacement == NULL)
						{
							szReplacement = rgBytes.m_aT;
						}
						int cbValue = lstrlen(szReplacement);
						if (cbValue & 0x00000001)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Binary Data does not fall on BYTE boundries\n"));
							return E_FAIL;
						}
						dwLen = cbValue/2;
						ATLTRY(pByteTemp.Allocate(dwLen));
						if (pByteTemp == NULL)
						{
							return E_OUTOFMEMORY;
						}						
						pByte = pByteTemp;						
						memset(pByte, 0, dwLen);
						for (int irg = 0; irg < cbValue; irg++)
							pByte[(irg/2)] |= (ChToByte(szReplacement[irg])) << (4*(1 - (irg & 0x00000001)));
					}

					if (SUCCEEDED(hr) && p1 != 0)
						hr = GetStringAtLoc(rgStrings, p1, rgBytes2, &szReplacement2);

					CRegKey key;
					if (p1 == 0)
						key.m_hKey = rkCur.m_hKey;
					else
						key.m_hKey = hKeyParent;	
					lRes = key.SetBinaryValue((szReplacement2) ? szReplacement2 : rgBytes2.m_aT, 
						pByte, dwLen);
					key.m_hKey = NULL; 
					if (ERROR_SUCCESS != lRes)
						return AtlHresultFromWin32(lRes);
					if (bRestoreRK)
						rkCur.m_hKey = NULL;
					ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), (szReplacement) ? szReplacement : rgBytes.m_aT, (p1 != 0) ? (szReplacement2) ? szReplacement2 : rgBytes2.m_aT : _T("default"));
				}
				pOps++;
				GetOpsFromDWORD(*pOps, code, p1, p2);
				break;
			}


			default:
				ATLASSERT(FALSE); // Should never get here
				break;
			};
		}
		pOps++;
		GetOpsFromDWORD(*pOps, code, p1, p2);
		return hr;
	}

	void GetOpsFromDWORD(RGSOps op, DWORD& rcode, DWORD& rp1, DWORD& rp2) throw()
	{
		rcode = (op & 0xF0000000) >> 28;
		rp1 = (op & 0x0FFFC000) >> 14;
		rp2 = (op & 0x00003FFF);
	}


	CVMExpansionVector								m_RepMap;
	CComObjectThreadModel::AutoCriticalSection      m_csMap;
};


struct _RDXEntries
{
	enum KeyType
	{
		keyTypeString,
		keyTypeCString,
		keyTypeDWORD,
		keyTypeBinary,
		keyTypeNoEntry
	};

	HKEY iRootKey;
	LPTSTR szSubKey;
	LPTSTR szValue;
	enum KeyType nKey;
	int nMemberOffset;
	DWORD cb;
};

#define RDX_MEMBER_OFFSET(member) ((int)((char*) &(member) - (char*) this))

#define BEGIN_RDX_MAP() \
	ATL::_RDXEntries* _GetRDXEntries() \
	{ \
		static ATL::_RDXEntries rgEntries [] = { 

#define RDX_TEXT(rootkey, subkey, valuename, member, member_size) \
{ rootkey, subkey, valuename, ATL::_RDXEntries::keyTypeString, RDX_MEMBER_OFFSET(member), member_size },

#define RDX_CSTRING_TEXT(rootkey, subkey, valuename, member, member_size) \
{ rootkey, subkey, valuename, ATL::_RDXEntries::keyTypeCString, RDX_MEMBER_OFFSET(member), member_size },

#define RDX_DWORD(rootkey, subkey, valuename, member, member_size) \
{ rootkey, subkey, valuename, ATL::_RDXEntries::keyTypeDWORD, RDX_MEMBER_OFFSET(member), member_size },

#define RDX_BINARY(rootkey, subkey, valuename, member, member_size) \
{ rootkey, subkey, valuename, ATL::_RDXEntries::keyTypeBinary, RDX_MEMBER_OFFSET(member), member_size },

#define END_RDX_MAP() \
		{NULL, NULL, NULL, ATL::_RDXEntries::keyTypeNoEntry, 0, 0} };\
		return rgEntries; \
	} \
	HRESULT RegistryDataExchange(enum ATL::RDXOperations rdxOp, void* pItem = NULL) \
	{ \
		return ::RegistryDataExchange(this, rdxOp, pItem); \
	}

class CByteFilter 
{
public:

	static BYTE ChToByte(const TCHAR ch)
	{
		switch (ch)
		{
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
					return (BYTE) (ch - '0');
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
					return (BYTE) (10 + (ch - 'A'));
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
					return (BYTE) (10 + (ch - 'a'));
			default:
					ATLASSERT(FALSE);
					ATLTRACE(atlTraceRegistrar, 0, _T("Bogus value %c passed as binary Hex value\n"), ch);
					return 0;
		}
	}
};

template <class T>
HRESULT RegistryDataExchange(T* pT, enum RDXOperations rdxOp, void* pItem = NULL)
{
	_RDXEntries* pEntries = pT->_GetRDXEntries();
	ATLASSERT(pEntries != NULL);
	LONG lRes = ERROR_SUCCESS;

	while (pEntries->nKey != _RDXEntries::keyTypeNoEntry)
	{
		void *pMember = (char*)pT + pEntries->nMemberOffset;
		ATLASSERT(pMember != NULL); 
		if (pItem == NULL || pItem == pMember) 
		{ 
			if (rdxOp == eDeleteFromReg)
			{
				if (pEntries->szSubKey != NULL)
				{
					if (pEntries->szValue != NULL)
					{
						CRegKey rkDel;
						lRes = rkDel.Open(pEntries->iRootKey, pEntries->szSubKey, KEY_READ | KEY_WRITE);
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Failed to Open key in order to delete Value\n"));
							return AtlHresultFromWin32(lRes);
						}
						lRes = rkDel.DeleteValue(pEntries->szValue);
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Failed to delete Value\n"));
							return AtlHresultFromWin32(lRes);
						}
					}
					else
					{
						lRes = RegDeleteKey(pEntries->iRootKey, pEntries->szSubKey);
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("RegDeleteKey failed\n"));
							return AtlHresultFromWin32(lRes);
						}
					}
				}
				else
				{
					if (pEntries->szValue)
					{
						lRes = RegDeleteValue(pEntries->iRootKey, pEntries->szValue);
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("RegDeleteValue failed\n"));
							return AtlHresultFromWin32(lRes);
						}
					}
				}
				pEntries++;
				continue;
			}

			CRegKey rk; 
			REGSAM samDesired = KEY_READ;
			if (rdxOp == eWriteToReg)
				samDesired |= KEY_WRITE;
			lRes = rk.Open(pEntries->iRootKey, pEntries->szSubKey, samDesired); 
			if (lRes != ERROR_SUCCESS && rdxOp == eReadFromReg) 
				return AtlHresultFromWin32(lRes);
			else 
			{
				if (lRes != ERROR_SUCCESS) 
				{ 
					lRes = rk.Create(pEntries->iRootKey, pEntries->szSubKey, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ); 
					if (lRes != ERROR_SUCCESS) 
						return AtlHresultFromWin32(lRes);
				} 
			} 
			DWORD dwRet = pEntries->cb;
			switch(pEntries->nKey)
			{
			case _RDXEntries::keyTypeString:
				if (rdxOp == eWriteToReg) 
					lRes = rk.SetStringValue(pEntries->szValue, (LPCTSTR)pMember); 
				else 
					lRes= rk.QueryStringValue(pEntries->szValue, (LPTSTR)pMember, &dwRet); 
				break;
			case _RDXEntries::keyTypeCString:
				{
					CString& rStr = *((CString*)pMember);
					if (rdxOp == eWriteToReg)
						lRes = rk.SetStringValue(pEntries->szValue, rStr); 
					else
					{
						lRes = rk.QueryStringValue(pEntries->szValue, NULL, &dwRet);
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Unable to determine keys length\n"));
							return AtlHresultFromWin32(lRes);
						}

						lRes= rk.QueryStringValue(pEntries->szValue, rStr.GetBuffer(dwRet), &dwRet); 
						rStr.ReleaseBuffer();
						if (lRes != ERROR_SUCCESS)
						{
							ATLTRACE(atlTraceRegistrar, 0, _T("Unable to copy keys data to CString\n"));
							return AtlHresultFromWin32(lRes);
						}
					}
				}
				break;
			case _RDXEntries::keyTypeDWORD:
				{
					DWORD& rdw = *((DWORD*)pMember);
					if (rdxOp == eWriteToReg) 
						lRes = rk.SetDWORDValue(pEntries->szValue, rdw); 
					else 
						lRes= rk.QueryDWORDValue(pEntries->szValue, rdw); 
					break;
				}
			case _RDXEntries::keyTypeBinary:
				if (rdxOp == eReadFromReg)
				{
					DWORD dwType = REG_BINARY;
					DWORD dwCount = pEntries->cb;
					LONG lRes = RegQueryValueEx(rk, pEntries->szValue, NULL, &dwType, (LPBYTE)pMember, &dwCount);
					if (lRes != ERROR_SUCCESS)
					{
						ATLTRACE(atlTraceRegistrar, 0, _T("Failed to query binary value\n"));
						return AtlHresultFromWin32(lRes);
					}
					ATLASSERT(dwType == REG_BINARY);
					break;
				}
				else
				{
					lRes = RegSetValueEx(rk, pEntries->szValue, 0, REG_BINARY, (const BYTE *)pMember, pEntries->cb);
					break;
				}
			case _RDXEntries::keyTypeNoEntry:
				ATLASSERT(FALSE);  // Not yet implemented
				break;
			};
			if (pItem != NULL)
				return AtlHresultFromWin32(lRes); 
		}
		pEntries++;
	}
	return AtlHresultFromWin32(lRes); 
}
}; // namespace ATL
#pragma pack(pop)

#endif // __ATLPLUS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlisapi.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSTENCIL_H__
#include <atlstencil.h>
#endif

#ifndef __ATLISAPI_H__
#define __ATLISAPI_H__

#pragma once
#include <atlbase.h>
#include <time.h>   // needed for cookie support
#include <httpext.h>    // needed for ECB and IIS support
#include <atlspriv.h>
#include <atlserr.h>
#include <atlfile.h>
#include <atlstr.h>
#ifndef _WIN32_WCE
#include <atldbcli.h>
#endif // _WIN32_WCE
#include <atlutil.h>
#include <atlcache.h>
#include <atlsrvres.h>
#include <atlsiface.h>
#include <objbase.h>
#ifndef _WIN32_WCE
#include <atlsecurity.h>
#include <errno.h>
#endif // _WIN32_WCE
#ifndef ATL_NO_SOAP
	#include <msxml2.h>
#endif
#ifndef ATL_NO_ACLAPI
	#include <aclapi.h>
#endif
#ifndef ATL_NO_MMSYS
#pragma warning(push)
#pragma warning(disable:4201) // nonstandard extension used : nameless struct/union
#include <mmsystem.h>
#pragma warning(pop)
#ifndef _ATL_NO_DEFAULT_LIBS
#ifndef _WIN32_WCE
#pragma comment(lib, "winmm.lib")
#ifndef ATL_NO_SOAP
#pragma comment(lib, "msxml2.lib")
#endif // !ATL_NO_SOAP
#endif // _WIN32_WCE
#endif  // !_ATL_NO_DEFAULT_LIBS
#endif // !ATL_NO_MMSYS
#ifndef _WIN32_WCE
#include <atlpath.h>
#endif // _WIN32_WCE

#pragma warning(push)
#pragma warning(disable: 4291) // allow placement new
#pragma warning(disable: 4127) // conditional expression is constant
#pragma warning(disable: 4511) // copy constructor could not be generated
#pragma warning(disable: 4512) // assignment operator could not be generated
#pragma warning(disable: 4625) // copy constructor could not be generated because a base class copy constructor is inaccessible
#pragma warning(disable: 4626) // assignment operator could not be generated because a base class assignment operator is inaccessible
#pragma warning(disable: 4191) // unsafe conversion from 'functionptr1' to 'functionptr2'
#pragma warning(disable: 4702) // unreachable code

#include <initguid.h>
#ifndef _WIN32_WCE
#include <dbgautoattach.h>
#endif // _WIN32_WCE

#ifndef SESSION_COOKIE_NAME
	#define SESSION_COOKIE_NAME "SESSIONID"
#endif

// override this if you want to use a different CLSID for SAX
#ifndef ATLS_SAXXMLREADER_CLSID
	#define ATLS_SAXXMLREADER_CLSID __uuidof(SAXXMLReader)
#endif // ATLS_SAXXMLREADER_CLSID


// This function is used in CValidateObject to determine if an empty
// request parameter really should be empty. You can 
// specialize this function in your own code such as
// the following specialization for type long:
// template <>
// inline bool IsNullByType<long>(long type) throw()
// {
//   return type == 0;
// }
// You should provide your own specialization for this 
// function if the comparison of type==0 is not adequate
// to discover whether or not your type is 0.
template <class TComp>
inline bool IsNullByType(__in TComp type) throw()
{
	return type == 0;
}


#pragma pack(push,_ATL_PACKING)
namespace ATL {

#ifndef _WIN32_WCE

// Default file extension for server response files
#ifndef ATL_DEFAULT_STENCIL_EXTENSION
	#define ATL_DEFAULT_STENCIL_EXTENSION ".srf"
#endif
extern __declspec(selectany) const char * const c_AtlSRFExtension = ATL_DEFAULT_STENCIL_EXTENSION;
extern __declspec(selectany) const TCHAR * const c_tAtlSRFExtension = _T(ATL_DEFAULT_STENCIL_EXTENSION);
#define ATLS_EXTENSION_LEN (sizeof(ATL_DEFAULT_STENCIL_EXTENSION)-2)

// Default file extension for handler DLLs
#ifndef ATL_DEFAULT_DLL_EXTENSION
	#define ATL_DEFAULT_DLL_EXTENSION ".dll"
#endif
extern __declspec(selectany) const char * const c_AtlDLLExtension = ATL_DEFAULT_DLL_EXTENSION;
extern __declspec(selectany) const TCHAR * const c_tAtlDLLExtension = _T(ATL_DEFAULT_DLL_EXTENSION);
#define ATLS_DLL_EXTENSION_LEN (sizeof(ATL_DEFAULT_DLL_EXTENSION)-2)

// maximum handler name length
#ifndef ATL_MAX_HANDLER_NAME_LEN 
	#define ATL_MAX_HANDLER_NAME_LEN 64
#endif

#ifndef ATL_HANDLER_NAME_DEFAULT
#define ATL_HANDLER_NAME_DEFAULT "Default"
#endif // ATL_DEFAULT_HANDLER_NAME


// maximum timeout for async guard mutex
#ifndef ATLS_ASYNC_MUTEX_TIMEOUT
	#define ATLS_ASYNC_MUTEX_TIMEOUT 10000
#endif

#if defined(_M_IA64) || defined (_M_AMD64)
#define ATLS_FUNCID_INITIALIZEHANDLERS "InitializeAtlHandlers"
#define ATLS_FUNCID_GETATLHANDLERBYNAME "GetAtlHandlerByName"
#define ATLS_FUNCID_UNINITIALIZEHANDLERS "UninitializeAtlHandlers"
#elif defined(_M_IX86)
#define ATLS_FUNCID_INITIALIZEHANDLERS "_InitializeAtlHandlers@8"
#define ATLS_FUNCID_GETATLHANDLERBYNAME "_GetAtlHandlerByName@12"
#define ATLS_FUNCID_UNINITIALIZEHANDLERS "_UninitializeAtlHandlers@0"
#else
#error Unknown Platform.
#endif

#define ATL_MAX_COOKIE_LEN 2048
#define ATL_MAX_COOKIE_ELEM 1024

#endif // _WIN32_WCE

// Defines a small value used for comparing the equality of floating point numbers.
#ifndef ATL_EPSILON
	#define ATL_EPSILON .0001
#endif

#ifndef ATL_DEFAULT_PRECISION
	#define ATL_DEFAULT_PRECISION 6
#endif

#ifndef _WIN32_WCE

// Call this function to URL-encode a buffer and have the result appended to a CString passed by reference.
//
// A space in the input string is encoded as a plus sign (+).
// Other unsafe characters (as determined by AtlIsUnsafeUrlChar) are encoded as escaped octets.
// An escaped octet is a percent sign (%) followed by two digits representing the hexadecimal code of the character.
//
// string       A CStringA reference to which will be appended the encoded version of szBuf.
//
// szBuf        The string to be URL-encoded.
ATL_NOINLINE inline bool EscapeToCString(__inout CStringA& string, __in LPCSTR szBuf)
{
	ATLENSURE( szBuf != NULL );

	_ATLTRY
	{
		CHAR szEscaped[512];
		LPSTR pszStr = szEscaped;
		DWORD dwLen = 0;

		while (*szBuf)
		{
			if (dwLen+4 >= _countof(szEscaped))
			{
				*pszStr = '\0';
				string.Append(szEscaped, dwLen);
				pszStr = szEscaped;
				dwLen = 0;
			}
			if (AtlIsUnsafeUrlChar(*szBuf))
			{
				if (*szBuf == ' ')
				{
					dwLen++;
					*pszStr++ = '+';
				}
				else
				{
					LPSTR pszTmp = pszStr;
					*pszTmp++ = '%';
					unsigned char ch = (unsigned char)*szBuf;
					if (ch < 16)
					{
						*pszTmp++ = '0';
					}
					Checked::ultoa_s((unsigned char)ch, pszTmp, szEscaped + _countof(szEscaped) - pszTmp, 16);
					pszStr+= sizeof("%FF")-1;
					dwLen+= sizeof("%FF")-1;
				}
			}
			else
			{
				*pszStr++ = *szBuf;
				dwLen++;
			}
			szBuf++;
		}

		*pszStr = '\0';
		string.Append(szEscaped, dwLen);
	}
	_ATLCATCHALL()
	{
		return false;
	}

	return true;
}

// UNICODE overload for EscapeToCString
// follow specifications detailed in RFC document on
// Internationalized Uniform Resource Identifiers (IURI)
inline bool EscapeToCString(__inout CStringA& string, __in_z LPCWSTR wszBuf) throw()
{
	_ATLTRY
	{
		// convert string to UTF8
		CFixedStringT<CStringA, 2048> strConvert;

		// get the required length for conversion
		int nSrcLen = (int) wcslen(wszBuf);
		int nLen = AtlUnicodeToUTF8(wszBuf, nSrcLen, NULL, 0);
		if (!nLen)
		{
			return false;
		}

		// allocate MBCS conversion string
		LPSTR sz = strConvert.GetBuffer(nLen+1);
		if (!sz)
		{
			return false;
		}

		// do the UNICODE to UTF8 conversion
		nLen = AtlUnicodeToUTF8(wszBuf, nSrcLen, sz, nLen);
		if (!nLen)
		{
			return false;
		}

		// null-terminate
		sz[nLen] = '\0';

		// delegate to ANSI version of EscapeToCString
		if (!EscapeToCString(string, sz))
		{
			return false;
		}

		strConvert.ReleaseBuffer(nLen);
	}
	_ATLCATCHALL()
	{
		return false;
	}

	return true;
}

#endif // _WIN32_WCE

struct CDefaultErrorProvider
{
	struct HTTP_ERROR_TEXT
	{
		UINT uHttpError;    // the Http Error value
		UINT uHttpSubError; // Allows for customization of error text based on srf specific errors.
		LPCSTR szHeader;    // the string that should appear in the http response header
		UINT uResId;        // the resource id of the string to send back as the body
	};


	// GetErrorText retrieves the http response header string
	// and a resource id of the response body for a given
	// http error code
	// uError: Http error code to retrieve information for
	// ppszHeader: pointer to LPCSTR that receives the response header string
	//          ppszHeader is optional
	// puResId: pointer to UINT that receives the response body resource id
	//          puResId is optional
	static BOOL GetErrorText(__in UINT uError, __in UINT uSubErr, __deref_out_opt LPCSTR *ppszHeader, __out_opt UINT *puResId) throw()
	{
		static const HTTP_ERROR_TEXT s_Errors[] = 
		{
			{ 200, SUBERR_NONE, "OK", 0 },
			{ 201, SUBERR_NONE, "Created", 0 },
			{ 202, SUBERR_NONE, "Accepted", 0 },
			{ 203, SUBERR_NONE, "Non-Authoritative Information", 0 },
			{ 204, SUBERR_NONE, "No Content", 0 },
			{ 204, DBG_SUBERR_ALREADY_DEBUGGING, "Already being debugged by another user", 0},
			{ 204, DBG_SUBERR_NOT_DEBUGGING, "Not currently debugging a process", 0},
			{ 204, DBG_SUBERR_INVALID_SESSION, "Requested DebugSessionID does not match current DebugSessionID", 0},
			{ 204, DBG_SUBERR_BAD_ID, "DebugSessionID corrupted or not provided", 0 },
			{ 204, DBG_SUBERR_COCREATE, "Could not CoCreate the debugger", 0 },
			{ 204, DBG_SUBERR_ATTACH, "Could not attach to process", 0 },
			{ 205, SUBERR_NONE, "Reset Content", 0 },
			{ 206, SUBERR_NONE, "Partial Content", 0 },
			{ 300, SUBERR_NONE, "Multiple Choices", 0 },
			{ 301, SUBERR_NONE, "Moved Permanently", 0 },
			{ 302, SUBERR_NONE, "Found", 0 },
			{ 303, SUBERR_NONE, "See Other", 0 },
			{ 304, SUBERR_NONE, "Not Modified", 0 },
			{ 305, SUBERR_NONE, "Use Proxy", 0 },
			{ 306, SUBERR_NONE, "(Unused)", 0 },
			{ 307, SUBERR_NONE, "Temporary Redirect", 0 },
			{ 400, SUBERR_NONE, "Bad Request", IDS_ATLSRV_BAD_REQUEST },
			{ 401, SUBERR_NONE, "Unauthorized", IDS_ATLSRV_AUTH_REQUIRED },
			{ 402, SUBERR_NONE, "Payment Required", 0 },
			{ 403, SUBERR_NONE, "Forbidden", IDS_ATLSRV_FORBIDDEN },
			{ 404, SUBERR_NONE, "Not Found", IDS_ATLSRV_NOT_FOUND },
			{ 405, SUBERR_NONE, "Method Not Allowed", 0 },
			{ 406, SUBERR_NONE, "Not Acceptable", 0 },
			{ 407, SUBERR_NONE, "Proxy Authentication Required", 0 },
			{ 408, SUBERR_NONE, "Request Timeout", 0 },
			{ 409, SUBERR_NONE, "Conflict", 0 },
			{ 410, SUBERR_NONE, "Gone", 0 },
			{ 411, SUBERR_NONE, "Length Required", 0 },
			{ 412, SUBERR_NONE, "Precondition Failed", 0 },
			{ 413, SUBERR_NONE, "Request Entity Too Long", 0 },
			{ 414, SUBERR_NONE, "Request-URI Too Long", 0 },
			{ 415, SUBERR_NONE, "Unsupported Media Type", 0 },
			{ 416, SUBERR_NONE, "Requested Range Not Satisfiable", 0 },
			{ 417, SUBERR_NONE, "Expectation Failed", 0 },
			{ 500, SUBERR_NONE, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR },
			{ 500, ISE_SUBERR_BADSRF, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_BADSRF },
			{ 500, ISE_SUBERR_HNDLFAIL, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_HNDLFAIL },
			{ 500, ISE_SUBERR_SYSOBJFAIL, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_SYSOBJFAIL},
			{ 500, ISE_SUBERR_READFILEFAIL, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_READFILEFAIL},
			{ 500, ISE_SUBERR_LOADFILEFAIL, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_LOADFILEFAIL},
			{ 500, ISE_SUBERR_LOADLIB, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_LOADLIB},
			{ 500, ISE_SUBERR_HANDLERIF, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_HANDLERIF},
			{ 500, ISE_SUBERR_OUTOFMEM, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_OUTOFMEM},
			{ 500, ISE_SUBERR_UNEXPECTED, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_UNEXPECTED},
			{ 500, ISE_SUBERR_STENCIL_PARSE_FAIL, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_STENCILPARSEFAIL},
			{ 500, ISE_SUBERR_STENCIL_LOAD_FAIL, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_STENCILLOADFAIL},
			{ 500, ISE_SUBERR_HANDLER_NOT_FOUND, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_HANDLERNOTFOUND},
			{ 500, ISE_SUBERR_BAD_HANDLER_TAG, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_BADHANDLERTAG},
			{ 500, ISE_SUBERR_LONGMETHODNAME, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_LONGMETHODNAME},
			{ 500, ISE_SUBERR_LONGHANDLERNAME, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_LONGHANDLERNAME},
			{ 500, ISE_SUBERR_NO_HANDLER_TAG, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_NOHANDLERTAG},
			{ 500, ISE_SUBERR_IMPERSONATIONFAILED, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_IMPERSONATIONFAILED},
			{ 500, ISE_SUBERR_ISAPISTARTUPFAILED, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_ISAPISTARTUPFAILED},
			{ 500, ISE_SUBERR_SOAPNOSOAPACTION, "Internal Server Error", IDS_ATLSRV_SERVER_ERROR_SOAPNOSOAPACTION},

			{ 501, SUBERR_NONE, "Not Implemented", IDS_ATLSRV_NOT_IMPLEMENTED },
			{ 502, SUBERR_NONE, "Bad Gateway", IDS_ATLSRV_BAD_GATEWAY },
			{ 503, SUBERR_NONE, "Service Unavailable", IDS_ATLSRV_SERVICE_NOT_AVAILABLE },
			{ 504, SUBERR_NONE, "Gateway Timeout", 0 },
			{ 505, SUBERR_NONE, "HTTP Version Not Supported", 0 },
		};

		// look for the error
		for (int i=0; i<sizeof(s_Errors)/sizeof(s_Errors[0]); i++)
		{
			if ((s_Errors[i].uHttpError == uError) && (s_Errors[i].uHttpSubError == uSubErr))
			{
				if (ppszHeader)
					*ppszHeader = s_Errors[i].szHeader;
				if (puResId)
					*puResId = s_Errors[i].uResId;
				return TRUE;
			}
		}

		// not found
		return FALSE;
	}
}; // CDefaultErrorProvider

template<class HttpUserErrorTextProvider>
void GetStatusHeader(__inout CStringA &strStatus, __in DWORD dwStatus, __in DWORD dwSubStatus, __in HttpUserErrorTextProvider* pErrorProvider, __out_opt UINT *puResId = NULL) throw(...)
{	
	ATLENSURE( pErrorProvider != NULL );	

	LPCSTR szHeadErr = NULL;
	// First, we check for the error text in the extension's user error text provider
	BOOL bRet = pErrorProvider->GetErrorText(dwStatus, dwSubStatus, &szHeadErr, puResId);
	if (!bRet)
	{
		szHeadErr = "";
	}

	char szBuf[512];
	Checked::itoa_s(dwStatus, szBuf, _countof(szBuf), 10);

	// add the space after the 3 digit response code
	szBuf[3] = ' ';
	szBuf[4] = '\0';
	strStatus.SetString(szBuf, 4);
	strStatus.Append(szHeadErr);
}

#ifndef _WIN32_WCE

template<class HttpUserErrorTextProvider>
void RenderError(__in IHttpServerContext *pServerContext, __in DWORD dwStatus, __in DWORD dwSubStatus, __in HttpUserErrorTextProvider* pErrorProvider)
{
	ATLENSURE( pServerContext != NULL );
	ATLENSURE( pErrorProvider != NULL );
	_ATLTRY
	{
		UINT uResId = 0;

		CFixedStringT<CStringA, 256> strStatus;
		GetStatusHeader(strStatus, dwStatus, dwSubStatus, pErrorProvider, &uResId);
		pServerContext->SendResponseHeader(NULL, strStatus, FALSE);

		LPCSTR szBody = strStatus;
		DWORD dwBodyLen = strStatus.GetLength();
		CFixedStringT<CStringA, 1024> strBody;
		if (uResId)
		{
			// load the body string from a resource
			if (strBody.LoadString(uResId))
			{
				szBody = strBody;
				dwBodyLen = strBody.GetLength();
			}
		}

		pServerContext->WriteClient((void *) szBody, &dwBodyLen);
	}
	_ATLCATCHALL()
	{
		// last resort message when low on memory
		LPCSTR szError;
		BOOL bRes;
		bRes = CDefaultErrorProvider::GetErrorText(dwStatus, dwSubStatus, &szError, 0);
		if (!bRes)
			bRes = CDefaultErrorProvider::GetErrorText(dwStatus, SUBERR_NONE, &szError, 0);
		if (!bRes)
			bRes = CDefaultErrorProvider::GetErrorText(500, SUBERR_NONE, &szError, 0);
		if(!szError)
		{
			szError="Unknown Error"; // last resort, can't localize 
		}
		DWORD dwBodyLen = (DWORD) strlen(szError);
		pServerContext->WriteClient((void *) szError, &dwBodyLen);
	}
}

// Call this function to retrieve the full canonical physical path 
 // of a file relative to the current script.
//
// Returns TRUE on success, FALSE on error.
//
// szFile           A file path relative to the current script directory for which
//                  you are trying to retrieve the full path.
//
// szFullFileName   A caller-allocated buffer of at least MAX_PATH characters in length.
//                  On success, contains the the full canonical path of szFile.
//
// pServerContext   The context for the current request. The context is used to obtain the
//                  current script directory.
inline BOOL GetScriptFullFileName(
	__in LPCSTR szFile,
	__in_ecount(MAX_PATH) LPSTR szFullFileName,
	__in IHttpServerContext* pServerContext) throw(...)
{
	ATLENSURE( szFile != NULL );
	ATLASSERT( szFullFileName != NULL );
	ATLENSURE( pServerContext != NULL );

	char szTmpScriptPath[MAX_PATH];
	LPCSTR szTmp = pServerContext->GetScriptPathTranslated();

	if (!szTmp)
	{
		return FALSE;
	}

	if (!SafeStringCopy(szTmpScriptPath, szTmp))
	{
		// path is too long
		return FALSE;
	}

	CHAR *szScriptPath = szTmpScriptPath;

	LPSTR szBackslash;
	if (*szFile != '\\')
	{
		szBackslash = strrchr(szScriptPath, '\\');

		ATLASSERT( *(szScriptPath+strlen(szScriptPath)) != '\\');

		if (szBackslash)
			szBackslash++;
	}
	else
	{
		// handle case where szFile is of the form \directory\etc\etc
		szBackslash = strchr(szScriptPath, '\\');
	}

	if (szBackslash)
		*szBackslash = '\0';

	int nScriptPathLen = (int)(szBackslash ? strlen(szScriptPath) : 0);
	int nFileLen = (int) strlen(szFile);
	int newLen = nScriptPathLen + nFileLen;

	if ((newLen < nScriptPathLen) || (newLen < nFileLen) || (newLen > MAX_PATH-1))
	{
		return FALSE;
	}
	CHAR szTemp[MAX_PATH];
	if (nScriptPathLen)
	{
		Checked::memcpy_s(szTemp, MAX_PATH, szScriptPath, nScriptPathLen);
	}
	Checked::memcpy_s(szTemp + nScriptPathLen, MAX_PATH-nScriptPathLen, szFile, nFileLen);
	*(szTemp + newLen) = 0;
	
	return PathCanonicalizeA(szFullFileName, szTemp);
}

enum ATLSRV_STATE
{
	ATLSRV_STATE_BEGIN,     // The request has just arrived, and the type has not been determined
	ATLSRV_STATE_CONTINUE,  // The request is a continuation of an async request
	ATLSRV_STATE_DONE,      // The request is a continuation of an async request, but the server is done with it
	ATLSRV_STATE_CACHE_DONE // The request is the callback of a cached page
};

enum ATLSRV_REQUESTTYPE
{
	ATLSRV_REQUEST_UNKNOWN=-1,  // The request type isn't known yet
	ATLSRV_REQUEST_STENCIL,     // The request is for a .srf file
	ATLSRV_REQUEST_DLL          // The request is for a .dll file
};

// Flags the InitRequest can return in dwStatus
#define  ATLSRV_INIT_USECACHE    1
#define  ATLSRV_INIT_USEASYNC    2
#define  ATLSRV_INIT_USEASYNC_EX 4 // required for use of NOFLUSH status

typedef HTTP_CODE (IRequestHandler::*PFnHandleRequest)(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider);
typedef void (*PFnAsyncComplete)(AtlServerRequest *pRequestInfo, DWORD cbIO, DWORD dwError);

struct AtlServerRequest
{
	DWORD cbSize;                           // For future compatibility
	IHttpServerContext *pServerContext;     // Necessary because it wraps the ECB
	ATLSRV_REQUESTTYPE dwRequestType;       // See the ATLSRV variables above
											// Indicates whether it was called through an .srf file or through a .dll file
	ATLSRV_STATE dwRequestState;            // See the ATLSRV variables above
											// Indicates what state of completion the request is in
	IRequestHandler *pHandler;              // Necessary because the callback (for async calls) must know where to
											// route the request
	HINSTANCE hInstDll;                     // Necessary in order to release the dll properly (for async calls)
	IIsapiExtension *pExtension;            // Necessary to requeue the request (for async calls)
	IDllCache* pDllCache;                   // Necessary to release the dll in async callback

	HANDLE hFile;
	HCACHEITEM hEntry;
	IFileCache* pFileCache;

	HANDLE m_hMutex;                        // necessary to syncronize calls to HandleRequest
											// if HandleRequest could potientially make an
											// async call before returning. only used
											// if indicated with ATLSRV_INIT_USEASYNC_EX

	DWORD dwStartTicks;                     // Tick count when the request was received
	EXTENSION_CONTROL_BLOCK *pECB;
	PFnHandleRequest pfnHandleRequest;
	PFnAsyncComplete pfnAsyncComplete;
	LPCSTR pszBuffer;                       // buffer to be flushed asyncronously
	DWORD dwBufferLen;                      // length of data in pszBuffer
	void* pUserData;                        // value that can be used to pass user data between parent and child handlers
};

inline void _ReleaseAtlServerRequest(__inout AtlServerRequest* pRequest)
{	
	ATLENSURE(pRequest!=NULL);
	if (pRequest->pHandler)
		pRequest->pHandler->Release();
	if (pRequest->pServerContext)
		pRequest->pServerContext->Release();
	if (pRequest->pDllCache && pRequest->hInstDll)
		pRequest->pDllCache->ReleaseModule(pRequest->hInstDll);
	if (pRequest->m_hMutex)
		CloseHandle(pRequest->m_hMutex);
}

typedef BOOL (__stdcall *GETATLHANDLERBYNAME)(LPCSTR szHandlerName, IIsapiExtension *pExtension, IUnknown **ppHandler);
typedef BOOL (__stdcall *INITIALIZEATLHANDLERS)(IHttpServerContext*, IIsapiExtension*);
typedef void (__stdcall *UNINITIALIZEATLHANDLERS)();

// initial size of thread worker heap (per thread)
// The heap is growable.  The default initial is 16KB
#ifndef ATLS_WORKER_HEAP_SIZE
#define ATLS_WORKER_HEAP_SIZE 16384
#endif

class CIsapiWorker
{
public:
	typedef AtlServerRequest* RequestType;
	HANDLE m_hHeap;
#ifndef ATL_NO_SOAP
	CComPtr<ISAXXMLReader> m_spReader;
#endif

	CIsapiWorker() throw()
	{
		m_hHeap = NULL;
	}

	virtual ~CIsapiWorker() throw()
	{
		ATLASSUME(m_hHeap == NULL);
	}

	virtual BOOL Initialize(__inout __crt_typefix(IIsapiExtension*) void *pvParam)
	{
		IIsapiExtension* pExtension = (IIsapiExtension*) pvParam;
		ATLENSURE(pExtension);
		if (!(pExtension->OnThreadAttach()))
			return FALSE;

		m_hHeap = HeapCreate(HEAP_NO_SERIALIZE, ATLS_WORKER_HEAP_SIZE, 0);
		if (!m_hHeap)
			return FALSE;
#ifndef ATL_NO_SOAP
		if (FAILED(m_spReader.CoCreateInstance(ATLS_SAXXMLREADER_CLSID, NULL, CLSCTX_INPROC_SERVER )))
		{
			ATLASSERT( FALSE );
			ATLTRACE( atlTraceISAPI, 0, _T("MSXML3 is not installed -- web services will not work.") );
		}
#endif
		return pExtension->SetThreadWorker(this);
	}

	virtual void Terminate(__inout_opt __crt_typefix(IIsapiExtension*) void* pvParam) throw()
	{
		if (m_hHeap)
		{
			if (HeapDestroy(m_hHeap))
				m_hHeap = NULL;
			else
			{
				ATLASSERT(FALSE);
			}
		}

#ifndef ATL_NO_SOAP
		m_spReader.Release();
#endif
        if (pvParam != NULL)
			(static_cast<IIsapiExtension*>(pvParam))->OnThreadTerminate();
	}

	void Execute(__inout AtlServerRequest *pRequestInfo, __inout __crt_typefix(IIsapiExtension*) void *pvParam, __reserved OVERLAPPED *pOverlapped)
	{
		ATLENSURE(pRequestInfo != NULL);
		ATLENSURE(pvParam != NULL);
		(pOverlapped);    // unused
		ATLASSUME(m_hHeap != NULL);
		// any exceptions thrown at this point should have been caught in an
		// override of DispatchStencilCall. They will not be thrown out of this
		// function.
		_ATLTRY
		{
			(static_cast<IIsapiExtension*>(pvParam))->DispatchStencilCall(pRequestInfo);
		}
		_ATLCATCHALL()
		{
			ATLTRACE(_T("Warning. An uncaught exception was thrown from DispatchStencilCall\n"));
			ATLASSERT(FALSE);
		}
	}

	virtual BOOL GetWorkerData(DWORD /*dwParam*/, void ** /*ppvData*/) throw()
	{
		return FALSE;
	}
};

inline void _AtlGetScriptPathTranslated(
	__in LPCSTR szPathTranslated, 
	__inout CFixedStringT<CStringA, MAX_PATH>& strScriptPathTranslated)
{
	ATLENSURE(szPathTranslated!=NULL);
	LPCSTR szEnd = szPathTranslated;

	while (TRUE)
	{
		while (*szEnd != '.' && *szEnd != '\0')
			szEnd++;
		if (*szEnd == '\0')
			break;

		szEnd++;

		size_t nLen(0);
		if (!AsciiStrnicmp(szEnd, c_AtlDLLExtension+1, ATLS_DLL_EXTENSION_LEN))
			nLen = ATLS_DLL_EXTENSION_LEN;
		else if (!AsciiStrnicmp(szEnd, c_AtlSRFExtension+1, ATLS_EXTENSION_LEN))
			nLen = ATLS_EXTENSION_LEN;

		if (nLen)
		{
			szEnd += nLen;
			if (!*szEnd || *szEnd == '/' || *szEnd == '\\' || *szEnd == '?' || *szEnd == '#')
				break;
		}
	}

	DWORD dwResult = (DWORD)(szEnd - szPathTranslated);
	char *szScriptPathTranslated = NULL;
	ATLTRY(szScriptPathTranslated = strScriptPathTranslated.GetBuffer(dwResult));
	if (szScriptPathTranslated)
	{
		Checked::memcpy_s(szScriptPathTranslated, dwResult, szPathTranslated, dwResult);
		szScriptPathTranslated[dwResult] = '\0';
		strScriptPathTranslated.ReleaseBuffer(dwResult);
	}
}


struct CStencilState
{
	CStencilState() throw()
	{
		dwIndex = 0;
		locale = CP_ACP;
		pIncludeInfo = NULL;
		pParentInfo = NULL;
	}

	DWORD dwIndex;
	LCID locale;
	AtlServerRequest* pIncludeInfo;
	AtlServerRequest* pParentInfo;
};

class CWrappedServerContext:
	public IHttpServerContext
{
public:
	CComPtr<IHttpServerContext> m_spParent;

	CWrappedServerContext() throw()
	{
	}

	virtual ~CWrappedServerContext() throw()
	{
	}

	CWrappedServerContext(__in IHttpServerContext *pParent) throw()
	{
		m_spParent = pParent;
	}

	LPCSTR GetRequestMethod()
	{
		ATLENSURE(m_spParent);
		return m_spParent->GetRequestMethod();
	}

	LPCSTR GetQueryString()
	{
		ATLENSURE(m_spParent);
		return m_spParent->GetQueryString();
	}

	LPCSTR GetPathInfo()
	{
		ATLENSURE(m_spParent);
		return m_spParent->GetPathInfo();
	}

	LPCSTR GetScriptPathTranslated()
	{       
		ATLENSURE(m_spParent);
		return m_spParent->GetScriptPathTranslated();
	}

	LPCSTR GetPathTranslated()
	{
		ATLENSURE(m_spParent);
		return m_spParent->GetPathTranslated();
	}

	DWORD GetTotalBytes()
	{
		ATLENSURE(m_spParent);
		return m_spParent->GetTotalBytes();
	}

	DWORD GetAvailableBytes()
	{
		ATLENSURE(m_spParent);
		return m_spParent->GetAvailableBytes();
	}

	BYTE *GetAvailableData()
	{
		ATLENSURE(m_spParent);
		return m_spParent->GetAvailableData();
	}

	LPCSTR GetContentType()
	{
		ATLENSURE(m_spParent);
		return m_spParent->GetContentType();
	}

	__checkReturn BOOL GetServerVariable(__in_z LPCSTR pszVariableName, __out_ecount_part(*pdwSize,*pdwSize) LPSTR pvBuffer, __inout DWORD *pdwSize)
	{
		ATLENSURE(m_spParent);
		return m_spParent->GetServerVariable(pszVariableName, pvBuffer, pdwSize);
	}

	__checkReturn BOOL WriteClient(__in_bcount(*pdwBytes) void *pvBuffer, __inout DWORD *pdwBytes)
	{ 
		ATLENSURE(m_spParent);
		return m_spParent->WriteClient(pvBuffer, pdwBytes);
	}

	__checkReturn BOOL AsyncWriteClient(__in_bcount(*pdwBytes) void * pvBuffer, __inout DWORD * pdwBytes)
	{
		ATLENSURE(m_spParent);
		return m_spParent->AsyncWriteClient(pvBuffer, pdwBytes);
	}

	__checkReturn BOOL ReadClient(__out_bcount_part(*pdwSize,*pdwSize) void * pvBuffer, __inout DWORD * pdwSize)
	{
		ATLENSURE(m_spParent);
		return m_spParent->ReadClient(pvBuffer, pdwSize);
	}

	__checkReturn BOOL AsyncReadClient(__out_bcount_part(*pdwSize,*pdwSize) void * pvBuffer, __inout DWORD * pdwSize)
	{
		ATLENSURE(m_spParent);
		return m_spParent->AsyncReadClient(pvBuffer, pdwSize);
	}

	__checkReturn BOOL SendRedirectResponse(__in LPCSTR pszRedirectUrl)
	{
		ATLENSURE(m_spParent);
		return m_spParent->SendRedirectResponse(pszRedirectUrl);
	}

	__checkReturn BOOL GetImpersonationToken(__out HANDLE * pToken)
	{
		ATLENSURE(m_spParent);
		return m_spParent->GetImpersonationToken(pToken);
	}

	__checkReturn BOOL SendResponseHeader(__in LPCSTR pszHeader, __in LPCSTR pszStatusCode, __in BOOL fKeepConn)
	{
		ATLENSURE(m_spParent);
		return m_spParent->SendResponseHeader(pszHeader, pszStatusCode, fKeepConn);
	}

	__checkReturn BOOL DoneWithSession(__in DWORD dwHttpStatusCode)
	{
		ATLENSURE(m_spParent);
		return m_spParent->DoneWithSession(dwHttpStatusCode);
	}

	__checkReturn BOOL RequestIOCompletion(__in PFN_HSE_IO_COMPLETION pfn, DWORD * pdwContext)
	{
		ATLENSURE(m_spParent);
		return m_spParent->RequestIOCompletion(pfn, pdwContext);
	}

	BOOL TransmitFile(__in HANDLE hFile, __in_opt PFN_HSE_IO_COMPLETION pfn, void * pContext,
		__in LPCSTR szStatusCode, __in DWORD dwBytesToWrite, __in DWORD dwOffset, __in_bcount_opt(dwHeadLen) void * pvHead,
		__in DWORD dwHeadLen, __in_bcount_opt(dwTailLen) void * pvTail, __in DWORD dwTailLen, __in DWORD dwFlags)
	{
		ATLENSURE(m_spParent);
		return m_spParent->TransmitFile(hFile, pfn, pContext, szStatusCode,
			dwBytesToWrite, dwOffset, pvHead, dwHeadLen, pvTail, dwTailLen,
			dwFlags);
	}

	BOOL AppendToLog(__in LPCSTR szMessage, __in_opt DWORD* pdwLen)
	{
		ATLENSURE(m_spParent);
		return m_spParent->AppendToLog(szMessage, pdwLen);
	}

	BOOL MapUrlToPathEx(__in_bcount(dwLen) LPCSTR szLogicalPath, __in DWORD dwLen, __out HSE_URL_MAPEX_INFO *pumInfo)
	{
		ATLENSURE(m_spParent);
		return m_spParent->MapUrlToPathEx(szLogicalPath, dwLen, pumInfo);
	}
}; // class CWrappedServerContext

// Wraps the EXTENSION_CONTROL_BLOCK structure used by IIS to provide
// an ISAPI extension with information about the current request and
// access to the web server's functionality.
class CServerContext :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IHttpServerContext
{
public:
	BEGIN_COM_MAP(CServerContext)
		COM_INTERFACE_ENTRY(IHttpServerContext)
	END_COM_MAP()

	CServerContext() throw()
	{
		m_pECB = NULL;
		m_bHeadersHaveBeenSent = false;
	}
	virtual ~CServerContext() throw()
	{
	}

	void Initialize(__in EXTENSION_CONTROL_BLOCK *pECB)
	{
		ATLENSURE(pECB);
		m_pECB = pECB;

		// Initialize the translated script path
		_AtlGetScriptPathTranslated(GetPathTranslated(), m_strScriptPathTranslated);
	}

	// Returns a nul-terminated string that contains the HTTP method of the current request.
	// Examples of common HTTP methods include "GET" and "POST".
	// Equivalent to the REQUEST_METHOD server variable or EXTENSION_CONTROL_BLOCK::lpszMethod.
	LPCSTR GetRequestMethod()
	{
		ATLENSURE(m_pECB);
		return m_pECB->lpszMethod;
	}

	// Returns a nul-terminated string that contains the query information.
	// This is the part of the URL that appears after the question mark (?). 
	// Equivalent to the QUERY_STRING server variable or EXTENSION_CONTROL_BLOCK::lpszQueryString.
	LPCSTR GetQueryString()
	{
		ATLENSURE(m_pECB);
		return m_pECB->lpszQueryString;
	}

	// Returns a nul-terminated string that contains the path of the current request.
	// This is the part of the URL that appears after the server name, but before the query string.
	// Equivalent to the PATH_INFO server variable or EXTENSION_CONTROL_BLOCK::lpszPathInfo.
	LPCSTR GetPathInfo()
	{
		ATLENSURE(m_pECB);
		return m_pECB->lpszPathInfo;
	}

	// Call this function to retrieve a nul-terminated string containing the physical path of the script.
	//
	// Returns TRUE on success, and FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the 
	// buffer (including the nul-terminating byte).
	// The script path is the same as GetPathTranslated up to the first .srf or .dll.
	// For example, if GetPathTranslated returns "c:\inetpub\vcisapi\hello.srf\goodmorning",
	// then this function returns "c:\inetpub\vcisapi\hello.srf".
	LPCSTR GetScriptPathTranslated()
	{
		ATLASSUME(m_pECB);
		return m_strScriptPathTranslated;
	}


	// Returns a nul-terminated string that contains the translated path of the requested resource.
	// This is the path of the resource on the local server.
	// Equivalent to the PATH_TRANSLATED server variable or EXTENSION_CONTROL_BLOCK::lpszPathTranslated.
	LPCSTR GetPathTranslated()
	{
		ATLENSURE(m_pECB);
		return m_pECB->lpszPathTranslated;
	}

	// Returns the total number of bytes to be received from the client.
	// If this value is 0xffffffff, then there are four gigabytes or more of available data.
	// In this case, ReadClient or AsyncReadClient should be called until no more data is returned.
	// Equivalent to the CONTENT_LENGTH server variable or EXTENSION_CONTROL_BLOCK::cbTotalBytes. 
	DWORD GetTotalBytes()
	{
		ATLENSURE(m_pECB);
		return m_pECB->cbTotalBytes;
	}

	// Returns the number of bytes available in the request buffer accessible via GetAvailableData.
	// If GetAvailableBytes returns the same value as GetTotalBytes, the request buffer contains the whole request.
	// Otherwise, the remaining data should be read from the client using ReadClient or AsyncReadClient.
	// Equivalent to EXTENSION_CONTROL_BLOCK::cbAvailable.
	DWORD GetAvailableBytes()
	{
		ATLENSURE(m_pECB);
		return m_pECB->cbAvailable;
	}

	// Returns a pointer to the request buffer containing the data sent by the client.
	// The size of the buffer can be determined by calling GetAvailableBytes.
	// Equivalent to EXTENSION_CONTROL_BLOCK::lpbData
	BYTE *GetAvailableData()
	{
		ATLENSURE(m_pECB);
		return m_pECB->lpbData;
	}

	// Returns a nul-terminated string that contains the content type of the data sent by the client.
	// Equivalent to the CONTENT_TYPE server variable or EXTENSION_CONTROL_BLOCK::lpszContentType.
	LPCSTR GetContentType()
	{
		ATLENSURE(m_pECB);
		return m_pECB->lpszContentType;
	}

	// Call this function to retrieve a nul-terminated string containing the value of the requested server variable.
	// Returns TRUE on success, and FALSE on failure. Call GetLastError to get extended error information.
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	// Equivalent to  EXTENSION_CONTROL_BLOCK::GetServerVariable.
	__checkReturn BOOL GetServerVariable(
		__in LPCSTR pszVariableName,
		__out_ecount_part(*pdwSize,*pdwSize) LPSTR pvBuffer,
		__inout DWORD *pdwSize)
	{
		ATLENSURE(m_pECB);
		ATLASSERT(pszVariableName);
		ATLASSERT(pdwSize);

		if (pszVariableName && pdwSize)
		{
			return m_pECB->GetServerVariable(m_pECB->ConnID, (LPSTR) pszVariableName,
							pvBuffer, pdwSize);
		}
		return FALSE;
	}

	// Synchronously sends the data present in the given buffer to the client that made the request.
	// Returns TRUE on success, and FALSE on failure. Call GetLastError to get extended error information.
	// Equivalent to EXTENSION_CONTROL_BLOCK::WriteClient(..., HSE_IO_SYNC).
	__checkReturn BOOL WriteClient(__in_bcount(*pdwBytes) void *pvBuffer, __inout DWORD *pdwBytes)
	{
		ATLENSURE(m_pECB);
		ATLASSERT(pvBuffer);
		ATLASSERT(pdwBytes);

		if (pvBuffer && pdwBytes)
		{
			return m_pECB->WriteClient(m_pECB->ConnID, pvBuffer, pdwBytes, HSE_IO_SYNC | HSE_IO_NODELAY);
		}
		return FALSE;
	}

	// Asynchronously sends the data present in the given buffer to the client that made the request.
	// Returns TRUE on success, and FALSE on failure. Call GetLastError to get extended error information.
	// Equivalent to EXTENSION_CONTROL_BLOCK::WriteClient(..., HSE_IO_ASYNC).
	__checkReturn BOOL AsyncWriteClient(__in_bcount(*pdwBytes) void *pvBuffer, __inout DWORD *pdwBytes)
	{
		ATLENSURE(m_pECB);
		ATLASSERT(pvBuffer);
		ATLASSERT(pdwBytes);

		if (pvBuffer && pdwBytes)
		{
			return m_pECB->WriteClient(m_pECB->ConnID, pvBuffer, pdwBytes, HSE_IO_ASYNC | HSE_IO_NODELAY);
		}
		return FALSE;
	}

	// Call this function to synchronously read information from the body of the web client's HTTP request into the buffer supplied by the caller.
	// Returns TRUE on success, and FALSE on failure. Call GetLastError to get extended error information.
	// Equivalent to EXTENSION_CONTROL_BLOCK::ReadClient.
	__checkReturn BOOL ReadClient(__out_ecount_part(*pdwSize,*pdwSize) void *pvBuffer, __inout DWORD *pdwSize)
	{
		ATLENSURE(m_pECB);
		ATLASSERT(pvBuffer);
		ATLASSERT(pdwSize);

		if (pvBuffer && pdwSize)
		{
			return m_pECB->ReadClient(m_pECB->ConnID, pvBuffer, pdwSize);
		}
		return FALSE;
	}

	// Call this function to asynchronously read information from the body of the web client's HTTP request into the buffer supplied by the caller.
	// Returns TRUE on success, and FALSE on failure. Call GetLastError to get extended error information.
	// Equivalent to the HSE_REQ_ASYNC_READ_CLIENT server support function.
	__checkReturn BOOL AsyncReadClient(__out_bcount_part(*pdwSize,*pdwSize) void *pvBuffer, __inout DWORD *pdwSize)
	{
		// To call this function successfully someone has to have already
		// called RequestIOCompletion specifying the callback function
		// to be used for IO completion.
		ATLENSURE(m_pECB);
		ATLASSERT(pvBuffer);
		ATLASSERT(pdwSize);

		if (pvBuffer && pdwSize)
		{
			DWORD dwFlag = HSE_IO_ASYNC;
			return m_pECB->ServerSupportFunction(m_pECB->ConnID,
				HSE_REQ_ASYNC_READ_CLIENT, pvBuffer, pdwSize,
				&dwFlag);
		}
		return FALSE;
	}

	// Call this function to redirect the client to the specified URL.
	// The client receives a 302 (Found) HTTP status code.
	// Returns TRUE on success, and FALSE on failure.
	// Equivalent to the HSE_REQ_SEND_URL_REDIRECT_RESP server support function.
	__checkReturn BOOL SendRedirectResponse(__in LPCSTR pszRedirectUrl)
	{
		ATLENSURE(m_pECB);
		ATLENSURE(pszRedirectUrl);

		if (pszRedirectUrl)
		{
			DWORD dwSize = (DWORD) strlen(pszRedirectUrl);
			return m_pECB->ServerSupportFunction(m_pECB->ConnID,
				HSE_REQ_SEND_URL_REDIRECT_RESP,
				(void *) pszRedirectUrl, &dwSize, NULL);
		}
		return FALSE;
	}

	// Call this function to retrieve a handle to the impersonation token for this request.
	// An impersonation token represents a user context. You can use the handle in calls to ImpersonateLoggedOnUser or SetThreadToken.
	// Do not call CloseHandle on the handle.
	// Returns TRUE on success, and FALSE on failure.
	// Equivalent to the HSE_REQ_GET_IMPERSONATION_TOKEN server support function.
	__checkReturn BOOL GetImpersonationToken(__out HANDLE * pToken)
	{
		ATLENSURE(m_pECB);
		if (pToken)
		{
			return m_pECB->ServerSupportFunction(m_pECB->ConnID,
				HSE_REQ_GET_IMPERSONATION_TOKEN, pToken,
				NULL, NULL);
		}
		return FALSE;
	}

	// Call this function to send an HTTP response header to the client including the HTTP status, server version, message time, and MIME version.
	// Returns TRUE on success, and FALSE on failure.
	// Equivalent to the HSE_REQ_SEND_RESPONSE_HEADER_EX server support function.
	__checkReturn BOOL SendResponseHeader(
		__in LPCSTR pszHeader = "Content-Type: text/html\r\n\r\n",
		__in LPCSTR pszStatusCode = "200 OK",
		__in BOOL fKeepConn=FALSE)
	{
		ATLENSURE(m_pECB);

		if (m_bHeadersHaveBeenSent)
			return TRUE;

		HSE_SEND_HEADER_EX_INFO hex;
		hex.pszStatus = pszStatusCode;
		hex.pszHeader = pszHeader;
		hex.cchStatus = (DWORD)(pszStatusCode ? strlen(pszStatusCode) : 0);
		hex.cchHeader = (DWORD)(pszHeader ? strlen(pszHeader) : 0);
		hex.fKeepConn = fKeepConn;

		m_bHeadersHaveBeenSent = true;

		return m_pECB->ServerSupportFunction(m_pECB->ConnID,
			HSE_REQ_SEND_RESPONSE_HEADER_EX,
			&hex, NULL, NULL);
	}

	// Call this function to terminate the session for the current request.
	// Returns TRUE on success, and FALSE on failure.
	// Equivalent to the HSE_REQ_DONE_WITH_SESSION server support function.
	__checkReturn BOOL DoneWithSession(__in DWORD dwHttpStatusCode)
	{
		ATLENSURE(m_pECB);

		m_pECB->dwHttpStatusCode = dwHttpStatusCode;

		DWORD dwStatusCode = (dwHttpStatusCode >= 400) ? HSE_STATUS_ERROR : HSE_STATUS_SUCCESS;

		return m_pECB->ServerSupportFunction(m_pECB->ConnID,
			HSE_REQ_DONE_WITH_SESSION, &dwStatusCode, NULL, NULL);
	}

	// Call this function to set a special callback function that will be used for handling the completion of asynchronous I/O operations.
	// Returns TRUE on success, and FALSE on failure.
	// Equivalent to the HSE_REQ_IO_COMPLETION server support function.
	__checkReturn BOOL RequestIOCompletion(__in PFN_HSE_IO_COMPLETION pfn, DWORD *pdwContext)
	{
		ATLENSURE(m_pECB);
		ATLASSERT(pfn);

		if (pfn)
		{
			return m_pECB->ServerSupportFunction(m_pECB->ConnID,
				HSE_REQ_IO_COMPLETION, pfn, NULL, pdwContext);
		}
		return FALSE;
	}

	// Call this function to transmit a file asynchronously to the client.
	// Returns TRUE on success, and FALSE on failure.
	// Equivalent to the HSE_REQ_TRANSMIT_FILE server support function.
	BOOL TransmitFile(
		__in HANDLE hFile,
		__in_opt PFN_HSE_IO_COMPLETION pfn,
		void *pContext,
		__in LPCSTR szStatusCode,
		__in DWORD dwBytesToWrite,
		__in DWORD dwOffset,
		__in_bcount_opt(dwHeadLen) void *pvHead,
		__in DWORD dwHeadLen,
		__in_bcount_opt(dwTailLen) void *pvTail,
		__in DWORD dwTailLen,
		__in DWORD dwFlags)
	{
		ATLENSURE(m_pECB);

		HSE_TF_INFO tf;
		tf.hFile = hFile;
		tf.BytesToWrite = dwBytesToWrite;
		tf.Offset = dwOffset;
		tf.pContext = pContext;
		tf.pfnHseIO = pfn;
		tf.pHead = pvHead;
		tf.HeadLength = dwHeadLen;
		tf.pTail = pvTail;
		tf.TailLength = dwTailLen;
		tf.pszStatusCode = szStatusCode;
		tf.dwFlags = dwFlags;
		return m_pECB->ServerSupportFunction(m_pECB->ConnID,
			HSE_REQ_TRANSMIT_FILE, &tf, NULL, NULL);
	}

	// Appends the string szMessage to the web server log for the current
	// request.
	// Returns TRUE on success, FALSE on failure.
	// Equivalent to the HSE_APPEND_LOG_PARAMETER server support function.
	BOOL AppendToLog(__in LPCSTR szMessage, __in_opt DWORD *pdwLen)
	{
		DWORD dwLen = 0;
		if (!pdwLen)
		{
			if(!szMessage)
			{
				return FALSE;
			}
			dwLen = (DWORD)strlen(szMessage);
		}
		else
		{
			dwLen = *pdwLen;
		}

		return m_pECB->ServerSupportFunction(m_pECB->ConnID,
			HSE_APPEND_LOG_PARAMETER, (void *)szMessage, 
			&dwLen, NULL);
	}

	// Maps a logical Url Path to a physical path
	// Returns TRUE on success, FALSE on failure.
	// Equivalent to the HSE_REQ_MAP_URL_TO_PATH_EX server support function.
	// you can pass 0 for dwLen if szLogicalPath is null terminated
	BOOL MapUrlToPathEx(__in_bcount(dwLen) LPCSTR szLogicalPath, __in DWORD dwLen, __out HSE_URL_MAPEX_INFO *pumInfo)
	{
		ATLENSURE(m_pECB!=NULL);
		if (dwLen == 0)
			dwLen = (DWORD) strlen(szLogicalPath);
		return m_pECB->ServerSupportFunction(m_pECB->ConnID, HSE_REQ_MAP_URL_TO_PATH_EX, (void *) szLogicalPath,
			&dwLen, (DWORD *) pumInfo);
	}

protected:
	// The pointer to the extension control block provided by IIS.
	EXTENSION_CONTROL_BLOCK *m_pECB;
	bool m_bHeadersHaveBeenSent;

	// The translated script path
	CFixedStringT<CStringA, MAX_PATH> m_strScriptPathTranslated;

}; // class CServerContext

class CPageCachePeer
{
public:

	struct PeerInfo
	{
		CStringA strHeader;
		CStringA strStatus;
	};

	static BOOL Add(__inout PeerInfo * pDest, __in PeerInfo * pSrc) throw()
	{
		_ATLTRY
		{
			PeerInfo *pIn = (PeerInfo *)pSrc;
			pDest->strHeader = pIn->strHeader;
			pDest->strStatus = pIn->strStatus;
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	static BOOL Remove(const PeerInfo * /*pDest*/) throw()
	{
		return TRUE;
	}
};


class CCacheServerContext :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CWrappedServerContext,
	public IPageCacheControl
{
private:

	CAtlTemporaryFile m_cacheFile;
	CComPtr<IFileCache> m_spCache;
	char m_szFullUrl[ATL_URL_MAX_URL_LENGTH + 1];
	FILETIME m_ftExpiration;
	BOOL m_bIsCached;
	CPageCachePeer::PeerInfo m_Headers;

public:

	BEGIN_COM_MAP(CCacheServerContext)
		COM_INTERFACE_ENTRY(IHttpServerContext)
		COM_INTERFACE_ENTRY(IPageCacheControl)
	END_COM_MAP()

	CCacheServerContext() throw()
	{
	}
	virtual ~CCacheServerContext() throw()
	{
	}

	BOOL Initialize(__in IHttpServerContext *pParent, __in IFileCache *pCache) throw()
	{
		ATLASSERT(pParent);
		ATLASSERT(pCache);

		if (pParent == NULL || pCache == NULL)
			return FALSE;

		m_spParent = pParent;
		m_spCache = pCache;

		if (FAILED(m_cacheFile.Create()))
			return FALSE;

		LPCSTR szPathInfo = pParent->GetPathInfo();
		LPCSTR szQueryString = pParent->GetQueryString();
		if ( szPathInfo == NULL || szQueryString == NULL)
			 return FALSE;

		LPSTR szTo = m_szFullUrl;
		int nSize = 0;
		while (*szPathInfo && nSize < ATL_URL_MAX_URL_LENGTH)
		{
			*szTo++ = *szPathInfo++;
			nSize++;
		}
		if (nSize >= ATL_URL_MAX_URL_LENGTH)
		{
			return FALSE;
		}
		*szTo++ = '?';
		nSize++;
		while (*szQueryString && nSize < ATL_URL_MAX_URL_LENGTH)
		{
			*szTo++ = *szQueryString++;
			nSize++;
		}
		if (nSize >= ATL_URL_MAX_URL_LENGTH)
		{
			return FALSE;
		}
		*szTo = '\0';

		memset(&m_ftExpiration, 0x00, sizeof(FILETIME));
		m_bIsCached = TRUE;

		return TRUE;
	}

	// IPageCacheControl methods
	HRESULT GetExpiration(__out FILETIME *pftExpiration) throw()
	{
		ATLASSERT(pftExpiration);
		if (!pftExpiration)
			return E_INVALIDARG;

		*pftExpiration = m_ftExpiration;

		return S_OK;
	}

	HRESULT SetExpiration(__in FILETIME ftExpiration) throw()
	{
		m_ftExpiration = ftExpiration;

		return S_OK;
	}

	__checkReturn BOOL IsCached() throw()
	{
		return m_bIsCached;
	}

	BOOL Cache(__in BOOL bCache) throw()
	{
		BOOL bRet = m_bIsCached;
		m_bIsCached = bCache;
		return bRet;
	}

	__checkReturn BOOL WriteClient(__in_bcount(*pdwBytes) void *pvBuffer, __inout DWORD *pdwBytes)
	{ 
		ATLENSURE(pvBuffer);
		ATLENSURE(pdwBytes);
		
		if (S_OK != m_cacheFile.Write(pvBuffer, *pdwBytes))
			return FALSE;
		ATLENSURE(m_spParent);
		return m_spParent->WriteClient(pvBuffer, pdwBytes);
	}

	__checkReturn BOOL DoneWithSession(__in DWORD dwHttpStatusCode)
	{
		ATLENSURE(m_spParent);

		_ATLTRY
		{
		   if (m_bIsCached)
		   {
			   CT2CA strFileName(m_cacheFile.TempFileName());
			   m_cacheFile.HandsOff();
			   m_spCache->AddFile(m_szFullUrl, strFileName, &m_ftExpiration, &m_Headers, NULL);
		   }
		   else
			   m_cacheFile.Close();
		}
		_ATLCATCHALL()
		{
			m_cacheFile.Close();
		}

		return m_spParent->DoneWithSession(dwHttpStatusCode);
	}

	__checkReturn BOOL GetImpersonationToken(__out HANDLE * pToken)
	{
		ATLTRACE(atlTraceISAPI, 0, _T("Getting impersonation token for cached page")
			_T(" -- Caching a page that requires special privileges to build is a possible security problem. ")
			_T("Future hits may get a cached page without going through the security checks done during the page creation process"));
		ATLENSURE(m_spParent);
		ATLASSERT(pToken);
		return m_spParent->GetImpersonationToken(pToken);
	}

	__checkReturn BOOL AppendToLog(__in LPCSTR szMessage, __in_opt DWORD* pdwLen)
	{
		ATLTRACE(atlTraceISAPI, 0, _T("Logging on cached page -- future hits will not log"));
		ATLENSURE(m_spParent);
		return m_spParent->AppendToLog(szMessage, pdwLen);
	}

	__checkReturn BOOL SendResponseHeader(
		__in LPCSTR pszHeader = "Content-Type: text/html\r\n\r\n",
		__in LPCSTR pszStatusCode = "200 OK",
		__in BOOL fKeepConn=FALSE)
	{
		ATLENSURE(m_spParent);

		m_Headers.strHeader = pszHeader;
		m_Headers.strStatus = pszStatusCode;

		return m_spParent->SendResponseHeader(pszHeader, pszStatusCode, fKeepConn);
	}

	// The methods below this point are actions that should not be performed on cached
	// pages, as they will not behave correctly.
	__checkReturn BOOL AsyncWriteClient(void * /*pvBuffer*/, DWORD * /*pdwBytes*/)
	{
		// Asynchronous calls will not work
		ATLASSERT(FALSE);
		return FALSE;
	}

	__checkReturn BOOL ReadClient(void * /*pvBuffer*/, DWORD * /*pdwSize*/)
	{
		// Nobody should be reading from this client if the page is being cached
		// Also, only GET's are cached anyway
		ATLASSERT(FALSE);
		return FALSE;
	}

	__checkReturn BOOL AsyncReadClient(void * /*pvBuffer*/, DWORD * /*pdwSize*/)
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	__checkReturn BOOL SendRedirectResponse(LPCSTR /*pszRedirectUrl*/)
	{
		ATLASSERT(FALSE);
		return FALSE;
	}


	__checkReturn BOOL RequestIOCompletion(PFN_HSE_IO_COMPLETION /*pfn*/, DWORD * /*pdwContext*/)
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	__checkReturn BOOL TransmitFile(
		HANDLE /*hFile*/,
		PFN_HSE_IO_COMPLETION /*pfn*/,
		void * /*pContext*/,
		LPCSTR /*szStatusCode*/,
		DWORD /*dwBytesToWrite*/,
		DWORD /*dwOffset*/,
		void * /*pvHead*/,
		DWORD /*dwHeadLen*/,
		void * /*pvTail*/,
		DWORD /*dwTailLen*/,
		DWORD /*dwFlags*/)
	{
		ATLASSERT(FALSE);
		return FALSE;
	}
};


// This class represents a collection of validation failures.
// Use this class in combination with CValidateObject to validate
// forms, cookies, or query strings and build up a collection of
// failures. If appropriate, use the information in the collection
// to return detailed responses to the client to help them correct the failures.


class CValidateContext 
{
public:
	enum { ATL_EMPTY_PARAMS_ARE_FAILURES = 0x00000001 };

	CValidateContext(__in DWORD dwFlags=0) throw()
	{
		m_bFailures = false;
		m_dwFlags = dwFlags;
	}

	bool SetResultAt(__in LPCSTR szName, __in DWORD type)
	{
		_ATLTRY
		{
			if (!VALIDATION_SUCCEEDED(type) ||
				(type == VALIDATION_S_EMPTY && (m_dwFlags & ATL_EMPTY_PARAMS_ARE_FAILURES)))
				m_bFailures = true;

			return TRUE == m_results.SetAt(szName,type);

		}
		_ATLCATCHALL()
		{
		}

		return false;
	}

	// Call this function to add a validation result to the collection managed by this object.
	// Each result is identified by a name and the type of result that occurred.
	// The result codes are the VALIDATION_ codes defined at the top of this file.
	// The bOnlyFailure parameter below is used to only allow failure results to
	// be added to the list of failures. The reason you'd want to do this is that
	// success codes should be the common case in validation routines so you can
	// use bOnlyFailures to limit the number of allocations by this class's base
	// map for mapping success results if you don't care about iterating successes.

	bool AddResult(__in LPCSTR szName, __in DWORD type, __in bool bOnlyFailures = true) throw()
	{
		_ATLTRY
		{
			if (!VALIDATION_SUCCEEDED(type) ||
				(type == VALIDATION_S_EMPTY && (m_dwFlags & ATL_EMPTY_PARAMS_ARE_FAILURES)))
				m_bFailures = true;

			if (!bOnlyFailures)
				return TRUE == m_results.Add(szName, type); // add everything

			else if (bOnlyFailures && 
					(!VALIDATION_SUCCEEDED(type) ||
					(type == VALIDATION_S_EMPTY && (m_dwFlags & ATL_EMPTY_PARAMS_ARE_FAILURES))))
				return TRUE == m_results.Add(szName, type); // only add failures
		}
		_ATLCATCHALL()
		{
		}

		return false;
	}

	// Returns true if there are no validation failures in the collection,
	// returns false otherwise.
	__checkReturn bool ParamsOK() throw()
	{
		return !m_bFailures;
	}

	// Returns the number of validation results in the collection.
	__checkReturn int GetResultCount() throw()
	{
		return m_results.GetSize();
	}

	// Call this function to retrieve the name and type of a
	// validation result based on its index in the collection.
	// Returns true on success, false on failure.
	//
	// i        The index of a result managed by this collection.
	//
	// strName  On success, the name of the result with index i.
	//
	// type     On success, the type of the result with index i.
	__checkReturn bool GetResultAt(__in int i, __out CStringA& strName, __out DWORD& type) throw()
	{
		if ( i >= 0 && i < m_results.GetSize())
		{
			_ATLTRY
			{
				strName = m_results.GetKeyAt(i);
				type = m_results.GetValueAt(i);
			}
			_ATLCATCHALL()
			{
				return false;
			}
			return true;
		}
		return false;
	}

	DWORD m_dwFlags;
protected:
	CSimpleMap<CStringA, DWORD> m_results;
	bool m_bFailures;
}; // CValidateContext



class CAtlValidator
{
public:
	template <class T, class TCompType>
	static DWORD Validate(
		__in T value,
		__in TCompType nMinValue,
		__in TCompType nMaxValue) throw()
	{
		DWORD dwRet = VALIDATION_S_OK;
		if (value < static_cast<T>(nMinValue))
			dwRet = VALIDATION_E_LENGTHMIN;
		else if (value > static_cast<T>(nMaxValue))             
			dwRet = VALIDATION_E_LENGTHMAX;
		return dwRet;
	}

	static DWORD Validate( __in LPCSTR pszValue, __in int nMinChars, __in int nMaxChars) throw()
	{
		DWORD dwRet = VALIDATION_S_OK;
		if(!pszValue)
		{
			return VALIDATION_E_FAIL;
		}
		int nChars = (int) strlen(pszValue);
		if (nChars < nMinChars)
			dwRet = VALIDATION_E_LENGTHMIN;
		else if (nChars > nMaxChars)
			dwRet = VALIDATION_E_LENGTHMAX;
		return dwRet;
	}
	static DWORD Validate( __in double dblValue, __in double dblMinValue, __in double dblMaxValue) throw()
	{
		DWORD dwRet = VALIDATION_S_OK;
		if ( dblValue < (dblMinValue - ATL_EPSILON) )
			dwRet = VALIDATION_E_LENGTHMIN;
		else if ( dblValue > (dblMaxValue + ATL_EPSILON) )
			dwRet = VALIDATION_E_LENGTHMAX;
		return dwRet;
	}
};

// This class provides functions for retrieving and validating named values.
//
// The named values are expected to be provided in string form by the class used as
// the template parameter. CValidateObject provides the means of
// retrieving these values converted to data types chosen by you. You can validate the values
// by specifying a range for numeric values or by specifying a minimum and maximum length
// for string values.
//
// Call one of the Exchange overloads to retrieve a named value converted to your chosen data type.
// Call one of the Validate overloads to retrieve a named value converted to your chosen data type
// and validated against a minimum and maximum value or length supplied by you.
//
// To add validation functionality to the class TLookupClass, derive that class from CValidateObject<TLookupClass>
// and provide a Lookup function that takes a name as a string and returns the corresponding value
// also as a string:
//      LPCSTR Lookup(LPCSTR szName);
template <class TLookupClass, class TValidator = CAtlValidator>
class CValidateObject
{
public:
	// Exchange Routines

	// Call this function to retrieve a named value converted to your chosen data type.
	// Returns one of the following validation status codes:
	//      VALIDATION_S_OK             The named value was found and could be converted successfully
	//      VALIDATION_S_EMPTY          The name was present, but the value was empty
	//      VALIDATION_E_PARAMNOTFOUND  The named value was not found
	//      VALIDATION_E_INVALIDPARAM   The name was present, but the value could not be converted to the requested data type
	//      VALIDATION_E_FAIL           An unspecified error occurred
	// Pass a pointer to a validation context object if you want to add
	// failures to the collection managed by that object.
	template <class T>
	ATL_NOINLINE __checkReturn DWORD Exchange(
		__in LPCSTR szParam,
		__out T* pValue,
		__inout_opt CValidateContext *pContext = NULL) const throw()
	{
		DWORD dwRet = VALIDATION_E_PARAMNOTFOUND;
		if (pValue)
		{
			_ATLTRY
			{
				const TLookupClass *pT = static_cast<const TLookupClass*>(this);
				LPCSTR szValue = pT->Lookup(szParam);
				if (szValue)
				{
					if (*szValue=='\0')
						dwRet = VALIDATION_S_EMPTY; 
					else
					{
						dwRet = ConvertNumber(szValue, pValue);
					}
				}
			}
			_ATLCATCHALL()
			{
				return VALIDATION_E_FAIL;
			}
		}
		else
			dwRet = VALIDATION_E_FAIL; // invalid input

		if (pContext)
			pContext->AddResult(szParam, dwRet);
		return dwRet;
	}

	template<>
	ATL_NOINLINE __checkReturn DWORD Exchange(
		__in LPCSTR szParam,
		__out_opt CString* pstrValue,
		__in_opt CValidateContext *pContext) const throw()
	{
		_ATLTRY
		{
			LPCSTR pszValue = NULL;
			DWORD dwRet = VALIDATION_E_PARAMNOTFOUND;
			if (pstrValue)
			{
				dwRet = Exchange(szParam, &pszValue, pContext);
				if (VALIDATION_SUCCEEDED(dwRet) && pstrValue != NULL)
					*pstrValue = CA2T(pszValue);
			}
			else
			{
				dwRet = VALIDATION_E_FAIL; // invalid input
				if (pContext)
					pContext->AddResult(szParam, dwRet);
			}

			return dwRet;
		}
		_ATLCATCHALL()
		{
			return VALIDATION_E_FAIL;
		}
	}

	template<>
	ATL_NOINLINE __checkReturn DWORD Exchange(
		__in LPCSTR szParam,
		__deref_out_opt LPCSTR* ppszValue,
		__inout_opt CValidateContext *pContext) const throw()
	{
		DWORD dwRet = VALIDATION_E_PARAMNOTFOUND;
		if (ppszValue)
		{
			_ATLTRY
			{
				*ppszValue = NULL;
				const TLookupClass *pT = static_cast<const TLookupClass*>(this);
				LPCSTR szValue = pT->Lookup(szParam);
				if (szValue)
				{
					if (*szValue=='\0')
						dwRet = VALIDATION_S_EMPTY; 
					else
					{
						*ppszValue = szValue;
						dwRet = VALIDATION_S_OK;
					}
				}
			}
			_ATLCATCHALL()
			{
				return VALIDATION_E_FAIL;
			}
		}
		else
			dwRet = VALIDATION_E_FAIL; // invalid input

		if (pContext)
			pContext->AddResult(szParam, dwRet);
		return dwRet;
	}

	template<>
	ATL_NOINLINE __checkReturn DWORD Exchange(
		__in LPCSTR szParam,
		__out GUID* pValue,
		__inout_opt CValidateContext *pContext) const throw()
	{
		DWORD dwRet = VALIDATION_E_PARAMNOTFOUND;
		if (pValue)
		{
			_ATLTRY
			{
				const TLookupClass *pT = static_cast<const TLookupClass*>(this);
				LPCSTR szValue = pT->Lookup(szParam);
				if (szValue)
				{
					if (*szValue=='\0')
						dwRet = VALIDATION_S_EMPTY; 
					else
					{						
						if (S_OK != CLSIDFromString(CA2W(szValue), pValue))
						{
							dwRet = VALIDATION_E_INVALIDPARAM;
						}
						else
							dwRet = VALIDATION_S_OK;
					}
				}
			}
			_ATLCATCHALL()
			{
				return VALIDATION_E_FAIL;
			}
		}
		else
			dwRet = VALIDATION_E_FAIL; // invalid input

		if (pContext)
			pContext->AddResult(szParam, dwRet);
		return dwRet;
	}

	template<>
	ATL_NOINLINE __checkReturn DWORD Exchange(
		__in LPCSTR szParam,
		__out bool* pbValue,
		__inout_opt CValidateContext *pContext) const throw()
	{
		DWORD dwRet = VALIDATION_S_OK;
		if (pbValue)
		{
			_ATLTRY
			{
				const TLookupClass *pT = static_cast<const TLookupClass*>(this);
				LPCSTR szValue = pT->Lookup(szParam);
				*pbValue = false;
				if (szValue)
				{
					if (*szValue != '\0')
						*pbValue = true;
				}
			}
			_ATLCATCHALL()
			{
				return VALIDATION_E_FAIL;
			}
		}
		else
			dwRet = VALIDATION_E_FAIL; // invalid input

		if (pContext)
			pContext->AddResult(szParam, dwRet);

		return dwRet;
	}

	__checkReturn DWORD ConvertNumber(__in LPCSTR szVal, __out ULONGLONG *pnVal) const throw()
	{
		if (!szVal)
			return VALIDATION_E_FAIL;

		ATLASSERT(pnVal);
		if (!pnVal)
			return VALIDATION_E_FAIL;
		char *pEnd = NULL;
		ULONGLONG n = _strtoui64(szVal, &pEnd, 10);
		if (pEnd == szVal || Checked::get_errno() == ERANGE)
		{
			Checked::set_errno(0);
			return VALIDATION_E_INVALIDPARAM;
		}
		*pnVal = n;
		return VALIDATION_S_OK;
	}

	__checkReturn DWORD ConvertNumber(__in LPCSTR szVal, __out LONGLONG *pnVal) const throw()
	{
		if (!szVal)
			return VALIDATION_E_FAIL;

		ATLASSERT(pnVal);
		if (!pnVal)
			return VALIDATION_E_FAIL;
		char *pEnd = NULL;
		LONGLONG n = _strtoi64(szVal, &pEnd, 10);
		if (pEnd == szVal || Checked::get_errno() == ERANGE)
		{
			Checked::set_errno(0);
			return VALIDATION_E_INVALIDPARAM;
		}
		*pnVal = n;
		return VALIDATION_S_OK;
	}

	__checkReturn DWORD ConvertNumber(__in LPCSTR szVal, __out double *pdblVal) const throw()
	{
		if (!szVal)
			return VALIDATION_E_FAIL;

		ATLASSERT(pdblVal);
		if (!pdblVal)
			return VALIDATION_E_FAIL;
		char *pEnd = NULL;
		double d = strtod(szVal, &pEnd);
		if (pEnd == szVal || Checked::get_errno() == ERANGE)
		{
			Checked::set_errno(0);
			return VALIDATION_E_INVALIDPARAM;
		}
		*pdblVal = d;
		return VALIDATION_S_OK;
	}

	__checkReturn DWORD ConvertNumber(__in LPCSTR szVal, __out int *pnVal) const throw()
	{
		return ConvertNumber(szVal, (long*)pnVal);
	}

	__checkReturn DWORD ConvertNumber(__in LPCSTR szVal, __out unsigned int *pnVal) const throw()
	{
		return ConvertNumber(szVal, (unsigned long*)pnVal);
	}

	__checkReturn DWORD ConvertNumber(__in LPCSTR szVal, __out long *pnVal) const throw()
	{
		if (!szVal)
			return VALIDATION_E_FAIL;

		ATLASSERT(pnVal);
		if (!pnVal)
			return VALIDATION_E_FAIL;
		char *pEnd = NULL;
		long n = strtol(szVal, &pEnd, 10);
		if (pEnd == szVal || Checked::get_errno() == ERANGE)
		{
			Checked::set_errno(0);
			return VALIDATION_E_INVALIDPARAM;
		}
		*pnVal = n;
		return VALIDATION_S_OK;
	}

	__checkReturn DWORD ConvertNumber(__in LPCSTR szVal, __out unsigned long *pnVal) const throw()
	{
		if (!szVal)
			return VALIDATION_E_FAIL;

		ATLASSERT(pnVal);
		if (!pnVal)
			return VALIDATION_E_FAIL;
		char *pEnd = NULL;
		long n = strtoul(szVal, &pEnd, 10);
		if (pEnd == szVal || Checked::get_errno() == ERANGE)
		{
			Checked::set_errno(0);
			return VALIDATION_E_INVALIDPARAM;
		}
		*pnVal = n;
		return VALIDATION_S_OK;
	}

	__checkReturn DWORD ConvertNumber(__in LPCSTR szVal, __out short *pnVal) const throw()
	{
		if (!szVal)
			return VALIDATION_E_FAIL;

		ATLASSERT(pnVal);
		if (!pnVal)
			return VALIDATION_E_FAIL;
		long nVal = 0;
		DWORD dwRet = ConvertNumber(szVal, &nVal);
		if (dwRet == VALIDATION_S_OK)
		{
			// clamp to the size of a short
			if(nVal <= SHRT_MAX &&
				nVal >= SHRT_MIN)
			{
				*pnVal = (short)nVal;
			}
			else
			{
				dwRet = VALIDATION_E_INVALIDPARAM;
			}
		}
		return dwRet;
	};

	__checkReturn DWORD ConvertNumber(__in LPCSTR szVal, __out unsigned short *pnVal) const throw()
	{
		if (!szVal)
			return VALIDATION_E_FAIL;

		ATLASSERT(pnVal);
		if (!pnVal)
			return VALIDATION_E_FAIL;
		unsigned long nVal = 0;
		DWORD dwRet = ConvertNumber(szVal, &nVal);
		if (dwRet == VALIDATION_S_OK)
		{
			// clamp to the size of a short
			if(nVal <= USHRT_MAX &&
			   nVal >= 0)
			{
				*pnVal = (unsigned short)nVal;
			}
			else
			{
				dwRet = VALIDATION_E_INVALIDPARAM;
			}
		}
		return dwRet;
	};

	// Call this function to retrieve a named value converted to your chosen data type
	// and validated against a minimum and maximum value or length supplied by you.
	//
	// Returns one of the following validation status codes:
	//      VALIDATION_S_OK             The named value was found and could be converted successfully
	//      VALIDATION_S_EMPTY          The name was present, but the value was empty
	//      VALIDATION_E_PARAMNOTFOUND  The named value was not found
	//      VALIDATION_E_INVALIDPARAM   The name was present, but the value could not be converted to the requested data type
	//      VALIDATION_E_LENGTHMIN      The name was present and could be converted to the requested data type, but the value was too small
	//      VALIDATION_E_LENGTHMAX      The name was present and could be converted to the requested data type, but the value was too large
	//      VALIDATION_E_FAIL           An unspecified error occurred
	//
	// Validate can be used to convert and validate name-value pairs
	// such as those associated with HTTP requests (query string, form fields, or cookie values).  
	// The numeric specializations validate the minimum and maximum value.
	// The string specializations validate the minimum and maximum length.
	//
	// Pass a pointer to a validation context object if you want to add
	// failures to the collection managed by that object.
	//
	// Note that you can validate the value of a parameter without
	// storing its value by passing NULL for the second parameter. However
	// if you pass NULL for the second parameter, make sure you cast the NULL to a 
	// type so that the compiler will call the correct specialization of Validate.
	template <class T, class TCompType>
	ATL_NOINLINE __checkReturn DWORD Validate(
		__in LPCSTR Param,
		__out_opt T *pValue,
		__in TCompType nMinValue,
		__in TCompType nMaxValue,
		__inout_opt CValidateContext *pContext = NULL) const throw()
	{
		T value;
		DWORD dwRet = Exchange(Param, &value, pContext);
		if ( dwRet == VALIDATION_S_OK )
		{
			if (pValue)
				*pValue = value;
			dwRet = TValidator::Validate(value, nMinValue, nMaxValue);
			if (pContext && dwRet != VALIDATION_S_OK)
				pContext->AddResult(Param, dwRet);
		}
		else if (dwRet == VALIDATION_S_EMPTY &&
				 !IsNullByType(nMinValue))
		{
				 dwRet = VALIDATION_E_LENGTHMIN;
				 if (pContext)
				 {
					pContext->SetResultAt(Param, VALIDATION_E_LENGTHMIN);
				 }
		}

		return dwRet;
	}

	// Specialization for strings. Comparison is for number of characters.
	template<>
	ATL_NOINLINE __checkReturn DWORD Validate(
		__in LPCSTR Param,
		__deref_opt_out LPCSTR* ppszValue,
		__in int nMinChars,
		__in int nMaxChars,
		__inout_opt CValidateContext *pContext) const throw()
	{
		LPCSTR pszValue = NULL;
		DWORD dwRet = Exchange(Param, &pszValue, pContext);
		if (dwRet == VALIDATION_S_OK )
		{
			if (ppszValue)
				*ppszValue = pszValue;
			dwRet = TValidator::Validate(pszValue, nMinChars, nMaxChars);
			if (pContext && dwRet != VALIDATION_S_OK)
				pContext->AddResult(Param, dwRet);
		}
		else if (dwRet == VALIDATION_S_EMPTY &&
				 nMinChars > 0)
		{
				 dwRet = VALIDATION_E_LENGTHMIN;
				 if (pContext)
				 {
					pContext->SetResultAt(Param, VALIDATION_E_LENGTHMIN);
				 }
		}


		return dwRet;
	}

	// Specialization for CString so caller doesn't have to cast CString
	template<>
	ATL_NOINLINE __checkReturn DWORD Validate(
		__in LPCSTR Param,
		__out_opt CString* pstrValue,
		__in int nMinChars,
		__in int nMaxChars,
		__inout_opt CValidateContext *pContext) const throw()
	{
		_ATLTRY
		{
			LPCSTR szValue;
			DWORD dwRet = Validate(Param, &szValue, nMinChars, nMaxChars, pContext);
			if (pstrValue && dwRet == VALIDATION_S_OK )
				*pstrValue = szValue;
			return dwRet;
		}
		_ATLCATCHALL()
		{
			return VALIDATION_E_FAIL;
		}
	}

	// Specialization for doubles, uses a different comparison.
	template<>
	ATL_NOINLINE __checkReturn DWORD Validate(
		__in LPCSTR Param,
		__out_opt double* pdblValue,
		__in double dblMinValue,
		__in double dblMaxValue,
		__inout_opt CValidateContext *pContext) const throw()
	{
		double dblValue;
		DWORD dwRet = Exchange(Param, &dblValue, pContext);
		if (dwRet == VALIDATION_S_OK)
		{
			if (pdblValue)
				*pdblValue = dblValue;
			dwRet = TValidator::Validate(dblValue, dblMinValue, dblMaxValue);
			if (pContext && dwRet != VALIDATION_S_OK)
				pContext->AddResult(Param, dwRet);
		}
		else if (dwRet == VALIDATION_S_EMPTY &&
				 (dblMinValue < -ATL_EPSILON ||
				 dblMinValue > ATL_EPSILON))
		{
			dwRet = VALIDATION_E_LENGTHMIN;
			if (pContext)
			{
				pContext->SetResultAt(Param, VALIDATION_E_LENGTHMIN);
			}
		}
		return dwRet;
	}
};

// Cookies provide a way for a server to store a small amount of data on a client
// and have that data returned to it on each request the client makes.
// Use this class to represent a cookie to be sent from the server to a client
// or to represent a cookie that has been returned by a client to the originating server.
//
// At the HTTP level, a cookie is an application-defined name-value pair
// plus some standard attribute-value pairs that describe the way in which the user agent (web browser)
// should interact with the cookie. The HTTP format of a cookie is described in RFC 2109.
//
// The CCookie class provides methods to set and get the application-defined name and value
// as well as methods for the standard attributes. In addition, CCookie provides an abstraction
// on top of the application-defined value that allows it to be treated as a collection of name-value
// pairs if that model makes sense to you. Cookies with a single value are known as single-valued cookies.
// Cookies whose value consists of name-value pairs are known as multi-valued cookies or dictionary cookies.
//
// You can set the name of a cookie by calling SetName or using the appropriate constructor.
// The name of a cookie can be 0 or more characters.
//
// You can set the value of a cookie by calling SetValue or using the appropriate constructor.
// If the cookie has a value set, it is a single-valued cookie and attempts to add a name-value pair will fail.
// You can remove the value of a cookie by calling SetValue(NULL).
//
// You can add a name-value pair to a cookie by calling AddValue.
// If the cookie has any name-value pairs, it is a multi-valued cookie and attempts to set the primary value will fail.
// You can remove all the name-value pairs of a cookie by calling RemoveAllValues.
//
// Class CCookie follows the same rules for creating cookies as ASP does.
class CCookie :
	public CValidateObject<CCookie>
{
	typedef CAtlMap<CStringA, CStringA, CStringElementTraits<CStringA>,
		CStringElementTraits<CStringA> > mapType;

	const static DWORD ATLS_MAX_HTTP_DATE = 64;

public:
	// Constructs a named cookie.
	CCookie(__in LPCSTR szName) throw(...)
	{
		ATLENSURE(SetName(szName));
	}

	// Constructs a single-valued cookie.
	CCookie(__in LPCSTR szName, __in_opt LPCSTR szValue) throw(...)
	{
		ATLENSURE(SetName(szName));
		ATLENSURE(SetValue(szValue));
	}

	CCookie(__in const CCookie& thatCookie) throw(...)
	{
		Copy(thatCookie);
	}

	CCookie& operator=(__in const CCookie& thatCookie) throw(...)
	{
        if(this!=&thatCookie)
        {
		    return Copy(thatCookie);
        }
        return *this;
	}

	CCookie() throw()
	{

	}

	__checkReturn BOOL IsEmpty() const throw()
	{
		return m_strName.IsEmpty();
	}

	// Call this function to set the name of this cookie.
	// Returns TRUE on success, FALSE on failure.
	// The name of a cookie cannot contain whitespace, semicolons or commas.
	// The name should not begin with a dollar sign ($) since such names are reserved for future use.
	__checkReturn BOOL SetName(__in LPCSTR szName) throw()
	{
		_ATLTRY
		{
			if (szName && *szName)
			{
				m_strName = szName;
				return TRUE;
			}
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
	}

	// Call this function to retrieve the name of this cookie.
	// Returns TRUE on success, FALSE on failure.
	__checkReturn BOOL GetName(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuff, __inout DWORD *pdwSize) const throw()
	{
		return CopyCString(m_strName, szBuff, pdwSize);
	}

	// Call this function to retrieve the name of this cookie.
	// Returns TRUE on success, FALSE on failure.
	__checkReturn BOOL GetName(__out CStringA &strName) const throw()
	{
		_ATLTRY
		{
			strName = m_strName;
			return TRUE;
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
	}

	// Call this function to set the value of this cookie.
	// Returns TRUE on success, FALSE on failure.
	// Will fail if the cookie is multi-valued.
	// Pass NULL to remove the cookie's value.
	__checkReturn BOOL SetValue(__in_opt LPCSTR szValue) throw()
	{
		_ATLTRY
		{
			if (m_Values.GetCount())
				return FALSE; //already dictionary values in the cookie

			if (!szValue)
				m_strValue.Empty();
			else 
				m_strValue = szValue;

			return TRUE;
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
	}

	// Call this function to retrieve the value of this cookie.
	// Returns TRUE on success, FALSE on failure.
	// Returns TRUE if there is no value or the value is of zero length.
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	__checkReturn BOOL GetValue(__out_ecount(*pdwSize) LPSTR szBuff, __inout DWORD *pdwSize) const throw()
	{
		return CopyCString(m_strValue, szBuff, pdwSize);
	}

	// Call this function to retrieve the value of this cookie.
	// Returns TRUE on success, FALSE on failure.
	__checkReturn BOOL GetValue(__out CStringA &strValue) const throw()
	{
		_ATLTRY
		{
			strValue = m_strValue;
			return TRUE;
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;        
	}

	// Call this function to add a name-value pair to the cookie.
	// Returns TRUE on success, FALSE on failure.
	// Will fail if the cookie is single-valued.
	// If the named value is already present in the cookie, calling this function
	// will modify the current value, otherwise a new name-value pair is added to the cookie.
	// Call RemoveValue or RemoveAllValues to remove the name-value pairs
	// added by this function.
	__checkReturn BOOL AddValue(__in LPCSTR szName, __in_opt LPCSTR szValue) throw()
	{
		if (m_strValue.GetLength())
			return FALSE;
		_ATLTRY
		{
			return m_Values.SetAt(szName, szValue) != NULL;
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
	}

	// Call this function to modify a name-value pair associated with the cookie.
	// Returns TRUE on success, FALSE on failure.
	// Will fail if the cookie is single-valued.
	// This function just calls AddValue so the name-value pair will be added if not already present.
	// Use this function instead of AddValue to document the intentions of your call. 
	__checkReturn BOOL ModifyValue(__in LPCSTR szName, __in LPCSTR szValue) throw()
	{
		return AddValue(szName, szValue);
	}

	// Call this function to remove a name-value pair from the collection managed by this cookie.
	// Returns TRUE on success, FALSE on failure.
	__checkReturn BOOL RemoveValue(__in LPCSTR szName) throw()
	{
		return m_Values.RemoveKey(szName);
	}

	// Call this function to remove all the name-value pairs from the collection managed by this cookie.
	void RemoveAllValues() throw()
	{
		m_Values.RemoveAll();
	}

	// Call this function to add an attribute-value pair to the collection of attributes for this cookie.
	// Returns TRUE on success, FALSE on failure.
	// This function is equivalent to calling ModifyAttribute.
	// Both functions will add the attribute if not already present or
	// change its value if it has already been applied to the cookie.
	__checkReturn BOOL AddAttribute(__in LPCSTR szName, __in LPCSTR szValue) throw()
	{
		if (!szName || !*szName || !szValue)
			return FALSE;

		_ATLTRY
		{
			return (m_Attributes.SetAt(szName, szValue) != NULL);
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;

	}

	// Call this function to modify an attribute-value pair associated with the cookie.
	// Returns TRUE on success, FALSE on failure.
	// This function is equivalent to calling AddAttribute.
	// Both functions will add the attribute if not already present or
	// change its value if it has already been applied to the cookie.
	__checkReturn BOOL ModifyAttribute(__in LPCSTR szName, __in LPCSTR szValue) throw()
	{
		return AddAttribute(szName, szValue);
	}

	// Call this function to remove an attribute-value pair from the collection of attributes managed by this cookie.
	// Returns TRUE on success, FALSE on failure.
	__checkReturn BOOL RemoveAttribute(__in LPCSTR szName) throw()
	{
		return m_Attributes.RemoveKey(szName);
	}

	// Call this function to remove all the attribute-value pairs from the collection of attributes managed by this cookie.
	void RemoveAllAttributes() throw()
	{
		m_Attributes.RemoveAll();
	}


	// Call this function to set the Comment attribute of the cookie.
	// Returns TRUE on success, FALSE on failure.
	// The Comment attribute allows a web server to document its
	// intended use of a cookie. This information may be displayed
	// by supporting browsers so that the user of the web site can
	// decide whether to initiate or continue a session with this cookie.
	// This attribute is optional.
	// Version 1 attribute.
	__checkReturn BOOL SetComment(__in LPCSTR szComment) throw()
	{
		BOOL bRet = SetVersion(1);
		if (bRet)
			bRet = AddAttribute("comment", szComment);
		return bRet;
	}

	// Call this function to set the CommentUrl attribute of the cookie.
	// Returns TRUE on success, FALSE on failure.
	// The CommentUrl attribute allows a web server to document its intended 
	// use of a cookie via a URL that the user of the web site can navigate to.
	// The URL specified here should not send further cookies to the client to
	// avoid frustrating the user.
	// This attribute is optional.
	// Version 1 attribute.
	__checkReturn BOOL SetCommentUrl(__in LPCSTR szUrl) throw()
	{
		BOOL bRet = SetVersion(1);
		if (bRet)
			bRet = AddAttribute("commenturl", szUrl);
		return bRet;
	}

	// Call this function to add or remove the Discard attribute of the cookie.
	// Returns TRUE on success, FALSE on failure.
	// The Discard attribute does not have a value.
	// Call SetDiscard(TRUE) to add the Discard attribute
	// or SetDiscard(FALSE) to remove the Discard attribute.
	// Setting the Discard attribute tells a web browser that it should
	// discard this cookie when the browser exits regardless of the 
	// value of the Max-Age attribute.
	// This attribute is optional.
	// When omitted, the default behavior is that the Max-Age attribute
	// controls the lifetime of the cookie.
	// Version 1 attribute.
	__checkReturn BOOL SetDiscard(__in BOOL bDiscard) throw()
	{
		BOOL bRet = FALSE;
		LPCSTR szKey = "Discard";
		bRet = SetVersion(1);
		if (bRet)
		{
			if (bDiscard == 0)
			{
				bRet = m_Attributes.RemoveKey(szKey);
			}
			else
			{
				_ATLTRY
				{
					bRet = m_Attributes.SetAt(szKey, " ") != 0;
				}
				_ATLCATCHALL()
				{
					bRet = FALSE;
				}
			}
		}
		return bRet;
	}

	// Call this function to set the Domain attribute of the cookie.
	// Returns TRUE on success, FALSE on failure.
	// The Domain attribute is used to indicate the domain to which the current 
	// cookie applies. Browsers should only send cookies back to the relevant domains.
	// This attribute is optional.
	// When omitted, the default behavior is for
	// browsers to use the full domain of the server originating the cookie. You can
	// set this attribute value explicitly if you want to share cookies among several servers.
	// Version 0 & Version 1 attribute.
	__checkReturn BOOL SetDomain(__in LPCSTR szDomain) throw()
	{
		BOOL bRet = SetVersion(1);
		if (bRet)
			bRet = AddAttribute("domain", szDomain);
		return bRet;
	}

	// Call this function to set the Max-Age attribute of the cookie.
	// Returns TRUE on success, FALSE on failure.
	// The value of the Max-Age attribute is a lifetime in seconds for the cookie.
	// When the time has expired, compliant browsers will discard this cookie
	// (if they haven't already done so as a result of the Discard attribute).
	// If Max-Age is set to zero, the browser discards the cookie immediately.
	// This attribute is the Version 1 replacement for the Expires attribute.
	// This attribute is optional.
	// When omitted, the default behavior is for browsers to discard cookies
	// when the user closes the browser.
	// Version 1 attribute.
	__checkReturn BOOL SetMaxAge(__in UINT nMaxAge) throw()
	{
		BOOL bRet = FALSE;
		bRet = SetVersion(1);
		if (bRet)
		{
			CHAR buff[20];
#if _SECURE_ATL
			if (0 != _itoa_s(nMaxAge, buff, _countof(buff), 10))
#else
			if (_itoa(nMaxAge, buff, 10))
#endif
			{
				bRet = AddAttribute("max-age", buff);
			}
		}
		return bRet;
	}

	// Call this function to set the Path attribute of the cookie.
	// Returns TRUE on success, FALSE on failure.
	// The Path attribute specifies the subset of URLs to which this cookie applies.
	// Only URLs that contain that path are allowed to read or modify the cookie. 
	// This attribute is optional.
	// When omitted the default behavior is for browsers to treat the path of a cookie
	// as the path of the request URL that generated the Set-Cookie response, up to,
	// but not including, the right-most /.
	// Version 0 & Version 1 attribute.
	__checkReturn BOOL SetPath(__in LPCSTR szPath) throw()
	{   
		BOOL bRet = SetVersion(1);
		if (bRet)
			bRet = AddAttribute("path", szPath);
		return bRet;
	}

	// Call this function to set the Port attribute of the cookie.
	// Returns TRUE on success, FALSE on failure.
	// The Port attribute specifies the port to which this cookie applies.
	// Only URLs accessed via that port are allowed to read or modify the cookie. 
	// This attribute is optional.
	// When omitted the default behavior is for browsers to return the cookie via any port.
	// Version 1 attribute.
	__checkReturn BOOL SetPort(__in LPCSTR szPort) throw()
	{
		BOOL bRet = SetVersion(1);
		if (bRet)
			bRet = AddAttribute("port", szPort);
		return bRet;
	}

	// Call this function to add or remove the Secure attribute of the cookie.
	// Returns TRUE on success, FALSE on failure.
	// The Secure attribute does not have a value.
	// Call SetSecure(TRUE) to add the Secure attribute
	// or SetSecure(FALSE) to remove the Secure attribute.
	// Setting the Secure attribute tells a browser that it should
	// transmit the cookie to the web server only via secure means such as HTTPS.
	// This attribute is optional.
	// When omitted, the default behavior is that the cookie
	// will be sent via unsecured protocols.
	// Version 0 & Version 1 attribute.
	__checkReturn BOOL SetSecure(__in BOOL bSecure) throw()
	{
		BOOL bRet = FALSE;
		LPCSTR szKey = "secure";
		bRet = SetVersion(1);
		if (bRet)
		{
			if (bSecure == 0)
			{
				bRet = m_Attributes.RemoveKey(szKey);
			}
			else
			{
				_ATLTRY
				{
					bRet = m_Attributes.SetAt(szKey, " ") != 0;
				}
				_ATLCATCHALL()
				{
					bRet = FALSE;
				}
			}
		}
		return bRet;
	}

	// Call this function to set the Version attribute of the cookie.
	// Returns TRUE on success, FALSE on failure.
	// This attribute is required for Version 1 cookies by RFC 2109 and must have a value of 1.
	// However, you do not need to call SetVersion explicitly from your own code unless you need to
	// force RFC 2109 compliance. CCookie will automatically set this attribute whenever
	// you use a Version 1 attribute in your cookie.
	// Version 1 attribute.
	__checkReturn BOOL SetVersion(__in UINT nVersion) throw()
	{
		BOOL bRet = FALSE;      
		CHAR buff[20];
#if _SECURE_ATL
		if (0 != _itoa_s(nVersion, buff, _countof(buff), 10))
#else
		if (_itoa(nVersion, buff, 10))
#endif
		{
			bRet = AddAttribute("version", buff);
		}
		return bRet;
	}

	// Call this function to set the Expires attribute of the cookie.
	// Returns TRUE on success, FALSE on failure.
	// The Expires attribute specifies an absolute date and time at which this cookie
	// should be discarded by web browsers. Pass a SYSTEMTIME holding a Greenwich Mean Time (GMT)
	// value or a string in the following format:
	//      Wdy, DD-Mon-YY HH:MM:SS GMT
	// This attribute is optional.
	// When omitted, the default behavior is for browsers to discard cookies
	// when the user closes the browser.
	// This attribute has been superceded in Version 1 by the Max-Age attribute,
	// but you should continue to use this attribute for Version 0 clients.
	// Version 0 attribute.
	__checkReturn BOOL SetExpires(__in LPCSTR szExpires) throw()
	{
		return AddAttribute("expires", szExpires);
	}

	__checkReturn BOOL SetExpires(__in const SYSTEMTIME &st) throw()
	{
		_ATLTRY
		{
			CFixedStringT<CStringA, ATLS_MAX_HTTP_DATE> strTime;
			SystemTimeToHttpDate(st, strTime);
			return SetExpires(strTime);
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
	}

	// Call this function to look up the value of a name-value pair applied to this cookie.
	// Returns the requested value if present or NULL if the name was not found.
	__checkReturn LPCSTR Lookup(__in_opt LPCSTR szName=NULL) const throw()
	{
		if (IsEmpty())
			return NULL;

		if (m_strValue.GetLength())
		{
			ATLASSERT(szName == NULL);
			return m_strValue;
		}

		if (m_Values.GetCount())
		{
			ATLENSURE(szName);
			const mapType::CPair *pPair = NULL;
			ATLTRY(pPair = m_Values.Lookup(szName));
			if (pPair)
				return (LPCSTR)pPair->m_value;
		}

		return NULL;
	}

	// Call this function to clear the cookie of all content
	// including name, value, name-value pairs, and attributes.
	void Empty() throw()
	{
		m_strName.Empty();
		m_strValue.Empty();
		m_Attributes.RemoveAll();
		m_Values.RemoveAll();
	}

	// Call this function to create a CCookie from a buffer.
	// The passed in buffer contains a cookie header retrieved
	// from the HTTP_COOKIE request variable
	bool ParseValue(__in const char *pstart)
	{
		ATLASSERT(pstart);
		if (!pstart || *pstart == '\0')
			return false;

		// could be just a value or could be an array of name=value pairs
		LPCSTR pEnd = pstart;
		LPCSTR pStart = pstart;
		CStringA name, value;

		while (*pEnd != '\0')
		{
			while (*pEnd && *pEnd != '=' && *pEnd != '&')
				pEnd++;

			if (*pEnd == '\0' || *pEnd == '&')
			{
				if (pEnd > pStart)
					CopyToCString(value, pStart, pEnd);
				SetValue(value);
				if (*pEnd == '&')
				{
					pEnd++;
					pStart = pEnd;
					continue;
				}
				return true; // we're done;
			}
			else if (*pEnd == '=' )
			{
				// we have name=value
				if (pEnd > pStart)
				{
					CopyToCString(name, pStart, pEnd);
				}
				else
				{
					pEnd++;
					pStart = pEnd;
					break;
				}

				// skip '=' and go for value
				pEnd++;
				pStart = pEnd;
				while (*pEnd && *pEnd != '&' && *pEnd != '=')
					pEnd++;
				if (pEnd > pStart)
					CopyToCString(value, pStart, pEnd);

				ATLENSURE(AddValue(name, value));

				if (*pEnd != '\0')
					pEnd++;
					pStart = pEnd;

			}
		}
		
		return true;
	}

	// Call this function to render this cookie
	// into a buffer. Returns TRUE on success, FALSE on failure.
	// On entry, pdwLen should point to a DWORD that indicates 
	// the size of the buffer in bytes. On exit, the DWORD contains
	// the number of bytes transferred or available to be transferred
	// into the buffer (including the nul-terminating byte). On
	// success, the buffer will contain the correct HTTP 
	// representation of the current cookie suitable for sending to 
	// a client as the body of a Set-Cookie header.
	__success(return==true) ATL_NOINLINE __checkReturn BOOL Render(__out_ecount_part_opt(*pdwLen,*pdwLen) LPSTR szCookieBuffer, __inout DWORD *pdwLen) const throw()
	{
		if (!pdwLen)
			return FALSE;
		CStringA strCookie;
		CStringA name, value;
		DWORD dwLenBuff = *pdwLen;
		*pdwLen = 0;

		// A cookie must have a name!
		if (!m_strName.GetLength())
		{
			*pdwLen = 0;
			return FALSE;
		}
		_ATLTRY
		{
			strCookie = m_strName;
			int nValSize = (int) m_Values.GetCount();
			if (nValSize)
			{
				strCookie += '=';
				POSITION pos = m_Values.GetStartPosition();
				for (int i=0; pos; i++)
				{
					m_Values.GetNextAssoc(pos, name, value);
					strCookie += name;
					if (value.GetLength())
					{
						strCookie += '=';
						strCookie += value;
					}
					if (i <= nValSize-2)
						strCookie += '&';
				}
			}
			else
			{
				strCookie += '=';
				if (m_strValue.GetLength())
					strCookie += m_strValue;
			}

			CStringA strAttributes;
			if (!RenderAttributes(strAttributes))
				return FALSE;
			if (strAttributes.GetLength() > 0)
			{
				strCookie += "; ";
				strCookie += strAttributes;
			}

			DWORD dwLenCookie = strCookie.GetLength() + 1;
			*pdwLen = dwLenCookie;
			if (!szCookieBuffer)
				return TRUE; // caller just wanted the length

			// see if buffer is big enough
			if (dwLenCookie > dwLenBuff)
				return FALSE; //buffer wasn't big enough

			// copy the buffer
			Checked::strcpy_s(szCookieBuffer, *pdwLen, strCookie);
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
		return TRUE;
	}

	POSITION GetFirstAttributePos() const throw()
	{
		return m_Attributes.GetStartPosition();
	}

	const CStringA& GetNextAttributeName(__inout POSITION& pos) const throw()
	{
		return m_Attributes.GetNextKey(pos);
	}

	const CStringA& GetAttributeValueAt(__in POSITION pos) const throw()
	{
		return m_Attributes.GetValueAt(pos);
	}

	BOOL GetNextAttrAssoc(__inout POSITION& pos, __out CStringA& key,
		__out CStringA& val) const throw()
	{
		_ATLTRY
		{
			m_Attributes.GetNextAssoc(pos, key, val);
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
		return TRUE;
	}

	POSITION GetFirstValuePos() const throw()
	{
		return m_Values.GetStartPosition();
	}

	const CStringA& GetNextValueName(__inout POSITION& pos) const throw()
	{
		return m_Values.GetNextKey(pos);
	}

	const CStringA& GetValueAt(__in POSITION pos) const throw()
	{
		return m_Values.GetValueAt(pos);
	}

	BOOL GetNextValueAssoc(__inout POSITION& pos, __out CStringA& key,
		__out CStringA& val) const throw()
	{
		_ATLTRY
		{
			m_Values.GetNextAssoc(pos, key, val);
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
		return TRUE;
	}

protected:
// Implementation
	BOOL RenderAttributes(__out CStringA& strAttributes) const throw()
	{
		_ATLTRY
		{
			strAttributes.Empty();

			POSITION pos = m_Attributes.GetStartPosition();
			CStringA key, val;
			for (int i=0; pos; i++)
			{
				if (i)
					strAttributes += ";";
				m_Attributes.GetNextAssoc(pos, key, val);
				strAttributes += key;
				strAttributes += '=';
				strAttributes += val;
			}
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
		return TRUE;
	}
private:
	CCookie& Copy(__in const CCookie& thatCookie) throw(...)
	{
		m_strName = thatCookie.m_strName;
		m_strValue = thatCookie.m_strValue;
		POSITION pos = NULL;
		CStringA strName, strValue;
		if (!thatCookie.m_Attributes.IsEmpty())
		{
			pos = thatCookie.m_Attributes.GetStartPosition();
			while (pos)
			{
				thatCookie.m_Attributes.GetNextAssoc(pos, strName, strValue);
				m_Attributes.SetAt(strName, strValue);
			}
		}
		if (!thatCookie.m_Values.IsEmpty())
		{
			strName.Empty();
			strValue.Empty();
			pos = thatCookie.m_Values.GetStartPosition();
			while (pos)
			{
				thatCookie.m_Values.GetNextAssoc(pos, strName, strValue);
				m_Values.SetAt(strName, strValue);
			}
		}
		return *this;
	}

	// Call this function to copy a substring to a CString reference and ensure nul-termination.
	void CopyToCString(__out CStringA& string, __in_ecount(pEnd-pStart) LPCSTR pStart, __in LPCSTR pEnd) throw( ... )
	{
		ATLENSURE( pStart != NULL );
		ATLENSURE( pEnd != NULL );

		string.SetString(pStart, (int)(pEnd-pStart));
		string.Trim();
	}


public:
	// These are implementation only, use at your own risk!
	// Map of attribute-value pairs applied to this cookie.
	mapType m_Attributes;

	// Map of name-value pairs applied to this cookie.
	mapType m_Values;

	// The name of this cookie.
	CStringA m_strName;

	// The value of this cookie.
	CStringA m_strValue;

};  // class CCookie

class CSessionCookie : public CCookie
{
public:
	CSessionCookie() throw(...)
	{
		if (!SetName(SESSION_COOKIE_NAME) ||
			!SetPath("/"))
			AtlThrow(E_OUTOFMEMORY);
	}

	CSessionCookie(LPCSTR szSessionID) throw(...)
	{
		if (!SetName(SESSION_COOKIE_NAME) ||
			!SetPath("/") ||
			!SetSessionID(szSessionID) )
			AtlThrow(E_OUTOFMEMORY);
	}

	BOOL SetSessionID(LPCSTR szSessionID) throw()
	{
		ATLASSERT(szSessionID && szSessionID[0]);
		return SetValue(szSessionID);
	}
}; // class CSessionCookie

template<>
class CElementTraits< CCookie > :
	public CElementTraitsBase< CCookie >
{
public:
	typedef const CCookie& INARGTYPE;
	typedef CCookie& OUTARGTYPE;

	static ULONG Hash( __in INARGTYPE cookie )
	{
		return CStringElementTraits<CStringA>::Hash( cookie.m_strName );
	}

	static bool CompareElements( __in INARGTYPE cookie1, __in INARGTYPE cookie2 )
	{
		return( cookie1.m_strName == cookie2.m_strName );
	}

	static int CompareElementsOrdered( __in INARGTYPE cookie1, __in INARGTYPE cookie2 )
	{
		return( cookie1.m_strName.Compare( cookie2.m_strName ) );
	}
};


///////////////////////////////////////////////////////////////////////////////
// Request and response classes and support functions


// This class is a wrapper for CAtlMap that allows maps to be chained.
// It simply adds a bool that tells whether or not a map shares values
template <typename K, typename V, typename KTraits=CElementTraits<K>, typename VTraits=CElementTraits<V> >
class CHttpMap
{
private:

#ifdef ATL_HTTP_PARAM_MULTIMAP
	typedef CRBMultiMap<K, V, KTraits, VTraits> MAPTYPE;
#else
	typedef CAtlMap<K, V, KTraits, VTraits> MAPTYPE;
#endif // ATL_HTTP_PARAM_MULTIMAP

public:

	typedef typename KTraits::INARGTYPE KINARGTYPE;
	typedef typename KTraits::OUTARGTYPE KOUTARGTYPE;
	typedef typename VTraits::INARGTYPE VINARGTYPE;
	typedef typename VTraits::OUTARGTYPE VOUTARGTYPE;

	typedef typename MAPTYPE::CPair CPair;

private:

	bool m_bShared;

	MAPTYPE m_map;

public:

	CHttpMap() throw()
		: m_bShared(false)
	{
	}

	virtual ~CHttpMap()
	{
	}

	inline bool IsShared() const throw()
	{
		return m_bShared;
	}

	inline void SetShared(__in bool bShared) throw()
	{
		m_bShared = bShared;
	}

	//
	// exposed lookup and iteration functionality
	//

	inline size_t GetCount() const throw()
	{
		return m_map.GetCount();
	}

	inline bool IsEmpty() const throw()
	{
		return m_map.IsEmpty();
	}

	inline POSITION GetStartPosition() const throw()
	{
#ifdef ATL_HTTP_PARAM_MULTIMAP
		return m_map.GetHeadPosition();
#else
		return m_map.GetStartPosition();
#endif // ATL_HTTP_PARAM_MULTIMAP
	}

	// Lookup wrappers
	bool Lookup( __in KINARGTYPE key, __out VOUTARGTYPE value ) const throw()
	{
		_ATLTRY
		{
#ifdef ATL_HTTP_PARAM_MULTIMAP
			CPair *p = Lookup(key);
			if (p != NULL)
			{
				value = p->m_value;
				return true;
			}
			return false;
#else
			return m_map.Lookup(key, value);
#endif // ATL_HTTP_PARAM_MULTIMAP
		}
		_ATLCATCHALL()
		{
			return false;
		}
	}

	const CPair* Lookup( __in KINARGTYPE key ) const throw()
	{
#ifdef ATL_HTTP_PARAM_MULTIMAP
		POSITION pos = m_map.FindFirstWithKey(key);
		if (pos != NULL)
		{
			return m_map.GetAt(pos);
		}
		return NULL;
#else
		return m_map.Lookup(key);
#endif // ATL_HTTP_PARAM_MULTIMAP
	}

	CPair* Lookup( __in KINARGTYPE key ) throw()
	{
#ifdef ATL_HTTP_PARAM_MULTIMAP
		POSITION pos = m_map.FindFirstWithKey(key);
		if (pos != NULL)
		{
			return m_map.GetAt(pos);
		}
		return NULL;
#else
		return m_map.Lookup(key);
#endif // ATL_HTTP_PARAM_MULTIMAP
	}

	// iteration wrappers
	void GetNextAssoc( __inout POSITION& pos, __out KOUTARGTYPE key, __out VOUTARGTYPE value ) const throw(...)
	{
		m_map.GetNextAssoc(pos, key, value);
	}

	const CPair* GetNext( __inout POSITION& pos ) const throw()
	{
		return m_map.GetNext(pos);
	}

	CPair* GetNext( __inout POSITION& pos ) throw()
	{
		return m_map.GetNext(pos);
	}

	const K& GetNextKey( __inout POSITION& pos ) const throw()
	{
		return m_map.GetNextKey(pos);
	}

	const V& GetNextValue( __inout POSITION& pos ) const throw()
	{
		return m_map.GetNextValue(pos);
	}

	V& GetNextValue( __inout POSITION& pos ) throw()
	{
		return m_map.GetNextValue(pos);
	}

	void GetAt( __in POSITION pos, __out KOUTARGTYPE key, __out VOUTARGTYPE value ) const throw(...)
	{
		return m_map.GetAt(pos, key, value);
	}

	CPair* GetAt( __in POSITION pos ) throw()
	{
		return m_map.GetAt(pos);
	}

	const CPair* GetAt( __in POSITION pos ) const throw()
	{
		return m_map.GetAt(pos);
	}

	const K& GetKeyAt( __in POSITION pos ) const throw()
	{
		return m_map.GetKeyAt(pos);
	}

	const V& GetValueAt( __in POSITION pos ) const throw()
	{
		return m_map.GetValueAt(pos);
	}

	V& GetValueAt( __in POSITION pos ) throw()
	{
		return m_map.GetValueAt(pos);
	}

	// modification wrappers
	POSITION SetAt( __in KINARGTYPE key, __in_opt VINARGTYPE value ) throw(...)
	{
#ifdef ATL_HTTP_PARAM_MULTIMAP
		return m_map.Insert(key, value);
#else
		return m_map.SetAt(key, value);
#endif // ATL_HTTP_PARAM_MULTIMAP
	}

	bool RemoveKey( __in KINARGTYPE key ) throw()
	{
#ifdef ATL_HTTP_PARAM_MULTIMAP
		return (m_map.RemoveKey(key) != 0);
#else
		return m_map.RemoveKey(key);
#endif // ATL_HTTP_PARAM_MULTIMAP
	}

	virtual void RemoveAll()
	{
		m_map.RemoveAll();
	}
};

// This class is a wrapper for CHttpMap that assumes it's values are pointers that
// should be deleted on RemoveAll
template <typename K, typename V, typename KTraits=CElementTraits<K>, typename VTraits=CElementTraits<V> >
class CHttpPtrMap : public CHttpMap<K, V, KTraits, VTraits>
{
public:
	typedef CHttpMap<K, V, KTraits, VTraits> Base;

	void RemoveAll()
	{
		if (!IsShared())
		{
			POSITION pos = GetStartPosition();
			while (pos)
			{
				GetNextValue(pos)->Free();
			}
		}
		Base::RemoveAll();
	}

	~CHttpPtrMap()
	{
		RemoveAll();
	}
};

// This class represents a collection of request parameters - the name-value pairs
// found, for example, in a query string or in the data provided when a form is submitted to the server.
// Call Parse to build the collection from a string of URL-encoded data.
// Use the standard collection methods of the CHttpMap base class to retrieve the
// decoded names and values.
// Use the methods of the CValidateObject base class to validate the parameters.
class CHttpRequestParams : 
#if (defined(ATL_HTTP_PARAM_MAP_CASEINSENSITIVE))
	public CHttpMap<CStringA, CStringA, CStringElementTraitsI<CStringA>, CStringElementTraitsI<CStringA> >, 
#else
	public CHttpMap<CStringA, CStringA, CStringElementTraits<CStringA>, CStringElementTraits<CStringA> >, 
#endif
	public CValidateObject<CHttpRequestParams>
{
public:
#if (defined(ATL_HTTP_PARAM_MAP_CASEINSENSITIVE))
	typedef CHttpMap<CStringA, CStringA, CStringElementTraitsI<CStringA>, CStringElementTraitsI<CStringA> > BaseMap;
#else
	typedef CHttpMap<CStringA, CStringA, CStringElementTraits<CStringA>, CStringElementTraits<CStringA> > BaseMap;
#endif

	LPCSTR Lookup(__in LPCSTR szName) const throw()
	{
		_ATLTRY
		{
			if (!szName)
				return NULL;

			const CPair *p = BaseMap::Lookup(szName);
			if (p)
			{
				return p->m_value;
			}
		}
		_ATLCATCHALL()
		{
		}
		return NULL;
	}

	// Call this function to build a collection of name-value pairs from a string of URL-encoded data.
	// Returns TRUE on success, FALSE on failure.
	// URL-encoded data:
	//      Each name-value pair is separated from the next by an ampersand (&)
	//      Each name is separated from its corresponding value by an equals signs (=)
	//      The end of the data to be parsed is indicated by a nul character (\0) or a pound symbol (#)
	//      A plus sign (+) in the input will be decoded as a space
	//      A percent sign (%) in the input signifies the start of an escaped octet.
	//          The next two digits represent the hexadecimal code of the character.
	//          For example, %21 is the escaped encoding for the US-ASCII exclamation mark and will be decoded as !.
	// Common sources of URL-encoded data are query strings and the bodies of POST requests with content type of application/x-www-form-urlencoded.
	//
	// Parse and Render are complementary operations.
	// Parse creates a collection from a string.
	// Render creates a string from a collection.
	ATL_NOINLINE __checkReturn BOOL Parse(__inout LPSTR szQueryString) throw()
	{
		while (szQueryString && *szQueryString)
		{
			LPSTR szUrlCurrent = szQueryString;
			LPSTR szName = szUrlCurrent;
			LPSTR szPropValue;

			while (*szQueryString)
			{
				if (*szQueryString == '=')
				{
					szQueryString++;
					break;
				}
				if (*szQueryString == '&')
				{
					break;
				}
				if (*szQueryString == '+')
					*szUrlCurrent = ' ';
				else if (*szQueryString == '%')
				{
					// if there is a % without two characters
					// at the end of the url we skip it
					if (*(szQueryString+1) && *(szQueryString+2))
					{
						*szUrlCurrent = (CHAR)(16*AtlHexValue(szQueryString[1])+AtlHexValue(szQueryString[2]));
						szQueryString += 2;
					}
					else
						*szUrlCurrent = '\0';
				}
				else
					*szUrlCurrent = *szQueryString;

				szQueryString++;
				szUrlCurrent++;
			}

			if (*szUrlCurrent == '&')
			{
				*szUrlCurrent++ = '\0';
				szQueryString++;
				szPropValue = "";
			}
			else
			{
				if (*szUrlCurrent)
					*szUrlCurrent++ = '\0';

				// we have the property name
				szPropValue = szUrlCurrent;
				while (*szQueryString && *szQueryString != '#')
				{
					if (*szQueryString == '&')
					{
						szQueryString++;
						break;
					}
					if (*szQueryString == '+')
						*szUrlCurrent = ' ';
					else if (*szQueryString == '%')
					{
						// if there is a % without two characters
						// at the end of the url we skip it
						if (*(szQueryString+1) && *(szQueryString+2))
						{
							*szUrlCurrent = (CHAR)(16*AtlHexValue(szQueryString[1])+AtlHexValue(szQueryString[2]));
							szQueryString += 2;
						}
						else
							*szUrlCurrent = '\0';
					}
					else
						*szUrlCurrent = *szQueryString;
					szQueryString++;
					szUrlCurrent++;
				}
				// we have the value
				*szUrlCurrent = '\0';
				szUrlCurrent++;
			}

			_ATLTRY
			{
				SetAt(szName, szPropValue);
			}
			_ATLCATCHALL()
			{
				return FALSE;
			}
		}
		return TRUE;
	}

	// Call this function to render the map of names and values into a buffer as a URL-encoded string.
	// Returns TRUE on success, FALSE on failure.
	// On entry, pdwLen should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	// On success, the buffer will contain the correct URL-encoded representation of the current object
	// suitable for sending to a server as a query string or in the body of a form.
	// URL-encoding:
	//      Each name-value pair is separated from the next by an ampersand (&)
	//      Each name is separated from its corresponding value by an equals signs (=)
	//      A space is encoded as a plus sign (+).
	//      Other unsafe characters (as determined by AtlIsUnsafeUrlChar) are encoded as escaped octets.
	//      An escaped octet is a percent sign (%) followed by two digits representing the hexadecimal code of the character.
	//
	// Parse and Render are complementary operations.
	// Parse creates a collection from a string.
	// Render creates a string from a collection.
	ATL_NOINLINE __checkReturn BOOL Render(__out_ecount(pdwLen) LPSTR szParameters, __inout LPDWORD pdwLen)
	{
		ATLENSURE(szParameters);
		ATLENSURE(pdwLen);
		_ATLTRY
		{
			if (GetCount() == 0)
			{
				*szParameters = '\0';
				*pdwLen = 0;
				return TRUE;
			}

			CStringA strParams;
			POSITION pos = GetStartPosition();
			while (pos != NULL)
			{
				LPCSTR szBuf = GetKeyAt(pos);
				EscapeToCString(strParams, szBuf);
				szBuf = GetValueAt(pos);
				if (*szBuf)
				{
					strParams+= '=';
					EscapeToCString(strParams, szBuf);
				}
				strParams+= '&';
				GetNext(pos);
			}

			DWORD dwLen = strParams.GetLength();
			strParams.Delete(dwLen-1);
			BOOL bRet = TRUE;
			if (dwLen > *pdwLen)
			{
				bRet = FALSE;
			}
			else
			{
				dwLen--;
				Checked::memcpy_s(szParameters, *pdwLen, static_cast<LPCSTR>(strParams), dwLen);
				szParameters[dwLen] = '\0';
			}

			*pdwLen = dwLen;
			return bRet;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}	
	}

}; // class CHttpRequestParams

#ifndef MAX_TOKEN_LENGTH
#define MAX_TOKEN_LENGTH (MAX_PATH)
#endif

// This class represents the information about a file that has been uploaded to the web server.
class CHttpRequestFile : public IHttpFile
{
private:

	// The name of the form field used to upload the file.
	CHAR m_szParamName[MAX_TOKEN_LENGTH];

	// The original file name of the uploaded file as set by the client.
	CHAR m_szFileName[MAX_PATH];

	// The original path and file name of the uploaded file as set by the client.
	CHAR m_szFullFileName[MAX_PATH];

	// The MIME type of the uploaded file.
	CHAR m_szContentType[MAX_TOKEN_LENGTH];

	// The name of the uploaded file on the server.
	CHAR m_szTempFileName[MAX_PATH];

	// The size of the file in bytes.
	ULONGLONG m_nFileSize;

public:

	CHttpRequestFile() throw()
	{
		*m_szParamName = '\0';
		*m_szFileName = '\0';
		*m_szFullFileName = '\0';
		*m_szContentType = '\0';
		m_nFileSize = 0;
	}

	__checkReturn BOOL Initialize(
		__in_opt LPCSTR pParamName,
		__in LPCSTR pFileName,
		__in_opt LPCSTR pTempFileName,
		__in_opt LPCSTR pContentType, 
		__in const ULONGLONG &nFileSize)
	{
		ATLENSURE( pFileName != NULL );

		if (!SafeStringCopy(m_szFullFileName, pFileName))
		{
			// path too long
			return FALSE;
		}

		if (pParamName && *pParamName)
		{
			if (!SafeStringCopy(m_szParamName, pParamName))
			{
				// string too long
				return FALSE;
			}
		}

		if (pTempFileName && *pTempFileName)
		{
			if (!SafeStringCopy(m_szTempFileName, pTempFileName))
			{
				// path too long
				return FALSE;
			}
		}

		if (pContentType && *pContentType)
		{
			if (!SafeStringCopy(m_szContentType, pContentType))
			{
				// string too long
				return FALSE;
			}
		}

		// Set m_szFileName to be the file name without the path.
		// This is likely to be the most meaningful part of the 
		// original file name once the file reaches the server.

		LPSTR szTmp = m_szFullFileName;
		LPSTR szFile = m_szFileName;
		LPSTR pszLastCharFileBuf=m_szFileName + _countof(m_szFileName) - 1;		
		while (*szTmp)
		{
			if (*szTmp == '\\')
			{
				szFile = m_szFileName;
			}
			else
			{
				if (szFile > pszLastCharFileBuf)
				{
					return FALSE;
				}
				*szFile++ = *szTmp;
			}
			szTmp++;
		}
		if (szFile > pszLastCharFileBuf)
		{
			return FALSE;
		}
		*szFile = 0;

		m_nFileSize = nFileSize;
		return TRUE;
	}


	//=======================================
	// IHttpFile interface
	//=======================================
	__checkReturn LPCSTR GetParamName()
	{
		return m_szParamName;
	}

	__checkReturn LPCSTR GetFileName()
	{
		return m_szFileName;
	}

	__checkReturn LPCSTR GetFullFileName()
	{
		return m_szFullFileName;
	}

	__checkReturn LPCSTR GetContentType()
	{
		return m_szContentType;
	}

	__checkReturn LPCSTR GetTempFileName()
	{
		return m_szTempFileName;
	}

	__checkReturn ULONGLONG GetFileSize()
	{
		return m_nFileSize;
	}

	void Free()
	{
		delete this;
	}

}; // class CHttpRequestFile


#endif // _WIN32_WCE

// utility function to ReadData from a ServerContext
ATL_NOINLINE inline 
__checkReturn BOOL ReadClientData(__inout IHttpServerContext *pServerContext, __out_ecount_part(*pdwLen,*pdwLen) LPSTR pbDest, __inout LPDWORD pdwLen, __in DWORD dwBytesRead)
{
	ATLENSURE(pServerContext != NULL);	
	ATLENSURE(pdwLen != NULL);
	ATLENSURE(pbDest != NULL);

	_ATLTRY
	{
		DWORD dwToRead = *pdwLen;
		DWORD dwAvailableBytes = pServerContext->GetAvailableBytes();
		DWORD dwRead(0);

		// Read from available data first
		if (dwBytesRead < dwAvailableBytes)
		{			
			LPBYTE pbAvailableData = pServerContext->GetAvailableData();
			pbAvailableData+= dwBytesRead;
			DWORD dwAvailableToRead = __min(dwToRead, dwAvailableBytes-dwBytesRead);			
			Checked::memcpy_s(pbDest, *pdwLen, pbAvailableData, dwAvailableToRead);
			dwBytesRead+= dwAvailableToRead;
			dwToRead-= dwAvailableToRead;
			pbDest+= dwAvailableToRead;
			dwRead+= dwAvailableToRead;
		}

		DWORD dwTotalBytes = pServerContext->GetTotalBytes();

		// If there is still more to read after the available data is exhausted
		if (dwToRead && dwBytesRead < dwTotalBytes)
		{
			DWORD dwClientBytesToRead = __min(pServerContext->GetTotalBytes()-dwBytesRead, dwToRead);
			DWORD dwClientBytesRead = 0;

			// keep on reading until we've read the amount requested
			do
			{
				dwClientBytesRead = dwClientBytesToRead;
				if (!pServerContext->ReadClient(pbDest, &dwClientBytesRead))
				{
					return FALSE;
				}
				dwClientBytesToRead-= dwClientBytesRead;
    			dwRead+= dwClientBytesRead;
				pbDest+= dwClientBytesRead;

			} while (dwClientBytesToRead != 0 && dwClientBytesRead != 0);

			 
		}

		*pdwLen = dwRead;
	}
	_ATLCATCHALL()
	{
		return FALSE;
	}

	return TRUE;
}

#ifndef _WIN32_WCE

#ifndef MAX_MIME_BOUNDARY_LEN
	#define MAX_MIME_BOUNDARY_LEN 128
#endif

enum ATL_FORM_FLAGS
{
	ATL_FORM_FLAG_NONE = 0,
	ATL_FORM_FLAG_IGNORE_FILES = 1,
	ATL_FORM_FLAG_REFUSE_FILES = 2,
	ATL_FORM_FLAG_IGNORE_EMPTY_FILES = 4,
	ATL_FORM_FLAG_IGNORE_EMPTY_FIELDS = 8,
};

// Use this class to read multipart/form-data from the associated server context
// and generate files as necessary from the data in the body of the request.
class CMultiPartFormParser
{
protected:

	LPSTR                       m_pCurrent;
	LPSTR                       m_pEnd;
	LPSTR                       m_pStart;
	CHAR                        m_szBoundary[MAX_MIME_BOUNDARY_LEN+2];
	DWORD                       m_dwBoundaryLen;
	BOOL                        m_bFinished;
	CComPtr<IHttpServerContext> m_spServerContext;

public:

	typedef CHttpMap<CStringA, IHttpFile*, CStringElementTraits<CStringA> > FILEMAPTYPE;

	CMultiPartFormParser(__in IHttpServerContext* pServerContext) throw() :
		m_pCurrent(NULL),
		m_pEnd(NULL),
		m_pStart(NULL),
		m_dwBoundaryLen(0),
		m_bFinished(FALSE),
		m_spServerContext(pServerContext)
	{
		*m_szBoundary = '\0';
	}

	~CMultiPartFormParser() throw()
	{
		_ATLTRY
		{
			// free memory if necessary
			if (m_spServerContext->GetTotalBytes() > m_spServerContext->GetAvailableBytes())
			{
				free(m_pStart);
			}
		}
		_ATLCATCHALL()
		{
		}
	}

	// Call this function to read multipart/form-data from the current HTTP request,
	// allowing files to be uploaded to the web server.
	//
	// Returns TRUE on success, FALSE on failure.
	//
	// Forms can be sent to a web server using one of two encodings: application/x-www-form-urlencoded or multipart/form-data.
	// In addition to the simple name-value pairs typically associated with
	// application/x-www-form-urlencoded form data, multipart/form-data (as 
	// described in RFC 2388) can also contain files to be uploaded
	// to the web server.
	//
	// This function will generate a physical file for each file contained in the multipart/form-data request body.
	// The generated files are stored in the server's temporary directory as returned by the 
	// GetTempPath API and are named using the GetTempFileName API.
	// The information about each file can be obtained from the elements of the Files array.
	// You can retrieve the original name of the file on the client, the name of the generated file on the server,
	// the MIME content type of the uploaded file, the name of the form field associated with that file, and the size in
	// bytes of the file. All this information is exposed by the CHttpRequestFile objects in the array.
	//
	// In addition to generating files and populating the Files array with information about them,
	// this function also populates the pQueryParams array with the names and values of the other form fields
	// contained in the current request. The file fields are also added to this array. The value of these fields
	// is the full name of the generated file on the server.
	//
	//      Note that files can be generated even if this function returns FALSE unless you specify either the
	//      ATL_FORM_FLAG_IGNORE_FILES or the ATL_FORM_FLAG_REFUSE_FILES flag. If you don't specify one of these
	//      flags, you should always check the Files array for generated files and delete any that are no longer
	//      needed to prevent your web server from running out of disk space.
	//
	// dwFlags can be a combination of one or more of the following values:
	//      ATL_FORM_FLAG_NONE                  Default behavior.
	//      ATL_FORM_FLAG_IGNORE_FILES          Any attempt to upload files is ignored.
	//      ATL_FORM_FLAG_REFUSE_FILES          Any attempt to upload files is treated as a failure. The function will return FALSE.
	//      ATL_FORM_FLAG_IGNORE_EMPTY_FILES    Files with a size of zero bytes are ignored.
	//      ATL_FORM_FLAG_IGNORE_EMPTY_FIELDS   Fields with no content are ignored.
	ATL_NOINLINE BOOL GetMultiPartData(
		__inout FILEMAPTYPE& Files, 
		__inout CHttpRequestParams* pQueryParams, 
		__in DWORD dwFlags=ATL_FORM_FLAG_NONE) throw()
	{
		_ATLTRY
		{
			if (!InitializeParser())
			{
				return FALSE;
			}

			//Get to the first boundary
			if (!ReadUntilBoundary())
			{
				return FALSE;
			}

			CStringA strParamName;
			CStringA strFileName;
			CStringA strContentType;
			CStringA strData;
			BOOL bFound;

			while (!m_bFinished)
			{
				// look for "name" field
				if (!GetMimeData(strParamName, "name=", sizeof("name=")-1, &bFound, TRUE) || !bFound)
				{
					ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
					return FALSE;
				}

				// see if it's a file
				if (!GetMimeData(strFileName, "filename=", sizeof("filename=")-1, &bFound, TRUE))
				{
					ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
					return FALSE;
				}

				if (bFound)
				{
					if (dwFlags & ATL_FORM_FLAG_REFUSE_FILES)
					{
						return FALSE;
					}

					if (!strFileName.GetLength())
					{
						if(!ReadUntilBoundary())
						{
							return FALSE;
						}
						continue;
					}

					if (!GetMimeData(strContentType, "Content-Type:", sizeof("Content-Type:")-1, &bFound, TRUE))
					{
						ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
						return FALSE;
					}

					// move to the actual uploaded data
					if (!MoveToData())
					{
						ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
						return FALSE;
					}

					// if the user doesn't want files, don't save the file
					if (dwFlags & ATL_FORM_FLAG_IGNORE_FILES)
					{
						if (!ReadUntilBoundary(NULL, NULL))
						{
							return FALSE;
						}
						continue;
					}

					CAtlTemporaryFile ctf;
					HRESULT hr = ctf.Create();
					if (hr != S_OK)
						return FALSE;

					if (!ReadUntilBoundary(NULL, &ctf))
					{
						ctf.Close();
						return FALSE;
					}
					ULONGLONG nFileSize = 0;
					if (ctf.GetSize(nFileSize) != S_OK)
						return FALSE;

					if ((dwFlags & ATL_FORM_FLAG_IGNORE_EMPTY_FILES) && nFileSize == 0)
					{
						ctf.Close();
						continue;
					}

					CAutoPtr<CHttpRequestFile> spFile;

					CT2AEX<MAX_PATH+1> szTempFileNameA(ctf.TempFileName());

					ATLTRY(spFile.Attach(new CHttpRequestFile()));
					if (!spFile)
					{
						return FALSE;
					}

					if (!spFile->Initialize(strParamName, strFileName, szTempFileNameA, strContentType, nFileSize))
					{
						// one of the strings was too long
						return FALSE;
					}

					if (!Files.SetAt(szTempFileNameA, spFile))
					{
						return FALSE;
					}

					spFile.Detach();
					
					if (!pQueryParams || !pQueryParams->SetAt(strParamName, szTempFileNameA))
					{
						return FALSE;
					}

					ctf.HandsOff();

					continue;
				}

				// move to the actual uploaded data
				if (!MoveToData())
				{
					ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
					return FALSE;
				}

				if (!ReadUntilBoundary(&strData))
				{
					return FALSE;
				}

				if ((dwFlags & ATL_FORM_FLAG_IGNORE_EMPTY_FIELDS) && strData.GetLength() == 0)
					continue;

				if (!pQueryParams || !pQueryParams->SetAt(strParamName, strData))
				{
					return FALSE;
				}

			}

			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

private:

	// implementation

	// case insensitive substring search -- does not handle multibyte characters (unlike tolower)
	// allows searching up to a maximum point in a string
	inline char AtlCharLower(__in char ch) throw()
	{
		if (ch > 64 && ch < 91)
		{
			return ch+32;
		}

		return ch;
	}

	inline __checkReturn char * _stristr (__in const char * str1, __in const char * str2)
	{
		ATLENSURE(str1!=NULL);
		ATLENSURE(str2!=NULL);
		char *cp = (char *) str1;
		char *s1, *s2;

		if ( !*str2 )
			return((char *)str1);

		while (*cp)
		{
			s1 = cp;
			s2 = (char *) str2;

			while ( *s1 && *s2 && !(AtlCharLower(*s1)-AtlCharLower(*s2)) )
			{
				s1++, s2++;
			}

			if (!*s2)
			{
				return(cp);
			}

			cp++;
		}

		return(NULL);
	}


	inline __checkReturn char * _stristrex (__in const char * str1, __in const char * str2, __in const char * str1End)
	{
		ATLENSURE(str1!=NULL);
		ATLENSURE(str2!=NULL);
		char *cp = (char *) str1;
		char *s1, *s2;

		if ( !*str2 )
			return((char *)str1);

		while (cp != str1End)
		{
			s1 = cp;
			s2 = (char *) str2;

			while ( s1 != str1End && *s2 && !(AtlCharLower(*s1)-AtlCharLower(*s2)) )
			{
				s1++, s2++;
			}

			if (!*s2)
			{
				return (cp);
			}

			if (s1 == str1End)
			{
				return (NULL);
			}

			cp++;
		}

		return(NULL);
	}

	inline __checkReturn char * _strstrex (__in const char * str1, __in const char * str2, __in const char * str1End)
	{
		ATLENSURE(str1!=NULL);
		ATLENSURE(str2!=NULL);
		char *cp = (char *) str1;
		char *s1, *s2;

		if ( !*str2 )
			return((char *)str1);

		while (cp != str1End)
		{
			s1 = cp;
			s2 = (char *) str2;

			while ( s1 != str1End && *s2 && !((*s1)-(*s2)) )
			{
				s1++, s2++;
			}

			if (!*s2)
			{
				return (cp);
			}

			if (s1 == str1End)
			{
				return (NULL);
			}

			cp++;
		}

		return(NULL);
	}

	ATL_NOINLINE __checkReturn BOOL InitializeParser() throw()
	{
		ATLASSUME( m_spServerContext != NULL );

		_ATLTRY
		{
			DWORD dwBytesTotal = m_spServerContext->GetTotalBytes();

			// if greater than bytes available, allocate necessary space
			if (dwBytesTotal > m_spServerContext->GetAvailableBytes())
			{
				m_pStart = (LPSTR) malloc(dwBytesTotal);
				if (!m_pStart)
				{
					return FALSE;
				}
				m_pCurrent = m_pStart;
				DWORD dwLen = dwBytesTotal;
				if (!ReadClientData(m_spServerContext, m_pStart, &dwLen, 0) || dwLen != dwBytesTotal)
				{
					return FALSE;
				}
			}
			else
			{
				m_pStart = (LPSTR) m_spServerContext->GetAvailableData();
			}

			m_pCurrent = m_pStart;
			m_pEnd = m_pCurrent + dwBytesTotal;

			//get the boundary
			LPCSTR pszContentType = m_spServerContext->GetContentType();
			ATLASSERT(pszContentType != NULL);

			LPCSTR pszTmp = _stristr(pszContentType, "boundary=");
			if (!pszTmp)
			{
				ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
				return FALSE;
			}

			pszTmp += sizeof("boundary=")-1;
			BOOL bInQuote = FALSE;
			if (*pszTmp == '\"')
			{
				bInQuote = TRUE;
				pszTmp++;
			}

			LPSTR pszMimeBoundary = m_szBoundary;
			*pszMimeBoundary++ = '-';
			*pszMimeBoundary++ = '-';
			m_dwBoundaryLen = 2;
			while (*pszTmp && (bInQuote || IsStandardBoundaryChar(*pszTmp)))
			{
				if (m_dwBoundaryLen >= MAX_MIME_BOUNDARY_LEN)
				{
					ATLTRACE(atlTraceISAPI, 0, _T("Malformed MIME boundary"));
					return FALSE;
				}

				if (*pszTmp == '\r' || *pszTmp == '\n')
				{
					if (bInQuote)
					{
						pszTmp++;
						continue;
					}
					break;
				}
				if (bInQuote && *pszTmp == '"')
				{
					break;
				}

				*pszMimeBoundary++ = *pszTmp++;
				m_dwBoundaryLen++;
			}

			*pszMimeBoundary = '\0';
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}

		return TRUE;
	}

	inline __checkReturn BOOL MoveToData() throw()
	{
		LPSTR szEnd = _strstrex(m_pCurrent, "\r\n\r\n", m_pEnd);
		if (!szEnd)
		{
			return FALSE;
		}

		m_pCurrent = szEnd+4;
		if (m_pCurrent >= m_pEnd)
		{
			return FALSE;
		}

		return TRUE;
	}

	inline __checkReturn BOOL GetMimeData(__inout CStringA &str, __in_ecount(dwFieldLen) LPCSTR szField, __in DWORD dwFieldLen, __out LPBOOL pbFound, __in BOOL bIgnoreCase = FALSE) throw()
	{
		_ATLTRY
		{
			ATLASSERT( szField != NULL );
			ATLENSURE( pbFound != NULL );

			*pbFound = FALSE;

			LPSTR szEnd = _strstrex(m_pCurrent, "\r\n\r\n", m_pEnd);
			if (!szEnd)
			{
				return FALSE;
			}

			LPSTR szDataStart = NULL;

			if (!bIgnoreCase)
			{
				szDataStart = _strstrex(m_pCurrent, szField, szEnd);
			}
			else
			{
				szDataStart = _stristrex(m_pCurrent, szField, szEnd);
			}

			if (szDataStart)
			{
				szDataStart+= dwFieldLen;
				if (szDataStart >= m_pEnd)
				{
					return FALSE;
				}

				BOOL bInQuote = FALSE;
				if (*szDataStart == '\"')
				{
					bInQuote = TRUE;
					szDataStart++;
				}

				LPSTR szDataEnd = szDataStart;
				while (!bInQuote && (szDataEnd < m_pEnd) && (*szDataEnd == ' ' || *szDataEnd == '\t'))
				{
					szDataEnd++;
				}

				if (szDataEnd >= m_pEnd)
				{
					return FALSE;
				}

				while (szDataEnd < m_pEnd)
				{
					if (!IsValidTokenChar(*szDataEnd))
					{
						if (*szDataEnd == '\"' || !bInQuote)
						{
							break;
						}
					}
					szDataEnd++;
				}

				if (szDataEnd >= m_pEnd)
				{
					return FALSE;
				}

				str.SetString(szDataStart, (int)(szDataEnd-szDataStart));
				*pbFound = TRUE;
			}

			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	ATL_NOINLINE __checkReturn BOOL ReadUntilBoundary(__inout_opt CStringA* pStrData=NULL, __inout_opt CAtlTemporaryFile* pCtf=NULL) throw()
	{
		_ATLTRY
		{
			LPSTR szBoundaryStart = m_pCurrent;
			LPSTR szBoundaryEnd = NULL;

			do 
			{
				szBoundaryStart = _strstrex(szBoundaryStart, m_szBoundary, m_pEnd);
				if (szBoundaryStart)
				{
					if ((szBoundaryStart-m_pStart) >= 2)
					{
						if (*(szBoundaryStart-1) != 0x0a || *(szBoundaryStart-2) != 0x0d)
						{
							szBoundaryStart++;
							continue;
						}
					}
					szBoundaryEnd = szBoundaryStart+m_dwBoundaryLen;
					if (szBoundaryEnd+2 >= m_pEnd)
					{
						return FALSE;
					}
					if (szBoundaryEnd[0] == '\r' && szBoundaryEnd[1] == '\n')
					{
						break;
					}
					if (szBoundaryEnd[0] == '-' && szBoundaryEnd[1] == '-')
					{
						m_bFinished = TRUE;
						break;
					}
					szBoundaryStart++;
				}
			} while (szBoundaryStart && szBoundaryStart < m_pEnd);

			if (!szBoundaryStart || szBoundaryStart >= m_pEnd)
			{
				return FALSE;
			}

			if ((szBoundaryStart-m_pStart) >= 2)
			{
				szBoundaryStart-= 2;
			}
			if (pStrData)
			{
				pStrData->SetString(m_pCurrent, (int)(szBoundaryStart-m_pCurrent)); 
			}
			if (pCtf)
			{
				if (FAILED(pCtf->Write(m_pCurrent, (DWORD)(szBoundaryStart-m_pCurrent))))
				{
					return FALSE;
				}
			}

			if (!m_bFinished)
			{
				m_pCurrent = szBoundaryEnd+2;
				if (m_pCurrent >= m_pEnd)
				{
					return FALSE;
				}
			}

			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	static inline __checkReturn BOOL IsStandardBoundaryChar(__in CHAR ch) throw()
	{
		if ( (ch >= 'A' && ch <= 'Z') ||
			 (ch >= 'a' && ch <= 'z') ||
			 (ch >= '0' && ch <= '9') ||
			 (ch == '\'') ||
			 (ch == '+')  ||
			 (ch == '_')  ||
			 (ch == '-')  ||
			 (ch == '=')  ||
			 (ch == '?') )
		{
			return TRUE;
		}

		return FALSE;
	}

	inline __checkReturn BOOL IsValidTokenChar(__in CHAR ch) throw()
	{
		return ( (ch != 0) && (ch != 0xd) && (ch != 0xa) && (ch != ' ') && (ch != '\"') );
	}

private:
	// Prevents copying.
	CMultiPartFormParser(__in const CMultiPartFormParser& /*that*/) throw()
	{
		ATLASSERT(FALSE);
	}

	const CMultiPartFormParser& operator=(__in const CMultiPartFormParser& /*that*/) throw()
	{
		ATLASSERT(FALSE);
		return (*this);
	}
}; // class CMultiPartFormParser


// 48K max form size
#ifndef DEFAULT_MAX_FORM_SIZE
#define DEFAULT_MAX_FORM_SIZE 49152
#endif

// This class provides access to the information contained in an HTTP request submitted to a web server.
//
// CHttpRequest provides access to the query string parameters, form fields, cookies, and files
// that make up an HTTP request, as well as many other important properties of the request.
class CHttpRequest : public IHttpRequestLookup
{
protected:
	// Implementation: Array used to map an HTTP request method (for example, "GET" or "POST")
	// from a string to a numeric constant from the HTTP_METHOD enum (HTTP_METHOD_GET or HTTP_METHOD_HEAD).
	static const char* const m_szMethodStrings[];

	// Implementation: The server context.
	CComPtr<IHttpServerContext> m_spServerContext;

	// Implementation: The number of bytes read from the body of the request.
	DWORD m_dwBytesRead;

	// Implementation: TRUE if the request method was POST and the encoding was
	// multipart/form-data, FALSE otherwise.
	BOOL m_bMultiPart;

	CCookie m_EmptyCookie;

	// Implementation: Constructor function used to reinitialize all data members.
	void Construct() throw()
	{
		m_spServerContext.Release();
		m_bMultiPart = FALSE;
		m_dwBytesRead = 0;
		if (m_pFormVars != &m_QueryParams)
			delete m_pFormVars;

		m_pFormVars = NULL;
		m_pFormVars = &m_QueryParams;
		m_QueryParams.RemoveAll();
		m_QueryParams.SetShared(false);

		ClearFilesAndCookies();
	}

	void ClearFilesAndCookies() throw()
	{
		m_Files.RemoveAll();
		m_Files.SetShared(false);
		m_requestCookies.RemoveAll();
		m_requestCookies.SetShared(false);
	}

public:

	// Implementation: The collection of query parameters (name-value pairs) obtained from the query string.
	CHttpRequestParams m_QueryParams;

	// Implementation: The collection of form fields (name-value pairs).
	// The elements of this collection are obtained from the query string for a GET request,
	// or from the body of the request for a POST request.
	CHttpRequestParams *m_pFormVars;

	// The array of CHttpRequestFiles obtained from the current request.
	// See CHttpRequest::Initialize and CMultiPartFormParser::GetMultiPartData for more information.
	typedef CHttpPtrMap<CStringA, IHttpFile*, CStringElementTraits<CStringA> > FileMap;
	FileMap m_Files;

	// Implementation: The array of cookies obtained from the current request.
	typedef CHttpMap<CStringA, CCookie, CStringElementTraits<CStringA> > CookieMap;
	CookieMap m_requestCookies;

	// Numeric constants for the HTTP request methods (such as GET and POST).
	enum HTTP_METHOD 
	{
		HTTP_METHOD_UNKNOWN=-1,
		HTTP_METHOD_GET,
		HTTP_METHOD_POST,
		HTTP_METHOD_HEAD,
		HTTP_METHOD_DELETE,
		HTTP_METHOD_LINK,
		HTTP_METHOD_UNLINK,
		HTTP_METHOD_DEBUG  // Debugging support for VS7
	};

	// The collection of query parameters (name-value pairs) obtained from the query string.
	// A read-only property.
	__declspec(property(get=GetQueryParams)) const CHttpRequestParams& QueryParams;

	// Returns a reference to the collection of query parameters(name-value pairs) 
	// obtained from the query string.
	const CHttpRequestParams& GetQueryParams() const throw()
	{
		return m_QueryParams;
	}

	// The collection of form fields (name-value pairs).
	// The elements of this collection are obtained from the query string for a GET request,
	// or from the body of the request for a POST request.
	// A read-only property.
	__declspec(property(get=GetFormVars)) const CHttpRequestParams& FormVars;

	// Returns a reference to the collection of form fields (name-value pairs)
	// obtained from the query string for a GET request,
	// or from the body of the request for a POST request.
	const CHttpRequestParams& GetFormVars() const throw()
	{
		return *m_pFormVars;
	}

	CHttpRequest() throw()
	{
		m_bMultiPart = FALSE;
		m_dwBytesRead = 0;
		m_pFormVars = &m_QueryParams;
	}

	virtual ~CHttpRequest() throw()
	{
		DeleteFiles();

		if (m_pFormVars != &m_QueryParams)
		{
			delete m_pFormVars;
			m_pFormVars = NULL;
		}
	}

	// Constructs and initializes the object.
	CHttpRequest(
		__in IHttpServerContext *pServerContext,
		__in DWORD dwMaxFormSize=DEFAULT_MAX_FORM_SIZE,
		__in DWORD dwFlags=ATL_FORM_FLAG_NONE) throw(...)
		:m_pFormVars(NULL)
	{
		Construct();
		if (!Initialize(pServerContext, dwMaxFormSize, dwFlags))
			AtlThrow(E_FAIL);
	}

	CHttpRequest(__in IHttpRequestLookup *pRequestLookup) throw(...)
		:m_pFormVars(NULL)
	{
		if (!Initialize(pRequestLookup)) // Calls Construct for you
			AtlThrow(E_FAIL);
	}

	//=========================================================================================
	// BEGIN IHttpRequestLoookup interface
	//=========================================================================================
	__success(return != NULL) __checkReturn POSITION GetFirstQueryParam(__deref_out LPCSTR *ppszName, __deref_out LPCSTR *ppszValue)
	{		
		POSITION pos = m_QueryParams.GetStartPosition();
		if (pos != NULL)
		{
			ATLENSURE(ppszName != NULL);
			ATLENSURE(ppszValue != NULL);
			*ppszName = m_QueryParams.GetKeyAt(pos);
			*ppszValue = m_QueryParams.GetValueAt(pos);
		}

		return pos;
	}

	__success(return != NULL) __checkReturn POSITION GetNextQueryParam(__in POSITION pos, __deref_out LPCSTR *ppszName, __deref_out LPCSTR *ppszValue)
	{
		ATLENSURE(pos != NULL);
		

		POSITION posNext(pos);
		m_QueryParams.GetNext(posNext);
		if (posNext != NULL)
		{
			ATLENSURE(ppszName != NULL);
			ATLENSURE(ppszValue != NULL);
			*ppszName = m_QueryParams.GetKeyAt(posNext);
			*ppszValue = m_QueryParams.GetValueAt(posNext);
		}

		return posNext;
	}

	__success(return != NULL) __checkReturn POSITION GetFirstFormVar(__deref_out LPCSTR *ppszName, __deref_out LPCSTR *ppszValue)
	{
		// if no form vars and just pointing to the query params,
		// then return NULL
		if (m_pFormVars == &m_QueryParams)
			return NULL;

		POSITION pos = m_pFormVars->GetStartPosition();
		if (pos != NULL)
		{
			ATLENSURE(ppszName != NULL);
			ATLENSURE(ppszValue != NULL);
			*ppszName = m_pFormVars->GetKeyAt(pos);
			*ppszValue = m_pFormVars->GetValueAt(pos);
		}

		return pos;
	}

	__success(return != NULL) __checkReturn POSITION GetNextFormVar(__in POSITION pos, __deref_out LPCSTR *ppszName, __deref_out LPCSTR *ppszValue)
	{
		ATLASSERT(pos != NULL);
		ATLASSERT(ppszName != NULL);
		ATLASSERT(ppszValue != NULL);

		POSITION posNext(pos);
		m_pFormVars->GetNext(posNext);
		if (posNext != NULL)
		{
			*ppszName = m_pFormVars->GetKeyAt(posNext);
			*ppszValue = m_pFormVars->GetValueAt(posNext);
		}

		return posNext;
	}

	POSITION GetFirstFile(__in LPCSTR *ppszName, __deref_out IHttpFile **ppFile)
	{
		ATLASSERT(ppszName != NULL);
		ATLASSERT(ppFile != NULL);

		POSITION pos = m_Files.GetStartPosition();
		if (pos != NULL)
		{
			*ppszName = m_Files.GetKeyAt(pos);
			*ppFile = m_Files.GetValueAt(pos);
		}

		return pos;
	}

	__success(return != NULL) __checkReturn POSITION GetNextFile(__in POSITION pos, __deref_out LPCSTR *ppszName, __deref_out IHttpFile **ppFile)
	{
		ATLASSERT(pos != NULL);
		ATLASSERT(ppszName != NULL);
		ATLASSERT(ppFile != NULL);

		m_Files.GetNext(pos);
		if (pos != NULL)
		{
			*ppszName = m_Files.GetKeyAt(pos);
			*ppFile = m_Files.GetValueAt(pos);
		}

		return pos;
	}

	// Returns a pointer to the IHttpServerContext interface for the current request.
	HRESULT GetServerContext(__deref_out_opt IHttpServerContext ** ppOut)
	{
		return m_spServerContext.CopyTo(ppOut);
	}
	//=========================================================================================
	// END IHttpRequestLookup interface
	//=========================================================================================

	__success(return != NULL) __checkReturn POSITION GetFirstCookie(__deref_out LPCSTR *ppszName, __deref_out const CCookie **ppCookie) throw()
	{
		ATLASSERT(ppszName != NULL);
		ATLASSERT(ppCookie != NULL);
		POSITION pos = NULL;
		if (GetRequestCookies())
		{
			pos = m_requestCookies.GetStartPosition();
			if (pos != NULL)
			{
				*ppszName = m_requestCookies.GetKeyAt(pos);
				*ppCookie = &(m_requestCookies.GetValueAt(pos));
			}
		}
		return pos;
	}

	__success(return != NULL) __checkReturn POSITION GetNextCookie(__in POSITION pos, __deref_out LPCSTR *ppszName, __deref_out const CCookie **ppCookie) throw()
	{
		ATLASSERT(pos != NULL);
		ATLASSERT(ppszName != NULL);
		ATLASSERT(ppCookie != NULL);

		POSITION posNext(pos);
		m_requestCookies.GetNext(posNext);
		if (posNext != NULL)
		{
			*ppszName = m_requestCookies.GetKeyAt(posNext);
			*ppCookie = &(m_requestCookies.GetValueAt(posNext));
		}
		return posNext;
	}

	void SetServerContext(__in IHttpServerContext *pServerContext) throw()
	{
		m_spServerContext = pServerContext;
	}

	BOOL Initialize(__in IHttpRequestLookup *pRequestLookup) throw()
	{
		_ATLTRY
		{	
			ATLASSERT(pRequestLookup != NULL);
			// if there's no pRequestLookup, just return
			if (!pRequestLookup)
				return TRUE;

			Construct();
			HRESULT hr = pRequestLookup->GetServerContext(&m_spServerContext);
			if (FAILED(hr))
				return FALSE;

			LPCSTR szName(NULL);
			LPCSTR szValue(NULL);

			// Initialize query params from the IHttpRequestLookup*
			POSITION pos(pRequestLookup->GetFirstQueryParam(&szName, &szValue));
			while (pos != NULL)
			{
				m_QueryParams.SetAt(szName, szValue);
				pos = pRequestLookup->GetNextQueryParam(pos, &szName, &szValue);
			}
			m_QueryParams.SetShared(true);

			// Initialize the form vars from the IHttpRequestLookup*
			pos = pRequestLookup->GetFirstFormVar(&szName, &szValue);
			if (pos)
			{
				m_pFormVars = NULL;
				ATLTRY(m_pFormVars = new CHttpRequestParams);
				if (!m_pFormVars)
					return FALSE;

				while (pos != NULL)
				{
					m_pFormVars->SetAt(szName, szValue);
					pos = pRequestLookup->GetNextFormVar(pos, &szName, &szValue);
				}
				m_pFormVars->SetShared(true);
			}
			else
			{
				m_pFormVars = &m_QueryParams;
			}

			// Initialize the files from the IHttpRequestLookup*
			IHttpFile *pFile(NULL);
			pos = pRequestLookup->GetFirstFile(&szName, &pFile);
			while (pos != NULL)
			{
				m_Files.SetAt(szName, pFile);
				pos = pRequestLookup->GetNextFile(pos, &szName, &pFile);
			}
			m_Files.SetShared(true);

			// Initialzie the cookies form the IHttpRequestLookup*
			BOOL bRet = FALSE;
			CStringA strCookies;
			bRet = GetCookies(strCookies);
			if (bRet)
			{
				bRet = Parse(strCookies);
			}
			m_requestCookies.SetShared(false);
			return bRet;
		} // _ATLTRY
		_ATLCATCHALL()
		{
		}
		return FALSE;
	}

	// Call this function to initialize the object with information about the current request.
	//
	// Returns TRUE on success, FALSE on failure.
	//
	// Call Initialize directly or via the appropriate constructor before using the methods and
	// properties of the request object.
	//
	// Initialize does the following:
	//
	//      Parses and decodes the query string into a collection of name-value pairs.
	//      This collection is accessible via the GetQueryParams method or the QueryParams property.
	//
	//      Sets m_bMultiPart to TRUE if the request is a POST request with multipart/form-data encoding.
	//
	//      Parses the body of a POST request if the size of the request data is less than or equal to dwMaxFormSize.
	//      The body of the request will consist of simple form fields and may also contain files if the request is encoded as multipart/form-data.
	//      In that case, the dwFlags parameter is passed to CMultiPartFormParser::GetMultiPartData to control the creation of the files.
	//      The collection of form fields is accessible via the GetFormVars method or the FormVars property.
	//      The collection of files is accessible via the m_Files member.
	//
	// Note that Initialize does not parse the cookies associated with a request.
	// Cookies are not processed until an attempt is made to access a cookie in the collection.
	BOOL Initialize(
		__in IHttpServerContext *pServerContext,
		__in DWORD dwMaxFormSize=DEFAULT_MAX_FORM_SIZE,
		__in DWORD dwFlags=ATL_FORM_FLAG_NONE) throw()
	{
		_ATLTRY
		{
			ATLASSERT(pServerContext != NULL);
			if (!pServerContext)
			{
				return FALSE;
			}

			m_spServerContext = pServerContext;

			HTTP_METHOD httpMethod = GetMethod();
			LPCSTR pszQueryString = GetQueryString();
			if (pszQueryString && *pszQueryString)
			{
				// Parse the query string.
				CHAR szQueryString[ATL_URL_MAX_URL_LENGTH];
				if (!SafeStringCopy(szQueryString, pszQueryString))
				{
					return FALSE;
				}

				if (!m_QueryParams.Parse(szQueryString))
				{
					return FALSE;
				}
			}

			if (m_QueryParams.IsShared())
			{
				return TRUE;
			}

			// If this is a GET request, the collection of form fields
			// is the same as the collection of query parameters.
			if (httpMethod == HTTP_METHOD_GET)
			{
				m_pFormVars = &m_QueryParams;
				return TRUE;
			}
			else if (httpMethod == HTTP_METHOD_POST)
			{
				LPCSTR szContentType = GetContentType();
				if (!szContentType)
					return FALSE;

				// Don't parse the form data if the size is bigger than the maximum specified.
				if (m_spServerContext->GetTotalBytes() > dwMaxFormSize)
				{
					if (strncmp(szContentType, "multipart/form-data", 19) == 0)
						m_bMultiPart = TRUE;

					m_dwBytesRead = 0;

					return TRUE;
				}

				// If POSTed data is urlencoded, call InitFromPost.
				if (strncmp(szContentType, "application/x-www-form-urlencoded", 33) == 0 && !m_pFormVars->IsShared())
					return InitFromPost();

				// If POSTed data is encoded as multipart/form-data, use CMultiPartFormParser.
				if (strncmp(szContentType, "multipart/form-data", 19) == 0 && !m_pFormVars->IsShared())
				{
					if (m_pFormVars != &m_QueryParams)
						delete m_pFormVars;
					m_pFormVars = NULL;

					CMultiPartFormParser FormParser(m_spServerContext);
					ATLTRY(m_pFormVars = new CHttpRequestParams);
					if (!m_pFormVars)
						return FALSE;

					BOOL bRet = FormParser.GetMultiPartData(m_Files, m_pFormVars, dwFlags);
					return bRet;
				}

				// else initialize m_dwBytesRead for ReadData
				m_dwBytesRead = 0;
			}

			return TRUE;
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;

	}

	// Implementation: Call this function to initialize the collection of form fields
	// from the body of an application/x-www-form-urlencoded POST request.
	ATL_NOINLINE BOOL InitFromPost() throw()
	{
		_ATLTRY
		{
			ATLASSUME(m_spServerContext != NULL);

			// create our m_pFormVars
			if (m_pFormVars == NULL || m_pFormVars == &m_QueryParams)
			{
				ATLTRY(m_pFormVars = new CHttpRequestParams);
				if (m_pFormVars == NULL)
				{
					return FALSE;
				}
			}   

			// read the form data into a buffer
			DWORD dwBytesTotal = m_spServerContext->GetTotalBytes();
			CAutoVectorPtr<CHAR> szBuff;
			if ((dwBytesTotal+1 < dwBytesTotal) || (dwBytesTotal < 0))
			{
				return FALSE;
			}
			if (!szBuff.Allocate(dwBytesTotal+1))
			{
				return FALSE;
			}
			// first copy the available
			BOOL bRet = ReadClientData(m_spServerContext, szBuff, &dwBytesTotal, 0);
			if (bRet)
			{
				szBuff[dwBytesTotal] = '\0';
				bRet = m_pFormVars->Parse(szBuff);
			}

			return bRet;
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
	}

	// Call this function to remove the files listed in m_Files from the web server's hard disk.
	// Returns the number of files deleted.
	int DeleteFiles() throw()
	{
		int nDeleted = 0;
		POSITION pos = m_Files.GetStartPosition();
		while (pos != NULL)
		{
			LPCSTR szTempFile = m_Files.GetKeyAt(pos);
			if (szTempFile && DeleteFileA(szTempFile))
			{
				nDeleted++;
			}
			m_Files.GetNext(pos);
		}

		return nDeleted;
	}

	// Read a specified amount of data into pbDest and return the bytes read in pdwLen.
	// Returns TRUE on success, FALSE on failure.
	BOOL ReadData(__out_ecount_part(*pdwLen,*pdwLen) LPSTR pDest, __inout LPDWORD pdwLen)
	{
		ATLENSURE(pDest);
		ATLENSURE(pdwLen);

		BOOL bRet = ReadClientData(m_spServerContext, pDest, pdwLen, m_dwBytesRead);
		if (bRet)
			m_dwBytesRead+= *pdwLen;
		return bRet;
	}

	// Returns the number of bytes available in the request buffer accessible via GetAvailableData.
	// If GetAvailableBytes returns the same value as GetTotalBytes, the request buffer contains the whole request.
	// Otherwise, the remaining data should be read from the client using ReadData.
	// Equivalent to EXTENSION_CONTROL_BLOCK::cbAvailable.
	__checkReturn DWORD GetAvailableBytes() throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetAvailableBytes();
	}

	// Returns the total number of bytes to be received from the client.
	// If this value is 0xffffffff, then there are four gigabytes or more of available data.
	// In this case, ReadData should be called until no more data is returned.
	// Equivalent to the CONTENT_LENGTH server variable or EXTENSION_CONTROL_BLOCK::cbTotalBytes. 
	__checkReturn DWORD GetTotalBytes() throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetTotalBytes();
	}

	// Returns a pointer to the request buffer containing the data sent by the client.
	// The size of the buffer can be determined by calling GetAvailableBytes.
	// Equivalent to EXTENSION_CONTROL_BLOCK::lpbData
	__checkReturn LPBYTE GetAvailableData() throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetAvailableData();
	}


	// Returns a nul-terminated string that contains the query information.
	// This is the part of the URL that appears after the question mark (?). 
	// Equivalent to the QUERY_STRING server variable or EXTENSION_CONTROL_BLOCK::lpszQueryString.
	__checkReturn LPCSTR GetQueryString() throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetQueryString();
	}

	// Returns a nul-terminated string that contains the HTTP method of the current request.
	// Examples of common HTTP methods include "GET" and "POST".
	// Equivalent to the REQUEST_METHOD server variable or EXTENSION_CONTROL_BLOCK::lpszMethod.
	__checkReturn LPCSTR GetMethodString() throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetRequestMethod();
	}

	// Returns an HTTP_METHOD enum value corresponding to the HTTP method of the current request.
	// Returns HTTP_METHOD_UNKNOWN if the request method is not one of the following methods:
	//      GET
	//      POST
	//      HEAD
	//      DELETE
	//      LINK
	//      UNLINK
	__checkReturn HTTP_METHOD GetMethod() throw(...)
	{
		LPCSTR szMethod = GetMethodString();
		if (!szMethod)
			return HTTP_METHOD_UNKNOWN;
		for (int i=0; m_szMethodStrings[i]; i++)
		{
			if (strcmp(szMethod, m_szMethodStrings[i]) == 0)
				return (HTTP_METHOD) i;
		}
		return HTTP_METHOD_UNKNOWN;
	}

	// Returns a nul-terminated string that contains the content type of the data sent by the client.
	// Equivalent to the CONTENT_TYPE server variable or EXTENSION_CONTROL_BLOCK::lpszContentType.
	__checkReturn LPCSTR GetContentType() throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetContentType();
	}


	// Call this function to retrieve a nul-terminated string containing the value of the "AUTH_USER" server variable.
	//
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	__checkReturn BOOL GetAuthUserName(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuff, __inout DWORD *pdwSize) throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetServerVariable("AUTH_USER", szBuff, pdwSize);
	}

	// Call this function to retrieve a nul-terminated string containing the value of the "APPL_PHYSICAL_PATH" server variable.
	//
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	__checkReturn BOOL GetPhysicalPath(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuff, __inout DWORD *pdwSize) throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetServerVariable("APPL_PHYSICAL_PATH", szBuff, pdwSize);
	}

	// Call this function to retrieve a nul-terminated string containing the value of the "AUTH_PASSWORD" server variable.
	//
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	__checkReturn BOOL GetAuthUserPassword(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuff, __inout DWORD *pdwSize) throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetServerVariable("AUTH_PASSWORD", szBuff, pdwSize);
	}

	// Call this function to retrieve a nul-terminated string containing the value of the "URL" server variable.
	//
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	__checkReturn BOOL GetUrl(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuff, DWORD *pdwSize) throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetServerVariable("URL", szBuff, pdwSize);
	}

	// Call this function to retrieve a nul-terminated string containing the value of the "REMOTE_HOST" server variable.
	//
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	__checkReturn BOOL GetUserHostName(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuff, __inout DWORD *pdwSize) throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetServerVariable("REMOTE_HOST", szBuff, pdwSize);
	}

	// Call this function to retrieve a nul-terminated string containing the value of the "REMOTE_ADDR" server variable.
	//
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	__checkReturn BOOL GetUserHostAddress(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuff, __inout DWORD *pdwSize) throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetServerVariable("REMOTE_ADDR", szBuff, pdwSize);
	}

	// Call this function to retrieve a nul-terminated string containing the physical path of the script.
	//
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	// The script path is the same as GetPathTranslated up to the first .srf or .dll.
	// For example, if GetPathTranslated returns "c:\inetpub\vcisapi\hello.srf\goodmorning",
	// then this function returns "c:\inetpub\vcisapi\hello.srf".
	__checkReturn LPCSTR GetScriptPathTranslated() throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetScriptPathTranslated();
	}

	// Returns a nul-terminated string that contains the physical path of the requested resource on the local server.
	// Equivalent to the PATH_TRANSLATED server variable or EXTENSION_CONTROL_BLOCK::lpszPathTranslated.
	__checkReturn LPCSTR GetPathTranslated() throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetPathTranslated();
	}

	// Returns a nul-terminated string that contains the path of the current request.
	// This is the part of the URL that appears after the server name, but before the query string.
	// Equivalent to the PATH_INFO server variable or EXTENSION_CONTROL_BLOCK::lpszPathInfo.
	__checkReturn LPCSTR GetPathInfo() throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetPathInfo();
	}

	// Call this function to determine whether the current request was authenticated.
	__checkReturn BOOL GetAuthenticated() throw(...)
	{
		// We assume that if we get an authentication type from IIS,
		// then the user has been authenticated.
		CStringA strAuthType;
		if (GetAuthenticationType(strAuthType) &&
			strAuthType.GetLength() > 0)
			return TRUE;

		return FALSE;
	}

	// Call this function to retrieve a nul-terminated string containing the value of the "AUTH_TYPE" server variable.
	//
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	__checkReturn BOOL GetAuthenticationType(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuff, __inout DWORD *pdwSize) throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetServerVariable("AUTH_TYPE", szBuff, pdwSize);
	}

	// Call this function to retrieve a nul-terminated string containing the value of the "REMOTE_USER" server variable.
	//
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	__checkReturn BOOL GetUserName(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuff, DWORD __inout *pdwSize) throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetServerVariable("REMOTE_USER", szBuff, pdwSize);
	}

	// Call this function to retrieve a nul-terminated string containing the value of the "HTTP_USER_AGENT" server variable.
	//
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	 __checkReturn BOOL GetUserAgent(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuff, __inout DWORD *pdwSize) throw(...)
	 {
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetServerVariable("HTTP_USER_AGENT", szBuff, pdwSize);
	 }

	// Call this function to retrieve a nul-terminated string containing the value of the "HTTP_ACCEPT_LANGUAGE" server variable.
	//
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	 __checkReturn BOOL GetUserLanguages(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuff, __inout DWORD *pdwSize) throw(...)
	 {
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetServerVariable("HTTP_ACCEPT_LANGUAGE", szBuff, pdwSize);
	 }

	// Call this function to retrieve a nul-terminated string containing the value of the "HTTP_ACCEPT" server variable.
	//
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	__checkReturn BOOL GetAcceptTypes(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuff, __inout DWORD *pdwSize) throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetServerVariable("HTTP_ACCEPT", szBuff, pdwSize);
	}

	// Call this function to retrieve a nul-terminated string containing the value of the "HTTP_ACCEPT_ENCODING" server variable.
	//
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	__checkReturn BOOL GetAcceptEncodings(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuff, __inout DWORD *pdwSize) throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetServerVariable("HTTP_ACCEPT_ENCODING", szBuff, pdwSize);
	}


	// Call this function to retrieve a nul-terminated string containing the value of the "HTTP_REFERER" server variable.
	//
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	__checkReturn BOOL GetUrlReferer(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuff, __inout DWORD *pdwSize) throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetServerVariable("HTTP_REFERER", szBuff, pdwSize);
	}

	// Call this function to retrieve a nul-terminated string containing the value of the "SCRIPT_NAME" server variable.
	//
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	//
	// On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
	// On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
	__checkReturn BOOL GetScriptName(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuff, __inout DWORD *pdwSize) throw(...)
	{
		ATLENSURE(m_spServerContext);
		return m_spServerContext->GetServerVariable("SCRIPT_NAME", szBuff, pdwSize);
	}

	// Fills a buffer with the contents of the HTTP_COOKIE headers sent
	// from the browser.
	__checkReturn BOOL GetCookies(__out_ecount_part(*pdwSize,*pdwSize) LPSTR szBuf, __inout LPDWORD pdwSize) const throw(...)
	{		
		ATLASSERT(szBuf != NULL);

		CStringA strCookie;
		if (GetCookies(strCookie))
		{
			ATLENSURE(pdwSize != NULL);
			if (pdwSize && *pdwSize > (DWORD)strCookie.GetLength())
			{
				Checked::strcpy_s(szBuf, *pdwSize, strCookie);
				*pdwSize = strCookie.GetLength();
				return true;
			}
		}
		return false;
	}

	// Fills a CStringA with the contents of the HTTP_COOKIE headers sent
	// from the browser.
	__checkReturn BOOL GetCookies(__inout CStringA& strBuff) const throw()
	{
		return GetServerVariable("HTTP_COOKIE", strBuff);
	}

	// Call this function to retrieve a reference to the specified cookie.
	// Returns a CCookie reference to the specified cookie or a
	// reference to an empty cookie if the name can not be found.
	ATL_NOINLINE const CCookie& Cookies(__in LPCSTR szName) throw(...)
	{
		if (GetRequestCookies())
		{
			// p->m_value is a const CCookie&
			CookieMap::CPair *p = NULL;
			ATLTRY(p = m_requestCookies.Lookup(szName));
			if (p)
			{
				return p->m_value;
			}
		}
		m_EmptyCookie.Empty(); // make sure it is cleared.
		return m_EmptyCookie;
	}


	// Call this function to retrieve the session cookie.
	const CCookie& GetSessionCookie() throw(...)
	{
		return Cookies(SESSION_COOKIE_NAME);
	}

	// Call this function to retrieve the value of the requested server variable in a CStringA object.
	// Returns TRUE on success, and FALSE on failure. Call GetLastError to get extended error information.
	// Equivalent to EXTENSION_CONTROL_BLOCK::GetServerVariable.
	BOOL GetServerVariable(__in LPCSTR szVariable, __out CStringA &str) const
	{
		ATLENSURE(m_spServerContext);

		DWORD dwSize = 0;
		BOOL bRet = FALSE;
		_ATLTRY
		{
			m_spServerContext->GetServerVariable(szVariable, NULL, &dwSize);
			bRet = m_spServerContext->GetServerVariable(szVariable, str.GetBuffer(dwSize), &dwSize);
			if (dwSize > 0)
				dwSize--;
			str.ReleaseBuffer(dwSize);
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
		return bRet;
	}

	// Call this function to retrieve the value of the "APPL_PHYSICAL_PATH" server variable.
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	__checkReturn BOOL GetPhysicalPath(__out CStringA &str) throw()
	{
		return GetServerVariable("APPL_PHYSICAL_PATH", str);
	}

	// Call this function to retrieve the value of the "REMOTE_HOST" server variable.
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	__checkReturn BOOL GetUserHostName(__out CStringA &str) throw()
	{
		return GetServerVariable("REMOTE_HOST", str);
	}

	// Call this function to retrieve the value of the "REMOTE_ADDR" server variable.
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	__checkReturn BOOL GetUserHostAddress(__out CStringA &str) throw()
	{
		return GetServerVariable("REMOTE_ADDR", str);
	}

	// Call this function to retrieve the value of the "AUTH_TYPE" server variable.
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	__checkReturn BOOL GetAuthenticationType(__out CStringA &str) throw()
	{
		return GetServerVariable("AUTH_TYPE", str);
	}

	// Call this function to retrieve the value of the "REMOTE_USER" server variable.
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	__checkReturn BOOL GetUserName(__out CStringA &str) throw()
	{
		return GetServerVariable("REMOTE_USER", str);
	}

	// Call this function to retrieve the value of the "HTTP_USER_AGENT" server variable.
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	__checkReturn BOOL GetUserAgent(__out CStringA &str) throw()
	{
		return GetServerVariable("HTTP_USER_AGENT", str);
	}

	// Call this function to retrieve the value of the "HTTP_ACCEPT_LANGUAGE" server variable.
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	__checkReturn BOOL GetUserLanguages(__out CStringA &str) throw()
	{
		return GetServerVariable("HTTP_ACCEPT_LANGUAGE", str);
	}

	// Call this function to retrieve the value of the "AUTH_USER" server variable.
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	__checkReturn BOOL GetAuthUserName(__out CStringA &str) throw()
	{
		return GetServerVariable("AUTH_USER", str);
	}

	// Call this function to retrieve the value of the "AUTH_PASSWORD" server variable.
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	__checkReturn BOOL GetAuthUserPassword(__out CStringA &str) throw()
	{
		return GetServerVariable("AUTH_PASSWORD", str);
	}

	// Call this function to retrieve the value of the "URL" server variable.
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	__checkReturn BOOL GetUrl(__out CStringA &str) throw()
	{
		return GetServerVariable("URL", str);
	}

	// Call this function to retrieve the value of the "HTTP_ACCEPT" server variable.
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	__checkReturn BOOL GetAcceptTypes(__out CStringA &str) throw()
	{
		return GetServerVariable("HTTP_ACCEPT", str);
	}

	// Call this function to retrieve the value of the "HTTP_ACCEPT_ENCODING" server variable.
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	__checkReturn BOOL GetAcceptEncodings(__out CStringA& str) throw()
	{
		return GetServerVariable("HTTP_ACCEPT_ENCODING", str);
	}

	// Call this function to retrieve the value of the "HTTP_REFERER" server variable.
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	__checkReturn BOOL GetUrlReferer(__out CStringA &str) throw()
	{
		return GetServerVariable("HTTP_REFERER", str);
	}

	// Call this function to retrieve the value of the "SCRIPT_NAME" server variable.
	// Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
	__checkReturn BOOL GetScriptName(__out CStringA &str) throw()
	{
		return GetServerVariable("SCRIPT_NAME", str);
	}

	// Implementation: Call this function to populate the collection 
	// of CCookie objects with the cookies in the current request.
	// Returns TRUE on success, FALSE on failure.
	__checkReturn BOOL GetRequestCookies() throw()
	{
		BOOL bRet = FALSE;

		if (m_requestCookies.GetCount())
			return TRUE; // we already got the cookies!

		CStringA strCookies;
		if (GetCookies(strCookies))
		{
			bRet = Parse(strCookies);
		}
		return bRet;
	}

private:
	struct Pair
	{
		Pair(__in const CStringA &n, __in const CStringA& v)
		{
			name = n;
			value = v;
		}

		Pair(__in const Pair& rhs)
		{	
			name = rhs.name;
			value = rhs.value;
		}
		
		CStringA name;
		CStringA value;
	};
	static const int INVALID_COOKIE_VERSION = -1;
public:

	// Implementation: Call this function to populate m_requestCookies
	// with a collection of CCookie objects which represents the
	// cookies contained in szCookie header sent from the browser.
	BOOL Parse(__in LPCSTR szCookieIn) 
	{
		ATLENSURE(szCookieIn!=NULL);
		UINT acp = GetACP();
		LPCSTR szStart;
		LPCSTR szEnd;
		CStringA name, value;
		CAtlList<Pair> pair_list;

		// create a list of name=value pairs
		// these are separated by or ;
		szStart = szCookieIn;
		szEnd = szStart;
		while (*szStart)
		{
			name.Empty();
			value.Empty();
			szStart = SkipSpace(szStart, (WORD)acp);
			if (*szStart == '\0')
				break;
			
			szEnd = szStart;
			while (*szEnd && *szEnd != '=' && *szEnd != ';' )
				szEnd++;

			if (szEnd <= szStart)
			{
				if (*szEnd ==';')
				{
					szEnd++;
					szStart = szEnd;
					continue;
				}
				szStart = szEnd;
				break; // no name or error
			}

			CopyToCString(name, szStart, szEnd);
			if (*szEnd == '\0' || *szEnd == ';' )
			{
				// no value expected;
				pair_list.AddTail(Pair(name, value));
				szStart = szEnd;
			}
			else if ( *szEnd == '=')
			{
				szEnd++; // skip '='
				szStart = szEnd;
				while (*szEnd && *szEnd != ';')
					szEnd++;

				if (szEnd <= szStart)
				{
					if (*szEnd == ';')
					{
						szEnd++;
						szStart = szEnd;
						continue;
					}
					szStart = szEnd;
					pair_list.AddTail(Pair(name,value));
					break; // no value
				}

				CopyToCString(value, szStart, szEnd);
				pair_list.AddTail(Pair(name,value));
				szStart = szEnd;
			}
		}

		// now make cookies out of the list
		// The first item could be $Version, which would
		// be the version for all cookies in the list.
		// any other $Version's found in the list will be ignored.
		if (pair_list.GetCount() <= 0)
			return TRUE; // nothing in the list

		// check for $Version
		static const char szVersion[] = "$Version";
		int nVersion = INVALID_COOKIE_VERSION;
		if (!strncmp(pair_list.GetHead().name, szVersion, sizeof(szVersion)+1))
		{
			char *pStop = NULL;
			nVersion = strtol(pair_list.GetHead().value, &pStop, 10);
			if (Checked::get_errno() == ERANGE)
				nVersion = INVALID_COOKIE_VERSION; // $Version contained garbage
			pair_list.RemoveHead(); // Remove $Version
		}

		POSITION pos = pair_list.GetHeadPosition();
		bool bInCookie = false;
		CCookie cookie;

		while (pos)
		{
			const Pair &p = pair_list.GetNext(pos);
			if (p.name[0] == '$')
			{
				if (!bInCookie)
					return FALSE; // invalid cookie string
				else
				{
					//add attribute to current cookie
					if(!cookie.AddAttribute(p.name.Right(p.name.GetLength()-1),p.value))
					{
						return FALSE;
					}
				}
			}
			else
			{
				if (!bInCookie)
				{
					bInCookie = true;
					cookie.SetName(p.name);
					cookie.ParseValue(p.value);
					if (nVersion != INVALID_COOKIE_VERSION)
						cookie.SetVersion(nVersion);
				}
				else
				{
					// add previous cookie
					CStringA strPrevName;
					if(!cookie.GetName(strPrevName))
					{
						return FALSE;
					}
					m_requestCookies.SetAt(strPrevName, cookie);

					// empty current cookie and start over
					cookie.Empty();
					cookie.SetName(p.name);
					cookie.ParseValue(p.value);
					if (nVersion != INVALID_COOKIE_VERSION)
						cookie.SetVersion(nVersion);

				}
			}
		}

		if (!cookie.IsEmpty())
		{
			CStringA strName;
			if(!cookie.GetName(strName))
			{
				return FALSE;
			}
			m_requestCookies.SetAt(strName, cookie);
		}
		return TRUE;

	}

private:
	// Call this function to copy a substring to a CString reference and ensure nul-termination.
	inline void CopyToCString(__out CStringA& string, __in_ecount(pEnd-pStart) LPCSTR pStart, __in LPCSTR pEnd) throw( ... )
	{
		ATLENSURE( pStart != NULL );
		ATLENSURE( pEnd != NULL );
		ATLENSURE( pEnd>=pStart );

		string.SetString(pStart, (int)(pEnd-pStart));
		string.Trim();
	}

	inline LPCSTR SkipSpace(__in LPCSTR sz, __in WORD nCodePage) throw()
	{
		if (sz == NULL)
			return NULL;

		while (isspace(static_cast<unsigned char>(*sz)))
			sz = CharNextExA(nCodePage, sz, 0);
		return sz;
	}
public:


	__success(SUCCEEDED(return)) __checkReturn HRESULT STDMETHODCALLTYPE QueryInterface(__in REFIID riid, __deref_out void **ppv)
	{
		if (!ppv)
			return E_POINTER;
		if (InlineIsEqualGUID(riid, __uuidof(IHttpRequestLookup)))
		{
			*ppv = static_cast<IUnknown*>(static_cast<IHttpRequestLookup*>(this));
			AddRef();
			return S_OK;
		}
		if (InlineIsEqualGUID(riid, __uuidof(IUnknown)))
		{
			*ppv = static_cast<IUnknown*>(this);
			AddRef();
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef()
	{
		return 1;
	}

	ULONG STDMETHODCALLTYPE Release()
	{
		return 1;
	}
}; // class CHttpRequest

__declspec(selectany) const char* const CHttpRequest::m_szMethodStrings[] = {
	"GET",
	"POST",
	"HEAD",
	"DELETE",
	"LINK",
	"UNLINK",
	"DEBUG",  // Debugging support for VS7
	NULL
};

#endif // _WIN32_WCE

// This class provides type conversions via the Write method
// and overloaded left shift << operator for writing
// data to the IWriteStream interface. The IWriteStream interface
// only accepts strings, but this helper class allows you to transparently
// pass many different types by providing automatic type conversions.
//
// Notes on Type Conversions:
//      Numeric types are converted to their decimal representations.
//      Floating point values are output with a precision of 6 decimal places.
//      Currency values are converted according to the locale settings of the current thread.
class CWriteStreamHelper
{
protected:
	// Implementation: The IWriteStream interface.
	IWriteStream *m_pStream;
	UINT m_ulACP;

public:
	CWriteStreamHelper() throw()
		:m_pStream(NULL)
	{
		m_ulACP = _AtlGetConversionACP();
	}

	CWriteStreamHelper(__in_opt IWriteStream *pStream) throw()
	{
		m_pStream = pStream;
		m_ulACP = _AtlGetConversionACP();
	}

	// Attach a IWriteStream
	IWriteStream *Attach(__in IWriteStream *pStream) throw()
	{
		IWriteStream *pRetStream = m_pStream;
		m_pStream = pStream;
		return pRetStream;
	}

	// Call this function to write data to the IWriteStream interface managed by this object.
	// Returns TRUE on success, FALSE on failure.
	BOOL Write(__in_z LPCSTR szOut) throw()
	{
		ATLASSUME(m_pStream != NULL);

		if (!szOut)
			return FALSE;

		DWORD dwWritten;
		return SUCCEEDED(m_pStream->WriteStream(szOut, (int) strlen(szOut), &dwWritten));
	}

	// Call this function to write data to the IWriteStream interface managed by this object.
	// Returns TRUE on success, FALSE on failure.
	BOOL Write(__in int n) throw()
	{
		CHAR szTmp[21];
		Checked::itoa_s(n, szTmp, _countof(szTmp), 10);
		return Write(szTmp);
	}

	// Call this function to write data to the IWriteStream interface managed by this object.
	// Returns TRUE on success, FALSE on failure.
	BOOL Write(__in unsigned int u) throw()
	{
		CHAR szTmp[21];
		Checked::ultoa_s(u, szTmp, _countof(szTmp), 10);
		return Write(szTmp);
	}

	// Call this function to write data to the IWriteStream interface managed by this object.
	// Returns TRUE on success, FALSE on failure.
	BOOL Write(__in short int w) throw()
	{
		return Write((int) w);
	}

	// Call this function to write data to the IWriteStream interface managed by this object.
	// Returns TRUE on success, FALSE on failure.
	BOOL Write(__in unsigned short int w) throw()
	{
		return Write((unsigned int) w);
	}

	// Call this function to write data to the IWriteStream interface managed by this object.
	// Returns TRUE on success, FALSE on failure.
	BOOL Write(__in long int dw) throw()
	{
		CHAR szTmp[21];
		Checked::ltoa_s(dw, szTmp, _countof(szTmp), 10);
		return Write(szTmp);
	}

	// Call this function to write data to the IWriteStream interface managed by this object.
	// Returns TRUE on success, FALSE on failure.
	BOOL Write(__in unsigned long int dw) throw()
	{
		CHAR szTmp[21];
		Checked::ultoa_s(dw, szTmp, _countof(szTmp), 10);
		return Write(szTmp);
	}

	// Call this function to write data to the IWriteStream interface managed by this object.
	// Returns TRUE on success, FALSE on failure.
	BOOL Write(__in double d, __in int nDigitCount=ATL_DEFAULT_PRECISION) throw()
	{
		ATLASSUME(m_pStream != NULL);

		CHAR szTmp[512];
		int nDec = 0;
		int nSign = 0;
		bool fWriteDec=true;
#if _SECURE_ATL && !defined(_WIN32_WCE)
		if (0 != _fcvt_s(szTmp, _countof(szTmp), d, nDigitCount, &nDec, &nSign))
#else
		if (!SafeStringCopy(szTmp, _fcvt(d, nDigitCount, &nDec, &nSign)))
#endif
		{
			// too large
			return FALSE;
		}

		if (nSign != 0)
			m_pStream->WriteStream("-", 1, NULL);
		if (nDec < 0)
		{
			nDec *= -1;
			m_pStream->WriteStream("0.", 2, NULL);
			for (int i=0;i<nDec;i++)
			{
				m_pStream->WriteStream("0", 1, NULL);
			}
			nDec = 0;
			fWriteDec=false;
		}

		char *p = szTmp;
		while (*p)
		{
			// if the decimal lies at the end of the number
			// (no digits to the right of the decimal, we don't
			// print it.
			if (nDec == 0 && fWriteDec)
				m_pStream->WriteStream(".", 1, NULL);
			m_pStream->WriteStream(p, 1, NULL);
			nDec--;
			p++;
		}
		return TRUE;
	}

	// Call this function to write data to the IWriteStream interface managed by this object.
	// Returns TRUE on success, FALSE on failure.
	BOOL Write(__in __int64 i) throw()
	{
		CHAR szTmp[21];
		Checked::i64toa_s(i, szTmp, _countof(szTmp), 10);
		return Write(szTmp);
	}       

	// Call this function to write data to the IWriteStream interface managed by this object.
	// Returns TRUE on success, FALSE on failure.
	BOOL Write(__in unsigned __int64 i) throw()
	{
		CHAR szTmp[21];
		Checked::ui64toa_s(i, szTmp, _countof(szTmp), 10);
		return Write(szTmp);
	}       

	// Call this function to write data to the IWriteStream interface managed by this object.
	// Returns TRUE on success, FALSE on failure.
	BOOL Write(__in CURRENCY c) throw()
	{
		CHAR szDest[256];
		CHAR szNumber[32];

		Checked::i64toa_s(c.int64, szNumber, _countof(szNumber), 10);
		int nLen = (int) strlen(szNumber);
		if (nLen < 5)
		{
			// prepend ascii zeros
			Checked::memmove_s(szNumber+5-nLen, 32-(5-nLen), szNumber, nLen+1);
			memset(szNumber, '0', 5-nLen);
			nLen = 5;
		}

		Checked::memmove_s(szNumber+nLen-3, 32-(nLen-3), szNumber+nLen-4, 5);
		szNumber[nLen-4] = '.';

		int nRet = GetCurrencyFormatA(GetThreadLocale(), 0, szNumber, NULL, szDest, sizeof(szDest));
		if (nRet > 0)
			return Write(szDest);

		ATLASSERT(GetLastError()==ERROR_INSUFFICIENT_BUFFER);

		nRet = GetCurrencyFormatA(GetThreadLocale(), 0, szNumber, NULL, NULL, 0);
		ATLASSERT(nRet > 0);

		if (nRet <= 0)
			return FALSE;

		CAutoVectorPtr<CHAR> szBuffer;
		if (!szBuffer.Allocate(nRet))
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			return FALSE;
		}
		nRet = GetCurrencyFormatA(GetThreadLocale(), 0, szNumber, NULL, szBuffer, nRet);

		ATLASSERT(nRet > 0);
		BOOL bRet = FALSE;
		if (nRet > 0)
			bRet = Write(szBuffer);

		return bRet;
	}

	// Call this function to write data to the IWriteStream interface managed by this object.
	// Returns TRUE on success, FALSE on failure.
	BOOL Write(__in LPCWSTR wsz) throw()
	{
		ATLASSUME(m_pStream != NULL);

		BOOL bRet;

		_ATLTRY
		{
			CW2A sz(wsz, m_ulACP);

			if (!sz)
			{
				bRet = FALSE;
			}

			DWORD dwWritten;
			bRet = SUCCEEDED(m_pStream->WriteStream(sz, (int) strlen(sz), &dwWritten));
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}

		return bRet;
	}

	// Use this operator to write data to the IWriteStream interface managed by this object.
	CWriteStreamHelper& operator<<(__in LPCSTR szStr) throw(...)
	{
		if (!Write(szStr))
			AtlThrow(E_FAIL);
		return *this;
	}

	// Use this operator to write data to the IWriteStream interface managed by this object.
	CWriteStreamHelper& operator<<(__in LPCWSTR wszStr) throw(...)
	{
		if (!Write(wszStr))
			AtlThrow(E_FAIL);
		return *this;
	}

	// Use this operator to write data to the IWriteStream interface managed by this object.
	CWriteStreamHelper& operator<<(__in int n) throw(...)
	{
		if (!Write(n))
			AtlThrow(E_FAIL);
		return *this;
	}

	// Use this operator to write data to the IWriteStream interface managed by this object.
	CWriteStreamHelper& operator<<(__in short int w) throw(...)
	{
		if (!Write(w))
			AtlThrow(E_FAIL);
		return *this;
	}

	// Use this operator to write data to the IWriteStream interface managed by this object.
	CWriteStreamHelper& operator<<(__in unsigned int u) throw(...)
	{
		if (!Write(u))
			AtlThrow(E_FAIL);
		return *this;
	}

	// Use this operator to write data to the IWriteStream interface managed by this object.
	CWriteStreamHelper& operator<<(__in long int dw) throw(...)
	{
		if (!Write(dw))
			AtlThrow(E_FAIL);
		return *this;
	}

	// Use this operator to write data to the IWriteStream interface managed by this object.
	CWriteStreamHelper& operator<<(__in unsigned long int dw) throw(...)
	{
		if (!Write(dw))
			AtlThrow(E_FAIL);
		return *this;
	}

	// Use this operator to write data to the IWriteStream interface managed by this object.
	CWriteStreamHelper& operator<<(__in double d) throw(...)
	{
		if (!Write(d))
			AtlThrow(E_FAIL);
		return *this;
	}

	// Use this operator to write data to the IWriteStream interface managed by this object.
	CWriteStreamHelper& operator<<(__in __int64 i) throw(...)
	{
		if (!Write(i))
			AtlThrow(E_FAIL);
		return *this;
	}

	// Use this operator to write data to the IWriteStream interface managed by this object.
	CWriteStreamHelper& operator<<(__in unsigned __int64 i) throw(...)
	{
		if (!Write(i))
			AtlThrow(E_FAIL);
		return *this;
	}

	// Use this operator to write data to the IWriteStream interface managed by this object.
	CWriteStreamHelper& operator<<(__in CURRENCY c) throw(...)
	{
		if (!Write(c))
			AtlThrow(E_FAIL);
		return *this;
	}

	UINT SetConversionCodePage(__in UINT nNewCP)
	{
		UINT nOldCP = m_ulACP;
		m_ulACP = nNewCP;
		return nOldCP;
	}
};

// This class represents the response that the web server will send back to the client.
//
// CHttpResponse provides friendly functions for building up the headers, cookies, and body of an HTTP response.
// The class derives from IWriteStream and CWriteStreamHelper, allowing you to call those classes' methods
// to build up the body of the response. By default, the class improves performance by buffering the response until it is complete before sending it back to the client.
class CHttpResponse : public IWriteStream, public CWriteStreamHelper
{
private:

	// Implementation: A map of HTTP response headers.
	// The key is the name of the response header.
	// The value is the data for the response header.
	CSimpleMap<CStringA, CStringA> m_headers;

	// Implementation: Determines whether the response is currently being buffered.
	BOOL m_bBufferOutput;

	// Implementation: Determines whether any output should be sent to the client.
	// Intended mainly for HEAD requests, where the client should get the same headers
	// (i.e. Content-Length) as for a GET request
	BOOL m_bSendOutput;

	// Implementation: The limit in bytes of the response buffer.
	// When the limit is reached, the buffer is automatically flushed
	// and data is sent to the client. You can set this to ULONG_MAX
	// to enable full buffering (this is the default, and is required
	// for enabling keep alive connections).
	DWORD m_dwBufferLimit;

	// Implementation: The server context.
	CComPtr<IHttpServerContext> m_spServerContext;

	// Implementation: The HTTP status code for the response.
	int m_nStatusCode;

	// Implementation: Determines whether the response headers have already been sent to the client.
	BOOL m_bHeadersSent;

	// Implementation: Handle of the file being transmitted so it can be closed
	// when the async I/O completes
	HANDLE m_hFile;

public:
	// Implementation: The buffer used to store the response before
	// the data is sent to the client.
	CAtlIsapiBuffer<> m_strContent;

	// Numeric constants for the HTTP status codes used for redirecting client requests.
	enum HTTP_REDIRECT
	{ 
		HTTP_REDIRECT_MULTIPLE=300,
		HTTP_REDIRECT_MOVED=301,
		HTTP_REDIRECT_FOUND=302,
		HTTP_REDIRECT_SEE_OTHER=303,
		HTTP_REDIRECT_NOT_MODIFIED=304,
		HTTP_REDIRECT_USE_PROXY=305,
		HTTP_REDIRECT_TEMPORARY_REDIRECT=307
	};

	CHttpResponse() throw()
	{
		m_bBufferOutput = TRUE;
		m_dwBufferLimit = ULONG_MAX;
		m_nStatusCode = 200;
		m_pStream = this;
		m_bHeadersSent = FALSE;
		m_bSendOutput = TRUE;
		m_hFile = INVALID_HANDLE_VALUE;
	}

	CHttpResponse(__in IHttpServerContext *pServerContext)
	{
		m_bBufferOutput = TRUE;
		m_dwBufferLimit = ULONG_MAX;
		m_nStatusCode = 200;
		m_pStream = this;
		m_bHeadersSent = FALSE;
		ATLENSURE(Initialize(pServerContext));
		m_bSendOutput = TRUE;
		m_hFile = INVALID_HANDLE_VALUE;
	}

	// The destructor flushes the buffer if there is content that
	// hasn't yet been sent to the client.
	virtual ~CHttpResponse() throw()
	{
		Flush(TRUE);
		if (m_hFile && m_hFile != INVALID_HANDLE_VALUE)
			CloseHandle(m_hFile);
	}

	// Call this function to initialize the response object with a pointer to the server context.
	// Returns TRUE on success, FALSE on failure.
	__checkReturn BOOL Initialize(__in IHttpServerContext *pServerContext) throw()
	{
		ATLASSERT(pServerContext != NULL);
		if (!pServerContext)
			return FALSE;

		m_spServerContext = pServerContext;

		return TRUE;
	}

	// This is called to initialize the CHttpResponse for a child handler.  By default, it
	// assumes the parent will be responsible for sending the headers.
	__checkReturn BOOL Initialize(__in IHttpRequestLookup *pLookup) throw(...)
	{
		ATLASSERT(pLookup);
		if (!pLookup)
			return FALSE;

		CComPtr<IHttpServerContext> spContext;
		HRESULT hr = pLookup->GetServerContext(&spContext);
		if (FAILED(hr))
			return FALSE;

		if (!Initialize(spContext))
			return FALSE;

		m_bHeadersSent = TRUE;

		return TRUE;
	}

	// Returns a pointer to the IHttpServerContext interface for the current request.
	__checkReturn HRESULT GetServerContext(__deref_out_opt IHttpServerContext ** ppOut) throw()
	{
		return m_spServerContext.CopyTo(ppOut);
	}

	void Detach()
	{
		m_spServerContext.Release();
		HaveSentHeaders(TRUE);
	}
	// Call this function to set buffering options for the response.
	//
	// This function allows you to turn buffering on or off, and to set a size limit
	// on the amount of data that will be buffered before being sent to the client.
	// 
	// When you turn off buffering, the current contents of the buffer will be sent to the client.
	// If you need to clear the buffer without sending the contents to the client, call ClearContent instead.
	//
	// When the size of the buffer is reduced below the current size of the buffered content,
	// the entire buffer is flushed.
	void SetBufferOutput(__in BOOL bBufferOutput, __in DWORD dwBufferLimit=ATL_ISAPI_BUFFER_SIZE) throw()
	{
		if (m_bBufferOutput && !bBufferOutput)
		{
			// before turning off buffering, flush
			// the current contents
			Flush();
		}
		SetBufferLimit(dwBufferLimit);

		m_bBufferOutput = bBufferOutput;
	}

	// Call this function to determine whether data written to the response object is being buffered or not.
	// Returns TRUE if output is being buffered, FALSE otherwise.
	__checkReturn BOOL GetBufferOutput() throw()
	{
		return m_bBufferOutput;
	}

	// Call this function to determine whether the response headers have been sent
	// Returns TRUE if headers have been sent, FALSE otherwise.
	__checkReturn BOOL HaveSentHeaders() throw()
	{
		return m_bHeadersSent;
	}

	// Call this function to override the m_bHeadersSent state.  This is useful
	// when you want child handlers (e.g. from an include or subhandler) to send the headers
	void HaveSentHeaders(__in BOOL bSent) throw()
	{
		m_bHeadersSent = bSent;
	}

	// Call this function to set a size limit on the amount of data buffered by the reponse object.
	// When the size of the buffer is reduced below the current size of the buffered content,
	// the entire buffer is flushed.
	// See GetBufferLimit.
	void SetBufferLimit(__in DWORD dwBufferLimit) throw()
	{
		if (m_bBufferOutput)
		{
			if (m_strContent.GetLength() >= dwBufferLimit)
			{
				// new buffer limit is less than the
				// size currently buffered.  So flush
				// the current buffer
				Flush();
			}
		}
		m_dwBufferLimit = dwBufferLimit;
	}

	// Returns the current size limit of the buffer in bytes.
	// See SetBufferLimit.
	DWORD GetBufferLimit() throw()
	{
		return m_dwBufferLimit;
	}

	// Returns the current value of the Content-Type header if present, otherwise returns NULL.
	LPCSTR GetContentType() throw()
	{
		// return the content type from the
		// header collection if any
		_ATLTRY
		{
			CStringA strKey("Content-Type");

			int nIndex = m_headers.FindKey(strKey);
			if (nIndex >= 0)
				return m_headers.GetValueAt(nIndex);
		}
		_ATLCATCHALL()
		{
		}
		return NULL;
	}

	// Call this function to set the Content-Type of the HTTP response.
	// Examples of common MIME content types include text/html and text/plain.
	BOOL SetContentType(__in_opt LPCSTR szContentType) throw()
	{
		_ATLTRY
		{
			if (!m_headers.SetAt("Content-Type", szContentType))
				return m_headers.Add("Content-Type", szContentType);
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
	}

	// Call this function to set the HTTP status code of the response.
	// If not set explicitly, the default status code is 200 (OK).
	// See GetStatusCode.
	void SetStatusCode(__in int nCode) throw()
	{
		m_nStatusCode = nCode;
	}

	// Returns the current HTTP status code of the response.
	// See SetStatusCode.
	int GetStatusCode() throw()
	{
		return m_nStatusCode;
	}

	// Call this function to set the Cache-Control http header of the response.
	// Examples of common Cache-Control header values: public, private, max-age=delta-seconds
	BOOL SetCacheControl(__in_opt LPCSTR szCacheControl) throw()
	{
		_ATLTRY
		{
			if (!m_headers.SetAt("Cache-Control", szCacheControl))
				return m_headers.Add("Cache-Control", szCacheControl);
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
	}

	// Call this function to set the Expires HTTP header to the absolute date/time
	// specified in the stExpires parameter
	BOOL SetExpiresAbsolute(__in const SYSTEMTIME& stExpires) throw()
	{
		_ATLTRY
		{
			CStringA strExpires;
			SystemTimeToHttpDate(stExpires, strExpires);

			if (!m_headers.SetAt("Expires", strExpires))
				return m_headers.Add("Expires", strExpires);
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
	}

#ifndef _WIN32_WCE
	// Call this function to set the Expires HTTP header to a relative date/time
	// value specified in minutes;
	BOOL SetExpires(__in long lMinutes) throw()
	{
		CFileTime ft;
		GetSystemTimeAsFileTime(&ft);

		// add the specified number of minutes
		ft += CFileTimeSpan(((ULONGLONG)lMinutes)*60*10000000);

		SYSTEMTIME st;
		FileTimeToSystemTime(&ft, &st);
		return SetExpiresAbsolute(st);
	}
#endif // _WIN32_WCE

	// Call this function to set whether or not to output to client.
	// Intended primarily for HEAD requests
	BOOL SetWriteToClient(__in BOOL bSendOutput) throw()
	{
		m_bSendOutput = bSendOutput;
		return TRUE;
	}

	// Call this function to determine whether or not the data is
	// sent to the client.  Intended primarily for HEAD requests
	BOOL GetWriteToClient() throw()
	{
		return m_bSendOutput;
	}

	// Call this function to write data to the response object.
	//
	// Returns S_OK on success, E_INVALIDARG or E_FAIL on failure.
	//
	// See WriteClient for comments on buffering.
	//
	// szOut    A pointer to the first byte of the data to be written.
	//
	// nLen     The number of bytes to write. If this parameter is -1,
	//          szOut is assumed to be a nul-terminated string and the
	//          whole string will be written.
	//
	// pdwWritten   A DWORD pointer that can be used to get the number of bytes written.
	//              This parameter can be NULL.
	__checkReturn HRESULT WriteStream(__in_z LPCSTR szOut, __in int nLen, __out_opt DWORD *pdwWritten)
	{
		ATLASSUME(m_spServerContext != NULL);

		if (pdwWritten)
			*pdwWritten = 0;
		if (nLen == -1)
		{
			if (!szOut)
				return E_INVALIDARG;
			nLen = (int) strlen(szOut);
		}
		BOOL bRet = WriteLen(szOut, nLen);
		if (!bRet)
		{
			return AtlHresultFromLastError();
		}
		if (pdwWritten)
			*pdwWritten = nLen;
		return S_OK;
	}

	// Call this function to write data to the response object.
	//
	// Returns TRUE on success. FALSE on failure.
	//
	// If buffering is disabled, data is written directly to the client.
	// If buffering is enabled, this function attempts to write to the buffer.
	// If the buffer is too small to contain its existing data and the new data,
	// the current contents of the buffer are flushed.
	// If the buffer is still too small to contain the new data, that data is written
	// directly to the client. Otherwise the new data is written to the buffer.
	//
	// Any headers that have been set in the response will be sent just before the 
	// data is written to the client if no headers have been sent up to that point.
	//
	// szOut    A pointer to the first byte of the data to be written.
	//
	// nLen     The number of bytes to write.
	__checkReturn BOOL WriteLen(__in_ecount(dwLen) LPCSTR szOut, __in DWORD dwLen) throw()
	{
		ATLASSUME(m_spServerContext != NULL);
		if (!szOut)
			return FALSE;

		if (m_bBufferOutput)
		{
			if (m_strContent.GetLength()+dwLen >= m_dwBufferLimit)
			{
				if (!Flush())
					return FALSE;
			}
			if (dwLen <= m_dwBufferLimit)
				return m_strContent.Append(szOut, dwLen);
		}
		BOOL bRet = SendHeadersInternal();

		if (bRet && m_bSendOutput)
			bRet = m_spServerContext->WriteClient((void *) szOut, &dwLen);

		return bRet;
	}

	// Call this function to redirect the client to a different resource.
	//
	// Returns TRUE on success, FALSE on failure.
	//
	// szURL        A nul-terminated string specifying the resource the client should navigate to. 
	//
	// statusCode   An HTTP status code from the HTTP_REDIRECT enumeration describing the reason
	//              for the redirection.
	//
	// bSendBody    Specifies whether to generate and send a response body with the headers.
	//
	//  This function allows (and RFC 2616 encourages) a response body to be sent
	//  with the following redirect types:
	//      HTTP_REDIRECT_MOVED
	//      HTTP_REDIRECT_FOUND
	//      HTTP_REDIRECT_SEE_OTHER
	//      HTTP_REDIRECT_TEMPORARY_REDIRECT
	// No body will be sent with other redirect types.
	//
	// The response body contains a short hypertext note with a hyperlink to the new resource.
	// A meta refresh tag is also included to allow browsers to automatically redirect
	// the user to the resource even if they don't understand the redirect header.
	//
	// See RFC 2616 section 10.3 for more information on redirection.
	BOOL Redirect(__in LPCSTR szUrl, __in HTTP_REDIRECT statusCode=HTTP_REDIRECT_MOVED, __in BOOL bSendBody=TRUE) throw(...)
	{
		CStringA strBody;
		LPCSTR szBody = NULL;
		if (bSendBody &&
			(HTTP_REDIRECT_MOVED == statusCode  || HTTP_REDIRECT_FOUND == statusCode ||
			HTTP_REDIRECT_SEE_OTHER == statusCode || HTTP_REDIRECT_TEMPORARY_REDIRECT == statusCode))
		{
			_ATLTRY
			{
			ATLENSURE(szUrl!=NULL);
			strBody.Format(
				"<html>\r\n"
				"<head>\r\n"
				"<meta http-equiv=\"refresh\" content=\"0; url=%s\">\r\n"
				"</head>\r\n"
				"<body>Please use the following link to access this resource:"
				" <a href=\"%s\">%s</a>\r\n"
				"</body>\r\n"
				"</html>\r\n",
				szUrl, szUrl, szUrl);
			}
			_ATLCATCHALL()
			{
				return FALSE;
			}
			szBody = (LPCSTR) strBody;
		}
		return Redirect(szUrl, szBody, statusCode);
	}

	// Call this function to redirect the client to a different resource.
	//
	// Returns TRUE on success, FALSE on failure.
	//
	// szURL        A nul-terminated string specifying the resource the client should navigate to.
	//
	// szBody       A nul-terminated string containing the body of the response to be sent to the client.
	//
	// statusCode   An HTTP status code from the HTTP_REDIRECT enumeration describing the reason
	//              for the redirection.
	//
	//  This function allows (and RFC 2616 encourages) a response body to be sent
	//  with the following redirect types:
	//      HTTP_REDIRECT_MOVED
	//      HTTP_REDIRECT_FOUND
	//      HTTP_REDIRECT_SEE_OTHER
	//      HTTP_REDIRECT_TEMPORARY_REDIRECT
	// No body will be sent with other redirect types.
	//
	// The response body should contain a short hypertext note with a hyperlink to the new resource.
	// You can include a meta refresh tag to allow browsers to automatically redirect
	// the user to the resource even if they don't understand the redirect header.
	//
	// See RFC 2616 section 10.3 for more information on redirection.
	BOOL Redirect(__in LPCSTR szUrl, __in LPCSTR szBody, __in HTTP_REDIRECT statusCode=HTTP_REDIRECT_MOVED) throw()
	{
		SetStatusCode(statusCode);
		AppendHeader("Location", szUrl);

		_ATLTRY
		{
			if (!SendHeadersInternal())
				return FALSE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}

		if (szBody &&
			(HTTP_REDIRECT_MOVED == statusCode  || HTTP_REDIRECT_FOUND == statusCode ||
			HTTP_REDIRECT_SEE_OTHER == statusCode || HTTP_REDIRECT_TEMPORARY_REDIRECT == statusCode))
		{
			Write(szBody);
			return Flush();
		}
		return TRUE;
	}

	// Call this function to append a header to the collection of HTTP headers managed by this object.
	//
	// szName   A nul-teminated string containing the name of the HTTP header.
	//
	// szValue  A nul-teminated string containing the value of the HTTP header.
	BOOL AppendHeader(__in LPCSTR szName, __in_opt LPCSTR szValue) throw()
	{
		ATLASSERT(szName);
		BOOL bRet = FALSE;
		_ATLTRY
		{
			bRet = m_headers.Add(szName, szValue);
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
		return bRet;
	}

#ifndef _WIN32_WCE

	// Call this function to add a Set-Cookie header to the collection of HTTP headers managed by this object.
	// 
	// pCookie      A pointer to a CCookie object describing the cookie to be sent to the client.
	BOOL AppendCookie(__in const CCookie *pCookie)
	{
		ATLENSURE(pCookie);
		return AppendCookie((const CCookie&)*pCookie);
	}

	// Call this function to add a Set-Cookie header to the collection of HTTP headers managed by this object.
	// 
	// cookie       A reference to a CCookie object describing the cookie to be sent to the client.
	BOOL AppendCookie(__in const CCookie& cookie) throw()
	{
		CHAR szCookie[ATL_MAX_COOKIE_LEN];
		DWORD dwBuffSize = ATL_MAX_COOKIE_LEN;
		BOOL bRet = FALSE;
		bRet = cookie.Render(szCookie, &dwBuffSize);
		if (bRet)
		{
			_ATLTRY
			{
				bRet = m_headers.Add("Set-Cookie", szCookie);
			}
			_ATLCATCHALL()
			{
				bRet = FALSE;
				dwBuffSize = 0;
			}
		}

		if (!bRet && dwBuffSize > 0 && dwBuffSize+1 > dwBuffSize)    //static buffer wasn't big enough.
		{   
			//We'll have to try dynamically allocating it
			//allocate a buffer
			CAutoVectorPtr<CHAR> sz;
			if (sz.Allocate(dwBuffSize+1))
			{
				DWORD dwSizeNew = dwBuffSize + 1;
				if (cookie.Render(sz, &dwSizeNew))
				{
					_ATLTRY
					{
						bRet = m_headers.Add("Set-Cookie", (const char *) sz);
					}
					_ATLCATCHALL()
					{
						bRet = FALSE;
					}
				}
			}
		}
		return bRet;
	}

	// Call this function to add a Set-Cookie header to the collection of HTTP headers managed by this object.
	// 
	// szName       A nul-terminated string containing the name of the cookie to be sent to the client.
	//
	// szValue      A nul-terminated string containing the value of the cookie to be sent to the client.
	BOOL AppendCookie(__in LPCSTR szName, __in_opt LPCSTR szValue) throw()
	{
		ATLASSERT(szName);
		BOOL bRet = FALSE;
		_ATLTRY
		{
			CCookie c(szName, szValue);
			bRet = AppendCookie(c);
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
		return bRet;
	}

	// Call this function to add a Set-Cookie header that removes a cookie value
	// to the collection of HTTP headers managed by this object.
	// 
	// szName       A nul-terminated string containing the name of the cookie to be deleted
	BOOL DeleteCookie(__in LPCSTR szName) throw()
	{
		ATLASSERT(szName);
		BOOL bRet = FALSE;
		_ATLTRY
		{
			CCookie cookie(szName, "");
			bRet=cookie.SetMaxAge(0);
			if(bRet)
			{
				bRet = AppendCookie(cookie);
			}
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
		return bRet;

	}

#endif // _WIN32_WCE

	// Call this function to clear the collection of HTTP response headers maintained by this object.
	//
	// Note that clearing the headers includes removing all cookies associated with the response
	// object. Cookies are sent to the client as Set-Cookie HTTP headers.
	void ClearHeaders() throw()
	{
		m_headers.RemoveAll();
	}

	// Call this function to clear theresponse buffer without sending the contents to the client.
	// If you need to empty the buffer but you do want the current contents sent to the client, call Flush instead. 
	void ClearContent() throw()
	{
		m_strContent.Empty();
	}

	// Call this function to send the current headers associated with this object to the client.
	// 
	// Returns TRUE on success, FALSE on failure.
	//
	// The response headers are sent to the client using the current status code for the
	// response object. See SetStatusCode and GetStatusCode.
	BOOL SendHeadersInternal(__in BOOL fKeepConn=FALSE) 
	{
		if (m_bHeadersSent)
			return TRUE;

		ATLENSURE(m_spServerContext != NULL);

		CStringA strHeaders;
		RenderHeaders(strHeaders);

		BOOL bRet = FALSE;
		_ATLTRY
		{
			if (m_nStatusCode == 200)
			{
				bRet = m_spServerContext->SendResponseHeader(strHeaders, "200 OK", fKeepConn);
				if (bRet)
				{
					m_bHeadersSent = TRUE;
				}
				return bRet;
			}

			CFixedStringT<CStringA, 256> strStatus;
			CDefaultErrorProvider prov;
			GetStatusHeader(strStatus, m_nStatusCode, SUBERR_NONE, &prov);
			bRet = m_spServerContext->SendResponseHeader(strHeaders, strStatus, fKeepConn);
			if (bRet)
			{
				m_bHeadersSent = TRUE;
			}
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
		return bRet;
	}

	// Call this function to get a string containing all the HTTP headers associated with
	// this object in a format suitable for sending to a client.
	//
	// strHeaders   A CStringA reference to which will be appended the HTTP headers.
	void RenderHeaders(CStringA& strHeaders) throw()
	{
		_ATLTRY
		{
			strHeaders.Preallocate(::ATL::AtlMultiplyThrow(m_headers.GetSize(),64));
			for (int i=0; i<m_headers.GetSize(); i++)
			{
				strHeaders += m_headers.GetKeyAt(i);
				strHeaders.Append(": ", sizeof(": ")-1);
				strHeaders += m_headers.GetValueAt(i);
				strHeaders.Append("\r\n", sizeof("\r\n")-1);
			}
			strHeaders.Append("\r\n", sizeof("\r\n")-1);
		}
		_ATLCATCHALL()
		{
		}
	}

	// Call this function to empty the response buffer and send its current
	// contents to the client.
	//
	// Returns S_OK on success, or an error HRESULT on failure.
	HRESULT FlushStream()
	{
		if (!Flush())
			return AtlHresultFromLastError();
		return S_OK;
	}

	// Call this function to empty the response buffer and send its current
	// contents to the client.
	//
	// Returns TRUE on success, or FALSE on failure.
	//
	// Any headers that have been set in the response will be sent just before the 
	// data is written to the client if no headers have been sent up to that point.
	BOOL Flush(BOOL bFinal=FALSE) throw()
	{
		if (!m_spServerContext)
			return FALSE;

		BOOL bRet = TRUE;

		_ATLTRY
		{
			// if the headers haven't been sent,
			// send them now

			if (!m_bHeadersSent)
			{
				char szProtocol[ATL_URL_MAX_URL_LENGTH];
				DWORD dwProtocolLen = sizeof(szProtocol);

				if (bFinal && m_bBufferOutput && m_dwBufferLimit==ULONG_MAX)
				{
					if (m_spServerContext->GetServerVariable("SERVER_PROTOCOL", szProtocol, &dwProtocolLen) &&
						!strcmp(szProtocol, "HTTP/1.0"))
						AppendHeader("Connection", "Keep-Alive");
					Checked::itoa_s(m_strContent.GetLength(), szProtocol, _countof(szProtocol), 10);
					AppendHeader("Content-Length", szProtocol);
					bRet = SendHeadersInternal(TRUE);
				}
				else
					bRet = SendHeadersInternal();
			}
			if (m_bBufferOutput)
			{
				DWORD dwLen = 0;

				dwLen = m_strContent.GetLength();
				if (dwLen)
				{
					if (m_bSendOutput && 
						m_spServerContext->WriteClient((void *) (LPCSTR) m_strContent, &dwLen) != TRUE)
					{
						m_strContent.Empty();
						return FALSE;
					}
					m_strContent.Empty();
				}
			}
		} // _ATLTRY
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
		return bRet;
	}

	// Call this function to clear the response object of any headers
	// and the contents of the buffer.
	void ClearResponse() throw()
	{
		m_strContent.Empty();
		m_headers.RemoveAll();
	}

	BOOL AsyncPrep(__in BOOL fKeepConn=FALSE) throw()
	{
		ATLASSUME(m_spServerContext != NULL);

		return SendHeadersInternal(fKeepConn);
	}

	BOOL AsyncFlush() throw()
	{
		ATLASSUME(m_spServerContext != NULL);

		BOOL bRet = SendHeadersInternal();

		if (bRet && m_bBufferOutput)
		{
			DWORD dwLen = 0;

			dwLen = m_strContent.GetLength();
			if (dwLen)
			{
				_ATLTRY
				{
					if (m_spServerContext->AsyncWriteClient((void *) (LPCSTR) m_strContent, &dwLen) != TRUE)
					{
						bRet = FALSE;
					}
				}
				_ATLCATCHALL()
				{
					bRet = FALSE;
				}
			}
		}

		return bRet;
	}

	BOOL TransmitFile(__in HANDLE hFile, __in LPCSTR szContentType="text/plain") throw()
	{
		ATLASSUME(m_spServerContext != NULL);
		ATLASSERT(hFile != NULL && hFile != INVALID_HANDLE_VALUE);

		SetContentType(szContentType);

		if (m_strContent.GetLength())
			if (!Flush())
				return FALSE;

		BOOL bRet = SendHeadersInternal();
		if (bRet)
		{
			_ATLTRY
			{
				bRet = m_spServerContext->TransmitFile(hFile, NULL, NULL, NULL, 
					0, 0, NULL, 0, NULL, 0, HSE_IO_ASYNC 
#ifndef _WIN32_WCE
					| HSE_IO_NODELAY
#endif // _WIN32_WCE
					);
			}
			_ATLCATCHALL()
			{
				bRet = FALSE;
			}
		}

		return bRet;
	}
}; // class CHttpResponse

#ifndef _WIN32_WCE


#define ATLS_FLAG_NONE      0
#define ATLS_FLAG_ASYNC     1   // handler might do some async handling

// push_macro/pop_macro doesn't work in a template definition.
#pragma push_macro("new")
#undef new
template <class T>
class PerThreadWrapper : public CComObjectNoLock<T>
{
public:
	void *operator new(size_t /*size*/, void *p) throw()
	{
		return p;
	}

	void operator delete(void * /*p*/) throw()
	{
	}

	STDMETHOD_(ULONG, Release)() throw()
	{
		ULONG l = InternalRelease();
		if (l == 0)
		{
			T *pT = static_cast<T*>(this);
			ATLASSERT(pT->m_spExtension != NULL);
			CIsapiWorker *pWorker = pT->m_spExtension->GetThreadWorker();
			ATLASSERT(pWorker);

			delete this;
			if(pWorker)
			{
				HeapFree(pWorker->m_hHeap, HEAP_NO_SERIALIZE, this);
			}
		}
		return l;
	}
};

template <typename THandler>
inline BOOL CreateRequestHandlerSync(__in IIsapiExtension *pExtension, __deref_out_opt IUnknown **ppOut) 
{
	ATLENSURE(pExtension);
	ATLENSURE(ppOut);

	CIsapiWorker *pWorker = pExtension->GetThreadWorker();
	ATLENSURE(pWorker);
	void *pv = HeapAlloc(pWorker->m_hHeap, HEAP_NO_SERIALIZE, sizeof(PerThreadWrapper<THandler>));
	if (!pv)
		return FALSE;

	PerThreadWrapper<THandler> *pHandler = new(pv) PerThreadWrapper<THandler>;
	*ppOut = static_cast<IRequestHandler *>(pHandler);
	pHandler->m_spExtension = pExtension;

	(*ppOut)->AddRef();

	return TRUE;
}
#pragma pop_macro("new")

#define DECLARE_ASYNC_HANDLER() \
	static DWORD GetHandlerFlags() \
	{ \
		return ATLS_FLAG_ASYNC; \
	} \
	DWORD GetAsyncFlags() \
	{ \
		return ATLSRV_INIT_USEASYNC; \
	}

#define DECLARE_ASYNC_HANDLER_EX() \
	static DWORD GetHandlerFlags() \
	{ \
		return ATLS_FLAG_ASYNC; \
	} \
	DWORD GetAsyncFlags() \
	{ \
		return (ATLSRV_INIT_USEASYNC|ATLSRV_INIT_USEASYNC_EX); \
	}

#endif // _WIN32_WCE

template <typename THandler>
class IRequestHandlerImpl : public IRequestHandler
{
public:
	HINSTANCE m_hInstHandler;
	CComPtr<IServiceProvider> m_spServiceProvider;
	CComPtr<IHttpServerContext> m_spServerContext;
	CComPtr<IIsapiExtension> m_spExtension;
	DWORD m_dwAsyncFlags;

	IRequestHandlerImpl()
		:m_hInstHandler(NULL)
	{
		m_dwAsyncFlags = 0;
	}
	virtual ~IRequestHandlerImpl()
	{
	}

	HTTP_CODE GetFlags(__out DWORD *pdwStatus)
	{
		ATLASSERT(pdwStatus);
		THandler *pT = static_cast<THandler *>(this);

		*pdwStatus = pT->GetAsyncFlags();
		if (pT->CachePage())
			*pdwStatus |= ATLSRV_INIT_USECACHE;

#ifdef _DEBUG
		if (*pdwStatus & (ATLSRV_INIT_USEASYNC|ATLSRV_INIT_USEASYNC_EX))
			ATLASSERT(pT->GetHandlerFlags() & ATLS_FLAG_ASYNC);
#endif

		return HTTP_SUCCESS;
	}

	HTTP_CODE InitializeHandler(__in AtlServerRequest *pRequestInfo, __in IServiceProvider *pProvider)
	{
		ATLENSURE(pRequestInfo != NULL);
		ATLENSURE(pProvider != NULL);
		ATLENSURE(pRequestInfo->hInstDll != NULL);
		ATLENSURE(pRequestInfo->pServerContext != NULL);

		// Initialize our internal references to required services
		m_hInstHandler = pRequestInfo->hInstDll;
		m_spServiceProvider = pProvider;
		m_spServerContext = pRequestInfo->pServerContext;

		return HTTP_SUCCESS;
	}

	HTTP_CODE InitializeChild(__in AtlServerRequest *pRequestInfo, __in IServiceProvider *pProvider, IHttpRequestLookup * /*pLookup*/)
	{
		return InitializeHandler(pRequestInfo, pProvider);
	}

	void UninitializeHandler()
	{
	}

	HTTP_CODE HandleRequest(
		AtlServerRequest* /*pRequestInfo*/,
		IServiceProvider* /*pServiceProvider*/)
	{
		return HTTP_SUCCESS;
	}

	DWORD GetAsyncFlags()
	{
		return m_dwAsyncFlags;
	}

	void SetAsyncFlags(__in DWORD dwAsyncFlags)
	{
		ATLASSERT((dwAsyncFlags & ~(ATLSRV_INIT_USEASYNC|ATLSRV_INIT_USEASYNC_EX)) == 0);
		m_dwAsyncFlags = dwAsyncFlags;
	}

	BOOL CachePage()
	{
		return FALSE;
	}

	static DWORD GetHandlerFlags()
	{
		return ATLS_FLAG_NONE;
	}

	// Used to create new instance of this object. A pointer to this
	// function is stored in the handler map in user's code.
	static BOOL CreateRequestHandler(__in IIsapiExtension *pExtension, __deref_out_opt IUnknown **ppOut)
	{
		ATLASSERT(ppOut != NULL);
		if (ppOut == NULL)
			return false;

		*ppOut = NULL;

		if (THandler::GetHandlerFlags() & ATLS_FLAG_ASYNC)
		{
			THandler *pHandler = NULL;
			ATLTRY(pHandler = new CComObjectNoLock<THandler>);
			if (!pHandler)
				return FALSE;
			*ppOut = static_cast<IRequestHandler *>(pHandler);
			pHandler->m_spExtension = pExtension;
			(*ppOut)->AddRef();
		}
		else
		{
			if (!CreateRequestHandlerSync<THandler>(pExtension, ppOut))
				return FALSE;
		}

		return TRUE;
	}

	// Used to initialize the class
	// function is stored in the handler map in user's code.
	static BOOL InitRequestHandlerClass(IHttpServerContext *pContext, IIsapiExtension *pExt)
	{
		(pContext); // unused
		(pExt); // unused
		return TRUE;
	}

	// Used to uninitialize the class
	// function is stored in the handler map in user's code.
	static void UninitRequestHandlerClass()
	{
		return;
	}
};

#ifndef _WIN32_WCE

struct CRequestStats
{
	long m_lTotalRequests;
	long m_lFailedRequests;
	__int64 m_liTotalResponseTime;
	long m_lAvgResponseTime;
	long m_lCurrWaiting;
	long m_lMaxWaiting;
	long m_lActiveThreads;

	CRequestStats() throw()
	{
		m_lTotalRequests = 0;
		m_lFailedRequests = 0;
		m_liTotalResponseTime = 0;
		m_lAvgResponseTime = 0;
		m_lCurrWaiting = 0;
		m_lMaxWaiting = 0;
		m_lActiveThreads = 0;
	}

	void RequestHandled(__in AtlServerRequest *pRequestInfo, __in BOOL bSuccess)
	{
		ATLENSURE(pRequestInfo);

		InterlockedIncrement(&m_lTotalRequests);
		if (!bSuccess)
			InterlockedIncrement(&m_lFailedRequests);

		long lTicks;

#ifndef ATL_NO_MMSYS
		lTicks = (long) (timeGetTime() - pRequestInfo->dwStartTicks);
#else
		lTicks = (long) (GetTickCount() - pRequestInfo->dwStartTicks);
#endif
		__int64 liTotalResponseTime = Add64(&m_liTotalResponseTime, lTicks);
		long lAv = (long) (liTotalResponseTime / m_lTotalRequests);
		InterlockedExchange(&m_lAvgResponseTime, lAv);

		InterlockedDecrement(&m_lActiveThreads);
	}

	long GetTotalRequests() throw()
	{
		return m_lTotalRequests;
	}

	long GetFailedRequests() throw()
	{
		return m_lFailedRequests;
	}

	long GetAvgResponseTime() throw()
	{
		return m_lAvgResponseTime;
	}

	void OnRequestReceived() throw()
	{
		long nCurrWaiting = InterlockedIncrement(&m_lCurrWaiting);
		AtlInterlockedUpdateMax(nCurrWaiting, &m_lMaxWaiting);
	}

	void OnRequestDequeued() throw()
	{
		InterlockedDecrement(&m_lCurrWaiting);
		InterlockedIncrement(&m_lActiveThreads);
	}

	long GetCurrWaiting() throw()
	{
		return m_lCurrWaiting;
	}

	long GetMaxWaiting() throw()
	{
		return m_lMaxWaiting;
	}

	long GetActiveThreads() throw()
	{
		return m_lActiveThreads;
	}

private:
	// not actually atomic, but it will add safely.

	// the returned value is not 100% guaranteed to be
	// correct, but should be correct more often than
	// just reading the __int64
	// the 2 cases where the return value will not be
	// a valid result value from an add are:
	// * multiple threads wrap the low part in rapid succession
	// * different threads are adding values with different signs

	// this is good enough for our use in RequestHandled -
	// we always add positive values and we shouldn't wrap 32-bits often
	inline __int64 Add64(__inout __int64* pn, long nAdd)
	{
		ATLENSURE(pn != NULL);

		long* pnLow = (long*)(LPBYTE(pn) + offsetof(LARGE_INTEGER, LowPart));
		long* pnHigh = (long*)(LPBYTE(pn) + offsetof(LARGE_INTEGER, HighPart));

		long nOrigLow = InterlockedExchangeAdd(pnLow, nAdd);
		long nNewLow = nOrigLow + nAdd;
		long nNewHigh = *pnHigh;
		if (nAdd > 0 && nNewLow < nOrigLow)
			nNewHigh = InterlockedIncrement(pnHigh);
		else if (nAdd < 0 && nNewLow > nOrigLow)
			nNewHigh = InterlockedDecrement(pnHigh);

		LARGE_INTEGER li;
		li.LowPart = nNewLow;
		li.HighPart = nNewHigh;
		return li.QuadPart;
	}
};

class CStdRequestStats : public CRequestStats
{

public:
	HRESULT Initialize() throw()
	{
		return S_OK;
	}

	void Uninitialize() throw()
	{
	}
};

#define PERF_REQUEST_OBJECT 100
 
struct CPerfRequestStatObject : public CPerfObject,
	public CRequestStats
{
	DECLARE_PERF_CATEGORY_EX(PERF_REQUEST_OBJECT, IDS_PERFMON_REQUEST, IDS_PERFMON_REQUEST_HELP, PERF_DETAIL_NOVICE, 0, sizeof(CPerfRequestStatObject), MAX_PATH, -1);
	BEGIN_COUNTER_MAP(CPerfRequestStatObject)
		DEFINE_COUNTER(m_lTotalRequests, IDS_PERFMON_REQUEST_TOTAL, IDS_PERFMON_REQUEST_TOTAL_HELP, PERF_COUNTER_RAWCOUNT, -1)
		DEFINE_COUNTER(m_lFailedRequests, IDS_PERFMON_REQUEST_FAILED, IDS_PERFMON_REQUEST_FAILED_HELP, PERF_COUNTER_RAWCOUNT, -1)
		DEFINE_COUNTER(m_lTotalRequests, IDS_PERFMON_REQUEST_RATE, IDS_PERFMON_REQUEST_RATE_HELP, PERF_COUNTER_COUNTER, -1)
		DEFINE_COUNTER(m_lAvgResponseTime, IDS_PERFMON_REQUEST_AVG_RESPONSE_TIME, IDS_PERFMON_REQUEST_AVG_RESPONSE_TIME_HELP, PERF_COUNTER_RAWCOUNT, -1)
		DEFINE_COUNTER(m_lCurrWaiting, IDS_PERFMON_REQUEST_CURR_WAITING, IDS_PERFMON_REQUEST_CURR_WAITING_HELP, PERF_COUNTER_RAWCOUNT, -1)
		DEFINE_COUNTER(m_lMaxWaiting, IDS_PERFMON_REQUEST_MAX_WAITING, IDS_PERFMON_REQUEST_MAX_WAITING_HELP, PERF_COUNTER_RAWCOUNT, -1)
		DEFINE_COUNTER(m_lActiveThreads, IDS_PERFMON_REQUEST_ACTIVE_THREADS, IDS_PERFMON_REQUEST_ACTIVE_THREADS, PERF_COUNTER_RAWCOUNT, -1)
	END_COUNTER_MAP()
};

class CRequestPerfMon : public CPerfMon
{
public:
	BEGIN_PERF_MAP(_T("ATL Server:Request"))
		CHAIN_PERF_CATEGORY(CPerfRequestStatObject)
	END_PERF_MAP()
};

class CPerfMonRequestStats
{
	CRequestPerfMon m_PerfMon;
	CPerfRequestStatObject * m_pPerfObjectInstance;
	CPerfRequestStatObject * m_pPerfObjectTotal;

public:
	CPerfMonRequestStats() throw()
	{
		m_pPerfObjectInstance = NULL;
		m_pPerfObjectTotal = NULL;
	}

	HRESULT Initialize() throw()
	{
		HRESULT hr;

		m_pPerfObjectInstance = NULL;
		m_pPerfObjectTotal = NULL;

		hr = m_PerfMon.Initialize();
		if (SUCCEEDED(hr))
		{
			CPerfLock lock(&m_PerfMon);
			if (FAILED(hr = lock.GetStatus()))
			{
				return hr;
			}

			HINSTANCE hInst = _AtlBaseModule.GetModuleInstance();
			WCHAR szName[MAX_PATH];
			if (GetModuleFileNameW(hInst, szName, MAX_PATH) == 0)
			{
				return E_FAIL;
			}
			szName[MAX_PATH-1] = 0;

			hr = m_PerfMon.CreateInstanceByName(L"_Total", &m_pPerfObjectTotal);
			if (FAILED(hr))
			{
				return hr;
			}

			hr = m_PerfMon.CreateInstanceByName(szName, &m_pPerfObjectInstance);
			if (FAILED(hr))
			{
				m_PerfMon.ReleaseInstance(m_pPerfObjectTotal);
				m_pPerfObjectTotal = NULL;
				return hr;
			}
		}

		return hr;
	}

	void Uninitialize() throw()
	{
		if (m_pPerfObjectInstance != NULL)
			m_PerfMon.ReleaseInstance(m_pPerfObjectInstance);
		if (m_pPerfObjectTotal != NULL)
			m_PerfMon.ReleaseInstance(m_pPerfObjectTotal);

		m_pPerfObjectInstance = NULL;
		m_pPerfObjectTotal = NULL;

		m_PerfMon.UnInitialize();
	}

	void RequestHandled(__in AtlServerRequest *pRequestInfo, __in BOOL bSuccess) throw()
	{
		if (m_pPerfObjectInstance != NULL)
			m_pPerfObjectInstance->RequestHandled(pRequestInfo, bSuccess);
		if (m_pPerfObjectTotal != NULL)
			m_pPerfObjectTotal->RequestHandled(pRequestInfo, bSuccess);
	}

	long GetTotalRequests() throw()
	{
		if (m_pPerfObjectInstance != NULL)
			return m_pPerfObjectInstance->GetTotalRequests();

		return 0;
	}

	long GetFailedRequests() throw()
	{
		if (m_pPerfObjectInstance != NULL)
			return m_pPerfObjectInstance->GetFailedRequests();

		return 0;
	}

	long GetAvgResponseTime() throw()
	{
		if (m_pPerfObjectInstance != NULL)
			return m_pPerfObjectInstance->GetAvgResponseTime();

		return 0;
	}

	void OnRequestReceived() throw()
	{
		if (m_pPerfObjectInstance != NULL)
			m_pPerfObjectInstance->OnRequestReceived();
		if (m_pPerfObjectTotal != NULL)
			m_pPerfObjectTotal->OnRequestReceived();
	}

	void OnRequestDequeued() throw()
	{
		if (m_pPerfObjectInstance != NULL)
			m_pPerfObjectInstance->OnRequestDequeued();
		if (m_pPerfObjectTotal != NULL)
			m_pPerfObjectTotal->OnRequestDequeued();
	}

	long GetCurrWaiting() throw()
	{
		if (m_pPerfObjectInstance != NULL)
			return m_pPerfObjectInstance->GetCurrWaiting();

		return 0;
	}

	long GetMaxWaiting() throw()
	{
		if (m_pPerfObjectInstance != NULL)
			return m_pPerfObjectInstance->GetMaxWaiting();

		return 0;
	}

	long GetActiveThreads() throw()
	{
		if (m_pPerfObjectInstance != NULL)
			return m_pPerfObjectInstance->GetActiveThreads();

		return 0;
	}
};

class CNoRequestStats
{
protected:

public:

	HRESULT Initialize() throw()
	{
		return S_OK;
	}

	void Uninitialize() throw()
	{
	}

	void RequestHandled(AtlServerRequest * /*pRequestInfo*/, BOOL /*bSuccess*/) throw()
	{
	}

	long GetTotalRequests() throw()
	{
		return 0;
	}

	long GetFailedRequests() throw()
	{
		return 0;
	}

	long GetAvgResponseTime() throw()
	{
		return 0;
	}

	void OnRequestReceived() throw()
	{
	}

	void OnRequestDequeued() throw()
	{
	}

	long GetCurrWaiting() throw()
	{
		return 0;
	}

	long GetMaxWaiting() throw()
	{
		return 0;
	}

	long GetActiveThreads() throw()
	{
		return 0;
	}
};

struct ATLServerDllInfo
{
	GETATLHANDLERBYNAME     pfnGetHandler;
	UNINITIALIZEATLHANDLERS pfnUninitHandlers;
	INITIALIZEATLHANDLERS pfnInitHandlers;
	IIsapiExtension *pExtension;
	IHttpServerContext *pContext;
};

class CDllCachePeer
{
public:
	struct DllInfo : public ATLServerDllInfo
	{
		DllInfo& operator=(__in const DllInfo& right) throw()
		{
			if (this != &right)
			{
	  		  	pfnGetHandler = right.pfnGetHandler;
	   			pfnUninitHandlers = right.pfnUninitHandlers;
				pfnInitHandlers = right.pfnInitHandlers;
		 	   	pExtension = right.pExtension;
		  	 	pContext = right.pContext;
			}
			return *this;
		}
	};

	BOOL Add(__in HINSTANCE hInst, __out DllInfo *pInfo) throw(...)
	{
		ATLENSURE(pInfo!=NULL);
		pInfo->pfnInitHandlers = (INITIALIZEATLHANDLERS) GetProcAddress(hInst, ATLS_FUNCID_INITIALIZEHANDLERS);

		pInfo->pfnGetHandler = (GETATLHANDLERBYNAME) GetProcAddress(hInst, ATLS_FUNCID_GETATLHANDLERBYNAME);
		if (!pInfo->pfnGetHandler)
			return FALSE;

		pInfo->pfnUninitHandlers = (UNINITIALIZEATLHANDLERS) GetProcAddress(hInst, ATLS_FUNCID_UNINITIALIZEHANDLERS);

		if (pInfo->pfnInitHandlers)
		{
			pInfo->pfnInitHandlers(pInfo->pContext, pInfo->pExtension);
			pInfo->pContext = NULL; // won't be valid after this call
		}

		return TRUE;
	}

	void Remove(HINSTANCE /*hInst*/, __in DllInfo *pInfo) throw(...)
	{
		ATLENSURE(pInfo!=NULL);
		if (pInfo->pfnUninitHandlers)
			(*pInfo->pfnUninitHandlers)();
	}

};

inline bool operator==(__in const CDllCachePeer::DllInfo& left, __in const CDllCachePeer::DllInfo& right) throw()
{
	return ( (left.pfnGetHandler == right.pfnGetHandler) &&
			 (left.pfnUninitHandlers == right.pfnUninitHandlers) &&
			 (left.pfnInitHandlers == right.pfnInitHandlers) &&
			 (left.pExtension == right.pExtension) &&
			 (left.pContext == right.pContext)
		   );
}



// Helper function to impersonate the client
// on the current thread
inline BOOL AtlImpersonateClient(__in IHttpServerContext *pServerContext)
{
	ATLENSURE(pServerContext);

	// impersonate the calling client on the current thread
	HANDLE hToken;
	_ATLTRY
	{
		if (!pServerContext->GetImpersonationToken(&hToken))
			return FALSE;
	}
	_ATLCATCHALL()
	{
		return FALSE;
	}

	if (!SetThreadToken(NULL, hToken))
		return FALSE;
	return TRUE;    
}

// Helper class to set the thread impersonation token
// This is mainly used internally to ensure that we
// don't forget to revert to the process impersonation
// level
class CSetThreadToken
{
public:
	CSetThreadToken() : m_bShouldRevert(FALSE) {}

	BOOL Initialize(__in AtlServerRequest *pRequestInfo)
	{
		ATLENSURE(pRequestInfo);
		m_bShouldRevert = AtlImpersonateClient(pRequestInfo->pServerContext);
		return m_bShouldRevert;
	}

	~CSetThreadToken() throw()
	{
		if( m_bShouldRevert && !RevertToSelf() )
		{
			_AtlRaiseException( (DWORD)EXCEPTION_ACCESS_VIOLATION );
		}
	}
protected:
	BOOL m_bShouldRevert;
};


// push_macro/pop_macro doesn't work in a template definition.
#pragma push_macro("new")
#undef new


//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class _CComObjectHeapNoLock : public Base
{
	public:
	typedef Base _BaseClass;
	HANDLE m_hHeap;

	_CComObjectHeapNoLock(void* = NULL, HANDLE hHeap = NULL)
	{
		m_hHeap = hHeap;
	}
	// Set refcount to -(LONG_MAX/2) to protect destruction and 
	// also catch mismatched Release in debug builds
	~_CComObjectHeapNoLock()
	{
		m_dwRef = -(LONG_MAX/2);
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}

	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() throw() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)() throw()
	{
		ULONG l = InternalRelease();
		if (l == 0)
		{
			HANDLE hHeap = m_hHeap;;
			this->~_CComObjectHeapNoLock();
			if (hHeap != NULL)
			{
				HeapFree(hHeap, 0, this);
			}
		}
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) throw()
	{return _InternalQueryInterface(iid, ppvObject);}

	static HRESULT WINAPI CreateInstance(_CComObjectHeapNoLock<Base>** pp, HANDLE hHeap) throw();	
};



template <class Base>
HRESULT WINAPI _CComObjectHeapNoLock<Base>::CreateInstance(__deref_out _CComObjectHeapNoLock<Base>** pp, __in HANDLE hHeap) throw()
{
	ATLASSERT(pp != NULL);
	if (pp == NULL)
		return E_POINTER;
	*pp = NULL;

	HRESULT hRes = E_OUTOFMEMORY;
	// Allocate a fixed block size to avoid fragmentation
	void *pv = HeapAlloc(hHeap, HEAP_ZERO_MEMORY,
		__max(sizeof(AtlServerRequest), sizeof(_CComObjectHeapNoLock<CServerContext>)));
	if (pv == NULL)
	{
		return hRes;
	}
#pragma warning(push)
#pragma warning(disable: 6280)
	/* prefast noise VSW 493229 */
	_CComObjectHeapNoLock<Base>* p = new(pv) _CComObjectHeapNoLock<CServerContext>(NULL, hHeap);
#pragma warning(pop)

	p->SetVoid(NULL);
	p->InternalFinalConstructAddRef();
	hRes = p->_AtlInitialConstruct();
	if (SUCCEEDED(hRes))	
		hRes = p->FinalConstruct();
	if (SUCCEEDED(hRes))
		hRes = p->_AtlFinalConstruct();
	p->InternalFinalConstructRelease();
	if (hRes != S_OK)
	{
		p->~_CComObjectHeapNoLock();	
#pragma warning(push)
#pragma warning(disable: 6280)
		/* prefast noise VSW 493229 */
		HeapFree(hHeap, 0, p);		
#pragma warning(pop)
		p = NULL;
	}
	*pp = p;
	return hRes;
}

inline CServerContext* CreateServerContext(__in HANDLE hRequestHeap) throw()
{
	_CComObjectHeapNoLock<CServerContext>* pContext;
	_CComObjectHeapNoLock<CServerContext>::CreateInstance(&pContext, hRequestHeap);
	return pContext;
}
#pragma pop_macro("new")

// _AtlGetHandlerName
// get handler name from stencil file. Ignore all server side comments
//  szFileName - the file from which to extract the handler name
//  szHandlerName - buffer into which handler name will be copied,
//       it is assumed to be of size MAX_PATH+ATL_MAX_HANDLER_NAME+2
inline HTTP_CODE _AtlGetHandlerName(__in LPCSTR szFileName, __out_ecount(MAX_PATH+ATL_MAX_HANDLER_NAME+2) LPSTR szHandlerName)
{
	ATLASSERT(szFileName);
	ATLENSURE(szHandlerName);

	szHandlerName[0] = '\0';
	CAtlFile cfFile;
	HRESULT hr;

	_ATLTRY
	{
		hr = cfFile.Create(CA2CTEX<MAX_PATH>(szFileName), GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING);
		if (FAILED(hr) || cfFile.m_h == NULL || GetFileType(cfFile.m_h) != FILE_TYPE_DISK)
		{
			if (hr == AtlHresultFromWin32(ERROR_FILE_NOT_FOUND))
				return HTTP_NOT_FOUND;
			else if (hr == AtlHresultFromWin32(ERROR_ACCESS_DENIED))
				return HTTP_UNAUTHORIZED;
			else
				return AtlsHttpError(500, IDS_ATLSRV_SERVER_ERROR_STENCILLOADFAIL);
		}
	}
	_ATLCATCHALL()
	{
		return AtlsHttpError(500, ISE_SUBERR_OUTOFMEM); // CA2CTEX threw
	}

	HTTP_CODE hcErr = HTTP_SUCCESS;
	DWORD dwRead=0;
	LPCSTR szHandler = "handler";
	LPCSTR pszHandlerPos = NULL;
	LPSTR pszHandlerName = szHandlerName;
	char szBuf[4097];
	LPSTR szCurly = NULL;
	LPSTR pszBuf = NULL;
	bool bInQuote = false;

	// state:
	//  0 = default/unknown
	//  1 = have "{"
	//  2 = have "{{" -- skip spaces
	//  3 = have "{{" -- check "handler"
	//  4 = have "handler" -- skip spaces
	//  5 = have "handler" -- get name
	//  6 = scan until first '}'
	//  7 = better be '}'
	//  8 = done
	int nState = 0;

	do
	{
		hr = cfFile.Read(szBuf, _countof(szBuf)-1, dwRead);
		if (hr != S_OK)
		{
			return AtlsHttpError(500, ISE_SUBERR_READFILEFAIL); // failed reading
		}

		szBuf[dwRead] = '\0';
		pszBuf = szBuf;

		while (*pszBuf && nState != 8)
		{
			switch (nState)
			{
			case 0: 
				//  0 = default/unknown

				// look for the first curly
				szCurly = strchr(pszBuf, '{');
				if (!szCurly)
				{
					// skip to the end of the buffer
					pszBuf = szBuf+dwRead-1;
				}
				else
				{
					pszBuf = szCurly;
					nState = 1;
				}
				break;
			case 1:
				//  1 = have "{"
				if (*pszBuf == '{') 
				{
					nState = 2;
				}
				else
				{
					nState = 0; // if the next character is not a '{', start over
				}
				break;
			case 2:
				if (!isspace(static_cast<unsigned char>(*pszBuf)))
				{
					pszHandlerPos = szHandler;
					pszBuf--;
					nState = 3;
				}
				break;
			case 3:
				//  3 = partial handler "h..." 
				if (*pszBuf != *pszHandlerPos)
				{
					// not a handler, skip tag
					nState = 6;
				}
				else
				{
					pszHandlerPos++;
					if (!*pszHandlerPos) // at the end of the "handler" part
						nState = 4;
				}
				break;
			case 4:
				//  4 = have "handler" -- skip spaces
				if (!isspace(static_cast<unsigned char>(*pszBuf)))
				{
					if (*pszBuf == '\"')
					{
						bInQuote = true;
					}
					else
					{
						pszBuf--;
					}
					nState = 5;
				}
				break;
			case 5:
				//  5 = have "handler" -- get name
				if (isspace(static_cast<unsigned char>(*pszBuf)) && !bInQuote)
				{
					if (*(pszHandlerName-1) != '/')
					{
						// end of the name -- jump to getting the first '}'
						nState = 6;
					}
					else
					{
						nState = 4;
					}
				}
				else if (*pszBuf == '}')
				{
					// end of the name -- jump to getting the second '}'
					nState = 7;
				}
				else if (*pszBuf == '\"')
				{
					if (bInQuote)
					{
						bInQuote = false;
					}
					else
					{
						hcErr = HTTP_FAIL;
						nState = 8;
					}
				}
				else
				{
					// ensure we don't overwrite the buffer
					if (pszHandlerName-szHandlerName >= MAX_PATH+ATL_MAX_HANDLER_NAME_LEN+1)
					{
						hcErr =  HTTP_FAIL;
						nState = 8;
					}
					else
					{
						*pszHandlerName++ = *pszBuf;
					}
				}
				break;
			case 6:
				//  6 = scan until first '}'
				if (*pszBuf == '}')
					nState = 7;
				break;
			case 7:
				//  7 = better be '}'
				if (*pszBuf != '}')
				{
					hcErr = AtlsHttpError(500, ISE_SUBERR_BAD_HANDLER_TAG);
					nState = 8;
				}
				if (*szHandlerName)
					nState = 8;
				else
					nState = 0;
				break;
			default:
				ATLASSERT(FALSE);
				return HTTP_INTERNAL_SERVER_ERROR;
			}

			pszBuf++;
		}
	} while (dwRead != 0 && nState != 8);

	*pszHandlerName = '\0';

	return hcErr;
}

// _AtlCrackHandler cracks a request path of the form dll_path/handler_name into its
// consituent parts
// szHandlerDllName - the full handler path of the form "dll_path/handler_name"
// szDllPath - the DLL path (should be of length MAX_PATH)
// szHandlerName - the handler name (should be of length ATL_MAX_HANDLER_NAME_LEN+1)
//
inline BOOL _AtlCrackHandler(
	__in_z LPCSTR szHandlerDllName,
	__out_ecount_part(*pdwszDllPathLen,*pdwszDllPathLen) LPSTR szDllPath,
	__inout LPDWORD pdwDllPathLen,
	__out_ecount_part(*pdwHandlerNameLen,*pdwHandlerNameLen) LPSTR szHandlerName,
	__inout LPDWORD pdwHandlerNameLen)
{
	ATLENSURE( szHandlerDllName != NULL );
	ATLASSERT( szDllPath != NULL );
	ATLENSURE( pdwDllPathLen != NULL );
	ATLASSERT( szHandlerName != NULL );
	ATLASSERT( pdwHandlerNameLen != NULL );

	BOOL bRet = TRUE;

	// skip leading spaces
	while (*szHandlerDllName && isspace(static_cast<unsigned char>(*szHandlerDllName)))
		++szHandlerDllName;

	// get the handler name
	LPCSTR szSlash = strchr(szHandlerDllName, '/');
	LPCSTR szEnd = NULL;
	LPCSTR szSlashEnd = NULL;

	// if it is of the form <dll_name>/<handler_name>
	if (szSlash)
	{
		szEnd = szSlash;

		// skip trailing spaces on <dll_name>
		while (szEnd>szHandlerDllName && isspace(static_cast<unsigned char>(*(szEnd-1))))
			--szEnd;

		szSlash++;
		// skip leading whitespace
		while (*szSlash && isspace(static_cast<unsigned char>(*szSlash)))
			szSlash++;

		// right trim szSlash;
		szSlashEnd = szSlash;
		while (*szSlashEnd && !isspace(static_cast<unsigned char>(*szSlashEnd)))
			szSlashEnd++;       
	}
	else // only the <dll_name>
	{
		szSlash = ATL_HANDLER_NAME_DEFAULT;
		szSlashEnd = szSlash+sizeof(ATL_HANDLER_NAME_DEFAULT)-1;

		// do it this way to handle paths with spaces
		// (e.g. "some path\subdirectory one\subdirectory two\dll_name.dll")
		szEnd = szHandlerDllName+strlen(szHandlerDllName);

		// skip trailing spaces
		while (szEnd>szHandlerDllName && isspace(static_cast<unsigned char>(*(szEnd-1))))
			--szEnd;
	}

	// if the dll path is quoted, strip the quotes
	if (*szHandlerDllName == '\"' && *(szEnd-1) == '\"' && szEnd > szHandlerDllName+2)
	{
		szHandlerDllName++;
		szEnd--;
	}

	if (*pdwDllPathLen > (DWORD)(szEnd-szHandlerDllName) && (szEnd-szHandlerDllName >= 0))
	{
		Checked::memcpy_s(szDllPath, *pdwDllPathLen, szHandlerDllName, szEnd-szHandlerDllName);
		szDllPath[szEnd-szHandlerDllName] = '\0';
		*pdwDllPathLen = (DWORD)(szEnd-szHandlerDllName);
	}
	else
	{
		*pdwDllPathLen = (DWORD)(szEnd-szHandlerDllName)+1;
		bRet = FALSE;
	}

	if (*pdwHandlerNameLen > (DWORD)(szSlashEnd-szSlash) && (szSlashEnd-szSlash >= 0))
	{
		Checked::memcpy_s(szHandlerName, *pdwHandlerNameLen, szSlash, (szSlashEnd-szSlash));
		szHandlerName[szSlashEnd-szSlash] = '\0';
		*pdwHandlerNameLen = (DWORD)(szSlashEnd-szSlash);
	}
	else
	{
		*pdwHandlerNameLen = (DWORD)(szSlashEnd-szSlash)+1;
		bRet = FALSE;
	}

	return bRet;
}

inline __checkReturn __success(return==HTTP_SUCCESS) HTTP_CODE _AtlLoadRequestHandler(
			__in LPCSTR szDllPath, 
			__in LPCSTR szHandlerName,
			__in IHttpServerContext *pServerContext, 
			__out HINSTANCE *phInstance, 
			__deref_out_opt IRequestHandler **ppHandler,
			__in IIsapiExtension *pExtension,
			__in IDllCache *pDllCache) throw(...)
{
	ATLENSURE(phInstance!=NULL);
	ATLENSURE(ppHandler!=NULL);
	ATLENSURE(pDllCache!=NULL);
	*phInstance = NULL;
	*ppHandler = NULL;

	ATLServerDllInfo DllInfo;
	DllInfo.pExtension = pExtension;
	DllInfo.pContext = pServerContext;
	if (!IsFullPathA(szDllPath))
	{
		CHAR szFileName[MAX_PATH];
		if (!GetScriptFullFileName(szDllPath, szFileName, pServerContext))
		{
			return HTTP_FAIL;
		}
		
		*phInstance = pDllCache->Load(szFileName, (void *)&DllInfo);
	}
	else
	{
		*phInstance = pDllCache->Load(szDllPath, (void *)&DllInfo);
	}
	if (!*phInstance)
	{
		ATLTRACE( "LoadLibrary failed: '%s' with error: %d\r\n", szDllPath, GetLastError() );
		return AtlsHttpError(500, ISE_SUBERR_LOADLIB);
	}

	CComPtr<IUnknown> spUnk;

	if (!DllInfo.pfnGetHandler || 
		!DllInfo.pfnGetHandler(szHandlerName, pExtension, &spUnk) ||
		FAILED(spUnk->QueryInterface(ppHandler)))
	{
		pDllCache->Free(*phInstance);
		*phInstance = NULL;
		return AtlsHttpError(500, ISE_SUBERR_HANDLER_NOT_FOUND);
	}

	return HTTP_SUCCESS;
} // _AtlLoadRequestHandler


class CTransferServerContext : public CComObjectRootEx<CComMultiThreadModel>,
	public CWrappedServerContext
{
public:
	char m_szFileName[MAX_PATH];
	char m_szQueryString[ATL_URL_MAX_PATH_LENGTH+1];
	CStringA m_strUrl;
	IWriteStream *m_pStream;

	BEGIN_COM_MAP(CTransferServerContext)
		COM_INTERFACE_ENTRY(IHttpServerContext)
	END_COM_MAP()

	CTransferServerContext() throw()
	{
		m_pStream = NULL;
	}

	BOOL Initialize(__in CTransferServerContext *pOtherContext)
	{
		ATLENSURE(pOtherContext!=NULL);
		return Initialize(pOtherContext->m_strUrl, pOtherContext->m_pStream, pOtherContext->m_spParent);
	}

	BOOL Initialize(__in LPCSTR szUrl, __in IWriteStream *pStream, __in IHttpServerContext *pParent) throw()
	{
		m_pStream = pStream;
		m_spParent = pParent;

		_ATLTRY
		{
			m_strUrl = szUrl; // we store the URL in case we need to initialize another context from this context
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}

		long nUrlLen = m_strUrl.GetLength();
		m_szFileName[0] = '\0';

		if (!IsFullPathA(szUrl))
		{
			DWORD dwLen = MAX_PATH;
			BOOL bRet = TRUE;
			_ATLTRY
			{
				bRet = m_spParent->GetServerVariable(
										"APPL_PHYSICAL_PATH",
										m_szFileName,
										&dwLen);
			}
			_ATLCATCHALL()
			{
				bRet = FALSE;
			}

			if (!bRet)
			{
				return bRet;
			}
		}

		// check for query params
		LPCSTR szMark = strchr(szUrl, '?');
		if (szMark)
		{
			size_t nPathLen = szMark - szUrl;
			size_t nLen;

			if ((nPathLen >= 0) && (nPathLen < MAX_PATH)) 
			{
				nLen = strlen(m_szFileName) + nPathLen;
				if (nLen < MAX_PATH)
				{
#pragma warning(push)
#pragma warning(disable: 22008)
					/* Prefast false warning about unbound nPathLen in the below fragment - 
					   we already have necessary checks few lines above 
					*/
					if (m_szFileName[0])
					{
						Checked::strcat_s(m_szFileName, MAX_PATH-nLen, szUrl);
					}
					else
					{
						Checked::memcpy_s(m_szFileName, MAX_PATH, szUrl, nPathLen);
						m_szFileName[nPathLen] = '\0';
					}
#pragma warning(pop)
				}
				else
				{
					return FALSE; // path would overwrite buffer
				}
			}
			else
			{
				return FALSE; // path would overwrite buffer
			}

			// save query params
			nLen = strlen(szMark + 1);
			if (nLen < ATL_URL_MAX_PATH_LENGTH)
			{
				Checked::strcpy_s(m_szQueryString, ATL_URL_MAX_PATH_LENGTH, szMark+1);
			}
			else
			{
				return FALSE; // url would overwrite buffer
			}
		}
		else
		{
			// no query string
			size_t nLen = strlen(m_szFileName) + nUrlLen;
			if (nLen < MAX_PATH)
			{
				if (m_szFileName[0])
				{
					Checked::strcat_s(m_szFileName, MAX_PATH-nLen, szUrl);
				}
				else
				{
					Checked::strcpy_s(m_szFileName, MAX_PATH, szUrl);
				}
			}
			else
			{
				return FALSE; // path would be too long
			}
			m_szQueryString[0] = '\0';
		}

		return TRUE;
	}
	BOOL WriteClient(__in_bcount(*pdwBytes) void *pvBuffer, __inout DWORD *pdwBytes)
	{
		ATLENSURE(m_pStream != NULL);

		HRESULT hr = S_OK;
		_ATLTRY
		{
			m_pStream->WriteStream((LPCSTR) pvBuffer, *pdwBytes, pdwBytes);
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}

		return SUCCEEDED(hr);
	}

	LPCSTR GetQueryString()
	{
		ATLASSUME(m_spParent);
		return m_szQueryString;
	}

	LPCSTR GetScriptPathTranslated()
	{
		ATLASSUME(m_spParent);
		return m_szFileName;
	}

	LPCSTR GetPathTranslated()
	{
		ATLASSUME(m_spParent);
		return m_szFileName;
	}

	// Asynchronous writes will not work properly in a child handler
	BOOL AsyncWriteClient(void * /*pvBuffer*/, DWORD * /*pdwBytes*/)
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	// These next few methods are to protect against attempting to parse form data twice
	// We tell the new handler that it was a GET request
	LPCSTR GetRequestMethod()
	{
		ATLASSUME(m_spParent);
		return "GET";
	}

	// The handler should not query these methods -- they are only useful if attempting to
	// parse form data, which is not allowed in child handlers.
	BOOL ReadClient(void * /*pvBuffer*/, DWORD * /*pdwSize*/)
	{
		return FALSE;
	}

	BOOL AsyncReadClient(void * /*pvBuffer*/, DWORD * /*pdwSize*/)
	{
		return FALSE;
	}

	DWORD GetTotalBytes()
	{       
		ATLASSERT(FALSE);
		return 0;
	}

	DWORD GetAvailableBytes()
	{
		ATLASSERT(FALSE);
		return 0;
	}

	BYTE *GetAvailableData()
	{
		ATLASSERT(FALSE);
		return NULL;
	}

	LPCSTR GetContentType()
	{
		ATLASSERT(FALSE);
		return NULL;
	}
};

class CAllocContextBase
{
public:
	virtual HTTP_CODE Alloc(IHttpServerContext **ppNewContext) = 0;
};

ATL_NOINLINE inline HTTP_CODE _AtlRenderInclude(
	__in IHttpServerContext *pServerContextNew,
	__in LPCSTR szFileName,
	__in LPCSTR szQueryParams,
	__in WORD wCodePage,
	__in CAllocContextBase *pAllocContext,
	__in IServiceProvider *pServiceProvider,
	__in_opt IHttpRequestLookup *pLookup,
	__inout_opt CStencilState* pState = NULL)
{
	 ATLENSURE(pServiceProvider!=NULL);
	 AtlServerRequest* pRequestInfo = NULL;
	 HTTP_CODE hcErr = HTTP_SUCCESS;

	 // get a pointer to the ISAPI extension
	 CComPtr<IIsapiExtension> spExtension;
	 if (S_OK != pServiceProvider->QueryInterface(&spExtension) ||
		 !spExtension)
	 {
		 return AtlsHttpError(500, ISE_SUBERR_UNEXPECTED);
	 }

	 // get a pointer to the extension's dll cache
	 CComPtr<IDllCache> spDllCache;
	 if (S_OK != pServiceProvider->QueryService(__uuidof(IDllCache),
												__uuidof(IDllCache),
												(void**)&spDllCache) ||
		 !spDllCache)
	 {
		 return AtlsHttpError(500, ISE_SUBERR_UNEXPECTED);
	 }

#ifdef _DEBUG
	bool bAsyncAllowed = false;
#endif
	if (pState && pState->pIncludeInfo)
	{
		pRequestInfo = pState->pIncludeInfo;
		pState->pIncludeInfo = NULL;
#ifdef _DEBUG
		bAsyncAllowed = true;
#endif
	}
	else
	{
		ATLASSERT(spDllCache);
		ATLASSERT(spExtension);

		pRequestInfo = spExtension->CreateRequest();
		if (pRequestInfo == NULL)
		{
			return AtlsHttpError(500, ISE_SUBERR_OUTOFMEM);
		}

		pRequestInfo->dwRequestState = ATLSRV_STATE_BEGIN;
		pRequestInfo->dwRequestType = ATLSRV_REQUEST_STENCIL;
		pRequestInfo->pDllCache = spDllCache;
		pRequestInfo->pExtension = spExtension;
		pRequestInfo->pServerContext = pServerContextNew;
		if (pState && pState->pParentInfo)
		{
			pRequestInfo->pUserData = pState->pParentInfo->pUserData;
		}

		// Extract the file extension of the included file by searching
		// for the first '.' from the right.
		// Can't use _tcsrchr because we have to use the stencil's codepage
		LPCSTR szDot = NULL;
		LPCSTR szMark = szFileName;
		ATLENSURE(szMark!=NULL);
		while (*szMark)
		{
			if (*szMark == '.')
				szDot = szMark;

			LPCSTR szNext = CharNextExA(wCodePage, szMark, 0);
			if (szNext == szMark)
			{
				// embedded null
				pRequestInfo->pServerContext = NULL;
				spExtension->FreeRequest(pRequestInfo);
				return HTTP_FAIL;
			}
			szMark = szNext;
		}

		if (szDot && AsciiStricmp(szDot, c_AtlSRFExtension) == 0)
		{
			hcErr = spExtension->LoadDispatchFile(szFileName, pRequestInfo);
			if (hcErr)
			{
				pRequestInfo->pServerContext = NULL;
				spExtension->FreeRequest(pRequestInfo);
				return hcErr;
			}
		}
		else if (szDot && AsciiStricmp(szDot, c_AtlDLLExtension) == 0)
		{
			// Get the handler name if they used the asdf.dll?Handler=Default notation
			char szHandlerName[ATL_MAX_HANDLER_NAME_LEN+1] = { '\0' };

			LPCSTR szStart = strstr(szQueryParams, "Handler=");
			if (szStart && 
				((szStart == szQueryParams) || 
				 ((szStart > szQueryParams) && (*(szStart-1) == '&'))))
			{
				szStart += 8;  // Skip past "Handler" and the "="
				LPCSTR szEnd = strchr(szStart, '&');
				if (szEnd)
				{
					Checked::memcpy_s(szHandlerName, ATL_MAX_HANDLER_NAME_LEN+1, szStart, __min((szEnd-szStart), ATL_MAX_HANDLER_NAME_LEN));
					szHandlerName[__min((szEnd-szStart), ATL_MAX_HANDLER_NAME_LEN)] = '\0';
				}
				else
				{
					if (!SafeStringCopy(szHandlerName, szStart))
					{
						// handler name too long
						pRequestInfo->pServerContext = NULL;
						spExtension->FreeRequest(pRequestInfo);
						return HTTP_FAIL;
					}
				}
			}
			else
			{
				ATLASSERT( ATL_MAX_HANDLER_NAME_LEN >= sizeof(ATL_HANDLER_NAME_DEFAULT) );
				Checked::memcpy_s(szHandlerName, ATL_MAX_HANDLER_NAME_LEN+1, ATL_HANDLER_NAME_DEFAULT, sizeof(ATL_HANDLER_NAME_DEFAULT));
			}

			pRequestInfo->dwRequestType = ATLSRV_REQUEST_DLL;

			hcErr = spExtension->LoadRequestHandler(szFileName, szHandlerName, pRequestInfo->pServerContext, 
				&pRequestInfo->hInstDll, &pRequestInfo->pHandler);
			if (hcErr)
			{
				pRequestInfo->pServerContext = NULL;
				spExtension->FreeRequest(pRequestInfo);
				return hcErr;
			}
		}
		else
		{
			// unknown extension
			pRequestInfo->pServerContext = NULL;
			spExtension->FreeRequest(pRequestInfo);
			return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);
		}

		DWORD dwStatus;
		hcErr = pRequestInfo->pHandler->GetFlags(&dwStatus);

		if (hcErr)
		{
			pRequestInfo->pHandler->UninitializeHandler();
			pRequestInfo->pServerContext = NULL;
			spExtension->FreeRequest(pRequestInfo);
			return hcErr;
		}

		if (dwStatus & (ATLSRV_INIT_USEASYNC | ATLSRV_INIT_USEASYNC_EX))
		{
#ifdef _DEBUG
			bAsyncAllowed = true;
#endif
			ATLENSURE(pAllocContext!=NULL);
			hcErr = pAllocContext->Alloc(&pRequestInfo->pServerContext);
			if (hcErr)
			{
				pRequestInfo->pHandler->UninitializeHandler();
				if (pRequestInfo->pServerContext == pServerContextNew)
				{
					pRequestInfo->pServerContext = NULL;
				}
				spExtension->FreeRequest(pRequestInfo);
				return hcErr;
			}
		}

		hcErr = pRequestInfo->pHandler->InitializeChild(pRequestInfo, pServiceProvider, pLookup);
		if (hcErr)
		{
			pRequestInfo->pHandler->UninitializeHandler();
			if (pRequestInfo->pServerContext == pServerContextNew)
			{
				pRequestInfo->pServerContext = NULL;
			}
			spExtension->FreeRequest(pRequestInfo);
			return hcErr;
		}

		pRequestInfo->pfnHandleRequest = &IRequestHandler::HandleRequest;
	}

	if (pRequestInfo)
	{
		if (!hcErr)
		{
			ATLASSERT(pRequestInfo->pfnHandleRequest != NULL);
			hcErr = (pRequestInfo->pHandler->*pRequestInfo->pfnHandleRequest)(pRequestInfo, pServiceProvider);

#ifdef _DEBUG
			// must use ATLSRV_INIT_USEASYNC to use ASYNC returns
			if (IsAsyncStatus(hcErr))
			{
				ATLASSERT(bAsyncAllowed);
			}
#endif

			if (IsAsyncStatus(hcErr))
			{
				ATLASSERT(pState); // state is required for async
				if (IsAsyncContinueStatus(hcErr))
				{
					pState->pIncludeInfo = pRequestInfo;
					pRequestInfo->dwRequestState = ATLSRV_STATE_CONTINUE;
				}
				else if (IsAsyncDoneStatus(hcErr))
				{
					pRequestInfo->pHandler->UninitializeHandler();
					if (pRequestInfo->pServerContext == pServerContextNew)
					{
						pRequestInfo->pServerContext = NULL;
					}
					spExtension->FreeRequest(pRequestInfo);
				}
			}
			else
			{
				pRequestInfo->pHandler->UninitializeHandler();
				if (pRequestInfo->pServerContext == pServerContextNew)
				{
					pRequestInfo->pServerContext = NULL;
				}
				spExtension->FreeRequest(pRequestInfo);
			}
		}
	}
	else
	{
		hcErr = AtlsHttpError(500, ISE_SUBERR_UNEXPECTED);
	}

	return hcErr;
}

// CAllocTransferAsyncContext is an unsupported implementation detail, used
// for implementing _AtlTransferRequest.
class CAllocTransferAsyncContext : 
	public CAllocContextBase
{
public:
	CAllocTransferAsyncContext(CTransferServerContext *pInitialContext):
		m_pInitialContext(pInitialContext)
	{
	}

	HTTP_CODE Alloc(IHttpServerContext** ppNewContext)
	{
		if (!ppNewContext)
			return AtlsHttpError(500, ISE_SUBERR_UNEXPECTED);
		*ppNewContext = NULL;

		CComObjectNoLock<CTransferServerContext>* pServerContext = NULL;
		ATLTRY(pServerContext = new CComObjectNoLock<CTransferServerContext>);
		if (pServerContext == NULL)
			return AtlsHttpError(500, ISE_SUBERR_OUTOFMEM);
		pServerContext->Initialize(m_pInitialContext);
		pServerContext->AddRef();
		*ppNewContext  = pServerContext;
		return HTTP_SUCCESS;
	}
private:
	CTransferServerContext *m_pInitialContext;
};

inline HTTP_CODE _AtlTransferRequest(
	__in AtlServerRequest *pRequest, 
	__in IServiceProvider *pServiceProvider,
	__in IWriteStream *pWriteStream,
	__in_opt IHttpRequestLookup *pLookup,
	__in LPCSTR szNewUrl,
	__in WORD nCodePage,
	__in bool bContinueAfterProcess,
	__inout_opt CStencilState *pState)
{
	CComObjectStackEx<CTransferServerContext> serverContext;
	if (!serverContext.Initialize(szNewUrl, pWriteStream, pRequest->pServerContext))
		return AtlsHttpError(500, 0);
	CAllocTransferAsyncContext AsyncAllocObj(&serverContext);
	HTTP_CODE hcErr = _AtlRenderInclude(static_cast<IHttpServerContext*>(&serverContext),
									serverContext.m_szFileName,
									serverContext.m_szQueryString,
									nCodePage,
									&AsyncAllocObj,
									pServiceProvider,
									pLookup,
									pState);
	if (hcErr == HTTP_SUCCESS && bContinueAfterProcess)
		return hcErr;
	return HTTP_SUCCESS_NO_PROCESS;
}

//
// This function is now deprecated. ATL is not using it anymore.
//
inline ATL_DEPRECATED("Do not use this function.")
void __cdecl AtlsSecErrHandlerFunc(int /* nCode */, void * /* pv */)
{
	//
	// a buffer overflow has occurred in your code
	//
	ATLASSERT( FALSE );

	//
	// terminate process (safest thing to do)
	//
	TerminateProcess( GetCurrentProcess(), 1 );
}

//
// Class CIsapiExtension
// The main ISAPI Extension implementation.
// Template parameters
// ThreadPoolClass: Specifies the thread pool that will be used by the 
//		extension to queue incoming requests. CThreadPool is the
//		default and is declared and implemented in ATLUTIL.H. This class
//		templatizes on a worker thread class. The worker thread class
//		represents an abstraction of a thread that will be used to
//		process requests as they are dequeued from the pool's work queue.
//		You would change this parameter if you wanted to use a completely
//		different thread pool, or, more commonly, if you wanted to use 
//		a different worker thread class. Request processing code can
//		access a pointer to the worker thread class, which allows the
//		request handling code to easily access per-thread data.
// CRequestStatClass:	Specifies the class to be used to track request statistics
//		CNoRequestStats is the default which is a noop class.
//		You would change this parameter to provide a class that will
//		track request statistics for you. ATL provides CStdRequestStats
//		and CPerfRequestStatObject but these classes should be used
//		with caution because they require interlocked operations to
//		keep track of request statistics which can affect server performance.
// HttpUserErrorTextProvider: This class provides error text messages
//		and headers, including  resource IDs of error messages to the
//		isapi extension's error handling functions. You would change this
//		parameter if you wanted to provide your own error headers and/or
//		messages in response to error encountered during request processing.
// CPageCacheStats, CStencilCacheStats: These two classes are used to keep
//		statistics about the page and stencil caches. You could change these
//		paramters if you wanted to track statistics for these caches. ATL
//		provides CPerfStatClass and CStdStatClass to store the stat data but
//		using these classes can affect server performance because they use
//		interlocked operations internally to store the data.
template <  class ThreadPoolClass=CThreadPool<CIsapiWorker>, 
			class CRequestStatClass=CNoRequestStats,
			class HttpUserErrorTextProvider=CDefaultErrorProvider,
			class WorkerThreadTraits=DefaultThreadTraits,
			class CPageCacheStats=CNoStatClass,
			class CStencilCacheStats=CNoStatClass>
class CIsapiExtension :
	public IServiceProvider, public IIsapiExtension, public IRequestStats
{
private:

#ifndef ATL_NO_CRITICAL_ISAPI_ERROR

	DWORD m_dwCriticalIsapiError;

#endif // ATL_NO_CRITICAL_ISAPI_ERROR

protected:
	DWORD m_dwTlsIndex;

	typedef CWorkerThread<WorkerThreadTraits> extWorkerType;

	extWorkerType m_WorkerThread;
	ThreadPoolClass m_ThreadPool;

	CDllCache<extWorkerType, CDllCachePeer> m_DllCache;
	CFileCache<extWorkerType, CPageCacheStats, CPageCachePeer> m_PageCache;
	CComObjectGlobal<CStencilCache<extWorkerType, CStencilCacheStats > > m_StencilCache;
	HttpUserErrorTextProvider m_UserErrorProvider;
	HANDLE m_hRequestHeap;
	CComCriticalSection m_critSec;

	// Dynamic services stuff
	struct ServiceNode
	{
		HINSTANCE hInst;
		IUnknown *punk;
		GUID guidService;
		IID riid;

		ServiceNode() throw()
		{
		}

		ServiceNode(const ServiceNode& that) throw()
			:hInst(that.hInst), punk(that.punk), guidService(that.guidService), riid(that.riid)
		{
		}
	};

	class CServiceEqualHelper
	{
	public:
		static bool IsEqual(__in const ServiceNode& t1, __in const ServiceNode& t2) throw()
		{
			return (InlineIsEqualGUID(t1.guidService, t2.guidService) != 0 &&
					InlineIsEqualGUID(t1.riid, t2.riid) != 0);
		}
	};

	CSimpleArray<ServiceNode, CServiceEqualHelper> m_serviceMap;

public:
	CWin32Heap m_heap;

	CRequestStatClass m_reqStats;

	AtlServerRequest *CreateRequest()
	{
		// Allocate a fixed block size to avoid fragmentation
		AtlServerRequest *pRequest = (AtlServerRequest *) HeapAlloc(m_hRequestHeap, 
				HEAP_ZERO_MEMORY, __max(sizeof(AtlServerRequest), sizeof(_CComObjectHeapNoLock<CServerContext>)));
		if (!pRequest)
			return NULL;
		pRequest->cbSize = sizeof(AtlServerRequest);

		return pRequest;
	}

	void FreeRequest(__inout AtlServerRequest *pRequest)
	{
		_ReleaseAtlServerRequest(pRequest);
		HeapFree(m_hRequestHeap, 0, pRequest);
	}

	CIsapiExtension() throw()
	{
		m_hRequestHeap = NULL;
#ifdef _DEBUG
		m_bDebug = FALSE;
#endif

#ifndef ATL_NO_CRITICAL_ISAPI_ERROR

		m_dwCriticalIsapiError = 0;

#endif // ATL_NO_CRITICAL_ISAPI_ERROR
	}

	HTTP_CODE TransferRequest(
		__in AtlServerRequest *pRequest, 
		__in IServiceProvider *pServiceProvider,
		__in IWriteStream *pWriteStream,
		__in_opt IHttpRequestLookup *pLookup,
		__in LPCSTR szNewUrl,
		__in WORD nCodePage,
		__in bool bContinueAfterProcess,
		__inout_opt CStencilState *pState)
	{
		HTTP_CODE hcErr;
		_ATLTRY
		{
			hcErr = _AtlTransferRequest(pRequest, pServiceProvider, pWriteStream,
				pLookup, szNewUrl, nCodePage, bContinueAfterProcess, pState);
		}
		_ATLCATCHALL()
		{
			hcErr = HTTP_FAIL;
		}
		return hcErr;
	}

#ifndef ATL_NO_CRITICAL_ISAPI_ERROR

	DWORD ReturnCriticalError(__in EXTENSION_CONTROL_BLOCK *pECB)
	{
		
		_ATLTRY
		{
			ATLENSURE(pECB);
			UINT uResId = 0;
			LPCSTR szHeader = NULL;

			CStringA strStatus;
			CStringA strBody;
			CStringA strFormat;
			CStringA strError;

			DWORD dwErr = GetCriticalIsapiError();
			if (!strError.LoadString(dwErr))
			{
				strError.Format("Unknown Error %d", dwErr);
			}

#ifdef ATL_CRITICAL_ISAPI_ERROR_LOGONLY
			// we've logged the real error - don't send detailed internal info to the user
			m_UserErrorProvider.GetErrorText(500,
											 SUBERR_NONE,
											 &szHeader,
											 &uResId);

			if (!uResId || !strBody.LoadString(uResId))
			{
				strBody = "<html><body>A server error has occurred.</body></html>";
			}
#else
			m_UserErrorProvider.GetErrorText(500,
											 ISE_SUBERR_ISAPISTARTUPFAILED,
											 &szHeader,
											 &uResId);
			if (!uResId || !strFormat.LoadString(uResId))
			{
				strFormat = "<html><body>A critical error has occurred initializing this ISAPI extension: %s</body></html>";
			}
			strBody.Format(strFormat, strError);
#endif
			strStatus.Format("500 %s", szHeader);

			HSE_SEND_HEADER_EX_INFO hex;
			hex.pszStatus = (LPCSTR)strStatus;
			hex.pszHeader = NULL;
			hex.cchStatus = (DWORD)strStatus.GetLength();
			hex.cchHeader = 0;
			hex.fKeepConn = FALSE;

			pECB->ServerSupportFunction(pECB->ConnID,
										HSE_REQ_SEND_RESPONSE_HEADER_EX,
										&hex,
										NULL,
										NULL);

			DWORD dwBodyLen = strBody.GetLength();
			pECB->WriteClient(pECB->ConnID, 
							 (void *) (LPCSTR) strBody,
							 &dwBodyLen,
							 NULL);
		}
		_ATLCATCHALL()
		{
			return HSE_STATUS_ERROR;
		}
		return HSE_STATUS_SUCCESS;
	}

#endif // ATL_NO_CRITICAL_ISAPI_ERROR

	DWORD HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK lpECB) throw()
	{

#ifndef ATL_NO_CRITICAL_ISAPI_ERROR

		if (GetCriticalIsapiError() != 0)
		{
			return ReturnCriticalError(lpECB);
		}

#endif // ATL_NO_CRITICAL_ISAPI_ERROR

		AtlServerRequest *pRequestInfo = NULL;

		_ATLTRY
		{
			pRequestInfo = CreateRequest();
			if (pRequestInfo == NULL)
				return HSE_STATUS_ERROR;

			CServerContext *pServerContext = NULL;
			ATLTRY(pServerContext = CreateServerContext(m_hRequestHeap));
			if (pServerContext == NULL)
			{
				FreeRequest(pRequestInfo);
				return HSE_STATUS_ERROR;
			}

			pServerContext->Initialize(lpECB);
			pServerContext->AddRef();

			pRequestInfo->pServerContext = pServerContext;
			pRequestInfo->dwRequestType = ATLSRV_REQUEST_UNKNOWN;
			pRequestInfo->dwRequestState = ATLSRV_STATE_BEGIN;
			pRequestInfo->pExtension = static_cast<IIsapiExtension *>(this);
			pRequestInfo->pDllCache = static_cast<IDllCache *>(&m_DllCache);
#ifndef ATL_NO_MMSYS
			pRequestInfo->dwStartTicks = timeGetTime();
#else
			pRequestInfo->dwStartTicks = GetTickCount();
#endif
			pRequestInfo->pECB = lpECB;

			m_reqStats.OnRequestReceived();

			if (m_ThreadPool.QueueRequest(pRequestInfo))
				return HSE_STATUS_PENDING;

			if (pRequestInfo != NULL)
			{
				FreeRequest(pRequestInfo);
			}

		}
		_ATLCATCHALL()
		{
		}



		return HSE_STATUS_ERROR;
	}


	BOOL QueueRequest(__in AtlServerRequest * pRequestInfo)
	{
		return m_ThreadPool.QueueRequest(pRequestInfo);
	}

	CIsapiWorker *GetThreadWorker()
	{
		return (CIsapiWorker *) TlsGetValue(m_dwTlsIndex);
	}

	BOOL SetThreadWorker(__in CIsapiWorker *pWorker)
	{
		return TlsSetValue(m_dwTlsIndex, (void*)pWorker);
	}

	// Configuration functions -- override in base class if another value is desired
	virtual LPCSTR GetExtensionDesc() throw() { return "VC Server Classes"; }
	virtual int GetNumPoolThreads() throw() { return 0; }
	virtual int GetPoolStackSize() throw() { return 0; }
	virtual HANDLE GetIOCompletionHandle() throw() { return INVALID_HANDLE_VALUE; }
	virtual DWORD GetDllCacheTimeout() throw() { return ATL_DLL_CACHE_TIMEOUT; }
	virtual DWORD GetStencilCacheTimeout() throw() { return ATL_STENCIL_CACHE_TIMEOUT; }
	virtual LONGLONG GetStencilLifespan() throw() { return ATL_STENCIL_LIFESPAN; }

	BOOL OnThreadAttach()
	{
		return SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED));
	}

	void OnThreadTerminate()
	{
		CoUninitialize();
	}

#ifndef ATL_NO_CRITICAL_ISAPI_ERROR

	BOOL SetCriticalIsapiError(__in DWORD dwErr = 1) throw()
	{
		m_dwCriticalIsapiError = dwErr;

		// send the error to the event log
		_ATLTRY
		{
			CStringA strBody;
			CStringA strFormat;
			CStringA strError;

			// format an error message
			if (!strError.LoadString(dwErr))
			{
				strError.Format("Unknown Error %d", dwErr);
			}

			if (!strFormat.LoadString(IDS_ATLSRV_CRITICAL_LOGMESSAGE))
			{
				strFormat = "A critical error has occurred initializing the ISAPI extension: %s";
			}
			strBody.Format(strFormat, strError);

			// take the base module name as the app name
			CPath path;
			{
				CStrBuf buf(path, MAX_PATH);
				DWORD dwLen = ::GetModuleFileName(_AtlBaseModule.GetModuleInstance(), buf, MAX_PATH);
				if (dwLen == MAX_PATH)
					buf.SetLength(MAX_PATH);
			}
			path.StripPath();

			// log the event
			HANDLE h = RegisterEventSource(NULL, path);
			if (h)
			{
				LPCSTR szBody = strBody;
				ReportEventA(h, EVENTLOG_ERROR_TYPE, 0, 0, NULL, 1, 0, &szBody, NULL);
				DeregisterEventSource(h);
			}
		}
		_ATLCATCHALL()
		{
		}

		return TRUE;
	}

	DWORD GetCriticalIsapiError() throw()
	{
		return m_dwCriticalIsapiError;
	}

#else

	BOOL SetCriticalIsapiError(__in DWORD dwErr = 1) throw()
	{
		dwErr; // not used
		return FALSE;
	}

	DWORD GetCriticalIsapiError() throw()
	{
		return 0;
	}

#endif // ATL_NO_CRITICAL_ISAPI_ERROR


	BOOL GetExtensionVersion(__out HSE_VERSION_INFO* pVer) throw()
	{
		ATLASSERT(pVer!=NULL);
		if(pVer==NULL)
		{
			return FALSE;
		}
		// allocate a Tls slot for storing per thread data
		m_dwTlsIndex = TlsAlloc();

		// create a private heap for request data
		// this heap has to be thread safe to allow for
		// async processing of requests
		m_hRequestHeap = HeapCreate(0, 0, 0);
		if (!m_hRequestHeap)
		{
			ATLTRACE(atlTraceISAPI, 0, _T("Failed creating request heap.  Using process heap\n"));
			m_hRequestHeap = GetProcessHeap();
			if (!m_hRequestHeap)
			{
				return SetCriticalIsapiError(IDS_ATLSRV_CRITICAL_HEAPCREATEFAILED);
			}

		}

		// create a private heap (synchronized) for
		// allocations.  This reduces fragmentation overhead
		// as opposed to the process heap
		HANDLE hHeap = HeapCreate(0, 0, 0);
		if (!hHeap)
		{
			ATLTRACE(atlTraceISAPI, 0, _T("Failed creating extension heap.  Using process heap\n"));
			hHeap = GetProcessHeap();
			m_heap.Attach(hHeap, false);
		}
		else
		{
			m_heap.Attach(hHeap, true);
		}
		hHeap = NULL;

		if (S_OK != m_reqStats.Initialize())
		{
			ATLTRACE(atlTraceISAPI,
					 0,
					 _T("Initialization failed for request statistics perfmon support.\n")
					 _T("Check request statistics perfmon dll registration\n") );
		}

		if (S_OK != m_WorkerThread.Initialize())
		{
			return SetCriticalIsapiError(IDS_ATLSRV_CRITICAL_WORKERINITFAILED);
		}

		if (m_critSec.Init() != S_OK)
		{
			HRESULT hrIgnore=m_WorkerThread.Shutdown();
			return SetCriticalIsapiError(IDS_ATLSRV_CRITICAL_CRITSECINITFAILED);
		}

		if (S_OK != m_ThreadPool.Initialize(static_cast<IIsapiExtension*>(this), GetNumPoolThreads(), GetPoolStackSize(), GetIOCompletionHandle()))
		{
			HRESULT hrIgnore=m_WorkerThread.Shutdown();
			m_critSec.Term();
			return SetCriticalIsapiError(IDS_ATLSRV_CRITICAL_THREADPOOLFAILED);
		}

		if (FAILED(m_DllCache.Initialize(&m_WorkerThread, GetDllCacheTimeout())))
		{
			HRESULT hrIgnore=m_WorkerThread.Shutdown();
			m_ThreadPool.Shutdown();
			m_critSec.Term();
			return SetCriticalIsapiError(IDS_ATLSRV_CRITICAL_DLLCACHEFAILED);
		}

		if (FAILED(m_PageCache.Initialize(&m_WorkerThread)))
		{
			HRESULT hrIgnore=m_WorkerThread.Shutdown();
			m_ThreadPool.Shutdown();
			m_DllCache.Uninitialize();
			m_critSec.Term();
			return SetCriticalIsapiError(IDS_ATLSRV_CRITICAL_PAGECACHEFAILED);
		}

		if (S_OK != m_StencilCache.Initialize(static_cast<IServiceProvider*>(this),
										  &m_WorkerThread, 
										  GetStencilCacheTimeout(),
										  GetStencilLifespan()))
		{
			HRESULT hrIgnore=m_WorkerThread.Shutdown();
			m_ThreadPool.Shutdown();
			m_DllCache.Uninitialize();
			m_PageCache.Uninitialize();
			m_critSec.Term();
			return SetCriticalIsapiError(IDS_ATLSRV_CRITICAL_STENCILCACHEFAILED);
		}

		pVer->dwExtensionVersion = HSE_VERSION;
		Checked::strncpy_s(pVer->lpszExtensionDesc, HSE_MAX_EXT_DLL_NAME_LEN, GetExtensionDesc(), _TRUNCATE);
		pVer->lpszExtensionDesc[HSE_MAX_EXT_DLL_NAME_LEN - 1] = '\0';

		return TRUE;
	}

	BOOL TerminateExtension(DWORD /*dwFlags*/) throw()
	{
		m_critSec.Lock();
		for (int i=0; i < m_serviceMap.GetSize(); i++)
		{
			ATLASSUME(m_serviceMap[i].punk != NULL);
			if(m_serviceMap[i].punk != NULL)
			{
				m_serviceMap[i].punk->Release();
			}
			m_DllCache.ReleaseModule(m_serviceMap[i].hInst);
		}
		m_critSec.Unlock();

		m_ThreadPool.Shutdown();
		m_StencilCache.Uninitialize();
		m_DllCache.Uninitialize();
		m_PageCache.Uninitialize();
		HRESULT hrShutdown=m_WorkerThread.Shutdown();
		m_reqStats.Uninitialize();
		m_critSec.Term();

		// free the request heap
		if (m_hRequestHeap != GetProcessHeap())
			HeapDestroy(m_hRequestHeap);

		// free the Tls slot that we allocated
		TlsFree(m_dwTlsIndex);

		return SUCCEEDED(hrShutdown);
	}

	static void WINAPI AsyncCallback(LPEXTENSION_CONTROL_BLOCK /*lpECB*/,
									 __in PVOID pContext,
									 __in DWORD cbIO,
									 __in DWORD dwError) throw(...)
	{
		AtlServerRequest *pRequestInfo = reinterpret_cast<AtlServerRequest*>(pContext);
		ATLENSURE(pRequestInfo);
		if (pRequestInfo->m_hMutex)
		{
			// synchronize in case the previous async_noflush call isn't finished
			// setting up state for the next call.
			DWORD dwStatus = WaitForSingleObject(pRequestInfo->m_hMutex, ATLS_ASYNC_MUTEX_TIMEOUT);
			if (dwStatus != WAIT_OBJECT_0 && dwStatus != WAIT_ABANDONED)
			{
				_ATLTRY
				{
					pRequestInfo->pExtension->RequestComplete(pRequestInfo, 500, ISE_SUBERR_UNEXPECTED);
				}
				_ATLCATCHALL()
				{
					ATLTRACE(_T("Warning: Uncaught user exception thrown and caught in AsyncCallback.\n"));
					_ATLRETHROW;
				}
				return;
			}
		}

		if (pRequestInfo->pfnAsyncComplete != NULL)
			ATLTRY((*pRequestInfo->pfnAsyncComplete)(pRequestInfo, cbIO, dwError));

		if (pRequestInfo->dwRequestState == ATLSRV_STATE_DONE)
		{
			pRequestInfo->pExtension->RequestComplete(pRequestInfo, HTTP_ERROR_CODE(HTTP_SUCCESS), 0);
		}
		else if (pRequestInfo->dwRequestState == ATLSRV_STATE_CACHE_DONE)
		{
			CloseHandle(pRequestInfo->hFile);
			pRequestInfo->pFileCache->ReleaseFile(pRequestInfo->hEntry);
			pRequestInfo->pExtension->RequestComplete(pRequestInfo, HTTP_ERROR_CODE(HTTP_SUCCESS), 0);
		}
		else 
		{
			HANDLE hMutex = pRequestInfo->m_hMutex;
			pRequestInfo->pExtension->QueueRequest(pRequestInfo);
			if (hMutex)
				ReleaseMutex(hMutex);
		}
	}

	void HandleError(__in IHttpServerContext *pServerContext, __in DWORD dwStatus, __in DWORD dwSubStatus) throw()
	{
		RenderError(pServerContext, dwStatus, dwSubStatus, &m_UserErrorProvider);
	}

	void RequestComplete(__inout AtlServerRequest *pRequestInfo, __in DWORD dwStatus, __in DWORD dwSubStatus)
	{
		ATLASSERT(pRequestInfo);

		if (pRequestInfo->pHandler != NULL)
			pRequestInfo->pHandler->UninitializeHandler();

		DWORD dwReqStatus = dwStatus;
		if (!dwReqStatus)
			dwReqStatus = 200;

		if (dwStatus >= 400)
		{
			if (dwSubStatus != SUBERR_NO_PROCESS)
				HandleError(pRequestInfo->pServerContext, dwStatus, dwSubStatus);
			m_reqStats.RequestHandled(pRequestInfo, FALSE);
		}
		else
			m_reqStats.RequestHandled(pRequestInfo, TRUE);

		CComPtr<IHttpServerContext> spServerContext = pRequestInfo->pServerContext;

		FreeRequest(pRequestInfo);

		spServerContext->DoneWithSession(dwReqStatus);
	}

	HTTP_CODE GetHandlerName(__in LPCSTR szFileName, __out_ecount(MAX_PATH+ATL_MAX_HANDLER_NAME+2) LPSTR szHandlerName) throw()
	{
		return _AtlGetHandlerName(szFileName, szHandlerName);
	}

	HTTP_CODE LoadDispatchFile(__in LPCSTR szFileName, __out AtlServerRequest *pRequestInfo)
	{
		ATLASSERT(szFileName);
		ATLASSERT(pRequestInfo);

		CStencil *pStencil = NULL;
		HCACHEITEM hStencil = NULL;

		// Must have space for the path to the handler + the maximum size
		// of the handler, plus the '/' plus the '\0'
		CHAR szDllPath[MAX_PATH];
		CHAR szHandlerName[ATL_MAX_HANDLER_NAME_LEN+1];

		pRequestInfo->pHandler = NULL;
		pRequestInfo->hInstDll = NULL;

		m_StencilCache.LookupStencil(szFileName, &hStencil);

		// Stencil was found, check to see if it needs to be refreshed
		if (hStencil)
		{
			m_StencilCache.GetStencil(hStencil, (void **) &pStencil);
			pStencil->GetHandlerName(szDllPath, MAX_PATH, szHandlerName, ATL_MAX_HANDLER_NAME_LEN + 1);

			CFileTime cftCurr;
			CFileTime cftLastChecked;
			cftCurr = CFileTime::GetCurrentTime();

			pStencil->GetLastChecked(&cftLastChecked);

			CFileTimeSpan span(ATL_STENCIL_CHECK_TIMEOUT * CFileTime::Millisecond);

			if (cftLastChecked + span < cftCurr)
			{
				CComPtr<IStencilCacheControl> spCacheCtrl;
				m_StencilCache.QueryInterface(__uuidof(IStencilCacheControl), reinterpret_cast<void**>(&spCacheCtrl));
				if (spCacheCtrl)
				{
					CFileTime cftLastModified;
					pStencil->GetLastModified(&cftLastModified);

					// Resource based stencils have a last modified filetime of 0
					if (cftLastModified != 0)
					{
						// for file base stencils, we check whether the file
						// has been modified since being put in the cache
						WIN32_FILE_ATTRIBUTE_DATA fad;
						pStencil->SetLastChecked(&cftCurr);
						BOOL bRet = GetFileAttributesExA(szFileName, GetFileExInfoStandard, &fad);

						if ((bRet && cftLastModified < fad.ftLastWriteTime) ||
							!bRet)
						{
							// the file has changed or an error has occurred trying to read the file, 
							// so remove it from the cache and force a reload
							spCacheCtrl->RemoveStencil(hStencil);
							pStencil = NULL;
							hStencil = NULL;
						}
					}
				}   
			}
		}


		if (!hStencil)
		{
			CHAR szHandlerDllName[MAX_PATH+ATL_MAX_HANDLER_NAME_LEN+1];
			*szHandlerDllName = '\0';

			// not in the cache, so open the file
			HTTP_CODE hcErr = GetHandlerName(szFileName, szHandlerDllName);
			if (hcErr)
				return hcErr;
			DWORD dwDllPathLen = MAX_PATH;
			DWORD dwHandlerNameLen = ATL_MAX_HANDLER_NAME_LEN+1;
			if (!_AtlCrackHandler(szHandlerDllName, szDllPath, &dwDllPathLen, szHandlerName, &dwHandlerNameLen))
			{
				return AtlsHttpError(500, ISE_SUBERR_HANDLER_NOT_FOUND);
			}
			ATLASSERT(*szHandlerName);
			ATLASSERT(*szDllPath);
			if (!*szHandlerName)
			{
				return AtlsHttpError(500, ISE_SUBERR_HANDLER_NOT_FOUND);
			}
		}
		else
		{
			m_StencilCache.ReleaseStencil(hStencil);
		}


		return LoadRequestHandler(szDllPath, szHandlerName, pRequestInfo->pServerContext, 
			&pRequestInfo->hInstDll, &pRequestInfo->pHandler);
	}

	HTTP_CODE LoadDllHandler(__in LPCSTR szFileName, __in AtlServerRequest *pRequestInfo)
	{
		ATLASSERT(szFileName);
		ATLENSURE(pRequestInfo);

		_ATLTRY
		{
			HTTP_CODE hcErr = HTTP_SUCCESS;
			CHAR szHandler[ATL_MAX_HANDLER_NAME_LEN+1] = { 'D', 'e', 'f', 'a', 'u', 'l', 't', '\0' };
			LPCSTR szQueryString = pRequestInfo->pServerContext->GetQueryString();
			if (szQueryString != NULL)
			{
				LPCSTR szHdlr = strstr(szQueryString, "Handler=");
				if (szHdlr != NULL)
				{
					if ((szHdlr == szQueryString) ||
						((szHdlr > szQueryString) && (*(szHdlr-1) == '&')))
					{
						int nCnt = 0;
						LPSTR pszHandler = szHandler;
						szHdlr += sizeof("Handler=")-1;
						while (*szHdlr && *szHdlr != '&')
						{
							if (nCnt < ATL_MAX_HANDLER_NAME_LEN)
							{
								*pszHandler++ = *szHdlr++;
								nCnt++;
							}
							else
							{
								hcErr = AtlsHttpError(500, ISE_SUBERR_HANDLER_NOT_FOUND);
								break;
							}
						}
						if (hcErr == HTTP_SUCCESS)
						{
							*pszHandler = '\0';
						}
					}
				}
			}

			if (hcErr == HTTP_SUCCESS)
			{
				CHAR szFile[MAX_PATH+ATL_MAX_HANDLER_NAME_LEN+1];
				if (SafeStringCopy(szFile, szFileName))
				{
					hcErr = LoadRequestHandler(szFile, szHandler, pRequestInfo->pServerContext, &pRequestInfo->hInstDll, &pRequestInfo->pHandler);
				}
				else
				{
					hcErr = AtlsHttpError(500, ISE_SUBERR_UNEXPECTED);
				}
			}

			return hcErr;
		}
		_ATLCATCHALL()
		{
			return AtlsHttpError(500, ISE_SUBERR_UNEXPECTED);
		}
	}

#pragma warning(push)
#pragma warning(disable: 6014)
	virtual __success(return) __checkReturn BOOL GetCacheServerContext(__in AtlServerRequest *pRequestInfo, __in IFileCache *pCache, __deref_out_opt IHttpServerContext **pCacheCtx)
	{
		ATLENSURE(pCacheCtx);
		*pCacheCtx = NULL;

		CComObjectNoLock<CCacheServerContext> *pCacheServerContext = NULL;
		ATLTRY(pCacheServerContext = new CComObjectNoLock<CCacheServerContext>);
		if (!pCacheServerContext)
			return FALSE;

		if (!pCacheServerContext->Initialize(pRequestInfo->pServerContext, pCache))
		{
			delete pCacheServerContext;
			return FALSE;
		}

		pCacheServerContext->QueryInterface(__uuidof(IHttpServerContext), (void **) pCacheCtx);

		if (*pCacheCtx)
			return TRUE;

	 	delete pCacheServerContext;
		return FALSE;
	}
#pragma warning(pop)

	virtual BOOL TransmitFromCache(__in AtlServerRequest* pRequestInfo, __out BOOL *pbAllowCaching)
	{
		ATLENSURE(pRequestInfo);
		ATLENSURE(pbAllowCaching);

		*pbAllowCaching = TRUE;

		_ATLTRY
		{
			if (strcmp(pRequestInfo->pServerContext->GetRequestMethod(), "GET"))
				return FALSE;

			char szUrl[ATL_URL_MAX_URL_LENGTH + 1];
			LPCSTR szPathInfo = pRequestInfo->pServerContext->GetPathInfo();
			LPCSTR szQueryString = pRequestInfo->pServerContext->GetQueryString();

			int nSize = 0;
			LPSTR szTo = szUrl;
			ATLENSURE(szPathInfo!=NULL);
			while (*szPathInfo && nSize < ATL_URL_MAX_URL_LENGTH)
			{
				*szTo++ = *szPathInfo++;
				nSize++;
			}
			if (nSize >= ATL_URL_MAX_URL_LENGTH)
			{
				return FALSE;
			}
			*szTo++ = '?';
			nSize++;
			ATLENSURE(szQueryString!=NULL);
			while (*szQueryString && nSize < ATL_URL_MAX_URL_LENGTH)
			{
				*szTo++ = *szQueryString++;
				nSize++;
			}
			if (nSize >= ATL_URL_MAX_URL_LENGTH)
			{
				return FALSE;
			}
			*szTo = '\0';

			HCACHEITEM hEntry;

			if (S_OK == m_PageCache.LookupFile(szUrl, &hEntry))
			{ 
				LPSTR szFileName;
				CPageCachePeer::PeerInfo *pInfo;
				m_PageCache.GetFile(hEntry, &szFileName, (void **)&pInfo);
				ATLENSURE(pInfo);
				CAtlFile file;
				HRESULT hr = E_FAIL;

				CA2CTEX<MAX_PATH> strFile(szFileName);
				hr = file.Create(strFile,
								GENERIC_READ,
								FILE_SHARE_READ,
								OPEN_EXISTING,
								FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED);

				if (FAILED(hr) || GetFileType(file) != FILE_TYPE_DISK)
				{
					m_PageCache.ReleaseFile(hEntry);
					*pbAllowCaching = FALSE;
					return FALSE;
				}

				pRequestInfo->pServerContext->SendResponseHeader(
					pInfo->strHeader, pInfo->strStatus, FALSE);
				HANDLE hFile = file.Detach();
				BOOL bRet = FALSE;

				pRequestInfo->dwRequestState = ATLSRV_STATE_CACHE_DONE;
				pRequestInfo->hFile = hFile;
				pRequestInfo->hEntry = hEntry;
				pRequestInfo->pFileCache = &m_PageCache;

				bRet = pRequestInfo->pServerContext->TransmitFile(
					hFile,                          // The file to transmit
					AsyncCallback, pRequestInfo,    // The async callback and context
					pInfo->strStatus,               // HTTP status code
					0,                              // Send entire file
					0,                              // Start at the beginning of the file
					NULL, 0,                        // Head and length
					NULL, 0,                        // Tail and length
					HSE_IO_ASYNC | HSE_IO_DISCONNECT_AFTER_SEND | HSE_IO_NODELAY // Send asynchronously
					);

				if (!bRet)
				{
					m_PageCache.ReleaseFile(hEntry);
					CloseHandle(hFile);
					*pbAllowCaching = FALSE;
					return FALSE;
				}
				return TRUE;
			}
		}
		_ATLCATCHALL()
		{
		}

		return FALSE;
	}

#if defined(_DEBUG) || defined(ATLS_ENABLE_DEBUGGING)

	BOOL m_bDebug;
	// F5 debugging support for VS7
	BOOL ProcessDebug(__inout AtlServerRequest *pRequestInfo)
{
		ATLENSURE(pRequestInfo);
		static GUID clsidDebugger[] = {
			{0x70F65411, 0xFE8C, 0x4248, {0xBC,0xFF,0x70,0x1C,0x8B,0x2F,0x45,0x29}}, // debugger clsid
			{0x62A78AC2, 0x7D9A, 0x4377, {0xB9,0x7E,0x69,0x65,0x91,0x9F,0xDD,0x02}}, // reserved
			{0xCC23651F, 0x4574, 0x438F, {0xB4,0xAA,0xBC,0xB2,0x8B,0x6B,0x3E,0xCF}}, // reserved
			{0xDBFDB1D0, 0x04A4, 0x4315, {0xB1,0x5C,0xF8,0x74,0xF6,0xB6,0xE9,0x0B}}, // reserved
			{0xA4FCB474, 0x2687, 0x4924, {0xB0,0xAD,0x7C,0xAF,0x33,0x1D,0xB8,0x26}}, // reserved
			{0xBEB261F6, 0xD5F0, 0x43BA, {0xBA,0xF4,0x8B,0x79,0x78,0x5F,0xFF,0xAF}}, // reserved
			{0x8E2F5E28, 0xD4E2, 0x44C0, {0xAA,0x02,0xF8,0xC5,0xBE,0xB7,0x0C,0xAC}}, // reserved
			{0x08100915, 0x0F41, 0x4CCF, {0x95,0x64,0xEB,0xAA,0x5D,0x49,0x44,0x6C}}  // reserved
		};
		_ATLTRY
		{
			if (!_stricmp(pRequestInfo->pServerContext->GetRequestMethod(), "debug"))
			{
				// Debugger must be able to validate the client we are impersonating
				// on an NT Domain so the client needs to use either NTLM or Negotiate.
				DWORD dwAuthTypeSize = 64;
				char szAuthType[64] = { 0 };

				if ( !pRequestInfo->pServerContext->GetServerVariable("AUTH_TYPE", szAuthType, &dwAuthTypeSize) )
				{
					// error retrieving authentication type
					RequestComplete(pRequestInfo, 501, 0);
					return FALSE;
				}

				// if it's empty or not NTLM or negotiate we fail.
				if ( !( *szAuthType != '\0 ' && 
					   ( !_stricmp(szAuthType, "NTLM") ||
					     !_stricmp(szAuthType, "Negotiate"))
					) )
				{
					// wrong authorization type or not authorized
					RequestComplete(pRequestInfo, 401, 0);
					return FALSE;
				}
				
				DWORD dwHeadersLen = 0;
				CStringA strHeaders;
				pRequestInfo->pServerContext->GetServerVariable("ALL_HTTP", NULL, &dwHeadersLen);
				BOOL bRet = pRequestInfo->pServerContext->GetServerVariable("ALL_HTTP", strHeaders.GetBuffer(dwHeadersLen), &dwHeadersLen);
				if (!bRet)
				{
					RequestComplete(pRequestInfo, 501, 0);
					return FALSE;
				}
				strHeaders.ReleaseBuffer(dwHeadersLen - 1);
				LPCSTR szCur = strHeaders;

				while(*szCur)
				{
					if (!strncmp(szCur, "HTTP_COMMAND:", 13))
					{
						szCur += 13;
						break;
					}

					szCur = strchr(szCur, '\n');
					if (!szCur)
					{
						RequestComplete(pRequestInfo, 501, 0);
						return FALSE;
					}

					szCur++;
				}


				if (!_strnicmp(szCur, "start-debug", sizeof("start-debug")-sizeof('\0')))
				{
					CCritSecLock Lock(m_critSec.m_sec);
					if (m_bDebug)
					{            
						HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_ALREADY_DEBUGGING);
						RequestComplete(pRequestInfo, 204, DBG_SUBERR_ALREADY_DEBUGGING);   // Already being debugged by another process
						return FALSE;
					}
					CHttpRequest HttpRequest;
					HttpRequest.Initialize(pRequestInfo->pServerContext);
					HttpRequest.InitFromPost();
					LPCSTR szString;
					szString = HttpRequest.FormVars.Lookup("DebugSessionID");
					if (!szString || !*szString)
					{
						HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_INVALID_SESSION);
						RequestComplete(pRequestInfo, 204, DBG_SUBERR_INVALID_SESSION);
						return FALSE;
					}
					CA2W szSessionID(szString);
					if (!szSessionID)
					{
						HandleError(pRequestInfo->pServerContext, 500, ISE_SUBERR_OUTOFMEM);
						RequestComplete(pRequestInfo, 500, ISE_SUBERR_OUTOFMEM);
						return FALSE;
					}
					DWORD dwPid = GetCurrentProcessId();
					LPWSTR szPoint = szSessionID;
					while (szPoint && *szPoint && wcsncmp(szPoint, L"autoattachclsid=", 16))
					{
						szPoint = wcschr(szPoint, ';');
						if (szPoint)
							szPoint++;
					}

					if (!szPoint || !*szPoint)
					{
						HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_BAD_ID);
						RequestComplete(pRequestInfo, 204, DBG_SUBERR_BAD_ID);
						return FALSE;
					}

					szPoint += (sizeof("autoattachclsid=") - 1);
					WCHAR szClsid[39];
					szClsid[38] = '\0';
					Checked::wcsncpy_s(szClsid, _countof(szClsid), szPoint, _TRUNCATE);
					if (szClsid[38] != '\0')
					{
						HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_BAD_ID);
						RequestComplete(pRequestInfo, 204, DBG_SUBERR_BAD_ID);
						return FALSE;
					}
					szClsid[38] = '\0';

					CLSID clsidDebugAutoAttach = CLSID_NULL;
					HRESULT hr = CLSIDFromString(szClsid, &clsidDebugAutoAttach);

					if (hr != S_OK)
					{
						HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_BAD_ID);
						RequestComplete(pRequestInfo, 204, DBG_SUBERR_BAD_ID);
						return FALSE;
					}

					size_t i=0,
						   nArrSize = sizeof(clsidDebugger)/sizeof(GUID);
					for (i=0; i<nArrSize; i++)
					{
						if( InlineIsEqualGUID(clsidDebugAutoAttach, clsidDebugger[i]) )
							break;
					}
					if (i >= nArrSize)
					{
						HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_BAD_ID);
						RequestComplete(pRequestInfo, 204, DBG_SUBERR_BAD_ID);
						return FALSE;
					}

					CComPtr<IDebugAutoAttach> spDebugAutoAttach;
					hr = CoCreateInstance(clsidDebugAutoAttach, NULL, CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER, __uuidof(IDebugAutoAttach), (void**)&spDebugAutoAttach);
					if (FAILED(hr))
					{
						if (hr == E_ACCESSDENIED)
							RequestComplete(pRequestInfo, 401, 0);
						else
						{
							HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_COCREATE);
							RequestComplete(pRequestInfo, 204, DBG_SUBERR_COCREATE);
						}
						return FALSE;
					}
					hr = spDebugAutoAttach->AutoAttach(GUID_NULL, dwPid, AUTOATTACH_PROGRAM_WIN32, 0, szSessionID);
					if (FAILED(hr))
					{
						char szRetBuf[256];
#if _SECURE_ATL
						int nLen = sprintf_s(szRetBuf, _countof(szRetBuf), "204 HRESULT=0x%.08X;ErrorString=Unable to attach to worker process", hr);
#else
						int nLen = _snprintf(szRetBuf, _countof(szRetBuf), "204 HRESULT=0x%.08X;ErrorString=Unable to attach to worker process", hr);
#endif
						if (nLen > 0)
						{
							DWORD dwLen = nLen;
							pRequestInfo->pServerContext->SendResponseHeader(NULL, szRetBuf, FALSE);
							pRequestInfo->pServerContext->WriteClient(szRetBuf, &dwLen);
							RequestComplete(pRequestInfo, 204, DBG_SUBERR_ATTACH);
						}
						return FALSE;
					}
					m_bDebug = TRUE;
					HandleError(pRequestInfo->pServerContext, 200, SUBERR_NONE);
					RequestComplete(pRequestInfo, 200, SUBERR_NONE);
					return FALSE;
				}
				else if (!_strnicmp(szCur, "stop-debug", sizeof("stop-debug")-sizeof('\0')))
				{
					m_bDebug = FALSE;
					HandleError(pRequestInfo->pServerContext, 200, SUBERR_NONE);
					RequestComplete(pRequestInfo, 200, SUBERR_NONE);
					return FALSE;
				}
				else
				{
					RequestComplete(pRequestInfo, 501, SUBERR_NONE);   // Not Implemented
					return FALSE;
				}            
			}
			return TRUE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}
#endif // defined(_DEBUG) || defined(ATLS_ENABLE_DEBUGGING)

	BOOL DispatchStencilCall(__inout AtlServerRequest *pRequestInfo)
	{
		ATLENSURE(pRequestInfo!=NULL);
		CSetThreadToken sec;

		m_reqStats.OnRequestDequeued();

		if (!sec.Initialize(pRequestInfo))
		{
			RequestComplete(pRequestInfo, 500, ISE_SUBERR_IMPERSONATIONFAILED);
			return FALSE;
		}

#if defined(_DEBUG) || defined(ATLS_ENABLE_DEBUGGING)
		if (!ProcessDebug(pRequestInfo))
			return TRUE;
#endif // defined(ATLS_ENABLE_DEBUGGING)

		if (pRequestInfo->m_hMutex)
		{
			// synchronize in case the previous async_noflush call isn't finished
			// setting up state for the next call.
			DWORD dwStatus = WaitForSingleObject(pRequestInfo->m_hMutex, ATLS_ASYNC_MUTEX_TIMEOUT);
			if (dwStatus != WAIT_OBJECT_0 && dwStatus != WAIT_ABANDONED)
			{
				RequestComplete(pRequestInfo, 500, ISE_SUBERR_UNEXPECTED);
				return FALSE;
			}
		}

#ifdef _DEBUG
		bool bAsyncAllowed = false;
#endif
		HTTP_CODE hcErr = HTTP_SUCCESS;
		if (pRequestInfo->dwRequestState == ATLSRV_STATE_BEGIN)
		{
			BOOL bAllowCaching = TRUE;
			if (TransmitFromCache(pRequestInfo, &bAllowCaching))    // Page is in the cache, send it and bail
			{                                       // Async Callback will handle freeing pRequestInfo
				return TRUE;
			}

			// get the srf filename
			LPCSTR szFileName = pRequestInfo->pServerContext->GetScriptPathTranslated();

			if (!szFileName)
			{
				RequestComplete(pRequestInfo, 500, ISE_SUBERR_UNEXPECTED);
				return FALSE;
			}

			LPCSTR szDot = szFileName + strlen(szFileName) - 1;

			// load a handler
			if (AsciiStricmp(szDot - ATLS_EXTENSION_LEN, c_AtlSRFExtension) == 0)
			{
				pRequestInfo->dwRequestType = ATLSRV_REQUEST_STENCIL;
				hcErr = LoadDispatchFile(szFileName, pRequestInfo);
			}
			else if (AsciiStricmp(szDot - ATLS_DLL_EXTENSION_LEN, c_AtlDLLExtension) == 0)
			{
				pRequestInfo->dwRequestType = ATLSRV_REQUEST_DLL;
				hcErr = LoadDllHandler(szFileName, pRequestInfo);
			}
			else
			{
				hcErr = HTTP_FAIL;
			}

			if (hcErr)
			{
				RequestComplete(pRequestInfo, HTTP_ERROR_CODE(hcErr), HTTP_SUBERROR_CODE(hcErr));
				return TRUE;
			}

			pRequestInfo->pfnHandleRequest = &IRequestHandler::HandleRequest;

			// initialize the handler
			DWORD dwStatus = 0;

			hcErr = pRequestInfo->pHandler->GetFlags(&dwStatus);
			if (hcErr)
			{
				RequestComplete(pRequestInfo, HTTP_ERROR_CODE(hcErr), HTTP_SUBERROR_CODE(hcErr));
				return FALSE;
			}

			if (bAllowCaching && ((dwStatus & ATLSRV_INIT_USECACHE) != 0) &&
				!strcmp(pRequestInfo->pServerContext->GetRequestMethod(), "GET"))
			{
				CComPtr<IHttpServerContext> spCacheCtx;
				if (!GetCacheServerContext(pRequestInfo, &m_PageCache, &spCacheCtx) ||
					!spCacheCtx)
				{
					RequestComplete(pRequestInfo, 500, ISE_SUBERR_OUTOFMEM);
					return FALSE;
				}

				pRequestInfo->pServerContext->Release();
				pRequestInfo->pServerContext = spCacheCtx.Detach();
			}

			if (dwStatus & (ATLSRV_INIT_USEASYNC | ATLSRV_INIT_USEASYNC_EX))
			{
#ifdef _DEBUG
				bAsyncAllowed = true;
#endif
				if (!pRequestInfo->pServerContext->RequestIOCompletion(AsyncCallback, (DWORD *)pRequestInfo))
				{
					RequestComplete(pRequestInfo, 500, SUBERR_NONE);
					return FALSE;
				}
			}

			if (dwStatus & ATLSRV_INIT_USEASYNC_EX)
			{
				pRequestInfo->m_hMutex = CreateMutex(NULL, FALSE, NULL);
				if (pRequestInfo->m_hMutex == NULL)
				{
					RequestComplete(pRequestInfo, 500, ISE_SUBERR_SYSOBJFAIL);
					return FALSE;
				}

				DWORD dwMutexStatus = WaitForSingleObject(pRequestInfo->m_hMutex, 10000);
				if (dwMutexStatus != WAIT_OBJECT_0 && dwMutexStatus != WAIT_ABANDONED)
				{
					RequestComplete(pRequestInfo, 500, ISE_SUBERR_UNEXPECTED);
					return FALSE;
				}
			}
			hcErr = pRequestInfo->pHandler->InitializeHandler(pRequestInfo, static_cast<IServiceProvider*>(this));
		}
#ifdef _DEBUG
		else // pRequestInfo->dwRequestState != ATLSRV_STATE_BEGIN
		{
			bAsyncAllowed = true;
		}
#endif

		ATLENSURE(pRequestInfo->pfnHandleRequest != NULL);

		if (hcErr == HTTP_SUCCESS)
		   hcErr = (pRequestInfo->pHandler->*pRequestInfo->pfnHandleRequest)(pRequestInfo, static_cast<IServiceProvider*>(this));

	   if (hcErr == HTTP_SUCCESS_NO_CACHE)
		{
			CComPtr<IPageCacheControl> spControl;
			HRESULT hr = pRequestInfo->pServerContext->QueryInterface(__uuidof(IPageCacheControl), reinterpret_cast<void**>(&spControl));
			if (hr == S_OK)
				spControl->Cache(FALSE);
		}

#ifdef _DEBUG
		// must use ATLSRV_INIT_USEASYNC to use ASYNC returns
		if (IsAsyncStatus(hcErr))
			ATLASSERT(bAsyncAllowed);

		// must use ATLSRV_INIT_USEASYNC_EX to use NOFLUSH returns
		if (IsAsyncNoFlushStatus(hcErr))
			ATLASSERT(pRequestInfo->m_hMutex);
#endif

		// save hMutex in case pRequestInfo is deleted by AsyncCallback after
		// we call StartAsyncFlush but before we check to see if we need to
		// call ReleaseMutex
		HANDLE hMutex = pRequestInfo->m_hMutex;

		if (IsAsyncStatus(hcErr))
		{
			if (IsAsyncDoneStatus(hcErr))
				pRequestInfo->dwRequestState = ATLSRV_STATE_DONE;
			else
				pRequestInfo->dwRequestState = ATLSRV_STATE_CONTINUE;

			if (IsAsyncFlushStatus(hcErr) && !StartAsyncFlush(pRequestInfo))
			{
				RequestComplete(pRequestInfo, 500, SUBERR_NONE);
				pRequestInfo = NULL;
			}
		}
		else
		{
			RequestComplete(pRequestInfo, HTTP_ERROR_CODE(hcErr), HTTP_SUBERROR_CODE(hcErr));
			pRequestInfo = NULL;
		}

		if (hMutex)
			ReleaseMutex(hMutex);

		return TRUE;
	}

	BOOL StartAsyncFlush(__in AtlServerRequest *pRequestInfo)
	{
		ATLENSURE(pRequestInfo);
		if (pRequestInfo->pszBuffer == NULL || pRequestInfo->dwBufferLen == 0)
		{
			ATLASSERT(FALSE);
			return FALSE;
		}

		ATLENSURE(pRequestInfo->pServerContext);
		BOOL bRet = TRUE;
		_ATLTRY
		{
			bRet = pRequestInfo->pServerContext->AsyncWriteClient(
				LPVOID(pRequestInfo->pszBuffer),
				&pRequestInfo->dwBufferLen);
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}

		return bRet;
	}

	long GetTotalRequests()
	{
		return m_reqStats.GetTotalRequests();
	}

	long GetFailedRequests()
	{
		return m_reqStats.GetFailedRequests();
	}

	long GetAvgResponseTime()
	{
		return m_reqStats.GetAvgResponseTime();
	}

	long GetCurrWaiting()
	{
		return m_reqStats.GetCurrWaiting();
	}

	long GetMaxWaiting()
	{
		return m_reqStats.GetMaxWaiting();
	}

	long GetActiveThreads()
	{
		return m_reqStats.GetActiveThreads();
	}

	__success(SUCCEEDED(return)) __checkReturn HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, __deref_out void **ppv)
	{
		if (!ppv)
			return E_POINTER;
		if (InlineIsEqualGUID(riid, __uuidof(IRequestStats)))
		{
			*ppv = static_cast<IRequestStats*>(this);
			AddRef();
			return S_OK;
		}
		if (InlineIsEqualGUID(riid, __uuidof(IUnknown)) ||
			InlineIsEqualGUID(riid, __uuidof(IServiceProvider)))
		{
			*ppv = static_cast<IServiceProvider*>(this);
			AddRef();
			return S_OK;
		}
		if (InlineIsEqualGUID(riid, __uuidof(IIsapiExtension)))
		{
			*ppv = static_cast<IIsapiExtension*>(this);
			AddRef();
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef()
	{
		return 1;
	}

	ULONG STDMETHODCALLTYPE Release()
	{
		return 1;
	}

	virtual __checkReturn HRESULT STDMETHODCALLTYPE QueryService(
		__in REFGUID guidService,
		__in REFIID riid,
		__deref_out void **ppvObject)
	{
		if (!ppvObject)
			return E_POINTER;

		if (InlineIsEqualGUID(guidService, __uuidof(IDllCache)))
			return m_DllCache.QueryInterface(riid, ppvObject);
		else if (InlineIsEqualGUID(guidService, __uuidof(IStencilCache)))
			return m_StencilCache.QueryInterface(riid, ppvObject);
		else if (InlineIsEqualGUID(guidService, __uuidof(IThreadPoolConfig)))
			return m_ThreadPool.QueryInterface(riid, ppvObject);
		else if (InlineIsEqualGUID(guidService, __uuidof(IAtlMemMgr)))
		{
			*ppvObject = static_cast<IAtlMemMgr *>(&m_heap);
			return S_OK;
		}
#ifndef ATL_NO_SOAP
		else if (InlineIsEqualGUID(guidService, __uuidof(ISAXXMLReader)))
		{
			CIsapiWorker *p = GetThreadWorker();
			ATLENSURE( p != NULL );
			return p->m_spReader->QueryInterface(riid, ppvObject);
		}
#endif

		// otherwise look it up in the servicemap
		return GetService(guidService, riid, ppvObject);
	}

	virtual HRESULT AddService(REFGUID guidService, REFIID riid, IUnknown *punkService, HINSTANCE hInstance)
	{
		if (!punkService)
			return E_INVALIDARG;

		if (!m_DllCache.AddRefModule(hInstance))
			return E_FAIL;

		ServiceNode srvNode;
		srvNode.hInst = hInstance;
		srvNode.punk = punkService;
		Checked::memcpy_s(&srvNode.guidService, sizeof(GUID), &guidService, sizeof(guidService));
		Checked::memcpy_s(&srvNode.riid, sizeof(IID), &riid, sizeof(riid));

		CComCritSecLock<CComCriticalSection> lock(m_critSec, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
		{
			return hr;
		}

		// if the service is already there, return S_FALSE
		int nIndex = m_serviceMap.Find(srvNode);
		if (nIndex >= 0)
			return S_FALSE;

		if (!m_serviceMap.Add(srvNode))
			return E_OUTOFMEMORY;

		punkService->AddRef();
		return S_OK;
	}

	virtual HRESULT RemoveService(__in REFGUID guidService, __in REFIID riid)
	{
		ServiceNode srvNode;
		Checked::memcpy_s(&srvNode.guidService, sizeof(GUID), &guidService, sizeof(guidService));
		Checked::memcpy_s(&srvNode.riid, sizeof(IID), &riid, sizeof(riid));

		CComCritSecLock<CComCriticalSection> lock(m_critSec, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
		{
			return hr;
		}

		int nIndex = m_serviceMap.Find(srvNode);
		if (nIndex < 0)
			return S_FALSE;

		ATLASSUME(m_serviceMap[nIndex].punk != NULL);
		m_serviceMap[nIndex].punk->Release();

		HINSTANCE hInstRemove = m_serviceMap[nIndex].hInst;

		m_serviceMap.RemoveAt(nIndex);

		if (!m_DllCache.ReleaseModule(hInstRemove))
			return S_FALSE;

		return S_OK;
	}

	__success(SUCCEEDED(return)) __checkReturn HRESULT GetService(__in REFGUID guidService, __in REFIID riid, __deref_out void **ppvObject) throw()
	{
		if (!ppvObject)
			return E_POINTER;

		*ppvObject = NULL;
		if (!m_serviceMap.GetSize())
			return E_NOINTERFACE;

		ServiceNode srvNode;
		Checked::memcpy_s(&srvNode.guidService, sizeof(GUID), &guidService, sizeof(guidService));
		Checked::memcpy_s(&srvNode.riid, sizeof(IID), &riid, sizeof(riid));

		CComCritSecLock<CComCriticalSection> lock(m_critSec, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
		{
			return hr;
		}

		int nIndex = m_serviceMap.Find(srvNode);
		if (nIndex < 0)
			return E_NOINTERFACE;

		ATLASSUME(m_serviceMap[nIndex].punk != NULL);
		return m_serviceMap[nIndex].punk->QueryInterface(riid, ppvObject);
	}

	HTTP_CODE LoadRequestHandler(__in LPCSTR szDllPath, __in LPCSTR szHandlerName, __in IHttpServerContext *pServerContext,
		__out HINSTANCE *phInstance, __deref_out IRequestHandler **ppHandler)
	{
		return _AtlLoadRequestHandler(szDllPath, szHandlerName, pServerContext, 
			phInstance, ppHandler, this, static_cast<IDllCache*>(&m_DllCache));
	} // LoadRequestHandler

}; // class CIsapiExtension


//===========================================================================================
// IMPORTANT NOTE TO USERS: 
// DO NOT ASSUME *ANYTHING* ABOUT THE STRUCTURE OF THESE MAPS/ENTRIES/FUNCTIONS--THEY CAN 
// AND *WILL* CHANGE IN THE FUTURE. CORRECT USAGE MANDATES THAT YOU USE THE MACROS PROVIDED.
// ABSOLUTELY NO GUARANTEES ABOUT BACKWARD COMPATABILITY ARE MADE FOR MANUALLY DEFINED 
// HANDLERS OR FUNCTIONS.
//===========================================================================================

typedef BOOL (*CREATEHANDLERFUNC)(IIsapiExtension *pExtension, IUnknown **ppOut);
typedef BOOL (*INITHANDLERFUNC)(IHttpServerContext*, IIsapiExtension*);
typedef void (*UNINITHANDLERFUNC)();

struct _HANDLER_ENTRY
{
	LPCSTR szName;
	CREATEHANDLERFUNC pfnCreate;
	INITHANDLERFUNC pfnInit;
	UNINITHANDLERFUNC pfnUninit;
};
// definitions of data segments and _HANDLER_ENTRY delimiters
#pragma section("ATLS$A", read, shared)
#pragma section("ATLS$Z", read, shared)
#pragma section("ATLS$C", read, shared)
extern "C"
{
__declspec(selectany) __declspec(allocate("ATLS$A")) ATL::_HANDLER_ENTRY * __phdlrA = NULL;
__declspec(selectany) __declspec(allocate("ATLS$Z")) ATL::_HANDLER_ENTRY * __phdlrZ = NULL;
}

#if !defined(_M_IA64)
#pragma comment(linker, "/merge:ATLS=.rdata")
#endif

#ifndef HANDLER_ENTRY_PRAGMA

#if defined(_M_IX86)
#define HANDLER_ENTRY_PRAGMA(class, line) __pragma(comment(linker, "/include:___phdlrEntry_" #class "_" #line));
#elif defined(_M_IA64)
#define HANDLER_ENTRY_PRAGMA(class, line) __pragma(comment(linker, "/include:__phdlrEntry_" #class "_" #line));
#elif defined(_M_AMD64)
#define HANDLER_ENTRY_PRAGMA(class, line) __pragma(comment(linker, "/include:__phdlrEntry_" #class "_" #line));
#else
#error Unknown Platform. define HANDLER_ENTRY_PRAGMA
#endif

#endif // HANDLER_ENTRY_PRAGMA

// DECLARE_REQUEST_HANDLER macro
#define __DECLARE_REQUEST_HANDLER_INTERNAL(handlerName, className, classQName, lineNum) \
__declspec(selectany) ATL::_HANDLER_ENTRY __hdlrEntry_ ## className ## _ ## lineNum = { handlerName, classQName::CreateRequestHandler, classQName::InitRequestHandlerClass, classQName::UninitRequestHandlerClass }; \
extern "C" __declspec(allocate("ATLS$C")) __declspec(selectany) \
ATL::_HANDLER_ENTRY * const __phdlrEntry_ ## className ## _ ## lineNum = &__hdlrEntry_ ## className ## _ ## lineNum; \
HANDLER_ENTRY_PRAGMA(className, lineNum) \
__if_not_exists(GetAtlHandlerByName) \
{ \
extern "C" ATL_NOINLINE inline BOOL __declspec(dllexport) __stdcall GetAtlHandlerByName(LPCSTR szHandlerName, IIsapiExtension *pExtension, IUnknown **ppHandler) throw() \
{ \
	*ppHandler = NULL; \
	ATL::_HANDLER_ENTRY **pEntry = &__phdlrA; \
	while (pEntry != &__phdlrZ) \
	{ \
		if (*pEntry && (*pEntry)->szName) \
		{ \
			if (strcmp((*pEntry)->szName, szHandlerName)==0) \
			{ \
				return (*(*pEntry)->pfnCreate)(pExtension, ppHandler); \
			} \
		} \
		pEntry++; \
	} \
	return FALSE; \
} \
extern "C" ATL_NOINLINE inline  BOOL __declspec(dllexport) __stdcall InitializeAtlHandlers(IHttpServerContext *pContext, IIsapiExtension *pExt) throw() \
{ \
	ATL::_HANDLER_ENTRY **pEntry = &__phdlrA; \
	BOOL bRet = TRUE; \
	while (pEntry != &__phdlrZ) \
	{ \
		if (*pEntry && (*pEntry)->szName && (*pEntry)->pfnInit) \
		{ \
			bRet = (*(*pEntry)->pfnInit)(pContext, pExt); \
			if (!bRet) \
				break; \
		} \
		pEntry++; \
	} \
	if (!bRet) \
	{ \
		if (pEntry == &__phdlrA) \
			return FALSE; \
		do \
		{ \
			pEntry--; \
			if(*pEntry) \
				(*(*pEntry)->pfnUninit)(); \
		} \
		while (pEntry != &__phdlrA); \
	} \
	return bRet; \
} \
extern "C" ATL_NOINLINE inline void __declspec(dllexport) __stdcall UninitializeAtlHandlers() throw() \
{\
	ATL::_HANDLER_ENTRY **pEntry = &__phdlrA; \
	while (pEntry != &__phdlrZ) \
	{ \
		if (*pEntry && (*pEntry)->szName && (*pEntry)->pfnUninit) \
		{ \
			(*(*pEntry)->pfnUninit)(); \
		} \
		pEntry++; \
	} \
} \
}

#define __DECLARE_REQUEST_HANDLER(handlerName, className, classQName, lineNum) __DECLARE_REQUEST_HANDLER_INTERNAL(handlerName, className, classQName, lineNum)
#define DECLARE_REQUEST_HANDLER(handlerName, className, classQName) __DECLARE_REQUEST_HANDLER(handlerName, className, classQName, __COUNTER__)

#define BEGIN_HANDLER_MAP()
#define HANDLER_ENTRY(handlerName, className) DECLARE_REQUEST_HANDLER(handlerName, className, className)
#define HANDLER_ENTRY_EX(handlerName, className, classQName) DECLARE_REQUEST_HANDLER(handlerName, className, classQName)
#define END_HANDLER_MAP()

#define __HANDLER_ENTRY_SDL_INTERNAL(handlerString, handlerClass, handlerQClass, sdlClassName, lineNum)\
_ATLSOAP_DECLARE_WSDL_SRF() \
extern __declspec(selectany) const char const s_szClassName##sdlClassName##lineNum[]=handlerString;\
typedef ATL::CSDLGenerator<handlerQClass, s_szClassName##sdlClassName##lineNum> sdlClassName; \
HANDLER_ENTRY_EX(handlerString, handlerClass, handlerQClass)\
HANDLER_ENTRY(#sdlClassName, sdlClassName)

#define __HANDLER_ENTRY_SDL(handlerString, handlerClass, handlerQClass, sdlClassName, lineNum) __HANDLER_ENTRY_SDL_INTERNAL(handlerString, handlerClass, handlerQClass, sdlClassName, lineNum)
#define HANDLER_ENTRY_SDL(handlerString, handlerClass, handlerQClass, sdlClassName) __HANDLER_ENTRY_SDL(handlerString, handlerClass, handlerQClass, sdlClassName, __COUNTER__)
// 
// Use this class to check the authorization level of a client who is making
// a request to this application. This class checks for the stronger authentication
// levels (NTLM and Negotiate). You can call it directly from an implementation
// of HandleRequest to check authorization before handling a request.
#define MAX_AUTH_TYPE 50
#define MAX_NAME_LEN 255

template <class T>
class CVerifyAuth
{
public:
	HTTP_CODE IsAuthorized(__in AtlServerRequest *pInfo, __in_opt const SID* psidAuthGroup)
	{
		ATLENSURE(pInfo);
		ATLENSURE(pInfo->pServerContext);
		ATLASSERT(psidAuthGroup);
		ATLASSERT(::IsValidSid((PSID) psidAuthGroup));

		HTTP_CODE hcErr = HTTP_UNAUTHORIZED;
		char szAuthType[MAX_AUTH_TYPE];
		DWORD dwSize = MAX_AUTH_TYPE;
		_ATLTRY
		{
			if (pInfo->pServerContext->GetServerVariable("AUTH_TYPE", 
				szAuthType, &dwSize))
			{
				if (szAuthType[0] && (!_stricmp(szAuthType, "NTLM") 
					|| !_stricmp(szAuthType, "Negotiate")))
				{
					// if we were passed a group name
					// we check to see that the logged on user is part
					// of that group, else we just return success.
					if (psidAuthGroup)
					{
						T* pT = static_cast<T*>(this);
						if (pT->CheckAccount(pInfo->pServerContext, psidAuthGroup))
							hcErr = HTTP_SUCCESS;
						else
							hcErr = pT->HandleError(pInfo);
					}
					else
						hcErr = HTTP_SUCCESS;
				}
			}
		}
		_ATLCATCHALL()
		{
			hcErr = HTTP_FAIL;
		}

		return hcErr;       
	}

	virtual bool CheckAccount(IHttpServerContext *pContext, const SID *psidAuthGroup) throw()
	{
		(pContext); // unused
		(psidAuthGroup); // unused
		return false;
	}

	HTTP_CODE HandleError(AtlServerRequest *pRequestInfo) throw()
	{
		pRequestInfo; // unused
		return HTTP_FAIL;
	}

	__checkReturn bool CheckAuthAccount(__in IHttpServerContext *pContext, __in const SID* psidAuthGroup) throw()
	{
		ATLASSERT(pContext);
		ATLASSERT(psidAuthGroup);
		if (!pContext || !psidAuthGroup)
			return false;

		HANDLE hToken = INVALID_HANDLE_VALUE;
		bool bIsMember;
		_ATLTRY
		{
			if (!pContext->GetImpersonationToken(&hToken) ||
							hToken == INVALID_HANDLE_VALUE)
				return false;

			CAccessToken tok;
			tok.Attach(hToken);
			bool bRet = tok.CheckTokenMembership(CSid(psidAuthGroup), &bIsMember);
			tok.Detach();

			if (!bRet)
				return false;
		}
		_ATLCATCHALL()
		{
			bIsMember = false;
		}

		return bIsMember;
	}
};

// Checks that the user that is logging on is in the required group
class CDefaultAuth :
	public CVerifyAuth<CDefaultAuth>
{
public:
	virtual bool CheckAccount(__in IHttpServerContext *pContext, __in const SID* psidAuthGroup) throw()
	{
		return CheckAuthAccount(pContext, psidAuthGroup);
	}

	HTTP_CODE HandleError(__in AtlServerRequest *pRequestInfo) throw()
	{
		ATLASSERT(pRequestInfo); // should always be valid
		if(!pRequestInfo)
		{
			return HTTP_FAIL;
		}

		_ATLTRY
		{
			CHttpResponse response(pRequestInfo->pServerContext);
			response.Write(GetErrorResponse());
			response.Flush();
		}
		_ATLCATCHALL()
		{
			return HTTP_FAIL;
		}

		return HTTP_SUCCESS_NO_PROCESS;
	}

	virtual LPCSTR GetErrorResponse()
	{
		static const char *szResponse = "<html><body>"
			"<H1 align=center>NOT AUTHORIZED</H1><p>"
			"</body></html>";
		return szResponse;
	}

};

#endif // _WIN32_WCE

} // namespace ATL
#pragma pack(pop)

#pragma warning(pop)

#endif // __ATLISAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlsecurity.inl ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.
#ifndef __ATLSECURITY_INL__
#define __ATLSECURITY_INL__

#pragma once

#ifndef __ATLSECURITY_H__
	#error atlsecurity.inl requires atlsecurity.h to be included first
#endif

#pragma warning(push)
#pragma warning(3: 4294)
#pragma warning(disable: 4571) //catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions
namespace ATL
{
#pragma comment(lib, "userenv.lib")

// **************************************************************
// CSid implementation

inline CSid::CSid() throw() :
	m_bValid(false),
	m_sidnameuse(SidTypeInvalid)
{
}

inline CSid::CSid(LPCTSTR pszAccountName, LPCTSTR pszSystem /* = NULL */) throw(...) :
	m_bValid(false),
	m_sidnameuse(SidTypeInvalid)
{
	if(!LoadAccount(pszAccountName, pszSystem))
		AtlThrowLastWin32();
}

inline CSid::CSid(const SID *pSid, LPCTSTR pszSystem /* = NULL */) throw(...) :
	m_bValid(false),
	m_sidnameuse(SidTypeInvalid)
{
	if(!LoadAccount(pSid, pszSystem))
		AtlThrowLastWin32();
}

#pragma warning(push)
#pragma warning(disable : 4793)
inline CSid::CSid(
		const SID_IDENTIFIER_AUTHORITY &IdentifierAuthority,
		BYTE nSubAuthorityCount,
		...) throw(...) :
	m_bValid(false),
	m_sidnameuse(SidTypeInvalid)
{
	BYTE buffer[SECURITY_MAX_SID_SIZE];
	SID *pSid = reinterpret_cast<SID*>(buffer);

	ATLASSERT(nSubAuthorityCount);
	if(!nSubAuthorityCount || ::GetSidLengthRequired(nSubAuthorityCount) > SECURITY_MAX_SID_SIZE)
		AtlThrow(E_INVALIDARG);

	if(!::InitializeSid(pSid,
		const_cast<SID_IDENTIFIER_AUTHORITY *>(&IdentifierAuthority),
		nSubAuthorityCount))
	{
		AtlThrowLastWin32();
	}

	va_list args;
	va_start(args, nSubAuthorityCount);
	for(UINT i = 0; i < nSubAuthorityCount; i++)
		*::GetSidSubAuthority(pSid, i) = va_arg(args, DWORD);
	va_end(args);

	Copy(*pSid);

	m_sidnameuse = SidTypeUnknown;
}
#pragma warning(pop)

inline CSid::~CSid() throw()
{
}

inline CSid::CSid(const CSid &rhs) throw(...) :
	m_sidnameuse(rhs.m_sidnameuse),
	m_bValid(rhs.m_bValid),
	m_strAccountName(rhs.m_strAccountName),
	m_strDomain(rhs.m_strDomain),
	m_strSid(rhs.m_strSid)
{
	if (!rhs.m_bValid)
		return;

	if(!rhs.IsValid())
		AtlThrow(E_INVALIDARG);

	if(!::CopySid(rhs.GetLength(), _GetPSID(), rhs._GetPSID()))
	{
		HRESULT hr = AtlHresultFromLastError();
		AtlThrow(hr);
	}
}

inline CSid &CSid::operator=(const CSid &rhs) throw(...)
{
	if(this != &rhs)
	{
		m_sidnameuse = rhs.m_sidnameuse;
		m_strAccountName = rhs.m_strAccountName;
		m_strDomain = rhs.m_strDomain;
		m_strSid = rhs.m_strSid;
		m_bValid = rhs.m_bValid;

		if (m_bValid)
		{
			if(!::CopySid(rhs.GetLength(), _GetPSID(), rhs._GetPSID()))
			{
				HRESULT hr = AtlHresultFromLastError();
				m_bValid = false;
				AtlThrow(hr);
			}
		}
	}
	return *this;
}

inline CSid::CSid(const SID &rhs) throw(...) :
	m_bValid(false),
	m_sidnameuse(SidTypeInvalid)
{
	Copy(rhs);
}

inline CSid &CSid::operator=(const SID &rhs) throw(...)
{
	if (!m_bValid || _GetPSID() != &rhs)
	{
		Clear();
		Copy(rhs);

		m_sidnameuse = SidTypeUnknown;
	}
	return *this;
}

inline bool CSid::LoadAccount(LPCTSTR pszAccountName, LPCTSTR pszSystem /* = NULL */) throw(...)
{
    Clear();

	ATLASSERT(pszAccountName);
	if (!pszAccountName)
    {
		return false;
    }

	static const DWORD dwDomainSize = 128; // reasonable to start with
	BYTE buffSid[SECURITY_MAX_SID_SIZE];
	CTempBuffer<TCHAR, dwDomainSize> buffDomain;
	buffDomain.Allocate(dwDomainSize); // just assign the static buffer

	SID *pSid = reinterpret_cast<SID *>(buffSid);
	TCHAR *szDomain = static_cast<TCHAR *>(buffDomain);
	DWORD cbSid = SECURITY_MAX_SID_SIZE;
	DWORD cbDomain = dwDomainSize;

	BOOL bSuccess = ::LookupAccountName(pszSystem, pszAccountName, pSid, &cbSid, szDomain, &cbDomain, &m_sidnameuse);
	if (!bSuccess && ::GetLastError() == ERROR_INSUFFICIENT_BUFFER)
	{
		// We could have gotten the insufficient buffer error because 
		// one or both of pSid and szDomain was too small. Check for that
		// here.
		if (cbSid > SECURITY_MAX_SID_SIZE)
		{
			// Should never happen. Fail
			AtlThrow(E_FAIL);
		}

		if (cbDomain > dwDomainSize)
		{
			// Failed because domain was not big enough, reallocate it.
			buffDomain.Reallocate(cbDomain);
			szDomain = static_cast<TCHAR *>(buffDomain);
		}
		bSuccess = ::LookupAccountName(pszSystem, pszAccountName, pSid, &cbSid, szDomain, &cbDomain, &m_sidnameuse);
	}

	if (bSuccess)
	{
		// should be taken care of by ::LookupAccountName
		ATLASSERT(::GetLengthSid(pSid) < SECURITY_MAX_SID_SIZE);

		// LookupAccountName doesn't change cbSid on success (although it changes cbDomain)
		m_bValid = true;
		if (::CopySid(cbSid, _GetPSID(), pSid))
		{
			m_strDomain = szDomain;
			m_strAccountName = pszAccountName;
			m_strSystem = pszSystem;
			return true;
		}
	}

	Clear();
	return false;
}

inline bool CSid::LoadAccount(const SID *pSid, LPCTSTR pszSystem /* = NULL */) throw(...)
{
    Clear();
	ATLASSERT(pSid);

	if(pSid)
	{
		_ATLTRY
		{
			m_strSystem = pszSystem;
			Copy(*pSid);
			return true;
		}
		_ATLCATCHALL()
		{
			Clear();
			throw;
		}
	}
	return false;
}

inline LPCTSTR CSid::AccountName() const throw(...)
{
	if(m_strAccountName.IsEmpty())
		GetAccountNameAndDomain();
	return m_strAccountName;
}

inline LPCTSTR CSid::Domain() const throw(...)
{
	if(m_strDomain.IsEmpty())
		GetAccountNameAndDomain();
	return m_strDomain;
}

inline LPCTSTR CSid::Sid() const throw(...)
{
	_ATLTRY
	{
		if(m_strSid.IsEmpty())
		{
#if(_WIN32_WINNT >= 0x0500)
			LPTSTR pszSid;
			if(::ConvertSidToStringSid(_GetPSID(), &pszSid))
			{
				m_strSid = pszSid;
				::LocalFree(pszSid);
			}
#else
			SID_IDENTIFIER_AUTHORITY *psia = ::GetSidIdentifierAuthority(_GetPSID());
			UINT i;

			if(psia->Value[0] || psia->Value[1])
			{
				m_strSid.Format(_T("S-%d-0x%02hx%02hx%02hx%02hx%02hx%02hx"), SID_REVISION,
					(USHORT)psia->Value[0],
					(USHORT)psia->Value[1],
					(USHORT)psia->Value[2],
					(USHORT)psia->Value[3],
					(USHORT)psia->Value[4],
					(USHORT)psia->Value[5]);
			}
			else
			{
				ULONG nAuthority = 0;
				for(i = 2; i < 6; i++)
				{
					nAuthority <<= 8;
					nAuthority |= psia->Value[i];
				}
				m_strSid.Format(_T("S-%d-%lu"), SID_REVISION, nAuthority);
			}

			UINT nSubAuthorityCount = *::GetSidSubAuthorityCount(_GetPSID());
			CString strTemp;
			for(i = 0; i < nSubAuthorityCount; i++)
			{
				strTemp.Format(_T("-%lu"), *::GetSidSubAuthority(_GetPSID(), i));
				m_strSid += strTemp;
			}
#endif
		}
		return m_strSid;
	}
	_ATLCATCHALL()
	{
		m_strSid.Empty();
		throw;
	}
}

inline const SID *CSid::GetPSID() const throw(...)
{
	return _GetPSID();
}

inline CSid::operator const SID *() const throw(...)
{
	return GetPSID();
}

inline SID_NAME_USE CSid::SidNameUse() const throw()
{
	return m_sidnameuse;
}

inline UINT CSid::GetLength() const throw()
{
	ATLASSERT(IsValid());
	return ::GetLengthSid(_GetPSID());
}

inline bool CSid::EqualPrefix(const CSid &rhs) const throw()
{
	if (_GetPSID() == NULL || rhs._GetPSID() == NULL || !IsValid() || !rhs.IsValid())
	{
		return FALSE;
	}
	return 0 != ::EqualPrefixSid(_GetPSID(), rhs._GetPSID());
}

inline bool CSid::EqualPrefix(const SID &rhs) const throw()
{
	if (_GetPSID() == NULL || !IsValid() || !::IsValidSid(const_cast<SID *>(&rhs)))
	{
		return FALSE;
	}
	return 0 != ::EqualPrefixSid(_GetPSID(), const_cast<SID *>(&rhs));
}

inline const SID_IDENTIFIER_AUTHORITY *CSid::GetPSID_IDENTIFIER_AUTHORITY() const throw()
{
	ATLASSERT(IsValid());
	return ::GetSidIdentifierAuthority(_GetPSID());
}

inline DWORD CSid::GetSubAuthority(DWORD nSubAuthority) const throw()
{
	ATLASSERT(IsValid());
	return *::GetSidSubAuthority(_GetPSID(), nSubAuthority);
}

inline UCHAR CSid::GetSubAuthorityCount() const throw()
{
	ATLASSERT(IsValid());
	return *::GetSidSubAuthorityCount(_GetPSID());
}

inline bool CSid::IsValid() const throw()
{
	if (!m_bValid)
		return false;
	return 0 != ::IsValidSid(_GetPSID());
}

inline void CSid::Clear() throw()
{
	m_sidnameuse = SidTypeInvalid;
	m_strAccountName.Empty();
	m_strDomain.Empty();
	m_strSid.Empty();
	m_strSystem.Empty();
	m_bValid = false;
}

inline void CSid::Copy(const SID &rhs) throw(...)
{
	// This function assumes everything is cleaned up/initialized
	// (with the exception of m_strSystem).
	// It does some sanity checking to prevent memory leaks, but
	// you should clean up all members of CSid before calling this
	// function.  (i.e., results are unpredictable on error)

	ATLASSUME(m_sidnameuse == SidTypeInvalid);
	ATLASSUME(m_strAccountName.IsEmpty());
	ATLASSUME(m_strDomain.IsEmpty());
	ATLASSUME(m_strSid.IsEmpty());

	SID *p = const_cast<SID *>(&rhs);
	if(!::IsValidSid(p))
		AtlThrow(E_INVALIDARG);

	DWORD dwLengthSid = ::GetLengthSid(p);
	if (dwLengthSid > SECURITY_MAX_SID_SIZE)
		AtlThrow(E_INVALIDARG);

	m_bValid = true;
	if(!::CopySid(dwLengthSid, _GetPSID(), p))
	{
		HRESULT hr = AtlHresultFromLastError();
		m_bValid = false;
		AtlThrow(hr);
	}
}

inline void CSid::GetAccountNameAndDomain() const throw(...)
{
	static const DWORD dwMax = 32;
	DWORD cbName = dwMax, cbDomain = dwMax;
	TCHAR szName[dwMax], szDomain[dwMax];

#pragma warning(push)
#pragma warning(disable: 6202)
	/* Prefast false warning: we do not use cbName or cbDomain as char buffers when call LookupAccountSid.*/
	if(::LookupAccountSid(m_strSystem, _GetPSID(), szName, &cbName, szDomain, &cbDomain, &m_sidnameuse))
#pragma warning(pop)
	{
		m_strAccountName = szName;
		m_strDomain = szDomain;
	}
	else
	{
		switch(::GetLastError())
		{
		case ERROR_INSUFFICIENT_BUFFER:
		{
			LPTSTR pszName = m_strAccountName.GetBuffer(cbName);
			LPTSTR pszDomain = m_strDomain.GetBuffer(cbDomain);

			if (!::LookupAccountSid(m_strSystem, _GetPSID(), pszName, &cbName, pszDomain, &cbDomain, &m_sidnameuse))
				AtlThrowLastWin32();

			m_strAccountName.ReleaseBuffer();
			m_strDomain.ReleaseBuffer();
			break;
		}

		case ERROR_NONE_MAPPED:
			m_strAccountName.Empty();
			m_strDomain.Empty();
			m_sidnameuse = SidTypeUnknown;
			break;

		default:
			ATLASSERT(FALSE);
		}
	}
}

inline SID* CSid::_GetPSID() const throw()
{
	ATLASSUME(m_bValid);
	return reinterpret_cast<SID*>(const_cast<BYTE*>(m_buffer));
}

inline bool operator==(const CSid &lhs, const CSid &rhs) throw()
{
	if( lhs.GetPSID() == NULL || rhs.GetPSID() == NULL || !lhs.IsValid() || !rhs.IsValid() )
		return false;
	return 0 != ::EqualSid(const_cast<SID*>(lhs.GetPSID()), const_cast<SID*>(rhs.GetPSID()));
}

inline bool operator!=(const CSid &lhs, const CSid &rhs) throw()
{
	return !(lhs == rhs);
}

inline bool operator<(const CSid &lhs, const CSid &rhs) throw()
{
	// all other ordered comparisons are done in terms of this one
	const SID_IDENTIFIER_AUTHORITY* la = lhs.GetPSID_IDENTIFIER_AUTHORITY();
	const SID_IDENTIFIER_AUTHORITY* ra = rhs.GetPSID_IDENTIFIER_AUTHORITY();

	for (int i=0; i<6; i++)
	{
		if (la->Value[i] < ra->Value[i])
		{
			return true;
		}
		else if (la->Value[i] > ra->Value[i])
		{
			return false;
		}
	}

	for (UCHAR i=0; i<rhs.GetSubAuthorityCount(); i++)
	{
		if (lhs.GetSubAuthorityCount() == i)
		{
			// lhs is a prefix of rhs
			return true;
		}

		if (lhs.GetSubAuthority(i) < rhs.GetSubAuthority(i))
		{
			return true;
		}
		else if (lhs.GetSubAuthority(i) > rhs.GetSubAuthority(i))
		{
			return false;
		}
	}

	return false;
}

inline bool operator>(const CSid &lhs, const CSid &rhs) throw()
{
	return (rhs < lhs);
}

inline bool operator<=(const CSid &lhs, const CSid &rhs) throw()
{
	return !(rhs < lhs);
}

inline bool operator>=(const CSid &lhs, const CSid &rhs) throw()
{
	return !(lhs < rhs);
}

// **************************************************************
// Well-known sids

namespace Sids
{
__declspec(selectany) extern const SID_IDENTIFIER_AUTHORITY
	SecurityNullSidAuthority		= SECURITY_NULL_SID_AUTHORITY,
	SecurityWorldSidAuthority		= SECURITY_WORLD_SID_AUTHORITY,
	SecurityLocalSidAuthority		= SECURITY_LOCAL_SID_AUTHORITY,
	SecurityCreatorSidAuthority		= SECURITY_CREATOR_SID_AUTHORITY,
	SecurityNonUniqueAuthority		= SECURITY_NON_UNIQUE_AUTHORITY,
	SecurityNTAuthority				= SECURITY_NT_AUTHORITY;

// Universal
inline CSid Null() throw(...)
{
	return CSid(SecurityNullSidAuthority, 1, SECURITY_NULL_RID);
}
inline CSid World() throw(...)
{
	return CSid(SecurityWorldSidAuthority, 1, SECURITY_WORLD_RID);
}
inline CSid Local() throw(...)
{
	return CSid(SecurityLocalSidAuthority, 1, SECURITY_LOCAL_RID);
}
inline CSid CreatorOwner() throw(...)
{
	return CSid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_OWNER_RID);
}
inline CSid CreatorGroup() throw(...)
{
	return CSid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_GROUP_RID);
}
inline CSid CreatorOwnerServer() throw(...)
{
	return CSid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_OWNER_SERVER_RID);
}
inline CSid CreatorGroupServer() throw(...)
{
	return CSid(SecurityCreatorSidAuthority, 1, SECURITY_CREATOR_GROUP_SERVER_RID);
}

// NT Authority
inline CSid Dialup() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_DIALUP_RID);
}
inline CSid Network() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_NETWORK_RID);
}
inline CSid Batch() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_BATCH_RID);
}
inline CSid Interactive() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_INTERACTIVE_RID);
}
inline CSid Service() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_SERVICE_RID);
}
inline CSid AnonymousLogon() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_ANONYMOUS_LOGON_RID);
}
inline CSid Proxy() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_PROXY_RID);
}
inline CSid ServerLogon() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_SERVER_LOGON_RID);
}
inline CSid Self() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_PRINCIPAL_SELF_RID);
}
inline CSid AuthenticatedUser() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_AUTHENTICATED_USER_RID);
}
inline CSid RestrictedCode() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_RESTRICTED_CODE_RID);
}
inline CSid TerminalServer() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_TERMINAL_SERVER_RID);
}
inline CSid System() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_LOCAL_SYSTEM_RID);
}


inline CSid NetworkService() throw(...)
{
	return CSid(SecurityNTAuthority, 1, SECURITY_NETWORK_SERVICE_RID);

}

// NT Authority\BUILTIN
inline CSid Admins() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS);
}
inline CSid Users() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_USERS);
}
inline CSid Guests() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_GUESTS);
}
inline CSid PowerUsers() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS);
}
inline CSid AccountOps() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ACCOUNT_OPS);
}
inline CSid SystemOps() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_SYSTEM_OPS);
}
inline CSid PrintOps() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_PRINT_OPS);
}
inline CSid BackupOps() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_BACKUP_OPS);
}
inline CSid Replicator() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_REPLICATOR);
}
inline CSid RasServers() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_RAS_SERVERS);
}
inline CSid PreW2KAccess() throw(...)
{
	return CSid(SecurityNTAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_PREW2KCOMPACCESS);
}
} // namespace Sids

// **************************************************************
// CAcl implementation

inline CAcl::CAcl() throw() :
	m_pAcl(NULL),
	m_bNull(false),
	m_dwAclRevision(ACL_REVISION)
{
}

inline CAcl::~CAcl() throw()
{
	free(m_pAcl);
}

inline CAcl::CAcl(const CAcl &rhs) throw(...) :
	m_pAcl(NULL),
	m_bNull(rhs.m_bNull),
	m_dwAclRevision(rhs.m_dwAclRevision)
{
}

inline CAcl &CAcl::operator=(const CAcl &rhs) throw(...)
{
	if(this != &rhs)
	{
		free(m_pAcl);
		m_pAcl = NULL;
		m_bNull = rhs.m_bNull;
		m_dwAclRevision = rhs.m_dwAclRevision;
	}
	return *this;
}

inline void CAcl::GetAclEntries(
	CSid::CSidArray *pSids,
	CAccessMaskArray *pAccessMasks /* = NULL */,
	CAceTypeArray *pAceTypes /* = NULL */,
	CAceFlagArray *pAceFlags /* = NULL */) const throw(...)
{
	ATLASSERT(pSids);
	if(pSids)
	{
		pSids->RemoveAll();
		if(pAccessMasks)
			pAccessMasks->RemoveAll();
		if(pAceTypes)
			pAceTypes->RemoveAll();
		if(pAceFlags)
			pAceFlags->RemoveAll();

		const CAce *pAce;
		const UINT nCount = GetAceCount();
		for(UINT i = 0; i < nCount; i++)
		{
			pAce = GetAce(i);

			pSids->Add(pAce->Sid());
			if(pAccessMasks)
				pAccessMasks->Add(pAce->AccessMask());
			if(pAceTypes)
				pAceTypes->Add(pAce->AceType());
			if(pAceFlags)
				pAceFlags->Add(pAce->AceFlags());
		}
	}
}

inline void CAcl::GetAclEntry(
	UINT nIndex,
	CSid* pSid,
	ACCESS_MASK* pMask /* = NULL */,
	BYTE* pType /* = NULL */,
	BYTE* pFlags /* = NULL */,
	GUID* pObjectType /* = NULL */,
	GUID* pInheritedObjectType /* = NULL */) const throw(...)
{
	const CAce* pAce = GetAce(nIndex);

	if (pSid)
		*pSid = pAce->Sid();
	if (pMask)
		*pMask = pAce->AccessMask();
	if (pType)
		*pType = pAce->AceType();
	if (pFlags)
		*pFlags = pAce->AceFlags();
	if (pObjectType)
		*pObjectType = pAce->ObjectType();
	if (pInheritedObjectType)
		*pInheritedObjectType = pAce->InheritedObjectType();
}

inline bool CAcl::RemoveAces(const CSid &rSid) throw(...)
{
	ATLASSERT(rSid.IsValid());
	if (!rSid.IsValid())
		AtlThrow(E_INVALIDARG);

	if(IsNull())
		return false;

	bool bRet = false;
	const CAce *pAce;
	UINT nIndex = 0;

	while(nIndex < GetAceCount())
	{
		pAce = GetAce(nIndex);
		if(rSid == pAce->Sid())
		{
			RemoveAce(nIndex);
			bRet = true;
		}
		else
			nIndex++;
	}

	if(bRet)
		Dirty();

	return bRet;
}

inline const ACL *CAcl::GetPACL() const throw(...)
{
	if(!m_pAcl && !m_bNull)
	{
		UINT nAclLength = sizeof(ACL);
		const CAce *pAce;
		UINT i;
		const UINT nCount = GetAceCount();

		for(i = 0; i < nCount; i++)
		{
			pAce = GetAce(i);
			ATLASSERT(pAce);
			if(pAce)
				nAclLength += pAce->GetLength();
		}

		m_pAcl = static_cast<ACL *>(malloc(nAclLength));
		if(!m_pAcl)
			AtlThrow(E_OUTOFMEMORY);

		if(!::InitializeAcl(m_pAcl, (DWORD) nAclLength, m_dwAclRevision))
		{
			HRESULT hr = AtlHresultFromLastError();
			free(m_pAcl);
			m_pAcl = NULL;
			AtlThrow(hr);
		}
		else
		{
			PrepareAcesForACL();

			for(i = 0; i < nCount; i++)
			{
				pAce = GetAce(i);
				ATLASSERT(pAce);
				if(!pAce ||
					!::AddAce(m_pAcl, m_dwAclRevision, MAXDWORD, pAce->GetACE(), (DWORD) pAce->GetLength()))
				{
					HRESULT hr = AtlHresultFromLastError();
					free(m_pAcl);
					m_pAcl = NULL;
					AtlThrow(hr);
				}
			}
		}
	}
	return m_pAcl;
}

inline CAcl::operator const ACL *() const throw(...)
{
	return GetPACL();
}

inline UINT CAcl::GetLength() const throw(...)
{
	ACL *pAcl = const_cast<ACL *>(GetPACL());
	ACL_SIZE_INFORMATION AclSize;

	ATLASSERT(pAcl);

	if(!::GetAclInformation(pAcl, &AclSize, sizeof(AclSize), AclSizeInformation))
		AtlThrowLastWin32();

	return AclSize.AclBytesInUse;
}

inline void CAcl::SetNull() throw()
{
	RemoveAllAces();
	m_bNull = true;
}

inline void CAcl::SetEmpty() throw()
{
	RemoveAllAces();
	m_bNull = false;
}

inline bool CAcl::IsNull() const throw()
{
	return m_bNull;
}

inline bool CAcl::IsEmpty() const throw()
{
	return !m_bNull && 0 == GetAceCount();
}

inline void CAcl::Dirty() throw()
{
	free(m_pAcl);
	m_pAcl = NULL;
}

inline void CAcl::PrepareAcesForACL() const throw()
{
}

// **************************************************************
// CAcl::CAce implementation

inline CAcl::CAce::CAce(const CSid &rSid, ACCESS_MASK accessmask, BYTE aceflags) throw(...) :
	m_dwAccessMask(accessmask),
	m_sid(rSid),
	m_aceflags(aceflags),
	m_pAce(NULL)
{
}

inline CAcl::CAce::~CAce() throw()
{
	free(m_pAce);
}

inline CAcl::CAce::CAce(const CAce &rhs) throw(...) :
	m_sid(rhs.m_sid),
	m_dwAccessMask(rhs.m_dwAccessMask),
	m_aceflags(rhs.m_aceflags),
	m_pAce(NULL)
{
}

inline CAcl::CAce &CAcl::CAce::operator=(const CAce &rhs) throw(...)
{
	if(this != &rhs)
	{
		m_sid = rhs.m_sid;
		m_dwAccessMask = rhs.m_dwAccessMask;
		m_aceflags = rhs.m_aceflags;
		free(m_pAce);
		m_pAce = NULL;
	}
	return *this;
}

inline bool CAcl::CAce::IsObjectAce() const throw()
{
	return false;
}

inline GUID CAcl::CAce::ObjectType() const throw()
{
	return GUID_NULL;
}

inline GUID CAcl::CAce::InheritedObjectType() const throw()
{
	return GUID_NULL;
}

inline ACCESS_MASK CAcl::CAce::AccessMask() const throw()
{
	return m_dwAccessMask;
}

inline BYTE CAcl::CAce::AceFlags() const throw()
{
	return m_aceflags;
}

inline const CSid &CAcl::CAce::Sid() const throw()
{
	return m_sid;
}

inline void CAcl::CAce::AddAccess(ACCESS_MASK accessmask) throw()
{
	m_dwAccessMask |= accessmask;
	free(m_pAce);
	m_pAce = NULL;
}

// ************************************************
// CDacl implementation

inline CDacl::CDacl() throw()
{
}

inline CDacl::~CDacl() throw()
{
	CDacl::RemoveAllAces();
}

inline CDacl::CDacl(const CDacl &rhs) throw(...)
{
	Copy(rhs);
}

inline CDacl &CDacl::operator=(const CDacl &rhs) throw(...)
{
	if (this != &rhs)
	{
		RemoveAllAces();
		Copy(rhs);
	}

	return *this;
}

inline CDacl::CDacl(const ACL &rhs) throw(...)
{
	Copy(rhs);
}

inline CDacl &CDacl::operator=(const ACL &rhs) throw(...)
{
	RemoveAllAces();

	Copy(rhs);
	return *this;
}

inline bool CDacl::AddAllowedAce(const CSid &rSid, ACCESS_MASK accessmask, BYTE aceflags /* = 0 */) throw(...)
{
	ATLASSERT(rSid.IsValid());
	if(!rSid.IsValid())
		return false;

	if (IsNull())
		SetEmpty();

	CAutoPtr<CAccessAce> pAce;
	ATLTRY(pAce.Attach(new CAccessAce(rSid, accessmask, aceflags, true)));
	if(!pAce)
		AtlThrow(E_OUTOFMEMORY);

	m_acl.Add(pAce);

	Dirty();
	return true;
}

inline bool CDacl::AddDeniedAce(const CSid &rSid, ACCESS_MASK accessmask, BYTE aceflags /* = 0 */) throw(...)
{
	ATLASSERT(rSid.IsValid());
	if(!rSid.IsValid())
		return false;

	if (IsNull())
		SetEmpty();

	CAutoPtr<CAccessAce> pAce;
	ATLTRY(pAce.Attach(new CAccessAce(rSid, accessmask, aceflags, false)));
	if(!pAce)
		AtlThrow(E_OUTOFMEMORY);

	m_acl.Add(pAce);

	Dirty();
	return true;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CDacl::AddAllowedAce(
	const CSid &rSid,
	ACCESS_MASK accessmask,
	BYTE aceflags,
	const GUID *pObjectType,
	const GUID *pInheritedObjectType) throw(...)
{
	if(!pObjectType && !pInheritedObjectType)
		return AddAllowedAce(rSid, accessmask, aceflags);

	ATLASSERT(rSid.IsValid());
	if(!rSid.IsValid())
		return false;

	if (IsNull())
		SetEmpty();

	CAutoPtr<CAccessAce> pAce;
	ATLTRY(pAce.Attach(new CAccessObjectAce(rSid, accessmask, aceflags, true,
		pObjectType, pInheritedObjectType)));
	if(!pAce)
		AtlThrow(E_OUTOFMEMORY);

	m_acl.Add(pAce);

	m_dwAclRevision = ACL_REVISION_DS;
	Dirty();
	return true;
}
#endif

#if(_WIN32_WINNT >= 0x0500)
inline bool CDacl::AddDeniedAce(
	const CSid &rSid,
	ACCESS_MASK accessmask,
	BYTE aceflags,
	const GUID *pObjectType,
	const GUID *pInheritedObjectType) throw(...)
{
	if(!pObjectType && !pInheritedObjectType)
		return AddDeniedAce(rSid, accessmask, aceflags);

	ATLASSERT(rSid.IsValid());
	if(!rSid.IsValid())
		return false;

	if (IsNull())
		SetEmpty();

	CAutoPtr<CAccessAce> pAce;
	ATLTRY(pAce.Attach(new CAccessObjectAce(rSid, accessmask, aceflags, false,
		pObjectType, pInheritedObjectType)));
	if(!pAce)
		AtlThrow(E_OUTOFMEMORY);

	m_acl.Add(pAce);

	m_dwAclRevision = ACL_REVISION_DS;
	Dirty();
	return true;
}
#endif

inline void CDacl::RemoveAllAces() throw()
{
	m_acl.RemoveAll();
	Dirty();
}

inline void CDacl::RemoveAce(UINT nIndex)
{
	m_acl.RemoveAt(nIndex);
}

inline UINT CDacl::GetAceCount() const throw()
{
	return (UINT) m_acl.GetCount();
}

inline void CDacl::Copy(const CDacl &rhs) throw(...)
{
	CSid sid;
	ACCESS_MASK accessmask;
	BYTE type;
	BYTE flags;
	GUID guidType;
	GUID guidInheritedType;
	CAutoPtr<CAccessAce> pAce;

	Dirty();

	if (rhs.IsNull())
		SetNull();
	else
		SetEmpty();

	m_dwAclRevision = rhs.m_dwAclRevision;

	for(UINT i=0; i<rhs.GetAceCount(); i++)
	{
		rhs.GetAclEntry(i, &sid, &accessmask, &type, &flags, &guidType, &guidInheritedType);
		switch (type)
		{
		case ACCESS_ALLOWED_ACE_TYPE:
		case ACCESS_DENIED_ACE_TYPE:
			ATLTRY(pAce.Attach(new CAccessAce(sid, accessmask, flags, ACCESS_ALLOWED_ACE_TYPE == type)));
			if (!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;

#if(_WIN32_WINNT >= 0x0500)
		case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
		case ACCESS_DENIED_OBJECT_ACE_TYPE:
		{
			GUID *pguidType = NULL;
			GUID *pguidInheritedType = NULL;
			if(guidType != GUID_NULL)
			{
				pguidType = &guidType;
			}

			if(guidInheritedType != GUID_NULL)
			{
				pguidInheritedType = &guidInheritedType;
			}

			ATLTRY(pAce.Attach(new CAccessObjectAce(
					sid,
					accessmask,
					flags,
					ACCESS_ALLOWED_OBJECT_ACE_TYPE == type,
					pguidType,
					pguidInheritedType)));
			if (!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;
		}
#endif

		default:
			// Wrong ACE type
			ATLASSERT(false);
		}
	}
}

inline void CDacl::Copy(const ACL &rhs) throw(...)
{
	ACL *pAcl = const_cast<ACL *>(&rhs);
	if (pAcl == NULL)
	{
		SetNull();
		return;
	}
	ACL_SIZE_INFORMATION aclsizeinfo;
	ACL_REVISION_INFORMATION aclrevisioninfo;
	ACE_HEADER *pHeader;
	CSid sid;
	ACCESS_MASK accessmask;
	CAutoPtr<CAccessAce> pAce;

	Dirty();

	if(!::GetAclInformation(pAcl, &aclsizeinfo, sizeof(aclsizeinfo), AclSizeInformation))
		AtlThrowLastWin32();

	if(!::GetAclInformation(pAcl, &aclrevisioninfo, sizeof(aclrevisioninfo), AclRevisionInformation))
		AtlThrowLastWin32();
	m_dwAclRevision = aclrevisioninfo.AclRevision;

	for(DWORD i = 0; i < aclsizeinfo.AceCount; i++)
	{
		if(!::GetAce(pAcl, i, reinterpret_cast<void **>(&pHeader)))
			AtlThrowLastWin32();

		accessmask = *reinterpret_cast<ACCESS_MASK *>
			(reinterpret_cast<BYTE *>(pHeader) + sizeof(ACE_HEADER));

		switch(pHeader->AceType)
		{
		case ACCESS_ALLOWED_ACE_TYPE:
		case ACCESS_DENIED_ACE_TYPE:
			sid = *reinterpret_cast<SID *>
				(reinterpret_cast<BYTE *>(pHeader) + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));

			ATLTRY(pAce.Attach(new CAccessAce(sid, accessmask, pHeader->AceFlags,
				ACCESS_ALLOWED_ACE_TYPE == pHeader->AceType)));
			if (!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;

#if(_WIN32_WINNT >= 0x0500)
		case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
		case ACCESS_DENIED_OBJECT_ACE_TYPE:
		{
			GUID *pObjectType = NULL, *pInheritedObjectType = NULL;
			BYTE *pb = reinterpret_cast<BYTE *>
				(pHeader) + offsetof(ACCESS_ALLOWED_OBJECT_ACE, SidStart);
			DWORD dwFlags = reinterpret_cast<ACCESS_ALLOWED_OBJECT_ACE *>(pHeader)->Flags;

			if(dwFlags & ACE_OBJECT_TYPE_PRESENT)
			{
				pObjectType = reinterpret_cast<GUID *>
					(reinterpret_cast<BYTE *>(pHeader) +
					offsetof(ACCESS_ALLOWED_OBJECT_ACE, ObjectType));
			}
			else
				pb -= sizeof(GUID);

			if(dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
			{
				pInheritedObjectType = reinterpret_cast<GUID *>
					(reinterpret_cast<BYTE *>(pHeader) +
					(pObjectType ?
					offsetof(ACCESS_ALLOWED_OBJECT_ACE, InheritedObjectType) :
					offsetof(ACCESS_ALLOWED_OBJECT_ACE, ObjectType)));
			}
			else
				pb -= sizeof(GUID);

			sid = *reinterpret_cast<SID *>(pb);

			ATLTRY(pAce.Attach(new CAccessObjectAce(sid, accessmask, pHeader->AceFlags,
				ACCESS_ALLOWED_OBJECT_ACE_TYPE == pHeader->AceType,
				pObjectType, pInheritedObjectType)));
			if (!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;
		}
#endif

		default:
			// Wrong ACE type
			ATLASSERT(false);
		}
	}
}

inline const CDacl::CAce *CDacl::GetAce(UINT nIndex) const
{
	return m_acl[nIndex];
}

inline void CDacl::PrepareAcesForACL() const throw()
{
	// For a dacl, sort the aces
	size_t i, j, h = 1;
	const size_t nCount = m_acl.GetCount();
	CAutoPtr<CAccessAce> spAce;

	while(h * 3 + 1 < nCount)
		h = 3 * h + 1;

	while(h > 0)
	{
		for(i = h - 1; i < nCount; i++)
		{
			spAce = m_acl[i];

			for(j = i; j >= h && CAccessAce::Order(*m_acl[j - h], *spAce) == -1; j -= h)
				m_acl[j] = m_acl[j - h];

			m_acl[j] = spAce;
		}

		h /= 3;
	}
}

// ************************************************
// CDacl::CAccessAce implementation

inline CDacl::CAccessAce::CAccessAce(
		const CSid &rSid,
		ACCESS_MASK accessmask,
		BYTE aceflags,
		bool bAllowAccess) throw(...) :
	CAce(rSid, accessmask, aceflags),
	m_bAllow(bAllowAccess)
{
}

inline CDacl::CAccessAce::~CAccessAce() throw()
{
}

inline void *CDacl::CAccessAce::GetACE() const throw(...)
{
	C_ASSERT(sizeof(ACCESS_ALLOWED_ACE) == sizeof(ACCESS_DENIED_ACE));
	C_ASSERT(offsetof(ACCESS_ALLOWED_ACE, Header)==offsetof(ACCESS_DENIED_ACE, Header));
	C_ASSERT(offsetof(ACCESS_ALLOWED_ACE, Mask)==offsetof(ACCESS_DENIED_ACE, Mask));
	C_ASSERT(offsetof(ACCESS_ALLOWED_ACE, SidStart)==offsetof(ACCESS_DENIED_ACE, SidStart));

	if(!m_pAce)
	{
		UINT nLength = GetLength();
		ACCESS_ALLOWED_ACE *pAce = static_cast<ACCESS_ALLOWED_ACE *>(malloc(nLength));
		if(!pAce)
			AtlThrow(E_OUTOFMEMORY);

		memset(pAce, 0x00, nLength);

		pAce->Header.AceSize = static_cast<WORD>(nLength);
		pAce->Header.AceFlags = m_aceflags;
		pAce->Header.AceType = AceType();

		pAce->Mask = m_dwAccessMask;
		ATLASSERT(nLength-offsetof(ACCESS_ALLOWED_ACE, SidStart) >= m_sid.GetLength());
		Checked::memcpy_s(&pAce->SidStart, nLength-offsetof(ACCESS_ALLOWED_ACE, SidStart), m_sid.GetPSID(), m_sid.GetLength());

		m_pAce = pAce;
	}
	return m_pAce;
}

inline UINT CDacl::CAccessAce::GetLength() const throw()
{
	return offsetof(ACCESS_ALLOWED_ACE, SidStart) + m_sid.GetLength();
}

inline BYTE CDacl::CAccessAce::AceType() const throw()
{
	return (BYTE)(m_bAllow ? ACCESS_ALLOWED_ACE_TYPE : ACCESS_DENIED_ACE_TYPE);
}

inline bool CDacl::CAccessAce::Allow() const throw()
{
	return m_bAllow;
}

inline bool CDacl::CAccessAce::Inherited() const throw()
{
	return 0 != (m_aceflags & INHERITED_ACE);
}

inline int CDacl::CAccessAce::Order(const CDacl::CAccessAce &lhs, const CDacl::CAccessAce &rhs) throw()
{
	// The order is:
	// denied direct aces
	// denied direct object aces
	// allowed direct aces
	// allowed direct object aces
	// denied inherit aces
	// denied inherit object aces
	// allowed inherit aces
	// allowed inherit object aces

	// inherited aces are always "greater" than non-inherited aces
	if(lhs.Inherited() && !rhs.Inherited())
		return -1;
	if(!lhs.Inherited() && rhs.Inherited())
		return 1;

	// if the aces are *both* either inherited or non-inherited, continue...

	// allowed aces are always "greater" than denied aces (subject to above)
	if(lhs.Allow() && !rhs.Allow())
		return -1;
	if(!lhs.Allow() && rhs.Allow())
		return 1;

	// if the aces are *both* either allowed or denied, continue...

	// object aces are always "greater" than non-object aces (subject to above)
	if(lhs.IsObjectAce() && !rhs.IsObjectAce())
		return -1;
	if(!lhs.IsObjectAce() && rhs.IsObjectAce())
		return 1;

	// aces are "equal" (e.g., both are access denied inherited object aces)
	return 0;
}

#if(_WIN32_WINNT >= 0x0500)
// ************************************************
// CDacl::CAccessObjectAce implementation

inline CDacl::CAccessObjectAce::CAccessObjectAce(
		const CSid &rSid,
		ACCESS_MASK accessmask,
		BYTE aceflags,
		bool bAllowAccess,
		const GUID *pObjectType,
		const GUID *pInheritedObjectType) throw(...) :
	CAccessAce(rSid, accessmask, aceflags, bAllowAccess),
	m_pObjectType(NULL),
	m_pInheritedObjectType(NULL)
{
	if(pObjectType)
	{
		ATLTRY(m_pObjectType = new GUID(*pObjectType));
		if(!m_pObjectType)
			AtlThrow(E_OUTOFMEMORY);
	}

	if(pInheritedObjectType)
	{
		ATLTRY(m_pInheritedObjectType = new GUID(*pInheritedObjectType));
		if(!m_pInheritedObjectType)
		{
			delete m_pObjectType;
			m_pObjectType = NULL;
			AtlThrow(E_OUTOFMEMORY);
		}
	}
}

inline CDacl::CAccessObjectAce::~CAccessObjectAce() throw()
{
	delete m_pObjectType;
	delete m_pInheritedObjectType;
}

inline CDacl::CAccessObjectAce::CAccessObjectAce(const CAccessObjectAce &rhs) throw(...) :
	CAccessAce(rhs),
	m_pObjectType(NULL),
	m_pInheritedObjectType(NULL)
{
	*this = rhs;
}

inline CDacl::CAccessObjectAce &CDacl::CAccessObjectAce::operator=(const CAccessObjectAce &rhs) throw(...)
{
	if(this != &rhs)
	{
		CAccessAce::operator=(rhs);

		if(rhs.m_pObjectType)
		{
			if(!m_pObjectType)
			{
				ATLTRY(m_pObjectType = new GUID);
				if(!m_pObjectType)
					AtlThrow(E_OUTOFMEMORY);
			}
			*m_pObjectType = *rhs.m_pObjectType;
		}
		else
		{
			delete m_pObjectType;
			m_pObjectType = NULL;
		}

		if(rhs.m_pInheritedObjectType)
		{
			if(!m_pInheritedObjectType)
			{
				ATLTRY(m_pInheritedObjectType = new GUID);
				if(!m_pInheritedObjectType)
				{
					delete m_pObjectType;
					m_pObjectType = NULL;
					AtlThrow(E_OUTOFMEMORY);
				}
			}
			*m_pInheritedObjectType = *rhs.m_pInheritedObjectType;
		}
		else
		{
			delete m_pInheritedObjectType;
			m_pInheritedObjectType = NULL;
		}
	}
	return *this;
}

inline void *CDacl::CAccessObjectAce::GetACE() const throw(...)
{
	C_ASSERT(sizeof(ACCESS_ALLOWED_OBJECT_ACE) == sizeof(ACCESS_DENIED_OBJECT_ACE));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, Header)==offsetof(ACCESS_DENIED_OBJECT_ACE, Header));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, Mask)==offsetof(ACCESS_DENIED_OBJECT_ACE, Mask));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, Flags)==offsetof(ACCESS_DENIED_OBJECT_ACE, Flags));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, ObjectType)==offsetof(ACCESS_DENIED_OBJECT_ACE, ObjectType));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, InheritedObjectType)==offsetof(ACCESS_DENIED_OBJECT_ACE, InheritedObjectType));
	C_ASSERT(offsetof(ACCESS_ALLOWED_OBJECT_ACE, SidStart)==offsetof(ACCESS_DENIED_OBJECT_ACE, SidStart));

	if(!m_pAce)
	{
		UINT nLength = GetLength();

		ACCESS_ALLOWED_OBJECT_ACE *pAce = static_cast<ACCESS_ALLOWED_OBJECT_ACE *>(malloc(nLength));
		if(!pAce)
			AtlThrow(E_OUTOFMEMORY);

		memset(pAce, 0x00, nLength);

		pAce->Header.AceSize = static_cast<WORD>(nLength);
		pAce->Header.AceFlags = m_aceflags;
		pAce->Header.AceType = AceType();

		pAce->Mask = m_dwAccessMask;
		pAce->Flags = 0;

		BYTE *pb = (reinterpret_cast<BYTE *>(pAce)) + offsetof(ACCESS_ALLOWED_OBJECT_ACE, SidStart);
		if(!m_pObjectType)
			pb -= sizeof(GUID);
		else
		{
			pAce->ObjectType = *m_pObjectType;
			pAce->Flags |= ACE_OBJECT_TYPE_PRESENT;
		}

		if(!m_pInheritedObjectType)
			pb -= sizeof(GUID);
		else
		{
			if(m_pObjectType)
				pAce->InheritedObjectType = *m_pInheritedObjectType;
			else
				pAce->ObjectType = *m_pInheritedObjectType;
			pAce->Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
		}
		ATLASSERT(UINT(pb - reinterpret_cast<BYTE *>(pAce)) >= m_sid.GetLength());
		Checked::memcpy_s(pb, (pb - reinterpret_cast<BYTE *>(pAce)), m_sid.GetPSID(), m_sid.GetLength());
		m_pAce = pAce;
	}
	return m_pAce;
}

inline UINT CDacl::CAccessObjectAce::GetLength() const throw()
{
	UINT nLength = offsetof(ACCESS_ALLOWED_OBJECT_ACE, SidStart);

	if(!m_pObjectType)
		nLength -= sizeof(GUID);
	if(!m_pInheritedObjectType)
		nLength -= sizeof(GUID);

	nLength += m_sid.GetLength();

	return nLength;
}

inline BYTE CDacl::CAccessObjectAce::AceType() const throw()
{
	return (BYTE)(m_bAllow ? ACCESS_ALLOWED_OBJECT_ACE_TYPE : ACCESS_DENIED_OBJECT_ACE_TYPE);
}

inline bool CDacl::CAccessObjectAce::IsObjectAce() const throw()
{
	return true;
}

inline GUID CDacl::CAccessObjectAce::ObjectType() const throw()
{
	return m_pObjectType ? *m_pObjectType : GUID_NULL;
}

inline GUID CDacl::CAccessObjectAce::InheritedObjectType() const throw()
{
	return m_pInheritedObjectType ? *m_pInheritedObjectType : GUID_NULL;
}
#endif // _WIN32_WINNT

//******************************************
// CSacl implementation

inline CSacl::CSacl() throw()
{
}

inline CSacl::~CSacl() throw()
{
	CSacl::RemoveAllAces();
}

inline CSacl::CSacl(const CSacl &rhs) throw(...)
{
	Copy(rhs);
}

inline CSacl &CSacl::operator=(const CSacl &rhs) throw(...)
{
	if (this != &rhs)
	{
		RemoveAllAces();
		Copy(rhs);
	}

	return *this;
}

inline CSacl::CSacl(const ACL &rhs) throw(...)
{
	Copy(rhs);
}

inline CSacl &CSacl::operator=(const ACL &rhs) throw(...)
{
	RemoveAllAces();

	Copy(rhs);
	return *this;
}

inline bool CSacl::AddAuditAce(
	const CSid &rSid,
	ACCESS_MASK accessmask,
	bool bSuccess,
	bool bFailure,
	BYTE aceflags /* = 0 */) throw(...)
{
	ATLASSERT(rSid.IsValid());
	if(!rSid.IsValid())
		return false;

	if (IsNull())
		SetEmpty();

	CAutoPtr<CAuditAce> pAce;
	ATLTRY(pAce.Attach(new CAuditAce(rSid, accessmask, aceflags, bSuccess, bFailure)))
	if(!pAce)
		AtlThrow(E_OUTOFMEMORY);

	m_acl.Add(pAce);

	Dirty();
	return true;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CSacl::AddAuditAce(
	const CSid &rSid,
	ACCESS_MASK accessmask,
	bool bSuccess,
	bool bFailure,
	BYTE aceflags,
	const GUID *pObjectType,
	const GUID *pInheritedObjectType) throw(...)
{
	if(!pObjectType && !pInheritedObjectType)
		return AddAuditAce(rSid, accessmask, bSuccess, bFailure, aceflags);

	ATLASSERT(rSid.IsValid());
	if(!rSid.IsValid())
		return false;

	if (IsNull())
		SetEmpty();

	CAutoPtr<CAuditAce> pAce;
	ATLTRY(pAce.Attach(new CAuditObjectAce(rSid, accessmask, aceflags, bSuccess,
		bFailure, pObjectType, pInheritedObjectType)));
	if(!pAce)
		AtlThrow(E_OUTOFMEMORY);

	m_acl.Add(pAce);
	m_dwAclRevision = ACL_REVISION_DS;
	Dirty();
	return true;
}
#endif

inline void CSacl::RemoveAllAces() throw()
{
	m_acl.RemoveAll();
	Dirty();
}

inline void CSacl::RemoveAce(UINT nIndex)
{
	m_acl.RemoveAt(nIndex);
}

inline UINT CSacl::GetAceCount() const throw()
{
	return (UINT) m_acl.GetCount();
}

inline void CSacl::Copy(const CSacl &rhs) throw(...)
{
	CSid sid;
	ACCESS_MASK accessmask;
	BYTE type;
	BYTE flags;
	GUID guidType;
	GUID guidInheritedType;
	bool bSuccess;
	bool bFailure;
	CAutoPtr<CAuditAce> pAce;

	Dirty();

	if (rhs.IsNull())
		SetNull();
	else
		SetEmpty();

	m_dwAclRevision = rhs.m_dwAclRevision;

	for (UINT i=0; i<rhs.GetAceCount(); i++)
	{
		rhs.GetAclEntry(i, &sid, &accessmask, &type, &flags, &guidType, &guidInheritedType);

		bSuccess = 0 != (flags & SUCCESSFUL_ACCESS_ACE_FLAG);
		bFailure = 0 != (flags & FAILED_ACCESS_ACE_FLAG);

		switch (type)
		{
		case SYSTEM_AUDIT_ACE_TYPE:
			ATLTRY(pAce.Attach(new CAuditAce(sid, accessmask, flags, bSuccess, bFailure)));
			if (!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;

#if(_WIN32_WINNT >= 0x0500)
		case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
		{
			GUID *pguidType = NULL;
			GUID *pguidInheritedType = NULL;
			if(guidType != GUID_NULL)
			{
				pguidType = &guidType;
			}

			if(guidInheritedType != GUID_NULL)
			{
				pguidInheritedType = &guidInheritedType;
			}

			ATLTRY(pAce.Attach(new CAuditObjectAce(
					sid,
					accessmask,
					flags,
					bSuccess,
					bFailure,
					pguidType,
					pguidInheritedType)));
			if(!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;
		}
#endif
		default:
			// Wrong ACE type
			ATLASSERT(false);
		}
	}
}

inline void CSacl::Copy(const ACL &rhs) throw(...)
{
	ACL *pAcl = const_cast<ACL *>(&rhs);
	ACL_SIZE_INFORMATION aclsizeinfo;
	ACL_REVISION_INFORMATION aclrevisioninfo;
	ACE_HEADER *pHeader;
	CSid sid;
	ACCESS_MASK accessmask;
	bool bSuccess, bFailure;
	CAutoPtr<CAuditAce> pAce;

	Dirty();

	if(!::GetAclInformation(pAcl, &aclsizeinfo, sizeof(aclsizeinfo), AclSizeInformation))
		AtlThrowLastWin32();

	if(!::GetAclInformation(pAcl, &aclrevisioninfo, sizeof(aclrevisioninfo), AclRevisionInformation))
		AtlThrowLastWin32();
	m_dwAclRevision = aclrevisioninfo.AclRevision;

	for(DWORD i = 0; i < aclsizeinfo.AceCount; i++)
	{
		if(!::GetAce(pAcl, i, reinterpret_cast<void **>(&pHeader)))
			AtlThrowLastWin32();

		accessmask = *reinterpret_cast<ACCESS_MASK *>
			(reinterpret_cast<BYTE *>(pHeader) + sizeof(ACE_HEADER));

		bSuccess = 0 != (pHeader->AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG);
		bFailure = 0 != (pHeader->AceFlags & FAILED_ACCESS_ACE_FLAG);

		switch(pHeader->AceType)
		{
		case SYSTEM_AUDIT_ACE_TYPE:
			sid = *reinterpret_cast<SID *>
				(reinterpret_cast<BYTE *>(pHeader) +	sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
			ATLTRY(pAce.Attach(new CAuditAce(sid, accessmask, pHeader->AceFlags, bSuccess, bFailure)));
			if (!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;

#if(_WIN32_WINNT >= 0x0500)
		case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
		{
			GUID *pObjectType = NULL, *pInheritedObjectType = NULL;
			BYTE *pb = reinterpret_cast<BYTE *>
				(pHeader) + offsetof(SYSTEM_AUDIT_OBJECT_ACE, SidStart);
			DWORD dwFlags = reinterpret_cast<SYSTEM_AUDIT_OBJECT_ACE *>(pHeader)->Flags;

			if(dwFlags & ACE_OBJECT_TYPE_PRESENT)
			{
				pObjectType = reinterpret_cast<GUID *>
					(reinterpret_cast<BYTE *>(pHeader) +
					offsetof(SYSTEM_AUDIT_OBJECT_ACE, ObjectType));
			}
			else
				pb -= sizeof(GUID);

			if(dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
			{
				pInheritedObjectType = reinterpret_cast<GUID *>
					(reinterpret_cast<BYTE *>(pHeader) +
					(pObjectType ?
					offsetof(SYSTEM_AUDIT_OBJECT_ACE, InheritedObjectType) :
					offsetof(SYSTEM_AUDIT_OBJECT_ACE, ObjectType)));
			}
			else
				pb -= sizeof(GUID);

			sid = *reinterpret_cast<SID *>(pb);

			ATLTRY(pAce.Attach(new CAuditObjectAce(sid, accessmask, pHeader->AceFlags,
				bSuccess, bFailure, pObjectType, pInheritedObjectType)));
			if(!pAce)
				AtlThrow(E_OUTOFMEMORY);
			m_acl.Add(pAce);
			break;
		}
#endif
		default:
			// Wrong ACE type
			ATLASSERT(false);
		}
	}
}

inline const CSacl::CAce *CSacl::GetAce(UINT nIndex) const
{
	return m_acl[nIndex];
}

//******************************************
// CSacl::CAuditAce implementation

inline CSacl::CAuditAce::CAuditAce(
		const CSid &rSid,
		ACCESS_MASK accessmask,
		BYTE aceflags,
		bool bAuditSuccess,
		bool bAuditFailure) throw(...) :
	CAce(rSid, accessmask, aceflags),
	m_bSuccess(bAuditSuccess),
	m_bFailure(bAuditFailure)
{
	if (m_bSuccess)
		m_aceflags |= SUCCESSFUL_ACCESS_ACE_FLAG;
	if (m_bFailure)
		m_aceflags |= FAILED_ACCESS_ACE_FLAG;
}

inline CSacl::CAuditAce::~CAuditAce() throw()
{
}

inline void *CSacl::CAuditAce::GetACE() const throw(...)
{
	if(!m_pAce)
	{
		UINT nLength = GetLength();
		SYSTEM_AUDIT_ACE *pAce = static_cast<SYSTEM_AUDIT_ACE *>(malloc(nLength));
		if(!pAce)
			AtlThrow(E_OUTOFMEMORY);

		memset(pAce, 0x00, nLength);

		pAce->Header.AceSize = static_cast<WORD>(nLength);
		pAce->Header.AceFlags = m_aceflags;
		pAce->Header.AceType = AceType();

		pAce->Mask = m_dwAccessMask;
		ATLASSERT(nLength-offsetof(SYSTEM_AUDIT_ACE, SidStart) >= m_sid.GetLength());
		Checked::memcpy_s(&pAce->SidStart, nLength-offsetof(SYSTEM_AUDIT_ACE, SidStart), m_sid.GetPSID(), m_sid.GetLength());

		m_pAce = pAce;
	}
	return m_pAce;
}

inline UINT CSacl::CAuditAce::GetLength() const throw()
{
	return offsetof(SYSTEM_AUDIT_ACE, SidStart) + m_sid.GetLength();
}

inline BYTE CSacl::CAuditAce::AceType() const throw()
{
	return SYSTEM_AUDIT_ACE_TYPE;
}

#if(_WIN32_WINNT >= 0x0500)
//******************************************
// CSacl::CAuditObjectAce implementation

inline CSacl::CAuditObjectAce::CAuditObjectAce(
		const CSid &rSid,
		ACCESS_MASK accessmask,
		BYTE aceflags,
		bool bAuditSuccess,
		bool bAuditFailure,
		const GUID *pObjectType,
		const GUID *pInheritedObjectType) throw(...) :
	CAuditAce(rSid, accessmask, aceflags, bAuditSuccess, bAuditFailure),
	m_pObjectType(NULL),
	m_pInheritedObjectType(NULL)
{
	if(pObjectType)
	{
		ATLTRY(m_pObjectType = new GUID(*pObjectType));
		if(!m_pObjectType)
			AtlThrow(E_OUTOFMEMORY);
	}

	if(pInheritedObjectType)
	{
		ATLTRY(m_pInheritedObjectType = new GUID(*pInheritedObjectType));
		if(!m_pInheritedObjectType)
		{
			delete m_pObjectType;
			m_pObjectType = NULL;
			AtlThrow(E_OUTOFMEMORY);
		}
	}
}

inline CSacl::CAuditObjectAce::~CAuditObjectAce() throw()
{
	delete m_pObjectType;
	delete m_pInheritedObjectType;
}

inline CSacl::CAuditObjectAce::CAuditObjectAce(const CAuditObjectAce &rhs) throw(...) :
	CAuditAce(rhs),
	m_pObjectType(NULL),
	m_pInheritedObjectType(NULL)
{
	*this = rhs;
}

inline CSacl::CAuditObjectAce &CSacl::CAuditObjectAce::operator=(const CAuditObjectAce &rhs) throw(...)
{
	if(this != &rhs)
	{
		CAuditAce::operator=(rhs);

		if(rhs.m_pObjectType)
		{
			if(!m_pObjectType)
			{
				ATLTRY(m_pObjectType = new GUID);
				if(!m_pObjectType)
					AtlThrow(E_OUTOFMEMORY);
			}
			*m_pObjectType = *rhs.m_pObjectType;
		}
		else
		{
			delete m_pObjectType;
			m_pObjectType = NULL;
		}

		if(rhs.m_pInheritedObjectType)
		{
			if(!m_pInheritedObjectType)
			{
				ATLTRY(m_pInheritedObjectType = new GUID);
				if(!m_pInheritedObjectType)
				{
					delete m_pObjectType;
					m_pObjectType = NULL;
					AtlThrow(E_OUTOFMEMORY);
				}
			}
			*m_pInheritedObjectType = *rhs.m_pInheritedObjectType;
		}
		else
		{
			delete m_pInheritedObjectType;
			m_pInheritedObjectType = NULL;
		}
	}
	return *this;
}

inline void *CSacl::CAuditObjectAce::GetACE() const throw(...)
{
	if(!m_pAce)
	{
		UINT nLength = GetLength();
		SYSTEM_AUDIT_OBJECT_ACE *pAce = static_cast<SYSTEM_AUDIT_OBJECT_ACE *>(malloc(nLength));
		if(!pAce)
			AtlThrow(E_OUTOFMEMORY);

		memset(pAce, 0x00, nLength);

		pAce->Header.AceType = SYSTEM_AUDIT_OBJECT_ACE_TYPE;
		pAce->Header.AceSize = static_cast<WORD>(nLength);
		pAce->Header.AceFlags = m_aceflags;

		pAce->Mask = m_dwAccessMask;
		pAce->Flags = 0;

		if(m_bSuccess)
			pAce->Header.AceFlags |= SUCCESSFUL_ACCESS_ACE_FLAG;
		else
			pAce->Header.AceFlags &= ~SUCCESSFUL_ACCESS_ACE_FLAG;

		if(m_bFailure)
			pAce->Header.AceFlags |= FAILED_ACCESS_ACE_FLAG;
		else
			pAce->Header.AceFlags &= ~FAILED_ACCESS_ACE_FLAG;

		BYTE *pb = ((BYTE *) pAce) + offsetof(SYSTEM_AUDIT_OBJECT_ACE, SidStart);
		if(!m_pObjectType)
			pb -= sizeof(GUID);
		else
		{
			pAce->ObjectType = *m_pObjectType;
			pAce->Flags |= ACE_OBJECT_TYPE_PRESENT;
		}

		if(!m_pInheritedObjectType)
			pb -= sizeof(GUID);
		else
		{
			if(m_pObjectType)
				pAce->InheritedObjectType = *m_pInheritedObjectType;
			else
				pAce->ObjectType = *m_pInheritedObjectType;
			pAce->Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
		}
		ATLASSERT(UINT(pb - reinterpret_cast<BYTE*>(pAce)) >= m_sid.GetLength());
		Checked::memcpy_s(pb, pb - reinterpret_cast<BYTE*>(pAce), m_sid.GetPSID(), m_sid.GetLength());
		m_pAce = pAce;
	}
	return m_pAce;
}

inline UINT CSacl::CAuditObjectAce::GetLength() const throw()
{
	UINT nLength = offsetof(SYSTEM_AUDIT_OBJECT_ACE, SidStart);

	if(!m_pObjectType)
		nLength -= sizeof(GUID);
	if(!m_pInheritedObjectType)
		nLength -= sizeof(GUID);

	nLength += m_sid.GetLength();

	return nLength;
}

inline BYTE CSacl::CAuditObjectAce::AceType() const throw()
{
	return SYSTEM_AUDIT_OBJECT_ACE_TYPE;
}

inline bool CSacl::CAuditObjectAce::IsObjectAce() const throw()
{
	return true;
}

inline GUID CSacl::CAuditObjectAce::ObjectType() const throw()
{
	return m_pObjectType ? *m_pObjectType : GUID_NULL;
}

inline GUID CSacl::CAuditObjectAce::InheritedObjectType() const throw()
{
	return m_pInheritedObjectType ? *m_pInheritedObjectType : GUID_NULL;
}
#endif

//******************************************
// CSecurityDesc implementation

inline CSecurityDesc::CSecurityDesc() throw() :
	m_pSecurityDescriptor(NULL)
{
}

inline CSecurityDesc::~CSecurityDesc() throw()
{
	Clear();
}

inline CSecurityDesc::CSecurityDesc(const CSecurityDesc &rhs) throw(...)
	: m_pSecurityDescriptor(NULL)
{
	if(rhs.m_pSecurityDescriptor)
		Init(*rhs.m_pSecurityDescriptor);
}

inline CSecurityDesc &CSecurityDesc::operator=(const CSecurityDesc &rhs) throw(...)
{
	if(this != &rhs)
	{
		Clear();
		if(rhs.m_pSecurityDescriptor)
			Init(*rhs.m_pSecurityDescriptor);
	}
	return *this;
}

inline CSecurityDesc::CSecurityDesc(const SECURITY_DESCRIPTOR &rhs) throw(...) :
	m_pSecurityDescriptor(NULL)
{
	Init(rhs);
}

inline CSecurityDesc &CSecurityDesc::operator=(const SECURITY_DESCRIPTOR &rhs) throw(...)
{
	if(m_pSecurityDescriptor != &rhs)
	{
		Clear();
		Init(rhs);
	}
	return *this;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CSecurityDesc::FromString(LPCTSTR pstr) throw(...)
{
	SECURITY_DESCRIPTOR *pSD;
	if(!::ConvertStringSecurityDescriptorToSecurityDescriptor(pstr, SDDL_REVISION_1,
			(PSECURITY_DESCRIPTOR *) &pSD, NULL))
		AtlThrowLastWin32();

	*this = *pSD;
	::LocalFree(pSD);

	return true;
}

inline bool CSecurityDesc::ToString(
	CString *pstr,
	SECURITY_INFORMATION si /* =
		OWNER_SECURITY_INFORMATION |
		GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION |
		SACL_SECURITY_INFORMATION */) const throw(...)
{
	ATLASSERT(pstr);
	if(!pstr || !m_pSecurityDescriptor)
		return false;

	LPTSTR pszStringSecurityDescriptor;
	if(!::ConvertSecurityDescriptorToStringSecurityDescriptor(m_pSecurityDescriptor,
			SDDL_REVISION_1,
			si,
			&pszStringSecurityDescriptor,
			NULL))
		AtlThrowLastWin32();

	_ATLTRY
	{
		*pstr = pszStringSecurityDescriptor;
	}
	_ATLCATCHALL()
	{
		::LocalFree(pszStringSecurityDescriptor);
		throw;
	}

	::LocalFree(pszStringSecurityDescriptor);
	return true;
}
#endif

inline void CSecurityDesc::SetOwner(const CSid &sid, bool bDefaulted /* = false */) throw(...)
{
	if(m_pSecurityDescriptor)
		MakeAbsolute();

	PSID pNewOwner, pOldOwner;
	if(m_pSecurityDescriptor)
	{
		BOOL _bDefaulted;
		if(!::GetSecurityDescriptorOwner(m_pSecurityDescriptor, &pOldOwner, &_bDefaulted))
			AtlThrowLastWin32();
	}
	else
	{
		AllocateAndInitializeSecurityDescriptor();
		pOldOwner = NULL;
	}

	if(!sid.IsValid())
		AtlThrow(E_FAIL);

	UINT nSidLength = sid.GetLength();
	pNewOwner = malloc(nSidLength);
	if(!pNewOwner)
		AtlThrow(E_OUTOFMEMORY);

	if(!::CopySid((DWORD) nSidLength, pNewOwner, const_cast<SID *>(sid.GetPSID())) ||
		!::SetSecurityDescriptorOwner(m_pSecurityDescriptor, pNewOwner, bDefaulted))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(pNewOwner);
		AtlThrow(hr);
	}

	free(pOldOwner);
}

inline void CSecurityDesc::SetGroup(const CSid &sid, bool bDefaulted /* = false */) throw(...)
{
	if(m_pSecurityDescriptor)
		MakeAbsolute();

	PSID pNewGroup, pOldGroup;
	if(m_pSecurityDescriptor)
	{
		BOOL _bDefaulted;
		if(!::GetSecurityDescriptorGroup(m_pSecurityDescriptor, &pOldGroup, &_bDefaulted))
			AtlThrowLastWin32();
	}
	else
	{
		AllocateAndInitializeSecurityDescriptor();
		pOldGroup = NULL;
	}

	if(!sid.IsValid())
		AtlThrow(E_FAIL);

	UINT nSidLength = sid.GetLength();
	pNewGroup = malloc(nSidLength);
	if(!pNewGroup)
		AtlThrow(E_OUTOFMEMORY);

	if(!::CopySid((DWORD) nSidLength, pNewGroup, const_cast<SID *>(sid.GetPSID())) ||
		!::SetSecurityDescriptorGroup(m_pSecurityDescriptor, pNewGroup, bDefaulted))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(pNewGroup);
		AtlThrow(hr);
	}

	free(pOldGroup);
}

inline void CSecurityDesc::SetDacl(const CDacl &Dacl, bool bDefaulted /* = false */) throw(...)
{
	if(m_pSecurityDescriptor)
		MakeAbsolute();

	PACL pNewDacl, pOldDacl = NULL;
	if(m_pSecurityDescriptor)
	{
		BOOL _bDefaulted, _bPresent;
		if(!::GetSecurityDescriptorDacl(m_pSecurityDescriptor, &_bPresent, &pOldDacl, &_bDefaulted))
			AtlThrowLastWin32();
	}
	else
		AllocateAndInitializeSecurityDescriptor();

	if(Dacl.IsNull() || Dacl.IsEmpty())
		pNewDacl = NULL;
	else
	{
		UINT nAclLength = Dacl.GetLength();
		ATLASSERT(nAclLength > 0);

		pNewDacl = static_cast<ACL *>(malloc(nAclLength));
		if(!pNewDacl)
			AtlThrow(E_OUTOFMEMORY);

		Checked::memcpy_s(pNewDacl, nAclLength, Dacl.GetPACL(), nAclLength);
	}

#ifdef _DEBUG
	if(Dacl.IsNull())
	{
		// setting a NULL DACL is almost always the wrong thing to do
		ATLTRACE(atlTraceSecurity, 2, _T("Error: Setting Dacl to Null offers no security\n"));
		ATLASSERT(FALSE);
	}
#endif

	if(!::SetSecurityDescriptorDacl(m_pSecurityDescriptor, Dacl.IsNull() || pNewDacl, pNewDacl, bDefaulted))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(pNewDacl);
		AtlThrow(hr);
	}

	free(pOldDacl);
}

inline void CSecurityDesc::SetDacl(bool bPresent, bool bDefaulted /* = false */) throw(...)
{
	if(m_pSecurityDescriptor)
		MakeAbsolute();

	PACL pOldDacl = NULL;
	if(m_pSecurityDescriptor)
	{
		BOOL _bDefaulted, _bPresent;
		if(!::GetSecurityDescriptorDacl(m_pSecurityDescriptor, &_bPresent, &pOldDacl, &_bDefaulted))
			AtlThrowLastWin32();
	}
	else
		AllocateAndInitializeSecurityDescriptor();

#ifdef _DEBUG
	if(bPresent)
	{
		// setting a NULL DACL is almost always the wrong thing to do
		ATLTRACE(atlTraceSecurity, 2, _T("Error: Setting Dacl to Null offers no security\n"));
		ATLASSERT(FALSE);
	}
#endif

	if(!::SetSecurityDescriptorDacl(m_pSecurityDescriptor, bPresent, NULL, bDefaulted))
		AtlThrowLastWin32();

	free(pOldDacl);
}

inline void CSecurityDesc::SetSacl(const CSacl &Sacl, bool bDefaulted /* = false */) throw(...)
{
	if(m_pSecurityDescriptor)
		MakeAbsolute();

	PACL pNewSacl, pOldSacl = NULL;
	if(m_pSecurityDescriptor)
	{
		BOOL _bDefaulted, _bPresent;
		if(!::GetSecurityDescriptorSacl(m_pSecurityDescriptor, &_bPresent, &pOldSacl, &_bDefaulted))
			AtlThrowLastWin32();
	}
	else
		AllocateAndInitializeSecurityDescriptor();

	if(Sacl.IsNull() || Sacl.IsEmpty())
		pNewSacl = NULL;
	else
	{
		UINT nAclLength = Sacl.GetLength();
		ATLASSERT(nAclLength > 0);

		pNewSacl = static_cast<ACL *>(malloc(nAclLength));
		if(!pNewSacl)
			AtlThrow(E_OUTOFMEMORY);

		Checked::memcpy_s(pNewSacl, nAclLength, Sacl.GetPACL(), nAclLength);
	}

	if(!::SetSecurityDescriptorSacl(m_pSecurityDescriptor, Sacl.IsNull() || pNewSacl, pNewSacl, bDefaulted))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(pNewSacl);
		AtlThrow(hr);
	}

	free(pOldSacl);
}

inline bool CSecurityDesc::GetOwner(CSid *pSid, bool *pbDefaulted /* = NULL */) const throw(...)
{
	ATLASSERT(pSid);
	SID *pOwner;
	BOOL bDefaulted;

	if(!pSid || !m_pSecurityDescriptor ||
		!::GetSecurityDescriptorOwner(m_pSecurityDescriptor, (PSID *) &pOwner, &bDefaulted))
	{
		return false;
	}

	*pSid = *pOwner;

	if(pbDefaulted)
		*pbDefaulted = 0 != bDefaulted;

	return true;
}

inline bool CSecurityDesc::GetGroup(CSid *pSid, bool *pbDefaulted /* = NULL */) const throw(...)
{
	ATLASSERT(pSid);
	SID *pGroup;
	BOOL bDefaulted;

	if(!pSid || !m_pSecurityDescriptor ||
		!::GetSecurityDescriptorGroup(m_pSecurityDescriptor, (PSID *) &pGroup, &bDefaulted))
	{
		return false;
	}

	*pSid = *pGroup;

	if(pbDefaulted)
		*pbDefaulted = 0 != bDefaulted;

	return true;
}

inline bool CSecurityDesc::GetDacl(CDacl *pDacl, bool *pbPresent /* = NULL */, bool *pbDefaulted /* = NULL */) const throw(...)
{
	ACL *pAcl;
	BOOL bPresent, bDefaulted;

	if(!m_pSecurityDescriptor ||
		!::GetSecurityDescriptorDacl(m_pSecurityDescriptor, &bPresent, &pAcl, &bDefaulted))
	{
		return false;
	}

	if(pDacl)
	{
		if(bPresent)
		{
			if(pAcl)
				*pDacl = *pAcl;
			else
				pDacl->SetNull();
		}
		else
			pDacl->SetEmpty();
	}

	if(pbPresent)
		*pbPresent = 0 != bPresent;

	if(pbDefaulted)
		*pbDefaulted = 0 != bDefaulted;

	return true;
}

inline bool CSecurityDesc::GetSacl(CSacl *pSacl, bool *pbPresent /* = NULL */, bool *pbDefaulted /* = NULL */) const throw(...)
{
	ACL *pAcl;
	BOOL bPresent, bDefaulted;

	if(!m_pSecurityDescriptor ||
		!::GetSecurityDescriptorSacl(m_pSecurityDescriptor, &bPresent, &pAcl, &bDefaulted))
	{
		return false;
	}

	if(pSacl)
	{
		if(bPresent)
		{
			if(pAcl)
				*pSacl = *pAcl;
			else
				pSacl->SetNull();
		}
		else
			pSacl->SetEmpty();
	}

	if(pbPresent)
		*pbPresent = 0 != bPresent;

	if(pbDefaulted)
		*pbDefaulted = 0 != bDefaulted;

	return true;
}

inline bool CSecurityDesc::IsDaclDefaulted() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return (sdc & SE_DACL_PRESENT) &&
		(sdc & SE_DACL_DEFAULTED);
}

inline bool CSecurityDesc::IsDaclPresent() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_DACL_PRESENT);
}

inline bool CSecurityDesc::IsGroupDefaulted() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_GROUP_DEFAULTED);
}

inline bool CSecurityDesc::IsOwnerDefaulted() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return (sdc & SE_OWNER_DEFAULTED);
}

inline bool CSecurityDesc::IsSaclDefaulted() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return (sdc & SE_SACL_PRESENT) &&
		(sdc & SE_SACL_DEFAULTED);
}

inline bool CSecurityDesc::IsSaclPresent() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_SACL_PRESENT);
}

inline bool CSecurityDesc::IsSelfRelative() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_SELF_RELATIVE);
}

inline bool CSecurityDesc::IsDaclAutoInherited() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_DACL_AUTO_INHERITED);
}

inline bool CSecurityDesc::IsDaclProtected() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_DACL_PROTECTED);
}

inline bool CSecurityDesc::IsSaclAutoInherited() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_SACL_AUTO_INHERITED);
}

inline bool CSecurityDesc::IsSaclProtected() const throw()
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!GetControl(&sdc))
		return false;

	return 0 != (sdc & SE_SACL_PROTECTED);
}

inline const SECURITY_DESCRIPTOR *CSecurityDesc::GetPSECURITY_DESCRIPTOR() const throw()
{
	return m_pSecurityDescriptor;
}

inline CSecurityDesc::operator const SECURITY_DESCRIPTOR *() const throw()
{
	return GetPSECURITY_DESCRIPTOR();
}

inline void CSecurityDesc::GetSECURITY_DESCRIPTOR(SECURITY_DESCRIPTOR *pSD, LPDWORD lpdwBufferLength) throw(...)
{
	ATLASSERT(lpdwBufferLength && m_pSecurityDescriptor);
	if(!lpdwBufferLength)
		AtlThrow(E_INVALIDARG);
	if (!m_pSecurityDescriptor)
		AtlThrow(E_UNEXPECTED);

	MakeAbsolute();

	if (!::MakeSelfRelativeSD(m_pSecurityDescriptor, pSD, lpdwBufferLength) &&
			(pSD || GetLastError() != ERROR_INSUFFICIENT_BUFFER))
		AtlThrowLastWin32();
}

inline UINT CSecurityDesc::GetLength() throw()
{
	return ::GetSecurityDescriptorLength(m_pSecurityDescriptor);
}

inline bool CSecurityDesc::GetControl(SECURITY_DESCRIPTOR_CONTROL *psdc) const throw()
{
	ATLASSERT(psdc);
	if(!psdc)
		return false;

	DWORD dwRev;
	*psdc = 0;
	if(!m_pSecurityDescriptor ||
		!::GetSecurityDescriptorControl(m_pSecurityDescriptor, psdc, &dwRev))
	{
		return false;
	}
	return true;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CSecurityDesc::SetControl(
	SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
	SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet) throw()
{
	ATLASSUME(m_pSecurityDescriptor);
	if (!m_pSecurityDescriptor)
		return false;

	return 0 != ::SetSecurityDescriptorControl(m_pSecurityDescriptor,
		ControlBitsOfInterest, ControlBitsToSet);
}
#endif

inline void CSecurityDesc::MakeSelfRelative() throw(...)
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!m_pSecurityDescriptor)
		return;

	if (!GetControl(&sdc))
		AtlThrow(E_FAIL);

	if(sdc & SE_SELF_RELATIVE)
		return;

	SECURITY_DESCRIPTOR *pSD;
	DWORD dwLen = 0;

	::MakeSelfRelativeSD(m_pSecurityDescriptor, NULL, &dwLen);
	if(::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		AtlThrowLastWin32();

	pSD = static_cast<SECURITY_DESCRIPTOR *>(malloc(dwLen));
	if(!pSD)
		AtlThrow(E_OUTOFMEMORY);

	if(!::MakeSelfRelativeSD(m_pSecurityDescriptor, pSD, &dwLen))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(pSD);
		AtlThrow(hr);
	}

	Clear();
	m_pSecurityDescriptor = pSD;
}

inline void CSecurityDesc::MakeAbsolute() throw(...)
{
	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!m_pSecurityDescriptor)
		return;

	if (!GetControl(&sdc))
		AtlThrow(E_FAIL);;

	if(!(sdc & SE_SELF_RELATIVE))
		return;

	SECURITY_DESCRIPTOR *pSD;
	SID *pOwner, *pGroup;
	ACL *pDacl, *pSacl;
	DWORD dwSD, dwOwner, dwGroup, dwDacl, dwSacl;

	dwSD = dwOwner = dwGroup = dwDacl = dwSacl = 0;

	::MakeAbsoluteSD(m_pSecurityDescriptor, NULL, &dwSD, NULL, &dwDacl,
		NULL, &dwSacl, NULL, &dwOwner, NULL, &dwGroup);
	if(::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		AtlThrowLastWin32();

	pSD    = static_cast<SECURITY_DESCRIPTOR *>(malloc(dwSD));
	ATLENSURE(pSD);
	pOwner = static_cast<SID *>(dwOwner ? malloc(dwOwner) : NULL);
	if(dwOwner) ATLENSURE(pOwner);
	pGroup = static_cast<SID *>(dwGroup ? malloc(dwGroup) : NULL);
	if(dwGroup) ATLENSURE(pGroup);
	pDacl  = static_cast<ACL *>(dwDacl ? malloc(dwDacl) : NULL);
	if(dwDacl) ATLENSURE(pDacl);
	pSacl  = static_cast<ACL *>(dwSacl ? malloc(dwSacl) : NULL);
	if(dwSacl) ATLENSURE(pSacl);

	if(!::MakeAbsoluteSD(m_pSecurityDescriptor,
		pSD, &dwSD,
		pDacl, &dwDacl,
		pSacl, &dwSacl,
		pOwner, &dwOwner,
		pGroup, &dwGroup))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(pSD);
		free(pOwner);
		free(pGroup);
		free(pDacl);
		free(pSacl);
		AtlThrow(hr);
	}

	Clear();
	m_pSecurityDescriptor = pSD;
}

inline void CSecurityDesc::Clear() throw()
{
	if(m_pSecurityDescriptor)
	{
		SECURITY_DESCRIPTOR_CONTROL sdc;
		if(GetControl(&sdc) && !(sdc & SE_SELF_RELATIVE))
		{
			PSID pOwner, pGroup;
			ACL *pDacl, *pSacl;
			BOOL bDefaulted, bPresent;

			::GetSecurityDescriptorOwner(m_pSecurityDescriptor, &pOwner, &bDefaulted);
			free(pOwner);
			::GetSecurityDescriptorGroup(m_pSecurityDescriptor, &pGroup, &bDefaulted);
			free(pGroup);
			::GetSecurityDescriptorDacl(m_pSecurityDescriptor, &bPresent, &pDacl, &bDefaulted);
			if(bPresent)
				free(pDacl);
			::GetSecurityDescriptorSacl(m_pSecurityDescriptor, &bPresent, &pSacl, &bDefaulted);
			if(bPresent)
				free(pSacl);
		}
		free(m_pSecurityDescriptor);
		m_pSecurityDescriptor = NULL;
	}
}

inline void CSecurityDesc::AllocateAndInitializeSecurityDescriptor() throw(...)
{
	// m_pSecurityDescriptor should be NULL.
	ATLASSERT(!m_pSecurityDescriptor);

	m_pSecurityDescriptor = static_cast<SECURITY_DESCRIPTOR *>(malloc(sizeof(SECURITY_DESCRIPTOR)));
	if(!m_pSecurityDescriptor)
		AtlThrow(E_OUTOFMEMORY);

	if(!::InitializeSecurityDescriptor(m_pSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(m_pSecurityDescriptor);
		m_pSecurityDescriptor = NULL;
		AtlThrow(hr);
	}
}

inline void CSecurityDesc::Init(const SECURITY_DESCRIPTOR &rhs) throw(...)
{
	SECURITY_DESCRIPTOR *pSD = const_cast<SECURITY_DESCRIPTOR *>(&rhs);
	DWORD dwRev, dwLen = ::GetSecurityDescriptorLength(pSD);

	m_pSecurityDescriptor = static_cast<SECURITY_DESCRIPTOR *>(malloc(dwLen));
	if(!m_pSecurityDescriptor)
		AtlThrow(E_OUTOFMEMORY);

	SECURITY_DESCRIPTOR_CONTROL sdc;
	if(!::GetSecurityDescriptorControl(pSD, &sdc, &dwRev))
	{
		HRESULT hr = AtlHresultFromLastError();
		free(m_pSecurityDescriptor);
		m_pSecurityDescriptor = NULL;
		AtlThrow(hr);
	}

	if(sdc & SE_SELF_RELATIVE)
	{
		Checked::memcpy_s(m_pSecurityDescriptor, dwLen, pSD, dwLen);
	}
	else
	{
		if(!::MakeSelfRelativeSD(pSD, m_pSecurityDescriptor, &dwLen))
		{
			HRESULT hr = AtlHresultFromLastError();
			free(m_pSecurityDescriptor);
			m_pSecurityDescriptor = NULL;
			AtlThrow(hr);
		}
	}
}

//******************************************
// CSecurityAttributes implementation

inline CSecurityAttributes::CSecurityAttributes() throw()
{
	nLength = 0;
	lpSecurityDescriptor = NULL;
	bInheritHandle = FALSE;
}

inline CSecurityAttributes::CSecurityAttributes(
		const CSecurityDesc &rSecurityDescriptor,
		bool bInheritHandle /* = false */) throw(...) :
	m_SecurityDescriptor(rSecurityDescriptor)
{
	Set(m_SecurityDescriptor, bInheritHandle);
}

inline void CSecurityAttributes::Set(
	const CSecurityDesc &rSecurityDescriptor,
	bool bInheritHandle /* = false */) throw(...)
{
	m_SecurityDescriptor = rSecurityDescriptor;
	nLength = sizeof(SECURITY_ATTRIBUTES);
	lpSecurityDescriptor = const_cast<SECURITY_DESCRIPTOR *>
		(m_SecurityDescriptor.GetPSECURITY_DESCRIPTOR());
	this->bInheritHandle = bInheritHandle;
}

//******************************************************
// CTokenPrivileges implementation

inline CTokenPrivileges::CTokenPrivileges() throw() :
	m_bDirty(true),
	m_pTokenPrivileges(NULL)
{
}

inline CTokenPrivileges::~CTokenPrivileges() throw()
{
	free(m_pTokenPrivileges);
}

inline CTokenPrivileges::CTokenPrivileges(const CTokenPrivileges &rhs) throw(...) :
	m_pTokenPrivileges(NULL),
	m_bDirty(true)
{
	const Map::CPair *pPair;
	POSITION pos = rhs.m_mapTokenPrivileges.GetStartPosition();
	while(pos)
	{
		pPair = rhs.m_mapTokenPrivileges.GetNext(pos);
		m_mapTokenPrivileges.SetAt(pPair->m_key, pPair->m_value);
	}
}

inline CTokenPrivileges &CTokenPrivileges::operator=(const CTokenPrivileges &rhs) throw(...)
{
	if(this != &rhs)
	{
		m_mapTokenPrivileges.RemoveAll();

		const Map::CPair *pPair;
		POSITION pos = rhs.m_mapTokenPrivileges.GetStartPosition();
		while(pos)
		{
			pPair = rhs.m_mapTokenPrivileges.GetNext(pos);
			m_mapTokenPrivileges.SetAt(pPair->m_key, pPair->m_value);
		}
		m_bDirty = true;
	}
	return *this;
}

inline CTokenPrivileges::CTokenPrivileges(const TOKEN_PRIVILEGES &rPrivileges) throw(...) :
	m_pTokenPrivileges(NULL)
{
	AddPrivileges(rPrivileges);
}

inline CTokenPrivileges &CTokenPrivileges::operator=(const TOKEN_PRIVILEGES &rPrivileges) throw(...)
{
	m_mapTokenPrivileges.RemoveAll();
	AddPrivileges(rPrivileges);
	return *this;
}

inline void CTokenPrivileges::Add(const TOKEN_PRIVILEGES &rPrivileges) throw(...)
{
	AddPrivileges(rPrivileges);
}

inline bool CTokenPrivileges::Add(LPCTSTR pszPrivilege, bool bEnable) throw(...)
{
	LUID_AND_ATTRIBUTES la;
	if(!::LookupPrivilegeValue(NULL, pszPrivilege, &la.Luid))
		return false;

	la.Attributes = bEnable ? SE_PRIVILEGE_ENABLED : 0;

	m_mapTokenPrivileges.SetAt(la.Luid, la.Attributes);

	m_bDirty = true;
	return true;
}

inline bool CTokenPrivileges::LookupPrivilege(
	LPCTSTR pszPrivilege,
	DWORD *pdwAttributes /* = NULL */) const throw(...)
{
	DWORD dwAttributes;
	LUID luid;

	if(!::LookupPrivilegeValue(NULL, pszPrivilege, &luid))
		return false;

	if(m_mapTokenPrivileges.Lookup(luid, dwAttributes))
	{
		if(pdwAttributes)
			*pdwAttributes = dwAttributes;
		return true;
	}
	return false;
}

inline void CTokenPrivileges::GetNamesAndAttributes(
	CNames *pNames,
	CAttributes *pAttributes /* = NULL */) const throw(...)
{
	ATLASSERT(pNames);
	if(pNames)
	{
		CAutoVectorPtr<TCHAR> psz;
		DWORD cbName = 0, cbTmp;
		const Map::CPair *pPair;

		pNames->RemoveAll();
		if(pAttributes)
			pAttributes->RemoveAll();

		POSITION pos = m_mapTokenPrivileges.GetStartPosition();
		while(pos)
		{
			pPair = m_mapTokenPrivileges.GetNext(pos);

			cbTmp = cbName;
#pragma warning(push)
#pragma warning(disable: 6535)
			/* prefast noise VSW 492728 */
			if(!::LookupPrivilegeName(NULL, const_cast<LUID *>(&pPair->m_key), psz, &cbTmp))
#pragma warning(pop)
				if(::GetLastError() == ERROR_INSUFFICIENT_BUFFER)
				{
					psz.Free();
					if(!psz.Allocate(cbTmp + 1))
					{
						pNames->RemoveAll();
						if(pAttributes)
							pAttributes->RemoveAll();
						AtlThrow(E_OUTOFMEMORY);
					}

					cbName = cbTmp;
					if(!::LookupPrivilegeName(NULL, const_cast<LUID *>(&pPair->m_key), psz, &cbTmp))
						break;
				}
				else
					break;

			pNames->Add((LPTSTR) psz);
			if(pAttributes)
				pAttributes->Add(pPair->m_value);
		}

		if(pos)
		{
			pNames->RemoveAll();
			if(pAttributes)
				pAttributes->RemoveAll();
		}
	}
}

inline void CTokenPrivileges::GetDisplayNames(CNames *pDisplayNames) const throw(...)
{
	ATLASSERT(pDisplayNames);
	if(pDisplayNames)
	{
		DWORD dwLang, cbTmp, cbDisplayName = 0;
		CAutoVectorPtr<TCHAR> psz;
		CNames Names;
		UINT i;

		GetNamesAndAttributes(&Names);

		pDisplayNames->RemoveAll();

		for(i = 0; i < Names.GetCount(); i++)
		{
			cbTmp = cbDisplayName;
#pragma warning(push)
#pragma warning(disable: 6535)
			/* prefast noise VSW 492728 */
			if(!::LookupPrivilegeDisplayName(NULL, Names[i], psz, &cbTmp, &dwLang))
#pragma warning(pop)
			{
				if(::GetLastError() == ERROR_INSUFFICIENT_BUFFER)
				{
					psz.Free();
					if(!psz.Allocate(cbTmp + 1))
					{
						pDisplayNames->RemoveAll();
						AtlThrow(E_OUTOFMEMORY);
					}

					cbDisplayName = cbTmp;
					if(!::LookupPrivilegeDisplayName(NULL, Names[i], psz, &cbTmp, &dwLang))
						break;
				}
				else
					break;
			}
			pDisplayNames->Add((LPTSTR) psz);
		}

		if(i != Names.GetCount())
			pDisplayNames->RemoveAll();
	}
}

inline void CTokenPrivileges::GetLuidsAndAttributes(
	CLUIDArray *pLuids,
	CAttributes *pAttributes /* = NULL */) const throw(...)
{
	ATLASSERT(pLuids);
	if(pLuids)
	{
		const Map::CPair *pPair;

		pLuids->RemoveAll();
		if(pAttributes)
			pAttributes->RemoveAll();

		POSITION pos = m_mapTokenPrivileges.GetStartPosition();
		while(pos)
		{
			pPair = m_mapTokenPrivileges.GetNext(pos);
			pLuids->Add(pPair->m_key);
			if(pAttributes)
				pAttributes->Add(pPair->m_value);
		}
	}
}

inline bool CTokenPrivileges::Delete(LPCTSTR pszPrivilege) throw()
{
	LUID Luid;
	if(!::LookupPrivilegeValue(NULL, pszPrivilege, &Luid))
		return false;

	if(!m_mapTokenPrivileges.RemoveKey(Luid))
		return false;

	m_bDirty = true;
	return true;
}

inline void CTokenPrivileges::DeleteAll() throw()
{
	m_mapTokenPrivileges.RemoveAll();
	m_bDirty = true;
}

inline UINT CTokenPrivileges::GetCount() const throw()
{
	return (UINT) m_mapTokenPrivileges.GetCount();
}

inline UINT CTokenPrivileges::GetLength() const throw()
{
	return offsetof(TOKEN_PRIVILEGES, Privileges) + sizeof(LUID_AND_ATTRIBUTES) * GetCount();
}

inline const TOKEN_PRIVILEGES *CTokenPrivileges::GetPTOKEN_PRIVILEGES() const throw(...)
{
	if(m_bDirty)
	{
		free(m_pTokenPrivileges);
		m_pTokenPrivileges = NULL;

		if(m_mapTokenPrivileges.GetCount())
		{
			m_pTokenPrivileges = static_cast<TOKEN_PRIVILEGES *>(malloc(GetLength()));
			if(!m_pTokenPrivileges)
				AtlThrow(E_OUTOFMEMORY);

			m_pTokenPrivileges->PrivilegeCount = (DWORD) GetCount();

			UINT i = 0;
			POSITION pos = m_mapTokenPrivileges.GetStartPosition();
			const Map::CPair *pPair;
			while(pos)
			{
				pPair = m_mapTokenPrivileges.GetNext(pos);
				m_pTokenPrivileges->Privileges[i].Luid = pPair->m_key;
				m_pTokenPrivileges->Privileges[i].Attributes = pPair->m_value;

				i++;
			}
		}
	}
	return m_pTokenPrivileges;
}

inline CTokenPrivileges::operator const TOKEN_PRIVILEGES *() const throw(...)
{
	return GetPTOKEN_PRIVILEGES();
}

inline void CTokenPrivileges::AddPrivileges(const TOKEN_PRIVILEGES &rPrivileges) throw(...)
{
	m_bDirty = true;
	for(UINT i = 0; i < rPrivileges.PrivilegeCount; i++)
#pragma warning(push)
#pragma warning(disable: 6385)
		/* prefast noise VSW 492737 */
		m_mapTokenPrivileges.SetAt(
			rPrivileges.Privileges[i].Luid, rPrivileges.Privileges[i].Attributes);
#pragma warning(pop)
}

//******************************************************
// CTokenGroups implementation

inline CTokenGroups::CTokenGroups() throw() :
	m_pTokenGroups(NULL),
	m_bDirty(true)
{
}

inline CTokenGroups::~CTokenGroups() throw()
{
	free(m_pTokenGroups);
}

inline CTokenGroups::CTokenGroups(const CTokenGroups &rhs) throw(...) :
	m_pTokenGroups(NULL),
	m_bDirty(true)
{
	const Map::CPair *pPair;
	POSITION pos = rhs.m_mapTokenGroups.GetStartPosition();
	while(pos)
	{
		pPair = rhs.m_mapTokenGroups.GetNext(pos);
		m_mapTokenGroups.SetAt(pPair->m_key, pPair->m_value);
	}
}

inline CTokenGroups &CTokenGroups::operator=(const CTokenGroups &rhs) throw(...)
{
	if(this != &rhs)
	{
		m_mapTokenGroups.RemoveAll();

		const Map::CPair *pPair;
		POSITION pos = rhs.m_mapTokenGroups.GetStartPosition();
		while(pos)
		{
			pPair = rhs.m_mapTokenGroups.GetNext(pos);
			m_mapTokenGroups.SetAt(pPair->m_key, pPair->m_value);
		}
		m_bDirty = true;
	}
	return *this;
}

inline CTokenGroups::CTokenGroups(const TOKEN_GROUPS &rhs) throw(...) :
	m_pTokenGroups(NULL)
{
	AddTokenGroups(rhs);
}

inline CTokenGroups &CTokenGroups::operator=(const TOKEN_GROUPS &rhs) throw(...)
{
	m_mapTokenGroups.RemoveAll();
	AddTokenGroups(rhs);
	return *this;
}

inline void CTokenGroups::Add(const TOKEN_GROUPS &rTokenGroups) throw(...)
{
	AddTokenGroups(rTokenGroups);
}

inline void CTokenGroups::Add(const CSid &rSid, DWORD dwAttributes) throw(...)
{
	m_mapTokenGroups.SetAt(rSid, dwAttributes);
	m_bDirty = true;
}

inline bool CTokenGroups::LookupSid(const CSid &rSid, DWORD *pdwAttributes /* = NULL */) const throw()
{
	DWORD dwAttributes;
	if(m_mapTokenGroups.Lookup(rSid, dwAttributes))
	{
		if(pdwAttributes)
			*pdwAttributes = dwAttributes;
		return true;
	}
	return false;
}

inline void CTokenGroups::GetSidsAndAttributes(
	CSid::CSidArray *pSids,
	CAtlArray<DWORD> *pAttributes /* = NULL */) const throw(...)
{
	ATLASSERT(pSids);
	if(pSids)
	{
		const Map::CPair *pPair;

		pSids->RemoveAll();
		if(pAttributes)
			pAttributes->RemoveAll();

		POSITION pos = m_mapTokenGroups.GetStartPosition();
		while(pos)
		{
			pPair = m_mapTokenGroups.GetNext(pos);
			pSids->Add(pPair->m_key);
			if(pAttributes)
				pAttributes->Add(pPair->m_value);
		}
	}
}

inline bool CTokenGroups::Delete(const CSid &rSid) throw()
{
	return m_mapTokenGroups.RemoveKey(rSid);
}

inline void CTokenGroups::DeleteAll() throw()
{
	m_mapTokenGroups.RemoveAll();
	m_bDirty = true;
}

inline UINT CTokenGroups::GetCount() const throw()
{
	return (UINT) m_mapTokenGroups.GetCount();
}

inline UINT CTokenGroups::GetLength() const throw()
{
	return UINT(offsetof(TOKEN_GROUPS, Groups) + sizeof(SID_AND_ATTRIBUTES) * m_mapTokenGroups.GetCount());
}

inline const TOKEN_GROUPS *CTokenGroups::GetPTOKEN_GROUPS() const throw(...)
{
	if(m_bDirty)
	{
		free(m_pTokenGroups);
		m_pTokenGroups = NULL;

		if(m_mapTokenGroups.GetCount())
		{
			m_pTokenGroups = static_cast<TOKEN_GROUPS *>(malloc(GetLength()));
			if(!m_pTokenGroups)
				AtlThrow(E_OUTOFMEMORY);

			m_pTokenGroups->GroupCount = (DWORD) m_mapTokenGroups.GetCount();

			UINT i = 0;
			POSITION pos = m_mapTokenGroups.GetStartPosition();
			const Map::CPair *pPair;
			while(pos)
			{
				pPair = m_mapTokenGroups.GetNext(pos);
				m_pTokenGroups->Groups[i].Sid = const_cast<SID *>(pPair->m_key.GetPSID());
				m_pTokenGroups->Groups[i].Attributes = pPair->m_value;

				i++;
			}
		}
	}
	return m_pTokenGroups;
}

inline CTokenGroups::operator const TOKEN_GROUPS *() const throw(...)
{
	return GetPTOKEN_GROUPS();
}

inline void CTokenGroups::AddTokenGroups(const TOKEN_GROUPS &rTokenGroups) throw(...)
{
	m_bDirty = true;
	for(UINT i = 0; i < rTokenGroups.GroupCount; i++)
#pragma warning(push)
#pragma warning(disable: 6385)
		/* prefast noise VSW 492737 */
		m_mapTokenGroups.SetAt(
			CSid(static_cast<SID *>(rTokenGroups.Groups[i].Sid)),
			rTokenGroups.Groups[i].Attributes);
#pragma warning(pop)
}

// *************************************
// CAccessToken implementation

inline CAccessToken::CAccessToken() throw() :
	m_hToken(NULL),
	m_hProfile(NULL),
	m_pRevert(NULL)
{
}

inline CAccessToken::~CAccessToken() throw()
{
	Clear();
}

inline void CAccessToken::Attach(HANDLE hToken) throw()
{
	ATLASSUME(m_hToken == NULL);
	m_hToken = hToken;
}

inline HANDLE CAccessToken::Detach() throw()
{
	HANDLE hToken = m_hToken;
	m_hToken = NULL;
	Clear();
	return hToken;
}

inline HANDLE CAccessToken::GetHandle() const throw()
{
	return m_hToken;
}

inline HKEY CAccessToken::HKeyCurrentUser() const throw()
{
	return reinterpret_cast<HKEY>(m_hProfile);
}

inline bool CAccessToken::EnablePrivilege(
	LPCTSTR pszPrivilege,
	CTokenPrivileges *pPreviousState /* = NULL */,bool* pbErrNotAllAssigned /*=NULL*/) throw(...)
{
	CTokenPrivileges NewState;
	NewState.Add(pszPrivilege, true);
	return EnableDisablePrivileges(NewState, pPreviousState,pbErrNotAllAssigned);
}

inline bool CAccessToken::EnablePrivileges(
	const CAtlArray<LPCTSTR> &rPrivileges,
	CTokenPrivileges *pPreviousState /* = NULL */,bool* pbErrNotAllAssigned /*=NULL*/) throw(...)
{
	return EnableDisablePrivileges(rPrivileges, true, pPreviousState,pbErrNotAllAssigned);
}

inline bool CAccessToken::DisablePrivilege(
	LPCTSTR pszPrivilege,
	CTokenPrivileges *pPreviousState /* = NULL */,bool* pbErrNotAllAssigned /*=NULL*/) throw(...)
{
	CTokenPrivileges NewState;
	NewState.Add(pszPrivilege, false);
	return EnableDisablePrivileges(NewState, pPreviousState,pbErrNotAllAssigned);
}

inline bool CAccessToken::DisablePrivileges(
	const CAtlArray<LPCTSTR> &rPrivileges,
	CTokenPrivileges *pPreviousState /* = NULL */,bool* pbErrNotAllAssigned /*=NULL*/) throw(...)
{
	return EnableDisablePrivileges(rPrivileges, false, pPreviousState,pbErrNotAllAssigned);
}

inline bool CAccessToken::EnableDisablePrivileges(
	const CTokenPrivileges &rNewState,
	CTokenPrivileges *pPreviousState /* = NULL */,bool* pbErrNotAllAssigned /*=NULL*/) throw(...)
{
	if(!rNewState.GetCount())
	{
		return true;
	}

	TOKEN_PRIVILEGES *pNewState = const_cast<TOKEN_PRIVILEGES *>(rNewState.GetPTOKEN_PRIVILEGES());

	DWORD dwLength = DWORD(offsetof(TOKEN_PRIVILEGES, Privileges) +
		rNewState.GetCount() * sizeof(LUID_AND_ATTRIBUTES));

	USES_ATL_SAFE_ALLOCA;
	TOKEN_PRIVILEGES *pPrevState = static_cast<TOKEN_PRIVILEGES *>(_ATL_SAFE_ALLOCA(dwLength, _ATL_SAFE_ALLOCA_DEF_THRESHOLD));
	if(::AdjustTokenPrivileges(m_hToken, FALSE, pNewState, dwLength, pPrevState, &dwLength))
	{
		if (pbErrNotAllAssigned)
		{
			if(::GetLastError() == ERROR_NOT_ALL_ASSIGNED)
			{
				*pbErrNotAllAssigned=true;
			} else
			{
				*pbErrNotAllAssigned=false;
			}
		}
	} else
	{
		return false;
	}

	if(pPreviousState)
	{
		pPreviousState->Add(*pPrevState);
	}

	return true;
}

inline bool CAccessToken::PrivilegeCheck(PPRIVILEGE_SET RequiredPrivileges, bool *pbResult) const throw()
{
	BOOL bResult;
	if(!::PrivilegeCheck(m_hToken, RequiredPrivileges, &bResult))
		return false;

	*pbResult = 0 != bResult;
	return true;
}

inline bool CAccessToken::GetLogonSid(CSid *pSid) const throw(...)
{
	ATLASSERT(pSid);
	if(!pSid)
		return false;

	DWORD dwLen;
	::GetTokenInformation(m_hToken, TokenGroups, NULL, 0, &dwLen);
	if(::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		return false;

	USES_ATL_SAFE_ALLOCA;
	TOKEN_GROUPS *pGroups = static_cast<TOKEN_GROUPS *>(_ATL_SAFE_ALLOCA(dwLen, _ATL_SAFE_ALLOCA_DEF_THRESHOLD));
	if(::GetTokenInformation(m_hToken, TokenGroups, pGroups, dwLen, &dwLen))
		for(UINT i = 0; i < pGroups->GroupCount; i++)
			if(pGroups->Groups[i].Attributes & SE_GROUP_LOGON_ID)
			{
				*pSid = *static_cast<SID *>(pGroups->Groups[i].Sid);
				return true;
			}
	return false;
}

inline bool CAccessToken::GetTokenId(LUID *pluid) const throw(...)
{
	ATLASSERT(pluid);
	if(!pluid)
		return false;

	TOKEN_STATISTICS Statistics;
	if(!GetStatistics(&Statistics))
		return false;

	*pluid = Statistics.TokenId;
	return true;
}

inline bool CAccessToken::GetLogonSessionId(LUID *pluid) const throw(...)
{
	ATLASSERT(pluid);
	if(!pluid)
		return false;

	TOKEN_STATISTICS Statistics;
	if(!GetStatistics(&Statistics))
		return false;

	*pluid = Statistics.AuthenticationId;
	return true;
}

inline bool CAccessToken::CheckTokenMembership(const CSid &rSid, bool *pbIsMember) const throw(...)
{
	// "this" must be an impersonation token and NOT a primary token
	BOOL bIsMember;

	ATLASSERT(pbIsMember);
	if (!pbIsMember)
		return false;

#if(_WIN32_WINNT >= 0x0500)
	if(::CheckTokenMembership(m_hToken, const_cast<SID *>(rSid.GetPSID()), &bIsMember))
#else
	GENERIC_MAPPING gm = {0, 0, 0, 1};
	PRIVILEGE_SET ps;
	DWORD cb = sizeof(PRIVILEGE_SET);
	DWORD ga;
	CSecurityDesc sd;
	CDacl dacl;

	if (!dacl.AddAllowedAce(rSid, 1))
		return false;
	sd.SetOwner(rSid);
	sd.SetGroup(rSid);
	sd.SetDacl(dacl);

	if(::AccessCheck(const_cast<SECURITY_DESCRIPTOR *>(sd.GetPSECURITY_DESCRIPTOR()),
		m_hToken, 1, &gm, &ps, &cb, &ga, &bIsMember))
#endif
	{
		*pbIsMember = 0 != bIsMember;
		return true;
	}
	return false;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CAccessToken::IsTokenRestricted() const throw()
{
	return 0 != ::IsTokenRestricted(m_hToken);
}
#endif

inline bool CAccessToken::GetDefaultDacl(CDacl *pDacl) const throw(...)
{
	return GetInfoConvert<CDacl, TOKEN_DEFAULT_DACL>(pDacl, TokenDefaultDacl);
}

inline bool CAccessToken::GetGroups(CTokenGroups *pGroups) const throw(...)
{
	return GetInfoConvert<CTokenGroups, TOKEN_GROUPS>(pGroups, TokenGroups);
}

inline bool CAccessToken::GetImpersonationLevel(SECURITY_IMPERSONATION_LEVEL *pImpersonationLevel) const throw(...)
{
	return GetInfo<SECURITY_IMPERSONATION_LEVEL>(pImpersonationLevel, TokenImpersonationLevel);
}

inline bool CAccessToken::GetOwner(CSid *pSid) const throw(...)
{
	return GetInfoConvert<CSid, TOKEN_OWNER>(pSid, TokenOwner);
}

inline bool CAccessToken::GetPrimaryGroup(CSid *pSid) const throw(...)
{
	return GetInfoConvert<CSid, TOKEN_PRIMARY_GROUP>(pSid, TokenPrimaryGroup);
}

inline bool CAccessToken::GetPrivileges(CTokenPrivileges *pPrivileges) const throw(...)
{
	return GetInfoConvert<CTokenPrivileges, TOKEN_PRIVILEGES>(pPrivileges, TokenPrivileges);
}

inline bool CAccessToken::GetTerminalServicesSessionId(DWORD *pdwSessionId) const throw(...)
{
	return GetInfo<DWORD>(pdwSessionId, TokenSessionId);
}

inline bool CAccessToken::GetSource(TOKEN_SOURCE *pSource) const throw(...)
{
	return GetInfo<TOKEN_SOURCE>(pSource, TokenSource);
}

inline bool CAccessToken::GetStatistics(TOKEN_STATISTICS *pStatistics) const throw(...)
{
	return GetInfo<TOKEN_STATISTICS>(pStatistics, TokenStatistics);
}

inline bool CAccessToken::GetType(TOKEN_TYPE *pType) const throw(...)
{
	return GetInfo<TOKEN_TYPE>(pType, TokenType);
}

inline bool CAccessToken::GetUser(CSid *pSid) const throw(...)
{
	return GetInfoConvert<CSid, TOKEN_USER>(pSid, TokenUser);
}

inline bool CAccessToken::SetOwner(const CSid &rSid) throw(...)

{
	TOKEN_OWNER to;
	to.Owner = const_cast<SID *>(rSid.GetPSID());
	return 0 != ::SetTokenInformation(m_hToken, TokenOwner, &to, sizeof(to));
}

inline bool CAccessToken::SetPrimaryGroup(const CSid &rSid) throw(...)
{
	TOKEN_PRIMARY_GROUP tpg;
	tpg.PrimaryGroup = const_cast<SID *>(rSid.GetPSID());
	return 0 != ::SetTokenInformation(m_hToken, TokenPrimaryGroup, &tpg, sizeof(tpg));
}

inline bool CAccessToken::SetDefaultDacl(const CDacl &rDacl) throw(...)
{
	TOKEN_DEFAULT_DACL tdd;
	tdd.DefaultDacl = const_cast<ACL *>(rDacl.GetPACL());
	return 0 != ::SetTokenInformation(m_hToken, TokenDefaultDacl, &tdd, sizeof(tdd));
}

inline bool CAccessToken::CreateImpersonationToken(
	CAccessToken *pImp,
	SECURITY_IMPERSONATION_LEVEL sil /* = SecurityImpersonation */) const throw(...)
{
	ATLASSERT(pImp);
	if(!pImp)
		return false;

	HANDLE hToken;
	if(!::DuplicateToken(m_hToken, sil, &hToken))
		return false;

	pImp->Clear();
	pImp->m_hToken = hToken;
	return true;
}

inline bool CAccessToken::CreatePrimaryToken(
	CAccessToken *pPri,
	DWORD dwDesiredAccess /* = MAXIMUM_ALLOWED */,
	const CSecurityAttributes *pTokenAttributes /* = NULL */) const throw(...)
{
	ATLASSERT(pPri);
	if(!pPri)
		return false;

	HANDLE hToken;
	if(!::DuplicateTokenEx(m_hToken, dwDesiredAccess,
		const_cast<CSecurityAttributes *>(pTokenAttributes),
		SecurityAnonymous, TokenPrimary, &hToken))
	{
		return false;
	}

	pPri->Clear();
	pPri->m_hToken = hToken;
	return true;
}

#if(_WIN32_WINNT >= 0x0500)

inline bool CAccessToken::CreateRestrictedToken(
	CAccessToken *pRestrictedToken,
	const CTokenGroups &SidsToDisable,
	const CTokenGroups &SidsToRestrict,
	const CTokenPrivileges &PrivilegesToDelete /* = CTokenPrivileges() */) const throw(...)
{
	ATLASSERT(pRestrictedToken);
	if(!pRestrictedToken)
		return false;

	HANDLE hToken;
	SID_AND_ATTRIBUTES *pSidsToDisable;
	SID_AND_ATTRIBUTES *pSidsToRestrict;
	LUID_AND_ATTRIBUTES *pPrivilegesToDelete;

	UINT nDisableSidCount = SidsToDisable.GetCount();
	if(nDisableSidCount)
	{
		const TOKEN_GROUPS * pTOKEN_GROUPS = SidsToDisable.GetPTOKEN_GROUPS();

		ATLASSERT(pTOKEN_GROUPS != NULL);

		if(pTOKEN_GROUPS != NULL)
		{
			pSidsToDisable = const_cast<SID_AND_ATTRIBUTES *>
				(pTOKEN_GROUPS->Groups);
		}
		else
		{
			return false;
		}
	}
	else
	{
		pSidsToDisable = NULL;
	}

	UINT nRestrictedSidCount = SidsToRestrict.GetCount();
	if(nRestrictedSidCount)
	{
		const TOKEN_GROUPS * pTOKEN_GROUPS = SidsToRestrict.GetPTOKEN_GROUPS();

		ATLASSERT(pTOKEN_GROUPS != NULL);

		if(pTOKEN_GROUPS != NULL)
		{
			pSidsToRestrict = const_cast<SID_AND_ATTRIBUTES *>
				(pTOKEN_GROUPS->Groups);
		}
		else
		{
			return false;
		}

	}
	else
	{
		pSidsToRestrict = NULL;
	}

	UINT nDeletePrivilegesCount = PrivilegesToDelete.GetCount();
	if(nDeletePrivilegesCount)
	{
		const TOKEN_PRIVILEGES * pTOKEN_PRIVILEGES = PrivilegesToDelete.GetPTOKEN_PRIVILEGES();

		ATLASSERT(pTOKEN_PRIVILEGES != NULL);

		if(pTOKEN_PRIVILEGES != NULL)
		{
			pPrivilegesToDelete = const_cast<LUID_AND_ATTRIBUTES *>
				(pTOKEN_PRIVILEGES->Privileges);
		}
		else
		{
			return false;
		}

	}
	else
	{
		pPrivilegesToDelete = NULL;
	}

	if(!::CreateRestrictedToken(m_hToken, 0,
		(DWORD) nDisableSidCount, pSidsToDisable,
		(DWORD) nDeletePrivilegesCount, pPrivilegesToDelete,
		(DWORD) nRestrictedSidCount, pSidsToRestrict, &hToken))
	{
		return false;
	}

	pRestrictedToken->Clear();
	pRestrictedToken->m_hToken = hToken;
	return true;
}

#endif // _WIN32_WINNT >= 0x0500

inline bool CAccessToken::GetProcessToken(DWORD dwDesiredAccess, HANDLE hProcess /* = NULL */) throw()
{
	if(!hProcess)
		hProcess = ::GetCurrentProcess();

	HANDLE hToken;
	if(!::OpenProcessToken(hProcess, dwDesiredAccess, &hToken))
		return false;

	Clear();
	m_hToken = hToken;
	return true;
}

inline bool CAccessToken::GetThreadToken(
	DWORD dwDesiredAccess,
	HANDLE hThread /* = NULL */,
	bool bOpenAsSelf /* = true */) throw()
{
	if(!hThread)
		hThread = ::GetCurrentThread();

	HANDLE hToken;
	if(!::OpenThreadToken(hThread, dwDesiredAccess, bOpenAsSelf, &hToken))
		return false;

	Clear();
	m_hToken = hToken;

	return true;
}

inline bool CAccessToken::GetEffectiveToken(DWORD dwDesiredAccess) throw()
{
	if(!GetThreadToken(dwDesiredAccess))
		return GetProcessToken(dwDesiredAccess);
	return true;
}

inline bool CAccessToken::OpenThreadToken(
	DWORD dwDesiredAccess,
	bool bImpersonate /* = false */,
	bool bOpenAsSelf /* = true */,
	SECURITY_IMPERSONATION_LEVEL sil /* = SecurityImpersonation */) throw(...)
{
	CheckImpersonation();

	if(!::ImpersonateSelf(sil))
		return false;

	HANDLE hToken;
	if(!::OpenThreadToken(::GetCurrentThread(), dwDesiredAccess, bOpenAsSelf, &hToken))
		return false;

	Clear();
	m_hToken = hToken;

	if(!bImpersonate)
		::RevertToSelf();
	else
	{
		ATLTRY(m_pRevert = new CRevertToSelf);
		if(!m_pRevert)
		{
			::RevertToSelf();
			Clear();
			return false;
		}
	}
	return true;
}

#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) 
inline bool CAccessToken::OpenCOMClientToken(
	DWORD dwDesiredAccess,
	bool bImpersonate /* = false */,
	bool bOpenAsSelf /* = true */) throw(...)
{
	CheckImpersonation();

	if(FAILED(::CoImpersonateClient()))
		return false;

	HANDLE hToken;
	if(!::OpenThreadToken(::GetCurrentThread(), dwDesiredAccess, bOpenAsSelf, &hToken))
		return false;

	Clear();
	m_hToken = hToken;

	if(!bImpersonate)
		::CoRevertToSelf();
	else
	{
		ATLTRY(m_pRevert = new CCoRevertToSelf);
		if(!m_pRevert)
		{
			::CoRevertToSelf();
			Clear();
			return false;
		}
	}
	return true;
}
#endif //(_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) 

inline bool CAccessToken::OpenNamedPipeClientToken(
	HANDLE hPipe,
	DWORD dwDesiredAccess,
	bool bImpersonate /* = false */,
	bool bOpenAsSelf /* = true */) throw(...)
{
	CheckImpersonation();

	if(!::ImpersonateNamedPipeClient(hPipe))
		return false;

	HANDLE hToken;
	if(!::OpenThreadToken(::GetCurrentThread(), dwDesiredAccess, bOpenAsSelf, &hToken))
		return false;

	Clear();
	m_hToken = hToken;

	if(!bImpersonate)
		::RevertToSelf();
	else
	{
		ATLTRY(m_pRevert = new CRevertToSelf);
		if(!m_pRevert)
		{
			::RevertToSelf();
			Clear();
			return false;
		}
	}
	return true;
}

inline bool CAccessToken::OpenRPCClientToken(
	RPC_BINDING_HANDLE BindingHandle,
	DWORD dwDesiredAccess,
	bool bImpersonate /* = false */,
	bool bOpenAsSelf /* = true */) throw(...)
{
	CheckImpersonation();

	if(RPC_S_OK != ::RpcImpersonateClient(BindingHandle))
		return false;

	HANDLE hToken;
	if(!::OpenThreadToken(::GetCurrentThread(), dwDesiredAccess, bOpenAsSelf, &hToken))
		return false;

	Clear();
	m_hToken = hToken;

	if(!bImpersonate)
	{
		RPC_STATUS rpcStatus = ::RpcRevertToSelfEx(BindingHandle);
		if( rpcStatus != RPC_S_OK )
		{
			Clear();
			return false;
		}
	}
	else
	{
		ATLTRY(m_pRevert = new CRpcRevertToSelfEx(BindingHandle));
		if(!m_pRevert)
		{
			RPC_STATUS rpcStatus = ::RpcRevertToSelfEx(BindingHandle);
		    if( rpcStatus != RPC_S_OK )
		    {
                // If we continue, arbitrary user code will run in the wrong context. Too dangerous to risk
                _ATL_FATAL_SHUTDOWN;
		    }
		}
	}
	return true;
}

inline bool CAccessToken::ImpersonateLoggedOnUser() const throw(...)
{
	CheckImpersonation();

	ATLASSUME(m_hToken);
	if(m_hToken && ::ImpersonateLoggedOnUser(m_hToken))
	{
		ATLASSERT(!m_pRevert);
		delete m_pRevert;
		ATLTRY(m_pRevert = new CRevertToSelf);
		if (!m_pRevert)
		{
			::RevertToSelf();
			return false;
		}
		return true;
	}
	return false;
}

inline bool CAccessToken::Impersonate(HANDLE hThread /* = NULL */) const throw(...)
{
	CheckImpersonation();

	ATLASSUME(m_hToken);
	if(m_hToken)
		return 0 != ::SetThreadToken(hThread ? &hThread : NULL, m_hToken);
	return false;
}

inline bool CAccessToken::Revert(HANDLE hThread /* = NULL */) const throw()
{
	if (hThread || !m_pRevert)
		return 0 != ::SetThreadToken(hThread ? &hThread : NULL, NULL);

	bool bRet = m_pRevert->Revert();
	delete m_pRevert;
	m_pRevert = NULL;
	return bRet;
}

inline bool CAccessToken::LoadUserProfile() throw(...)
{
	ATLASSUME(m_hToken && !m_hProfile);
	if(!m_hToken || m_hProfile)
		return false;

	CSid UserSid;
	PROFILEINFO Profile;

	if(!GetUser(&UserSid))
		return false;

	memset(&Profile, 0x00, sizeof(PROFILEINFO));
	Profile.dwSize = sizeof(PROFILEINFO);
	Profile.lpUserName = const_cast<LPTSTR>(UserSid.AccountName());
	if(!::LoadUserProfile(m_hToken, &Profile))
		return false;

	m_hProfile = Profile.hProfile;

	return true;
}

inline HANDLE CAccessToken::GetProfile() const throw()
{
	return m_hProfile;
}

inline bool CAccessToken::LogonUser(
	LPCTSTR pszUserName,
	LPCTSTR pszDomain,
	LPCTSTR pszPassword,
	DWORD dwLogonType /* = LOGON32_LOGON_INTERACTIVE */,
	DWORD dwLogonProvider /* = LOGON32_PROVIDER_DEFAULT */) throw()
{
	Clear();

	return 0 != ::LogonUser(
		const_cast<LPTSTR>(pszUserName),
		const_cast<LPTSTR>(pszDomain),
		const_cast<LPTSTR>(pszPassword),
		dwLogonType, dwLogonProvider, &m_hToken);
}

inline bool CAccessToken::CreateProcessAsUser(
	__in_z_opt LPCTSTR pApplicationName,
	__in_z_opt LPTSTR pCommandLine,
	__in LPPROCESS_INFORMATION pProcessInformation,
	__in LPSTARTUPINFO pStartupInfo,
	__in DWORD dwCreationFlags /* = NORMAL_PRIORITY_CLASS */,
	__in bool bLoadProfile /* = false */,
	__in_opt const CSecurityAttributes *pProcessAttributes /* = NULL */,
	__in_opt const CSecurityAttributes *pThreadAttributes /* = NULL */,
	__in bool bInherit /* = false */,
	__in_z_opt LPCTSTR pCurrentDirectory /* = NULL */) throw()
{
	ATLASSERT(pProcessInformation != NULL);
	ATLASSERT(pStartupInfo != NULL);

	if(!pProcessInformation || !pStartupInfo)
	{
		return false;
	}

	LPVOID pEnvironmentBlock;
	PROFILEINFO Profile;
	CSid UserSid;
	DWORD dwLastError;

	HANDLE hToken = m_hToken;

	// Straighten out impersonation problems...
	TOKEN_TYPE TokenType;
	if(!GetType(&TokenType))
	{
		return false;
	}

	if (TokenType != TokenPrimary)
	{
		hToken = NULL;
		if (!::DuplicateTokenEx(m_hToken, TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_ASSIGN_PRIMARY, NULL,
			SecurityImpersonation, TokenPrimary, &hToken))
		{
			return false;
		}
	}

	// Profile
	if(bLoadProfile && !m_hProfile)
	{
		if(!GetUser(&UserSid))
		{
			if(TokenType != TokenPrimary)
				::CloseHandle(hToken);
			return false;
		}
		memset(&Profile, 0x00, sizeof(PROFILEINFO));
		Profile.dwSize = sizeof(PROFILEINFO);
		Profile.lpUserName = const_cast<LPTSTR>(UserSid.AccountName());
		if(::LoadUserProfile(hToken, &Profile))
			m_hProfile = Profile.hProfile;
	}

	// Environment block
	if(!::CreateEnvironmentBlock(&pEnvironmentBlock, hToken, bInherit))
		return false;

	BOOL bRetVal = ::CreateProcessAsUser(
		hToken,
		pApplicationName,
		pCommandLine,
		const_cast<CSecurityAttributes *>(pProcessAttributes),
		const_cast<CSecurityAttributes *>(pThreadAttributes),
		bInherit,
		dwCreationFlags,
		pEnvironmentBlock,
		pCurrentDirectory,
		pStartupInfo,
		pProcessInformation);

	 dwLastError = ::GetLastError();

	if(TokenType != TokenPrimary)
		::CloseHandle(hToken);

	::DestroyEnvironmentBlock(pEnvironmentBlock);

	::SetLastError(dwLastError);
	return bRetVal != 0;
}

inline bool CAccessToken::EnableDisablePrivileges(
	const CAtlArray<LPCTSTR> &rPrivileges,
	bool bEnable,
	CTokenPrivileges *pPreviousState,bool* pbErrNotAllAssigned/*=NULL*/) throw(...)
{
	CTokenPrivileges NewState;
	for(UINT i = 0; i < rPrivileges.GetCount(); i++)
		NewState.Add(rPrivileges[i], bEnable);
	return EnableDisablePrivileges(NewState, pPreviousState,pbErrNotAllAssigned);
}

inline bool CAccessToken::CheckImpersonation() const throw()
{
	// You should not be impersonating at this point.  Use GetThreadToken
	// instead of the OpenXXXToken functions or call Revert before
	// calling Impersonate.
	HANDLE hToken=INVALID_HANDLE_VALUE;
	if(!::OpenThreadToken(::GetCurrentThread(), 0, false, &hToken) &&
		::GetLastError() != ERROR_NO_TOKEN)
	{
		ATLTRACE(atlTraceSecurity, 2, _T("Caution: replacing thread impersonation token.\n"));
		return true;
	}
	if(hToken!=INVALID_HANDLE_VALUE)
	{
	    ::CloseHandle(hToken);
	}
	return false;
}

inline void CAccessToken::Clear() throw()
{
	if(m_hProfile)
	{
		ATLASSUME(m_hToken);
		if(m_hToken)
			::UnloadUserProfile(m_hToken, m_hProfile);
		m_hProfile = NULL;
	}

	if(m_hToken)
	{
		::CloseHandle(m_hToken);
		m_hToken = NULL;
	}
	delete m_pRevert;
	m_pRevert = NULL;
}

//*******************************************
// CAutoRevertImpersonation implementation

inline CAutoRevertImpersonation::CAutoRevertImpersonation(const CAccessToken* pAT) throw()
{
	m_pAT = pAT;
}

inline CAutoRevertImpersonation::~CAutoRevertImpersonation() throw()
{
	if (m_pAT != NULL)
	{
		m_pAT->Revert();
	}
}

inline void CAutoRevertImpersonation::Attach(const CAccessToken* pAT) throw()
{
	ATLASSUME(m_pAT == NULL);
	m_pAT = pAT;
}

inline const CAccessToken* CAutoRevertImpersonation::Detach() throw()
{
	const CAccessToken* pAT = m_pAT;
	m_pAT = NULL;
	return pAT;
}

inline const CAccessToken* CAutoRevertImpersonation::GetAccessToken() throw()
{
	return m_pAT;
}

//*******************************************
// CPrivateObjectSecurityDesc implementation

inline CPrivateObjectSecurityDesc::CPrivateObjectSecurityDesc() throw() :
	m_bPrivate(false),
	CSecurityDesc()
{
}

inline CPrivateObjectSecurityDesc::~CPrivateObjectSecurityDesc() throw()
{
	Clear();
}

inline bool CPrivateObjectSecurityDesc::Create(
	const CSecurityDesc *pParent,
	const CSecurityDesc *pCreator,
	bool bIsDirectoryObject,
	const CAccessToken &Token,
	PGENERIC_MAPPING GenericMapping) throw()
{
	Clear();

	const SECURITY_DESCRIPTOR *pSDParent = pParent ? pParent->GetPSECURITY_DESCRIPTOR() : NULL;
	const SECURITY_DESCRIPTOR *pSDCreator = pCreator ? pCreator->GetPSECURITY_DESCRIPTOR() : NULL;

	if(!::CreatePrivateObjectSecurity(
		const_cast<SECURITY_DESCRIPTOR *>(pSDParent),
		const_cast<SECURITY_DESCRIPTOR *>(pSDCreator),
		reinterpret_cast<PSECURITY_DESCRIPTOR *>(&m_pSecurityDescriptor),
		bIsDirectoryObject, Token.GetHandle(), GenericMapping))
	{
		return false;
	}

	m_bPrivate = true;
	return true;
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CPrivateObjectSecurityDesc::Create(
	const CSecurityDesc *pParent,
	const CSecurityDesc *pCreator,
	GUID *ObjectType,
	bool bIsContainerObject,
	ULONG AutoInheritFlags,
	const CAccessToken &Token,
	PGENERIC_MAPPING GenericMapping) throw()
{
	Clear();

	const SECURITY_DESCRIPTOR *pSDParent = pParent ? pParent->GetPSECURITY_DESCRIPTOR() : NULL;
	const SECURITY_DESCRIPTOR *pSDCreator = pCreator ? pCreator->GetPSECURITY_DESCRIPTOR() : NULL;

	if(!::CreatePrivateObjectSecurityEx(
		const_cast<SECURITY_DESCRIPTOR *>(pSDParent),
		const_cast<SECURITY_DESCRIPTOR *>(pSDCreator),
		reinterpret_cast<PSECURITY_DESCRIPTOR *>(&m_pSecurityDescriptor),
		ObjectType, bIsContainerObject, AutoInheritFlags, Token.GetHandle(), GenericMapping))
	{
		return false;
	}

	m_bPrivate = true;
	return true;
}
#endif

inline bool CPrivateObjectSecurityDesc::Get(SECURITY_INFORMATION si, CSecurityDesc *pResult) const throw()
{
	ATLASSERT(pResult);
	if(!pResult)
		return false;

	if(!m_bPrivate)
		return false;

	DWORD dwLength = 0;
	SECURITY_DESCRIPTOR *pSDResult = NULL;

	if(!::GetPrivateObjectSecurity(m_pSecurityDescriptor, si, pSDResult, dwLength, &dwLength) &&
		::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	{
		return false;
	}

	USES_ATL_SAFE_ALLOCA;
	pSDResult = static_cast<SECURITY_DESCRIPTOR *>(_ATL_SAFE_ALLOCA(dwLength, _ATL_SAFE_ALLOCA_DEF_THRESHOLD));
	if(!::GetPrivateObjectSecurity(m_pSecurityDescriptor, si, pSDResult, dwLength, &dwLength))
		return false;

	*pResult = *pSDResult;

	return true;
}

inline bool CPrivateObjectSecurityDesc::Set(
	SECURITY_INFORMATION si,
	const CSecurityDesc &Modification,
	PGENERIC_MAPPING GenericMapping,
	const CAccessToken &Token) throw()
{
	if(!m_bPrivate)
		return false;

	const SECURITY_DESCRIPTOR *pSDModification = Modification.GetPSECURITY_DESCRIPTOR();

	return 0 != ::SetPrivateObjectSecurity(si,
		const_cast<SECURITY_DESCRIPTOR *>(pSDModification),
		reinterpret_cast<PSECURITY_DESCRIPTOR *>(&m_pSecurityDescriptor),
		GenericMapping, Token.GetHandle());
}

#if(_WIN32_WINNT >= 0x0500)
inline bool CPrivateObjectSecurityDesc::Set(
	SECURITY_INFORMATION si,
	const CSecurityDesc &Modification,
	ULONG AutoInheritFlags,
	PGENERIC_MAPPING GenericMapping,
	const CAccessToken &Token) throw()
{
	if(!m_bPrivate)
		return false;

	const SECURITY_DESCRIPTOR *pSDModification = Modification.GetPSECURITY_DESCRIPTOR();

	return 0 != ::SetPrivateObjectSecurityEx(si,
		const_cast<SECURITY_DESCRIPTOR *>(pSDModification),
		reinterpret_cast<PSECURITY_DESCRIPTOR *>(&m_pSecurityDescriptor),
		AutoInheritFlags, GenericMapping, Token.GetHandle());
}

inline bool CPrivateObjectSecurityDesc::ConvertToAutoInherit(
	const CSecurityDesc *pParent,
	GUID *ObjectType,
	bool bIsDirectoryObject,
	PGENERIC_MAPPING GenericMapping) throw()
{
	if(!m_bPrivate)
		return false;

	const SECURITY_DESCRIPTOR *pSDParent = pParent ? pParent->GetPSECURITY_DESCRIPTOR() : NULL;
	SECURITY_DESCRIPTOR *pSD;

	if(!::ConvertToAutoInheritPrivateObjectSecurity(
		const_cast<SECURITY_DESCRIPTOR *>(pSDParent),
		m_pSecurityDescriptor,
		reinterpret_cast<PSECURITY_DESCRIPTOR *>(&pSD),
		ObjectType, bIsDirectoryObject, GenericMapping))
	{
		return false;
	}

	Clear();
	m_bPrivate = true;
	m_pSecurityDescriptor = pSD;

	return true;
}

inline void CPrivateObjectSecurityDesc::Clear() throw()
{
	if(m_bPrivate)
	{
		ATLVERIFY(::DestroyPrivateObjectSecurity(reinterpret_cast<PSECURITY_DESCRIPTOR *>(&m_pSecurityDescriptor)));
		m_bPrivate = false;
		m_pSecurityDescriptor = NULL;
	}
	else
		CSecurityDesc::Clear();
}

#endif // _WIN32_WINNT >= 0x500

//*******************************************
// Global functions

inline bool AtlGetSecurityDescriptor(
	LPCTSTR pszObjectName,
	SE_OBJECT_TYPE ObjectType,
	CSecurityDesc *pSecurityDescriptor,
	SECURITY_INFORMATION requestedInfo /* =
		OWNER_SECURITY_INFORMATION |
		GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION |
		SACL_SECURITY_INFORMATION */,
	bool bRequestNeededPrivileges /* = true */) throw(...)
{
	ATLASSERT(pSecurityDescriptor);
	if(!pSecurityDescriptor)
		return false;

	SECURITY_DESCRIPTOR *pSD;
	DWORD dwErr;

	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	if (!(requestedInfo & SACL_SECURITY_INFORMATION))
		bRequestNeededPrivileges = false;

	if (bRequestNeededPrivileges)
	{
		if(!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
					false, false, SecurityImpersonation) ||
				!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
				!at.Impersonate())
			return false;
	}

#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType, requestedInfo, NULL, NULL, NULL, NULL, (PSECURITY_DESCRIPTOR *) &pSD);
#pragma warning(pop)

	if (bRequestNeededPrivileges)
	{
		if( !at.EnableDisablePrivileges(TokenPrivileges) )
			return false;
		if( !at.Revert() )
			return false;
	}

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSecurityDescriptor = *pSD;
	::LocalFree(pSD);
	return true;
}

inline bool AtlGetSecurityDescriptor(
	HANDLE hObject,
	SE_OBJECT_TYPE ObjectType,
	CSecurityDesc *pSecurityDescriptor,
	SECURITY_INFORMATION requestedInfo /* =
		OWNER_SECURITY_INFORMATION |
		GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION |
		SACL_SECURITY_INFORMATION */,
	bool bRequestNeededPrivileges /* = true */) throw(...)
{
	ATLASSERT(pSecurityDescriptor);
	if(!pSecurityDescriptor)
		return false;

	SECURITY_DESCRIPTOR *pSD;
	DWORD dwErr;

	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	if (!(requestedInfo & SACL_SECURITY_INFORMATION))
		bRequestNeededPrivileges = false;

	if (bRequestNeededPrivileges)
	{
		if(!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
					false, false, SecurityImpersonation) ||
				!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
				!at.Impersonate())
			return false;
	}

#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	dwErr = ::GetSecurityInfo(hObject, ObjectType, requestedInfo, NULL, NULL, NULL, NULL, reinterpret_cast<PSECURITY_DESCRIPTOR *>(&pSD));
#pragma warning(pop)

	if (bRequestNeededPrivileges)
	{
		if( !at.EnableDisablePrivileges(TokenPrivileges) )
			return false;
		if( !at.Revert() )
			return false;
	}

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSecurityDescriptor = *pSD;
	::LocalFree(pSD);
	return true;
}

inline bool AtlGetOwnerSid(HANDLE hObject, SE_OBJECT_TYPE ObjectType, CSid *pSid) throw(...)
{
	ATLASSERT(hObject && pSid);
	if(!hObject || !pSid)
		return false;

	SID *pOwner;
	PSECURITY_DESCRIPTOR pSD;

#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetSecurityInfo(hObject, ObjectType, OWNER_SECURITY_INFORMATION, (PSID *) &pOwner, NULL, NULL, NULL, &pSD);
#pragma warning(pop)

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSid = *pOwner;
	::LocalFree(pSD);
	return true;
}

inline bool AtlSetOwnerSid(HANDLE hObject, SE_OBJECT_TYPE ObjectType, const CSid &rSid) throw(...)
{
	ATLASSERT(hObject && rSid.IsValid());
	if(!hObject || !rSid.IsValid())
		return false;

	DWORD dwErr = ::SetSecurityInfo(hObject, ObjectType, OWNER_SECURITY_INFORMATION,
		const_cast<SID *>(rSid.GetPSID()), NULL, NULL, NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetOwnerSid(LPCTSTR pszObjectName, SE_OBJECT_TYPE ObjectType, CSid *pSid) throw(...)
{
	ATLASSERT(pszObjectName && pSid);
	if(!pszObjectName || !pSid)
		return false;

	SID *pOwner;
	PSECURITY_DESCRIPTOR pSD;
#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,	OWNER_SECURITY_INFORMATION, reinterpret_cast<PSID *>(&pOwner), NULL, NULL, NULL, &pSD);
#pragma warning(pop)

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSid = *pOwner;
	::LocalFree(pSD);
	return true;
}

inline bool AtlSetOwnerSid(LPCTSTR pszObjectName, SE_OBJECT_TYPE ObjectType, const CSid &rSid) throw(...)
{
	ATLASSERT(pszObjectName && rSid.IsValid());
	if(!pszObjectName || !rSid.IsValid())
		return false;

	DWORD dwErr = ::SetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,
		OWNER_SECURITY_INFORMATION, const_cast<SID *>(rSid.GetPSID()), NULL, NULL, NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetGroupSid(HANDLE hObject, SE_OBJECT_TYPE ObjectType, CSid *pSid) throw(...)
{
	ATLASSERT(hObject && pSid);
	if(!hObject || !pSid)
		return false;

	SID *pGroup;
	PSECURITY_DESCRIPTOR pSD;
#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetSecurityInfo(hObject, ObjectType, GROUP_SECURITY_INFORMATION, NULL, reinterpret_cast<PSID *>(&pGroup), NULL, NULL, &pSD);
#pragma warning(pop)

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSid = *pGroup;
	::LocalFree(pSD);
	return true;
}

inline bool AtlSetGroupSid(HANDLE hObject, SE_OBJECT_TYPE ObjectType, const CSid &rSid) throw(...)
{
	ATLASSERT(hObject && rSid.IsValid());
	if(!hObject || !rSid.IsValid())
		return false;

	DWORD dwErr = ::SetSecurityInfo(hObject, ObjectType, GROUP_SECURITY_INFORMATION,
		NULL, const_cast<SID *>(rSid.GetPSID()), NULL, NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetGroupSid(LPCTSTR pszObjectName, SE_OBJECT_TYPE ObjectType, CSid *pSid) throw(...)
{
	ATLASSERT(pszObjectName && pSid);
	if(!pszObjectName || !pSid)
		return false;

	SID *pGroup;
	PSECURITY_DESCRIPTOR pSD;
#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName),	ObjectType, GROUP_SECURITY_INFORMATION, NULL, reinterpret_cast<PSID *>(&pGroup), NULL, NULL, &pSD);
#pragma warning(pop)

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	*pSid = *pGroup;
	::LocalFree(pSD);
	return true;
}

inline bool AtlSetGroupSid(LPCTSTR pszObjectName, SE_OBJECT_TYPE ObjectType, const CSid &rSid) throw(...)
{
	ATLASSERT(pszObjectName && rSid.IsValid());
	if(!pszObjectName || !rSid.IsValid())
		return false;

	DWORD dwErr = ::SetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,
		GROUP_SECURITY_INFORMATION, NULL, const_cast<SID *>(rSid.GetPSID()), NULL, NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetDacl(HANDLE hObject, SE_OBJECT_TYPE ObjectType, CDacl *pDacl) throw(...)
{
	ATLASSERT(hObject && pDacl);
	if(!hObject || !pDacl)
		return false;

	ACL *pAcl;
	PSECURITY_DESCRIPTOR pSD;

#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetSecurityInfo(hObject, ObjectType, DACL_SECURITY_INFORMATION, NULL, NULL, &pAcl, NULL, &pSD);
#pragma warning(pop)

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	if(pAcl)
		*pDacl = *pAcl;
	::LocalFree(pSD);

	return NULL != pAcl;
}

inline bool AtlSetDacl(
	HANDLE hObject,
	SE_OBJECT_TYPE ObjectType,
	const CDacl &rDacl,
	DWORD dwInheritanceFlowControl /* = 0 */) throw(...)
{
	ATLASSERT(hObject);
	if(!hObject)
		return false;

	ATLASSERT(
		dwInheritanceFlowControl == 0 ||
		dwInheritanceFlowControl == PROTECTED_DACL_SECURITY_INFORMATION ||
		dwInheritanceFlowControl == UNPROTECTED_DACL_SECURITY_INFORMATION);

	DWORD dwErr = ::SetSecurityInfo(hObject, ObjectType,
		DACL_SECURITY_INFORMATION | dwInheritanceFlowControl,
		NULL, NULL, const_cast<ACL *>(rDacl.GetPACL()), NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetDacl(LPCTSTR pszObjectName, SE_OBJECT_TYPE ObjectType, CDacl *pDacl) throw(...)
{
	ATLASSERT(pszObjectName && pDacl);
	if(!pszObjectName || !pDacl)
		return false;

	ACL *pAcl;
	PSECURITY_DESCRIPTOR pSD;

#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,	DACL_SECURITY_INFORMATION, NULL, NULL, &pAcl, NULL, &pSD);
#pragma warning(pop)

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	if(pAcl)
		*pDacl = *pAcl;
	::LocalFree(pSD);

	return NULL != pAcl;
}

inline bool AtlSetDacl(
	LPCTSTR pszObjectName,
	SE_OBJECT_TYPE ObjectType,
	const CDacl &rDacl,
	DWORD dwInheritanceFlowControl /* = 0 */) throw(...)
{
	ATLASSERT(pszObjectName);
	if(!pszObjectName)
		return false;

	ATLASSERT(
		dwInheritanceFlowControl == 0 ||
		dwInheritanceFlowControl == PROTECTED_DACL_SECURITY_INFORMATION ||
		dwInheritanceFlowControl == UNPROTECTED_DACL_SECURITY_INFORMATION);

	DWORD dwErr = ::SetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,
		DACL_SECURITY_INFORMATION | dwInheritanceFlowControl,
		NULL, NULL, const_cast<ACL *>(rDacl.GetPACL()), NULL);

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetSacl(
	HANDLE hObject,
	SE_OBJECT_TYPE ObjectType,
	CSacl *pSacl,
	bool bRequestNeededPrivileges /* = true */) throw(...)
{
	ATLASSERT(hObject && pSacl);
	if(!hObject || !pSacl)
		return false;

	ACL *pAcl;
	PSECURITY_DESCRIPTOR pSD;
	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	if (bRequestNeededPrivileges)
	{
		if(!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
					false, false, SecurityImpersonation) ||
				!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
				!at.Impersonate())
			return false;
	}

#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetSecurityInfo(hObject, ObjectType, SACL_SECURITY_INFORMATION, NULL, NULL, NULL, &pAcl, &pSD);
#pragma warning(pop)

	if (bRequestNeededPrivileges)
	{
        if( !at.EnableDisablePrivileges(TokenPrivileges) )
			return false;
		if( !at.Revert() )
			return false;
	}

	if(dwErr != ERROR_SUCCESS)
	{
		::SetLastError(dwErr);
		return false;
	}

	if(pAcl)
		*pSacl = *pAcl;
	::LocalFree(pSD);

	return NULL != pAcl;
}

inline bool AtlSetSacl(
	HANDLE hObject,
	SE_OBJECT_TYPE ObjectType,
	const CSacl &rSacl,
	DWORD dwInheritanceFlowControl /* = 0 */,
	bool bRequestNeededPrivileges /* = true */) throw(...)
{
	ATLASSERT(hObject);
	if (!hObject)
		return false;

	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	ATLASSERT(
		dwInheritanceFlowControl == 0 ||
		dwInheritanceFlowControl == PROTECTED_SACL_SECURITY_INFORMATION ||
		dwInheritanceFlowControl == UNPROTECTED_SACL_SECURITY_INFORMATION);

	if (bRequestNeededPrivileges)
	{
		if(!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
					false, false, SecurityImpersonation) ||
				!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
				!at.Impersonate())
			return false;
	}

	DWORD dwErr = ::SetSecurityInfo(hObject, ObjectType,
		SACL_SECURITY_INFORMATION | dwInheritanceFlowControl,
		NULL, NULL, NULL, const_cast<ACL *>(rSacl.GetPACL()));

	if (bRequestNeededPrivileges)
	{
		if( !at.EnableDisablePrivileges(TokenPrivileges) )
			return false;
		if( !at.Revert() )
			return false;
	}

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

inline bool AtlGetSacl(
	LPCTSTR pszObjectName,
	SE_OBJECT_TYPE ObjectType,
	CSacl *pSacl,
	bool bRequestNeededPrivileges /* = true */) throw(...)
{
	ATLASSERT(pszObjectName && pSacl);
	if(!pszObjectName || !pSacl)
		return false;

	ACL *pAcl;
	PSECURITY_DESCRIPTOR pSD;
	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	if (bRequestNeededPrivileges)
	{
		if(!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
					false, false, SecurityImpersonation) ||
				!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
				!at.Impersonate())
			return false;
	}

#pragma warning(push)
#pragma warning(disable: 6309 6387)
	/* psdk prefast noise 498088 */
	DWORD dwErr = ::GetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,	SACL_SECURITY_INFORMATION, NULL, NULL, NULL, &pAcl, &pSD);
#pragma warning(pop)

	if (bRequestNeededPrivileges)
	{
		at.EnableDisablePrivileges(TokenPrivileges);
		at.Revert();
	}

	::SetLastError(dwErr);
	if(dwErr != ERROR_SUCCESS)
		return false;

	if(pAcl)
		*pSacl = *pAcl;
	::LocalFree(pSD);

	return NULL != pAcl;
}

inline bool AtlSetSacl(
	LPCTSTR pszObjectName,
	SE_OBJECT_TYPE ObjectType,
	const CSacl &rSacl,
	DWORD dwInheritanceFlowControl /* = 0 */,
	bool bRequestNeededPrivileges /* = true */) throw(...)
{
	ATLASSERT(pszObjectName);
	if (!pszObjectName)
		return false;

	CAccessToken at;
	CTokenPrivileges TokenPrivileges;

	ATLASSERT(
		dwInheritanceFlowControl == 0 ||
		dwInheritanceFlowControl == PROTECTED_SACL_SECURITY_INFORMATION ||
		dwInheritanceFlowControl == UNPROTECTED_SACL_SECURITY_INFORMATION);

	if(bRequestNeededPrivileges)
	{
		if (!at.OpenThreadToken(TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
					false, false, SecurityImpersonation) ||
				!at.EnablePrivilege(SE_SECURITY_NAME, &TokenPrivileges) ||
				!at.Impersonate())
			return false;
	}

	DWORD dwErr = ::SetNamedSecurityInfo(const_cast<LPTSTR>(pszObjectName), ObjectType,
		SACL_SECURITY_INFORMATION | dwInheritanceFlowControl,
		NULL, NULL, NULL, const_cast<ACL *>(rSacl.GetPACL()));

	if (bRequestNeededPrivileges)
	{
		at.EnableDisablePrivileges(TokenPrivileges);
		at.Revert();
	}

	::SetLastError(dwErr);
	return ERROR_SUCCESS == dwErr;
}

} // namespace ATL

#pragma warning(pop)

#endif // __ATLSECURITY_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlsharedsvc.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSHAREDSVC_H__
#define __ATLSHAREDSVC_H__

#pragma once

#ifdef _WIN32_WCE
	#error atlsharedsvc.h is not supported on Windows CE (_WIN32_WCE is defined)
#endif //_WIN32_WCE

#include <atltime.h>
#include <atlsoap.h>
#pragma pack(push,_ATL_PACKING)
namespace ATL{

#ifndef ATL_SHAREDBLOBCACHE_TIMEOUT
	#define ATL_SHAREDBLOBCACHE_TIMEOUT 36000000000 // in 100 nano second intervals
													 // each entry will be free'd if 
													// no access in 1 hour.
#endif

// Interface used by to access the shared blob cache.
[ uuid("AB4AF9CD-8DB1-4974-A617-CF0449578FB9"), object ]
__interface ISharedBlobCache
{
	[id(0)] STDMETHOD(AddItem)([in] BSTR szItemName, [in] BSTR szData);
	[id(1)] STDMETHOD(GetItem)([in] BSTR szItemName, [out,retval] BSTR *szData); 
};

class CSharedCache: 
	public CBlobCache<CWorkerThread<>, CStdStatClass >,
	public IMemoryCacheClient,
	public ISharedBlobCache
{
	typedef CBlobCache<CWorkerThread<>, CStdStatClass > basecache;
public:

	// IMemoryCacheClient method, frees data in the memory cache.
	STDMETHOD( Free )(const void *pvData)
	{
		if (pvData)
		{
			::SysFreeString((BSTR)pvData);
		}
		return S_OK;
	}


	STDMETHODIMP AddItem(BSTR szItemName, BSTR szData)
	{

		HRESULT hr = E_UNEXPECTED;

		// We make a copy of the BSTR and stick it in the cache.
		// The BSTR will be freed in our IMemoryCacheClient::Free
		// implementation above.
		BSTR szEntry = SysAllocString(szData);
		if(szEntry)
		{
			USES_CONVERSION_EX;
			// create a time span and for the entry
			CFileTime tm = CFileTime::GetCurrentTime();
			CFileTimeSpan span;
			span.SetTimeSpan(ATL_SHAREDBLOBCACHE_TIMEOUT);
			tm += span;
			HCACHEITEM h;
			hr = basecache::Add(OLE2A_EX(szItemName, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), szEntry, sizeof(BSTR), 
				&tm, _AtlBaseModule.m_hInst, &h, static_cast<IMemoryCacheClient*>(this));

			if (hr == S_OK)
			{
				// On successful add, we have to release our 
				// reference on the entry.
				basecache::ReleaseEntry(h);
			}
		}
		return hr;
	}

	STDMETHODIMP GetItem(BSTR szItemName, BSTR *szData)
	{
		USES_CONVERSION_EX;
		HRESULT hr = E_UNEXPECTED;
		HCACHEITEM hEntry = NULL;

		if (!szItemName || !szData)
			return hr;

		hr = basecache::LookupEntry(OLE2A_EX(szItemName, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), &hEntry);
		if (hr == S_OK)
		{
			void *pData = NULL;
			DWORD dwSize = 0;
			hr = basecache::GetData(hEntry, &pData, &dwSize);
			if (hr == S_OK)
			{
				// make a copy of the string
				*szData = ::SysAllocString((BSTR)pData);
			}
			basecache::ReleaseEntry(hEntry);
		}
		return hr;
	}


	STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
	{
		HRESULT hr = E_NOINTERFACE;
		if (InlineIsEqualGUID(__uuidof(IMemoryCacheClient), riid)||
			InlineIsEqualGUID(__uuidof(IUnknown), riid))
		{
			*ppv = static_cast<void*>(static_cast<IMemoryCacheClient*>(this));
			hr = S_OK;
		}
		else if( InlineIsEqualGUID(__uuidof(ISharedBlobCache), riid))
		{
			*ppv = static_cast<void*>(static_cast<ISharedBlobCache*>(this));
			hr = S_OK;
		}
		return hr;
	}
	ULONG STDMETHODCALLTYPE AddRef()
	{
		return 1;
	}
	ULONG STDMETHODCALLTYPE Release()
	{
		return 1;
	}
};


// This class implements the SOAP interface for the shared blob cache.
[
	soap_handler(
					name="SharedBlobCache", 
					namespace="http://www.microsoft.com/vc/atlserver/soap/SharedBlobCache",
					protocol="soap"
				),
	request_handler(
					name="SharedBlobCache",
					sdl="GenSharedBlobCacheWSDL"
					)
]
class CSharedCacheHandler:
	public ISharedBlobCache
{
public:
	[soap_method]
	STDMETHOD(AddItem)(BSTR szItemName, BSTR szData)
	{
		if (!m_spMemCache)
			return E_UNEXPECTED;
		return m_spMemCache->AddItem(szItemName, szData);
	}

	[soap_method]
	STDMETHOD(GetItem)(BSTR szItemName, BSTR *szData)
	{	
		if (!m_spMemCache)
			return E_UNEXPECTED;
		return m_spMemCache->GetItem(szItemName, szData);
	}

	HTTP_CODE Initialize(IServiceProvider *pProvider)
	{
		ATLASSERT(pProvider); // should never be NULL
		if (!pProvider)
			return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

		if (m_spMemCache)
			return HTTP_SUCCESS; // already initialized

		pProvider->QueryService(__uuidof(ISharedBlobCache), &m_spMemCache);
		return m_spMemCache ? HTTP_SUCCESS : HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);
	}

	// override HandleRequest to Initialize our m_spServiceProvider
	// and to handle authorizing the client.
	HTTP_CODE HandleRequest(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider)
	{
		HTTP_CODE dwErr = Initialize(pProvider);
		if (dwErr != HTTP_SUCCESS)
			return dwErr;

		dwErr = CSoapHandler<CSharedCacheHandler>::HandleRequest(pRequestInfo,
								pProvider);
		return dwErr;
	}
	CComPtr<ISharedBlobCache> m_spMemCache;
};

} //ATL

#pragma pack(pop)

#endif // __ATLSHAREDSVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\atl8\Include\atlsession.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSESSION_H__
#define __ATLSESSION_H__

#pragma once

#ifdef _WIN32_WCE
	#error atlsession.h is not supported on Windows CE (_WIN32_WCE is defined)
#endif //_WIN32_WCE

#pragma warning(push)
#pragma warning(disable: 4702) // unreachable code

#include <atldbcli.h>
#include <atlcom.h>
#include <atlstr.h>
#include <stdio.h>
#include <atlcoll.h>
#include <atltime.h>
#include <atlcrypt.h>
#include <atlenc.h>
#include <atlutil.h>
#include <atlcache.h>
#include <atlspriv.h>
#include <atlsiface.h>

#pragma warning(disable: 4625) // copy constructor could not be generated because a base class copy constructor is inaccessible
#pragma warning(disable: 4626) // assignment operator could not be generated because a base class assignment operator is inaccessible

#ifndef MAX_SESSION_KEY_LEN 
	#define MAX_SESSION_KEY_LEN 128
#endif

#ifndef MAX_VARIABLE_NAME_LENGTH 
	#define MAX_VARIABLE_NAME_LENGTH 50
#endif

#ifndef MAX_VARIABLE_VALUE_LENGTH 
	#define MAX_VARIABLE_VALUE_LENGTH 1024
#endif

#ifndef MAX_CONNECTION_STRING_LEN
	#define MAX_CONNECTION_STRING_LEN 2048
#endif

#ifndef SESSION_COOKIE_NAME
	#define SESSION_COOKIE_NAME "SESSIONID"
#endif

#ifndef ATL_SESSION_TIMEOUT
	#define ATL_SESSION_TIMEOUT 600000 //10 min
#endif

#ifndef ATL_SESSION_SWEEPER_TIMEOUT
	#define ATL_SESSION_SWEEPER_TIMEOUT 1000 // 1sec
#endif

#define INVALID_DB_SESSION_POS 0x0
#define ATL_DBSESSION_ID _T("__ATL_SESSION_DB_CONNECTION")

#pragma pack(push,_ATL_PACKING)
namespace ATL {

// CSessionNameGenerator
// This is a helper class that generates random data for session key
// names. This class tries to use the CryptoApi to generate random
// bytes for the session key name. If the CryptoApi isn't available
// then the CRT rand() is used to generate the random bytes. This
// class's GetNewSessionName member function is used to actually
// generate the session name.
class CSessionNameGenerator :
	public CCryptProv
{
public:
	bool m_bCryptNotAvailable;
	enum {MIN_SESSION_KEY_LEN=5};

	CSessionNameGenerator() throw() :
		m_bCryptNotAvailable(false)
	{
		// Note that the crypto api is being
		// initialized with no private key
		// information
		HRESULT hr = InitVerifyContext();
		m_bCryptNotAvailable = FAILED(hr) ? true : false;
	}

	// This function creates a new session name and base64 encodes it.
	// The base64 encoding algorithm used needs at least MIN_SESSION_KEY_LEN
	// bytes to work correctly. Since we stack allocate the temporary
	// buffer that holds the key name, the buffer must be less than or equal to
	// the MAX_SESSION_KEY_LEN in size.
	HRESULT GetNewSessionName(__out_ecount_part_z(*pdwSize, *pdwSize) LPSTR szNewID, __inout DWORD *pdwSize) throw()
	{
		HRESULT hr = E_FAIL;

		if (!pdwSize)
			return E_POINTER;

		if (*pdwSize < MIN_SESSION_KEY_LEN ||
			*pdwSize > MAX_SESSION_KEY_LEN)
			return E_INVALIDARG;

		if (!szNewID)
			return E_POINTER;

		BYTE key[MAX_SESSION_KEY_LEN] = {0x0};


		// calculate the number of bytes that will fit in the
		// buffer we've been passed
		DWORD dwDataSize = CalcMaxInputSize(*pdwSize);

		if (dwDataSize && *pdwSize >= (DWORD)(Base64EncodeGetRequiredLength(dwDataSize,
			ATL_BASE64_FLAG_NOCRLF)))
		{
			int dwKeySize = *pdwSize;
			hr = GenerateRandomName(key, dwDataSize);
			if (SUCCEEDED(hr))
			{
				if( Base64Encode(key,
								dwDataSize,
								szNewID,
								&dwKeySize,
								ATL_BASE64_FLAG_NOCRLF) )
				{
					//null terminate
					szNewID[dwKeySize]=0;
					*pdwSize = dwKeySize+1;
				}
				else
					hr = E_FAIL;
			}
			else
			{
				*pdwSize = (DWORD)(Base64EncodeGetRequiredLength(dwDataSize,
					ATL_BASE64_FLAG_NOCRLF));
				return E_OUTOFMEMORY;
			}
		}
		return hr;
	}

	DWORD CalcMaxInputSize(DWORD nOutputSize) throw()
	{
		if (nOutputSize < (DWORD)MIN_SESSION_KEY_LEN)
			return 0;
		// subtract one from the output size to make room
		// for the NULL terminator in the output then
		// calculate the biggest number of input bytes that
		// when base64 encoded will fit in a buffer of size
		// nOutputSize (including base64 padding)
		int nInputSize = ((nOutputSize-1)*3)/4;
		int factor = ((nInputSize*4)/3)%4;
		if (factor)
			nInputSize -= factor;
		return nInputSize;
	}


	HRESULT GenerateRandomName(BYTE *pBuff, DWORD dwBuffSize) throw()
	{
		if (!pBuff)
			return E_POINTER;

		if (!dwBuffSize)
			return E_UNEXPECTED;

		if (!m_bCryptNotAvailable && GetHandle())
		{
			// Use the crypto api to generate random data.
			return GenRandom(dwBuffSize, pBuff);
		}

		// CryptoApi isn't available so we generate
		// random data using rand. We seed the random
		// number generator with a seed that is a combination
		// of bytes from an arbitrary number and the system
		// time which changes every millisecond so it will
		// be different for every call to this function.
		FILETIME ft;
		GetSystemTimeAsFileTime(&ft);
		static DWORD dwVal = 0x21;
		DWORD dwSeed = (dwVal++ << 0x18) | (ft.dwLowDateTime & 0x00ffff00) | dwVal++ & 0x000000ff;
		srand(dwSeed);
		BYTE *pCurr = pBuff;
		// fill buffer with random bytes
		for (int i=0; i < (int)dwBuffSize; i++)
		{
			*pCurr = (BYTE) (rand() & 0x000000ff);
			pCurr++;
		}
		return S_OK;
	}
};


//
// CDefaultQueryClass
// returns Query strings for use in SQL queries used 
// by the database persisted session service.
class CDefaultQueryClass
{
public:
	LPCTSTR GetSessionRefDelete() throw()
	{
		return 	_T("DELETE FROM SessionReferences ")
				_T("WHERE SessionID=? AND RefCount <= 0 ")
				_T("AND DATEDIFF(millisecond,  LastAccess, getdate()) > TimeoutMs");
	}

	LPCTSTR GetSessionRefIsExpired() throw()
	{
		return _T("SELECT SessionID FROM SessionReferences ")
			   _T("WHERE (SessionID=?) AND (DATEDIFF(millisecond,  LastAccess, getdate()) > TimeoutMs)");
	}

	LPCTSTR GetSessionRefDeleteFinal() throw()
	{
		return _T("DELETE FROM SessionReferences ")
			   _T("WHERE SessionID=?");
	}

	LPCTSTR GetSessionRefCreate() throw()
	{
		return _T("INSERT INTO SessionReferences ")
			_T("(SessionID, LastAccess, RefCount, TimeoutMs) ")
			_T("VALUES (?, getdate(), 1, ?)");
	}

	LPCTSTR GetSessionRefUpdateTimeout() throw()
	{
		return _T("UPDATE SessionReferences ")
			   _T("SET TimeoutMs=? WHERE SessionID=?");
	}

	LPCTSTR GetSessionRefAddRef() throw()
	{
		return _T("UPDATE SessionReferences ")
			_T("SET RefCount=RefCount+1, ")
			_T("LastAccess=getdate() ")
			_T("WHERE SessionID=?");
	}

	LPCTSTR GetSessionRefRemoveRef() throw()
	{
		return _T("UPDATE SessionReferences ")
					_T("SET RefCount=RefCount-1, ")
					_T("LastAccess=getdate() ")
					_T("WHERE SessionID=?");
	}

	LPCTSTR GetSessionRefAccess() throw()
	{
		return 	_T("UPDATE SessionReferences ")
				_T("SET LastAccess=getdate() ")
				_T("WHERE SessionID=?");
	}

	LPCTSTR GetSessionRefSelect() throw()
	{
		return _T("SELECT * FROM SessionReferences ")
			   _T("WHERE SessionID=?");
	}

	LPCTSTR GetSessionRefGetCount() throw()
	{
		return 	_T("SELECT COUNT(*) FROM SessionReferences");
	}


	LPCTSTR GetSessionVarCount() throw()
	{
		return _T("SELECT COUNT(*) FROM SessionVariables WHERE SessionID=?");
	}

	LPCTSTR GetSessionVarInsert() throw()
	{
		return  _T("INSERT INTO SessionVariables ")
				_T("(VariableValue, SessionID, VariableName) ")
				_T("VALUES (?, ?, ?)");
	}

	LPCTSTR GetSessionVarUpdate() throw()
	{
		return 	_T("UPDATE SessionVariables ")
				_T("SET VariableValue=? ")
				_T("WHERE SessionID=? AND VariableName=?");
	}

	LPCTSTR GetSessionVarDeleteVar() throw()
	{
		return _T("DELETE FROM SessionVariables ")
				_T("WHERE SessionID=? AND VariableName=?");
	}

	LPCTSTR GetSessionVarDeleteAllVars() throw()
	{
		return _T("DELETE FROM SessionVariables WHERE (SessionID=?)");
	}

	LPCTSTR GetSessionVarSelectVar()throw()
	{
		return _T("SELECT SessionID, VariableName, VariableValue ")
			   _T("FROM SessionVariables ")
			   _T("WHERE SessionID=? AND VariableName=?");
	}

	LPCTSTR GetSessionVarSelectAllVars() throw()
	{
		return _T("SELECT SessionID, VariableName, VariableValue ")
				_T("FROM SessionVariables ")
				_T("WHERE SessionID=?");
	}

	LPCTSTR GetSessionReferencesSet() throw()
	{
		return _T("UPDATE SessionReferences SET TimeoutMs=?");
	}
};


// Contains the data for the session variable accessors
class CSessionDataBase
{
public:
	TCHAR m_szSessionID[MAX_SESSION_KEY_LEN];
	TCHAR m_VariableName[MAX_VARIABLE_NAME_LENGTH];
	BYTE m_VariableValue[MAX_VARIABLE_VALUE_LENGTH];
	DBLENGTH m_VariableLen;
	CSessionDataBase() throw()
	{
		m_szSessionID[0] = '\0';
		m_VariableName[0] = '\0';
		m_VariableValue[0] = '\0';
		m_VariableLen = 0;
	}
	HRESULT Assign(LPCTSTR szSessionID, LPCTSTR szVarName, VARIANT *pVal) throw()
	{
		HRESULT hr = S_OK;
		CVariantStream stream;
		if ( szSessionID )
		{
			if (Checked::tcsnlen(szSessionID, MAX_SESSION_KEY_LEN)< MAX_SESSION_KEY_LEN)
				Checked::tcscpy_s(m_szSessionID, _countof(m_szSessionID), szSessionID);
			else
				hr = E_OUTOFMEMORY;
		}
		else
			return E_INVALIDARG;

		if (hr == S_OK && szVarName)
			if (Checked::tcsnlen(szVarName, MAX_VARIABLE_NAME_LENGTH) < MAX_VARIABLE_NAME_LENGTH)
				Checked::tcscpy_s(m_VariableName, _countof(m_VariableName), szVarName);
			else
				hr = E_OUTOFMEMORY;

		if (hr == S_OK && pVal)
		{
			hr = stream.InsertVariant(pVal);
			if (hr == S_OK)
			{
				BYTE *pBytes = stream.m_stream;
				size_t size = stream.GetVariantSize();
				if (pBytes && size && size < MAX_VARIABLE_VALUE_LENGTH)
				{
					Checked::memcpy_s(m_VariableValue, MAX_VARIABLE_VALUE_LENGTH, pBytes, size);
					m_VariableLen = static_cast<DBLENGTH>(size);
				}
				else
					hr = E_INVALIDARG;
			}
		}

		return hr;
	}
};

// Use to select a session variable given the name
// of a session and the name of a variable.
class CSessionDataSelector : public CSessionDataBase
{
public:
	BEGIN_COLUMN_MAP(CSessionDataSelector) 
		COLUMN_ENTRY(1, m_szSessionID)
		COLUMN_ENTRY(2, m_VariableName)
		COLUMN_ENTRY_LENGTH(3, m_VariableValue, m_VariableLen)
	END_COLUMN_MAP()
	BEGIN_PARAM_MAP(CSessionDataSelector) 
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_szSessionID)
		COLUMN_ENTRY(2, m_VariableName)
	END_PARAM_MAP()
};

// Use to select all session variables given the name of
// of a session.
class CAllSessionDataSelector : public CSessionDataBase
{
public:
	BEGIN_COLUMN_MAP(CAllSessionDataSelector) 
		COLUMN_ENTRY(1, m_szSessionID)
		COLUMN_ENTRY(2, m_VariableName)
		COLUMN_ENTRY_LENGTH(3, m_VariableValue, m_VariableLen)
	END_COLUMN_MAP()
	BEGIN_PARAM_MAP(CAllSessionDataSelector) 
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_szSessionID)
	END_PARAM_MAP()
};

// Use to update the value of a session variable
class CSessionDataUpdator : public CSessionDataBase
{
public:
	BEGIN_PARAM_MAP(CSessionDataUpdator) 
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY_LENGTH(1, m_VariableValue, m_VariableLen)
		COLUMN_ENTRY(2, m_szSessionID)
		COLUMN_ENTRY(3, m_VariableName)
	END_PARAM_MAP()
};

// Use to delete a session variable given the
// session name and the name of the variable
class CSessionDataDeletor
{
public:
	CSessionDataDeletor()
	{
		m_szSessionID[0] = '\0';
		m_VariableName[0] = '\0';
	}

	TCHAR m_szSessionID[MAX_SESSION_KEY_LEN];
	TCHAR m_VariableName[MAX_VARIABLE_NAME_LENGTH];
	HRESULT Assign(LPCTSTR szSessionID, LPCTSTR szVarName) throw()
	{
		if (szSessionID)
		{
			if (Checked::tcsnlen(szSessionID, MAX_SESSION_KEY_LEN) < MAX_SESSION_KEY_LEN)
				Checked::tcscpy_s(m_szSessionID, _countof(m_szSessionID), szSessionID);
			else
				return E_OUTOFMEMORY;
		}

		if (szVarName)
		{
			if(Checked::tcsnlen(szVarName, MAX_VARIABLE_NAME_LENGTH) < MAX_VARIABLE_NAME_LENGTH)
				Checked::tcscpy_s(m_VariableName, _countof(m_VariableName), szVarName);
			else
				return E_OUTOFMEMORY;
		}
		return S_OK;
	}

	BEGIN_PARAM_MAP(CSessionDataDeletor) 
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_szSessionID)
		COLUMN_ENTRY(2, m_VariableName)
	END_PARAM_MAP()
};

class CSessionDataDeleteAll
{
public:
	TCHAR m_szSessionID[MAX_SESSION_KEY_LEN];
	HRESULT Assign(LPCTSTR szSessionID) throw()
	{
		if (!szSessionID)
			return E_INVALIDARG;

		if (Checked::tcsnlen(szSessionID, MAX_SESSION_KEY_LEN) < MAX_SESSION_KEY_LEN)
			Checked::tcscpy_s(m_szSessionID, _countof(m_szSessionID), szSessionID);
		else
			return E_OUTOFMEMORY;

		return S_OK;
	}

	BEGIN_PARAM_MAP(CSessionDataDeleteAll) 
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_szSessionID)
	END_PARAM_MAP()
};

// Used for retrieving the count of session variables for
// a given session ID.
class CCountAccessor
{
public:
	LONG m_nCount;
	TCHAR m_szSessionID[MAX_SESSION_KEY_LEN];
	CCountAccessor() throw()
	{
		m_szSessionID[0] = '\0';
		m_nCount = 0;
	}

	HRESULT Assign(LPCTSTR szSessionID) throw()
	{
		if (!szSessionID)
			return E_INVALIDARG;

		if (Checked::tcsnlen(szSessionID, MAX_SESSION_KEY_LEN) < MAX_SESSION_KEY_LEN)
			Checked::tcscpy_s(m_szSessionID, _countof(m_szSessionID), szSessionID);
		else
			return E_OUTOFMEMORY;

		return S_OK;
	}

	BEGIN_COLUMN_MAP(CCountAccessor)
		COLUMN_ENTRY(1, m_nCount)
	END_COLUMN_MAP()
	BEGIN_PARAM_MAP(CCountAccessor)
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_szSessionID)
	END_PARAM_MAP()
};


// Used for updating entries in the session
// references table, given a session ID
class CSessionRefUpdator
{
public:
	TCHAR m_SessionID[MAX_SESSION_KEY_LEN];
	HRESULT Assign(LPCTSTR szSessionID) throw()
	{
		if (!szSessionID)
			return E_INVALIDARG;
		if (Checked::tcsnlen(szSessionID, MAX_SESSION_KEY_LEN) < MAX_SESSION_KEY_LEN)
			Checked::tcscpy_s(m_SessionID, _countof(m_SessionID), szSessionID);
		else
			return E_OUTOFMEMORY;
		return S_OK;
	}
	BEGIN_PARAM_MAP(CSessionRefUpdator)
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_SessionID)
	END_PARAM_MAP()
};

class CSessionRefIsExpired
{
public:
	TCHAR m_SessionID[MAX_SESSION_KEY_LEN];
	TCHAR m_SessionIDOut[MAX_SESSION_KEY_LEN];
	HRESULT Assign(LPCTSTR szSessionID) throw()
	{
		m_SessionIDOut[0]=0;
		if (!szSessionID)
			return E_INVALIDARG;
		if (Checked::tcsnlen(szSessionID, MAX_SESSION_KEY_LEN) < MAX_SESSION_KEY_LEN)
			Checked::tcscpy_s(m_SessionID, _countof(m_SessionID), szSessionID);
		else
			return E_OUTOFMEMORY;
		return S_OK;
	}
	BEGIN_COLUMN_MAP(CSessionRefIsExpired)
		COLUMN_ENTRY(1, m_SessionIDOut)
	END_COLUMN_MAP()
	BEGIN_PARAM_MAP(CSessionRefIsExpired)
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_SessionID)
	END_PARAM_MAP()
};

class CSetAllTimeouts
{
public:
	unsigned __int64 m_dwNewTimeout;
	HRESULT Assign(unsigned __int64 dwNewValue)
	{
		m_dwNewTimeout = dwNewValue;
		return S_OK;
	}
	BEGIN_PARAM_MAP(CSetAllTimeouts)
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_dwNewTimeout)
	END_PARAM_MAP()
};

class CSessionRefUpdateTimeout
{
public:
	TCHAR m_SessionID[MAX_SESSION_KEY_LEN];
	unsigned __int64 m_nNewTimeout;
	HRESULT Assign(LPCTSTR szSessionID, unsigned __int64 nNewTimeout) throw()
	{
		if (!szSessionID)
			return E_INVALIDARG;

		if (Checked::tcsnlen(szSessionID, MAX_SESSION_KEY_LEN) < MAX_SESSION_KEY_LEN)
			Checked::tcscpy_s(m_SessionID, _countof(m_SessionID), szSessionID);
		else
			return E_OUTOFMEMORY;

		m_nNewTimeout = nNewTimeout;

		return S_OK;
	}

	BEGIN_PARAM_MAP(CSessionRefUpdateTimeout)
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_nNewTimeout)
		COLUMN_ENTRY(2, m_SessionID)
	END_PARAM_MAP()
};

class CSessionRefSelector
{
public:
	TCHAR m_SessionID[MAX_SESSION_KEY_LEN];
	int m_RefCount;
	HRESULT Assign(LPCTSTR szSessionID) throw()
	{
		if (!szSessionID)
			return E_INVALIDARG;
		if (Checked::tcsnlen(szSessionID, MAX_SESSION_KEY_LEN) < MAX_SESSION_KEY_LEN)
			Checked::tcscpy_s(m_SessionID, _countof(m_SessionID), szSessionID);
		else
			return E_OUTOFMEMORY;
		return S_OK;
	}
	BEGIN_COLUMN_MAP(CSessionRefSelector)
		COLUMN_ENTRY(1, m_SessionID)
		COLUMN_ENTRY(3, m_RefCount)
	END_COLUMN_MAP()
	BEGIN_PARAM_MAP(CSessionRefSelector)
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_SessionID)
	END_PARAM_MAP()
};

class CSessionRefCount
{
public:
	LONG m_nCount;
	BEGIN_COLUMN_MAP(CSessionRefCount)
		COLUMN_ENTRY(1, m_nCount)
	END_COLUMN_MAP()
};

// Used for creating new entries in the session
// references table.
class CSessionRefCreator
{
public:
	TCHAR m_SessionID[MAX_SESSION_KEY_LEN];
	unsigned __int64 m_TimeoutMs;
	HRESULT Assign(LPCTSTR szSessionID, unsigned __int64 timeout) throw()
	{
		if (!szSessionID)
			return E_INVALIDARG;
		if (Checked::tcsnlen(szSessionID, MAX_SESSION_KEY_LEN) < MAX_SESSION_KEY_LEN)
		{
			Checked::tcscpy_s(m_SessionID, _countof(m_SessionID), szSessionID);
			m_TimeoutMs = timeout;
		}
		else
			return E_OUTOFMEMORY;
		return S_OK;
	}
	BEGIN_PARAM_MAP(CSessionRefCreator)
		SET_PARAM_TYPE(DBPARAMIO_INPUT)
		COLUMN_ENTRY(1, m_SessionID)
		COLUMN_ENTRY(2, m_TimeoutMs)
	END_PARAM_MAP()
};


// CDBSession
// This session persistance class persists session variables to
// an OLEDB datasource. The following table gives a general description
// of the table schema for the tables this class uses.
//
// TableName: SessionVariables
// Column		Name			Type							Description
// 1			SessionID		char[MAX_SESSION_KEY_LEN]		Session Key name
// 2			VariableName	char[MAX_VARIABLE_NAME_LENGTH]	Variable Name
// 3			VariableValue	varbinary[MAX_VARIABLE_VALUE_LENGTH]	Variable Value

//
// TableName: SessionReferences
// Column		Name			Type							Description
// 1			SessionID		char[MAX_SESSION_KEY_LEN]		Session Key Name.
// 2			LastAccess		datetime						Date and time of last access to this session.
// 3			RefCount		int								Current references on this session.
// 4			TimeoutMS		int								Timeout value for the session in milli seconds

typedef bool (*PFN_GETPROVIDERINFO)(DWORD_PTR, wchar_t **);

template <class QueryClass=CDefaultQueryClass>
class CDBSession:
	public ISession,
	public CComObjectRootEx<CComGlobalsThreadModel>

{
	typedef CCommand<CAccessor<CAllSessionDataSelector> >  iterator_accessor;
public:
	typedef QueryClass DBQUERYCLASS_TYPE;
	BEGIN_COM_MAP(CDBSession)
		COM_INTERFACE_ENTRY(ISession)
	END_COM_MAP()

	CDBSession() throw():
		m_dwTimeout(ATL_SESSION_TIMEOUT)
	{
		m_szSessionName[0] = '\0';
	}

	~CDBSession() throw()
	{
	}

	void FinalRelease()throw()
	{
		SessionUnlock();
	}

	STDMETHOD(SetVariable)(LPCSTR szName, VARIANT Val) throw()
	{
		HRESULT hr = E_FAIL;
		if (!szName)
			return E_INVALIDARG;

		// Get the data connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// Update the last access time for this session
		hr = Access();
		if (hr != S_OK)
			return hr;

		// Allocate an updator command and fill out it's input parameters.
		CCommand<CAccessor<CSessionDataUpdator> > command;
		_ATLTRY
		{
			CA2CT name(szName);
			hr = command.Assign(m_szSessionName, name, &Val);
		}
		_ATLCATCHALL()
		{
			hr = E_OUTOFMEMORY;
		}
		if (hr != S_OK)
			return hr;

		// Try an update. Update will fail if the variable is not already there.
		DBROWCOUNT nRows = 0;

		hr = command.Open(dataconn, 
						m_QueryObj.GetSessionVarUpdate(),
						NULL, &nRows, DBGUID_DEFAULT, false);
		if (hr == S_OK && nRows <= 0)
			hr = E_UNEXPECTED;
		if (hr != S_OK)
		{
			// Try an insert
			hr = command.Open(dataconn, m_QueryObj.GetSessionVarInsert(), NULL, &nRows, DBGUID_DEFAULT, false);
			if (hr == S_OK && nRows <=0)
				hr = E_UNEXPECTED;
		}

		return hr;
	}

	// Warning: For string data types, depending on the configuration of
	// your database, strings might be returned with trailing white space.
	STDMETHOD(GetVariable)(LPCSTR szName, VARIANT *pVal) throw()
	{
		HRESULT hr = E_FAIL;
		if (!szName)
			return E_INVALIDARG;
		if (pVal)
			VariantInit(pVal);
		else
			return E_POINTER;

		// Get the data connection for this thread
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// Update the last access time for this session
		hr = Access();
		if (hr != S_OK)
			return hr;

		// Allocate a command a fill out it's input parameters.
		CCommand<CAccessor<CSessionDataSelector> > command;
		_ATLTRY
		{
			CA2CT name(szName);
			hr = command.Assign(m_szSessionName, name, NULL);
		}
		_ATLCATCHALL()
		{
			hr = E_OUTOFMEMORY;
		}

		if (hr == S_OK)
		{
			hr = command.Open(dataconn, m_QueryObj.GetSessionVarSelectVar());
			if (SUCCEEDED(hr))
			{
				if ( S_OK == (hr = command.MoveFirst()))
				{
					CStreamOnByteArray stream(command.m_VariableValue);
					CComVariant vOut;
					hr = vOut.ReadFromStream(static_cast<IStream*>(&stream));
					if (hr == S_OK)
						hr = vOut.Detach(pVal);
				}
			}
		}
		return hr;
	}

	STDMETHOD(RemoveVariable)(LPCSTR szName) throw()
	{
		HRESULT hr = E_FAIL;
		if (!szName)
			return E_INVALIDARG;

		// Get the data connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// update the last access time for this session
		hr = Access();
		if (hr != S_OK)
			return hr;

		// allocate a command and set it's input parameters
		CCommand<CAccessor<CSessionDataDeletor> > command;
		_ATLTRY
		{
			CA2CT name(szName);
			hr = command.Assign(m_szSessionName, name);
		}
		_ATLCATCHALL()
		{
			return E_OUTOFMEMORY;
		}

		// execute the command
		DBROWCOUNT nRows = 0;
		if (hr == S_OK)
			hr = command.Open(dataconn, m_QueryObj.GetSessionVarDeleteVar(),
			NULL, &nRows, DBGUID_DEFAULT, false);
		if (hr == S_OK && nRows <= 0)
			hr = E_FAIL;
		return hr;
	}

	// Gives the count of rows in the table for this session ID.
	STDMETHOD(GetCount)(long *pnCount) throw()
	{
		HRESULT hr = S_OK;
		if (pnCount)
			*pnCount = 0;
		else
			return E_POINTER;

		// Get the database connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;
		hr = Access();
		if (hr != S_OK)
			return hr;
		CCommand<CAccessor<CCountAccessor> > command;

		hr = command.Assign(m_szSessionName);
		if (hr == S_OK)
		{
			hr = command.Open(dataconn, m_QueryObj.GetSessionVarCount());
			if (hr == S_OK)
			{
				if (S_OK == (hr = command.MoveFirst()))
				{
					*pnCount = command.m_nCount;
					hr = S_OK;
				}
			}
		}
		return hr;
	}

	STDMETHOD(RemoveAllVariables)() throw()
	{
		HRESULT hr = E_UNEXPECTED;

		// Get the data connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		CCommand<CAccessor<CSessionDataDeleteAll> > command;
		hr = command.Assign(m_szSessionName);
		if (hr != S_OK)
			return hr;

		// delete all session variables
		hr = command.Open(dataconn, m_QueryObj.GetSessionVarDeleteAllVars(), NULL, NULL, DBGUID_DEFAULT, false);
		return hr;
	}

	// Iteration of variables works by taking a snapshot
	// of the sessions at the point in time BeginVariableEnum
	// is called, and then keeping an index variable that you use to
	// move through the snapshot rowset. It is important to know
	// that the handle returned in phEnum is not thread safe. It
	// should only be used by the calling thread.
	STDMETHOD(BeginVariableEnum)(POSITION *pPOS, HSESSIONENUM *phEnum) throw()
	{
		HRESULT hr = E_FAIL;
		if (!pPOS)
			return E_POINTER;

		if (phEnum)
			*phEnum = NULL;
		else
			return E_POINTER;

		// Get the data connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// Update the last access time for this session.
		hr = Access();
		if (hr != S_OK)
			return hr;

		// Allocate a new iterator accessor and initialize it's input parameters.
		iterator_accessor *pIteratorAccessor = NULL;
		ATLTRYALLOC(pIteratorAccessor = new iterator_accessor);
		if (!pIteratorAccessor)
			return E_OUTOFMEMORY;

		hr = pIteratorAccessor->Assign(m_szSessionName, NULL, NULL);
		if (hr == S_OK)
		{
			// execute the command and move to the first row of the recordset.
			hr = pIteratorAccessor->Open(dataconn, 
								m_QueryObj.GetSessionVarSelectAllVars());
			if (hr == S_OK)
			{
				hr = pIteratorAccessor->MoveFirst();
				if (hr == S_OK)
				{
					*pPOS = (POSITION) INVALID_DB_SESSION_POS + 1;
					*phEnum = reinterpret_cast<HSESSIONENUM>(pIteratorAccessor);
				}
			}

			if (hr != S_OK)
			{
				*pPOS = INVALID_DB_SESSION_POS;
				*phEnum = NULL;
				delete pIteratorAccessor;
			}
		}
		return hr;
	}

	// The values for hEnum and pPos must have been initialized in a previous
	// call to BeginVariableEnum. On success, the out variant will hold the next
	// variable
	STDMETHOD(GetNextVariable)(POSITION *pPOS, VARIANT *pVal, HSESSIONENUM hEnum, LPSTR szName=NULL, DWORD dwLen=0) throw()
	{
		if (!pPOS)
			return E_INVALIDARG;

		if (pVal)
			VariantInit(pVal);
		else
			return E_POINTER;

		if (!hEnum)
			return E_UNEXPECTED;

		if (*pPOS <= INVALID_DB_SESSION_POS)
			return E_UNEXPECTED;

		iterator_accessor *pIteratorAccessor = reinterpret_cast<iterator_accessor*>(hEnum);

		// update the last access time.
		HRESULT hr = Access();

		POSITION posCurrent = *pPOS;

		if (szName)
		{
			// caller wants entry name
			_ATLTRY
			{
				CT2CA szVarName(pIteratorAccessor->m_VariableName);
				if (szVarName != NULL && dwLen > Checked::strnlen(szVarName, dwLen))
				{
					Checked::strcpy_s(szName, dwLen, szVarName);
				}
				else
					hr = E_OUTOFMEMORY; // buffer not big enough
			}				
			_ATLCATCHALL()
			{
				hr = E_OUTOFMEMORY;
			}
				
		}

		if (hr == S_OK)
		{
			CStreamOnByteArray stream(pIteratorAccessor->m_VariableValue);
			CComVariant vOut;
			hr = vOut.ReadFromStream(static_cast<IStream*>(&stream));
			if (hr == S_OK)
				vOut.Detach(pVal);
			else
				return hr;
		}
		else
			return hr;

		hr = pIteratorAccessor->MoveNext();
		*pPOS = ++posCurrent;

		if (hr == DB_S_ENDOFROWSET)
		{
			// We're done iterating, reset everything
			*pPOS = INVALID_DB_SESSION_POS;
			hr = S_OK;
		}

		if (hr != S_OK)
		{
			VariantClear(pVal);
		}
		return hr;
	}

	// CloseEnum frees up any resources allocated by the iterator
	STDMETHOD(CloseEnum)(HSESSIONENUM hEnum) throw()
	{
		iterator_accessor *pIteratorAccessor = reinterpret_cast<iterator_accessor*>(hEnum);
		if (!pIteratorAccessor)
			return E_INVALIDARG;
		pIteratorAccessor->Close();
		delete pIteratorAccessor;
		return S_OK;
	}

	//
	// Returns S_FALSE if it's not expired
	// S_OK if it is expired and an error HRESULT
	// if an error occurred.
	STDMETHOD(IsExpired)() throw()
	{
		HRESULT hrRet = S_FALSE;
		HRESULT hr = E_UNEXPECTED;

		// Get the data connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		CCommand<CAccessor<CSessionRefIsExpired> > command;
		hr = command.Assign(m_szSessionName);
		if (hr != S_OK)
			return hr;

		hr = command.Open(dataconn, m_QueryObj.GetSessionRefIsExpired(), 
							NULL, NULL, DBGUID_DEFAULT, true);
		if (hr == S_OK)
		{
			if (S_OK == command.MoveFirst())
			{
				if (!_tcscmp(command.m_SessionIDOut, m_szSessionName))
					hrRet = S_OK;
			}
		}

		if (hr == S_OK)
			return hrRet;
		return hr;
	}

	STDMETHOD(SetTimeout)(unsigned __int64 dwNewTimeout) throw()
	{
		HRESULT hr = E_UNEXPECTED;

		// Get the data connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// allocate a command and set it's input parameters
		CCommand<CAccessor<CSessionRefUpdateTimeout> > command;
		hr = command.Assign(m_szSessionName, dwNewTimeout);
		if (hr != S_OK)
			return hr;

		hr = command.Open(dataconn, m_QueryObj.GetSessionRefUpdateTimeout(),
						NULL, NULL, DBGUID_DEFAULT, false);

		return hr;
	}

	// SessionLock increments the session reference count for this session.
	// If there is not a session by this name in the session references table,
	// a new session entry is created in the the table.
	HRESULT SessionLock() throw()
	{
		HRESULT hr = E_UNEXPECTED;
		if (!m_szSessionName || m_szSessionName[0]==0)
			return hr; // no session to lock.

		// retrieve the data connection for this thread
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// first try to update a session with this name
		DBROWCOUNT nRows = 0;
		CCommand<CAccessor<CSessionRefUpdator> > updator;
		if (S_OK == updator.Assign(m_szSessionName))
		{
			if (S_OK != (hr = updator.Open(dataconn, m_QueryObj.GetSessionRefAddRef(),
				NULL, &nRows, DBGUID_DEFAULT, false)) ||
				nRows == 0)
			{
				// No session to update. Use the creator accessor
				// to create a new session reference.
				CCommand<CAccessor<CSessionRefCreator> > creator;
				hr = creator.Assign(m_szSessionName, m_dwTimeout);
				if (hr == S_OK)
					hr = creator.Open(dataconn, m_QueryObj.GetSessionRefCreate(),
					NULL, &nRows, DBGUID_DEFAULT, false);
			}
		}

		// We should have been able to create or update a session.
		ATLASSERT(nRows > 0);
		if (hr == S_OK && nRows <= 0)
			hr = E_UNEXPECTED;

		return hr;
	}

	// SessionUnlock decrements the session RefCount for this session.
	// Sessions cannot be removed from the database unless the session
	// refcount is 0
	HRESULT SessionUnlock() throw()
	{
		HRESULT hr = E_UNEXPECTED;
		if (!m_szSessionName ||
			m_szSessionName[0]==0)
			return hr; 

		// get the data connection for this thread
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// The session must exist at this point in order to unlock it
		// so we can just use the session updator here.
		DBROWCOUNT nRows = 0;
		CCommand<CAccessor<CSessionRefUpdator> > updator;
		hr = updator.Assign(m_szSessionName);
		if (hr == S_OK)
		{
			hr = updator.Open(	dataconn,
								m_QueryObj.GetSessionRefRemoveRef(),
								NULL,
								&nRows,
								DBGUID_DEFAULT,
								false);
		}
		if (hr != S_OK)
			return hr;

		// delete the session from the database if 
		// nobody else is using it and it's expired.
		hr = FreeSession();
		return hr;
	}

	// Access updates the last access time for the session. The access
	// time for sessions is updated using the SQL GETDATE function on the
	// database server so that all clients will be using the same clock
	// to compare access times against.
	HRESULT Access() throw()
	{
		HRESULT hr = E_UNEXPECTED;

		if (!m_szSessionName || 
			m_szSessionName[0]==0)
			return hr; // no session to access

		// get the data connection for this thread
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// The session reference entry in the references table must
		// be created prior to calling this function so we can just
		// use an updator to update the current entry.
		CCommand<CAccessor<CSessionRefUpdator> > updator;

		DBROWCOUNT nRows = 0;
		hr = updator.Assign(m_szSessionName);
		if (hr == S_OK)
		{
			hr = updator.Open(	dataconn,
								m_QueryObj.GetSessionRefAccess(),
								NULL,
								&nRows,
								DBGUID_DEFAULT,
								false);
		}

		ATLASSERT(nRows > 0);
		if (hr == S_OK && nRows <= 0)
			hr = E_UNEXPECTED;
		return hr;
	}

	// If the session is expired and it's reference is 0,
	// it can be deleted. SessionUnlock calls this function to
	// unlock the session and delete it after we release a session
	// lock. Note that our SQL command will only delete the session
	// if it is expired and it's refcount is <= 0
	HRESULT FreeSession() throw()
	{
		HRESULT hr = E_UNEXPECTED;
		if (!m_szSessionName ||
			m_szSessionName[0]==0)
			return hr;

		// Get the data connection for this thread.
		CDataConnection dataconn;
		hr = GetSessionConnection(&dataconn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		CCommand<CAccessor<CSessionRefUpdator> > updator;

		// The SQL for this command only deletes the
		// session reference from the references table if it's access
		// count is 0 and it has expired.
		return updator.Open(dataconn,
							m_QueryObj.GetSessionRefDelete(),
							NULL,
							NULL,
							DBGUID_DEFAULT,
							false);
	}

	// Initialize is called each time a new session is created.
	HRESULT Initialize( LPCSTR szSessionName, 
						IServiceProvider *pServiceProvider,
						DWORD_PTR dwCookie,
						PFN_GETPROVIDERINFO pfnInfo) throw()
	{
		if (!szSessionName)
			return E_INVALIDARG;

		if (!pServiceProvider)
			return E_INVALIDARG;

		if (!pfnInfo)
			return E_INVALIDARG;

		m_pfnInfo = pfnInfo;
		m_dwProvCookie = dwCookie;
		m_spServiceProvider = pServiceProvider;

		_ATLTRY
		{
			CA2CT tcsSessionName(szSessionName);
			if (Checked::tcsnlen(tcsSessionName, MAX_SESSION_KEY_LEN) < MAX_SESSION_KEY_LEN)
				Checked::tcscpy_s(m_szSessionName, _countof(m_szSessionName), tcsSessionName);
			else
				return E_OUTOFMEMORY;
		}
		_ATLCATCHALL()
		{
			return E_OUTOFMEMORY;
		}
		return SessionLock();
	}

	HRESULT GetSessionConnection(CDataConnection *pConn,
								 IServiceProvider *pProv) throw()
	{
		if (!pProv)
			return E_INVALIDARG;

		if (!m_pfnInfo || 
			!m_dwProvCookie)
			return E_UNEXPECTED;

		wchar_t *wszProv = NULL;
		if (m_pfnInfo(m_dwProvCookie, &wszProv) && wszProv!=NULL)
		{
			return GetDataSource(pProv,
						ATL_DBSESSION_ID,
						wszProv,
						pConn);
		}
		return E_FAIL;
	}


protected:
	TCHAR m_szSessionName[MAX_SESSION_KEY_LEN];
	unsigned __int64 m_dwTimeout;
	CComPtr<IServiceProvider> m_spServiceProvider;
	DWORD_PTR m_dwProvCookie;
	PFN_GETPROVIDERINFO m_pfnInfo;
	DBQUERYCLASS_TYPE m_QueryObj;
}; // CDBSession


template <class TDBSession=CDBSession<> >
class CDBSessionServiceImplT
{
	wchar_t m_szConnectionString[MAX_CONNECTION_STRING_LEN];
	CComPtr<IServiceProvider> m_spServiceProvider;
	typename TDBSession::DBQUERYCLASS_TYPE m_QueryObj;
public:
	typedef const wchar_t* SERVICEIMPL_INITPARAM_TYPE;
	CDBSessionServiceImplT() throw()
	{
		m_dwTimeout = ATL_SESSION_TIMEOUT;
		m_szConnectionString[0] = '\0';
	}

	static bool GetProviderInfo(DWORD_PTR dwProvCookie, wchar_t **ppszProvInfo) throw()
	{
		if (dwProvCookie &&
			ppszProvInfo)
		{
			CDBSessionServiceImplT<TDBSession> *pSvc = 
				reinterpret_cast<CDBSessionServiceImplT<TDBSession>*>(dwProvCookie);
			*ppszProvInfo = pSvc->m_szConnectionString;
			return true;
		}
		return false;
	}

	HRESULT GetSessionConnection(CDataConnection *pConn,
								 IServiceProvider *pProv) throw()
	{
		if (!pProv)
			return E_INVALIDARG;

		if(!m_szConnectionString[0])
			return E_UNEXPECTED;

		return GetDataSource(pProv,
					ATL_DBSESSION_ID,
					m_szConnectionString,
					pConn);
	}

	HRESULT Initialize(SERVICEIMPL_INITPARAM_TYPE pData,
						IServiceProvider *pProvider,
						unsigned __int64 dwInitialTimeout) throw()
	{
		if (!pData || !pProvider)
			return E_INVALIDARG;

		if (Checked::wcsnlen(pData, MAX_CONNECTION_STRING_LEN) < MAX_CONNECTION_STRING_LEN)
		{
			Checked::wcscpy_s(m_szConnectionString, _countof(m_szConnectionString), pData);
		}
		else
			return E_OUTOFMEMORY;

		m_dwTimeout = dwInitialTimeout;
		m_spServiceProvider = pProvider;
		return S_OK;
	}

	HRESULT CreateNewSession(__out_ecount_part_z(*pdwSize, *pdwSize) LPSTR szNewID, __inout DWORD *pdwSize, __deref_out ISession** ppSession) throw()
	{
		HRESULT hr = E_FAIL;
		CComObject<TDBSession> *pNewSession = NULL;

		if (!pdwSize)
			return E_POINTER;

		if (ppSession)
			*ppSession = NULL;
		else
			return E_POINTER;

		if (szNewID)
			*szNewID = NULL;
		else
			return E_INVALIDARG;


		// Create new session
		CComObject<TDBSession>::CreateInstance(&pNewSession);
		if (pNewSession == NULL)
			return E_OUTOFMEMORY;

		// Create a session name and initialize the object
		hr = m_SessionNameGenerator.GetNewSessionName(szNewID, pdwSize);
		if (hr == S_OK)
		{
			hr = pNewSession->Initialize(szNewID, 
										m_spServiceProvider,
										reinterpret_cast<DWORD_PTR>(this),
										GetProviderInfo);
			if (hr == S_OK)
			{
				// we don't hold a reference to the object
				hr = pNewSession->QueryInterface(ppSession);
			}
		}

		if (hr != S_OK)
			delete pNewSession;
		return hr;
	}

	HRESULT CreateNewSessionByName(__in_z LPSTR szNewID, __deref_out ISession** ppSession) throw()
	{
		HRESULT hr = E_FAIL;
		CComObject<TDBSession> *pNewSession = NULL;

		if (!szNewID || *szNewID == 0)
			return E_INVALIDARG;

		if (ppSession)
			*ppSession = NULL;
		else
			return E_POINTER;

		// Create new session
		CComObject<TDBSession>::CreateInstance(&pNewSession);
		if (pNewSession == NULL)
			return E_OUTOFMEMORY;

		hr = pNewSession->Initialize(szNewID, 
									m_spServiceProvider,
									reinterpret_cast<DWORD_PTR>(this),
									GetProviderInfo);
		if (hr == S_OK)
		{
			// we don't hold a reference to the object
			hr = pNewSession->QueryInterface(ppSession);
		}


		if (hr != S_OK)
			delete pNewSession;
		return hr;
	}


	HRESULT GetSession(LPCSTR szID, ISession **ppSession) throw()
	{
		HRESULT hr = E_FAIL;
		if (!szID)
			return E_INVALIDARG;

		if (ppSession)
			*ppSession = NULL;
		else
			return E_POINTER;

		CComObject<TDBSession> *pNewSession = NULL;

		// Check the DB to see if the session ID is a valid session
		_ATLTRY
		{
			CA2CT session(szID);
			hr = IsValidSession(session);
		}
		_ATLCATCHALL()
		{
			hr = E_OUTOFMEMORY;
		}
		if (hr == S_OK)
		{
			// Create new session object to represent this session
			CComObject<TDBSession>::CreateInstance(&pNewSession);
			if (pNewSession == NULL)
				return E_OUTOFMEMORY;

			hr = pNewSession->Initialize(szID,
										m_spServiceProvider,
										reinterpret_cast<DWORD_PTR>(this),
										GetProviderInfo);
			if (hr == S_OK)
			{
				// we don't hold a reference to the object
				hr = pNewSession->QueryInterface(ppSession);
			}
		}

		if (hr != S_OK && pNewSession)
			delete pNewSession;
		return hr;
	}

	HRESULT CloseSession(LPCSTR szID) throw()
	{
		if (!szID)
			return E_INVALIDARG;

		CDataConnection conn;
		HRESULT hr = GetSessionConnection(&conn,
										  m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// set up accessors
		CCommand<CAccessor<CSessionRefUpdator> > updator;
		CCommand<CAccessor<CSessionDataDeleteAll> > command;
		_ATLTRY
		{
			CA2CT session(szID);
			hr = updator.Assign(session);
			if (hr == S_OK)
				hr = command.Assign(session);
		}
		_ATLCATCHALL()
		{
			hr = E_OUTOFMEMORY;
		}

		if (hr == S_OK)
		{
			// delete all session variables (may not be any!)
			hr = command.Open(conn,
								m_QueryObj.GetSessionVarDeleteAllVars(),
								NULL,
								NULL,
								DBGUID_DEFAULT,
								false);
			if (hr == S_OK)
			{
				DBROWCOUNT nRows = 0;
				nRows = 0;
				// delete references in the session references table
				hr = updator.Open(conn,
							m_QueryObj.GetSessionRefDeleteFinal(),
							NULL,
							&nRows,
							DBGUID_DEFAULT,
							false);
				if (nRows == 0)
					hr = E_UNEXPECTED;
			}
		}
		return hr;
	}

	HRESULT SetSessionTimeout(unsigned __int64 nTimeout) throw()
	{
		// Get the data connection for this thread
		CDataConnection conn;

		HRESULT hr = GetSessionConnection(&conn, m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// all sessions get the same timeout
		CCommand<CAccessor<CSetAllTimeouts> > command;
		hr = command.Assign(nTimeout);
		if (hr == S_OK)
		{
			hr = command.Open(conn, m_QueryObj.GetSessionReferencesSet(),
						NULL,
						NULL,
						DBGUID_DEFAULT,
						false);
			if (hr == S_OK)
			{
				m_dwTimeout = nTimeout;
			}
		}
		return hr;
	}


	HRESULT GetSessionTimeout(unsigned __int64* pnTimeout) throw()
	{
		if (pnTimeout)
			*pnTimeout = m_dwTimeout;
		else
			return E_INVALIDARG;

		return S_OK;
	}

	HRESULT GetSessionCount(DWORD *pnCount) throw()
	{
		if (pnCount)
			*pnCount = 0;
		else
			return E_POINTER;

		CCommand<CAccessor<CSessionRefCount> > command;
		CDataConnection conn;
		HRESULT hr = GetSessionConnection(&conn,
											m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		hr = command.Open(conn,
							m_QueryObj.GetSessionRefGetCount());
		if (hr == S_OK)
		{
			hr = command.MoveFirst();
			if (hr == S_OK)
			{
				*pnCount = (DWORD)command.m_nCount;
			}
		}

		return hr;
	}

	void ReleaseAllSessions() throw()
	{
		// nothing to do
	}

	void SweepSessions() throw()
	{
		// nothing to do
	}


	// Helpers
	HRESULT IsValidSession(LPCTSTR szID) throw()
	{
		if (!szID)
			return E_INVALIDARG;
		// Look in the sessionreferences table to see if there is an entry
		// for this session.
		if (m_szConnectionString[0] == 0)
			return E_UNEXPECTED;

		CDataConnection conn;
		HRESULT hr = GetSessionConnection(&conn,
											m_spServiceProvider);
		if (hr != S_OK)
			return hr;

		// Check the session references table to see if
		// this is a valid session
		CCommand<CAccessor<CSessionRefSelector> > selector;
		hr = selector.Assign(szID);
		if (hr != S_OK)
			return hr;

		hr = selector.Open(conn,
							m_QueryObj.GetSessionRefSelect(),
							NULL,
							NULL,
							DBGUID_DEFAULT,
							true);
		if (hr == S_OK)
			return selector.MoveFirst();
		return hr;
	}

	CSessionNameGenerator m_SessionNameGenerator; // Object for generating session names
	unsigned __int64 m_dwTimeout;
}; // CDBSessionServiceImplT

typedef CDBSessionServiceImplT<> CDBSessionServiceImpl;





//////////////////////////////////////////////////////////////////
//
// In-memory persisted session
//
//////////////////////////////////////////////////////////////////

// In-memory persisted session service keeps a pointer
// to the session obejct around in memory. The pointer is
// contained in a CComPtr, which is stored in a CAtlMap, so
// we have to have a CElementTraits class for that.
typedef CComPtr<ISession> SESSIONPTRTYPE;

template<>
class CElementTraits<SESSIONPTRTYPE> :
	public CElementTraitsBase<SESSIONPTRTYPE>
{
public:
	static ULONG Hash( INARGTYPE obj ) throw()
	{
		return( (ULONG)(ULONG_PTR)obj.p);
	}

	static BOOL CompareElements( OUTARGTYPE element1, OUTARGTYPE element2 ) throw()
	{
		return element1.IsEqualObject(element2.p) ? TRUE : FALSE;
	}

	static int CompareElementsOrdered( INARGTYPE , INARGTYPE ) throw()
	{
		ATLASSERT(0); // NOT IMPLEMENTED
		return 0;
	}
};


// CMemSession
// This session persistance class persists session variables in memory.
// Note that this type of persistance should only be used on single server
// web sites.
class CMemSession :
	public ISession,
	public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
	BEGIN_COM_MAP(CMemSession)
		COM_INTERFACE_ENTRY(ISession)
	END_COM_MAP()

	CMemSession() throw(...)
	{
	}
	virtual ~CMemSession()
	{
	}	

	STDMETHOD(GetVariable)(LPCSTR szName, VARIANT *pVal) throw()
	{
		if (!szName)
			return E_INVALIDARG;

		if (pVal)
			VariantInit(pVal);
		else
			return E_POINTER;

		HRESULT hr = Access();
		if (hr == S_OK)
		{
			CSLockType lock(m_cs, false);
			hr = lock.Lock();
			if (FAILED(hr))
				return hr;

			hr = E_FAIL;
			_ATLTRY
			{
				CComVariant val;
				if (m_Variables.Lookup(szName, val))
				{
					hr = VariantCopy(pVal, &val);
				}
			}
			_ATLCATCHALL()
			{
				hr = E_UNEXPECTED;
			}
		}
		return hr;
	}

	STDMETHOD(SetVariable)(LPCSTR szName, VARIANT vNewVal) throw()
	{
		if (!szName)
			return E_INVALIDARG;

		HRESULT hr = Access();
		if (hr == S_OK)
		{
			CSLockType lock(m_cs, false);
			hr = lock.Lock();
			if (FAILED(hr))
				return hr;
			_ATLTRY
			{
				hr = m_Variables.SetAt(szName, vNewVal) ? S_OK : E_FAIL;
			}
			_ATLCATCHALL()
			{
				hr = E_UNEXPECTED;
			}
		}
		return hr;
	}

	STDMETHOD(RemoveVariable)(LPCSTR szName) throw()
	{
		if (!szName)
			return E_INVALIDARG;

		HRESULT hr = Access();
		if (hr == S_OK)
		{
			CSLockType lock(m_cs, false);
			hr = lock.Lock();
			if (FAILED(hr))
				return hr;
			_ATLTRY
			{
				hr = m_Variables.RemoveKey(szName) ? S_OK : E_FAIL;
			}
			_ATLCATCHALL()
			{
				hr = E_UNEXPECTED;
			}
		}
		return hr;
	}

	STDMETHOD(GetCount)(long *pnCount) throw()
	{
		if (pnCount)
			*pnCount = 0;
		else
			return E_POINTER;

		HRESULT hr = Access();
		if (hr == S_OK)
		{
			CSLockType lock(m_cs, false);
			hr = lock.Lock();
			if (FAILED(hr))
				return hr;
			*pnCount = (long) m_Variables.GetCount();
		}
		return hr;
	}

	STDMETHOD(RemoveAllVariables)() throw()
	{
		HRESULT hr = Access();
		if (hr == S_OK)
		{
			CSLockType lock(m_cs, false);
			hr = lock.Lock();
			if (FAILED(hr))
				return hr;
			m_Variables.RemoveAll();
		}

		return hr;
	}

	STDMETHOD(BeginVariableEnum)(POSITION *pPOS, HSESSIONENUM *phEnumHandle=NULL) throw()
	{
		if (phEnumHandle)
			*phEnumHandle = NULL;

		if (pPOS)
			*pPOS = NULL;
		else
			return E_POINTER;

		HRESULT hr = Access();
		if (hr == S_OK)
		{
			CSLockType lock(m_cs, false);
			hr = lock.Lock();
			if (FAILED(hr))
				return hr;
			*pPOS = m_Variables.GetStartPosition();
		}
		return hr;
	}

	STDMETHOD(GetNextVariable)(POSITION *pPOS, VARIANT *pVal,
							   HSESSIONENUM hEnum=NULL,
							   LPSTR szName=NULL,
							   DWORD dwLen=0 ) throw()
	{
		(hEnum); // Unused!
		if (pVal)
			VariantInit(pVal);
		else
			return E_POINTER;

		if (!pPOS)
			return E_POINTER;

		CComVariant val;
		POSITION pos = *pPOS;
		HRESULT hr = Access();
		if (hr == S_OK)
		{
			CSLockType lock(m_cs, false);
			hr = lock.Lock();
			if (FAILED(hr))
				return hr;

			hr = E_FAIL;
			_ATLTRY
			{
				if (szName)
				{
					CStringA strName = m_Variables.GetKeyAt(pos);
					if (strName.GetLength())
					{
						if (dwLen > (DWORD)strName.GetLength())
						{
							Checked::strcpy_s(szName, dwLen, strName);
							hr = S_OK;
						}
						else
							hr = E_OUTOFMEMORY;
					}
				}
				else
					hr = S_OK;

				if (hr == S_OK)
				{
					val = m_Variables.GetNextValue(pos);
					hr = VariantCopy(pVal, &val);
					if (hr == S_OK)
						*pPOS = pos;
				}
			}
			_ATLCATCHALL()
			{
				hr = E_UNEXPECTED;
			}
		}
		return hr;
	}

	STDMETHOD(CloseEnum)(HSESSIONENUM /*hEnumHandle*/) throw()
	{
		return S_OK;
	}

	STDMETHOD(IsExpired)() throw()
	{
		CTime tmNow = CTime::GetCurrentTime();
		CTimeSpan span = tmNow-m_tLastAccess;
		if ((unsigned __int64)((span.GetTotalSeconds()*1000)) > m_dwTimeout)
			return S_OK;
		return S_FALSE;
	}

	HRESULT Access() throw()
	{
		// We lock here to protect against multiple threads
		// updating the same member concurrently.
		CSLockType lock(m_cs, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
			return hr;
		m_tLastAccess = CTime::GetCurrentTime();
		return S_OK;
	}

	STDMETHOD(SetTimeout)(unsigned __int64 dwNewTimeout) throw()
	{
		// We lock here to protect against multiple threads
		// updating the same member concurrently
		CSLockType lock(m_cs, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
			return hr;
		m_dwTimeout = dwNewTimeout;
		return S_OK;
	}

	HRESULT SessionLock() throw()
	{
		Access();
		return S_OK;
	}

	HRESULT SessionUnlock() throw()
	{
		return S_OK;
	}

protected:
	typedef CAtlMap<CStringA,
					CComVariant,
					CStringElementTraits<CStringA> > VarMapType;
	unsigned __int64 m_dwTimeout;
	CTime m_tLastAccess;
	VarMapType m_Variables;
	CComAutoCriticalSection m_cs;
	typedef CComCritSecLock<CComAutoCriticalSection> CSLockType;
}; // CMemSession


//
// CMemSessionServiceImpl
// Implements the service part of in-memory persisted session services.
//
class CMemSessionServiceImpl
{
public:
	typedef void* SERVICEIMPL_INITPARAM_TYPE;
	CMemSessionServiceImpl() throw()
	{
		m_dwTimeout = ATL_SESSION_TIMEOUT;
	}

	~CMemSessionServiceImpl() throw()
	{
		m_CritSec.Term();
	}

	HRESULT CreateNewSession(__out_ecount_part_z(*pdwSize, *pdwSize) LPSTR szNewID, __inout DWORD *pdwSize, __deref_out_opt ISession** ppSession) throw()
	{
		HRESULT hr = E_FAIL;
		CComObject<CMemSession> *pNewSession = NULL;

		if (!szNewID)
			return E_INVALIDARG;

		if (!pdwSize)
			return E_POINTER;

		if (ppSession)
			*ppSession = NULL;
		else
			return E_POINTER;

		_ATLTRY
		{
			// Create new session
			CComObject<CMemSession>::CreateInstance(&pNewSession);
			if (pNewSession == NULL)
				return E_OUTOFMEMORY;

			// Initialize and add to list of CSessionData
			hr = m_SessionNameGenerator.GetNewSessionName(szNewID, pdwSize);

			if (SUCCEEDED(hr))
			{
				CComPtr<ISession> spSession;
				hr = pNewSession->QueryInterface(&spSession);
				if (SUCCEEDED(hr))
				{
					pNewSession->SetTimeout(m_dwTimeout);
					pNewSession->Access();
					CSLockType lock(m_CritSec, false);
					hr = lock.Lock();
					if (FAILED(hr))
						return hr;
					hr = m_Sessions.SetAt(szNewID, spSession) != NULL ? S_OK : E_FAIL;
					if (hr == S_OK)
						*ppSession = spSession.Detach();
				}
			}
		}
		_ATLCATCHALL()
		{
			hr = E_UNEXPECTED;
		}

		return hr;

	}

	HRESULT CreateNewSessionByName(__in_z LPSTR szNewID, __deref_out_opt ISession** ppSession) throw()
	{
		HRESULT hr = E_FAIL;
		CComObject<CMemSession> *pNewSession = NULL;

		if (!szNewID || *szNewID == 0)
			return E_INVALIDARG;

		if (ppSession)
			*ppSession = NULL;
		else
			return E_POINTER;

		CComPtr<ISession> spSession;
		// If the session already exists, you get a pointer to the
		// existing session. You can't have multiple entries with the
		// same name in CAtlMap
		hr = GetSession(szNewID, &spSession);
		if (hr == S_OK)
		{
			*ppSession = spSession.Detach();
			return hr;
		}

		_ATLTRY
		{
			// Create new session
			CComObject<CMemSession>::CreateInstance(&pNewSession);
			if (pNewSession == NULL)
				return E_OUTOFMEMORY;


			hr = pNewSession->QueryInterface(&spSession);
			if (SUCCEEDED(hr))
			{
				pNewSession->SetTimeout(m_dwTimeout);
				pNewSession->Access();
				CSLockType lock(m_CritSec, false);
				hr = lock.Lock();
				if (FAILED(hr))
					return hr;

				hr = m_Sessions.SetAt(szNewID, spSession) != NULL ? S_OK : E_FAIL;

				if (hr == S_OK)
					*ppSession = spSession.Detach();
			}
		}
		_ATLCATCHALL()
		{
			hr = E_UNEXPECTED;
		}

		return hr;

	}

	HRESULT GetSession(LPCSTR szID, ISession **ppSession) throw()
	{
		HRESULT hr = E_FAIL;
		SessMapType::CPair *pPair = NULL;

		if (ppSession)
			*ppSession = NULL;
		else
			return E_POINTER;

		if (!szID)
			return E_INVALIDARG;

		CSLockType lock(m_CritSec, false);
		hr = lock.Lock();
		if (FAILED(hr))
			return hr;

		hr = E_FAIL;
		_ATLTRY
		{
			pPair = m_Sessions.Lookup(szID); 
			if (pPair) // the session exists and is in our local map of sessions
			{
				hr = pPair->m_value.QueryInterface(ppSession);
			}
		}
		_ATLCATCHALL()
		{
			return E_UNEXPECTED;
		}

		return hr;	
	}

	HRESULT CloseSession(LPCSTR szID) throw()
	{
		if (!szID)
			return 