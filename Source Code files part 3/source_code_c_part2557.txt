ned.  Reading only one byte beyond the buffer does not set
    the error flag because inflate() could pre-fetch too far while grabbing
    the EOB code.  We still don't try to fetch the over-shot byte from the
    buffer because that could cause a protection fault.  */

/* if this was a function, it would read:
BYTE get_char()
{
    if (context->inptr < context->insize)
    {
        return(context->inbuf[context->inptr++]);
    }
    else
    {
        if (context->inptr == context->insize)
        {
            return(0);
        }
        else
        {
            context->get_error = 1;
            return(0);
        }
    }
}

but it's a macro, so it reads:  */

#define get_char()                                  \
(BYTE)                                              \
(                                                   \
    (context->inptr < context->insize) ?            \
    (                                               \
        context->inbuf[context->inptr++]            \
    )                                               \
    :                                               \
    (                                               \
        (context->inptr == context->insize) ?       \
        (                                           \
            0                                       \
        )                                           \
        :                                           \
        (                                           \
            context->get_error = 1,                 \
            0                                       \
        )                                           \
    )                                               \
)

#define NEEDBITS(n)                                 \
    {                                               \
        while (k < (n))                             \
        {                                           \
            b |= ((ULONG) get_char()) << k;         \
            k += 8;                                 \
        }                                           \
    }

#define DUMPBITS(n)                                 \
    {                                               \
        b >>= (n);                                  \
        k -= (n);                                   \
    }

#define     MASK1(x)    ((int) (x & 0x0001))
#define     MASK2(x)    ((int) (x & 0x0003))
#define     MASK3(x)    ((int) (x & 0x0007))
#define     MASK4(x)    ((int) (x & 0x000F))
#define     MASK5(x)    ((int) (x & 0x001F))
#define     MASK6(x)    ((int) (x & 0x003F))
#define     MASK7(x)    ((int) (x & 0x007F))

/* --- local function prototypes ------------------------------------------ */

static int NEAR HuftBuild(unsigned *, unsigned, unsigned, USHORT *, USHORT *,
        HUFF_TREE *, unsigned, int *);
static int NEAR InflateCodes(PMSZIP_DECOMPRESS_CONTEXT context,
        HUFF_TREE *, HUFF_TREE *, int, int, BOOL);
static int NEAR InflateStored(PMSZIP_DECOMPRESS_CONTEXT context,BOOL);
static int NEAR InflateFixed(PMSZIP_DECOMPRESS_CONTEXT context);
static int NEAR InflateDynamic(PMSZIP_DECOMPRESS_CONTEXT context);
static int NEAR InflateBlock(PMSZIP_DECOMPRESS_CONTEXT context);
static int NEAR InitFixed(void);

#ifdef  DISPLAY
static void NEAR DisplayTree(HUFF_TREE *);
#endif

/* --- HuftBuild() -------------------------------------------------------- */

/*  Given a list of code lengths and a maximum table size, make a set of
    tables to decode that set of codes.  Return zero on success, one if
    the given code set is incomplete (the tables are still built in this
    case), two if the input is invalid (all zero length codes or an
    oversubscribed set of lengths), and three if not enough memory. */

/* unsigned *b;         code lengths in bits (all assumed <= BMAX) */
/* unsigned n;          number of codes (assumed <= N_MAX) */
/* unsigned s;          number of simple-valued codes (0..s-1) */
/* USHORT *d;             list of base values for non-simple codes */
/* USHORT *e;             list of extra bits for non-simple codes */

/* HUFF_TREE *ht        the array in which to build tree */
/* int hts              the size of the ht array */

/* int *m;              maximum lookup bits, returns actual */

static int NEAR HuftBuild(unsigned *b, unsigned n, unsigned s, USHORT *d,
        USHORT *e, HUFF_TREE *ht, unsigned htmax, int *m)
{
    unsigned a;                 /* counter for codes of length k */
    unsigned c[BMAX+1];         /* bit length count table */
    unsigned f;                 /* i repeats in table every f entries */
    int g;                      /* maximum code length */
    int h;                      /* table level */
    register unsigned i;        /* counter, current code */
    register unsigned j;        /* counter */
    register int k;             /* number of bits in current code */
    int l;                      /* bits per table (returned in m) */
    register unsigned *p;       /* pointer into c[], b[], or v[] */
#ifdef POINTERS
    register HUFF_TREE *q;      /* points to current table */
    HUFF_TREE *u[BMAX];         /* table stack */
#else
    unsigned q = 0;             /* offset to current table within current block */
    unsigned u[BMAX];           /* table stack */
#endif
    HUFF_TREE r;                /* table entry for structure assignment */
    unsigned v[N_MAX];          /* values in order of bit length */
    register int w;             /* bits before this table == (l * h) */
    unsigned x[BMAX+1];         /* bit offsets, then code stack */
    unsigned *xp;               /* pointer into x */
    int y;                      /* number of dummy codes added */

    unsigned z;                 /* number of entries in current table */
    unsigned htnext = 0;        /* next free entry in ht */

#ifdef  DISPLAY
    memset(&r,0,sizeof(r));             /* tidy up */
    memset(v,0,sizeof(v));
    memset(x,0,sizeof(x));
#endif

    memset(c, 0, sizeof(c));            /* Generate counts for each bit len */
    p = b;
    i = n;

    do
    {
        c[*p++]++;                      /* assume all entries <= BMAX */
    } while (--i);

    if (c[0] == n)                      /* null input: all 0-length codes */
    {
        *m = 0;
        return 0;
    }

    l = *m;                             /* Find min/max length, bound *m */
    for (j = 1; j <= BMAX; j++)
    {
        if (c[j])
        {
            break;
        }
    }

    k = j;                              /* minimum code length */

    if ((unsigned) l < j)
    {
        l = j;
    }

    for (i = BMAX; i; i--)
    {
        if (c[i])
        {
            break;
        }
    }

    g = i;                              /* maximum code length */

    if ((unsigned) l > i)
    {
        l = i;
    }

    *m = l;

    /* Adjust last length count to fill out codes, if needed */

    for (y = 1 << j; j < i; j++, y <<= 1)
    {
        if ((y -= c[j]) < 0)
        {
#ifdef CK_DEBUG
printf("HUFT_BUILD: bad 1\n");
#endif
            return 2;                   /* bad input: more codes than bits */
        }
    }

    if ((y -= c[i]) < 0)
    {
#ifdef CK_DEBUG
printf("HUFT_BUILD: bad 2\n");
#endif
        return 2;
    }

    c[i] += y;

    /* Generate starting offsets into the value table for each length */

    x[1] = j = 0;

    p = c + 1;

    xp = x + 2;

    while (--i)
    {                                   /* note that i == g from above */
        *xp++ = (j += *p++);
    }

    /* Make a table of values in order of bit lengths */

    p = b;

    i = 0;

    do
    {
        if ((j = *p++) != 0)
        {
            v[x[j]++] = i;
        }
    } while (++i < n);

    /* Generate the Huffman codes and for each, make the table entries */

    x[0] = i = 0;                       /* first Huffman code is zero */
    p = v;                              /* grab values in bit order */
    h = -1;                             /* no tables yet--level -1 */
    w = -l;                             /* bits decoded == (l * h) */
#ifdef POINTERS
    u[0] = NULL;
    q = NULL;
#else
    u[0] = (unsigned) -1;
    q = 0;
#endif
    z = 0;                              /* ditto */

    /* go through the bit lengths (k already is bits in shortest code) */

    for (; k <= g; k++)
    {
        a = c[k];

        while (a--)
        {
            /* here i is the Huffman code of length k bits for value *p */
            /* make tables up to required level */

            while (k > w + l)
            {
                h++;
                w += l;                 /* previous table always l bits */

                /* compute minimum size table less than or equal to l bits */

                /* upper limit on table size */

                z = (USHORT) g - w;

                if (z > (unsigned) l)
                {
                    z = (USHORT) l;
                }

                /* try a k-w bit table */

                if ((f = 1 << (j = k - w)) > a + 1)
                {                       /* too few codes for k-w bit table */
                    f -= a + 1;         /* deduct codes from patterns left */
                    xp = c + k;

                    while (++j < z)     /* try smaller tables up to z bits */
                    {
                        if ((f <<= 1) <= *++xp)
                        {
                            break;      /* enough codes to use up j bits */
                        }

                        f -= *xp;       /* else deduct codes from patterns */
                    }
                }

                z = (USHORT) 1 << j;    /* table entries for j-bit table */

#ifdef POINTERS
                q = ht + htnext;
#else
                q = htnext;
#endif
                htnext += z;
                if (htnext > htmax)
                {
#ifdef CK_DEBUG
printf("[not enough memory]");
#endif
                    return 3;           /* not enough memory */
                }

#ifdef  DISPLAY
#ifdef POINTERS
                memset(q, 0, z * sizeof(HUFF_TREE));   /* tidy up */
#else
                memset(ht + q, 0, z * sizeof(HUFF_TREE));   /* tidy up */
#endif

/*  Here we used to set number of nodes (z) into first entry (link)
    but now we aren't keeping the extra entry.  */

#endif

                u[h] = q;

                /* connect to last table, if there is one */
                if (h)
                {
                    x[h] = i;           /* save pattern for backing up */
                    r.b = (BYTE)l;      /* bits to dump before this table */
                    r.e = (BYTE)(16 + j);  /* bits in this table */
#ifdef POINTERS
                    r.v.t = q;
                    j = i >> (w - l);   /* (get around Turbo C bug) */
                    u[h-1][j] = r;      /* connect to last table */
#else
                    r.v.t = (USHORT) q;     /* pointer to this table */
                    j = i >> (w - l);   /* (get around Turbo C bug) */
                    *(ht + u[h-1] + j) = r;      /* connect to last table */
#endif
                }
            }

            /* set up table entry in r */

            r.b = (BYTE)(k - w);

            if (p >= v + n)
            {
                r.e = 99;               /* out of values--invalid code */
            }
            else if (*p < s)
            {                           /* 256 is end-of-block code */
                r.e = (BYTE)(*p < 256 ? 16 : 15);
                r.v.n = (USHORT) *p++;           /* simple code is just the value */
            }
            else
            {
                r.e = (BYTE)e[*p - s];  /* non-simple--look up in lists */
                r.v.n = (USHORT) d[*p++ - s];
            }

            /* fill code-like entries with r */

            f = 1 << (k - w);

            for (j = i >> w; j < z; j += f)
            {
#ifdef POINTERS
                q[j] = r;
#else
                *(ht + q + j) = r;
#endif
            }

            /* backwards increment the k-bit code i */

            for (j = 1 << (k - 1); i & j; j >>= 1)
            {
                i ^= j;
            }

            i ^= j;

            /* backup over finished tables */

            while ((i & ((1 << w) - 1)) != x[h])
            {
                h--;                    /* don't need to update q */
                w -= l;
            }
        }
    }

    /* Return true (1) if we were given an incomplete table */

#ifdef  DISPLAY
#ifdef POINTERS
    DisplayTree(u[0]);                  /* display finished results */
#else
    DisplayTree(ht);                    /* display finished results */
#endif
#endif

    return ((y != 0) && (g != 1));
}

/* --- InflateCodes() ----------------------------------------------------- */

/* HUFF_TREE *tl, *td;  literal/length and distance decoder tables */
/* int bl, bd;          number of bits decoded by tl[] and td[] */
/* inflate (decompress) the codes in a deflated (compressed) block.
   Return an error code or zero if it all goes ok. */

static int NEAR InflateCodes(PMSZIP_DECOMPRESS_CONTEXT context,
        HUFF_TREE *tl, HUFF_TREE *td, int bl, int bd, BOOL bResume)
{
    register unsigned e;        /* table entry flag/number of extra bits */
    unsigned n, d;              /* length and index for copy */
    HUFF_TREE *t;               /* pointer to table entry */
    unsigned ml, md;            /* masks for bl and bd bits */
    register ULONG b;           /* bit buffer */
    register unsigned k;        /* number of bits in bit buffer */

    BYTE * dptr;                /* pointer used for match/copy */

    /* make local copies of globals */
    b = context->bb;            /* initialize bit buffer */
    k = context->bk;

    /* inflate the coded data */
    ml = mask_bits[bl];           /* precompute masks for speed */
    md = mask_bits[bd];


    /* Resuming a previous inflate in the middle of a match? */
    if (bResume && context->streeIsMatch)
    {
        dptr = context->streePointer;
        n = context->streeNumber;
        goto ResumeMatch;
    }


    for (;;)                      /* do until end of block */
    {
        NEEDBITS((unsigned)bl)
        if (context->get_error)
        {
#ifdef CK_DEBUG
printf("InflateCodes: bad 1\n");
#endif
            return(1);
        }

        if ((e = (t = tl + ((unsigned)b & ml))->e) > 16)
        {
            do
            {
                if (e == 99)
                {
#ifdef CK_DEBUG
printf("InflateCodes: bad 2\n");
#endif
                    return 1;
                }

#ifdef  DISPLAY
    if (t->b)
    {
        printf("%d ",b & mask_bits[t->b]);
    }
#endif
                DUMPBITS(t->b)
                e -= 16;
                NEEDBITS(e)
                if (context->get_error)
                {
#ifdef CK_DEBUG
printf("InflateCodes: bad 3\n");
#endif
                    return(1);
                }
#ifdef POINTERS
            } while ((e = (t = t->v.t +
                    ((unsigned)b & mask_bits[e]))->e) > 16);
#else
            } while ((e = (t = (tl + t->v.t) +
                    ((unsigned)b & mask_bits[e]))->e) > 16);
#endif
        }
#ifdef  DISPLAY
        if (t->b)
        {
            printf("%d ",b & mask_bits[t->b]);
        }
#endif
        DUMPBITS(t->b)

        if (e == 16)                /* then it's a literal */
        {
#ifdef  DISPLAY_DECO
            if ((t->v.n >= ' ') && (t->v.n <= '~'))
            {
                printf("%5ld %5ld: '%c'\n",(unsigned long) context->inptr,
                        (unsigned long) (context->outbuffer - context->outstart),t->v.n);
            }
            else
            {
                printf("%5ld %5ld: 0x%02X\n",(unsigned long) context->inptr,
                        (unsigned long) (context->outbuffer - context->outstart),t->v.n);
            }
#endif
            *context->outbuffer++ = ((BYTE)t->v.n);  /* Emit one literal byte */
            if (--context->outleft == 0)        /* More output bytes requested? */
            {
                /*  NO, store state for restart */

                context->IncrementalState = sHUFFTREE;
                context->streeIsMatch = FALSE;
                context->streeTL = tl;
                context->streeTD = td;
                context->streeBL = bl;
                context->streeBD = bd;
                goto Done;
            }
        }
        else                        /* it's an EOB or a length */
        {
            /* exit if end of block */
            if (e == 15)
            {
                break;
            }

            /* get length of block to copy */
            NEEDBITS(e)
            if (context->get_error)
            {
#ifdef CK_DEBUG
printf("InflateCodes: bad 4\n");
#endif
                return(1);
            }

            n = t->v.n + ((unsigned)b & mask_bits[e]);
#ifdef  DISPLAY
    if (e)
    {
        printf("%d ",b & mask_bits[e]);
    }
#endif
            DUMPBITS(e);

            /* decode distance of block to copy */
            NEEDBITS((unsigned)bd)
            if (context->get_error)
            {
#ifdef CK_DEBUG
printf("InflateCodes: bad 5\n");
#endif
                return(1);
            }

            if ((e = (t = td + ((unsigned)b & md))->e) > 16)
            {
                do
                {
                    if (e == 99)
                    {
#ifdef CK_DEBUG
printf("InflateCodes: bad 6\n");
#endif
                        return 1;
                    }
#ifdef  DISPLAY
    if (t->b)
    {
        printf("%d ",b & mask_bits[t->b]);
    }
#endif
                    DUMPBITS(t->b)
                    e -= 16;
                    NEEDBITS(e)
                    if (context->get_error)
                    {
                        return(1);
                    }

#ifdef POINTERS
                } while ((e = (t = t->v.t +
                        ((unsigned)b & mask_bits[e]))->e) > 16);
#else
                } while ((e = (t = (td + t->v.t) +
                        ((unsigned)b & mask_bits[e]))->e) > 16);
#endif
            }
#ifdef  DISPLAY
    if (t->b)
    {
        printf("%d ",b & mask_bits[t->b]);
    }
#endif
            DUMPBITS(t->b)

            NEEDBITS(e)
            if (context->get_error)
            {
#ifdef CK_DEBUG
printf("InflateCodes: bad 7\n");
#endif
                return(1);
            }

            /* d is distance back in buffer */
            d = t->v.n + ((unsigned)b & mask_bits[e]);

#ifdef  DISPLAY
            if (e)
            {
                printf("%d ",b & mask_bits[e]);
            }
#endif
            DUMPBITS(e)

#ifdef  DISPLAY_DECO
            printf("%5ld %5ld: copy(%d,%d)\n",(unsigned long) context->inptr,
                    (unsigned long) (context->outbuffer - context->outstart),d,n);
#endif

            /* do the copy */
            /* note: may reach back into "previous buffer" */
            /* previous buffer is loaded, so this may grab from end of buffer */

#ifdef NOWRAP
            /* ifdef DRIVESPACE - don't worry about wrapping to previous buffer, */
            /* this is the easy case... */

            dptr = context->outbuffer - d;

ResumeMatch:

            while (n--)
            {
                *context->outbuffer++ = *dptr++;
                if (--context->outleft == 0)
                {
                    context->IncrementalState = sHUFFTREE;
                    context->streeIsMatch = TRUE;
                    context->streeTL = tl;
                    context->streeTD = td;
                    context->streeBL = bl;
                    context->streeBD = bd;
                    context->streePointer = dptr;
                    context->streeNumber = n;
                    goto Done;
                }
            }
#else
            if (d > (unsigned)(context->outbuffer - context->outstart))
            {
                dptr = context->outbuffer + (WSIZE - d);
            }
            else
            {
                dptr = context->outbuffer - d;
            }

ResumeMatch:
            while (n--)
            {
                *context->outbuffer++ = *dptr++;

                if (dptr == context->outstart + WSIZE)
                {
                    dptr = context->outstart;
                }

                if (--context->outleft == 0)
                {
                    context->IncrementalState = sHUFFTREE;
                    context->streeIsMatch = TRUE;
                    context->streeTL = tl;
                    context->streeTD = td;
                    context->streeBL = bl;
                    context->streeBD = bd;
                    context->streePointer = dptr;
                    context->streeNumber = n;
                    goto Done;
                }
            }
#endif
        }
    }

Done:

    /* restore the globals from the locals */
    context->bb = b;                       
    context->bk = k;

    /* done */
    return 0;
}

/* --- InflateDynamic() --------------------------------------------------- */

static int NEAR InflateDynamic(PMSZIP_DECOMPRESS_CONTEXT context)
/* decompress an inflated type 2 (dynamic Huffman codes) block. */
{
    int i;                      /* temporary variables */
    unsigned j;
    unsigned l;                 /* last length */
    unsigned m;                 /* mask for bit lengths table */
    unsigned n;                 /* number of lengths to get */
    HUFF_TREE *td;              /* distance code table */
    int bl;                     /* lookup bits for tl */
    int bd;                     /* lookup bits for td */
    unsigned nb;                /* number of bit length codes */
    unsigned nl;                /* number of literal/length codes */
    unsigned nd;                /* number of distance codes */
    register ULONG b;           /* bit buffer */
    register unsigned k;        /* number of bits in bit buffer */
    int rc;                     /* return code */
    unsigned ll[286+30];        /* literal/length and distance code lengths */

    b = context->bb;            /* setup local bit buffer */
    k = context->bk;

    /* read in table lengths */

    NEEDBITS(5)
    nl = MASK5(b) + 257;        /* number of literal/length codes */
    DUMPBITS(5)

    NEEDBITS(5)
    nd = MASK5(b) + 1;          /* number of distance codes */
    DUMPBITS(5)

    NEEDBITS(4)
    nb = MASK4(b) + 4;          /* number of bit length codes */
    DUMPBITS(4)

    if ((context->get_error) || (nl > 286) || (nd > 30))
    {
#ifdef CK_DEBUG
printf("InflateDynamic: bad 1\n");
#endif
        return 1;               /* bad lengths */
    }

    /* read in bit-length-code lengths */

    for (j = 0; j < nb; j++)
    {
        NEEDBITS(3)
        ll[border[j]] = MASK3(b);
        DUMPBITS(3)
    }

    while (j < 19)
    {
        ll[border[j++]] = 0;
    }

    if (context->get_error)
    {
#ifdef CK_DEBUG
printf("InflateDynamic: bad 2\n");
#endif
        return(1);
    }

    /* build decoding table for trees--single level, 7 bit lookup */

    bl = 7;

    rc = HuftBuild(ll, 19, 19, NULL, NULL, context->htl, HTL_SIZE, &bl);

    if (rc != 0)
    {
#ifdef CK_DEBUG
printf("InflateDynamic: bad 3\n");
#endif
        return rc;                   /* incomplete code set */
    }

    /* read in literal and distance code lengths */

    n = nl + nd;
    m = mask_bits[bl];
    i = l = 0;

    while ((unsigned)i < n)
    {
        NEEDBITS((unsigned)bl)
        if (context->get_error)
        {
            break;
        }

        j = (td = context->htl + ((unsigned)b & m))->b;
        DUMPBITS(j)

        j = td->v.n;

        if (j < 16)                 /* length of code in bits (0..15) */
        {
            ll[i++] = l = j;        /* save last length in l */
        }
        else if (j == 16)           /* repeat last length 3 to 6 times */
        {
            NEEDBITS(2)
            if (context->get_error)
            {
                break;
            }

            j = MASK2(b) + 3;
            DUMPBITS(2)

            if ((unsigned)i + j > n)
            {
                context->get_error = 2;     /* force it to free first */
                break;
            }

            while (j--)
            {
                ll[i++] = l;
            }
        }
        else if (j == 17)           /* 3 to 10 zero length codes */
        {
            NEEDBITS(3)
            if (context->get_error)
            {
                break;
            }

            j = MASK3(b) + 3;
            DUMPBITS(3)

            if ((unsigned) i + j > n)
            {
                context->get_error = 2;     /* force it to free first */
                break;
            }

            while (j--)
            {
                ll[i++] = 0;
            }

            l = 0;
        }
        else                        /* j == 18: 11 to 138 zero length codes */
        {
            NEEDBITS(7)
            if (context->get_error)
            {
                break;
            }

            j = MASK7(b) + 11;
            DUMPBITS(7)

            if ((unsigned) i + j > n)
            {
                context->get_error = 2;     /* force it to free first */
                break;
            }

            while (j--)
            {
                ll[i++] = 0;
            }

            l = 0;
        }
    }

    if (context->get_error)
    {
        return(1);
    }

    /* restore the global bit buffer */
    context->bb = b;
    context->bk = k;

    /* build the decoding tables for literal/length and distance codes */

    bl = LBITS;

    rc = HuftBuild(ll, nl, 257, cplens, cplext, context->htl, HTL_SIZE, &bl);
    if (rc != 0)
    {
        return rc;                   /* incomplete code set */
    }

    bd = DBITS;

    rc = HuftBuild(ll + nl, nd, 0, cpdist, cpdext, context->htd, HTD_SIZE, &bd);
    if (rc != 0)
    {
        return rc;                  /* incomplete code set */
    }

    /* decompress using tables */
    rc = InflateCodes(context, context->htl, context->htd, bl, bd, FALSE);

    return rc;
}

/* --- InitFixed() -------------------------------------------------------- */

/* Initialize the fixed huffman tables once only */

static int NEAR InitFixed()
{
    int i;                                  /* table fill looper */
    unsigned l[288];                        /* length list for huft_build */
    int rc;                                 /* result code */

    i = 0;

    while (i < 144)
    {
        l[i++] = 8;
    }

    while (i < 256)
    {
        l[i++] = 9;
    }

    while (i < 280)
    {
        l[i++] = 7;
    }

    while (i < 288)         /* make a complete, but wrong code set */
    {
        l[i++] = 8;
    }

    i = FIX_B_LIT;

    rc = HuftBuild(l, 288, 257, cplens, cplext, fhtl, FIX_HTL_SIZE, &i);
    if (rc != 0)
    {
        return rc;                          /* ran out of memory */
    }

    for (i = 0; i < 30; i++)                /* make an incomplete code set */
    {
        l[i] = 5;
    }

    i = FIX_B_DIST;

    rc = HuftBuild(l, 30, 0, cpdist, cpdext, fhtd, FIX_HTD_SIZE, &i);

    if (rc > 1)
    {
        return rc;
    }

    return (0);
}

/* --- InflateFixed() ----------------------------------------------------- */

/* decompress an inflated type 1 (fixed Huffman codes) block. */

static int NEAR InflateFixed(PMSZIP_DECOMPRESS_CONTEXT context)
{
    /* inflate using fixed tables, and return result */

    return InflateCodes(context, fhtl, fhtd, FIX_B_LIT, FIX_B_DIST, FALSE);
}

/* --- InflateStored() ---------------------------------------------------- */

/* "decompress" a stored block */
/* bResume is TRUE if we are resuming a previous operation */

static int NEAR InflateStored(PMSZIP_DECOMPRESS_CONTEXT context,BOOL bResume)
{
    unsigned n;                             /* number of bytes in block */
    register ULONG b;                       /* local bit buffer */
    register unsigned k;                    /* number of bits in bit buffer */
    BYTE *source;

    if (bResume)
    {
        source = context->sstorePointer;
        n = context->sstoreNBytes;

        context->IncrementalState = sNEWBLOCK;  /* don't repeat */
    }
    else
    {
        b = context->bb;                    /* pickup current global buffer */
        k = context->bk;

        n = (USHORT) (k & 7);               /* advance to even byte boundary */
        DUMPBITS(n)

        /* get the stored block's length and maybe its complement */
        NEEDBITS(16)
        n = (unsigned) (b & 0xffff);        /* get length */
        DUMPBITS(16)

#ifdef LARGE_STORED_BLOCKS
        NEEDBITS(16)

        if (n != (~b & 0xFFFFL))            /* compare with complement */
        {
#ifdef CK_DEBUG
printf("Stored complement doesn't match\n");
#endif
            return(1);                      /* if complement doesn't jive */
        }
        DUMPBITS(16)
#endif

        /* bit buffer should be empty now, since we just ate at least 3 bytes */

        if (context->get_error || k)        /* if bit buffer isn't empty */
        {
            return(1);                      /* this code assumes it is */
        }

        context->bk = 0;                    /* "restore" (empty) global bit buffer */
        context->bb = 0;

        source = &context->inbuf[context->inptr];

        context->inptr += n;                /* advance source pointer too */
    }

    /* read and output the compressed data */
    /* circumvent the bit buffer for speed */

#ifdef DISPLAY_DECO
    printf("%5ld %5ld: stored %u\n",(unsigned long) context->inptr,
            (unsigned long) (context->outbuffer - context->outstart),n);
#endif

    /* The entire stored block fits into the buffer, move it through */
    if (n <= context->outleft)
    {
        context->outleft -= n;
        memcpy(context->outbuffer, source, n);
        context->outbuffer += n;
    }
    /* The buffer will not hold the entire stored block, fill buffer and set checkpoint */
    else
    {
        memcpy(context->outbuffer, source, context->outleft);
        context->outbuffer += context->outleft;

        context->IncrementalState = sSTORE;
        context->sstoreNBytes = n - context->outleft;
        context->sstorePointer = source + context->outleft;
        context->outleft = 0;
    }

    return 0;                               /* no error */
}

/* --- InflateBlock() ----------------------------------------------------- */

/* on exit: lastBlock set indicates last block was processed */

static int NEAR InflateBlock(PMSZIP_DECOMPRESS_CONTEXT context)
{
    int blockType;          /* block type */
    int rc;                 /* result code */
    ULONG b;                /* local bit buffer */
    unsigned k;             /* local number of bits in bit buffer */

    b = context->bb;                        /* get global buffer */
    k = context->bk;

    NEEDBITS(1)
    context->lastBlock = MASK1(b);          /* get last block bit 0,1 */
    DUMPBITS(1)

    NEEDBITS(2)
    blockType = MASK2(b);                   /* get block type 0,1,2 */
    DUMPBITS(2)

    context->bb = b;                        /* update global buffer */
    context->bk = k;

    if (context->get_error)
    {
        return(1);
    }

    switch (blockType)
    {
    case STORED:                            /* stored block */
        rc = InflateStored(context,FALSE);
        break;

    case FIXED:                             /* fixed tree block */
        rc = InflateFixed(context);
        break;

    case DYNAMIC:                           /* dynamic tree block */
        rc = InflateDynamic(context);
        break;

    default:                                /* bad block type */
        rc = 2;
    }

    return(rc);
}

/* --- NFM_Prepare() ------------------------------------------------------ */

/* NFM_Prepare is used to initialize the decompressor for a new buffer. */
/* All pointers are reset. */

int NFM_Prepare(void FAR *ctx, BYTE FAR *bfSrc, UINT cbSrc, BYTE FAR *bfDest,
        UINT cbDest)
{
    PMSZIP_DECOMPRESS_CONTEXT context = ctx;

#ifndef DRVSPACE
    if ((bfSrc[0] != NFM_SIG0) || (bfSrc[1] != NFM_SIG1))
    {
        return NFMinvalid;                  /* if block signature missing */
    }

    context->inbuf = bfSrc + NFM_SIG_LEN;   /* toss signature */
    context->insize = cbSrc - NFM_SIG_LEN;
#else
    context->inbuf = bfSrc;                 /* no internal signature */
    context->insize = cbSrc;
#endif

    context->inptr = 0;

    /* initialize window, bit buffer */
    context->bk = 0;
    context->bb = 0;

    context->outstart = context->outbuffer = bfDest;
    context->bufavail = cbDest;             /* space available in buffer */

    context->lastBlock = 0;
    context->get_error = 0;                 /* reset error indicators */

    context->IncrementalState = sNEWBLOCK;  /* always start at beginning of block */

    return NFMsuccess;
}


/* --- NFM_Decompress() --------------------------------------------------- */
/*
    NFM_Decompress is used to decompress data.  The buffers (input and output)
    must have been set up with NFM_Prepare.
*/
int NFM_Decompress(void FAR *ctx, UINT FAR *pcbDestCount)
{
    PMSZIP_DECOMPRESS_CONTEXT context = ctx;
    int rc;                     /* return code */
    unsigned firstoutleft;      /* space left in buffer when we begin */

    context->outleft = *pcbDestCount;

    /* avoid over-running the output buffer if too much data requested */
    if (context->outleft > context->bufavail)
    {
        context->outleft = context->bufavail;
    }

    firstoutleft = context->outleft;

    if (context->outleft > 0)
    {
        switch (context->IncrementalState)
        {
        case sNEWBLOCK:         /* Starting fresh, no work left over */
            break;

        case sSTORE:            /* resume previous STORE operation */
            InflateStored(context,TRUE);
            break;

        case sHUFFTREE:         /* resume previous TREE operation */
            InflateCodes(context, context->streeTL, context->streeTD,
                    context->streeBL, context->streeBD, TRUE);
            break;

        case sDONE:             /* No data left, return OK, 0 bytes */
            *pcbDestCount = 0;
            return NFMsuccess;

        default:                /* Impossible condition */
            return NFMinvalid;
        }

        /* decompress until the last block or we finish request */
        while ((!context->lastBlock) && (context->outleft > 0))
        {
            rc = InflateBlock(context);

            if (rc != 0)
            {
                if (rc == 3)
                {
                    return NFMoutofmem;     /* if ran out internally */
                }
                else
                {
                    return NFMinvalid;      /* if bad input data */
                }
            }
        }
    }

    /* return actual output count */
    *pcbDestCount = (USHORT) (firstoutleft - context->outleft);

    return NFMsuccess;                      /* return to caller */
}

/* --- NFMdeco_create() --------------------------------------------------- */

void FAR *NFMdeco_create(PFNALLOC NFMalloc)
{
    PMSZIP_DECOMPRESS_CONTEXT p;
    static int fixed_init = 0;

    p = NFMalloc(sizeof(MSZIP_DECOMPRESS_CONTEXT));

    if (p != NULL)
    {
        memset(p,0,sizeof(MSZIP_DECOMPRESS_CONTEXT));

        /* initialize members */

        /* initialize fixed decoding trees */

        if (fixed_init == 0)
        {
            InitFixed();

            fixed_init = 1;
        }
    }

    return(p);
}

/* --- NFMdeco_destroy() -------------------------------------------------- */

void NFMdeco_destroy(void FAR *ctx,PFNFREE NFMfree)
{
    NFMfree(ctx);
}

/* --- DisplayTree() ------------------------------------------------------ */

#ifdef  DISPLAY

static void NEAR DisplayTree(HUFF_TREE *tree)
{
    static int depth = -1;      /* not multi-context safe */
    int tab;
    int element;
    BYTE e,b;

    depth++;            /* recursion depth controls indentation */

    for (element = 0; element < NNodes; element++)
    {
        for (tab = 0; tab < depth; tab++)
        {
            printf("    ");
        }
        printf("%3d: ",element);

        e = tree[element].e;
        b = tree[element].b;

        if (e < 14)
        {
            printf("extra bits=%u, b=%u, n=%u\n",e,b,tree[element].v.n);
        }
        else if (e == 15)
        {
            printf("<end of block>\n");
        }
        else if (e == 16)
        {
            printf("literal %02X",tree[element].v.n);
            if ((tree[element].v.n >= ' ') && (tree[element].v.n <= '~'))
            {
                printf("  '%c'",tree[element].v.n);
            }
            printf("\n");
        }
        else if ((e > 16) && (e < 32))
        {
            printf("sub table codes %d bit(s), b=%d\n",(e-16),b);
#ifdef POINTERS
            DisplayTree(tree[element].v.t);  /* recurse */
#else
            DisplayTree(tree + (tree[element].v.t));  /* recurse */
#endif
        }
        else if (e == 99)
        {
            printf("<unused code>\n");
        }
        else
        {
            printf("<illegal code e=%d>\n",e);
        }
    }

    depth--;        /* handle display formatting */
}

#endif

/* ------------------------------------------------------------------------ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xblob.cpp ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xblob.cpp
//
//  Description:    Implement XBinaryData class.
//
//  History:
//      01/13/98    CongpaY     Created
//
//**************************************************************************

#include "precomp.h"

////////////////////////////////////////////////////////////////////////////
//
//  Implemenat XBlobData class
//
////////////////////////////////////////////////////////////////////////////

XBlobData::XBlobData(DWORD dwOffset, LPCSTR szMimeType, DWORD cbSize)
  : m_dwOffset(dwOffset),
    m_szMimeType(szMimeType),
    m_cbSize(cbSize)
{
}

////////////////////////////////////////////////////////////////////////////
//
//  Implemenat XBinaryData class
//
////////////////////////////////////////////////////////////////////////////

XBinaryData::XBinaryData(LPCSTR szName, REFGUID id, XBlobData *pBlobData,
                         XStreamRead *pStream)
  : XObject(szName, id),
    m_szMimeType((LPCSTR)pBlobData->m_szMimeType),
    m_pvData(NULL),
    m_cbSize(pBlobData->m_cbSize),
    m_cbRead(0),
    m_pStream(pStream),
    m_dwOffset(pBlobData->m_dwOffset)
{
}

XBinaryData::XBinaryData(LPCSTR szName, REFGUID id, LPCSTR mimeType,
                         LPVOID data, DWORD cbSize)
  : XObject(szName, id),
    m_szMimeType(mimeType),
    m_pvData(data),
    m_cbSize(cbSize),
    m_cbRead(0),
    m_pStream(NULL),
    m_dwOffset(0)
{
}

XBinaryData::~XBinaryData()
{
    if (m_pStream && m_pvData)
        XFree(m_pvData);
}

HRESULT XBinaryData::Save(XStreamWrite *pStream)
{
    DPF_ERR("Save is not supported.");
    return D3DERR_INVALIDCALL;
}

STDMETHODIMP
XBinaryData::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr;

    ASSERT(ppvObj != NULL);

    *ppvObj = NULL;

    if (riid == IID_IUnknown || riid == IID_IDirectXFileBinary) {
        *ppvObj = (LPVOID)this;
        AddRef();
        hr = S_OK;
    } else {
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP
XBinaryData::GetSize(DWORD *pcbSize)
{
    ASSERT(pcbSize != NULL);

    *pcbSize = m_cbSize;

    return DXFILE_OK;
}

STDMETHODIMP
XBinaryData::GetMimeType(LPCSTR *pszMimeType)
{
    ASSERT(pszMimeType);

    *pszMimeType = m_szMimeType;

    return DXFILE_OK;
}

STDMETHODIMP
XBinaryData::Read(LPVOID pvData, DWORD cbSize, LPDWORD pcbRead)
{
    HRESULT hr;

    ASSERT(pvData != NULL && pcbRead != NULL);

    if (m_cbRead >= m_cbSize) {
        return DXFILEERR_NOMOREDATA;
    }

    if (cbSize > m_cbSize - m_cbRead)
        cbSize = m_cbSize - m_cbRead;

    if (m_pvData) {
        memcpy(pvData, (LPBYTE)m_pvData + m_cbRead, cbSize);

        m_cbRead += cbSize;
        *pcbRead = cbSize;

        hr = DXFILE_OK;

    } else {
        hr = m_pStream->Read(pvData, m_dwOffset + m_cbRead, cbSize, pcbRead);

        if (SUCCEEDED(hr))
            m_cbRead += *pcbRead;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xdata.cpp ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xdata.cpp
//
//  Description:    Implement data object classes.
//
//  History:
//      01/10/98    CongpaY     Created
//
//**************************************************************************

#include "precomp.h"

////////////////////////////////////////////////////////////////////////////
//
//  Implemenat XDataObj class.
//
////////////////////////////////////////////////////////////////////////////

XDataObj::XDataObj(XTemplate *pTemplate, LPCSTR szName, REFGUID id,
                   DWORD cbSize, LPVOID pData)
  : XObject(szName, id),
    m_pTemplate(pTemplate),
    m_plChildren(NULL),
    m_plDataPart(NULL),
    m_cbSize(0),
    m_pData(NULL)
{
    if (cbSize && XMalloc(&m_pData, cbSize) == DXFILE_OK) {
        memcpy(m_pData, pData, cbSize);
        m_cbSize = cbSize;
    }
}

XDataObj::XDataObj(XTemplate *pTemplate, LPCSTR szName, REFGUID id,
                   XDataPartList *plDataPart)
  : XObject(szName, id),
    m_pTemplate(pTemplate),
    m_plChildren(NULL),
    m_plDataPart(plDataPart),
    m_cbSize(0),
    m_pData(NULL)
{
}

HRESULT XDataObj::Create(REFGUID idType, LPCSTR szName, REFGUID id,
                         DWORD cbSize, LPVOID pData, XDataObj **ppObj)
{
    if (!cbSize && pData || cbSize && !pData)
        return DXFILEERR_BADVALUE;

    XTemplate *pTemplate;

    if (!XTemplateList::Find(idType, &pTemplate))
        return DXFILEERR_BADVALUE;

    *ppObj = new XDataObj(pTemplate, szName, id, cbSize, pData);

    if (!*ppObj)
        return DXFILEERR_BADALLOC;

    return DXFILE_OK;
}

XDataObj *
XDataObj::Create(LPCSTR szType, LPCSTR szName, REFGUID id, XDataPartList *plDataPart)
{
    XDataObj *pDataObj;
    XTemplate *pTemplate;

    if (!XTemplateList::Find(szType, &pTemplate)) {
        DPF(("Unknown object type %s.", szType));
        return NULL;
    }

    if (!plDataPart && pTemplate->ml()) {
        DPF(("No data for %s object.", szType));
        return NULL;
    }

    pDataObj = new XDataObj(pTemplate, szName, id, plDataPart);

    if (!pDataObj)
        return NULL;

    if(pDataObj->ProcessDataPartList() != DXFILE_OK) {
        DPF(("Bad data list for %s data object.", szType));
        pDataObj->Release();
        return NULL;
    }

    return pDataObj;
}

XDataObj::~XDataObj()
{
    if (m_plDataPart)
        delete m_plDataPart;

    if (m_pData)
        XFree(m_pData);

    if (m_plChildren)
        delete m_plChildren;
}

HRESULT XDataObj::ProcessDataPartList()
{
    HRESULT hr = DXFILE_OK;

    m_cbSize = 0;
    m_pData = NULL;

    if (!m_plDataPart)
        return hr;

    for (DWORD i = 0; i < m_plDataPart->count(); i++)
        (*m_plDataPart)[i]->ProcessSelf(this);

    if (SUCCEEDED(hr) && m_pTemplate->NeedRepack()) {
        LPVOID pMData, pData = m_pData;
        DWORD cbSize;

        hr = m_pTemplate->ModulateData(&pData, &cbSize, &pMData);

        if (SUCCEEDED(hr)) {
            XFree(m_pData);
            m_cbSize = cbSize;
            m_pData = pMData;
        }
    }

    return hr;
}

BOOL XDataObj::Allow(LPCSTR szType)
{
    if (m_pTemplate->IsOpen())
        return TRUE;

    XTemplateOptionList *plOptions = m_pTemplate->ol();

    if (plOptions) {
        for (DWORD i = 0; i < plOptions->count(); i++) {
            if (!xstricmp((*plOptions)[i]->name(), szType))
                return TRUE;
        }
    }

    return FALSE;
}

HRESULT XDataObj::AddChild(XObject *pChild)
{
    if (!m_plChildren) {
        m_plChildren = new XObjectList();

        if (!m_plChildren)
            return DXFILEERR_BADALLOC;
    }

    if (m_plChildren->Add(pChild) < 0)
        return DXFILEERR_BADALLOC;

    pChild->AddRef();

    return DXFILE_OK;
}

HRESULT XDataObj::AddData(LPVOID pData, DWORD cbData)
{
    HRESULT hr;

    if ((hr = XRealloc(&m_pData, m_cbSize + cbData)) != DXFILE_OK)
        return hr;

    memcpy((LPVOID)(((char *)m_pData) + m_cbSize), pData, cbData);

    m_cbSize += cbData;

    return DXFILE_OK;
}

XDataObj *XDataObj::FindDataObj(LPCSTR szName)
{
    if (name() && !xstrcmp(name(), szName))
        return this;

    if (m_plChildren) {
        for (DWORD i = 0; i < m_plChildren->count(); i++) {
            XDataObj *pObj;

            if (pObj = (*m_plChildren)[i]->FindDataObj(szName))
                return pObj;
        }
    }

    return NULL;
}

XDataObj *XDataObj::FindDataObj(REFGUID idSrc)
{
    if (id() == idSrc)
        return this;

    if (m_plChildren) {
        for (DWORD i = 0; i < m_plChildren->count(); i++) {
            XDataObj *pObj;

            if (pObj = (*m_plChildren)[i]->FindDataObj(idSrc))
                return pObj;
        }
    }

    return NULL;
}

STDMETHODIMP
XDataObj::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr;

    ASSERT(ppvObj != NULL);

    *ppvObj = NULL;

    if (riid == IID_IUnknown || riid == IID_IDirectXFileData) {
        *ppvObj = (LPVOID)this;
        AddRef();
        hr = S_OK;
    } else {
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP
XDataObj::GetData(const CHAR *szMember, DWORD *pcbSize, void **ppvData)
{
    HRESULT hr;

    ASSERT(pcbSize != NULL && ppvData != NULL);

    if (szMember) {
        hr = m_pTemplate->GetSubData(m_pData, szMember, pcbSize, ppvData);
    } else {
        *pcbSize = m_cbSize;
        *ppvData = m_pData;
        hr = DXFILE_OK;
    }

    return hr;
}

STDMETHODIMP
XDataObj::GetType(const CLSID ** type)
{
    HRESULT hr;

    ASSERT(type != NULL);

    *type = NULL;

    if (m_pTemplate) {
        *type = &(m_pTemplate->id());
        hr = DXFILE_OK;
    } else {
        *type = NULL;
        hr = DXFILEERR_BADOBJECT;
    }

    return hr;
}

STDMETHODIMP
XDataObj::GetNextObject(IDirectXFileObject **ppObj)
{
    HRESULT hr;

    if (!ppObj) {
        return DXFILEERR_BADVALUE;
    }

    if (m_plChildren && m_iChild < m_plChildren->count()) {
        *ppObj = (IDirectXFileObject *)(*m_plChildren)[m_iChild];
        (*ppObj)->AddRef();
        m_iChild++;
        hr = DXFILE_OK;
    } else {
        *ppObj = NULL;
        hr = DXFILEERR_NOMOREOBJECTS;
    }

    return hr;
}

STDMETHODIMP
XDataObj::AddDataObject(IDirectXFileData *pChild)
{
    HRESULT hr;

    if (!pChild) {
        return DXFILEERR_BADVALUE;
    }

    if (!m_plChildren) {
        m_iChild = 0;
        m_plChildren = new XObjectList();
    }

    XDataObj *pDataObj = (XDataObj *)pChild;
    XObject *pObj = pDataObj;

    if (m_plChildren && m_plChildren->Add(pObj)) {
        pObj->AddRef();
        hr = DXFILE_OK;
    } else {
        hr = DXFILEERR_BADALLOC;
    }

    return hr;
}

STDMETHODIMP
XDataObj::AddDataReference(LPCSTR name, const GUID *uuid)
{
    HRESULT hr;

    if ((!name || !*name) && (!uuid || *uuid == GUID_NULL)) {
        DPF_ERR("No name or uuid specified.");
        return DXFILEERR_BADVALUE;
    }

    if (!m_plChildren) {
        m_iChild = 0;
        m_plChildren = new XObjectList();
    }

    XDataRef *pDataRef = new XDataRef(name, uuid? *uuid : GUID_NULL, 0);
    XObject *pObj = pDataRef;

    if (m_plChildren && pObj && m_plChildren->Add(pObj)) {
        hr = DXFILE_OK;
    } else {
        hr = DXFILEERR_BADALLOC;
    }

    return hr;
}

STDMETHODIMP
XDataObj::AddBinaryObject(LPCSTR name, const GUID *uuid,
                          LPCSTR mimeType, LPVOID data, DWORD cbSize)
{
    HRESULT hr;

    if (!data || !cbSize) {
        return DXFILEERR_BADVALUE;
    }

    if (!m_plChildren) {
        m_iChild = 0;
        m_plChildren = new XObjectList();
    }

    XBinaryData *pBinaryObj;

    pBinaryObj = new XBinaryData(name, uuid? *uuid : GUID_NULL,
                                 mimeType, data, cbSize);

    XObject *pObj = pBinaryObj;

    if (m_plChildren && pObj && m_plChildren->Add(pObj)) {
        hr = DXFILE_OK;
    } else {
        hr = DXFILEERR_BADALLOC;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////
//
//  Implemenat XDataRef class
//
////////////////////////////////////////////////////////////////////////////

XDataRef::XDataRef(LPCSTR szRef, REFGUID idRef, XStreamRead *pStream)
  : XObject(NULL, GUID_NULL),
    m_szRef(szRef),
    m_idRef(idRef),
    m_pStream(pStream)
{
}


STDMETHODIMP
XDataRef::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr;

    ASSERT(ppvObj != NULL);

    *ppvObj = NULL;

    if (riid == IID_IUnknown || riid == IID_IDirectXFileDataReference) {
        *ppvObj = (LPVOID)this;
        AddRef();
        hr = S_OK;
    } else {
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP
XDataRef::Resolve(IDirectXFileData **ppDataObj)
{
    HRESULT hr;

    ASSERT(ppDataObj != NULL);

    *ppDataObj = NULL;

    XDataObj *pObj;

    if (m_szRef) {
        if (m_idRef == GUID_NULL)
            hr = m_pStream->GetObjectByName(m_szRef, &pObj);
        else
            hr = m_pStream->GetObjectByNameAndId(m_szRef, m_idRef, &pObj);
    } else if (m_idRef != GUID_NULL)
        hr = m_pStream->GetObjectById(m_idRef, &pObj);
    else
        hr = DXFILEERR_BADOBJECT;

    if (hr == DXFILE_OK) {
        pObj->ResetChildIndex();
        *ppDataObj = pObj;
    }

    return hr;
}

STDMETHODIMP_(ULONG)
stringList::Release()
{
    for (DWORD i = 0; i < count(); i++)
        XFree((LPVOID)(*this)[i]);

    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\nfmdeco.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1993,1994,1995,1996
 *  All Rights Reserved.
 *
 *  NFMDECO.H -- features of NFMDECO.C, the NF decompressor
 *
 *  History:
 *      13-Feb-1994     msliger     revised type names, ie, UINT16 -> UINT.
 *                                  normalized MCI_MEMORY type.
 *      24-Feb-1994     msliger     Changed MDI_MEMORY to MI_MEMORY.
 *      22-Mar-1994     msliger     Changed !INT32 to BIT16.
 *                                  Changed interface USHORT -> UINT.
 *      06-Apr-1994     msliger     Defined UNALIGNED for RISC.
 *      13-Apr-1994     msliger     Defined call convention for alloc/free.
 *      12-May-1994     msliger     ifdef'd 1's complement LARGE_STORED_BLOCKS.
 *      15-Nov-1994     msliger     No longer needs alloc/free.
 *      25-May-1995     msliger     Dropped NFMuncompress, added NFM_Prepare()
 *                                  and NFM_Decompress().
 *      12-Jun-1995     msliger     Found cases to increase MAX_GROWTH.
 *      06-Nov-1996     msliger     Added support for multiple contexts.
 */

/* --- types -------------------------------------------------------------- */

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif

#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
typedef unsigned char  BYTE;
#endif

#ifndef _UINT_DEFINED
#define _UINT_DEFINED
typedef unsigned int UINT;
#endif

#ifndef _ULONG_DEFINED
#define _ULONG_DEFINED
typedef unsigned long  ULONG;
#endif

#ifndef FAR
#ifdef BIT16
#define FAR far
#else
#define FAR
#endif
#endif

#ifndef HUGE
#ifdef BIT16
#define HUGE huge
#else
#define HUGE
#endif
#endif

#ifndef UNALIGNED
#ifdef  NEEDS_ALIGNMENT
#define UNALIGNED __unaligned
#else   /* !NEEDS_ALIGNMENT */
#define UNALIGNED
#endif  /* NEEDS_ALIGNMENT */
#endif  /* UNALIGNED */

#ifndef _MI_MEMORY_DEFINED
#define _MI_MEMORY_DEFINED
typedef void HUGE *  MI_MEMORY;
#endif

/***    PFNALLOC - Memory allocation function for MCI
 *
 *  Entry:
 *      cb - Size in bytes of memory block to allocate
 *
 *  Exit-Success:
 *      Returns !NULL pointer to memory block
 *
 *  Exit-Failure:
 *      Returns NULL; insufficient memory
 */
#ifndef _PFNALLOC_DEFINED
#define _PFNALLOC_DEFINED
typedef MI_MEMORY (_cdecl FAR DIAMONDAPI *PFNALLOC)(ULONG cb);       /* pfnma */
#endif


/***    PFNFREE - Free memory function for MCI
 *
 *  Entry:
 *      pv - Memory block allocated by matching PFNALLOC function
 *
 *  Exit:
 *      Memory block freed.
 */
#ifndef _PFNFREE_DEFINED
#define _PFNFREE_DEFINED
typedef void (_cdecl FAR DIAMONDAPI *PFNFREE)(MI_MEMORY pv);          /* pfnmf */
#endif

/* --- prototypes --------------------------------------------------------- */

extern int NFM_Prepare(void FAR *ctx, BYTE FAR *bfSrc, UINT cbSrc,
        BYTE FAR *bfDest, UINT cbDest);

extern int NFM_Decompress(void FAR *ctx, UINT FAR *pcbDestCount);

extern void *NFMdeco_create(PFNALLOC NFMalloc);

extern void NFMdeco_destroy(void FAR *ctx, PFNFREE NFMfree);

/* --- constants ---------------------------------------------------------- */

/* return codes */

#define     NFMsuccess      0       /* successful completion */
#define     NFMdestsmall    1       /* destination buffer is too small */
#define     NFMoutofmem     2       /* alloc returned an error (NULL) */
#define     NFMinvalid      3       /* source buffer contains bad data */


#ifdef LARGE_STORED_BLOCKS
#define     MAX_GROWTH      12      /* maximum growth of a block */
#else
#define     MAX_GROWTH      8       /* maximum growth of a block */
#endif

/* ----------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xblob.h ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xblob.h
//
//  Description:    Blob data related classes header file.
//
//  History:
//      01/13/98    CongpaY     Created
//
//**************************************************************************

#ifndef _XBLOB_H_
#define _XBLOB_H_

class XString;
class XData;
class XObject;
class XStreamRead;
class XStreamWrite;

////////////////////////////////////////////////////////////////////////////
//
//  XBlobData: Binary data object's data.
//
////////////////////////////////////////////////////////////////////////////

class XBlobData
{
public:
    DWORD   m_dwOffset;
    XString m_szMimeType;
    DWORD   m_cbSize;

    XBlobData(DWORD dwOffset, LPCSTR szMimeType, DWORD cbSize);
};

////////////////////////////////////////////////////////////////////////////
//
//  XBinaryData: Binary data object.
//
////////////////////////////////////////////////////////////////////////////

class XBinaryData : public IDirectXFileBinary,
                    public XObject
{
    XString m_szMimeType;
    LPVOID m_pvData;
    DWORD m_cbSize;
    DWORD m_cbRead;
    XStreamRead *m_pStream;
    DWORD m_dwOffset;

public:
    XBinaryData(LPCSTR szName, REFGUID id, XBlobData *pBlobData,
                XStreamRead *pStream);

    XBinaryData(LPCSTR szName, REFGUID id, LPCSTR mimeType,
                LPVOID data, DWORD cbSize);

    virtual ~XBinaryData();

    virtual BOOL ValidChild(XDataObj *pParent) { return pParent->AllowBinaryData(); }
    virtual HRESULT Save(XStreamWrite *pStream);

// Interfaces.

    STDMETHOD(QueryInterface) (REFIID iid, LPVOID FAR *lplpv);
    STDMETHOD_(ULONG, AddRef) () { return XObject::AddRef(); }
    STDMETHOD_(ULONG, Release) () { return XObject::Release(); }
    STDMETHOD(GetName) (LPSTR szName, LPDWORD pdwSize) { return XObject::GetName(szName, pdwSize); }
    STDMETHOD(GetId) (LPGUID pId) { return XObject::GetId(pId); }
    STDMETHOD(GetSize) (DWORD *);
    STDMETHOD(GetMimeType) (LPCSTR *);
    STDMETHOD(Read) (LPVOID, DWORD, LPDWORD);
};

#endif // _XBLOB_H_

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xfactory.cpp ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xclsfac.cpp
//
//  Description:    Implement IClassFactory interface.
//
//  History:
//      04/23/98    CongpaY     Created
//
//**************************************************************************

#include "precomp.h"
#include "xfactory.h"

static long g_cServerLocks = 0;
extern long g_cInstances;

STDMETHODIMP
XFactory::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr;

    ASSERT(ppvObj != NULL);

	{
        *ppvObj = NULL;

        if (riid == IID_IUnknown || riid == IID_IClassFactory) {
            *ppvObj = this;
            m_cRef++;
            hr = S_OK;
        } else {
            hr = E_NOINTERFACE;
        }
    }

    return hr;
}

STDMETHODIMP_(ULONG)
XFactory::AddRef()
{
    m_cRef++;

    return m_cRef;

}

STDMETHODIMP_(ULONG)
XFactory::Release()
{
    ULONG cRef;

    cRef = --m_cRef;

    if (!cRef)
        delete this;

    return cRef;
}

STDMETHODIMP
XFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObj)
{
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

#if 0
    if (!VALID_OUT_PTR(ppvObj))
        return E_INVALIDARG;
#endif 0

    HRESULT hr;
    LPDIRECTXFILE pDXFile;

    if (FAILED(hr = DirectXFileCreate(&pDXFile)))
        return hr;

    hr = pDXFile->QueryInterface(riid, ppvObj);

    pDXFile->Release();

    return hr;
}

STDMETHODIMP
XFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cServerLocks);
    else
        InterlockedDecrement(&g_cServerLocks);

    return S_OK;
}

STDAPI
DllGetClassObject(REFCLSID rclsid,
                  REFIID riid,
                  LPVOID *ppvObj)
{
    ASSERT(ppvObj != NULL);

    *ppvObj = NULL;

    if (rclsid != CLSID_CDirectXFile)
        return CLASS_E_CLASSNOTAVAILABLE;

    XFactory *pFactory = new XFactory;

    if (!pFactory)
        return E_OUTOFMEMORY;

    HRESULT hr;

    hr = pFactory->QueryInterface(riid, ppvObj);

    pFactory->Release();

    return hr;
}

STDAPI
DllCanUnloadNow()
{
    HRESULT hr;

    if (!g_cInstances && !g_cServerLocks)
        hr = S_OK;
    else
        hr = S_FALSE;

    return hr;
}

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xguid.c ===
#define INITGUID
#include <xtl.h>
#include "dxfile.h"

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xfactory.h ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xfactory.h
//
//  Description:    XFactory class header file.
//
//  History:
//      04/22/98    CongpaY     Created
//
//**************************************************************************

#ifndef _XFACTORY_H_
#define _XFACTORY_H_

////////////////////////////////////////////////////////////////////////////
//
//  XFactory: IClassFactory impl class.
//
////////////////////////////////////////////////////////////////////////////

class XFactory : public IClassFactory
{
private:
    ULONG m_cRef;

public:
    XFactory() : m_cRef(1) {}

    STDMETHOD(QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

    STDMETHOD(CreateInstance) (LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppv);
    STDMETHOD(LockServer) (BOOL fLock);
};

#endif // _XFACTORY_H_

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xdata.h ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xdata.h
//
//  Description:    Data object classes header file.
//
//  History:
//      01/10/98    CongpaY     Created
//
//**************************************************************************

#ifndef _XDATA_H_
#define _XDATA_H_

class XTemplate;
class XStreamWrite;
class XStreamRead;

#define INTEGER_LIST_CHUNK_SIZE     10
#define FLOAT_LIST_CHUNK_SIZE       250
#define STRING_LIST_CHUNK_SIZE      10
#define XOBJECT_LIST_CHUNK_SIZE     10

typedef XObjPtrArray<XObject, XOBJECT_LIST_CHUNK_SIZE> XObjectList;

////////////////////////////////////////////////////////////////////////////
//
//  XDataObj: Data objects with real data.
//
////////////////////////////////////////////////////////////////////////////

class XDataObj : public IDirectXFileData,
                 public XObject
{
    XTemplate      *m_pTemplate;
    XDataObj       *m_pParent;      // This object's parent.
    XObjectList    *m_plChildren;   // Optional data objects.
    DWORD           m_iChild;       // Current child index in the list.
    XDataPartList  *m_plDataPart;   // data part list.
    DWORD           m_cbSize;       // number of bytes m_pData points to.
    LPVOID          m_pData;        // pointer to the chunk of data.

    XDataObj(XTemplate *pTemplate, LPCSTR szName, REFGUID id,
             DWORD cbSize, LPVOID pData);

    XDataObj(XTemplate *pTemplate, LPCSTR szName, REFGUID id,
             XDataPartList *plDataPart);

    HRESULT ProcessDataPartList();

public:
    static HRESULT Create(REFGUID idType,
                          LPCSTR szName,
                          REFGUID id,
                          DWORD cbSize,
                          LPVOID pData,
                          XDataObj **ppObj);

    static XDataObj *Create(LPCSTR szType,
                            LPCSTR szName,
                            REFGUID id,
                            XDataPartList *plDataPart);

    virtual ~XDataObj();

    virtual XDataObj *FindDataObj(LPCSTR szName);
    virtual XDataObj *FindDataObj(REFGUID id);
    virtual BOOL ValidChild(XDataObj *pParent) { return pParent->Allow(m_pTemplate->name()); }

    BOOL Allow(LPCSTR szType);
    BOOL AllowDataRef() { return !m_pTemplate->IsClosed(); }
    BOOL AllowBinaryData() { return Allow(SZBINARY); }
    HRESULT AddChild(XObject *pChild);
    HRESULT AddData(LPVOID pData, DWORD cbData);
    void ResetChildIndex() { m_iChild = 0; }

// Interface methods.

    STDMETHOD(QueryInterface) (REFIID iid, LPVOID FAR *lplpv);
    STDMETHOD_(ULONG, AddRef) () { return XObject::AddRef(); }
    STDMETHOD_(ULONG, Release) () { return XObject::Release(); }
    STDMETHOD(GetName) (LPSTR szName, LPDWORD pdwSize) { return XObject::GetName(szName, pdwSize); }
    STDMETHOD(GetId) (LPGUID pId) { return XObject::GetId(pId); }
    STDMETHOD(GetData) (const CHAR *, DWORD *, void **);
    STDMETHOD(GetType) (const CLSID **);
    STDMETHOD(GetNextObject) (interface IDirectXFileObject **);
    STDMETHOD(AddDataObject) (interface IDirectXFileData *);
    STDMETHOD(AddDataReference) (LPCSTR, const GUID *);
    STDMETHOD(AddBinaryObject) (LPCSTR, const GUID *, LPCSTR, LPVOID, DWORD);
};

////////////////////////////////////////////////////////////////////////////
//
//  XDataRef: Data that reference to other data objects.
//
////////////////////////////////////////////////////////////////////////////

class XDataRef : public IDirectXFileDataReference,
                 public XObject
{
    const XString  m_szRef;
    const GUID     m_idRef;
    XStreamRead   *m_pStream;

public:
    XDataRef(LPCSTR szRef, REFGUID idRef, XStreamRead *pStream);

    virtual BOOL ValidChild(XDataObj *pParent) { return pParent->AllowDataRef(); }

// Interface methods.

    STDMETHOD(QueryInterface) (REFIID iid, LPVOID FAR *lplpv);
    STDMETHOD_(ULONG, AddRef) () { return XObject::AddRef(); }
    STDMETHOD_(ULONG, Release) () { return XObject::Release(); }
    STDMETHOD(GetName) (LPSTR szName, LPDWORD pdwSize) { return XObject::GetName(szName, pdwSize); }
    STDMETHOD(GetId) (LPGUID pId) { return XObject::GetId(pId); }
    STDMETHOD(Resolve) (IDirectXFileData **);
};

////////////////////////////////////////////////////////////////////////////
//
//  XDataArray: Template class for integerList, floatList and stringList.
//
////////////////////////////////////////////////////////////////////////////

typedef DWORD  stgInt;
typedef float  stgFlt;

template<class T>
class XSizedData {
public:
    DWORD count;
    T *data;
};

typedef XSizedData<stgInt> integerListBinData;
typedef XSizedData<stgFlt> floatListBinData;

template<class T, DWORD cChunk>
class XDataArray : public XArray<T, cChunk>, public XDataPart
{
public:
    XDataArray() : XArray<T, cChunk>() {}

    XDataArray(const XSizedData<T> &src)
      : XArray<T, cChunk>(src.count, src.data) {}

    STDMETHOD_(ULONG, Release) () { delete this; return 0; }
    virtual HRESULT ProcessSelf(XDataObj *pParent) { return pParent->AddData((LPVOID)list(), count()*sizeof(T)); }
};

typedef XDataArray<stgInt, INTEGER_LIST_CHUNK_SIZE> integerList;

typedef XDataArray<stgFlt, FLOAT_LIST_CHUNK_SIZE> floatList;

class stringList : public XDataArray<LPCSTR, STRING_LIST_CHUNK_SIZE>
{
    STDMETHOD_(ULONG, Release) ();
};

#endif // _XDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xheader.h ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xheader.h
//
//  Description:    X file header definitions.
//
//  History:
//      02/03/98    congpay     Created
//
//**************************************************************************

#ifndef _XHEADER_H_
#define _XHEADER_H_

#define XFILE_MAGIC \
        ((long)'x' + ((long)'o' << 8) + ((long)'f' << 16) + ((long)' ' << 24))

#define XFILE_VERSION \
        ((long)'0' + ((long)'3' << 8) + ((long)'0' << 16) + ((long)'3' << 24))

#define XFILE_VERSION_DX3 \
        ((long)'0' + ((long)'3' << 8) + ((long)'0' << 16) + ((long)'2' << 24))

#define XFILE_VERSION_TEXT "0303"

#define XFILE_FORMAT_BINARY \
        ((long)'b' + ((long)'i' << 8) + ((long)'n' << 16) + ((long)' ' << 24))

#define XFILE_FORMAT_TEXT   \
        ((long)'t' + ((long)'x' << 8) + ((long)'t' << 16) + ((long)' ' << 24))

#define XFILE_FORMAT_TEXT_ZIP \
        ((long)'t' + ((long)'z' << 8) + ((long)'i' << 16) + ((long)'p' << 24))

#define XFILE_FORMAT_BINARY_ZIP \
        ((long)'b' + ((long)'z' << 8) + ((long)'i' << 16) + ((long)'p' << 24))

#define XFILE_FLOATSIZE_32 \
        ((long)'0' + ((long)'0' << 8) + ((long)'3' << 16) + ((long)'2' << 24))

#define XFILE_FLOATSIZE_32_TEXT "0032"

#define XFILE_FLOATSIZE_64 \
        ((long)'0' + ((long)'0' << 8) + ((long)'6' << 16) + ((long)'4' << 24))

#endif // _XHEADER_H_

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xlist.h ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xlist.h
//
//  Description:    list related classes header file.
//
//  History:
//      01/08/98    CongpaY     Created
//
//**************************************************************************

#ifndef _XLIST_H_
#define _XLIST_H_

template<class T, DWORD cChunk>
class XArray
{
    DWORD m_cUsed;
    DWORD m_cTotal;
    DWORD m_cChunk;

protected:
    T *m_pData;

public:
    XArray(DWORD count = 0, T *data = NULL)
      : m_cUsed(count),
        m_cTotal(count),
        m_cChunk(cChunk),
        m_pData(data) {}

    ~XArray() { XFree(m_pData); }

    const T &operator[](int i) const { return m_pData[i]; }

    const DWORD count() { return m_cUsed; }
    const T *list() { return m_pData; }

    int Add(T & tSrc)
    {
        if (m_cUsed == m_cTotal) {
            m_cTotal += m_cChunk;
            if (FAILED(XRealloc((void **)&m_pData, m_cTotal * sizeof(T))))
                return 0;
        }

        m_pData[m_cUsed] = tSrc;
        return ++m_cUsed;
    }
};

template<class T, DWORD cChunk>
class XPtrArray : public XArray<T *, cChunk>
{
public:
    ~XPtrArray()
    {
        if (m_pData) {
            for (DWORD i = 0; i < count(); i++)
                delete m_pData[i];
        }
    }

};

template<class T, DWORD cChunk>
class XObjPtrArray : public XArray<T *, cChunk>
{
public:
    ~XObjPtrArray()
    {
        if (m_pData) {
            for (DWORD i = 0; i < count(); i++)
                m_pData[i]->Release();
        }
    }
};

#endif // _XLIST_H_

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xmemory.cpp ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xmemory.cpp
//
//  Description:    Implement memory alloc/free functions.
//
//  History:
//      03/02/98    CongpaY     Created
//
//**************************************************************************

#include "precomp.h"

#if !defined(DBG)

    #undef DPF_MODNAME
    #define DPF_MODNAME "XMalloc"
    
    HRESULT XMalloc(void** ppvOut, size_t size)
    {
        if (!(*ppvOut = MemAlloc(size))) {
            DPF_ERR("XMalloc failed");
            return DXFILEERR_BADALLOC;
        }
    
        return DXFILE_OK;
    }
    
    #undef DPF_MODNAME
    #define DPF_MODNAME "XRealloc"
    
    HRESULT XRealloc(void** ppvInOut, size_t size)
    {
        void *p = *ppvInOut;
    
        if (p == NULL)
            return XMalloc(ppvInOut, size);
    
        if (!(*ppvInOut = MemReAlloc(p, size))) {
            DPF_ERR("XRealloc failed");
            return DXFILEERR_BADALLOC;
        }
    
        return DXFILE_OK;
    }
    
    #undef DPF_MODNAME
    #define DPF_MODNAME "XFree"
    
    void XFree(void *p)
    {
        MemFree(p);
    }

#else
    
    #define ALLOCATED_STAMP 0xfedcba98
    #define FREED_STAMP     0xf00df00d
    
    struct MemorySignature {
        ULONG ulSize;             
        ULONG ulSignature2;
        ULONG ulSignature3;
        ULONG ulSignature4;
    };
    
    #undef DPF_MODNAME
    #define DPF_MODNAME "XMalloc"
    
    HRESULT XMalloc(void** ppvOut, size_t size)
    {
        void* p = NULL;
        MemorySignature* pHeader = (MemorySignature*) MemAlloc(size + 2*sizeof(MemorySignature));
    
        if (pHeader)
        {
            p = (VOID*) (pHeader + 1);
    
            // The trailer signature may very well be unaligned, but do I look
            // like I care?
            
            MemorySignature* pTrailer = (MemorySignature*) ((BYTE*) p + size);
    
            pHeader->ulSize = size;
            pHeader->ulSignature2 = ALLOCATED_STAMP;
            pHeader->ulSignature3 = ALLOCATED_STAMP;
            pHeader->ulSignature4 = ALLOCATED_STAMP;
    
            pTrailer->ulSize = size;
            pTrailer->ulSignature2 = ALLOCATED_STAMP;
            pTrailer->ulSignature3 = ALLOCATED_STAMP;
            pTrailer->ulSignature4 = ALLOCATED_STAMP;
        }
    
        *ppvOut = p;
    
        return (p != NULL) ? DXFILE_OK : DXFILEERR_BADALLOC;
    }
    
    #undef DPF_MODNAME
    #define DPF_MODNAME "XRealloc"
    
    HRESULT XRealloc(void** ppvInOut, size_t size)
    {
        void *pOld = *ppvInOut;
        void *pNew;
    
        if (pOld == NULL)
            return XMalloc(ppvInOut, size);
    
        if (SUCCEEDED(XMalloc(&pNew, size)))
        {
            memcpy(pNew, pOld, ((MemorySignature *)pOld - 1)->ulSize);

            XFree(pOld);
            *ppvInOut = pNew;
            return DXFILE_OK;
        }
    
        DPF_ERR("XRealloc failed");
        return DXFILEERR_BADALLOC;
    }
    
    #undef DPF_MODNAME
    #define DPF_MODNAME "XFree"
    
    void XFree(void *p)
    {
        if (p != NULL)
        {
            MemorySignature* pHeader = ((MemorySignature*) p) - 1;
            ASSERT(pHeader->ulSignature2 == ALLOCATED_STAMP);
            ASSERT(pHeader->ulSignature3 == ALLOCATED_STAMP);
            ASSERT(pHeader->ulSignature4 == ALLOCATED_STAMP);
    
            MemorySignature* pTrailer = (MemorySignature*) ((BYTE*) p + pHeader->ulSize);
            ASSERT(pHeader->ulSize == pTrailer->ulSize);
            ASSERT(pTrailer->ulSignature2 == ALLOCATED_STAMP);
            ASSERT(pTrailer->ulSignature3 == ALLOCATED_STAMP);
            ASSERT(pTrailer->ulSignature4 == ALLOCATED_STAMP);
    
            pHeader->ulSize = 0;
            pHeader->ulSignature2 = FREED_STAMP;
            pHeader->ulSignature3 = FREED_STAMP;
            pHeader->ulSignature4 = FREED_STAMP;
    
            pTrailer->ulSize = 0;
            pTrailer->ulSignature2 = FREED_STAMP;
            pTrailer->ulSignature3 = FREED_STAMP;
            pTrailer->ulSignature4 = FREED_STAMP;
        
            MemFree(pHeader);
        }
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\ximplapi.h ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   ximplapi.h
//
//  Description:    api interface implementation classes.
//
//  History:
//      01/13/98    CongpaY     Created
//
//**************************************************************************

#ifndef _XIMPLAPI_H_
#define _XIMPLAPI_H_

////////////////////////////////////////////////////////////////////////////
//
//  XDirctXFile: Implement IDirectXFile interface.
//
////////////////////////////////////////////////////////////////////////////

class XDirectXFile : public IDirectXFile {
private:
    ULONG m_cRef;

public:
    XDirectXFile() { m_cRef = 1; }

    STDMETHOD(QueryInterface) (REFIID iid, LPVOID FAR *lplpv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

    STDMETHOD(CreateEnumObject) (LPVOID, DWORD, IDirectXFileEnumObject **);

    STDMETHOD(CreateSaveObject) (LPCSTR, DWORD, IDirectXFileSaveObject **);

    STDMETHOD(RegisterTemplates) (LPVOID, DWORD);
};

////////////////////////////////////////////////////////////////////////////
//
//  XEnumObject: Implement IDirectXFileEnumObject interface.
//
////////////////////////////////////////////////////////////////////////////

class XEnumObject : public IDirectXFileEnumObject {
private:
    ULONG m_cRef;
    XStreamRead *m_pStream;

public:
    XEnumObject(XStreamRead *pStream)
      : m_pStream(pStream), m_cRef(1) {}

    STDMETHOD(QueryInterface) (REFIID iid, LPVOID FAR *lplpv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();
    STDMETHOD(GetNextDataObject) (IDirectXFileData **);
    STDMETHOD(GetDataObjectById) (REFGUID, IDirectXFileData **);
    STDMETHOD(GetDataObjectByName) (LPCSTR, IDirectXFileData **);
};


#endif // _XIMPLAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\ximplapi.cpp ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   ximplapi.cpp
//
//  Description:    Implement interface implementation classes.
//
//  History:
//      01/13/98    CongpaY     Created
//
//**************************************************************************

#include "precomp.h"

long g_cInstances = 0;

STDAPI
DirectXFileCreate(LPDIRECTXFILE *ppDXFile)
{
    HRESULT hr;

    ASSERT(ppDXFile != NULL);

    *ppDXFile = new XDirectXFile;

    if (*ppDXFile) {
        g_cInstances++;
        hr = DXFILE_OK;
    } else {
        hr = DXFILEERR_BADALLOC;
    }

    return hr;
}

STDMETHODIMP_(ULONG)
XDirectXFile::AddRef()
{
    m_cRef++;

    return m_cRef;
}

STDMETHODIMP_(ULONG)
XDirectXFile::Release()
{
    ULONG cRef;

    cRef = --m_cRef;

    if (!cRef) {
        delete this;
        g_cInstances--;
    }

    return cRef;
}

STDMETHODIMP
XDirectXFile::CreateEnumObject(LPVOID pvSource,
                              DWORD loadflags,
                              IDirectXFileEnumObject **ppEnumObj)
{
    HRESULT hr;

    ASSERT(ppEnumObj != NULL && pvSource != NULL);

    *ppEnumObj = 0;

    XStreamRead *pStream;

    hr = XStreamRead::Create(pvSource, loadflags, &pStream);

    if (hr == DXFILE_OK) {
        *ppEnumObj = new XEnumObject(pStream);

        if (!*ppEnumObj) {
            delete pStream;
            hr = DXFILEERR_BADALLOC;
        }
    }

    return hr;
}

STDMETHODIMP
XDirectXFile::CreateSaveObject(LPCSTR szFilename, DWORD format,
                              IDirectXFileSaveObject **ppSaveObj)
{
    DPF_ERR("Save is not supported.");
    return D3DERR_INVALIDCALL;
}

STDMETHODIMP
XDirectXFile::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr;

    ASSERT(ppvObj != NULL);

    *ppvObj = NULL;

    if (riid == IID_IUnknown || riid == IID_IDirectXFile) {
        *ppvObj = (LPVOID)this;
        AddRef();
        hr = S_OK;
    } else {
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP
XDirectXFile::RegisterTemplates(LPVOID data, DWORD cbSize)
{
    if (!data || !cbSize) {
        return DXFILEERR_BADVALUE;
    }

    XStreamRead *pStream;

    DXFILELOADMEMORY mData;
    mData.lpMemory = data;
    mData.dSize = cbSize;

    HRESULT hr = XStreamRead::Create(&mData, DXFILELOAD_FROMMEMORY, &pStream);

    if (hr == DXFILE_OK) {
        XDataObj *obj;

        hr = pStream->GetNextObject(&obj); // Parse the templates.

        if (hr == DXFILEERR_NOMOREOBJECTS)
            hr = DXFILE_OK;

        delete pStream;
    }

    return hr;
}

STDMETHODIMP
XEnumObject::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr;

    ASSERT(ppvObj != NULL);

    *ppvObj = NULL;

    if (riid == IID_IUnknown || riid == IID_IDirectXFileEnumObject) {
        *ppvObj = (LPVOID)this;
        AddRef();
        hr = S_OK;
    } else {
        hr = E_NOINTERFACE;
    }

    return hr;

}

STDMETHODIMP_(ULONG)
XEnumObject::AddRef()
{
    m_cRef++;

    return m_cRef;
}

STDMETHODIMP_(ULONG)
XEnumObject::Release()
{
    ULONG cRef;

    cRef = --m_cRef;

    if (!cRef) {
        delete m_pStream;
        delete this;
    }

    return cRef;
}

STDMETHODIMP
XEnumObject::GetNextDataObject(IDirectXFileData **ppObj)
{
    HRESULT hr;

    ASSERT(ppObj != NULL);

    *ppObj = NULL;

    XDataObj *pObj;

    hr = m_pStream->GetNextObject(&pObj);

    if (SUCCEEDED(hr)) {
        pObj->AddRef();
        *ppObj = pObj;
    }

    return hr;
}

STDMETHODIMP
XEnumObject::GetDataObjectById(REFGUID id, IDirectXFileData **ppObj)
{
    HRESULT hr;

    ASSERT(ppObj != NULL);

    *ppObj = NULL;

    XDataObj *pObj;

    hr = m_pStream->GetObjectById(id, &pObj);

    if (SUCCEEDED(hr))
        *ppObj = pObj;

    return hr;
}

STDMETHODIMP
XEnumObject::GetDataObjectByName(LPCSTR name, IDirectXFileData **ppObj)
{
    HRESULT hr;

    ASSERT(ppObj != NULL);

    *ppObj = NULL;

    XDataObj *pObj;

    hr = m_pStream->GetObjectByName(name, &pObj);

    if (SUCCEEDED(hr))
        *ppObj = pObj;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xmemory.h ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xmemory.h
//
//  Description:    Memory alloc/free functions.
//
//  History:
//      02/03/98    congpay     Created
//
//**************************************************************************

#ifndef _XMEMORY_H_
#define _XMEMORY_H_

HRESULT XMalloc(void ** p_out, size_t size);
HRESULT XRealloc(void** p_inout, size_t size);
void    XFree(void *p);

#if defined(__cplusplus)

    static __forceinline void* operator new(size_t size)
    {
        void *p;
        XMalloc(&p, size);
        return p;
    }
    
    static __forceinline void operator delete(void* p)
    {
        XFree(p);
    }

#endif

#endif // _XMEMORY_H_

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xobject.cpp ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xobject.cpp
//
//  Description:    Implement XObject class.
//
//  History:
//      01/14/98    CongpaY     Created
//
//**************************************************************************

#include "precomp.h"

STDMETHODIMP_(ULONG)
XObject::AddRef()
{
    m_cRef++;

    return m_cRef;
}

STDMETHODIMP_(ULONG)
XObject::Release()
{
    ULONG cRef;

    cRef = --m_cRef;

    if (!cRef)
        delete this;

    return cRef;
}

#undef DPF_MODNAME
#define DPF_MODNAME "XObject::GetName"

STDMETHODIMP
XObject::GetName(LPSTR szName, LPDWORD pdwSize)
{
    ASSERT(pdwSize != NULL);

    if (!m_szName) {
        if (*pdwSize > 0 && szName)
            *szName = 0;
        *pdwSize = 0;
    } else {
        DWORD dwSize;

        dwSize = xstrlen(m_szName) + 1;

        if (szName) {
            if (dwSize > *pdwSize) {
                DPF_ERR("szName buffer not big enough.");
                return DXFILEERR_BADVALUE;
            }

            memcpy(szName, m_szName, dwSize * sizeof(CHAR));
        }

        *pdwSize = dwSize;
    }

    return DXFILE_OK;
}

STDMETHODIMP
XObject::GetId(LPGUID pId)
{
    ASSERT(pId != NULL);

    memcpy(pId, &m_id, sizeof(GUID));

    return DXFILE_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "XObject::ProcessSelf"

HRESULT XObject::ProcessSelf(XDataObj *pParent)
{
    HRESULT hr;

    if (ValidChild(pParent))
        hr = pParent->AddChild(this);
    else {
        DPF_ERR("Invalid child object existed.");
        hr = DXFILEERR_BADOBJECT;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xparse.cpp ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)

/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
 *
 *  File: xparse.y
 *
 *  Content:
 *
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   04/19/96   v-paulf This header added
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#undef XOFDEBUG

#include "precomp.h"

#define YYPREFIX "yy"
#define YYDEBUG 0

CHAR *Strdup(const CHAR *s)
{
    CHAR *d = NULL;

    if (s) {
        int n = (strlen(s) + 1) * sizeof(CHAR);

        if (SUCCEEDED(XMalloc((void **) &d, n)))
            memcpy(d, s, n);
        else
            DPF_ERR("Failed to allocate space for string");
    }

    return d;
}

static int yylex_ascii(XStreamRead *pStream);
static int yylex_binary(XStreamRead *pStream);

typedef union {
        stgInt              stgInt;
        stgFlt              stgFlt;
        GUID                guid;
        char*               string;
        XObject*            xobject;
        XDataPart*          xdatapart;
        XDataRef*           xdataref;
        XDataPartList*      xdatapartList;
        integerList*        intList;
        integerListBinData  intListBinData;
        floatList*          fltList;
        floatListBinData    fltListBinData;
        stringList*         strList;
        XTemplate*          xtemplate;
        XDimension*         elementSize;
        XDimensionList*     dimList;
        XIdentifier*        idInf;
        XTemplateOptionList* toList;
        XTemplateMember*    templMember;
        XTemplateMemberList* tmList;
        XTemplateInfo*      templInfo;
        XBlobData*          binaryData;
} YYSTYPE;
#define YT_END_OF_FILE 0
#define YT_YIELD 0
#define YT_ERROR 255
#define YT_NAME 1
#define YT_STRING 2
#define YT_INTEGER 3
#define YT_REALNUM 4
#define YT_GUID 5
#define YT_INTEGER_LIST 6
#define YT_REALNUM_LIST 7
#define YT_BINARY_DATA 254
#define YT_OBRACE 10
#define YT_CBRACE 11
#define YT_OPAREN 12
#define YT_CPAREN 13
#define YT_OBRACKET 14
#define YT_CBRACKET 15
#define YT_OANGLE 16
#define YT_CANGLE 17
#define YT_DOT 18
#define YT_COMMA 19
#define YT_SEMICOLON 20
#define YT_OBJECT 30
#define YT_TEMPLATE 31
#define YT_WORD 40
#define YT_DWORD 41
#define YT_FLOAT 42
#define YT_DOUBLE 43
#define YT_CHAR 44
#define YT_UCHAR 45
#define YT_SWORD 46
#define YT_SDWORD 47
#define YT_VOID 48
#define YT_LPSTR 49
#define YT_UNICODE 50
#define YT_CSTRING 51
#define YT_ARRAY 52
#define YT_ULONGLONG 53
#define YT_BINARY 54
#define YT_BINARY_RESOURCE 55
#define YYERRCODE 256
short yylhs[] = {                                        -1,
    0,    0,   36,   36,   18,   18,   20,   20,   20,   19,
   19,   19,   19,   19,   19,   35,   35,   26,   26,   25,
   25,   21,   21,   21,   33,   33,   32,   32,   34,   34,
   23,    6,    6,    7,   29,   29,   27,   28,   28,   22,
    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
    5,    5,    5,   17,   24,    4,    4,    8,    3,    3,
    1,    2,    9,    9,   11,   10,   10,   12,   12,   14,
   13,   13,   15,   16,   16,   31,   31,   30,   38,   38,
   39,   39,   37,   37,   40,
};
short yylen[] = {                                         2,
    0,    1,    1,    2,    6,    6,    0,    1,    2,    1,
    6,    1,    1,    1,    6,    4,    1,    0,    1,    1,
    2,    1,    1,    1,    3,    1,    1,    2,    3,    2,
    5,    1,    1,    1,    1,    2,    3,    1,    1,    3,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    5,    3,    1,    1,    1,    0,    1,
    1,    1,    2,    1,    1,    1,    3,    2,    1,    1,
    1,    3,    2,    1,    3,    0,    1,    1,    1,    2,
    1,    2,    0,    1,    1,
};
short yydefred[] = {                                      0,
   61,    0,   41,   42,   43,   44,   45,   46,   47,   48,
   49,   50,   51,   52,   53,    0,   56,    0,   57,    3,
    0,   58,    0,   60,    0,    4,    0,    0,   78,    0,
   77,    0,    0,    0,    0,   20,   22,   23,   24,    0,
    0,    0,   62,   66,   71,   65,   70,    0,   74,    0,
   12,    0,   64,   13,    0,   69,   14,    0,   10,    8,
    0,   33,   32,    0,    0,    0,   21,    0,    6,    0,
    0,    0,   79,   81,    0,    0,    0,    0,    5,    9,
   34,    0,   55,   40,    0,    0,    0,    0,    0,   27,
    0,    0,    0,   67,   85,   82,   80,   84,   72,   75,
    0,   35,    0,    0,   30,    0,   28,   16,    0,    0,
    0,   38,   39,    0,   31,   36,   25,   29,    0,   54,
    0,   37,   15,   11,
};
short yydgoto[] = {                                      16,
   17,   49,   25,   50,   19,   64,   82,   23,   51,   52,
   53,   54,   55,   56,   57,   58,   59,   20,   60,   61,
   36,   37,   38,   39,   40,   41,  102,  114,  103,   31,
   32,   88,   89,   90,   42,   21,   97,   75,   76,   98,
};
short yysindex[] = {                                    310,
    0,   14,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   14,    0,    0,
  310,    0,   15,    0,   41,    0,   49,   49,    0,  325,
    0,  209,  344,   14,   14,    0,    0,    0,    0,  325,
   46,   54,    0,    0,    0,    0,    0,    4,    0,   14,
    0,   44,    0,    0,   44,    0,    0,   44,    0,    0,
   68,    0,    0,   14,   47,   53,    0,    1,    0,   14,
   49,   70,    0,    0,   78,   57,   79,   80,    0,    0,
    0,   71,    0,    0,   66,   72,   49,    5,   83,    0,
   49,   72,   49,    0,    0,    0,    0,    0,    0,    0,
    9,    0,   16,   76,    0,   72,    0,    0,   84,   89,
  209,    0,    0,   87,    0,    0,    0,    0, -153,    0,
   86,    0,    0,    0,
};
short yyrindex[] = {                                    103,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   94,    0,    0,
  105,    0,    0,    0,    0,    0,    0,  140,    0,   92,
    0,   96,    0,  100,  100,    0,    0,    0,    0,   39,
    0,    0,    0,    0,    0,    0,    0,   30,    0,   94,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   32,
   28,    0,    0,    0,  224,  155,  278,  293,    0,    0,
    0,    0,    0,    0,    0,    3,    2,  101,    0,    0,
  112,  113,  140,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    3,    0,    0,    0,    0,
   96,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,
};
short yygindex[] = {                                      0,
   -2,   56,  -26,   13,   12,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  104,  -60,   27,
  108,    0,    0,    0,    0,    0,   42,    0,    0,  122,
  -64,    0,    0,   64,    0,    0,  -66,  -44,    0,    0,
};
#define YYTABLESIZE 398
short yytable[] = {                                      22,
   80,    1,   76,   83,    1,    1,   92,   65,   66,    1,
   77,  112,   18,   78,    1,   24,   76,   83,   85,  105,
   76,   71,  106,   72,   27,  110,  109,   34,  111,  101,
   62,   24,   24,   18,   59,  115,   59,   34,   76,  118,
   59,   35,   59,   91,   63,   24,   76,   24,   59,   17,
   28,   35,   19,   29,   86,   76,   83,   70,   86,   68,
   80,   81,   73,   74,   69,   87,   83,   24,    1,   43,
   44,   45,   84,   46,   47,   95,   96,   48,   79,   93,
   94,   43,   99,  104,  101,   87,    1,   43,   44,   45,
   95,   46,   47,  117,  119,   48,  124,  108,  113,  120,
  123,  122,    1,   59,    2,   18,    7,    3,    4,    5,
    6,    7,    8,    9,   10,   26,   11,   12,   13,   59,
   14,   15,   76,   83,   26,    3,    4,    5,    6,    7,
    8,    9,   10,  100,   11,   12,   13,  121,   14,   15,
   76,   76,   76,   76,  116,   76,   76,   67,   30,   76,
   76,  107,    0,    0,    0,   83,   83,   83,   83,    0,
   83,   83,    0,    0,   83,   83,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   76,
   76,   76,   76,   76,   76,   76,   76,    0,   76,   76,
   76,    0,   76,   76,   83,   83,   83,   83,   83,   83,
   83,   83,    0,   83,   83,   83,    0,   83,   83,    1,
   43,   44,   45,    0,   46,   47,    0,    0,   48,    0,
    0,    0,    0,    0,   63,   63,    0,   63,    0,   63,
   63,    0,    0,   63,   63,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    3,    4,
    5,    6,    7,    8,    9,   10,    0,   11,   12,   13,
    0,   14,   15,   63,   63,   63,   63,   63,   63,   63,
   63,    0,   63,   63,   63,    0,   63,   63,   68,   68,
   68,    0,    0,   68,   68,    0,    0,   68,   68,    0,
    0,    0,    0,   73,    0,   73,   73,    0,   73,   73,
    0,    0,   73,   73,    0,    0,    0,    0,    0,    0,
    1,    0,    0,    0,    0,    0,    0,   68,   68,   68,
   68,   68,   68,   68,   68,    1,   68,   68,   68,    0,
   68,   68,   73,   73,   73,   73,   73,   73,   73,   73,
    2,   73,   73,   73,    1,   73,   73,    0,    0,    3,
    4,    5,    6,    7,    8,    9,   10,    0,   11,   12,
   13,    0,   14,   15,    3,    4,    5,    6,    7,    8,
    9,   10,    0,   11,   12,   13,   33,   14,   15,    0,
    0,    0,    0,    3,    4,    5,    6,    7,    8,    9,
   10,    0,   11,   12,   13,    0,   14,   15,
};
short yycheck[] = {                                       2,
   61,    1,    1,    1,    1,    1,   71,   34,   35,    1,
   55,    3,    0,   58,    1,   18,   15,   15,   18,   86,
   19,   48,   87,   50,   10,   92,   91,   30,   93,   14,
   33,   34,   35,   21,    5,   20,    5,   40,   11,  106,
   11,   30,   11,   70,   33,   48,   19,   50,   19,   11,
   10,   40,   14,    5,   54,   54,   54,   54,   54,   14,
  121,   64,   19,   20,   11,   68,   20,   70,    1,    2,
    3,    4,   20,    6,    7,   19,   20,   10,   11,   10,
    3,    2,    4,   18,   14,   88,    1,    2,    3,    4,
   19,    6,    7,   18,   11,   10,   11,   15,  101,   11,
  254,   15,    0,   10,    0,   14,   11,   40,   41,   42,
   43,   44,   45,   46,   47,   15,   49,   50,   51,   20,
   53,   54,   11,   11,   21,   40,   41,   42,   43,   44,
   45,   46,   47,   78,   49,   50,   51,  111,   53,   54,
    1,    2,    3,    4,  103,    6,    7,   40,   27,   10,
   11,   88,   -1,   -1,   -1,    1,    2,    3,    4,   -1,
    6,    7,   -1,   -1,   10,   11,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   40,
   41,   42,   43,   44,   45,   46,   47,   -1,   49,   50,
   51,   -1,   53,   54,   40,   41,   42,   43,   44,   45,
   46,   47,   -1,   49,   50,   51,   -1,   53,   54,    1,
    2,    3,    4,   -1,    6,    7,   -1,   -1,   10,   -1,
   -1,   -1,   -1,   -1,    1,    2,   -1,    4,   -1,    6,
    7,   -1,   -1,   10,   11,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   40,   41,
   42,   43,   44,   45,   46,   47,   -1,   49,   50,   51,
   -1,   53,   54,   40,   41,   42,   43,   44,   45,   46,
   47,   -1,   49,   50,   51,   -1,   53,   54,    1,    2,
    3,   -1,   -1,    6,    7,   -1,   -1,   10,   11,   -1,
   -1,   -1,   -1,    1,   -1,    3,    4,   -1,    6,    7,
   -1,   -1,   10,   11,   -1,   -1,   -1,   -1,   -1,   -1,
    1,   -1,   -1,   -1,   -1,   -1,   -1,   40,   41,   42,
   43,   44,   45,   46,   47,    1,   49,   50,   51,   -1,
   53,   54,   40,   41,   42,   43,   44,   45,   46,   47,
   31,   49,   50,   51,    1,   53,   54,   -1,   -1,   40,
   41,   42,   43,   44,   45,   46,   47,   -1,   49,   50,
   51,   -1,   53,   54,   40,   41,   42,   43,   44,   45,
   46,   47,   -1,   49,   50,   51,   52,   53,   54,   -1,
   -1,   -1,   -1,   40,   41,   42,   43,   44,   45,   46,
   47,   -1,   49,   50,   51,   -1,   53,   54,
};
#define YYFINAL 16
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 255
#if YYDEBUG
char *yyname[] = {
"end-of-file","YT_NAME","YT_STRING","YT_INTEGER","YT_REALNUM","YT_GUID",
"YT_INTEGER_LIST","YT_REALNUM_LIST",0,0,"YT_OBRACE","YT_CBRACE","YT_OPAREN",
"YT_CPAREN","YT_OBRACKET","YT_CBRACKET","YT_OANGLE","YT_CANGLE","YT_DOT",
"YT_COMMA","YT_SEMICOLON",0,0,0,0,0,0,0,0,0,"YT_OBJECT","YT_TEMPLATE",0,0,0,0,0,
0,0,0,"YT_WORD","YT_DWORD","YT_FLOAT","YT_DOUBLE","YT_CHAR","YT_UCHAR",
"YT_SWORD","YT_SDWORD","YT_VOID","YT_LPSTR","YT_UNICODE","YT_CSTRING",
"YT_ARRAY","YT_ULONGLONG","YT_BINARY","YT_BINARY_RESOURCE",0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"YT_BINARY_DATA",
"YT_ERROR",
};
char *yyrule[] = {
"$accept : file",
"file :",
"file : object_list",
"object_list : object",
"object_list : object_list object",
"object : identifier opt_name YT_OBRACE opt_clsid data_parts_list YT_CBRACE",
"object : YT_TEMPLATE template_name YT_OBRACE clsid template_parts YT_CBRACE",
"data_parts_list :",
"data_parts_list : data_part",
"data_parts_list : data_parts_list data_part",
"data_part : data_reference",
"data_part : identifier opt_name YT_OBRACE opt_clsid data_parts_list YT_CBRACE",
"data_part : number_list",
"data_part : float_list",
"data_part : string_list",
"data_part : YT_OBRACE YT_BINARY opt_name opt_clsid YT_CBRACE YT_BINARY_DATA",
"template_parts : template_members_part YT_OBRACKET template_option_info YT_CBRACKET",
"template_parts : template_members_list",
"template_members_part :",
"template_members_part : template_members_list",
"template_members_list : template_members",
"template_members_list : template_members_list template_members",
"template_members : primitive",
"template_members : array",
"template_members : template_reference",
"template_option_info : YT_DOT YT_DOT YT_DOT",
"template_option_info : template_option_list",
"template_option_list : template_option_part",
"template_option_list : template_option_list template_option_part",
"template_option_part : name opt_clsid opt_comma",
"template_option_part : YT_BINARY opt_comma",
"array : YT_ARRAY array_data_type array_name dimension_list YT_SEMICOLON",
"array_data_type : primitive_type",
"array_data_type : name",
"array_name : name",
"dimension_list : dimension",
"dimension_list : dimension_list dimension",
"dimension : YT_OBRACKET dimension_size YT_CBRACKET",
"dimension_size : YT_INTEGER",
"dimension_size : name",
"primitive : primitive_type opt_name YT_SEMICOLON",
"primitive_type : YT_WORD",
"primitive_type : YT_DWORD",
"primitive_type : YT_FLOAT",
"primitive_type : YT_DOUBLE",
"primitive_type : YT_CHAR",
"primitive_type : YT_UCHAR",
"primitive_type : YT_SWORD",
"primitive_type : YT_SDWORD",
"primitive_type : YT_LPSTR",
"primitive_type : YT_UNICODE",
"primitive_type : YT_CSTRING",
"primitive_type : YT_ULONGLONG",
"primitive_type : YT_BINARY",
"data_reference : YT_OBRACE opt_name opt_clsid opt_comma YT_CBRACE",
"template_reference : name opt_name YT_SEMICOLON",
"identifier : name",
"identifier : primitive_type",
"template_name : name",
"opt_name :",
"opt_name : name",
"name : YT_NAME",
"string : YT_STRING",
"number_list : number_list_1 list_separator",
"number_list : number_list_2",
"number_list_2 : YT_INTEGER_LIST",
"number_list_1 : YT_INTEGER",
"number_list_1 : number_list_1 list_separator YT_INTEGER",
"float_list : float_list_1 list_separator",
"float_list : float_list_2",
"float_list_2 : YT_REALNUM_LIST",
"float_list_1 : YT_REALNUM",
"float_list_1 : float_list_1 list_separator YT_REALNUM",
"string_list : string_list_1 list_separator",
"string_list_1 : string",
"string_list_1 : string_list_1 list_separator string",
"opt_clsid :",
"opt_clsid : clsid",
"clsid : YT_GUID",
"list_separator : YT_COMMA",
"list_separator : semicolon_list opt_comma",
"semicolon_list : YT_SEMICOLON",
"semicolon_list : semicolon_list YT_SEMICOLON",
"opt_comma :",
"opt_comma : comma",
"comma : YT_COMMA",
};
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short yyss[YYSTACKSIZE];
YYSTYPE yyvs[YYSTACKSIZE];
#define yystacksize YYSTACKSIZE

struct _keyword {
    char    *keyword;
    int  token;
} keywords[] = {
    { "TEMPLATE",       YT_TEMPLATE    },
    { "WORD",           YT_WORD        },
    { "DWORD",          YT_DWORD       },
    { "FLOAT",          YT_FLOAT       },
    { "DOUBLE",         YT_DOUBLE      },
    { "CHAR",           YT_CHAR        },
    { "UCHAR",          YT_UCHAR       },
    { "SWORD",          YT_SWORD       },
    { "SDWORD",         YT_SDWORD      },
    { "STRING",         YT_LPSTR       },
    { "UNICODE",        YT_UNICODE     },
    { "CSTRING",        YT_CSTRING     },
    { "ARRAY",          YT_ARRAY       },
    { "ULONGLONG",      YT_ULONGLONG   },
    { "BINARY",         YT_BINARY      },
    { "BINARY_RESOURCE", YT_BINARY_RESOURCE }
};
static const size_t numKeywords = sizeof(keywords)/sizeof(struct _keyword);


static XStreamRead *yypStream = NULL;

static int lineNum  = 1;
static int flagYield = FALSE;
static int flagEof = FALSE;
static int flagError = FALSE;

#define BUFSIZE 512
static  int  nInBuf = 0;
static  char buf[BUFSIZE];


#ifdef XOFDEBUG
static stgInt scanInt;
static stgFlt scanFlt;
static DWORD scanIntListLen;
static DWORD scanFltListLen;
static char *scanStr = NULL;
static int scanStrLine = 0;
static char scanGuid[37];

static char *tokText(int tok)
{
    static char buf[32];

    switch (tok) {
    case YT_END_OF_FILE:    sprintf(buf, "END_OF_FILE"); break;
    case YT_ERROR:      sprintf(buf, "ERROR");  break;

    case YT_OBRACE:     sprintf(buf, "OBRACE"); break;
    case YT_CBRACE:     sprintf(buf, "CBRACE"); break;
    case YT_OPAREN:     sprintf(buf, "OPAREN"); break;
    case YT_CPAREN:     sprintf(buf, "CPAREN"); break;
    case YT_OBRACKET:   sprintf(buf, "OBRACKET"); break;
    case YT_CBRACKET:   sprintf(buf, "CBRACKET"); break;
    case YT_OANGLE:     sprintf(buf, "OANGLE"); break;
    case YT_CANGLE:     sprintf(buf, "CANGLE"); break;
    case YT_DOT:        sprintf(buf, "DOT");    break;
    case YT_COMMA:      sprintf(buf, "COMMA");  break;
    case YT_SEMICOLON:  sprintf(buf, "SEMICOLON"); break;

    case YT_NAME:       sprintf(buf, "NAME (%s)", scanStr);     break;
    case YT_STRING:     sprintf(buf, "STRING (%s)",scanStr);    break;
    case YT_INTEGER:    sprintf(buf, "INTEGER (0x%x)",scanInt); break;
    case YT_REALNUM:    sprintf(buf, "FLOAT (%f)", scanFlt);    break;
    case YT_GUID:       sprintf(buf, "GUID (%s)", scanGuid); break;
    case YT_INTEGER_LIST: sprintf(buf, "INTEGER LIST (len=0x%x)",
                                  scanIntListLen); break;
    case YT_REALNUM_LIST: sprintf(buf, "FLOAT LIST (len=0x%x)",
                                  scanFltListLen); break;
    case YT_WORD:       sprintf(buf, "WORD");   break;
    case YT_DWORD:      sprintf(buf, "DWORD");  break;
    case YT_FLOAT:      sprintf(buf, "FLOAT");  break;
    case YT_DOUBLE:     sprintf(buf, "DOUBLE"); break;
    case YT_CHAR:       sprintf(buf, "CHAR");   break;
    case YT_UCHAR:      sprintf(buf, "UCHAR");  break;
    case YT_SWORD:      sprintf(buf, "SWORD");  break;
    case YT_SDWORD:     sprintf(buf, "SDWORD"); break;
    case YT_VOID:       sprintf(buf, "VOID");   break;
    case YT_LPSTR:      sprintf(buf, "LPSTR");  break;
    case YT_UNICODE:    sprintf(buf, "UNICODE"); break;
    case YT_CSTRING:    sprintf(buf, "CSTRING"); break;
    case YT_ARRAY:      sprintf(buf, "ARRAY");  break;
    case YT_ULONGLONG:  sprintf(buf, "ULONGLONG"); break;
    case YT_BINARY:         sprintf(buf, "BINARY"); break;
    case YT_BINARY_RESOURCE:sprintf(buf, "BINARY_RESOURCE"); break;

    case YT_TEMPLATE:   sprintf(buf, "TEMPLATE");  break;
    case YT_OBJECT:     sprintf(buf, "OBJECT"); break;
    default:            sprintf(buf, "UNKNOWN"); break;
    }
    return buf;
}
#endif /* XOFDEBUG */

int yyGetUuid()
{
    char ch;
    int rtrn = YT_ERROR;            /* Assume */
    char *p = buf;

    while (((ch = yypStream->GetByte()) != EOF) && (ch != '>') &&
           (ch == '-' || isxdigit(ch)))
        *p++ = ch;

    *p = '\0';
    if (ch == '>') {
        int   data4[8]; /* int, not char coz sscanf may overrun array */

        /* COUNT_GUID_SCANF_FIELDS = 11 */
        /* COUNT_GUID_STRING_LEN = 36 */

        if (strlen(buf) == 36 &&
            sscanf(buf, "%8x-%4x-%4x-%2x%2x-%2x%2x%2x%2x%2x%2x",
                   &yylval.guid.Data1, &yylval.guid.Data2,
                   &yylval.guid.Data3, &data4[0], &data4[1],
                   &data4[2], &data4[3], &data4[4], &data4[5],
                   &data4[6], &data4[7]) == 11) {
            yylval.guid.Data4[0] = (BYTE)data4[0];
            yylval.guid.Data4[1] = (BYTE)data4[1];
            yylval.guid.Data4[2] = (BYTE)data4[2];
            yylval.guid.Data4[3] = (BYTE)data4[3];
            yylval.guid.Data4[4] = (BYTE)data4[4];
            yylval.guid.Data4[5] = (BYTE)data4[5];
            yylval.guid.Data4[6] = (BYTE)data4[6];
            yylval.guid.Data4[7] = (BYTE)data4[7];
            rtrn = YT_GUID;
#ifdef XOFDEBUG
        {
            int i;
            for (i = 0; i < sizeof scanGuid; i++)
                scanGuid[i] = buf[i];
        }
#endif /* XOFDEBUG */

        }
    }
    return rtrn;
}

int yyGetString()
{
    char ch;

    nInBuf = 0;
    while (((ch = yypStream->GetByte()) != EOF) && (ch != '"')) {
        if (ch == '\\') {
            if ((ch = yypStream->GetByte())!= EOF) {
                if (ch == 'n')      ch = '\n';
                else if ( ch == 't' )   ch = '\t';
                else if ( ch == 'v' )   ch = '\v';
                else if ( ch == 'b' )   ch = '\b';
                else if ( ch == 'r' )   ch = '\r';
                else if ( ch == 'f' )   ch = '\f';
                else if ( ch == 'e' )   ch = '\033';
                else if ( ch == '0' ) {
                    int tmp, stop;
                    ch = stop = 0;
                    if (((tmp = yypStream->GetByte()) != EOF) &&
                        (isdigit(tmp)) && (tmp!='8') && (tmp!='9')) {
                      ch = (ch * 8) + (tmp - '0');
                    } else {
                        stop = 1;
                        yypStream->UngetByte();
                    }
                    if ((!stop) && ((tmp=yypStream->GetByte())!=EOF) &&
                        (isdigit(tmp)) && (tmp!='8') && (tmp!='9')) {
                        ch= (ch*8)+(tmp-'0');
                    }
                    else {
                        stop= 1;
                        yypStream->UngetByte();
                    }
                    if ((!stop) && ((tmp=yypStream->GetByte())!=EOF) &&
                        (isdigit(tmp)) && (tmp!='8') && (tmp!='9')) {
                        ch= (ch*8)+(tmp-'0');
                    }
                    else {
                        stop= 1;
                        yypStream->UngetByte();
                    }
                }
            }
            else return YT_ERROR;
        }

        if ( nInBuf < BUFSIZE-1 )
            buf[nInBuf++] = ch;
    }
    if ( ch == '"' ) {
        buf[nInBuf++] = '\0';
        yylval.string = Strdup(buf);
#ifdef XOFDEBUG
        scanStr = yylval.string;
        scanStrLine = lineNum;
#endif
        return YT_STRING;
    }
    return YT_ERROR;
}

int
yyGetName(char first)
{
    char ch;
    int i,found;
    int rtrn;

    rtrn = YT_NAME;
    buf[0] = first; nInBuf = 1;
    while (((ch = yypStream->GetByte())!= EOF) &&
            (isalnum(ch) || (ch == '_') || (ch == '-'))) {
        if (nInBuf < BUFSIZE - 1)
            buf[nInBuf++] = ch;
    }
    buf[nInBuf++] = '\0';
    found= 0;

    for (i=0;(!found)&&(i<(int)numKeywords);i++) {
        if (_stricmp(buf,keywords[i].keyword)==0) {
            rtrn = keywords[i].token;
            found= 1;
        }
    }

    if (rtrn != YT_BINARY_RESOURCE)
        yylval.string = Strdup(buf);
#ifdef XOFDEBUG
    scanStr = yylval.string;
    scanStrLine = lineNum;
#endif

    if ((ch != EOF) && (!isspace(ch)))
        yypStream->UngetByte();
    else if (ch == '\n')
        lineNum++;

    return rtrn;
}

int yyGetNumber(char c)
{
    int rtrn = YT_INTEGER;      /* Assume */

    char* p = buf;
    if (c == '-' || c == '+') {
        *p++ = c;
        c = yypStream->GetByte();
    }
    while (c != EOF && isdigit(c)) {
        *p++ = c;
        c = yypStream->GetByte();
    }
    if (c == '.') {
        *p++ = c;
        c = yypStream->GetByte();
        while (c != EOF && isdigit(c)) {
            *p++ = c;
            c = yypStream->GetByte();
        }
        if (c == 'e' || c == 'E') {
            *p++ = c;
            c = yypStream->GetByte();
            if (c == '+' || c == '-') {
                *p++ = c;
                c = yypStream->GetByte();
            }
            while (c != EOF && isdigit(c)) {
                *p++ = c;
                c = yypStream->GetByte();
            }
        }
        rtrn = YT_REALNUM;
    }
    if (c != EOF) yypStream->UngetByte();
    *p = '\0';
    if (rtrn == YT_REALNUM) {
        yylval.stgFlt = (stgFlt)atof(buf);
#ifdef XOFDEBUG
        scanFlt = yylval.stgFlt;
#endif
    } else if (rtrn == YT_INTEGER) {
        yylval.stgInt = (stgInt)atol(buf);
#ifdef XOFDEBUG
        scanInt = yylval.stgInt;
#endif
    }

    return rtrn;
}

int yyGetBinaryData(XStreamRead *pStream)
{
    XBlobData* bd;
    CHAR *mimeType = NULL;
    DWORD i;
    DWORD cbMimeSize;
    DWORD dwOffset;
    DWORD cbSize, dummy; /* XXXXXX DWORD -> ULONGLONG */

    yylval.binaryData = NULL;   /* Assume error */

    /*
     * Read binary blob header. Looks like this:
     * 64-bit offset to real data in resource section
     * 64-bit size field
     * 16-bit length of following mime type string field
     * Mime type stored as ascii. Length specified by previous field
     */

    if (!pStream->ReadDword(&dwOffset))
        return YT_END_OF_FILE;

    /* XXXXXX Ignore high part of offset until ULONGLONG supported... */
    if (!pStream->ReadDword(&dummy))
        return YT_END_OF_FILE;

    if (!pStream->ReadDword(&cbSize))
        return YT_END_OF_FILE;

    /* XXXXXX Ignore high part of size until ULONGLONG supported... */
    if (!pStream->ReadDword(&dummy))
        return YT_END_OF_FILE;

    cbMimeSize = pStream->ReadWord();
    if (cbMimeSize == EOF)
        return YT_END_OF_FILE;

    if (cbMimeSize) {
        if (XMalloc((void **) &mimeType, (cbMimeSize + 1) * sizeof(WCHAR)) != DXFILE_OK)
            return YT_ERROR;

        /* Read the mime type string */
        for (i = 0; i < cbMimeSize; i++) {
            int byte;

            if ((byte = pStream->GetByte()) == EOF)
                return YT_END_OF_FILE;
            mimeType[i] = byte & 0xff;
        }
        mimeType[i] = '\0';
    }

    bd = new XBlobData(dwOffset, mimeType, cbSize);

    if (mimeType)
        XFree(mimeType);

    if (!bd)
        return YT_ERROR;

    yylval.binaryData = bd;

    return YT_BINARY_DATA;
}

int yylex()
{
    int token;

    if (flagError) {
        flagError = FALSE;
        return YT_ERROR;
    }

    if (flagYield) {
        flagEof = flagYield = FALSE;        /* Reset flags */
        return YT_YIELD;
    }

    if (yypStream->mode() == FM_Binary)
        token =  yylex_binary(yypStream);
    else if (yypStream->mode() == FM_Text)
        token = yylex_ascii(yypStream);
    else {
        DPF_ERR("Unknown file mode");
        token = YT_ERROR;
    }

#ifdef XOFDEBUG 
    //DPF(8,"scan: %s\n", tokText(token));
#endif

    if ( token == YT_BINARY_RESOURCE ) {
        flagEof = TRUE;
        token = YT_END_OF_FILE;
    }
    return token;
}

static int yylex_binary(XStreamRead *pStream)
{
    int   token;
    DWORD i, len;

    token = pStream->ReadWord();

    switch (token) {
    case YT_OBRACE:
    case YT_CBRACE:
    case YT_OPAREN:
    case YT_CPAREN:
    case YT_OBRACKET:
    case YT_CBRACKET:
    case YT_DOT:
    case YT_COMMA:
    case YT_SEMICOLON:
        break;

    case YT_TEMPLATE:
    case YT_WORD:
    case YT_DWORD:
    case YT_FLOAT:
    case YT_DOUBLE:
    case YT_CHAR:
    case YT_UCHAR:
    case YT_SWORD:
    case YT_SDWORD:
    case YT_LPSTR:
    case YT_UNICODE:
    case YT_CSTRING:
    case YT_ARRAY:
    case YT_ULONGLONG:
    case YT_BINARY:
        /* The parser expects to find the string in yylval.string... */
        for (i = 0; i < (int)numKeywords; i++) {
            if (token == keywords[i].token) { /* Should _always_ find a match */
                yylval.string = Strdup(keywords[i].keyword);
#ifdef XOFDEBUG
                scanStr = yylval.string;
#endif
                break;
            }
        }
        break;

    case YT_BINARY_RESOURCE:
        break;

    case YT_NAME:
    case YT_STRING:
    /* Names and strings are the same thing apart from the token... */
    {
        char *p;

        /* Length follows the token... */
        if (!pStream->ReadDword(&len)) {
            DPF_ERR("Unexpected EOF");
            return YT_ERROR;      /* Premature EOF */
        }

        for (p = buf, i = 0; i < len; i++) {
            char ch;

            if ((ch = pStream->GetByte()) == EOF) {
                DPF_ERR("Unexpected EOF");
                return YT_ERROR;        /* Premature EOF */
            }
            if (i < BUFSIZE - 1)  /* Don't overrun buffer */
                *p++ = ch;
        }
        *p = '\0';
        yylval.string = Strdup(buf);
#ifdef XOFDEBUG
        scanStr = yylval.string;
#endif
      }
      break;

    case YT_INTEGER_LIST:
    {
        stgInt *data;

        /* Length follows the token... */
        if (!pStream->ReadDword(&len)) {
            DPF_ERR("Unexpected EOF");
            return YT_ERROR;
        } else if (len == 0) {
            DPF_ERR("Zero-length integer list");
            return YT_ERROR;
        }
        if ((XMalloc((void **) &data, len * sizeof(stgInt))) != DXFILE_OK)
            return YT_ERROR;      /* Hmm, out of memory really */

        for(i = 0; i < len; i++) {
            DWORD val;

            if (!pStream->ReadDword(&val)) {
                DPF_ERR("Unexpected EOF");
                return YT_ERROR;
            }
            data[i] = (stgInt)val;
        }
        yylval.intListBinData.data = data;
        yylval.intListBinData.count = len;
#ifdef XOFDEBUG
        scanIntListLen = len;
#endif
    }
    break;

    case YT_REALNUM_LIST:
    {
        stgFlt *data;

        /* Length follows the token... */
        if (!pStream->ReadDword(&len)) {
            DPF_ERR("Unexpected EOF");
            return YT_ERROR;
        } else if (len == 0) {
            DPF_ERR("Zero-length float list");
            return YT_ERROR;
        }
        if ((XMalloc((void **) &data, len * sizeof(stgFlt))) != DXFILE_OK)
            return YT_ERROR;      /* Hmm, out of memory really */

        /*
         * The # of bits used to represent float values is stored in
         * the file header. Check it so we know how much to read now...
         */
        if (pStream->floatSize() == sizeof(FLOAT)) {
            for(i = 0; i < len; i++) {
                float val;

                if (!pStream->ReadFloat(&val)) {
                    DPF_ERR("Unexpected EOF");
                    return YT_ERROR;
                }
                data[i] = (stgFlt)val;
            }
        } else {
            for(i = 0; i < len; i++) {
                double val;

                if (!pStream->ReadDouble(&val)) {
                    DPF_ERR("Unexpected EOF");
                    return YT_ERROR;
                }
                data[i] = (stgFlt)val;
            }
        }
        yylval.fltListBinData.data = data;
        yylval.fltListBinData.count = len;
#ifdef XOFDEBUG
        scanFltListLen = len;
#endif
      }
      break;

    case YT_INTEGER:
    {
        DWORD val;

        if (!pStream->ReadDword(&val)) {
            DPF_ERR("Unexpected EOF");
            return YT_ERROR;
        }
        yylval.stgInt = (stgInt)val;
#ifdef XOFDEBUG
        scanInt = yylval.stgInt;
#endif
    }
    break;

    case YT_REALNUM:
        if (pStream->floatSize() == sizeof(FLOAT)) {
            float val;

            if (!pStream->ReadFloat(&val)) {
                DPF_ERR("Unexpected EOF");
                return YT_ERROR;
            }
            yylval.stgFlt = (stgFlt)val;
#ifdef XOFDEBUG
            scanFlt = yylval.stgFlt;
#endif
        } else {
            double val;

            if (!pStream->ReadDouble(&val)) {
                DPF_ERR("Unexpected EOF");
                return YT_ERROR;
            }
            yylval.stgFlt = (stgFlt)val;
#ifdef XOFDEBUG
            scanFlt = yylval.stgFlt;
#endif
        }
        break;

    case YT_GUID:
        pStream->ReadDword(&(yylval.guid.Data1));
        yylval.guid.Data2 = (unsigned short)pStream->ReadWord();
        yylval.guid.Data3 = (unsigned short)pStream->ReadWord();
        for (i = 0; i < sizeof yylval.guid.Data4; i++) {
            int ch;

            if ((ch = pStream->GetByte()) == EOF) {
                DPF_ERR("Unexpected EOF");
                token = YT_ERROR;
                break;
            } else {
                yylval.guid.Data4[i] = (unsigned char)ch;
            }
        }
        break;

    case YT_BINARY_DATA:
        token = yyGetBinaryData(pStream);
        if (token == YT_END_OF_FILE)
            flagEof = TRUE;
        break;

    case EOF:
        flagEof = TRUE;
        token = YT_END_OF_FILE;
        break;

    default:
        DPF_ERR("Unexpected data in input stream");
        token = YT_ERROR;
    }

    return token;
}

static int yylex_ascii(XStreamRead *pStream)
{
    register char ch;
    int rtrn;

    do {
        ch = pStream->GetByte();
        if (ch == '\n') {
            lineNum++;
        }
        else if (ch == '#') {
            do {
                ch = pStream->GetByte();
            } while ((ch != '\n') && (ch != EOF));
            lineNum++;
        }
        else if (ch == '/') {   /* handle C++ style double-/ comments */
            int newch = pStream->GetByte();
            if (newch == '/') {
                do {
                    ch= pStream->GetByte();
                } while ((ch != '\n') && (ch != EOF));
                lineNum++;
            }
            else if (newch != EOF) {
                pStream->UngetByte();
            }
        }
    } while ((ch != EOF) && (isspace(ch)));
    if      ( ch == '{' )       rtrn = YT_OBRACE;
    else if ( ch == '}' )       rtrn = YT_CBRACE;
    else if ( ch == '(' )       rtrn = YT_OPAREN;
    else if ( ch == ')' )       rtrn = YT_CPAREN;
    else if ( ch == '[' )       rtrn = YT_OBRACKET;
    else if ( ch == ']' )       rtrn = YT_CBRACKET;
    else if ( ch == '.' )       rtrn = YT_DOT;
    else if ( ch == ',' )       rtrn = YT_COMMA;
    else if ( ch == ';' )       rtrn = YT_SEMICOLON;
    else if ( ch == '"' )       rtrn = yyGetString();
    else if ( ch == '<' )       rtrn = yyGetUuid();
    else if ( (isalpha(ch) || (ch=='_')) )
        rtrn = yyGetName(ch);
    else if ( (isdigit(ch) || ch == '-' || ch == '+') )
        rtrn = yyGetNumber(ch);
    else if ( ch == YT_BINARY_DATA ) {
        ch = pStream->GetByte();
        if (ch != ((YT_BINARY_DATA >> 8) & 0xff)) {
            if (ch == EOF) {
                flagEof = TRUE;
                rtrn = YT_END_OF_FILE;
            }
            DPF_ERR("Unexpected character in input stream");
            return YT_ERROR;
        }
        rtrn = yyGetBinaryData(pStream);
        if (rtrn == YT_END_OF_FILE)
            flagEof = TRUE;
    }
    else if ( ch == EOF ) {
        flagEof = TRUE;
        rtrn = YT_END_OF_FILE;
    }
    else {
        DPF_ERR("Unexpected character in input stream");
        rtrn = YT_ERROR;
    }

    return rtrn;
}

yyerror(char* s)
{
#if 0
    if (*buf)
        DPF(0, "%d: %s near \"%s\"\n", lineNum, s, buf);
    else
        DPF(0, "%d: %s\n", lineNum, s);
#endif 0

    return 0;
}

extern int yyparse();

int YaccParseXOF(XStreamRead *pStream)
{
    yypStream = pStream;
    return yyparse();
}

/*
 * Parsed to end of file?
 */
int YaccIsEof(void)
{
    return flagEof;
}

void YaccResetEof(void)
{
    flagEof = FALSE;
}

XStreamRead *YaccGetStream()
{
    return yypStream;
}

void YaccSetStream(XStreamRead *pStream)
{
    yypStream = pStream;
}

void YaccSetError(void)
{
    flagError = TRUE;
}

#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse()
{
    register int yym, yyn, yystate;

    if (!XTemplateList::Init())
        goto yyabort;

#if YYDEBUG

    register char *yys;

#if 0
    extern char *getenv();

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#else
    yydebug = 9;
#endif

#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            DebugPrint("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            DebugPrint("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
yynewerror:
#endif
    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
yyerrlab:
#endif
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    DebugPrint("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    DebugPrint("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            DebugPrint("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        DebugPrint("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 5:
{
                    XDataObj *data;

                    data = XDataObj::Create(yyvsp[-5].string, 
                                            yyvsp[-4].string, 
                                            yyvsp[-2].guid, 
                                            yyvsp[-1].xdatapartList);

                    if (!data) {
                        if (yyvsp[-1].xdatapartList) delete yyvsp[-1].xdatapartList;
                        DPF_ERR("parser: failed to create data object");
                        YaccSetError();
                    } else {
                        if (!yypStream->AddDataObject(data)) {
                            DPF_ERR("parser: failed to add object to list.");
                            YaccSetError();
                        }

                        /* Intrinsic header is special case. Set flags... */
                        const GUID *type;

                        if (SUCCEEDED(data->GetType(&type)) &&
                            *type == TID_DXFILEHeader) {
                            yypStream->SetIntrinsicHeaderInfo(data);
                        }
                    }

                    XFree(yyvsp[-5].string);
                    XFree(yyvsp[-4].string);

                    flagYield = TRUE;
                }
break;
case 6:
{
                    XTemplate *tmplate;

                    tmplate = new XTemplate(yyvsp[-4].string, yyvsp[-2].guid, yyvsp[-1].templInfo);

                    if (!tmplate) {
                        DPF_ERR("parser: failed to create template object");
                        YaccSetError();
                    }

                    XTemplateList::Add(tmplate);

                    XFree(yyvsp[-5].string);
                    XFree(yyvsp[-4].string);
                    delete yyvsp[-1].templInfo;
                }
break;
case 7:
{ yyval.xdatapartList = NULL; }
break;
case 8:
{
                        yyval.xdatapartList = new XDataPartList();

                        if (!yyval.xdatapartList) {
                            DPF_ERR("parser: failed to create data part list.");
                            YaccSetError();
                        } else if (yyvsp[0].xdatapart && !yyval.xdatapartList->Add(yyvsp[0].xdatapart)) {
                            DPF_ERR("parser: failed to add data part to list.");
                            YaccSetError();
                        }
                    }
break;
case 9:
{
                        yyval.xdatapartList = yyvsp[-1].xdatapartList;

                        if (yyvsp[0].xdatapart && !yyval.xdatapartList->Add(yyvsp[0].xdatapart)) {
                            DPF_ERR("parser: failed to add data part to list.");
                            YaccSetError();
                        }
                    }
break;
case 10:
{
                    yyval.xdatapart = yyvsp[0].xdataref;
                }
break;
case 11:
{
                    yyval.xdatapart = XDataObj::Create(yyvsp[-5].string, yyvsp[-4].string, yyvsp[-2].guid, yyvsp[-1].xdatapartList);
                    if (!yyval.xdatapart) {
                        if (yyvsp[-1].xdatapartList) delete yyvsp[-1].xdatapartList;
                        DPF_ERR("parser: failed to create data part object");
                        YaccSetError();
                    }
                    XFree(yyvsp[-5].string);
                    XFree(yyvsp[-4].string);
                }
break;
case 12:
{
                    yyval.xdatapart = yyvsp[0].intList;
                }
break;
case 13:
{
                    yyval.xdatapart = yyvsp[0].fltList;
                }
break;
case 14:
{
                    yyval.xdatapart = yyvsp[0].strList;
                }
break;
case 15:
{
                    yyval.xdatapart = new XBinaryData(yyvsp[-3].string, yyvsp[-2].guid, yyvsp[0].binaryData, yypStream);
                    if (!yyval.xdatapart) {
                        DPF_ERR("parser: failed to create binary object");
                        YaccSetError();
                    }
                    XFree(yyvsp[-4].string);
                    XFree(yyvsp[-3].string);
                    delete yyvsp[0].binaryData;
                }
break;
case 16:
{
                            yyval.templInfo = new XTemplateInfo(yyvsp[-3].tmList, yyvsp[-1].toList,
                                yyvsp[-1].toList? DXFILETEMPLATE_RESTRICTED : DXFILETEMPLATE_OPEN);

                            if (!yyval.templInfo) {
                                DPF_ERR("Failed to create XTemplateInfo.");
                                YaccSetError();
                            }
                        }
break;
case 17:
{
                            yyval.templInfo = new XTemplateInfo(yyvsp[0].tmList);
                            if (!yyval.templInfo) {
                                DPF_ERR("Failed to create XTemplateInfo");
                                YaccSetError();
                            }
                        }
break;
case 18:
{ yyval.tmList = NULL; }
break;
case 19:
{
                            yyval.tmList = yyvsp[0].tmList;
                        }
break;
case 20:
{
                            yyval.tmList = new XTemplateMemberList();
                            if (!yyval.tmList) {
                                DPF_ERR("Failed to create XTemplateMemberList.");
                                YaccSetError();
                            } else if (yyvsp[0].templMember && !yyval.tmList->Add(yyvsp[0].templMember)) {
                                DPF_ERR("Failed to add template member.");
                                YaccSetError();
                            }
                        }
break;
case 21:
{
                            yyval.tmList = yyvsp[-1].tmList;

                            if (yyvsp[0].templMember && !yyval.tmList->Add(yyvsp[0].templMember)) {
                                DPF_ERR("Failed to add template member.");
                                YaccSetError();
                            }
                        }
break;
case 22:
{ yyval.templMember = yyvsp[0].templMember; }
break;
case 23:
{ yyval.templMember = yyvsp[0].templMember; }
break;
case 24:
{ yyval.templMember = yyvsp[0].templMember; }
break;
case 25:
{
                            yyval.toList = NULL;
                       }
break;
case 26:
{
                            yyval.toList = yyvsp[0].toList;
                       }
break;
case 27:
{
                           yyval.toList = new XTemplateOptionList();
                           if (!yyval.toList) {
                               DPF_ERR("Failed to create XTemplateOptionList.");
                               YaccSetError();
                           } else if (!yyval.toList->Add(yyvsp[0].idInf)) {
                               DPF_ERR("Failed to add template option.");
                               YaccSetError();
                           }
                       }
break;
case 28:
{
                           yyval.toList = yyvsp[-1].toList;
                           if (!yyval.toList->Add(yyvsp[0].idInf)) {
                               DPF_ERR("Failed to add template option.");
                               YaccSetError();
                           }
                       }
break;
case 29:
{
                            yyval.idInf = XIdentifier::Create(yyvsp[-2].string, yyvsp[-1].guid);

                            if (!yyval.idInf) {
                                DPF_ERR("Bad template optional member.");
                                YaccSetError();
                            }

                            XFree(yyvsp[-2].string);
                       }
break;
case 30:
{
                            yyval.idInf = XIdentifier::Create(SZBINARY, GUID_NULL);

                            if (!yyval.idInf) {
                                DPF_ERR("Bad template optional member.");
                                YaccSetError();
                            }

                            XFree(yyvsp[-1].string);
                     }
break;
case 31:
{
                        yyval.templMember = XTemplateMember::Create(yyvsp[-3].string, yyvsp[-2].string, yyvsp[-1].dimList);
                        if (!yyval.templMember) {
                            DPF_ERR("parser: failed to create array object");

                            /* Backward compatibility fix:*/
                            /* XOF3 did not verify array_data_type but we do.*/
                            /* See bug 19233:*/
                            /* PolyTrans outputs bad template MeshVertexColors.*/
                            /* It uses indexColor instead of IndextedColor*/
                            /* as the type for vertexColors.*/

                            if (strcmp(yyvsp[-3].string, "indexColor"))
                                YaccSetError();
                            delete yyvsp[-1].dimList;
                        }

                        XFree(yyvsp[-4].string);
                        XFree(yyvsp[-3].string);
                        XFree(yyvsp[-2].string);
                    }
break;
case 32:
{ yyval.string = yyvsp[0].string; }
break;
case 33:
{ yyval.string = yyvsp[0].string; }
break;
case 34:
{ yyval.string = yyvsp[0].string; }
break;
case 35:
{
                        yyval.dimList = new XDimensionList();
                        if (!yyval.dimList) {
                            DPF_ERR("Failed to create XDimensionList.");
                            YaccSetError();
                        } else if (!yyval.dimList->Add(yyvsp[0].elementSize)) {
                            DPF_ERR("Failed to add dimension.");
                            YaccSetError();
                        }
                    }
break;
case 36:
{
                        yyval.dimList = yyvsp[-1].dimList;
                        if (!yyval.dimList->Add(yyvsp[0].elementSize)) {
                            DPF_ERR("Failed to add dimension.");
                            YaccSetError();
                        }
                    }
break;
case 37:
{ yyval.elementSize = yyvsp[-1].elementSize; }
break;
case 38:
{
                       yyval.elementSize = new XDimension(yyvsp[0].stgInt, NULL);

                       if (!yyval.elementSize) {
                           DPF_ERR("Failed to create XDimension");
                           YaccSetError();
                       }
                   }
break;
case 39:
{
                       yyval.elementSize = new XDimension(0, yyvsp[0].string);

                       if (!yyval.elementSize) {
                           DPF_ERR("Failed to create XDimension");
                           YaccSetError();
                       }

                       XFree(yyvsp[0].string);
                   }
break;
case 40:
{
                        yyval.templMember = XTemplateMember::Create(yyvsp[-2].string, yyvsp[-1].string);
                        if (!yyval.templMember) {
                            DPF_ERR("parser: failed to create primitive object");
                            YaccSetError();
                        }

                        XFree(yyvsp[-2].string);
                        XFree(yyvsp[-1].string);
                    }
break;
case 41:
{ yyval.string = yyvsp[0].string; }
break;
case 42:
{ yyval.string = yyvsp[0].string; }
break;
case 43:
{ yyval.string = yyvsp[0].string; }
break;
case 44:
{ yyval.string = yyvsp[0].string; }
break;
case 45:
{ yyval.string = yyvsp[0].string; }
break;
case 46:
{ yyval.string = yyvsp[0].string; }
break;
case 47:
{ yyval.string = yyvsp[0].string; }
break;
case 48:
{ yyval.string = yyvsp[0].string; }
break;
case 49:
{ yyval.string = yyvsp[0].string; }
break;
case 50:
{ yyval.string = yyvsp[0].string; }
break;
case 51:
{ yyval.string = yyvsp[0].string; }
break;
case 52:
{ yyval.string = yyvsp[0].string; }
break;
case 53:
{ yyval.string = yyvsp[0].string; }
break;
case 54:
{
                    if (!yyvsp[-3].string && yyvsp[-2].guid == GUID_NULL) {
                        DPF_ERR("Bad date reference, no name or uuid");
                        YaccSetError();
                    } else {
                        yyval.xdataref = new XDataRef(yyvsp[-3].string, yyvsp[-2].guid, yypStream);
                        if (!yyval.xdataref) {
                            DPF_ERR("Failed to create XDataRef");
                            YaccSetError();
                        }
                        XFree(yyvsp[-3].string);
                    }
                }
break;
case 55:
{
                    yyval.templMember = XTemplateMember::Create(yyvsp[-2].string, yyvsp[-1].string);
                    if (!yyval.templMember) {
                        DPF_ERR("parser: failed to create template reference object");
                        YaccSetError();
                    }

                    XFree(yyvsp[-2].string);
                    XFree(yyvsp[-1].string);
                }
break;
case 56:
{ yyval.string = yyvsp[0].string; }
break;
case 57:
{ yyval.string = yyvsp[0].string; }
break;
case 58:
{ yyval.string = yyvsp[0].string; }
break;
case 59:
{ yyval.string = NULL; }
break;
case 60:
{ yyval.string = yyvsp[0].string; }
break;
case 61:
{ yyval.string = yyvsp[0].string; }
break;
case 62:
{ yyval.string = yyvsp[0].string; }
break;
case 65:
{
                        yyval.intList = new integerList(yyvsp[0].intListBinData);
                        if (!yyval.intList) {
                            DPF_ERR("Failed to create integerList.");
                            YaccSetError();
                        }
                    }
break;
case 66:
{
                        yyval.intList = new integerList();
                        if (!yyval.intList) {
                            DPF_ERR("Failed to create integerList.");
                            YaccSetError();
                        } else if (!yyval.intList->Add(yyvsp[0].stgInt)) {
                            DPF_ERR("Failed to add integer.");
                            YaccSetError();
                        }
                    }
break;
case 67:
{
                        yyval.intList = yyvsp[-2].intList;
                        if (!yyval.intList->Add(yyvsp[0].stgInt)) {
                            DPF_ERR("Failed to add integer.");
                            YaccSetError();
                        }
                    }
break;
case 70:
{
                        yyval.fltList = new floatList(yyvsp[0].fltListBinData);
                        if (!yyval.fltList) {
                            DPF_ERR("Failed to create floatList.");
                            YaccSetError();
                        }
                    }
break;
case 71:
{
                        yyval.fltList = new floatList();

                        if (!yyval.fltList) {
                            DPF_ERR("Failed to create floatList.");
                            YaccSetError();
                        } else if (!yyval.fltList->Add(yyvsp[0].stgFlt)) {
                            DPF_ERR("Failed to add float.");
                            YaccSetError();
                        }
                    }
break;
case 72:
{
                        yyval.fltList = yyvsp[-2].fltList;
                        if (!yyval.fltList->Add(yyvsp[0].stgFlt)) {
                            DPF_ERR("Failed to add float.");
                            YaccSetError();
                        }
                    }
break;
case 74:
{
                        yyval.strList = new stringList();
                        if (!yyval.strList) {
                            DPF_ERR("Failed to create stringList.");
                            YaccSetError();
                        } else if (!yyval.strList->Add(yyvsp[0].string)) {
                            DPF_ERR("Failed to add string.");
                            YaccSetError();
                        }
                    }
break;
case 75:
{
                        yyval.strList = yyvsp[-2].strList;
                        if (!yyval.strList->Add(yyvsp[0].string)) {
                            DPF_ERR("Failed to add string.");
                            YaccSetError();
                        }
                    }
break;
case 76:
{ yyval.guid = GUID_NULL; }
break;
case 77:
{ yyval.guid = yyvsp[0].guid; }
break;
case 78:
{ yyval.guid = yyvsp[0].guid; }
break;
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            DebugPrint("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                DebugPrint("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        DebugPrint("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = (short)yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    XTemplateList::Free();
    return (1);
yyaccept:
    XTemplateList::Free();
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xparse.h ===
#define YT_END_OF_FILE 0
#define YT_YIELD 0
#define YT_ERROR 255
#define YT_NAME 1
#define YT_STRING 2
#define YT_INTEGER 3
#define YT_REALNUM 4
#define YT_GUID 5
#define YT_INTEGER_LIST 6
#define YT_REALNUM_LIST 7
#define YT_BINARY_DATA 254
#define YT_OBRACE 10
#define YT_CBRACE 11
#define YT_OPAREN 12
#define YT_CPAREN 13
#define YT_OBRACKET 14
#define YT_CBRACKET 15
#define YT_OANGLE 16
#define YT_CANGLE 17
#define YT_DOT 18
#define YT_COMMA 19
#define YT_SEMICOLON 20
#define YT_OBJECT 30
#define YT_TEMPLATE 31
#define YT_WORD 40
#define YT_DWORD 41
#define YT_FLOAT 42
#define YT_DOUBLE 43
#define YT_CHAR 44
#define YT_UCHAR 45
#define YT_SWORD 46
#define YT_SDWORD 47
#define YT_VOID 48
#define YT_LPSTR 49
#define YT_UNICODE 50
#define YT_CSTRING 51
#define YT_ARRAY 52
#define YT_ULONGLONG 53
#define YT_BINARY 54
#define YT_BINARY_RESOURCE 55

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xobject.h ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xobject.h
//
//  Description:    XObject class header file.
//
//  History:
//      01/03/98    CongpaY     Created
//
//**************************************************************************

#ifndef _XOBJECT_H_
#define _XOBJECT_H_

class XDataObj;

#define XDATA_PART_LIST_CHUNK_SIZE  10

////////////////////////////////////////////////////////////////////////////
//
//  XDataPart:
//      A data part can be integerList, floatList, stringList or XObject
//
////////////////////////////////////////////////////////////////////////////

class XDataPart
{
public:
    STDMETHOD_(ULONG, Release) () PURE;
    virtual HRESULT ProcessSelf(XDataObj *pParent) = 0;
};

typedef XObjPtrArray<XDataPart, XDATA_PART_LIST_CHUNK_SIZE> XDataPartList;


////////////////////////////////////////////////////////////////////////////
//
//  XObject: Base class for XTemplate and XData.
//           Handle reference counting.
//
////////////////////////////////////////////////////////////////////////////

class XObject : public IDirectXFileObject, public XDataPart
{
    const XString m_szName;     // Name (optional for data objects).
    const GUID    m_id;         // User's identifier for this object.
    DWORD         m_cRef;       // Reference count.

protected:
// constructor and destructor.

    XObject(LPCSTR szName, REFGUID id) : m_szName(szName), m_id(id), m_cRef(1){}
    virtual ~XObject() {}

public:
// Interfaces.
    STDMETHOD(QueryInterface) (REFIID iid, LPVOID FAR *lplpv) PURE;
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();
    STDMETHOD(GetName) (LPSTR szName, LPDWORD pdwSize);
    STDMETHOD(GetId) (LPGUID pId);

// Properties.

    const XString &name() { return m_szName; }
    REFGUID id() { return m_id; }

// Other methods.

    virtual XDataObj *FindDataObj(LPCSTR szName) { return NULL; }
    virtual XDataObj *FindDataObj(REFGUID idSrc) { return NULL; }
    virtual BOOL ValidChild(XDataObj *pParent) = 0;
    virtual HRESULT ProcessSelf(XDataObj *pParent);
};

#endif // _XOBJECT_H_

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xprim.cpp ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xprim.cpp
//
//  Description:    Implement XPrimitiveList class.
//
//  History:
//      01/08/98    CongpaY     Created
//
//**************************************************************************

#include "precomp.h"

static const XPrimitive aPrimitives[] = {
    "WORD",      X_Word,      sizeof(unsigned short),
    "DWORD",     X_DWord,     sizeof(unsigned long),
    "FLOAT",     X_Float,     sizeof(float),
    "DOUBLE",    X_Double,    sizeof(double),
    "CHAR",      X_Char,      sizeof(char),
    "UCHAR",     X_UChar,     sizeof(unsigned char),
    "BYTE",      X_UChar,     sizeof(unsigned char),
    "SWORD",     X_SWord,     sizeof(short),
    "SDWORD",    X_SDWord,    sizeof(long),
    "STRING",    X_Lpstr,     sizeof(char *),
    "CSTRING",   X_Cstring,   sizeof(char *),
    "UNICODE",   X_Unicode,   sizeof(short *),
    "ULONGLONG", X_ULongLong, sizeof(__int64)
};

static const cPrimitives = sizeof(aPrimitives)/sizeof(XPrimitive);

const XPrimitive *XPrimitiveFromName(LPCSTR szName)
{
    for (DWORD i = 0; i < cPrimitives; i++) {
        if (!xstricmp(szName, aPrimitives[i].name))
            return &aPrimitives[i];
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xstring.h ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xstring.h
//
//  Description:    XString class header file.
//
//  History:
//      01/02/98    CongpaY     Created
//
//**************************************************************************

#ifndef _XSTRING_H_
#define _XSTRING_H_

class XString
{
    CHAR *m_szData;

public:
    XString(const CHAR *szSrc = NULL);

    ~XString();

    const XString& operator=(const CHAR *szSrc);

    operator const CHAR *() const { return m_szData; }
};

#define xstricmp _stricmp
#define xstrcmp strcmp
#define xstrlen strlen
CHAR *xstrdup(const CHAR *s);

#endif // _XSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xstring.cpp ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xstring.cpp
//
//  Description:    Implement XString class.
//
//  History:
//      01/02/98    CongpaY     Created
//
//**************************************************************************

#include "precomp.h"

XString::XString(const CHAR *szSrc)
{
    m_szData = xstrdup(szSrc);
}

XString::~XString()
{
    if (m_szData)
        XFree((void *)m_szData);
}


const XString& XString::operator=(const CHAR *szSrc)
{
    if (m_szData)
        XFree((void *)m_szData);

    m_szData = xstrdup(szSrc);

    return *this;
}

#undef DPF_MODNAME
#define DPF_MODNAME "xstrdup"
CHAR *xstrdup(const CHAR *s)
{
    CHAR *d = NULL;

    if (s) {
        int n = (xstrlen(s) + 1) * sizeof(CHAR);

        if (SUCCEEDED(XMalloc((void **) &d, n)))
            memcpy(d, s, n);
        else
            DPF_ERR("Failed to allocate space for string");
    }

    return d;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xprim.h ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xprim.h
//
//  Description:    XPrimitive and XPrimitiveList classes.
//
//  History:
//      01/08/98    CongpaY     Created
//
//**************************************************************************

#ifndef _XPRIM_H_
#define _XPRIM_H_

typedef enum _XPrimType {
    X_Word,             // 16 bits (unsigned short)
    X_DWord,            // 32 bits (unsigned long)
    X_Float,            // 32 bits (float)
    X_Double,           // 64 bits (double)
    X_Char,             // 8 bits (char)
    X_UChar,            // 8 bits (unsigned char)
    X_SWord,            // (short)
    X_SDWord,           // (long)
    X_Lpstr,            // Null terminated string
    X_Cstring,          // C string
    X_Unicode,          // Unicode string
    X_ULongLong         // 64 bit int
} XPrimType;

class XPrimitive {
public:
    LPCSTR   name;
    XPrimType   type;
    DWORD       size;
};

const XPrimitive *XPrimitiveFromName(LPCSTR szName);

#endif // _XPRIM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xstrmrd.h ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xstrmrd.h
//
//  Description:    XStreamRead and its sub classes header file.
//
//  History:
//      02/23/98    CongpaY     Created
//
//**************************************************************************

#ifndef _XSTRMRD_H_
#define _XSTRMRD_H_

#define XDATAOBJ_LIST_CHUNK_SIZE    100

typedef XObjPtrArray<XDataObj, XDATAOBJ_LIST_CHUNK_SIZE> XDataObjList;

typedef enum _StreamStatus {
    StreamParsed,           // The (Normal) stream has been parsed
    StreamParsing,          // The (Streaming) stream is being parsed
    StreamParseError        // Parse error parsing stream
} StreamStatus;

typedef enum _FileMode {
    FM_Binary,
    FM_Text
} FileMode;

typedef enum _CompressionType {
    CT_None,
    CT_ZIP
} CompressionType;

class XSource
{
public:
    virtual ~XSource() {;}

    virtual char GetByte() = 0;
    virtual void UngetByte() = 0;
    virtual int ReadWord() = 0;
    virtual BOOL ReadDword(LPDWORD pData) = 0;
    virtual BOOL ReadFloat(float *pData) = 0;
    virtual BOOL ReadDouble(double *pData) = 0;

    virtual HRESULT Read(LPVOID pvData, DWORD dwOffset, DWORD cbSize, LPDWORD pcbRead) = 0;

    virtual HRESULT GetFile(LPVOID *ppvFile, LPDWORD pcbFile) = 0;
};

class XSrcMemory : public XSource
{
    LPBYTE  m_pFile;    // Point to the beginning of the file buffer.
    DWORD   m_cbFile;   // File buffer size.
    LPBYTE  m_pEnd;     // Point to the end of the file buffer
    LPBYTE  m_pCur;     // Point to the current reading position.
    BOOL    m_fFree;    // True if need to free m_pFile.

public:
    XSrcMemory(LPVOID pvFile, DWORD cbFile, BOOL fFree = FALSE);
    virtual ~XSrcMemory();

    virtual char GetByte();
    virtual void UngetByte() { m_pCur--; }
    virtual int ReadWord();
    virtual BOOL ReadDword(LPDWORD pData);
    virtual BOOL ReadFloat(float *pData);
    virtual BOOL ReadDouble(double *pData);

    virtual HRESULT Read(LPVOID pvData, DWORD dwOffset, DWORD cbSize, LPDWORD pcbRead);

    virtual HRESULT GetFile(LPVOID *ppvFile, LPDWORD pcbFile);
};

#if 0 // Memory mapped file IO is not currently supported

class XSrcFile : public XSrcMemory
{
    HANDLE m_hFile;
    HANDLE m_hMapFile;
    LPVOID m_pMapFile;

public:
    XSrcFile(HANDLE hFile, HANDLE m_hMapFile, LPVOID pvFile, DWORD cbFile);
    virtual ~XSrcFile();
};

#endif 0

class XStreamRead
{
    XSource      *m_pSrc;       // Source for reading.

    StreamStatus  m_status;     // Current status of this stream

    FileMode      m_mode;       // Text, binary
    DWORD         m_floatSize;  // 32 or 64

    DWORD         m_flags;      // Information from the intrinsic header

    XDataObjList *m_plDataObj;  // This stream's data object list
    DWORD         m_iDataObj;   // Where we are in the data object list

    HRESULT ValidateStream();

    static HRESULT CreateFromMemory(LPVOID pvFile, DWORD cbFile, XStreamRead **ppStream);
    static HRESULT CreateFromFile(LPCSTR szFilename, XStreamRead **ppStream);

public:
    XStreamRead(XSource *pSource);
    ~XStreamRead();

    static HRESULT Create(LPVOID pvSource, DWORD loadflags, XStreamRead **ppStream);

    DWORD floatSize() { return m_floatSize; }
    FileMode mode() { return m_mode; }

    HRESULT SetIntrinsicHeaderInfo(XDataObj *header);

    int AddDataObject(XDataObj *pObj);

    HRESULT GetNextObject(XDataObj **ppObj);
    HRESULT GetObjectById(REFGUID id, XDataObj **ppObj);
    HRESULT GetObjectByName(LPCSTR name, XDataObj **ppObj);
    HRESULT GetObjectByNameAndId(LPCSTR name, REFGUID id, XDataObj **ppObj);

    // Inline read functions.

    char GetByte() { return m_pSrc->GetByte(); }
    void UngetByte() { m_pSrc->UngetByte(); }
    int ReadWord() { return m_pSrc->ReadWord(); }
    BOOL ReadDword(LPDWORD pData) { return m_pSrc->ReadDword(pData); }
    BOOL ReadFloat(float *pData) { return m_pSrc->ReadFloat(pData); }
    BOOL ReadDouble(double *pData) { return m_pSrc->ReadDouble(pData); }

    HRESULT Read(LPVOID pvData, DWORD dwOffset, DWORD cbSize, LPDWORD pcbRead)
      { return m_pSrc->Read(pvData, dwOffset, cbSize, pcbRead); }
};

#endif // _XSTRMRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xtempl.cpp ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xtempl.cpp
//
//  Description:    Implement XTemplateList class.
//
//  History:
//      01/09/98    CongpaY     Created
//
//**************************************************************************

#include "precomp.h"

#define TEMPLATE_LIST_CHUNK_SIZE 100

typedef XPtrArray<XTemplate, TEMPLATE_LIST_CHUNK_SIZE> XTemplateListImpl;

static XTemplateListImpl *spTemplateList;

////////////////////////////////////////////////////////////////////////////
//
//  Implement XIdentifier class
//
////////////////////////////////////////////////////////////////////////////

XIdentifier *XIdentifier::Create(LPCSTR szName, REFGUID id)
{
    XTemplate *pTemplate;

    if (szName && XTemplateList::Find(szName, &pTemplate)) {
        return new XIdentifier(szName, pTemplate->id());
    }

    if (XTemplateList::Find(id, &pTemplate)) {
        return new XIdentifier(pTemplate->name(), id);
    }

    if (szName && !xstricmp(szName, SZBINARY))
        return new XIdentifier(SZBINARY, GUID_NULL);

    return NULL;
}

////////////////////////////////////////////////////////////////////////////
//
//  Implement XTemplateList class
//
////////////////////////////////////////////////////////////////////////////

BOOL XTemplateList::Init()
{
    if (spTemplateList == NULL)
    {
        spTemplateList = new XTemplateListImpl();
    }

    return spTemplateList != NULL;
}

int XTemplateList::Add(XTemplate *pSrc)
{
    if (Find(pSrc->name())) {
        delete pSrc;
        return 0;
    }

    return spTemplateList->Add(pSrc);
}

BOOL XTemplateList::Find(LPCSTR szName, XTemplate **ppTemplate)
{
    for (DWORD i = 0; i < spTemplateList->count(); i++) {
        if (!xstricmp((*spTemplateList)[i]->name(), szName)) {
            if (ppTemplate)
                *ppTemplate = (*spTemplateList)[i];
            return TRUE;
        }
    }

    return FALSE;
}

BOOL XTemplateList::Find(REFGUID id, XTemplate **ppTemplate)
{
    for (DWORD i = 0; i < spTemplateList->count(); i++) {
        if ((*spTemplateList)[i]->id() == id) {
            if (ppTemplate)
                *ppTemplate = (*spTemplateList)[i];
            return TRUE;
        }
    }

    return FALSE;
}

void XTemplateList::Free()
{
}

////////////////////////////////////////////////////////////////////////////
//
//  Implement XTemplateMember class
//
////////////////////////////////////////////////////////////////////////////

XTemplateMember::XTemplateMember(LPCSTR szName,
                                 const XPrimitive *pPrim,
                                 XTemplate *pTemplate,
                                 XDimensionList *plDim)
  : m_szName(szName),
    m_pPrim(pPrim),
    m_pTemplate(pTemplate),
    m_plDim(plDim)
{
}

XTemplateMember *
XTemplateMember::Create(LPCSTR szType, LPCSTR szName, XDimensionList *plDim)
{
    const XPrimitive *pPrim;
    XTemplate *pTemplate;
    XTemplateMember *pMember;

    if (pPrim = XPrimitiveFromName(szType))
        pMember = new XTemplateMember(szName, pPrim, NULL, plDim);
    else if (XTemplateList::Find(szType, &pTemplate))
        pMember = new XTemplateMember(szName, NULL, pTemplate, plDim);
    else
        pMember = NULL;

    return pMember;
}

XTemplateMember::~XTemplateMember()
{
    if (m_plDim)
        delete m_plDim;
}

LPCSTR XTemplateMember::type()
{
    if (m_pPrim)
        return m_pPrim->name;
    else if (m_pTemplate)
        return m_pTemplate->name();
    else
        return NULL;
}

BOOL XTemplateMember::NeedRepack()
{
    if (m_pPrim)
        return m_pPrim->size != 4;
    else
        return m_pTemplate->NeedRepack();
}

HRESULT XTemplateMember::ResolveArraySize(XTemplate *pParent,
                                          DWORD *pcArraySize)
{
    DWORD cArraySize = 1;

    for (DWORD i = 0; i < m_plDim->count(); i++) {
        XDimension *pDim = (*m_plDim)[i];

        if (pDim->m_cElements) {
            cArraySize *= pDim->m_cElements;
        } else if (pDim->m_szElements) {
            HRESULT hr;
            LPVOID pData;

            hr = pParent->GetMemberData(this, pDim->m_szElements, &pData);

            if (FAILED(hr))
                return hr;

            cArraySize *= *((DWORD *)pData);
        } else {
            return DXFILEERR_BADARRAYSIZE;
        }
    }

    *pcArraySize = cArraySize;
    return DXFILE_OK;
}

HRESULT XTemplateMember::ModulateSingleData(LPVOID *ppvData,
                                            DWORD *pcbSize,
                                            LPVOID *ppvRet)
{
    HRESULT hr;
    LPCSTR pData = (LPCSTR)*ppvData;

    m_pData = *ppvData;

    if (m_pTemplate) {
        hr = m_pTemplate->ModulateData(ppvData, pcbSize, ppvRet);
        *ppvData = (LPVOID)pData;
        return hr;
    }

    if (FAILED(hr = XRealloc(ppvRet, *pcbSize + m_pPrim->size)))
        return hr;

    LPSTR p = (LPSTR)*ppvRet;
    p += *pcbSize;

    switch (m_pPrim->type) {
    case X_DWord:
    case X_SDWord:
        *(DWORD *)p = *(DWORD *)pData;
        break;
    case X_Word:
    case X_SWord:
        *(WORD *)p = (WORD)*(DWORD *)pData;
        break;
    case X_Char:
    case X_UChar:
        *p = (char)*(DWORD *)pData;
        break;
    case X_Float:
        *(float *)p = *(float *)pData;
        break;
    case X_Double:
        *(double *)p = (double)*(float *)pData;
        break;
    case X_Lpstr:
        *(LPSTR *)p = *(LPSTR *)pData;
        break;
    default:
        hr = DXFILEERR_NOTDONEYET;
        break;
    }

    *pcbSize += m_pPrim->size;
    *ppvData = (LPVOID)(pData + 4);

    return hr;
}

HRESULT XTemplateMember::ModulateData(LPVOID *ppvData,
                                     DWORD *pcbSize,
                                     LPVOID *ppvRet,
                                     XTemplate *pParent)
{
    if (!m_plDim)
        return ModulateSingleData(ppvData, pcbSize, ppvRet);

    // It's an array. Resolve array size.

    HRESULT hr;
    DWORD cArraySize;

    hr = ResolveArraySize(pParent, &cArraySize);

    if (FAILED(hr))
        return hr;

    // Modulate array data.

    for (DWORD i = 0; i < cArraySize; i++) {
        hr = ModulateSingleData(ppvData, pcbSize, ppvRet);

        if (FAILED(hr))
            break;
    }

    return hr;
}

DWORD XTemplateMember::GetSize(XTemplate *pParent)
{
    DWORD cbSize;

    if (m_pPrim)
        cbSize = m_pPrim->size;
    else
        cbSize = m_pTemplate->GetSize(m_pData);

    if (m_plDim) {
        DWORD cArraySize;
        ResolveArraySize(pParent, &cArraySize);
        cbSize *= cArraySize;
    }

    return cbSize;
}

////////////////////////////////////////////////////////////////////////////
//
//  Implement XTemplate class
//
////////////////////////////////////////////////////////////////////////////

XTemplate::XTemplate(LPCSTR szName, REFGUID id, XTemplateInfo *pTemplInfo)
  : m_szName(szName),
    m_id(id),
    m_plMembers(pTemplInfo->m_plMembers),
    m_plOptions(pTemplInfo->m_plOptions),
    m_type(pTemplInfo->m_type),
    m_fRepack(FALSE)
{
    if (m_plMembers) {
        for (DWORD i = 0; i < m_plMembers->count(); i++) {
            m_fRepack |= (*m_plMembers)[i]->NeedRepack();
        }
    }
}

XTemplate::~XTemplate()
{
    if (m_plMembers)
        delete m_plMembers;

    if (m_plOptions)
        delete m_plOptions;
}

HRESULT XTemplate::GetMemberData(XTemplateMember *pMemberCur,
                                 LPCSTR szMember,
                                 LPVOID *ppvData)
{
    for (DWORD i = 0; i < m_plMembers->count(); i++) {
        XTemplateMember *pMember = (*m_plMembers)[i];

        if (pMember == pMemberCur)
            break;

        if (!xstricmp(pMember->name(), szMember)) {
            *ppvData = pMember->m_pData;
            return DXFILE_OK;
        }
    }
    return DXFILEERR_BADDATAREFERENCE;
}

HRESULT XTemplate::ModulateData(LPVOID *ppvData, DWORD *pcbSize, LPVOID *ppvRet)
{
    *pcbSize = 0;
    *ppvRet = NULL;

    if (!m_plMembers)
        return DXFILE_OK;

    HRESULT hr;

    for (DWORD i = 0; i < m_plMembers->count(); i++) {
        hr = (*m_plMembers)[i]->ModulateData(ppvData, pcbSize, ppvRet, this);

        if (hr != DXFILE_OK)
            break;
    }

    return hr;
}

DWORD XTemplate::GetSize(LPVOID pvSrc)
{
    LPCSTR pData = (LPCSTR)pvSrc;

    for (DWORD i = 0; i < m_plMembers->count(); i++) {
        DWORD cbInc;
        XTemplateMember *pMember = (*m_plMembers)[i];

        pMember->m_pData = (LPVOID)pData;
        pData += pMember->GetSize(this);
    }

    return (DWORD)(pData - (LPCSTR)pvSrc);
}

HRESULT XTemplate::GetSubData(LPVOID pvSrc, LPCSTR szMember,
                              DWORD *pcbSize, LPVOID *ppvRet)
{
    LPCSTR pData = (LPCSTR)pvSrc;
    DWORD cbSize;

    for (DWORD i = 0; i < m_plMembers->count(); i++) {
        XTemplateMember *pMember = (*m_plMembers)[i];

        pMember->m_pData = (LPVOID)pData;
        cbSize = pMember->GetSize(this);

        if (!xstricmp(pMember->name(), szMember)) {
            *ppvRet = (LPVOID)pData;
            *pcbSize = cbSize;
            return DXFILE_OK;
        }

        pData += cbSize;
    }
    return DXFILEERR_BADDATAREFERENCE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xtempl.h ===
//**************************************************************************
//
// Copyright (C) 1997 - 1998 Microsoft Corporation. All Rights Reserved.
//
// FileName:    xtempl.h
//
// Description: Template related classes header file
//
// History:
//      01/09/98    CongpaY     Created
//
//**************************************************************************

#ifndef _XTEMPL_H_
#define _XTEMPL_H_

#define SZBINARY "BINARY"

#define DIMENSION_LIST_CHUNK_SIZE       2
#define TEMPLATE_OPTION_LIST_CHUNK_SIZE 5
#define TEMPLATE_MEMBER_LIST_CHUNK_SIZE 10

typedef enum _DXFILETEMPLATETYPE {
    DXFILETEMPLATE_OPEN,
    DXFILETEMPLATE_CLOSED,
    DXFILETEMPLATE_RESTRICTED
} DXFILETEMPLATETYPE;

class XTemplate;

////////////////////////////////////////////////////////////////////////////
//
//  XIdentifier: Class for identifiers. name | uuid | name uuid.
//
////////////////////////////////////////////////////////////////////////////

class XIdentifier
{
    const XString m_szName;
    const GUID    m_id;
    XIdentifier(LPCSTR szName, REFGUID id) : m_szName(szName), m_id(id) {}

public:
    static XIdentifier *Create(LPCSTR szName, REFGUID id);

    LPCSTR name() { return m_szName; }
    REFGUID id() { return m_id; }
};

typedef XPtrArray<XIdentifier, TEMPLATE_OPTION_LIST_CHUNK_SIZE> \
XTemplateOptionList;

////////////////////////////////////////////////////////////////////////////
//
//  XDimension: Class for describing array dimension.
//
////////////////////////////////////////////////////////////////////////////

class XDimension
{
public:
    DWORD   m_cElements;
    XString m_szElements;

    XDimension(DWORD cElements, LPCSTR szElements)
      : m_cElements(cElements), m_szElements(szElements) {}
};

typedef XPtrArray<XDimension, DIMENSION_LIST_CHUNK_SIZE> XDimensionList;

////////////////////////////////////////////////////////////////////////////
//
//  XTemplateMember: Class for template members.
//
////////////////////////////////////////////////////////////////////////////

class XTemplateMember
{
    XString           m_szName;
    const XPrimitive *m_pPrim;
    XTemplate        *m_pTemplate;
    XDimensionList   *m_plDim;

    XTemplateMember(LPCSTR szName,
                    const XPrimitive *pPrim,
                    XTemplate *pTemplate,
                    XDimensionList *plDim);

    HRESULT ResolveArraySize(XTemplate *pParent, DWORD *pcArraySize);

    HRESULT ModulateSingleData(LPVOID *ppvData, DWORD *pcbSize, LPVOID *ppvRet);

public:
    LPVOID m_pData;

    ~XTemplateMember();

    static XTemplateMember *Create(LPCSTR szType,
                                   LPCSTR szName,
                                   XDimensionList *plDim = NULL);

    LPCSTR name() { return m_szName; }
    XDimensionList *dl() { return m_plDim; }

    LPCSTR type();

    BOOL NeedRepack();

    HRESULT ModulateData(LPVOID *ppvData, DWORD *pcbSize, LPVOID *ppvRet,
                         XTemplate *pParent);

    DWORD GetSize(XTemplate *pParent);
};

typedef XPtrArray<XTemplateMember, TEMPLATE_MEMBER_LIST_CHUNK_SIZE> \
XTemplateMemberList;

////////////////////////////////////////////////////////////////////////////
//
//  XTemplateInfo: Class for definding template.
//
////////////////////////////////////////////////////////////////////////////

class XTemplateInfo
{
public:
    XTemplateMemberList *m_plMembers;
    XTemplateOptionList *m_plOptions;
    DXFILETEMPLATETYPE   m_type;

    XTemplateInfo(XTemplateMemberList *plMembers,
                  XTemplateOptionList *plOptions = NULL,
                  DXFILETEMPLATETYPE   type = DXFILETEMPLATE_CLOSED)
      : m_plMembers(plMembers), m_plOptions(plOptions), m_type(type) {}
};

////////////////////////////////////////////////////////////////////////////
//
//  XTemplate: Class for templates.
//
////////////////////////////////////////////////////////////////////////////

class XTemplate
{
    const XString m_szName;
    const GUID    m_id;

    XTemplateMemberList *m_plMembers;     // Template member list.
    XTemplateOptionList *m_plOptions;     // restricted member identifiers.
    DXFILETEMPLATETYPE   m_type;          // Open, closed or restricted.

    // All numbers are stored in 4 bytes from the parser.
    // If the size of any member is not 4. We need to repack data.

    BOOL                  m_fRepack;

public:
    XTemplate(LPCSTR szName, REFGUID id, XTemplateInfo *pTemplInfo);
    virtual ~XTemplate();

    const XString &name() { return m_szName; }
    REFGUID id() { return m_id; }

    XTemplateMemberList *ml() { return m_plMembers; }
    XTemplateOptionList *ol() { return m_plOptions; }
    BOOL IsOpen() { return m_type == DXFILETEMPLATE_OPEN; }
    BOOL IsClosed() { return m_type == DXFILETEMPLATE_CLOSED; }

    BOOL NeedRepack() { return m_fRepack; }

    HRESULT GetMemberData(XTemplateMember *pMemberCur,
                          LPCSTR szMember,
                          LPVOID *ppvData);

    HRESULT ModulateData(LPVOID *ppvData, DWORD *pcbSize, LPVOID *ppvRet);

    DWORD GetSize(LPVOID pvSrc);

    HRESULT GetSubData(LPVOID pData, LPCSTR szMember, DWORD *pcbSize,
                       LPVOID *ppvRet);
};


////////////////////////////////////////////////////////////////////////////
//
//  XTemplateList: Class for template list.
//
////////////////////////////////////////////////////////////////////////////

class XTemplateList
{
public:
    static BOOL Init();

    static int Add(XTemplate *pSrc);

    static BOOL Find(LPCSTR szName,
                     XTemplate **ppTmplate = NULL);

    static BOOL Find(REFGUID id,
                     XTemplate **ppTmplate = NULL);

    static void Free();
};

#endif // _XTEMPL_H_

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xstrmrd.cpp ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xstrmrd.cpp
//
//  Description:    Implement XStreamRead and its subclasses.
//
//  History:
//      02/24/98    CongpaY     Created
//
//**************************************************************************

#include "precomp.h"

#define URL_READ_CHUNK_SIZE 0x8000

int YaccIsEof(void);
void YaccResetEof(void);
int YaccParseXOF(XStreamRead *);

HRESULT DecompressFile_Zip(XSource *pSrc, XSrcMemory **ppSrcMem);

///////////////////////////////////////////////////////////////////////////////
//
//  XStreamRead class
//
///////////////////////////////////////////////////////////////////////////////

XStreamRead::XStreamRead(XSource *pSrc)
  : m_pSrc(pSrc),
    m_status(StreamParsing),
    m_plDataObj(NULL),
    m_iDataObj(0)
{
}

XStreamRead::~XStreamRead()
{
    if (m_plDataObj)
        delete m_plDataObj;

    if (m_pSrc)
        delete m_pSrc;
}

HRESULT XStreamRead::ValidateStream()
{
    DWORD magic, version, format, floatBits;
    CompressionType ct = CT_None;


    if (!ReadDword(&magic) || magic != XFILE_MAGIC) {
        DPF_ERR("Bad magic number");
        return DXFILEERR_BADFILETYPE;
    }

    if (!ReadDword(&version) ||
        version != XFILE_VERSION && version != XFILE_VERSION_DX3) {
        DPF_ERR("Invalid file format version");
        return DXFILEERR_BADFILEVERSION;
    }

    if (!ReadDword(&format))
        return DXFILEERR_BADFILETYPE;

    if (format == XFILE_FORMAT_TEXT) {
        m_mode = FM_Text;
        ct = CT_None;
    } else if (format == XFILE_FORMAT_BINARY) {
        m_mode = FM_Binary;
        ct = CT_None;
    } else if (format == XFILE_FORMAT_TEXT_ZIP) {
        m_mode = FM_Text;
        ct = CT_ZIP;
    } else if (format == XFILE_FORMAT_BINARY_ZIP) {
        m_mode = FM_Binary;
        ct = CT_ZIP;
    } else
        return DXFILEERR_BADFILETYPE;

    if (!ReadDword(&floatBits))
        return DXFILEERR_BADFILETYPE;

    if (floatBits == XFILE_FLOATSIZE_32)
        m_floatSize = sizeof(FLOAT);
    else if (floatBits == XFILE_FLOATSIZE_64)
        m_floatSize = sizeof(double);
    else
        return DXFILEERR_BADFILEFLOATSIZE;

    if (ct == CT_ZIP) {
        HRESULT hr;

        XSrcMemory *pSrcMem;

        hr = DecompressFile_Zip(m_pSrc, &pSrcMem);

        if (SUCCEEDED(hr)) {
            delete m_pSrc;
            m_pSrc = pSrcMem;
            hr = ValidateStream();
        }

        return hr;
    }

    return DXFILE_OK;
}

HRESULT XStreamRead::Create(LPVOID pvSource, DWORD loadflags,
                            XStreamRead **ppStream)
{
    HRESULT hr;

    if (loadflags & DXFILELOAD_FROMRESOURCE) {
        DPF_ERR("Opening a .x stream from a resource is not supported.");

        hr = D3DERR_INVALIDCALL;
    } else if (loadflags & DXFILELOAD_FROMMEMORY) {
        LPDXFILELOADMEMORY lMemory = (LPDXFILELOADMEMORY)pvSource;

        hr = CreateFromMemory(lMemory->lpMemory,
                              lMemory->dSize,
                              ppStream);

    } else if (loadflags & DXFILELOAD_FROMURL) {
        DPF_ERR("Opening a .x stream from a url is not supported.");

        hr = D3DERR_INVALIDCALL;
    } else if (loadflags & DXFILELOAD_FROMSTREAM) {
        hr = DXFILEERR_NOTDONEYET;

    } else {
        hr = CreateFromFile((LPCSTR)pvSource, ppStream);
    }

    if (SUCCEEDED(hr)) {
        hr = (*ppStream)->ValidateStream();

        if (FAILED(hr))
            delete *ppStream;
    }

    return hr;
}

HRESULT XStreamRead::CreateFromMemory(LPVOID pvFile, DWORD cbFile,
                                      XStreamRead **ppStream)
{
    if (!pvFile || !cbFile)
        return DXFILEERR_BADVALUE;

    XSrcMemory *pSrc = new XSrcMemory(pvFile, cbFile);

    if (!pSrc)
        return DXFILEERR_BADALLOC;

    *ppStream = new XStreamRead(pSrc);

    if (!*ppStream) {
        delete pSrc;
        return DXFILEERR_BADALLOC;
    }

    return DXFILE_OK;
}

HRESULT XStreamRead::CreateFromFile(LPCSTR szFilename, XStreamRead **ppStream)
{
    HANDLE hFile;

    hFile = CreateFileA(szFilename, GENERIC_READ, FILE_SHARE_READ, NULL,
                       OPEN_EXISTING, 0, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DPF_ERR("Failed to open file.");
        return DXFILEERR_FILENOTFOUND;
    }

    DWORD cbFile;

    cbFile = GetFileSize(hFile, NULL);

    if (cbFile == -1) {
        CloseHandle(hFile);
        DPF_ERR("Failed to get file size.");
        return DXFILEERR_BADFILE;
    }


#if 1

    BYTE *pbMemory;
    
    XMalloc((void **)&pbMemory, cbFile);

    if (!pbMemory)
    {
        CloseHandle(hFile);
        DPF_ERR("Failed to allocate memory for the file.");
        return DXFILEERR_BADALLOC;
    }

    DWORD dwRead;

    if (!ReadFile(hFile, pbMemory, cbFile, &dwRead, NULL))
    {
        CloseHandle(hFile);

        DPF_ERR("Failed to read the file into memory.");
        return DXFILEERR_BADFILE;
    }

    XSrcMemory *pSrc;

    pSrc = new XSrcMemory(pbMemory, cbFile, TRUE);    

    if (!pSrc)
    {
        CloseHandle(hFile);
        return DXFILEERR_BADALLOC;
    }

#else 0

    HANDLE hMapFile;

    hMapFile = CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, NULL);

    if (hMapFile == INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
        DPF_ERR("Failed to create file mapping.");
        return DXFILEERR_BADFILE;
    }

    LPVOID pvFile;

    pvFile = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);

    if (!pvFile) {
        CloseHandle(hMapFile);
        CloseHandle(hFile);
        DPF_ERR("Failed to map view of file on.");
        return DXFILEERR_BADFILE;
    }

    XSrcFile *pSrc;

    pSrc = new XSrcFile(hFile, hMapFile, pvFile, cbFile);

    if (!pSrc) {

        UnmapViewOfFile(pvFile);
        CloseHandle(hMapFile);

        CloseHandle(hFile);
        return DXFILEERR_BADALLOC;
    }

#endif 0

    *ppStream = new XStreamRead(pSrc);

    if (!*ppStream) {
        delete pSrc;
        return DXFILEERR_BADALLOC;
    }

    return DXFILE_OK;
}

HRESULT XStreamRead::SetIntrinsicHeaderInfo(XDataObj *pHeaderObj)
{
    LPVOID   data;
    DWORD    cbSize;
    HRESULT hr;

    hr = pHeaderObj->GetData("flag", &cbSize, &data);

    if (SUCCEEDED(hr)) {
        m_flags = *(DWORD *)data;

        if (m_flags & 1)
            m_mode = FM_Text;
        else
            m_mode = FM_Binary;
    }

    return hr;
}

int XStreamRead::AddDataObject(XDataObj *pObj)
{
    if (!m_plDataObj) {
        m_plDataObj = new XDataObjList();

        if (!m_plDataObj)
            return 0;
    }

    return m_plDataObj->Add(pObj);
}

HRESULT XStreamRead::GetNextObject(XDataObj **ppObj)
{
    *ppObj = NULL;

    if (m_status != StreamParsed) {
        if (!YaccParseXOF(this)) {
            if (YaccIsEof()) {
                m_status = StreamParsed;
                YaccResetEof();
            } else {
                m_status = StreamParsing;
            }
        } else {
            DPF_ERR("Error while parsing stream");
            m_status = StreamParseError;
        }
    }

    if (m_status == StreamParseError) {
        DPF_ERR("GetNextObject: Parse error.");
        return DXFILEERR_PARSEERROR;
    }

    if (m_plDataObj && m_plDataObj->count() > m_iDataObj) {
        *ppObj = (*m_plDataObj)[m_iDataObj];
        m_iDataObj++;
        return DXFILE_OK;
    }

    return DXFILEERR_NOMOREOBJECTS;
}

HRESULT XStreamRead::GetObjectById(REFGUID id, XDataObj **ppObj)
{
    *ppObj = NULL;

    if (m_plDataObj) {
        for (DWORD i = 0; i < m_plDataObj->count(); i++) {
            *ppObj = (*m_plDataObj)[i]->FindDataObj(id);

            if (*ppObj) {
                (*ppObj)->AddRef();
                return DXFILE_OK;
            }
        }
    }

    XDataObj *pObj;

    while (SUCCEEDED(GetNextObject(&pObj))) {
        if (*ppObj = pObj->FindDataObj(id)) {
            (*ppObj)->AddRef();
            return DXFILE_OK;
        }
    }

    return DXFILEERR_NOTFOUND;
}

HRESULT XStreamRead::GetObjectByName(LPCSTR name, XDataObj **ppObj)
{
    *ppObj = NULL;

    if (!name || !*name)
        return DXFILEERR_BADVALUE;

    if (m_plDataObj) {
        for (DWORD i = 0; i < m_plDataObj->count(); i++) {
            *ppObj = (*m_plDataObj)[i]->FindDataObj(name);

            if (*ppObj) {
                (*ppObj)->AddRef();
                return DXFILE_OK;
            }
        }
    }

    XDataObj *pObj;

    while (SUCCEEDED(GetNextObject(&pObj))) {
        if (*ppObj = pObj->FindDataObj(name)) {
            (*ppObj)->AddRef();
            return DXFILE_OK;
        }
    }

    return DXFILEERR_NOTFOUND;
}

HRESULT XStreamRead::GetObjectByNameAndId(LPCSTR name, REFGUID id, XDataObj **ppObj)
{
    *ppObj = NULL;

    XDataObj *pObj;

    if (m_plDataObj) {
        for (DWORD i = 0; i < m_plDataObj->count(); i++) {
            pObj = (*m_plDataObj)[i]->FindDataObj(id);

            if (pObj && pObj->name() && !xstrcmp(name, pObj->name())) {
                *ppObj = pObj;
                (*ppObj)->AddRef();
                return DXFILE_OK;
            }
        }
    }

    XDataObj *pObjNext;

    while (SUCCEEDED(GetNextObject(&pObjNext))) {
        if ((pObj = pObjNext->FindDataObj(id)) &&
            pObj->name() && !xstrcmp(name, pObj->name())) {
            *ppObj = pObj;
            (*ppObj)->AddRef();
            return DXFILE_OK;
        }
    }

    return DXFILEERR_NOTFOUND;
}

///////////////////////////////////////////////////////////////////////////////
//
//  XSrcMemory class
//
///////////////////////////////////////////////////////////////////////////////

XSrcMemory::XSrcMemory(LPVOID pvFile, DWORD cbFile, BOOL fFree)
  : m_pFile((LPBYTE)pvFile),
    m_cbFile(cbFile),
    m_pEnd(m_pFile),
    m_pCur(m_pFile),
    m_fFree(fFree)
{
    m_pEnd += m_cbFile;
}

XSrcMemory::~XSrcMemory()
{
    if (m_fFree)
        XFree(m_pFile);
}

char XSrcMemory::GetByte()
{
    return (m_pCur < m_pEnd)? *m_pCur++ : EOF;
}

int XSrcMemory::ReadWord()
{
    if (m_pCur + sizeof(WORD) <= m_pEnd) {
        WORD wRet = *((LPWORD)m_pCur);
        m_pCur += sizeof(WORD);
        return wRet;
    }

    return EOF;
}

BOOL XSrcMemory::ReadDword(LPDWORD pData)
{
    if (m_pCur + sizeof(DWORD) <= m_pEnd) {
        *pData = *((LPDWORD)m_pCur);
        m_pCur += sizeof(DWORD);
        return TRUE;
    }

    return FALSE;
}

BOOL XSrcMemory::ReadFloat(float *pData)
{
    if (m_pCur + sizeof(float) <= m_pEnd) {
        *pData = *((float *)m_pCur);
        m_pCur += sizeof(float);
        return TRUE;
    }

    return FALSE;
}

BOOL XSrcMemory::ReadDouble(double *pData)
{
    if (m_pCur + sizeof(double) <= m_pEnd) {
        *pData = *((double *)m_pCur);
        m_pCur += sizeof(double);
        return TRUE;
    }

    return FALSE;
}

HRESULT XSrcMemory::Read(LPVOID pvData, DWORD dwOffset, DWORD cbSize, LPDWORD pcbRead)
{
    if (dwOffset >= m_cbFile)
        return DXFILEERR_NOMOREDATA;

    if (cbSize > m_cbFile - dwOffset)
        cbSize = m_cbFile - dwOffset;

    memcpy(pvData, m_pFile+dwOffset, cbSize);

    *pcbRead = cbSize;

    return DXFILE_OK;
}

HRESULT XSrcMemory::GetFile(LPVOID *ppvFile, LPDWORD pcbFile)
{
    *ppvFile = m_pFile;
    *pcbFile = m_cbFile;
    return DXFILE_OK;
}

#if 0

///////////////////////////////////////////////////////////////////////////////
//
//  XSrcFile class
//
///////////////////////////////////////////////////////////////////////////////

XSrcFile::XSrcFile(HANDLE hFile, HANDLE hMapFile, LPVOID pvFile, DWORD cbFile)
  : XSrcMemory(pvFile, cbFile),
    m_hFile(hFile),
    m_hMapFile(hMapFile),
    m_pMapFile(pvFile)
{
}

XSrcFile::~XSrcFile()
{
    UnmapViewOfFile(m_pMapFile);
    CloseHandle(m_hMapFile);
    CloseHandle(m_hFile);
}

#endif 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xzip.cpp ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xzip.cpp
//
//  Description:    Implement functions to compress/decompress X files with
//                  mszip (nfmcomp.* and nfmdeco.*).
//
//  History:
//      02/16/98    CongpaY     Created
//
//**************************************************************************

#include "precomp.h"

extern "C" {
#include "nfmcomp.h"
#include "nfmdeco.h"
}

#include "xzip.h"

#define DXFILE_HEADER_LEN   16
#define BLOCKSIZE           0x8000
#define CMPBLOCKSIZE_MAX    BLOCKSIZE+MAX_GROWTH

static MI_MEMORY FAR __cdecl MyAlloc(ULONG amount)
{
    MI_MEMORY p;
    if (FAILED(XMalloc(&p, amount)))
        p = NULL;
    return p;
}

static void FAR __cdecl MyFree(MI_MEMORY pointer)
{
    XFree(pointer);
}

ZipDecompressor::ZipDecompressor()
  : m_nfmContext(NULL),
    m_bufDest(NULL)
{
}

ZipDecompressor::~ZipDecompressor()
{
    if (m_bufDest)
        XFree(m_bufDest);

    if (m_nfmContext)
        NFMdeco_destroy(m_nfmContext, MyFree);
}

BOOL ZipDecompressor::Init()
{
    if (FAILED(XMalloc(&m_bufDest, BLOCKSIZE)))
        return FALSE;

    m_nfmContext = NFMdeco_create(MyAlloc);

    return m_nfmContext != NULL;
}

///////////////////////////////////////////////////////////////////////////////
//
// Compressed X File format:
//
// 16 bytes        Header : "xof 0303bzip0032" or "xof 0303tzip0032"
// DWORD           FileSize (For allocating memory for decompressed data.)
// WORD            Uncompressed chunk size cbOrg. (required by decompressor)
// WORD            Compressed chunk size cbCmp.
// cbCmp bytes     Compressed data.
// ...             Repeat of the last 3 items.
//
///////////////////////////////////////////////////////////////////////////////

HRESULT ZipDecompressor::Decompress(LPVOID pvSrc, DWORD cbSrc,
                                    LPVOID *ppvDest, LPDWORD pcbDest)
{
    CompressedFile *pSrcFile = (CompressedFile *)pvSrc;

    // Get file size.

    *pcbDest = pSrcFile->m_dwOrgFileSize;

    // Allocate memory for decompressed data.

    if (FAILED(XMalloc(ppvDest, *pcbDest)))
        return DXFILEERR_BADALLOC;

    // Copy over header.

    UnCompressedFile *pDestFile = (UnCompressedFile *)(*ppvDest);

    memcpy(pDestFile, pSrcFile, DXFILE_HEADER_LEN);

    // Convert header file format field.

    if (pDestFile->m_dwFormat == XFILE_FORMAT_BINARY_ZIP)
        pDestFile->m_dwFormat = XFILE_FORMAT_BINARY;
    else if (pDestFile->m_dwFormat == XFILE_FORMAT_TEXT_ZIP)
        pDestFile->m_dwFormat = XFILE_FORMAT_TEXT;

    // Prepare for the loop.

    CmpBlock *pCmpBlock = pSrcFile->m_pCmpBlock;

    LPBYTE pDest = pDestFile->m_pData;

    LPBYTE pEnd = (LPBYTE)pvSrc + cbSrc;

    HRESULT hr = NOERROR;

    while ((LPBYTE)pCmpBlock < pEnd) {
        // Don't change m_bufDest content.

        if (NFM_Prepare(m_nfmContext,
                        pCmpBlock->m_pData, pCmpBlock->m_cbData,
                        (LPBYTE)m_bufDest, BLOCKSIZE) != NFMsuccess) {
            hr = E_FAIL;
            break;
        }

        UINT cbDestRet = pCmpBlock->m_cbOrg;

        if (NFM_Decompress(m_nfmContext, &cbDestRet) != NFMsuccess ||
            cbDestRet != pCmpBlock->m_cbOrg) {
            hr = E_FAIL;
            break;
        }

        memcpy (pDest, m_bufDest, pCmpBlock->m_cbOrg);
        pDest += pCmpBlock->m_cbOrg;
        pCmpBlock = (CmpBlock *)(pCmpBlock->m_pData + pCmpBlock->m_cbData);
    }

    if (FAILED(hr))
        XFree(*ppvDest);

    return hr;
}

HRESULT DecompressFile_Zip(XSource *pSrc, XSrcMemory **ppSrcMem)
{
    HRESULT hr;

    ZipDecompressor decompressor;

    if (!decompressor.Init())
        return DXFILEERR_BADALLOC;

    LPVOID pvSrc, pvDest;
    DWORD cbSrc, cbDest;

    if (FAILED(hr = pSrc->GetFile(&pvSrc, &cbSrc)))
        return hr;

    if (FAILED(hr = decompressor.Decompress(pvSrc, cbSrc, &pvDest, &cbDest)))
        return hr;

    *ppSrcMem = new XSrcMemory(pvDest, cbDest, TRUE);

    if (!*ppSrcMem)
        return DXFILEERR_BADALLOC;

    return DXFILE_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\xzip.h ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   xzip.h
//
//  Description:    Functions to compress/decompress X files with mszip.
//
//  History:
//      02/16/98    CongpaY     Created
//
//**************************************************************************

#ifndef _XZIP_H_
#define _XZIP_H_

class UnCompressedFile
{
public:
    DWORD m_dwMagic;
    DWORD m_dwVersion;
    DWORD m_dwFormat;
    DWORD m_dwFloatSize;
    BYTE  m_pData[1];
};

class CmpBlock
{
public:
    WORD m_cbOrg;
    WORD m_cbData;
    BYTE m_pData[1];
};

class CompressedFile
{
public:
    DWORD m_dwMagic;
    DWORD m_dwVersion;
    DWORD m_dwFormat;
    DWORD m_dwFloatSize;
    DWORD m_dwOrgFileSize;
    CmpBlock m_pCmpBlock[1];
};

class ZipDecompressor
{
    LPVOID    m_nfmContext;
    MI_MEMORY m_bufDest;

public:
    ZipDecompressor();
    ~ZipDecompressor();

    BOOL Init();

    HRESULT Decompress(LPVOID pvSrc, DWORD cbSrc,
                       LPVOID *ppvDest, LPDWORD pcbDest);
};

#endif // _XZIP_H_

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\kdexts\help.cpp ===
#include "precomp.hpp"

VOID HelpStats(VOID)
{
    dprintf("Stats - dumps various counters\n");
    dprintf("        No options dumps everything\n");
    dprintf("  -a: dump API counters\n");
    dprintf("  -r: dump render state counters\n");
    dprintf("  -t: dump texture stage state counters\n");
    dprintf("  -i: dump internal counters\n");
    dprintf("  -p: dump perf counters\n");
    dprintf("  -h: display help info\n");
    dprintf("  -?: display help info\n");
}

VOID HelpHelp(VOID)
{
    dprintf("Help - shows this help info\n");
}

VOID HelpDumper(VOID)
{
    dprintf("Dumper - dumps push-buffer / hardware state\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\kdexts\kdexts.cpp ===
#include "precomp.hpp"

EXT_API_VERSION ApiVersion =
{
    (VER_PRODUCTVERSION_W >> 8),
    (VER_PRODUCTVERSION_W & 0xff),
    EXT_API_VERSION_NUMBER,
    0
};

WINDBG_EXTENSION_APIS ExtensionApis;

VOID WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion)
{
    ExtensionApis = *lpExtensionApis;
}

VOID CheckVersion(
    VOID)
{
}

LPEXT_API_VERSION ExtensionApiVersion(
    VOID)
{
    return &ApiVersion;
}

BOOLEAN WINAPI DllMain(
    HINSTANCE hInstDll,
    DWORD fdwReason,
    LPVOID lpvReserved)
{
    return TRUE;
}

DECLARE_API(help)
{
    HelpHelp();
    HelpStats();
    HelpDumper();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\kdexts\option.cpp ===
#include "precomp.hpp"

BOOL IsOption(const char *s, char opt)
{
    while (s != NULL && *s != '\0')
    {
        if (*s == '-')
        {
            while (*++s)
            {
                if (*s == opt)
                {
                    return TRUE;
                }
            }
        }
        else
        {
            s++;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\kdexts\precomp.hpp ===
// public headers
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define NOGDI
#include <windows.h>
#include <wdbgexts.h>
#include <ntverp.h>
#include <d3d8.h>

// DXG private headers
#include "nv32.h"
#include "stats.hpp"
#include "dumper.hpp"

BOOL IsOption(const char *s, char opt);

VOID HelpStats(VOID);
VOID HelpHelp(VOID);
VOID HelpDumper(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\kdexts\dumper.cpp ===
#include "precomp.hpp"

using namespace D3D;

#if DBG

#define STATE_SIZE (65536 / 4)

//------------------------------------------------------------------------------
// BitField
//
// Given a dword and a bitfield range like 5:2, returns the numeric value.

DWORD BitField(
    DWORD Value,
    DWORD HighBit,
    DWORD LowBit)
{
    if (HighBit != 31)
    {
        Value &= ((1 << (HighBit + 1)) - 1);
    }

    Value >>= LowBit;

    return Value;
}

//------------------------------------------------------------------------------
// PrintFloat
//
// Hack-around to remove our sprintf CRT depedency, since libcntpr.lib 
// (currently) does not support floats with printf.

VOID PrintFloat(
    float* f)
{
    DWORD scaled = (DWORD) (*f * 1000.0f);

    dprintf("%li.%03li", scaled / 1000, scaled % 1000);
}

//------------------------------------------------------------------------------
// ShowDump()
//
// Show a dump of the current register state.

DECLARE_API(dumper)
{
    DWORD method;
    DWORD fieldCount;
    DWORD i;
    DWORD j;
    DWORD* pState;
    BOOL* pModified;
    FieldDescription* pField;
    FieldDescription* pFieldLimit;
    FieldDescription* pThis;
    BOOL showIt;
    DWORD ParseState[STATE_SIZE];
    BOOL Modified[STATE_SIZE];
    DWORD subch = 0;
    ULONG addr;

    addr = GetExpression("D3D__g_ParseState");
    if (addr == 0)
    {
        dprintf("Error: can't get g_ParseState address\n");
        return;
    }

    if (ReadMemory(addr, (PVOID)ParseState, sizeof(ParseState), NULL) == 0)
    {
        dprintf("Error: can't read memory for g_ParseState\n");
        return;
    }

    addr = GetExpression("D3D__g_Modified");
    if (addr == 0)
    {
        dprintf("Error: can't get g_Modified address\n");
        return;
    }

    if (ReadMemory(addr, (PVOID)Modified, sizeof(Modified), NULL) == 0)
    {
        dprintf("Error: can't read memory for g_Modified\n");
        return;
    }

    pField = (FieldDescription*)g_Kelvin;
    pFieldLimit = pField + ((sizeof(g_Kelvin) / sizeof(g_Kelvin[0])) - 1);
    pState = &ParseState[(subch << 13) >> 2];
    pModified = &Modified[(subch << 13) >> 2];

    dprintf("-----------------------------------------------------------\n");

    // Loop through the description array in order:

    while (pField < pFieldLimit)
    {
        showIt = FALSE;
        for (i = 0; i < pField->ReplicationCount[0]; i++)
        {
            for (j = 0; j < pField->ReplicationCount[1]; j++)
            {
                method = pField->Method
                       + i * pField->ReplicationStride[0]
                       + j * pField->ReplicationStride[1];

                if (pState[method >> 2] != 0)
                    showIt = TRUE;
            }
        }

        // Don't show fields that have zero values, or any fields with
        // capital letter 'types' (which denote read-only fields):

        if ((showIt) &&
            !((pField->FieldType >= 'A') && (pField->FieldType <= 'Z')))
        {
            // Handle replications specially:

            if (pField->ReplicationCount[0] > 1)
            {
                // Handle 1-d replications of dword values specially:

                if ((pField->ReplicationCount[1] <= 1) &&
                    (pField->ReplicationCount[0] > 1) &&
                    (pField->FieldHighBit == 31) &&
                    (pField->FieldLowBit == 0))
                {
                    // SET_MODEL_VIEW_MATRIX0 0x400
                    //     Zero:    0.0    1.0   2.0   3.0

                    dprintf("0x%lx - %s\n    %-20s:\t",
                               pField->Method,
                               pField->MethodName,
                               pField->FieldName);
                                            
                    for (i = 0; i < pField->ReplicationCount[0]; i++)
                    {
                        // Insert a return to make matrices appear 4x4:

                        if ((i > 0) && 
                            ((i & 3) == 0) && 
                            (pField->ReplicationCount[0] == 16))
                        {
                            dprintf("\n\t\t\t\t");
                        }

                        method = pField->Method 
                               + i * pField->ReplicationStride[0];

                        if (pField->FieldType == 'f')
                        {
                            PrintFloat((float*) &pState[method >> 2]);
                            dprintf(" \t");
                        }
                        else
                        {
                            dprintf("0x%lx\t", pState[method >> 2]);
                        }
                    }

                    dprintf("\n");
                }
                else
                {
                    for (i = 0; i < pField->ReplicationCount[0]; i++)
                    {
                        // Handle all 2-d replications specially.
                        // We assume there's no bitfields stuff in 2-d 
                        // replications.
    
                        if (pField->ReplicationCount[1] > 1)
                        {
                            // 0x800 - SET_LIGHT_AMBIENT_COLOR(3)
                            //     Zero:   0.0    0.0    0.0   0.0
        
                            dprintf("0x%lx - %s(%li)\n    %-20s:\t",
                                       pField->Method,
                                       pField->MethodName,
                                       i,
                                       pField->FieldName);
            
                            for (j = 0; j < pField->ReplicationCount[1]; j++)
                            {
                                // Insert a return to make matrices appear 4x4:
        
                                if ((j > 0) && 
                                    ((j & 3) == 0) && 
                                    (pField->ReplicationCount[1] == 16))
                                {
                                    dprintf("\n\t\t\t\t");
                                }
        
                                method = pField->Method 
                                       + i * pField->ReplicationStride[0]
                                       + j * pField->ReplicationStride[1];
        
                                if (pField->FieldType == 'f')
                                {
                                    PrintFloat((float*) &pState[method >> 2]);
                                    dprintf("\t ");
                                }
                                else
                                {
                                    dprintf("0x%lx\t", pState[method >> 2]);
                                }
                            }
        
                            dprintf("\n");
                        }
                        else
                        {
                            // 0x218 - SET_TEXTURE_FORMAT(2)
                            //     CONTEXT_DMA:     0x0
                            //     ENABLE:          0x0

                            method = pField->Method 
                                   + i * pField->ReplicationStride[0];

                            dprintf("0x%lx - %s(%li)\t\t\t0x%lx\n",
                                       pField->Method,
                                       pField->MethodName,
                                       i,
                                       pState[method >> 2]);

                            for (pThis = pField; 
                                 pThis->Method == pField->Method;
                                 pThis++)
                            {
                                dprintf("    %-20s:\t0x%lx\n",
                                           pThis->FieldName,
                                           BitField(pState[method >> 2],
                                                    pThis->FieldHighBit,
                                                    pThis->FieldLowBit));
                            }
                        }
                    }
                }
            }
            else
            {
                // SET_SURFACE_CLIP_HORIZONTAL 0x200
                //     X:   0x0
                //     WIDTH:   0x1e0

                method = pField->Method;

                dprintf("0x%lx - %s\t\t\t0x%lx\n",
                           pField->Method,
                           pField->MethodName,
                           pState[method >> 2]);

                if (pField->FieldType == 'f')
                {
                    dprintf("    %-20s:\t",
                               pField->FieldName);
                    PrintFloat((float*) &pState[method >> 2]);
                    dprintf("\n");
                }
                else
                {
                    for (pThis = pField; 
                         pThis->Method == pField->Method;
                         pThis++)
                    {
                        dprintf("    %-20s:\t0x%lx\n",
                                   pThis->FieldName,
                                   BitField(pState[method >> 2],
                                            pThis->FieldHighBit,
                                            pThis->FieldLowBit));
                    }
                }
            }
        }

        // Advance and skip over any multiple bitfields for this method 
        // (since we already handled them above):

        pThis = pField;
        do {
            pField++;
        } while (pField->Method == pThis->Method);
    }
}

#else // DBG

DECLARE_API(dumper)
{
    dprintf("Dumper extention works for checked builds only\n");
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\kdexts\stats.cpp ===
#include "precomp.hpp"

using namespace D3D;

#if DBG

VOID DumpPerf(VOID)
{
    DWORD id;
    DWORD i;
    CHAR* string;
    ULONG addr;
    DWORD Count[D3DPERF_MAX];
    
    addr = GetExpression("D3D__g_PerfCounters");
    if (addr == 0)
    {
        dprintf("Error: can't get g_PerfCounters address\n");
        return;
    }

    if (ReadMemory(addr, (PVOID)Count, sizeof(Count), NULL) == 0)
    {
        dprintf("Error: can't read memory for g_PerfCounters\n");
        return;
    }

    dprintf("\nPerf counters:\n");

    for (id = 0; id < D3DPERF_MAX; id++)
    {
        if (Count[id])
        {
            dprintf("%10li  %s\n", Count[id], g_PerfNames.m_PerformanceCounterNames[id]);
        }
    }
}

VOID DumpApiCount(VOID)
{
    DWORD id;
    DWORD i;
    CHAR* string;
    ULONG addr;
    DWORD Count[D3DAPI_MAX];

    addr = GetExpression("D3D__g_PerfCounters");
    if (addr == 0)
    {
        dprintf("Error: can't get g_PerfCounters address\n");
        return;
    }

    addr += (ULONG)&((D3DPERF *)0)->m_APICounters;

    if (ReadMemory(addr, (PVOID)Count, sizeof(Count), NULL) == 0)
    {
        dprintf("Error: can't read memory for g_PerfCounters\n");
        return;
    }

    dprintf("API counters:\n");

    for (id = 0; id < D3DAPI_MAX; id++)
    {
        if (Count[id])
        {
            dprintf("%10li  %s\n", Count[id], g_PerfNames.m_APICounterNames[id]);
        }
    }
}

VOID DumpTextureStageState(VOID)
{
    DWORD id;
    DWORD i;
    CHAR* string;
    ULONG addr;
    DWORD Count[D3DTSS_MAX];

    addr = GetExpression("D3D__g_PerfCounters");
    if (addr == 0)
    {
        dprintf("Error: can't get g_PerfCounters address\n");
        return;
    }

    addr += (ULONG)&((D3DPERF *)0)->m_TextureStateCounters;

    if (ReadMemory(addr, (PVOID)Count, sizeof(Count), NULL) == 0)
    {
        dprintf("Error: can't read memory for g_PerfCounters\n");
        return;
    }

    dprintf("\nTextureStageState counters:\n");

    for (id = 0; id < D3DTSS_MAX; id++)
    {
        if (Count[id])
        {
            string = "Missing Description";

            for (i = 0; 
                 i < sizeof(g_PerfNames.m_TextureStateNames) / sizeof(g_PerfNames.m_TextureStateNames[0]);
                 i++)
            {
                if (g_PerfNames.m_TextureStateNames[i].m_State == id)
                {
                    string = g_PerfNames.m_TextureStateNames[i].m_Name;
                    break;
                }
            }

            dprintf("%10li  %s\n", Count[id], string);
        }
    }
}

VOID DumpRenderState(VOID)
{
    DWORD id;
    DWORD i;
    CHAR* string;
    ULONG addr;
    DWORD Count[D3DRS_MAX];

    addr = GetExpression("D3D__g_PerfCounters");
    if (addr == 0)
    {
        dprintf("Error: can't get g_PerfCounters address\n");
        return;
    }

    addr += (ULONG)&((D3DPERF *)0)->m_RenderStateCounters;

    if (ReadMemory(addr, (PVOID)Count, sizeof(Count), NULL) == 0)
    {
        dprintf("Error: can't read memory for g_PerfCounters\n");
        return;
    }

    dprintf("\nRenderState counters:\n");

    for (id = 0; id < D3DRS_MAX; id++)
    {
        if (Count[id])
        {
            string = "Missing Description";

            for (i = 0; 
                 i < sizeof(g_PerfNames.m_RenderStateNames) / sizeof(g_PerfNames.m_RenderStateNames[0]);
                 i++)
            {
                if (g_PerfNames.m_RenderStateNames[i].m_State == id)
                {
                    string = g_PerfNames.m_RenderStateNames[i].m_Name;
                    break;
                }
            }

            dprintf("%10li  %s\n", Count[id], string);
        }
    }
}

DECLARE_API(stats)
{
    const char *s;

    if (args[0] == '\0')
    {
        s = "-artp";
    }
    else
    {
        s = args;
    }

    if (IsOption(s, '?') || IsOption(s, 'h'))
    {
        HelpStats();
    }

    if (IsOption(s, 'a'))
    {
        DumpApiCount();
    }

    if (IsOption(s, 'r'))
    {
        DumpRenderState();
    }

    if (IsOption(s, 't'))
    {
        DumpTextureStageState();
    }

    if (IsOption(s, 'p'))
    {
        DumpPerf();
    }
}

#else // DBG

DECLARE_API(stats)
{
    dprintf("Stats extention works for checked builds only\n");
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\andrewgo\console\mrmath.c ===
/****************************** Module Header ******************************\
* Module Name: mrmath.c
*
* Copyright (c) 1992, Microsoft Corporation
*
* Simple test program for stressing the FPU.
*
* History:
*  18-Jul-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

#include <windows.h>
#include <stdlib.h>
#include <time.h>
#include <stdio.h>
#include <float.h>
#include <math.h>

int __cdecl main(int argc, char** argv)
{
    UINT i;
    UINT result;

    printf("Divide by 3 approximation:\n");

    for (i = 0; i < 65536; i ++)
    {
        result = ((i * (0x10000 / 3)) + (0x10000 / 3)) >> 16;

        if (result != (i / 3))
            printf("i: %li  result: %li\n", i, result);
    }

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\misc\dpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.h
 *  Content:    header file for debug printf
 *
 ***************************************************************************/

// These macros are used for debugging. They expand to
// whitespace on a free build.
//
// DebugLevel
//  Global variable which holds the current debug level. You can use it to
//  control the quantity of debug messages emitted.
//
//  Okay, so I haven't actually bothered to implement this yet.  But it
//  could happen.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ASSERT(cond)
//  Verify that a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify that a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//
//  These macros require extra parentheses for the msg argument
//  for example:
//      WARNING(("App passed NULL pointer; ignoring it.\n"));
//      ASSERTMSG(x > 0, ("x is less than 0\n"));
//
//  Note that you need to put a trailing \n on the message.

#if defined(DBG)
    
    // DebugPrint is actually just a forward to the kernel's DebugPrint.
    // It is vastly superior to OutputDebugString because it takes
    // varargs...

    #if defined(__cplusplus)
        extern "C" ULONG DebugPrint(const char *Format, ...);
    #else
        ULONG DebugPrint(PCHAR Format, ...);
    #endif

    #define WARNING(msg)        \
        {                       \
            DebugPrint msg;     \
            DebugPrint("\n");   \
        }
    
    #define RIP(msg)            \
        {                       \
            DebugPrint msg;     \
            DebugPrint("\n");   \
            _asm { int 3 };     \
        }
    
    #undef ASSERT
    #define ASSERT(cond)   \
        {                  \
            if (! (cond))  \
            {              \
                RIP(("Assertion failure: %s", #cond)); \
            }              \
        }

    #undef ASSERTMSG
    #define ASSERTMSG(cond, msg) \
        {                        \
            if (! (cond))        \
            {                    \
                RIP(msg);        \
            }                    \
        }

    #define DPF(msg) RIP(msg)
    #define DPF_ERR(msg) RIP((msg))
    #define D3D_ERR(msg) RIP((msg))
    #define DXGASSERT(cond) ASSERT(cond)
    #define DDASSERT(cond) ASSERT(cond)
    #define UNIMPLEMENTED() RIP(("D3D: Function not yet implemented"))

#else

    #define WARNING(msg) {}
    #define RIP(msg) {}

    #undef ASSERT
    #define ASSERT(cond) {}

    #undef ASSERTMSG
    #define ASSERTMSG(cond, msg) {}

    #define DPF(msg) {}
    #define DPF_ERR(msg)
    #define D3D_ERR(msg)
    #define DXGASSERT(cond)
    #define DDASSERT(cond)
    #define UNIMPLEMENTED()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\andrewgo\simple\sdkcommon.h ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    SDKCommon.h

Abstract:

    Common header files and macros for the Xbox SDK

Revision History:

--*/

#if !defined(SDK_HEADER_SDKCOMMON_H)
#define SDK_HEADER_SDKCOMMON_H

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#if defined(__cplusplus)
extern "C" {
#endif // __cplusplus


#ifndef STRICT
#define STRICT 1
#endif
#undef D3D_OVERLOADS

// Windows headers
#include "Windows.h"
#include "D3D8.h"

#pragma warning (disable:4850)

// __$ReturnUdt is the address of the destination when returning a structure
// It is Microsoft specific so will need to be adjusted to work with other
// compilers. The best way is to declare a local of the correct type and
// then return in.
#define that_ptr __$ReturnUdt

#if defined(__cplusplus)
}
#endif // __cplusplus

#endif //#ifndef SDK_HEADER_RENDERSURFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\misc\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

// Note that RtlAllocateHeap(XapiProcessHeap()), which is what LocalAlloc
// amounts to on Xbox, has 8 byte alignment:

#define MemAlloc(size) ((VOID*) LocalAlloc(LMEM_ZEROINIT, size))
#define MemAllocNoZero(size) ((VOID*) LocalAlloc(0, size))
#define MemReAlloc(p, size) ((VOID*) LocalReAlloc(p, size, LMEM_ZEROINIT))
#define MemFree(p) LocalFree((p))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\andrewgo\simple\main.cpp ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Complete DX8 application to draw a screen space triangle.

Revision History:

    Derived from a DX8 sample.
--*/
#include <SDKCommon.h>

#define CheckHR(x) if ((x) != S_OK) _asm int 3;

bool                       bQuit   = false;
IDirect3DDevice8*          pDev  = NULL;
IDirect3DVertexBuffer8*    pVB   = NULL;

extern "C"
{
    BOOL _fltused;
}

//------------------------------------------------------------------------------
bool InitD3D
(
    HWND hWnd
)
//--------------------------------------
{
    static int doneOnce; 
    if (!doneOnce)       
    {                    
        { ; }  
        doneOnce=1;      
    }                    

    // Create D3D 8.
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    if (pD3D == NULL)
        return false;

    // Set the screen mode.
    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount           = 1;
    d3dpp.Windowed                  = false;   // Must be false for Xbox.
    d3dpp.EnableAutoDepthStencil    = true;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_UNKNOWN_D24S8;
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz= 60;
    d3dpp.hDeviceWindow             = hWnd;

    // Create the device.
    if (pD3D->CreateDevice
    (
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        hWnd,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        &pDev
    ) != S_OK)
    {
        return false;
    }

    // Now we no longer need the D3D interface so lets free it.
    pD3D->Release();

    return true;
}

static struct { float x,y,z,w; DWORD color; } Vertices0[] =
{
    {   0,   0, 0.5f, 1, 0xff000000 },
    {   0, 480, 0.5f, 1, 0xffff0000 },
    { 640,   0, 0.5f, 1, 0xff00ff00 },
    { 640, 480, 0.5f, 1, 0xff0000ff }
};

static struct { float x,y,z,w; DWORD color; float u,v; } Vertices[] =
{
    {   0,   0, 0.5f, 1, 0xffffffff, 0.25f, 0.25f },
    {   0, 480, 0.5f, 1, 0xffffffff, 0.25f, 0.75f },
    {   0,   0,    0, 0,          0,     0,     0 },
    { 640,   0, 0.5f, 1, 0xffffffff, 0.75f, 0.25f },
    { 640, 480, 0.5f, 1, 0xffffffff, 0.75f, 0.75f }
};

static short Indices[] =
{
    0, 1, 3, 1, 3, 4
};


//------------------------------------------------------------------------------
void Paint
(
)
//--------------------------------------
{
    IDirect3DSurface8* pBackBuffer;
    IDirect3DVertexBuffer8* pVertexBuffer;
    IDirect3DIndexBuffer8* pIndexBuffer;
    IDirect3DTexture8* pTexture;
    D3DLOCKED_RECT lockData;
    DWORD* pdwData;
    BYTE* pbData;
    INT i;

    CheckHR(pDev->Clear(0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0X00ffffff, 1.0, 0));

    CheckHR(pDev->CreateVertexBuffer(sizeof(Vertices), D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1,
            D3DUSAGE_WRITEONLY, D3DPOOL_DEFAULT, &pVertexBuffer));

    CheckHR(pVertexBuffer->Lock(0, sizeof(Vertices), &pbData, 0));
    memcpy(pbData, Vertices, sizeof(Vertices));
    CheckHR(pVertexBuffer->Unlock());

    CheckHR(pDev->CreateTexture(2, 2, 1, 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &pTexture));

    CheckHR(pTexture->LockRect(0, &lockData, NULL, 0));

    pdwData = (DWORD*) lockData.pBits;
    *(pdwData)     = 0xffff0000;
    *(pdwData + 1) = 0xff00ff00;
    pdwData = (DWORD*) ((BYTE*) pdwData + lockData.Pitch);
    *(pdwData)     = 0xff0000ff;
    *(pdwData + 1) = 0xff000000;

    CheckHR(pTexture->UnlockRect(0));

    CheckHR(pDev->SetTexture(0, pTexture));

    CheckHR(pDev->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR));

    CheckHR(pDev->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1));

    CheckHR(pDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE));

    CheckHR(pDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 
                                         0, // MinVertexIndex
                                         5, // NumVertices
                                         2, // PrimitiveCount
                                         &Indices, // pIndexData
                                         D3DFMT_INDEX16, // IndexDataFormat
                                         Vertices,
                                         sizeof(Vertices[0])));

    pDev->Present(NULL, NULL, NULL, NULL);

    pTexture->Release();

    pVertexBuffer->Release();
}

#if !defined(XBOX)

//------------------------------------------------------------------------------
LRESULT WINAPI MessageHandler
(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
//--------------------------------------
{
    if (Msg == WM_DESTROY)
        PostQuitMessage(0);

    return DefWindowProc(hWnd, Msg, wParam, lParam);
}

//------------------------------------------------------------------------------
int APIENTRY WinMain
(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpCmdLine,
    int         nCmdShow
)
//--------------------------------------
{
    MSG msg;

    WNDCLASSEX classex;
    ZeroMemory( &classex, sizeof(classex) );

    classex.cbSize          = sizeof(WNDCLASSEX);
    classex.style           = CS_CLASSDC;
    classex.lpfnWndProc     = MessageHandler;
    classex.hInstance       = hInstance;
    classex.lpszClassName   = L"XBOX";
    RegisterClassEx(&classex);

    HWND hwnd = CreateWindowEx(WS_EX_TOPMOST, L"XBOX", L"XBOX Basic Shell",
                          WS_VISIBLE|WS_POPUP,
                          CW_USEDEFAULT,CW_USEDEFAULT, 0, 0,
                          NULL, NULL, hInstance, NULL);

    if (!InitD3D(hwnd))
    {
        return EXIT_FAILURE;
    }

    ShowCursor(false);

    while (!bQuit)
    {
        while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
        {
            if (!GetMessage(&msg, NULL, 0, 0))
            {
                bQuit = true;
            }

            TranslateMessage(&msg);
            DispatchMessage(&msg);

            Paint();
        }
    }

    return EXIT_SUCCESS;
}

#else

extern "C"
DWORD
WINAPI
TestMain()
{
    _asm nop;
    _asm int 3;
    _asm nop;

    if (!InitD3D(NULL))
    {
        return(0);
    }

    while (TRUE)
    {
        Paint();
    }

    return(TRUE);
}

#endif // defined(XBOX)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\andrewgo\simple\sources.inc ===
TARGETNAME=Simple
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    main.cpp \
    main.rc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\benmark\sources.inc ===
TARGETNAME=BenMark
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    benmark5.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\billboard\sources.inc ===
TARGETNAME=Billbrd
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    billboard.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\clipmirror\sources.inc ===
TARGETNAME=ClipMir
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    clipmirror.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\benmark\benmark5.cpp ===
//-----------------------------------------------------------------------------
// FILE: BENMARK5.CPP
//
// Desc: Main BenMark file. This was all based on the dx7
//  BenMark5 Ribbons exe written by Ben DeWaal of nVidia.
//
// Ben says: "The key point here is NOT to use D3DVBCAPS_SYSTEMMEMORY.
//  It will halve the triangle rate."
//
// Copyright (c) 1999-2000 NVIDIA Corporation. All rights reserved.
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#define STRICT

#ifdef XBOX
#include <xtl.h>
#include <xgraphics.h>
#else
#include <windows.h>
#include <D3DX8.h>
#endif
#include <stdio.h>
#include <math.h>
#include "D3DApp.h"
#include "DXUtil.h"

#ifdef USE_SOUND
#include "dsound.h"

///
/// Set up necessary types
/// 

typedef short* LPSHORT;

///
/// Setup the frequency, and define PI
///

static const double FREQ = 440;
static const double PI = 3.1415926535;

///
/// Scaling factors
///
/// ISCALE is used to convert an interger [0, 44099] to a double [0, 2PI]
/// DATASCALE is used to conver a double [-1.0, 1.0] to an integer [-32767, 32767]

static const double ISCALE = 2.0 * PI / 44099.0;
static const double DATASCALE = 32767.0 / 1.0;

///
/// the main sine player code
///

HRESULT PlaySineWave( void )
{

	///
	/// create a dsound buffer and a data buffer
	///

    HRESULT hr = S_OK;
	LPDIRECTSOUNDBUFFER pDSBuffer = NULL;
	LPSHORT pData = NULL;

	///
	/// place to hold the number of bytes allocated by dsound
	///

	DWORD dwBytes = 0;

	///
	/// allocate space for calculate argument to sin, return value from sine, and actual integer value
	///

	double dArg = 0.0;
	double dSinVal = 0.0;
	SHORT sVal = 0;
   
	///
	/// allocate the dsound buffer description and the wave format
	///

	DSBUFFERDESC dsbd;
	WAVEFORMATEX wfx;

	///
	/// It's always safe to zero out stack allocated structs
	///

	ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
	ZeroMemory( &wfx, sizeof( DSBUFFERDESC ) );

	///
	/// setup the waveformat description to be PCM, 44100hz, 16bit, mono
    ///

	wfx.cbSize = 0;
	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 1;
	wfx.nSamplesPerSec = 44100;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = 2;
	wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;

	///
	/// setup the dsound buffer description with the waveformatex
	///

	dsbd.dwBufferBytes = wfx.nAvgBytesPerSec;
	dsbd.dwFlags = 0;
	dsbd.dwSize = sizeof( DSBUFFERDESC );
	dsbd.lpwfxFormat = &wfx;
    //dsbd.dwMixBins = DSMIXBIN_FXSEND_0;

	/// 
	/// Create the dsound buffer
	///

	hr = DirectSoundCreateBuffer( &dsbd, &pDSBuffer );

	///
	/// start the dsound buffer playing in a loop mode
	///

	if ( SUCCEEDED( hr ) )
	{
		hr = pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );
	}

	///
	/// continue forever (or until an error occurs)
	///

	if ( SUCCEEDED( hr ) )
	{

		///
		/// get a buffer from dsound using lock
		///

		hr = pDSBuffer->Lock( 0, dsbd.dwBufferBytes, (LPVOID*) &pData, &dwBytes, NULL, NULL, 0 );

		///
		/// go through the buffer 2 bytes (1 short) at a time
		///

		for( DWORD i = 0; SUCCEEDED( hr ) && i < dsbd.dwBufferBytes / 2; i++ )
		{	
			///
			/// calculate the sin value
			///

			dArg = (double) i * ISCALE;
			dSinVal = sin( FREQ * dArg );
			sVal = (SHORT) ( dSinVal * DATASCALE );

			///
			/// copy the value into the dsound buffer
			///

			pData[i] = sVal;
		}

    }
    
    //
    // leave with the buffer still playing..
    //

    return hr;
}

#endif // USE_SOUND

extern "C" ULONG DebugPrint(PCHAR Format, ...);

const DWORD cdwRibbonCount  = 25;

const float cfRibbonCurl    = 60.0f * D3DX_PI;
const float cfRibbonPitch   = 3.25f;
const float cfRibbonWidth   = 0.04f;
const float cfRibbonRadius  = 0.05f;

const DWORD cdwSubsInLength = 1200;
const DWORD cdwSubsInWidth  = 5;

static ScenarioMenu s_Button7Menu = 
{
	MT_BUTTON7,
	L"Toggle Effects",
	{
		L"Toggle specular lighting",
		L"Toggle Z buffer",
		L"Toggle local view",
		NULL,
		NULL,
		NULL
	},
	3
};

static ScenarioMenu s_Button8Menu = 
{
	MT_BUTTON8,
	L"Lighting",
	{
		L"Add directional light",
		L"Add spot light",
		L"Add point light",
		L"Remove directional light",
		L"Remove spot light",
		L"Remove point light"
	},
	6
};

static ScenarioMenu s_Button9Menu = 
{
	MT_BUTTON9,
	L"Performance",
	{
		L"Toggle number of Textures from 0 - 2",
		L"Toggle Triangle List / Triangle Strip",
		L"Toggle Solid/Point/Wireframe fillmode",
		L"Toggle DrawIndexedPrimitive/DrawIndexedPrimitiveUP routine",
        L"Toggle realtime/precompiled draws",
        NULL
	},
	5
};

/*
 * Application class. The base class provides just about all the
 * functionality we want, so we're just supplying stubs to interface with
 * the non-C++ functions of the app.
 */

class BenMark : public CD3DApplication
{

public:

	/*
	 * Support structures.
	 */

	// The different options for the test.
	struct BMXSTATE
	{
		UINT        cApplyTextures;
		bool		bUseTriList;
		bool        bZenable;
		bool        bSpecularenable;
		bool        bLocalviewer;

		int         nDirectionalLights;
		int         nSpotLights;
		int         nPointLights;

		int         iDrawFunc;
        bool        fPrecompile;
		D3DFILLMODE iFillMode; 
	};

	/*
	 * Geometry Constants
	 */

    enum DRAWFUNC
    {
        DF_DRAWINDEXEDPRIMITIVE,    // use vertexbuffer drawprim
        DF_DRAWINDEXEDPRIMITIVEUP,  // use user ptr drawprim
        DRAWMAX
    };

	void DrawIndexedPrimitive(UINT iIndex, D3DPRIMITIVETYPE dwPrimType, DWORD PrimitiveCount);
	void DrawIndexedPrimitiveUP(UINT iIndex, D3DPRIMITIVETYPE dwPrimType, DWORD PrimitiveCount);
	void PrecompiledDraw(UINT iIndex, D3DPRIMITIVETYPE dwPrimType, DWORD PrimitiveCount);

    typedef void (BenMark::*PFNDRAWRIBBON)(
        UINT                iIndex,
        D3DPRIMITIVETYPE    Type,
        DWORD               PrimitiveCount);

    PFNDRAWRIBBON m_pfnDrawRibbon;

	/*
	 * Our materials
	 */

	D3DMATERIAL8 m_matIn;
	D3DMATERIAL8 m_matOut[cdwRibbonCount];

	/*
	 * Implementation
	 */

	void InitMaterials(D3DMATERIAL8 *pmatIn, D3DMATERIAL8 *pmatOut);
	void InitLights();
	IDirect3DTexture8 *CreateTexture(DWORD dwWidth, DWORD dwHeight);
	void InitIndices();
	void InitVBs();

    /* 
	 * Data members
	 */

	BMXSTATE				m_bmxState;
    WORD                   *m_pwIndices;    // user ptr to indices
    IDirect3DIndexBuffer8  *m_pIndexBuffer; // dx8 index buffer

    IDirect3DVertexBuffer8 *m_pVBRibbon[2]; // vb of verts
    BYTE                   *m_pVertices[2]; // user ptr to verts

#ifdef XBOX
    IDirect3DPushBuffer8   *m_pPushBuffer;  // precompiled push buffer
#endif

    IDirect3DTexture8      *m_pTexture1;    // texture1
    IDirect3DTexture8      *m_pTexture2;    // texture2
    IDirect3DSurface8      *m_pBackSurf;    // back surface ptr

    DWORD                   m_dwFVF;        // our current FVF
    DWORD                   m_dwFVFSize;    // FVF size

    DWORD                   m_dwIndexCount; // # indices
    DWORD                   m_dwNumVertices;// # verts

	DWORD					m_dwTotalTimes; // # of times the ribbons have been drawn

    DWORD                   m_dwTriCount;
    _D3DPRIMITIVETYPE       m_dwPrimType;
    float                   m_fDelta;

	int						m_nNumLights;	// # of allocated lights.

    LONG                    m_lDivides;
    int                     m_iMaxDivides;
    
	// long-term stats.
	double					m_fdAveTriPerSec;
	double					m_fdMaxTriPerSec;
	double					m_fdMinTriPerSec;

	DWORD					m_dwAveCount;

    // Background thread management.
    HANDLE                  m_hThread;
    bool                    m_fTerminateThread;

	/*
	 * Overridden members of the base class
	 */

    void InitDeviceObjects();
    void RestoreDeviceObjects();
    void DeleteDeviceObjects();
    void Render();
	void UpdateStats(float fElapsedTime);
	void ShowInfo(int iY, int cHeight);
	unsigned GetMenus(ScenarioMenu **rgMenus);
	void ProcessKeyPress(DWORD iMenu, DWORD iKey);

	/*
	 * Constructor
	 */

	BenMark();
};

//=========================================================================
// Entrypoint into the test.
//=========================================================================

#ifdef XBOX
void __cdecl main()
#else
INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )
#endif
{
#ifdef USE_SOUND
    PlaySineWave();
#endif // USE_SOUND

    BenMark app;

#ifdef XBOX
    app.Create(NULL);
#else
    app.Create(hInst);
#endif

    app.Run();

#ifndef XBOX
	return 0;
#endif  // ! XBOX
}

//=========================================================================
// BenMark constructor
//=========================================================================

BenMark::BenMark()
{
    m_pwIndices = NULL;
    m_pIndexBuffer = NULL;

    m_pVBRibbon[0] = NULL;
    m_pVBRibbon[1] = NULL;

    m_pVertices[0] = NULL;
    m_pVertices[1] = NULL;

#ifdef XBOX
    m_pPushBuffer  = NULL;
#endif

    m_pTexture1 = NULL;
    m_pTexture2 = NULL;
    m_pBackSurf = NULL;

    m_dwFVF = 0;
    m_dwFVFSize = 0;

    m_dwIndexCount = 0;
    m_dwNumVertices = 0;

    m_lDivides      = 0;
    m_dwAveCount     = 0;
    m_fdAveTriPerSec = 0.0;
    m_fdMaxTriPerSec = 0.0;
    m_fdMinTriPerSec = 1e199;

	m_nNumLights = 0;

    m_hThread = 0;

	ZeroMemory(&m_bmxState, sizeof(m_bmxState));

    m_bmxState.iDrawFunc   = DF_DRAWINDEXEDPRIMITIVE;
    m_bmxState.iFillMode   = D3DFILL_SOLID;

    m_bmxState.fPrecompile = false;

    m_bmxState.bZenable = true;

    m_bmxState.nDirectionalLights   = 1;
    m_bmxState.nSpotLights          = 0;
    m_bmxState.nPointLights         = 0;

    m_bUseDepthBuffer = TRUE;
    m_DepthBufferFormat = D3DFMT_D16;
}

//=========================================================================
// This creates all device-dependant managed objects, such as managed
// textures and managed vertex buffers.
//=========================================================================

void BenMark::InitDeviceObjects()
{
    InitMaterials(&m_matIn, m_matOut);

    m_pTexture1 = CreateTexture(8, 256);
    m_pTexture2 = CreateTexture(8, 256);
};

//=========================================================================
// Background thread loop.
//=========================================================================

DWORD WINAPI ThreadProc
(
  LPVOID lpParameter   // thread data
)
{
    BenMark *pMark = (BenMark *)lpParameter;

    while (!pMark->m_fTerminateThread)
    {
        for (volatile double i = 1000000000.0f; i != 0; i = i / 10.0f)
            ;

        InterlockedIncrement(&pMark->m_lDivides);
    }

    return 0;
}

//=========================================================================
// Restore device-memory objects and state after a device is created or 
// resized.
//
// This will manually get called any time an option changes so any
// option-specific initialization should go here.
//=========================================================================

void BenMark::RestoreDeviceObjects()
{
    // initalize our lights
    InitLights();

    // create our vertex buffers and indices
    InitVBs();

	// Set up our transformations.
    D3DXMATRIX mux;
    D3DXMatrixIdentity(&mux);
    D3DXMatrixTranslation(&mux, 0.0f, 0.0f, -10.0f);

    CheckHR(m_pDevice->SetTransform(D3DTS_VIEW, (D3DMATRIX*)&mux));

    D3DXMatrixPerspectiveFovRH(&mux,
                              D3DX_PI * 30.0f / 360.0f,
//                              (float)m_BackBufferDesc.Height / m_BackBufferDesc.Width,
                              (float)m_BackBufferDesc.Width / m_BackBufferDesc.Height,
                              1.0f,
                              19.0f);

    CheckHR(m_pDevice->SetTransform(D3DTS_PROJECTION, (D3DMATRIX*)&mux));

    // init some render states
    CheckHR(m_pDevice->SetRenderState(D3DRS_ZENABLE, m_bmxState.bZenable));
    CheckHR(m_pDevice->SetRenderState(D3DRS_SPECULARENABLE, m_bmxState.bSpecularenable));
    CheckHR(m_pDevice->SetRenderState(D3DRS_LOCALVIEWER, m_bmxState.bLocalviewer));
	CheckHR(m_pDevice->SetRenderState(D3DRS_FILLMODE, m_bmxState.iFillMode));
    CheckHR(m_pDevice->SetRenderState(D3DRS_LIGHTING, TRUE));

	// init some random states.
    m_fDelta     = 0.75f * cfRibbonPitch / (cdwRibbonCount - 1);

    // Create the background thread.
    m_fTerminateThread = FALSE;
    m_hThread = CreateThread(NULL, 0, ThreadProc, this, 0, NULL);
    SetThreadPriority(m_hThread, THREAD_PRIORITY_BELOW_NORMAL);

    DWORD dwTime = GetTickCount();
    m_lDivides = 0;
    
    Sleep(2000);

    LONG Divides = InterlockedExchange(&m_lDivides, 0);
    dwTime = GetTickCount() - dwTime;

    m_iMaxDivides = Divides * 1000 / dwTime;
};

//=========================================================================
// Called when the app is exitting, or the device is being changed,
// this function deletes any device dependant objects.
//=========================================================================

void BenMark::DeleteDeviceObjects()
{
    if (m_hThread)
    {
        m_fTerminateThread = TRUE;
        WaitForSingleObject(m_hThread, 2000);
    }

    delete[] m_pwIndices;
    m_pwIndices = NULL;

    delete[] m_pVertices[0];
    m_pVertices[0] = NULL;

    delete[] m_pVertices[1];
    m_pVertices[1] = NULL;

    SAFE_RELEASE(m_pIndexBuffer);

    SAFE_RELEASE(m_pVBRibbon[0]);
    SAFE_RELEASE(m_pVBRibbon[1]);

    SAFE_RELEASE(m_pTexture1);
    SAFE_RELEASE(m_pTexture2);

#ifdef XBOX
    SAFE_RELEASE(m_pPushBuffer);
#endif
}

//=========================================================================
// Draw Ben's ribbons
//=========================================================================

void BenMark::Render()
{
    //float fRotation2 = 2.0f * D3DX_PI / 2047.0f * float(dwNow & 2047);
    float fRotation2 = 2.0f * D3DX_PI / 2047.0f * m_fTime * 1023;

    // clear -- worth moving this calculation?
    DWORD dwFlags = (m_Presentation.AutoDepthStencilFormat != D3DFMT_UNKNOWN) ?
        D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER : D3DCLEAR_TARGET;

    CheckHR(m_pDevice->Clear(0, NULL, dwFlags, 0x00000000, 1.0f, 0L));

    // begin scene
    CheckHR(m_pDevice->BeginScene());

	// Set up the world translation.
    D3DXMATRIX matWorld;
    D3DXMatrixTranslation(&matWorld, 0.0f, -0.5f * 0.75f * cfRibbonPitch, 0.0f);

    // draw ribbons
    for (DWORD i = 0; i < cdwRibbonCount ; i++)
    {
        // setup matrix
        D3DXMATRIX matWorldT;

        D3DXMatrixRotationAxis(&matWorldT, &D3DXVECTOR3(1.0f, 0.0f, 0.0f),
            fRotation2 + i * 0.4f);
        matWorldT *= matWorld;

        // translate y by fDelta for the next line
        matWorld.m[3][1] += m_fDelta;

        // set our world transform
        CheckHR(m_pDevice->SetTransform(D3DTS_WORLD, (D3DMATRIX*)&matWorldT));

        // draw outside
        if(m_bmxState.cApplyTextures)
        {
            CheckHR(m_pDevice->SetTexture          (0, m_pTexture1));

            CheckHR(m_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1,D3DTA_TEXTURE));
            CheckHR(m_pDevice->SetTextureStageState(0, D3DTSS_COLOROP,  D3DTOP_MODULATE));
            CheckHR(m_pDevice->SetTextureStageState(0, D3DTSS_COLORARG2,D3DTA_DIFFUSE));

            CheckHR(m_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1,D3DTA_TEXTURE));
            CheckHR(m_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP,  D3DTOP_MODULATE));
            CheckHR(m_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2,D3DTA_DIFFUSE));

            if(m_bmxState.cApplyTextures > 1)
            {
                CheckHR(m_pDevice->SetTexture          (1, m_pTexture2));

                CheckHR(m_pDevice->SetTextureStageState(1, D3DTSS_COLORARG1,D3DTA_TEXTURE));
                CheckHR(m_pDevice->SetTextureStageState(1, D3DTSS_COLOROP,  D3DTOP_ADD));
                CheckHR(m_pDevice->SetTextureStageState(1, D3DTSS_COLORARG2,D3DTA_CURRENT));

                CheckHR(m_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1,D3DTA_TEXTURE));
                CheckHR(m_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP,  D3DTOP_ADD));
                CheckHR(m_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2,D3DTA_CURRENT));
            }
            else
            {
                CheckHR(m_pDevice->SetTextureStageState(1, D3DTSS_COLOROP,  D3DTOP_DISABLE));
                CheckHR(m_pDevice->SetTextureStageState(1, D3DTSS_ALPHAOP,  D3DTOP_DISABLE));
            }
        }

        CheckHR(m_pDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CW));
        CheckHR(m_pDevice->SetMaterial(&m_matOut[i]));

        // draw outside ribbon
        (this->*m_pfnDrawRibbon)(0, m_dwPrimType, m_dwTriCount);

        // draw inside
        if(m_bmxState.cApplyTextures)
        {
            CheckHR(m_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1,D3DTA_DIFFUSE));
            CheckHR(m_pDevice->SetTextureStageState(0, D3DTSS_COLOROP,  D3DTOP_SELECTARG1));
            CheckHR(m_pDevice->SetTextureStageState(1, D3DTSS_COLOROP,  D3DTOP_DISABLE));

            CheckHR(m_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1,D3DTA_DIFFUSE));
            CheckHR(m_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP,  D3DTOP_SELECTARG1));
            CheckHR(m_pDevice->SetTextureStageState(1, D3DTSS_ALPHAOP,  D3DTOP_DISABLE));
        }

        CheckHR(m_pDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW));
        CheckHR(m_pDevice->SetMaterial(&m_matIn));

        // draw inside ribbon
        (this->*m_pfnDrawRibbon)(1, m_dwPrimType, m_dwTriCount);

        // next
        m_dwTotalTimes += 2;
    }

    // end
    CheckHR(m_pDevice->EndScene());
}

//=========================================================================
// Called once a second or after a test run to update the 
// test status string.
//=========================================================================

void BenMark::UpdateStats(float fElapsedTime)
{
    LONG Divides = InterlockedExchange(&m_lDivides, 0);

    // next experiment?
    double rcp = 1e-6 / (double)fElapsedTime;
    double tps = double(m_dwTotalTimes * m_dwTriCount) * rcp;
    double sps = double(m_dwTotalTimes * m_dwIndexCount) * rcp;
    double ips = double(m_dwTotalTimes * m_dwIndexCount * 2) * rcp;
    double vps = double(m_dwTotalTimes * m_dwIndexCount * m_dwFVFSize) * rcp;
    double dps = double(Divides) / (double)fElapsedTime;

    swprintf(m_szTestStats, L"%i KTri/s, %i KVerts/s, %i KB/s index traffic, "
        L"%iKB/s [effective] vertex traffic, %i background thread loops/second", 
             (INT) (tps * 1000.0f), (INT) (sps * 1000.0f), 
             (INT) (ips * 1000.0f), (INT) (vps * 1000.0f),
             (INT) (dps));

    static DWORD count = 0;

    if (count++ == 0)
    {
        count = 0;
    
        DebugPrint("%i KTri/s, %i KVerts/s, %i KB/s index traffic, "
              "%iKB/s [effective] vertex traffic, %i K/s background thread loops\n", 
             (INT) (tps * 1000.0f), (INT) (sps * 1000.0f), 
             (INT) (ips * 1000.0f), (INT) (vps * 1000.0f),
             (INT) (dps * 1000.0f));
    }

	static bool isFirst = true;
	
	if (!isFirst)
	{
		m_dwAveCount++;
		m_fdAveTriPerSec += tps;
		m_fdMaxTriPerSec = max(tps, m_fdMaxTriPerSec);
		m_fdMinTriPerSec = min(tps, m_fdMinTriPerSec);
	}

	isFirst = false;

	m_dwTotalTimes = 0;
}

//=========================================================================
// initialize our materials
//=========================================================================

void BenMark::InitMaterials(D3DMATERIAL8 *pmatIn, D3DMATERIAL8 *pmatOut)
{
    // set material
    ZeroMemory(pmatOut, sizeof(D3DMATERIAL8) * cdwRibbonCount);
    for (DWORD i = 0; i < cdwRibbonCount; i++)
    {
        float r = 0.3f + 0.5f * float(rand()) / float(RAND_MAX);
        float g = 0.3f + 0.5f * float(rand()) / float(RAND_MAX);
        float b = 0.3f + 0.5f * float(rand()) / float(RAND_MAX);

        pmatOut[i].Diffuse.r  = r;
        pmatOut[i].Diffuse.g  = g;
        pmatOut[i].Diffuse.b  = b;
        pmatOut[i].Diffuse.a  = 1.0f;
        pmatOut[i].Ambient.r  = r * 0.3f;
        pmatOut[i].Ambient.g  = g * 0.3f;
        pmatOut[i].Ambient.b  = b * 0.3f;
        pmatOut[i].Ambient.a  = 1.0f;
    }

    // set material
    ZeroMemory(pmatIn, sizeof(D3DMATERIAL8));
    pmatIn->Diffuse.r  = 0.7f;
    pmatIn->Diffuse.g  = 0.3f;
    pmatIn->Diffuse.b  = 0.3f;
    pmatIn->Diffuse.a  = 0.7f;
    pmatIn->Ambient.r  = 0.3f;
    pmatIn->Ambient.g  = 0.1f;
    pmatIn->Ambient.b  = 0.1f;
    pmatIn->Ambient.a  = 1.0f;
}

//=========================================================================
// initialize our lights
//=========================================================================

void BenMark::InitLights()
{
    // setup lights
    float fIntensity = 1.0f /
        (m_bmxState.nDirectionalLights +
         m_bmxState.nPointLights +
         m_bmxState.nSpotLights);

    // disable all our existing lights
    while(m_nNumLights--)
        CheckHR(m_pDevice->LightEnable(m_nNumLights, FALSE));

    // get a count of the new dudes
    m_nNumLights =
        m_bmxState.nDirectionalLights +
        m_bmxState.nPointLights +
        m_bmxState.nSpotLights;

    DWORD dwIndex = 0;
    for (int nT = 0; nT < m_bmxState.nDirectionalLights; nT++)
    {
        D3DLIGHT8 lig;

        ZeroMemory(&lig, sizeof(lig));
        lig.Type        =  D3DLIGHT_DIRECTIONAL;
        lig.Diffuse.r   =  1.0f * fIntensity;
        lig.Diffuse.g   =  1.0f * fIntensity;
        lig.Diffuse.b   =  1.0f * fIntensity;
        lig.Direction.x =  0.2f;
        lig.Direction.y =  0.3f;
        lig.Direction.z = -0.8f;
        CheckHR(m_pDevice->SetLight(dwIndex, &lig));
        CheckHR(m_pDevice->LightEnable(dwIndex, TRUE));

        dwIndex++;
    }
    for (nT = 0; nT < m_bmxState.nPointLights; nT++)
    {
        D3DLIGHT8 lig;

        ZeroMemory(&lig, sizeof(lig));
        lig.Type         =  D3DLIGHT_POINT;
        lig.Diffuse.r    =  1.0f * fIntensity;
        lig.Diffuse.g    =  1.0f * fIntensity;
        lig.Diffuse.b    =  1.0f * fIntensity;
        lig.Position.x   =  0.0f;
        lig.Position.y   =  0.0f;
        lig.Position.z   =  5.0f;
        lig.Range        = 9999.0f;
        lig.Attenuation0 = 1.0f;
        CheckHR(m_pDevice->SetLight(dwIndex, &lig));
        CheckHR(m_pDevice->LightEnable(dwIndex, TRUE));

        dwIndex++;
    }
    for (nT = 0; nT < m_bmxState.nSpotLights; nT++)
    {
        D3DLIGHT8 lig;

        ZeroMemory(&lig, sizeof(lig));
        lig.Type         =  D3DLIGHT_SPOT;
        lig.Diffuse.r    =  1.0f * fIntensity;
        lig.Diffuse.g    =  1.0f * fIntensity;
        lig.Diffuse.b    =  1.0f * fIntensity;
        lig.Position.x   = -1.0f;
        lig.Position.y   = -5.0f;
        lig.Position.z   =  6.0f;
        lig.Direction.x  =  0.1f;
        lig.Direction.y  =  0.5f;
        lig.Direction.z  = -0.6f;
        lig.Range        = 999.0f;
        lig.Theta        = 0.1f;
        lig.Phi          = 0.5f;
        lig.Falloff      = 1.0f;
        lig.Attenuation0 = 1.0f;
        CheckHR(m_pDevice->SetLight(dwIndex, &lig));
        CheckHR(m_pDevice->LightEnable(dwIndex, TRUE));

        dwIndex++;
    }
}


//=========================================================================
// create a texture
//=========================================================================

IDirect3DTexture8 *BenMark::CreateTexture(DWORD dwWidth, DWORD dwHeight)
{
    IDirect3DTexture8 *pTexture = NULL;

    CheckHR(D3DXCreateTexture(m_pDevice, dwWidth, dwHeight, 1, 0, D3DFMT_A4R4G4B4, D3DPOOL_MANAGED, &pTexture));
    if(pTexture)
    {
        D3DLOCKED_RECT lockRect;

        HRESULT hr = pTexture->LockRect(0, &lockRect, NULL, 0);

        D3DSURFACE_DESC desc;
        pTexture->GetLevelDesc(0, &desc);

#ifdef XBOX
        void *pBits = (void *)LocalAlloc(0, dwWidth * dwHeight * 16);
        DWORD dwLine = (DWORD)pBits;
#else
        DWORD dwLine = (DWORD)lockRect.pBits;
#endif

        LONG lPitch = lockRect.Pitch;

        for (DWORD y = 0; y < dwHeight; y++)
        {
            DWORD dwAddr = dwLine;
            BOOL  by     = y & 1;
            for (DWORD x = 0; x < dwWidth; x++)
            {
                DWORD c = x + (y >> 5);

                c = (c | (c << 4) | (c << 8) | 0xf000);

                if(by)
                    c ^= 0x0777;

                *(WORD*)dwAddr = (WORD)c;
                dwAddr += 2;
            }
            dwLine += lPitch;
        }

#ifdef XBOX
        XGSwizzleRect(pBits, 
                      0,
                      NULL,
                      lockRect.pBits,
                      dwWidth,
                      dwHeight,
                      NULL, 
                      2);

         LocalFree(pBits);
#endif

        // Unlock the map so it can be used
        pTexture->UnlockRect(0);
   }

   return pTexture;
}

//=========================================================================
// Renders geometric primitive using Vertex Buffer.
//=========================================================================

void BenMark::DrawIndexedPrimitive
(
	UINT iIndex,
    D3DPRIMITIVETYPE dwPrimType, 
	DWORD PrimitiveCount
)
{
    CheckHR(m_pDevice->SetVertexShader(m_dwFVF));
    CheckHR(m_pDevice->SetStreamSource(0, m_pVBRibbon[iIndex], m_dwFVFSize));
    CheckHR(m_pDevice->SetIndices(m_pIndexBuffer, 0));

    CheckHR(m_pDevice->DrawIndexedPrimitive(
        dwPrimType,         // PrimitiveType
        0,                  // minIndex
        m_dwNumVertices,    // NumIndices
        0,                  // startIndex
        PrimitiveCount));   // PrimitiveCount
}

//=========================================================================
// Renders geometric primitive with data specified by a user memory pointer.
//=========================================================================

void BenMark::DrawIndexedPrimitiveUP
(
	UINT iIndex,
    D3DPRIMITIVETYPE dwPrimType, 
	DWORD PrimitiveCount
)
{
    CheckHR(m_pDevice->DrawIndexedPrimitiveUP(
        dwPrimType,             // Type
        0,                      // MinVertexIndex
        m_dwNumVertices,        // NumVertexIndices
        PrimitiveCount,         // primCount
        m_pwIndices,            // pIndexData
        D3DFMT_INDEX16,         // IndexDataFormat
        m_pVertices[iIndex],    // pVertexStreamZeroData
        m_dwFVFSize));          // VertexStreamZeroStride
}

//=========================================================================
// Renders geometric primitive using Vertex Buffer.
//=========================================================================

void BenMark::PrecompiledDraw
(
	UINT iIndex,
    D3DPRIMITIVETYPE dwPrimType, 
	DWORD PrimitiveCount
)
{
    CheckHR(m_pDevice->SetVertexShader(m_dwFVF));
    CheckHR(m_pDevice->SetStreamSource(0, m_pVBRibbon[iIndex], m_dwFVFSize));

#ifdef XBOX
    m_pDevice->RunPushBuffer(m_pPushBuffer, 0);
#endif
}

//=========================================================================
// initialize our VBs
//=========================================================================

void BenMark::InitVBs()
{
    // clean these guys up if they've already been inited
    delete[] m_pwIndices;
    m_pwIndices = NULL;

    SAFE_RELEASE(m_pIndexBuffer);
    SAFE_RELEASE(m_pVBRibbon[0]);
    SAFE_RELEASE(m_pVBRibbon[1]);

    if (m_bmxState.fPrecompile)
    {
        m_pfnDrawRibbon = BenMark::PrecompiledDraw;
    }
    else if (m_bmxState.iDrawFunc == DF_DRAWINDEXEDPRIMITIVE)
    {
        m_pfnDrawRibbon = BenMark::DrawIndexedPrimitive;
    }
    else
    {
        m_pfnDrawRibbon = BenMark::DrawIndexedPrimitiveUP;
    }

    // create vertex buffer
    m_dwFVF = D3DFVF_XYZ | D3DFVF_NORMAL;

    if(m_bmxState.cApplyTextures > 1)
        m_dwFVF |= D3DFVF_TEX2;
    else if(m_bmxState.cApplyTextures)
        m_dwFVF |= D3DFVF_TEX1;

    m_dwFVFSize = D3DXGetFVFVertexSize(m_dwFVF);

    m_dwNumVertices = (cdwSubsInLength + 1) * (cdwSubsInWidth + 1);
    UINT Length = m_dwNumVertices * m_dwFVFSize;

    // Default when running is to NOT use D3DVBCAPS_SYSTEMMEMORY
    // Using this flag will slow the app to about half the triangle rate.
#ifdef XBOX
    DWORD dwCaps = D3DUSAGE_WRITEONLY;
#else
    DWORD dwCaps = D3DUSAGE_WRITEONLY | D3DUSAGE_DONOTCLIP | D3DUSAGE_DYNAMIC;
#endif
    D3DPOOL dwPool = D3DPOOL_DEFAULT;

    float *pfVerticesO;
    float *pfVerticesI;

    // Create our vertex buffers if we're using DrawIndexedPrimitive.
    if(m_bmxState.iDrawFunc == DF_DRAWINDEXEDPRIMITIVE)
    {
        CheckHR(m_pDevice->CreateVertexBuffer(Length, dwCaps, m_dwFVF, dwPool, &m_pVBRibbon[0]));
        CheckHR(m_pDevice->CreateVertexBuffer(Length, dwCaps, m_dwFVF, dwPool, &m_pVBRibbon[1]));

        CheckHR(m_pVBRibbon[0]->Lock(0, Length, (BYTE **)&pfVerticesO, 0));
        CheckHR(m_pVBRibbon[1]->Lock(0, Length, (BYTE **)&pfVerticesI, 0));
    }
    else
    {
        // skip the vertex buffers and just use alloc'd mem
        m_pVertices[0] = new BYTE[Length];
        pfVerticesO = (float *)m_pVertices[0];

        m_pVertices[1] = new BYTE[Length];
        pfVerticesI = (float *)m_pVertices[1];
    }

    // populate with vertices
    for (DWORD y = 0; y <= cdwSubsInLength; y++)
    {
        for (DWORD x = 0; x <= cdwSubsInWidth; x++)
        {
            // compute point
            float angle  = cfRibbonCurl * float(y) / float(cdwSubsInLength);
            float height = cfRibbonWidth * float(x) / float(cdwSubsInWidth)
                         + cfRibbonPitch * float(y) / float(cdwSubsInLength)
                         - 0.5f * cfRibbonPitch;
            float fcosangle = cosf(angle);
            float fsinangle = sinf(angle);

            // start
            D3DXVECTOR3 n(0, fcosangle, fsinangle);
            D3DXVECTOR3 p(height, cfRibbonRadius * fcosangle,
                cfRibbonRadius * fsinangle);

            // copy to vertex buffer
            *(D3DXVECTOR3 *)&pfVerticesO[0] = p;
            *(D3DXVECTOR3 *)&pfVerticesO[3] = n;
            pfVerticesO += 6;

            *(D3DXVECTOR3 *)&pfVerticesI[0] = p;
            *(D3DXVECTOR3 *)&pfVerticesI[3] = -n;
            pfVerticesI += 6;

            if(m_bmxState.cApplyTextures)
            {
                float tv = float(y) / float(cdwSubsInLength);
                float tu = float(x) / float(cdwSubsInWidth);

                *pfVerticesO++ = tu;
                *pfVerticesO++ = tv;

                *pfVerticesI++ = tu;
                *pfVerticesI++ = tv;

                if(m_bmxState.cApplyTextures > 1)
                {
                    // add second set of texture coords
                    *pfVerticesO++ = tu;
                    *pfVerticesO++ = tv;

                    *pfVerticesI++ = tu;
                    *pfVerticesI++ = tv;
                }
            }
        }
    }

    if(m_bmxState.iDrawFunc == DF_DRAWINDEXEDPRIMITIVE)
    {
        CheckHR(m_pVBRibbon[0]->Unlock());
        CheckHR(m_pVBRibbon[1]->Unlock());
    }

    // setup indices
    m_dwIndexCount = 1 + cdwSubsInLength * (cdwSubsInWidth * 2 + 1);
    m_dwPrimType = m_bmxState.bUseTriList ? D3DPT_TRIANGLELIST : D3DPT_TRIANGLESTRIP;
    m_dwTriCount = (m_dwIndexCount - 2)  / (m_bmxState.bUseTriList ? 3 : 1);

    m_pwIndices = new WORD[m_dwIndexCount];
    WORD  *pwIndex  = m_pwIndices;
    DWORD dwCurrent = 0;

    pwIndex[0] = 0; pwIndex++;

    for (y = 0; y < cdwSubsInLength; y++)
    {
        if (dwCurrent > 0xffff)
        {
            DisplayError(L"Index out of range - reduce geometry complexity", 0);
        }

        pwIndex[0] = WORD(dwCurrent + (cdwSubsInWidth + 1));
        pwIndex++;
        dwCurrent++;

        for (DWORD x = 0; x < cdwSubsInWidth; x++)
        {
            pwIndex[0]  = WORD(dwCurrent);
            pwIndex[1]  = WORD(dwCurrent + (cdwSubsInWidth + 1));
            pwIndex    += 2;
            dwCurrent  ++;
        }

        dwCurrent += (cdwSubsInWidth + 1) - 1;
        y++;

        if (y < cdwSubsInLength)
        {
            pwIndex[0] = WORD(dwCurrent + (cdwSubsInWidth + 1));
            pwIndex++;
            dwCurrent--;

            for (DWORD x = 0; x < cdwSubsInWidth; x++)
            {
                pwIndex[0]  = WORD(dwCurrent);
                pwIndex[1]  = WORD(dwCurrent + (cdwSubsInWidth + 1));
                pwIndex+= 2;
                dwCurrent --;
            }

            dwCurrent += (cdwSubsInWidth + 1) + 1;
        }
    }

    // if we use tri lists, we convert the strip to independent triangles here
    if(m_bmxState.bUseTriList)
    {
        DWORD dwNewIndexCount = (m_dwIndexCount - 2) * 3;
        WORD *pwNewIndices    = new WORD[dwNewIndexCount];

        DWORD a = m_pwIndices[0];
        DWORD b = m_pwIndices[1];
        for (DWORD i = 2,j = 0; i < m_dwIndexCount; i++,j+=3)
        {
            DWORD c = m_pwIndices[i];
            pwNewIndices[j + 0] = (WORD)a;
            pwNewIndices[j + 1] = (WORD)b;
            pwNewIndices[j + 2] = (WORD)c;
            if (i & 1)
                b = c;
            else
                a = c;
        }

        // adopt new
        delete[] m_pwIndices;
        m_dwIndexCount = dwNewIndexCount;
        m_pwIndices    = pwNewIndices;
    }

#ifdef XBOX

    // Create our precompiled push buffers
    if (m_bmxState.fPrecompile)
    {
        CheckHR(m_pDevice->CreatePushBuffer(256*1024, FALSE, &m_pPushBuffer));
        CheckHR(m_pDevice->BeginPushBuffer(m_pPushBuffer));
        CheckHR(m_pDevice->DrawIndexedVertices(m_dwPrimType, D3DVERTEXCOUNT(m_dwPrimType, m_dwTriCount), m_pwIndices));
        CheckHR(m_pDevice->EndPushBuffer());
    }
    else 
     
#endif 

    // Create our index buffer if we're using DrawIndexedPrimitive.
    if (m_bmxState.iDrawFunc == DF_DRAWINDEXEDPRIMITIVE)
    {
        CheckHR(m_pDevice->CreateIndexBuffer(m_dwIndexCount * sizeof(WORD),
            dwCaps, D3DFMT_INDEX16, dwPool, &m_pIndexBuffer));

        WORD *pVertexIndices;
        CheckHR(m_pIndexBuffer->Lock(0, m_dwIndexCount * sizeof(WORD),
            (BYTE**)&pVertexIndices, 0));

        for(DWORD i = 0; i < m_dwIndexCount; i++)
            pVertexIndices[i] = m_pwIndices[i];

        m_pIndexBuffer->Unlock();

        delete[] m_pwIndices;
        m_pwIndices = NULL;
    }

#ifdef XBOX
    
    if(m_bmxState.iDrawFunc == DF_DRAWINDEXEDPRIMITIVE)
    {
        m_pVBRibbon[0]->MoveResourceMemory(D3DMEM_VIDEO);
        m_pVBRibbon[1]->MoveResourceMemory(D3DMEM_VIDEO);
    }

#endif XBOX
}

//=========================================================================
// Given a D3DFORMAT, return string description.
//=========================================================================

const WCHAR *SzFmtName(D3DFORMAT d3dfmt)
{
    #define XTAG(x) {x, L#x}
    static const struct FMTD3DFMT
    {
        D3DFORMAT d3dfmt;
        WCHAR *szName;
    } rgFmtD3dFmt[] =
    {
        XTAG(D3DFMT_X8R8G8B8),
        XTAG(D3DFMT_A1R5G5B5),
        XTAG(D3DFMT_A8R8G8B8),
        XTAG(D3DFMT_A4R4G4B4),
        XTAG(D3DFMT_R5G6B5),
        XTAG(D3DFMT_A1R5G5B5),

        XTAG(D3DFMT_UNKNOWN),
    };
    static const WCHAR szD3dUnkwn[] = L"D3DFMT_???";

    for(int i = 0; i < sizeof(rgFmtD3dFmt) / sizeof(rgFmtD3dFmt[0]); i++)
    {
        if(d3dfmt == rgFmtD3dFmt[i].d3dfmt)
            return rgFmtD3dFmt[i].szName;
    }

    return szD3dUnkwn;
}

//=========================================================================
// Display the various options we we're started with.
//=========================================================================

void BenMark::ShowInfo(int iY, int cHeight)
{
    WCHAR str[128];
    D3DCOLOR colFore = D3DCOLOR_XRGB(255, 255, 0);

	iY += cHeight;

    _snwprintf(str, sizeof(str), L"Xbox BenMark");

    DisplayText(str, iY, colFore);
    iY += cHeight;

    _snwprintf(str, sizeof(str), L"Adapter: %S",
        m_Adapter.AdapterIdentifier.Description);
    DisplayText(str, iY, colFore);
    iY += cHeight;

    DWORD HighPart = m_Adapter.AdapterIdentifier.DriverVersion.HighPart;
    DWORD LowPart = m_Adapter.AdapterIdentifier.DriverVersion.LowPart;
    _snwprintf(str, sizeof(str), L"Driver: %S (%d.%d.%04d.%04d)",
        m_Adapter.AdapterIdentifier.Driver,
        HIWORD(HighPart), LOWORD(HighPart),
        HIWORD(LowPart), LOWORD(LowPart));
    DisplayText(str, iY, colFore);
    iY += cHeight * 2;

    _snwprintf(str, sizeof(str), L"Primitive Type: '%s'  Textures: %d",
        m_bmxState.bUseTriList ? L"trilist" : L"tristrip",
        m_bmxState.cApplyTextures);
    DisplayText(str, iY, colFore);
    iY += cHeight;

    _snwprintf(str, sizeof(str), L"Dirlights: %d  Spotlights: %d  Pointlights: %d",
        m_bmxState.nDirectionalLights,
        m_bmxState.nSpotLights,
        m_bmxState.nPointLights);
    DisplayText(str, iY, colFore);
    iY += cHeight;

    _snwprintf(str, sizeof(str), L"Z-Buffer: %s  Specular Lighting: %s  Local Viewer: %s",
        m_bmxState.bZenable ? L"true" : L"false",
        m_bmxState.bSpecularenable ? L"true" : L"false",
        m_bmxState.bLocalviewer ? L"true" : L"false");
    DisplayText(str, iY, colFore);
    iY += cHeight;

    static const WCHAR *rgszFillMode[] =
        { L"D3DFILL_POINT", L"D3DFILL_WIREFRAME", L"D3DFILL_SOLID" };
    static const WCHAR *rgszDrawFunc[] =
        { L"DrawIndexedPrimitive", L"DrawIndexedPrimitiveUP" };

    DWORD iFillMode = 0;
    switch (m_bmxState.iFillMode)
    {
    case D3DFILL_POINT: iFillMode = 0; break;
    case D3DFILL_WIREFRAME: iFillMode = 1; break;
    case D3DFILL_SOLID: iFillMode = 2; break;
    }

    _snwprintf(str, sizeof(str), L"Rendering: %s  Precompiled: %s  Fillmode: %s",
        rgszDrawFunc[m_bmxState.iDrawFunc], 
        m_bmxState.fPrecompile ? L"true" : L"false",
        rgszFillMode[iFillMode]);
    DisplayText(str, iY, colFore);
    iY += cHeight;

    _snwprintf(str, sizeof(str), L"Triangles: %d  Indices: %d  FVFSize: %d",
        m_dwTriCount,
        m_dwIndexCount,
        m_dwFVFSize);
    DisplayText(str, iY, colFore);
    iY += cHeight;

    _snwprintf(str, sizeof(str), L"Maximum possible background loops per second: %i", (int)m_iMaxDivides);
	DisplayText(str, iY, colFore);
	iY += cHeight * 2;

	if (m_fdMaxTriPerSec != 0)
	{
		_snwprintf(str, sizeof(str), L"AveTriPerSec(%d): %i  MaxTriPerSec: %i  MinTriPerSec: %i",
			m_dwAveCount,
			(INT) ((m_fdAveTriPerSec / m_dwAveCount) * 1000.0f),
			(INT) (m_fdMaxTriPerSec * 1000.0f),
			(INT) (m_fdMinTriPerSec * 1000.0f));
		DisplayText(str, iY, colFore);
		iY += cHeight;
	}

}

//=========================================================================
// Set up the menus.
//=========================================================================

unsigned BenMark::GetMenus(ScenarioMenu **rgMenus)
{
	rgMenus[0] = &s_Button7Menu;
	rgMenus[1] = &s_Button8Menu;
	rgMenus[2] = &s_Button9Menu;

	return 3;
}

//=========================================================================
// Handle keyboard input.
//=========================================================================

void BenMark::ProcessKeyPress(DWORD iMenu, DWORD iKey)
{
	switch(iMenu)
	{
	case MT_BUTTON7:
		switch(iKey)
		{
		case 0:
			m_bmxState.bSpecularenable = !m_bmxState.bSpecularenable;
			break;
		case 1:
			m_bmxState.bZenable = !m_bmxState.bZenable;
			break;
		case 2:
			m_bmxState.bLocalviewer = !m_bmxState.bLocalviewer;
			break;

		default:
			return;
		}
		break;

	case MT_BUTTON8:
		switch(iKey)
		{
		case 0:
			m_bmxState.nDirectionalLights++;
			break;

		case 1:
			m_bmxState.nSpotLights++;
			break;

		case 2:
			m_bmxState.nPointLights++;
			break;

		case 3:
			if (m_bmxState.nDirectionalLights)
			{
				m_bmxState.nDirectionalLights--;
			}
			else
			{
				return;
			}
			break;

		case 4:
			if (m_bmxState.nSpotLights)
			{
				m_bmxState.nSpotLights--;
			}
			else
			{
				return;
			}
			break;

		case 5:
			if (m_bmxState.nPointLights)
			{
				m_bmxState.nPointLights--;
			}
			else
			{
				return;
			}
			break;
		}

		InitLights();

		return;

	case MT_BUTTON9:
		switch(iKey)
		{
		case 0:
			m_bmxState.cApplyTextures = (m_bmxState.cApplyTextures + 1) % 3;
			break;
		case 1:
			m_bmxState.bUseTriList = !m_bmxState.bUseTriList;
			break;

		case 2:
			m_bmxState.iFillMode = D3DFILLMODE((m_bmxState.iFillMode + 1) % D3DFILL_SOLID + 1);
			break;

		case 3:
			m_bmxState.iDrawFunc = (DRAWFUNC)((m_bmxState.iDrawFunc + 1) % DRAWMAX);
			break;

#ifdef XBOX
        case 4:
            m_bmxState.fPrecompile = !m_bmxState.fPrecompile;
            break;
#endif 

		default:
			return;
		}
		break;

	default:
		return;
	}

	Change3DEnvironment();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\common\d3dapp.h ===
//-----------------------------------------------------------------------------
// File: D3DApp.h
//
// Desc: Application class for the Direct3D samples framework library.
//
// Copyright (c) 1998-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef D3DAPP_H
#define D3DAPP_H

#include "bitfont.h"

interface IDirectInput8 ;
interface IDirectInputDevice8;

//-----------------------------------------------------------------------------
// Structure for holding information about an adapter, and its display modes.
//-----------------------------------------------------------------------------

struct Adapter
{
	struct Mode
	{
		// Mode data
		DWORD      Width;
		DWORD      Height;
		D3DFORMAT  Format;
		DWORD      dwBehavior;
	};
	
	// Adapter data
	D3DADAPTER_IDENTIFIER8 AdapterIdentifier;
	D3DCAPS8   Caps;

	// Mode data
	DWORD      dwNumModes;
	Mode       modes[150];

	Adapter()
	{
		ZeroMemory(this, sizeof(*this));
	}
};

//-----------------------------------------------------------------------------
// Structure used to define menus.
//-----------------------------------------------------------------------------

enum MenuTypes
{
	MT_NONE = 0,			// no menu button is pressed
	MT_BUTTON7 = 1,			// top left
	MT_BUTTON8 = 2,			// top right
	MT_BUTTON9 = 3,			// under left
	MT_BUTTON10 = 4,		// under right
	MT_STARTBUTTON1 = 5,	// reserved for the framework menu
	MT_STARTBUTTON2 = 6,	// reserved for the framework menu
	MT_MAX
};

struct ScenarioMenu
{

	MenuTypes m_MenuType;

	const WCHAR *m_szMenuName;

	const WCHAR *m_szActions[6]; // for A, B, C, D, E, F
	unsigned m_cActions;        // Number of filled actions.
};

//-----------------------------------------------------------------------------
// Name: class CD3DApplication8
// Desc: A base class for creating sample D3D8 applications. To create a simple
//       Direct3D application, simply derive this class into a class (such as
//       class CMyD3DApplication) and override the following functions, as 
//       needed:
//          OneTimeSceneInit()    - To initialize app data (alloc mem, etc.)
//          InitDeviceObjects()   - To initialize the 3D scene objects
//          FrameMove()           - To animate the scene
//          Render()              - To render the scene
//          DeleteDeviceObjects() - To cleanup the 3D scene objects
//          FinalCleanup()        - To cleanup app data (for exitting the app)
//-----------------------------------------------------------------------------

class CD3DApplication
{
	// Internal variables for the state of the app
    BOOL    m_bActive;
    BOOL    m_bReady;

    // Internal variables used for timing
    BOOL    m_bFrameMoving;
    BOOL    m_bSingleStep;
	BOOL    m_bRunFullTest;

	// FPS stats.
    FLOAT             m_fFPS;              // Instanteous frame rate
	WCHAR  m_strFrameStats[80];			   // String to hold frame rate stats
    DWORD m_dwFrames;

#if defined(PCBUILD)
	// Internal members used to manage input.
	IDirectInput8 *m_pDirectInput;
	IDirectInputDevice8 *m_pKeyboard;
	IDirectInputDevice8 *m_pGamepad;
#else
    HANDLE  m_hDevice;
#endif 

	BOOL    m_fShowHelp;				// Show a help menu.
	BOOL    m_fShowStats;               // Show statistics?
	DWORD	m_iActiveMenu;				// Which menu is currently active
	DWORD   m_iActiveKey;				// Which of ABCDEF is currently pressed?
	
	// Internal members for the menus.
	unsigned m_cMenus;					// How many menus are installed?

	ScenarioMenu *m_rgpMenus[MT_MAX];	// Descriptor for each menu.

	DWORD m_dwSpaceHeight;				// The height of a blank.
	DWORD m_dwHelpWidth;				// Width of the help box.
	DWORD m_dwColumn1X;					// Relative X for the first column
	DWORD m_dwColumn2X;                 // Relative X for the second column

	// Member used for output.  This variable is only valid for a short
	// period of time.
	//
	IDirect3DSurface8 *m_pBackBuffer;
	
    // Internal functions to manage and render the 3D scene
	void BuildDeviceList();

#if defined(PCBUILD)
	void GetInputDevices();
#endif 

    void UserChangeDevice();
    void Initialize3DEnvironment();
	void Resize3DEnvironment();
	void ToggleFullscreen();
    void Cleanup3DEnvironment();
    void Render3DEnvironment();
	bool ProcessInput();
	void InitializeHelpInformation();
	void ShowHelp(IDirect3DSurface8 *pSurface);
	void UpdateAllStats();

protected:

	// The adapter.
	Adapter          m_Adapter;

    // Main objects used for creating and rendering the 3D scene
	D3DPRESENT_PARAMETERS	m_Presentation;
    LPDIRECT3D8				m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8		m_pDevice;           // The D3D rendering device
    D3DCAPS8				m_Caps;              // Caps for the device
    D3DSURFACE_DESC			m_BackBufferDesc;    // Surface desc of the backbuffer
    HWND					m_hWnd;              // The main app window

	DWORD					m_dwSampleMask;      // Mask of available FSAA modes.
	D3DMULTISAMPLE_TYPE		m_iSampleType;       // Current sample mode.

    BitFont                 m_Font;

	// Variables for timing
    FLOAT             m_fTime;             // Current time in seconds
    FLOAT             m_fElapsedTime;      // Time elapsed since last frame

    // Overridable variables for the app
    BOOL      m_bUseDepthBuffer ;  // Whether to autocreate depthbuffer
    D3DFORMAT m_DepthBufferFormat; // Format used to create depthbuffer
	DWORD	  m_dwCurrentMode;	   // The current screen mode.
	WCHAR	  m_szTestStats[256];   // String to hold the test stats.

    // Overridable functions for the 3D scene created by the app
	virtual bool ConfirmDevice(D3DCAPS8*, DWORD, D3DFORMAT) { return true; }
    virtual void OneTimeSceneInit()                         { }
    virtual void InitDeviceObjects()                        { }
	virtual void RestoreDeviceObjects()                     { }
    virtual void FrameMove()                                { }
    virtual void Render()                                   { }
	virtual void InvalidateDeviceObjects()                  { }
    virtual void DeleteDeviceObjects()                      { }
    virtual void FinalCleanup()                             { }
	virtual void UpdateStats(float fElapsedTime)			{ }
	virtual void ShowInfo(int iY, int cHeight)              { }

	// Override this method to handle input. 
	virtual void ProcessKeyPress(DWORD iMenu, DWORD iKey)   { }

	// Override this method to set additional menus.  The
	// passed-in array has 10 elements, return the number 
	// of menus put into the array.
	//
	virtual unsigned GetMenus(ScenarioMenu **rgMenus)		{ return 0; }

	// Helper to draw the text on the screen.
    void DisplayText(const WCHAR *sz, int iY, DWORD dwColor);

	// Helper to reinitialize the 3d engine.
    void Change3DEnvironment();

public:

    // Functions to create, run, pause, and clean up the application
    virtual void Create(HINSTANCE hInstance);
    virtual void Run();

    // Internal constructor
    CD3DApplication();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\clearbug\clearbug.cpp ===
/*--

Copyright (c) 1999 - 2001 Microsoft Corporation - Xbox SDK

--*/

#include <stddef.h>
#include <stdio.h>

extern "C"
{
    #include <ntos.h>
    #include <nturtl.h>
    #include <av.h>
};

#include <xtl.h>
#include <xgraphics.h>

IDirect3DDevice8* pDev  = NULL;

bool InitD3D()
{
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    if (pD3D == NULL)
        return false;

    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
    d3dpp.EnableAutoDepthStencil    = true;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
    d3dpp.MultiSampleType           = D3DMULTISAMPLE_NONE;

    if (pD3D->CreateDevice(
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        NULL,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        &pDev) != S_OK)
    {
        return false;
    }

    pD3D->Release();

    return true;
}

#define NOP_COUNT 20000

DWORD i;
BYTE nopBuffer[NOP_COUNT + 1];

void __cdecl main()
{
    DWORD j;

    InitD3D();

    for (j = 0; j < NOP_COUNT; j++)
    {
        nopBuffer[j] = 0x90;        // nop
    }
    nopBuffer[NOP_COUNT] = 0xc3;    // ret

    Sleep(2000);

    for (i = 0; ; i++)
    {
        _asm 
        {
            lea esi, nopBuffer
            call esi
        }

        if ((i % 1000) == 0)
        {
            DbgPrint("Iteration... %li\n", i);
        }

        pDev->Clear(0, NULL, D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0xff, 0, 0xff);
        pDev->KickPushBuffer();
        while (pDev->IsBusy())
            ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\common\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef XBOX
#include <xgraphics.h>
#endif
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

#ifdef XBOX
    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
#else
    if(pSurface->LockRect(&lockRect, NULL, 0) != S_OK)
#endif
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\billboard\billboard.cpp ===
//-----------------------------------------------------------------------------
// File: Billboard.cpp
//
// Desc: Example code showing how to do billboarding. The sample uses
//       billboarding to draw some trees.
//
//       Note: this implementation is for billboards that are fixed to rotate
//       about the Y-axis, which is good for things like trees. For
//       unconstrained billboards, like explosions in a flight sim, the
//       technique is the same, but the the billboards are positioned slightly
//       different. Try using the inverse of the view matrix, TL-vertices, or
//       some other technique.
//
// Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#define STRICT

#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <D3DX8.h>
#endif
#include <stdio.h>
#include <math.h>
#include <tchar.h>
#include "..\common\D3DApp.h"
#include "..\common\D3DFile.h"
#include "..\common\D3DUtil.h"
#include "..\common\DXUtil.h"




//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
#define NUM_TREES 500

// Need global access of the eye point used by the callback to sort trees
D3DXVECTOR3 g_vEyePt;

// Simple function to define "hilliness" for terrain
inline FLOAT HeightField( FLOAT x, FLOAT y )
{
    return 9*(cosf(x/20+0.2f)*cosf(y/15-0.2f)+1.0f);
}

// Custom vertex type for the trees
struct TREEVERTEX
{
    D3DXVECTOR3 p;
    DWORD       color;
    FLOAT       tu, tv;
};

#define D3DFVF_TREEVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)

// Tree textures to use
CHAR* g_strTreeTextures[] =
{
    "Tree02S.tga",
    "Tree35S.tga",
    "Tree01S.tga",
};

#define NUMTREETEXTURES 3




//-----------------------------------------------------------------------------
// Name: Tree
// Desc: Simple structure to hold data for rendering a tree
//-----------------------------------------------------------------------------
struct Tree
{
    TREEVERTEX  v[4];
    D3DXVECTOR3 vPos;
    DWORD       dwTreeTexture;
};




//-----------------------------------------------------------------------------
// Name: class CMyD3DApplication
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CMyD3DApplication : public CD3DApplication
{
    CD3DMesh*     m_pTerrain;           // Terrain object
    CD3DMesh*     m_pSkyBox;            // Skybox background object

    LPDIRECT3DVERTEXBUFFER8 m_pTreeVB;  // Vertex buffer for rendering a tree
    LPDIRECT3DTEXTURE8      m_pTreeTextures[NUMTREETEXTURES]; // Tree images
    D3DXMATRIX    m_matBillboardMatrix; // Used for billboard orientation
    Tree          m_Trees[NUM_TREES];   // Array of tree info

    void DrawBackground();
    void DrawTrees();

protected:
    void OneTimeSceneInit();
    void InitDeviceObjects();
    void RestoreDeviceObjects();
    void InvalidateDeviceObjects();
    void DeleteDeviceObjects();
    void Render();
    void FrameMove();
    void FinalCleanup();

public:
    CMyD3DApplication();
};



#ifdef XBOX

void __cdecl main()
{
    CMyD3DApplication d3dApp;

    d3dApp.Create( NULL );

    d3dApp.Run();
}

#else 

//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )
{
    CMyD3DApplication d3dApp;

    d3dApp.Create( hInst );

    d3dApp.Run();

    return 0;
}

#endif



//-----------------------------------------------------------------------------
// Name: CMyD3DApplication()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CMyD3DApplication::CMyD3DApplication()
{
    m_bUseDepthBuffer   = TRUE;

    m_pSkyBox      = new CD3DMesh();
    m_pTerrain     = new CD3DMesh();
    m_pTreeVB      = NULL;

    for( DWORD i=0; i<NUMTREETEXTURES; i++ )
        m_pTreeTextures[i] = NULL;
}




//-----------------------------------------------------------------------------
// Name: OneTimeSceneInit()
// Desc: Called during initial app startup, this function performs all the
//       permanent initialization.
//-----------------------------------------------------------------------------
void CMyD3DApplication::OneTimeSceneInit()
{
    // Initialize the tree data
    for( WORD i=0; i<NUM_TREES; i++ )
    {
        // Position the trees randomly
        FLOAT fTheta  = 2.0f*D3DX_PI*(FLOAT)rand()/RAND_MAX;
        FLOAT fRadius = 25.0f + 55.0f * (FLOAT)rand()/RAND_MAX;
        m_Trees[i].vPos.x  = fRadius * sinf(fTheta);
        m_Trees[i].vPos.z  = fRadius * cosf(fTheta);
        m_Trees[i].vPos.y  = HeightField( m_Trees[i].vPos.x, m_Trees[i].vPos.z );

        // Size the trees randomly
        FLOAT fWidth  = 1.0f + 0.2f * (FLOAT)(rand()-rand())/RAND_MAX;
        FLOAT fHeight = 1.4f + 0.4f * (FLOAT)(rand()-rand())/RAND_MAX;

        // Each tree is a random color between red and green
        DWORD r = (255-190) + (DWORD)(190*(FLOAT)(rand())/RAND_MAX);
        DWORD g = (255-190) + (DWORD)(190*(FLOAT)(rand())/RAND_MAX);
        DWORD b = 0;
        DWORD dwColor = 0xff000000 + (r<<16) + (g<<8) + (b<<0);

        m_Trees[i].v[0].p     = D3DXVECTOR3(-fWidth, 0*fHeight, 0.0f );
        m_Trees[i].v[0].color = dwColor;
        m_Trees[i].v[0].tu    = 0.0f;   m_Trees[i].v[0].tv = 1.0f;
        m_Trees[i].v[1].p     = D3DXVECTOR3(-fWidth, 2*fHeight, 0.0f  );
        m_Trees[i].v[1].color = dwColor;
        m_Trees[i].v[1].tu    = 0.0f;   m_Trees[i].v[1].tv = 0.0f;
        m_Trees[i].v[2].p     = D3DXVECTOR3( fWidth, 0*fHeight, 0.0f  );
        m_Trees[i].v[2].color = dwColor;
        m_Trees[i].v[2].tu    = 1.0f;   m_Trees[i].v[2].tv = 1.0f;
        m_Trees[i].v[3].p     = D3DXVECTOR3( fWidth, 2*fHeight, 0.0f  );
        m_Trees[i].v[3].color = dwColor;
        m_Trees[i].v[3].tu    = 1.0f;   m_Trees[i].v[3].tv = 0.0f;

        // Size the trees randomly
        m_Trees[i].dwTreeTexture = (DWORD)( ( NUMTREETEXTURES * rand() ) / (FLOAT)RAND_MAX );
    }
}




//-----------------------------------------------------------------------------
// Name: TreeSortCB()
// Desc: Callback function for sorting trees in back-to-front order
//-----------------------------------------------------------------------------
int __cdecl TreeSortCB( const VOID* arg1, const VOID* arg2 )
{
    Tree* p1 = (Tree*)arg1;
    Tree* p2 = (Tree*)arg2;

    FLOAT dx1 = p1->vPos.x - g_vEyePt.x;
    FLOAT dz1 = p1->vPos.z - g_vEyePt.z;
    FLOAT dx2 = p2->vPos.x - g_vEyePt.x;
    FLOAT dz2 = p2->vPos.z - g_vEyePt.z;

    if( (dx1*dx1+dz1*dz1) < (dx2*dx2+dz2*dz2) )
        return +1;

    return -1;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
void CMyD3DApplication::FrameMove()
{
    // Get the eye and lookat points from the camera's path
    D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );
    D3DXVECTOR3 vEyePt;
    D3DXVECTOR3 vLookatPt;

    vEyePt.x = 30.0f*cosf( 0.8f * ( m_fTime + 1.0f ) );
    vEyePt.z = 30.0f*sinf( 0.8f * ( m_fTime + 1.0f ) );
    vEyePt.y = 4 + HeightField( vEyePt.x, vEyePt.z );

    vLookatPt.x = 30.0f*cosf( 0.8f * ( m_fTime + 1.5f ) );
    vLookatPt.z = 30.0f*sinf( 0.8f * ( m_fTime + 1.5f ) );
    vLookatPt.y = vEyePt.y - 1.0f;

    // Set the app view matrix for normal viewing
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    CheckHR(m_pDevice->SetTransform( D3DTS_VIEW, &matView ));

    // Set up a rotation matrix to orient the billboard towards the camera.
    D3DXVECTOR3 vDir = vLookatPt - vEyePt;
    if( vDir.x > 0.0f )
        D3DXMatrixRotationY( &m_matBillboardMatrix, -atanf(vDir.z/vDir.x)+D3DX_PI/2 );
    else
        D3DXMatrixRotationY( &m_matBillboardMatrix, -atanf(vDir.z/vDir.x)-D3DX_PI/2 );

    // Sort trees in back-to-front order
    g_vEyePt = vEyePt;
    qsort( m_Trees, NUM_TREES, sizeof(Tree), TreeSortCB );
}




//-----------------------------------------------------------------------------
// Name: DrawTrees()
// Desc:
//-----------------------------------------------------------------------------
void CMyD3DApplication::DrawTrees()
{
    // Set diffuse blending for alpha set in vertices.
    CheckHR(m_pDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,   TRUE ))
    CheckHR(m_pDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA ))
    CheckHR(m_pDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ))

    // Enable alpha testing (skips pixels with less than a certain alpha.)
    if( m_Caps.AlphaCmpCaps & D3DPCMPCAPS_GREATEREQUAL )
    {
        CheckHR(m_pDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE ))
        CheckHR(m_pDevice->SetRenderState( D3DRS_ALPHAREF,        0x08 ))
        CheckHR(m_pDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL ))
    }

    // Loop through and render all trees
    for( DWORD i=0; i<NUM_TREES; i++ )
    {
        // Set the tree texture
        CheckHR(m_pDevice->SetTexture( 0, m_pTreeTextures[m_Trees[i].dwTreeTexture] ))

        // Translate the billboard into place
        m_matBillboardMatrix._41 = m_Trees[i].vPos.x;
        m_matBillboardMatrix._42 = m_Trees[i].vPos.y;
        m_matBillboardMatrix._43 = m_Trees[i].vPos.z;
        CheckHR(m_pDevice->SetTransform( D3DTS_WORLD, &m_matBillboardMatrix ))

        // Copy tree mesh into vertexbuffer
        TREEVERTEX* v;
        CheckHR(m_pTreeVB->Lock( 0, 0, (BYTE**)&v, 0 ));
        memcpy( v, m_Trees[i].v, 4*sizeof(TREEVERTEX) );
        CheckHR(m_pTreeVB->Unlock())

        // Render the billboard
        CheckHR(m_pDevice->SetStreamSource( 0, m_pTreeVB, sizeof(TREEVERTEX) ));
        CheckHR(m_pDevice->SetVertexShader( D3DFVF_TREEVERTEX ));
        CheckHR(m_pDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 ));
    }

    // Restore state
    D3DXMATRIX  matWorld;
    D3DXMatrixIdentity( &matWorld );
    CheckHR(m_pDevice->SetTransform( D3DTS_WORLD, &matWorld ));
    CheckHR(m_pDevice->SetRenderState( D3DRS_ALPHATESTENABLE,    FALSE ));
    CheckHR(m_pDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,   FALSE ));
}




//-----------------------------------------------------------------------------
// Name: App_Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
void CMyD3DApplication::Render()
{
    // Clear the viewport
    CheckHR(m_pDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L ));

    // Begin the scene
    CheckHR(m_pDevice->BeginScene() );

    // Render the Skybox
    {
        // Center view matrix for skybox and disable zbuffer
        D3DXMATRIX matView, matViewSave;
        CheckHR(m_pDevice->GetTransform( D3DTS_VIEW,      &matViewSave ));
        matView = matViewSave;
        matView._41 = 0.0f; matView._42 = -0.3f; matView._43 = 0.0f;
        CheckHR(m_pDevice->SetTransform( D3DTS_VIEW,      &matView ));
        CheckHR(m_pDevice->SetRenderState( D3DRS_ZENABLE, FALSE ));

        // Render the skybox
        m_pSkyBox->Render( m_pDevice );

        // Restore the render states
        CheckHR(m_pDevice->SetTransform( D3DTS_VIEW,      &matViewSave ));
        CheckHR(m_pDevice->SetRenderState( D3DRS_ZENABLE, TRUE ));
    }

    // Draw the terrain
    m_pTerrain->Render( m_pDevice );

    // Draw the trees
    DrawTrees();

    // End the scene.
    CheckHR(m_pDevice->EndScene());
}




//-----------------------------------------------------------------------------
// Name: InitDeviceObjects()
// Desc: This creates all device-dependant managed objects, such as managed
//       textures and managed vertex buffers.
//-----------------------------------------------------------------------------
void CMyD3DApplication::InitDeviceObjects()
{
    // Create the tree textures
    for( DWORD i=0; i<NUMTREETEXTURES; i++ )
    {
        CheckHR(D3DUtil_CreateTexture( m_pDevice, g_strTreeTextures[i], &m_pTreeTextures[i])) ;
    }

    // Create a quad for rendering each tree
    CheckHR(m_pDevice->CreateVertexBuffer( 4*sizeof(TREEVERTEX),
                                           D3DUSAGE_WRITEONLY, D3DFVF_TREEVERTEX,
                                           D3DPOOL_MANAGED, &m_pTreeVB ) );

    // Load the skybox
    m_pSkyBox->Create( m_pDevice, "SkyBox2.x");

    // Load the terrain
    m_pTerrain->Create( m_pDevice, "SeaFloor.x");

    // Add some "hilliness" to the terrain
    LPDIRECT3DVERTEXBUFFER8 pVB;
    CheckHR(m_pTerrain->GetSysMemMesh()->GetVertexBuffer( &pVB ) );

    {
        struct VERTEX { FLOAT x,y,z,tu,tv; };
        VERTEX* pVertices;
        DWORD   dwNumVertices = m_pTerrain->GetSysMemMesh()->GetNumVertices();

        CheckHR(pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ));

        for( DWORD i=0; i<dwNumVertices; i++ )
            pVertices[i].y = HeightField( pVertices[i].x, pVertices[i].z );

        CheckHR(pVB->Unlock());
        pVB->Release();
    }
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc: Restore device-memory objects and state after a device is created or
//       resized.
//-----------------------------------------------------------------------------
void CMyD3DApplication::RestoreDeviceObjects()
{
    // Restore the device objects for the meshes and fonts
    m_pTerrain->RestoreDeviceObjects( m_pDevice );
    m_pSkyBox->RestoreDeviceObjects( m_pDevice );

    // Set the transform matrices (view and world are updated per frame)
    D3DXMATRIX matProj;
    FLOAT fAspect = m_BackBufferDesc.Width / (FLOAT)m_BackBufferDesc.Height;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, fAspect, 1.0f, 100.0f );
    CheckHR(m_pDevice->SetTransform( D3DTS_PROJECTION, &matProj ));

    // Set up the default texture states
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR ));

    CheckHR(m_pDevice->SetRenderState( D3DRS_DITHERENABLE, TRUE ));
    CheckHR(m_pDevice->SetRenderState( D3DRS_ZENABLE,      TRUE ));
    CheckHR(m_pDevice->SetRenderState( D3DRS_LIGHTING,     FALSE ));
}




//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: Called when the device-dependant objects are about to be lost.
//-----------------------------------------------------------------------------
void CMyD3DApplication::InvalidateDeviceObjects()
{
    m_pTerrain->InvalidateDeviceObjects();
    m_pSkyBox->InvalidateDeviceObjects();
}




//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Called when the app is exitting, or the device is being changed,
//       this function deletes any device dependant objects.
//-----------------------------------------------------------------------------
void CMyD3DApplication::DeleteDeviceObjects()
{
    m_pTerrain->Destroy();
    m_pSkyBox->Destroy();

    for( DWORD i=0; i<NUMTREETEXTURES; i++ )
        SAFE_RELEASE( m_pTreeTextures[i] );

    SAFE_RELEASE( m_pTreeVB )
}




//-----------------------------------------------------------------------------
// Name: FinalCleanup()
// Desc: Called before the app exits, this function gives the app the chance
//       to cleanup after itself.
//-----------------------------------------------------------------------------
void CMyD3DApplication::FinalCleanup()
{
    SAFE_DELETE( m_pTerrain );
    SAFE_DELETE( m_pSkyBox );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\common\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\clipmirror\clipmirror.cpp ===
//-----------------------------------------------------------------------------
// File: ClipMirror.cpp
//
// Desc: This sample shows how to use clip planes to implement a planar mirror.
//       The scene is reflected in a mirror and rendered in a 2nd pass. The
//       corners of the mirrors, together with the camera eye point, are used
//       to define a custom set of clip planes so that the reflected geometry
//       appears only within the mirror's boundaries.
//
//       Note: This code uses the D3D Framework helper library.
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#define STRICT

#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <D3DX8.h>
#endif
#include <math.h>
#include "..\Common\D3DApp.h"
#include "..\Common\D3DFile.h"
#include "..\Common\D3DUtil.h"
#include "..\Common\DXUtil.h"




//-----------------------------------------------------------------------------
// Name: struct MIRRORVERTEX
// Desc: Custom mirror vertex type
//-----------------------------------------------------------------------------
struct MIRRORVERTEX
{
    D3DXVECTOR3 p;
    D3DXVECTOR3 n;
    DWORD       color;
};

#define D3DFVF_MIRRORVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE)




//-----------------------------------------------------------------------------
// Name: class CMyD3DApplication
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CMyD3DApplication : public CD3DApplication
{
    CD3DMesh*    m_pTeapot;     // The teapot object
    D3DXMATRIX   m_matTeapot;   // Teapot's local matrix

    LPDIRECT3DVERTEXBUFFER8 m_pMirrorVB;

    D3DXVECTOR3  m_vEyePt;      // Vectors defining the camera
    D3DXVECTOR3  m_vLookatPt;
    D3DXVECTOR3  m_vUpVec;

    void RenderMirror();
    void RenderScene();

protected:
    void OneTimeSceneInit();
    void InitDeviceObjects();
    void RestoreDeviceObjects();
    void InvalidateDeviceObjects();
    void DeleteDeviceObjects();
    void Render();
    void FrameMove();
    void FinalCleanup();

public:
    CMyD3DApplication();
};




//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------

#ifdef PCBUILD

INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )
{
    CMyD3DApplication d3dApp;

    d3dApp.Create( hInst );

    d3dApp.Run();

    return 0;
}
#else

void __cdecl main()
{
    CMyD3DApplication d3dApp;

    d3dApp.Create( NULL );

    d3dApp.Run();
}

#endif

//-----------------------------------------------------------------------------
// Name: CMyD3DApplication()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CMyD3DApplication::CMyD3DApplication()
{
    m_bUseDepthBuffer   = TRUE;
    m_pTeapot           = new CD3DMesh;
    m_pMirrorVB         = NULL;
}




//-----------------------------------------------------------------------------
// Name: OneTimeSceneInit()
// Desc: Called during initial app startup, this function performs all the
//       permanent initialization.
//-----------------------------------------------------------------------------
void CMyD3DApplication::OneTimeSceneInit()
{
    // Initialize the camera's orientation
    m_vEyePt    = D3DXVECTOR3( 0.0f, 2.0f, -6.5f );
    m_vLookatPt = D3DXVECTOR3( 0.0f, 0.0f,  0.0f );
    m_vUpVec    = D3DXVECTOR3( 0.0f, 1.0f,  0.0f );
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
void CMyD3DApplication::FrameMove()
{
    // Set the teapot's local matrix (rotating about the y-axis)
    D3DXMatrixRotationY( &m_matTeapot, m_fTime );

#if 0
    // When the window has focus, let the mouse adjust the camera view
    if( GetFocus() )
    {
        D3DXQUATERNION quat = D3DUtil_GetRotationFromCursor( m_hWnd );
        m_vEyePt.x = 5*quat.y;
        m_vEyePt.y = 5*quat.x;
        m_vEyePt.z = -sqrtf( 50.0f - 25*quat.x*quat.x - 25*quat.y*quat.y );

        D3DXMATRIX matView;
        D3DXMatrixLookAtLH( &matView, &m_vEyePt, &m_vLookatPt, &m_vUpVec );
        CheckHR(m_pDevice->SetTransform( D3DTS_VIEW, &matView ));
    }
#endif 0
}




//-----------------------------------------------------------------------------
// Name: RenderScene()
// Desc: Renders all objects in the scene.
//-----------------------------------------------------------------------------
void CMyD3DApplication::RenderScene()
{
    D3DXMATRIX matLocal, matWorldSaved;
    CheckHR(m_pDevice->GetTransform( D3DTS_WORLD, &matWorldSaved ));

    // Build the local matrix
    D3DXMatrixMultiply( &matLocal, &m_matTeapot, &matWorldSaved );
    CheckHR(m_pDevice->SetTransform( D3DTS_WORLD, &matLocal ));

    // Render the object
    m_pTeapot->Render( m_pDevice );

    // Restore the modified render states
    CheckHR(m_pDevice->SetTransform( D3DTS_WORLD, &matWorldSaved ));
}




//-----------------------------------------------------------------------------
// Name: RenderMirror()
// Desc: Renders the scene as reflected in a mirror. The corners of the mirror
//       define a plane, which is used to build the reflection matrix. The
//       scene is rendered with the cull-mode reversed, since all normals in
//       the scene are likewise reflected.
//-----------------------------------------------------------------------------
void CMyD3DApplication::RenderMirror()
{
    D3DXMATRIX matWorldSaved;
    D3DXMATRIX matReflectInMirror;
    D3DXPLANE  plane;

    // Save the world matrix so it can be restored
    CheckHR(m_pDevice->GetTransform( D3DTS_WORLD, &matWorldSaved ));

    // Get the four corners of the mirror. (This should be dynamic rather than
    // hardcoded.)
    D3DXVECTOR3 a(-1.5f, 1.5f, 3.0f );
    D3DXVECTOR3 b( 1.5f, 1.5f, 3.0f );
    D3DXVECTOR3 c( -1.5f,-1.5f, 3.0f );
    D3DXVECTOR3 d( 1.5f,-1.5f, 3.0f );

    // Construct the reflection matrix
    D3DXPlaneFromPoints( &plane, &a, &b, &c );
    D3DXMatrixReflect( &matReflectInMirror, &plane );
    CheckHR(m_pDevice->SetTransform( D3DTS_WORLD, &matReflectInMirror ));

    // Reverse the cull mode (since normals will be reflected)
    CheckHR(m_pDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CW ));

    // Set the custom clip planes (so geometry is clipped by mirror edges).
    // This is the heart of this sample. The mirror has 4 edges, so there are
    // 4 clip planes, each defined by two mirror vertices and the eye point.
#if 0
    CheckHR(m_pDevice->SetClipPlane( 0, *D3DXPlaneFromPoints( &plane, &b, &a, &m_vEyePt ) ));
    CheckHR(m_pDevice->SetClipPlane( 1, *D3DXPlaneFromPoints( &plane, &d, &b, &m_vEyePt ) ));
    CheckHR(m_pDevice->SetClipPlane( 2, *D3DXPlaneFromPoints( &plane, &c, &d, &m_vEyePt ) ));
    CheckHR(m_pDevice->SetClipPlane( 3, *D3DXPlaneFromPoints( &plane, &a, &c, &m_vEyePt ) ));
#endif 0
    // !!! CheckHR(m_pDevice->SetRenderState( D3DRS_CLIPPLANEENABLE, 0x0f ));

    // Render the scene
    RenderScene();

    // Restore the modified render states
    CheckHR(m_pDevice->SetTransform( D3DTS_WORLD, &matWorldSaved ));
    // !!! CheckHR(m_pDevice->SetRenderState( D3DRS_CLIPPLANEENABLE, 0x00 ));
    CheckHR(m_pDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW ));

    // Finally, render the mirror itself (as an alpha-blended quad)
    CheckHR(m_pDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,   TRUE ));
    CheckHR(m_pDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA ));
    CheckHR(m_pDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ));

    CheckHR(m_pDevice->SetStreamSource( 0, m_pMirrorVB, sizeof(MIRRORVERTEX) ));
    CheckHR(m_pDevice->SetVertexShader( D3DFVF_MIRRORVERTEX ));
    CheckHR(m_pDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 ));

    CheckHR(m_pDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,   FALSE ));
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
void CMyD3DApplication::Render()
{
    // Clear the viewport
    CheckHR(m_pDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                              0x000000ff, 1.0f, 0L ));
 
    // Begin the scene
    CheckHR(m_pDevice->BeginScene());
    
    // Render the scene
    RenderScene();

    // Render the scene in the mirror
    RenderMirror();

    // End the scene.
    CheckHR(m_pDevice->EndScene());
}




//-----------------------------------------------------------------------------
// Name: InitDeviceObjects()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
void CMyD3DApplication::InitDeviceObjects()
{
    // Set up the geometry objects
    m_pTeapot->Create( m_pDevice, "Teapot.x");

    // Create a square for rendering the mirror
    CheckHR(m_pDevice->CreateVertexBuffer( 4*sizeof(MIRRORVERTEX),
                                           D3DUSAGE_WRITEONLY,
                                           D3DFVF_MIRRORVERTEX,
                                           D3DPOOL_MANAGED, 
                                           &m_pMirrorVB ) );

    // Initialize the mirror's vertices
    MIRRORVERTEX* v;
    CheckHR(m_pMirrorVB->Lock( 0, 0, (BYTE**)&v, 0 ));
    v[0].p = D3DXVECTOR3(-1.5f, 1.5f, 3.0f );
    v[2].p = D3DXVECTOR3(-1.5f,-1.5f, 3.0f );
    v[1].p = D3DXVECTOR3( 1.5f, 1.5f, 3.0f );
    v[3].p = D3DXVECTOR3( 1.5f,-1.5f, 3.0f );
    v[0].n     = v[1].n     = v[2].n     = v[3].n     = D3DXVECTOR3(0.0f,0.0f,-1.0f);
    v[0].color = v[1].color = v[2].color = v[3].color = 0x80ffffff;
    CheckHR(m_pMirrorVB->Unlock());
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
void CMyD3DApplication::RestoreDeviceObjects()
{
    // Set up the geometry objects
    m_pTeapot->RestoreDeviceObjects( m_pDevice );

    // Set up the textures
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR ));

    // Set miscellaneous render states
    CheckHR(m_pDevice->SetRenderState( D3DRS_DITHERENABLE,   TRUE ));
    CheckHR(m_pDevice->SetRenderState( D3DRS_SPECULARENABLE, TRUE ));
    CheckHR(m_pDevice->SetRenderState( D3DRS_ZENABLE,        TRUE ));

    // Set up the matrices
    D3DXMATRIX matWorld, matView, matProj;
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixLookAtLH( &matView, &m_vEyePt, &m_vLookatPt, &m_vUpVec );
    FLOAT fAspect = m_BackBufferDesc.Width / (FLOAT)m_BackBufferDesc.Height;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, fAspect, 1.0f, 100.0f );
    CheckHR(m_pDevice->SetTransform( D3DTS_WORLD,      &matWorld ));
    CheckHR(m_pDevice->SetTransform( D3DTS_VIEW,       &matView ));
    CheckHR(m_pDevice->SetTransform( D3DTS_PROJECTION, &matProj ));

    // Set up a light
    if( ( m_Caps.VertexProcessingCaps & D3DVTXPCAPS_DIRECTIONALLIGHTS ))
    {
        D3DLIGHT8 light;
        D3DUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, 0.2f, -1.0f, -0.2f );
        CheckHR(m_pDevice->SetLight( 0, &light ));
        CheckHR(m_pDevice->LightEnable( 0, TRUE ));
    }
    CheckHR(m_pDevice->SetRenderState( D3DRS_AMBIENT, 0xff555555 ));
}




//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc:
//-----------------------------------------------------------------------------
void CMyD3DApplication::InvalidateDeviceObjects()
{
    m_pTeapot->InvalidateDeviceObjects();
}




//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Called when the app is exitting, or the device is being changed,
//       this function deletes any device dependant objects.
//-----------------------------------------------------------------------------
void CMyD3DApplication::DeleteDeviceObjects()
{
    m_pTeapot->Destroy();

    SAFE_RELEASE( m_pMirrorVB );
}




//-----------------------------------------------------------------------------
// Name: FinalCleanup()
// Desc: Called before the app exits, this function gives the app the chance
//       to cleanup after itself.
//-----------------------------------------------------------------------------
void CMyD3DApplication::FinalCleanup()
{
    SAFE_DELETE( m_pTeapot );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\common\dxutil.h ===
//-----------------------------------------------------------------------------
// File: DXUtil.h
//
// Desc: Helper functions and typing shortcuts for DirectX programming.
//
// Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#ifndef DXUTIL_H
#define DXUTIL_H

//-----------------------------------------------------------------------------
// Helpers for handling errors.
//-----------------------------------------------------------------------------

void DisplayError(const WCHAR *szCall, HRESULT hr);

#define CheckHR(x) { HRESULT _hr = (x); if (FAILED(_hr)) { DisplayError(L#x, _hr); } }

//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------
#define SAFE_DELETE(p)       { if(p) { delete (p);     (p)=NULL; } }
#define SAFE_DELETE_ARRAY(p) { if(p) { delete[] (p);   (p)=NULL; } }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

//-----------------------------------------------------------------------------
// Name: DXUtil_GetDXSDKMediaPath() and DXUtil_FindMediaFile() 
// Desc: Find a file in the media directory
//-----------------------------------------------------------------------------
void   DXUtil_FindMediaFile( CHAR* strPath, CHAR* strFilename );

//-----------------------------------------------------------------------------
// Name: DXUtil_Timer()
// Desc: Performs timer opertations. Must be reset before use.
//-----------------------------------------------------------------------------

class DXUtil_Timer
{
	static float GetTime() 
	{
        LARGE_INTEGER qwTime;

        QueryPerformanceCounter( &qwTime );
        return ((float)qwTime.QuadPart) * m_fSecsPerTick;
	}

	static FLOAT m_fSecsPerTick;
	static FLOAT m_fBaseTime;
	static FLOAT m_fStopTime;

public:

	static void Reset()
	{
        LARGE_INTEGER qwTicksPerSec;

        QueryPerformanceFrequency(&qwTicksPerSec);

        m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;

        m_fBaseTime = GetTime();
	}

	static float GetAppTime()
	{
        return GetTime() - m_fBaseTime;
	}

	static float GetAbsoluteTime()
	{
        return GetTime();
	}

	static void Start()
	{
        m_fBaseTime += GetTime() - m_fStopTime;
	}

	static void Stop()
	{
        m_fStopTime = GetTime();
	}

	static void Advance()
	{
        m_fBaseTime += GetTime() - ( m_fStopTime + 0.1f );
	}
};

VOID DXUtil_ConvertWideStringToAnsi( CHAR* strDestination, const WCHAR* wstrSource, 
                                     int cchDestChar );
VOID DXUtil_ConvertGenericStringToAnsi( CHAR* strDestination, const TCHAR* tstrSource, 
                                        int cchDestChar );

#endif // DXUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\common\d3dapp.cpp ===
//-----------------------------------------------------------------------------
// File: D3DApp.cpp
//
// Desc: Application class for the Direct3D samples framework library.
//
// Copyright (c) 1998-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#define INITGUID

#include <stdio.h>
#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#endif

#if defined(PCBUILD)
#include <d3d8.h>
#include <d3dx8core.h>
#include <dinput.h>
#endif 

#include "D3DApp.h"
#include "DXUtil.h"

#ifndef XBOX

#define INITGUID
#include <objbase.h>
#include <rmxfguid.h>
#endif

// Define PCBUILD if building to run on a PC - we need to create a window.

static ScenarioMenu s_MainMenu = 
{
	MT_STARTBUTTON1,
	L"Main Menu",
	{
		L"Display statistics",
		L"Run a 20-second test",
		L"Pause",
		L"Step",
		L"Quit",
		NULL
	},
	5
};

static ScenarioMenu s_ToggleMenu = 
{
	MT_STARTBUTTON2,
	L"Main Toggle Menu",
	{
		L"Cycle screen mode",
		L"Cycle antialias mode",
		NULL,
		NULL,
		NULL,
		NULL
	},
	2
};

static const WCHAR *s_rgszMenuButtons[] =
{
	L"Left top trigger",
	L"Right top trigger",
	L"Left underside trigger",
	L"Right underside trigger",
	L"Top start button",
	L"Bottom start button",
};

//-----------------------------------------------------------------------------
// Class constructor.
//-----------------------------------------------------------------------------

CD3DApplication::CD3DApplication()
{
    m_pD3D              = NULL;
    m_pDevice           = NULL;
    m_hWnd              = NULL;
    m_bActive           = FALSE;
    m_bReady            = FALSE;

#if defined(PCBUILD)
	m_pDirectInput		= NULL;
	m_pKeyboard			= NULL;
	m_pGamepad          = NULL;
#else
    m_hDevice           = 0;
#endif 

	m_fShowHelp         = FALSE;
	m_fShowStats		= TRUE;
	m_iActiveMenu		= MT_NONE;
	m_iActiveKey		= -1;

	ZeroMemory(m_rgpMenus, sizeof(m_rgpMenus));

	m_cMenus			= 0;
	m_dwSpaceHeight		= 0;
	m_dwHelpWidth		= 0;	
	m_dwColumn1X		= 0;	
	m_dwColumn2X		= 0;

    m_bFrameMoving      = TRUE;
    m_bSingleStep       = FALSE;
	m_bRunFullTest      = FALSE;

    m_fFPS              = 0.0f;
    m_strFrameStats[0]  = 0;
	m_szTestStats[0]    = 0;

    m_bUseDepthBuffer   = FALSE;
    m_DepthBufferFormat = D3DFMT_D16;
	m_dwCurrentMode     = 0;

	m_dwSampleMask		= 0;
	m_iSampleType		= (D3DMULTISAMPLE_TYPE)0;

	m_dwFrames			= 0;
}

#if PCBUILD

//-----------------------------------------------------------------------------
// Dummy message handler for the window that the PC requires us to create.
//-----------------------------------------------------------------------------

LRESULT CALLBACK WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return DefWindowProc( hWnd, uMsg, wParam, lParam );
}

//-----------------------------------------------------------------------------
// Create the dummy window.
//-----------------------------------------------------------------------------

static HWND GetDummyWindow(HINSTANCE hInstance)
{
	HWND hWnd;

    // Register the windows class
    WNDCLASS wndClass = { 
						  CS_CLASSDC, 
		                  WndProc, 
						  0, 
						  0, 
						  hInstance,
                          NULL,
                          NULL, 
                          (HBRUSH)GetStockObject(WHITE_BRUSH),
                          NULL, 
						  L"Dummy Window" 
						};

    RegisterClass( &wndClass );

    // Create the render window
    hWnd = CreateWindow(L"Dummy Window", 
		                NULL,
                        WS_MINIMIZE,
                        0, 
						0,
                        1,
						1, 
						0,
                        NULL, 
                        hInstance, 
						0L);

    ShowWindow(hWnd, SW_SHOWNORMAL);
    ShowCursor(false);

	return hWnd;
}

#else !PCBUILD

//-----------------------------------------------------------------------------
// Stub so we won't try to create a window on the non-pc build.
//-----------------------------------------------------------------------------

inline HWND GetDummyWindow(HINSTANCE) { return NULL; }

#endif !PCBUILD

//-----------------------------------------------------------------------------
// Do the initial preparations for running the scenario.
//-----------------------------------------------------------------------------

void CD3DApplication::Create(HINSTANCE hInstance)
{

#if defined(XBOX)

#endif

    // Create the Direct3D object
    m_pD3D = Direct3DCreate8(D3D_SDK_VERSION);

    if( m_pD3D == NULL )
    {
		DisplayError(L"FATAL: Unable to create Direct3D.", 0);
    }

    // Build a list of Direct3D adapters, modes and devices. The ConfirmDevice() 
	// callback is used to confirm that only devices that meet the app's 
	// requirements are considered.
	//
    BuildDeviceList();

#if defined(PCBUILD)

	// Create the DirectInput object.
	CheckHR(DirectInput8Create(hInstance, 
		                       DIRECTINPUT_VERSION, 
							   IID_IDirectInput8, 
							   (void **)&m_pDirectInput, 
							   NULL));

	// Hook up to the keyboard and the gamepad if they're available.
	GetInputDevices();

#else
    //Initialize core peripheral port support
    XInitDevices(0,NULL);

    if(XDEVICE_PORT0_MASK&XGetDevices(XDEVICE_TYPE_GAMEPAD))
    {
        m_hDevice = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL);
    }

#endif

    // Get the windows class.
	m_hWnd = GetDummyWindow(hInstance);

    // Initialize the app's custom scene stuff
    OneTimeSceneInit();

    // Initialize the 3D environment for the app
    Initialize3DEnvironment();

	// Prepare the help information.
	InitializeHelpInformation();

    // Setup the app so it can support single-stepping
	DXUtil_Timer::Reset();

    // The app is ready to go
    m_bReady = TRUE;
}

//-----------------------------------------------------------------------------
// Callback function for sorting display modes.
//-----------------------------------------------------------------------------

int SortModesCallback( const VOID* arg1, const VOID* arg2 )
{
    D3DDISPLAYMODE* p1 = (D3DDISPLAYMODE*)arg1;
    D3DDISPLAYMODE* p2 = (D3DDISPLAYMODE*)arg2;

    if( p1->Format > p2->Format )   return -1;
    if( p1->Format < p2->Format )   return +1;
    if( p1->Width  < p2->Width )    return -1;
    if( p1->Width  > p2->Width )    return +1;
    if( p1->Height < p2->Height )   return -1;
    if( p1->Height > p2->Height )   return +1;

    return 0;
}

//-----------------------------------------------------------------------------
// Gather information about the adapter and what modes it supports.  This
// method assumes that we only have one adapter and that is supports the
// modes an capacities that we need.
//
// The method returns 'true' if it succeeds.
//-----------------------------------------------------------------------------

void CD3DApplication::BuildDeviceList()
{	
	// We only support one adapter.
	const unsigned iAdapter = 0;

	if (m_pD3D->GetAdapterCount() != 1)
	{
		DisplayError(L"FATAL: Multiple adapters found, only one adapter is supported.", 0);
	}

    // Get the adapter attributes
    CheckHR(m_pD3D->GetAdapterIdentifier(iAdapter, 0L, &m_Adapter.AdapterIdentifier));

    // Enumerate display modes
    D3DDISPLAYMODE modes[100];
    D3DFORMAT      formats[20];
    DWORD dwNumFormats      = 0;
    DWORD dwNumModes        = 0;
    DWORD dwNumAdapterModes = m_pD3D->GetAdapterModeCount(iAdapter);

    // Add the current desktop format to list of formats
    D3DDISPLAYMODE DesktopMode;
    CheckHR(m_pD3D->GetAdapterDisplayMode(iAdapter, &DesktopMode));
    if (DesktopMode.Format != 0)
    {
        formats[dwNumFormats++] = DesktopMode.Format;
    }

    for (UINT iMode = 0; iMode < dwNumAdapterModes; iMode++)
    {
        // Get the display mode attributes
        D3DDISPLAYMODE DisplayMode;

        CheckHR(m_pD3D->EnumAdapterModes(iAdapter, iMode, &DisplayMode));

        // Filter out unknown modes
        if (DisplayMode.Format == D3DFMT_UNKNOWN)
		{
            continue;
		}

        // Filter out low-resolution modes
        if (DisplayMode.Width  < 640 || DisplayMode.Height < 400) 
		{
            continue;
		}

        // Check if the mode already exists (to filter out refresh rates)
        for (DWORD m = 0; m < dwNumModes; m++)
        {
            if ((modes[m].Width  == DisplayMode.Width ) &&
                (modes[m].Height == DisplayMode.Height) &&
                (modes[m].Format == DisplayMode.Format)) 
			{
                break;
			}
        }

        // If we found a new mode, add it to the list
        if (m == dwNumModes)
        {
            modes[dwNumModes].Width       = DisplayMode.Width;
            modes[dwNumModes].Height      = DisplayMode.Height;
            modes[dwNumModes].Format      = DisplayMode.Format;
            modes[dwNumModes].RefreshRate = 0;
            dwNumModes++;

            // Check if the mode's format already exists
            for (DWORD f = 0; f < dwNumFormats; f++)
            {
                if (DisplayMode.Format == formats[f])
				{
                    break;
				}
            }

            // If the format is new, add it to the list
            if (f == dwNumFormats)
			{
                formats[dwNumFormats++] = DisplayMode.Format;
			}
        }
    }

    // Sort the list of display modes (by format, then width, then height)

    // Get the device attributes
    CheckHR(m_pD3D->GetDeviceCaps(iAdapter, D3DDEVTYPE_HAL, &m_Adapter.Caps));

    // Call the app's ConfirmDevice() callback to see if the device
    // caps and the enumerated formats meet the app's requirements.
	//
    BOOL  bFormatConfirmed[20];
    DWORD dwBehavior[20];

    for (DWORD f = 0; f < dwNumFormats; f++)
    {
		HRESULT hr;

        bFormatConfirmed[f] = FALSE;

        hr = m_pD3D->CheckDeviceFormat(iAdapter, 
			                           D3DDEVTYPE_HAL, 
                                       formats[f], 
									   D3DUSAGE_RENDERTARGET, 
                                       D3DRTYPE_SURFACE, 
									   formats[f]);

		if (FAILED(hr))
		{
            continue;
		}

        // Confirm the device for HW vertex processing
        if (m_Adapter.Caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT)
        {
            dwBehavior[f] = D3DCREATE_HARDWARE_VERTEXPROCESSING;

            if (ConfirmDevice(&m_Adapter.Caps, dwBehavior[f], formats[f]))
			{
                bFormatConfirmed[f] = TRUE;
			}
        }

        // Confirm the device for SW vertex processing
        if (FALSE == bFormatConfirmed[f])
        {
            dwBehavior[f] = D3DCREATE_SOFTWARE_VERTEXPROCESSING;

            if (ConfirmDevice(&m_Adapter.Caps, dwBehavior[f], formats[f]))
			{
                bFormatConfirmed[f] = TRUE;
			}
        }
    }

    // Add all enumerated display modes with confirmed formats to the
    // device's list of valid modes
	//
    for (DWORD m = 0; m < dwNumModes; m++)
    {
        for (DWORD f = 0; f < dwNumFormats; f++)
        {
            if (modes[m].Format == formats[f])
            {
                if (bFormatConfirmed[f] == TRUE)
                {
                    // Add this mode to the device's list of valid modes
                    m_Adapter.modes[m_Adapter.dwNumModes].Width      = modes[m].Width;
                    m_Adapter.modes[m_Adapter.dwNumModes].Height     = modes[m].Height;
                    m_Adapter.modes[m_Adapter.dwNumModes].Format     = modes[m].Format;
                    m_Adapter.modes[m_Adapter.dwNumModes].dwBehavior = dwBehavior[f];
                    m_Adapter.dwNumModes++;
                }
            }
        }
    }

    // Select 640x480, 16-bit mode for default
    for (m = 0; m < m_Adapter.dwNumModes; m++)
    {
        if (m_Adapter.modes[m].Width==640 && 
			m_Adapter.modes[m].Height==480 
#ifdef XBOX
			 && m_Adapter.modes[m].Format == D3DFMT_LIN_R5G6B5
#endif
            )
        {
            m_dwCurrentMode = m;
            break;
        }
    }

	// Generate an error if we didn't find the default mode.
	if (m == m_Adapter.dwNumModes)
	{
		DisplayError(L"FATAL: Unable to obtain 640x480x16 mode.", 0);
	}
}

#if defined(PCBUILD)

//-----------------------------------------------------------------------------
// Callback to enumerate the devices.
//-----------------------------------------------------------------------------

BOOL _stdcall CALLBACK InputEnumCallback(const DIDEVICEINSTANCE *pdi, void *pvRef) 
{ 
	DIDEVICEINSTANCE *rgdi = (DIDEVICEINSTANCE *)pvRef;

	if (GET_DIDEVICE_TYPE(pdi->dwDevType) == DI8DEVTYPE_KEYBOARD)
	{
		// Only 'see' the first one.
		if (!rgdi[0].dwDevType)
		{
			rgdi[0] = *pdi;
		}
	}

	else if (GET_DIDEVICE_TYPE(pdi->dwDevType) == DI8DEVTYPE_JOYSTICK)
	{
		// Only 'see' the first one.
		if (!rgdi[1].dwDevType)
		{
			rgdi[1] = *pdi;
		}
	}

	if (rgdi[0].dwDevType && rgdi[1].dwDevType)
	{
		return DIENUM_STOP; 
	}
	else
	{
		return DIENUM_CONTINUE; 
	}
}

#endif

//-----------------------------------------------------------------------------
// Hook up to the keyboard and the gamepad if they're available.  If there
// aren't any devices then the scenario cannot be controlled and will 
// run forever.
//-----------------------------------------------------------------------------

#if defined(PCBUILD)

void CD3DApplication::GetInputDevices()
{

	DIDEVICEINSTANCE rgdi[2];

	// Zero the array we're going to fill in the enumeration.
	ZeroMemory(rgdi, sizeof(rgdi));

	// Enumerate all connected devices.
	CheckHR(m_pDirectInput->EnumDevices(DI8DEVCLASS_ALL, 
					                    InputEnumCallback, 
										(void *)&rgdi, 
										DIEDFL_ATTACHEDONLY));	

	// Initialize the keyboard device, if installed.
	if (rgdi[0].dwDevType)
	{
		CheckHR(m_pDirectInput->CreateDevice(rgdi[0].guidInstance, &m_pKeyboard, NULL));

		CheckHR(m_pKeyboard->SetDataFormat(&c_dfDIKeyboard))
		CheckHR(m_pKeyboard->Acquire());
	}

	// Initialize the gamepad device, if installed.
	if (rgdi[1].dwDevType)
	{
		CheckHR(m_pDirectInput->CreateDevice(rgdi[1].guidInstance, &m_pGamepad, NULL));

		// What should I set the format to?
		CheckHR(m_pGamepad->SetDataFormat(&c_dfDIJoystick ))
		CheckHR(m_pGamepad->Acquire());
	}

}

#endif

//-----------------------------------------------------------------------------
// Create the rendering device and set up the back buffers.
//-----------------------------------------------------------------------------

void CD3DApplication::Initialize3DEnvironment()
{
    Adapter::Mode *pModeInfo = &m_Adapter.modes[m_dwCurrentMode];

    // Set up the presentation parameters
    ZeroMemory(&m_Presentation, sizeof(m_Presentation));

    switch(pModeInfo->Format)
    {
#ifdef XBOX
    case D3DFMT_LIN_A8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
#endif
    case D3DFMT_A8R8G8B8:
    case D3DFMT_X8R8G8B8:
        m_DepthBufferFormat = D3DFMT_D24S8;
        break;

#ifdef XBOX
    case D3DFMT_LIN_R5G6B5:
    case D3DFMT_LIN_X1R5G5B5:
#endif
    case D3DFMT_R5G6B5:
    case D3DFMT_X1R5G5B5:
        m_DepthBufferFormat = D3DFMT_D16;
        break;
    }

    m_Presentation.Windowed               = FALSE;
    m_Presentation.BackBufferCount        = 2;
    m_Presentation.MultiSampleType        = m_iSampleType;
    m_Presentation.SwapEffect             = D3DSWAPEFFECT_DISCARD;
    m_Presentation.EnableAutoDepthStencil = m_bUseDepthBuffer;
    m_Presentation.AutoDepthStencilFormat = m_DepthBufferFormat;
    m_Presentation.hDeviceWindow          = m_hWnd;
    m_Presentation.BackBufferWidth        = pModeInfo->Width;
    m_Presentation.BackBufferHeight       = pModeInfo->Height;
    m_Presentation.BackBufferFormat       = pModeInfo->Format;
    m_Presentation.Flags                  = D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;
    m_Presentation.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Create the device
    CheckHR(m_pD3D->CreateDevice(0, 
		                     D3DDEVTYPE_HAL, 
                             m_hWnd, 
						     pModeInfo->dwBehavior, 
							 &m_Presentation, 
                             &m_pDevice));

    // Store device Caps
    CheckHR(m_pDevice->GetDeviceCaps(&m_Caps));

	// Figure out the FSAA modes that are supported by the device.
	m_dwSampleMask = 0;
	m_iSampleType = (D3DMULTISAMPLE_TYPE)0;

	for (unsigned i = 2; i < 32; i++)
	{
		HRESULT hr = m_pD3D->CheckDeviceMultiSampleType(0, 
			                                            D3DDEVTYPE_HAL, 
												        pModeInfo->Format, 
														FALSE, 
														(D3DMULTISAMPLE_TYPE)i);

		if (SUCCEEDED(hr))
		{
            m_dwSampleMask |= 1 << i;
		}
	}

    // Store render target surface descriptor

    CheckHR(m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer));

    m_pBackBuffer->GetDesc(&m_BackBufferDesc);

    // Initialize the app's device-dependant objects
	InitDeviceObjects();
    RestoreDeviceObjects();

	m_bActive = TRUE;
}

//-----------------------------------------------------------------------------
// Helper to draw text on the screen.
//-----------------------------------------------------------------------------
void CD3DApplication::DisplayText(const WCHAR *sz, int iY, DWORD dwColor)
{
    m_Font.DrawText(m_pBackBuffer, sz, 0, iY, DRAWTEXT_TRANSPARENTBKGND, dwColor, 0);
}

//-----------------------------------------------------------------------------
// Handles driver, device, and/or mode changes for the app.
//-----------------------------------------------------------------------------

void CD3DApplication::Change3DEnvironment()
{
    // Release all scene objects that will be re-created for the new device
	InvalidateDeviceObjects();
    DeleteDeviceObjects();

    if (m_pBackBuffer)
	{
		m_pBackBuffer->Release();
		m_pBackBuffer = NULL;
	}

    // Release display objects, so a new device can be created
	//
	// UNDONE andrewso: Make sure this is a safe assumption.
	//
    if (m_pDevice->Release() > 0)
    {
		DisplayError(L"FATAL: Device still has an outstanding reference.", 0);
    }

	// Just to be safe.
	m_pDevice = NULL;

    // Inform the display class of the driver change. It will internally
    // re-create valid surfaces, a d3ddevice, etc.
	//
    Initialize3DEnvironment();

    // If the app is paused, trigger the rendering of the current frame
    if (FALSE == m_bFrameMoving)
    {
        m_bSingleStep = TRUE;

		DXUtil_Timer::Start();
		DXUtil_Timer::Stop();
    }
}

//-----------------------------------------------------------------------------
// Handle regaining the device.
//-----------------------------------------------------------------------------

void CD3DApplication::Resize3DEnvironment()
{
    // Release all vidmem objects
	InvalidateDeviceObjects();

    // Resize the device
    CheckHR(m_pDevice->Reset(&m_Presentation));

    // Store render target surface desc
    LPDIRECT3DSURFACE8 pBackBuffer;

    CheckHR(m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer));

    pBackBuffer->GetDesc(&m_BackBufferDesc);
    pBackBuffer->Release();

    // Initialize the app's device-dependant objects
    RestoreDeviceObjects();

    // If the app is paused, trigger the rendering of the current frame
    if (FALSE == m_bFrameMoving)
    {
        m_bSingleStep = TRUE;

		DXUtil_Timer::Start();
		DXUtil_Timer::Stop();
    }
}

//-----------------------------------------------------------------------------
// Cleanup scene objects
//-----------------------------------------------------------------------------

void CD3DApplication::Cleanup3DEnvironment()
{
    m_bActive = FALSE;
    m_bReady  = FALSE;

    if (m_pBackBuffer)
	{
		m_pBackBuffer->Release();
		m_pBackBuffer = NULL;
	}

    if (m_pDevice)
    {
        InvalidateDeviceObjects();
        DeleteDeviceObjects();

        m_pDevice->Release();
        m_pD3D->Release();
        
        m_pDevice = NULL;
        m_pD3D = NULL;
    }

#if defined(PCBUILD)
	if (m_pKeyboard)
	{
		m_pKeyboard->Release();
		m_pKeyboard = NULL;
	}

	if (m_pGamepad)
	{
		m_pGamepad->Release();
		m_pGamepad = NULL;
	}

	if (m_pDirectInput)
	{
		m_pDirectInput->Release();
		m_pDirectInput = NULL;
	}
#endif

    FinalCleanup();
}

//-----------------------------------------------------------------------------
// Run the scenario.
//-----------------------------------------------------------------------------

void CD3DApplication::Run()
{
	do
	{
		// Run a 'test'.  This disables everything, resets the stats,
		// runs the test for about 5 seconds, pauses and shows
		// the stats from the result.
		//
		if (m_bRunFullTest)
		{
			// Turn off everything.
			m_bFrameMoving = TRUE;
			m_bSingleStep = FALSE;
			m_fShowHelp = FALSE;
			m_fShowStats = FALSE;
			
			// Clear the stats.  This won't clear any 'lifetime' stats.
			UpdateAllStats();

			// Reset the timer and run for 5 seconds.
			DXUtil_Timer::Start();
			DXUtil_Timer::Reset();

			do
			{
				Render3DEnvironment();
			}
			while (m_fTime < 20.0f);

			// Update the stats.
			UpdateAllStats();

			// Pause.
			m_bFrameMoving = FALSE;
			DXUtil_Timer::Stop();

			// Show the stats.
			m_fShowStats = TRUE;

			// Don't do this agian.
			m_bRunFullTest = FALSE;
		}

        // Render a frame.
        if (m_bActive && m_bReady)
        {
            Render3DEnvironment();
        }
	}
	while(ProcessInput());
}

//-----------------------------------------------------------------------------
// Draws the scene.
//-----------------------------------------------------------------------------

void CD3DApplication::Render3DEnvironment()
{       
    // Get the app's time, in seconds.
    static float fLastAppTime = 0.0f;

    float fAppTime        = DXUtil_Timer::GetAppTime();
    float fElapsedAppTime = fAppTime - fLastAppTime;
    fLastAppTime          = fAppTime;

    // FrameMove (animate) the scene
    if (m_bFrameMoving || m_bSingleStep)
    {
        // Store the time for the app
        m_fTime        = fAppTime;
        m_fElapsedTime = fElapsedAppTime;

        // Frame move the scene
        FrameMove();

        m_bSingleStep = FALSE;
    }

    // Render the scene as normal
    Render();

	if (m_fShowStats)
	{
		int iY = 0;

		if (m_strFrameStats[0])
		{
			DisplayText(m_strFrameStats, 0, 0xffffff00);
			iY += m_dwSpaceHeight;
		}

		if (m_szTestStats[0])
		{
			DisplayText(m_szTestStats, iY, 0xffffff00);
			iY += m_dwSpaceHeight;
		}

		ShowInfo(iY, m_dwSpaceHeight);
	}

	if (m_fShowHelp)
	{
		ShowHelp(m_pBackBuffer);
	}

	// Keep track of the frame rate.
	m_dwFrames++;

	// Only update the stats if the scene is moving.
	if (m_fShowStats && m_bFrameMoving)
    {
		UpdateAllStats();
    }

    // Show the frame on the primary surface.
    CheckHR(m_pDevice->Present(NULL, NULL, NULL, NULL));
}

//-----------------------------------------------------------------------------
// Gets a string for an antialias mode.
//-----------------------------------------------------------------------------

static WCHAR *AntialiasModeName(D3DMULTISAMPLE_TYPE iType)
{
	switch(iType)
	{
    case D3DMULTISAMPLE_NONE:
		return L"D3DMULTISAMPLE_NONE";

	default:
		return L"unknown mode";
	}
}

//-----------------------------------------------------------------------------
// Update and reset all of the statistics.
//-----------------------------------------------------------------------------

void CD3DApplication::UpdateAllStats()
{
    static float fLastTime = 0.0f;

    float fTime = DXUtil_Timer::GetAbsoluteTime();

    // Update the scene stats once per second
    if (fTime - fLastTime > 1.0f)
    {
        m_fFPS     = m_dwFrames / (fTime - fLastTime);

        swprintf(m_strFrameStats, 
			     L"%.2f fps (%dx%dx%d) antialiasmode: %s", 
				 m_fFPS,
                 m_BackBufferDesc.Width, 
				 m_BackBufferDesc.Height, 
#ifdef XBOX
                 m_BackBufferDesc.Format == D3DFMT_LIN_X8R8G8B8 ? 32 : 16,
#else // XBOX
                 16,
#endif // XBOX
				 m_dwSampleMask ? AntialiasModeName(m_iSampleType) : L"not supported");

		// Let the subclass update its stats.
		UpdateStats(fTime - fLastTime);

		// Reset.
        fLastTime  = fTime;
        m_dwFrames = 0L;
    }
}

//-----------------------------------------------------------------------------
// Do all input processing.
//-----------------------------------------------------------------------------

bool CD3DApplication::ProcessInput()
{
	bool retval = true;

	DWORD rgActiveMenu[MT_MAX];
	BOOL rgKeyDown[6];

	unsigned cMenus = 0;

	DWORD iActiveMenu;
	DWORD iActiveKey;

	ZeroMemory(rgKeyDown, sizeof(rgKeyDown));
    ZeroMemory(rgActiveMenu, sizeof(rgActiveMenu));

	//
	// Get the state.
	//

#if defined(PCBUILD)

	// Get the state from the keyboard.
	if (m_pKeyboard)
	{
		BYTE rgKeys[256];

		CheckHR(m_pKeyboard->GetDeviceState(sizeof(rgKeys), &rgKeys));

		// Check the menu keys.
		if (rgKeys[DIK_LSHIFT] & 0x80)
		{
			rgActiveMenu[cMenus++] = MT_BUTTON7;
		}

		if (rgKeys[DIK_RSHIFT] & 0x80)
		{
			rgActiveMenu[cMenus++] = MT_BUTTON8;
		}
		
		if (rgKeys[DIK_LCONTROL] & 0x80)
		{
			rgActiveMenu[cMenus++] = MT_BUTTON9;
		}
		
		if (rgKeys[DIK_RCONTROL] & 0x80)
		{
			rgActiveMenu[cMenus++] = MT_BUTTON10;
		}
		
		if ((rgKeys[DIK_LMENU] & 0x80))
		{
			rgActiveMenu[cMenus++] = MT_STARTBUTTON1;
		}
	
		if ((rgKeys[DIK_RMENU] & 0x80))
		{
			rgActiveMenu[cMenus++] = MT_STARTBUTTON2;
		}

		// Check the action keys.
		if (rgKeys[DIK_A] & 0x80)
		{
			rgKeyDown[0] = TRUE;
		}

		if (rgKeys[DIK_B] & 0x80)
		{
			rgKeyDown[1] = TRUE;
		}

		if (rgKeys[DIK_C] & 0x80)
		{
			rgKeyDown[2] = TRUE;
		}

		if (rgKeys[DIK_D] & 0x80)
		{
			rgKeyDown[3] = TRUE;
		}

		if (rgKeys[DIK_E] & 0x80)
		{
			rgKeyDown[4] = TRUE;
		}

		if (rgKeys[DIK_F] & 0x80)
		{
			rgKeyDown[5] = TRUE;
		}

		// A couple of cheaters.  F1 brings up the main help menu
		// and ESC quits the app.
		//
		if (rgKeys[DIK_F1] & 0x80)
		{
			// This forces the main help menu.
			cMenus = 2;
		}

		if (rgKeys[DIK_ESCAPE] & 0x80)
		{
			// This forces a 'quit'.
			cMenus = 1;
			rgActiveMenu[0] = MT_STARTBUTTON1;

			ZeroMemory(rgKeyDown, sizeof(rgKeyDown));
			rgKeyDown[4] = TRUE;
		}
	}

	// Get the state from the gamepad.
	if (m_pGamepad)
	{
		DIJOYSTATE state;

		CheckHR(m_pGamepad->GetDeviceState(sizeof(state), &state));

		// Check the menu keys.
		if (state.rgbButtons[6] & 0x80)
		{
			rgActiveMenu[cMenus++] = MT_BUTTON7;
		}

		if (state.rgbButtons[7] & 0x80)
		{
			rgActiveMenu[cMenus++] = MT_BUTTON8;
		}
		
		if (state.rgbButtons[8] & 0x80)
		{
			rgActiveMenu[cMenus++] = MT_BUTTON9;
		}
		
		if (state.rgbButtons[9] & 0x80)
		{
			rgActiveMenu[cMenus++] = MT_BUTTON10;
		}
		
		if (state.rgbButtons[10] & 0x80)
		{
			rgActiveMenu[cMenus++] = MT_STARTBUTTON1;
		}
	
		if (state.rgbButtons[11] & 0x80)
		{
			rgActiveMenu[cMenus++] = MT_STARTBUTTON2;
		}

		// Check the action keys.
		for (unsigned i = 0; i < 6; i++)
		{
			if (state.rgbButtons[i] & 0x80)
			{
				rgKeyDown[i] = TRUE;
			}
		}
	}

#else // !PCBUILD

    //
    //  Check to see if a port 0 gamepad has come or gone.
    //
    DWORD dwInsertions, dwRemovals;
    if(XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals))
    {
        if(dwRemovals&XDEVICE_PORT0_MASK)
        {
            if(m_hDevice)
            {
                XInputClose(m_hDevice);
                m_hDevice = NULL;
            }
        }
        if(dwInsertions&XDEVICE_PORT0_MASK)
        {
            m_hDevice = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL);
        }
    }

    // If we have a device, get its state.
    if (m_hDevice)
    {
        XINPUT_STATE InputState;

        XInputGetState(m_hDevice, &InputState);

		// Check the menu keys.
		if (InputState.Gamepad.bAnalogButtons[6])
		{
			rgActiveMenu[cMenus++] = MT_BUTTON7;
		}

		if (InputState.Gamepad.bAnalogButtons[7])
		{
			rgActiveMenu[cMenus++] = MT_BUTTON8;
		}
		
		if (InputState.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_THUMB)
		{
			rgActiveMenu[cMenus++] = MT_BUTTON9;
		}
		
		if (InputState.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB)
		{
			rgActiveMenu[cMenus++] = MT_BUTTON10;
		}
		
		if (InputState.Gamepad.wButtons & XINPUT_GAMEPAD_START)
		{
			rgActiveMenu[cMenus++] = MT_STARTBUTTON1;
		}
	
		if (InputState.Gamepad.wButtons & XINPUT_GAMEPAD_BACK)
		{
			rgActiveMenu[cMenus++] = MT_STARTBUTTON2;
		}

		// Check the action keys.
		for (unsigned i = 0; i < 6; i++)
		{
			if (InputState.Gamepad.bAnalogButtons[i])
			{
				rgKeyDown[i] = TRUE;
			}
		}
    }


#endif // !PCBUILD

	//
	// Process the inputs.
	//

	// We need to show help if at least one menu button is
	// pressed.
	//
	m_fShowHelp = cMenus;

	// Select the active menu.
	if (cMenus != 1 || !m_rgpMenus[rgActiveMenu[0]])
	{
		iActiveMenu = MT_NONE;
	}
	else
	{
		iActiveMenu = rgActiveMenu[0];
	}

	// Find the active key, if any (set to -1 if there is no key).  
	// Don't set the key if there are multiple menu buttons
	// pressed.
	//
	iActiveKey = -1;

	if (cMenus < 2) 
	{
		for (unsigned i = 0; i < 6; i++)
		{
			if (rgKeyDown[i])
			{
				if (iActiveKey == -1)
				{
					iActiveKey = i;
				}
				else
				{
					iActiveKey = -1;
					break;
				}
			}
		}
	}

	// Part of the above ESC hack, if ESC was pressed and is
	// no more, then remember the old menu.
	//
	if (iActiveKey == -1 && m_iActiveKey == 4 && m_iActiveMenu == MT_STARTBUTTON1)
	{
		iActiveMenu = m_iActiveMenu;;
	}

	// Figure out which key was actually pressed and
	// process it.
	//
	if (iActiveKey == -1 && m_iActiveKey != -1)
	{
		if (iActiveMenu == MT_STARTBUTTON1)
		{
			switch(m_iActiveKey)
			{
			// Display stats.
			case 0:
				m_fShowStats = !m_fShowStats;
				break;

			// Run a full test.
			case 1:
				m_bRunFullTest = TRUE;
				break;

			// Pause the test.
			case 2:
				// Toggle frame movement
				m_bFrameMoving = !m_bFrameMoving;

				if (m_bFrameMoving)
				{
					DXUtil_Timer::Start();
				}
				else
				{
					DXUtil_Timer::Stop();
				}
				break;

			// Single-step.
			case 3:
				// Single-step frame movement
				if (FALSE == m_bFrameMoving)
				{
					DXUtil_Timer::Advance();
				}

				DXUtil_Timer::Stop();
				m_bFrameMoving = FALSE;
				m_bSingleStep  = TRUE;

				break;

			// Quit?
			case 4:
				retval = false;
				break;
			}
		}	
		else if (iActiveMenu == MT_STARTBUTTON2)
		{
			switch(m_iActiveKey)
			{
			// Cycle the screen mode.
			case 0:
				m_dwCurrentMode = (m_dwCurrentMode + 1) % m_Adapter.dwNumModes;

				Change3DEnvironment();
				break;

			// Cycle to the next antialias mode.
			case 1:
				{
					unsigned i, iNewSampleType;

					// If no bits are set,then iNewSampleType will wind
					// up with the same value as m_iSampleType;
					//
					for (i = 1; i <= 32; i++)
					{
						iNewSampleType = (m_iSampleType + i) % 32;

						if (m_dwSampleMask & (1 << iNewSampleType ))
						{
							break;
						}
					}
							
					if (m_iSampleType != (D3DMULTISAMPLE_TYPE)iNewSampleType)
					{
						m_iSampleType = (D3DMULTISAMPLE_TYPE)iNewSampleType;						

						Change3DEnvironment();
					}
				}
				break;
			}
		}
		else
		{
			// Send it to the host.
			ProcessKeyPress(m_iActiveMenu, m_iActiveKey);
		}
	}

	// Save the existing state.
	m_iActiveMenu = iActiveMenu;
	m_iActiveKey = iActiveKey;

	return retval;
}

//-----------------------------------------------------------------------------
// Set up the per-app help information.  This pre-computes everything needed
// to draw the help box.
//-----------------------------------------------------------------------------

void CD3DApplication::InitializeHelpInformation()
{
	const unsigned cVertical = 3;		// Spaces for the vertial border
	const unsigned cBetween = 2;        // Space between the two columns.

	unsigned i;

	// Set up the default menu.
	m_rgpMenus[MT_STARTBUTTON1] = &s_MainMenu;
	m_rgpMenus[MT_STARTBUTTON2] = &s_ToggleMenu;
	m_cMenus = 2;

	// Collect menus from our subclass.
	ScenarioMenu *rgOtherMenus[10];
	unsigned iMenu, cMenus;

	cMenus = GetMenus(rgOtherMenus);

	for (iMenu = 0; iMenu < cMenus; iMenu++)
	{
		m_rgpMenus[rgOtherMenus[iMenu]->m_MenuType] = rgOtherMenus[iMenu];
	}

	m_cMenus += cMenus;

	DWORD dwSpaceWidth;
	DWORD dwColumn1Size = 0, dwColumn2Size = 0;

	// Use a big character (such as 'O') to get the height/width that
	// we'll use to create spaces.
	//
    m_Font.GetTextStringLength(&dwSpaceWidth, &m_dwSpaceHeight, L"O");

	// Decide on the size of the menu buttons...these are in column 1
	for (i = 0; i < sizeof(s_rgszMenuButtons) / sizeof(WCHAR *); i++)
	{
		DWORD dwWidth;

        m_Font.GetTextStringLength(&dwWidth, NULL, s_rgszMenuButtons[i]);

		if (dwWidth > dwColumn1Size)
		{
			dwColumn1Size = dwWidth;
		}
	}

	// Figure out the size of the menu names and menu items.
	for (i = 0; i < MT_MAX; i++)
	{
		DWORD dwWidth;

		if (m_rgpMenus[i])
		{
			// The first menu does not have a name.
			if (i != 0)
			{
                m_Font.GetTextStringLength(&dwWidth, NULL, m_rgpMenus[i]->m_szMenuName);

				if (dwWidth > dwColumn2Size)
				{
					dwColumn2Size = dwWidth;
				}
			}

			for (unsigned iItem = 0; iItem < 6; iItem++)
			{
				if (m_rgpMenus[i]->m_szActions[iItem])
				{
                    m_Font.GetTextStringLength(&dwWidth, NULL, m_rgpMenus[i]->m_szActions[iItem]);

					if (dwWidth > dwColumn2Size)
					{
						dwColumn2Size = dwWidth;
					}
				}
			}
		}
	}

	// Compute the values of each column and the total width of the box.  The height
	// can't be calculated until we know which menu is being displayed.
	//
	m_dwColumn1X = dwSpaceWidth * cVertical;
	m_dwColumn2X = m_dwColumn1X + dwColumn1Size + dwSpaceWidth * cBetween;
	m_dwHelpWidth = m_dwColumn2X + dwColumn2Size + dwSpaceWidth * cVertical;
}

//-----------------------------------------------------------------------------
// Draw a help screen on the display.  Make it look pretty.
//-----------------------------------------------------------------------------

void CD3DApplication::ShowHelp(IDirect3DSurface8 *pSurface)
{		
	const unsigned cHorizontal = 2;		// Spaces for the horizontal border

	// Which menu is being displayed?
	const ScenarioMenu *pMenu = m_rgpMenus[m_iActiveMenu];

	// How big is the box?
	unsigned dwHelpHeight = m_dwSpaceHeight * cHorizontal * 2 + m_cMenus * m_dwSpaceHeight;
	
	if (pMenu)
	{
		dwHelpHeight += m_dwSpaceHeight + pMenu->m_cActions * m_dwSpaceHeight;
	}

	// Is the box too big?
	DWORD dwBoxX, dwBoxY;

	// Box too big?
	if (m_Adapter.modes[m_dwCurrentMode].Height <= dwHelpHeight || 
		m_Adapter.modes[m_dwCurrentMode].Width <= m_dwHelpWidth)
	{
		DisplayError(L"FATAL: Help box is too big for this display mode.", 0);
	}

	// Center the box.
	dwBoxX = (m_Adapter.modes[m_dwCurrentMode].Width  - m_dwHelpWidth) / 2;
	dwBoxY = (m_Adapter.modes[m_dwCurrentMode].Height - dwHelpHeight) / 2;

	// Clear the box.
	D3DRECT rect = { dwBoxX, dwBoxY, dwBoxX + m_dwHelpWidth, dwBoxY + dwHelpHeight };
	CheckHR(m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, 0x00000000, 0.0f, 0L));

	// Paint the text.
	DWORD dwY = dwBoxY + m_dwSpaceHeight * cHorizontal;
	unsigned i, c;

	// Start with the menus.
	c = MT_MAX;

	for (i = 1; i < c; i++)
	{
		if (m_rgpMenus[i])
		{
            m_Font.DrawText(m_pBackBuffer, s_rgszMenuButtons[i - 1], m_dwColumn1X + dwBoxX, dwY, DRAWTEXT_TRANSPARENTBKGND, 0x00FFFFFF, 0);
            m_Font.DrawText(m_pBackBuffer, m_rgpMenus[i]->m_szMenuName, m_dwColumn2X + dwBoxX, dwY, DRAWTEXT_TRANSPARENTBKGND, 0x00FFFFFF, 0);

			dwY += m_dwSpaceHeight;
		}
	}

	// Menu items.
	if (pMenu)
	{
		dwY += m_dwSpaceHeight;

		for (i = 0; i < 6; i++)
		{
			if (pMenu->m_szActions[i])
			{
				WCHAR sz[2] = L"A";
				sz[0] += (WCHAR) i;

                m_Font.DrawText(m_pBackBuffer, sz, m_dwColumn1X + dwBoxX, dwY, DRAWTEXT_TRANSPARENTBKGND, 0x00FFFFFF, 0);
                m_Font.DrawText(m_pBackBuffer, pMenu->m_szActions[i], m_dwColumn2X + dwBoxX, dwY, DRAWTEXT_TRANSPARENTBKGND, 0x00FFFFFF, 0);

				dwY += m_dwSpaceHeight;
			}
		}
	}
}

//=========================================================================
// Map our 'new' directly to LocalAlloc
//=========================================================================

static void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//=========================================================================
// Map our 'delete' directly to LocalFree   
//=========================================================================

static VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\common\d3dfile.h ===
//-----------------------------------------------------------------------------
// File: D3DFile.h
//
// Desc: Support code for loading DirectX .X files.
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef D3DFILE_H
#define D3DFILE_H
#define STRICT
#include <d3d8.h>
#include <d3dx8.h>




//-----------------------------------------------------------------------------
// Name: class CD3DMesh
// Desc: Class for loading and rendering file-based meshes
//-----------------------------------------------------------------------------
class CD3DMesh
{
public:
	CHAR                m_strName[512];

    LPD3DXMESH          m_pSysMemMesh;    // SysSem mesh, lives through resize
    LPD3DXMESH          m_pLocalMesh;     // Local mesh, rebuilt on resize
    
    DWORD               m_dwNumMaterials; // Materials for the mesh
    D3DMATERIAL8*       m_pMaterials;
    LPDIRECT3DTEXTURE8* m_pTextures;
	BOOL                m_bUseMaterials;

public:
	// Rendering
    void Render( LPDIRECT3DDEVICE8 pd3dDevice, 
		            BOOL bDrawOpaqueSubsets = TRUE,
		            BOOL bDrawAlphaSubsets = TRUE );

	// Mesh access
    LPD3DXMESH GetSysMemMesh() { return m_pSysMemMesh; }
    LPD3DXMESH GetLocalMesh()  { return m_pLocalMesh; }

	// Rendering options
	VOID    UseMeshMaterials( BOOL bFlag ) { m_bUseMaterials = bFlag; }
	void SetFVF( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwFVF );

	// Initializing
    void RestoreDeviceObjects( LPDIRECT3DDEVICE8 pd3dDevice );
    void InvalidateDeviceObjects();

	// Creation/destruction
	void Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename );
	void Create( LPDIRECT3DDEVICE8 pd3dDevice, LPDIRECTXFILEDATA pFileData );
	void Destroy();

    CD3DMesh( CHAR* strName = "CD3DFile_Mesh" );
    virtual ~CD3DMesh();
};




//-----------------------------------------------------------------------------
// Name: class CD3DFrame
// Desc: Class for loading and rendering file-based meshes
//-----------------------------------------------------------------------------
class CD3DFrame
{
public:
	CHAR       m_strName[512];
	D3DXMATRIX m_mat;
	CD3DMesh*  m_pMesh;
	CHAR       m_strMeshName[512];

	CD3DFrame* m_pNext;
	CD3DFrame* m_pChild;

public:
	// Matrix access
    VOID        SetMatrix( D3DXMATRIX* pmat ) { m_mat = *pmat; }
    D3DXMATRIX* GetMatrix()                   { return &m_mat; }

	CD3DMesh*   FindMesh( CHAR* strMeshName );
	CD3DFrame*  FindFrame( CHAR* strFrameName );
    BOOL        EnumMeshes( BOOL (*EnumMeshCB)(CD3DMesh*,VOID*), 
		                    VOID* pContext );

	void Destroy();
    void RestoreDeviceObjects( LPDIRECT3DDEVICE8 pd3dDevice );
    void InvalidateDeviceObjects();
    void Render( LPDIRECT3DDEVICE8 pd3dDevice, 
		            BOOL bDrawOpaqueSubsets = TRUE,
		            BOOL bDrawAlphaSubsets = TRUE );
	
	CD3DFrame( CHAR* strName = "CD3DFile_Frame" );
	virtual ~CD3DFrame();
};




//-----------------------------------------------------------------------------
// Name: class CD3DFile
// Desc: Class for loading and rendering file-based meshes
//-----------------------------------------------------------------------------
class CD3DFile : public CD3DFrame
{
	void LoadMesh( LPDIRECT3DDEVICE8 pd3dDevice, LPDIRECTXFILEDATA pFileData, 
					  CD3DFrame* pParentFrame );
	void LoadFrame( LPDIRECT3DDEVICE8 pd3dDevice, LPDIRECTXFILEDATA pFileData, 
		               CD3DFrame* pParentFrame );
public:
	void Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename );
	void Render( LPDIRECT3DDEVICE8 pd3dDevice );

	CD3DFile() : CD3DFrame( "CD3DFile_Root" ) {}
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\common\d3dfile.cpp ===
//-----------------------------------------------------------------------------
// File: D3DFile.cpp
//
// Desc: Support code for loading DirectX .X files.
//
// Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#define STRICT

#include <stdio.h>
#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#include <d3dx8core.h>
#endif

#include <rmxfguid.h>
#include <rmxftmpl.h>

#include <dxfile.h>
#include "D3DFile.h"
#include "DXUtil.h"

//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
CD3DMesh::CD3DMesh( CHAR* strName )
{
    strcpy( m_strName, strName );
    m_pSysMemMesh        = NULL;
    m_pLocalMesh         = NULL;
    m_dwNumMaterials     = 0L;
    m_pMaterials         = NULL;
    m_pTextures          = NULL;
    m_bUseMaterials      = TRUE;
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
CD3DMesh::~CD3DMesh()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
void CD3DMesh::Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename )
{
    CHAR        strPath[MAX_PATH];

    LPD3DXBUFFER pMtrlBuffer = NULL;

    // Find the path for the file
	DXUtil_FindMediaFile( strPath, strFilename );

    // Load the mesh

    CheckHR( D3DXLoadMeshFromX(strPath, D3DXMESH_SYSTEMMEM, 
                               pd3dDevice, NULL, &pMtrlBuffer, 
                               &m_dwNumMaterials, &m_pSysMemMesh ) );

    // Get material info for the mesh
    // Get the array of materials out of the buffer
    if( pMtrlBuffer && m_dwNumMaterials > 0 )
    {
        // Allocate memory for the materials and textures
        D3DXMATERIAL* d3dxMtrls = (D3DXMATERIAL*)pMtrlBuffer->GetBufferPointer();
        m_pMaterials = new D3DMATERIAL8[m_dwNumMaterials];
        m_pTextures  = new LPDIRECT3DTEXTURE8[m_dwNumMaterials];

        // Copy each material and create it's texture
        for( DWORD i=0; i<m_dwNumMaterials; i++ )
        {
			// Copy the material
            m_pMaterials[i]         = d3dxMtrls[i].MatD3D;
            m_pMaterials[i].Ambient = m_pMaterials[i].Diffuse;
			m_pTextures[i]          = NULL;

            // Create a texture
            if( d3dxMtrls[i].pTextureFilename )
            {
                CHAR strTexture[MAX_PATH];

				DXUtil_FindMediaFile( strTexture, d3dxMtrls[i].pTextureFilename );

                if( FAILED( D3DXCreateTextureFromFileA(pd3dDevice, 
													   strTexture, 
					                                   &m_pTextures[i] ) ) )
					m_pTextures[i] = NULL;
            }
        }
    }

    SAFE_RELEASE( pMtrlBuffer );
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
void CD3DMesh::Create( LPDIRECT3DDEVICE8 pd3dDevice,
                          LPDIRECTXFILEDATA pFileData )
{
    LPD3DXBUFFER pMtrlBuffer = NULL;

    // Load the mesh from the DXFILEDATA object
    CheckHR( D3DXLoadMeshFromXof( pFileData, D3DXMESH_SYSTEMMEM, pd3dDevice,
                              NULL, &pMtrlBuffer, &m_dwNumMaterials,
                              &m_pSysMemMesh ));

    // Get material info for the mesh
    // Get the array of materials out of the buffer
    if( pMtrlBuffer && m_dwNumMaterials > 0 )
    {
        // Allocate memory for the materials and textures
        D3DXMATERIAL* d3dxMtrls = (D3DXMATERIAL*)pMtrlBuffer->GetBufferPointer();
        m_pMaterials = new D3DMATERIAL8[m_dwNumMaterials];
        m_pTextures  = new LPDIRECT3DTEXTURE8[m_dwNumMaterials];

        // Copy each material and create it's texture
        for( DWORD i=0; i<m_dwNumMaterials; i++ )
        {
			// Copy the material
            m_pMaterials[i]         = d3dxMtrls[i].MatD3D;
            m_pMaterials[i].Ambient = m_pMaterials[i].Diffuse;
			m_pTextures[i]          = NULL;

            // Create a texture
            if( d3dxMtrls[i].pTextureFilename )
            {
                CHAR strTexture[MAX_PATH];

				DXUtil_FindMediaFile( strTexture, d3dxMtrls[i].pTextureFilename );

                if( FAILED( D3DXCreateTextureFromFileA(pd3dDevice, strTexture, 
					                                   &m_pTextures[i] ) ) )
					m_pTextures[i] = NULL;
            }
        }
    }

    SAFE_RELEASE( pMtrlBuffer );
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
void CD3DMesh::SetFVF( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwFVF )
{
    LPD3DXMESH pTempSysMemMesh = NULL;
    LPD3DXMESH pTempLocalMesh  = NULL;

    if( m_pSysMemMesh )
    {
        CheckHR( m_pSysMemMesh->CloneMeshFVF( D3DXMESH_SYSTEMMEM, dwFVF,
                                                 pd3dDevice, &pTempSysMemMesh ) );

    }
    if( m_pLocalMesh )
    {
        CheckHR( m_pLocalMesh->CloneMeshFVF( 0L, dwFVF, pd3dDevice, &pTempLocalMesh ) );
    }

    SAFE_RELEASE( m_pSysMemMesh );
    SAFE_RELEASE( m_pLocalMesh );

    if( pTempSysMemMesh ) m_pSysMemMesh = pTempSysMemMesh;
    if( pTempLocalMesh )  m_pLocalMesh  = pTempLocalMesh;

    // Compute normals in case the meshes have them
    if( m_pSysMemMesh )
        D3DXComputeNormals( m_pSysMemMesh );
    if( m_pLocalMesh )
        D3DXComputeNormals( m_pLocalMesh );
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
void CD3DMesh::RestoreDeviceObjects( LPDIRECT3DDEVICE8 pd3dDevice )
{
    // Make a local memory version of the mesh. Note: because we are passing in
    // no flags, the default behavior is to clone into local memory.
    CheckHR( m_pSysMemMesh->CloneMeshFVF( 0L, m_pSysMemMesh->GetFVF(),
                                             pd3dDevice, &m_pLocalMesh ) );
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
void CD3DMesh::InvalidateDeviceObjects()
{
    SAFE_RELEASE( m_pLocalMesh );
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
void CD3DMesh::Destroy()
{
    for( UINT i=0; i<m_dwNumMaterials; i++ )
        SAFE_RELEASE( m_pTextures[i] );
    SAFE_DELETE_ARRAY( m_pTextures );
    SAFE_DELETE_ARRAY( m_pMaterials );

    SAFE_RELEASE( m_pSysMemMesh );

    m_dwNumMaterials = 0L;
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
void CD3DMesh::Render( LPDIRECT3DDEVICE8 pd3dDevice, BOOL bDrawOpaqueSubsets,
                          BOOL bDrawAlphaSubsets )
{
    // Frist, draw the subsets without alpha
    if( bDrawOpaqueSubsets )
    {
        for( DWORD i=0; i<m_dwNumMaterials; i++ )
        {
            if( m_bUseMaterials )
            {
                if( m_pMaterials[i].Diffuse.a < 1.0f )
                    continue;
                CheckHR( pd3dDevice->SetMaterial( &m_pMaterials[i] ));
                CheckHR( pd3dDevice->SetTexture( 0, m_pTextures[i] ));
            }
            CheckHR( m_pLocalMesh->DrawSubset( i ));
        }
    }

    // Then, draw the subsets with alpha
    if( bDrawAlphaSubsets && m_bUseMaterials )
    {
        for( DWORD i=0; i<m_dwNumMaterials; i++ )
        {
            if( m_pMaterials[i].Diffuse.a == 1.0f )
                continue;

            // Set the material and texture
            CheckHR( pd3dDevice->SetMaterial( &m_pMaterials[i] ));
            CheckHR( pd3dDevice->SetTexture( 0, m_pTextures[i] ));
            CheckHR( m_pLocalMesh->DrawSubset( i ));
        }
    }
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
CD3DFrame::CD3DFrame( CHAR* strName )
{
    strcpy( m_strName, strName );
    D3DXMatrixIdentity( &m_mat );
    m_pMesh  = NULL;

    m_pChild = NULL;
    m_pNext  = NULL;
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
CD3DFrame::~CD3DFrame()
{
    SAFE_DELETE( m_pChild );
    SAFE_DELETE( m_pNext );
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
BOOL CD3DFrame::EnumMeshes( BOOL (*EnumMeshCB)(CD3DMesh*,VOID*),
                            VOID* pContext )
{
    if( m_pMesh )
        EnumMeshCB( m_pMesh, pContext );
    if( m_pChild )
        m_pChild->EnumMeshes( EnumMeshCB, pContext );
    if( m_pNext )
        m_pNext->EnumMeshes( EnumMeshCB, pContext );

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
CD3DMesh* CD3DFrame::FindMesh( CHAR* strMeshName )
{
    CD3DMesh* pMesh;

    if( m_pMesh )
        if( !_strcmpi( m_pMesh->m_strName, strMeshName ) )
            return m_pMesh;

    if( m_pChild )
        if( NULL != ( pMesh = m_pChild->FindMesh( strMeshName ) ) )
            return pMesh;

    if( m_pNext )
        if( NULL != ( pMesh = m_pNext->FindMesh( strMeshName ) ) )
            return pMesh;

    return NULL;
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
CD3DFrame* CD3DFrame::FindFrame( CHAR* strFrameName )
{
    CD3DFrame* pFrame;

    if( !_strcmpi( m_strName, strFrameName ) )
        return this;

    if( m_pChild )
        if( NULL != ( pFrame = m_pChild->FindFrame( strFrameName ) ) )
            return pFrame;

    if( m_pNext )
        if( NULL != ( pFrame = m_pNext->FindFrame( strFrameName ) ) )
            return pFrame;

    return NULL;
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
void CD3DFrame::Destroy()
{
    if( m_pMesh )  m_pMesh->Destroy();
    if( m_pChild ) m_pChild->Destroy();
    if( m_pNext )  m_pNext->Destroy();

    SAFE_DELETE( m_pMesh );
    SAFE_DELETE( m_pNext );
    SAFE_DELETE( m_pChild );
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
void CD3DFrame::RestoreDeviceObjects( LPDIRECT3DDEVICE8 pd3dDevice )
{
    if( m_pMesh )  m_pMesh->RestoreDeviceObjects( pd3dDevice );
    if( m_pChild ) m_pChild->RestoreDeviceObjects( pd3dDevice );
    if( m_pNext )  m_pNext->RestoreDeviceObjects( pd3dDevice );
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
void CD3DFrame::InvalidateDeviceObjects()
{
    if( m_pMesh )  m_pMesh->InvalidateDeviceObjects();
    if( m_pChild ) m_pChild->InvalidateDeviceObjects();
    if( m_pNext )  m_pNext->InvalidateDeviceObjects();
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
void CD3DFrame::Render( LPDIRECT3DDEVICE8 pd3dDevice, BOOL bDrawOpaqueSubsets,
                           BOOL bDrawAlphaSubsets )
{
    D3DXMATRIX matSavedWorld, matWorld;
    CheckHR( pd3dDevice->GetTransform( D3DTS_WORLD, &matSavedWorld ));
    D3DXMatrixMultiply( &matWorld, &m_mat, &matSavedWorld );
    CheckHR( pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld ));

    if( m_pMesh )
        m_pMesh->Render( pd3dDevice, bDrawOpaqueSubsets, bDrawAlphaSubsets );

    if( m_pChild )
        m_pChild->Render( pd3dDevice, bDrawOpaqueSubsets, bDrawAlphaSubsets );

    CheckHR( pd3dDevice->SetTransform( D3DTS_WORLD, &matSavedWorld ));

    if( m_pNext )
        m_pNext->Render( pd3dDevice, bDrawOpaqueSubsets, bDrawAlphaSubsets );
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
void CD3DFile::LoadFrame( LPDIRECT3DDEVICE8 pd3dDevice,
                             LPDIRECTXFILEDATA pFileData,
                             CD3DFrame* pParentFrame )
{
    LPDIRECTXFILEDATA   pChildData = NULL;
    LPDIRECTXFILEOBJECT pChildObj = NULL;
    const GUID* pGUID;
    DWORD       cbSize;
    CD3DFrame*  pCurrentFrame;

    // Get the type of the object
    CheckHR( pFileData->GetType( &pGUID ) );

    if( *pGUID == TID_D3DRMMesh )
    {
        LoadMesh( pd3dDevice, pFileData, pParentFrame );
    }
    if( *pGUID == TID_D3DRMFrameTransformMatrix )
    {
        D3DXMATRIX* pmatMatrix;
        CheckHR( pFileData->GetData( NULL, &cbSize, (VOID**)&pmatMatrix ));

        // Update the parents matrix with the new one
        pParentFrame->SetMatrix( pmatMatrix );
    }
    if( *pGUID == TID_D3DRMFrame )
    {
        // Get the frame name
        CHAR strName[MAX_PATH] = "";
        DWORD dwNameLength;
        CheckHR( pFileData->GetName( NULL, &dwNameLength ));
        if( dwNameLength > 0 )
		{
            CheckHR( pFileData->GetName( strName, &dwNameLength ));
		}

        // Create the frame
        pCurrentFrame = new CD3DFrame( strName );

        pCurrentFrame->m_pNext = pParentFrame->m_pChild;
        pParentFrame->m_pChild = pCurrentFrame;

        // Enumerate child objects
        while( SUCCEEDED( pFileData->GetNextObject( &pChildObj ) ) )
        {
            // Query the child for it's FileData
            CheckHR( pChildObj->QueryInterface( IID_IDirectXFileData,
                                            (VOID**)&pChildData ));

            LoadFrame( pd3dDevice, pChildData, pCurrentFrame );
            pChildData->Release();

            pChildObj->Release();
        }
    }
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
void CD3DFile::LoadMesh( LPDIRECT3DDEVICE8 pd3dDevice,
                            LPDIRECTXFILEDATA pFileData,
                            CD3DFrame* pParentFrame )
{
    // Currently only allowing one mesh per frame
    if( pParentFrame->m_pMesh )
	{
		DisplayError(L"FATAL: We only allow one mesh per frame", 0);
	}

    // Get the mesh name
    CHAR strName[MAX_PATH] = "";
    DWORD dwNameLength;
    pFileData->GetName( NULL, &dwNameLength );
    if( dwNameLength > 0 )
	{
        CheckHR( pFileData->GetName( strName, &dwNameLength ));
	}

    // Create the mesh
    pParentFrame->m_pMesh = new CD3DMesh( strName );
    pParentFrame->m_pMesh->Create( pd3dDevice, pFileData );
}

//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
void CD3DFile::Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename )
{
    LPDIRECTXFILE           pDXFile   = NULL;
    LPDIRECTXFILEENUMOBJECT pEnumObj  = NULL;
    LPDIRECTXFILEDATA       pFileData = NULL;

    // Create a x file object
    CheckHR( DirectXFileCreate( &pDXFile ) );

    // Register templates for d3drm and patch extensions.
    CheckHR( pDXFile->RegisterTemplates( (VOID*)D3DRM_XTEMPLATES,
                                                 D3DRM_XTEMPLATE_BYTES ) );

    CHAR strPath[MAX_PATH];

	DXUtil_FindMediaFile( strPath, strFilename );

    // Create enum object
    CheckHR( pDXFile->CreateEnumObject( strPath, DXFILELOAD_FROMFILE, 
                                    &pEnumObj ));

    // Enumerate top level objects (which are always frames)
    while( SUCCEEDED( pEnumObj->GetNextDataObject( &pFileData ) ) )
    {
        LoadFrame( pd3dDevice, pFileData, this );
        pFileData->Release();
    }

    SAFE_RELEASE( pFileData );
    SAFE_RELEASE( pEnumObj );
    SAFE_RELEASE( pDXFile );
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
void CD3DFile::Render( LPDIRECT3DDEVICE8 pd3dDevice )
{
    // Setup the world transformation
    D3DXMATRIX matSavedWorld, matWorld;
    CheckHR( pd3dDevice->GetTransform( D3DTS_WORLD, &matSavedWorld ));
    D3DXMatrixMultiply( &matWorld, &matSavedWorld, &m_mat );
    CheckHR( pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld ));

    // Render opaque subsets in the meshes
    if( m_pChild )
        m_pChild->Render( pd3dDevice, TRUE, FALSE );

    // Enable alpha blending
    CheckHR( pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ));
    CheckHR( pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA ));
    CheckHR( pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ));

    // Render alpha subsets in the meshes
    if( m_pChild )
        m_pChild->Render( pd3dDevice, FALSE, TRUE );

    // Restore state
    CheckHR( pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ));
    CheckHR( pd3dDevice->SetTransform( D3DTS_WORLD, &matSavedWorld ));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\common\d3dutil.cpp ===
//-----------------------------------------------------------------------------
// File: D3DUtil.cpp
//
// Desc: Shortcut macros and functions for using DX objects
//
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------

#define STRICT

#include <stdio.h>
#ifdef XBOX
#include <xtl.h>
#include <xgraphics.h>
#else
#include <windows.h>
#endif

#include "D3DUtil.h"
#include "DXUtil.h"

//-----------------------------------------------------------------------------
// Name: D3DUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID D3DUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r, FLOAT g, FLOAT b,
                           FLOAT a )
{
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = r;
    mtrl.Diffuse.g = mtrl.Ambient.g = g;
    mtrl.Diffuse.b = mtrl.Ambient.b = b;
    mtrl.Diffuse.a = mtrl.Ambient.a = a;
}




//-----------------------------------------------------------------------------
// Name: D3DUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID D3DUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                        FLOAT x, FLOAT y, FLOAT z )
{
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type        = ltType;
    light.Diffuse.r   = 1.0f;
    light.Diffuse.g   = 1.0f;
    light.Diffuse.b   = 1.0f;
    light.Position.x   = light.Direction.x = x;
    light.Position.y   = light.Direction.y = y;
    light.Position.z   = light.Direction.z = z;
    light.Range        = 1000.0f;
}




//-----------------------------------------------------------------------------
// Name: D3DUtil_CreateTexture()
// Desc: Helper function to create a texture. It checks the root path first,
//       then tries the DXSDK media path (as specified in the system registry).
//-----------------------------------------------------------------------------
HRESULT D3DUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strTexture,
                               LPDIRECT3DTEXTURE8* ppTexture, D3DFORMAT d3dFormat )
{
	// Get the path to the texture
    CHAR strPath[512];
	DXUtil_FindMediaFile( strPath, strTexture );

	// Create the texture using D3DX
    return D3DXCreateTextureFromFileExA(pd3dDevice, strPath, 
		        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, d3dFormat, 
				D3DPOOL_MANAGED, D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 
			    D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 0, NULL, NULL, ppTexture );
}


#if 0

//-----------------------------------------------------------------------------
// Name: D3DUtil_SetColorKey()
// Desc: Changes all texels matching the colorkey to transparent, black.
//-----------------------------------------------------------------------------
HRESULT D3DUtil_SetColorKey( LPDIRECT3DTEXTURE8 pTexture, DWORD dwColorKey )
{
    // Get colorkey's red, green, and blue components
    DWORD r = ((dwColorKey&0x00ff0000)>>16);
    DWORD g = ((dwColorKey&0x0000ff00)>>8);
    DWORD b = ((dwColorKey&0x000000ff)>>0);

    // Put the colorkey in the texture's native format
    D3DSURFACE_DESC d3dsd;    
    pTexture->GetLevelDesc( 0, &d3dsd );

    if( d3dsd.Format == D3DFMT_A4R4G4B4 )
        dwColorKey = 0xf000 + ((r>>4)<<8) + ((g>>4)<<4) + (b>>4);
    else if( d3dsd.Format == D3DFMT_A1R5G5B5 )
        dwColorKey = 0x8000 + ((r>>3)<<10) + ((g>>3)<<5) + (b>>3);
    else if( d3dsd.Format != D3DFMT_A8R8G8B8 )
        return E_FAIL;
    // Lock the texture
    D3DLOCKED_RECT  d3dlr;
#ifdef XBOX
    if( FAILED( pTexture->LockRect( 0, &d3dlr, 0, D3DLOCK_RAWDATA ) ) )
        return E_FAIL;

    PVOID pBits = Swizzler_GetUnswizzledBits(&d3dlr, &d3dsd);
    if (pBits == NULL)
    {
        pTexture->UnlockRect(0);
        return E_FAIL;
    }
#else
    if( FAILED( pTexture->LockRect( 0, &d3dlr, 0, 0 ) ) )
        return E_FAIL;
#endif

    // Scan through each pixel, looking for the colorkey to replace
    for( DWORD y=0; y<d3dsd.Height; y++ )
    {
        for( DWORD x=0; x<d3dsd.Width; x++ )
        {
            if( d3dsd.Format==D3DFMT_A8R8G8B8 )
            {
                // Handle 32-bit formats
#ifdef XBOX
                if( ((DWORD*)pBits)[d3dsd.Width*y+x] == dwColorKey )
                    ((DWORD*)pBits)[d3dsd.Width*y+x] = 0x00000000;
#else
                if( ((DWORD*)d3dlr.pBits)[d3dsd.Width*y+x] == dwColorKey )
                    ((DWORD*)d3dlr.pBits)[d3dsd.Width*y+x] = 0x00000000;
#endif
            }
            else
            {
                // Handle 16-bit formats
#ifdef XBOX
                if( ((WORD*)pBits)[d3dsd.Width*y+x] == dwColorKey )
                    ((WORD*)pBits)[d3dsd.Width*y+x] = 0x0000;
#else
                if( ((WORD*)d3dlr.pBits)[d3dsd.Width*y+x] == dwColorKey )
                    ((WORD*)d3dlr.pBits)[d3dsd.Width*y+x] = 0x0000;
#endif
            }
        }
    }

#ifdef XBOX
    Swizzler_SwizzleFromBits(pBits, &d3dlr, &d3dsd);
#endif

    // Unlock the texture and return OK.
    pTexture->UnlockRect(0);
    return S_OK;
}

#endif 0



//-----------------------------------------------------------------------------
// Name: D3DUtil_CreateVertexShader()
// Desc: Assembles and creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT D3DUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
								    WCHAR* strFilename, DWORD* pdwVertexDecl,
									DWORD* pdwVertexShader )
{
#if 1
    return E_NOTIMPL;
#else

    LPD3DXBUFFER pCode;
    WCHAR        strPath[512];
    HRESULT      hr;

	// Get the path to the vertex shader file
	DXUtil_FindMediaFile( strPath, strFilename );

	// Assemble the vertex shader file
    if( FAILED( hr = D3DXAssembleVertexShaderFromFile( strPath, &pCode, NULL ) ) )
		return hr;

	// Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( pdwVertexDecl, 
		                                 (DWORD*)pCode->GetBufferPointer(),
                                         pdwVertexShader, 0 );
    pCode->Release();
	return hr;
#endif
}




//-----------------------------------------------------------------------------
// Name: D3DUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX D3DUtil_GetCubeMapViewMatrix( DWORD dwFace )
{
    D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_X:
            vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
    }

    // Set the view transform for this cubemap surface
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookDir, &vUpDir );
    return matView;
}


#if 0

//-----------------------------------------------------------------------------
// Name: D3DUtil_GetRotationFromCursor()
// Desc: Returns a quaternion for the rotation implied by the window's cursor
//       position.
//-----------------------------------------------------------------------------
D3DXQUATERNION D3DUtil_GetRotationFromCursor( HWND hWnd,
                                              FLOAT fTrackBallRadius )
{
    POINT pt;
    RECT  rc;
    GetCursorPos( &pt );
    GetClientRect( hWnd, &rc );
    ScreenToClient( hWnd, &pt );
    FLOAT sx = ( ( ( 2.0f * pt.x ) / (rc.right-rc.left) ) - 1 );
    FLOAT sy = ( ( ( 2.0f * pt.y ) / (rc.bottom-rc.top) ) - 1 );
    FLOAT sz;

    if( sx == 0.0f && sy == 0.0f )
        return D3DXQUATERNION( 0.0f, 0.0f, 0.0f, 1.0f );

    FLOAT d1 = 0.0f;
    FLOAT d2 = sqrtf( sx*sx + sy*sy );

    if( d2 < fTrackBallRadius * 0.70710678118654752440 ) // Inside sphere
        sz = sqrtf( fTrackBallRadius*fTrackBallRadius - d2*d2 );
    else                                                 // On hyperbola
        sz = (fTrackBallRadius*fTrackBallRadius) / (2.0f*d2);

    // Get two points on trackball's sphere
    D3DXVECTOR3 p1( sx, sy, sz );
    D3DXVECTOR3 p2( 0.0f, 0.0f, fTrackBallRadius );

    // Get axis of rotation, which is cross product of p1 and p2
    D3DXVECTOR3 vAxis;
    D3DXVec3Cross( &vAxis, &p1, &p2);

    // Calculate angle for the rotation about that axis
    FLOAT t = D3DXVec3Length( &(p2-p1) ) / ( 2.0f*fTrackBallRadius );
    if( t > +1.0f) t = +1.0f;
    if( t < -1.0f) t = -1.0f;
    FLOAT fAngle = 2.0f * asinf( t );

    // Convert axis to Quaternion
    D3DXQUATERNION quat;
    D3DXQuaternionRotationAxis( &quat, &vAxis, fAngle );
    return quat;
}

#endif 0


//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
CD3DArcBall::CD3DArcBall()
{
    D3DXQuaternionIdentity( &m_qDown );
    D3DXQuaternionIdentity( &m_qNow );
    D3DXMatrixIdentity( &m_matRotation );
    D3DXMatrixIdentity( &m_matRotationDelta );
    D3DXMatrixIdentity( &m_matTranslation );
    D3DXMatrixIdentity( &m_matTranslationDelta );
    m_bDrag = FALSE;
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
VOID CD3DArcBall::SetWindow( int iWidth, int iHeight, float fRadius )
{
    // Set ArcBall info
    m_iWidth  = iWidth;
    m_iHeight = iHeight;
    m_fRadius = fRadius;
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
D3DXVECTOR3 CD3DArcBall::ScreenToVector( int sx, int sy )
{
    // Scale to screen
    FLOAT x   =  (sx - m_iWidth/2)  / (m_fRadius*m_iWidth/2);
    FLOAT y   = -(sy - m_iHeight/2) / (m_fRadius*m_iHeight/2);
    FLOAT z   = 0.0f;
    FLOAT mag = x*x + y*y;

    if( mag > 1.0f )
    {
        FLOAT scale = 1.0f/sqrtf(mag);
        x *= scale;
        y *= scale;
    }
    else
        z = sqrtf( 1.0f - mag );

    // Return vector
    return D3DXVECTOR3( x, y, z );
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
VOID CD3DArcBall::SetRadius( FLOAT fRadius )
{
    m_fRadius2 = fRadius;
}

#if 0

//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
LRESULT CD3DArcBall::HandleMouseMessages( HWND hWnd, UINT uMsg, WPARAM wParam,
                                          LPARAM lParam )
{
    static int         iCurMouseX;      // Saved mouse position
    static int         iCurMouseY;
    static D3DXVECTOR3 m_vDown;         // Button down quaternion
    static D3DXVECTOR3 m_vCur;          // Current quaternion

    // Current mouse position
    int iMouseX = LOWORD(lParam);
    int iMouseY = HIWORD(lParam);

    switch( uMsg )
    {
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
            // Store off the position of the cursor when the button is pressed
            iCurMouseX = iMouseX;
            iCurMouseY = iMouseY;
            return TRUE;

        case WM_LBUTTONDOWN:
            // Start drag mode
            m_bDrag = TRUE;
            m_vDown = ScreenToVector( iMouseX, iMouseY );
            return TRUE;

        case WM_LBUTTONUP:
            // End drag mode
            m_bDrag = FALSE;
            m_qDown = m_qNow;
            return TRUE;

        case WM_MOUSEMOVE:
            // Drag object
            if( MK_LBUTTON&wParam )
            {
                if( m_bDrag )
                {
                    D3DXVECTOR3 vPart;
                    D3DXVECTOR3 vCur = ScreenToVector( iMouseX, iMouseY );
                    D3DXVec3Cross( &vPart, &m_vDown, &vCur );
                    m_qNow = m_qDown * D3DXQUATERNION( vPart.x, vPart.y, vPart.z,
                                                       D3DXVec3Dot( &m_vDown, &vCur ) );
                }

                D3DXQUATERNION qConj;
                D3DXQuaternionConjugate( &qConj, &m_qNow );

                D3DXMatrixRotationQuaternion( &m_matRotationDelta, &qConj );
                D3DXMatrixTranspose( &m_matRotationDelta, &m_matRotationDelta );
                D3DXMatrixMultiply( &m_matRotation, &m_matRotation, &m_matRotationDelta );

                D3DXQuaternionIdentity( &m_qDown );
                D3DXQuaternionIdentity( &m_qNow );
                m_vDown = ScreenToVector( iMouseX, iMouseY );
                m_bDrag = TRUE;
            }
            else if( (MK_RBUTTON&wParam) || (MK_MBUTTON&wParam) )
            {
                // Normalize based on size of window and bounding sphere radius
                FLOAT fDeltaX = ( iCurMouseX-iMouseX ) * m_fRadius2 / m_iWidth;
                FLOAT fDeltaY = ( iCurMouseY-iMouseY ) * m_fRadius2 / m_iHeight;

                if( wParam & MK_RBUTTON )
                {
                    D3DXMatrixTranslation( &m_matTranslationDelta, -2*fDeltaX, 2*fDeltaY, 0.0f );
                    D3DXMatrixMultiply( &m_matTranslation, &m_matTranslation, &m_matTranslationDelta );
                }
                else  // wParam & MK_MBUTTON
                {
                    D3DXMatrixTranslation( &m_matTranslationDelta, 0.0f, 0.0f, 5*fDeltaY );
                    D3DXMatrixMultiply( &m_matTranslation, &m_matTranslation, &m_matTranslationDelta );
                }

                // Store mouse coordinate
                iCurMouseX = iMouseX;
                iCurMouseY = iMouseY;
            }
            return TRUE;
    }

    return FALSE;
}

#endif 0


//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
CD3DCamera::CD3DCamera()
{
    // Set attributes for the view matrix
    SetViewParams( D3DXVECTOR3(0.0f,0.0f,0.0f), D3DXVECTOR3(0.0f,0.0f,1.0f),
                   D3DXVECTOR3(0.0f,1.0f,0.0f) );

    // Set attributes for the projection matrix
    SetProjParams( D3DX_PI/4, 1.0f, 1.0f, 1000.0f );
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
VOID CD3DCamera::SetViewParams( D3DXVECTOR3 &vEyePt, D3DXVECTOR3& vLookatPt,
                                D3DXVECTOR3& vUpVec )
{
    // Set attributes for the view matrix
    m_vEyePt    = vEyePt;
    m_vLookatPt = vLookatPt;
    m_vUpVec    = vUpVec;
    D3DXVec3Normalize( &m_vView, &(m_vLookatPt - m_vEyePt) );
    D3DXVec3Cross( &m_vCross, &m_vView, &m_vUpVec );

    D3DXMatrixLookAtLH( &m_matView, &m_vEyePt, &m_vLookatPt, &m_vUpVec );
    D3DXMatrixInverse( &m_matBillboard, NULL, &m_matView );
    m_matBillboard._41 = 0.0f;
    m_matBillboard._42 = 0.0f;
    m_matBillboard._43 = 0.0f;
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
VOID CD3DCamera::SetProjParams( FLOAT fFOV, FLOAT fAspect, FLOAT fNearPlane,
                                FLOAT fFarPlane )
{
    // Set attributes for the projection matrix
    m_fFOV        = fFOV;
    m_fAspect     = fAspect;
    m_fNearPlane  = fNearPlane;
    m_fFarPlane   = fFarPlane;

    D3DXMatrixPerspectiveFovLH( &m_matProj, fFOV, fAspect, fNearPlane, fFarPlane );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\common\sources.inc ===
TARGETNAME=d3dtestlib
TARGETPATH=obj
TARGETTYPE=LIBRARY

SYNCHRONIZE_BLOCK=1

SOURCES= \
    d3dapp.cpp \
    d3dfile.cpp \
    d3dutil.cpp \
    dxutil.cpp \
    bitfont.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\common\dxutil.cpp ===
//-----------------------------------------------------------------------------
// File: DXUtil.cpp
//
// Desc: Shortcut macros and functions for using DX objects
//
//
// Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------

#define STRICT

#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#endif
#include <stdio.h> 
#include <stdarg.h>
#include <D3D8.h>
#include <d3dx8core.h>
#include "DXUtil.h"

FLOAT DXUtil_Timer::m_fSecsPerTick = 0.0f;
FLOAT DXUtil_Timer::m_fBaseTime    = 0.0f;
FLOAT DXUtil_Timer::m_fStopTime    = 0.0f;

//-----------------------------------------------------------------------------
// Helper to display error messages.  This just shoves them out through the
// debug console.
//-----------------------------------------------------------------------------

void DisplayError(const WCHAR *szCall, HRESULT hr)
{
    WCHAR szErr[512];
	unsigned cch;

	if (hr)
	{
		cch = _snwprintf(szErr, sizeof(szErr), L"FATAL: %s failed 0x%08lX: ", szCall, hr);

		D3DXGetErrorString(hr, &szErr[cch], sizeof(szErr));
	}
	else
	{
		wcscpy(szErr, szCall);
	}

    wcscat(szErr, L"\n");

    OutputDebugString(szErr);

    _asm int 3;
}

//-----------------------------------------------------------------------------
// Name: DXUtil_FindMediaFile()
// Desc: Returns a valid path to a DXSDK media file
//-----------------------------------------------------------------------------
void DXUtil_FindMediaFile( CHAR* strPath, CHAR* strFilename )
{
    HANDLE file;

    if ( NULL==strFilename || NULL==strPath )
	{
		DisplayError(L"FATAL: Bad arguments to DXUtil_FindMediaFile", 0);
	}

    // Check if the file exists in the current directory
    strcpy( strPath, strFilename );

    file = CreateFileA( strPath, GENERIC_READ, FILE_SHARE_READ, NULL,
                       OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE != file )
    {
        CloseHandle( file );
        return;
    }

    // Check if the file exists in the media directory
#ifdef PCBUILD
    sprintf( strPath, "c:\\Media\\%s", strFilename );
#else
    sprintf( strPath, "T:\\Media\\%s", strFilename );
#endif 

    file = CreateFileA(strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                       OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE != file )
    {
        CloseHandle( file );
		return;
    }

	DisplayError(L"FATAL: Unable to open a file.", 0);
}

#ifdef PCBUILD

extern "C" ULONG DebugPrint(const char *Format, ...)
{
    char sz[2048];

    va_list args;
    va_start(args, Format);

    _vsnprintf(sz, 2048, Format, args);
    OutputDebugStringA(sz);

    va_end(args);

    return 0;
}


#endif PCBUILD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\copyspeed\main.c ===
/*
 * Test different copy speeds
 */

#include <xtl.h>
#include <stdio.h>
#include <mmintrin.h>

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

#define CHECK_RESULTS 0
#define BLOCK_SIZE    (511)
#define ITERATIONS    100000

#define PAGE_SIZE 0x1000

/*
 * Helpers
 */

#if CHECK_RESULTS

    #define INIT(x)        Init(x)
    #define PREP(x)        Prep(x)
    #define VERIFY(x, y)   Verify(x, y)
    #define COPYSIZE(x)    (x)

#else            
    
    #define INIT(x)
    #define PREP(x)  
    #define VERIFY(x, y)
    #define COPYSIZE(x)    (BLOCK_SIZE)

#endif

void Init(
    DWORD *pArray
    )
{
    DWORD i;

    for (i = 0; i < BLOCK_SIZE / 4; i++)
    {
        pArray[i] = 0xFFFFFFFF - i;
    }

    pArray[i] = 0;
}

void Prep(
    DWORD *pArray
    )
{
    memset(pArray, 0, (BLOCK_SIZE + 1) * 4);
}

void Verify(
    DWORD *pArray,
    DWORD Size
    )
{
    DWORD i;

    for (i = 0; i < Size; i++)
    {
        if (pArray[i] != 0xFFFFFFFF - i)
        {
            _asm int 3;
        }
    }

    if (pArray[i] != 0)
    {
        _asm int 3;
    }
}

/*
 * Copy methods
 */

//----------------------------------------------------------------------------
// Uses SSE to copy chunks of memory around.
//
void FastDWORDCopy(
    void *pDest, 
    void *pSource, 
    unsigned Count
    )
{
    _asm
    {
        // int 3

        mov eax, pSource
        mov ebx, pDest

        mov ecx, Count   
        shr ecx, 4

        mov ecx, Count
        and ecx, 0xFFFFFFF0
        shr ecx, 4

        jz copy_16

    copy_64_loop:

        movq mm0, [eax]
        movq mm1, [eax + 8]
        movq mm2, [eax + 16]
        movq mm3, [eax + 24]
        movq mm4, [eax + 32]
        movq mm5, [eax + 40]
        movq mm6, [eax + 48]
        movq mm7, [eax + 56]
            
        movntq [ebx],      mm0
        movntq [ebx + 8],  mm1
        movntq [ebx + 16], mm2
        movntq [ebx + 24], mm3     
        movntq [ebx + 32], mm4
        movntq [ebx + 40], mm5
        movntq [ebx + 48], mm6
        movntq [ebx + 56], mm7     

        add eax, 0x40
        add ebx, 0x40

        dec ecx
        jnz copy_64_loop

    copy_16:

        mov ecx, Count
        and ecx, 0xC
        shr ecx, 2

        jz copy_4

    copy_16_loop:
    
        movq mm0, [eax]
        movq mm1, [eax + 8]

        movntq [ebx],      mm0
        movntq [ebx + 8],  mm1

        add eax, 0x10
        add ebx, 0x10

        dec ecx
        jnz copy_16_loop

    copy_4:

        mov ecx, Count
        and ecx, 0x03

        jz done

    copy_4_loop:

        mov edx, [eax]
        mov [ebx], edx
        
        add eax, 0x04
        add ebx, 0x04

        dec ecx
        jnz copy_4_loop

    done:
    }
}

/*
 * Test
 */

void __cdecl main()
{
    _int64 StartTime;
    _int64 StopTime;

    DWORD *pSource;
    DWORD *pDest;

    DWORD i, SourceOffset, DestinationOffset;

    pSource = (DWORD *)malloc((BLOCK_SIZE + 32) * 4);
    pDest   = (DWORD *)XPhysicalAlloc((BLOCK_SIZE + 32) * 4, 
                                      MAXULONG_PTR, 
                                      PAGE_SIZE,
                                      PAGE_READWRITE | PAGE_WRITECOMBINE);

    pSource = (DWORD *)(((DWORD)pSource + 15) & ~15);
    pDest   = (DWORD *)(((DWORD)pDest   + 15) & ~15);

    INIT(pSource);

    DbgPrint("\n");

    // memcpy

    for (DestinationOffset = 0; DestinationOffset <= 0; DestinationOffset += 2)
    {
        for (SourceOffset = 0; SourceOffset <= 0; SourceOffset += 2)
        {
            QueryPerformanceCounter((LARGE_INTEGER *)&StartTime);

            for (i = 0; i < ITERATIONS; i++)
            {
                PREP(pDest);

                memcpy((BYTE *)pDest + DestinationOffset, 
                       (BYTE *)pSource + SourceOffset, 
                       COPYSIZE(i) * 4);

                VERIFY(pDest, COPYSIZE(i));
            }

            QueryPerformanceCounter((LARGE_INTEGER *)&StopTime);

            DbgPrint("memcpy   [src: %02d  dst: %02d] - %d ticks\n", 
                     SourceOffset, 
                     DestinationOffset, 
                     (DWORD)(StopTime - StartTime));

            // SSE

            QueryPerformanceCounter((LARGE_INTEGER *)&StartTime);

            for (i = 0; i < ITERATIONS; i++)
            {
                PREP(pDest);

                FastDWORDCopy((BYTE *)pDest + DestinationOffset, 
                              (BYTE *)pSource + SourceOffset, 
                              COPYSIZE(i));

                VERIFY(pDest, COPYSIZE(i));
            }

            QueryPerformanceCounter((LARGE_INTEGER *)&StopTime);

            DbgPrint("fastcopy [src: %02d  dst: %02d] - %d ticks\n", 
                     SourceOffset,
                     DestinationOffset,
                     (DWORD)(StopTime - StartTime));
        }
    }

    // Spin forever.
    DbgPrint("\nDone\n");

    for (;;)
        Sleep(10);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\death\main.cpp ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Complete DX8 application to draw a screen space triangle.

Revision History:

    Derived from a DX8 sample.
--*/

#include <stddef.h>
#include <stdio.h>

extern "C"
{
    #include <ntos.h>
    #include <nturtl.h>
    #include <av.h>
};

#include <xtl.h>
#include <xgraphics.h>

IDirect3DDevice8*          g_pDev  = NULL;
BOOL                       g_Done;

#define PUSHBUFFERSIZE 32*1024*1024
#define SCRATCHSIZE 16*1024

bool InitD3D()
{
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    if (pD3D == NULL)
        return false;

    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount           = 1;
    d3dpp.Windowed                  = false;   // Must be false for Xbox.
    d3dpp.EnableAutoDepthStencil    = true;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;

    // Create the device.
    if (pD3D->CreateDevice
    (
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        NULL,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        &g_pDev
    ) != S_OK)
    {
        return false;
    }

    pD3D->Release();

    return true;
}

void __cdecl AllDone(DWORD Context)
{
    DbgPrint("...We survived!\n");
}

void StripedClear()
{
    D3DRECT rect;
    INT left;
    INT right;

    for (DWORD i = 0; i < 5; i++)
    {
        INT left = 0;

        while (left < 640)
        {
            rect.x1 = left;
            rect.x2 = min(640, left + 128);
            rect.y1 = 0;
            rect.y2 = 480;

            g_pDev->Clear(1, &rect, D3DCLEAR_TARGET | D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER, 0, 1.0, 0);

            left = rect.x2;
        }
    }
}

void Die2()
{
    D3DPushBuffer* pPushBuffer;
    DWORD offset;
    VOID* pScratch;
    BYTE* p;
    DWORD i;

    DbgPrint("Starting test...\n");

    pScratch = D3D_AllocContiguousMemory(SCRATCHSIZE, 0);

    g_pDev->CreatePushBuffer(PUSHBUFFERSIZE, FALSE, &pPushBuffer);
    g_pDev->BeginPushBuffer(pPushBuffer);
    do {
        StripedClear();
        g_pDev->GetPushBufferOffset(&offset);

    } while (offset < PUSHBUFFERSIZE - 1024);
    
    g_pDev->InsertCallback(D3DCALLBACK_READ, AllDone, 0);
    g_pDev->EndPushBuffer();

    g_pDev->RunPushBuffer(pPushBuffer, NULL);
    g_pDev->KickPushBuffer();

    while (TRUE)
        ;
}

void Die1()
{
    DWORD count = 0;
    while (TRUE)
    {
        StripedClear();
        g_pDev->InsertFence();
        if ((count % 100) == 0)
            DbgPrint("Count: %li\n", count);
        count++;
    }
}

void __cdecl main()
{
    InitD3D();

    Die2();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\dolphin\sources.inc ===
TARGETNAME=Dolphtst
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    dolphin.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\dolphin\dolphin.cpp ===
//-----------------------------------------------------------------------------
// File: Dolphin.cpp
//
// Desc: Sample of swimming dolphin
//
//       Note: This code uses the D3D Framework helper library.
//
// Copyright (c) 1998-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#define STRICT

#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <D3DX8.h>
#endif
#include <stdio.h>
#include "D3DApp.h"
#include "D3DFile.h"
#include "D3DUtil.h"
#include "DXUtil.h"

//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------

inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }

#define WATER_COLOR         0x00006688

//-----------------------------------------------------------------------------
// Name: struct MESHTOOL
// Desc: Convenient structure for accessing a mesh's vertices. Pass in a ptr to
//       a D3DXMESH object, and then the vertices can be accessed easily. The
//       destructor nicely cleans everything up.
//-----------------------------------------------------------------------------
struct MESHTOOL
{
    struct VERTEX { D3DXVECTOR3 p, n; FLOAT tu, tv; }; // Same as a Vertex

    LPDIRECT3DVERTEXBUFFER8 pVB;
    DWORD                   dwNumVertices;
    VERTEX*                 pVertices;

    MESHTOOL( LPD3DXMESH pMesh )
    {
        CheckHR(pMesh->GetVertexBuffer( &pVB ));
        CheckHR(pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ));
        dwNumVertices= pMesh->GetNumVertices();
    }

    ~MESHTOOL()
    {
        CheckHR(pVB->Unlock());
        CheckHR(pVB->Release());
    }
};

//-----------------------------------------------------------------------------
// Name: class CMyD3DApplication
// Desc: Main class to run this application. Most functionality is inherited
//       from the CD3DApplication base class.
//-----------------------------------------------------------------------------
class CMyD3DApplication : public CD3DApplication
{
    // The dolphin object
    CD3DFile* m_pDolphinGroupObject;
    CD3DFile* m_pDolphinObject;
    CD3DMesh* m_pDolphinMesh;
    CD3DMesh* m_pDolphinMesh01;
    CD3DMesh* m_pDolphinMesh02;
    CD3DMesh* m_pDolphinMesh03;

    // The seafloor object
    CD3DFile* m_pFloorObject;
    CD3DMesh* m_pSeaFloorMesh;

    // Textures for the water caustics
    LPDIRECT3DTEXTURE8 m_pCausticTextures[32];
    LPDIRECT3DTEXTURE8 m_pCurrentCausticTexture;

    // Function used to blend the dolphin meshes
    void BlendMeshes( FLOAT fWeight );

public:
    void InitDeviceObjects();
    void RestoreDeviceObjects();
    void InvalidateDeviceObjects();
    void DeleteDeviceObjects();
    void Render();
    void FrameMove();
    void FinalCleanup();

    CMyD3DApplication();
};




//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------

#ifdef XBOX
void __cdecl main()
#else
INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )
#endif
{
    CMyD3DApplication d3dApp;

#ifdef XBOX
    d3dApp.Create(NULL);
#else
    d3dApp.Create(hInst);
#endif

    d3dApp.Run();

#ifndef XBOX
    return 0;
#endif
}


//-----------------------------------------------------------------------------
// Name: CMyD3DApplication()
// Desc: Constructor
//-----------------------------------------------------------------------------
CMyD3DApplication::CMyD3DApplication()
                  :CD3DApplication()
{
    // Override base class members
    m_bUseDepthBuffer   = TRUE;
    m_DepthBufferFormat = D3DFMT_D16;

    // Initialize member variables
    m_pFloorObject        = new CD3DFile();
    m_pDolphinGroupObject = new CD3DFile();
    m_pDolphinObject      = new CD3DFile();

    for( DWORD t=0; t<32; t++ )
        m_pCausticTextures[t] = NULL;
}




//-----------------------------------------------------------------------------
// Name: BlendMeshes()
// Desc: Does a linear interpolation between all vertex positions and normals
//       in two source meshes and outputs the result to the destination mesh.
//       Note: all meshes must contain the same number of vertices, and the
//       destination mesh must be in device memory.
//-----------------------------------------------------------------------------
void CMyD3DApplication::BlendMeshes( FLOAT fWeight )
{
    // Build convenient objects to access the mesh vertices
    MESHTOOL dest( m_pDolphinMesh->GetLocalMesh() );
    MESHTOOL src2( m_pDolphinMesh02->GetSysMemMesh() );
    MESHTOOL src1( fWeight<0.0f ? m_pDolphinMesh03->GetSysMemMesh()
                                : m_pDolphinMesh01->GetSysMemMesh() );

    // The blending factors
    FLOAT fWeight1 = fabsf(fWeight);
    FLOAT fWeight2 = 1.0f - fWeight1;

    // LERP positions and normals
    for( DWORD i=0; i<dest.dwNumVertices; i++ )
    {
        dest.pVertices[i].p = fWeight1*src1.pVertices[i].p +
                              fWeight2*src2.pVertices[i].p;

        dest.pVertices[i].n = fWeight1*src1.pVertices[i].n +
                              fWeight2*src2.pVertices[i].n;
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
void CMyD3DApplication::FrameMove()
{
        // Animation attributes for the dolphin
    FLOAT fKickFreq    = 2*m_fTime;
    FLOAT fPhase       = m_fTime/3;
    FLOAT fBlendWeight = sinf( fKickFreq );

    // Blend the meshes (which makes the dolphin appear to swim)
    BlendMeshes( fBlendWeight );

    // Move the dolphin in a circle
    D3DXMATRIX* pmatDolphin = m_pDolphinObject->GetMatrix();
    D3DXMATRIX  matTrans, matRotate1, matRotate2;
    D3DXMatrixScaling( pmatDolphin, 0.01f, 0.01f, 0.01f );
    D3DXMatrixRotationZ( &matRotate1, -cosf(fKickFreq)/6 );
    D3DXMatrixMultiply( pmatDolphin, pmatDolphin, &matRotate1 );
    D3DXMatrixRotationY( &matRotate2, fPhase );
    D3DXMatrixMultiply( pmatDolphin, pmatDolphin, &matRotate2 );
    D3DXMatrixTranslation( &matTrans, -5*sinf(fPhase), sinf(fKickFreq)/2, 10-10*cosf(fPhase) );
    D3DXMatrixMultiply( pmatDolphin, pmatDolphin, &matTrans );

    // Animate the caustic textures
    DWORD tex = ((DWORD)(m_fTime*32))%32;
    m_pCurrentCausticTexture = m_pCausticTextures[tex];
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------

void CMyD3DApplication::Render()
{
    // Clear the viewport
    CheckHR( m_pDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         WATER_COLOR, 1.0f, 0L ));

    // Begin the scene
    CheckHR( m_pDevice->BeginScene() );

    {
        // Render the Seafloor. For devices that support one-pass multi-
        // texturing, use the second texture stage to blend in the animated
        // water caustics texture.
        if( m_Caps.MaxSimultaneousTextures > 1 )
        {
            // Set up the 2nd texture stage for the animated water caustics
            CheckHR( m_pDevice->SetTexture( 1, m_pCurrentCausticTexture ));
            CheckHR( m_pDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_MODULATE ));
            CheckHR( m_pDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE ));
            CheckHR( m_pDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT ));

            // Tell D3D to automatically generate texture coordinates from the
            // model's position in camera space. The texture transform matrix is
            // setup so that the 'x' and 'z' coordinates are scaled to become the
            // resulting 'tu' and 'tv' texture coordinates. The resulting effect
            // is that the caustic texture is draped over the geometry from above.
            D3DXMATRIX mat;
            mat._11 = 0.05f;           mat._12 = 0.00f;
            mat._21 = 0.00f;           mat._22 = 0.00f;
            mat._31 = 0.00f;           mat._32 = 0.05f;
            mat._41 = sinf(m_fTime)/8; mat._42 = cosf(m_fTime)/10 - m_fTime/10;

            CheckHR( m_pDevice->SetTransform( D3DTS_TEXTURE1, &mat ));
            CheckHR( m_pDevice->SetTextureStageState( 1, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION ));
            CheckHR( m_pDevice->SetTextureStageState( 1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 ));
        }

        // Finally, render the actual seafloor with the above states

        m_pFloorObject->Render( m_pDevice );

        // Disable the second texture stage
        if( m_Caps.MaxSimultaneousTextures > 1 )
            CheckHR( m_pDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE ));

        // Render the dolphin in it's first pass.

        m_pDolphinObject->Render( m_pDevice );

        // For devices that support one-pass multi-texturing, use the second
        // texture stage to blend in the animated water caustics texture for
        // the dolphin. This a little tricky because we only want caustics on
        // the part of the dolphin that is lit from above. To acheive this
        // effect, the dolphin is rendered alpha-blended with a second pass
        // which has the caustic effects modulating the diffuse component
        // (which contains lighting-only information) of the geometry.
        if( m_Caps.MaxSimultaneousTextures > 1 )
        {
            // For the 2nd pass of rendering the dolphin, turn on the caustic
            // effects. Start with setting up the 2nd texture stage state, which
            // will modulate the texture with the diffuse component. This actually
            // only needs one stage, except that using a CD3DFile object makes that
            // a little tricky.
            CheckHR( m_pDevice->SetTexture( 1, m_pCurrentCausticTexture ));
            CheckHR( m_pDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_MODULATE ));
            CheckHR( m_pDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE ));
            CheckHR( m_pDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_DIFFUSE ));

            // Now, set up D3D to generate texture coodinates. This is the same as
            // with the seafloor (the 'x' and 'z' position coordinates in camera
            // space are used to generate the 'tu' and 'tv' texture coordinates),
            // except our scaling factors are different in the texture matrix, to
            // get a better looking result.
            D3DXMATRIX mat;
            ZeroMemory(&mat, sizeof(mat));
            mat._11 = 0.50f; mat._12 = 0.00f;
            mat._21 = 0.00f; mat._22 = 0.00f;
            mat._31 = 0.00f; mat._32 = 0.50f;
            mat._41 = 0.00f; mat._42 = 0.00f;
            CheckHR( m_pDevice->SetTransform( D3DTS_TEXTURE1, &mat ));
            CheckHR( m_pDevice->SetTextureStageState( 1, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION ));
            CheckHR( m_pDevice->SetTextureStageState( 1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 ));

            // Set the ambient color and fog color to pure black. Ambient is set
            // to black because we still have a light shining from above, but we
            // don't want any caustic effects on the dolphin's underbelly. Fog is
            // set to black because we want the caustic effects to fade out in the
            // distance just as the model does with the WATER_COLOR.
            CheckHR( m_pDevice->SetRenderState( D3DRS_AMBIENT,   0x00000000 ));
            CheckHR( m_pDevice->SetRenderState( D3DRS_FOGCOLOR,  0x00000000 ));

            // Set up blending modes to add this caustics-only pass with the
            // previous pass.
            CheckHR( m_pDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ));
            CheckHR( m_pDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCCOLOR ));
            CheckHR( m_pDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE ));

            // Finally, render the caustic effects for the dolphin

            m_pDolphinObject->Render( m_pDevice );

            // After all is well and done, restore any munged texture stage states
            CheckHR( m_pDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE ));
            CheckHR( m_pDevice->SetRenderState( D3DRS_AMBIENT,  0x33333333 ));
            CheckHR( m_pDevice->SetRenderState( D3DRS_FOGCOLOR, WATER_COLOR ));
            CheckHR( m_pDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ));
        }

        // End the scene.
        CheckHR( m_pDevice->EndScene() );
    }
}




//-----------------------------------------------------------------------------
// Name: InitDeviceObjects()
// Desc: Initialize device-dependant objects. This is the place to create mesh
//       and texture objects.
//-----------------------------------------------------------------------------
void CMyD3DApplication::InitDeviceObjects()
{
    // Set up textures for the water caustics
    for( DWORD t=0; t<32; t++ )
    {
        CHAR strName[80];
        sprintf( strName, "Caust%02ld.tga", t );
        CheckHR( D3DUtil_CreateTexture( m_pDevice, strName,
                                           &m_pCausticTextures[t] ) );
    }

    // Load the file-based mesh objects
    m_pDolphinGroupObject->Create( m_pDevice, "dolphing.x" );
    m_pDolphinObject->Create( m_pDevice, "dolphin.x" );
    m_pFloorObject->Create( m_pDevice, "seafloor.x" );

        // Gain access to the meshes
    m_pDolphinMesh01 = m_pDolphinGroupObject->FindMesh( "Dolph01" );
    m_pDolphinMesh02 = m_pDolphinGroupObject->FindMesh( "Dolph02" );
    m_pDolphinMesh03 = m_pDolphinGroupObject->FindMesh( "Dolph03" );
    m_pDolphinMesh   = m_pDolphinObject->FindMesh( "Dolph02" );
    m_pSeaFloorMesh  = m_pFloorObject->FindMesh( "SeaFloor" );

        // Set the FVF type to something useful
    m_pDolphinMesh01->SetFVF( m_pDevice, D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1 );
    m_pDolphinMesh02->SetFVF( m_pDevice, D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1 );
    m_pDolphinMesh03->SetFVF( m_pDevice, D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1 );
    m_pDolphinMesh->SetFVF(   m_pDevice, D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1 );
    m_pSeaFloorMesh->SetFVF(  m_pDevice, D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1 );

     // Scale the sea floor vertices, and add some bumpiness
    {
        MESHTOOL dest( m_pSeaFloorMesh->GetSysMemMesh() );
        srand(5);

        for( DWORD i=0; i<dest.dwNumVertices; i++ )
        {
            dest.pVertices[i].p.y += (rand()/(FLOAT)RAND_MAX);
            dest.pVertices[i].p.y += (rand()/(FLOAT)RAND_MAX);
            dest.pVertices[i].p.y += (rand()/(FLOAT)RAND_MAX);
            dest.pVertices[i].tu  *= 10;
            dest.pVertices[i].tv  *= 10;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc: Restore device-memory objects and state after a device is created or
//       resized.
//-----------------------------------------------------------------------------
void CMyD3DApplication::RestoreDeviceObjects()
{
    // Build the device objects for the files
    m_pDolphinGroupObject->RestoreDeviceObjects( m_pDevice );
    m_pDolphinObject->RestoreDeviceObjects( m_pDevice );
    m_pFloorObject->RestoreDeviceObjects( m_pDevice );

    // Set world transform
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    CheckHR( m_pDevice->SetTransform( D3DTS_WORLD, &matWorld ));

    // Set the view matrix
    D3DXMATRIX  matView;
    D3DXVECTOR3 vEyePt      = D3DXVECTOR3( 0.0f, 0.0f, -5.0f );
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3( 0.0f, 0.0f,  0.0f );
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3( 0.0f, 1.0f,  0.0f );
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    CheckHR( m_pDevice->SetTransform( D3DTS_VIEW, &matView ));

    // Set projection transform
    D3DXMATRIX matProj;
    FLOAT fAspect = ((FLOAT)m_BackBufferDesc.Width) / m_BackBufferDesc.Height;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/3, fAspect, 1.0f, 10000.0f );
    CheckHR( m_pDevice->SetTransform( D3DTS_PROJECTION, &matProj ));

    CheckHR( m_pDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE ));
    CheckHR( m_pDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE ));
    CheckHR( m_pDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE ));
    CheckHR( m_pDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR ));
    CheckHR( m_pDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR ));
    CheckHR( m_pDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR ));
    CheckHR( m_pDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR ));

    // Set default render states
    CheckHR( m_pDevice->SetRenderState( D3DRS_DITHERENABLE,     TRUE ));
    CheckHR( m_pDevice->SetRenderState( D3DRS_SPECULARENABLE,   FALSE ));
    CheckHR( m_pDevice->SetRenderState( D3DRS_ZENABLE,          TRUE ));
    CheckHR( m_pDevice->SetRenderState( D3DRS_NORMALIZENORMALS, TRUE ));

    // Turn on fog, for underwater effect
    FLOAT fFogStart =  1.0f;
    FLOAT fFogEnd   = 50.0f;
    CheckHR( m_pDevice->SetRenderState( D3DRS_FOGENABLE,      TRUE ));
    CheckHR( m_pDevice->SetRenderState( D3DRS_FOGCOLOR,       WATER_COLOR ));
    CheckHR( m_pDevice->SetRenderState( D3DRS_FOGTABLEMODE,   D3DFOG_LINEAR ));
    CheckHR( m_pDevice->SetRenderState( D3DRS_RANGEFOGENABLE, FALSE ));
    CheckHR( m_pDevice->SetRenderState( D3DRS_FOGSTART,       FtoDW(fFogStart) ));
    CheckHR( m_pDevice->SetRenderState( D3DRS_FOGEND,         FtoDW(fFogEnd) ));

    // Set up the lighting states
    D3DLIGHT8 light;
    D3DUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, 0.0f, -1.0f, 0.0f );
    CheckHR( m_pDevice->SetLight( 0, &light ));
    CheckHR( m_pDevice->LightEnable( 0, TRUE ));
    CheckHR( m_pDevice->SetRenderState( D3DRS_LIGHTING, TRUE ));
    CheckHR( m_pDevice->SetRenderState( D3DRS_AMBIENT, 0x33333333 ));
}




//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: Called when the device-dependant objects are about to be lost.
//-----------------------------------------------------------------------------
void CMyD3DApplication::InvalidateDeviceObjects()
{
    m_pFloorObject->InvalidateDeviceObjects();
    m_pDolphinGroupObject->InvalidateDeviceObjects();
    m_pDolphinObject->InvalidateDeviceObjects();
}




//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Called when the app is exitting, or the device is being changed,
//       this function deletes any device dependant objects.
//-----------------------------------------------------------------------------
void CMyD3DApplication::DeleteDeviceObjects()
{
    InvalidateDeviceObjects();

    m_pFloorObject->Destroy();
    m_pDolphinGroupObject->Destroy();
    m_pDolphinObject->Destroy();

    for( DWORD i=0; i<32; i++ )
        SAFE_RELEASE( m_pCausticTextures[i] );
}




//-----------------------------------------------------------------------------
// Name: FinalCleanup()
// Desc: Called before the app exits, this function gives the app the chance
//       to cleanup after itself.
//-----------------------------------------------------------------------------
void CMyD3DApplication::FinalCleanup()
{
    SAFE_DELETE( m_pDolphinGroupObject );
    SAFE_DELETE( m_pDolphinObject );
    SAFE_DELETE( m_pFloorObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\common\d3dutil.h ===
//-----------------------------------------------------------------------------
// File: D3DUtil.h
//
// Desc: Helper functions and typing shortcuts for Direct3D programming.
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#ifndef D3DUTIL_H
#define D3DUTIL_H
#include <D3D8.h>
#include <D3DX8Math.h>




//-----------------------------------------------------------------------------
// Name: D3DUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID D3DUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                                               FLOAT b=0.0f, FLOAT a=1.0f );




//-----------------------------------------------------------------------------
// Name: D3DUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID D3DUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                        FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f );




//-----------------------------------------------------------------------------
// Name: D3DUtil_CreateTexture()
// Desc: Helper function to create a texture. It checks the root path first,
//       then tries the DXSDK media path (as specified in the system registry).
//-----------------------------------------------------------------------------
HRESULT D3DUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strTexture,
                               LPDIRECT3DTEXTURE8* ppTexture,
                               D3DFORMAT d3dFormat = D3DFMT_UNKNOWN );




//-----------------------------------------------------------------------------
// Name: D3DUtil_SetColorKey()
// Desc: Changes all texels matching the colorkey to transparent, black.
//-----------------------------------------------------------------------------
HRESULT D3DUtil_SetColorKey( LPDIRECT3DTEXTURE8 pTexture, DWORD dwColorKey );




//-----------------------------------------------------------------------------
// Name: D3DUtil_CreateVertexShader()
// Desc: Assembles and creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT D3DUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
								    WCHAR* strFilename, DWORD* pdwVertexDecl,
									DWORD* pdwVertexShader );

									
									
									
//-----------------------------------------------------------------------------
// Name: D3DUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX D3DUtil_GetCubeMapViewMatrix( DWORD dwFace );




//-----------------------------------------------------------------------------
// Name: D3DUtil_GetRotationFromCursor()
// Desc: Returns a quaternion for the rotation implied by the window's cursor
//       position.
//-----------------------------------------------------------------------------
D3DXQUATERNION D3DUtil_GetRotationFromCursor( HWND hWnd,
                                              FLOAT fTrackBallRadius=1.0f );




//-----------------------------------------------------------------------------
// Name: class CD3DArcBall
// Desc:
//-----------------------------------------------------------------------------
class CD3DArcBall
{
	INT            m_iWidth;   // ArcBall's window width
	INT            m_iHeight;  // ArcBall's window height
	FLOAT          m_fRadius;  // ArcBall's radius in screen coords
	FLOAT          m_fRadius2; // ArcBall's radius in screen coords

	D3DXQUATERNION m_qDown;               // Quaternion before button down
	D3DXQUATERNION m_qNow;                // Composite quaternion for current drag
	D3DXMATRIX     m_matRotation;         // Matrix for arcball's orientation
	D3DXMATRIX     m_matRotationDelta;    // Matrix for arcball's orientation
	D3DXMATRIX     m_matTranslation;      // Matrix for arcball's position
	D3DXMATRIX     m_matTranslationDelta; // Matrix for arcball's position
	BOOL           m_bDrag;               // Whether user is dragging arcball

	D3DXVECTOR3 ScreenToVector( int sx, int sy );

public:
	LRESULT     HandleMouseMessages( HWND, UINT, WPARAM, LPARAM );

	D3DXMATRIX* GetRotationMatrix()         { return &m_matRotation; }
	D3DXMATRIX* GetRotationDeltaMatrix()    { return &m_matRotationDelta; }
	D3DXMATRIX* GetTranslationMatrix()      { return &m_matTranslation; }
	D3DXMATRIX* GetTranslationDeltaMatrix() { return &m_matTranslationDelta; }
	BOOL        IsBeingDragged()            { return m_bDrag; }

	VOID        SetRadius( FLOAT fRadius );
	VOID        SetWindow( int w, int h, float r=0.9 );

	CD3DArcBall();
};




//-----------------------------------------------------------------------------
// Name: class CD3DCamera
// Desc:
//-----------------------------------------------------------------------------
class CD3DCamera
{
	D3DXVECTOR3 m_vEyePt;       // Attributes for view matrix
	D3DXVECTOR3 m_vLookatPt;
	D3DXVECTOR3 m_vUpVec;

	D3DXVECTOR3 m_vView;
	D3DXVECTOR3 m_vCross;

	D3DXMATRIX  m_matView;
	D3DXMATRIX  m_matBillboard; // Special matrix for billboarding effects

	FLOAT       m_fFOV;         // Attributes for projection matrix
	FLOAT       m_fAspect;
	FLOAT       m_fNearPlane;
	FLOAT       m_fFarPlane;
	D3DXMATRIX  m_matProj;

public:
	// Access functions
	D3DXVECTOR3 GetEyePt()           { return m_vEyePt; }
	D3DXVECTOR3 GetPookatPt()        { return m_vLookatPt; }
	D3DXVECTOR3 GetUpVec()           { return m_vUpVec; }
	D3DXVECTOR3 GetViewDir()         { return m_vView; }
	D3DXVECTOR3 GetCross()           { return m_vCross; }

	D3DXMATRIX  GetViewMatrix()      { return m_matView; }
	D3DXMATRIX  GetBillboardMatrix() { return m_matBillboard; }
	D3DXMATRIX  GetProjMatrix()      { return m_matProj; }

	VOID SetViewParams( D3DXVECTOR3 &vEyePt, D3DXVECTOR3& vLookatPt,
						D3DXVECTOR3& vUpVec );
	VOID SetProjParams( FLOAT fFOV, FLOAT fAspect, FLOAT fNearPlane,
						FLOAT fFarPlane );

	CD3DCamera();
};




//-----------------------------------------------------------------------------
// Helper macros for pixel shader instructions
//-----------------------------------------------------------------------------

// Parameter writemasks
#define D3DPSP_WRITEMASK_B   D3DSP_WRITEMASK_0
#define D3DPSP_WRITEMASK_G   D3DSP_WRITEMASK_1
#define D3DPSP_WRITEMASK_R   D3DSP_WRITEMASK_2
#define D3DPSP_WRITEMASK_A   D3DSP_WRITEMASK_3
#define D3DPSP_WRITEMASK_C   (D3DPSP_WRITEMASK_B|D3DPSP_WRITEMASK_G|D3DPSP_WRITEMASK_R)
#define D3DPSP_WRITEMASK_ALL (D3DSP_WRITEMASK_0|D3DSP_WRITEMASK_1|D3DSP_WRITEMASK_2|D3DSP_WRITEMASK_3)
#define D3DPSP_WRITEMASK_10  (D3DSP_WRITEMASK_0|D3DSP_WRITEMASK_1)
#define D3DPSP_WRITEMASK_32  (D3DSP_WRITEMASK_2|D3DSP_WRITEMASK_3)

// Source and destination parameter token
#define D3DPS_REGNUM_MASK(_Num)   ( (1L<<31) | ((_Num)&D3DSP_REGNUM_MASK) )
#define D3DPS_DST(_Num)           ( D3DPS_REGNUM_MASK(_Num) | D3DSPR_TEMP | D3DPSP_WRITEMASK_ALL )
#define D3DPS_SRC_TEMP(_Num)      ( D3DPS_REGNUM_MASK(_Num) | D3DSP_NOSWIZZLE | D3DSPR_TEMP )
#define D3DPS_SRC_INPUT(_Num)     ( D3DPS_REGNUM_MASK(_Num) | D3DSP_NOSWIZZLE | D3DSPR_INPUT )
#define D3DPS_SRC_CONST(_Num)     ( D3DPS_REGNUM_MASK(_Num) | D3DSP_NOSWIZZLE | D3DSPR_CONST )
#define D3DPS_SRC_TEXTURE(_Num)   ( D3DPS_REGNUM_MASK(_Num) | D3DSP_NOSWIZZLE | D3DSPR_TEXTURE )
#define D3DVS_SRC_ADDR(_Num)      ( D3DPS_REGNUM_MASK(_Num) | D3DSP_NOSWIZZLE | D3DSPR_ADDR )
#define D3DVS_SRC_RASTOUT(_Num)   ( D3DPS_REGNUM_MASK(_Num) | D3DSP_NOSWIZZLE | D3DSPR_RASTOUT )
#define D3DVS_SRC_ATTROUT(_Num)   ( D3DPS_REGNUM_MASK(_Num) | D3DSP_NOSWIZZLE | D3DSPR_ATTROUT )
#define D3DVS_SRC_TEXCRDOUT(_Num) ( D3DPS_REGNUM_MASK(_Num) | D3DSP_NOSWIZZLE | D3DSPR_TEXCRDOUT )


// Temp destination registers
#define D3DS_DR0   D3DPS_DST(0)
#define D3DS_DR1   D3DPS_DST(1)
#define D3DS_DR2   D3DPS_DST(2)
#define D3DS_DR3   D3DPS_DST(3)
#define D3DS_DR4   D3DPS_DST(4)
#define D3DS_DR5   D3DPS_DST(5)
#define D3DS_DR6   D3DPS_DST(6)
#define D3DS_DR7   D3DPS_DST(7)

// Temp source registers
#define D3DS_SR0   D3DPS_SRC_TEMP(0)
#define D3DS_SR1   D3DPS_SRC_TEMP(1)
#define D3DS_SR2   D3DPS_SRC_TEMP(2)
#define D3DS_SR3   D3DPS_SRC_TEMP(3)
#define D3DS_SR4   D3DPS_SRC_TEMP(4)
#define D3DS_SR5   D3DPS_SRC_TEMP(5)
#define D3DS_SR6   D3DPS_SRC_TEMP(6)
#define D3DS_SR7   D3DPS_SRC_TEMP(7)

// Texture parameters
#define D3DS_T0   D3DPS_SRC_TEXTURE(0)
#define D3DS_T1   D3DPS_SRC_TEXTURE(1)
#define D3DS_T2   D3DPS_SRC_TEXTURE(2)
#define D3DS_T3   D3DPS_SRC_TEXTURE(3)
#define D3DS_T4   D3DPS_SRC_TEXTURE(4)
#define D3DS_T5   D3DPS_SRC_TEXTURE(5)
#define D3DS_T6   D3DPS_SRC_TEXTURE(6)
#define D3DS_T7   D3DPS_SRC_TEXTURE(7)

// Constant (factor) source parameters
#define D3DS_C0     D3DPS_SRC_CONST(0)
#define D3DS_C1     D3DPS_SRC_CONST(1)
#define D3DS_C2     D3DPS_SRC_CONST(2)
#define D3DS_C3     D3DPS_SRC_CONST(3)
#define D3DS_C4     D3DPS_SRC_CONST(4)
#define D3DS_C5     D3DPS_SRC_CONST(5)
#define D3DS_C6     D3DPS_SRC_CONST(6)
#define D3DS_C7     D3DPS_SRC_CONST(7)

// Interated source parameters (0==Diffuse, 1==specular)
#define D3DS_V0     D3DPS_SRC_INPUT(0)
#define D3DS_V1     D3DPS_SRC_INPUT(1)




#endif // D3DUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\draw\sources.inc ===
TARGETNAME=Draw
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    bitfont.cpp \
    main.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\draw\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\draw\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#include <xgraphics.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL,
            D3DLOCK_NOSYSLOCK | D3DLOCK_RAWDATA) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    PVOID pBits = Swizzler_GetUnswizzledBits(&lockRect, &desc);
    if (pBits == NULL)
    {
        assert(FALSE);
        pSurface->UnlockRect();
        return;
    }

    PVOID pBitsOld = lockRect.pBits;
    lockRect.pBits = pBits;

    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    lockRect.pBits = pBitsOld;
    Swizzler_SwizzleFromBits(pBits, &lockRect, &desc);

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\endless\main.cpp ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Complete DX8 application to draw a screen space triangle.

Revision History:

    Derived from a DX8 sample.
--*/

#include <stddef.h>
#include <stdio.h>

extern "C"
{
    #include <ntos.h>
    #include <nturtl.h>
    #include <av.h>
};

#include <xtl.h>
#include <xgraphics.h>

IDirect3DDevice8* g_pDev  = NULL;

bool InitD3D()
{
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    if (pD3D == NULL)
        return false;

    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_A8R8G8B8;
    d3dpp.BackBufferCount           = 1;
    d3dpp.Windowed                  = false;   // Must be false for Xbox.
    d3dpp.EnableAutoDepthStencil    = true;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;

    if (pD3D->CreateDevice(
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        NULL,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        &g_pDev) != S_OK)
    {
        return false;
    }

    pD3D->Release();

    return true;
}

#define PUSHBUFFERSIZE 32768

void __cdecl main()
{
    D3DPushBuffer* pPushBuffer;
    DWORD offset;
    DWORD jumpOffset;

    InitD3D();

    g_pDev->CreatePushBuffer(32768, FALSE, &pPushBuffer);
    g_pDev->BeginPushBuffer(pPushBuffer);
    do {
        g_pDev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER, 0, 0, 0);
        g_pDev->Clear(0, NULL, D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0xff, 0, 0xff);
        g_pDev->GetPushBufferOffset(&offset);

    } while (offset < PUSHBUFFERSIZE - 1024);

    g_pDev->GetPushBufferOffset(&jumpOffset);
    g_pDev->Nop();
    g_pDev->EndPushBuffer();

    pPushBuffer->BeginFixup(NULL, 0);
    pPushBuffer->Jump(jumpOffset, 0);
    pPushBuffer->EndFixup();

    g_pDev->RunPushBuffer(pPushBuffer, NULL);
    g_pDev->KickPushBuffer();

    while (g_pDev->IsBusy())
        ;

    DbgPrint("Done!\n");

    while (TRUE)
        ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\draw\main.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#ifdef XBOX
#include <xtl.h>
#else
#include "windows.h"
#endif

#include "d3d8.h"
#include "bitfont.h"

HWND g_hwnd;

//------------------------------------------------------------------------------
// Draw
//
// Handy little D3D encapsulation for simple 2D drawing.

class Draw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    Draw(INT width = 640, INT height = 480);

    ~Draw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};

//------------------------------------------------------------------------------
// Draw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* Draw::m_pDevice;

//------------------------------------------------------------------------------
// Draw constructor

Draw::Draw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = g_hwnd;   // Ignored on Xbox
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            g_hwnd,                                 // Ignored on Xbox
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// Draw::~Draw

Draw::~Draw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// Draw::FillRect

VOID Draw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

//------------------------------------------------------------------------------
// Draw::DrawText

VOID Draw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

//------------------------------------------------------------------------------
// Draw::Present
//
// Make the current back-buffer visible

VOID Draw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}

//------------------------------------------------------------------------------
// Test

VOID Test()
{
    Draw draw;

    draw.FillRect(0, 0, 640, 480, 0xff0000);            // Draw border in red
    draw.FillRect(50, 50, 540, 380, 0);                 // Fill interior with black
    draw.DrawText(L"Xbox rules!", 100, 100, 0x00ff00);  
    draw.Present();                                     // Show the buffer
}

#if defined(XBOX)

//------------------------------------------------------------------------------
// TestMain

extern "C" DWORD WINAPI TestMain()
{
    Test();

    while (TRUE)
        ;

    return 1;
}

#else

//------------------------------------------------------------------------------
LRESULT WINAPI MessageHandler
(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
//--------------------------------------
{
    if (Msg == WM_DESTROY)
        PostQuitMessage(0);

    return DefWindowProc(hWnd, Msg, wParam, lParam);
}

//------------------------------------------------------------------------------
int APIENTRY WinMain
(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpCmdLine,
    int         nCmdShow
)
//--------------------------------------
{
    MSG msg;
    BOOL bQuit;

    WNDCLASSEX classex;
    ZeroMemory( &classex, sizeof(classex) );

    classex.cbSize          = sizeof(WNDCLASSEX);
    classex.style           = CS_CLASSDC;
    classex.lpfnWndProc     = MessageHandler;
    classex.hInstance       = hInstance;
    classex.lpszClassName   = L"XBOX";
    RegisterClassEx(&classex);

    g_hwnd = CreateWindowEx(WS_EX_TOPMOST, L"XBOX", L"XBOX Basic Shell",
                            WS_VISIBLE|WS_POPUP,
                            CW_USEDEFAULT,CW_USEDEFAULT, 0, 0,
                            NULL, NULL, hInstance, NULL);

    ShowCursor(false);

    bQuit = FALSE;
    while (!bQuit)
    {
        while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
        {
            if (!GetMessage(&msg, NULL, 0, 0))
            {
                bQuit = true;
            }

            TranslateMessage(&msg);
            DispatchMessage(&msg);

            Test();
        }
    }

    return EXIT_SUCCESS;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\error\main.c ===
#include <xtl.h>

#pragma pack(1)

typedef struct _IMAGE_RUN1 {
    UINT fOne : 1;
    UINT Size : 3;
    UINT Intensity : 4;
} IMAGE_RUN1;

typedef struct _IMAGE_RUN2 {
    UINT fOne : 1;
    UINT fTwo : 1;
    UINT Size : 10;
    UINT Intensity : 4;
} IMAGE_RUN2;

typedef struct _IMAGE_RUN3 {
    UINT fOne : 1;
    UINT fTwo : 1;
    UINT Size : 18;
    UINT Intensity : 4;
} IMAGE_RUN3;

#pragma pack()

#include "image.h"

const struct TheVerts { float x,y,z,w; float u, v; } Verts[] =
{
    {  0.0f,   0.0f, 0.5f, 1.0f,   0.0f,   0.0f},
    {640.0f, 480.0f, 0.5f, 1.0f, 320.0f, 240.0f},
    {  0.0f, 480.0f, 0.5f, 1.0f,   0.0f, 240.0f},
    {640.0f,   0.0f, 0.5f, 1.0f, 320.0f,   0.0f},
    {640.0f, 480.0f, 0.5f, 1.0f, 320.0f, 240.0f},
    {  0.0f,   0.0f, 0.5f, 1.0f,   0.0f,   0.0f},
};

IDirect3DDevice8* InitD3D(void)
{
    D3DPRESENT_PARAMETERS d3dpp;
    IDirect3DDevice8 *pDev;
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);

    if (pD3D == NULL)
    {
        return NULL;
    }

    pDev = NULL;
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth                 = 640;
    d3dpp.BackBufferHeight                = 480;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 1;
    d3dpp.Windowed                        = FALSE;
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz      = 60;
    d3dpp.hDeviceWindow                   = NULL;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    IDirect3D8_CreateDevice(pD3D,
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &pDev);

    IDirect3D8_Release(pD3D);

    return pDev;
}

BOOL InitVB(IDirect3DDevice8 *pDev)
{
    IDirect3DVertexBuffer8 *pVB;
    void *pVerts;

    if (FAILED(IDirect3DDevice8_CreateVertexBuffer(pDev,
            sizeof(Verts),
            D3DUSAGE_WRITEONLY,
            D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1,
            D3DPOOL_MANAGED,
            &pVB)))
    {
        return FALSE;
    }

    IDirect3DVertexBuffer8_Lock(pVB, 0, sizeof(Verts), (BYTE **)(&pVerts), 0);
    memcpy((void*)pVerts, (void*)Verts, sizeof(Verts));
    IDirect3DVertexBuffer8_Unlock(pVB);

    IDirect3DDevice8_SetStreamSource(pDev, 0, pVB, sizeof(Verts[0]));
    IDirect3DDevice8_SetVertexShader(pDev, D3DFVF_XYZRHW | D3DFVF_TEX1);

    return TRUE;
}

COLORREF ColorFromIntensity(UINT intensity4bits)
{
    UINT BaseR = 0x00;
    UINT BaseG = 0xFF;
    UINT BaseB = 0x00;

    UINT r = (UINT)((BaseR * intensity4bits) / 15.0f + 0.5f);
    UINT g = (UINT)((BaseG * intensity4bits) / 15.0f + 0.5f);
    UINT b = (UINT)((BaseB * intensity4bits) / 15.0f + 0.5f);

    return D3DCOLOR_ARGB(0xFF, r, g, b);
}

BOOL InitTexture(IDirect3DDevice8 *pDev)
{
    IDirect3DTexture8* pTex;
    D3DLOCKED_RECT lock;
    UINT x = 0, y = 0, i, j;
    DWORD dwLine;
    DWORD dwAddr;
    IMAGE_RUN1 *pRun1;
    IMAGE_RUN2 *pRun2;
    IMAGE_RUN3 *pRun3;
    UINT Size;
    UINT Intensity;

    if (FAILED(IDirect3DDevice8_CreateTexture(pDev,
            320,
            240,
            1,
            0,
            D3DFMT_LIN_X8R8G8B8,
            0,
            &pTex)))
    {
        return FALSE;
    }

    IDirect3DTexture8_LockRect(pTex, 0, &lock, NULL, 0);
    dwLine = (DWORD)lock.pBits;
    dwAddr = dwLine;
    i = 0;

    while(i < sizeof(g_Image))
    {
        pRun1 = (IMAGE_RUN1*)&g_Image[i];
        if (pRun1->fOne)
        {
            Size = pRun1->Size;
            Intensity = pRun1->Intensity;
            i += 1;
        }
        else
        {
            pRun2 = (IMAGE_RUN2*)&g_Image[i];
            if (pRun2->fTwo)
            {
                Size = pRun2->Size;
                Intensity = pRun2->Intensity;
                i += 2;
            }
            else
            {
                pRun3 = (IMAGE_RUN3*)&g_Image[i];
                Size = pRun3->Size;
                Intensity = pRun3->Intensity;
                i += 3;
            }
        }

        for (j = 0; j < Size; j++)
        {
            if (Intensity == 0)
            {
                *(DWORD*)dwAddr = 0xFF000000;
            }
            else
            {
                *(DWORD*)dwAddr = ColorFromIntensity(Intensity);
            }
            if (x >= 320)
            {
                x = 0;
                y++;
                dwLine += lock.Pitch;
                dwAddr = dwLine;
            }
            else
            {
                dwAddr += sizeof(DWORD);
            }
        }
    }

    IDirect3DTexture8_UnlockRect(pTex, 0);

    IDirect3DDevice8_SetTexture(pDev, 0, (D3DBaseTexture*)pTex);

    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

    return TRUE;
}

void __cdecl main(void)
{
    IDirect3DDevice8 *pDev;

//    __asm int 3;

    if ((pDev = InitD3D()) == NULL)
    {
        return;
    }

    if (!InitVB(pDev) || !InitTexture(pDev))
    {
        IDirect3DDevice8_Release(pDev);
        return;
    }

    IDirect3DDevice8_SetRenderState(pDev, D3DRS_SRCBLEND, D3DBLEND_SRCCOLOR);
    IDirect3DDevice8_SetRenderState(pDev, D3DRS_DESTBLEND, D3DBLEND_ONE);

    IDirect3DDevice8_SetRenderState(pDev, D3DRS_CULLMODE, D3DCULL_NONE);
    IDirect3DDevice8_SetRenderState(pDev, D3DRS_ALPHABLENDENABLE, FALSE);
    IDirect3DDevice8_SetRenderState(pDev, D3DRS_ALPHATESTENABLE, FALSE);

    while (1)
    {
        IDirect3DDevice8_BeginScene(pDev);

        IDirect3DDevice8_DrawPrimitive(pDev,
                D3DPT_TRIANGLELIST,
                0,
                (sizeof(Verts) / sizeof(Verts[0])) / 3);

        IDirect3DDevice8_EndScene(pDev);

        IDirect3DDevice8_Present(pDev, NULL, NULL, NULL, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\fillrate\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "bitfont.h"

DWORD BitsPerPixelOfD3DFORMAT(DWORD Format);
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000f, 0x00000060, 0x00000008,
    0x000f0800, 0x1e080000, 0x08000000, 0x0000002d,
    0x00003c08, 0x004b0800, 0x5a080000, 0x08000000,
    0x00000069, 0x00007808, 0x00870800, 0x96080000,
    0x08000000, 0x000000a5, 0x0000b408, 0x00c30800,
    0xd2080000, 0x08000000, 0x000000e1, 0x0000f008,
    0x00ff0800, 0x0e080000, 0x08000001, 0x0000011d,
    0x00012c08, 0x013b0800, 0x4a080000, 0x08000001,
    0x00000159, 0x00016808, 0x01770800, 0x86080000,
    0x08000001, 0x00000195, 0x0001a408, 0x01b30800,
    0xc2080000, 0x08000001, 0x000001d1, 0x0001e008,
    0x01ef0800, 0xfe080000, 0x08000001, 0x0000020d,
    0x00021c08, 0x022b0800, 0x3a080000, 0x08000002,
    0x00000249, 0x00025808, 0x02670800, 0x76080000,
    0x08000002, 0x00000285, 0x00029408, 0x02a30800,
    0xb2080000, 0x08000002, 0x000002c1, 0x0002d008,
    0x02df0800, 0xee080000, 0x08000002, 0x000002fd,
    0x00030c08, 0x031b0800, 0x2a080000, 0x08000003,
    0x00000339, 0x00034808, 0x03570800, 0x66080000,
    0x08000003, 0x00000375, 0x00038408, 0x03930800,
    0xa2080000, 0x08000003, 0x000003b1, 0x0003c008,
    0x03cf0800, 0xde080000, 0x08000003, 0x000003ed,
    0x0003fc08, 0x040b0800, 0x1a080000, 0x08000004,
    0x00000429, 0x00043808, 0x04470800, 0x56080000,
    0x08000004, 0x00000465, 0x00047408, 0x04830800,
    0x92080000, 0x08000004, 0x000004a1, 0x0004b008,
    0x04bf0800, 0xce080000, 0x08000004, 0x000004dd,
    0x0004ec08, 0x04fb0800, 0x0a080000, 0x08000005,
    0x00000519, 0x00052808, 0x05370800, 0x46080000,
    0x08000005, 0x00000555, 0x00056408, 0x05730800,
    0x82080000, 0x08000005, 0x00000591, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xc3e7ffff,
    0xe7e7c3c3, 0xffe7e7ff, 0xffffffff, 0x999999ff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xc980c9c9,
    0xc980c9c9, 0xffffffc9, 0xc3e7e7ff, 0xe7cf9f99,
    0xc399f9f3, 0xffffe7e7, 0x25278fff, 0xcfe7f389,
    0xf1e4a491, 0xffffffff, 0x9393c7ff, 0x99909fc7,
    0xffffc499, 0xffffffff, 0xffe7e7e7, 0xffffffff,
    0xffffffff, 0xf3ffffff, 0xcfcfe7e7, 0xe7cfcfcf,
    0xfffff3e7, 0xe7cfffff, 0xf3f3f3e7, 0xe7e7f3f3,
    0xffffffcf, 0xc9ffffff, 0xc9e380e3, 0xffffffff,
    0xffffffff, 0xe7e7ffff, 0xffe7e781, 0xffffffff,
    0xffffffff, 0xffffffff, 0xe3e3ffff, 0xffffe7f3,
    0xffffffff, 0xff81ffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffe3e3, 0xffffffff,
    0xf3f3f9f9, 0xcfcfe7e7, 0xffff9f9f, 0xe1ffffff,
    0xccc8c8cc, 0xe1ccc4c4, 0xffffffff, 0xe3f3ffff,
    0xf3f3f383, 0xfff3f3f3, 0xffffffff, 0x9999c3ff,
    0xcfe7f3f9, 0xffff819f, 0xffffffff, 0xf99999c3,
    0x9999f9e3, 0xffffffc3, 0xcfffffff, 0xc9c9c9cf,
    0xf9f98099, 0xffffffff, 0x9f81ffff, 0xf9839f9f,
    0xff87f3f9, 0xffffffff, 0xcfe7e3ff, 0x99999983,
    0xffffc399, 0xffffffff, 0xf3f3f981, 0xcfcfe7e7,
    0xffffffcf, 0xc3ffffff, 0xc3899999, 0xc3999991,
    0xffffffff, 0x99c3ffff, 0xc1999999, 0xffc7e7f3,
    0xffffffff, 0xe3ffffff, 0xffffffe3, 0xffffe3e3,
    0xffffffff, 0xe3e3ffff, 0xe3ffffff, 0xffe7f3e3,
    0xf9ffffff, 0x9fcfe7f3, 0xf9f3e7cf, 0xffffffff,
    0xffffffff, 0x81ff81ff, 0xffffffff, 0xffffffff,
    0xe7cf9fff, 0xe7f3f9f3, 0xffff9fcf, 0xffffffff,
    0xf39999c3, 0xe7ffe7e7, 0xffffffe7, 0x81ffffff,
    0x24303c3c, 0x803f3024, 0xffffffff, 0xc3e7ffff,
    0x81999999, 0xff999999, 0xffffffff, 0x999983ff,
    0x99998399, 0xffff8399, 0xffffffff, 0x9f9999c3,
    0x99999f9f, 0xffffffc3, 0x87ffffff, 0x99999993,
    0x87939999, 0xffffffff, 0x9f81ffff, 0x9f839f9f,
    0xff819f9f, 0xffffffff, 0x9f9f81ff, 0x9f9f839f,
    0xffff9f9f, 0xffffffff, 0x9f9999c3, 0x9999919f,
    0xffffffc1, 0x99ffffff, 0x81999999, 0x99999999,
    0xffffffff, 0xe7c3ffff, 0xe7e7e7e7, 0xffc3e7e7,
    0xffffffff, 0xf9f9f9ff, 0x99f9f9f9, 0xffffc399,
    0xffffffff, 0x93939999, 0x99939387, 0xffffff99,
    0x9fffffff, 0x9f9f9f9f, 0x819f9f9f, 0xffffffff,
    0x9c9cffff, 0x94949488, 0xff9c9c9c, 0xffffffff,
    0x8c9c9cff, 0x9c989084, 0xffff9c9c, 0xffffffff,
    0x999999c3, 0x99999999, 0xffffffc3, 0x83ffffff,
    0x83999999, 0x9f9f9f9f, 0xffffffff, 0x99c3ffff,
    0x99999999, 0xf3c39999, 0xfffffff9, 0x999983ff,
    0x99938399, 0xffff9999, 0xffffffff, 0xcf9f99c3,
    0x99f9f3e7, 0xffffffc3, 0x81ffffff, 0xe7e7e7e7,
    0xe7e7e7e7, 0xffffffff, 0x9999ffff, 0x99999999,
    0xffc39999, 0xffffffff, 0x999999ff, 0x99999999,
    0xffffe7c3, 0xffffffff, 0x949c9c9c, 0xc9c99494,
    0xffffffc9, 0x99ffffff, 0xe7e7cb99, 0x999999d3,
    0xffffffff, 0x9999ffff, 0xe7c39999, 0xffe7e7e7,
    0xffffffff, 0xf9f981ff, 0x9fcfe7f3, 0xffff819f,
    0xffffffff, 0xcfcfcfc3, 0xcfcfcfcf, 0xc3cfcfcf,
    0x9fffffff, 0xe7cfcf9f, 0xf9f3f3e7, 0xfffffff9,
    0xf3c3ffff, 0xf3f3f3f3, 0xf3f3f3f3, 0xe7ffc3f3,
    0xffff99c3, 0xffffffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0x00ffffff, 0xf3e7c7ff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0xc1f9f9c3, 0xffc19999, 0xffffffff, 0x839f9fff,
    0x99999999, 0xffff8399, 0xffffffff, 0x99c3ffff,
    0x999f9f9f, 0xffffffc3, 0xf9ffffff, 0x9999c1f9,
    0xc1999999, 0xffffffff, 0xffffffff, 0x819999c3,
    0xffc39f9f, 0xffffffff, 0xcfcfe1ff, 0xcfcf81cf,
    0xffffcfcf, 0xffffffff, 0x99c1ffff, 0x99999999,
    0x83f9f9c1, 0x9fffffff, 0x9999839f, 0x99999999,
    0xffffffff, 0xffe7e7ff, 0xe7e7e787, 0xff81e7e7,
    0xffffffff, 0xc3fff3f3, 0xf3f3f3f3, 0xf3f3f3f3,
    0xffffff87, 0x99999f9f, 0x99938793, 0xffffff99,
    0x87ffffff, 0xe7e7e7e7, 0x81e7e7e7, 0xffffffff,
    0xffffffff, 0x94949481, 0xff9c9494, 0xffffffff,
    0x83ffffff, 0x99999999, 0xffff9999, 0xffffffff,
    0x99c3ffff, 0x99999999, 0xffffffc3, 0xffffffff,
    0x999983ff, 0x83999999, 0xff9f9f9f, 0xffffffff,
    0x999999c1, 0xf9c19999, 0xfffff9f9, 0x99ffffff,
    0x9f9f8f91, 0xffff9f9f, 0xffffffff, 0x9fc1ffff,
    0xf9f9c39f, 0xffffff83, 0xcfffffff, 0xcfcf81cf,
    0xe1cfcfcf, 0xffffffff, 0xffffffff, 0x99999999,
    0xffc19999, 0xffffffff, 0x99ffffff, 0x99999999,
    0xffffe7c3, 0xffffffff, 0x949cffff, 0xc9949494,
    0xffffffc9, 0xffffffff, 0xc39999ff, 0x9999c3e7,
    0xffffffff, 0xffffffff, 0x99999999, 0xf3c39999,
    0xffff0fe7, 0x81ffffff, 0xcfe7f3f9, 0xffff819f,
    0xffffffff, 0xe7e7e7f3, 0xe7cf9fcf, 0xfff3e7e7,
    0xe7ffffff, 0xe7e7e7e7, 0xe7e7e7e7, 0xffe7e7e7,
    0xe7cfffff, 0xf9f3e7e7, 0xe7e7e7f3, 0xffffffcf,
    0x71248eff, 0xffffffff, 0xffffffff, 0xffffffff,
    0x81818181, 0x81818181, 0xffffff81
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const char* filename)
{
#ifdef NEVER
    HFILE hf = _lopen(filename, OF_READ);

    if(hf != HFILE_ERROR)
    {
        // get the file size and move back to the start
        LONG lSize = _llseek(hf, 0, FILE_END);
        _llseek(hf, 0, FILE_BEGIN);

        // need at least a BITFONT and one BITFONTINFO
        if(lSize < sizeof(BitFontInfo) + sizeof(BitFontCharInfo))
            goto err;

        // malloc our BITFONT block and read it in
        m_pBitFontInfo = (BitFontInfo *)new BYTE[lSize];
        if(!m_pBitFontInfo)
            goto err;

        if(_lread(hf, m_pBitFontInfo, (UINT)lSize) != (UINT)lSize)
            goto err;

        // if the sig doesn't match or we don't have any bitfontinfos then bail
        if(m_pBitFontInfo->dwSig != BITFONT_SIG || !m_pBitFontInfo->cBfis)
            goto err;

        _lclose(hf);
        return true;
    }

err:
    if(hf != HFILE_ERROR)
        _lclose(hf);

    delete [] m_pBitFontInfo;
    m_pBitFontInfo = NULL;
#endif
    return false;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const char *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const char *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const char*         str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const char *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const char*         str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const char *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const char*     str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const char*         str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        _asm int 3;
        return;
    }

    D3DSURFACE_DESC desc;
    if(FAILED(pSurface->GetDesc(&desc)))
    {
        _asm int 3;
        return;
    }

    UINT BitsPerPixel = BitsPerPixelOfD3DFORMAT(desc.Format);

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_R4G4B4A4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        _asm int 3;
        break;
    }

    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\error\image.h ===
const BYTE g_Image[] =
{

0x74, 0x7E, 0x00, 0xA3, 0x07, 0xA3, 0x4A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x96, 0x00, 0xA3, 0x92, 0x00, 0xA3, 0x62, 0x03, 0xA3, 0x07, 0xA3, 
0x4A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x92, 0x04, 0xA3, 0x03, 0xA3, 
0x05, 0xA7, 0x05, 0xA3, 0x07, 0xA9, 0x0B, 0xA5, 0x05, 0xA9, 0x07, 0xA7, 
0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA7, 0x03, 0xA5, 0x07, 0xA9, 0x03, 0xA3, 
0x07, 0xA5, 0x05, 0xA7, 0x03, 0xA5, 0x07, 0xA7, 0x0B, 0xA7, 0x05, 0xA5, 
0x05, 0xA9, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA5, 0x42, 0x03, 
0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x22, 0x00, 0xA3, 
0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 
0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x0F, 0xA3, 0x09, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x3E, 0x03, 0xA3, 0x05, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x0F, 0xA5, 0x05, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA9, 0x05, 0xA5, 0x0D, 
0xA5, 0x05, 0xA9, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x09, 0xA9, 0x3E, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x0D, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 
0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x0F, 0xA3, 0x0F, 0xA3, 
0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x4A, 0x03, 0xA3, 0x07, 0xA7, 0x07, 0xAB, 0x0D, 0xA3, 0x05, 
0xA3, 0x03, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 
0xA7, 0x05, 0xA9, 0x05, 0xAB, 0x05, 0xA3, 0x07, 0xA7, 0x03, 0xA7, 0x0B, 
0xA7, 0x07, 0xA7, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x07, 
0xA7, 0x05, 0xA3, 0x16, 0x04, 0xA3, 0xFE, 0x04, 0xA3, 0x02, 0x0E, 0xA7, 
0x05, 0xA3, 0x8A, 0x00, 0xA3, 0x05, 0xA3, 0x0D, 0xA7, 0x32, 0x00, 0xA3, 
0x72, 0x00, 0xA5, 0x72, 0x00, 0xA3, 0x0E, 0x03, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x8A, 0x00, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x07, 0xA3, 0x2E, 0x00, 
0xA3, 0x6E, 0x00, 0xA3, 0x05, 0xA3, 0x6E, 0x00, 0xA3, 0x0E, 0x03, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA7, 0x07, 0xA7, 0x05, 0xA5, 
0x0B, 0xA5, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x09, 0xA3, 
0x07, 0xA3, 0x05, 0xA7, 0x03, 0xA5, 0x05, 0xA7, 0x03, 0xA7, 0x03, 0xA5, 
0x07, 0xA5, 0x05, 0xA7, 0x09, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA9, 
0x03, 0xA9, 0x07, 0xA7, 0x03, 0xA7, 0x03, 0xA5, 0x0A, 0x03, 0xA7, 0x05, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x05, 
0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0B, 
0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x07, 
0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x0F, 
0xA5, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x0E, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA9, 
0x05, 0xA7, 0x05, 0xA5, 0x05, 0xA9, 0x07, 0xA3, 0x0B, 0xA7, 0x03, 0xA3, 
0x05, 0xA3, 0x0B, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x05, 0xA5, 0x05, 0xA3, 
0x05, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 
0x26, 0x00, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x0E, 0x03, 0xA3, 0x09, 0xA3, 
0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x0D, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 
0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x0E, 0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA7, 0x05, 
0xA7, 0x03, 0xA7, 0x07, 0xA7, 0x09, 0xA5, 0x07, 0xA7, 0x03, 0xA3, 0x05, 
0xA3, 0x0D, 0xA7, 0x05, 0xA9, 0x03, 0xA7, 0x05, 0xA5, 0x05, 0xA7, 0x03, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x0F, 0xA5, 0x07, 
0xA9, 0x03, 0xA9, 0x03, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x07, 0xA5, 0xAA, 
0x04, 0xA3, 0x09, 0xA3, 0xEA, 0x04, 0xA3, 0x09, 0xA3, 0x28, 0x44, 0x00, 
0xA3, 0x03, 0xA3, 0x42, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x1A, 0x01, 
0xA3, 0x0F, 0xA3, 0x62, 0x00, 0xA3, 0xFE, 0x02, 0xA3, 0x03, 0xA3, 0x42, 
0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x1A, 0x01, 0xA3, 0x0F, 0xA3, 0x62, 
0x00, 0xA3, 0xFE, 0x02, 0xA3, 0x03, 0xA9, 0x03, 0xA7, 0x05, 0xA5, 0x0D, 
0xA5, 0x05, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA7, 0x03, 
0xA5, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA7, 0x05, 0xA7, 0x0B, 0xA9, 0x03, 
0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA9, 0x05, 0xA7, 0x03, 0xA5, 0x05, 
0xA5, 0x05, 0xA5, 0x07, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA5, 0x05, 
0xA7, 0x05, 0xA9, 0x03, 0xA5, 0x05, 0xA9, 0xDA, 0x02, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 
0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x07, 0xA5, 0x09, 0xA3, 0x0F, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x0B, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 
0x03, 0xA3, 0x07, 0xA3, 0xD6, 0x02, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 
0xA9, 0x0B, 0xA5, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA5, 0x0B, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA5, 0x07, 0xA5, 0x0B, 0xA3, 0x07, 0xAB, 0x05, 0xA3, 0x03, 0xA3, 0x03, 
0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x0B, 
0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA3, 0x07, 
0xAB, 0x03, 0xA3, 0x07, 0xA3, 0xD6, 0x02, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 
0x07, 0xA3, 0x0F, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x07, 0xA3, 0x07, 0xA3, 0x09, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x0D, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 
0x09, 0xA3, 0x0D, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 
0x07, 0xA5, 0x09, 0xA3, 0x07, 0xA3, 0xD6, 0x02, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x09, 0xA7, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x07, 0xA7, 0x03, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xAF, 0x05, 
0xA7, 0x0D, 0xA9, 0x03, 0xA7, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA7, 0x03, 
0xA3, 0x07, 0xA5, 0x05, 0xA7, 0x03, 0xA5, 0x0B, 0xA3, 0x03, 0xA3, 0x07, 
0xA7, 0x03, 0xA3, 0x09, 0xA9, 0x03, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x05, 
0xA3, 0xDE, 0x03, 0xA3, 0x07, 0xA3, 0xF2, 0x04, 0xA7, 0x0E, 0x0E, 0xA9, 
0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x2E, 0x00, 0xA3, 0x07, 0xA3, 0x3E, 
0x00, 0xA3, 0x3E, 0x00, 0xA5, 0x4A, 0x00, 0xA3, 0x62, 0x00, 0xA5, 0x5A, 
0x03, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x2E, 0x00, 0xA3, 0x05, 
0xA3, 0x42, 0x00, 0xA3, 0x3E, 0x00, 0xA3, 0x4E, 0x00, 0xA3, 0x62, 0x00, 
0xA3, 0x5E, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA5, 0x03, 0xA5, 0x05, 0xA5, 
0x0D, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xAB, 0x07, 0xA9, 0x03, 0xA5, 
0x05, 0xA9, 0x07, 0xAB, 0x07, 0xA5, 0x05, 0xA9, 0x05, 0xA7, 0x05, 0xA5, 
0x07, 0xA7, 0x05, 0xA9, 0x05, 0xA9, 0x07, 0xA3, 0x03, 0xA5, 0x03, 0xA5, 
0x07, 0xA9, 0x32, 0x03, 0xA9, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x0B, 0xA5, 0x03, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x0B, 
0xA3, 0x0F, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x2E, 
0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA9, 0x0B, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xAB, 
0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA9, 0x03, 0xA3, 
0x07, 0xA3, 0x03, 0xA5, 0x07, 0xA3, 0x0B, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x03, 0xA9, 0x05, 0xA3, 
0x07, 0xA3, 0x2E, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x22, 0x00, 0xA3, 0x07, 0xA5, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 
0x09, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x03, 0xA3, 0x0B, 0xA3, 0x07, 0xA3, 0x2E, 0x03, 0xA9, 0x03, 0xA3, 0x05, 
0xA5, 0x03, 0xA5, 0x05, 0xA7, 0x0B, 0xA3, 0x07, 0xA3, 0x03, 0xAB, 0x07, 
0xA3, 0x05, 0xA9, 0x03, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xAB, 0x07, 
0xA7, 0x03, 0xA3, 0x07, 0xA9, 0x07, 0xA5, 0x09, 0xA7, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA9, 0x03, 0xA3, 0x05, 0xA7, 0x05, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x1C, 0x4B, 0x00, 0xA3, 0x76, 0x02, 0xA3, 0x9A, 0x00, 
0xA3, 0x2A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x96, 0x00, 0xA3, 0x6E, 
0x00, 0xA3, 0x0F, 0xA3, 0x46, 0x00, 0xA3, 0x26, 0x00, 0xA3, 0x07, 0xA3, 
0x3A, 0x00, 0xA3, 0x3E, 0x02, 0xA3, 0x9A, 0x00, 0xA3, 0x2A, 0x00, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x26, 0x01, 0xA3, 0x6E, 0x00, 0xA3, 0x8A, 0x02, 
0xA3, 0x07, 0xA7, 0x0D, 0xA5, 0x07, 0xA7, 0x05, 0xA9, 0x05, 0xA7, 0x05, 
0xA7, 0x05, 0xA3, 0x03, 0xA7, 0x0F, 0xA5, 0x05, 0xA9, 0x05, 0xA7, 0x05, 
0xA3, 0x05, 0xA3, 0x07, 0xA7, 0x05, 0xA5, 0x07, 0xAB, 0x07, 0xA3, 0x03, 
0xA3, 0x05, 0xA5, 0x05, 0xA7, 0x05, 0xA5, 0x09, 0xA7, 0x07, 0xA7, 0x03, 
0xA3, 0x07, 0xA7, 0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA9, 0x05, 0xA5, 0x05, 
0xA3, 0x05, 0xA7, 0x09, 0xA5, 0x05, 0xA5, 0x07, 0xA5, 0x05, 0xA9, 0x05, 
0xA3, 0x05, 0xA5, 0x05, 0xA7, 0x1A, 0x02, 0xA3, 0x0D, 0xA3, 0x09, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x09, 0xA3, 
0x07, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x0F, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 
0x07, 0xA3, 0x05, 0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x07, 0xA3, 0x05, 0xA3, 0x0D, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 
0x09, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 
0x03, 0xA3, 0x0B, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x09, 0xA3, 0x16, 0x02, 0xA3, 0x09, 0xA7, 0x09, 0xA3, 0x09, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x05, 0xA7, 0x0D, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 
0xA5, 0x09, 0xA3, 0x07, 0xA9, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 
0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA9, 0x09, 0xA7, 0x05, 0xA5, 0x05, 
0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x07, 0xA5, 0x09, 
0xA3, 0x07, 0xA7, 0x07, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x09, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x0B, 0xA7, 0x16, 0x02, 0xA3, 0x07, 0xA3, 
0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 
0x05, 0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 
0x03, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 
0x09, 0xA3, 0x03, 0xA3, 0x0B, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 
0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 
0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x16, 0x02, 0xA9, 0x03, 
0xA7, 0x0B, 0xA5, 0x07, 0xA7, 0x05, 0xA3, 0x07, 0xA9, 0x07, 0xA7, 0x05, 
0xA3, 0x05, 0xA7, 0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x05, 0xA7, 0x05, 
0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x09, 0xA7, 0x05, 0xA9, 0x03, 0xA9, 0x03, 
0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x09, 0xA7, 0x09, 0xA7, 0x03, 0xA7, 0x05, 
0xA3, 0x05, 0xA7, 0x05, 0xA5, 0x05, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA5, 0x05, 0xA3, 0x07, 0xA7, 0x07, 0xA5, 0x05, 0xA7, 0x05, 0xA5, 0x05, 
0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA5, 0x07, 0xA7, 0x05, 0xA3, 0x62, 
0x03, 0xA3, 0xFE, 0x04, 0xA3, 0xDE, 0x0D, 0xA3, 0x07, 0xA3, 0x72, 0x00, 
0xA3, 0x5A, 0x00, 0xA3, 0x0F, 0xA3, 0x36, 0x00, 0xA3, 0x86, 0x00, 0xA3, 
0x3E, 0x00, 0xA3, 0x26, 0x00, 0xA3, 0x03, 0xA3, 0x32, 0x00, 0xA3, 0x9A, 
0x02, 0xA3, 0x07, 0xA3, 0x72, 0x00, 0xA3, 0xB2, 0x00, 0xA3, 0x86, 0x00, 
0xA3, 0x3E, 0x00, 0xA3, 0x26, 0x00, 0xA3, 0x3A, 0x00, 0xA3, 0x9A, 0x02, 
0xA3, 0x07, 0xA3, 0x05, 0xA7, 0x05, 0xA7, 0x03, 0xA5, 0x07, 0xA5, 0x0B, 
0xA7, 0x05, 0xA3, 0x0B, 0xA7, 0x05, 0xA5, 0x05, 0xA9, 0x05, 0xA3, 0x03, 
0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA7, 0x0B, 0xA9, 0x05, 0xA5, 0x0B, 
0xA7, 0x05, 0xA7, 0x05, 0xA9, 0x05, 0xA7, 0x05, 0xAB, 0x05, 0xA5, 0x0B, 
0xA7, 0x05, 0xA3, 0x0B, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 
0xA9, 0x03, 0xA5, 0x05, 0xA5, 0x86, 0x02, 0xA3, 0x07, 0xA3, 0x0B, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0F, 0xA3, 
0x03, 0xA3, 0x09, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 
0x07, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 
0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x0F, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x82, 0x02, 0xA3, 0x07, 0xA3, 0x07, 
0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x0B, 0xA7, 0x03, 
0xA3, 0x0B, 0xA5, 0x05, 0xA9, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x07, 
0xA3, 0x03, 0xA9, 0x09, 0xA5, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA9, 0x0B, 0xA7, 0x03, 
0xA3, 0x09, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x07, 
0xA5, 0x05, 0xA9, 0x82, 0x02, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x0F, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x0F, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 
0x07, 0xA3, 0x03, 0xA3, 0x26, 0x00, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x0F, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x8E, 0x02, 0xAB, 
0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x0B, 0xA7, 
0x03, 0xA3, 0x09, 0xA7, 0x07, 0xA7, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 
0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA7, 0x0B, 0xA9, 0x05, 0xA7, 0x07, 0xA7, 
0x07, 0xA7, 0x05, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA7, 
0x0B, 0xA7, 0x03, 0xA3, 0x0B, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA7, 
0x03, 0xA3, 0x07, 0xA7, 0x05, 0xA7, 0x05, 0xA3, 0xFE, 0x03, 0xA3, 0xFE, 
0x04, 0xA3, 0x94, 0x44, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x4A, 0x00, 
0xA3, 0x32, 0x00, 0xA3, 0x09, 0xA3, 0x8E, 0x00, 0xA5, 0x76, 0x00, 0xA3, 
0x46, 0x00, 0xA3, 0x02, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x4A, 0x00, 
0xA3, 0x32, 0x00, 0xA3, 0xA2, 0x00, 0xA3, 0x7A, 0x00, 0xA3, 0x4E, 0x03, 
0xA5, 0x05, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA9, 0x03, 
0xA7, 0x0B, 0xA9, 0x03, 0xA3, 0x07, 0xA7, 0x05, 0xA7, 0x05, 0xA9, 0x03, 
0xA9, 0x05, 0xA7, 0x0B, 0xAB, 0x0B, 0xA7, 0x03, 0xA5, 0x05, 0xA7, 0x05, 
0xA9, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA9, 0x03, 
0xA9, 0x03, 0xA3, 0x05, 0xA7, 0x05, 0xA9, 0x05, 0xA5, 0xCE, 0x02, 0xA3, 
0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 
0x07, 0xA3, 0x07, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x09, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x07, 0xA3, 
0x07, 0xA5, 0x0B, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x07, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x05, 0xA3, 0xC6, 0x02, 0xA5, 0x05, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 0x07, 0xA3, 0x03, 0xA7, 0x09, 
0xA3, 0x07, 0xA5, 0x07, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x07, 0xA3, 0x07, 0xA5, 0x0B, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 
0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xAB, 0xC2, 0x02, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 
0x07, 0xA5, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x0B, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x07, 0xA3, 
0x07, 0xA5, 0x0B, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 
0x07, 0xA5, 0x09, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 
0xCE, 0x02, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 
0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA7, 0x09, 0xA9, 0x03, 0xA3, 0x05, 
0xA7, 0x07, 0xA7, 0x05, 0xA9, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA7, 0x0B, 
0xAB, 0x0B, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA9, 0x03, 0xA5, 0x05, 0xA7, 0x03, 0xA3, 0x07, 0xAB, 0x03, 
0xA3, 0x05, 0xA7, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA7, 0x05, 0xA3, 0x92, 
0x03, 0xA3, 0x07, 0xA3, 0xF2, 0x04, 0xA7, 0x42, 0x0E, 0xA7, 0x03, 0xA3, 
0x0B, 0xA3, 0x7E, 0x00, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x3A, 0x00, 0xA3, 
0x0D, 0xA3, 0x6E, 0x00, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x32, 0x00, 0xA3, 
0x05, 0xA3, 0x16, 0x03, 0xA3, 0x07, 0xA5, 0x96, 0x00, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x52, 0x00, 0xA3, 0x6A, 0x00, 0xA3, 0x07, 0xA5, 
0x3E, 0x00, 0xA3, 0x22, 0x03, 0xA3, 0x09, 0xA9, 0x05, 0xA3, 0x03, 0xA7, 
0x07, 0xA7, 0x03, 0xA5, 0x05, 0xA7, 0x05, 0xA7, 0x03, 0xA5, 0x0B, 0xA3, 
0x09, 0xA3, 0x03, 0xA3, 0x09, 0xA7, 0x05, 0xA7, 0x03, 0xA3, 0x05, 0xA7, 
0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA9, 0x05, 0xAF, 0x0D, 0xA3, 0x09, 0xA3, 
0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA9, 0x05, 0xA5, 0x03, 0xA3, 0x16, 0x03, 
0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x09, 
0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x09, 0xA3, 0x09, 0xA3, 0x03, 
0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x07, 
0xA3, 0x09, 0xA3, 0x0B, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x16, 0x03, 0xA3, 
0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x05, 0xA9, 0x09, 0xA3, 0x09, 0xA7, 
0x09, 0xA5, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA3, 0x05, 0xA9, 
0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x07, 0xA7, 0x0B, 0xA3, 0x09, 0xA3, 
0x05, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x16, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x0F, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x0B, 0xA3, 0x09, 
0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x07, 0xA5, 0x05, 
0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x1A, 
0x03, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA7, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x07, 0xA7, 0x09, 0xA3, 
0x07, 0xA3, 0x07, 0xA3, 0x05, 0xA7, 0x05, 0xA7, 0x05, 0xA3, 0x03, 0xA7, 
0x05, 0xA5, 0x05, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA9, 0x03, 0xA7, 
0x0D, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA5, 0x03, 0xA3, 0x05, 0xA3, 0x8C, 0x4D, 0x00, 0xA3, 0x09, 0xA3, 
0x0B, 0xA3, 0x3A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x7A, 0x00, 0xA5, 
0x46, 0x00, 0xA3, 0x05, 0xA3, 0x1E, 0x01, 0xA3, 0x6A, 0x00, 0xA3, 0x22, 
0x02, 0xA3, 0x09, 0xA3, 0x0B, 0xA3, 0x3A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x7A, 0x00, 0xA3, 0x4A, 0x00, 0xA3, 0x2A, 0x01, 0xA3, 0x6A, 0x00, 
0xA3, 0x26, 0x02, 0xA3, 0x05, 0xA3, 0x03, 0xA7, 0x05, 0xA5, 0x03, 0xA7, 
0x03, 0xA5, 0x0F, 0xA5, 0x05, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 
0x07, 0xA9, 0x07, 0xA5, 0x09, 0xA5, 0x05, 0xA7, 0x05, 0xA9, 0x05, 0xA5, 
0x05, 0xA5, 0x03, 0xA3, 0x07, 0xA7, 0x03, 0xA9, 0x05, 0xA9, 0x05, 0xA5, 
0x0B, 0xA9, 0x03, 0xA7, 0x07, 0xA7, 0x0B, 0xA5, 0x07, 0xA7, 0x03, 0xA7, 
0x03, 0xA7, 0x03, 0xA5, 0x07, 0xA5, 0x05, 0xA5, 0x05, 0xA5, 0x05, 0xA7, 
0x03, 0xA5, 0x07, 0xA5, 0x05, 0xA9, 0x05, 0xA5, 0x22, 0x02, 0xA3, 0x05, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x0F, 
0xA3, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA5, 0x09, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x09, 0xA3, 0x07, 
0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x0F, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x26, 0x02, 0xA3, 
0x05, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA9, 0x0D, 0xA5, 
0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA5, 0x09, 0xA3, 0x07, 0xA3, 
0x03, 0xA9, 0x07, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 
0x09, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xAB, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA7, 0x05, 0xA5, 0x0B, 0xA3, 
0x09, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x09, 0xA3, 
0x05, 0xA9, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 
0x07, 0xA3, 0x03, 0xA3, 0x2A, 0x02, 0xA5, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x22, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x0D, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x0F, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x09, 0xA3, 0x09, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x2A, 0x02, 0xA5, 0x05, 
0xA7, 0x05, 0xA5, 0x03, 0xA3, 0x07, 0xA7, 0x0B, 0xA3, 0x05, 0xA3, 0x03, 
0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x05, 
0xA7, 0x07, 0xA3, 0x07, 0xA7, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x05, 
0xA5, 0x03, 0xA3, 0x07, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA7, 0x09, 0xA9, 0x05, 0xA7, 0x03, 0xA7, 0x0D, 0xA5, 0x07, 
0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x07, 0xA7, 0x05, 0xA5, 0x05, 0xA5, 0x05, 
0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA5, 0x05, 0xA3, 0xCE, 0x03, 0xA3, 0xFE, 0x04, 0xA3, 0x4A, 
0x0A, 0xA3, 0xA2, 0x00, 0xA3, 0x5E, 0x02, 0xA3, 0x09, 0xA3, 0x2A, 0x00, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x7A, 0x00, 0xA3, 0x32, 0x00, 0xA3, 0x36, 
0x00, 0xA3, 0x2E, 0x00, 0xA5, 0x6E, 0x00, 0xA3, 0x0F, 0xA3, 0x09, 0xA3, 
0x3A, 0x00, 0xA3, 0x05, 0xA3, 0x32, 0x00, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 
0x4E, 0x02, 0xA3, 0x09, 0xA3, 0x36, 0x00, 0xA3, 0x03, 0xA3, 0x7A, 0x00, 
0xA3, 0x32, 0x00, 0xA3, 0x36, 0x00, 0xA3, 0x2A, 0x00, 0xA3, 0x05, 0xA3, 
0x6A, 0x00, 0xA3, 0x32, 0x00, 0xA3, 0x3A, 0x00, 0xA3, 0x3E, 0x00, 0xA3, 
0x0F, 0xA3, 0x52, 0x02, 0xA3, 0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA3, 0x07, 
0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA9, 0x09, 0xA5, 0x07, 
0xA7, 0x03, 0xA9, 0x05, 0xA5, 0x03, 0xA7, 0x07, 0xA5, 0x05, 0xA5, 0x05, 
0xA5, 0x05, 0xA7, 0x07, 0xA3, 0x05, 0xA5, 0x0D, 0xA3, 0x09, 0xA3, 0x07, 
0xAB, 0x05, 0xA9, 0x05, 0xA7, 0x05, 0xAB, 0x09, 0xA7, 0x09, 0xA3, 0x05, 
0xA7, 0x0B, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA9, 0x05, 
0xA5, 0x05, 0xA5, 0x05, 0xA3, 0x05, 0xA5, 0x42, 0x02, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x0B, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x0B, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x0D, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x22, 0x00, 0xA3, 0x07, 
0xA3, 0x0B, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x3E, 0x02, 0xA3, 0x05, 0xA3, 
0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA9, 
0x05, 0xA3, 0x0B, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA7, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x0B, 0xA3, 
0x03, 0xA9, 0x22, 0x00, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0D, 0xA7, 0x07, 
0xA3, 0x07, 0xA7, 0x07, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x03, 0xA9, 0x42, 
0x02, 0xA5, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x09, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 
0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x0B, 0xA3, 0x03, 0xA3, 0x22, 0x00, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x05, 0xA3, 0x07, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 
0xA3, 0x03, 0xA3, 0x4E, 0x02, 0xA5, 0x07, 0xA7, 0x05, 0xAB, 0x05, 0xA3, 
0x03, 0xA3, 0x07, 0xA7, 0x03, 0xA9, 0x09, 0xA5, 0x07, 0xA7, 0x03, 0xA3, 
0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA7, 0x05, 0xA5, 0x05, 0xA5, 0x05, 0xA7, 
0x03, 0xA3, 0x0B, 0xA3, 0x05, 0xA7, 0x0D, 0xA5, 0x07, 0x22, 0xA0, 0x05, 
0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA5, 0x0B, 0xA7, 0x07, 0xA3, 0x07, 
0xA7, 0x09, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA5, 0x05, 0xA7, 0x03, 0xA3, 0x05, 0xA7, 0x05, 0xA3, 0xBE, 
0x03, 0xA3, 0x0B, 0xA3, 0xE6, 0x04, 0xA3, 0x0B, 0xA3, 0x5C, 0x3F, 0x00, 
0x2A, 0xA0, 0x09, 0xAD, 0x22, 0x00, 0xA5, 0x26, 0x00, 0xA5, 0x05, 0xA7, 
0x07, 0xA5, 0x03, 0xA5, 0x0F, 0xA5, 0x2A, 0x00, 0xA5, 0x0D, 0xA5, 0x26, 
0x00, 0xA5, 0x46, 0x00, 0xA5, 0x2E, 0x00, 0xA7, 0x09, 0xAF, 0x56, 0x00, 
0xA5, 0x22, 0x00, 0xA5, 0x05, 0xA7, 0x52, 0x02, 0xA5, 0x22, 0x00, 0xA5, 
0x05, 0xA5, 0x0F, 0xA9, 0x22, 0x00, 0xA5, 0x22, 0x00, 0xA5, 0x03, 0xA5, 
0x0F, 0xA5, 0x05, 0xA7, 0x05, 0xAD, 0x0B, 0xA5, 0x26, 0x00, 0xA5, 0x46, 
0x00, 0xA5, 0x05, 0xA5, 0x07, 0xAB, 0x22, 0x00, 0xA5, 0x03, 0xA5, 0x0D, 
0x26, 0xA0, 0x05, 0x26, 0xA0, 0x0B, 0xA5, 0x62, 0x02, 0xA5, 0x26, 0x00, 
0xAD, 0x0D, 0xA5, 0x05, 0xA5, 0x0B, 0xAB, 0x03, 0xA5, 0x09, 0x26, 0xA0, 
0x07, 0xA5, 0x2A, 0x00, 0xA5, 0x0D, 0xA5, 0x0F, 0xAD, 0x36, 0x00, 0xAD, 
0x03, 0xA5, 0x0B, 0xA5, 0x0D, 0x2A, 0xA0, 0x0F, 0xA5, 0x26, 0x00, 0xA5, 
0x0D, 0xAB, 0x03, 0xA5, 0x4E, 0x02, 0xAD, 0x0D, 0xA5, 0x05, 0xA5, 0x09, 
0x2A, 0xA0, 0x09, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA5, 
0x0F, 0xA5, 0x0F, 0xAF, 0x09, 0xA5, 0x26, 0x00, 0xA5, 0x46, 0x00, 0xA5, 
0x0F, 0x22, 0xA0, 0x07, 0x26, 0xA0, 0x0F, 0xA5, 0x03, 0xA7, 0x09, 0xA9, 
0x0F, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x46, 0x02, 0xA5, 0x03, 0xA5, 0x03, 
0xA5, 0x0B, 0xAD, 0x4A, 0x00, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x0D, 0xA5, 
0x0F, 0xA5, 0x2A, 0x00, 0xA5, 0x0D, 0xA5, 0x22, 0x00, 0xA5, 0x03, 0xAB, 
0x32, 0x00, 0xAD, 0x0D, 0xA5, 0x22, 0x00, 0xA9, 0x03, 0xA5, 0x0D, 0xA5, 
0x22, 0x00, 0xA5, 0x03, 0xA5, 0x0F, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x42, 
0x02, 0xA5, 0x05, 0xA5, 0x05, 0xA5, 0x3E, 0x00, 0x22, 0xA0, 0x0B, 0xA5, 
0x03, 0xA5, 0x03, 0xA5, 0x07, 0x22, 0xA0, 0x09, 0xA5, 0x2A, 0x00, 0xA5, 
0x0D, 0xA5, 0x22, 0x00, 0xA5, 0x46, 0x00, 0xA7, 0x07, 0xA5, 0x03, 0x2A, 
0xA0, 0x05, 0x26, 0xA0, 0x0D, 0xA5, 0x22, 0x00, 0xA5, 0x03, 0xA5, 0x0F, 
0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x52, 0x02, 0xA5, 0x0D, 0x2A, 0xA0, 0x07, 
0xA5, 0x09, 0xA5, 0x09, 0xA5, 0x05, 0xAB, 0x0D, 0xA5, 0x0F, 0xA5, 0x07, 
0xA5, 0x05, 0xAB, 0x0D, 0xA5, 0x07, 0xA5, 0x07, 0xA5, 0x22, 0x00, 0xA5, 
0x0D, 0xA9, 0x07, 0xA5, 0x0B, 0xA5, 0x0F, 0xA9, 0x03, 0xA5, 0x0F, 0xA5, 
0x26, 0x00, 0xA9, 0x0D, 0xA5, 0x05, 0xAB, 0x52, 0x02, 0xA5, 0x22, 0x00, 
0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x09, 0xA5, 0x09, 0xA5, 0x05, 0xA5, 0x26, 
0x00, 0xA5, 0x0F, 0xA5, 0x05, 0xA5, 0x05, 0xA5, 0x05, 0xA7, 0x0B, 0xA5, 
0x05, 0xA5, 0x07, 0xA5, 0x05, 0xA5, 0x09, 0xA9, 0x0B, 0xAD, 0x03, 0xA5, 
0x0B, 0xA5, 0x22, 0x00, 0xA5, 0x03, 0xA9, 0x0F, 0xA5, 0x2A, 0x00, 0xA5, 
0x0D, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x42, 0x02, 0xA5, 0x0F, 0xA5, 0x09, 
0xA5, 0x09, 0x22, 0xA0, 0x09, 0xAB, 0x0D, 0x2A, 0xA0, 0x09, 0xA9, 0x09, 
0xA9, 0x03, 0xA5, 0x0B, 0xA9, 0x09, 0xA5, 0x05, 0xAB, 0x05, 0xA5, 0x0F, 
0xA7, 0x03, 0xA7, 0x0B, 0xA7, 0x0D, 0xAD, 0x05, 0xA5, 0x0F, 0xA7, 0x0B, 
0xA9, 0x0F, 0xAB, 0x0F, 0xA5, 0xF8, 0x1F, 0x00, 0xA5, 0x4E, 0x00, 0xA5, 
0x7A, 0x00, 0xA5, 0x05, 0xA5, 0x22, 0x00, 0xA5, 0x03, 0xA7, 0x36, 0x00, 
0xA5, 0x0F, 0xA5, 0x2E, 0x00, 0xA5, 0x0D, 0x2A, 0xA0, 0x46, 0x00, 0xA5, 
0x26, 0x00, 0xA5, 0x2E, 0x00, 0xA5, 0x05, 0xA5, 0x0D, 0xA5, 0x0B, 0xA5, 
0x2A, 0x00, 0xA5, 0xE2, 0x01, 0xA5, 0x22, 0x00, 0xAF, 0x09, 0xAD, 0x05, 
0x26, 0xA0, 0x3E, 0x00, 0xA5, 0x05, 0xA5, 0x22, 0x00, 0xA5, 0x03, 0xA7, 
0x36, 0x00, 0xA5, 0x0F, 0xA5, 0x03, 0xAD, 0x09, 0xA5, 0x05, 0xA5, 0x05, 
0xA5, 0x03, 0xA9, 0x03, 0xA5, 0x05, 0xA5, 0x32, 0x00, 0xA9, 0x22, 0x00, 
0xA5, 0x2E, 0x00, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x0D, 0xA5, 0x05, 0xA7, 
0x0B, 0xA5, 0x07, 0xA5, 0xC6, 0x01, 0x22, 0xA0, 0x26, 0x00, 0xA5, 0x07, 
0xA5, 0x07, 0xA5, 0x26, 0x00, 0xA5, 0x3A, 0x00, 0x26, 0xA0, 0x07, 0x22, 
0xA0, 0x3A, 0x00, 0xA5, 0x0F, 0xA5, 0x26, 0x00, 0xAD, 0x03, 0xA5, 0x03, 
0x2A, 0xA0, 0x05, 0xA5, 0x09, 0xA5, 0x0B, 0xA5, 0x05, 0xA5, 0x0B, 0x22, 
0xA0, 0x0F, 0xAF, 0x07, 0xA5, 0x0B, 0xAD, 0x0B, 0x2A, 0xA0, 0x09, 0xA5, 
0xB6, 0x01, 0xA5, 0x05, 0xA5, 0x26, 0x00, 0xA5, 0x07, 0xA5, 0x07, 0xA5, 
0x22, 0x00, 0xA5, 0x42, 0x00, 0xA5, 0x05, 0xA5, 0x22, 0x00, 0xA5, 0x46, 
0x00, 0xA9, 0x0B, 0xA5, 0x2E, 0x00, 0xA5, 0x0D, 0xA5, 0x0D, 0xA5, 0x05, 
0xA5, 0x09, 0xA5, 0x07, 0x2A, 0xA0, 0x0B, 0xA7, 0x05, 0xA5, 0x09, 0xA9, 
0x05, 0xA5, 0x07, 0xA5, 0x22, 0x00, 0xA5, 0x2E, 0x00, 0xA5, 0x05, 0xA5, 
0x09, 0xA5, 0xB6, 0x01, 0xA5, 0x05, 0xA5, 0x22, 0x00, 0xA5, 0x07, 0xA5, 
0x03, 0xA5, 0x03, 0xA5, 0x07, 0xA5, 0x05, 0xA5, 0x09, 0x22, 0xA0, 0x0B, 
0xA5, 0x05, 0xA5, 0x0D, 0xA9, 0x03, 0xA5, 0x07, 0x22, 0xA0, 0x07, 0xA5, 
0x03, 0xA7, 0x07, 0xA5, 0x2E, 0x00, 0xAD, 0x05, 0xA5, 0x03, 0xA9, 0x03, 
0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x46, 0x00, 0xA5, 0x07, 0xA5, 0x0D, 0xA5, 
0x05, 0xA5, 0x07, 0xA5, 0x0F, 0xA5, 0x03, 0xAB, 0x0D, 0xA5, 0x05, 0xA5, 
0x0B, 0xA5, 0xAE, 0x01, 0xA5, 0x07, 0xA5, 0x0F, 0xA7, 0x0F, 0xA7, 0x0B, 
0xA9, 0x4A, 0x00, 0xA5, 0x05, 0xA5, 0x0D, 0xA9, 0x03, 0xA5, 0x3A, 0x00, 
0xA5, 0x0F, 0xA5, 0x2A, 0x00, 0xA7, 0x07, 0xA5, 0x03, 0xA5, 0x03, 0xA9, 
0x03, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x07, 0x22, 0xA0, 0x0B, 0xA7, 0x07, 
0xA5, 0x0D, 0xA5, 0x03, 0xA7, 0x09, 0xA5, 0x0D, 0xA5, 0x26, 0x00, 0xAD, 
0x03, 0xA5, 0x0B, 0xA5, 0xAE, 0x01, 0xA5, 0x07, 0xA5, 0x0D, 0xA5, 0x03, 
0xA5, 0x0F, 0xA5, 0x0D, 0xA5, 0x5E, 0x00, 0xA5, 0x0B, 0xA5, 0x03, 0xA5, 
0x05, 0xA5, 0x36, 0x00, 0xA5, 0x0F, 0xA5, 0x03, 0xA5, 0x0D, 0xA9, 0x07, 
0xA5, 0x03, 0xA5, 0x03, 0xA9, 0x03, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x07, 
0xA5, 0x09, 0xA5, 0x09, 0xA9, 0x07, 0xA5, 0x0D, 0xA5, 0x26, 0x00, 0xA5, 
0x0B, 0xA5, 0x22, 0x00, 0xA5, 0x07, 0xA5, 0x03, 0xA5, 0x0B, 0xA5, 0x07, 
0xA5, 0x9A, 0x01, 0xA5, 0x07, 0xA5, 0x0B, 0xA5, 0x07, 0xA5, 0x09, 0xAB, 
0x0D, 0xA5, 0x56, 0x00, 0xA5, 0x0D, 0xA5, 0x03, 0xA5, 0x05, 0xA5, 0x36, 
0x00, 0xA5, 0x0F, 0xA5, 0x03, 0xAD, 0x05, 0xAD, 0x03, 0xA5, 0x03, 0xA5, 
0x0D, 0xA5, 0x05, 0xA5, 0x03, 0xA5, 0x0F, 0xA5, 0x09, 0xA5, 0x0D, 0xA5, 
0x07, 0xA5, 0x0D, 0xA5, 0x2A, 0x00, 0xA5, 0x07, 0xA5, 0x05, 0xA5, 0x0B, 
0xA5, 0x0D, 0xA5, 0x03, 0xA5, 0x0D, 0xA9, 0x92, 0x01, 0xA5, 0x03, 0xA9, 
0x09, 0xA7, 0x09, 0xA5, 0x05, 0xA7, 0x2A, 0x00, 0xA5, 0x4E, 0x00, 0xA7, 
0x26, 0x00, 0xA7, 0x46, 0x00, 0xA5, 0x0F, 0xA5, 0x2A, 0x00, 0xA7, 0x03, 
0xA7, 0x05, 0xA5, 0x0B, 0xA7, 0x07, 0xA7, 0x22, 0x00, 0x22, 0xA0, 0x0D, 
0xA5, 0x03, 0xA7, 0x22, 0x00, 0xAD, 0x0D, 0xA5, 0x05, 0xA5, 0x05, 0xAB, 
0x07, 0xAB, 0x07, 0xA7, 0x22, 0x00, 0xA5, 0xD4, 0x87, 0x00, 

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\fillrate\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_

// pack the structure as we're reading it from the disk
#pragma pack(1)

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const char* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const char* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const char*     str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\fillrate\fillrate.cpp ===
//-----------------------------------------------------------------------------
// FILE: FILLRATE.CPP
//
// Desc: a stupid fillrate test
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include <assert.h>
#include <d3d8perf.h>

#include "utils.h"
#include "inifile.h"
#include "fillrate.h"


// Define for whether we use the VisibilityTest apis. Note that
// BeginVisibilityTest() will turn off some blend optimizations and
// it doesn't count pixels which aren't drawn due to alpha test or
// the like so we don't use it by default.
#define NO_VIS_TEST

/*
 * globals
 */
IDirect3DDevice8       *g_pDev = NULL;                  // our device
IDirect3DVertexBuffer8 *g_pVB = NULL;                   // our vertex buffer
IDirect3DBaseTexture8  *g_pTexture[4] = { NULL };       // 4 textures
IDirect3DSurface8      *g_pBackBuffer = NULL;

DWORD                   g_ShaderHandle = 0;             // pixel shader handle

DWORD                   g_dwFVFSize;                    // FVF size

UINT                    g_cindices = 0;                 // count of indices
WORD*                   g_pindices = NULL;              // indices allocation

HANDLE                  g_hInpDevice = NULL;            // input device

CScrText                g_scrtext;                      // text helper
CIniFile                g_inifile("d:\\fillrate.ini");  // Ini file

bool                    g_fRedrawScreen = true;         // refresh screen?
bool                    g_fdumpZ = false;               // dump Z val

FRSETTINGS              g_var = {0};                    // current settings

/*
 * Suite of available tests. Selectable via g_iCurTest in ini file
 *  or by using left/right gamepad trigger.
 */
struct
{
    LPCSTR szDesc;
    void (*pfnTest)();
} g_rgTests[] =
{
    { "Current",        DoQuickTimedTest },
    { "MultiSample",    DoMultiSampleTimedTest },
    { "FillRate",       DoCompleteTimedTest },
    { "Texture Test",   DoTextureTest },
};
UINT g_iCurTest = 0;

//=========================================================================
// Init Direct3d
//=========================================================================
bool InitD3D()
{
    static D3DPRESENT_PARAMETERS d3dppCur = {0};
    D3DPRESENT_PARAMETERS d3dpp = {0};

    // Set the screen mode.
    d3dpp.BackBufferWidth                   = g_var.screenwidth;
    d3dpp.BackBufferHeight                  = g_var.screenheight;
    d3dpp.BackBufferFormat                  = g_var.BackBufferFormat;
    d3dpp.BackBufferCount                   = 1;
    d3dpp.EnableAutoDepthStencil            = !!g_var.AutoDepthStencilFormat;
    d3dpp.AutoDepthStencilFormat            = g_var.AutoDepthStencilFormat;
    d3dpp.SwapEffect                        = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz        = 60;
    d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;
    d3dpp.Flags                             = D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;

    if(g_var.MSType != D3DMULTISAMPLE_NONE)
        d3dpp.MultiSampleType = (D3DMULTISAMPLE_TYPE)((DWORD)(g_var.MSType) | (DWORD)(g_var.MSFormat));

    // if nothing has changed - don't reinit
    if(!memcmp(&d3dppCur, &d3dpp, sizeof(D3DPRESENT_PARAMETERS)))
        return true;
    d3dppCur = d3dpp;

    if(g_pDev)
    {
        if(g_ShaderHandle)
        {
            CheckHR(g_pDev->SetPixelShader(0));
            CheckHR(g_pDev->DeletePixelShader(g_ShaderHandle));
            g_ShaderHandle = 0;
        }

        // make sure everything is freed
        RELEASE(g_pVB);
        for(int itex = 0; itex < 4; itex++)
            RELEASE(g_pTexture[itex]);

        RELEASE(g_pBackBuffer);
        RELEASE(g_pDev);
    }

    // Create the device.
    if(Direct3D_CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
        NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDev))
    {
        CheckHR(E_FAIL);
        return false;
    }

    D3DDevice_GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &g_pBackBuffer);
    return true;
}

//=========================================================================
// Fill a volume texture with shtuff
//=========================================================================
void FillTextureBits3D(D3DLOCKED_BOX *plockVol,
    D3DFORMAT d3dFormat, DWORD dwHeight, DWORD dwWidth, DWORD dwDepth)
{
    DWORD dwBits = BitsPerPixelOfD3DFORMAT(d3dFormat);

    assert(!IsLinearFormat(d3dFormat));

    BYTE *pBits = (BYTE *)plockVol->pBits;
    for(DWORD d = 0; d < dwDepth; d++)
    {
        for(DWORD y = 0; y < dwHeight; y++)
        {
            for(DWORD x = 0; x < dwWidth; x++)
            {
                DWORD c = (~y & 1) * (y + 1) * 0xff / dwHeight;
                DWORD c2 = d * 0xff / (dwDepth - 1);

                switch(dwBits)
                {
                case 4:
                    x++;
                case 8:
                    *pBits++ = LOBYTE(c);
                    break;
                case 16:
                    *(WORD *)pBits = MAKEWORD(c2, c);
                    pBits += 2;
                    break;
                case 32:
                    *(DWORD *)pBits = D3DCOLOR_ARGB(0x0, c, c, c);
                    pBits += 4;
                    break;
                default:
                    CheckHR(E_FAIL);
                    break;
                }
            }
        }
    }
}

//=========================================================================
// Fill a 2D cubemap face or texture with shtuff
//=========================================================================
void FillTextureBits(D3DLOCKED_RECT *plockRect,
    D3DFORMAT d3dFormat, DWORD dwHeight, DWORD dwWidth)
{
    bool fIsLinear = IsLinearFormat(d3dFormat);
    DWORD dwBits = BitsPerPixelOfD3DFORMAT(d3dFormat);
    DWORD dwLine = (DWORD)plockRect->pBits;

    for (DWORD y = 0; y < dwHeight; y++)
    {
        DWORD dwAddr = dwLine;
        DWORD c = (~y & 1) * (y + 1) * 0xff / dwHeight;

        for (DWORD x = 0; x < dwWidth; x++)
        {
            switch(dwBits)
            {
            case 4:
                *(BYTE *)dwAddr = LOBYTE(c);
                dwAddr += 1;
                x++;
                break;
            case 8:
                *(BYTE *)dwAddr = LOBYTE(c);
                dwAddr += 1;
                break;
            case 16:
                *(WORD *)dwAddr = MAKEWORD(c, c);
                dwAddr += 2;
                break;
            case 32:
                *(DWORD *)dwAddr = D3DCOLOR_ARGB(0x0, c, c, c);
                dwAddr += 4;
                break;
            }
        }

        // pitch is only valid for linear textures
        if(fIsLinear)
            dwLine += plockRect->Pitch;
        else
            dwLine += dwWidth * dwBits / 8;
    }
}

//=========================================================================
// Create a texture
//=========================================================================
IDirect3DBaseTexture8 *MyCreateTexture(D3DRESOURCETYPE d3dtype,
    D3DFORMAT d3dFormat, DWORD dwWidth, DWORD dwHeight, DWORD Levels)
{
    IDirect3DBaseTexture8 *pTexRet = NULL;

    if(d3dtype == D3DRTYPE_TEXTURE)
    {
        D3DLOCKED_RECT lockRect;
        IDirect3DTexture8 *pTexture = NULL;

        CheckHR(g_pDev->CreateTexture(dwWidth, dwHeight, Levels, 0, d3dFormat,
            D3DPOOL_MANAGED, &pTexture));

        for(DWORD ilevel = 0; ilevel < pTexture->GetLevelCount(); ilevel++)
        {
            CheckHR(pTexture->LockRect(ilevel, &lockRect, NULL, 0));
            FillTextureBits(&lockRect, d3dFormat, dwHeight, dwWidth);
            CheckHR(pTexture->UnlockRect(ilevel));
        }

        pTexRet = pTexture;
    }
    else if(d3dtype == D3DRTYPE_CUBETEXTURE)
    {
        D3DLOCKED_RECT lockRect;
        IDirect3DCubeTexture8 *pCubeTexture = NULL;

        CheckHR(g_pDev->CreateCubeTexture(dwWidth, Levels, 0, d3dFormat,
            D3DPOOL_MANAGED, &pCubeTexture));

        for(DWORD ilevel = 0; ilevel < pCubeTexture->GetLevelCount(); ilevel++)
        {
            for(int iFace = 0; iFace < D3DCUBEMAP_FACE_NEGATIVE_Z; iFace++)
            {
                D3DCUBEMAP_FACES cmFace = (D3DCUBEMAP_FACES)iFace;

                CheckHR(pCubeTexture->LockRect(cmFace, ilevel, &lockRect, NULL, 0));
                FillTextureBits(&lockRect, d3dFormat, dwHeight, dwWidth);
                CheckHR(pCubeTexture->UnlockRect(cmFace, ilevel));
            }
        }

        pTexRet = pCubeTexture;
    }
    else
    {
        assert(d3dtype == D3DRTYPE_VOLUMETEXTURE);

        D3DLOCKED_BOX lockVol;
        IDirect3DVolumeTexture8 *pVolumeTexture = NULL;

        CheckHR(g_pDev->CreateVolumeTexture(dwWidth, dwHeight, dwHeight, Levels, 0,
            d3dFormat, D3DPOOL_MANAGED, &pVolumeTexture));

        for(DWORD ilevel = 0; ilevel < pVolumeTexture->GetLevelCount(); ilevel++)
        {
            CheckHR(pVolumeTexture->LockBox(ilevel, &lockVol, NULL, 0));
            FillTextureBits3D(&lockVol, d3dFormat, dwHeight, dwWidth, dwWidth);
            CheckHR(pVolumeTexture->UnlockBox(ilevel));
        }

        pTexRet = pVolumeTexture;
    }

   return pTexRet;
}

//=========================================================================
// Create a quadlist vb with X quads and decreasing z values
//=========================================================================
void CreateQuadList(int nquads)
{
    RELEASE(g_pVB);

    if(g_cindices)
    {
        delete [] g_pindices;
        g_cindices = 0;
    }

    g_dwFVFSize = D3DXGetFVFVertexSize(g_var.FVF);

    if(g_var.verboselevel >= 2)
        dprintf("FVF:0x%08lx, FVFSize: %d\n", g_var.FVF, g_dwFVFSize);

    UINT VBLength = g_dwFVFSize * 4 * nquads;

    CheckHR(g_pDev->CreateVertexBuffer(VBLength,
        D3DUSAGE_WRITEONLY, g_var.FVF, D3DPOOL_MANAGED, &g_pVB));

    float *pVerts;
    CheckHR(g_pVB->Lock(0, g_dwFVFSize, (BYTE **)&pVerts, 0));

    float texscale = g_var.rgtex[0].type && IsLinearFormat(g_var.rgtex[0].d3dFormat) ?
        g_var.rgtex[0].texsize : 1.0f;

    float dz = 1.0f / (nquads * 2);
    float zval = 1.0f - dz;
    for(int iquad = 0; iquad < nquads; iquad++, zval -= dz)
    {
        for(int y = 0; y <= 1; y++)
        {
            for(int x = 0; x <= 1; x++)
            {
                D3DXVECTOR4 pos;
                D3DXVECTOR4 tex0;

                // position
                pos.x = g_var.quadx + x * g_var.quadwidth;
                pos.y = g_var.quady + y * g_var.quadheight;
                pos.z = g_var.tiltz ? y : zval;
                pos.w = 1.0f;

                // texture coordinates
                if(g_var.rotatetex)
                {
                    tex0.x = (1.0f - y) * texscale;
                    tex0.y = x * texscale;
                }
                else
                {
                    tex0.x = x * texscale;
                    tex0.y = y * texscale;
                }
                tex0.z = (1.0f - x) * texscale;
                tex0.w = 1.0f;

                // diffuse color
                DWORD diffuse = D3DCOLOR_COLORVALUE(tex0.x,
                    tex0.y, 1.0f - tex0.x, 2.0f / 0xff);

                if(g_var.FVF & D3DFVF_XYZRHW)
                {
                    *(D3DXVECTOR4 *)pVerts = pos;
                    pVerts += 4;
                }
                else if(g_var.FVF & D3DFVF_XYZ)
                {
                    *(D3DXVECTOR3 *)pVerts = *(D3DXVECTOR3 *)&pos;
                    pVerts += 3;
                }

                if(g_var.FVF & D3DFVF_NORMAL)
                {
                    *(D3DXVECTOR3 *)pVerts = D3DXVECTOR3(0, .707f, .707f);
                    pVerts += 3;
                }

                if(g_var.FVF & D3DFVF_DIFFUSE)
                    *(DWORD *)pVerts++ = diffuse;

                if(g_var.FVF & D3DFVF_SPECULAR)
                    *(DWORD *)pVerts++ = ~diffuse;

                // Texture coordinates
                UINT uNumTexCoords = (((g_var.FVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT);
                UINT uTextureFormats = g_var.FVF >> 16;

                if(uTextureFormats)
                {
                    for(UINT i = 0; i < uNumTexCoords; i++)
                    {
                        switch(uTextureFormats & 3)
                        {
                        case D3DFVF_TEXTUREFORMAT1:     // u
                            *pVerts++ = tex0.x;
                            break;
                        case D3DFVF_TEXTUREFORMAT2:     // u,v
                            *(D3DXVECTOR2 *)pVerts = *(D3DXVECTOR2 *)&tex0;
                            pVerts += 2;
                            break;
                        case D3DFVF_TEXTUREFORMAT3:     // s,t,r
                            *(D3DXVECTOR3 *)pVerts = *(D3DXVECTOR3 *)&tex0;
                            pVerts += 3;
                            break;
                        case D3DFVF_TEXTUREFORMAT4:     // s,t,r,q
                            *(D3DXVECTOR4 *)pVerts = tex0;
                            pVerts += 4;
                            break;
                        }

                        uTextureFormats >>= 2;
                    }
                }
                else while(uNumTexCoords--)
                {
                    // u,v
                    *(D3DXVECTOR2 *)pVerts = *(D3DXVECTOR2 *)&tex0;
                    pVerts += 2;
                }
            }
        }
    }

    CheckHR(g_pVB->Unlock());
    g_pVB->MoveResourceMemory(D3DMEM_VIDEO);

    // create out index buffer
    g_cindices = nquads * 4;
    g_pindices = new WORD [g_cindices];

    WORD *pindices = g_pindices;

    for(iquad = 0; iquad < nquads; iquad++)
    {
        *pindices++ = iquad * 4 + 0;
        *pindices++ = iquad * 4 + 1;
        *pindices++ = iquad * 4 + 3;
        *pindices++ = iquad * 4 + 2;
    }
}

//=========================================================================
// Initialize fillrate app
//=========================================================================
bool InitFR(bool freadINIFile)
{
    if(freadINIFile && !ReadFRIniFile())
        dprintf("%s not found.\n", g_inifile.GetFileName());

    // init d3d
    if(!InitD3D())
    {
        dprintf("InitD3D failed.\n");
        return false;
    }

    CheckHR(g_pDev->SetRenderState(D3DRS_SPECULARENABLE, g_var.specularenable));

    CheckHR(g_pDev->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE));

    CheckHR(g_pDev->SetRenderState(D3DRS_SWATHWIDTH, g_var.SwathWidth));
    CheckHR(g_pDev->SetRenderState(D3DRS_FILLMODE, g_var.d3dfillmode));
    CheckHR(g_pDev->SetRenderState(D3DRS_COLORWRITEENABLE, g_var.colorwriteenable));

    CheckHR(g_pDev->SetRenderState(D3DRS_ZENABLE, g_var.zenable));
    CheckHR(g_pDev->SetRenderState(D3DRS_ZWRITEENABLE, g_var.zwriteenable));
    CheckHR(g_pDev->SetRenderState(D3DRS_ZFUNC, g_var.d3dcmpfunc));

    CheckHR(g_pDev->SetRenderState(D3DRS_ALPHABLENDENABLE, g_var.alphablendenable));
    CheckHR(g_pDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA));
    CheckHR(g_pDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA));

    CheckHR(g_pDev->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD));

    CheckHR(g_pDev->SetRenderState(D3DRS_ALPHATESTENABLE, g_var.alphatestenable));
    CheckHR(g_pDev->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL));
    CheckHR(g_pDev->SetRenderState(D3DRS_ALPHAREF, 0x00000001));

    if(g_var.userpixelshader)
        CheckHR(g_pDev->CreatePixelShader(&g_var.shaderdef, &g_ShaderHandle));

    for(int itex = 0; itex < 4; itex++)
    {
        RELEASE(g_pTexture[itex]);

        if(g_var.rgtex[itex].type)
        {
            assert(g_var.rgtex[itex].type < TEX_Max);
            g_var.rgtex[itex].type = min(g_var.rgtex[itex].type, TEX_Max - 1);

            static const D3DRESOURCETYPE rgrestype[] =
                { D3DRTYPE_TEXTURE, D3DRTYPE_CUBETEXTURE, D3DRTYPE_VOLUMETEXTURE };
            assert(TEX_2d == 1 && TEX_Cubemap == 2 && TEX_Volume == 3);

            g_pTexture[itex] = MyCreateTexture(
                rgrestype[g_var.rgtex[itex].type - 1],
                g_var.rgtex[itex].d3dFormat,
                g_var.rgtex[itex].texsize,
                g_var.rgtex[itex].texsize,
                (g_var.rgtex[itex].mipfilter != D3DTEXF_NONE) ? 0 : 1);

            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_MINFILTER, g_var.rgtex[itex].filtertype));
            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_MAGFILTER, g_var.rgtex[itex].filtertype));
            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_MIPFILTER, g_var.rgtex[itex].mipfilter));

            // Set the texture stage states appropriately
            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_COLORARG1, D3DTA_TEXTURE));
            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_COLOROP, g_var.ColorOp));
            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_COLORARG2, D3DTA_DIFFUSE));

            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_ALPHAARG1, D3DTA_TEXTURE));
            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_ALPHAOP, g_var.AlphaOp));
            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE));
        }
        else
        {
            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_COLOROP, D3DTOP_DISABLE));
            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_ALPHAOP, D3DTOP_DISABLE));

            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_MINFILTER, D3DTEXF_LINEAR));
            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_MAGFILTER, D3DTEXF_LINEAR));
            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_MIPFILTER, D3DTEXF_NONE));
        }

        CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP));
        CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP));
    }

    CreateQuadList(g_var.overdraw);
    return true;
}

//=========================================================================
// Dump the first entry in the z buffer
//=========================================================================
void DumpZ()
{
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    IDirect3DSurface8 *pZBuffer = NULL;

    if(!g_var.AutoDepthStencilFormat)
        return;

    CheckHR(g_pDev->GetDepthStencilSurface(&pZBuffer));

    CheckHR(pZBuffer->LockRect(&lockRect, NULL, D3DLOCK_READONLY));
    CheckHR(pZBuffer->GetDesc(&desc));

    DWORD dwVal;
    switch(desc.Format)
    {
    case D3DFMT_LIN_D16:
    case D3DFMT_D16:
        // v = z[15:0]  0.0 to 65535.0
        dprintf("D3DFMT_D16: 0x%08lx", *(WORD *)lockRect.pBits);
        break;
    case D3DFMT_LIN_D24S8:
    case D3DFMT_D24S8:
        // v = z[24:0] 0.0 to 16,777,215.0  (0 to FFFFFF)
        dwVal = (*(DWORD *)lockRect.pBits);
        dprintf("D3DFMT_D24S8: 0x%08lx:%02lx %.2f", dwVal >> 8, LOBYTE(dwVal),
            (dwVal >> 8) / 16777215.0f);
        // 0x3ffffffe, 0x7ffffffe, 0xbffffffe
        // 0.25f, 0.75f, 0.5f
        break;
    case D3DFMT_LIN_F16:
    case D3DFMT_F16:
        // e4m12
        // e = z[15:12]
        // m = z[11:0]
        // value = 2^(e-7) * (1 + m/4096)
        // value = 0.0 when e == 0 and m == 0
        dprintf("D3DFMT_F16: 0x%08lx", *(WORD *)lockRect.pBits);
        break;
    case D3DFMT_LIN_F24S8:
    case D3DFMT_F24S8:
        // e8m16
        // e = z[23:16]
        // m = z[15:0]
        // value = 2^(e-127) * (1 + m/65536)
        // value = 0.0 when e == 0 and m == 0
        dprintf("D3DFMT_F24S8: 0x%08lx", *(DWORD *)lockRect.pBits);
        break;
    }

    pZBuffer->UnlockRect();

    RELEASE(pZBuffer);
}

//=========================================================================
// render the quads X # of times
//=========================================================================
void RenderFrame(int overdraw)
{
    UINT coverdrawverts = overdraw * 4;

    // clear stuff
    DWORD dwCFlags = g_var.clearflags;
    if(!g_var.AutoDepthStencilFormat)
        dwCFlags &= ~(D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL);

    CheckHR(g_pDev->Clear(0, NULL, dwCFlags, g_var.cclearval,
        g_var.zclearval, g_var.sclearval));

    // begin scene
    CheckHR(g_pDev->BeginScene());

    // set textures
    for(int itex = 0; itex < 4; itex++)
        CheckHR(g_pDev->SetTexture(itex, g_pTexture[itex]));

    CheckHR(g_pDev->SetVertexShader(g_var.FVF));
    CheckHR(g_pDev->SetStreamSource(0, g_pVB, g_dwFVFSize));

    CheckHR(g_pDev->SetPixelShader(g_ShaderHandle));

    if(g_var.zenable && g_var.primez)
    {
        // prime the z buffer to 0.5f
        CheckHR(g_pDev->SetRenderState(D3DRS_ZFUNC, g_var.primezcmpfunc));
        CheckHR(g_pDev->SetRenderState(D3DRS_ZWRITEENABLE, TRUE));

        // draw one quad (not the first one) to prime the z buffer
        CheckHR(g_pDev->DrawIndexedVertices(D3DPT_QUADLIST, 4, g_pindices + 4));
        coverdrawverts -= 4;

        CheckHR(g_pDev->SetRenderState(D3DRS_ZFUNC, g_var.d3dcmpfunc));
        CheckHR(g_pDev->SetRenderState(D3DRS_ZWRITEENABLE, g_var.zwriteenable));
    }

    while(coverdrawverts)
    {
        UINT VertexCount = min(g_cindices, coverdrawverts);
        CheckHR(g_pDev->DrawIndexedVertices(D3DPT_QUADLIST, VertexCount, g_pindices));

        coverdrawverts -= VertexCount;
    }

    if(g_fdumpZ)
        DumpZ();

    CheckHR(g_pDev->EndScene());
}

//=========================================================================
// Handle joystick input
//=========================================================================
void HandleInput(DWORD dwTicks)
{
    static BOOL fRunTestRightNow = FALSE;

    if(g_inifile.FileChanged())
    {
        dprintf("g_inifile.FileChanged()\n");
        InitFR(true);

        fRunTestRightNow = g_var.runtestonreload;

        g_fRedrawScreen = true;
    }

    // If we don't have a device don't let them start any tests.
    // They're going to have to change their settings in fillrate.ini
    // and just try again.
    if(!g_pDev)
        return;

    if(!g_hInpDevice)
        g_hInpDevice = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL);

    if(g_hInpDevice)
    {
        XINPUT_STATE xinpstate = {0};
        static XINPUT_STATE xinpstatelast;
#define FButtonDown(_btn) \
        (xinpstate.Gamepad.bAnalogButtons[_btn] && \
            (!xinpstate.Gamepad.bAnalogButtons[_btn] != !xinpstatelast.Gamepad.bAnalogButtons[_btn]))

        XInputGetState(g_hInpDevice, &xinpstate);

        if(fRunTestRightNow || FButtonDown(XINPUT_GAMEPAD_A))
        {
            fRunTestRightNow = FALSE;

            // run current test
            g_rgTests[g_iCurTest].pfnTest();

            // draw one frame with current settings
            RenderFrame(1);

            // flip that dude to the front
            CheckHR(g_pDev->Present(NULL, NULL, NULL, NULL));

            g_scrtext.drawtext(g_var.verboselevel >= 1);
            g_fRedrawScreen = false;
        }

#if DBG

        if(FButtonDown(XINPUT_GAMEPAD_B))
        {
            D3DPUSHBUFFERINFO PushBufferInfo;
            D3DPERF_GetPushBufferInfo(&PushBufferInfo);

            D3DPERF_Dump();
            D3DPERF_Reset();
        }

#endif

        if(FButtonDown(XINPUT_GAMEPAD_LEFT_TRIGGER))
        {
            g_iCurTest = (g_iCurTest + ARRAYSIZE(g_rgTests) - 1) % ARRAYSIZE(g_rgTests);
            g_fRedrawScreen = true;
        }

        if(FButtonDown(XINPUT_GAMEPAD_RIGHT_TRIGGER))
        {
            g_iCurTest = (g_iCurTest + 1) % ARRAYSIZE(g_rgTests);
            g_fRedrawScreen = true;
        }

        if(FButtonDown(XINPUT_GAMEPAD_X))
        {
            InitFR(true);
            g_fRedrawScreen = true;
        }

        if(FButtonDown(XINPUT_GAMEPAD_Y))
        {
            // toggle wireframe and solid fill modes
            g_var.d3dfillmode = (g_var.d3dfillmode == D3DFILL_WIREFRAME) ?
                D3DFILL_SOLID : D3DFILL_WIREFRAME;
            CheckHR(g_pDev->SetRenderState(D3DRS_FILLMODE, g_var.d3dfillmode));
            g_fRedrawScreen = true;
        }

        xinpstatelast = xinpstate;
    }
}

//=========================================================================
// Run through a suite of multisample/supersample tests
//=========================================================================
void DoMultiSampleTimedTest()
{
    D3DMULTISAMPLE_TYPE rgMSType[] =
    {
        D3DMS_NONE,
        D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR,
        D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX,
        D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR,
        D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN,
        D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN,
        D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR,
        D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR,
        D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR,
        D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN,
        D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN
    };
    static const int cMSTypes = ARRAYSIZE(rgMSType);

    D3DFORMAT rgBackBuf[] = { D3DFMT_R5G6B5, D3DFMT_X8R8G8B8 };
    static const cBBufs = ARRAYSIZE(rgBackBuf);

    g_scrtext.cls();
    for(int iBuf = 0; iBuf < cBBufs; iBuf++)
    {
        g_scrtext.printf("BackBufFmt: %-38s %-8s %-8s %s",
            GetD3DFormatStr(rgBackBuf[iBuf]), "MPix/s", "fps", "frames");

        for(int iType = 0; iType < cMSTypes; iType++)
        {
            TIMETESTRESULTS ttres;

            g_var.MSType = rgMSType[iType];
            g_var.BackBufferFormat = rgBackBuf[iBuf];

            InitFR(false);
            DoTimedTest(&ttres);

            g_scrtext.printf("    %-45s %7.2f  %8.2f  %d",
                GetMultiSampleStr(rgMSType[iType]),
                ttres.fillrate, ttres.fps, ttres.cFrames);
        }
    }

    // restore settings from ini file
    InitFR(true);
}

//=========================================================================
// Do a quick test with the current settings
//=========================================================================
void DoQuickTimedTest()
{
    TIMETESTRESULTS ttres;

    DoTimedTest(&ttres);

    g_scrtext.cls();
    DumpCurrentSettings();

    g_scrtext.printf(" ");
    g_scrtext.printf("fillrate: %.2fMP/s",  ttres.fillrate);
    g_scrtext.printf("fps:      %.2f",      ttres.fps);
    g_scrtext.printf("frames:   %d",        ttres.cFrames);
    g_scrtext.printf("time:     %.2fms",    ttres.TimeTillIdle);
    g_scrtext.printf("pixels:   %I64u",     ttres.cNumPixelsDrawn);
}

//=========================================================================
// Texture fillrate test
//=========================================================================
void DoTextureTest()
{
    D3DFORMAT rgFormats[] =
    {
        D3DFMT_A4R4G4B4,
        D3DFMT_A8R8G8B8,
        D3DFMT_DXT1,
        D3DFMT_DXT2,
        D3DFMT_P8,
        D3DFMT_LIN_A8R8G8B8
    };
    int rgTexSize[] = { 1, 16, 256 };
    float rgResults[ARRAYSIZE(rgTexSize)];

    g_scrtext.cls();

    g_scrtext.printf("%-20s %-10s %-10s %-10s",
        "texturefmt", "1x1", "16x16", "256x256");

    for(int id3dformat = 0; id3dformat < ARRAYSIZE(rgFormats); id3dformat++)
    {
        char szBuf[128];

        szBuf[0] = 0;
        for(int itexsize = 0; itexsize < ARRAYSIZE(rgTexSize); itexsize++)
        {
            g_var.rgtex[0].type = TEX_2d;
            g_var.rgtex[0].texsize = rgTexSize[itexsize];
            g_var.rgtex[0].d3dFormat = rgFormats[id3dformat];

            InitFR(false);
            rgResults[itexsize] = DoTimedTest();
        }

        g_scrtext.printf(
            "%-20s %-10.2f %-10.2f %-10.2f",
            GetD3DFormatStr(g_var.rgtex[0].d3dFormat),
            rgResults[0], rgResults[1], rgResults[2]);
    }

    // restore settings from ini file
    InitFR(true);
}

//=========================================================================
// Run through a suite of fillrate tests
//=========================================================================
void DoCompleteTimedTest()
{
    D3DFORMAT rgFormats[] = { D3DFMT_DXT1, D3DFMT_A8R8G8B8, D3DFMT_A4R4G4B4 };

    g_scrtext.cls();

    g_scrtext.printf(
        "zwrite zread texturefmt      texturesize fillrate  (alphablendenable:%d)",
        g_var.alphablendenable);

    for(int id3dformat = 0; id3dformat < ARRAYSIZE(rgFormats); id3dformat++)
    {
        for(int texsize = 0; texsize <= 512; texsize += 256)
        {
            for(int zenable = 0; zenable < 2; zenable++)
            {
                for(int zwriteenable = 0; zwriteenable < 2; zwriteenable++)
                {
                    g_var.zenable = !!zenable;
                    g_var.zwriteenable = !!zwriteenable;

                    g_var.d3dcmpfunc = D3DCMP_NOTEQUAL;

                    g_var.rgtex[0].texsize = texsize;
                    g_var.rgtex[0].type = !!texsize;
                    g_var.rgtex[0].d3dFormat = rgFormats[id3dformat];

                    if(!g_var.zenable && zwriteenable)
                        continue;

                    if(!g_var.rgtex[0].type && id3dformat)
                        continue;

                    InitFR(false);
                    float fResult = DoTimedTest();

                    g_scrtext.printf(
                        "%-6d %-5d %-15s %-11d %.2f",
                        g_var.zwriteenable,
                        g_var.zenable,
                        texsize ? GetD3DFormatStr(g_var.rgtex[0].d3dFormat) : "",
                        texsize,
                        fResult);
                }
            }
        }
    }

    // restore settings from ini file
    InitFR(true);
}

//=========================================================================
// Dump the current options
//=========================================================================
void DumpCurrentSettings()
{
    g_scrtext.printf("Btn A) run '%s' test.", g_rgTests[g_iCurTest].szDesc);

    g_scrtext.printf(
        "AutoDepthStencilFormat:%s "
        "BackBufferFormat:%s ",
        g_var.AutoDepthStencilFormat ? GetD3DFormatStr(g_var.AutoDepthStencilFormat) : "none",
        GetD3DFormatStr(g_var.BackBufferFormat));

    g_scrtext.printf(
        "MultiSampleType:%s ",
        GetMultiSampleStr(g_var.MSType));

    g_scrtext.printf(
        "MultiSampleFormat:%s",
        GetMultiSampleStr(g_var.MSFormat));

    g_scrtext.printf(
        "zenable:%d "
        "z-write:%d "
        "d3dcmpfunc:%s",
        g_var.zenable,
        g_var.zenable && g_var.zwriteenable,
        GetD3DCMPStr(g_var.d3dcmpfunc));

    g_scrtext.printf(
        "alpha-blend:%d "
        "alpha-test:%d "
        "swathwidth:%d ",
        g_var.alphablendenable,
        g_var.alphatestenable,
        (g_var.SwathWidth == D3DSWATH_OFF) ? -1 : (0x8 << g_var.SwathWidth));

    g_scrtext.printf(
        "timeflags:%s%s",
        (g_var.timeflags & TIME_Render) ? "TIME_Render " : "",
        (g_var.timeflags & TIME_Present) ? "TIME_Present" : "");

    for(int itex = 0; itex < 4; itex++)
    {
        if(g_var.rgtex[itex].type)
        {
            g_scrtext.printf(
                "%d) texfmt:%s "
                "texel size (bytes):%0.1f "
                "texsize: %d "
                "mips: %d",
                itex,
                GetD3DFormatStr(g_var.rgtex[itex].d3dFormat),
                BitsPerPixelOfD3DFORMAT(g_var.rgtex[itex].d3dFormat) / 8.0f,
                g_var.rgtex[itex].texsize,
                g_pTexture[itex]->GetLevelCount()
                );
        }
    }

    if(g_var.userpixelshader)
    {
        g_scrtext.printf(
            "CombinerCount:%d",
            g_var.shaderdef.PSCombinerCount & 0xf);

        UINT TexModes = g_var.shaderdef.PSTextureModes;
        for(int texmode = 0; texmode < 4; texmode++, TexModes >>= 5)
        {
            if(TexModes & 0x1f)
            {
                g_scrtext.printf( "  T%d Mode:%s",
                    texmode, GetTextureModeStr(TexModes & 0x1f));
            }
        }
    }
}

//=========================================================================
//
//=========================================================================
float EstimateTimeForScene()
{
    CTimer timer;
    int overdraw = min(10, g_var.overdraw);

    // update the screen
    RenderFrame(1);
    CheckHR(g_pDev->Present(NULL, NULL, NULL, NULL));

    // wait until everything is cleared out
    g_pDev->BlockUntilIdle();

    // start timing
    timer.Start();

    if(g_var.timeflags & TIME_Render)
        RenderFrame(10);
    if(g_var.timeflags & TIME_Present)
    {
        CheckHR(g_pDev->Present(NULL, NULL, NULL, NULL));
    }

    // wait until GPU is idle again
    g_pDev->BlockUntilIdle();

    // stop timer
    timer.Stop();

    return g_var.overdraw * timer.getTime() / overdraw;
}

//=========================================================================
// Do a timed test and spit out the results
//=========================================================================
float DoTimedTest(TIMETESTRESULTS *pttres)
{
    CTimer timer;
    int frames = 0;
    int visibilityindex = 0;
    float TimeTillDoneDrawing = 0;

    // wait until everything is cleared out
    g_pDev->BlockUntilIdle();

    int numberscenes = g_var.numberscenes;

    if(!numberscenes)
    {
        // if there isn't an explicit count of scenes to render
        // guesstimate the time required for each scene
        float fEstimatedTimePerScene = EstimateTimeForScene();

        // and figure out how many scenes to render
        numberscenes = int(g_var.testtime / fEstimatedTimePerScene);
    }

    // put an upper cap and lower bound on the number of scenes
    numberscenes = max(2, min(numberscenes, 2047));

    // start timing
    timer.Start();

    // render X number of scenes
    for(frames = 0; frames < numberscenes; frames++)
    {
#ifndef NO_VIS_TEST

        CheckHR(g_pDev->BeginVisibilityTest());

#endif

        if(g_var.timeflags & TIME_Render)
            RenderFrame(g_var.overdraw);
        if(g_var.timeflags & TIME_Present)
        {
            CheckHR(g_pDev->Present(NULL, NULL, NULL, NULL));
        }

#ifndef NO_VIS_TEST

        CheckHR(g_pDev->EndVisibilityTest(visibilityindex++));

#endif
    }

    TimeTillDoneDrawing = timer.getTime();

    // wait until GPU is idle again
    g_pDev->BlockUntilIdle();

    // stop timer
    timer.Stop();
    float TimeTillIdle = timer.getTime();

    // get count of pixels drawn
    UINT64 dwNumPixelsDrawn = 0;

#ifdef NO_VIS_TEST

    if((g_var.timeflags & TIME_Present) == TIME_Present)
    {
        dwNumPixelsDrawn = (UINT64)g_var.screenwidth * g_var.screenheight * frames;
    }
    else if(g_var.timeflags & TIME_Render) 
    {
        // Get backbuffer size.
        D3DSURFACE_DESC Desc;
        CheckHR(g_pBackBuffer->GetDesc(&Desc));

        // Scale this bugger by the backbuffer size.
        DWORD Scale = (Desc.Width * Desc.Height) / (g_var.screenwidth * g_var.screenheight);

        dwNumPixelsDrawn = (UINT64)g_var.screenwidth * g_var.screenheight *
            frames * g_var.overdraw * Scale;

        if(g_var.timeflags & TIME_Present)
            dwNumPixelsDrawn += (UINT64)g_var.screenwidth * g_var.screenheight * frames;
    }

#else

    for(int ivis = 0; ivis < visibilityindex; ivis++)
    {
        // Check the number of pixels drawn.
        UINT dwT;
        while(g_pDev->GetVisibilityTestResult(ivis, &dwT, NULL) == D3DERR_TESTINCOMPLETE)
            ;

        if(g_var.verboselevel >= 2)
            dprintf("pass:%d  %ld pixels\n", ivis, dwT);

        if(dwT == 0xffffffff)
            dwT = 0;
        dwNumPixelsDrawn += dwT;
    }

#endif

    /*
     * Calculate fillrate
     */
    float fillrate = dwNumPixelsDrawn / (TimeTillIdle * 1000.0f);

    if(pttres)
    {
        pttres->fillrate = fillrate;
        pttres->fps = frames * 1000 / TimeTillIdle;
        pttres->cFrames = frames;
        pttres->TimeTillDoneDrawing = TimeTillDoneDrawing;
        pttres->TimeTillIdle = TimeTillIdle;
        pttres->cNumPixelsDrawn = dwNumPixelsDrawn;
    }

    return fillrate;
}

//=========================================================================
// macros to help read entries from the ini file
//=========================================================================
static const char g_szOpts[] = "options";
#define get_option_val(_var)          g_inifile.GetIniInt(g_szOpts, #_var, g_var._var)
#define get_option_valf(_var)         g_inifile.GetIniFloat(g_szOpts, #_var, g_var._var)
#define get_option_val3(_s, _var, _d) g_inifile.GetIniInt(_s, _var, _d)

//=========================================================================
// Read ini file and update all fr settings
//=========================================================================
bool ReadFRIniFile()
{
    if(!g_inifile.ReadFile())
        return false;

    if(g_ShaderHandle)
    {
        assert(g_pDev);
        CheckHR(g_pDev->SetPixelShader(0));
        CheckHR(g_pDev->DeletePixelShader(g_ShaderHandle));
        g_ShaderHandle = 0;
    }

    // read the verbose flag(s) first
    g_inifile.m_fverbose            = !!get_option_val3(g_szOpts, "verboseinireads", false);
    g_var.verboselevel              = get_option_val(verboselevel);

    // if the g_iCurTest entry exists, read it in
    if(g_inifile.IniEntryExists(g_szOpts, "g_iCurTest"))
        g_iCurTest = g_inifile.GetIniInt(g_szOpts, "g_iCurTest", g_iCurTest);

    g_var.runtestonreload           = !!get_option_val(runtestonreload);

    g_var.AutoDepthStencilFormat    = (D3DFORMAT)get_option_val(AutoDepthStencilFormat);
    g_var.BackBufferFormat          = (D3DFORMAT)get_option_val(BackBufferFormat);

    g_var.MSType                    = (D3DMULTISAMPLE_TYPE)get_option_val(MSType);
    g_var.MSFormat                  = (D3DMULTISAMPLE_TYPE)get_option_val(MSFormat);

    g_var.specularenable            = !!get_option_val(specularenable);
    g_var.zenable                   = !!get_option_val(zenable);
    g_var.zwriteenable              = !!get_option_val(zwriteenable);
    g_var.d3dcmpfunc                = (D3DCMPFUNC)get_option_val(d3dcmpfunc);

    g_var.primez                    = !!get_option_val(primez);
    g_var.primezcmpfunc             =  (D3DCMPFUNC)get_option_val(primezcmpfunc);

    g_var.alphablendenable          = !!get_option_val(alphablendenable);
    g_var.alphatestenable           = !!get_option_val(alphatestenable);

    g_var.rotatetex                 = !!get_option_val(rotatetex);
    g_var.tiltz                     = !!get_option_val(tiltz);

    g_var.testtime                  = get_option_valf(testtime);
    g_var.numberscenes              = get_option_val(numberscenes);
    g_var.timeflags                 = get_option_val(timeflags);

    g_var.SwathWidth                = (D3DSWATHWIDTH)get_option_val(SwathWidth);

    g_var.colorwriteenable          = get_option_val(colorwriteenable);

    g_var.quadwidth                 = get_option_valf(quadwidth);
    g_var.quadheight                = get_option_valf(quadheight);

    g_var.quadx                     = (g_var.screenwidth - min(g_var.screenwidth, g_var.quadwidth)) / 2;
    g_var.quady                     = (g_var.screenheight - min(g_var.screenheight, g_var.quadheight)) / 2;
    g_var.quadx                     = get_option_valf(quadx);
    g_var.quady                     = get_option_valf(quady);

    g_var.FVF                       = get_option_val(FVF);

    g_var.clearflags                = get_option_val(clearflags);
    g_var.zclearval                 = get_option_valf(zclearval);
    g_var.sclearval                 = get_option_val(sclearval);
    g_var.cclearval                 = get_option_val(cclearval);

    g_var.userpixelshader           = !!get_option_val(userpixelshader);
    if(g_var.userpixelshader)
        ReadPixelShaderIni(&g_var.shaderdef);

    for(int itex = 0; itex < 4; itex++)
    {
        char szSect[128];
        _snprintf(szSect, sizeof(szSect), "texture%d", itex);

        g_var.rgtex[itex].type = get_option_val3(szSect, "type", TEX_None);
        g_var.rgtex[itex].texsize = get_option_val3(szSect, "texsize", 8);
        g_var.rgtex[itex].d3dFormat = (D3DFORMAT)get_option_val3(szSect, "d3dFormat", D3DFMT_DXT1);
        g_var.rgtex[itex].filtertype = (D3DTEXTUREFILTERTYPE)get_option_val3(szSect, "filtertype", D3DTEXF_LINEAR);
        g_var.rgtex[itex].mipfilter = (D3DTEXTUREFILTERTYPE)get_option_val3(szSect, "mipfilter", D3DTEXF_NONE);
    }

    return true;
}

#if DBG

extern "C" { extern DWORD D3D__DeadlockTimeOutVal; }

#endif

//=========================================================================
// main
//=========================================================================
void __cdecl main()
{
#if DBG

    // Bump the dbg deadlock timeout value to 20 seconds otherwise some
    // of the tests will complain about d3d being deadlocked.
    D3D__DeadlockTimeOutVal = 20000;

#endif

    /*
     * init vars
     */
    g_var.screenwidth = 640;
    g_var.screenheight = 480;

    g_var.quadwidth = 640;
    g_var.quadheight = 480;

    g_var.quadx = (g_var.screenwidth - min(g_var.screenwidth, g_var.quadwidth)) / 2;
    g_var.quady = (g_var.screenheight - min(g_var.screenheight, g_var.quadheight)) / 2;

    g_var.FVF = D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1;

    g_var.alphablendenable = false;
    g_var.alphatestenable = false;

    // default to drawing 10 seconds
    g_var.numberscenes = 0;
    g_var.overdraw = 100;
    g_var.testtime = 10000.0f;
    g_var.timeflags = TIME_Render;

    g_var.SwathWidth = D3DSWATH_128;

    g_var.colorwriteenable = D3DCOLORWRITEENABLE_ALL;

    g_var.ColorOp = D3DTOP_SELECTARG1;
    g_var.AlphaOp = D3DTOP_SELECTARG1;
    g_var.d3dfillmode = D3DFILL_SOLID;

    g_var.zenable = false;
    g_var.zwriteenable = false;

    g_var.d3dcmpfunc = D3DCMP_NOTEQUAL;

    g_var.primez = false;
    g_var.primezcmpfunc = D3DCMP_ALWAYS;

    g_var.BackBufferFormat = D3DFMT_A8R8G8B8;
    g_var.AutoDepthStencilFormat = D3DFMT_D24S8;

    g_var.clearflags = D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL;
    g_var.cclearval = 0x00006688;

    /*
     * Init fillrate
     */
    XInitDevices(0, NULL);

    DWORD dwLastTickCount = GetTickCount();
    for(;;)
    {
        DWORD dwTickCount = GetTickCount();
        DWORD dwTicks = dwTickCount - dwLastTickCount;

        dwLastTickCount = dwTickCount;

        HandleInput(dwTicks);

        if(g_pDev)
        {
            if(g_fRedrawScreen)
            {
                // clear back buffer
                RenderFrame(1);

                // swap that guy to the front
                CheckHR(g_pDev->Present(NULL, NULL, NULL, NULL));

                // clear new back buffer
                RenderFrame(1);

                // display current options on front buffer
                g_scrtext.cls();
                DumpCurrentSettings();
                g_scrtext.drawtext(g_var.verboselevel >= 1);

                g_fRedrawScreen = false;
            }
            else
            {
                // 33.3 fps baby!
                Sleep(30);
            }
        }
    }
}

//=========================================================================
// Initialize and create our pixel shader
//=========================================================================
void ReadPixelShaderIni(D3DPIXELSHADERDEF *pshaderdef)
{
    enum
    {
        SE_PSTextureModes,
        SE_PSDotMapping,
        SE_PSInputTexture,
        SE_PSCompareMode,
        SE_PSCombinerCount,
        SE_PSFinalCombinerConstant0,
        SE_PSFinalCombinerConstant1,
        SE_PSFinalCombinerInputsABCD,
        SE_PSFinalCombinerInputsEFG,
        SE_Max
    };

#define SE_ENTRY(_x) SE_##_x, #_x
    struct ShaderEntry
    {
        DWORD dwSectionID;
        LPCSTR szSectionName;
        LPCSTR rgkeys[4];
        int rgvals[4];
    } rgEntries[] =
    {
        { SE_ENTRY(PSTextureModes),             { "t0", "t1", "t2", "t3" } },
        { SE_ENTRY(PSDotMapping),               { "t0", "t1", "t2", "t3" } },
        { SE_ENTRY(PSInputTexture),             { "t2", "t3" } },
        { SE_ENTRY(PSCompareMode),              { "t0", "t1", "t2", "t3" } },
        { SE_ENTRY(PSCombinerCount),            { "count", "flags" } },
        { SE_ENTRY(PSFinalCombinerConstant0),   { "c" } },
        { SE_ENTRY(PSFinalCombinerConstant1),   { "c" } },
        { SE_ENTRY(PSFinalCombinerInputsABCD),  { "A", "B", "C", "D" } },
        { SE_ENTRY(PSFinalCombinerInputsEFG),   { "E", "F", "G", "flags" } },
    };

    enum
    {
        SSE_PSConstant0,
        SSE_PSConstant1,
        SSE_PSRGBInputs,
        SSE_PSAlphaInputs,
        SSE_PSRGBOutputs,
        SSE_PSAlphaOutputs,
        SSE_Max
    };

#define SSE_ENTRY(_x) SSE_##_x, #_x
    struct ShaderStageEntry
    {
        DWORD dwSectionID;
        LPCSTR szSectionName;
        LPCSTR rgkeys[4];
        int rgvals[4][8];
    } rgStageEntries[] =
    {
        { SSE_ENTRY(PSConstant0),       { "c" } },
        { SSE_ENTRY(PSConstant1),       { "c" } },
        { SSE_ENTRY(PSRGBInputs),       { "A", "B", "C", "D" } },
        { SSE_ENTRY(PSAlphaInputs),     { "A", "B", "C", "D" } },
        { SSE_ENTRY(PSRGBOutputs),      { "ab", "cd", "mux_sum", "flags" } },
        { SSE_ENTRY(PSAlphaOutputs),    { "ab", "cd", "mux_sum", "flags" } },
    };

    // read all the shader entries
    for(int iSE = 0; iSE < SE_Max; iSE++)
    {
        ShaderEntry *pse = &rgEntries[iSE];

        for(int ikey = 0; ikey < 4; ikey++)
        {
            if(pse->rgkeys[ikey])
            {
                int val = g_inifile.GetIniInt(pse->szSectionName, pse->rgkeys[ikey], -1);
                if(val != -1)
                {
                    pse->rgvals[ikey] = val;
                    if(g_var.verboselevel >= 2)
                    {
                        dprintf("%s.%s = 0x%lx\n",
                            pse->szSectionName,
                            pse->rgkeys[ikey],
                            val);
                    }
                }
            }
        }
    }

    // read all the shader stage entries
    for(int iSSE = 0; iSSE < SSE_Max; iSSE++)
    {
        char szKey[128];
        ShaderStageEntry *psse = &rgStageEntries[iSSE];

        for(int ikey = 0; ikey < 4; ikey++)
        {
            if(psse->rgkeys[ikey])
            {
                for(int istage = 0; istage < 8; istage++)
                {
                    _snprintf(szKey, sizeof(szKey), "%s%d", psse->rgkeys[ikey], istage);
                    int val = g_inifile.GetIniInt(psse->szSectionName, szKey, -1);
                    if(val != -1)
                    {
                        psse->rgvals[ikey][istage] = val;
                        if(g_var.verboselevel >= 2)
                        {
                            dprintf("%s.%s[%d] = 0x%lx\n",
                                psse->szSectionName,
                                psse->rgkeys[ikey],
                                istage,
                                val);
                        }
                    }
                }
            }
        }
    }

    ZeroMemory(pshaderdef, sizeof(*pshaderdef));

    /*---------------------------------------------------------------------------*/
    /*  Texture configuration - The following members of the D3DPixelShaderDef   */
    /*  structure define the addressing modes of each of the four texture stages */
    /*---------------------------------------------------------------------------*/
    pshaderdef->PSTextureModes = PS_TEXTUREMODES(
        rgEntries[SE_PSTextureModes].rgvals[0],
        rgEntries[SE_PSTextureModes].rgvals[1],
        rgEntries[SE_PSTextureModes].rgvals[2],
        rgEntries[SE_PSTextureModes].rgvals[3]);

    pshaderdef->PSDotMapping = PS_DOTMAPPING(
        rgEntries[SE_PSDotMapping].rgvals[0],
        rgEntries[SE_PSDotMapping].rgvals[1],
        rgEntries[SE_PSDotMapping].rgvals[2],
        rgEntries[SE_PSDotMapping].rgvals[3]);

    pshaderdef->PSInputTexture = PS_INPUTTEXTURE(
        0,
        0,
        rgEntries[SE_PSInputTexture].rgvals[0],  // 0 and 1 valid
        rgEntries[SE_PSInputTexture].rgvals[1]); // 0, 1, and 2 valid

    pshaderdef->PSCompareMode = PS_COMPAREMODE(
        rgEntries[SE_PSCompareMode].rgvals[0],
        rgEntries[SE_PSCompareMode].rgvals[1],
        rgEntries[SE_PSCompareMode].rgvals[2],
        rgEntries[SE_PSCompareMode].rgvals[3]);

    /*---------------------------------------------------------------------------------*/
    /*  Color combiners - The following members of the D3DPixelShaderDef structure     */
    /*  define the state for the eight stages of color combiners                       */
    /*---------------------------------------------------------------------------------*/
    pshaderdef->PSCombinerCount = PS_COMBINERCOUNT(
        rgEntries[SE_PSCombinerCount].rgvals[0],
        rgEntries[SE_PSCombinerCount].rgvals[1]);

    for(int istage = 0; istage < 8; istage++)
    {
        pshaderdef->PSConstant0[istage] = rgStageEntries[SSE_PSConstant0].rgvals[0][istage];
        pshaderdef->PSConstant1[istage] = rgStageEntries[SSE_PSConstant1].rgvals[0][istage];

        // R0_ALPHA is initialized to T0_ALPHA in stage0

        // a,b,c,d each contain a value from PS_REGISTER, PS_CHANNEL, and PS_INPUTMAPPING
        pshaderdef->PSRGBInputs[istage] = PS_COMBINERINPUTS(
            rgStageEntries[SSE_PSRGBInputs].rgvals[0][istage],      // A
            rgStageEntries[SSE_PSRGBInputs].rgvals[1][istage],      // B
            rgStageEntries[SSE_PSRGBInputs].rgvals[2][istage],      // C
            rgStageEntries[SSE_PSRGBInputs].rgvals[3][istage]);     // D

        // R0_ALPHA is initialized to T0_ALPHA in stage0
        pshaderdef->PSAlphaInputs[istage] = PS_COMBINERINPUTS(
            rgStageEntries[SSE_PSAlphaInputs].rgvals[0][istage],    // A
            rgStageEntries[SSE_PSAlphaInputs].rgvals[1][istage],    // B
            rgStageEntries[SSE_PSAlphaInputs].rgvals[2][istage],    // C
            rgStageEntries[SSE_PSAlphaInputs].rgvals[3][istage]);   // D

        // mux_sum must be DISCARD if either AB_DOT_PRODUCT or CD_DOT_PRODUCT are set
        //  ie: Dot / Dot / Discard || Dot / Mult / Discard || Mult / Dot / Discard

        // ab,cd,mux_sum contain a value from PS_REGISTER
        // flags contains values from PS_COMBINEROUTPUT
        pshaderdef->PSRGBOutputs[istage] = PS_COMBINEROUTPUTS(
            rgStageEntries[SSE_PSRGBOutputs].rgvals[0][istage],     // ab
            rgStageEntries[SSE_PSRGBOutputs].rgvals[1][istage],     // cd
            rgStageEntries[SSE_PSRGBOutputs].rgvals[2][istage],     // mux_sum
            rgStageEntries[SSE_PSRGBOutputs].rgvals[3][istage]);    // flags
        pshaderdef->PSAlphaOutputs[istage] = PS_COMBINEROUTPUTS(
            rgStageEntries[SSE_PSAlphaOutputs].rgvals[0][istage],   // ab
            rgStageEntries[SSE_PSAlphaOutputs].rgvals[1][istage],   // cd
            rgStageEntries[SSE_PSAlphaOutputs].rgvals[2][istage],   // mux_sum
            rgStageEntries[SSE_PSAlphaOutputs].rgvals[3][istage]);  // flags
    }

    pshaderdef->PSFinalCombinerConstant0 = rgEntries[SE_PSFinalCombinerConstant0].rgvals[0];
    pshaderdef->PSFinalCombinerConstant1 = rgEntries[SE_PSFinalCombinerConstant1].rgvals[0];

    // FOG ALPHA is only available in final combiner
    // V1R0_SUM and EF_PROD are only available in final combiner A,B,C,D inputs
    // V1R0_SUM_ALPHA and EF_PROD_ALPHA are not available

    // AB + (1-A)C + D
    pshaderdef->PSFinalCombinerInputsABCD = PS_COMBINERINPUTS(
        rgEntries[SE_PSFinalCombinerInputsABCD].rgvals[0],          // A
        rgEntries[SE_PSFinalCombinerInputsABCD].rgvals[1],          // B
        rgEntries[SE_PSFinalCombinerInputsABCD].rgvals[2],          // C
        rgEntries[SE_PSFinalCombinerInputsABCD].rgvals[3]);         // D

    // E,F,G contain a value from PS_REGISTER, PS_CHANNEL, and PS_INPUTMAPPING
    // flags contains values from PS_FINALCOMBINERSETTING:
    //    PS_FINALCOMBINERSETTING_CLAMP_SUM         // V1+R0 sum clamped to [0,1]
    //    PS_FINALCOMBINERSETTING_COMPLEMENT_V1     // unsigned invert mapping
    //    PS_FINALCOMBINERSETTING_COMPLEMENT_R0     // unsigned invert mapping
    pshaderdef->PSFinalCombinerInputsEFG = PS_COMBINERINPUTS(
        rgEntries[SE_PSFinalCombinerInputsEFG].rgvals[0],           // E
        rgEntries[SE_PSFinalCombinerInputsEFG].rgvals[1],           // F
        rgEntries[SE_PSFinalCombinerInputsEFG].rgvals[2],           // G (alpha)
        rgEntries[SE_PSFinalCombinerInputsEFG].rgvals[3]);          // flags
}

//=========================================================================
// Callback from inifile.cpp to get float string value
//=========================================================================
bool GetIniConstf(const char *szStr, int cchStr, float *pval)
{
    return false;
}

//=========================================================================
// Callback from inifile.cpp to get int string value
//=========================================================================
bool GetIniConst(const char *szStr, int cchStr, int *pval)
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        int Val;
        const char *szStr;
    } rgszConsts[] =
    {
        // Pixel Shaders
        XTAG(PS_TEXTUREMODES_NONE), XTAG(PS_TEXTUREMODES_PROJECT2D), XTAG(PS_TEXTUREMODES_PROJECT3D),
        XTAG(PS_TEXTUREMODES_CUBEMAP), XTAG(PS_TEXTUREMODES_PASSTHRU), XTAG(PS_TEXTUREMODES_CLIPPLANE),
        XTAG(PS_TEXTUREMODES_BUMPENVMAP), XTAG(PS_TEXTUREMODES_BUMPENVMAP_LUM), XTAG(PS_TEXTUREMODES_BRDF),
        XTAG(PS_TEXTUREMODES_DOT_ST), XTAG(PS_TEXTUREMODES_DOT_ZW), XTAG(PS_TEXTUREMODES_DOT_RFLCT_DIFF),
        XTAG(PS_TEXTUREMODES_DOT_RFLCT_SPEC), XTAG(PS_TEXTUREMODES_DOT_STR_3D), XTAG(PS_TEXTUREMODES_DOT_STR_CUBE),
        XTAG(PS_TEXTUREMODES_DPNDNT_AR), XTAG(PS_TEXTUREMODES_DPNDNT_GB), XTAG(PS_TEXTUREMODES_DOTPRODUCT),
        XTAG(PS_TEXTUREMODES_DOT_RFLCT_SPEC_CONST), XTAG(PS_COMPAREMODE_S_LT), XTAG(PS_COMPAREMODE_S_GE),
        XTAG(PS_COMPAREMODE_T_LT), XTAG(PS_COMPAREMODE_T_GE), XTAG(PS_COMPAREMODE_R_LT),
        XTAG(PS_COMPAREMODE_R_GE), XTAG(PS_COMPAREMODE_Q_LT), XTAG(PS_COMPAREMODE_Q_GE),
        XTAG(PS_COMBINERCOUNT_MUX_LSB), XTAG(PS_COMBINERCOUNT_MUX_MSB), XTAG(PS_COMBINERCOUNT_SAME_C0),
        XTAG(PS_COMBINERCOUNT_UNIQUE_C0), XTAG(PS_COMBINERCOUNT_SAME_C1), XTAG(PS_COMBINERCOUNT_UNIQUE_C1),
        XTAG(PS_INPUTMAPPING_UNSIGNED_IDENTITY), XTAG(PS_INPUTMAPPING_UNSIGNED_INVERT), XTAG(PS_INPUTMAPPING_EXPAND_NORMAL),
        XTAG(PS_INPUTMAPPING_EXPAND_NEGATE), XTAG(PS_INPUTMAPPING_HALFBIAS_NORMAL), XTAG(PS_INPUTMAPPING_HALFBIAS_NEGATE),
        XTAG(PS_INPUTMAPPING_SIGNED_IDENTITY), XTAG(PS_INPUTMAPPING_SIGNED_NEGATE), XTAG(PS_REGISTER_ZERO),
        XTAG(PS_REGISTER_DISCARD), XTAG(PS_REGISTER_C0), XTAG(PS_REGISTER_C1),
        XTAG(PS_REGISTER_FOG), XTAG(PS_REGISTER_V0), XTAG(PS_REGISTER_V1),
        XTAG(PS_REGISTER_T0), XTAG(PS_REGISTER_T1), XTAG(PS_REGISTER_T2),
        XTAG(PS_REGISTER_T3), XTAG(PS_REGISTER_R0), XTAG(PS_REGISTER_R1),
        XTAG(PS_REGISTER_V1R0_SUM), XTAG(PS_REGISTER_EF_PROD), XTAG(PS_REGISTER_ONE),
        XTAG(PS_REGISTER_NEGATIVE_ONE), XTAG(PS_REGISTER_ONE_HALF), XTAG(PS_REGISTER_NEGATIVE_ONE_HALF),
        XTAG(PS_CHANNEL_RGB), XTAG(PS_CHANNEL_BLUE), XTAG(PS_CHANNEL_ALPHA),
        XTAG(PS_FINALCOMBINERSETTING_CLAMP_SUM), XTAG(PS_FINALCOMBINERSETTING_COMPLEMENT_V1), XTAG(PS_FINALCOMBINERSETTING_COMPLEMENT_R0),
        XTAG(PS_COMBINEROUTPUT_IDENTITY), XTAG(PS_COMBINEROUTPUT_BIAS), XTAG(PS_COMBINEROUTPUT_SHIFTLEFT_1),
        XTAG(PS_COMBINEROUTPUT_SHIFTLEFT_1_BIAS), XTAG(PS_COMBINEROUTPUT_SHIFTLEFT_2), XTAG(PS_COMBINEROUTPUT_SHIFTRIGHT_1),
        XTAG(PS_COMBINEROUTPUT_AB_BLUE_TO_ALPHA), XTAG(PS_COMBINEROUTPUT_CD_BLUE_TO_ALPHA), XTAG(PS_COMBINEROUTPUT_AB_MULTIPLY),
        XTAG(PS_COMBINEROUTPUT_AB_DOT_PRODUCT), XTAG(PS_COMBINEROUTPUT_CD_MULTIPLY), XTAG(PS_COMBINEROUTPUT_CD_DOT_PRODUCT),
        XTAG(PS_COMBINEROUTPUT_AB_CD_SUM), XTAG(PS_COMBINEROUTPUT_AB_CD_MUX),
        XTAG(PS_DOTMAPPING_ZERO_TO_ONE), XTAG(PS_DOTMAPPING_MINUS1_TO_1_D3D), XTAG(PS_DOTMAPPING_MINUS1_TO_1_GL),
        XTAG(PS_DOTMAPPING_MINUS1_TO_1), XTAG(PS_DOTMAPPING_HILO_1), XTAG(PS_DOTMAPPING_HILO_HEMISPHERE_D3D), XTAG(PS_DOTMAPPING_HILO_HEMISPHERE_GL),
        XTAG(PS_DOTMAPPING_HILO_HEMISPHERE),

        // D3DFORMATs
        XTAG(D3DFMT_A8R8G8B8), XTAG(D3DFMT_X8R8G8B8), XTAG(D3DFMT_R5G6B5), XTAG(D3DFMT_R6G5B5),
        XTAG(D3DFMT_X1R5G5B5), XTAG(D3DFMT_A1R5G5B5), XTAG(D3DFMT_A4R4G4B4), XTAG(D3DFMT_A8),
        XTAG(D3DFMT_A8B8G8R8), XTAG(D3DFMT_B8G8R8A8), XTAG(D3DFMT_R4G4B4A4), XTAG(D3DFMT_R5G5B5A1),
        XTAG(D3DFMT_R8G8B8A8), XTAG(D3DFMT_R8B8), XTAG(D3DFMT_G8B8), XTAG(D3DFMT_P8),
        XTAG(D3DFMT_L8), XTAG(D3DFMT_A8L8), XTAG(D3DFMT_AL8), XTAG(D3DFMT_L16),
        XTAG(D3DFMT_V8U8), XTAG(D3DFMT_L6V5U5), XTAG(D3DFMT_X8L8V8U8), XTAG(D3DFMT_Q8W8V8U8),
        XTAG(D3DFMT_V16U16), XTAG(D3DFMT_D16_LOCKABLE), XTAG(D3DFMT_D16), XTAG(D3DFMT_D24S8),
        XTAG(D3DFMT_F16), XTAG(D3DFMT_F24S8), XTAG(D3DFMT_UYVY), XTAG(D3DFMT_YUY2),
        XTAG(D3DFMT_DXT1), XTAG(D3DFMT_DXT2), XTAG(D3DFMT_DXT3), XTAG(D3DFMT_DXT4),
        XTAG(D3DFMT_DXT5), XTAG(D3DFMT_LIN_A1R5G5B5), XTAG(D3DFMT_LIN_A4R4G4B4), XTAG(D3DFMT_LIN_A8),
        XTAG(D3DFMT_LIN_A8B8G8R8), XTAG(D3DFMT_LIN_A8R8G8B8), XTAG(D3DFMT_LIN_B8G8R8A8), XTAG(D3DFMT_LIN_G8B8),
        XTAG(D3DFMT_LIN_R4G4B4A4), XTAG(D3DFMT_LIN_R5G5B5A1), XTAG(D3DFMT_LIN_R5G6B5), XTAG(D3DFMT_LIN_R6G5B5),
        XTAG(D3DFMT_LIN_R8B8), XTAG(D3DFMT_LIN_R8G8B8A8), XTAG(D3DFMT_LIN_X1R5G5B5), XTAG(D3DFMT_LIN_X8R8G8B8),
        XTAG(D3DFMT_LIN_A8L8), XTAG(D3DFMT_LIN_AL8), XTAG(D3DFMT_LIN_L16), XTAG(D3DFMT_LIN_L8),
        XTAG(D3DFMT_LIN_D24S8), XTAG(D3DFMT_LIN_F24S8), XTAG(D3DFMT_LIN_D16), XTAG(D3DFMT_LIN_F16),

        XTAG(D3DMULTISAMPLE_NONE), XTAG(D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX), XTAG(D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR),
        XTAG(D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR), XTAG(D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN),
        XTAG(D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT),
        XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5),
        XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8),

        XTAG(D3DMS_NONE), XTAG(D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX), XTAG(D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR),
        XTAG(D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR), XTAG(D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN), XTAG(D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR),
        XTAG(D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN),
        XTAG(D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMS_PREFILTER_FORMAT_DEFAULT),
        XTAG(D3DMS_PREFILTER_FORMAT_X1R5G5B5), XTAG(D3DMS_PREFILTER_FORMAT_R5G6B5),
        XTAG(D3DMS_PREFILTER_FORMAT_X8R8G8B8), XTAG(D3DMS_PREFILTER_FORMAT_A8R8G8B8),

        XTAG(D3DCLEAR_TARGET), XTAG(D3DCLEAR_ZBUFFER), XTAG(D3DCLEAR_STENCIL),

        // FVFs
        XTAG(D3DFVF_XYZ), XTAG(D3DFVF_XYZRHW), XTAG(D3DFVF_NORMAL), XTAG(D3DFVF_DIFFUSE),
        XTAG(D3DFVF_SPECULAR), XTAG(D3DFVF_TEX0), XTAG(D3DFVF_TEX1), XTAG(D3DFVF_TEX2),
        XTAG(D3DFVF_TEX3), XTAG(D3DFVF_TEX4),

        // textcoord sizes
        XTAG(T0_SIZE1), XTAG(T0_SIZE2), XTAG(T0_SIZE3), XTAG(T0_SIZE4),
        XTAG(T1_SIZE1), XTAG(T1_SIZE2), XTAG(T1_SIZE3), XTAG(T1_SIZE4),
        XTAG(T2_SIZE1), XTAG(T2_SIZE2), XTAG(T2_SIZE3), XTAG(T2_SIZE4),
        XTAG(T3_SIZE1), XTAG(T3_SIZE2), XTAG(T3_SIZE3), XTAG(T3_SIZE4),

        // D3DCMPs
        XTAG(D3DCMP_NEVER), XTAG(D3DCMP_LESS), XTAG(D3DCMP_EQUAL), XTAG(D3DCMP_LESSEQUAL),
        XTAG(D3DCMP_GREATER), XTAG(D3DCMP_NOTEQUAL), XTAG(D3DCMP_GREATEREQUAL), XTAG(D3DCMP_ALWAYS),

        XTAG(D3DTEXF_NONE), XTAG(D3DTEXF_POINT), XTAG(D3DTEXF_LINEAR), XTAG(D3DTEXF_ANISOTROPIC),
        XTAG(D3DTEXF_QUINCUNX), XTAG(D3DTEXF_GAUSSIANCUBIC),

        XTAG(TEX_None), XTAG(TEX_2d), XTAG(TEX_Cubemap), XTAG(TEX_Volume),

        XTAG(TIME_Present), XTAG(TIME_Render),

        // swaths
        XTAG(D3DSWATH_8), XTAG(D3DSWATH_16), XTAG(D3DSWATH_32),
        XTAG(D3DSWATH_64), XTAG(D3DSWATH_128), XTAG(D3DSWATH_OFF),

        XTAG(D3DCOLORWRITEENABLE_RED), XTAG(D3DCOLORWRITEENABLE_GREEN), XTAG(D3DCOLORWRITEENABLE_BLUE),
        XTAG(D3DCOLORWRITEENABLE_ALPHA), XTAG(D3DCOLORWRITEENABLE_ALL),

        // misc
        XTAG(FALSE), XTAG(TRUE)
    };

    for(int ifmt = 0; ifmt < ARRAYSIZE(rgszConsts); ifmt++)
    {
        if(!_strnicmp(rgszConsts[ifmt].szStr, szStr, cchStr))
        {
            // set val
            *pval = rgszConsts[ifmt].Val;
            return true;
        }
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\fillrate\inifile.h ===
//-----------------------------------------------------------------------------
// FILE: INIFILE.H
//
// Desc: Quick and dirty INI file routines
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

// Routines supplied by the main application to return the values for a given
// string found in an ini file.
bool GetIniConst(const char *szStr, int cchStr, int *pval);
bool GetIniConstf(const char *szStr, int cchStr, float *pval);

//=========================================================================
// IniFile class
//=========================================================================
class CIniFile
{
public:
    CIniFile(LPCSTR szFileName) : m_szFile(NULL), m_ftFileReadTime(0), m_fverbose(false), m_recurselevel(0)
        { lstrcpyA(m_szFileName, szFileName); }
    ~CIniFile()
    {
        if(m_szFile)
        {
            free(m_szFile);
            m_szFile = NULL;
        }
    };

    // get int entry
    int GetIniInt(LPCSTR lpSectionName, LPCSTR lpKeyName, int nDefault);

    // get float entry
    float GetIniFloat(LPCSTR lpSectionName, LPCSTR lpKeyName, float nDefault);

    // check for entry existance
    bool IniEntryExists(LPCSTR lpSectionName, LPCSTR lpKeyName);

    // get ini string value. Up to caller to parse and check for end '\n' or ';'
    bool GetIniStrBuf(LPCSTR lpSectionName, LPCSTR lpKeyName,
        LPCSTR szDefault, char *buf, int buflen);

    // get ini string value. Up to caller to parse and check for end '\n' or ';'
    LPCSTR GetIniStr(LPCSTR lpSectionName, LPCSTR lpKeyName,
        LPCSTR szDefault, LPCSTR *ppszLineStart);

    // read/refresh an ini file
    bool ReadFile();

    // get name of ini file
    LPCSTR GetFileName()
        { return m_szFileName; }

    // has ini file timestamp changed?
    bool FileChanged()
        { return GetFileTime(m_szFileName) != m_ftFileReadTime; }

    bool m_fverbose;

private:
    enum { INIVAL_INT, INIVAL_FLOAT };
    struct INIVAL
    {
        int type;

        int val;
        float valf;

        void SetVal(int newval)
            { val = newval; valf = (float)newval; }
        void SetVal(float newval)
            { val = (int)newval; valf = newval; }
    };

    LPCSTR GetIniConstValue(const char *szStr, INIVAL *pinival);

    bool ParseIntVal(LPCSTR szLineStart, LPCSTR szLine, int *pval);
    bool ParseFloatVal(LPCSTR szLineStart, LPCSTR szLine, float *pval);

    char m_szFileName[MAX_PATH];
    char *m_szFile;
    UINT64 m_ftFileReadTime;

    UINT m_recurselevel;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\fillrate\utils.cpp ===
//-----------------------------------------------------------------------------
// FILE: FILLRATE.CPP
//
// Desc: a stupid fillrate test
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>

#include "bitfont.h"
#include "utils.h"

// CScrText font class
BitFont g_bitfont;

//=========================================================================
// Stringtize PS_TEXTUREMODES_*
//=========================================================================
LPCSTR GetTextureModeStr(DWORD TextureMode)
{
    #undef XTAG
    #define XTAG(_tag) { PS_TEXTUREMODES##_tag, "PS_TM" #_tag }
    static const struct
    {
        DWORD texturemode;
        const char *szD3DMSStr;
    } rgszTMStr[] =
    {
        XTAG(_NONE), XTAG(_PROJECT2D), XTAG(_PROJECT3D),
        XTAG(_CUBEMAP), XTAG(_PASSTHRU), XTAG(_CLIPPLANE),
        XTAG(_BUMPENVMAP), XTAG(_BUMPENVMAP_LUM), XTAG(_BRDF),
        XTAG(_DOT_ST), XTAG(_DOT_ZW), XTAG(_DOT_RFLCT_DIFF),
        XTAG(_DOT_RFLCT_SPEC), XTAG(_DOT_STR_3D), XTAG(_DOT_STR_CUBE),
        XTAG(_DPNDNT_AR), XTAG(_DPNDNT_GB), XTAG(_DOTPRODUCT),
        XTAG(_DOT_RFLCT_SPEC_CONST),
    };
    static const int cFmts = sizeof(rgszTMStr) / sizeof(rgszTMStr[0]);

    for(int ifmt = 0; ifmt < cFmts; ifmt++)
    {
        if(rgszTMStr[ifmt].texturemode == TextureMode)
            return rgszTMStr[ifmt].szD3DMSStr;
    }

    return rgszTMStr[cFmts - 1].szD3DMSStr;
}

//=========================================================================
// Stringtize D3DMS_*
//=========================================================================
LPCSTR GetMultiSampleStr(DWORD mstype)
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        DWORD mstype;
        const char *szD3DMSStr;
    } rgszMSStr[] =
    {
        XTAG(D3DMS_NONE), XTAG(D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX), XTAG(D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR),
        XTAG(D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR), XTAG(D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN), XTAG(D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR),
        XTAG(D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN),
        XTAG(D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMS_PREFILTER_FORMAT_DEFAULT),
        XTAG(D3DMS_PREFILTER_FORMAT_X1R5G5B5), XTAG(D3DMS_PREFILTER_FORMAT_R5G6B5),
        XTAG(D3DMS_PREFILTER_FORMAT_X8R8G8B8), XTAG(D3DMS_PREFILTER_FORMAT_A8R8G8B8),
    };
    static const int cFmts = sizeof(rgszMSStr) / sizeof(rgszMSStr[0]);

    for(int ifmt = 0; ifmt < cFmts; ifmt++)
    {
        if(rgszMSStr[ifmt].mstype == mstype)
            return rgszMSStr[ifmt].szD3DMSStr;
    }

    return rgszMSStr[cFmts - 1].szD3DMSStr;
}

//=========================================================================
// Stringtize D3DCMP_*
//=========================================================================
LPCSTR GetD3DCMPStr(D3DCMPFUNC d3dcmpfunc)
{
    static const char *rgszD3DCmp[] =
    {
        "D3DCMP_NEVER",         // 0x200,
        "D3DCMP_LESS",          // 0x201,
        "D3DCMP_EQUAL",         // 0x202,
        "D3DCMP_LESSEQUAL",     // 0x203,
        "D3DCMP_GREATER",       // 0x204,
        "D3DCMP_NOTEQUAL",      // 0x205,
        "D3DCMP_GREATEREQUAL",  // 0x206,
        "D3DCMP_ALWAYS",        // 0x207,
        "??",
    };

    DWORD id3dcmp = min(d3dcmpfunc & 0xf, sizeof(rgszD3DCmp) / sizeof(rgszD3DCmp[0]));
    return rgszD3DCmp[id3dcmp];
}

//=========================================================================
// Stringtize D3DFMT_*
//=========================================================================
LPCSTR GetD3DFormatStr(D3DFORMAT d3dformat)
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        D3DFORMAT d3dformat;
        const char *szD3DFormat;
    } rgszD3DFmt[] =
    {
        XTAG(D3DFMT_A8R8G8B8), XTAG(D3DFMT_X8R8G8B8), XTAG(D3DFMT_R5G6B5),
        XTAG(D3DFMT_R6G5B5), XTAG(D3DFMT_X1R5G5B5), XTAG(D3DFMT_A1R5G5B5),
        XTAG(D3DFMT_A4R4G4B4), XTAG(D3DFMT_A8), XTAG(D3DFMT_A8B8G8R8),
        XTAG(D3DFMT_B8G8R8A8), XTAG(D3DFMT_R4G4B4A4), XTAG(D3DFMT_R5G5B5A1),
        XTAG(D3DFMT_R8G8B8A8), XTAG(D3DFMT_R8B8), XTAG(D3DFMT_G8B8),
        XTAG(D3DFMT_P8), XTAG(D3DFMT_L8), XTAG(D3DFMT_A8L8),
        XTAG(D3DFMT_AL8), XTAG(D3DFMT_L16), XTAG(D3DFMT_V8U8),
        XTAG(D3DFMT_L6V5U5), XTAG(D3DFMT_X8L8V8U8), XTAG(D3DFMT_Q8W8V8U8),
        XTAG(D3DFMT_V16U16), XTAG(D3DFMT_D16_LOCKABLE), XTAG(D3DFMT_D16),
        XTAG(D3DFMT_D24S8), XTAG(D3DFMT_F16), XTAG(D3DFMT_F24S8),
        XTAG(D3DFMT_UYVY), XTAG(D3DFMT_YUY2), XTAG(D3DFMT_DXT1),
        XTAG(D3DFMT_DXT2), XTAG(D3DFMT_DXT3), XTAG(D3DFMT_DXT4),
        XTAG(D3DFMT_DXT5), XTAG(D3DFMT_LIN_A1R5G5B5), XTAG(D3DFMT_LIN_A4R4G4B4),
        XTAG(D3DFMT_LIN_A8), XTAG(D3DFMT_LIN_A8B8G8R8), XTAG(D3DFMT_LIN_A8R8G8B8),
        XTAG(D3DFMT_LIN_B8G8R8A8), XTAG(D3DFMT_LIN_G8B8), XTAG(D3DFMT_LIN_R4G4B4A4),
        XTAG(D3DFMT_LIN_R5G5B5A1), XTAG(D3DFMT_LIN_R5G6B5), XTAG(D3DFMT_LIN_R6G5B5),
        XTAG(D3DFMT_LIN_R8B8), XTAG(D3DFMT_LIN_R8G8B8A8), XTAG(D3DFMT_LIN_X1R5G5B5),
        XTAG(D3DFMT_LIN_X8R8G8B8), XTAG(D3DFMT_LIN_A8L8), XTAG(D3DFMT_LIN_AL8),
        XTAG(D3DFMT_LIN_L16), XTAG(D3DFMT_LIN_L8), XTAG(D3DFMT_LIN_D24S8),
        XTAG(D3DFMT_LIN_F24S8), XTAG(D3DFMT_LIN_D16), XTAG(D3DFMT_LIN_F16),
        XTAG(D3DFMT_UNKNOWN),
    };
    static const int cFmts = sizeof(rgszD3DFmt) / sizeof(rgszD3DFmt[0]);

    for(int ifmt = 0; ifmt < cFmts; ifmt++)
    {
        if(rgszD3DFmt[ifmt].d3dformat == d3dformat)
            return rgszD3DFmt[ifmt].szD3DFormat;
    }

    return rgszD3DFmt[cFmts - 1].szD3DFormat;
}

//=========================================================================
// Check whether specified format is linear
//=========================================================================
bool IsLinearFormat(DWORD Format)
{
    switch(Format)
    {
    case D3DFMT_LIN_A1R5G5B5:
    case D3DFMT_LIN_A4R4G4B4:
    case D3DFMT_LIN_A8:
    case D3DFMT_LIN_A8B8G8R8:
    case D3DFMT_LIN_A8R8G8B8:
    case D3DFMT_LIN_B8G8R8A8:
    case D3DFMT_LIN_G8B8:
    case D3DFMT_LIN_R4G4B4A4:
    case D3DFMT_LIN_R5G5B5A1:
    case D3DFMT_LIN_R5G6B5:
    case D3DFMT_LIN_R6G5B5:
    case D3DFMT_LIN_R8B8:
    case D3DFMT_LIN_R8G8B8A8:
    case D3DFMT_LIN_X1R5G5B5:
    case D3DFMT_LIN_X8R8G8B8:

    case D3DFMT_LIN_A8L8:
    case D3DFMT_LIN_AL8:
    case D3DFMT_LIN_L16:
    case D3DFMT_LIN_L8:

    case D3DFMT_LIN_D24S8:
    case D3DFMT_LIN_F24S8:
    case D3DFMT_LIN_D16:
    case D3DFMT_LIN_F16:
        return true;
    }

    return false;
}

//=========================================================================
// Return number of bits per pixel/texel.
//=========================================================================
DWORD BitsPerPixelOfD3DFORMAT(DWORD Format)
{
    DWORD retval = 0;

    switch(Format)
    {
    case D3DFMT_A8R8G8B8:   // Q8W8V8U8
    case D3DFMT_X8R8G8B8:   // X8L8V8U8
    case D3DFMT_A8B8G8R8:
    case D3DFMT_B8G8R8A8:
    case D3DFMT_R8G8B8A8:
    case D3DFMT_V16U16:
    case D3DFMT_D24S8:
    case D3DFMT_F24S8:
    case D3DFMT_UYVY:
    case D3DFMT_YUY2:
    case D3DFMT_LIN_A8B8G8R8:
    case D3DFMT_LIN_A8R8G8B8:
    case D3DFMT_LIN_B8G8R8A8:
    case D3DFMT_LIN_R8G8B8A8:
    case D3DFMT_LIN_X8R8G8B8:
    case D3DFMT_LIN_D24S8:
    case D3DFMT_LIN_F24S8:
        retval = 32;
        break;

    case D3DFMT_R5G6B5:
    case D3DFMT_X1R5G5B5:
    case D3DFMT_A1R5G5B5:
    case D3DFMT_A4R4G4B4:
    case D3DFMT_R4G4B4A4:
    case D3DFMT_R5G5B5A1:
    case D3DFMT_R8B8:
    case D3DFMT_G8B8:   // V8U8
    case D3DFMT_A8L8:
    case D3DFMT_L16:
    case D3DFMT_L6V5U5:
    case D3DFMT_D16_LOCKABLE:  // D16
    case D3DFMT_F16:
    case D3DFMT_LIN_A1R5G5B5:
    case D3DFMT_LIN_A4R4G4B4:
    case D3DFMT_LIN_G8B8:
    case D3DFMT_LIN_R4G4B4A4:
    case D3DFMT_LIN_R5G5B5A1:
    case D3DFMT_LIN_R5G6B5:
    case D3DFMT_LIN_R6G5B5:
    case D3DFMT_LIN_R8B8:
    case D3DFMT_LIN_X1R5G5B5:
    case D3DFMT_LIN_A8L8:
    case D3DFMT_LIN_L16:
    case D3DFMT_LIN_D16:
    case D3DFMT_LIN_F16:
        retval = 16;
        break;

    case D3DFMT_A8:
    case D3DFMT_P8:
    case D3DFMT_L8:
    case D3DFMT_AL8:
    case D3DFMT_LIN_A8:
    case D3DFMT_LIN_AL8:
    case D3DFMT_LIN_L8:
        retval = 8;
        break;

    case D3DFMT_DXT1:
        retval = 4;
        break;

    case D3DFMT_DXT2: // DXT3
    case D3DFMT_DXT4: // DXT5
        retval = 8;
        break;

    default:
        CheckHR(E_FAIL);
        retval = 0;
        break;
    }

    return retval;
}

//=========================================================================
// Return file's last write time
//=========================================================================
UINT64 GetFileTime(LPCSTR lpFileName)
{
    WIN32_FILE_ATTRIBUTE_DATA fad;

    GetFileAttributesExA(lpFileName, GetFileExInfoStandard, &fad);
    return *(UINT64 *)&fad.ftLastWriteTime;
}

//=========================================================================
// Display d3d error then break into debugger
//=========================================================================
void DisplayError(const char *szCall, HRESULT hr)
{
    char szErr[512];

    if(hr)
    {
        UINT cch = _snprintf(szErr, sizeof(szErr), "FATAL: %s failed 0x%08lX: ", szCall, hr);

        D3DXGetErrorStringA(hr, &szErr[cch], sizeof(szErr) - cch - 1);
    }
    else
    {
        lstrcpynA(szErr, szCall, sizeof(szErr) - 1);
    }

    lstrcatA(szErr, "\n");
    OutputDebugStringA(szErr);

    _asm int 3;
}

//=========================================================================
// Formatted debug squirty
//=========================================================================
void _cdecl dprintf(LPCSTR lpFmt, ...)
{
    va_list arglist;
    char lpOutput[256];

    va_start(arglist, lpFmt);
    _vsnprintf(lpOutput, sizeof(lpOutput), lpFmt, arglist);
    va_end(arglist);

    OutputDebugStringA(lpOutput);
}

//=========================================================================
// Draw CScrText text buffer to front buffer
//=========================================================================
void CScrText::drawtext(bool fDebugSquirty)
{
    IDirect3DSurface8 *pFrontBuffer = NULL;

    D3DDevice_GetBackBuffer(-1, D3DBACKBUFFER_TYPE_MONO, &pFrontBuffer);
    if(pFrontBuffer)
    {
        // render results to the frontbuffer
        DWORD dx = 40;
        DWORD dy = 20;
        DWORD dwHeight;

        g_bitfont.GetTextStringLength(NULL, &dwHeight, NULL);
        dwHeight += 2;

        for(int iBuf = 0; iBuf < m_iLine; iBuf++)
        {
            if(fDebugSquirty)
                dprintf("%s\n", m_rgText[iBuf]);

            if(m_rgText[iBuf][0])
                g_bitfont.DrawText(pFrontBuffer, m_rgText[iBuf], dx, dy, 0, 0xff9f9f9f, 0);

            dy += dwHeight;
        }

        RELEASE(pFrontBuffer);
    }
}

//=========================================================================
// Add a string to the CScrText string buffer
//=========================================================================
void _cdecl CScrText::printf(LPCSTR lpFmt, ...)
{
    va_list arglist;

    va_start(arglist, lpFmt);
    _vsnprintf(m_rgText[m_iLine], LINE_WIDTH, lpFmt, arglist);
    va_end(arglist);

	//7 sep 2001: prevent buffer overrun when printing text on the last line
	m_rgText[m_iLine][LINE_WIDTH - 1] = '\0'; 

    m_iLine = (m_iLine + 1) % NUM_LINES;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\fillrate\inifile.cpp ===
//-----------------------------------------------------------------------------
// FILE: INIFILE.CPP
//
// Desc: fake ini file routines
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include <assert.h>

#include "utils.h"
#include "inifile.h"

//=========================================================================
// Get the value of a constant
//=========================================================================
LPCSTR CIniFile::GetIniConstValue(const char *szStr, INIVAL *pinival)
{
    // skip whitespace
    while(*szStr == ' ' || *szStr == '\t')
        szStr++;

    if((*szStr >= '0' && *szStr <= '9') || (*szStr == '.'))
    {
        char *endptr;
        int base = 10;

        if(szStr[1] == 'x')
        {
            // hexadecimal: skip over leading '0x'
            base = 16;
            szStr += 2;
        }
        else if(pinival->type == INIVAL_FLOAT)
        {
            // check for floating point value
            for(const char *szT = szStr;
                *szT && ((*szT >= '0' && *szStr <= '9') || *szT == '.');
                szT++)
            {
                if(*szT == '.')
                {
                    for(szT++; *szT && (*szT >= '0' && *szStr <= '9'); szT++)
                        ;

                    // check for trailing f
                    if(*szT == 'f')
                        szT++;

                    pinival->SetVal((float)atof(szStr));
                    return szT;
                }
            }
        }

        pinival->SetVal((int)strtoul(szStr, &endptr, base));
        return endptr;
    }

    // token length
    int cchStr = 0;

    // find token length
    for(const char *szT = szStr; *szT && (*szT != ';') && (*szT != '|') && !isspace(*szT); szT++)
        cchStr++;

    // see if the token is known by the app
    if(GetIniConstf(szStr, cchStr, &pinival->valf))
    {
        pinival->val = (int)pinival->valf;
        return szStr + cchStr;
    }
    else if(GetIniConst(szStr, cchStr, &pinival->val))
    {
        pinival->valf = (float)pinival->val;
        return szStr + cchStr;
    }

    // couldn't find token - search in [defines] section
    if(m_recurselevel < 10)
    {
        char szKeyName[64];
        static const char szSectName[] = "defines";

        lstrcpynA(szKeyName, szStr, min(sizeof(szKeyName), cchStr + 1));

        LPCSTR szLineStart;
        LPCSTR szLine = GetIniStr(szSectName, szKeyName, NULL, &szLineStart);

        if(szLine)
        {
            bool fFoundDefine = false;

            m_recurselevel++;

            // did not find entry - search in defines section
            if(pinival->type == INIVAL_FLOAT)
            {
                fFoundDefine = ParseFloatVal(szLineStart, szLine, &pinival->valf);
                pinival->val = (int)pinival->valf;
            }
            else
            {
                fFoundDefine = ParseIntVal(szLineStart, szLine, &pinival->val);
                pinival->valf = (float)pinival->val;
            }

            m_recurselevel--;

            if(fFoundDefine)
                return szStr + cchStr;
        }
    }

    return NULL;
}

//=========================================================================
// Read a file and return malloc'd pointer to data
//=========================================================================
char *SzReadFile(LPCSTR szFileName)
{

    HANDLE hFile = CreateFile(szFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        DWORD dwSize = GetFileSize(hFile, NULL);
        char *szFile = (char *)malloc(dwSize + 1);

        DWORD NumberOfBytesRead;
        ReadFile(hFile, szFile, dwSize, &NumberOfBytesRead, NULL);

        assert(dwSize == NumberOfBytesRead);
        szFile[NumberOfBytesRead] = 0;

        CloseHandle(hFile);
        return szFile;
    }

    return NULL;
}

//=========================================================================
// Read/refresh ini file
//=========================================================================
bool CIniFile::ReadFile()
{
    if(m_szFile)
    {
        free(m_szFile);
        m_szFile = NULL;
    }

    m_szFile = SzReadFile(m_szFileName);
    if(!m_szFile)
    {
        // if file read failed - sleep a short bit in case xbcp
        // had file open still.
        Sleep(500);
        m_szFile = SzReadFile(m_szFileName);
    }

    if(m_szFile)
    {
        m_ftFileReadTime = GetFileTime(m_szFileName);
        return true;
    }

    return false;
}

//=========================================================================
// Find the next real line and return pointer
//=========================================================================
LPCSTR GetLine(LPCSTR szLine)
{
    for(;;)
    {
        // skip whitespace
        while(isspace(*szLine))
            szLine++;

        // check for comments
        if(*szLine == ';' || (szLine[0] == '/' && szLine[1] == '/'))
        {
            // found a comment - cruise to end of line
            while(*szLine && *szLine != '\n')
                szLine++;
            continue;
        }

        return szLine;
    }
}

//=========================================================================
// Get first line of INI file
//=========================================================================
LPCSTR FindFirstLine(LPCSTR szFile)
{
    if(szFile)
        return GetLine(szFile);

    return NULL;
}

//=========================================================================
// Get line after szLine
//=========================================================================
LPCSTR FindNextLine(LPCSTR szLine)
{
    if(szLine)
    {
        while(*szLine && *szLine++ != '\n')
            ;
        return GetLine(szLine);
    }

    return NULL;
}

//=========================================================================
// Find the next token's first char
//=========================================================================
char FindNextChar(LPCSTR szLine, LPCSTR *ppszLine = NULL)
{
    // skip whitespace
    while(*szLine == ' ' || *szLine == '\t')
        szLine++;

    if(ppszLine)
        *ppszLine = szLine;
    return *szLine;
}

//=========================================================================
// Print out error message for something we couldn't parse
//=========================================================================
void OutputLineErr(LPCSTR szErr, LPCSTR szLine)
{
    LPCSTR szEnd = szLine;
    while(*szEnd && (*szEnd != '\r' && *szEnd != '\n'))
        szEnd++;

    char chSav = *szEnd;
    *(char *)szEnd = 0;

    OutputDebugStringA(szErr);
    OutputDebugStringA(":");
    OutputDebugStringA(szLine);
    OutputDebugStringA("\n");

    *(char *)szEnd = chSav;
}

//=========================================================================
// Parse a token stream and return the value
//=========================================================================
bool CIniFile::ParseFloatVal(LPCSTR szLineStart, LPCSTR szLine, float *pval)
{
    INIVAL valT = { INIVAL_FLOAT };
    if(GetIniConstValue(szLine, &valT))
    {
        *pval = valT.valf;
        return true;
    }

    OutputLineErr("unknown token", szLineStart);
    return false;
}

//=========================================================================
// Parse a token stream and return the value
//=========================================================================
bool CIniFile::ParseIntVal(LPCSTR szLineStart, LPCSTR szLine, int *pval)
{
    INIVAL valT = { INIVAL_INT };
    int val = 0;

    while(szLine = GetIniConstValue(szLine, &valT))
    {
        val |= valT.val;

        char ch = FindNextChar(szLine, &szLine);
        switch(ch)
        {
        case '|':
            szLine++;
            break;
        case '\r':
        case '\n':
        case '\0':
        case ';':
            // end of the line
            *pval = val;
            return true;
        default:
            OutputLineErr("unknown char", szLineStart);
            return false;
        }
    }

    OutputLineErr("unknown token", szLineStart);
    return false;
}

//=========================================================================
// Get float value for ini entry
//=========================================================================
float CIniFile::GetIniFloat(LPCSTR lpSectionName, LPCSTR lpKeyName, float nDefault)
{
    LPCSTR szLineStart;
    LPCSTR szLine = GetIniStr(lpSectionName, lpKeyName, NULL, &szLineStart);

    if(!szLine)
        return nDefault;

    ParseFloatVal(szLineStart, szLine, &nDefault);
    return nDefault;
}

//=========================================================================
// Get int value for ini entry
//=========================================================================
int CIniFile::GetIniInt(LPCSTR lpSectionName, LPCSTR lpKeyName, int nDefault)
{
    LPCSTR szLineStart;
    LPCSTR szLine = GetIniStr(lpSectionName, lpKeyName, NULL, &szLineStart);

    if(!szLine)
        return nDefault;

    ParseIntVal(szLineStart, szLine, &nDefault);
    return nDefault;
}

//=========================================================================
// Check if an ini entry exists
//=========================================================================
bool CIniFile::IniEntryExists(LPCSTR lpSectionName, LPCSTR lpKeyName)
{
    bool fverboseBak = m_fverbose;
    m_fverbose = false;

    LPCSTR szLine = GetIniStr(lpSectionName, lpKeyName, NULL, NULL);

    m_fverbose = fverboseBak;
    return !!szLine;
}

//=========================================================================
// Get an INI string and shtuff it into a buffer
//=========================================================================
bool CIniFile::GetIniStrBuf(LPCSTR lpSectionName, LPCSTR lpKeyName,
    LPCSTR szDefault, char *buf, int buflen)
{
    LPCSTR szLine = GetIniStr(lpSectionName, lpKeyName, NULL, NULL);
    if(szLine)
    {
        strncpy(buf, szLine, buflen);

        for(int nT = 0; nT < buflen; nT++)
        {
            if(buf[nT] == '\n' || buf[nT] == '\r' || buf[nT] == ';')
            {
                buf[nT] = 0;
                break;
            }
        }
    }
    else
    {
        strncpy(buf, szDefault, buflen);
    }

    buf[buflen - 1] = 0;
    return !!szLine;
}

//=========================================================================
// Return non-nil terminated string for keyname
//=========================================================================
LPCSTR CIniFile::GetIniStr(LPCSTR lpSectionName, LPCSTR lpKeyName, LPCSTR szDefault,
    LPCSTR *ppszLineStart)
{
    assert(m_szFile);
    if(!m_szFile)
        return szDefault;

    bool finsection = false;
    int cchSectionName = lstrlenA(lpSectionName);
    int cchKeyName = lstrlenA(lpKeyName);
    LPCSTR szLine = FindFirstLine(m_szFile);

    while(szLine && *szLine)
    {
        if(ppszLineStart)
            *ppszLineStart = szLine;

        if(finsection)
        {
            if(*szLine == '[')
            {
                // new section - not found
                break;
            }
            else if(!_strnicmp(lpKeyName, szLine, cchKeyName) &&
                (FindNextChar(szLine + cchKeyName, &szLine) == '='))
            {
                // skip over '='
                szLine++;

                // skip whitespace
                while(*szLine == ' ' || *szLine == '\t')
                    szLine++;

                return szLine;
            }
        }
        else if(*szLine == '[')
        {
            // section name matches?
            szLine++;
            finsection = !_strnicmp(lpSectionName, szLine, cchSectionName) &&
                (FindNextChar(szLine + cchSectionName) == ']');
        }

        szLine = FindNextLine(szLine);
    }

    if(m_fverbose)
        dprintf("entry [%s]/%s not found\n", lpSectionName, lpKeyName);
    return szDefault;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\fillrate\fillrate.h ===
//-----------------------------------------------------------------------------
// FILE: FILLRATE.H
//
// Desc: fillrate header
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

enum { TEX_None, TEX_2d, TEX_Cubemap, TEX_Volume, TEX_Max };
enum { TIME_Present = 0x1, TIME_Render = 0x2 };

struct TIMETESTRESULTS
{
    float   fillrate;
    float   fps;
    int     cFrames;
    float   TimeTillDoneDrawing;
    float   TimeTillIdle;
    UINT64  cNumPixelsDrawn;
};

struct FRSETTINGS
{
    UINT overdraw;                      // number of overdraws in a scene
    UINT verboselevel;                  // chatty when loading pixelshader defs, etc.
    UINT runtestonreload;               // after reloading fillrate.ini run test

    UINT screenwidth;                   // screen width
    UINT screenheight;                  // screen height
    D3DFORMAT BackBufferFormat;         // back buffer d3dformat
    D3DFORMAT AutoDepthStencilFormat;   // z buffer format (0 for none)

    D3DMULTISAMPLE_TYPE MSType;         // multisample type
    D3DMULTISAMPLE_TYPE MSFormat;       // multisample format

    DWORD FVF;                          // fvf type
    float quadwidth;                    // quad width
    float quadheight;                   // quad height
    float quadx;
    float quady;

    bool specularenable;                // specularenable
    bool zenable;                       // enable z buffer
    bool zwriteenable;                  // enable z write
    D3DCMPFUNC d3dcmpfunc;              // z compare function

    bool primez;                        // prime z with quad/D3DCMP_ALWAYS before drawing scene
    D3DCMPFUNC primezcmpfunc;           // z prime compare function

    UINT timeflags;                     // what to time: TIME_Present, TIME_Render, ...
    int numberscenes;                   // number of scenes to time (0 to use testtime)
    float testtime;                     // number of seconds to time

    DWORD clearflags;                   // Clear() flags
    DWORD cclearval;                    // color clear val
    float zclearval;                    // z clear val
    DWORD sclearval;                    // stencil clear val

    bool userpixelshader;               // use a userpixelshader
    D3DPIXELSHADERDEF shaderdef;        // the users pixel shader def

    bool alphablendenable;              // turn on alphablending
    bool alphatestenable;               // turn on alphatesting
    bool rotatetex;                     // rotate texture
    bool tiltz;                         // top edge z of 0, bottom edge z of 1.0

    struct FRTEX
    {
        UINT type;                      // type of texture (TEX_None, TEX_2d, TEX_Cubemap, TEX_Volume)
        UINT texsize;                   // size of texture
        D3DFORMAT d3dFormat;            // format of tetxure
        D3DTEXTUREFILTERTYPE filtertype;// filtertype
        D3DTEXTUREFILTERTYPE mipfilter;
    } rgtex[4];

    D3DSWATHWIDTH SwathWidth;           // swadth width

    D3DTEXTUREOP ColorOp;               // color op (if !userpixelshader)
    D3DTEXTUREOP AlphaOp;               // alpha op (if !userpixelshader)

    D3DFILLMODE d3dfillmode;            // SOLID, WIREFRAME, ...
    DWORD colorwriteenable;             // D3DRS_COLORWRITEENABLE flags
};

// macros to help us define the size of our texcoords in fillrate.ini
static const DWORD T0_SIZE1 = D3DFVF_TEXCOORDSIZE1(0);
static const DWORD T0_SIZE2 = D3DFVF_TEXCOORDSIZE2(0);
static const DWORD T0_SIZE3 = D3DFVF_TEXCOORDSIZE3(0);
static const DWORD T0_SIZE4 = D3DFVF_TEXCOORDSIZE4(0);

static const DWORD T1_SIZE1 = D3DFVF_TEXCOORDSIZE1(1);
static const DWORD T1_SIZE2 = D3DFVF_TEXCOORDSIZE2(1);
static const DWORD T1_SIZE3 = D3DFVF_TEXCOORDSIZE3(1);
static const DWORD T1_SIZE4 = D3DFVF_TEXCOORDSIZE4(1);

static const DWORD T2_SIZE1 = D3DFVF_TEXCOORDSIZE1(2);
static const DWORD T2_SIZE2 = D3DFVF_TEXCOORDSIZE2(2);
static const DWORD T2_SIZE3 = D3DFVF_TEXCOORDSIZE3(2);
static const DWORD T2_SIZE4 = D3DFVF_TEXCOORDSIZE4(2);

static const DWORD T3_SIZE1 = D3DFVF_TEXCOORDSIZE1(3);
static const DWORD T3_SIZE2 = D3DFVF_TEXCOORDSIZE2(3);
static const DWORD T3_SIZE3 = D3DFVF_TEXCOORDSIZE3(3);
static const DWORD T3_SIZE4 = D3DFVF_TEXCOORDSIZE4(3);

// fillrate.cpp
float DoTimedTest(TIMETESTRESULTS *pttres = NULL);
void DoCompleteTimedTest();
void DoQuickTimedTest();
void DoMultiSampleTimedTest();
void DumpCurrentSettings();
void DoTextureTest();

void ReadPixelShaderIni(D3DPIXELSHADERDEF *pshaderdef);
bool ReadFRIniFile();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\fillrate\vstune\vstune.cpp ===
//-----------------------------------------------------------------------------
// FILE: FILLRATE.CPP
//
// Desc: vertex shader tune app
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <d3d8perf.h>
#include <stdio.h>
#include <assert.h>

// With the profile build we can spew out how much time
// was spent in pushbuffer waits. However you must link
// with d3d8i.lib so it's off by default.
#define PROFILE     0

#include "utils.h"
#include "inifile.h"
#include "vstune.h"

/*
 * globals
 */
IDirect3DDevice8       *g_pDev = NULL;                  // our device
IDirect3DVertexBuffer8 *g_pVB[16] = {NULL};             // stream vertex buffers
IDirect3DTexture8      *g_pTextures[4] = { NULL };

DWORD                  *g_pAlloc = NULL;                // a random WC allocation
const int               g_AllocSize = 1024*1024;        // random allocation size

DWORD                   g_dwVertexShader;               // vertex shader handle

DWORD                   g_dwFVFSize[16];                // FVF sizes for each stream

WORD                   *g_pindices = NULL;              // out indices

HANDLE                  g_hInpDevice = NULL;            // input device

CScrText                g_scrtext;                      // text helper
CIniFile                g_inifile("d:\\vstune.ini");    // Ini file

bool                    g_fRedrawScreen = true;         // refresh screen?
volatile bool           g_gpudrawingdone = false;       // is the gpu done drawing?

VSTSETTINGS             g_var = {0};                    // current settings

DWORD                   g_Declaration[MAX_FVF_DECL_SIZE]; // vertex shader declaration
DWORD                   g_nvclk = 233;

HANDLE                  g_hThread = NULL;

D3DPERF                 *g_pPerf;

struct
{
    LPCSTR szDesc;
    void (*pfnTest)();
} g_rgTests[] =
{
    { "Current",                DoQuickTimedTest },
    { "PushBuffer Call Test",   DoPushBufferCallTest },
};
UINT g_iCurTest = 0;

//=========================================================================
// Init Direct3d
//=========================================================================
bool InitD3D()
{
    static D3DPRESENT_PARAMETERS d3dppCur = {0};
    D3DPRESENT_PARAMETERS d3dpp = {0};

    // Set the screen mode.
    d3dpp.BackBufferWidth                   = UINT(g_var.screenwidth);
    d3dpp.BackBufferHeight                  = UINT(g_var.screenheight);
    d3dpp.BackBufferFormat                  = g_var.BackBufferFormat;
    d3dpp.BackBufferCount                   = 1;
    d3dpp.EnableAutoDepthStencil            = !!g_var.AutoDepthStencilFormat;
    d3dpp.AutoDepthStencilFormat            = g_var.AutoDepthStencilFormat;
    d3dpp.SwapEffect                        = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz        = 60;
    d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;
    d3dpp.Flags                             = // D3DCREATE_NOPRESENTTHROTTLE |
                                                D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;

    if(g_var.MSType != D3DMULTISAMPLE_NONE)
        d3dpp.MultiSampleType = (D3DMULTISAMPLE_TYPE)((DWORD)(g_var.MSType) | (DWORD)(g_var.MSFormat));

    // if nothing has changed - don't reinit
    if(!memcmp(&d3dppCur, &d3dpp, sizeof(D3DPRESENT_PARAMETERS)))
        return true;
    d3dppCur = d3dpp;

    if(g_pDev)
    {
        for(int itex = 0; itex < 4; itex++)
            RELEASE(g_pTextures[itex]);

        if(g_dwVertexShader)
        {
            g_pDev->SetVertexShader(D3DFVF_XYZ);
            g_pDev->DeleteVertexShader(g_dwVertexShader);
            g_dwVertexShader = 0;
        }

        // make sure everything is freed
        for(int ivb = 0; ivb < ARRAYSIZE(g_pVB); ivb++)
            RELEASE(g_pVB[ivb]);
        RELEASE(g_pDev);
    }

    // Create the device.
    if(Direct3D_CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
        NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDev))
    {
        CheckHR(E_FAIL);
        return false;
    }

    for(int itex = 0; itex < 4; itex++)
    {
        CheckHR(g_pDev->CreateTexture(4, 4, 1, 0, D3DFMT_A4R4G4B4,
            D3DPOOL_MANAGED, &g_pTextures[itex]));
    }

    g_nvclk = GetNVCLK();
    dprintf("gpu clk: %d\n", g_nvclk);

    return true;
}

//=========================================================================
// quick routine to return token type from decl
//=========================================================================
inline DWORD VSDGetTokenType(DWORD dwDecl)
{
    return (dwDecl & D3DVSD_TOKENTYPEMASK) >> D3DVSD_TOKENTYPESHIFT;
}

//=========================================================================
// return data type from decl
//=========================================================================
inline DWORD VSDGetDataType(DWORD dwDecl)
{
    return (dwDecl & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT;
}

//=========================================================================
// get skip count from decl
//=========================================================================
inline DWORD VSDGetSkipCount(DWORD dwDecl)
{
    return (dwDecl & D3DVSD_SKIPCOUNTMASK) >> D3DVSD_SKIPCOUNTSHIFT;
}

//=========================================================================
// Given a D3DVSD_TOKEN_STREAMDATA return # of bytes it requires
//=========================================================================
DWORD dwBytesForStreamData(DWORD dwDecl)
{
    if(dwDecl & 0x08000000)
    {
        // D3DVSD_SKIPBYTES
        return VSDGetSkipCount(dwDecl);
    }
    else if(dwDecl & 0x10000000)
    {
        // D3DVSD_SKIP DWORDS
        return VSDGetSkipCount(dwDecl) * sizeof(DWORD);
    }
    else
    {
        DWORD dwType = VSDGetDataType(dwDecl);
        DWORD dwCount = (dwType >> 4) & 0xf;

        switch(dwType & 0xf)
        {
        case 0x0:   // D3DCOLOR
            return dwCount * sizeof(BYTE);
        case 0x2:   // float
            return dwCount * sizeof(float);
        case 0x1:   // NORMSHORT
        case 0x5:   // short
            return dwCount * sizeof(short);
        case 0x6:   // NORMPACKED
            return dwCount * sizeof(DWORD);
        case 0x4:   // PBYTE
            return dwCount * sizeof(BYTE);
        }
    }

    return 0;
}

//=========================================================================
// Return vert size for specific stream in declaration
//=========================================================================
DWORD GetDeclVertexSize(DWORD dwStream, DWORD *pDecl)
{
    DWORD dwBytes = 0;
    DWORD dwCurStream = (DWORD)-1;

    while(*pDecl != D3DVSD_END())
    {
        if(VSDGetTokenType(*pDecl) == D3DVSD_TOKEN_STREAM)
        {
            dwCurStream = *pDecl & D3DVSD_STREAMNUMBERMASK;
        }
        else if(dwCurStream == dwStream &&
            VSDGetTokenType(*pDecl) == D3DVSD_TOKEN_STREAMDATA)
        {
            dwBytes += dwBytesForStreamData(*pDecl);
        }

        pDecl++;
    }

    return dwBytes;
}

//=========================================================================
// Create our index buffer
//=========================================================================
void CreateIB()
{
    if(g_pindices)
    {
        delete [] g_pindices;
        g_pindices = NULL;
    }

    if(g_var.pushbuffernops)
        g_var.TriCount = g_var.indexcount;
    else
    {
        switch(g_var.primitivetype)
        {
        case D3DPT_POINTLIST:
            g_var.TriCount = g_var.indexcount;
            break;
        case D3DPT_TRIANGLELIST:
            g_var.indexcount = (g_var.indexcount / 3) * 3;
            g_var.TriCount = g_var.indexcount / 3;
            break;
        case D3DPT_TRIANGLESTRIP:
        case D3DPT_TRIANGLEFAN:
            g_var.TriCount = g_var.indexcount - 2;
            break;
        case D3DPT_QUADLIST:
            g_var.indexcount = (g_var.indexcount / 4) * 4;
            g_var.TriCount = g_var.indexcount / 2;
            break;
        case D3DPT_QUADSTRIP:
            g_var.indexcount = (g_var.indexcount / 2) * 2;
            g_var.TriCount = (g_var.indexcount / 2 - 1) * 2;
            break;
        case D3DPT_POLYGON:
        case D3DPT_LINELIST:
        case D3DPT_LINELOOP:
        case D3DPT_LINESTRIP:
        default:
            g_var.TriCount = g_var.indexcount;
            _asm int 3;
            break;
        }
    }

    // create our index buffer
    g_pindices = new WORD [g_var.indexcount];

    WORD *pindices = g_pindices;
    for(UINT ivert = 0; ivert < g_var.indexcount; ivert++)
    {
        *pindices++ = LOWORD(ivert % g_var.vertcount);
    }
}

//=========================================================================
// Copy count of floats from src to dst
//=========================================================================
inline float *MyMemCpy(float *dst, const float *src, int count)
{
    memcpy(dst, src, count * sizeof(float));
    return dst + count;
}

//=========================================================================
// Create our vertex buffer for specific stream defined in g_pDeclaration
//=========================================================================
void CreateVB(DWORD istream)
{
    RELEASE(g_pVB[istream]);

    if(!g_var.FVF)
    {
        // calculate stream size and length
        g_dwFVFSize[istream] = GetDeclVertexSize(istream, g_Declaration);

        UINT VBLength = g_dwFVFSize[istream] * g_var.vertcount;

        CheckHR(g_pDev->CreateVertexBuffer(VBLength, 0, 0, 0, &g_pVB[istream]));

        byte *pVerts;
        CheckHR(g_pVB[istream]->Lock(0, VBLength, (BYTE **)&pVerts, 0));

        // Fill it up.
        memset(pVerts, 0x11, VBLength);

        CheckHR(g_pVB[istream]->Unlock());
    }
    else
    {
        g_dwFVFSize[istream] = D3DXGetFVFVertexSize(g_var.FVF);

        UINT VBLength = g_dwFVFSize[istream] * g_var.vertcount;

        CheckHR(g_pDev->CreateVertexBuffer(VBLength, 0, 0, 0, &g_pVB[istream]));

        float *pVerts;
        CheckHR(g_pVB[istream]->Lock(0, VBLength, (BYTE **)&pVerts, 0));

        int dy = 0;
        int iIndex = 0;
        D3DXVECTOR4 tex0(0, 0, 0, 1.0f);
        D3DXVECTOR4 pos(-2000, -2000, .5f, 1.0f);
        D3DXVECTOR3 norm(0, .707f, .707f);
        DWORD diffuse = D3DCOLOR_COLORVALUE(tex0.x, tex0.y, 1.0f - tex0.x, 2.0f / 0xff);

        for(UINT ivert = 0; ivert < g_var.vertcount; ivert++)
        {
            if(!g_var.degenerates)
            {
                static float xval = 4.0f;
                static float yval = 4.0f;

                pos.x = xval * (iIndex / 2);
                pos.y = dy + yval * (iIndex & 0x1);

                // if we're not doing just degenerate tris then move along
                // in a nice little grid pattern
                iIndex++;

                if(pos.x + xval > g_var.screenwidth)
                {
                    iIndex = 0;
                    dy += int(yval) + 1;
                }
            }

            if(g_var.FVF & D3DFVF_XYZRHW)
                pVerts = MyMemCpy(pVerts, pos, 4);
            else if(g_var.FVF & D3DFVF_XYZ)
                pVerts = MyMemCpy(pVerts, pos, 3);

            if(g_var.FVF & D3DFVF_NORMAL)
                pVerts = MyMemCpy(pVerts, norm, 3);

            if(g_var.FVF & D3DFVF_DIFFUSE)
                *(DWORD *)pVerts++ = diffuse;

            if(g_var.FVF & D3DFVF_SPECULAR)
                *(DWORD *)pVerts++ = ~diffuse;

            // Texture coordinates
            UINT uNumTexCoords = (((g_var.FVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT);
            UINT uTextureFormats = g_var.FVF >> 16;

            if(uTextureFormats)
            {
                for(UINT i = 0; i < uNumTexCoords; i++)
                {
                    switch(uTextureFormats & 3)
                    {
                    case D3DFVF_TEXTUREFORMAT1:     // u
                        *pVerts++ = tex0.x;
                        break;
                    case D3DFVF_TEXTUREFORMAT2:     // u,v
                        pVerts = MyMemCpy(pVerts, tex0, 2);
                        break;
                    case D3DFVF_TEXTUREFORMAT3:     // s,t,r
                        pVerts = MyMemCpy(pVerts, tex0, 3);
                        break;
                    case D3DFVF_TEXTUREFORMAT4:     // s,t,r,q
                        pVerts = MyMemCpy(pVerts, tex0, 4);
                        break;
                    }

                    uTextureFormats >>= 2;
                }
            }
            else while(uNumTexCoords--)
            {
                // u,v
                pVerts = MyMemCpy(pVerts, tex0, 2);
            }
        }

        CheckHR(g_pVB[istream]->Unlock());
    }
}

//=========================================================================
// initialize our lights
//=========================================================================
void InitLights()
{
    // disable all our existing lights
    for(DWORD i = 0; i < g_var.NumLights; i++)
        CheckHR(g_pDev->LightEnable(g_var.NumLights, FALSE));

    // get count of new lights
    g_var.NumLights =
        g_var.numDirectionalLights +
        g_var.numPointLights +
        g_var.numSpotLights;

    // setup lights
    float fIntensity = 1.0f / g_var.NumLights;
    D3DXCOLOR Diffuse(fIntensity, fIntensity, fIntensity, 1.0f);

    DWORD dwIndex = 0;
    for(i = 0; i < g_var.numDirectionalLights; i++)
    {
        D3DLIGHT8 lig = { D3DLIGHT_DIRECTIONAL };

        lig.Diffuse     =  Diffuse;
        lig.Direction   =  D3DXVECTOR3(0.2f, 0.3f, -0.8f);

        CheckHR(g_pDev->SetLight(dwIndex, &lig));
        CheckHR(g_pDev->LightEnable(dwIndex, TRUE));
        dwIndex++;
    }

    for(i = 0; i < g_var.numPointLights; i++)
    {
        D3DLIGHT8 lig = { D3DLIGHT_POINT };

        lig.Diffuse      =  Diffuse;
        lig.Position     =  D3DXVECTOR3(0.0f, 0.0f, 5.0f);
        lig.Range        = 9999.0f;
        lig.Attenuation0 = 1.0f;

        CheckHR(g_pDev->SetLight(dwIndex, &lig));
        CheckHR(g_pDev->LightEnable(dwIndex, TRUE));
        dwIndex++;
    }

    for(i = 0; i < g_var.numSpotLights; i++)
    {
        D3DLIGHT8 lig = { D3DLIGHT_SPOT };

        lig.Diffuse      = Diffuse;
        lig.Position     = D3DXVECTOR3(-1.0f, -5.0f, 6.0f);
        lig.Direction    = D3DXVECTOR3(0.1f, 0.5f, -0.6f);
        lig.Range        = 999.0f;
        lig.Theta        = 0.1f;
        lig.Phi          = 0.5f;
        lig.Falloff      = 1.0f;
        lig.Attenuation0 = 1.0f;

        CheckHR(g_pDev->SetLight(dwIndex, &lig));
        CheckHR(g_pDev->LightEnable(dwIndex, TRUE));
        dwIndex++;
    }
}


//=========================================================================
// Initialize fillrate app
//=========================================================================
bool InitVST(bool freadINIFile)
{
    if(freadINIFile && !ReadVSTIniFile())
        dprintf("%s not found", g_inifile.GetFileName());

    // init d3d
    if(!InitD3D())
    {
        dprintf("InitD3D failed.\n");
        return false;
    }

    // init our render states
    CheckHR(g_pDev->SetRenderState(D3DRS_LIGHTING,  g_var.lighting));
    CheckHR(g_pDev->SetRenderState(D3DRS_SPECULARENABLE, g_var.specularenable));
    CheckHR(g_pDev->SetRenderState(D3DRS_LOCALVIEWER, g_var.localviewer));
    CheckHR(g_pDev->SetRenderState(D3DRS_NORMALIZENORMALS, g_var.normalizenormals));

    CheckHR(g_pDev->SetRenderState(D3DRS_COLORVERTEX, g_var.colorvertex));

    static DWORD dwMatSource = D3DMCS_COLOR1;
    CheckHR(g_pDev->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE,  dwMatSource));
    CheckHR(g_pDev->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, dwMatSource));
    CheckHR(g_pDev->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE,  dwMatSource));
    CheckHR(g_pDev->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, dwMatSource));

    CheckHR(g_pDev->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_FLAT));

    CheckHR(g_pDev->SetRenderState(D3DRS_FOGENABLE, g_var.fogenable));

    // z buffer
    CheckHR(g_pDev->SetRenderState(D3DRS_ZENABLE, g_var.zenable));
    CheckHR(g_pDev->SetRenderState(D3DRS_ZWRITEENABLE, g_var.zwriteenable));
    CheckHR(g_pDev->SetRenderState(D3DRS_ZFUNC, g_var.d3dcmpfunc));

    // alpha blending
    CheckHR(g_pDev->SetRenderState(D3DRS_ALPHABLENDENABLE, g_var.alphablendenable));
    CheckHR(g_pDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA));
    CheckHR(g_pDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA));

    CheckHR(g_pDev->SetRenderState(D3DRS_ALPHATESTENABLE, g_var.alphatestenable));
    CheckHR(g_pDev->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_ALWAYS));
    CheckHR(g_pDev->SetRenderState(D3DRS_ALPHAREF, 0x00000001));

    // fill and cull mode
    CheckHR(g_pDev->SetRenderState(D3DRS_FILLMODE, g_var.d3dfillmode));
    CheckHR(g_pDev->SetRenderState(D3DRS_CULLMODE, g_var.cullmode));

    // initialize lights
    InitLights();

    // initialize vertex shader or FVF declaration
    InitVertexShader();

    // set up texture stages
    for(DWORD itex = 0; itex < 4; itex++)
    {
        if(itex < g_var.numtextures)
        {
            CheckHR(g_pDev->SetTexture(itex, g_pTextures[itex]));

            CheckHR(g_pDev->SetTextureStageState(0, D3DTSS_COLORARG1,D3DTA_TEXTURE));
            CheckHR(g_pDev->SetTextureStageState(0, D3DTSS_COLOROP,  D3DTOP_MODULATE));
            CheckHR(g_pDev->SetTextureStageState(0, D3DTSS_COLORARG2,D3DTA_DIFFUSE));

            CheckHR(g_pDev->SetTextureStageState(0, D3DTSS_ALPHAARG1,D3DTA_TEXTURE));
            CheckHR(g_pDev->SetTextureStageState(0, D3DTSS_ALPHAOP,  D3DTOP_MODULATE));
            CheckHR(g_pDev->SetTextureStageState(0, D3DTSS_ALPHAARG2,D3DTA_DIFFUSE));
        }
        else
        {
            CheckHR(g_pDev->SetTexture(itex, NULL));

            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_COLOROP, D3DTOP_DISABLE));
            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_ALPHAOP, D3DTOP_DISABLE));
        }

        CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP));
        CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP));

        CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_MINFILTER, D3DTEXF_LINEAR));
        CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_MAGFILTER, D3DTEXF_LINEAR));
    }

    // create our index buffer
    CreateIB();

    // create all our vertex buffer streams
    for(DWORD istream = 0; istream < g_var.NumStreams; istream++)
        CreateVB(istream);

    // Initialize our VAB entries so we have consistent and unique values
    for(DWORD Register = 0; Register < 16; Register++)
    {
        float val = (float)Register;

        g_pDev->SetVertexData4f(Register,
            val + .1f, val + .2f, val + .3f, val + .4f);
    }

    // if we're not writing stuff in the background then suspend our thread
    if(g_var.wcwritesinbkgnd != 2)
        SuspendThread(g_hThread);
    else
    {
        while(ResumeThread(g_hThread) > 1)
            ;
    }

    return true;
}

//=========================================================================
// clear surface
//=========================================================================
void ClearScreen()
{
    // clear stuff
    DWORD dwCFlags = g_var.clearflags;

    if(!g_var.AutoDepthStencilFormat)
        dwCFlags &= ~(D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL);

    CheckHR(g_pDev->Clear(0, NULL, dwCFlags, g_var.cclearval,
        g_var.zclearval, g_var.sclearval));
}

//=========================================================================
// Initialize the vertex shader and stream source(s)
//=========================================================================
void InitFrame()
{
    CheckHR(g_pDev->SetVertexShader(g_dwVertexShader));

    for(DWORD istream = 0; istream < g_var.NumStreams; istream++)
        CheckHR(g_pDev->SetStreamSource(istream, g_pVB[istream], g_dwFVFSize[istream]));
}

//=========================================================================
// Render the vertices x times
//=========================================================================
void RenderFrame(int vbdrawcount, BOOL nops)
{
    if(nops)
    {
        while(vbdrawcount--)
        {
            for(DWORD index = 0; index < g_var.indexcount; index++)
                D3DDevice_Nop();
        }
    }
    else
    {
        while(vbdrawcount--)
        {
            CheckHR(g_pDev->DrawIndexedVertices(g_var.primitivetype, g_var.indexcount, g_pindices));
        }
    }
}

//=========================================================================
// Handle joystick input
//=========================================================================
void HandleInput(DWORD dwTicks)
{
    static BOOL fRunTestRightNow = FALSE;

    if(g_inifile.FileChanged())
    {
        InitVST(true);

        fRunTestRightNow = g_var.runtestonreload;

        g_fRedrawScreen = true;
    }

    // If we don't have a device don't let them start any tests.
    // They're going to have to change their settings in fillrate.ini
    // and just try again.
    if(!g_pDev)
        return;

    if(!g_hInpDevice)
        g_hInpDevice = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL);

    if(g_hInpDevice)
    {
        XINPUT_STATE xinpstate = {0};
        static XINPUT_STATE xinpstatelast;
#define FButtonDown(_btn) \
        (xinpstate.Gamepad.bAnalogButtons[_btn] && \
            (!xinpstate.Gamepad.bAnalogButtons[_btn] != !xinpstatelast.Gamepad.bAnalogButtons[_btn]))

        XInputGetState(g_hInpDevice, &xinpstate);

        if(fRunTestRightNow || FButtonDown(XINPUT_GAMEPAD_A))
        {
            fRunTestRightNow = FALSE;

            // run current test
            g_rgTests[g_iCurTest].pfnTest();

            // draw one scene with current settings
            ClearScreen();
            InitFrame();
            RenderFrame(1);

            // flip that dude to the front
            CheckHR(g_pDev->Present(NULL, NULL, NULL, NULL));

            // plaster our results on the front buffer
            g_scrtext.drawtext(g_var.verboselevel >= 1);
            g_fRedrawScreen = false;
        }

        if(FButtonDown(XINPUT_GAMEPAD_LEFT_TRIGGER))
        {
            g_iCurTest = (g_iCurTest + ARRAYSIZE(g_rgTests) - 1) % ARRAYSIZE(g_rgTests);
            g_fRedrawScreen = true;
        }

        if(FButtonDown(XINPUT_GAMEPAD_RIGHT_TRIGGER))
        {
            g_iCurTest = (g_iCurTest + 1) % ARRAYSIZE(g_rgTests);
            g_fRedrawScreen = true;
        }

        if(FButtonDown(XINPUT_GAMEPAD_X))
        {
            InitVST(true);
            g_fRedrawScreen = true;
        }

        if(FButtonDown(XINPUT_GAMEPAD_Y))
        {
            // toggle wireframe and solid fill modes
            g_var.d3dfillmode = (g_var.d3dfillmode == D3DFILL_WIREFRAME) ?
                D3DFILL_SOLID : D3DFILL_WIREFRAME;
            CheckHR(g_pDev->SetRenderState(D3DRS_FILLMODE, g_var.d3dfillmode));
            g_fRedrawScreen = true;
        }

        xinpstatelast = xinpstate;
    }
}

//=========================================================================
//
//=========================================================================
const char *szGetPTType(DWORD pt)
{
    static const char *rgszD3DPT[] =
    {
        "D3DPT_0",
        "D3DPT_POINTLIST",
        "D3DPT_LINELIST",
        "D3DPT_LINELOOP",
        "D3DPT_LINESTRIP",
        "D3DPT_TRIANGLELIST",
        "D3DPT_TRIANGLESTRIP",
        "D3DPT_TRIANGLEFAN",
        "D3DPT_QUADLIST",
        "D3DPT_QUADSTRIP",
        "D3DPT_POLYGON",
        "D3DPT_?",
    };

    return rgszD3DPT[min(pt, ARRAYSIZE(rgszD3DPT))];
}

//=========================================================================
// Do a series of pushbuffer calls w/ varying pushbuffer sizes
//=========================================================================
void DoPushBufferCallTest()
{
    // clear screen text
    g_scrtext.cls();

    g_var.vbdrawcount = 1;
    g_var.framesperpushbuffermax = 1;

    DumpCurrentSettings();

    char szIndices[256];
    static const char *szDefIndices =
        "50, 100, 250, 500, 1000, 1500, 2000, 2500, 5000, 10000, 20000, 40000";

    g_inifile.GetIniStrBuf("pushbuffercalltest", "indices",
        szDefIndices, szIndices, sizeof(szIndices));

    dprintf("** PushBufferCallTest (%s) **\n", szIndices);

    static const char *rgHdrsNops[2] =
        { "Mnops", "cycles/nop" };
    static const char *rgHdrsIndices[2] =
        { "Mtps", "cycles/vert" };
    const char **rgHdrs = g_var.pushbuffernops ? rgHdrsNops : rgHdrsIndices;
    char *sizehdr = g_var.precompiled ? "pushbufsize" : "# indices";

    g_scrtext.printf("%-12s %-7s %-7s %-10s(%d)"
#if PROFILE
        " waits waittime(ms)"
#endif
        , sizehdr,
        rgHdrs[0], rgHdrs[1], "throughput", g_var.wcwritesinbkgnd);

    char *token;
    const char seps[]   = " ,\t";
    token = strtok(szIndices, seps);
    while(token)
    {
        g_var.indexcount = atoi(token);

        if(g_var.verboselevel >= 1)
            dprintf("%d ", g_var.indexcount);

        if(g_var.indexcount)
        {
            InitVST(false);

            TIMETESTRESULTS ttres = {0};
            DoTimedTest(&ttres);

            g_scrtext.printf("%11d %6.2f  %12.2f %10.2f"
#if PROFILE
                " %8d-%.2f"
#endif
                , g_var.precompiled ? ttres.pushbuffersize : g_var.indexcount,
                ttres.mtps, ttres.cycles, ttres.throughput,
                ttres.PushBufferWaitInfo.Count,
                (double)(ttres.PushBufferWaitInfo.Cycles / 733) / 1000.0);
        }

        token = strtok(NULL, seps);
    }

    dprintf("\n\n");
    g_scrtext.printf("");

    // restore our settings
    InitVST(true);
}

//=========================================================================
// Do a quick test with the current settings
//=========================================================================
void DoQuickTimedTest()
{
    static DWORD testnum = 0;
    dprintf("\n*** test #%ld ***\n", ++testnum);

    // clear screen text
    g_scrtext.cls();

    // run test
    TIMETESTRESULTS ttres = {0};
    DoTimedTest(&ttres);

    DumpCurrentSettings();

    g_scrtext.printf("");

    // if we did the wc writes in the background spew the results
    if(g_var.wcwritesinbkgnd)
    {
        g_scrtext.printf("writer thread:  %s",
            (g_var.wcwritesinbkgnd == 1) ? "main" : "low prio bkgnd");
        g_scrtext.printf("bytes written:  %lu", ttres.byteswritten);
        g_scrtext.printf("throughput:     %.2f MB/s", ttres.throughput);
        g_scrtext.printf("");
    }

    g_scrtext.printf("pushbuffercalls:%d", ttres.pushbuffercalls);
    g_scrtext.printf("pushbuffersize :%d", ttres.pushbuffersize);

#if PROFILE
    g_scrtext.printf("pushbufferwaits:%d",   ttres.PushBufferWaitInfo.Count);
    g_scrtext.printf("pshbfwaittime:%.2fms", (double)(ttres.PushBufferWaitInfo.Cycles / 733) / 1000.0);
#endif

    // print out results
    g_scrtext.printf("");

    g_scrtext.printf("fps:            %.2f",     ttres.fps);
    g_scrtext.printf("frames:         %d",       ttres.cFrames);
    g_scrtext.printf("time:           %.2fms",   ttres.TimeTillIdle);

    if(g_var.pushbuffernops)
    {
        g_scrtext.printf("nops:           %I64u",    ttres.cTrisDrawn);
        g_scrtext.printf("Mnops:          %.2f",     ttres.mtps);
        g_scrtext.printf("cycles/nop:     %.2f",     ttres.cycles);
    }
    else
    {
        g_scrtext.printf("triangles:      %I64u",    ttres.cTrisDrawn);
        g_scrtext.printf("Mtps:           %.2f",     ttres.mtps);
        g_scrtext.printf("cycles/vert:    %.2f",     ttres.cycles);
    }
}

//=========================================================================
//
//=========================================================================
inline char *MyStrCpy(char *dst, const char *src)
{
    while(*src && (*dst++ = *src++))
        ;

    return dst;
}

//=========================================================================
// Return a static char buffer with stream declaration
//=========================================================================
const char *SzGetDeclDescr(DWORD dwStream, DWORD *pDecl)
{
    static char szBuf[128];
    DWORD dwBytes = 0;
    DWORD dwCurStream = (DWORD)-1;

    char *psz = szBuf;

    while(*pDecl != D3DVSD_END())
    {
        if(VSDGetTokenType(*pDecl) == D3DVSD_TOKEN_STREAM)
        {
            dwCurStream = *pDecl & D3DVSD_STREAMNUMBERMASK;
        }
        else if(dwStream == dwCurStream &&
            VSDGetTokenType(*pDecl) == D3DVSD_TOKEN_STREAMDATA)
        {
            static const char rgReg[] = "0123456789abcdef";

            if(psz != szBuf)
                *psz++ = ',';

            if(*pDecl & 0x18000000)
            {
                psz = MyStrCpy(psz, (*pDecl & 0x08000000) ? "x:BYTES" : "x:DWRDS");
                *psz++ = char('0' + VSDGetSkipCount(*pDecl));
            }
            else
            {
                static const char *rgType[] =
                    { "CLR", "NRMSHRT", "FLT", "?", "PBYTE", "SHRT", "NRMPCKD", "??" };
                DWORD dwType = VSDGetDataType(*pDecl);
                DWORD dwCount = (dwType >> 4) & 0xf;

                *psz++ = char(rgReg[*pDecl & 0xf]);
                *psz++ = ':';

                psz = MyStrCpy(psz, rgType[min(dwType & 0xf, ARRAYSIZE(rgType))]);
                *psz++ = char('0' + dwCount);
            }
        }

        pDecl++;
    }

    *psz = 0;
    return szBuf;
}

//=========================================================================
// Dump the current options
//=========================================================================
void DumpCurrentSettings()
{
    if(g_var.pushbuffernops)
    {
        g_scrtext.printf("precompiled:    %d (w/ Kelvin nops)", g_var.precompiled);
        g_scrtext.printf("runusingcpucopy:%d",      g_var.runusingcpucopy);
        g_scrtext.printf("nop count:      %d * %d", g_var.indexcount, g_var.vbdrawcount);
    }
    else
    {
        DWORD dwFVFSizeTot = 0;

        for(DWORD istream = 0; istream < g_var.NumStreams; istream++)
            dwFVFSizeTot += g_dwFVFSize[istream];

        g_scrtext.printf("type:          %s",       szGetPTType(g_var.primitivetype));
        g_scrtext.printf("precompiled:   %d - %d pushbuffer(s)",
            g_var.precompiled, g_var.numberofpushbuffers);

        if(g_var.precompiled)
            g_scrtext.printf("runusingcpucopy:%d",      g_var.runusingcpucopy);

        if(g_var.uservertexshader)
            g_scrtext.printf("vertshaderlen: %d",   g_var.uservertexshader);

        g_scrtext.printf("vertcount:     %d",       g_var.vertcount);
        g_scrtext.printf("indexcount:    %d*%d",    g_var.indexcount, g_var.vbdrawcount);

        g_scrtext.printf("numtextures:   %d",       g_var.numtextures);
        g_scrtext.printf("FVF size:      %d bytes", dwFVFSizeTot);

        for(DWORD istream = 0; istream < g_var.NumStreams; istream++)
            g_scrtext.printf("  stream % d:   %s", istream, SzGetDeclDescr(istream, g_Declaration));

#undef XTAG
#define XTAG(_tag)    ((g_var. ## _tag) ? #_tag : "!" #_tag)

        // spew various render states
        g_scrtext.printf("%s %s %s %s",
            XTAG(zenable), XTAG(zwriteenable),
            XTAG(alphablendenable), XTAG(alphatestenable));

        g_scrtext.printf("%s %s %s %s %s",
            XTAG(localviewer), XTAG(specularenable),
            XTAG(fogenable), XTAG(normalizenormals), XTAG(colorvertex));

        if(g_var.lighting)
        {
            g_scrtext.printf("%s: directional:%d point:%d spot:%d", XTAG(lighting),
                g_var.numDirectionalLights, g_var.numPointLights, g_var.numSpotLights);
        }
        else
        {
            g_scrtext.printf("%s", XTAG(lighting));
        }
    }
}

//=========================================================================
// Take a wild guess at the amount of time one scene will take
//=========================================================================
float EstimateTimeForScene()
{
    CTimer timer;

    // clear the screen
    ClearScreen();
    CheckHR(g_pDev->Present(NULL, NULL, NULL, NULL));

    InitFrame();

    // wait until everything is cleared out
    g_pDev->BlockUntilIdle();

    // start timing
    timer.Start();

    // draw one scene
    RenderFrame(g_var.vbdrawcount, g_var.pushbuffernops);

    // wait until GPU is idle again
    g_pDev->BlockUntilIdle();

    // stop timer
    timer.Stop();

    return timer.getTime();
}

// helper struct used in PrecompiledCallback
struct GPUINFO
{
    CTimer *ptimer;
    DWORD byteswritten;
    DWORD bytes;
} g_gpuInfo;

//=========================================================================
// Called back at DPC level when the test is done
//=========================================================================
void __cdecl PrecompiledCallback(DWORD context)
{
    GPUINFO* pgpuInfo = (GPUINFO *)context;

    // stop the timer
    pgpuInfo->ptimer->Stop();

    // record how many bytes we've written
    pgpuInfo->byteswritten = pgpuInfo->bytes;

    g_gpudrawingdone = true;
}

//=========================================================================
// Block or do wc writes until GPU is idle
//=========================================================================
void WaitOrWriteUntilIdle()
{
    DWORD batch = 0;

    g_pDev->InsertCallback(D3DCALLBACK_WRITE, PrecompiledCallback, (DWORD)&g_gpuInfo);
    g_pDev->KickPushBuffer();

    if(g_var.wcwritesinbkgnd == 1)
    {
        // do some wc writes w/ the main thread while waiting
        while(!g_gpudrawingdone)
        {
            DWORD* pDst = g_pAlloc;

            batch = g_AllocSize / sizeof(DWORD);

            // pDst = (DWORD*) ((DWORD) pDst | 0xf0000000);

            do {
                *pDst++ = g_gpuInfo.bytes;

                g_gpuInfo.bytes += 4;

            } while (--batch != 0);
        }
    }
    else
    {
        // wait until GPU is idle again
        g_pDev->BlockUntilIdle();
    }
}

//=========================================================================
//
//=========================================================================
void CreatePushBuffers(IDirect3DPushBuffer8 *pPushbuffer[300],
    int numberscenes, DWORD *psize, int *pframesperpushbuffer)
{
    DWORD size;
    int framesperpushbuffer;
    const int MaxPushbufferSize = 32*1024*1024;

    // calculate pushbuffer size
    IDirect3DPushBuffer8 *pPushBufferT;
    CheckHR(g_pDev->CreatePushBuffer(MaxPushbufferSize, g_var.runusingcpucopy, &pPushBufferT));

    // render one frame - and get the size
    CheckHR(g_pDev->BeginPushBuffer(pPushBufferT));
    RenderFrame(g_var.vbdrawcount, g_var.pushbuffernops);
    CheckHR(g_pDev->GetPushBufferOffset(&size));

    // we're capped by the push-buffer size or the total frame count
    framesperpushbuffer = min(numberscenes, MaxPushbufferSize / (int)size);

    // cap the guy at the max # of frames allowed in our pushbuffer
    if(g_var.framesperpushbuffermax)
        framesperpushbuffer = min(g_var.framesperpushbuffermax, (DWORD)framesperpushbuffer);

    // render the remaining frames in there
    for(int i = 1; i < framesperpushbuffer; i++)
    {
        RenderFrame(g_var.vbdrawcount, g_var.pushbuffernops);
    }

    CheckHR(g_pDev->GetPushBufferOffset(&size));

    CheckHR(g_pDev->EndPushBuffer());

    // ok - cruise through and create X number of pushbuffers
    g_var.numberofpushbuffers = min(300, max(1, g_var.numberofpushbuffers));

    if(g_var.numberofpushbuffers == 1)
    {
        pPushbuffer[0] = pPushBufferT;
        pPushBufferT = NULL;
    }
    else
    {
        for(DWORD ipushbuf = 0; ipushbuf < g_var.numberofpushbuffers; ipushbuf++)
        {
            // create precompiled pushbuffer
            CheckHR(g_pDev->CreatePushBuffer(max(512, size) + sizeof(DWORD),
                g_var.runusingcpucopy, &pPushbuffer[ipushbuf]));

            assert(pPushbuffer[ipushbuf]->AllocationSize >=
                pPushBufferT->Size);

            memcpy((void *)pPushbuffer[ipushbuf]->Data,
                (void *)pPushBufferT->Data, pPushBufferT->Size);

            pPushbuffer[ipushbuf]->Size = pPushBufferT->Size;
        }
    }

    *psize = size;
    *pframesperpushbuffer = framesperpushbuffer;

    RELEASE(pPushBufferT);
}

//=========================================================================
// Do a timed test and spit out the results
//=========================================================================
float DoTimedTest(TIMETESTRESULTS *pttres)
{
    CTimer timer;
    int frames = 0;
    int visibilityindex = 0;
    float TimeTillDoneDrawing = 0;
    float TimeTillIdle = 0;
    UINT64 cIndicesDrawn = 0;
    UINT64 cTrisDrawn = 0;
    D3DWAITINFO *pPushBufferWaitInfo =
        &g_pPerf->m_PerformanceCounters[PERF_PUSHBUFFER_WAITS];

    // if there isn't an explicit count of scenes to render
    // guesstimate the time required for each scene
    float fEstimatedTimePerScene = EstimateTimeForScene();

    // and figure out how many scenes to render
    int numberscenes = int(g_var.testtime / fEstimatedTimePerScene);

    // put an upper cap and lower bound on the number of scenes
    numberscenes = max(2, min(numberscenes, INT_MAX));

    // set up stream sources
    InitFrame();

    g_gpuInfo.ptimer = &timer;
    g_gpuInfo.byteswritten = 0;
    g_gpuInfo.bytes = 0;

    if(g_var.precompiled)
    {
        DWORD size;
        int framesperpushbuffer;
        static IDirect3DPushBuffer8 *pPushbuffer[300];

        // Create our pushbuffers
        CreatePushBuffers(pPushbuffer, numberscenes, &size, &framesperpushbuffer);

        int pushbuffercalls = (numberscenes / framesperpushbuffer) + 1;

        pPushBufferWaitInfo->Count = 0;
        pPushBufferWaitInfo->Cycles = 0;

        // wait until everything is cleared out
        g_pDev->BlockUntilIdle();

        // start timing
        timer.Start();
        g_gpudrawingdone = false;

        // render X number of scenes
        DWORD ipushbuf = 0;
        for(int pushbuffers = 0; pushbuffers < pushbuffercalls; pushbuffers++)
        {
            CheckHR(g_pDev->RunPushBuffer(pPushbuffer[ipushbuf], NULL));

            if(++ipushbuf >= g_var.numberofpushbuffers)
                ipushbuf = 0;
        }

        TimeTillDoneDrawing = timer.getTime();

        WaitOrWriteUntilIdle();

        TimeTillIdle = timer.getTime();

        frames = pushbuffercalls * framesperpushbuffer;
        cIndicesDrawn = (UINT64)pushbuffercalls * framesperpushbuffer * g_var.vbdrawcount * g_var.indexcount;
        cTrisDrawn = (UINT64)pushbuffercalls * framesperpushbuffer * g_var.vbdrawcount * g_var.TriCount;

        if(pttres)
        {
            pttres->pushbuffercalls = pushbuffercalls;
            pttres->pushbuffersize = size;
        }

        for(ipushbuf = 0; ipushbuf < g_var.numberofpushbuffers; ipushbuf++)
            RELEASE(pPushbuffer[ipushbuf]);
    }
    else
    {
        pPushBufferWaitInfo->Count = 0;
        pPushBufferWaitInfo->Cycles = 0;

        // wait until everything is cleared out
        g_pDev->BlockUntilIdle();

        // start timing
        timer.Start();
        g_gpudrawingdone = false;

        // render X number of scenes
        for(frames = 0; frames < numberscenes; frames++)
        {
            RenderFrame(g_var.vbdrawcount);
        }

        TimeTillDoneDrawing = timer.getTime();

        // wait until GPU is idle again
        WaitOrWriteUntilIdle();

        TimeTillIdle = timer.getTime();

        cIndicesDrawn = (UINT64)frames * g_var.vbdrawcount * g_var.indexcount;
        cTrisDrawn = (UINT64)frames * g_var.vbdrawcount * g_var.TriCount;
    }

    if(pttres)
    {
        pttres->fps = frames * 1000 / TimeTillIdle;
        pttres->cFrames = frames;
        pttres->TimeTillDoneDrawing = TimeTillDoneDrawing;
        pttres->TimeTillIdle = TimeTillIdle;
        pttres->cTrisDrawn = cTrisDrawn;
        pttres->mtps = (float)(pttres->cTrisDrawn / (pttres->TimeTillIdle * 1000));
        pttres->cycles = g_nvclk * pttres->TimeTillIdle * 1000.0f / cIndicesDrawn;

        pttres->byteswritten = g_gpuInfo.byteswritten;
        pttres->throughput = g_gpuInfo.byteswritten / (TimeTillIdle * 1000.0f);
        pttres->PushBufferWaitInfo = *pPushBufferWaitInfo;
    }

    return pttres->fps;
}

//=========================================================================
// macros to help read entries from the ini file
//=========================================================================
static const char g_szOpts[] = "options";
#define get_option_val(_var)          g_inifile.GetIniInt(g_szOpts, #_var, g_var._var)
#define get_option_valf(_var)         g_inifile.GetIniFloat(g_szOpts, #_var, g_var._var)
#define get_option_val3(_s, _var, _d) g_inifile.GetIniInt(_s, _var, _d)

//=========================================================================
// Read ini file and update all fr settings
//=========================================================================
bool ReadVSTIniFile()
{
    if(!g_inifile.ReadFile())
        return false;

    // read the verbose flag(s) first
    g_inifile.m_fverbose            = !!get_option_val3(g_szOpts, "verboseinireads", false);
    g_var.verboselevel              = get_option_val(verboselevel);

    // if the g_iCurTest entry exists, read it in
    if(g_inifile.IniEntryExists(g_szOpts, "g_iCurTest"))
        g_iCurTest = g_inifile.GetIniInt(g_szOpts, "g_iCurTest", g_iCurTest);

    g_var.runtestonreload           = !!get_option_val(runtestonreload);

    g_var.AutoDepthStencilFormat    = (D3DFORMAT)get_option_val(AutoDepthStencilFormat);
    g_var.BackBufferFormat          = (D3DFORMAT)get_option_val(BackBufferFormat);

    g_var.MSType                    = (D3DMULTISAMPLE_TYPE)get_option_val(MSType);
    g_var.MSFormat                  = (D3DMULTISAMPLE_TYPE)get_option_val(MSFormat);

    g_var.zenable                   = !!get_option_val(zenable);
    g_var.zwriteenable              = !!get_option_val(zwriteenable);
    g_var.d3dcmpfunc                = (D3DCMPFUNC)get_option_val(d3dcmpfunc);

    g_var.alphablendenable          = !!get_option_val(alphablendenable);
    g_var.alphatestenable           = !!get_option_val(alphatestenable);

    g_var.testtime                  = get_option_valf(testtime);
    g_var.vbdrawcount               = get_option_val(vbdrawcount);
    g_var.precompiled               = get_option_val(precompiled);
    g_var.framesperpushbuffermax    = get_option_val(framesperpushbuffermax);
    g_var.pushbuffernops            = g_var.precompiled ? get_option_val(pushbuffernops) : 0;
    g_var.runusingcpucopy           = g_var.precompiled && !!get_option_val(runusingcpucopy);
    g_var.numberofpushbuffers       = get_option_val(numberofpushbuffers);
    g_var.wcwritesinbkgnd           = get_option_val(wcwritesinbkgnd);

    g_var.FVF                       = get_option_val(FVF);
    g_var.primitivetype             = (D3DPRIMITIVETYPE)get_option_val(primitivetype);
    g_var.indexcount                = get_option_val(indexcount);
    g_var.vertcount                 = get_option_val(vertcount);

    g_var.cullmode                  = (D3DCULL)get_option_val(cullmode);
    g_var.d3dfillmode               = (D3DFILLMODE)get_option_val(d3dfillmode);

    g_var.degenerates               = !!get_option_val(degenerates);

    g_var.clearflags                = get_option_val(clearflags);
    g_var.zclearval                 = get_option_valf(zclearval);
    g_var.sclearval                 = get_option_val(sclearval);
    g_var.cclearval                 = get_option_val(cclearval);

    g_var.uservertexshader          = get_option_val(uservertexshader);

    g_var.colorvertex               = !!get_option_val(colorvertex);
    g_var.normalizenormals          = !!get_option_val(normalizenormals);
    g_var.fogenable                 = !!get_option_val(fogenable);

    g_var.localviewer               = !!get_option_val(localviewer);
    g_var.specularenable            = !!get_option_val(specularenable);

    g_var.lighting                  = !!get_option_val(lighting);
    g_var.numDirectionalLights      = get_option_val(numDirectionalLights);
    g_var.numPointLights            = get_option_val(numPointLights);
    g_var.numSpotLights             = get_option_val(numSpotLights);

    g_var.numtextures               = get_option_val(numtextures);

    // Read in the explicit declaration if we don't have an FVF code
    g_var.NumStreams = 1;
    if(!g_var.FVF)
    {
        char szStream[20];
        char szEntry[20];
        int idecl = 0;

        for(int istream = 0; istream < 15; istream++)
        {
            wsprintfA(szStream, "stream%d", istream);
            if(!g_inifile.IniEntryExists(szStream, "Decl0"))
            {
                break;
            }
            else
            {
                g_Declaration[idecl++] = D3DVSD_STREAM(istream);

                for(int ientry = 0; ientry < 15; ientry++)
                {
                    wsprintfA(szEntry, "Decl%d", ientry);
                    if(!g_inifile.IniEntryExists(szStream, szEntry))
                        break;

                    DWORD dwDecl = g_inifile.GetIniInt(szStream, szEntry, 0);

                    if(dwDecl & 0x08000000)
                        g_Declaration[idecl++] = D3DVSD_SKIPBYTES(LOWORD(dwDecl));
                    else if(dwDecl & 0x10000000)
                        g_Declaration[idecl++] = D3DVSD_SKIP(LOWORD(dwDecl));
                    else
                        g_Declaration[idecl++] = D3DVSD_REG(LOWORD(dwDecl), HIWORD(dwDecl));
                }
            }
        }

        g_Declaration[idecl] = D3DVSD_END();

        g_var.NumStreams = istream;
    }

    return true;
}

//=========================================================================
// Background thread loop.
//=========================================================================
DWORD WINAPI ThreadProc(LPVOID lpParameter)
{
    DWORD batch;

    for(;;)
    {
        if(!g_gpudrawingdone)
        {
            DWORD* pDst = g_pAlloc;

            batch = g_AllocSize / sizeof(DWORD);

            // pDst = (DWORD*) ((DWORD) pDst | 0xf0000000);
            do {
                *pDst++ = g_gpuInfo.bytes;

                g_gpuInfo.bytes += 4;

            } while (--batch != 0);
        }
    }

    return 0;
}


//=========================================================================
// main
//=========================================================================
void __cdecl main()
{
    DWORD dwT = 0x418937;

    dprintf("TEST: %lu %lu\n", dwT * 1000 / 48000, (dwT + 1) * 1000 / 48000);
    
    g_hThread = CreateThread(NULL, 0, ThreadProc, 0, CREATE_SUSPENDED, NULL);
    SetThreadPriority(g_hThread, THREAD_PRIORITY_BELOW_NORMAL);

#if PROFILE
    g_pPerf = D3DPERF_GetStatistics();
#else
    static D3DPERF perf = {0};
    g_pPerf = &perf;
#endif

    /*
     * init vars
     */
    g_var.screenwidth = 640.0f;
    g_var.screenheight = 480.0f;

    g_var.FVF = D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1;
    g_var.primitivetype = D3DPT_TRIANGLELIST;
    g_var.indexcount = 4998;
    g_var.vertcount = 27;

    g_var.cullmode = D3DCULL_NONE;

    g_var.degenerates = false;

    g_var.alphablendenable = false;
    g_var.alphatestenable = false;

    // default to drawing 10 seconds
    g_var.testtime = 10000.0f;
    g_var.vbdrawcount = 50;

    g_var.d3dfillmode = D3DFILL_SOLID;

    g_var.zenable = false;
    g_var.zwriteenable = false;

    g_var.d3dcmpfunc = D3DCMP_NOTEQUAL;

    g_var.BackBufferFormat = D3DFMT_A8R8G8B8;
    g_var.AutoDepthStencilFormat = D3DFMT_D24S8;

    g_var.clearflags = D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL;
    g_var.cclearval = 0x00006688;


    g_pAlloc = (DWORD*) XPhysicalAlloc(g_AllocSize, MAXULONG_PTR, 4096,
                                       PAGE_READWRITE | PAGE_WRITECOMBINE);

    CheckHR(g_pAlloc != NULL ? S_OK : E_OUTOFMEMORY);

    /*
     * Init vstune
     */
    XInitDevices(0, NULL);

    DWORD dwLastTickCount = GetTickCount();
    for(;;)
    {
        DWORD dwTickCount = GetTickCount();
        DWORD dwTicks = dwTickCount - dwLastTickCount;

        dwLastTickCount = dwTickCount;

        HandleInput(dwTicks);

        if(g_pDev)
        {
            if(g_fRedrawScreen)
            {
                ClearScreen();

                // draw back frame with current settings
                InitFrame();
                RenderFrame(1);

                // swap that guy to the front
                CheckHR(g_pDev->Present(NULL, NULL, NULL, NULL));

                // display current options on front buffer
                g_scrtext.cls();

                g_scrtext.printf("Btn A) run '%s' test.", g_rgTests[g_iCurTest].szDesc);
                g_scrtext.printf("");
                DumpCurrentSettings();
                g_scrtext.drawtext(g_var.verboselevel >= 1);

                g_fRedrawScreen = false;
            }
            else
            {
                // 33.3 fps baby!
                Sleep(30);
            }
        }
    }
}

//=========================================================================
// Callback from inifile.cpp to get float string value
//=========================================================================
bool GetIniConstf(const char *szStr, int cchStr, float *pval)
{
    return false;
}

//=========================================================================
// Callback from inifile.cpp to get int string value
//=========================================================================
bool GetIniConst(const char *szStr, int cchStr, int *pval)
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        int Val;
        const char *szStr;
    } rgszConsts[] =
    {
        // D3DFORMATs
        XTAG(D3DFMT_A8R8G8B8), XTAG(D3DFMT_X8R8G8B8), XTAG(D3DFMT_R5G6B5), XTAG(D3DFMT_R6G5B5),
        XTAG(D3DFMT_X1R5G5B5), XTAG(D3DFMT_A1R5G5B5), XTAG(D3DFMT_A4R4G4B4), XTAG(D3DFMT_A8),
        XTAG(D3DFMT_A8B8G8R8), XTAG(D3DFMT_B8G8R8A8), XTAG(D3DFMT_R4G4B4A4), XTAG(D3DFMT_R5G5B5A1),
        XTAG(D3DFMT_R8G8B8A8), XTAG(D3DFMT_R8B8), XTAG(D3DFMT_G8B8), XTAG(D3DFMT_P8),
        XTAG(D3DFMT_L8), XTAG(D3DFMT_A8L8), XTAG(D3DFMT_AL8), XTAG(D3DFMT_L16),
        XTAG(D3DFMT_V8U8), XTAG(D3DFMT_L6V5U5), XTAG(D3DFMT_X8L8V8U8), XTAG(D3DFMT_Q8W8V8U8),
        XTAG(D3DFMT_V16U16), XTAG(D3DFMT_D16_LOCKABLE), XTAG(D3DFMT_D16), XTAG(D3DFMT_D24S8),
        XTAG(D3DFMT_F16), XTAG(D3DFMT_F24S8), XTAG(D3DFMT_UYVY), XTAG(D3DFMT_YUY2),
        XTAG(D3DFMT_DXT1), XTAG(D3DFMT_DXT2), XTAG(D3DFMT_DXT3), XTAG(D3DFMT_DXT4),
        XTAG(D3DFMT_DXT5), XTAG(D3DFMT_LIN_A1R5G5B5), XTAG(D3DFMT_LIN_A4R4G4B4), XTAG(D3DFMT_LIN_A8),
        XTAG(D3DFMT_LIN_A8B8G8R8), XTAG(D3DFMT_LIN_A8R8G8B8), XTAG(D3DFMT_LIN_B8G8R8A8), XTAG(D3DFMT_LIN_G8B8),
        XTAG(D3DFMT_LIN_R4G4B4A4), XTAG(D3DFMT_LIN_R5G5B5A1), XTAG(D3DFMT_LIN_R5G6B5), XTAG(D3DFMT_LIN_R6G5B5),
        XTAG(D3DFMT_LIN_R8B8), XTAG(D3DFMT_LIN_R8G8B8A8), XTAG(D3DFMT_LIN_X1R5G5B5), XTAG(D3DFMT_LIN_X8R8G8B8),
        XTAG(D3DFMT_LIN_A8L8), XTAG(D3DFMT_LIN_AL8), XTAG(D3DFMT_LIN_L16), XTAG(D3DFMT_LIN_L8),
        XTAG(D3DFMT_LIN_D24S8), XTAG(D3DFMT_LIN_F24S8), XTAG(D3DFMT_LIN_D16), XTAG(D3DFMT_LIN_F16),

        XTAG(D3DMULTISAMPLE_NONE), XTAG(D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX), XTAG(D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR),
        XTAG(D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR), XTAG(D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN),
        XTAG(D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT),
        XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5),
        XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8),

        XTAG(D3DMS_NONE), XTAG(D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX), XTAG(D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR),
        XTAG(D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR), XTAG(D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN), XTAG(D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR),
        XTAG(D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN),
        XTAG(D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMS_PREFILTER_FORMAT_DEFAULT),
        XTAG(D3DMS_PREFILTER_FORMAT_X1R5G5B5), XTAG(D3DMS_PREFILTER_FORMAT_R5G6B5),
        XTAG(D3DMS_PREFILTER_FORMAT_X8R8G8B8), XTAG(D3DMS_PREFILTER_FORMAT_A8R8G8B8),

        XTAG(D3DCLEAR_TARGET), XTAG(D3DCLEAR_ZBUFFER), XTAG(D3DCLEAR_STENCIL),

        // FVFs
        XTAG(D3DFVF_XYZ), XTAG(D3DFVF_XYZRHW), XTAG(D3DFVF_NORMAL), XTAG(D3DFVF_DIFFUSE),
        XTAG(D3DFVF_SPECULAR), XTAG(D3DFVF_TEX0), XTAG(D3DFVF_TEX1), XTAG(D3DFVF_TEX2),
        XTAG(D3DFVF_TEX3), XTAG(D3DFVF_TEX4),

        // textcoord sizes
        XTAG(T0_SIZE1), XTAG(T0_SIZE2), XTAG(T0_SIZE3), XTAG(T0_SIZE4),
        XTAG(T1_SIZE1), XTAG(T1_SIZE2), XTAG(T1_SIZE3), XTAG(T1_SIZE4),
        XTAG(T2_SIZE1), XTAG(T2_SIZE2), XTAG(T2_SIZE3), XTAG(T2_SIZE4),
        XTAG(T3_SIZE1), XTAG(T3_SIZE2), XTAG(T3_SIZE3), XTAG(T3_SIZE4),

        XTAG(VSDT_FLOAT1), XTAG(VSDT_FLOAT2), XTAG(VSDT_FLOAT3), XTAG(VSDT_FLOAT4),
        XTAG(VSDT_D3DCOLOR), XTAG(VSDT_SHORT2), XTAG(VSDT_SHORT4), XTAG(VSDT_NORMSHORT1),
        XTAG(VSDT_NORMSHORT2), XTAG(VSDT_NORMSHORT3), XTAG(VSDT_NORMSHORT4), XTAG(VSDT_NORMPACKED3),
        XTAG(VSDT_SHORT1), XTAG(VSDT_SHORT3), XTAG(VSDT_PBYTE1), XTAG(VSDT_PBYTE2),
        XTAG(VSDT_PBYTE3), XTAG(VSDT_PBYTE4), XTAG(VSDT_FLOAT2H), XTAG(VSDT_NONE),

        XTAG(D3DVSDE_POSITION), XTAG(D3DVSDE_BLENDWEIGHT), XTAG(D3DVSDE_NORMAL), XTAG(D3DVSDE_DIFFUSE),
        XTAG(D3DVSDE_SPECULAR), XTAG(D3DVSDE_FOG), XTAG(D3DVSDE_BACKDIFFUSE), XTAG(D3DVSDE_BACKSPECULAR),
        XTAG(D3DVSDE_TEXCOORD0), XTAG(D3DVSDE_TEXCOORD1), XTAG(D3DVSDE_TEXCOORD2), XTAG(D3DVSDE_TEXCOORD3),

        // primitive types
        XTAG(D3DPT_POINTLIST), XTAG(D3DPT_LINELIST), XTAG(D3DPT_LINELOOP),
        XTAG(D3DPT_LINESTRIP), XTAG(D3DPT_TRIANGLELIST), XTAG(D3DPT_TRIANGLESTRIP),
        XTAG(D3DPT_TRIANGLEFAN), XTAG(D3DPT_QUADLIST), XTAG(D3DPT_QUADSTRIP),
        XTAG(D3DPT_POLYGON),

        XTAG(D3DCULL_NONE), XTAG(D3DCULL_CCW), XTAG(D3DCULL_CW),
        XTAG(D3DFILL_POINT), XTAG(D3DFILL_WIREFRAME), XTAG(D3DFILL_SOLID),

        // D3DCMPs
        XTAG(D3DCMP_NEVER), XTAG(D3DCMP_LESS), XTAG(D3DCMP_EQUAL), XTAG(D3DCMP_LESSEQUAL),
        XTAG(D3DCMP_GREATER), XTAG(D3DCMP_NOTEQUAL), XTAG(D3DCMP_GREATEREQUAL), XTAG(D3DCMP_ALWAYS),

        // misc
        XTAG(FALSE), XTAG(TRUE)
    };

    for(int ifmt = 0; ifmt < ARRAYSIZE(rgszConsts); ifmt++)
    {
        if(!_strnicmp(rgszConsts[ifmt].szStr, szStr, cchStr))
        {
            // set val
            *pval = rgszConsts[ifmt].Val;
            return true;
        }
    }

    return false;
}

//=========================================================================
//  function    MyNotBrokenD3DXDeclaratorFromFVF
//
//   devnote    Generates a declarator from a given FVF. And pays attention
//              to the D3DFVF_TEXTUREFORMAT1 bits unlike the piece of crap
//              D3DX routine.
//
//              Note that it doesn't handle D3DFVF_XYZB*
//=========================================================================
void MyNotBrokenD3DXDeclaratorFromFVF(DWORD dwFVF, DWORD Declarator[MAX_FVF_DECL_SIZE])
{
    DWORD iTemp = 0;

    Declarator[iTemp++] = D3DVSD_STREAM(0);

    if(dwFVF & D3DFVF_XYZ)
        Declarator[iTemp++] = D3DVSD_REG( D3DVSDE_POSITION,  D3DVSDT_FLOAT3);
    else if(dwFVF & D3DFVF_XYZRHW)
        Declarator[iTemp++] = D3DVSD_REG( D3DVSDE_POSITION,  D3DVSDT_FLOAT4);

    if(dwFVF & D3DFVF_NORMAL)
        Declarator[iTemp++] = D3DVSD_REG( D3DVSDE_NORMAL,  D3DVSDT_FLOAT3);

    if(dwFVF & D3DFVF_DIFFUSE)
        Declarator[iTemp++] = D3DVSD_REG( D3DVSDE_DIFFUSE,  D3DVSDT_D3DCOLOR);

    if(dwFVF & D3DFVF_SPECULAR)
        Declarator[iTemp++] = D3DVSD_REG( D3DVSDE_SPECULAR,  D3DVSDT_D3DCOLOR);

    // Texture coordinates
    UINT uNumTexCoords = ((dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT);
    UINT uTextureFormats = dwFVF >> 16;

    if(uTextureFormats)
    {
        for(UINT i = 0; i < uNumTexCoords; i++)
        {
            DWORD dwVsdt;

            switch(uTextureFormats & 3)
            {
            case D3DFVF_TEXTUREFORMAT1:     // u
                dwVsdt = D3DVSDT_FLOAT1;
                break;
            case D3DFVF_TEXTUREFORMAT2:     // u,v
                dwVsdt = D3DVSDT_FLOAT2;
                break;
            case D3DFVF_TEXTUREFORMAT3:     // s,t,r
                dwVsdt = D3DVSDT_FLOAT3;
                break;
            case D3DFVF_TEXTUREFORMAT4:     // s,t,r,q
                dwVsdt = D3DVSDT_FLOAT4;
                break;
            }

            Declarator[iTemp++] = D3DVSD_REG(D3DVSDE_TEXCOORD0 + i, dwVsdt),
            uTextureFormats >>= 2;
        }
    }
    else while(uNumTexCoords--)
    {
        // u,v
        Declarator[iTemp++] = D3DVSD_REG(D3DVSDE_TEXCOORD0 + uNumTexCoords, D3DVSDT_FLOAT2);
    }

    Declarator[iTemp++] = D3DVSD_END();
}

//=========================================================================
// Initialize the vertex shader
//=========================================================================
void InitVertexShader()
{
    static const char szShaderName[] = "d:\\vstune.xvu";

    if(!g_var.FVF)
    {
        // make sure our position is initialized
        g_pDev->SetVertexData4f(D3DVSDE_VERTEX, -2000, -2000, .5f, 1.0f);
    }
    else
    {
        MyNotBrokenD3DXDeclaratorFromFVF(g_var.FVF, g_Declaration);
    }

    if(g_dwVertexShader)
    {
        g_pDev->SetVertexShader(D3DFVF_XYZ);
        g_pDev->DeleteVertexShader(g_dwVertexShader);
        g_dwVertexShader = 0;
    }

    if(g_var.uservertexshader)
    {
        HANDLE hFile = CreateFile(szShaderName,
            GENERIC_READ, FILE_SHARE_READ, NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
        {
            DWORD dwSize = GetFileSize(hFile, NULL);
            DWORD *pdwVertexShader = new DWORD [dwSize / sizeof(DWORD) + 1];

            DWORD NumberOfBytesRead;
            ReadFile(hFile, pdwVertexShader, dwSize, &NumberOfBytesRead, NULL);

            CheckHR(g_pDev->CreateVertexShader(g_Declaration, pdwVertexShader,
                &g_dwVertexShader, 0));

            g_var.uservertexshader = HIWORD(*pdwVertexShader);

            delete [] pdwVertexShader;
            CloseHandle(hFile);
        }
        else
        {
            dprintf("load '%s' failed: 0x%08lx\n", szShaderName);

            // set this guy to 0 and do the declaration thing below
            g_var.uservertexshader = 0;
        }
    }

    if(!g_var.uservertexshader)
    {
        CheckHR(g_pDev->CreateVertexShader(g_Declaration, NULL, &g_dwVertexShader, 0));
    }
}

//  helper routines for pinging gpu registers
extern "C" volatile DWORD *D3D__GpuReg;

_forceinline ULONG
REG_RD32(VOID* Ptr, ULONG Addr)
{
   return *((volatile DWORD*)((BYTE*)(Ptr) + (Addr)));
}

//=========================================================================
// Get the NVCLK speed
//=========================================================================
DWORD GetNVCLK()
{
    BYTE *RegBase = (BYTE *)D3D__GpuReg;

    // Calculate nvclk
    DWORD nvpll = REG_RD32(RegBase, 0x00680500);
    DWORD m = nvpll & 0xFF;
    DWORD n = (nvpll >> 8)  & 0xFF;
    DWORD p = (nvpll >> 16) & 0xFF;
    FLOAT xtal = 16.6667f;

    DWORD nvclk = (m != 0) ? (DWORD)((n * xtal / (1 << p) / m)) : 0;

    return nvclk;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\fillrate\utils.h ===
//-----------------------------------------------------------------------------
// FILE: UTILS.H
//
// Desc: utils header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#define ARRAYSIZE(_a)     (sizeof(_a) / sizeof((_a)[0]))

//=========================================================================
// Release helper function
//=========================================================================
template <class T> inline void RELEASE(T& punk)
{
    if(punk)
    {
        punk->Release();
        punk = NULL;
    }
}

//=========================================================================
// Class to help time things
//=========================================================================
class CTimer
{
public:
    // constructor
    CTimer()
    {
        QueryPerformanceFrequency((LARGE_INTEGER*)&ticksPerSecond);
        ticksPerSecond /= 1000;
    }

    ~CTimer() {};

    void Start()
        { frunning = true; QueryPerformanceCounter((LARGE_INTEGER *)&ticksstart); }

    void Stop()
        { frunning = false; QueryPerformanceCounter((LARGE_INTEGER *)&ticksend); }

    float getTime()
        {
            if(frunning)
                QueryPerformanceCounter((LARGE_INTEGER *)&ticksend);
            return ((ticksend - ticksstart) * 1.0f / ticksPerSecond);
        }

    bool frunning;
    _int64 ticksstart;
    _int64 ticksend;
    _int64 ticksPerSecond;
};

//=========================================================================
// Screen Text helper class
//=========================================================================
class CScrText
{
public:
    CScrText()
        { cls(); }

    ~CScrText() {}

    void cls()
    {
        m_iLine = 0;
        for(int i = 0; i < NUM_LINES; i++)
            m_rgText[i][0] = 0;
    }
    void _cdecl printf(LPCSTR lpFmt, ...);
    void drawtext(bool fDebugSquirty);

private:
    enum { LINE_WIDTH = 80, NUM_LINES = 40 };
    char m_rgText[NUM_LINES][LINE_WIDTH];
    int m_iLine;
};

// redefine these guys to make them shorter and remove the misleading D3DMULTISAMPLE_ part
#define D3DMS_NONE                                         D3DMULTISAMPLE_NONE
#define D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR                 D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR
#define D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX               D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX
#define D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR      D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR
#define D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR        D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR
#define D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR                 D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR
#define D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN               D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN
#define D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR                 D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR
#define D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN               D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN
#define D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN               D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN
#define D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN               D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN
#define D3DMS_PREFILTER_FORMAT_DEFAULT                     D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT
#define D3DMS_PREFILTER_FORMAT_X1R5G5B5                    D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5
#define D3DMS_PREFILTER_FORMAT_R5G6B5                      D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5
#define D3DMS_PREFILTER_FORMAT_X8R8G8B8                    D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8
#define D3DMS_PREFILTER_FORMAT_A8R8G8B8                    D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8

// utils.cpp
bool IsLinearFormat(DWORD Format);
DWORD BitsPerPixelOfD3DFORMAT(DWORD Format);
LPCSTR GetD3DCMPStr(D3DCMPFUNC d3dcmpfunc);
LPCSTR GetD3DFormatStr(D3DFORMAT d3dformat);
LPCSTR GetMultiSampleStr(DWORD mstype);
LPCSTR GetTextureModeStr(DWORD TextureMode);
UINT64 GetFileTime(LPCSTR lpFileName);

void DisplayError(const char *szCall, HRESULT hr);
#define CheckHR(x) { HRESULT _hr = (x); if (FAILED(_hr)) { DisplayError(#x, _hr); } }
void _cdecl dprintf(LPCSTR lpFmt, ...);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\fsaa\sdkcommon.h ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    SDKCommon.h

Abstract:

    Common header files and macros for the Xbox SDK

Revision History:

--*/

#if !defined(SDK_HEADER_SDKCOMMON_H)
#define SDK_HEADER_SDKCOMMON_H

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef STRICT
#define STRICT 1
#endif
#undef D3D_OVERLOADS

// Windows headers

#ifdef XBOX
#include <xtl.h>
#else
#include "Windows.h"
#include "D3D8.h"
#endif

#if defined(__cplusplus)
extern "C" {
#endif // __cplusplus

#pragma warning (disable:4850)

// __$ReturnUdt is the address of the destination when returning a structure
// It is Microsoft specific so will need to be adjusted to work with other
// compilers. The best way is to declare a local of the correct type and
// then return in.
#define that_ptr __$ReturnUdt

#if defined(__cplusplus)
}
#endif // __cplusplus

#endif //#ifndef SDK_HEADER_RENDERSURFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\fsaa\sources.inc ===
TARGETNAME=FSAA
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    main.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\fsaa\main.cpp ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Illustrates effects of various FSAA modes

Revision History:

    Derived from a DX8 sample.
--*/

#include <SDKCommon.h>
#include <xgraphics.h>
#include <TCHAR.h>

bool                       bQuit   = false;
INT                        g_iType = 0;
INT                        g_iFormat = 0;
INT                        g_iFlicker = 4;

DWORD                      dwFVF = D3DFVF_XYZRHW|D3DFVF_DIFFUSE;

IDirect3D8*                g_pD3D = NULL;
HANDLE                     g_hDevice = 0;      // handle of the gamepad
BOOL                       g_KeyDown[6];
BYTE                       g_PreviousState[6];
BOOL                       g_Pause = false;
BOOL                       g_UseReset = true;  // Use Reset API instead of CreateDevice/Release

// objects that need to be released:
IDirect3DDevice8*          g_pDev  = NULL;
IDirect3DVertexBuffer8*    g_pVB   = NULL;

#define NUMPRIMS 240
#define DA (360.0/(NUMPRIMS*2.0))
#define DR (DA*3.141592654/180.0)
// Define our screen space triangles.

static struct TheVerts { float x,y,z,w; DWORD color; } Verts[NUMPRIMS*3];

//------------------------------------------------------------------------------

struct StateDescription 
{
    DWORD MultisampleFormat;
    WCHAR* Text;
};

StateDescription g_AntialiasTypes[] =
{
    D3DMULTISAMPLE_NONE,                                    L"NONE", 
    D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR,            L"2_SAMPLES_MULTISAMPLE_LINEAR",
    D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX,          L"2_SAMPELS_MULTISAMPLE_QUINCUNX",
    D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR, L"2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR",
    D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR,   L"2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR",
    D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR,            L"4_SAMPLES_MULTISAMPLE_LINEAR",
    D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN,          L"4_SAMPLES_MULTISAMPLE_GAUSSIAN",
    D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR,            L"4_SAMPLES_SUPERSAMPLE_LINEAR",
    D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN,          L"4_SAMPLES_SUPERSAMPLE_GAUSSIAN",
    D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN,          L"9_SAMPLES_MULTISAMPLE_GAUSSIAN",
    D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN,          L"9_SAMPLES_SUPERSAMPLE_GAUSSIAN",
};

INT g_AntialiasTypesCount = sizeof(g_AntialiasTypes) / sizeof(g_AntialiasTypes[0]);

StateDescription g_AntialiasFormats[] =
{
    D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5,   L"PREFILTER_FORMAT_X1R5G5B5",
    D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5,     L"PREFILTER_FORMAT_R5G6B5",
    D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8,   L"PREFILTER_FORMAT_X8R8G8B8",
    D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8,   L"PREFILTER_FORMAT_A8R8G8B8",
};

INT g_AntialiasFormatsCount = sizeof(g_AntialiasFormats) / sizeof(g_AntialiasFormats[0]);

//------------------------------------------------------------------------------
void InitPresentationParameters(D3DPRESENT_PARAMETERS *ppp)
{
    ZeroMemory(ppp, sizeof(*ppp));

    ppp->BackBufferWidth           = 640;
    ppp->BackBufferHeight          = 480;
    ppp->BackBufferFormat          = D3DFMT_X8R8G8B8;
    ppp->BackBufferCount           = 2;
    ppp->Windowed                  = false;   // Must be false for Xbox.
    ppp->EnableAutoDepthStencil    = true;
    ppp->AutoDepthStencilFormat    = D3DFMT_D24S8;
    ppp->SwapEffect                = D3DSWAPEFFECT_DISCARD;
    ppp->FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
    if (g_iType != 0)
        ppp->MultiSampleType       = g_AntialiasTypes[g_iType].MultisampleFormat
                                    | g_AntialiasFormats[g_iFormat].MultisampleFormat;

    WCHAR buf[1024];
    swprintf(buf, L"Flicker: %li  FSAA type: %s | %s\n", 
             g_iFlicker,
             g_AntialiasTypes[g_iType].Text,
             g_AntialiasFormats[g_iFormat].Text);
    OutputDebugString(buf);
}

//------------------------------------------------------------------------------
bool Init()
{
    // Create D3D 8.
    if(g_pD3D == NULL)
    {
        g_pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (g_pD3D == NULL)
            return false;
    }

    // Set the screen mode.
    D3DPRESENT_PARAMETERS d3dpp;
    InitPresentationParameters(&d3dpp);

    // Create the device.
    if (g_pD3D->CreateDevice(D3DADAPTER_DEFAULT,
                             D3DDEVTYPE_HAL,
                             0,
                             D3DCREATE_HARDWARE_VERTEXPROCESSING,
                             &d3dpp,
                             &g_pDev) != S_OK)
        return false;

    // Create the vertex buffer.
    void* pVerts;

    UINT v = 0;
    for(UINT i=0; i<NUMPRIMS; i++)
    {
        Verts[v].x = 320.0f;
        Verts[v].y = 240.0f;
        Verts[v].z = 0.5f;
        Verts[v].w = 1.0f;
        Verts[v].color = 0xffffffff;
        v++;

        Verts[v].x = (FLOAT)(320. + 320.*(cos(i*2.0*DR)));
        Verts[v].y = (FLOAT)(240. + 320.*(sin(i*2.0*DR)));
        Verts[v].z = 0.5f;
        Verts[v].w = 1.0f;
        Verts[v].color = 0xffffffff;
        v++;

        Verts[v].x = (FLOAT)(320. + 320.*(cos((i*2.0+1.0)*DR)));
        Verts[v].y = (FLOAT)(240. + 320.*(sin((i*2.0+1.0)*DR)));
        Verts[v].z = 0.5f;
        Verts[v].w = 1.0f;
        Verts[v].color = 0xffffffff;
        v++;
    }
    if ( g_pDev->CreateVertexBuffer( sizeof(Verts), D3DUSAGE_WRITEONLY, dwFVF, D3DPOOL_MANAGED, &g_pVB ) != S_OK)
        return false;

    g_pVB->Lock( 0, sizeof(Verts), (BYTE **)(&pVerts), 0 );
    memcpy( (void*)pVerts, (void*)Verts, sizeof(Verts) );
    g_pVB->Unlock();

    g_pDev->SetFlickerFilter(g_iFlicker);

    return true;
}

//------------------------------------------------------------------------------
void Uninit()
{
    g_pVB->Release();
    g_pVB = NULL;

    g_pDev->Release();
    g_pDev = NULL;

    g_pD3D->Release();
    g_pD3D = NULL;
}

//------------------------------------------------------------------------------
bool InitGammaRamp()
{
    D3DGAMMARAMP ramp;
    DWORD i;

    for (i = 0; i <= 255; i++)
    {
        FLOAT f = i / 255.0f;

        // sRGB is a gamma of 2.2, but we'll approximate with 2:

        f = (FLOAT) sqrt(f);

        // Normalize and round:

        BYTE b = (BYTE) (f * 255.0f + 0.5f);

        ramp.red[i] = b;
        ramp.green[i] = b;
        ramp.blue[i] = b;
    }

    g_pDev->SetGammaRamp(0, &ramp);

    return true;
}

//------------------------------------------------------------------------------
void Paint()
{
    DWORD minFilter;
    DWORD magFilter;
    DWORD fillMode;
    DWORD lighting;
    DWORD colorKeyOp;
    DWORD shader;

    // Exercise the synchornization code.
    TheVerts* pVerts;
    
    g_pVB->Lock( 0, sizeof(Verts), (BYTE **)(&pVerts), 0 );

    // Transform the verticies to make the triangle spin so we can verify that
    // this actually works over a period of time.
    //
    static DWORD Time = GetTickCount();
    static DWORD CurrentTime;
     
    // If paused, just use the same time as last time:
    if (!g_Pause)
        CurrentTime = GetTickCount();

    // 180 seconds per rotation
    float spin = 2 * 3.14159f * (float)(CurrentTime - Time) / 180000.0f;

    DWORD i;

    for (i = 0; i < NUMPRIMS*3; i++)
    {

        float x = Verts[i].x;
        float y = Verts[i].y;

        x = x - 320.0f;
        y = y - 240.0f;

        pVerts[i].x = x * (float)cos(spin) - y * (float)sin(spin);
        pVerts[i].y = x * (float)sin(spin) + y * (float)cos(spin);

        pVerts[i].x += 320.0f;
        pVerts[i].y += 240.0f;
    }

    g_pVB->Unlock();

    // Clear the frame buffer, Zbuffer.
    g_pDev->Clear(0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0X00000000, 1.0, 0);

    // Draw the vertex streamsetup in stream 0.
    g_pDev->BeginScene();

    g_pDev->SetStreamSource( 0, g_pVB, sizeof(Verts[0]) );
    g_pDev->SetVertexShader( dwFVF );
    g_pDev->DrawPrimitive( D3DPT_TRIANGLELIST, 0, NUMPRIMS );      // Draw a single triangle.

    g_pDev->EndScene();

    // Set some state to ensure that Present() doesn't nuke it:
    g_pDev->SetVertexShader( D3DFVF_XYZ );

g_pDev->SetVertexShader( 0 );

    g_pDev->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
    g_pDev->SetRenderState(D3DRS_LIGHTING, FALSE);
    g_pDev->SetTextureStageState(0, D3DTSS_COLORKEYOP, D3DTCOLORKEYOP_KILL);
    g_pDev->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_POINT);
    g_pDev->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_POINT);
    g_pDev->SetShaderConstantMode(D3DSCM_192CONSTANTS);

    // Flip the buffers.
    g_pDev->Present(NULL, NULL, NULL, NULL);

    // Check the state.
    g_pDev->SetShaderConstantMode(D3DSCM_96CONSTANTS);

    g_pDev->GetVertexShader(&shader);
    g_pDev->GetRenderState(D3DRS_FILLMODE, &fillMode);
    g_pDev->GetRenderState(D3DRS_LIGHTING, &lighting);
    g_pDev->GetTextureStageState(0, D3DTSS_COLORKEYOP, &colorKeyOp);
    g_pDev->GetTextureStageState(0, D3DTSS_MINFILTER, &minFilter);
    g_pDev->GetTextureStageState(0, D3DTSS_MAGFILTER, &magFilter);

    if ((shader != 0) ||
        (fillMode != D3DFILL_WIREFRAME) ||
        (lighting != FALSE) ||
        (colorKeyOp != D3DTCOLORKEYOP_KILL) ||
        (minFilter != D3DTEXF_POINT) || 
        (magFilter != D3DTEXF_POINT))
    {
        _asm int 3;
    }

    // Reset the state.
    g_pDev->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
    g_pDev->SetRenderState(D3DRS_LIGHTING, TRUE);
    g_pDev->SetTextureStageState(0, D3DTSS_COLORKEYOP, D3DTCOLORKEYOP_DISABLE);
}

//------------------------------------------------------------------------------
INT CheckInput()
{
    DWORD dwInsertions, dwRemovals, i;
    INT key = -1;
    
    //
    //  Check to see if a port 0 gamepad has come or gone.
    //
    if(XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals))
    {
        if(dwRemovals&XDEVICE_PORT0_MASK)
        {
            if(g_hDevice)
            {
                XInputClose(g_hDevice);
                g_hDevice = NULL;
            }
        }
        if(dwInsertions&XDEVICE_PORT0_MASK)
        {
            g_hDevice = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL);
        }
    }

    // If we have a device, get its state.
    if (g_hDevice)
    {
        XINPUT_STATE InputState;

        XInputGetState(g_hDevice, &InputState);
        // check to see if we need to change modes
        for (i = 0; i < 6; i++)
        {
            if ((InputState.Gamepad.bAnalogButtons[i] == 0) != 
                (g_PreviousState[i] == 0))
            {
                g_KeyDown[i] = !g_KeyDown[i];
                if (g_KeyDown[i])
                    key = i;
            }
            g_PreviousState[i] = InputState.Gamepad.bAnalogButtons[i];
        }
    }

    return key;
}

//-----------------------------------------------------------------------------
// Name: AddModulus()
//-----------------------------------------------------------------------------
INT AddModulus(INT Value, INT Increment, INT Max)
{
    Value += Increment;
    if (Value >= Max)
        Value -= Max;
    if (Value < 0)
        Value += Max;

    return Value;
}

//-----------------------------------------------------------------------------
// Name: main()
// Desc: The application's entry point
//-----------------------------------------------------------------------------
void __cdecl main()
{
    D3DPRESENT_PARAMETERS pp;
    INT keyDown;

    //Initialize core peripheral port support
    XInitDevices(0,NULL);
    
    // Initialize the gamepad
    if(XDEVICE_PORT0_MASK & XGetDevices(XDEVICE_TYPE_GAMEPAD))
    {
        g_hDevice = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL);
    }

    if (!Init() || !InitGammaRamp())
    {
        OutputDebugString( L"Could not initialize\n");
        _asm int 3;
    }

    while (TRUE)
    {
        while (TRUE)
        {
            Paint();

            keyDown = CheckInput();

            if (keyDown == XINPUT_GAMEPAD_BLACK)
                g_Pause = !g_Pause;
            else if (keyDown == XINPUT_GAMEPAD_A)
            {
                g_iType = AddModulus(g_iType, 1, g_AntialiasTypesCount);
                break;
            }
            else if (keyDown == XINPUT_GAMEPAD_B)
            {
                g_iType = AddModulus(g_iType, -1, g_AntialiasTypesCount);
                break;
            }
            else if (keyDown == XINPUT_GAMEPAD_X)
            {
                g_iFlicker = AddModulus(g_iFlicker, 1, 5);
                break;
            }
            else if (keyDown == XINPUT_GAMEPAD_Y)
            {
                g_iFlicker = AddModulus(g_iFlicker, -1, 5);
                break;
            }
        }

        g_pDev->PersistDisplay();

        if (g_UseReset)
        {
            InitPresentationParameters(&pp);
            if (g_pDev->Reset(&pp) != S_OK)
            {
                OutputDebugString( L"Could not Reset\n");
                _asm int 3;
            }
        }
        else
        {
            Uninit();
            if (!Init() || !InitGammaRamp())
            {
                OutputDebugString( L"Could not initialize\n");
                _asm int 3;
            }
        }

        g_pDev->SetFlickerFilter(g_iFlicker);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\fillrate\vstune\vstune.h ===
//-----------------------------------------------------------------------------
// FILE: VSTUNE.H
//
// Desc: vertex shader tune header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

struct TIMETESTRESULTS
{
    float fps;
    UINT cFrames;
    float TimeTillDoneDrawing;
    float TimeTillIdle;
    UINT64 cTrisDrawn;
    float mtps;
    float cycles;

    // precompiled results
    DWORD byteswritten;
    float throughput;
    DWORD pushbuffercalls;
    DWORD pushbuffersize;

    D3DWAITINFO PushBufferWaitInfo;
};

struct VSTSETTINGS
{
    UINT verboselevel;                  // chatty when loading pixelshader defs, etc.
    bool runtestonreload;               // after reloading fillrate.ini run test

    float screenwidth;                  // screen width
    float screenheight;                 // screen height
    D3DFORMAT BackBufferFormat;         // back buffer d3dformat
    D3DFORMAT AutoDepthStencilFormat;   // z buffer format (0 for none)

    D3DMULTISAMPLE_TYPE MSType;         // multisample type
    D3DMULTISAMPLE_TYPE MSFormat;       // multisample format

    DWORD FVF;                          // fvf type
    D3DPRIMITIVETYPE primitivetype;     // vertex buffer primitive type
    UINT indexcount;                    // count of indices
    UINT vertcount;                     // count of vertices in VB
    UINT TriCount;                      // count of triangles drawn

    DWORD uservertexshader;             // user vertex shader instruction count

    D3DCULL cullmode;                   // cullmode

    bool degenerates;                   // degenerate primitives?

    bool zenable;                       // enable z buffer
    bool zwriteenable;                  // enable z write
    D3DCMPFUNC d3dcmpfunc;              // z compare function

    float testtime;                     // number of seconds to time
    UINT vbdrawcount;                   // count of times to draw VB
    int precompiled;                    // use precompiled pushbuffer?
    int wcwritesinbkgnd;                // do wc background writes or block?
    int pushbuffernops;                 // insert noops into pushbuffer
    DWORD framesperpushbuffermax;       // max frames recorded in pushbuffer
    bool runusingcpucopy;               // copy pushbuffer
    DWORD numberofpushbuffers;          // number of pushbuffers (1 - 300) to use

    DWORD clearflags;                   // Clear() flags
    DWORD cclearval;                    // color clear val
    float zclearval;                    // z clear val
    DWORD sclearval;                    // stencil clear val

    bool alphablendenable;              // turn on alphablend
    bool alphatestenable;               // turn on alphatest

    D3DFILLMODE d3dfillmode;            // SOLID, WIREFRAME, ...

    bool localviewer;                   // D3DRS_LOCALVIEWER
    bool specularenable;                // D3DRS_SPECULARENABLE
    bool fogenable;                     // D3DRS_FOGENABLE
    bool normalizenormals;              // D3DRS_NORMALIZENORMALS
    bool colorvertex;                   // D3DRS_COLORVERTEX

    bool lighting;                      // D3DRS_LIGHTING
    DWORD numDirectionalLights;         // # of directional lights
    DWORD numPointLights;               // # of point lights
    DWORD numSpotLights;                // # of spotlights

    DWORD numtextures;                  // number of textures

    DWORD NumLights;                    // total number of lights enabled
    DWORD NumStreams;                   // total number of VB streams
};

// macros to help us define the size of our texcoords in vstune.ini
static const DWORD T0_SIZE1 = D3DFVF_TEXCOORDSIZE1(0);
static const DWORD T0_SIZE2 = D3DFVF_TEXCOORDSIZE2(0);
static const DWORD T0_SIZE3 = D3DFVF_TEXCOORDSIZE3(0);
static const DWORD T0_SIZE4 = D3DFVF_TEXCOORDSIZE4(0);

static const DWORD T1_SIZE1 = D3DFVF_TEXCOORDSIZE1(1);
static const DWORD T1_SIZE2 = D3DFVF_TEXCOORDSIZE2(1);
static const DWORD T1_SIZE3 = D3DFVF_TEXCOORDSIZE3(1);
static const DWORD T1_SIZE4 = D3DFVF_TEXCOORDSIZE4(1);

static const DWORD T2_SIZE1 = D3DFVF_TEXCOORDSIZE1(2);
static const DWORD T2_SIZE2 = D3DFVF_TEXCOORDSIZE2(2);
static const DWORD T2_SIZE3 = D3DFVF_TEXCOORDSIZE3(2);
static const DWORD T2_SIZE4 = D3DFVF_TEXCOORDSIZE4(2);

static const DWORD T3_SIZE1 = D3DFVF_TEXCOORDSIZE1(3);
static const DWORD T3_SIZE2 = D3DFVF_TEXCOORDSIZE2(3);
static const DWORD T3_SIZE3 = D3DFVF_TEXCOORDSIZE3(3);
static const DWORD T3_SIZE4 = D3DFVF_TEXCOORDSIZE4(3);

static const DWORD VSDT_FLOAT1 = D3DVSDT_FLOAT1 << 16;
static const DWORD VSDT_FLOAT2 = D3DVSDT_FLOAT2 << 16;
static const DWORD VSDT_FLOAT3 = D3DVSDT_FLOAT3 << 16;
static const DWORD VSDT_FLOAT4 = D3DVSDT_FLOAT4 << 16;
static const DWORD VSDT_D3DCOLOR = D3DVSDT_D3DCOLOR << 16;
static const DWORD VSDT_SHORT2 = D3DVSDT_SHORT2 << 16;
static const DWORD VSDT_SHORT4 = D3DVSDT_SHORT4 << 16;
static const DWORD VSDT_NORMSHORT1 = D3DVSDT_NORMSHORT1 << 16;
static const DWORD VSDT_NORMSHORT2 = D3DVSDT_NORMSHORT2 << 16;
static const DWORD VSDT_NORMSHORT3 = D3DVSDT_NORMSHORT3 << 16;
static const DWORD VSDT_NORMSHORT4 = D3DVSDT_NORMSHORT4 << 16;
static const DWORD VSDT_NORMPACKED3 = D3DVSDT_NORMPACKED3 << 16;
static const DWORD VSDT_SHORT1 = D3DVSDT_SHORT1 << 16;
static const DWORD VSDT_SHORT3 = D3DVSDT_SHORT3 << 16;
static const DWORD VSDT_PBYTE1 = D3DVSDT_PBYTE1 << 16;
static const DWORD VSDT_PBYTE2 = D3DVSDT_PBYTE2 << 16;
static const DWORD VSDT_PBYTE3 = D3DVSDT_PBYTE3 << 16;
static const DWORD VSDT_PBYTE4 = D3DVSDT_PBYTE4 << 16;
static const DWORD VSDT_FLOAT2H = D3DVSDT_FLOAT2H << 16;
static const DWORD VSDT_NONE = D3DVSDT_NONE << 16;

// vstune.cpp
bool ReadVSTIniFile();

void DoQuickTimedTest();
void DoPushBufferCallTest();
void RandomVS();

void DumpCurrentSettings();
float DoTimedTest(TIMETESTRESULTS *pttres = NULL);
void InitVertexShader();
void ClearScreen();
DWORD GetNVCLK();
void RenderFrame(int vbdrawcount, BOOL nops = FALSE);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\Media\satest\blinn_reflect.h ===
/******************************************************************************

  Copyright (C) 1999, 2000 NVIDIA Corporation
  This file is provided without support, instruction, or implied warranty of any
  kind.  NVIDIA makes no guarantee of its fitness for a particular purpose and is
  not liable under any circumstances for any damages or loss whatsoever arising
  from the use or inability to use this file or items derived from it.
  
    Comments:
    
      
        
******************************************************************************/

#define CV_ZERO 0
#define CV_ONE 1

#define CV_WORLDVIEWPROJ_0 2
#define CV_WORLDVIEWPROJ_1 3
#define CV_WORLDVIEWPROJ_2 4
#define CV_WORLDVIEWPROJ_3 5

#define CV_WORLDVIEW_0 6
#define CV_WORLDVIEW_1 7
#define CV_WORLDVIEW_2 8
#define CV_WORLDVIEW_3 9

#define CV_WORLDVIEWIT_0 10
#define CV_WORLDVIEWIT_1 11
#define CV_WORLDVIEWIT_2 12

#define CV_WORLD_0 13
#define CV_WORLD_1 14
#define CV_WORLD_2 15
#define CV_WORLD_3 16

#define CV_HALF 18

#define CV_LIGHT_COLOR 19
#define CV_ONE_OVER_LIGHT_RANGE 20

#define CV_LIGHT_DIRECTION 21
#define CV_LIGHT_POSITION 22

#define CV_EYE_VECTOR 23

// Pixel shader defines
#define CP_EYE_VECTOR 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\font\main.c ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    App to test TV output

--*/

#define XFONT_TRUETYPE 1

#include <xtl.h>
#include <xgraphics.h>
#include <xfont.h>
#include <stdio.h>
#include <xbdm.h>
#include <av.h>
#include <xfont.h>

#define THETEXT L"I'm a little teapot, short and stout."

D3DSurface *g_pBack;
D3DSurface *g_pZBuffer;
D3DSurface *g_pTextureSurface;

HANDLE g_InputHandle;

BOOL g_A;
BOOL g_B;
BOOL g_X;
BOOL g_Y;

typedef enum _WHICHFONT {

    WHICH_Default,
    WHICH_Uni0,
    WHICH_Uni2,
    WHICH_Uni4,

    WHICH_Max,

} WHICHFONT;

WHICHFONT g_WhichFont;

DWORD g_Sizes[] =
{
    16,
    24,
    32,
    40,
    48,
    56,
    60,
    65,
    70,
    75,
    80,
    90,
    100,
    110,
    150,
    180,
    200
};

DWORD g_WhichSize;

XFONT *g_pFont;

XFONT *g_pDefaultFont;
XFONT *g_pUnicodeFont;
XFONT *g_pStatusFont;
       
typedef struct _MYFORMAT
{
    D3DFORMAT Format;
    DWORD ClearValue;
    DWORD BytesPerPixel;
    WCHAR *Name;
} MYFORMAT;

D3DFORMAT g_FrameFormats[] = 
{ 
    D3DFMT_X8R8G8B8, 
    D3DFMT_A8R8G8B8, 
    D3DFMT_R5G6B5, 
    D3DFMT_X1R5G5B5 
};

DWORD g_FrameFormat;

MYFORMAT g_TextureFormats[] = 
{ 
    { D3DFMT_LIN_A1R5G5B5,     0x0300, 2, L"A1R5G5B5" },
    { D3DFMT_LIN_R5G6B5,       0x0600, 2, L"R5G6B5"   },
    { D3DFMT_LIN_A8R8G8B8, 0x8000C000, 4, L"A8R8G8B8" },
    { D3DFMT_LIN_R8B8,         0xC000, 2, L"R8B8"     },
    { D3DFMT_LIN_G8B8,         0xC000, 2, L"G8B8"     },
    { D3DFMT_LIN_X1R5G5B5,     0x0300, 2, L"X1R5G5B5" },
    { D3DFMT_LIN_A4R4G4B4,     0x80C0, 2, L"A4R4G4B4" },
    { D3DFMT_LIN_X8R8G8B8, 0x0000C000, 4, L"X8R8G8B8" },
    { D3DFMT_LIN_A8,             0x80, 1, L"A8"       },
    { D3DFMT_LIN_R5G5B5A1,     0x0600, 2, L"R5G5B5A1" }, 
    { D3DFMT_LIN_R4G4B4A4,     0x0C08, 2, L"R4G4B4A4" },
    { D3DFMT_LIN_A8B8G8R8, 0x8000C000, 4, L"A8B8G8R8" },
    { D3DFMT_LIN_B8G8R8A8, 0x00C00080, 4, L"B8G8R8A8" },
    { D3DFMT_LIN_R8G8B8A8, 0x00C00080, 4, L"R8G8B8A8" },
};

DWORD g_TextureFormat;


D3DRECT g_rect = { 40, 40, 601, 441 };

long g_x = 320;
long g_y = 240;

DWORD g_Color = 0x000000FF;

BOOL g_DrawWithTexture;

static struct TheVerts { float x,y,z,w,tu,tv; } g_Verts[] =
{
    {   0.0f,   0.0f, 0.5f, 1.0f,   0.0f,   0.0f},
    { 639.0f,   0.0f, 0.5f, 1.0f, 511.0f,   0.0f},
    { 639.0f, 479.0f, 0.5f, 1.0f, 511.0f, 511.0f},
    {   0.0f, 479.0f, 0.5f, 1.0f,   0.0f, 511.0f},
};

DWORD g_dwFVF = D3DFVF_XYZRHW | D3DFVF_TEX1;

//==============================================================================
// Graphics
//==============================================================================

//------------------------------------------------------------------------------
// Creates a texture.
//                                                                                                                                                                  
void CreateTexture()
{
    D3DTexture *pTexture;

    D3DDevice_CreateTexture(512, 512, 1, 0, g_TextureFormats[g_TextureFormat].Format, 0, &pTexture);

    if (g_pTextureSurface)
    {
        D3DSurface_Release(g_pTextureSurface);
    }

    D3DTexture_GetSurfaceLevel(pTexture, 0, &g_pTextureSurface);

    D3DDevice_SetTexture(0, (D3DBaseTexture *)pTexture);

    D3DDevice_SetTextureStageState(0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP);
    D3DDevice_SetTextureStageState(0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP);

    D3DDevice_SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
    D3DDevice_SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);

    D3DDevice_SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    D3DDevice_SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    D3DDevice_SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    D3DDevice_SetRenderState(D3DRS_ZENABLE, FALSE);
    D3DDevice_SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
        
    D3DTexture_Release(pTexture);
}

//------------------------------------------------------------------------------
// Loads a font.
//
DWORD g_CurrentTextHeight;

void
LoadFont()
{
    if (!g_pUnicodeFont)
    {
        g_WhichFont = WHICH_Default;
    }

    switch(g_WhichFont)
    {
    case WHICH_Default:
        g_pFont = g_pDefaultFont;
        g_WhichSize = 1;
        break;

    case WHICH_Uni0:
        g_pFont = g_pUnicodeFont;
        XFONT_SetTextAntialiasLevel(g_pFont, 0);
        break;

    case WHICH_Uni2:
        g_pFont = g_pUnicodeFont;
        XFONT_SetTextAntialiasLevel(g_pFont, 2);
        break;

    case WHICH_Uni4:
        g_pFont = g_pUnicodeFont;
        XFONT_SetTextAntialiasLevel(g_pFont, 4);
        break;
    }    

    if (g_WhichFont != WHICH_Default && g_WhichSize != g_CurrentTextHeight)
    {
        XFONT_SetTextHeight(g_pFont, g_Sizes[g_WhichSize]);
        g_CurrentTextHeight = g_WhichSize;
    }
}

//------------------------------------------------------------------------------
// Intialize D3D.
//
void
Init()
{
    D3DPRESENT_PARAMETERS d3dpp;

    // Initialize the controller.
    XInitDevices(0, NULL);

    // Make D3D go.
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = g_FrameFormats[g_FrameFormat];
    d3dpp.BackBufferCount           = 1;
    d3dpp.EnableAutoDepthStencil    = TRUE;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;

    // Create the device.
    Direct3D_CreateDevice(
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        NULL,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        NULL);

    // Get the buffer to draw into.
    D3DDevice_GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &g_pBack);
    D3DDevice_GetDepthStencilSurface(&g_pZBuffer);

    // Get the default font.
    XFONT_OpenDefaultFont(&g_pDefaultFont);
    XFONT_Release(g_pDefaultFont);

    XFONT_OpenDefaultFont(&g_pDefaultFont);

    XFONT_SetTextAlignment(g_pDefaultFont, XFONT_CENTER | XFONT_BASELINE);
    XFONT_SetTextColor(g_pDefaultFont, 0xC0FFFFFF);

    // Get the utility font.
    XFONT_OpenDefaultFont(&g_pStatusFont);
    XFONT_SetTextColor(g_pStatusFont, 0xFFFFFF00);

    // Get the unicode font.
    XFONT_OpenTrueTypeFont(L"d:\\media\\arialuni.ttf", 2 * 1024 * 1024, &g_pUnicodeFont);

    if (g_pUnicodeFont)
    {
        XFONT_SetTextAlignment(g_pUnicodeFont, XFONT_CENTER | XFONT_BASELINE);
        XFONT_SetTextColor(g_pUnicodeFont, 0xC0FFFFFF);
    }

    // Prepare to render.
    D3DDevice_SetVertexShader(g_dwFVF);

    // Create the texture.
    CreateTexture();

    // Set the first font.
    LoadFont();
}


//------------------------------------------------------------------------------
// Draw one frame.
//
void
Paint()
{    
    D3DLOCKED_RECT rect;
    DWORD *pDW;
    WORD *pW;
    BYTE *pB;
    DWORD x, y;

    WCHAR Buffer[80];

    if (g_DrawWithTexture)
    {
        D3DSurface_LockRect(g_pTextureSurface, &rect, NULL, 0);
         
        switch (g_TextureFormats[g_TextureFormat].BytesPerPixel)
        {
        case 4:
            for (y = 0; y < 512; y++)
            {
                pDW = (DWORD *)((BYTE *)rect.pBits + rect.Pitch * y);

                for (x = 0; x < 512; x++)
                {
                    *(pDW++) = (DWORD)g_TextureFormats[g_TextureFormat].ClearValue;
                }
            }
            break;

        case 2:
            for (y = 0; y < 512; y++)
            {
                pW = (WORD *)((BYTE *)rect.pBits + rect.Pitch * y);

                for (x = 0; x < 512; x++)
                {
                    *(pW++) = (WORD)g_TextureFormats[g_TextureFormat].ClearValue;
                }
            }
            break;

        case 1:
            for (y = 0; y < 512; y++)
            {
                pB = (BYTE *)((BYTE *)rect.pBits + rect.Pitch * y);

                for (x = 0; x < 512; x++)
                {
                    *(pB++) = (BYTE)g_TextureFormats[g_TextureFormat].ClearValue;
                }
            }
            break;
        }

        XFONT_SetClippingRectangle(g_pFont, NULL);
        XFONT_TextOut(g_pFont, g_pTextureSurface, THETEXT, -1, g_x, g_y);

//        D3DDevice_SetRenderTarget(g_pBack, g_pZBuffer);

        D3DDevice_Clear(0, NULL, D3DCLEAR_TARGET, g_Color, 1.0, 0);
        D3DDevice_Clear(1, &g_rect, D3DCLEAR_TARGET, g_Color & 0x00808080, 1.0, 0);

        D3DDevice_DrawVerticesUP(D3DPT_TRIANGLEFAN, sizeof(g_Verts) / sizeof(g_Verts[0]), g_Verts, sizeof(g_Verts[0]));
    }
    else
    {
        D3DDevice_Clear(0, NULL, D3DCLEAR_TARGET, g_Color, 1.0, 0);
        D3DDevice_Clear(1, &g_rect, D3DCLEAR_TARGET, g_Color & 0x00808080, 1.0, 0);

        XFONT_SetClippingRectangle(g_pFont, &g_rect);
        XFONT_TextOut(g_pFont, g_pBack, THETEXT, -1, g_x, g_y);
    }

    wcscpy(Buffer, L"FONT: ");
    switch(g_WhichFont)
    {
    case WHICH_Default:
        wcscat(Buffer, L"DEFAULT");
        break;
    case WHICH_Uni0:
        wcscat(Buffer, L"UNICODE-0");
        break;
    case WHICH_Uni2:
        wcscat(Buffer, L"UNICODE-2");
        break;
    case WHICH_Uni4:
        wcscat(Buffer, L"UNICODE-4");
        break;
    }

    XFONT_TextOut(g_pStatusFont, g_pBack, Buffer, -1, 50, 50);

    wcscpy(Buffer, L"BACK BUFFER: ");
    switch(g_FrameFormat)
    {
    case 0:
        wcscat(Buffer, L"X8R8G8B8");
        break;
    case 1:
        wcscat(Buffer, L"A8R8G8B8");
        break; 
    case 2:
        wcscat(Buffer, L"R5G6B5");
        break;
    case 3:
        wcscat(Buffer, L"X1R5G5B5");
        break;
    }

    XFONT_TextOut(g_pStatusFont, g_pBack, Buffer, -1, 280, 50);

    wsprintf(Buffer, L"SIZE: %d", g_Sizes[g_WhichSize]);

    XFONT_TextOut(g_pStatusFont, g_pBack, Buffer, -1, 50, 76);

    if (g_DrawWithTexture)
    {
        wcscpy(Buffer, L"TEXTURE: ");
        wcscat(Buffer, g_TextureFormats[g_TextureFormat].Name);

        XFONT_TextOut(g_pStatusFont, g_pBack, Buffer, -1, 280, 76);
    }

    // Show it.
    D3DDevice_Swap(0);
}

//------------------------------------------------------------------------------
// Handle controller input.
//
void ProcessInput()
{
    XINPUT_STATE InputState;
    DWORD A, B, X, Y;
    D3DPRESENT_PARAMETERS d3dpp;

    if (!(XGetDevices(XDEVICE_TYPE_GAMEPAD) & XDEVICE_PORT0_MASK))        
    {
        if (g_InputHandle)
        {
            XInputClose(g_InputHandle);
            g_InputHandle = NULL;
        }

        return;
    }

    if (!g_InputHandle)
    {
        g_InputHandle = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, 0, NULL);
    }

    // Query the input state
    if (XInputGetState(g_InputHandle, &InputState) != ERROR_SUCCESS)
    {
        return;
    }

    A = InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] & 0x80;
    B = InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] & 0x80;
    X = InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] & 0x80;
    Y = InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] & 0x80;

    g_x = 400 * InputState.Gamepad.sThumbLX / 32768 + 400;
    g_y = 300 * -InputState.Gamepad.sThumbLY / 32768 + 300;

    if (A)
    {
        if (!g_A)
        {
            g_WhichFont = (g_WhichFont + 1) % WHICH_Max;
        }
    }

    g_A = A;

    if (B)
    {
        if (!g_B)
        {
            g_WhichSize = (g_WhichSize + 1) % (sizeof(g_Sizes) / 4);
        }
    }

    g_B = B;

    if (X)
    {
        if (!g_X)
        {
            g_DrawWithTexture = !g_DrawWithTexture;
        }
    }

    g_X = X;

    if (Y)
    {
        if (!g_Y)
        {            
            if (g_DrawWithTexture)
            {
                g_TextureFormat = (g_TextureFormat + 1) % (sizeof(g_TextureFormats) / sizeof(g_TextureFormats[0]));

                CreateTexture();
            }
            else
            {
                g_FrameFormat = (g_FrameFormat + 1) %  (sizeof(g_FrameFormats) / sizeof(g_FrameFormats[0]));

                ZeroMemory(&d3dpp, sizeof(d3dpp));

                d3dpp.BackBufferWidth            = 640;
                d3dpp.BackBufferHeight           = 480;
                d3dpp.BackBufferFormat           = g_FrameFormats[g_FrameFormat];
                d3dpp.BackBufferCount            = 1;
                d3dpp.EnableAutoDepthStencil     = TRUE;
                d3dpp.AutoDepthStencilFormat     = D3DFMT_D24S8;

                D3DDevice_Reset(&d3dpp);
            }
        }
    }

    g_Y = Y;

    LoadFont();
}

//==============================================================================
// Main goo.
//==============================================================================

//------------------------------------------------------------------------------
// Main entrypoint.
//
void __cdecl main()
{
    Init();

    for(;;)
    {
        ProcessInput();

        Paint();

        D3DDevice_BlockUntilIdle();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\Media\satest\dot3.h ===
/******************************************************************************

  Copyright (C) 1999, 2000 NVIDIA Corporation
  This file is provided without support, instruction, or implied warranty of any
  kind.  NVIDIA makes no guarantee of its fitness for a particular purpose and is
  not liable under any circumstances for any damages or loss whatsoever arising
  from the use or inability to use this file or items derived from it.
  
    Comments:
    
      
        
******************************************************************************/

#define CV_ZERO 0
#define CV_ONE 1

#define CV_WORLDVIEWPROJ_0 2
#define CV_WORLDVIEWPROJ_1 3
#define CV_WORLDVIEWPROJ_2 4
#define CV_WORLDVIEWPROJ_3 5

#define CV_WORLDVIEW_0 6
#define CV_WORLDVIEW_1 7
#define CV_WORLDVIEW_2 8
#define CV_WORLDVIEW_3 9

#define CV_WORLDVIEWIT_0 10
#define CV_WORLDVIEWIT_1 11
#define CV_WORLDVIEWIT_2 12

#define CV_WORLD_0 13
#define CV_WORLD_1 14
#define CV_WORLD_2 15
#define CV_WORLD_3 16

#define CV_HALF 18

#define CV_LIGHT_COLOR 19
#define CV_ONE_OVER_LIGHT_RANGE 20

#define CV_LIGHT_DIRECTION 21
#define CV_LIGHT_POSITION 22
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\Media\satest\MotionBlur.h ===
/******************************************************************************

  Copyright (C) 1999, 2000 NVIDIA Corporation
  This file is provided without support, instruction, or implied warranty of any
  kind.  NVIDIA makes no guarantee of its fitness for a particular purpose and is
  not liable under any circumstances for any damages or loss whatsoever arising
  from the use or inability to use this file or items derived from it.
  
    Comments:
    
      
        
******************************************************************************/

#define CV_ZERO              0
#define CV_OBJECT_EXTEND     1

#define CV_PREV_COLOR        2
#define CV_CURR_COLOR        3

#define CV_PREV_VIEW_PROJ_0  4
#define CV_PREV_VIEW_PROJ_1  5
#define CV_PREV_VIEW_PROJ_2  6
#define CV_PREV_VIEW_PROJ_3  7

#define CV_PREV_WORLD_TXF_0  8
#define CV_PREV_WORLD_TXF_1  9
#define CV_PREV_WORLD_TXF_2 10
#define CV_PREV_WORLD_TXF_3 11

#define CV_CURR_VIEW_PROJ_0 12
#define CV_CURR_VIEW_PROJ_1 13
#define CV_CURR_VIEW_PROJ_2 14
#define CV_CURR_VIEW_PROJ_3 15

#define CV_CURR_WORLD_TXF_0 16
#define CV_CURR_WORLD_TXF_1 17
#define CV_CURR_WORLD_TXF_2 18
#define CV_CURR_WORLD_TXF_3 19
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\Media\satest\oFogFog.h ===
/******************************************************************************

  Copyright (C) 1999, 2000 NVIDIA Corporation
  This file is provided without support, instruction, or implied warranty of any
  kind.  NVIDIA makes no guarantee of its fitness for a particular purpose and is
  not liable under any circumstances for any damages or loss whatsoever arising
  from the use or inability to use this file or items derived from it.
  
    Comments:
    
      
        
******************************************************************************/

#define CV_ZERO 0
#define CV_ONE 1

#define CV_WORLDVIEWPROJ_0 2
#define CV_WORLDVIEWPROJ_1 3
#define CV_WORLDVIEWPROJ_2 4
#define CV_WORLDVIEWPROJ_3 5

#define CV_WORLDVIEW_0 6
#define CV_WORLDVIEW_1 7
#define CV_WORLDVIEW_2 8
#define CV_WORLDVIEW_3 9

#define CV_WORLDVIEWIT_0 10
#define CV_WORLDVIEWIT_1 11
#define CV_WORLDVIEWIT_2 12

#define CV_PROJ_0 13
#define CV_PROJ_1 14
#define CV_PROJ_2 15
#define CV_PROJ_3 16

#define CV_LIGHT1_DIRECTION 17
#define CV_LIGHT1_AMBIENT 18
#define CV_LIGHT1_DIFFUSE 19

#define CV_DIFFUSE_MATERIAL 20

#define CV_WORLD_EYE 21

#define CV_WORLD_0 22
#define CV_WORLD_1 23
#define CV_WORLD_2 24
#define CV_WORLD_3 25

#define CV_FOG_SCALE 26

#define CV_FOG_PLANE_TOP_POSITION 27
#define CV_FOG_PLANE_TOP_NORMAL 28
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\Media\satest\fog.h ===
/******************************************************************************

  Copyright (C) 1999, 2000 NVIDIA Corporation
  This file is provided without support, instruction, or implied warranty of any
  kind.  NVIDIA makes no guarantee of its fitness for a particular purpose and is
  not liable under any circumstances for any damages or loss whatsoever arising
  from the use or inability to use this file or items derived from it.
  
    Comments:
    
      
        
******************************************************************************/

#define CV_ZERO 0
#define CV_ONE 1

#define CV_WORLDVIEWPROJ_0 2
#define CV_WORLDVIEWPROJ_1 3
#define CV_WORLDVIEWPROJ_2 4
#define CV_WORLDVIEWPROJ_3 5

#define CV_WORLDVIEW_0 6
#define CV_WORLDVIEW_1 7
#define CV_WORLDVIEW_2 8
#define CV_WORLDVIEW_3 9

#define CV_WORLDVIEWIT_0 10
#define CV_WORLDVIEWIT_1 11
#define CV_WORLDVIEWIT_2 12

#define CV_PROJ_0 13
#define CV_PROJ_1 14
#define CV_PROJ_2 15
#define CV_PROJ_3 16

#define CV_LIGHT1_DIRECTION 17
#define CV_LIGHT1_AMBIENT 18
#define CV_LIGHT1_DIFFUSE 19

#define CV_DIFFUSE_MATERIAL 20

#define CV_WORLD_EYE 21

#define CV_WORLD_0 22
#define CV_WORLD_1 23
#define CV_WORLD_2 24
#define CV_WORLD_3 25

#define CV_FOG_SCALE 26

#define CV_FOG_PLANE_TOP_POSITION 27
#define CV_FOG_PLANE_TOP_NORMAL 28
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\Media\satest\reflect.h ===
/******************************************************************************

  Copyright (C) 1999, 2000 NVIDIA Corporation
  This file is provided without support, instruction, or implied warranty of any
  kind.  NVIDIA makes no guarantee of its fitness for a particular purpose and is
  not liable under any circumstances for any damages or loss whatsoever arising
  from the use or inability to use this file or items derived from it.
  
    Comments:
    
      
        
******************************************************************************/

#define CV_ZERO 0
#define CV_ONE 1

#define CV_WORLDVIEWPROJ_0 2
#define CV_WORLDVIEWPROJ_1 3
#define CV_WORLDVIEWPROJ_2 4
#define CV_WORLDVIEWPROJ_3 5

#define CV_WORLDVIEWIT_0 6
#define CV_WORLDVIEWIT_1 7
#define CV_WORLDVIEWIT_2 8

#define CV_VECA 10
#define CV_VECD 11
#define CV_VECSIN 12
#define CV_VECCOS 13

#define CV_HALF 14
#define CV_LIGHT1_DIRECTION 15

#define CV_WORLDVIEW_0 16
#define CV_WORLDVIEW_1 17
#define CV_WORLDVIEW_2 18
#define CV_WORLDVIEW_3 19
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\Media\satest\ParticleSystem.h ===
/******************************************************************************

  Copyright (C) 1999, 2000 NVIDIA Corporation
  This file is provided without support, instruction, or implied warranty of any
  kind.  NVIDIA makes no guarantee of its fitness for a particular purpose and is
  not liable under any circumstances for any damages or loss whatsoever arising
  from the use or inability to use this file or items derived from it.
  
    Comments:
    
      
        
******************************************************************************/

#define VSC_WORLDVIEW_PROJ_0   80
#define VSC_WORLDVIEW_PROJ_1   81
#define VSC_WORLDVIEW_PROJ_2   82
#define VSC_WORLDVIEW_PROJ_3   83

#define VSC_START_POSITION     84
#define VSC_DIRECTION          85
#define VSC_DIR_PERPENDICULAR  86
#define VSC_HALF_GRAVITY       87

#define VSC_CURRENT_TIME       90

#define VSC_CONSTANTS           0
#define VSC_COSINE              1
#define VSC_SINE                2

#define VSC_RND_VARIANCE       20
#define VSC_RND_NUM_VECTORS    21
#define VSC_RND_START          22
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\Media\satest\morph.h ===
/******************************************************************************

  Copyright (C) 1999, 2000 NVIDIA Corporation
  This file is provided without support, instruction, or implied warranty of any
  kind.  NVIDIA makes no guarantee of its fitness for a particular purpose and is
  not liable under any circumstances for any damages or loss whatsoever arising
  from the use or inability to use this file or items derived from it.
  
    Comments:
    
      
        
******************************************************************************/

#define CV_ZERO 0
#define CV_ONE 1
#define CV_HALF 2

#define CV_WORLDVIEWPROJ_0 3
#define CV_WORLDVIEWPROJ_1 4
#define CV_WORLDVIEWPROJ_2 5
#define CV_WORLDVIEWPROJ_3 6

#define CV_WORLDVIEWIT_0 7
#define CV_WORLDVIEWIT_1 8
#define CV_WORLDVIEWIT_2 9

#define CV_WORLDVIEW_0 10
#define CV_WORLDVIEW_1 11
#define CV_WORLDVIEW_2 12
#define CV_WORLDVIEW_3 13

#define CV_WEIGHT 23

#define CV_LIGHT1_DIRECTION 24
#define CV_LIGHT1_AMBIENT 25

#define CV_FOGDATA 26
#define CV_FOGMAX 27

#define CV_TEXTURESCALE 28
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\Media\satest\lighting.h ===
/******************************************************************************

  Copyright (C) 1999, 2000 NVIDIA Corporation
  This file is provided without support, instruction, or implied warranty of any
  kind.  NVIDIA makes no guarantee of its fitness for a particular purpose and is
  not liable under any circumstances for any damages or loss whatsoever arising
  from the use or inability to use this file or items derived from it.
  
    Comments:
    
      
        
******************************************************************************/

#define CV_ZERO 0
#define CV_ONE 1

#define CV_WORLDVIEWPROJ_0 2
#define CV_WORLDVIEWPROJ_1 3
#define CV_WORLDVIEWPROJ_2 4
#define CV_WORLDVIEWPROJ_3 5

#define CV_WORLDVIEW_0 6
#define CV_WORLDVIEW_1 7
#define CV_WORLDVIEW_2 8
#define CV_WORLDVIEW_3 9

#define CV_WORLDVIEWIT_0 10
#define CV_WORLDVIEWIT_1 11
#define CV_WORLDVIEWIT_2 12

#define CV_LIGHT1_POSITION 13
#define CV_LIGHT2_POSITION 14
#define CV_LIGHT3_POSITION 15
#define CV_LIGHT4_POSITION 16
#define CV_LIGHT5_POSITION 17
#define CV_LIGHT6_POSITION 18
#define CV_LIGHT7_POSITION 19
#define CV_LIGHT8_POSITION 20
#define CV_LIGHT9_POSITION 21
#define CV_LIGHT10_POSITION 22
#define CV_LIGHT11_POSITION 23
#define CV_LIGHT12_POSITION 24
#define CV_LIGHT13_POSITION 25
#define CV_LIGHT14_POSITION 26
#define CV_LIGHT15_POSITION 27
#define CV_LIGHT16_POSITION 28
#define CV_LIGHT17_POSITION 29

#define CV_LIGHT1_DIRECTION 13
#define CV_LIGHT2_DIRECTION 14
#define CV_LIGHT3_DIRECTION 15
#define CV_LIGHT4_DIRECTION 16
#define CV_LIGHT5_DIRECTION 17
#define CV_LIGHT6_DIRECTION 18
#define CV_LIGHT7_DIRECTION 19
#define CV_LIGHT8_DIRECTION 20
#define CV_LIGHT9_DIRECTION 21
#define CV_LIGHT10_DIRECTION 22
#define CV_LIGHT11_DIRECTION 23
#define CV_LIGHT12_DIRECTION 24
#define CV_LIGHT13_DIRECTION 25
#define CV_LIGHT14_DIRECTION 26
#define CV_LIGHT15_DIRECTION 27
#define CV_LIGHT16_DIRECTION 28
#define CV_LIGHT17_DIRECTION 29

#define CV_LIGHT1_DIFFUSE 30
#define CV_LIGHT2_DIFFUSE 31
#define CV_LIGHT3_DIFFUSE 32
#define CV_LIGHT4_DIFFUSE 33
#define CV_LIGHT5_DIFFUSE 34
#define CV_LIGHT6_DIFFUSE 35
#define CV_LIGHT7_DIFFUSE 36
#define CV_LIGHT8_DIFFUSE 37
#define CV_LIGHT9_DIFFUSE 38
#define CV_LIGHT10_DIFFUSE 39
#define CV_LIGHT11_DIFFUSE 40
#define CV_LIGHT12_DIFFUSE 41
#define CV_LIGHT13_DIFFUSE 42
#define CV_LIGHT14_DIFFUSE 43
#define CV_LIGHT15_DIFFUSE 44
#define CV_LIGHT16_DIFFUSE 45
#define CV_LIGHT17_DIFFUSE 46


#define CV_FRONTCOLOR 47
#define CV_BACKCOLOR 48

#define CV_LIGHT1_AMBIENT 49
#define CV_LIGHT2_AMBIENT 50
#define CV_LIGHT3_AMBIENT 51

#define CV_LIGHT1_SPECULAR 52
#define CV_LIGHT2_SPECULAR 53
#define CV_LIGHT3_SPECULAR 54

#define CV_LIGHT1_ATTENUATION 55
#define CV_LIGHT2_ATTENUATION 56
#define CV_LIGHT3_ATTENUATION 57

#define CV_MATPOWER 58
#define CV_EYE_VECTOR 59
#define CV_FIXED_COLOR 60
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\Media\satest\sinewave.h ===
/******************************************************************************

  Copyright (C) 1999, 2000 NVIDIA Corporation
  This file is provided without support, instruction, or implied warranty of any
  kind.  NVIDIA makes no guarantee of its fitness for a particular purpose and is
  not liable under any circumstances for any damages or loss whatsoever arising
  from the use or inability to use this file or items derived from it.
  
    Comments:
    
      
        
******************************************************************************/

#define CV_ZERO 0
#define CV_ONE 1

#define CV_WORLDVIEWPROJ_0 2
#define CV_WORLDVIEWPROJ_1 3
#define CV_WORLDVIEWPROJ_2 4
#define CV_WORLDVIEWPROJ_3 5

#define CV_WORLDVIEWIT_0 6
#define CV_WORLDVIEWIT_1 7
#define CV_WORLDVIEWIT_2 8

#define CV_VECA 10
#define CV_VECD 11
#define CV_VECSIN 12
#define CV_VECCOS 13

#define CV_HALF 14
#define CV_LIGHT1_DIRECTION 15

#define CV_WORLDVIEW_0 16
#define CV_WORLDVIEW_1 17
#define CV_WORLDVIEW_2 18
#define CV_WORLDVIEW_3 19
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\Media\satest\trees.h ===
/******************************************************************************

  Copyright (C) 1999, 2000 NVIDIA Corporation
  This file is provided without support, instruction, or implied warranty of any
  kind.  NVIDIA makes no guarantee of its fitness for a particular purpose and is
  not liable under any circumstances for any damages or loss whatsoever arising
  from the use or inability to use this file or items derived from it.
  
    Comments:
    
      
        
******************************************************************************/

#define CV_ZERO 0
#define CV_ONE 1

#define CV_WORLDVIEWPROJ_0 2
#define CV_WORLDVIEWPROJ_1 3
#define CV_WORLDVIEWPROJ_2 4
#define CV_WORLDVIEWPROJ_3 5

#define CV_WORLDVIEW_0 6
#define CV_WORLDVIEW_1 7
#define CV_WORLDVIEW_2 8
#define CV_WORLDVIEW_3 9

#define CV_WORLDVIEWIT_0 10
#define CV_WORLDVIEWIT_1 11
#define CV_WORLDVIEWIT_2 12

#define CV_PROJ_0 13
#define CV_PROJ_1 14
#define CV_PROJ_2 15
#define CV_PROJ_3 16

#define CV_FISHEYEINFO 17
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\Media\satest\skinning.h ===
/******************************************************************************

  Copyright (C) 1999, 2000 NVIDIA Corporation
  This file is provided without support, instruction, or implied warranty of any
  kind.  NVIDIA makes no guarantee of its fitness for a particular purpose and is
  not liable under any circumstances for any damages or loss whatsoever arising
  from the use or inability to use this file or items derived from it.
  
    Comments:
    
      
        
******************************************************************************/

#define CV_ZERO 0
#define CV_ONE 1

#define CV_WORLDVIEWPROJ_0 2
#define CV_WORLDVIEWPROJ_1 3
#define CV_WORLDVIEWPROJ_2 4
#define CV_WORLDVIEWPROJ_3 5

#define CV_LIGHT_DIRECTION 6

#define CV_MATERIAL_DIFFUSE 7
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\perf\sdkcommon.h ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    SDKCommon.h

Abstract:

    Common header files and macros for the Xbox SDK

Revision History:

--*/

#if !defined(SDK_HEADER_SDKCOMMON_H)
#define SDK_HEADER_SDKCOMMON_H

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef STRICT
#define STRICT 1
#endif
#undef D3D_OVERLOADS

// Windows headers

#ifdef XBOX
#include <xtl.h>
#else
#include "Windows.h"
#include "D3D8.h"
#endif

#if defined(__cplusplus)
extern "C" {
#endif // __cplusplus

#pragma warning (disable:4850)

// __$ReturnUdt is the address of the destination when returning a structure
// It is Microsoft specific so will need to be adjusted to work with other
// compilers. The best way is to declare a local of the correct type and
// then return in.
#define that_ptr __$ReturnUdt

#if defined(__cplusplus)
}
#endif // __cplusplus

#endif //#ifndef SDK_HEADER_RENDERSURFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\memcpy2\memcpy2.h ===
//-----------------------------------------------------------------------------
// FILE: MEMCPY2.H
//
// Desc: MEMCPY2 header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#define PAGE_SIZE 0x1000

#define ARRAYSIZE(_a)     (sizeof(_a) / sizeof((_a)[0]))

//=========================================================================
// Formatted debug squirty
//=========================================================================
inline void _cdecl dprintf(LPCSTR lpFmt, ...)
{
    va_list arglist;
    static char lpOutput[256];

    va_start(arglist, lpFmt);
    _vsnprintf(lpOutput, sizeof(lpOutput), lpFmt, arglist);
    va_end(arglist);

    OutputDebugStringA(lpOutput);
}

//=========================================================================
// Class to help time things
//=========================================================================
class CTimer
{
public:
    // constructor
    CTimer()
    {
        m_fRunning = false;
        QueryPerformanceFrequency((LARGE_INTEGER*)&ticksPerSecond);
        ticksPerSecond /= 1000;
    }

    ~CTimer() {}

    void Start()
    {
        m_fRunning = true;
        QueryPerformanceCounter((LARGE_INTEGER *)&ticksstart);
    }

    void Stop()
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&ticksend);
        m_fRunning = false;
    }

    float getTime()
        {
            if(m_fRunning)
                QueryPerformanceCounter((LARGE_INTEGER *)&ticksend);
            return ((ticksend - ticksstart) * 1.0f / ticksPerSecond);
        }

    bool m_fRunning;
    _int64 ticksstart;
    _int64 ticksend;
    _int64 ticksPerSecond;
};

//=========================================================================
// Helper routine for rdpmc
//=========================================================================
__forceinline ULONGLONG ReadPerformanceCounter(DWORD counter)
{
    _asm mov ecx, (counter)
    _asm rdpmc
}

//=========================================================================
// Stupid PIII counter class
//=========================================================================
class CProfiler
{
public:
    //=========================================================================
    // CProfiler c'tor - enables counters
    //=========================================================================
    CProfiler(DWORD Ctr0, DWORD Ctr1)
    {
        /*
            186H    EVNTSEL0

            7:0     Event Select (Refer to Performance Counter section for a list of event encodings)
            15:8    UMASK:  Unit Mask Register Set to 0 to enable all count options
            16      USER:   Controls the counting of events at Privilege levels of 1, 2, and 3
            17      OS:     Controls the counting of events at Privilege level of 0
            18      E:      Occurrence/Duration Mode Select
                                1 = Occurrence
                                0 = Duration
            19      PC:     Enabled the signaling of performance counter overflow via BP0 pin
            20      INT:    Enables the signaling of counter overflow via input to APIC
                                1 = Enable
                                0 = Disable
            22      ENABLE: Enables the counting of performance events in both counters
                                1 = Enable
                                0 = Disable
            23      INV:    Inverts the result of the CMASK condition
                                1 = Inverted
                                0 = Non-Inverted
            31:24   CMASK:  Counter Mask
        */

        rgCtrs[0] = Ctr0;
        rgCtrs[1] = Ctr1;

        for(int Counter = 0; Counter < 2; Counter++)
        {
            // Select the correct MSR for the specified counter
            DWORD dwMSR = 0x186 + Counter;

            DWORD dwValue = rgCtrs[Counter];

            if(dwValue)
            {
                // Enable counter
                dwValue |=  (1<<22) | (1<<17);

                _asm
                {
                    mov     ecx, dwMSR
                    mov     eax, dwValue
                    mov     edx, 0

                    // WRMSR: Write the value in EDX:EAX to MSR specified by ECX
                    wrmsr
                }
            }
        }
    }

    //=========================================================================
    // CProfiler d'tor - disables counters set in rgCtrs
    //=========================================================================
    ~CProfiler()
    {
        // Select the correct MSR for the specified counter
        for(DWORD Counter = 0; Counter < 2; Counter++)
        {
            DWORD dwMSR = 0x186 + Counter;
            DWORD dwValue = rgCtrs[Counter];

            if(dwValue)
            {
                // Disable counter
                _asm
                {
                    mov     ecx, dwMSR
                    mov     eax, dwValue
                    mov     edx, 0

                    // WRMSR: Write the value in EDX:EAX to MSR specified by ECX
                    wrmsr
                }
            }
        }
    }

    void Start()
    {
        ctrstart0 = ReadPerformanceCounter(0);
        ctrstart1 = ReadPerformanceCounter(1);
    }

    void Stop()
    {
        ctrend0 = ReadPerformanceCounter(0);
        ctrend1 = ReadPerformanceCounter(1);
    }

    __int64 getCtr0()
        { return ctrend0 - ctrstart0; }
    __int64 getCtr1()
        { return ctrend1 - ctrstart1; }

    __int64 ctrstart0, ctrstart1;
    __int64 ctrend0, ctrend1;

    DWORD rgCtrs[2];
};

/*
 * Various PIII counter defines
 */

// data cache unit
#define PERF_DCU_MEMORY_REFERENCES                                  0x00000043
#define PERF_DCU_LINES_ALLOCATED                                    0x00000045
#define PERF_DCU_LINES_MODIFIED                                     0x00000046
#define PERF_DCU_MODFIED_LINES_EVICTED                              0x00000047
#define PERF_DCU_CYCLES_MISS_OUTSTANDING                            0x00000048

// instruction fetch unit
#define PERF_IFU_INSTRUCTION_FETCHES                                0x00000080
#define PERF_IFU_CACHE_MISSES                                       0x00000081
#define PERF_IFU_ITLB_MISSES                                        0x00000085
#define PERF_IFU_CYCLES_DECODER_STALLED                             0x00000086
#define PERF_IFU_CYCLES_DECODER_LENGTH_STALLED                      0x00000087

// L2 cache
#define PERF_L2_INSTRUCTION_FETCH                                   0x00000f28
#define PERF_L2_DATA_LOAD                                           0x00000f29
#define PERF_L2_DATA_STORE                                          0x00000f2a
#define PERF_L2_LINES_ALLOCATED                                     0x00000024
#define PERF_L2_LINES_REMOVED                                       0x00000026
#define PERF_L2_LINES_MODIFIED                                      0x00000025
#define PERF_L2_MODIFIED_LINES_REMOVED                              0x00000027
#define PERF_L2_REQUESTS                                            0x00000f2E
#define PERF_L2_ADDRESS_STROBES                                     0x00000021
#define PERF_L2_DATA_BUS_BUSY                                       0x00000022
#define PERF_L2_DATA_BUS_BUSY_XFER_TO_CPU                           0x00000023

// external bus logic
#define PERF_BUS_CYCLES_CPU_DRDY                                    0x00000062
#define PERF_BUS_CYCLES_LOCKED                                      0x00000063
#define PERF_BUS_REQUESTS_OUTSTANDING                               0x00000060
#define PERF_BUS_BUST_READ                                          0x00000065
#define PERF_BUS_READ_FOR_OWNERSHIP                                 0x00000066
#define PERF_BUS_WRITE_BACK                                         0x00000067
#define PERF_BUS_INSTRUCTION_FETCH                                  0x00000068
#define PERF_BUS_COMPLETED_INVALIDATE_TRANSACTIONS                  0x00000069
#define PERF_BUS_COMPLETED_PARTIAL_WRITES                           0x0000006a
#define PERF_BUS_COMPLETED_PARTIAL_TRANSACTIONS                     0x0000006b
#define PERF_BUS_COMPLETED_IO_TRANSACTIONS                          0x0000006c
#define PERF_BUS_DEFERRED_TRANSACTIONS                              0x0000006d
#define PERF_BUS_COMPLETED_BURSTS                                   0x0000006e
#define PERF_BUS_TOTAL_COMPLETED_TRANSACTIONS                       0x00000070
#define PERF_BUS_COMPLETED_MEMORY_TRANSACTIONS                      0x0000006f
#define PERF_BUS_CYCLES_PROCESSOR_RECEIVING_DATA                    0x00000064
#define PERF_BUS_CYCLES_PROCESSOR_DRIVING_BNR                       0x00000061
#define PERF_BUS_CYCLES_PROCESSOR_DRIVING_HIT                       0x0000007a
#define PERF_BUS_CYCLES_PROCESSOR_DRIVING_HITM                      0x0000007b
#define PERF_BUS_CYCLES_SNOOP_STALLED                               0x0000007e

// floating point unit
#define PERF_FPU_FLOATING_POINT_OPERATIONS                          0x000000c1
#define PERF_FPU_COMPUTATIONAL_OPERATIONS                           0x00000010
#define PERF_FPU_MICROCODE_EXCEPTIONS                               0x00000011
#define PERF_FPU_MULTIPLIES                                         0x00000012
#define PERF_FPU_DIVIDES                                            0x00000013
#define PERF_FPU_CYCLES_DIVIDER_BUSY                                0x00000014

// memory ordering
#define PERF_MO_STORE_BUFFER_BLOCKS                                 0x00000003
#define PERF_MO_STORE_BUFFER_DRAIN_CYCLES                           0x00000004
#define PERF_MO_MISALIGNED_MEMORY_REFERENCE                         0x00000005
#define PERF_MO_KNI_PREFETCH_NTA                                    0x00000007
#define PERF_MO_KNI_PREFETCH_T1                                     0x00000107
#define PERF_MO_KNI_PREFETCH_T2                                     0x00000207
#define PERF_MO_KNI_WEAKLY_ORDERED_STORES                           0x00000307
#define PERF_MO_KNI_PREFETCH_MISS_CACHES_NTA                        0x0000004b
#define PERF_MO_KNI_PREFETCH_MISS_CACHES_T1                         0x0000014b
#define PERF_MO_KNI_PREFETCH_MISS_CACHES_T2                         0x0000024b
#define PERF_MO_KNI_WEAKLY_ORDERED_STORE_MISS_CACHES                0x0000034b

// instruction decoding and retiring
#define PERF_IDR_INSTRUCTIONS_RETIRED                               0x000000c0
#define PERF_IDR_MICRO_OPS_RETIRED                                  0x000000c2
#define PERF_IDR_INSTRUCTIONS_DECODED                               0x000000d0
#define PERF_IDR_KNI_ALL_INSTRUCTIONS_RETIRED                       0x000000d8
#define PERF_IDR_KNI_SCALAR_INSTRUCTIONS_RETIRED                    0x000001d8
#define PERF_IDR_KNI_ALL_COMPUTATIONAL_INSTRUCTIONS_RETIRED         0x000000d9
#define PERF_IDR_KNI_SCALAR_COMPUTATIONAL_INSTRUCTIONS_RETIRED      0x000001d9

// interrupts
#define PERF_INT_RECEIVED                                           0x000000c8
#define PERF_INT_CYCLES_MASKED                                      0x000000c6
#define PERF_INT_CYCLES_MASKED_AND_INT_PENDING                      0x000000c7

// branches
#define PERF_BR_INSTRUCTIONS                                        0x000000c4
#define PERF_BR_MISPREDICTED_RETIRED                                0x000000c5
#define PERF_BR_TAKEN_RETIRED                                       0x000000c9
#define PERF_BR_TAKEN_MISPREDICT_RETIRED                            0x000000ca
#define PERF_BR_DECODED                                             0x000000e0
#define PERF_BR_NO_BTB_PREDICT                                      0x000000e2
#define PERF_BR_BOGUS                                               0x000000e4
#define PERF_BR_STATIC_PREDICTIONS                                  0x000000e6

// stalls
#define PERF_RES_STALLS                                             0x000000a2
#define PERF_RES_PARTIAL_STALL                                      0x000000d2

// segment register loads
#define PERF_SREG_LOADS                                             0x00000006

// clocks
#define PERF_CLOCK_UNHALTED                                         0x00000079

// mmx unit
#define PERF_MMX_SATURATING                                         0x000000b1
#define PERF_MMX_MICRO_OPS_EXECUTED                                 0x000000b2
#define PERF_MMX_PACKED_MULTIPLY_EXECUTED                           0x000001b3
#define PERF_MMX_PACKED_SHIFT_EXECUTED                              0x000002b3
#define PERF_MMX_PACK_OPERATIONS_EXECUTED                           0x000004b3
#define PERF_MMX_UNPACK_OPERATIONS_EXECUTED                         0x000008b3
#define PERF_MMX_PACKED_LOGICAL_OPERATIONS_EXECUTED                 0x000010b3
#define PERF_MMX_PACKED_ARITHMETIC_OPERATIONS_EXECUTED              0x000020b3
#define PERF_MMX_TRANSITION_FROM_MMX_TO_FLOATING                    0x000000cc
#define PERF_MMX_TRANSITION_FROM_FLOATING_TO_MMX                    0x000001cc
#define PERF_MMX_EMMS_EXECUTED                                      0x000000cd

// segment register renaming
#define PERF_SEG_RENAME_STALL_ALL                                   0x00000fd4
#define PERF_SEG_RENAME_STALL_ES                                    0x000001d4
#define PERF_SEG_RENAME_STALL_DS                                    0x000002d4
#define PERF_SEG_RENAME_STALL_FS                                    0x000004d4
#define PERF_SEG_RENAME_STALL_GS                                    0x000008d4
#define PERF_SEG_NUMBER_RENAMES_ALL                                 0x00000fd5
#define PERF_SEG_NUMBER_RENAMES_ES                                  0x000001d5
#define PERF_SEG_NUMBER_RENAMES_DS                                  0x000002d5
#define PERF_SEG_NUMBER_RENAMES_FS                                  0x000004d5
#define PERF_SEG_NUMBER_RENAMES_GS                                  0x000008d5
#define PERF_NUMBER_SEG_RENAMES_RETIRED                             0x000000d6
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\memcpy2\memcpy2.cpp ===
//-----------------------------------------------------------------------------
// FILE: MEMCPY2.CPP
//
// Desc: stupid bandwidth tests
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include <mmintrin.h>

#include "memcpy2.h"

// Size of block we're copying
DWORD g_blocksize = 256 * 1000;

// Chunk size of bytes to move during each loop
const DWORD g_movchunksize = 512;

// Whatever PIII counters you think might help you
#define XTAG(_x) { _x, #_x }
struct
{
    DWORD Ctr;
    const char *CtrName;
} rgCtrs[] =
{
    XTAG(PERF_BUS_COMPLETED_PARTIAL_WRITES),
    XTAG(PERF_DCU_CYCLES_MISS_OUTSTANDING),
};

// Silly macros to help start/end/time each routine

#define START_TIME_BLOCK()                                              \
    int oldprio = GetThreadPriority(GetCurrentThread());                \
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);     \
    Sleep(10);                                                          \
    CProfiler profiler(rgCtrs[0].Ctr, rgCtrs[1].Ctr);                   \
    CTimer timer;                                                       \
    DWORD passes = 1000;                                                \
    profiler.Start();                                                   \
    timer.Start();

#define END_TIME_BLOCK(_x)                                              \
    timer.Stop();                                                       \
    profiler.Stop();                                                    \
    SetThreadPriority(GetCurrentThread(), oldprio);                     \
    SpewResults(#_x, g_blocksize, passes, timer.getTime(), &profiler);

//=========================================================================
// Spew the results of whatever test we just ran
//=========================================================================
void SpewResults(char *test, DWORD blocksize, DWORD passes,
    float time, CProfiler *pprofiler = NULL)
{
    __int64 ctr0 = pprofiler ? pprofiler->getCtr0() : 0;
    __int64 ctr1 = pprofiler ? pprofiler->getCtr1() : 0;

    float time2 = time / 1000;
    dprintf("  %-12s: %7.2f MBytes/sec  %7.2f ms  ctr0:%7I64u ctr1:%7I64u\n",
        test, (blocksize * passes) / (time2 * 1024 * 1024), time, ctr0, ctr1);
}

//=========================================================================
// Standard memcpy test
//=========================================================================
void
memcpyTest(void *pvDst, void *pvSrc)
{
    START_TIME_BLOCK();

    for(DWORD i = 0; i < passes; i++)
    {
        DWORD totbytes = g_blocksize;
        BYTE *Dst = (BYTE *)pvDst;
        BYTE *Src = (BYTE *)pvSrc;

        while(totbytes)
        {
            DWORD size = min(totbytes, g_movchunksize);

            memcpy(Dst, Src, size);
            totbytes -= size;
            Src += size;
            Dst += size;
        }
    }

    END_TIME_BLOCK(memcpy);
}

//=========================================================================
// rep movsd test
//=========================================================================
void
RepMovSdTest(void *pvDst, void *pvSrc)
{
    START_TIME_BLOCK();

    for(DWORD i = 0; i < passes; i++)
    {
        DWORD totbytes = g_blocksize;
        DWORD *pdwDst = (DWORD *)pvDst;
        DWORD *pdwSrc = (DWORD *)pvSrc;

        while(totbytes)
        {
            DWORD numdwords = min(totbytes, g_movchunksize) / sizeof(DWORD);

            _asm
            {
                mov esi, pdwSrc
                mov edi, pdwDst
                mov ecx, numdwords
                rep movsd
            }

            pdwSrc += numdwords;
            pdwDst += numdwords;

            totbytes -= numdwords * sizeof(DWORD);
        }
    }

    END_TIME_BLOCK(repmovsd);
}

//=========================================================================
// movupsmemcpy
//=========================================================================
void
movupsmemcpy(void *pvDst, void *pvSrc)
{
    START_TIME_BLOCK();

    for(DWORD i = 0; i < passes; i++)
    {
        DWORD totbytes = g_blocksize;
        BYTE *pdwDst = (BYTE *)pvDst;
        BYTE *pdwSrc = (BYTE *)pvSrc;

        while(totbytes)
        {
            DWORD numbytes = min(totbytes, g_movchunksize);

            _asm
            {
                // loop through 4 times copying quadwords
                mov ecx, numbytes
                shr ecx, 6
                mov edi, pdwDst
                mov esi, pdwSrc

                align 16

            loop1:
                prefetchnta [esi+64]
                prefetchnta [esi+96]

                movups xmm0, [esi]
                movups xmm1, [esi+16]
                movups xmm2, [esi+32]
                movups xmm3, [esi+48]

                movntps [edi], xmm0
                movntps [edi+16], xmm1
                movntps [edi+32], xmm2
                movntps [edi+48], xmm3

                // move to the next quadword
                add edi, 64
                add esi, 64

                dec ecx
                jnz loop1;
            }

            pdwDst += numbytes;
            pdwSrc += numbytes;

            totbytes -= numbytes;
        }
    }

    END_TIME_BLOCK(movupsmemcpy);
}


//=========================================================================
// movapsmemcpy
//=========================================================================
void
movapsmemcpy(void *pvDst, void *pvSrc)
{
    START_TIME_BLOCK();

    for(DWORD i = 0; i < passes; i++)
    {
        DWORD totbytes = g_blocksize;
        BYTE *pdwDst = (BYTE *)pvDst;
        BYTE *pdwSrc = (BYTE *)pvSrc;

        while(totbytes)
        {
            DWORD numbytes = min(totbytes, g_movchunksize);

            _asm
            {
                // loop through 4 times copying quadwords
                mov ecx, numbytes
                shr ecx, 6
                mov edi, pdwDst
                mov esi, pdwSrc

                align 16

            loop1:
                prefetchnta [esi+64]
                prefetchnta [esi+96]

                movaps xmm0, [esi]
                movaps xmm1, [esi+16]
                movaps xmm2, [esi+32]
                movaps xmm3, [esi+48]

                movntps [edi], xmm0
                movntps [edi+16], xmm1
                movntps [edi+32], xmm2
                movntps [edi+48], xmm3

                // move to the next quadword
                add edi, 64
                add esi, 64

                dec ecx
                jnz loop1;
            }

            pdwDst += numbytes;
            pdwSrc += numbytes;

            totbytes -= numbytes;
        }
    }

    END_TIME_BLOCK(movapsmemcpy);
}

//=========================================================================
// movqmemcpy
//=========================================================================
void
movqmemcpy(void *pvDst, void *pvSrc)
{
    START_TIME_BLOCK();

    for(DWORD i = 0; i < passes; i++)
    {
        DWORD totbytes = g_blocksize;
        BYTE *pdwDst = (BYTE *)pvDst;
        BYTE *pdwSrc = (BYTE *)pvSrc;

        while(totbytes)
        {
            DWORD numbytes = min(totbytes, g_movchunksize);

            _asm
            {
                // loop through 4 times copying quadwords
                mov ecx, numbytes
                shr ecx, 6
                mov edi, pdwDst
                mov esi, pdwSrc

                align 16

            loop1:
                prefetchnta [esi+64]
                prefetchnta [esi+96]

                movq mm0, [esi+0]
                movq mm1, [esi+8]
                movq mm2, [esi+16]
                movq mm3, [esi+24]
                movq mm4, [esi+32]
                movq mm5, [esi+40]
                movq mm6, [esi+48]
                movq mm7, [esi+56]

                movntq [edi+0], mm0
                movntq [edi+8], mm1
                movntq [edi+16], mm2
                movntq [edi+24], mm3
                movntq [edi+32], mm4
                movntq [edi+40], mm5
                movntq [edi+48], mm6
                movntq [edi+56], mm7

                // move to the next quadword
                add edi, 64
                add esi, 64

                nop
                nop
                nop

                dec ecx
                jnz loop1;
            }

            pdwDst += numbytes;
            pdwSrc += numbytes;

            totbytes -= numbytes;
        }
    }

    _asm emms

    END_TIME_BLOCK(movqmemcpy);
}

//=========================================================================
// movqmemcpy
//=========================================================================
void
movqmemcpynoprefetch(void *pvDst, void *pvSrc)
{
    START_TIME_BLOCK();

    for(DWORD i = 0; i < passes; i++)
    {
        DWORD totbytes = g_blocksize;
        BYTE *pdwDst = (BYTE *)pvDst;
        BYTE *pdwSrc = (BYTE *)pvSrc;

        while(totbytes)
        {
            DWORD numbytes = min(totbytes, g_movchunksize);

            _asm
            {
                // loop through 4 times copying quadwords
                mov ecx, numbytes
                shr ecx, 6
                mov edi, pdwDst
                mov esi, pdwSrc

                align 16

            loop1:
                movq mm0, [esi+0]
                movq mm1, [esi+8]
                movq mm2, [esi+16]
                movq mm3, [esi+24]
                movq mm4, [esi+32]
                movq mm5, [esi+40]
                movq mm6, [esi+48]
                movq mm7, [esi+56]

                movntq [edi+0], mm0
                movntq [edi+8], mm1
                movntq [edi+16], mm2
                movntq [edi+24], mm3
                movntq [edi+32], mm4
                movntq [edi+40], mm5
                movntq [edi+48], mm6
                movntq [edi+56], mm7

                // move to the next quadword
                add edi, 64
                add esi, 64

                dec ecx
                jnz loop1;
            }

            pdwDst += numbytes;
            pdwSrc += numbytes;

            totbytes -= numbytes;
        }
    }

    _asm emms

    END_TIME_BLOCK(movqnopref)
}

//=========================================================================
// Get the cpu speed.
//=========================================================================
float GetCpuSpeed(void)
{
    __int64 start, end, freq;
    int     clocks;

    int oldprio = GetThreadPriority(GetCurrentThread());

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
    Sleep(10);

    QueryPerformanceFrequency((LARGE_INTEGER*)&freq);
    QueryPerformanceCounter((LARGE_INTEGER*)&start);

    _asm
    {
        rdtsc
        mov     ecx, 900000
x:      dec     ecx
        jnz     x
        mov     ebx,eax
        rdtsc
        sub     eax,ebx
        mov     dword ptr clocks[0],eax
    }

    QueryPerformanceCounter((LARGE_INTEGER*)&end);

    SetThreadPriority(GetCurrentThread(), oldprio);

    float time = (float)MulDiv((int)(end - start), 1000000, (int)freq);

    return clocks / time;
}


//=========================================================================
// Big move loop
//=========================================================================
void MovqCopy(void *pvDst, void *pvSrc)
{
    START_TIME_BLOCK();

    __asm
    {
        mov ebx, passes

test_loop:
        mov esi,[pvSrc]
        mov edi,[pvDst]

        ;add esi,4

        mov eax,g_blocksize
        shr eax,6

        ALIGN 16

copy_loop:
        prefetchnta [esi+64]
        prefetchnta [esi+96]

        movq mm0,[esi]
        movq mm1,[esi+8]
        movq mm2,[esi+16]
        movq mm3,[esi+24]

        movq mm4,[esi+32]
        movq mm5,[esi+40]
        movq mm6,[esi+48]
        movq mm7,[esi+56]

        movntq [edi],mm0
        movntq [edi+8],mm1
        movntq [edi+16],mm2
        movntq [edi+24],mm3

        movntq [edi+32],mm4
        movntq [edi+40],mm5
        movntq [edi+48],mm6
        movntq [edi+56],mm7

        add esi,64
        add edi,64

        dec eax
        jnz copy_loop

        dec ebx
        jnz test_loop

        emms
    }

    END_TIME_BLOCK(movqcopy);
}

//=========================================================================
//
//=========================================================================
void SpewMemoryFlags(DWORD dwFlags)
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        DWORD flag;
        const char *szDescr;
    } rgsz[] =
    {
        XTAG(PAGE_NOACCESS),            XTAG(PAGE_READONLY),
        XTAG(PAGE_READWRITE),           XTAG(PAGE_WRITECOPY),
        XTAG(PAGE_EXECUTE),             XTAG(PAGE_EXECUTE_READ),
        XTAG(PAGE_EXECUTE_READWRITE),   XTAG(PAGE_EXECUTE_WRITECOPY),
        XTAG(PAGE_GUARD),               XTAG(PAGE_NOCACHE),
        XTAG(PAGE_WRITECOMBINE),
    };
    static const int cFmts = sizeof(rgsz) / sizeof(rgsz[0]);

    for(int ifmt = 0; ifmt < cFmts; ifmt++)
    {
        if(rgsz[ifmt].flag & dwFlags)
            dprintf(" %s", rgsz[ifmt].szDescr);
    }
}

//=========================================================================
//
//=========================================================================
#define GETFIELD(value, upper, lower) \
    ((value >> lower) & ((2L << (upper-lower))-1))

//=========================================================================
// Dump our memory dest and src values
//=========================================================================
void SpewMemLocs(void *pvDst, void *pvSrc)
{
    DWORD dwAlign = (DWORD)pvSrc & 0x1f;

    static const char *rgHdrs[] =
        { "Source", "Dest" };
    void *rgMems[] = { pvSrc, pvDst };

    dprintf("\n");
    for(int i = 0; i < 2; i++)
    {
        DWORD dwAddr = (DWORD)rgMems[i];

        dprintf("%-14s: 0x%08lx (+%2d)  bank:%d  (",
            rgHdrs[i], dwAddr,  dwAddr & 0x1f, GETFIELD(dwAddr, 13, 12));

        SpewMemoryFlags(XQueryMemoryProtect(rgMems[i]));

        dprintf(" )\n");
    }
}

//=========================================================================
// main
//=========================================================================
void __cdecl main()
{
    // Calc cpu speed

    float cpuspeed = GetCpuSpeed();

    dprintf("\ncpuspeed: %f\n\n", cpuspeed);

    for(int ctr = 0; ctr < 2; ctr++)
    {
        dprintf("ctr%d: %s\n", ctr, rgCtrs[ctr].CtrName);
    }


    // Alloc memory

    Sleep(1000);

    byte *pvCachedMem = (byte *)XPhysicalAlloc(g_blocksize * 2,
        MAXULONG_PTR, PAGE_SIZE, PAGE_READWRITE);

    byte *pvWCMem = (byte *)XPhysicalAlloc(g_blocksize * 2,
        MAXULONG_PTR, PAGE_SIZE, PAGE_READWRITE | PAGE_WRITECOMBINE);

#ifdef NEVER
    // The following tests a routine which doesn't use the chunk
    // copy mechanism - it just blasts the entire block over.
    // Currently #ifdef'd NEVER as the times are virtually identical
    // to the below routines and I got sick of the extra noise.

    void *pvCachedMem2 = (byte *)malloc(g_blocksize * 2);

    // large block tests - first with XPhysicalAlloc block

    SpewMemLocs(pvWCMem, pvCachedMem);

    for(int i = 0; i < 4; i++)
        MovqCopy(pvWCMem, pvCachedMem);

    // second with malloc'd block

    SpewMemLocs(pvWCMem, pvCachedMem2);

    for(int i = 0; i < 4; i++)
        MovqCopy(pvWCMem, pvCachedMem2);
#endif

    // run standard memcpy vs. movq tests
    for(int align_dst = 0; align_dst <= 16; align_dst += 16)
    {
        for(int align_src = 1; align_src < 32; align_src <<= 1)
        {
            void *pvSrc = pvCachedMem + ((align_src == 1) ? 0 : align_src);
            void *pvDst = pvWCMem + align_dst;

            SpewMemLocs(pvDst, pvSrc);

            memcpyTest(pvDst, pvSrc);

            movqmemcpy(pvDst, pvSrc);

            movqmemcpynoprefetch(pvDst, pvSrc);

            // dest must be 16 byte aligned for movntps
            if(!((DWORD)pvDst & 0xf))
            {
                movupsmemcpy(pvDst, pvSrc);

                // src must be 16 byte aligned for movaps
                if(!((DWORD)pvSrc & 0xf))
                    movapsmemcpy(pvDst, pvSrc);
            }
        }
    }

    dprintf("\n\nWaiting forever now.\n");
    for(;;) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\mems\mems.h ===
//-----------------------------------------------------------------------------
// FILE: MEMS.H
//
// Desc: mems header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#define PAGE_SIZE 0x1000

#define ARRAYSIZE(_a)     (sizeof(_a) / sizeof((_a)[0]))

//=========================================================================
// Class to help time things
//=========================================================================
class CTimer
{
public:
    // constructor
    CTimer()
    {
        QueryPerformanceFrequency((LARGE_INTEGER*)&ticksPerSecond);
        ticksPerSecond /= 1000;
    }

    ~CTimer() {};

    void Start()
        { QueryPerformanceCounter((LARGE_INTEGER *)&ticksstart); }

    void Stop()
        { QueryPerformanceCounter((LARGE_INTEGER *)&ticksend); }

    float getTime()
        {
            QueryPerformanceCounter((LARGE_INTEGER *)&ticksend);
            return ((ticksend - ticksstart) * 1.0f / ticksPerSecond);
        }

    _int64 ticksstart;
    _int64 ticksend;
    _int64 ticksPerSecond;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\perf\main.cpp ===
/*--Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Complete DX8 application to draw a screen space triangle.

Revision History:

    Derived from a DX8 sample.
--*/

extern "C"
{
    #include <ntos.h>
    #include <nturtl.h>
    #include <ani.h>
};

#include <SDKCommon.h>
#include <xgraphics.h>
#include <xmetal.h>

D3DDevice *pDevice;

extern DWORD PushBufferSize;
extern DWORD Repeat;

void Setup();
void Draw();
void Verify();

typedef enum
{
    SUBCH_UNUSED0            = 0,
    SUBCH_UNUSED1            = 1,
    SUBCH_UNUSED2            = 2,
    SUBCH_UNUSED3            = 3,
    SUBCH_UNUSED4            = 4,
    SUBCH_SW                 = 5,   // NVX_SOFTWARE_CLASS_HANDLE
    SUBCH_3D                 = 6,   // D3D_KELVIN_PRIMITIVE (0x097)
    SUBCH_MEMCOPY            = 7,   // D3D_MEMORY_TO_MEMORY_COPY (0x039)

} SubChannel;

#define PUSHER_METHOD(subch, method, count) \
            (((count) << 18) + ((subch) << 13) + (method))

extern "C" { extern volatile DWORD *D3D__GpuGet; }
extern "C" { extern volatile DWORD *D3D__GpuPut; }
extern "C" { extern volatile DWORD *D3D__GpuReg; }
extern "C" { extern volatile DWORD *D3D__GpuTime; }
extern "C" { extern DWORD *D3D__PushBase; }
extern "C" { extern DWORD *D3D__PushLimit; }
extern "C" { extern ULONGLONG D3D__TestTime; }

__forceinline ULONGLONG GetTime()
{
    _asm rdtsc
}


VOID FlushWCCache()
{
    DWORD* pPut = g_pPushBuffer->m_pPut;
    DWORD* pPushBase = D3D__PushBase;
    DWORD* pPushMiddle = D3D__PushBase + (D3D__PushLimit - D3D__PushBase) / 2;
    DWORD* pPushLimit = D3D__PushLimit;

    // The following is to combat a problem we're seeing where the write-
    // combine cache doesn't seem to get properly flushed using an 'sfence'.
    // An easy way to repro is to run Quake, and do a KickOffAndWaitForEmpty()
    // after every DrawPrimitive.

    _asm 
    {
        mov esi, pPut
        mov edi, pPushLimit
        add edi, 1020
        mov eax, [esi]
        xchg eax, [edi]

        xor eax, eax
        mov esi, pPushBase
        or [esi], eax
        mov esi, pPushMiddle
        or [esi], eax
    }

    // Flush the write-combine cache:

    _asm sfence
}

void __cdecl main()
{
    // Set the screen mode.
    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount           = 1;
    d3dpp.EnableAutoDepthStencil    = true;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz= 60;
//    d3dpp.MultiSampleType           = D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX;

    Direct3D_SetPushBufferSize(PushBufferSize, PushBufferSize / 16);

    // Create the device.
    Direct3D_CreateDevice(D3DADAPTER_DEFAULT,
                          D3DDEVTYPE_HAL,
                          NULL,
                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                          &d3dpp,
                          &pDevice);

    DbgPrint("Generating the commands to test.\n");

    /* 
     * Do setup...stuff we dont' want to time.
     */

    Setup();

    /*
     * Do some cheating to remember what is getting pushed.
     */

    D3DDevice_BlockUntilIdle();

    DWORD *pStartPush = g_pPushBuffer->m_pPut;

    // Hork the threshold so we won't kick off.  If you go beyond
    // then this whole thing will fall apart.
    //
    g_pPushBuffer->m_pThreshold = D3D__PushLimit;

    /*
     * Draw the commands to time.
     */

    Draw();

    /*
     * Snapshot what was drawn
     */

    DWORD *pEndPush = g_pPushBuffer->m_pPut;

    DWORD Size = (pEndPush - pStartPush) * 4;
    void *pCode = malloc(Size);

    memcpy(pCode, pStartPush, Size);

    /*
     * Do any verification (i.e Present) needed to see if this worked.
     */
    
    Verify();

    D3DDevice_BlockUntilIdle();

    /*
     * Prepare to run the test.
     */

    #define HwOffset(x)    ((DWORD)(x) & 0x0FFFFFFF)
    
    volatile DWORD *GpuGet  = D3D__GpuGet;
    volatile DWORD *GpuPut  = D3D__GpuPut;
    volatile DWORD *GpuReg  = D3D__GpuReg;
    volatile DWORD *GpuTime = D3D__GpuTime;

    DWORD *pPushBase = D3D__PushBase;
    DWORD *pPushLimit = D3D__PushLimit;

    DWORD *pPut = g_pPushBuffer->m_pPut;

    //
    // Reset the push buffer back to zero.
    //

    // Set reference.
    *(pPut++) = PUSHER_METHOD(SUBCH_3D, 0x00000050, 1);
    *(pPut++) = 0;

    // Jump to start of pb.
    *(pPut++) = (0x00000001 + HwOffset(pPushBase));

    FlushWCCache();

    // Run it.
    *GpuPut = HwOffset(pPushBase);

    // Wait until it finishes.
    while (*GpuGet != HwOffset(pPushBase))
    {
        Sleep(100);
    }

    while (GpuReg[0x00400700 / 4])
    {
        Sleep(100);
    }

    //
    // Figure out how many times we can run the commands.
    // 

    DbgPrint("Filling the push buffer.\n");

    DWORD ActualPushBufferSize = (pPushLimit - pPushBase - 5) * 4;
    DWORD Count = ActualPushBufferSize / Size;

    if (Count == 0)
    {
        _asm int 3;
    }

    BYTE *pDest = (BYTE *)pPushBase;

    for (DWORD i = 0; i < Count; i++)
    {
        memcpy(pDest, pCode, Size);

        pDest+= Size;
    }

    pPut = (DWORD *)pDest;

    //
    // Do the run.
    //

    DbgPrint("Executing the test.\n");

    // Write a funky value to the semaphore to indicate the end of the run.

    *(pPut++) = PUSHER_METHOD(SUBCH_3D, 0x00001d70, 1);
    *(pPut++) = 0x80088008;

    // Add a jump back to zero at the end of the buffer so we can rerun this test.
    *pPut = (0x00000001 + HwOffset(pPushBase));

    FlushWCCache();

    DWORD FinalPut = HwOffset(pPut);
    ULONGLONG TotalTime = 0;

    for (DWORD i = 0; i < Repeat; i++)
    {
        *GpuTime = 0;

        // 
        // Run the test.
        //

        ULONGLONG Begin, End;

        Begin = GetTime();

        *GpuPut = FinalPut;

        while (*GpuTime != 0x80088008)
            ;

        End = GetTime();

        ULONGLONG Time = End - Begin;
        TotalTime += Time;

        if (Count == 0)
        {
            DbgPrint("%I64u cycles.\n", Time);
        }
        else
        {
            DbgPrint("Time = %d cycles/iteration (%I64u cycles for %d iterations).\n", (DWORD)(Time / (ULONGLONG)Count), Time, Count);
        }

        //
        // Reset back to zero.
        //

        *GpuPut = HwOffset(pPushBase);

        // Wait until it finishes.
        while (*GpuGet != HwOffset(pPushBase))
        {
            Sleep(100);
        }

        while (GpuReg[0x00400700 / 4])
        {
            Sleep(100);
        }
    }

    if (Count == 0)
    {
        DbgPrint("\nAverage Time - %I64u cycles.\n", TotalTime / (ULONGLONG)Repeat);
    }
    else
    {
        DbgPrint("\nAverages: %d cycles/iteration, %I64u cycles.\n", (DWORD)(TotalTime / (ULONGLONG)Count / (ULONGLONG)Repeat), TotalTime / (ULONGLONG)Repeat);
    }

    _asm int 3;

    HalReturnToFirmware(HalQuickRebootRoutine);    
}


/***
 *** The tests. Uncomment something to go.
 **/

/*
 * Fill the buffer with NOPs.
 */

#if 0

// Variation, use KELVIN nops insteads.
#define USE_KELVIN_NOPS 0

DWORD PushBufferSize = (16 * 1024 * 1024);
DWORD Repeat = 10;

void Setup()
{
}

void Draw()
{
    DWORD *pPush = XMETAL_StartPush(g_pPushBuffer);

#if USE_KELVIN_NOPS

    *(pPush + 0) = PUSHER_METHOD(SUBCH_3D, 0x00000100, 1);
    *(pPush + 1) = 0;

    XMETAL_PushedRaw(pPush + 2);
    XMETAL_EndPush(g_pPushBuffer, pPush + 2);

#else 

    *(pPush + 0) = 0;

    XMETAL_PushedRaw(pPush + 1);
    XMETAL_EndPush(g_pPushBuffer, pPush + 1);

#endif
}

void Verify()
{
}

#endif

/*
 * Draw 4 triangles, each of which covers half of the screen.  The triangles
 * are textured from a very large linear 32-bit texture.
 */

#if 0

// Variation, push a 'wait for idle' after each set of 4 triangles.
#define ADD_WAIT_FOR_IDLE 0

DWORD PushBufferSize = (4 * 1024 * 1024);
DWORD Repeat = 5;

DWORD dwFVF = D3DFVF_XYZRHW|D3DFVF_TEX1;

//------------------------------------------------------------------------------
// Define our screen space triangle.

static struct TheVerts { float x,y,z,w,tu,tv; } Verts[] =
{
    {   0.0f,    0.0f, 0.5f, 1.0f,   0.0f,   0.0f},
    { 640.0f,    0.0f, 0.5f, 1.0f, 255.0f,   0.0f},
    {   0.0f,  480.0f, 0.5f, 1.0f,   0.0f, 127.0f},
    {   0.0f,  480.0f, 0.5f, 1.0f,   0.0f, 127.0f},
    { 640.0f,    0.0f, 0.5f, 1.0f, 255.0f,   0.0f},
    { 640.0f,  480.0f, 0.5f, 1.0f, 255.0f, 127.0f},

    {   0.0f,    0.0f, 0.5f, 1.0f,   0.0f, 128.0f},
    { 640.0f,    0.0f, 0.5f, 1.0f, 255.0f, 128.0f},
    {   0.0f,  480.0f, 0.5f, 1.0f,   0.0f, 255.0f},
    {   0.0f,  480.0f, 0.5f, 1.0f,   0.0f, 255.0f},
    { 640.0f,    0.0f, 0.5f, 1.0f, 255.0f, 128.0f},
    { 640.0f,  480.0f, 0.5f, 1.0f, 255.0f, 255.0f},
    };

void Setup()
{
    // Create the texture.
    D3DTexture *pTexture;
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;

    D3DDevice_CreateTexture(256, 256, 1, 0, D3DFMT_LIN_X8R8G8B8, D3DPOOL_MANAGED, &pTexture);

    pTexture->GetLevelDesc(0, &desc);
    pTexture->LockRect(0, &lockRect, NULL, D3DLOCK_RAWDATA);

    // Make the texture half white, half blue.
    DWORD *pb = (DWORD *)lockRect.pBits;
    DWORD y;
    
    for (y = 0; y < 256; y++)
    {
        for (DWORD x = 0; x < 256; x++)
        {
            if (y >= 128)
            {
                *pb = 0xFFFFFFFF;
            }
            else
            {
                *pb = 0xFF0000FF;
            }

            pb++;
        }
    }

    // Create a vertex buffer.
    D3DVertexBuffer *pVB;
    void *pVerts;

    D3DDevice_CreateVertexBuffer(sizeof(Verts), 0, 0, 0, &pVB);

    pVB->Lock(0, sizeof(Verts), (BYTE **)(&pVerts), 0);
    memcpy((void *)pVerts, (void *)Verts, sizeof(Verts));
    pVB->Unlock();

    // Set the states to ready for the render.
    D3DDevice_SetTexture(0, pTexture);
    D3DDevice_SetStreamSource(0, pVB, sizeof(Verts[0]));
    D3DDevice_SetVertexShader(dwFVF);

    D3DDevice_SetTextureStageState(0, D3DTSS_COLORARG1,D3DTA_TEXTURE);
    D3DDevice_SetTextureStageState(0, D3DTSS_COLOROP,  D3DTOP_MODULATE);
    D3DDevice_SetTextureStageState(0, D3DTSS_COLORARG2,D3DTA_DIFFUSE);
    D3DDevice_SetTextureStageState(0, D3DTSS_ALPHAARG1,D3DTA_TEXTURE);
    D3DDevice_SetTextureStageState(0, D3DTSS_ALPHAOP,  D3DTOP_MODULATE);
    D3DDevice_SetTextureStageState(0, D3DTSS_ALPHAARG2,D3DTA_DIFFUSE);
    D3DDevice_SetTextureStageState(0, D3DTSS_MINFILTER,D3DTEXF_LINEAR);
    D3DDevice_SetTextureStageState(0, D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
    D3DDevice_SetTextureStageState(0, D3DTSS_ADDRESSU ,D3DTADDRESS_CLAMP);
    D3DDevice_SetTextureStageState(0, D3DTSS_ADDRESSV ,D3DTADDRESS_CLAMP);

    D3DDevice_Clear(0, NULL, D3DCLEAR_TARGET, 0, 1.0, 0);
}

void Draw()
{
    D3DDevice_DrawVertices(D3DPT_TRIANGLELIST, 0, 12); 

#if ADD_WAIT_FOR_IDLE

    DWORD *pPush = XMETAL_StartPush(g_pPushBuffer);

    *(pPush + 0) = PUSHER_METHOD(SUBCH_3D, 0x00000110, 1);
    *(pPush + 1) = 0;

    XMETAL_PushedRaw(pPush + 2);
    XMETAL_EndPush(g_pPushBuffer, pPush + 2);

#endif
}

void Verify()
{
    D3DDevice_Present(NULL, NULL, NULL, NULL);
}

#endif 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\pshader\sdkcommon.h ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    SDKCommon.h

Abstract:

    Common header files and macros for the Xbox SDK

Revision History:

--*/

#if !defined(SDK_HEADER_SDKCOMMON_H)
#define SDK_HEADER_SDKCOMMON_H

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef STRICT
#define STRICT 1
#endif
#undef D3D_OVERLOADS

// Windows headers

#ifdef XBOX
#include <xtl.h>
#else
#include "Windows.h"
#include "D3D8.h"
#endif

#if defined(__cplusplus)
extern "C" {
#endif // __cplusplus

#pragma warning (disable:4850)

// __$ReturnUdt is the address of the destination when returning a structure
// It is Microsoft specific so will need to be adjusted to work with other
// compilers. The best way is to declare a local of the correct type and
// then return in.
#define that_ptr __$ReturnUdt

#if defined(__cplusplus)
}
#endif // __cplusplus

#endif //#ifndef SDK_HEADER_RENDERSURFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\mems\mems.cpp ===
//-----------------------------------------------------------------------------
// FILE: FILLRATE.CPP
//
// Desc: a stupid fillrate test
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include <mmintrin.h>

#include "mems.h"

void *g_pvCachedMem;
void *g_pvWCMem;

//=========================================================================
// Formatted debug squirty
//=========================================================================
void _cdecl dprintf(LPCSTR lpFmt, ...)
{
    va_list arglist;
    char lpOutput[256];

    va_start(arglist, lpFmt);
    _vsnprintf(lpOutput, sizeof(lpOutput), lpFmt, arglist);
    va_end(arglist);

    OutputDebugStringA(lpOutput);
}

//=========================================================================
// Get the cpu speed.
//=========================================================================
float GetCpuSpeed(void)
{
    __int64 start, end, freq;
    int     clocks;

    int oldprio = GetThreadPriority(GetCurrentThread());

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
    Sleep(10);

    QueryPerformanceFrequency((LARGE_INTEGER*)&freq);
    QueryPerformanceCounter((LARGE_INTEGER*)&start);

    _asm
    {
        rdtsc
        mov     ecx, 900000
x:      dec     ecx
        jnz     x
        mov     ebx,eax
        rdtsc
        sub     eax,ebx
        mov     dword ptr clocks[0],eax
    }

    QueryPerformanceCounter((LARGE_INTEGER*)&end);
    SetThreadPriority(GetCurrentThread(), oldprio);

    float time = (float)MulDiv((int)(end - start), 1000000, (int)freq);

    return clocks / time;
}

void SpewResults(DWORD chunksize, DWORD passes, float time)
{
    dprintf("  %.2f MBytes/sec \t %ld KBytes * %ld / %.2f ms\n",
        chunksize * passes / (time * 1000 / 1024),
        chunksize, passes, time);
}

void
MovntqTest(void *pvDst)
{
    dprintf("movntq\n");

    CTimer timer;
    DWORD passes = 0;

    timer.Start();

    for(int i = 0; i < 10000; i++)
    {
        DWORD totbytes = 100 * 1024;

        while(totbytes)
        {
            _asm
            {
                mov ecx, 64
                mov edi, pvDst

            loop1:
                movntq [edi], mm0
                add edi, 8
                dec ecx
                jnz loop1;
            }

            totbytes -= 512;
        }

        passes++;

    }

    timer.Stop();

    _asm emms;

    SpewResults(100, passes, timer.getTime());
}

void
RepStoSdTest(void *pvDst)
{
    dprintf("rep stosd\n");

    CTimer timer;
    DWORD passes = 0;

    timer.Start();

    for(int i = 0; i < 10000; i++)
    {
        DWORD totbytes = 100 * 1024;

        while(totbytes)
        {
            _asm
            {
                mov edi, pvDst
                mov ecx, 128
                rep stosd
            }

            totbytes -= 512;
        }

        passes++;

    }

    timer.Stop();

    SpewResults(100, passes, timer.getTime());
}

void
memcpyTest(void *pvDst, void *pvSrc, DWORD chunksize)
{
    dprintf("memcpy chunksize: %d\n", chunksize);

    DWORD rgSizes[] = { 1, 100, 1000 };

    for(int iSize = 0; iSize < ARRAYSIZE(rgSizes); iSize++)
    {
        CTimer timer;
        DWORD passes = 0;

        timer.Start();

        for(int i = 0; i < 10000; i++)
        {
            DWORD totbytes = rgSizes[iSize] * 1024;
            BYTE *Dst = (BYTE *)pvDst;
            BYTE *Src = (BYTE *)pvSrc;

            while(totbytes)
            {
                DWORD size = min(totbytes, chunksize);

                memcpy(Dst, Src, size);
                totbytes -= size;
                Src += size;
                Dst += size;
            }

            passes++;
        }

        timer.Stop();

        SpewResults(rgSizes[iSize], passes, timer.getTime());

        // Break if current iteration was more than 5 seconds.
        if (timer.getTime() > 5000)
            break;
    }
}

void
RepMovSdTest(void *pvDst, void *pvSrc, DWORD chunksize)
{
    dprintf("rep movsd chunksize: %d\n", chunksize);

    DWORD rgSizes[] = { 1, 100, 1000 };

    for(int iSize = 0; iSize < ARRAYSIZE(rgSizes); iSize++)
    {
        CTimer timer;
        DWORD passes = 0;

        timer.Start();

        for(int i = 0; i < 10000; i++)
        {
            DWORD totbytes = rgSizes[iSize] * 1024;
            DWORD *pdwDst = (DWORD *)pvDst;
            DWORD *pdwSrc = (DWORD *)pvSrc;

            while(totbytes)
            {
                DWORD numdwords = min(totbytes, chunksize) / sizeof(DWORD);

                _asm
                {
                    mov esi, pdwSrc
                    mov edi, pdwDst
                    mov ecx, numdwords
                    rep movsd
                }

                pdwSrc += numdwords;
                pdwDst += numdwords;

                totbytes -= numdwords * sizeof(DWORD);
            }

            passes++;
        }

        timer.Stop();

        SpewResults(rgSizes[iSize], passes, timer.getTime());

        // Break if current iteration was more than 5 seconds.
        if (timer.getTime() > 5000)
            break;
    }

}

void
memcpy2(void *pvDst, void *pvSrc, DWORD chunksize)
{
    dprintf("memcpy2 chunksize: %d\n", chunksize);

    DWORD rgSizes[] = { 1, 100, 1000 };

    for(int iSize = 0; iSize < ARRAYSIZE(rgSizes); iSize++)
    {
        CTimer timer;
        DWORD passes = 0;

        timer.Start();

        for(int i = 0; i < 10000; i++)
        {
            DWORD totbytes = rgSizes[iSize] * 1024;
            BYTE *pdwDst = (BYTE *)pvDst;
            BYTE *pdwSrc = (BYTE *)pvSrc;

            while(totbytes)
            {
                // we're doing 256 byte blocks
                DWORD numblocks = min(totbytes, chunksize) / 256;

                for(DWORD j = 0; j < numblocks; j++)
                {
                    _asm
                    {
                        // loop through 4 times copying quadwords
                        mov ecx, 4
                        mov edi, pvDst
                        mov esi, pvSrc

                    loop1:
                        movq mm0, [esi+ 00]
                        movq mm1, [esi+ 32]
                        movq mm2, [esi+ 64]
                        movq mm3, [esi+ 96]
                        movq mm4, [esi+128]
                        movq mm5, [esi+160]
                        movq mm6, [esi+192]
                        movq mm7, [esi+224]

                        movq [edi+ 00], mm0
                        movq [edi+ 32], mm1
                        movq [edi+ 64], mm2
                        movq [edi+ 96], mm3
                        movq [edi+128], mm4
                        movq [edi+160], mm5
                        movq [edi+192], mm6
                        movq [edi+224], mm7

                        // move to the next quadword
                        add edi, 8
                        add esi, 8

                        dec ecx
                        jnz loop1;
                    }

                    pdwDst += 256;
                    pdwSrc += 256;
                }

                totbytes -= numblocks * 256;
            }

            passes++;
        }

        timer.Stop();

        _asm emms;

        SpewResults(rgSizes[iSize], passes, timer.getTime());

        // Break if current iteration was more than 5 seconds.
        if (timer.getTime() > 5000)
            break;
    }

}

//=========================================================================
// main
//=========================================================================
void __cdecl main()
{
    float cpuspeed = GetCpuSpeed();

    dprintf("\ncpuspeed: %f\n\n", cpuspeed);

    for(int times = 0; times < 1; times++)
    {
        Sleep(1000);

        g_pvCachedMem = malloc(1000 * 1024);

        g_pvWCMem = XPhysicalAlloc(1000 * 1024, MAXULONG_PTR, PAGE_SIZE,
                                   PAGE_READWRITE | PAGE_WRITECOMBINE);

        for(int type = 0; type < 3; type++)
        {
            void* pvWCMem;

            switch (type)
            {
                case 0:
                    pvWCMem = g_pvWCMem;
                    dprintf("--> Physical address range 0 - 64 MB:\n");
                    break;

                case 1:
                    pvWCMem = (void*) ((DWORD) g_pvWCMem | 0xA0000000);
                    dprintf("--> 1 GB Alias:\n");
                    break;

                case 2:
                    pvWCMem = (void*) ((DWORD) g_pvWCMem | 0xf0000000);
                    dprintf("--> Memory buffer aperture:\n");
                    break;

            }

            dprintf("pvWCMem: %lx\n", pvWCMem);

            memcpyTest(pvWCMem, g_pvCachedMem, 512);

            memcpyTest(pvWCMem, g_pvCachedMem, 0xffffffff);

            RepMovSdTest(pvWCMem, g_pvCachedMem, 512);

            dprintf("read from wc ");
            RepMovSdTest(g_pvCachedMem, pvWCMem, 0xffffffff);

            dprintf("read from wc ");
            memcpy2(g_pvCachedMem, pvWCMem, 0xffffffff);

            RepStoSdTest(pvWCMem);

            MovntqTest(pvWCMem);

            dprintf("\n");
        }

        XPhysicalFree(g_pvWCMem);
        free(g_pvCachedMem);
    }

    dprintf("Waiting forever now.\n");
    for(;;) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\over\main.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	main.cpp

Abstract:

	Overlay and Closed Captioning test

Author:

	Jason Gould (jgould) 2001

Environment:

	Xbox only

Revision History:

	2001		jgould
		Initial Version
	14-Nov-2001 robheit
		Cleaned up the code and made functional

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include <stdlib.h>

//------------------------------------------------------------------------------
//	Externs:
//------------------------------------------------------------------------------
extern "C" unsigned long HalReadSMBusValue(UCHAR, UCHAR, BOOLEAN, ULONG*);
extern "C" unsigned long HalWriteSMBusValue(UCHAR, UCHAR, BOOLEAN, ULONG);
extern "C" void DebugPrint(const char*, ...);

extern "C"
{
void    WINAPI D3DDevice_EnableCC(BOOL Enable);
void    WINAPI D3DDevice_SendCC(BOOL Field, BYTE cc1, BYTE cc2);
void    WINAPI D3DDevice_GetCCStatus(BOOL *pField1, BOOL *pField2);
};

//------------------------------------------------------------------------------
//	Cosed Captioning Codes:
//------------------------------------------------------------------------------

// Control Codes
#define	CC_RCL	0x14, 0x20	/* Resume caption loading */
#define	CC_BS	0x14, 0x21	/* Backspace */
#define	CC_AOF	0x14, 0x22	/* Reserved (formerly Alarm Off) */
#define	CC_AON	0x14, 0x23	/* Reserved (formerly Alarm On)  */
#define	CC_DER	0x14, 0x24	/* Delete to End of Row */
#define	CC_RU2	0x14, 0x25	/* Roll-Up Captions-2 Rows */
#define	CC_RU3	0x14, 0x26	/* Roll-Up Captions-3 Rows */
#define	CC_RU4	0x14, 0x27	/* Roll-Up Captions-4 Rows */
#define	CC_FON	0x14, 0x28	/* Flash On */
#define	CC_RDC	0x14, 0x29	/* Resume Direct Captioning */
#define	CC_TR	0x14, 0x2a	/* Text Restart */
#define	CC_RTD	0x14, 0x2b	/* Resume Text Display */
#define	CC_EDM	0x14, 0x2c	/* Erase Displayed Memory */
#define	CC_CR	0x14, 0x2d	/* Carriage Return */
#define	CC_ENM	0x14, 0x2e	/* Erase Non-Displayed Memory */
#define	CC_EOC	0x14, 0x2f	/* End fo Caption (Flip Memories) */
#define	CC_TO1	0x17, 0x21	/* Tab Offset 1 Column */
#define	CC_TO2	0x17, 0x22	/* Tab Offset 2 Columns */
#define	CC_TO3	0x17, 0x23	/* Tab Offset 3 Columns */

// Mid-Row Codes
#define CC_WHITE				0x11, 0x20	/* White */
#define CC_WHITE_UNDERLINE		0x11, 0x21	/* White Underline */
#define CC_GREEN				0x11, 0x22	/* Green */
#define CC_GREEN_UNDERLINE		0x11, 0x23	/* Green Underline */
#define CC_BLUE					0x11, 0x24	/* Blue */
#define CC_BLUE_UNDERLINE		0x11, 0x25	/* Blue Underline */
#define CC_CYAN					0x11, 0x26	/* Cyan */
#define CC_CYAN_UNDERLINE		0x11, 0x27	/* Cyan Underline */
#define CC_RED					0x11, 0x28	/* Red */
#define CC_RED_UNDERLINE		0x11, 0x29	/* Red Underline */
#define CC_YELLOW				0x11, 0x2a	/* Yellow */
#define CC_YELLOW_UNDERLINE		0x11, 0x2b	/* Yellow Underline */
#define CC_MAGENTA				0x11, 0x2c	/* Magenta */
#define CC_MAGENTA_UNDERLINE	0x11, 0x2d	/* Magenta Underline */
#define CC_ITALICS				0x11, 0x2e	/* Italics */
#define CC_ITALICS_UNDERLINE	0x11, 0x2f	/* Italics Underline */

// Special Characters
#define CC_REGISTERED			0x11, 0x30	/* Registered mark symbol */
#define CC_DEGREE				0x11, 0x31	/* Degree sign */
#define CC_HALF					0x11, 0x32	/* 1/2 */
#define CC_IQ					0x11, 0x33	/* Inverse Query */
#define CC_TRADEMARK			0x11, 0x34	/* Trademark symbol */
#define CC_CENTS				0x11, 0x35	/* Cents sign */
#define CC_POUNDS_STERLING		0x11, 0x36	/* Pounds Sterling sign */
#define CC_NOTE					0x11, 0x37	/* Musical note */
#define CC_a_GRAVE				0x11, 0x38	/* Lowercase a with grave accent */
#define CC_TRANSPARENT_SPACE	0x11, 0x39	/* Transparent space */
#define CC_e_GRAVE				0x11, 0x3a	/* Lowercase e with grave accent */
#define CC_a_CIRCUMFLEX			0x11, 0x3b	/* Lowercase a with circumflex */
#define CC_e_CIRCUMFLEX			0x11, 0x3c	/* Lowercase e with circumflex */
#define CC_i_CIRCUMFLEX			0x11, 0x3d	/* Lowercase i with circumflex */
#define CC_o_CIRCUMFLEX			0x11, 0x3e	/* Lowercase o with circumflex */
#define CC_u_CIRCUMFLEX			0x11, 0x3f	/* Lowercase u with circumflex */

// Standard Characters
#define CC_SPACE				0x20	/* Standard Space */
#define CC_EXCLAMATION			0x21	/* ! */
#define CC_QUOTE				0x22	/* " */
#define CC_POUND				0x23	/* # */
#define CC_DOLLAR				0x24	/* $ */
#define CC_PERCENT				0x25	/* % */
#define CC_AMPERSAND			0x26	/* & */
#define CC_APOSTROPHE			0x27	/* ' */
#define CC_OPEN_PARENTHESES		0x28	/* ( */
#define CC_CLOSE_PARENTHESES	0x29	/* ) */
#define CC_a_ACCENT				0x2a	/* Lowercase a with acute accent */
#define CC_PLUS					0x2b	/* + */
#define CC_COMMA				0x2c	/* , */
#define CC_MINUS				0x2d	/* - */
#define CC_PERIOD				0x2e	/* . */
#define CC_SLASH				0x2f	/* / */
#define CC_0					0x30	/* 0 */
#define CC_1					0x31	/* 1 */
#define CC_2					0x32	/* 2 */
#define CC_3					0x33	/* 3 */
#define CC_4					0x34	/* 4 */
#define CC_5					0x35	/* 5 */
#define CC_6					0x36	/* 6 */
#define CC_7					0x37	/* 7 */
#define CC_8					0x38	/* 8 */
#define CC_9					0x39	/* 9 */
#define CC_COLON				0x3a	/* : */
#define CC_SEMICOLON			0x3b	/* ; */
#define CC_LESS_THAN			0x3c	/* < */
#define CC_EQUAL				0x3d	/* = */
#define CC_GREATER_THAN			0x3e	/* > */
#define CC_QUESTION				0x3f	/* ? */
#define CC_AT					0x40	/* @ */
#define CC_A					0x41	/* A */
#define CC_B					0x42	/* B */
#define CC_C					0x43	/* C */
#define CC_D					0x44	/* D */
#define CC_E					0x45	/* E */
#define CC_F					0x46	/* F */
#define CC_G					0x47	/* G */
#define CC_H					0x48	/* H */
#define CC_I					0x49	/* I */
#define CC_J					0x4a	/* J */
#define CC_K					0x4b	/* K */
#define CC_L					0x4c	/* L */
#define CC_M					0x4d	/* M */
#define CC_N					0x4e	/* N */
#define CC_O					0x4f	/* O */
#define CC_P					0x50	/* P */
#define CC_Q					0x51	/* Q */
#define CC_R					0x52	/* R */
#define CC_S					0x53	/* S */
#define CC_T					0x54	/* T */
#define CC_U					0x55	/* U */
#define CC_V					0x56	/* V */
#define CC_W					0x57	/* W */
#define CC_X					0x58	/* X */
#define CC_Y					0x59	/* Y */
#define CC_Z					0x5a	/* Z */
#define CC_OPEN_BRACKET			0x5b	/* [ */
#define CC_e_ACCENT				0x5c	/* Lowercase e with acute accent */
#define CC_CLOSE_BRACKET		0x5d	/* ] */
#define CC_i_ACCENT				0x5e	/* Lowercase i with acute accent */
#define CC_o_ACCENT				0x5f	/* Lowercase o with acute accent */
#define CC_u_ACCENT				0x60	/* Lowercase u with acute accent */
#define CC_a					0x61	/* a */
#define CC_b					0x62	/* b */
#define CC_c					0x63	/* c */
#define CC_d					0x64	/* d */
#define CC_e					0x65	/* e */
#define CC_f					0x66	/* f */
#define CC_g					0x67	/* g */
#define CC_h					0x68	/* h */
#define CC_i					0x69	/* i */
#define CC_j					0x6a	/* j */
#define CC_k					0x6b	/* k */
#define CC_l					0x6c	/* l */
#define CC_m					0x6d	/* m */
#define CC_n					0x6e	/* n */
#define CC_o					0x6f	/* o */
#define CC_p					0x70	/* p */
#define CC_q					0x71	/* q */
#define CC_r					0x72	/* r */
#define CC_s					0x73	/* s */
#define CC_t					0x74	/* t */
#define CC_u					0x75	/* u */
#define CC_v					0x76	/* v */
#define CC_w					0x77	/* w */
#define CC_x					0x78	/* x */
#define CC_y					0x79	/* y */
#define CC_z					0x7a	/* z */
#define CC_c_CEDILLA			0x7b	/* Lowercase c with cedilla */
#define CC_DIVIDE				0x7c	/* Division sign */
#define CC_N_TILDE				0x7d	/* Uppercase N with tilde */
#define CC_n_TILDE				0x7e	/* Uppercase N with tilde */
#define CC_BLOCK				0x7f	/* Solid block */

//------------------------------------------------------------------------------
//	Closed Captioning Row Styles
//------------------------------------------------------------------------------
enum CCStyle
{
	CCSTYLE_WHITE,
	CCSTYLE_WHITE_UNDERLINE,
	CCSTYLE_GREEN,
	CCSTYLE_GREEN_UNDERLINE,
	CCSTYLE_BLUE,
	CCSTYLE_BLUE_UNDERLINE,
	CCSTYLE_CYAN,
	CCSTYLE_CYAN_UNDERLINE,
	CCSTYLE_RED,
	CCSTYLE_RED_UNDERLINE,
	CCSTYLE_YELLOW,
	CCSTYLE_YELLOW_UNDERLINE,
	CCSTYLE_MAGENTA,
	CCSTYLE_MAGENTA_UNDERLINE,
	CCSTYLE_WHITE_ITALICS,
	CCSTYLE_WHITE_ITALICS_UNDERLINE,
	CCSTYLE_INDENT0,
	CCSTYLE_INDENT0_UNDERLINE,
	CCSTYLE_INDENT4,
	CCSTYLE_INDENT4_UNDERLINE,
	CCSTYLE_INDENT8,
	CCSTYLE_INDENT8_UNDERLINE,
	CCSTYLE_INDENT12,
	CCSTYLE_INDENT12_UNDERLINE,
	CCSTYLE_INDENT16,
	CCSTYLE_INDENT16_UNDERLINE,
	CCSTYLE_INDENT20,
	CCSTYLE_INDENT20_UNDERLINE,
	CCSTYLE_INDENT24,
	CCSTYLE_INDENT24_UNDERLINE,
	CCSTYLE_INDENT28,
	CCSTYLE_INDENT28_UNDERLINE,
	NUM_CCSTYLE
};

//------------------------------------------------------------------------------
//	Macros:
//------------------------------------------------------------------------------
#define RAND_INT(x)			((rand() * (x)) / RAND_MAX)
#define RANDOM_VELOCITY()	(RAND_INT(2) + 1)
#define GetBValue(rgb)		((BYTE)((rgb) & 0xff))
#define GetGValue(rgb)		((BYTE)(((rgb) >> 8) & 0xff))
#define GetRValue(rgb)		((BYTE)(((rgb) >> 16) & 0xff))

//------------------------------------------------------------------------------
//	Structures and typedefs
//------------------------------------------------------------------------------
struct CLOSEDCAPTION 
{
	BOOL field;
	BYTE cc0;
	BYTE cc1;
};

struct TheVerts 
{ 
	float	x;
	float	y;
	float	z;
	float	w; 
	DWORD	color; 
	float	u;
	float	v; 
};

//------------------------------------------------------------------------------
//	Static Global Variables:
//------------------------------------------------------------------------------
CLOSEDCAPTION g_CC[] =
{
	1, CC_A, CC_B,
	1, CC_C, CC_D,
	1, CC_E, CC_F,
	1, CC_G, CC_H,
	1, CC_I, CC_J,
	1, CC_K, CC_L,
	1, CC_M, CC_N,
	1, CC_O, CC_P,
	1, CC_Q, CC_R,
	1, CC_S, CC_T,
	1, CC_U, CC_V,
	1, CC_W, CC_X,
	1, CC_Y, CC_Z,
	1, CC_CR,
	1, CC_a, CC_b,
	1, CC_c, CC_d,
	1, CC_e, CC_f,
	1, CC_g, CC_h,
	1, CC_i, CC_j,
	1, CC_k, CC_l,
	1, CC_m, CC_n,
	1, CC_o, CC_p,
	1, CC_q, CC_r,
	1, CC_s, CC_t,
	1, CC_u, CC_v,
	1, CC_w, CC_x,
	1, CC_y, CC_z,
	1, CC_CR,
	1, CC_0, CC_1,
	1, CC_2, CC_3,
	1, CC_4, CC_5,
	1, CC_6, CC_7,
	1, CC_8, CC_9,
	1, CC_CR,
	1, CC_EXCLAMATION, CC_QUOTE, 
	1, CC_POUND, CC_DOLLAR, 
	1, CC_PERCENT, CC_AMPERSAND, 
	1, CC_APOSTROPHE, CC_OPEN_PARENTHESES, 
	1, CC_CLOSE_PARENTHESES, CC_PLUS, 
	1, CC_COMMA, CC_MINUS, 
	1, CC_PERIOD, CC_SLASH, 
	1, CC_COLON, CC_SEMICOLON, 
	1, CC_LESS_THAN, CC_EQUAL, 
	1, CC_GREATER_THAN, CC_QUESTION, 
	1, CC_AT, CC_OPEN_BRACKET, 
	1, CC_CLOSE_BRACKET, CC_DIVIDE, 
	1, CC_CR,
	1, CC_REGISTERED, 
	1, CC_DEGREE,
	1, CC_HALF, 
	1, CC_IQ,
	1, CC_TRADEMARK, 
	1, CC_CENTS,
	1, CC_POUNDS_STERLING, 
	1, CC_NOTE,
	1, CC_a_GRAVE, 
	1, CC_TRANSPARENT_SPACE,
	1, CC_e_GRAVE, 
	1, CC_a_CIRCUMFLEX,
	1, CC_e_CIRCUMFLEX, 
	1, CC_i_CIRCUMFLEX,
	1, CC_o_CIRCUMFLEX, 
	1, CC_u_CIRCUMFLEX,
	1, CC_e_ACCENT, CC_i_ACCENT,
	1, CC_o_ACCENT, CC_u_ACCENT,
	1, CC_c_CEDILLA, CC_N_TILDE,
	1, CC_n_TILDE, CC_BLOCK
};
int					g_sx2;
int					g_sy1;
int					g_sy2;
int					g_dx1;
int					g_dx2;
int					g_dy1;
int					g_dy2;
int					g_swidth;
int					g_sheight;
int					g_sx1	= -5;
int					g_dsx1	= -2;
int					g_dsx2	= 5;
int					g_dsy1	= -3;
int					g_dsy2	= 2;
int					g_ddx1	= -4;
int					g_ddx2	= 1;
int					g_ddy1	= -3;
int					g_ddy2	= 4;
IDirect3DDevice8*	g_pDev	= NULL;
D3DTexture*			g_pTex0	= NULL;
D3DTexture*			g_pTex1	= NULL;
D3DTexture*			g_pTex2	= NULL;
D3DTexture*			g_pTex3	= NULL;
DWORD				g_dwFVF	= D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1;
int					g_delay = 1;	// Number of milliseconds to delay
									// between calls to GetCCStatus.
									// Setting this to 0 will eliminate the delay.

TheVerts	g_originalVerts[] =
{
	{113.0f,   0.0f, 0.5f, 1.0f, 0xffff0000, 0.0f, 0.0f},
	{527.0f, 360.0f, 0.5f, 1.0f, 0xff0000ff, 1.0f, 1.0f},
	{113.0f, 360.0f, 0.5f, 1.0f, 0xff0000ff, 0.0f, 1.0f},
	{527.0f,   0.0f, 0.5f, 1.0f, 0xffff0000, 1.0f, 0.0f},
	{527.0f, 360.0f, 0.5f, 1.0f, 0xff0000ff, 1.0f, 1.0f},
	{113.0f,   0.0f, 0.5f, 1.0f, 0xffff0000, 0.0f, 0.0f},
};
TheVerts	g_verts[6];

//------------------------------------------------------------------------------
//	WriteSMC
//------------------------------------------------------------------------------
DWORD 
WriteSMC(
		 unsigned char addr, 
		 unsigned char value
		 )
{
	return HalWriteSMBusValue(0x20, addr, FALSE, value);
}

//------------------------------------------------------------------------------
//	ReadSMC
//------------------------------------------------------------------------------
DWORD 
ReadSMC(
		unsigned char addr
		)
{
	DWORD value = 0xCCCCCCCC;
	DWORD status = HalReadSMBusValue(0x21, addr, FALSE, &value);
	return value;
}

//------------------------------------------------------------------------------
//	Setp
//------------------------------------------------------------------------------
BYTE 
Setp(
	 BYTE b
	 ) 
/*++

Routine Description:

	set the parity bit...

Arguments:

	IN b -	Byte to set parity bit on

Return Value:

	Adjusted byte

--*/
{
	_asm 
	{
		xor eax, eax
		mov al, [b]
		test al, al
		jnp dontsetpb
		or al, 0x80
		dontsetpb:
	}
}

//------------------------------------------------------------------------------
//	SetCol
//------------------------------------------------------------------------------
void 
SetCol(
	   BYTE		col, 
	   BYTE*	a, 
	   BYTE*	b
	   ) 
/*++

Routine Description:

	My gueses on how this works have been unsuccessful...
	sending 0x94, 0x76 seems to set the column to about 12,
	and 0x94,74 seems to set it to about 8
	but it seems to also change the row. This may just be my TV though.

Arguments:

	None

Return Value:

	None

--*/
{
	*a = 0x14;
	if(col & 1) 
		*b = (col >> 2) | 0x50;
	else 
		*b = (col >> 2) | 0x70;
}

//------------------------------------------------------------------------------
//	Bounce
//------------------------------------------------------------------------------
void 
Bounce(
	   int	f, 
	   int*	a, 
	   int*	b, 
	   int	l, 
	   int*	pa, 
	   int*	pb
	   ) 
/*++

Routine Description:

	bounces one or two numbers off of eachother, and the min (f) and max (l).
	f is inclusive, l is exclusive, a and b are inclusive
	if b is not specified, a will bounce on the interval [f, l)
	spd is used to increment a and b.
	pa and pb are the current speeds of a and b (should be (+/- spd))

Arguments:

	None

Return Value:

	None

--*/
{
	if(!pa || !a) 
		_asm {int 3};
	if(pb && !b) 
		_asm {int 3};

	if(*a < f + abs(*pa))
		*pa =  abs(*pa);
	if(pb)
	{
		if(*a > *b - abs(*pa) - abs(*pb))
		{ 
			*pa = -abs(*pa); 
			*pb = abs(*pb); 
		}
	}
	if(pb)
	{
		if(*b >= l - abs(*pb))
			*pb = -abs(*pb);
	}
	if(!pb)
	{
		if(*a >= l - abs(*pa))
			*pa = -abs(*pa);
	}

	*a += *pa;
	if(pb)
		*b += *pb;
}

//------------------------------------------------------------------------------
//	SendCC
//------------------------------------------------------------------------------
void
SendCC(
	   IN BOOL	bField,
	   IN BYTE	cc1,
	   IN BYTE	cc2
	   )
/*++

Routine Description:

	Send the CC data

Arguments:

	IN bField -	Field: TRUE = field1, FALSE = field2

Return Value:

	None

--*/
{
	BOOL	bF1;
	BOOL	bF2;

	do
	{
		Sleep(g_delay);
		D3DDevice_GetCCStatus(&bF1, &bF2);
	}
	while((!bField && !bF2) || (bField && !bF1));
	D3DDevice_SendCC(bField, Setp(cc1), Setp(cc2));
}

//------------------------------------------------------------------------------
//	SetRow
//------------------------------------------------------------------------------
void 
SetRow(
	   IN BOOL		bField,
	   IN BYTE		channel,
	   IN BYTE		row, 
	   IN CCStyle	style
	   )
/*++

Routine Description:

	Sets a row style by making a SendCC call

Arguments:

	IN bField -		Field: TRUE == field1, FALSE == field2
	IN channel -	1 or 2
	IN row -		[1, 15]
	IN style -		Style. See CCStyle above

Return Value:

	None

--*/
{
	BYTE	a;
	BYTE	b;

	switch(row) 
	{
	case  1: 
		a = 0x11; 
		b = 0x40 + style; 
		break;
	case  2: 
		a = 0x11; 
		b = 0x60 + style; 
		break;
	case  3: 
		a = 0x12; 
		b = 0x40 + style; 
		break;
	case  4: 
		a = 0x12; 
		b = 0x60 + style; 
		break;
	case  5: 
		a = 0x15; 
		b = 0x40 + style; 
		break;
	case  6: 
		a = 0x15; 
		b = 0x60 + style; 
		break;
	case  7: 
		a = 0x16; 
		b = 0x40 + style; 
		break;
	case  8: 
		a = 0x16; 
		b = 0x60 + style; 
		break;
	case  9: 
		a = 0x17; 
		b = 0x40 + style; 
		break;
	case 10: 
		a = 0x17; 
		b = 0x60 + style; 
		break;
	case 11: 
		a = 0x10; 
		b = 0x40 + style; 
		break;
	case 12: 
		a = 0x13; 
		b = 0x40 + style; 
		break;
	case 13: 
		a = 0x13; 
		b = 0x60 + style; 
		break;
	case 14: 
		a = 0x14; 
		b = 0x40 + style; 
		break;
	case 15: 
		a = 0x14; 
		b = 0x60 + style; 
		break;
	}

	if(channel == 2) 
		a |= 8;

	SendCC(bField, a, b);
}

//------------------------------------------------------------------------------
//	AsciiToCC
//------------------------------------------------------------------------------
BYTE
AsciiToCC(
		  IN char	c
		  )
/*++

Routine Description:

	Converts an ascii character to a CC byte code. This method will only
	return a single byte code. SendCC needs two per call.

Arguments:

	IN c -	Character to convert

Return Value:

	CC byte code

--*/
{
	switch(c)
	{
	case ' ':
		return CC_SPACE;
	case '!':
		return CC_EXCLAMATION;
	case '"':
		return CC_QUOTE;
	case '#':
		return CC_POUND;
	case '$':
		return CC_DOLLAR;
	case '%':
		return CC_PERCENT;
	case '&':
		return CC_AMPERSAND;
	case '\'':
		return CC_APOSTROPHE;
	case '(':
		return CC_OPEN_PARENTHESES;
	case ')':
		return CC_CLOSE_PARENTHESES;
	case '+':
		return CC_PLUS;
	case ',':
		return CC_COMMA;
	case '-':
		return CC_MINUS;
	case '.':
		return CC_PERIOD;
	case '/':
		return CC_SLASH;
	case '0':
		return CC_0;
	case '1':
		return CC_1;
	case '2':
		return CC_2;
	case '3':
		return CC_3;
	case '4':
		return CC_4;
	case '5':
		return CC_5;
	case '6':
		return CC_6;
	case '7':
		return CC_7;
	case '8':
		return CC_8;
	case '9':
		return CC_9;
	case ':':
		return CC_COLON;
	case ';':
		return CC_SEMICOLON;
	case '<':
		return CC_LESS_THAN;
	case '=':
		return CC_EQUAL;
	case '>':
		return CC_GREATER_THAN;
	case '?':
		return CC_QUESTION;
	case '@':
		return CC_AT;
	case 'A':
		return CC_A;
	case 'B':
		return CC_B;
	case 'C':
		return CC_C;
	case 'D':
		return CC_D;
	case 'E':
		return CC_E;
	case 'F':
		return CC_F;
	case 'G':
		return CC_G;
	case 'H':
		return CC_H;
	case 'I':
		return CC_I;
	case 'J':
		return CC_J;
	case 'K':
		return CC_K;
	case 'L':
		return CC_L;
	case 'M':
		return CC_M;
	case 'N':
		return CC_N;
	case 'O':
		return CC_O;
	case 'P':
		return CC_P;
	case 'Q':
		return CC_Q;
	case 'R':
		return CC_R;
	case 'S':
		return CC_S;
	case 'T':
		return CC_T;
	case 'U':
		return CC_U;
	case 'V':
		return CC_V;
	case 'W':
		return CC_W;
	case 'X':
		return CC_X;
	case 'Y':
		return CC_Y;
	case 'Z':
		return CC_Z;
	case '[':
		return CC_OPEN_BRACKET;
	case ']':
		return CC_CLOSE_BRACKET;
	case 'a':
		return CC_a;
	case 'b':
		return CC_b;
	case 'c':
		return CC_c;
	case 'd':
		return CC_d;
	case 'e':
		return CC_e;
	case 'f':
		return CC_f;
	case 'g':
		return CC_g;
	case 'h':
		return CC_h;
	case 'i':
		return CC_i;
	case 'j':
		return CC_j;
	case 'k':
		return CC_k;
	case 'l':
		return CC_l;
	case 'm':
		return CC_m;
	case 'n':
		return CC_n;
	case 'o':
		return CC_o;
	case 'p':
		return CC_p;
	case 'q':
		return CC_q;
	case 'r':
		return CC_r;
	case 's':
		return CC_s;
	case 't':
		return CC_t;
	case 'u':
		return CC_u;
	case 'v':
		return CC_v;
	case 'w':
		return CC_w;
	case 'x':
		return CC_x;
	case 'y':
		return CC_y;
	case 'z':
		return CC_z;
	}
	return CC_BLOCK;
}

//------------------------------------------------------------------------------
//	InitD3D
//------------------------------------------------------------------------------
void 
InitD3D(void)
/*++

Routine Description:

	Initialize D3D

Arguments:

	None

Return Value:

	None

--*/
{
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);

    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory(&d3dpp, sizeof(d3dpp));
    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_A8R8G8B8;
    d3dpp.BackBufferCount           = 1;
    d3dpp.Windowed                  = false;
    d3dpp.EnableAutoDepthStencil    = true;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow             = NULL;

    pD3D->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL,
					   D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDev);
    pD3D->Release();
}

//------------------------------------------------------------------------------
//	InitVB
//------------------------------------------------------------------------------
void 
InitVB(void)
/*++

Routine Description:

	Setup the vertices for the texture

Arguments:

	None

Return Value:

	None

--*/
{
	for(int i=0; i<6; ++i)
	{
		g_verts[i].x		= g_originalVerts[i].x;
		g_verts[i].y		= g_originalVerts[i].y;
		g_verts[i].z		= g_originalVerts[i].z;
		g_verts[i].w		= g_originalVerts[i].w;
		g_verts[i].color	= g_originalVerts[i].color;
		g_verts[i].u		= g_originalVerts[i].u;
		g_verts[i].v		= g_originalVerts[i].v;
	}
    g_pDev->SetVertexShader(g_dwFVF);
}

//------------------------------------------------------------------------------
//	Paint
//------------------------------------------------------------------------------
void 
Paint(void)
/*++

Routine Description:

	Draw the scene

Arguments:

	None

Return Value:

	None

--*/
{
    static DWORD	Time = GetTickCount();
    DWORD			CurrentTime = GetTickCount();
    float			spin;
    DWORD			i;
	float			x;
	float			y;

	// 10 seconds per rotation
	spin = 2 * 3.14159f * (float)(CurrentTime - Time) / 10000.0f;

    for(i=0; i<6; ++i)
    {
        x = g_originalVerts[i].x - 320.0f;
        y = g_originalVerts[i].y - 240.0f;

        g_verts[i].x = x * (float)cos(spin) - y * (float)sin(spin);
        g_verts[i].y = x * (float)sin(spin) + y * (float)cos(spin);

        g_verts[i].x += 320.0f;
        g_verts[i].y += 240.0f;
    }

	g_pDev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | 
				  D3DCLEAR_STENCIL, 0x00000000, 1.0, 0);

    g_pDev->SetTextureStageState(0, D3DTSS_ADDRESSU,	D3DTADDRESS_CLAMP);
    g_pDev->SetTextureStageState(0, D3DTSS_ADDRESSV,	D3DTADDRESS_CLAMP);
    g_pDev->SetTextureStageState(0, D3DTSS_COLOROP,		D3DTOP_SELECTARG1);
    g_pDev->SetTextureStageState(0, D3DTSS_COLORARG1,	D3DTA_TEXTURE);
    g_pDev->SetTextureStageState(0, D3DTSS_MINFILTER,	D3DTEXF_LINEAR);
    g_pDev->SetTextureStageState(0, D3DTSS_MAGFILTER,	D3DTEXF_LINEAR);
    g_pDev->SetTexture(0, g_pTex0);

    g_pDev->BeginScene();
	g_pDev->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 2, g_verts, sizeof(TheVerts));
    g_pDev->EndScene();

    g_pDev->Present(NULL, NULL, NULL, NULL);
}

//------------------------------------------------------------------------------
//	ConvertToYUV
//------------------------------------------------------------------------------
void 
ConvertToYUV(
			 IN LPDIRECT3DSURFACE8	pFromSurface, 
			 OUT LPDIRECT3DSURFACE8	pToSurface
			 )
/*++

Routine Description:

	Converts a surface from an ARGB to a YUV surface.
	The dimensions of both surfaces must be the same.

Arguments:

	IN pFromSurface -	Source surface
	OUT pToSurface -	Destination surface

Return Value:

	None

--*/
{
    D3DSURFACE_DESC	descFrom;
    D3DSURFACE_DESC	descTo;
    D3DLOCKED_RECT	lockFrom;
    D3DLOCKED_RECT	lockTo;
    PVOID			pBitsFrom;
    PVOID			pBitsCopy;
    PBYTE			pTo;
    BYTE			R;
    BYTE			G;
    BYTE			B;
    BYTE			Y0;
    BYTE			Y1;
    BYTE			U;
    BYTE			V;
    DWORD*			pFrom;
    DWORD			y;
	DWORD			x;

    pFromSurface->GetDesc(&descFrom);

    pBitsFrom = LocalAlloc(0, descFrom.Width * descFrom.Height * 4);
    pBitsCopy = LocalAlloc(0, descFrom.Width * descFrom.Height * 4);

    pFromSurface->LockRect(&lockFrom, 0, D3DLOCK_READONLY);
    memcpy(pBitsCopy, lockFrom.pBits, descFrom.Width * descFrom.Height * 4);
    pFromSurface->UnlockRect();

    XGUnswizzleRect(pBitsCopy, descFrom.Width, descFrom.Height,
                    NULL, pBitsFrom, 0, NULL, 4);
    LocalFree(pBitsCopy);

    pToSurface->GetDesc(&descTo);
    pToSurface->LockRect(&lockTo, NULL, 0);

	pTo		= (PBYTE)lockTo.pBits;
    pFrom	= (DWORD*)pBitsFrom;
    for(y=0; y<descTo.Height; ++y)
    {
        for(x=0; x<descFrom.Width; x+=2)
        {
            R	= GetRValue(*pFrom);
            G	= GetGValue(*pFrom);
            B	= GetBValue(*pFrom);
            Y0	= (BYTE)(0.29*R + 0.59*G + 0.14*B);
            U	= (BYTE)(128.0 - 0.14*R - 0.29*G + 0.43*B);
            ++pFrom;

            R	= GetRValue(*pFrom);
            G	= GetGValue(*pFrom);
            B	= GetBValue(*pFrom);
            Y1	= (BYTE)(0.29*R + 0.57*G + 0.14*B);
            V	= (BYTE)(128.0 + 0.36*R - 0.29*G - 0.07*B);
			++pFrom;

            *(pTo++)	= Y0;
            *(pTo++)	= U;
            *(pTo++)	= Y1;
            *(pTo++)	= V;
        }
    }

	LocalFree(pBitsFrom);
    pToSurface->UnlockRect();
}

//------------------------------------------------------------------------------
//	LoadImage
//------------------------------------------------------------------------------
D3DTexture*
LoadImage(
		  IN char*	psz,
		  IN BOOL	convert
		  )
/*++

Routine Description:

	Loads a texture from a file into a surface

Arguments:

	IN psz -		Filename
	IN convert -	TRUE to convert to YUV, FALSE otherwise

Return Value:

	D3DTexture* -	The texture

--*/
{
    D3DTexture*			pTex;
    IDirect3DSurface8*	pSurT;
	IDirect3DSurface8*	pSur;

	if(convert)
	{
		D3DDevice_CreateTexture(256, 256, 1, 0, D3DFMT_YUY2, 0, &pTex);
		D3DTexture_GetSurfaceLevel(pTex, 0, &pSur);
		g_pDev->CreateImageSurface(256, 256, D3DFMT_A8R8G8B8, &pSurT);
		D3DXLoadSurfaceFromFile(pSurT, NULL, NULL, psz, NULL, 
								D3DX_FILTER_LINEAR, 0, NULL);
		ConvertToYUV(pSurT, pSur);
		pSurT->Release();
	}
	else
	{
	    D3DDevice_CreateTexture(256, 256, 1, 0, D3DFMT_A8R8G8B8, 0, &pTex);
		D3DTexture_GetSurfaceLevel(pTex, 0, &pSur);
	    D3DXLoadSurfaceFromFile(pSur, NULL, NULL, psz, NULL, 
								D3DX_FILTER_LINEAR, 0, NULL);
	}
	pSur->Release();
    return pTex;
}

//------------------------------------------------------------------------------
//	InitOverlay
//------------------------------------------------------------------------------
void 
InitOverlay(void)
/*++

Routine Description:

	Loads all the images and creates the associated textures

Arguments:

	None

Return Value:

	None

--*/
{
    g_pTex0 = LoadImage("d:\\media\\mosquit1.bmp", FALSE);
    g_pTex1 = LoadImage("d:\\media\\mosquit1.bmp", TRUE);
    g_pTex2 = LoadImage("d:\\media\\mosquit2.bmp", TRUE);
	g_pTex3 = LoadImage("d:\\media\\mosquit3.bmp", TRUE);
}

//------------------------------------------------------------------------------
//	InitPosition
//------------------------------------------------------------------------------
void 
InitPosition(
			 IN int sWidth, 
			 IN int sHeight, 
			 IN int dWidth, 
			 IN int dHeight
			 ) 
/*++

Routine Description:

	Initializes the position of the moving box

Arguments:

	IN sWidth -		Source Width
	IN sHeight -	Source Height
	IN dWidth -		Destination width
	IN dHeight -	Destination height

Return Value:

	None

--*/
{
	g_sx1		= RAND_INT(sWidth - 2);
	g_sx2		= g_sx1 + (RAND_INT(sWidth - g_sx1));
	g_sy1		= RAND_INT(sHeight - 2);
	g_sy2		= g_sy1 + (RAND_INT(sHeight - g_sy1));
	g_dx1		= RAND_INT(dWidth - 2);
	g_dx2		= g_dx1 + (RAND_INT(dWidth - g_dx1));
	g_dy1		= RAND_INT(dHeight - 2);
	g_dy2		= g_dy1 + (RAND_INT(dHeight - g_dy1));
	g_swidth	= sWidth;
	g_sheight	= sHeight;
}

//------------------------------------------------------------------------------
//	UpdatePosition
//------------------------------------------------------------------------------
void 
UpdatePosition(void)
/*++

Routine Description:

	Updates the bouncing box's position

Arguments:

	None

Return Value:

	None

--*/
{
	Bounce(0, &g_sx1, &g_sx2, g_swidth,		&g_dsx1, &g_dsx2);
    Bounce(0, &g_sy1, &g_sy2, g_sheight,	&g_dsy1, &g_dsy2);
    Bounce(0, &g_dx1, &g_dx2, 640,			&g_ddx1, &g_ddx2);
    Bounce(0, &g_dy1, &g_dy2, 480,			&g_ddy1, &g_ddy2);
}

//------------------------------------------------------------------------------
//	UpdateOverlay
//------------------------------------------------------------------------------
void 
UpdateOverlay(
			  IN D3DTexture *pTex
			  )
/*++

Routine Description:

	Updates the overlay

Arguments:

	IN pTex -	Texture to use for the overlay

Return Value:

	None

--*/
{
    BOOL			status;
    D3DSURFACE_DESC	desc;
    D3DSurface*		pSur;

    D3DTexture_GetSurfaceLevel(pTex, 0, &pSur);

    pSur->GetDesc(&desc);

    // Initial value
	if(g_sx1 <= -3)
        InitPosition(desc.Width, desc.Height, 640,480);
    
	RECT rcSrc = {0, 0, 256, 256};//{g_sx1,g_sy1,g_sx2,g_sy2};
	RECT rcDst = {g_dx1,g_dy1,g_dx2,g_dy2};

    while(!g_pDev->GetOverlayUpdateStatus());

    g_pDev->UpdateOverlay(pSur, &rcSrc, &rcDst, TRUE, 0xff000000);

    pSur->Release();
}

//------------------------------------------------------------------------------
//	Pass1
//------------------------------------------------------------------------------
BOOL
Pass1(void)
/*++

Routine Description:

	Scrolling text

Arguments:

	None

Return Value:

	TRUE if the pass is complete, FALSE if not

--*/
{
	static BOOL		bNewPass	= TRUE;
	static BOOL		bCr			= FALSE;
	static DWORD	i			= 0;

	if(bNewPass)
	{
		// Clear any previous data
		SendCC(1, CC_ENM);
		SendCC(1, CC_EDM);

		// Start the pass
		SendCC(1, CC_TR);

		// Setup for 4 rows of scrolling text
		SendCC(1, CC_RU4);

		bNewPass	= FALSE;
		bCr			= FALSE;
		i			= 0;
	}

	else
	{
		// Still working?
		if(i < (sizeof(g_CC) / sizeof(g_CC[0])))
		{
			SendCC(g_CC[i].field, g_CC[i].cc0, g_CC[i].cc1);
			++i;
		}

		// Wait a while
		else if(i < (2 * (sizeof(g_CC) / sizeof(g_CC[0]))))
			++i;

		// Otherwise done
		else
		{
			// End the closed captioning
			SendCC(1, CC_EOC);
			bNewPass = TRUE;
			return TRUE;
		}
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	Pass2
//------------------------------------------------------------------------------
BOOL
Pass2(void)
/*++

Routine Description:

	Randomly placed and formatted text

Arguments:

	None

Return Value:

	TRUE if the pass is complete, FALSE if not

--*/
{
	static BOOL	bNewPass	= TRUE;
	static BOOL	bCr			= FALSE;
	static BYTE	i			= 1;

	if(bNewPass)
	{
		// Clear any previous data
		SendCC(1, CC_ENM);
		SendCC(1, CC_EDM);

		// Start the pass
		SendCC(1, CC_TR);

		// Setup for 4 Direct Captioning
		SendCC(1, CC_RDC);

		bNewPass	= FALSE;
		bCr			= FALSE;
		i			= 1;
	}

	else
	{
		// Still working?
		if(i <= 15)
		{
			// Random style
			SetRow(1, 1, i, (CCStyle)(rand() % NUM_CCSTYLE));

			// Random chars
			SendCC(1, (rand() % (CC_BLOCK - CC_SPACE)) + CC_SPACE,
				   (rand() % (CC_BLOCK - CC_SPACE)) + CC_SPACE);
			++i;
		}

		// Otherwise done
		else
		{
			// End the closed captioning
			SendCC(1, CC_EOC);
			bNewPass = TRUE;
			return TRUE;
		}
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	main
//------------------------------------------------------------------------------
void __cdecl 
main(void)
{
    DWORD			LastTickShow	= 0;
	DWORD			LastTickMove	= 0;
	DWORD			i				= sizeof(g_CC);
    D3DTexture*		pTex			= NULL;
    DWORD			CurrentTick;
	int				temp;
	int				pass1			= 0;
	int				pass2			= 0;
	int				frame			= 0;

    _asm 
	{
		rdtsc
		mov [CurrentTick], eax
    }
    srand((CurrentTick));

    InitD3D();
    InitVB();
    InitOverlay();

    g_pDev->EnableOverlay(TRUE);
    D3DDevice_EnableCC(TRUE);

    while(TRUE)
    {
        Paint();

        CurrentTick = GetTickCount();

        if (CurrentTick - LastTickMove > 80)
        {
            UpdatePosition();
            LastTickMove = CurrentTick;
        }

        if (pTex == g_pTex1)
            pTex = g_pTex2;
        else if(pTex == g_pTex2)
            pTex = g_pTex3;
        else
            pTex = g_pTex1;

		UpdateOverlay(pTex);

		if(pass1 < 5)
		{
			if(Pass1())
				++pass1;
		}

		else if(pass2 < 10)
		{
			if(frame == 30) 
			{
				frame = 0;
				if(Pass2())
					++pass2;
			}
			else
				++frame;
		}

		else
		{
			pass1 = 0;
			pass2 = 0;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\pointsprite\sources.inc ===
TARGETNAME=psprite
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    psprite.cpp 	\
    bitfont.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\pointsprite\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_

// pack the structure as we're reading it from the disk
#pragma pack(1)

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)


//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const char* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const char* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const char*     str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\pointsprite\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <mmsystem.h>
#include <D3DX8.h>
#endif

#include <xgraphics.h>

#include "bitfont.h"

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000f, 0x00000060, 0x00000008,
    0x000f0800, 0x1e080000, 0x08000000, 0x0000002d,
    0x00003c08, 0x004b0800, 0x5a080000, 0x08000000,
    0x00000069, 0x00007808, 0x00870800, 0x96080000,
    0x08000000, 0x000000a5, 0x0000b408, 0x00c30800,
    0xd2080000, 0x08000000, 0x000000e1, 0x0000f008,
    0x00ff0800, 0x0e080000, 0x08000001, 0x0000011d,
    0x00012c08, 0x013b0800, 0x4a080000, 0x08000001,
    0x00000159, 0x00016808, 0x01770800, 0x86080000,
    0x08000001, 0x00000195, 0x0001a408, 0x01b30800,
    0xc2080000, 0x08000001, 0x000001d1, 0x0001e008,
    0x01ef0800, 0xfe080000, 0x08000001, 0x0000020d,
    0x00021c08, 0x022b0800, 0x3a080000, 0x08000002,
    0x00000249, 0x00025808, 0x02670800, 0x76080000,
    0x08000002, 0x00000285, 0x00029408, 0x02a30800,
    0xb2080000, 0x08000002, 0x000002c1, 0x0002d008,
    0x02df0800, 0xee080000, 0x08000002, 0x000002fd,
    0x00030c08, 0x031b0800, 0x2a080000, 0x08000003,
    0x00000339, 0x00034808, 0x03570800, 0x66080000,
    0x08000003, 0x00000375, 0x00038408, 0x03930800,
    0xa2080000, 0x08000003, 0x000003b1, 0x0003c008,
    0x03cf0800, 0xde080000, 0x08000003, 0x000003ed,
    0x0003fc08, 0x040b0800, 0x1a080000, 0x08000004,
    0x00000429, 0x00043808, 0x04470800, 0x56080000,
    0x08000004, 0x00000465, 0x00047408, 0x04830800,
    0x92080000, 0x08000004, 0x000004a1, 0x0004b008,
    0x04bf0800, 0xce080000, 0x08000004, 0x000004dd,
    0x0004ec08, 0x04fb0800, 0x0a080000, 0x08000005,
    0x00000519, 0x00052808, 0x05370800, 0x46080000,
    0x08000005, 0x00000555, 0x00056408, 0x05730800,
    0x82080000, 0x08000005, 0x00000591, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xc3e7ffff,
    0xe7e7c3c3, 0xffe7e7ff, 0xffffffff, 0x999999ff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xc980c9c9,
    0xc980c9c9, 0xffffffc9, 0xc3e7e7ff, 0xe7cf9f99,
    0xc399f9f3, 0xffffe7e7, 0x25278fff, 0xcfe7f389,
    0xf1e4a491, 0xffffffff, 0x9393c7ff, 0x99909fc7,
    0xffffc499, 0xffffffff, 0xffe7e7e7, 0xffffffff,
    0xffffffff, 0xf3ffffff, 0xcfcfe7e7, 0xe7cfcfcf,
    0xfffff3e7, 0xe7cfffff, 0xf3f3f3e7, 0xe7e7f3f3,
    0xffffffcf, 0xc9ffffff, 0xc9e380e3, 0xffffffff,
    0xffffffff, 0xe7e7ffff, 0xffe7e781, 0xffffffff,
    0xffffffff, 0xffffffff, 0xe3e3ffff, 0xffffe7f3,
    0xffffffff, 0xff81ffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffe3e3, 0xffffffff,
    0xf3f3f9f9, 0xcfcfe7e7, 0xffff9f9f, 0xe1ffffff,
    0xccc8c8cc, 0xe1ccc4c4, 0xffffffff, 0xe3f3ffff,
    0xf3f3f383, 0xfff3f3f3, 0xffffffff, 0x9999c3ff,
    0xcfe7f3f9, 0xffff819f, 0xffffffff, 0xf99999c3,
    0x9999f9e3, 0xffffffc3, 0xcfffffff, 0xc9c9c9cf,
    0xf9f98099, 0xffffffff, 0x9f81ffff, 0xf9839f9f,
    0xff87f3f9, 0xffffffff, 0xcfe7e3ff, 0x99999983,
    0xffffc399, 0xffffffff, 0xf3f3f981, 0xcfcfe7e7,
    0xffffffcf, 0xc3ffffff, 0xc3899999, 0xc3999991,
    0xffffffff, 0x99c3ffff, 0xc1999999, 0xffc7e7f3,
    0xffffffff, 0xe3ffffff, 0xffffffe3, 0xffffe3e3,
    0xffffffff, 0xe3e3ffff, 0xe3ffffff, 0xffe7f3e3,
    0xf9ffffff, 0x9fcfe7f3, 0xf9f3e7cf, 0xffffffff,
    0xffffffff, 0x81ff81ff, 0xffffffff, 0xffffffff,
    0xe7cf9fff, 0xe7f3f9f3, 0xffff9fcf, 0xffffffff,
    0xf39999c3, 0xe7ffe7e7, 0xffffffe7, 0x81ffffff,
    0x24303c3c, 0x803f3024, 0xffffffff, 0xc3e7ffff,
    0x81999999, 0xff999999, 0xffffffff, 0x999983ff,
    0x99998399, 0xffff8399, 0xffffffff, 0x9f9999c3,
    0x99999f9f, 0xffffffc3, 0x87ffffff, 0x99999993,
    0x87939999, 0xffffffff, 0x9f81ffff, 0x9f839f9f,
    0xff819f9f, 0xffffffff, 0x9f9f81ff, 0x9f9f839f,
    0xffff9f9f, 0xffffffff, 0x9f9999c3, 0x9999919f,
    0xffffffc1, 0x99ffffff, 0x81999999, 0x99999999,
    0xffffffff, 0xe7c3ffff, 0xe7e7e7e7, 0xffc3e7e7,
    0xffffffff, 0xf9f9f9ff, 0x99f9f9f9, 0xffffc399,
    0xffffffff, 0x93939999, 0x99939387, 0xffffff99,
    0x9fffffff, 0x9f9f9f9f, 0x819f9f9f, 0xffffffff,
    0x9c9cffff, 0x94949488, 0xff9c9c9c, 0xffffffff,
    0x8c9c9cff, 0x9c989084, 0xffff9c9c, 0xffffffff,
    0x999999c3, 0x99999999, 0xffffffc3, 0x83ffffff,
    0x83999999, 0x9f9f9f9f, 0xffffffff, 0x99c3ffff,
    0x99999999, 0xf3c39999, 0xfffffff9, 0x999983ff,
    0x99938399, 0xffff9999, 0xffffffff, 0xcf9f99c3,
    0x99f9f3e7, 0xffffffc3, 0x81ffffff, 0xe7e7e7e7,
    0xe7e7e7e7, 0xffffffff, 0x9999ffff, 0x99999999,
    0xffc39999, 0xffffffff, 0x999999ff, 0x99999999,
    0xffffe7c3, 0xffffffff, 0x949c9c9c, 0xc9c99494,
    0xffffffc9, 0x99ffffff, 0xe7e7cb99, 0x999999d3,
    0xffffffff, 0x9999ffff, 0xe7c39999, 0xffe7e7e7,
    0xffffffff, 0xf9f981ff, 0x9fcfe7f3, 0xffff819f,
    0xffffffff, 0xcfcfcfc3, 0xcfcfcfcf, 0xc3cfcfcf,
    0x9fffffff, 0xe7cfcf9f, 0xf9f3f3e7, 0xfffffff9,
    0xf3c3ffff, 0xf3f3f3f3, 0xf3f3f3f3, 0xe7ffc3f3,
    0xffff99c3, 0xffffffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0x00ffffff, 0xf3e7c7ff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0xc1f9f9c3, 0xffc19999, 0xffffffff, 0x839f9fff,
    0x99999999, 0xffff8399, 0xffffffff, 0x99c3ffff,
    0x999f9f9f, 0xffffffc3, 0xf9ffffff, 0x9999c1f9,
    0xc1999999, 0xffffffff, 0xffffffff, 0x819999c3,
    0xffc39f9f, 0xffffffff, 0xcfcfe1ff, 0xcfcf81cf,
    0xffffcfcf, 0xffffffff, 0x99c1ffff, 0x99999999,
    0x83f9f9c1, 0x9fffffff, 0x9999839f, 0x99999999,
    0xffffffff, 0xffe7e7ff, 0xe7e7e787, 0xff81e7e7,
    0xffffffff, 0xc3fff3f3, 0xf3f3f3f3, 0xf3f3f3f3,
    0xffffff87, 0x99999f9f, 0x99938793, 0xffffff99,
    0x87ffffff, 0xe7e7e7e7, 0x81e7e7e7, 0xffffffff,
    0xffffffff, 0x94949481, 0xff9c9494, 0xffffffff,
    0x83ffffff, 0x99999999, 0xffff9999, 0xffffffff,
    0x99c3ffff, 0x99999999, 0xffffffc3, 0xffffffff,
    0x999983ff, 0x83999999, 0xff9f9f9f, 0xffffffff,
    0x999999c1, 0xf9c19999, 0xfffff9f9, 0x99ffffff,
    0x9f9f8f91, 0xffff9f9f, 0xffffffff, 0x9fc1ffff,
    0xf9f9c39f, 0xffffff83, 0xcfffffff, 0xcfcf81cf,
    0xe1cfcfcf, 0xffffffff, 0xffffffff, 0x99999999,
    0xffc19999, 0xffffffff, 0x99ffffff, 0x99999999,
    0xffffe7c3, 0xffffffff, 0x949cffff, 0xc9949494,
    0xffffffc9, 0xffffffff, 0xc39999ff, 0x9999c3e7,
    0xffffffff, 0xffffffff, 0x99999999, 0xf3c39999,
    0xffff0fe7, 0x81ffffff, 0xcfe7f3f9, 0xffff819f,
    0xffffffff, 0xe7e7e7f3, 0xe7cf9fcf, 0xfff3e7e7,
    0xe7ffffff, 0xe7e7e7e7, 0xe7e7e7e7, 0xffe7e7e7,
    0xe7cfffff, 0xf9f3e7e7, 0xe7e7e7f3, 0xffffffcf,
    0x71248eff, 0xffffffff, 0xffffffff, 0xffffffff,
    0x81818181, 0x81818181, 0xffffff81
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const char* filename)
{
#ifdef NEVER
    HFILE hf = _lopen(filename, OF_READ);

    if(hf != HFILE_ERROR)
    {
        // get the file size and move back to the start
        LONG lSize = _llseek(hf, 0, FILE_END);
        _llseek(hf, 0, FILE_BEGIN);

        // need at least a BITFONT and one BITFONTINFO
        if(lSize < sizeof(BitFontInfo) + sizeof(BitFontCharInfo))
            goto err;

        // malloc our BITFONT block and read it in
        m_pBitFontInfo = (BitFontInfo *)new BYTE[lSize];
        if(!m_pBitFontInfo)
            goto err;

        if(_lread(hf, m_pBitFontInfo, (UINT)lSize) != (UINT)lSize)
            goto err;

        // if the sig doesn't match or we don't have any bitfontinfos then bail
        if(m_pBitFontInfo->dwSig != BITFONT_SIG || !m_pBitFontInfo->cBfis)
            goto err;

        _lclose(hf);
        return true;
    }

err:
    if(hf != HFILE_ERROR)
        _lclose(hf);

    delete [] m_pBitFontInfo;
    m_pBitFontInfo = NULL;
#endif
    return false;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const char *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const char *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const char*         str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const char *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const char*         str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const char *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const char*     str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const char*         str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, 0) != S_OK)
    {
        _asm int 3;
        return;
    }

    D3DSURFACE_DESC desc;
    if(FAILED(pSurface->GetDesc(&desc)))
    {
        _asm int 3;
        return;
    }

    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 || desc.Format == D3DFMT_X8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
#ifdef XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
    case D3DFMT_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        _asm int 3;
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\pointsprite\psprite.cpp ===
//-----------------------------------------------------------------------------
// FILE: PSPRITE.C
//
// Desc: Point sprite sample. based on Kilgards gl pointburst.c
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#define STRICT

#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <mmsystem.h>
#include <D3DX8.h>
#endif
#include <stdio.h>
#include "D3DApp.h"
#include "D3DFile.h"
#include "D3DUtil.h"
#include "DXUtil.h"

#include <xgraphics.h>

#include "bitfont.h"

#ifndef XBOX
#undef CheckHR
#define CheckHR(x) { HRESULT _hr = (x); if (FAILED(_hr)) { _asm { int 3 } } }
#endif

/*
 * Globals and stuff
 */
IDirect3DDevice8    *pDev  = NULL;          // d3d device
IDirect3DTexture8   *g_pFloorTex = NULL;    // floor texture
IDirect3DTexture8   *g_pSpriteTex = NULL;   // sprite texture
LPDIRECT3DSURFACE8  g_pBackBuffer = NULL;   // our backbuffer

const float         g_fRadius = 8.0f;       // radius of floor disk
const int           g_cMaxPoints = 2001;    // maximum count of points
int                 g_numPoints = 500;      // current count of points
int                 g_clivepoints = 0;      // count of live points

float               g_angle = 0;            // view rotation around Y axis
float               g_time;                 // current time
bool                g_fpausetime = false;   // pause the particles
bool                g_fspin = true;         // I spin you right round baby...

HANDLE              g_hInpDevice = NULL;    // input handle

BitFont             g_bitfont;

static const float rgPointScale[3][3] =
{
    { 1/5.0f, 0.0, 0.0 },   // constant
    { 0.0, 1/5.0f, 0.0 },   // linear
    { 0.25f, 0.0, 1/60.0f } // quadratic
};
int g_iPointScale = 2;                      // defualt to quadratic

bool g_fPointScaleEnable = true;
float g_fPointSize = 10.0f;

// our point data
struct POINTDATA
{
    float time;
    float velocity[2];
    float direction[2];
} rgPointData[g_cMaxPoints];

// point rendering data
struct MYD3DPOINTVERTEX
{
    float sx, sy, sz;
    D3DCOLOR color;
} rgPoints[g_cMaxPoints];

// our floor
static const int g_cfloorverts = 20;
struct MYD3DTLVERTEX
{
    float    sx, sy, sz; // Screen coordinates
    DWORD    color;      // Vertex color
    float    tu, tv;     // Texture coordinates
} g_floorverts[g_cfloorverts];

// handle joystick input
void HandleInput();
BOOL InitD3D(HWND hWnd);
void DeinitD3D();

static float float_rand(void) { return rand() / (float)RAND_MAX; }
#define RANDOM_RANGE(lo, hi) ((lo) + (hi - lo) * float_rand())

// helper routine to convert floats to dwords for pointsize, etc.
inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }

//=========================================================================
// Create our points
//=========================================================================
void makePointList(void)
{
    static const D3DCOLOR colorSet[] =
    {
        D3DCOLOR_COLORVALUE(0.7f, 0.7f, 0.4f, 0.5f),
        D3DCOLOR_COLORVALUE(0.7f, 0.7f, 0.4f, 0.5f),
        D3DCOLOR_COLORVALUE(0.8f, 0.8f, 0.7f, 0.5f),
        D3DCOLOR_COLORVALUE(1.0f, 1.0f, 0.0f, 0.5f),
        D3DCOLOR_COLORVALUE(0.9f, 0.9f, 0.6f, 0.5f),
        D3DCOLOR_COLORVALUE(1.0f, 1.0f, 0.0f, 0.5f),
        D3DCOLOR_COLORVALUE(1.0f, 1.0f, 0.5f, 0.5f),
    };
    const int cColorSets = sizeof(colorSet) / sizeof(colorSet[0]);
    static const float fMEAN_VELOCITY = 3.0f;

    for(int i = 0; i < g_numPoints; i++)
    {
        rgPoints[i].sx = 0.0;
        rgPoints[i].sy = 0.0;
        rgPoints[i].sz = 0.0;
        rgPointData[i].time = 0.0;

        float direction = RANDOM_RANGE(0.0f, 360.0f) * D3DX_PI / 180.0f;

        rgPointData[i].direction[0] = cosf(direction);  // X
        rgPointData[i].direction[1] = sinf(direction);  // Z

        float angle = (RANDOM_RANGE(60.0f, 70.0f)) * D3DX_PI / 180.0f;
        float velocity = fMEAN_VELOCITY + RANDOM_RANGE(-0.8f, 1.0f);

        rgPointData[i].velocity[0] = velocity * cosf(angle); // X,Z
        rgPointData[i].velocity[1] = velocity * sinf(angle); // Y

        rgPoints[i].color = colorSet[rand() % cColorSets];
    }

    g_time = 0.0;
    g_clivepoints = g_numPoints;
}

//=========================================================================
// Update the point sprite positions
//=========================================================================
void updatePointList(DWORD dwTicks)
{
    float fTIME_DELTA = min(.025f, .0015f * dwTicks);

    for(int i = 0; i < g_clivepoints; i++)
    {
        static const float fGRAVITY = 2.0f;
        float distance = rgPointData[i].velocity[0] * g_time;

        // X and Z
        rgPoints[i].sx = rgPointData[i].direction[0] * distance;
        rgPoints[i].sz = rgPointData[i].direction[1] * distance;

        // Y
        rgPoints[i].sy =
            (rgPointData[i].velocity[1] - 0.5f * fGRAVITY * rgPointData[i].time) *
             rgPointData[i].time;

        // if we hit the ground, bounce the point upward again.
        if(rgPoints[i].sy <= 0.0)
        {
            if(distance <= g_fRadius)
            {
                rgPointData[i].velocity[1] *= 0.8f; // 80% of previous up velocity.
                rgPointData[i].time = 0.0;          // reset the particles sense of up time.
            }
            else if(distance > g_fRadius + 1.0f)
            {
                // Particle has hit ground past the distance duration of
                // the particles. Die little particle die.
                rgPointData[i] = rgPointData[--g_clivepoints];
                rgPoints[i--] = rgPoints[g_clivepoints];
                continue;
            }
        }

        rgPointData[i].time += fTIME_DELTA;
    }

    g_time += fTIME_DELTA;

    if(!g_clivepoints)
        makePointList();
}

//=========================================================================
// Create a texture of width & height using the szFmt pattern
//=========================================================================
IDirect3DTexture8 *CreateTexture(DWORD dwWidth, DWORD dwHeight,
    const char *szFmt[])
{
    IDirect3DTexture8 *pTexture = NULL;

    pDev->CreateTexture(dwWidth, dwHeight, 1, 0,
        D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &pTexture);
    if(pTexture)
    {
        D3DLOCKED_RECT lockRect;

        HRESULT hr = pTexture->LockRect(0, &lockRect, NULL, 0);

        PVOID pBits = LocalAlloc(0, dwWidth * dwHeight * 4);

        DWORD dwLine = (DWORD)pBits;
        LONG lPitch = lockRect.Pitch;

        int xFmt = 0;
        for(DWORD x = 0; x < dwWidth; x++)
        {
            DWORD dwAddr = dwLine;
            const char *szLineFmt = szFmt[xFmt];

            if(szLineFmt)
                xFmt++;

            int yFmt = 0;
            for(DWORD y = 0; y < dwHeight; y++)
            {
                char ch = (szLineFmt && szLineFmt[yFmt]) ?
                    szLineFmt[yFmt++] : 0;

                *(DWORD*)dwAddr = (ch == 'x') ?
                    D3DCOLOR_ARGB(0xff, 0x1f, 0x1f, 0x8f) :
                    D3DCOLOR_ARGB(0x00, 0, 0, 0);

                dwAddr += sizeof(DWORD);
            }
            dwLine += lPitch;
        }

        XGSwizzleRect(pBits, 
                      0,
                      NULL,
                      lockRect.pBits,
                      dwWidth,
                      dwHeight,
                      NULL, 
                      4);

        LocalFree(pBits);

        // Unlock the map so it can be used
        pTexture->UnlockRect(0);
   }

   return pTexture;
}

//=========================================================================
// Draw the floor
//=========================================================================
void DrawFloor()
{
    CheckHR(pDev->SetTexture(0, g_pFloorTex));

    CheckHR(pDev->SetVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1));

    CheckHR(pDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, g_cfloorverts - 2,
        g_floorverts, sizeof(g_floorverts[0])));
}

//=========================================================================
// Draw the point sprites
//=========================================================================
void DrawPSprites()
{
    if(!g_clivepoints)
        return;

    CheckHR(pDev->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_ADD));
    CheckHR(pDev->SetTextureStageState(3, D3DTSS_COLORARG1, D3DTA_DIFFUSE));
    CheckHR(pDev->SetTextureStageState(3, D3DTSS_COLORARG2, D3DTA_TEXTURE));
    CheckHR(pDev->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_MODULATE));
    CheckHR(pDev->SetTextureStageState(3, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE));
    CheckHR(pDev->SetTextureStageState(3, D3DTSS_ALPHAARG2, D3DTA_TEXTURE));

    CheckHR(pDev->SetRenderState(D3DRS_ZWRITEENABLE, FALSE));
    CheckHR(pDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE));
    CheckHR(pDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA));
    CheckHR(pDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA));

    // Set the render states for using point sprites
    CheckHR(pDev->SetRenderState(D3DRS_POINTSPRITEENABLE, TRUE));
    CheckHR(pDev->SetRenderState(D3DRS_POINTSCALEENABLE,  g_fPointScaleEnable));

    CheckHR(pDev->SetRenderState(D3DRS_POINTSIZE,     FtoDW(g_fPointSize)));
    CheckHR(pDev->SetRenderState(D3DRS_POINTSCALE_A,  FtoDW(rgPointScale[g_iPointScale][0])));
    CheckHR(pDev->SetRenderState(D3DRS_POINTSCALE_B,  FtoDW(rgPointScale[g_iPointScale][1])));
    CheckHR(pDev->SetRenderState(D3DRS_POINTSCALE_C,  FtoDW(rgPointScale[g_iPointScale][2])));

//    CheckHR(pDev->SetRenderState(D3DRS_POINTSIZE_MIN, FtoDW(0.08f)));
//    CheckHR(pDev->SetRenderState(D3DRS_POINTSIZE_MAX, FtoDW(0.08f)));

    // set the point sprite texture
    CheckHR(pDev->SetTexture(3, g_pSpriteTex));

    // draw the little dudes
    CheckHR(pDev->SetVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE));

    CheckHR(pDev->DrawPrimitiveUP(D3DPT_POINTLIST, g_clivepoints,
        &rgPoints, sizeof(rgPoints[0])));

    // clear our renderstates
    CheckHR(pDev->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE));
    CheckHR(pDev->SetRenderState(D3DRS_POINTSCALEENABLE, FALSE));

    CheckHR(pDev->SetRenderState(D3DRS_ZWRITEENABLE, TRUE));
    CheckHR(pDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE));
    CheckHR(pDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE));
    CheckHR(pDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE));

    CheckHR(pDev->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_DISABLE));
    CheckHR(pDev->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_DISABLE));
    CheckHR(pDev->SetTexture(3, NULL));
}

//=========================================================================
// Spit out our current state
//=========================================================================
void DrawText()
{
#if 0
    char szBuf[256];
    DWORD dwHeight;
    DWORD dwY = 10;

    g_bitfont.GetTextStringLength(NULL, &dwHeight, NULL);
    dwHeight += 2;

    D3DCOLOR colFore = D3DCOLOR_XRGB(255, 255, 255);
    D3DCOLOR colBack = D3DCOLOR_XRGB(0, 0, 0);

    dwY += dwHeight;

    sprintf(szBuf, "# Points: %d", g_numPoints);
    //g_bitfont.DrawText(g_pBackBuffer, szBuf, 10, dwY,
    //    0, colFore, colBack);
    dwY += dwHeight;

    sprintf(szBuf, "PointSize: %.3f", g_fPointSize);
    //g_bitfont.DrawText(g_pBackBuffer, szBuf, 10, dwY,
    //    0, colFore, colBack);
    dwY += dwHeight;

    sprintf(szBuf, "PointScaleEnable: %s",
        g_fPointScaleEnable ? "true" : "false");
    //g_bitfont.DrawText(g_pBackBuffer, szBuf, 10, dwY,
    //    0, colFore, colBack);
    dwY += dwHeight;

    static const char *rgszScale[] = { "constant", "linear", "quadratic" };
    sprintf(szBuf, "PointScale: %s", rgszScale[g_iPointScale]);
    //g_bitfont.DrawText(g_pBackBuffer, szBuf, 10, dwY,
    //    0, colFore, colBack);
    dwY += dwHeight;

    if(g_fpausetime)
    {
    //    g_bitfont.DrawText(g_pBackBuffer, "Paused", 10, dwY,
    //        0, colFore, colBack);
    }
#endif
}

//=========================================================================
// Update the point sprites and paint the scene
//=========================================================================
void Render(DWORD dwTicks)
{
    HRESULT hr;

    // Clear the frame buffer, Zbuffer.
    CheckHR(pDev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
        0x00006688, 1.0, 0));

    CheckHR(pDev->BeginScene());

    if(g_fspin)
    {
        D3DXMATRIX matRotate;

        g_angle += dwTicks * .018f;

        D3DXMatrixRotationY(&matRotate, g_angle * D3DX_PI / 180);
        pDev->SetTransform(D3DTS_WORLD, &matRotate);
    }

    // draw the floor
    DrawFloor();

    // draw the happy faces
    DrawPSprites();

    CheckHR(pDev->EndScene());

    DrawText();

    // Present!
    hr = pDev->Present(NULL, NULL, NULL, NULL);
    if(hr != D3DERR_DEVICELOST)
        CheckHR(hr);
}

//=========================================================================
// input, update, render
//=========================================================================
void MainLoop()
{
    static DWORD dwLastTickCount = GetTickCount();

    DWORD dwTickCount = GetTickCount();
    DWORD dwTicks = dwTickCount - dwLastTickCount;

    dwLastTickCount = dwTickCount;

    HandleInput();

    if(!g_fpausetime)
        updatePointList(dwTicks);

    Render(dwTicks);
}

#ifndef XBOX

//=========================================================================
// Our useless WIN32 message handler. Almost useless.
//=========================================================================
LRESULT WINAPI
MessageHandler(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    if (Msg == WM_DESTROY)
        PostQuitMessage(0);

    return DefWindowProc(hWnd, Msg, wParam, lParam);
}

//=========================================================================
// WIN32 WinMain
//=========================================================================
int APIENTRY
WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    LPSTR lpCmdLine, int nCmdShow)
{
    MSG msg;
    HWND hwnd;

    WNDCLASSEX classex;
    ZeroMemory(&classex, sizeof(classex));

    classex.cbSize          = sizeof(WNDCLASSEX);
    classex.style           = CS_CLASSDC;
    classex.lpfnWndProc     = MessageHandler;
    classex.hInstance       = hInstance;
    classex.lpszClassName   = L"XBOX";
    RegisterClassEx(&classex);

    hwnd = CreateWindowEx(WS_EX_TOPMOST, L"XBOX", L"XBOX Basic Shell",
                          WS_VISIBLE|WS_POPUP,
                          CW_USEDEFAULT,CW_USEDEFAULT, 0, 0,
                          NULL, NULL, hInstance, NULL);

    if(!InitD3D(hwnd))
        return EXIT_FAILURE;

    ShowCursor(FALSE);

    bool bQuit = false;
    while(!bQuit)
    {
        while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            bQuit |= (msg.message == WM_QUIT);
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        MainLoop();
    }

    DeinitD3D();
    return EXIT_SUCCESS;
}

#else

//=========================================================================
// Xbox main. Much better.
//=========================================================================
void __cdecl main()
{

    if(!InitD3D(NULL))
        return;

    for(;;)
        MainLoop();


    // whatever
    DeinitD3D();
}

#endif // defined(XBOX)

// Emulate Xbox input functions
#ifndef XBOX

#ifndef _XBOX_
#define     XDEVICE_TYPE_GAMEPAD        0
#define     XDEVICE_TYPE_CHAT_BUTTONS   1
#define     XDEVICE_TYPE_MEMORY_UNIT    2
#define     XDEVICE_TYPE_CHAT_AUDIO     3
#define     XDEVICE_TYPE_MODEM          4

#define     XDEVICE_PORT0               0
#define     XDEVICE_PORT1               1
#define     XDEVICE_PORT2               2
#define     XDEVICE_PORT3               3

#define     XDEVICE_NO_SLOT             0
#define     XDEVICE_TOP_SLOT            0
#define     XDEVICE_BOTTOM_SLOT         16

#define     XDEVICE_PORT0_MASK          (1 << XDEVICE_PORT0)
#define     XDEVICE_PORT1_MASK          (1 << XDEVICE_PORT1)
#define     XDEVICE_PORT2_MASK          (1 << XDEVICE_PORT2)
#define     XDEVICE_PORT3_MASK          (1 << XDEVICE_PORT3)
#define     XDEVICE_PORT0_TOP_MASK      (1 << (XDEVICE_PORT0 + XDEVICE_TOP_SLOT))
#define     XDEVICE_PORT1_TOP_MASK      (1 << (XDEVICE_PORT1 + XDEVICE_TOP_SLOT))
#define     XDEVICE_PORT2_TOP_MASK      (1 << (XDEVICE_PORT2 + XDEVICE_TOP_SLOT))
#define     XDEVICE_PORT3_TOP_MASK      (1 << (XDEVICE_PORT3 + XDEVICE_TOP_SLOT))
#define     XDEVICE_PORT0_BOTTOM_MASK   (1 << (XDEVICE_PORT0 + XDEVICE_BOTTOM_SLOT))
#define     XDEVICE_PORT1_BOTTOM_MASK   (1 << (XDEVICE_PORT1 + XDEVICE_BOTTOM_SLOT))
#define     XDEVICE_PORT2_BOTTOM_MASK   (1 << (XDEVICE_PORT2 + XDEVICE_BOTTOM_SLOT))
#define     XDEVICE_PORT3_BOTTOM_MASK   (1 << (XDEVICE_PORT3 + XDEVICE_BOTTOM_SLOT))

struct XINPUT_GAMEPAD
{
    WORD    wButtons;
    BYTE    bAnalogButtons[8];
    SHORT   sThumbLX;
    SHORT   sThumbLY;
    SHORT   sThumbRX;
    SHORT   sThumbRY;
};

#define XINPUT_GAMEPAD_DPAD_UP          0x00000001
#define XINPUT_GAMEPAD_DPAD_DOWN        0x00000002
#define XINPUT_GAMEPAD_DPAD_LEFT        0x00000004
#define XINPUT_GAMEPAD_DPAD_RIGHT       0x00000008
#define XINPUT_GAMEPAD_START            0x00000010
#define XINPUT_GAMEPAD_BACK             0x00000020
#define XINPUT_GAMEPAD_LEFT_THUMB       0x00000040
#define XINPUT_GAMEPAD_RIGHT_THUMB      0x00000080

#define XINPUT_GAMEPAD_A                0
#define XINPUT_GAMEPAD_B                1
#define XINPUT_GAMEPAD_X                2
#define XINPUT_GAMEPAD_Y                3
#define XINPUT_GAMEPAD_BLACK            4
#define XINPUT_GAMEPAD_WHITE            5
#define XINPUT_GAMEPAD_LEFT_TRIGGER     6
#define XINPUT_GAMEPAD_RIGHT_TRIGGER    7

struct XINPUT_STATE
{
    DWORD dwPacketNumber;
    XINPUT_GAMEPAD Gamepad;
};

#define XGetPortCount() 4
DWORD   XGetDevices( DWORD dwType );
BOOL    XGetDeviceChanges( DWORD dwType, DWORD* pdwInsertions, DWORD* pdwRemovals );
HANDLE  XInputOpen( DWORD dwType, DWORD dwPort, DWORD dwSlot, VOID* );
VOID    XInputClose( HANDLE hDevice );
DWORD   XInputGetState( HANDLE hDevice, XINPUT_STATE* pState );

#endif

void XInitDevices(){}

DWORD XGetDevices(DWORD dwType)
{
    return XDEVICE_PORT0_MASK;
}

BOOL XGetDeviceChanges(DWORD dwType, DWORD* pdwInsertions, DWORD* pdwRemovals)
{
    (*pdwInsertions) = 0L;
    (*pdwRemovals)   = 0L;
    return FALSE;
}

HANDLE XInputOpen(DWORD dwType, DWORD dwPort, DWORD dwSlot, VOID*)
{
    return (HANDLE)1;
}

VOID XInputClose(HANDLE hDevice)
{
}

DWORD XInputGetState(HANDLE hDevice, XINPUT_STATE* pState)
{
    // Read joystick 1 with the Win32 API.
    JOYINFOEX joy;
    ZeroMemory( &joy, sizeof(joy) );
    joy.dwSize  = sizeof(joy);
    joy.dwFlags = JOY_RETURNX|JOY_RETURNY|JOY_RETURNBUTTONS|JOY_RETURNPOV|
                  JOY_USEDEADZONE|JOY_RETURNZ|JOY_RETURNR;
    if( 0 != joyGetPosEx( 0, &joy ) )
        return 0L;

    // Fill in the XBGAMEPAD structure
    ZeroMemory( pState, sizeof(XINPUT_STATE) );

    // Convert joystick's thumbstick values to Xbox gamepad values
    pState->Gamepad.sThumbLX =  (SHORT)joy.dwXpos - 32768;
    pState->Gamepad.sThumbLY = -(SHORT)joy.dwYpos + 32767;
    pState->Gamepad.sThumbRX =  (SHORT)joy.dwZpos - 32768;
    pState->Gamepad.sThumbRY = -(SHORT)joy.dwRpos + 32767;
    if( pState->Gamepad.sThumbLX == -1 )
        pState->Gamepad.sThumbLX = 0;
    if( pState->Gamepad.sThumbRX == -1 )
        pState->Gamepad.sThumbRX = 0;

    // Convert joystick's button values to Xbox gamepad values
    if( joy.dwButtons & 0x001 )   pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X]     = TRUE;
    if( joy.dwButtons & 0x002 )   pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y]     = TRUE;
    if( joy.dwButtons & 0x004 )   pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] = TRUE;
    if( joy.dwButtons & 0x008 )   pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A]     = TRUE;
    if( joy.dwButtons & 0x010 )   pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B]     = TRUE;
    if( joy.dwButtons & 0x020 )   pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] = TRUE;
    if( joy.dwButtons & 0x100 )   pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER]  = TRUE;
    if( joy.dwButtons & 0x200 )   pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] = TRUE;

    if( joy.dwButtons & 0x040 )   pState->Gamepad.wButtons |= XINPUT_GAMEPAD_LEFT_THUMB;
    if( joy.dwButtons & 0x080 )   pState->Gamepad.wButtons |= XINPUT_GAMEPAD_RIGHT_THUMB;
    if( joy.dwButtons & 0x400 )   pState->Gamepad.wButtons |= XINPUT_GAMEPAD_START;
    if( joy.dwButtons & 0x800 )   pState->Gamepad.wButtons |= XINPUT_GAMEPAD_BACK;

    if( joy.dwPOV == 0 )          pState->Gamepad.wButtons |= (XINPUT_GAMEPAD_DPAD_UP);
    else if( joy.dwPOV == 4500 )  pState->Gamepad.wButtons |= (XINPUT_GAMEPAD_DPAD_RIGHT|XINPUT_GAMEPAD_DPAD_UP);
    else if( joy.dwPOV == 9000 )  pState->Gamepad.wButtons |= (XINPUT_GAMEPAD_DPAD_RIGHT);
    else if( joy.dwPOV == 13500 ) pState->Gamepad.wButtons |= (XINPUT_GAMEPAD_DPAD_RIGHT|XINPUT_GAMEPAD_DPAD_DOWN);
    else if( joy.dwPOV == 18000 ) pState->Gamepad.wButtons |= (XINPUT_GAMEPAD_DPAD_DOWN);
    else if( joy.dwPOV == 22500 ) pState->Gamepad.wButtons |= (XINPUT_GAMEPAD_DPAD_LEFT|XINPUT_GAMEPAD_DPAD_DOWN);
    else if( joy.dwPOV == 27000 ) pState->Gamepad.wButtons |= (XINPUT_GAMEPAD_DPAD_LEFT);
    else if( joy.dwPOV == 31500 ) pState->Gamepad.wButtons |= (XINPUT_GAMEPAD_DPAD_LEFT|XINPUT_GAMEPAD_DPAD_UP);

    // For beneift of keyboard users, also trap the Escape key
    if( GetAsyncKeyState( VK_ESCAPE ) )
        pState->Gamepad.wButtons |= XINPUT_GAMEPAD_BACK;

    return 0L;
}

#endif

void HandleInput()
{
    if(g_hInpDevice)
    {
        XINPUT_STATE xinpstate;
        static XINPUT_STATE xinpstatelast;
#define FButtonDown(_btn) \
        (xinpstate.Gamepad.bAnalogButtons[_btn] && \
            (xinpstate.Gamepad.bAnalogButtons[_btn] != xinpstatelast.Gamepad.bAnalogButtons[_btn]))

        XInputGetState(g_hInpDevice, &xinpstate);

        if(FButtonDown(XINPUT_GAMEPAD_A))
            g_fspin = !g_fspin;

        if(FButtonDown(XINPUT_GAMEPAD_B))
            g_fpausetime = !g_fpausetime;

        if(FButtonDown(XINPUT_GAMEPAD_X))
        {
            g_numPoints += 500;
            if(g_numPoints >= g_cMaxPoints)
                g_numPoints = 500;

            // restart
            g_clivepoints = 0;
        }

        if(FButtonDown(XINPUT_GAMEPAD_Y))
            g_iPointScale = (g_iPointScale + 1) % (sizeof(rgPointScale) / sizeof(rgPointScale[0]));

        if(FButtonDown(XINPUT_GAMEPAD_BLACK))
            g_fPointScaleEnable = !g_fPointScaleEnable;

        if(FButtonDown(XINPUT_GAMEPAD_WHITE))
        {
            g_fPointSize += 10.0f;
            if(g_fPointSize > 70.0f)
                g_fPointSize = 2.0f;
        }

        xinpstatelast = xinpstate;
    }
}

//=========================================================================
// Initialize d3d and a bunch of renderstates
//=========================================================================
BOOL InitD3D(HWND hWnd)
{
    D3DPRESENT_PARAMETERS d3dpp;

    // Create D3D 8.
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    if(pD3D == NULL)
        return FALSE;

    // Set the screen mode.
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_R5G6B5;
    d3dpp.BackBufferCount           = 1;
    d3dpp.Windowed                  = FALSE;   // Must be FALSE for Xbox.
    d3dpp.EnableAutoDepthStencil    = TRUE;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D16;
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz= 60;
    d3dpp.hDeviceWindow             = hWnd;
    d3dpp.Flags                     = D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;

    // Create the device.
    HRESULT hr = pD3D->CreateDevice
    (
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        hWnd,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        &pDev
    );
    if(hr != S_OK)
        return FALSE;

    CheckHR(pDev->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &g_pBackBuffer));

    D3DXVECTOR3 g_vEye(0.0f, 2.0f, 8.0f);
    D3DXVECTOR3 g_vAt(0.0f, 1.0f, 0.0f);
    D3DXVECTOR3 g_vUp(0.0f, 1.0f, 0.0f);

    D3DXMATRIX matView;
    D3DXMatrixLookAtLH(&matView, &g_vEye, &g_vAt, &g_vUp);
    pDev->SetTransform(D3DTS_VIEW, &matView);

    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH(&matProj,
                              D3DX_PI * 40.0f / 180.0f,
                              640.0f  / 480.0f,
                              0.5f, 40.0f);
    pDev->SetTransform(D3DTS_PROJECTION, &matProj);

    static const char *circles[] =
    {
        "....xxxx....",
        "..xxxxxxxx..",
        ".xxxxxxxxxx.",
        ".xxx....xxx.",
        "xxx......xxx",
        "xxx......xxx",
        "xxx......xxx",
        "xxx......xxx",
        ".xxx....xxx.",
        ".xxxxxxxxxx.",
        "..xxxxxxxx..",
        "....xxxx....",
        NULL
    };
    g_pFloorTex = CreateTexture(16, 16, circles);

    static const char *happyAndrew[] =
    {
        "....xxxx....",
        "..xxxxxxxx..",
        ".xxx....xxx.",
        ".xx..xx..xx.",
        "xx..xxxx..xx",
        "xxxxx..xxxxx",
        "xxxxx..xxxxx",
        "xxxxxxxxxxxx",
        ".xx..xx..xx.",
        ".xx..xx..xx.",
        "..xxxxxxxx..",
        "....xxxx....",
        NULL
    };
    g_pSpriteTex = CreateTexture(16, 16, happyAndrew);

    CheckHR(pDev->SetRenderState(D3DRS_LIGHTING, FALSE));
    CheckHR(pDev->SetRenderState(D3DRS_ZENABLE, TRUE));

    CheckHR(pDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_ADD));
    CheckHR(pDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE));
    CheckHR(pDev->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TEXTURE));

    CheckHR(pDev->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE));
    CheckHR(pDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE));
    CheckHR(pDev->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TEXTURE));

    CheckHR(pDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_CW));

    // create our points
    makePointList();

    // create floor
    DWORD color = 0;//D3DCOLOR_COLORVALUE(0.5f, 1.0f, 0f, 1.0f);
    color = D3DCOLOR_COLORVALUE(0, 0, .5f, 1.0f);

    // center point
    g_floorverts[0].sx = 0.0;
    g_floorverts[0].sy = -0.05f;
    g_floorverts[0].sz = 0.0;
    g_floorverts[0].color = color;
    g_floorverts[0].tu = 0.0;
    g_floorverts[0].tv = 0.0;

    // create fan around center point
    int ivert = 1;
    float angle = 0;
    for(ivert = 1; ivert < g_cfloorverts; ivert++)
    {
        g_floorverts[ivert].sx = cosf(angle) * g_fRadius;
        g_floorverts[ivert].sy = -0.05f;
        g_floorverts[ivert].sz = sinf(angle) * g_fRadius;

        g_floorverts[ivert].color = color;
        g_floorverts[ivert].tu = cosf(angle) * g_fRadius;
        g_floorverts[ivert].tv = sinf(angle) * g_fRadius;
        angle += 2 * D3DX_PI / (g_cfloorverts - 2);
    }

    // No longer need the D3D interface so free it.
    pD3D->Release();

    g_hInpDevice = XInputOpen(XDEVICE_TYPE_GAMEPAD, 0, XDEVICE_NO_SLOT, NULL);
    return TRUE;
}

//=========================================================================
// Whack all our alloc'd stuff
//=========================================================================
void DeinitD3D()
{
    if(g_pFloorTex)
        g_pFloorTex->Release();
    if(g_pSpriteTex)
        g_pSpriteTex->Release();
    if(g_pBackBuffer)
        g_pBackBuffer->Release();
    if(pDev)
        pDev->Release();

    XInputClose(g_hInpDevice);
    g_hInpDevice = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\pshader\xbox\makefile.inc ===
pshader.xpu: ..\pshader.psh
    xsasm ..\pshader.psh
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\psprite\sources.inc ===
TARGETNAME=psprite
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    main.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\pshader\main.cpp ===
#include <xtl.h>
#include <tchar.h>
#include <xgraphics.h>

// model types
#define MT_QUAD     0
#define MT_CYLINDER 1
#define MT_MAX      2

// rendering types
#define RT_TEXTURE  0
#define RT_LIT      1
#define RT_SHADER1  2
#define RT_SHADER2  3
#define RT_MAX      4


//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
LPDIRECT3D8             g_pD3D       = NULL; // Used to create the D3DDevice
LPDIRECT3DDEVICE8       g_pd3dDevice = NULL; // Our rendering device

UINT                    g_SelectedModel = MT_CYLINDER;  // displayed model
BOOL                    g_bRSelectUp = TRUE; // model select button release
UINT                    g_SelectedRenderer = RT_SHADER1;  // render type
BOOL                    g_bLSelectUp = TRUE; // renderer select button release
BOOL                    g_bDumpImage = FALSE; // dump an image to disk
BOOL                    g_bDumpImageUp = TRUE; // button is released
BOOL                    g_bDoParameterTest = FALSE; // do bad parameter test

LPDIRECT3DVERTEXBUFFER8 g_pCylinderVB = NULL; // Buffer for cylinder vertices
LPDIRECT3DVERTEXBUFFER8 g_pQuadVB = NULL;     // Buffer for quad vertices
LPDIRECT3DINDEXBUFFER8  g_pIndicesIB = NULL;  // index buffer for quad
LPDIRECT3DTEXTURE8      g_pPShaderTexture0 = NULL;
LPDIRECT3DTEXTURE8      g_pPShaderTexture1 = NULL;
LPDIRECT3DTEXTURE8      g_pPShaderTexture2 = NULL;

DWORD                   g_PShader1 = 0; // handle for pixel shader 1
DWORD                   g_PShader2 = 0; // handle for pixel shader 2

DWORD                   g_VertexShader = 0; // handle for vertex shader

struct CUSTOMVERTEX
{
    D3DXVECTOR3 position; // The position
    D3DXVECTOR3 normal;   // The vertex normals
    D3DCOLOR    color;    // The color
    FLOAT       tu0, tv0;   // Texture 0 coordinates
    FLOAT       tu1, tv1;   // Texture 1 coordinates
    FLOAT       tu2, tv2;   // Texture 2 coordinates
};

// Our custom FVF, which describes our custom vertex structure
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE|D3DFVF_TEX1|D3DFVF_TEX2|D3DFVF_TEX3)

HANDLE  g_hDevice = 0;      // handle of the gamepad
D3DXMATRIX matObject;       // transform matrix for the object
D3DXMATRIX matLight;        // transform matrix for the light
BOOL bWireFrame = FALSE;    // wireframe flag
FLOAT EyeScale = 1.0;       // scale of viewing distance

//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes Direct3D
//-----------------------------------------------------------------------------
HRESULT InitD3D()
{
    // Create the D3D object.
    if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        return E_FAIL;

    // Set up the structure used to create the D3DDevice.
    D3DPRESENT_PARAMETERS d3dpp; 
    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.BackBufferWidth        = 640;
    d3dpp.BackBufferHeight       = 480;
    d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    d3dpp.BackBufferCount        = 1;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;
    d3dpp.MultiSampleType        = D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN;

    // Create the Direct3D device.
    if( FAILED( g_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
                                      D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                      &d3dpp, &g_pd3dDevice ) ) )
        return E_FAIL;

    // Turn off culling
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    // Turn off D3D lighting
    g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    
    // Turn on the zbuffer
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );

    // initialize globals
    D3DXMatrixIdentity(&matObject);
    D3DXMatrixIdentity(&matLight);
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitGeometry()
// Desc: Creates the scene geometry
//-----------------------------------------------------------------------------
HRESULT InitGeometry()
{
    // Create pixel shader 1

/*
    D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );
 
    psd.PSConstant0[0] = 0xffff00ff;
    psd.PSFinalCombinerConstant0 = 0xffff00ff;
    psd.PSCombinerCount = PS_COMBINERCOUNT(
        2, 
        PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes = PS_TEXTUREMODES(
        PS_TEXTUREMODES_PROJECT2D,
        PS_TEXTUREMODES_PROJECT2D,
        PS_TEXTUREMODES_PROJECT2D,
        PS_TEXTUREMODES_NONE);
    
    psd.PSRGBInputs[0] = PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_RGB,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB,
        PS_REGISTER_ZERO,
        PS_REGISTER_ZERO);
    psd.PSAlphaInputs[0] = PS_COMBINERINPUTS(
        PS_REGISTER_T2 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_BLUE,
        PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_INVERT,
        PS_REGISTER_ZERO,
        PS_REGISTER_ZERO);
    psd.PSRGBOutputs[0] = PS_COMBINEROUTPUTS(
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY);
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY);
    
    psd.PSRGBInputs[1] = PS_COMBINERINPUTS(
        PS_REGISTER_T0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
        PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_INVERT | PS_CHANNEL_RGB,
        PS_REGISTER_T1 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
        PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_INVERT | PS_CHANNEL_RGB);
    psd.PSAlphaInputs[1] = PS_COMBINERINPUTS(
        PS_REGISTER_ZERO,
        PS_REGISTER_ZERO,
        PS_REGISTER_ZERO,
        PS_REGISTER_ZERO);
    psd.PSRGBOutputs[1] = PS_COMBINEROUTPUTS(
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_REGISTER_R0 | PS_CHANNEL_RGB,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_MUX);
    psd.PSAlphaOutputs[1] = PS_COMBINEROUTPUTS(
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY);
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS(
        PS_REGISTER_ZERO,
        PS_REGISTER_R0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO);
    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS(
        PS_REGISTER_ZERO,
        PS_REGISTER_ZERO,
        PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_INVERT,    // opaque output
        0);
*/

D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );
psd.PSCombinerCount=PS_COMBINERCOUNT(
    2,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_NONE);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_EXPAND_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_BLUE | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_EXPAND_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0]=00000000;
psd.PSConstant1[0]=00000000;

//------------- Stage 1 -------------
psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_EXPAND_NEGATE,
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_EXPAND_NEGATE);
psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_EXPAND_NEGATE,
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_EXPAND_NEGATE);
psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_MUX);
psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_MUX);
psd.PSConstant0[1]=00000000;
psd.PSConstant1[1]=00000000;

//------------- FinalCombiner -------------
psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    0 | 0 | 0);

psd.PSC0Mapping = 00000000;
psd.PSC1Mapping = 00000000;

    if( FAILED( g_pd3dDevice->CreatePixelShader(&psd, &g_PShader1)))
    {
        OutputDebugString( L"Could not create pixel shader 1\n");
        return E_FAIL;
    }

    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD BytesRead;

    hFile = CreateFile("D:\\media\\pshader.xpu",
                       GENERIC_READ, 
                       0, 
                       NULL, 
                       OPEN_EXISTING, 
                       0, 
                       NULL);
    
    if(INVALID_HANDLE_VALUE == hFile)
    {
        WCHAR buf2[256];
        swprintf(buf2, L"Unable to open file:  error %x\n", GetLastError());
        OutputDebugString(buf2);
        return E_FAIL;
    }
    
    D3DPIXELSHADERDEF_FILE psdf;
    ReadFile(hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &BytesRead, NULL);
    CloseHandle(hFile); // finished reading shader

    if(BytesRead != sizeof(D3DPIXELSHADERDEF_FILE) || psdf.FileID != D3DPIXELSHADERDEF_FILE_ID)
    {
        OutputDebugString( L"Invalid pixel shader file\n");
        return E_FAIL;
    }

    if( FAILED( g_pd3dDevice->CreatePixelShader(&(psdf.Psd), &g_PShader2)))
    {
        OutputDebugString( L"Could not create pixel shader 2\n");
        return E_FAIL;
    }


    hFile = CreateFile("D:\\media\\pshader.xvu",
                       GENERIC_READ, 
                       0, 
                       NULL, 
                       OPEN_EXISTING, 
                       0, 
                       NULL);
    
    if(INVALID_HANDLE_VALUE == hFile)
    {
        WCHAR buf2[256];
        swprintf(buf2, L"Unable to open file:  error %x\n", GetLastError());
        OutputDebugString(buf2);
        return E_FAIL;
    }
    
    // Allocate memory to read the vertex shader file
    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize+4];
    if( NULL == pData )
        return E_FAIL;
    ZeroMemory( pData, dwSize+4 );

    // Read the pre-compiled vertex shader microcode
    ReadFile( hFile, pData, dwSize, &BytesRead, NULL );
    CloseHandle(hFile); // finished reading shader

    DWORD dwVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),                // This data comes from stream 0
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),   // v0 = Position of first mesh
        D3DVSD_REG( 1, D3DVSDT_FLOAT3 ),   // v1 = Normal
        D3DVSD_REG( 2, D3DVSDT_D3DCOLOR ), // v2 = Diffuse color
        D3DVSD_REG( 3, D3DVSDT_FLOAT2 ),   // v3 = Tex coord 0
        D3DVSD_REG( 4, D3DVSDT_FLOAT2 ),   // v4 = Tex coord 1
        D3DVSD_REG( 5, D3DVSDT_FLOAT2 ),   // v5 = Tex coord 2
        D3DVSD_END()
    };

    // Create the vertex shader
    if(FAILED(g_pd3dDevice->CreateVertexShader( dwVertexDecl, (const DWORD*)pData,
                                                &g_VertexShader, 0 )))
    {
        OutputDebugString( L"Could not create vertex shader\n");
        return E_FAIL;
    }

    
    
    // Use D3DX to create a texture from a file
    if( FAILED( D3DXCreateTextureFromFile( g_pd3dDevice, "D:\\MEDIA\\pshader0.bmp",
                                           &g_pPShaderTexture0 ) ) )
    {
        OutputDebugString( L"Could not load texture pshader0.bmp\n" );
        return E_FAIL;
    }
    if( FAILED( D3DXCreateTextureFromFile( g_pd3dDevice, "D:\\MEDIA\\pshader1.bmp",
                                           &g_pPShaderTexture1 ) ) )
    {
        OutputDebugString( L"Could not load texture pshader1.bmp\n" );
        return E_FAIL;
    }
    if( FAILED( D3DXCreateTextureFromFile( g_pd3dDevice, "D:\\MEDIA\\pshader2.bmp",
                                           &g_pPShaderTexture2 ) ) )
    {
        OutputDebugString( L"Could not load texture pshader2.bmp\n" );
        return E_FAIL;
    }

    
    /* Initialize the Quad */

    if( FAILED( g_pd3dDevice->CreateVertexBuffer( 5*sizeof(CUSTOMVERTEX),
                                                  0, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_DEFAULT, &g_pQuadVB ) ) )
        return E_FAIL;

    CUSTOMVERTEX *pVertices;

    if( FAILED( g_pQuadVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
        return E_FAIL;

    pVertices[0].position = D3DXVECTOR3(  0.0f, 0.0f, 0.0f );
    pVertices[0].color    = 0xffffff00;
    pVertices[0].tu0      = 0.5;
    pVertices[0].tv0      = 0.5;
    pVertices[0].tu1      = 0.5;
    pVertices[0].tv1      = 0.5;
    pVertices[0].tu2      = 0.5;
    pVertices[0].tv2      = 0.5;
    pVertices[0].normal   = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );

    pVertices[4].position = D3DXVECTOR3(  1.0f, -1.0f, 0.0f );
    pVertices[4].color    = 0xff00ff00;
    pVertices[4].tu0      = 1.0;
    pVertices[4].tv0      = 1.0;
    pVertices[4].tu1      = 1.0;
    pVertices[4].tv1      = 1.0;
    pVertices[4].tu2      = 1.0;
    pVertices[4].tv2      = 1.0;
    pVertices[4].normal   = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );

    pVertices[1].position = D3DXVECTOR3(  1.0f,  1.0f, 0.0f );
    pVertices[1].color    = 0xff0000ff;
    pVertices[1].tu0      = 1.0;
    pVertices[1].tv0      = 0.0;
    pVertices[1].tu1      = 1.0;
    pVertices[1].tv1      = 0.0;
    pVertices[1].tu2      = 1.0;
    pVertices[1].tv2      = 0.0;
    pVertices[1].normal   = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );

    pVertices[3].position = D3DXVECTOR3( -1.0f, -1.0f, 0.0f );
    pVertices[3].color    = 0xffff0000;
    pVertices[3].tu0      = 0.0;
    pVertices[3].tv0      = 1.0;
    pVertices[3].tu1      = 0.0;
    pVertices[3].tv1      = 1.0;
    pVertices[3].tu2      = 0.0;
    pVertices[3].tv2      = 1.0;
    pVertices[3].normal   = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );

    pVertices[2].position = D3DXVECTOR3( -1.0f,  1.0f, 0.0f );
    pVertices[2].color    = 0xffffffff;
    pVertices[2].tu0      = 0.0;
    pVertices[2].tv0      = 0.0;
    pVertices[2].tu1      = 0.0;
    pVertices[2].tv1      = 0.0;
    pVertices[2].tu2      = 0.0;
    pVertices[2].tv2      = 0.0;
    pVertices[2].normal   = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
    
    g_pQuadVB->Unlock();


    // Create the index buffer and fill it
    g_pd3dDevice->CreateIndexBuffer( 12*sizeof(WORD),
                                     D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, 
                                     D3DPOOL_MANAGED, &g_pIndicesIB );
    WORD* pIndices;
    g_pIndicesIB->Lock( 0, 0, (BYTE**)&pIndices, 0 );
    pIndices[ 0] = 0;
    pIndices[ 1] = 1;
    pIndices[ 2] = 2;
    pIndices[ 3] = 0;
    pIndices[ 4] = 2;
    pIndices[ 5] = 3;
    pIndices[ 6] = 0;
    pIndices[ 7] = 3;
    pIndices[ 8] = 4;
    pIndices[ 9] = 0;
    pIndices[10] = 4;
    pIndices[11] = 1;
    g_pIndicesIB->Unlock();

    /* Initialize the Cylinder */
    // Create the vertex buffer.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( 50*2*sizeof(CUSTOMVERTEX),
                                                  0, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_DEFAULT, &g_pCylinderVB ) ) )
        return E_FAIL;

    // Fill the vertex buffer. We are setting the tu and tv texture
    // coordinates, which range from 0.0 to 1.0
    if( FAILED( g_pCylinderVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
        return E_FAIL;
    for( DWORD i=0; i<50; i++ )
    {
        FLOAT theta = (2*D3DX_PI*i)/(50-1);

        pVertices[2*i+0].position = D3DXVECTOR3( sinf(theta),-1.2f, cosf(theta) );
        pVertices[2*i+0].color    = 0xffffffff;
        pVertices[2*i+0].tu0      = ((FLOAT)i*2.0f)/(50-1);
        pVertices[2*i+0].tv0      = 1.0f;
        pVertices[2*i+0].tu1      = ((FLOAT)i*2.0f)/(50-1);
        pVertices[2*i+0].tv1      = 1.0f;
        pVertices[2*i+0].tu2      = ((FLOAT)i*2.0f)/(50-1);
        pVertices[2*i+0].tv2      = 1.0f;
        pVertices[2*i+0].normal   = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) );

        pVertices[2*i+1].position = D3DXVECTOR3( sinf(theta), 1.2f, cosf(theta) );
        pVertices[2*i+1].color    = 0xff808080;
        pVertices[2*i+1].tu0      = ((FLOAT)i*2.0f)/(50-1);
        pVertices[2*i+1].tv0      = 0.0f;
        pVertices[2*i+1].tu1      = ((FLOAT)i*2.0f)/(50-1);
        pVertices[2*i+1].tv1      = 0.0f;
        pVertices[2*i+1].tu2      = ((FLOAT)i*2.0f)/(50-1);
        pVertices[2*i+1].tv2      = 0.0f;
        pVertices[2*i+1].normal   = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) );
    }
    g_pCylinderVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetupMatrices()
// Desc: Sets up the world, view, and projection transform matrices.
//-----------------------------------------------------------------------------
VOID SetupMatrices(BOOL bIdent)
{
    CONST D3DXMATRIX *pmatWorld;
    // set object transform
    if(bIdent)
    {
        D3DXMATRIX matIdentity;
        D3DXMatrixIdentity(&matIdentity);
        pmatWorld = &matIdentity;
    }
    else
        pmatWorld = &matObject;
        
    g_pd3dDevice->SetTransform( D3DTS_WORLD, pmatWorld );

    // Set up our view matrix. A view matrix can be defined given an eye point,
    // a point to lookat, and a direction for which way is up. Here, we set the
    // eye five units back along the z-axis and up three units, look at the
    // origin, and define "up" to be in the y-direction.
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f*EyeScale, 3.0f*EyeScale,-5.0f*EyeScale ),
                                  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ),
                                  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
    g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // For the projection matrix, we set up a perspective transform (which
    // transforms geometry from 3D view space to 2D viewport space, with
    // a perspective divide making objects smaller in the distance). To build
    // a perpsective transform, we need the field of view (1/4 pi is common),
    // the aspect ratio, and the near and far clipping planes (which define at
    // what distances geometry should be no longer be rendered).
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 1.0f, 1.0f, 100.0f );
    g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set the transform matrices
    D3DXMATRIX matW, matWV, matWVP;
    D3DXMatrixMultiply( &matWV,  pmatWorld, &matView );
    D3DXMatrixMultiply( &matWVP, &matWV, &matProj );
    D3DXMatrixTranspose( &matWVP, &matWVP );
    g_pd3dDevice->SetVertexShaderConstant( 10, &matWVP, 4 );
    
    float cnst1[4] = {1.0, 1.0, 1.0, 1.0};
    g_pd3dDevice->SetVertexShaderConstant( 1, cnst1, 1);
    float cnst2[4] = {2.0, 2.0, 2.0, 2.0};
    g_pd3dDevice->SetVertexShaderConstant( 2, cnst2, 1);
}




//-----------------------------------------------------------------------------
// Name: SetupLights()
// Desc: Sets up the lights for the scene.
//-----------------------------------------------------------------------------
VOID SetupLights()
{
    // Set up a material. The material here just has the diffuse and ambient
    // colors set to yellow. Note that only one material can be used at a time.
    D3DMATERIAL8 mtrl;
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = 1.0f;
    mtrl.Diffuse.g = mtrl.Ambient.g = 1.0f;
    mtrl.Diffuse.b = mtrl.Ambient.b = 0.0f;
    mtrl.Diffuse.a = mtrl.Ambient.a = 1.0f;
    g_pd3dDevice->SetMaterial( &mtrl );

    // Direction vector for the light
	D3DXVECTOR3 vDirection( 0.7f, 0.14f, 0.7f );
    D3DXVec3TransformNormal( &vDirection, &vDirection, &matLight );

	// The light structure
    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type       = D3DLIGHT_DIRECTIONAL;
    light.Diffuse.r  = 1.0f;
    light.Diffuse.g  = 1.0f;
    light.Diffuse.b  = 1.0f;
	light.Direction  = vDirection;
    light.Range      = 1000.0f;
    g_pd3dDevice->SetLight( 0, &light );
    g_pd3dDevice->LightEnable( 0, TRUE );
    
	// When using lights, we must turn lighting on
	g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );

    // Finally, turn on some ambient light.
    g_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0x00303030 );
}

//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Draws the scene
//-----------------------------------------------------------------------------
VOID Render()
{
    // Clear the backbuffer and the zbuffer
    g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         D3DCOLOR_XRGB(20,20,30), 1.0f, 0 );

    // Begin the scene
    g_pd3dDevice->BeginScene();

    // set default state
    // disable any previous textures
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    // disable lighting
    g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    // remove any pixel shaders
    g_pd3dDevice->SetPixelShader( NULL );
    
    // Setup the world, view, and projection matrices
    SetupMatrices(FALSE);

    if(g_bDoParameterTest)
    {
        // set pixel shader renderstates with random values and make 
        // sure that the chip doesn't choke
        OutputDebugString(L"Beginning parameter test\n");
        g_pd3dDevice->SetPixelShader( g_PShader1 );
        while(1)
        {
            static DWORD mode=0;
            static DWORD offset=0;
            static DWORD value=1;
            switch(mode)
            {
            case 2:
                offset = rand() % 57; // 57 dwords in pixel shader definition
                value = ((rand() >> 8) & 0xff) |
                        (((rand() >> 8) & 0xff) <<  8) |
                        (((rand() >> 8) & 0xff) << 16) |
                        (((rand() >> 8) & 0xff) << 24);
                    break;

            }
            WCHAR buf[256];
            swprintf(buf, L"RS %d: %08x\n", offset, value);
            OutputDebugString(buf);
            g_pd3dDevice->SetRenderState((D3DRENDERSTATETYPE)(D3DRS_PSALPHAINPUTS0+offset), value);

            switch(mode)
            {
            case 0:
                offset++;
                if(offset == 57)
                {
                    offset = 0;
                    if(value == 0)
                    {
                        mode++;
                        value = 1;
                    }
                    else
                        value = value << 1;
                }
                break;
            case 1:
                offset++;
                if(offset == 57)
                {
                    offset = 0;
                    if(value == 0x0)
                    {
                        mode++;
                        value = 1;
                    }
                    else
                    {
                        if(value & 0x80000000)
                            value = (value << 1);
                        else
                            value = (value << 1) | 0x1;
                    }
                }
                break;
            }
        }
    }
    static FLOAT fXoff = 0.0;
    static FLOAT fYoff = 0.0;
    D3DXMATRIX matTex;
    
    switch(g_SelectedRenderer)
    {
    case RT_TEXTURE:
        // Setup our texture. Using textures introduces the texture stage states,
        // which govern how textures get blended together (in the case of multiple
        // textures) and lighting information. In this case, we are modulating
        // (blending) our texture with the diffuse color of the vertices.
        g_pd3dDevice->SetTexture( 0, g_pPShaderTexture0 );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
        
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
        break;
    
    case RT_LIT:
        // Setup the lights
        SetupLights();
        break;

    case RT_SHADER1:
        g_pd3dDevice->SetTexture( 0, g_pPShaderTexture0 );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetTexture( 1, g_pPShaderTexture1 );
        g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetTexture( 2, g_pPShaderTexture2 );
        g_pd3dDevice->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetTextureStageState( 2, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 );
        D3DXMatrixRotationYawPitchRoll(&matTex, fXoff, fYoff, 0.0);
        g_pd3dDevice->SetTransform( D3DTS_TEXTURE2, &matTex );
        fXoff += 0.01f;
        fYoff += 0.005f;

        // install pixel shader
        g_pd3dDevice->SetPixelShader( g_PShader1 );
        break;

    case RT_SHADER2:
        static FLOAT color[] = {0.0, 0.0, 0.0, 1.0};
        g_pd3dDevice->SetTexture( 0, g_pPShaderTexture0 );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetTexture( 1, g_pPShaderTexture1 );
        g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetTexture( 2, g_pPShaderTexture2 );
        g_pd3dDevice->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetTextureStageState( 2, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 );
        D3DXMatrixRotationYawPitchRoll(&matTex, fXoff, fYoff, 0.0);
        g_pd3dDevice->SetTransform( D3DTS_TEXTURE2, &matTex );
        fXoff += 0.01f;
        fYoff += 0.005f;

        // install pixel shader
        g_pd3dDevice->SetPixelShader( g_PShader2 );
        //g_pd3dDevice->SetPixelShaderConstant(0, color, 1);
        color[0] += 0.01F;
        color[1] += 0.037F;
        color[2] += 0.045F;
        if(color[0] > 1.0) color[0] -= 1.0;
        if(color[1] > 1.0) color[1] -= 1.0;
        if(color[2] > 1.0) color[2] -= 1.0;
        break;

    }
    
    switch(g_SelectedModel)
    {
    case MT_CYLINDER:
        // Render the cylinder
        g_pd3dDevice->SetStreamSource( 0, g_pCylinderVB, sizeof(CUSTOMVERTEX) );
//        g_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
        g_pd3dDevice->SetVertexShader( g_VertexShader );
        g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2*50-2 );
        break;

    case MT_QUAD:
        // Render the quad
        g_pd3dDevice->SetStreamSource( 0, g_pQuadVB, sizeof(CUSTOMVERTEX) );
        g_pd3dDevice->SetIndices( g_pIndicesIB, 0 );
//        g_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
        g_pd3dDevice->SetVertexShader( g_VertexShader );
        g_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, 5, 0, 4 );
        break;
    }

    // End the scene
    g_pd3dDevice->EndScene();

    if(g_bDumpImage)
    {
        static char filename[]="D:\\media\\Image000.bmp";
        IDirect3DSurface8 *pBackBuffer;
        g_pd3dDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer);
        XGWriteSurfaceToFile(pBackBuffer, filename);
        pBackBuffer->Release();
        // increment filename
        if(filename[16] == '9')
        {
            filename[16] = '0';
            if(filename[15] == '9')
            {
                filename[15] = '0';
                if(filename[14] == '9')
                {
                    filename[14] = '0';
                }
                else
                    filename[14]++;
            }
            else
                filename[15]++;
        }
        else
            filename[16]++;

        g_bDumpImage = FALSE;   // only a single write per button push
    }

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
}



void GetInput(void)
{
    DWORD dwInsertions, dwRemovals;
    
    //
    //  Check to see if a port 0 gamepad has come or gone.
    //
    if(XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals))
    {
        if(dwRemovals&XDEVICE_PORT0_MASK)
        {
            if(g_hDevice)
            {
                XInputClose(g_hDevice);
                g_hDevice = NULL;
            }
        }
        if(dwInsertions&XDEVICE_PORT0_MASK)
        {
            g_hDevice = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL);
        }
    }

    // If we have a device, get its state.
    if (g_hDevice)
    {
        XINPUT_STATE InputState;

        XInputGetState(g_hDevice, &InputState);

        FLOAT dxRot, dyRot, dzRot;
        D3DXMATRIX matTmp;
		
        // calculate object transform
        static FLOAT objXRot=0;
        static FLOAT objYRot=0;
        static FLOAT objZRot=0;
        
        if(InputState.Gamepad.wButtons & XINPUT_GAMEPAD_START)
        {
            // reset object position
            objXRot = objYRot = objZRot = 0.0;
        }
        else
        {
            if(fabs((FLOAT)InputState.Gamepad.sThumbLY) > 10000.0)
                dxRot = (FLOAT)InputState.Gamepad.sThumbLY/(float)32768.0;
            else
                dxRot = 0.0;
            if(InputState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT)
                dyRot =  0.75;
            else if(InputState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)
                dyRot = -0.75;
            else
                dyRot = 0.0;
            if(fabs((FLOAT)InputState.Gamepad.sThumbLX) > 10000.0)
                dzRot = (FLOAT)InputState.Gamepad.sThumbLX/(float)32768.0;
            else
                dzRot = 0.0;
            objXRot += dxRot*3.1415926F/75.0F;  // these scaling factors can be changed 
            objYRot += dyRot*3.1415926F/75.0F;  // these scaling factors can be changed 
            objZRot -= dzRot*3.1415926F/75.0F;  // these scaling factors can be changed 
        }

        D3DXMatrixRotationX(&matObject, objXRot);   // start with X rotation
        D3DXMatrixRotationY(&matTmp, objYRot);
        D3DXMatrixMultiply(&matObject, &matTmp, &matObject);    // include Y rotation
        D3DXMatrixRotationZ(&matTmp, objZRot);
        D3DXMatrixMultiply(&matObject, &matTmp, &matObject);    // include Z rotation
    
        // calculate light transform
        static FLOAT lightXRot=0;
        static FLOAT lightYRot=0;
        static FLOAT lightZRot=0;
        
        if(InputState.Gamepad.wButtons & XINPUT_GAMEPAD_START)
        {
            // reset light position
            lightXRot = lightYRot = lightZRot = 0.0;
        }
        else
        {
            dxRot = (FLOAT)InputState.Gamepad.sThumbRY/(float)32768.0;
            dyRot = 0.0;
            dzRot = (FLOAT)InputState.Gamepad.sThumbRX/(float)32768.0;
            lightXRot += dxRot*3.1415926F/75.0F;  // these scaling factors can be changed 
            lightYRot += dyRot*3.1415926F/75.0F;  // these scaling factors can be changed 
            lightZRot -= dzRot*3.1415926F/75.0F;  // these scaling factors can be changed 
        }

        D3DXMatrixRotationX(&matLight, lightXRot);   // start with X rotation
        D3DXMatrixRotationY(&matTmp, lightYRot);
        D3DXMatrixMultiply(&matLight, &matTmp, &matLight);    // include Y rotation
        D3DXMatrixRotationZ(&matTmp, lightZRot);
        D3DXMatrixMultiply(&matLight, &matTmp, &matLight);    // include Z rotation

        // check for eye vector scale
        if(InputState.Gamepad.wButtons & XINPUT_GAMEPAD_START)
            EyeScale = 1.0f;
        else if(InputState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
            EyeScale = EyeScale/1.01f;
        else if(InputState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN)
            EyeScale *= 1.01f;

        // check for wireframe toggle
        if(InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] != 0)
            g_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_WIREFRAME );
        else
            g_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );

        // check to see if we need to change models next frame
        if(InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] != 0)
        {
            if(g_bRSelectUp) // button was previously up
            {
                g_bRSelectUp = FALSE;
                g_SelectedModel++;
                if(g_SelectedModel == MT_MAX)
                    g_SelectedModel = 0;
            }
        }
        else
            g_bRSelectUp = TRUE;

        // check to see if we need to change rendering type next frame
        if(InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] != 0)
        {
            if(g_bLSelectUp) // button was previously up
            {
                g_bLSelectUp = FALSE;
                g_SelectedRenderer++;
                if(g_SelectedRenderer == RT_MAX)
                    g_SelectedRenderer = 0;
            }
        }
        else
            g_bLSelectUp = TRUE;

        // check to see if we need to dump an image
        if((InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] != 0) && g_bDumpImageUp)
        {
            g_bDumpImage = TRUE;
            g_bDumpImageUp = FALSE;
        }
        else if(InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] == 0)
            g_bDumpImageUp = TRUE;

        // check to see if we need to go into parameter test mode
        if(InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] != 0)
            g_bDoParameterTest = TRUE;

    }
}

//-----------------------------------------------------------------------------
// Name: main()
// Desc: The application's entry point
//-----------------------------------------------------------------------------
void __cdecl main()
{
    OutputDebugString( L"### Beginning PShader.xbe ###\n" );
    

/*
    _asm nop;
    _asm int 3;
    _asm nop;
*/
    //Initialize core peripheral port support
    XInitDevices(0,NULL);

    // Initialize Direct3D
    if( FAILED( InitD3D() ) )
		return;

    // Initialize the gamepad
    if(XDEVICE_PORT0_MASK & XGetDevices(XDEVICE_TYPE_GAMEPAD))
    {
        g_hDevice = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL);
    }

    // Create the geometry
    if( FAILED( InitGeometry() ) )
		return;

	// Enter the render loop
    while( TRUE )
    {
        GetInput();
        Render();
        Sleep(10);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\regress\precomp.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       precomp.hpp
 *  Content:    Common include file
 *
 ***************************************************************************/
 
#include <stddef.h>
#include <stdio.h>

extern "C"
{
    #include <ntos.h>
    #include <nturtl.h>
    #include <av.h>
};

#include <xtl.h>
#include <xgraphics.h>
#include "regress.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\pshader\sources.inc ===
TARGETNAME=PShader
TARGETPATH=obj
TARGETTYPE=PROGRAM

NTTARGETFILE0=pshader.xpu

SOURCES= \
    main.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\regress\leaks.cpp ===
/*==========================================================================;
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       leaks.cpp
 *  Content:    Tests for leaks
 *
 ***************************************************************************/
 
#include "precomp.hpp" 

D3DFORMAT g_BackBufferFormats[] =
{
    D3DFMT_X8R8G8B8,
    D3DFMT_A8R8G8B8,
    D3DFMT_R5G6B5,
    D3DFMT_X1R5G5B5,
};

D3DFORMAT g_DepthFormats[] =
{
    D3DFMT_D24S8,
    D3DFMT_F24S8,
    D3DFMT_D16,
    D3DFMT_F16,
};

DWORD g_MultisampleTypes[] =
{
    D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR,   
    D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX,   
    D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR,   
    D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR,   
    D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR,   
    D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN,   
    D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR,   
    D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN,   
    D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN,   
    D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN,   
};

DWORD g_BackCounts[] =
{
    0, 1, 2,
};

DWORD g_Intervals[] =
{
    D3DPRESENT_INTERVAL_IMMEDIATE,
    D3DPRESENT_INTERVAL_ONE,
    D3DPRESENT_INTERVAL_TWO,
};

//------------------------------------------------------------------------------
void TestLeaks()
{
    DWORD count;
    IDirect3D8* pD3D;
    IDirect3DDevice8* pDev;
    D3DTexture* pTexture;
    D3DSurface* pTextureSurface;
    D3DSurface* pDepthSurface;
    D3DPalette* pPalette;
    D3DVertexBuffer* pVertexBuffer;
    D3DIndexBuffer* pIndexBuffer;
    DWORD alphaTestEnable;
    DWORD minFilter;
    DWORD texCoordIndex;
    D3DPRESENT_PARAMETERS d3dpp;

    pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    ASSERT(pD3D != NULL);

#if DBG
    ASSERT((D3D__AllocsContiguous == 0) && (D3D__AllocsNoncontiguous == 0));
#endif

    count = 0;

    for (DWORD iReset = FALSE;
         iReset <= TRUE;
         iReset++)
    {
        if (iReset)
        {
            // Create a device using the last presentation parameters used
            // by the non-reset case:

            CheckHR(pD3D->CreateDevice(
                            D3DADAPTER_DEFAULT,
                            D3DDEVTYPE_HAL,
                            NULL,
                            D3DCREATE_HARDWARE_VERTEXPROCESSING,
                            &d3dpp,
                            &pDev));
        }

        for (DWORD iBackBufferFormat = 0; 
             iBackBufferFormat < ARRAYSIZE(g_BackBufferFormats); 
             iBackBufferFormat++)
        {
            for (DWORD iDepthFormat = 0; 
                 iDepthFormat < ARRAYSIZE(g_DepthFormats); 
                 iDepthFormat++)
            {
                for (DWORD iMultisampleType = 0; 
                     iMultisampleType < ARRAYSIZE(g_MultisampleTypes); 
                     iMultisampleType++)
                {
                    for (DWORD iBackCount = 0; 
                         iBackCount < ARRAYSIZE(g_BackCounts); 
                         iBackCount++)
                    {
                        for (DWORD iInterval = 0; 
                             iInterval < ARRAYSIZE(g_Intervals); 
                             iInterval++)
                        {
                            ZeroMemory(&d3dpp, sizeof(d3dpp));
                        
                            d3dpp.BackBufferWidth        = 640;
                            d3dpp.BackBufferHeight       = 480;
                            d3dpp.EnableAutoDepthStencil = true;
                            d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;
                            d3dpp.BackBufferFormat       = g_BackBufferFormats[iBackBufferFormat];
                            d3dpp.BackBufferCount        = g_BackCounts[iBackCount];
                            d3dpp.AutoDepthStencilFormat = g_DepthFormats[iDepthFormat];
                            d3dpp.MultiSampleType        = g_MultisampleTypes[iMultisampleType];
                        
                            count++;
                            if (iReset)
                            {
                                if ((count % 100) == 0)
                                    DbgPrint("Reset: %li\n", count);

                                CheckHR(pDev->Reset(&d3dpp));
                            }
                            else
                            {
                                if ((count % 100) == 0)
                                    DbgPrint("CreateDevice: %li\n", count);

                                CheckHR(pD3D->CreateDevice(
                                                D3DADAPTER_DEFAULT,
                                                D3DDEVTYPE_HAL,
                                                NULL,
                                                D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                                &d3dpp,
                                                &pDev));
                            }
    
                            // Now create and select all the resource types:

                            CheckHR(pDev->CreateImageSurface(1024, 1024, D3DFMT_LIN_F24S8, &pDepthSurface));
                            CheckHR(pDev->CreateTexture(1024, 1024, 1, 0, D3DFMT_A8R8G8B8, 0, &pTexture));
                            CheckHR(pTexture->GetSurfaceLevel(0, &pTextureSurface));
    
                            CheckHR(pDev->SetTexture(0, pTexture));
                            CheckHR(pDev->SetTexture(1, pTexture));
                            CheckHR(pDev->SetTexture(2, pTexture));
                            CheckHR(pDev->SetTexture(3, pTexture));
                            CheckHR(pDev->SetRenderTarget(pTextureSurface, pDepthSurface));
    
                            CheckHR(pDev->CreatePalette(D3DPALETTE_256, &pPalette));
                            CheckHR(pDev->SetPalette(0, pPalette));
                            CheckHR(pDev->SetPalette(1, pPalette));
                            CheckHR(pDev->SetPalette(2, pPalette));
                            CheckHR(pDev->SetPalette(3, pPalette));
    
                            CheckHR(pDev->CreateVertexBuffer(32768, 0, 0, 0, &pVertexBuffer));
                            for (DWORD i = 0; i < 15; i++) // Can't be 16, we'd overflow
                            {
                                CheckHR(pDev->SetStreamSource(i, pVertexBuffer, 32));
                            }
    
                            CheckHR(pDev->CreateIndexBuffer(32768, 0, D3DFMT_INDEX16, 0, &pIndexBuffer));
                            CheckHR(pDev->SetIndices(pIndexBuffer, 0));
    
                            // Do a Present, verifying that some states are preserved across
                            // an FSAA Present call:
    
                            CheckHR(pDev->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE));
                            CheckHR(pDev->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_POINT));
                            CheckHR(pDev->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 3));
                            CheckHR(pDev->Clear(0, NULL, D3DCLEAR_TARGET, 0, 0, 0));
                            CheckHR(pDev->Present(NULL, NULL, NULL, NULL));
                            CheckHR(pDev->GetRenderState(D3DRS_ALPHATESTENABLE, &alphaTestEnable));
                            CheckHR(pDev->GetTextureStageState(0, D3DTSS_MINFILTER, &minFilter));
                            CheckHR(pDev->GetTextureStageState(0, D3DTSS_TEXCOORDINDEX, &texCoordIndex));
    
                            ASSERT((alphaTestEnable == TRUE) && (minFilter == D3DTEXF_POINT) && (texCoordIndex == 3));

                            if (!iReset)
                            {
                                pDev->Release();
                                pDev = NULL;
                            }
    
                            // Now release any created objects:
    
                            pTextureSurface->Release();
                            pTexture->Release();
                            pDepthSurface->Release();
                            pPalette->Release();
                            pVertexBuffer->Release();
                            pIndexBuffer->Release();
    
                            // Finally, assert that everything is back to zero.  
                            // (We can't do this now for the Reset case because
                            // it can have a bunch of frame buffer objects and
                            // stuff active.)
    
                        #if DBG
                            if (!iReset)
                            {
                                ASSERT((D3D__AllocsContiguous == 0) && (D3D__AllocsNoncontiguous == 0));
                            }
                        #endif
                        }
                    }
                }
            }
        }

        if (iReset)
        {
            pDev->Release();
        #if DBG
            ASSERT((D3D__AllocsContiguous == 0) && (D3D__AllocsNoncontiguous == 0));
        #endif
        }
    }

    pD3D->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\psprite\main.cpp ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Complete DX8 application to draw a screen space triangle.

Revision History:

    Derived from a DX8 sample.
--*/

#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#include <d3d8.h>
#include <d3dx8.h>
#endif // XBOX

const GUID DECLSPEC_SELECTANY IID_IUnknown =
{ 0x00000000, 0x0000, 0x0000, { 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 } };

#define timeGetTime GetTickCount
#define g_pd3dDevice pDev

IDirect3DDevice8* pDev  = NULL;

DWORD               g_dwVertexShaderHandle;  // Handle for the vertex shader
LPDIRECT3DTEXTURE8  g_pTexture = NULL;

struct CUSTOMVERTEX
{ 
    FLOAT x,y,z; 
    float size; 
};

CUSTOMVERTEX g_Vertices[] =
{
    { -0.6f, -1.0f, 0.0f, 10.1f, },
    {  0.0f,  1.0f, 0.0f, 30.5f, },
    {  0.6f, -1.0f, 0.0f, 60.9f, },
};

DWORD dwShaderVertexDecl[] =
{
    D3DVSD_STREAM( 0 ),
    D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),    // Position
    D3DVSD_REG( 1, D3DVSDT_FLOAT1 ),    // Point size
    D3DVSD_END()
};

BOOL InitApp()
{
#ifdef XBOX

    // Load the pre-compiled vertex shader microcode
    HANDLE hFile = CreateFileA( "D:\\media\\Shader.xvu", GENERIC_READ, FILE_SHARE_READ, 
                                NULL, OPEN_EXISTING, 
                                FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN, NULL );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        OutputDebugStringA( "ERROR: Could not load the vertex shader!\n" );
        return E_FAIL;
    }

    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize];
    ReadFile( hFile, pData, dwSize, &dwSize, NULL );
    CloseHandle( hFile );

    HRESULT hr = g_pd3dDevice->CreateVertexShader( dwShaderVertexDecl,
                                                   (DWORD*)pData,
                                                   &g_dwVertexShaderHandle, 0 );

    delete pData;

#else // XBOX

    ID3DXBuffer *pShader;
    D3DXAssembleShaderFromFileA("shader.vsh", 0, NULL, &pShader, NULL);

    HRESULT hr = g_pd3dDevice->CreateVertexShader( dwShaderVertexDecl,
                                                   (DWORD*)pShader->GetBufferPointer(),
                                                   &g_dwVertexShaderHandle, 0 );

    pShader->Release();

#endif // XBOX

    if (FAILED(hr))
        return FALSE;

#ifdef XBOX
    D3DXCreateTextureFromFileA(g_pd3dDevice, "D:\\media\\wall.bmp", &g_pTexture);
#else // XBOX
    D3DXCreateTextureFromFileA(g_pd3dDevice, "wall.bmp", &g_pTexture);
#endif // XBOX

    if (g_pTexture == NULL)
        return FALSE;

    return TRUE;
}

VOID Render()
{
    // Clear the backbuffer and the zbuffer
    g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         D3DCOLOR_XRGB(0,0,255), 1.0f, 0 );
    
    // Begin the scene
    g_pd3dDevice->BeginScene();

    // Set state
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, true);
    g_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE, true);

    float size = 40.0f;
    g_pd3dDevice->SetRenderState( D3DRS_POINTSIZE, *((DWORD*)&size));

#ifdef XBOX
    g_pd3dDevice->SetTexture(3, g_pTexture);

    g_pd3dDevice->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(3, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pd3dDevice->SetTextureStageState(3, D3DTSS_COLORARG2, D3DTA_CURRENT);
    g_pd3dDevice->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
#else // XBOX
    g_pd3dDevice->SetTexture(0, g_pTexture);

    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_CURRENT);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
#endif // XBOX

    // Draw the vertices using the vertex shader
    g_pd3dDevice->SetVertexShader( g_dwVertexShaderHandle );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_POINTLIST, 3, g_Vertices, 
                                   sizeof(g_Vertices[0]) );

    // End the scene
    g_pd3dDevice->EndScene();
    
    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
}

VOID FrameMove()
{
    // Rotate around the Y axis
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixRotationX( &matWorld, timeGetTime()/600.0f );

    // Set up our view matrix. A view matrix can be defined given an eye point,
    // a point to lookat, and a direction for which way is up.
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 0.0f,-3.0f ), 
                                  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ), 
                                  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );

    // For the projection matrix, we set up a perspective transform (which
    // transforms geometry from 3D view space to 2D viewport space, with
    // a perspective divide making objects smaller in the distance). To build
    // a perpsective transform, we need the field of view (1/4 pi is common),
    // the aspect ratio, and the near and far clipping planes (which define at
    // what distances geometry should be no longer be rendered).
    D3DXMATRIX matProj;
    float aspectRatio = 480.f / 640.f;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, aspectRatio, 1.0f, 800.0f );

    // Calculate concatenated World x ( View x Projection) matrix.
    // We transpose the matrix at the end because that's how matrix math
    // works in vertex shaders. (Because the vertex shader DP4 operator works on
    // rows, not on columns.)
    D3DXMATRIX mat;
    D3DXMatrixMultiply( &mat, &matView, &matProj );
    D3DXMatrixMultiply( &mat, &matWorld, &mat );
    D3DXMatrixTranspose( &mat, &mat );
    g_pd3dDevice->SetVertexShaderConstant( 0, &mat, 4 );
}

BOOL InitD3D(HWND hWnd)
{
    D3DPRESENT_PARAMETERS d3dpp;
    IDirect3D8 *pD3D;

    // Create D3D 8.
    pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    if (pD3D == NULL)
        return FALSE;

    // Set the screen mode.
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth                 = 640;
    d3dpp.BackBufferHeight                = 480;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 1;
    d3dpp.Windowed                        = FALSE;   // Must be FALSE for Xbox.
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                   = hWnd;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Create the device.

    if (IDirect3D8_CreateDevice(
        pD3D,
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        hWnd,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        &pDev) != S_OK)
    {
        return FALSE;
    }

    // Now we no longer need the D3D interface so lets free it.
    IDirect3D8_Release(pD3D);

    return InitApp();
}

#ifdef XBOX

//-----------------------------------------------------------------------------

void __cdecl main()
{
    if (!InitD3D(NULL))
    {
        return;
    }

    while (TRUE)
    {
        FrameMove();
        Render();
    }
}

#else // XBOX

LRESULT WINAPI MessageHandler(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    if (Msg == WM_DESTROY)
        PostQuitMessage(0);

    return DefWindowProc(hWnd, Msg, wParam, lParam);
}

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    BOOL bQuit = FALSE;
    MSG msg;
    HWND hwnd;

    WNDCLASSEX classex;
    ZeroMemory( &classex, sizeof(classex) );

    classex.cbSize          = sizeof(WNDCLASSEX);
    classex.style           = CS_CLASSDC;
    classex.lpfnWndProc     = MessageHandler;
    classex.hInstance       = hInstance;
    classex.lpszClassName   = L"XBOX";
    RegisterClassEx(&classex);

    hwnd = CreateWindowEx(WS_EX_TOPMOST, L"XBOX", L"XBOX Basic Shell",
                          WS_VISIBLE|WS_POPUP,
                          CW_USEDEFAULT,CW_USEDEFAULT, 0, 0,
                          NULL, NULL, hInstance, NULL);

    if (!InitD3D(hwnd))
    {
        return EXIT_FAILURE;
    }

    ShowCursor(FALSE);

    while (!bQuit)
    {
        while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
        {
            if (!GetMessage(&msg, NULL, 0, 0))
            {
                bQuit = TRUE;
            }

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        FrameMove();
        Render();
    }

    return EXIT_SUCCESS;
}

#endif // XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\regress\pushbuf.cpp ===
/*==========================================================================;
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pushbuf.cpp
 *  Content:    Push-buffer resource regression test 
 *
 ***************************************************************************/
 
#include "precomp.hpp" 
 
IDirect3DVertexBuffer8*    pVertsVB = NULL;
IDirect3DVertexBuffer8*    pRedTriangleVB = NULL;
IDirect3DTexture8*         pTexture = NULL;
DWORD                      VertsShader;
DWORD                      RedTriangleShader;

//------------------------------------------------------------------------------
// Geometry declarations

DWORD VertsShaderDeclaration[] =
{
    D3DVSD_STREAM(0),
    D3DVSD_REG(D3DVSDE_POSITION, D3DVSDT_FLOAT4), 
    D3DVSD_REG(D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2),
    D3DVSD_END()
};

static struct TheVerts { float x,y,z,w,tu,tv; } Verts[] =
{
    {320.0f,   0.0f, 0.5f, 1.0f,  0.5f, 0.0f},
    {527.0f, 360.0f, 0.5f, 1.0f,  1.0f, 1.0f},
    {113.0f, 360.0f, 0.5f, 1.0f,  0.0f, 1.0f},
};

DWORD RedTriangleShaderDeclaration[] =
{
    D3DVSD_STREAM(0),
    D3DVSD_REG(D3DVSDE_POSITION, D3DVSDT_FLOAT4), 
    D3DVSD_REG(D3DVSDE_DIFFUSE, D3DVSDT_D3DCOLOR),
    D3DVSD_END()
};

static struct TheRedTriangle { float x,y,z,w; DWORD color; } RedTriangle[] =
{
    {320.0f, 240.0f, 0.5f, 1.0f, 0xffff0000, },
    {310.0f, 250.0f, 0.5f, 1.0f, 0xffff0000, },
    {330.0f, 250.0f, 0.5f, 1.0f, 0xffff0000, },
};

//------------------------------------------------------------------------------
bool InitVB(D3DDevice* pDev)
{
    void* pVerts;
    void* pRedTriangle;

    CheckHR( pDev->CreateVertexBuffer( sizeof(Verts), 0, 0, 0, &pVertsVB ) );
    CheckHR( pDev->CreateVertexBuffer( sizeof(RedTriangle), 0, 0, 0, &pRedTriangleVB ) );

    pVertsVB->Lock( 0, sizeof(Verts), (BYTE **)(&pVerts), 0 );
    memcpy( (void*)pVerts, (void*)Verts, sizeof(Verts) );
    pVertsVB->Unlock();

    pRedTriangleVB->Lock( 0, sizeof(RedTriangle), (BYTE **)(&pRedTriangle), 0 );
    memcpy( (void*)pRedTriangle, (void*)RedTriangle, sizeof(RedTriangle) );
    pRedTriangleVB->Unlock();

    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;

    if ( pDev->CreateTexture( 256, 256, 1, 0, D3DFMT_P8, D3DPOOL_MANAGED, &pTexture ) != S_OK )
        return false;

    if ( pTexture->GetLevelDesc( 0, &desc ) != S_OK )
        return false;

    if ( pTexture->LockRect ( 0, &lockRect, NULL, 0 ) != S_OK)
        return false;

    PVOID pBits = LocalAlloc(0, 256 * 256 * 1);

    // Generate a set of vertical lines of varying color into a buffer.
    BYTE *pb = (BYTE *)pBits;
    DWORD y;
    
    for (y = 0; y < 256; y++)
    {
        for (DWORD x = 0; x < 256; x++)
        {
            *pb = (BYTE) x;

            pb++;
        }
    }

    // Now draw an 'X' using index 0:
    pb = (BYTE *)pBits;
    for (y = 0; y < 256; y++)
    {
        *pb = 0;

        pb += 257;
    }

    pb = (BYTE *)pBits + 255;
    for (y = 0; y < 256; y++)
    {
        *pb = 0;

        pb += 255;
    }


    XGSwizzleRect(pBits,
                  0,
                  NULL,
                  lockRect.pBits,
                  256,
                  256,
                  NULL,
                  1);

    LocalFree(pBits);

    // Unlock the map so it can be used
    pTexture->UnlockRect(0);

    pDev->SetTexture(0, pTexture);

    // We're done with this texture now
    pTexture->Release();

    // Create and select a fake test palette
    IDirect3DPalette8* pFakePalette;
    if ( pDev->CreatePalette(D3DPALETTE_32, &pFakePalette) != S_OK )
        return false;

    D3DCOLOR* pColors;
    if ( pFakePalette->Lock(&pColors, 0) != S_OK )
        return false;

    memset(pColors, 0, 32 * sizeof(D3DCOLOR));

    if ( pFakePalette->Unlock() != S_OK )
        return false;

    if ( pDev->SetPalette(0, pFakePalette) != S_OK )
        return false;

    // Now create and select a real palette
    IDirect3DPalette8* pPalette;
    if ( pDev->CreatePalette(D3DPALETTE_256, &pPalette) != S_OK )
        return false;

    if ( pPalette->Lock(&pColors, 0) != S_OK )
        return false;

    pColors[0] = 0xffff0000;                    // Index 0 is red
    pColors[255] = 0xff00ff00;                  // Index 255 is green

    for (DWORD i = 1; i < 255; i++)
    {
        pColors[i] = 0xff000000 | i;            // Rest is a blue wash
    }

    if ( pPalette->Unlock() != S_OK )
        return false;

    if ( pPalette->GetSize() != D3DPALETTE_256 )
        return false;

    if ( pDev->SetPalette(0, pPalette) != S_OK )
        return false;

    IDirect3DPalette8* pGetPalette;
    if ( pDev->GetPalette(0, &pGetPalette) != S_OK )
        return false;

    if ( pGetPalette != pPalette )
        return false;

    pGetPalette->Release();

    if ( pFakePalette->Release() != 0 )
        return false;

    // Set the texture stage states appropriately
    pDev->SetTextureStageState(0, D3DTSS_COLOROP,  D3DTOP_SELECTARG1);
    pDev->SetTextureStageState(0, D3DTSS_MINFILTER,D3DTEXF_LINEAR);
    pDev->SetTextureStageState(0, D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
    pDev->SetRenderState(D3DRS_ZENABLE, FALSE);
    pDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

    // Create the vertex shaders
    CheckHR( pDev->CreateVertexShader(VertsShaderDeclaration, NULL, &VertsShader, 0) );
    CheckHR( pDev->CreateVertexShader(RedTriangleShaderDeclaration, NULL, &RedTriangleShader, 0) );

    // Test some extra junk.

    CheckHR( pDev->Nop() );
    if (pDev->GetVertexBlendModelView(0, NULL, NULL) != S_FALSE)
        _asm int 3;

    D3DMATRIX mat[4];

    pDev->SetRenderState(D3DRS_VERTEXBLEND, TRUE);
    CheckHR( pDev->SetVertexBlendModelView(1, mat, mat, mat) );
    CheckHR( pDev->SetVertexBlendModelView(4, mat, mat, mat) );
    if (pDev->GetVertexBlendModelView(4, mat, mat) != S_OK)
        _asm int 3;

    pDev->SetRenderState(D3DRS_VERTEXBLEND, FALSE);
    CheckHR(pDev->SetVertexBlendModelView(0, NULL, NULL, NULL));

    return true;
}

//------------------------------------------------------------------------------
void UnInitVB(D3DDevice* pDev)
{
    pVertsVB->Release();
    pRedTriangleVB->Release();

    pDev->DeleteVertexShader(VertsShader);
    pDev->DeleteVertexShader(RedTriangleShader);
}

//------------------------------------------------------------------------------
void Paint(D3DDevice* pDev)
{
    // Exercise the synchronization code.
    TheVerts* pVerts;
    D3DPushBuffer* pPushBuffer;
    DWORD i;
    DWORD offset;
    
    pVertsVB->Lock( 0, sizeof(Verts), (BYTE **)(&pVerts), 0 );

    // Transform the verticies to make the triangle spin so we can verify that
    // this actually works over a period of time.
    //
    static DWORD Time = GetTickCount();
    DWORD CurrentTime = GetTickCount();

    // 10 seconds per rotation
    float spin = 2 * 3.14159f * (float)(CurrentTime - Time) / 10000.0f;

    for (i = 0; i < 3; i++)
    {

        float x = Verts[i].x;
        float y = Verts[i].y;

        x = x - 320.0f;
        y = y - 240.0f;

        pVerts[i].x = x * (float)cos(spin) - y * (float)sin(spin);
        pVerts[i].y = x * (float)sin(spin) + y * (float)cos(spin);

        pVerts[i].x += 320.0f;
        pVerts[i].y += 240.0f;
    }

    pVertsVB->Unlock();

    pDev->Clear(0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0X00404040, 1.0, 0);

    D3DSTREAM_INPUT streamInput = { pVertsVB, sizeof(Verts[0]), 0 };
    pDev->SetStreamSource(0, pVertsVB, sizeof(Verts[0]));
    pDev->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_TEX1);
    pDev->SetVertexShaderInput(VertsShader, 1, &streamInput);

    pDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

    if (pDev->CreatePushBuffer(4 * 4096, FALSE, &pPushBuffer) != S_OK)
        _asm int 3;

    // Try a small empty push buffer:
    pDev->BeginPushBuffer(pPushBuffer);
    if (pDev->EndPushBuffer() != S_OK)
        _asm int 3;
    pDev->RunPushBuffer(pPushBuffer, NULL);

    // Try a big empty push buffer:
    pDev->BeginPushBuffer(pPushBuffer);
    for (i = 0; i < 1024; i++)
    {
        pDev->SetRenderState(D3DRS_DITHERENABLE, TRUE);
    }
    pDev->GetPushBufferOffset(&offset);
    if (offset != 8 * 1024)
        _asm int 3;
    if (pDev->EndPushBuffer() != S_OK)
        _asm int 3;
    pDev->RunPushBuffer(pPushBuffer, NULL);

    // Record our rotating triangle:
    pDev->BeginPushBuffer(pPushBuffer);
    pDev->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
    pDev->EndPushBuffer();
    pDev->RunPushBuffer(pPushBuffer, NULL);

    // Draw a red triangle on top:
    pDev->SetVertexShaderInput(NULL, 0, NULL);
    pDev->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_DIFFUSE);
    pDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
    pDev->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 1, RedTriangle, sizeof(RedTriangle[0]));

    // Flip the buffers.
    pDev->Present(NULL, NULL, NULL, NULL);

    pPushBuffer->Release();
}

//------------------------------------------------------------------------------
void MemoryCompare(VOID* a, VOID* b, DWORD size)
{
    BOOL mismatch = FALSE;
    BYTE* pa = (BYTE*) a;
    BYTE* pb = (BYTE*) b;
    CHAR stringBuffer[200];

    while (size-- != 0)
    {
        if (*pa++ != *pb++)
        {
            sprintf(stringBuffer, "Mismatch at offset %li\n", pa - (BYTE*) a);
            OutputDebugStringA(stringBuffer);
            mismatch = TRUE;
        }
    }

    if (mismatch)
    {
        sprintf(stringBuffer, "a: %lx  b: %lx\n", a, b);
        OutputDebugStringA(stringBuffer);
        _asm int 3;
    }
}

//------------------------------------------------------------------------------
void PlayResources(
    D3DDevice* pDev,
    D3DPushBuffer* pPushBuffer, // If NULL, we're recording
    DWORD visibilityIndex)
{
    ////////////////////////////////////////////////////////////////////////////
    // RunPushBuffer

    static DWORD runPushBufferOffset;
    static D3DPushBuffer* pPushBufferDestination = NULL;
    if (pPushBufferDestination == NULL)
    {
        // Create an empty, initialized push-buffer:
        CheckHR(pDev->CreatePushBuffer(1024, FALSE, &pPushBufferDestination));
        pPushBufferDestination->Size = 1024;
        ZeroMemory((void*) pPushBufferDestination->Data, 1024);
    }

    if (!pPushBuffer)
    {
        CheckHR(pDev->GetPushBufferOffset(&runPushBufferOffset))
        CheckHR(pDev->RunPushBuffer(pPushBufferDestination, NULL));
    }
    else
    {
        CheckHR(pPushBuffer->RunPushBuffer(runPushBufferOffset, pPushBufferDestination, NULL));
    }
    ////////////////////////////////////////////////////////////////////////////
    // SetModelView

    static DWORD setModelViewOffset;
    static D3DMATRIX matProjection;
    D3DMATRIX get1;
    D3DMATRIX get2;
    D3DXMATRIX matModelView;
    D3DXMATRIX matInverseModelView;
    D3DXMATRIX matProjectionViewport;
    D3DXMatrixIdentity(&matModelView);
    D3DXMatrixIdentity(&matInverseModelView);
    matInverseModelView.m[0][0] = 2;

    CheckHR(pDev->GetProjectionViewportMatrix(&matProjectionViewport));

    if (!pPushBuffer)
    {
        if (pDev->GetModelView(NULL) != S_FALSE)
            _asm int 3;
        CheckHR(pDev->GetProjectionViewportMatrix(&matProjection));
        CheckHR(pDev->GetPushBufferOffset(&setModelViewOffset));
        CheckHR(pDev->SetModelView(&matModelView, &matInverseModelView, &matProjection));
        if (pDev->GetModelView(&get1) != S_OK)
            _asm int 3;
        MemoryCompare(&matModelView, &get1, sizeof(matModelView));
        CheckHR(pDev->SetModelView(NULL, NULL, NULL));
        if (pDev->GetModelView(NULL) != S_FALSE)
            _asm int 3;
    }
    else
    {
        CheckHR(pPushBuffer->SetModelView(setModelViewOffset, &matModelView,
                                          &matInverseModelView, &matProjection));
    }

    ////////////////////////////////////////////////////////////////////////////
    // SetVertexBlendModelView

    static DWORD setVertexBlendModelViewOffset;

    if (!pPushBuffer)
    {
        pDev->SetRenderState(D3DRS_VERTEXBLEND, TRUE);
        if (pDev->GetVertexBlendModelView(0, NULL, NULL) != S_FALSE)
            _asm int 3;
        CheckHR(pDev->GetPushBufferOffset(&setVertexBlendModelViewOffset));
        CheckHR(pDev->SetVertexBlendModelView(1, &matModelView, &matInverseModelView, &matProjectionViewport));
        if (pDev->GetVertexBlendModelView(0, NULL, NULL) != S_OK)
            _asm int 3;
        CheckHR(pDev->SetVertexBlendModelView(0, NULL, NULL, NULL));
        if (pDev->GetVertexBlendModelView(1, &get1, &get2) != S_FALSE)
            _asm int 3;
        MemoryCompare(&matModelView, &get1, sizeof(matModelView));
        MemoryCompare(&matProjectionViewport, &get2, sizeof(matModelView));
        pDev->SetRenderState(D3DRS_VERTEXBLEND, FALSE);
    }
    else
    {
        CheckHR(pPushBuffer->SetVertexBlendModelView(setVertexBlendModelViewOffset, 1, &matModelView, &matInverseModelView, &matProjectionViewport));
    }

    ////////////////////////////////////////////////////////////////////////////
    // SetVertexShaderInput

    static DWORD setVertexShaderInputOffset;
    static D3DVertexBuffer* pVertexBuffer = NULL;
    static DWORD hVertexShader;
    DWORD shaderDeclaration[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position
        D3DVSD_REG( 1, D3DVSDT_D3DCOLOR ), // Diffuse color
        D3DVSD_END()
    };

    if (pVertexBuffer == NULL)
    {
        CheckHR(pDev->CreateVertexBuffer(1024, 0, 0, 0, &pVertexBuffer));
        CheckHR(pDev->CreateVertexShader(shaderDeclaration, NULL, &hVertexShader, 0));
    }
    D3DSTREAM_INPUT streamInput = { pVertexBuffer, 32, 0 };

    if (!pPushBuffer)
    {
        CheckHR(pDev->GetPushBufferOffset(&setVertexShaderInputOffset));
        CheckHR(pDev->SetVertexShaderInput(hVertexShader, 1, &streamInput));
    }
    else
    {
        CheckHR(pPushBuffer->SetVertexShaderInput(setVertexShaderInputOffset,
                                                  hVertexShader, 1, &streamInput));
    }

    ////////////////////////////////////////////////////////////////////////////
    // SetRenderTarget

    static DWORD setRenderTargetOffset;
    D3DSurface* pRenderTarget;
    D3DSurface* pZBuffer;

    CheckHR(pDev->GetRenderTarget(&pRenderTarget));
    CheckHR(pDev->GetDepthStencilSurface(&pZBuffer));

    if (!pPushBuffer)
    {
        CheckHR(pDev->GetPushBufferOffset(&setRenderTargetOffset));
        CheckHR(pDev->SetRenderTarget(pRenderTarget, pZBuffer));
    }
    else
    {
        CheckHR(pPushBuffer->SetRenderTarget(setRenderTargetOffset, pRenderTarget, pZBuffer));
    }

    ////////////////////////////////////////////////////////////////////////////
    // SetTexture

    static DWORD setTextureOffset;
    static D3DTexture* pTexture = NULL;

    if (pTexture == NULL)
    {
        CheckHR(pDev->CreateTexture(32, 32, 1, 0, D3DFMT_DXT1, 0, &pTexture));
    }

    if (!pPushBuffer)
    {
        CheckHR(pDev->GetPushBufferOffset(&setTextureOffset));
        CheckHR(pDev->SetTexture(1, pTexture));
    }
    else
    {
        CheckHR(pPushBuffer->SetTexture(setTextureOffset, 1, pTexture));
    }

    ////////////////////////////////////////////////////////////////////////////
    // SwitchTexture

    static DWORD switchTextureOffset;
    static D3DTexture* pSwitch = NULL;

    if (pSwitch == NULL)
    {
        CheckHR(pDev->CreateTexture(32, 32, 1, 0, D3DFMT_DXT3, 0, &pSwitch));
    }

    if (!pPushBuffer)
    {
        CheckHR(pDev->GetPushBufferOffset(&switchTextureOffset));
        CheckHR(pDev->SwitchTexture(1, pSwitch));
    }
    else
    {
        CheckHR(pPushBuffer->SetTexture(switchTextureOffset, 1, pSwitch));
    }

    ////////////////////////////////////////////////////////////////////////////
    // SetPalette

    static DWORD setPaletteOffset;
    static D3DPalette *pPalette = NULL;

    if (pPalette == NULL)
    {
        CheckHR(pDev->CreatePalette(D3DPALETTE_256, &pPalette));
    }

    if (!pPushBuffer)
    {
        CheckHR(pDev->GetPushBufferOffset(&setPaletteOffset));
        CheckHR(pDev->SetPalette(0, pPalette));
    }
    else
    {
        CheckHR(pPushBuffer->SetPalette(setPaletteOffset, 0, pPalette));
    }

    ////////////////////////////////////////////////////////////////////////////
    // EndVisibilityTest

    static DWORD endVisibilityTestOffset;

    if (!pPushBuffer)
    {
        CheckHR(pDev->BeginVisibilityTest());
        CheckHR(pDev->GetPushBufferOffset(&endVisibilityTestOffset));
        CheckHR(pDev->EndVisibilityTest(visibilityIndex));
    }
    else
    {
        CheckHR(pPushBuffer->EndVisibilityTest(endVisibilityTestOffset, visibilityIndex));
    }

    ////////////////////////////////////////////////////////////////////////////
    // SetVertexShaderConstant

    static DWORD setVertexShaderConstantOffset;
    const UINT constantCount = 55;
    DWORD constantData[4 * constantCount];

    for (DWORD i = 0; i < 4 * constantCount; i++)
    {
        constantData[i] = i;
    }

    if (!pPushBuffer)
    {
        CheckHR(pDev->GetPushBufferOffset(&setVertexShaderConstantOffset));
        CheckHR(pDev->SetVertexShaderConstant(3, constantData, constantCount));
    }
    else
    {
        CheckHR(pPushBuffer->SetVertexShaderConstant(setVertexShaderConstantOffset, 3, constantData, constantCount));
    }

    ////////////////////////////////////////////////////////////////////////////
    // Jump

    static DWORD jumpOffset;

    if (!pPushBuffer)
    {
        CheckHR(pDev->GetPushBufferOffset(&jumpOffset));
        CheckHR(pDev->Nop());
    }
    else
    {
        CheckHR(pPushBuffer->Jump(jumpOffset, jumpOffset));
    }

    ////////////////////////////////////////////////////////////////////////////
    // Clean-up after recording

    if (!pPushBuffer)
    {
        CheckHR(pDev->SetTexture(1, NULL));
    }
}

//------------------------------------------------------------------------------
DWORD g_index = 2;

//------------------------------------------------------------------------------
void TestFixups(D3DDevice* pDev)
{
    static CopyBuffer[32768];
    D3DPushBuffer* pPushBuffer;
    D3DFixup* pFixup;
    DWORD size1;
    DWORD size2;


    CheckHR(pDev->CreatePushBuffer(32768, FALSE, &pPushBuffer));
    CheckHR(pDev->BeginPushBuffer(pPushBuffer));
    PlayResources(pDev, NULL, ++g_index);
    CheckHR(pDev->EndPushBuffer());

    // Copy the result for later:
    memcpy(CopyBuffer, (VOID*) pPushBuffer->Data, pPushBuffer->Size);

    // Stomp all the resource references:
    CheckHR(pPushBuffer->Verify(TRUE));

    // Now reapply everything using a fixup:
    CheckHR(pPushBuffer->BeginFixup(NULL, 0));
    PlayResources(pDev, pPushBuffer, g_index);
    CheckHR(pPushBuffer->EndFixup());
    CheckHR(pPushBuffer->Verify(FALSE));

    // Finally, check that the results match:
    MemoryCompare(CopyBuffer, (VOID*) pPushBuffer->Data, pPushBuffer->Size - 4);

    // Do a pass with an empty fix-up object to see if anything falls over:
    CheckHR(pDev->CreateFixup(0, &pFixup));
    CheckHR(pPushBuffer->BeginFixup(pFixup, 0));
    PlayResources(pDev, pPushBuffer, ++g_index);

    // With an empty fix-up buffer, we should always get1 a too small error (but
    // GetSize will still be valid):
    if (pPushBuffer->EndFixup() != D3DERR_BUFFERTOOSMALL)
        _asm int 3;
    CheckHR(pFixup->GetSize(&size1));
    pFixup->Release();

    // Try again with a humongous fix-up buffer to verify that the size is
    // the same:
    CheckHR(pDev->CreateFixup(4096*4, &pFixup));
    CheckHR(pPushBuffer->BeginFixup(pFixup, 0));
    PlayResources(pDev, pPushBuffer, ++g_index);
    CheckHR(pPushBuffer->EndFixup());
    CheckHR(pFixup->GetSize(&size2));
    pFixup->Release();

    if (size1 != size2)
        _asm int 3;
}

//------------------------------------------------------------------------------
void TestDrawVertices(D3DDevice* pDev)
{
    DWORD i;
    WORD indexBuffer[4096];
    D3DPushBuffer* pPushBuffer;
    D3DFixup* pFixup;
    BYTE compileBuffer[32768];
    DWORD compileSize;

    for (i = 0; i < 4096; i++)
        indexBuffer[i] = (WORD) i;

    CheckHR( pDev->CreatePushBuffer(32768, FALSE, &pPushBuffer) );

    CheckHR( pDev->BeginPushBuffer(pPushBuffer) );
    CheckHR( pDev->DrawIndexedVertices(D3DPT_TRIANGLELIST, 5, indexBuffer) );
    CheckHR( pDev->EndPushBuffer() );

    compileSize = sizeof(compileBuffer);
    CheckHR( XGCompileDrawIndexedVertices(compileBuffer, &compileSize,
                                          D3DPT_TRIANGLELIST, 5, indexBuffer) );

    if ( compileSize != pPushBuffer->Size )
        _asm int 3;
    
    MemoryCompare( (VOID*) pPushBuffer->Data, compileBuffer, compileSize - 4 );

    CheckHR( pDev->BeginPushBuffer(pPushBuffer) );
    CheckHR( pDev->DrawIndexedVertices(D3DPT_LINELIST, 3000, indexBuffer + 3) );
    CheckHR( pDev->EndPushBuffer() );

    compileSize = sizeof(compileBuffer);
    CheckHR( XGCompileDrawIndexedVertices(compileBuffer, &compileSize,
                                          D3DPT_LINELIST, 3000, indexBuffer + 3) );

    // Ack, MikeSart's optimized DrawIndexedVertices no longer produces the
    // same signature, so drop the compare:

    // if ( compileSize != pPushBuffer->Size )
    //     _asm int 3;
    //
    // MemoryCompare( (VOID*) pPushBuffer->Data, compileBuffer, compileSize - 4 );

    pPushBuffer->Release();

    CheckHR( pDev->CreateFixup(1024, &pFixup) );
    pFixup->Release();
}

//------------------------------------------------------------------------------
#define TRIANGLE_NUM    8

struct VERTEX {
    FLOAT x, y, z;
};

void TestSizes1(D3DDevice* pDev)
{
    // Create Vertex Buffer
    D3DVertexBuffer *vtx;
    pDev->CreateVertexBuffer( 8192,
                                D3DUSAGE_WRITEONLY, 
                                0, 
                                D3DPOOL_MANAGED, 
                                &vtx );

    VERTEX *p;
    vtx->Lock( 0, 0, (BYTE **)&p, 0 );
    ZeroMemory(p, 3 * sizeof(VERTEX));
    vtx->Unlock();

    // Create Push Buffer
    D3DPushBuffer *push;
    pDev->CreatePushBuffer( 8192, FALSE, &push );
    pDev->BeginPushBuffer( push );
    for ( int i = 0; i < TRIANGLE_NUM; i++ )
        pDev->DrawVertices( D3DPT_TRIANGLELIST, 0, 3 );

    pDev->EndPushBuffer();

    for ( int i = 0; i < 128; i++ )
    {
        *((DWORD*) (push->Data + push->Size - 4))
            = 0xdeadbeef;

        pDev->RunPushBuffer( push, NULL );

        pDev->BlockUntilIdle();
    }
}

//------------------------------------------------------------------------------
WORD g_Zero[1024];

#define PUSH_BUFFER_SIZE 8192
#define VERTEX_BUFFER_SIZE 8192

//------------------------------------------------------------------------------
void TestSizes2(D3DDevice* pDev)
{
    D3DPushBuffer* pPushBuffer;
    D3DVertexBuffer* pVertexBuffer;
    BYTE* pData;

    pDev->CreatePushBuffer(PUSH_BUFFER_SIZE, FALSE, &pPushBuffer);
    pDev->CreateVertexBuffer(VERTEX_BUFFER_SIZE, 0, 0, 0, &pVertexBuffer);

    pVertexBuffer->Lock(0, 0, &pData, 0);
    ZeroMemory(pData, VERTEX_BUFFER_SIZE);
    pVertexBuffer->Unlock();

    pDev->SetStreamSource(0, pVertexBuffer, 32);

    for (DWORD type = 0; type < 3; type++)
    {
        for (DWORD indices = 1; indices < 1024; indices++)
        {
            // For each, use a degenerate (zero-sized) triangle:

            RtlFillMemoryUlong((void*) pPushBuffer->Data, 
                               PUSH_BUFFER_SIZE,
                               0xdeadbeef);

            switch (type)
            {
            case 2:
                pPushBuffer->Size = PUSH_BUFFER_SIZE;
                CheckHR(XGCompileDrawIndexedVertices((void*) pPushBuffer->Data, 
                                                     &pPushBuffer->Size,
                                                     D3DPT_TRIANGLELIST,
                                                     indices,
                                                     g_Zero));
                break;
            case 1:
                pDev->BeginPushBuffer(pPushBuffer);
                pDev->DrawIndexedVertices(D3DPT_TRIANGLELIST, indices, &g_Zero[0]);
                CheckHR(pDev->EndPushBuffer());
                break;
            case 0:
                pDev->BeginPushBuffer(pPushBuffer);
                for (DWORD i = 0; i < indices / 8; i++)
                    pDev->DrawVertices(D3DPT_TRIANGLELIST, 0, 3);

                CheckHR(pDev->EndPushBuffer());
                break;
            }
    
            for (DWORD nops = 0; nops < 16; nops++)
            {
                for (DWORD repeats = 0; repeats < 16; repeats++)
                {
                    *((DWORD*) (pPushBuffer->Data + pPushBuffer->Size - 4))
                        = 0xdeadbeef;
    
                    for (DWORD i = 0; i < nops; i++)
                        pDev->Nop();
    
                    pDev->RunPushBuffer(pPushBuffer, NULL);
                    pDev->BlockUntilIdle();
                }
            }
        }
    }

    pPushBuffer->Release();
    pVertexBuffer->Release();
}

//------------------------------------------------------------------------------
void TestPushBuffers(D3DDevice* pDev)
{
    TestDrawVertices(pDev);
    TestFixups(pDev);
    TestSizes1(pDev);
    TestSizes2(pDev);

    InitVB(pDev);
    for (DWORD i = 0; i < 20; i++)
    {
        Paint(pDev);
    }
    UnInitVB(pDev);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\reset\sources.inc ===
TARGETNAME=Reset
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    main.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\regress\regress.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       regress.hpp
 *  Content:    Common include file
 *
 ***************************************************************************/

extern "C"
{
    extern BOOL D3D__Parser;
    extern DWORD D3D__AllocsContiguous;
    extern DWORD D3D__AllocsNoncontiguous;
}

#define CheckHR(_x)                                             \
{                                                               \
    HRESULT _hr = (_x);                                         \
    if (FAILED(_hr))                                            \
    {                                                           \
        OutputDebugStringA("CheckHR failure");                  \
        _asm { int 3 }                                          \
    }                                                           \
}
#define WARNING(msg)        \
    {                       \
        DbgPrint msg;     \
        DbgPrint("\n");   \
    }

#undef RIP

#define RIP(msg)            \
    {                       \
        DbgPrint msg;     \
        DbgPrint("\n");   \
        _asm { int 3 };     \
    }

#undef ASSERT
#define ASSERT(cond)   \
    {                  \
        if (! (cond))  \
        {              \
            RIP(("Assertion failure: %s", #cond)); \
        }              \
    }

#undef ASSERTMSG
#define ASSERTMSG(cond, msg) \
    {                        \
        if (! (cond))        \
        {                    \
            RIP(msg);        \
        }                    \
    }

//=========================================================================
// Class to help time things
//=========================================================================
class CTimer
{
public:
    // constructor
    CTimer()
    {
        QueryPerformanceFrequency((LARGE_INTEGER*)&ticksPerSecond);
        ticksPerSecond /= 1000;
    }

    ~CTimer() {};

    void Start()
        { frunning = true; QueryPerformanceCounter((LARGE_INTEGER *)&ticksstart); }

    void Stop()
        { frunning = false; QueryPerformanceCounter((LARGE_INTEGER *)&ticksend); }

    float getTime()
        {
            if(frunning)
                QueryPerformanceCounter((LARGE_INTEGER *)&ticksend);
            return ((ticksend - ticksstart) * 1.0f / ticksPerSecond);
        }

    bool frunning;
    _int64 ticksstart;
    _int64 ticksend;
    _int64 ticksPerSecond;
};
    
// Handy macros:

#define ARRAYSIZE(_a) (sizeof(_a) / sizeof((_a)[0]))

// Tests:

void TestLeaks();

void TestPushBuffers(D3DDevice* pDev);
void TestTiles(D3DDevice* pDev);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\regress\regress.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       regress.cpp
 *  Content:    Main file for the D3D regression test
 *
 ***************************************************************************/
 
#include "precomp.hpp"

//------------------------------------------------------------------------------
D3DDevice* InitD3D()
{
    D3DDevice* pDev = NULL;

    Direct3D* pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    if (pD3D == NULL)
        return NULL;

    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount           = 1;
    d3dpp.Windowed                  = false;   // Must be false for Xbox.
    d3dpp.EnableAutoDepthStencil    = true;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz= 60;
    d3dpp.MultiSampleType           = D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX;

    if (pD3D->CreateDevice(
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        NULL,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        &pDev) != S_OK)
    {
        return NULL;
    }

    pD3D->Release();

    return pDev;
}

//------------------------------------------------------------------------------
void TestScissors(D3DDevice* pDev)
{
    D3DRECT originalRect;
    D3DRECT rects[2] = { { 100, 100, 350, 350 }, { 300, 300, 800, 400 } };
    D3DRECT getRects[2];
    BOOL Exclusive = TRUE;
    DWORD count;
    BOOL exclusive;

    CheckHR(pDev->GetScissors(&count, &exclusive, &originalRect));

    ASSERT((count == 1) && 
           (exclusive == FALSE) && 
           (originalRect.x1 == 0) &&
           (originalRect.y1 == 0) &&
           (originalRect.x2 == 640) &&
           (originalRect.y2 == 480));
    
    CheckHR(pDev->SetScissors(2, Exclusive, rects));
    CheckHR(pDev->GetScissors(&count, &exclusive, getRects));
    
    if ((count != 2) ||
        (exclusive != Exclusive) ||
        (memcmp(getRects, rects, 2 * sizeof(D3DRECT)) != 0))
    {
        RIP(("Failed"));
    }

    Exclusive = FALSE;
    
    CheckHR(pDev->SetScissors(2, Exclusive, rects));
    CheckHR(pDev->GetScissors(&count, &exclusive, getRects));
    
    if ((count != 2) ||
        (exclusive != Exclusive) ||
        (memcmp(getRects, rects, 2 * sizeof(D3DRECT)) != 0))
    {
        RIP(("Failed"));
    }

    // Restore the scissors to their original state:

    CheckHR(pDev->SetScissors(0, 0, NULL));
}

//------------------------------------------------------------------------------
void TestPeristentAttributes(D3DDevice* pDev)
{
    // We used to have a problem with doing these not in a Begin/End bracket:

    for (DWORD i = 0; i < 512000; i++)
    {
        pDev->SetVertexData4f(0, 0, 0, 0, 0);
    }
}

//------------------------------------------------------------------------------
void TestCreateDeviceAndReset()
{
    D3DDevice* pDev = NULL;
    D3DSurface* pColorSurface1;
    D3DSurface* pColorSurface2;
    D3DSurface* pZSurface;

    // Yes, it's legal to use a NULL pDev for this:
    
    pDev->CreateImageSurface(640, 480, D3DFMT_LIN_X1R5G5B5, &pColorSurface1);
    pDev->CreateImageSurface(640, 480, D3DFMT_LIN_X1R5G5B5, &pColorSurface2);
    pDev->CreateImageSurface(640, 480, D3DFMT_LIN_D16, &pZSurface);

    // Now create the object:

    Direct3D* pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    ASSERT(pD3D != NULL);

    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_LIN_X1R5G5B5;
    d3dpp.BackBufferCount           = 1;
    d3dpp.Windowed                  = false;   // Must be false for Xbox.
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz= 60;
    d3dpp.MultiSampleType           = D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX;
    d3dpp.BufferSurfaces[0]         = pColorSurface1;
    d3dpp.BufferSurfaces[1]         = pColorSurface2;
    d3dpp.DepthStencilSurface       = pZSurface;

    if (pD3D->CreateDevice(
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        NULL,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        &pDev) != S_OK)
    {
        RIP(("Argh"));
    }

    pD3D->Release();

    pColorSurface1->Release();
    pColorSurface2->Release();
    pZSurface->Release();

    // Now create new surfaces and Reset the sucker:

    pDev->CreateImageSurface(640, 480, D3DFMT_LIN_X8R8G8B8, &pColorSurface1);
    pDev->CreateImageSurface(640, 480, D3DFMT_LIN_X8R8G8B8, &pColorSurface2);
    pDev->CreateImageSurface(640, 480, D3DFMT_LIN_D24S8, &pZSurface);

    d3dpp.BackBufferFormat          = D3DFMT_LIN_X8R8G8B8;
    d3dpp.MultiSampleType           = 0;
    d3dpp.BufferSurfaces[0]         = pColorSurface1;
    d3dpp.BufferSurfaces[1]         = pColorSurface2;
    d3dpp.DepthStencilSurface       = pZSurface;

    pDev->Reset(&d3dpp);

    pDev->Release();

    pColorSurface1->Release();
    pColorSurface2->Release();
    pZSurface->Release();
}

//------------------------------------------------------------------------------
void TestLargePushes(D3DDevice* pDev)
{
    DWORD i;

    D3DPushBuffer* pPushBuffer;

    pDev->CreatePushBuffer(136*1024, TRUE, &pPushBuffer);
    pDev->BeginPushBuffer(pPushBuffer);

    for (i = 0; i < 128*1024/8; i++)
    {
        pDev->Nop();
    }

    HRESULT hresult = pDev->EndPushBuffer();
    ASSERT(hresult == S_OK);

    for (i = 0; i < 256; i++)
    {
        pDev->Clear(0, NULL, D3DCLEAR_TARGET_R | D3DCLEAR_ZBUFFER, 0, 0, 0);
        pDev->Clear(0, NULL, D3DCLEAR_TARGET_R | D3DCLEAR_ZBUFFER, 0, 0, 0);
        pDev->Clear(0, NULL, D3DCLEAR_TARGET_R | D3DCLEAR_ZBUFFER, 0, 0, 0);
        pDev->Clear(0, NULL, D3DCLEAR_TARGET_R | D3DCLEAR_ZBUFFER, 0, 0, 0);
        pDev->Clear(0, NULL, D3DCLEAR_TARGET_R | D3DCLEAR_ZBUFFER, 0, 0, 0);
        pDev->RunPushBuffer(pPushBuffer, NULL);
        pDev->RunPushBuffer(pPushBuffer, NULL);
        pDev->RunPushBuffer(pPushBuffer, NULL);
        pDev->RunPushBuffer(pPushBuffer, NULL);
    }

    pPushBuffer->Release();
}

//------------------------------------------------------------------------------
void __cdecl main()
{
    // Before anything else, test for leaks:

    TestLeaks();

    // Put tests here that have to create their own D3D objects:

    TestCreateDeviceAndReset();

    // Put tests here that can inherit the pre-built D3D object (via pDev):

    D3DDevice* pDev = InitD3D();

    for (DWORD pass = 0; pass < 2; pass++)
    {
    #if DBG
        D3D__Parser = pass;
    #endif

        TestLargePushes(pDev);
        TestPushBuffers(pDev);
        TestTiles(pDev);
        TestScissors(pDev);
        TestPeristentAttributes(pDev);
    }

    // We're done:

    DbgPrint("\n>> D3D Regress: Done.  Success!\n");

    while (TRUE)
        ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\reset\main.cpp ===
#include <xtl.h>

#define CheckHR(_x)                                             \
{                                                               \
    HRESULT _hr = (_x);                                         \
    if (FAILED(_hr))                                            \
    {                                                           \
        OutputDebugStringA("CheckHR failure");                  \
        _asm { int 3 }                                          \
    }                                                           \
}

#define ARRAYSIZE(_a) (sizeof(_a) / sizeof((_a)[0]))

D3DFORMAT g_BackBufferFormats[] =
{
    D3DFMT_X8R8G8B8,
    D3DFMT_A8R8G8B8,
    D3DFMT_R5G6B5,
    D3DFMT_X1R5G5B5,
};

D3DFORMAT g_DepthFormats[] =
{
    D3DFMT_D24S8,
    D3DFMT_F24S8,
    D3DFMT_D16,
    D3DFMT_F16,
};

DWORD g_MultisampleTypes[] =
{
    D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR,
    D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX,
    D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR,
    D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR,
    D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR,
    D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN,
    D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR,
    D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN,
    D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN,
    D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN,
};

DWORD g_BackCounts[] =
{
    0, 1, 2,
};

DWORD g_Intervals[] =
{
    D3DPRESENT_INTERVAL_IMMEDIATE,
    D3DPRESENT_INTERVAL_ONE,
    D3DPRESENT_INTERVAL_TWO,
};

D3DTexture* pTexture;
D3DTexture* pDepth;
D3DPalette* pPalette;
D3DVertexBuffer* pVertexBuffer;
D3DIndexBuffer* pIndexBuffer;
DWORD alphaTestEnable;
DWORD minFilter;
DWORD texCoordIndex;

void __cdecl main()
{
    BOOL fReset = FALSE;
    IDirect3DDevice8* pDev = NULL;
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);

    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory(&d3dpp, sizeof(d3dpp));
    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.Windowed                  = false;   // Must be false for Xbox.
    d3dpp.EnableAutoDepthStencil    = true;
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz= 60;
    d3dpp.hDeviceWindow             = NULL;

    while (TRUE)
    {
        for (int iBackBufferFormat = 0;
             iBackBufferFormat < ARRAYSIZE(g_BackBufferFormats);
             iBackBufferFormat++)
        {
            for (int iDepthFormat = 0;
                 iDepthFormat < ARRAYSIZE(g_DepthFormats);
                 iDepthFormat++)
            {
                for (int iMultisampleType = 0;
                     iMultisampleType < ARRAYSIZE(g_MultisampleTypes);
                     iMultisampleType++)
                {
                    for (int iBackCount = 0;
                         iBackCount < ARRAYSIZE(g_BackCounts);
                         iBackCount++)
                    {
                        for (int iInterval = 0;
                             iInterval < ARRAYSIZE(g_Intervals);
                             iInterval++)
                        {

                            d3dpp.BackBufferFormat       = g_BackBufferFormats[iBackBufferFormat];
                            d3dpp.BackBufferCount        = g_BackCounts[iBackCount];
                            d3dpp.AutoDepthStencilFormat = g_DepthFormats[iDepthFormat];
                            d3dpp.MultiSampleType        = g_MultisampleTypes[iMultisampleType];

                            if (fReset)
                            {
                                pDev->Reset(&d3dpp);
                            }
                            else
                            {
                                if (pDev != NULL)
                                {
                                    pDev->Release();
                                }

                                pD3D->CreateDevice(D3DADAPTER_DEFAULT,
                                                    D3DDEVTYPE_HAL,
                                                    NULL,
                                                    D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                                    &d3dpp,
                                                    &pDev);
                            }
#if 1
                            CheckHR(pDev->CreateTexture(1024, 1024, 4, 0, D3DFMT_A8R8G8B8, 0, &pTexture));
                            CheckHR(pDev->CreateTexture(1024, 1024, 1, 0, D3DFMT_LIN_F24S8, 0, &pDepth));
                            CheckHR(pDev->SetTexture(0, pTexture));
                            CheckHR(pDev->SetTexture(1, pTexture));
                            CheckHR(pDev->SetTexture(2, pTexture));
                            CheckHR(pDev->SetTexture(3, pTexture));
                            CheckHR(pDev->SetRenderTarget((D3DSurface*) pTexture, (D3DSurface*) pDepth));

                            CheckHR(pDev->CreatePalette(D3DPALETTE_256, &pPalette));
                            CheckHR(pDev->SetPalette(0, pPalette));
                            CheckHR(pDev->SetPalette(1, pPalette));
                            CheckHR(pDev->SetPalette(2, pPalette));
                            CheckHR(pDev->SetPalette(3, pPalette));
#endif
#if 1
                            CheckHR(pDev->CreateVertexBuffer(32768, 0, 0, 0, &pVertexBuffer));
                            for (DWORD i = 0; i < 15; i++) // Can't be 16, we'd overflow
                            {
                                CheckHR(pDev->SetStreamSource(i, pVertexBuffer, 32));
                            }
    
                            CheckHR(pDev->CreateIndexBuffer(32768, 0, D3DFMT_INDEX16, 0, &pIndexBuffer));
                            CheckHR(pDev->SetIndices(pIndexBuffer, 0));
#endif    
                            // Do a Present, verifying that some states are preserved across
                            // an FSAA Present call:
    
                            CheckHR(pDev->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE));
                            CheckHR(pDev->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_POINT));
                            CheckHR(pDev->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 3));

                            CheckHR(pDev->Clear(0, NULL, D3DCLEAR_TARGET, 0, 0, 0));
                            CheckHR(pDev->Present(NULL, NULL, NULL, NULL));

                            CheckHR(pDev->GetRenderState(D3DRS_ALPHATESTENABLE, &alphaTestEnable));
                            CheckHR(pDev->GetTextureStageState(0, D3DTSS_MINFILTER, &minFilter));
                            CheckHR(pDev->GetTextureStageState(0, D3DTSS_TEXCOORDINDEX, &texCoordIndex));

                            // Now release any created objects:
#if 1    
                            pTexture->Release();
                            pDepth->Release();
                            pPalette->Release();
#endif
#if 1
                            pVertexBuffer->Release();
                            pIndexBuffer->Release();
#endif
                        }
                    }
                }
            }
        }
        fReset = !fReset;
    }

    pD3D->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\rtpatch\rtpatch.cpp ===
//-----------------------------------------------------------------------------
// File: RTPatch.cpp
//
// Desc: Example code showing how to use patches in D3D.
//
// Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#define STRICT
#include <tchar.h>
#include <math.h>
#include <stdio.h>

#ifdef XBOX
#include <xtl.h>
#else
#include <D3DX8.h>
#endif

#include "D3DApp.h"
#include "D3DFile.h"
#include "D3DUtil.h"
#include "DXUtil.h"

#include "teapot.h"

// A structure for our custom vertex type
struct CUSTOMVERTEX
{
    D3DXVECTOR3 p; // The original position of the vertex
};

// Surface handles need to start with 1
const UINT SURFACEHANDLEBASE = 1;

//-----------------------------------------------------------------------------
// Name: class CMyD3DApplication
// Desc: Application class. The base class (CD3DApplication) provides the 
//       generic functionality needed in all Direct3D samples. CMyD3DApplication 
//       adds functionality specific to this sample program.
//-----------------------------------------------------------------------------
class CMyD3DApplication : public CD3DApplication
{
#ifdef _FONT_
    CD3DFont*               m_pFont;          // Font for drawing text
#endif
    LPDIRECT3DVERTEXBUFFER8 m_pVB;            // Buffer to hold vertices
    DWORD                   m_hVShader;       // Handle to vertex shader
    CD3DArcBall             m_ArcBall;        // Mouse rotation utility

    UINT                    m_numSegments;    // Amount to tessellate
    BOOL                    m_bRetessellate;  // Need to retessellate patches
    UINT                    m_numPatches;
    BOOL                    m_bShowHelp;
    BOOL                    m_bWireframe;

    bool ConfirmDevice( D3DCAPS8*, DWORD, D3DFORMAT );

protected:
    void InitDeviceObjects();
    void RestoreDeviceObjects();
    void InvalidateDeviceObjects();
    void DeleteDeviceObjects();
    void Render();
    void FrameMove();
    void FinalCleanup();

public:
    CMyD3DApplication();
};




//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------

#ifdef XBOX
void __cdecl main()
#else
INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )
#endif
{
    CMyD3DApplication d3dApp;

#ifdef XBOX
    d3dApp.Create( NULL );
#else
    d3dApp.Create( hInst );
#endif

    d3dApp.Run();

#ifndef XBOX
    return 0;
#endif
}



//-----------------------------------------------------------------------------
// Name: CMyD3DApplication()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CMyD3DApplication::CMyD3DApplication()
{
    m_bUseDepthBuffer   = TRUE;

#ifdef _FONT_
    m_pFont             = new CD3DFont( _T("Arial"), 12, D3DFONT_BOLD );
#endif
    m_pVB               = NULL;
    m_bRetessellate     = TRUE;
    m_numSegments       = 4;
    m_bShowHelp         = FALSE;
    m_bWireframe        = FALSE;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
void CMyD3DApplication::FrameMove()
{
    // Set up viewing postion from ArcBall
    D3DXMATRIX matRotationInverse;
    D3DXMatrixInverse( &matRotationInverse, NULL, m_ArcBall.GetRotationMatrix() );
    m_pDevice->SetTransform( D3DTS_WORLD, &matRotationInverse );
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: 
//-----------------------------------------------------------------------------
void CMyD3DApplication::Render()
{
    // Clear the viewport
    m_pDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         0x000000ff, 1.0f, 0L );

    if( m_bWireframe )
        m_pDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_WIREFRAME );
    else
        m_pDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );

    // Begin the scene
    if( SUCCEEDED( m_pDevice->BeginScene() ) )
    {
        m_pDevice->SetVertexShader( m_hVShader );
        m_pDevice->SetStreamSource( 0, m_pVB, sizeof(CUSTOMVERTEX) );

        for( UINT i = 0; i < m_numPatches; i++ ) 
        {
            float numSegs[4];
            numSegs[0] = (FLOAT)m_numSegments;
            numSegs[1] = (FLOAT)m_numSegments;
            numSegs[2] = (FLOAT)m_numSegments;
            numSegs[3] = (FLOAT)m_numSegments;
            if ( m_bRetessellate ) 
            {
                // First time through, tesellate
                D3DRECTPATCH_INFO info;
                info.StartVertexOffsetWidth = 0;
                info.StartVertexOffsetHeight = i * 4;
                info.Width = 4;
                info.Height = 4;
                info.Stride = 4; // verticies to next row of verticies
                info.Basis = D3DBASIS_BEZIER;
                info.Order = D3DORDER_CUBIC;
                m_pDevice->DrawRectPatch(SURFACEHANDLEBASE + i, numSegs, &info);
            }
            else 
            {
                // After the first time, use the existing surface handles
                m_pDevice->DrawRectPatch(SURFACEHANDLEBASE + i, numSegs, 0);
            }
        }

        m_bRetessellate = FALSE;

#ifdef _FONT_      
        // Output statistics
        m_pFont->DrawText( 2,  0, D3DCOLOR_ARGB(255,255,255,0), m_strFrameStats );
        m_pFont->DrawText( 2, 20, D3DCOLOR_ARGB(255,255,255,0), m_strDeviceStats );
        TCHAR szSegments[150];
        wsprintf(szSegments, TEXT("%d segments per patch"), m_numSegments);
        m_pFont->DrawText( 2, 40, D3DCOLOR_ARGB(255,255,255,255), szSegments );

        if( m_bShowHelp )
        {
            m_pFont->DrawText( 2, 60, D3DCOLOR_ARGB(255,255,255,255), 
                TEXT("Up/Down arrows: change number of segments") );
            m_pFont->DrawText( 2, 80, D3DCOLOR_ARGB(255,255,255,255), 
                TEXT("W: toggle wireframe") );
        }
        else
        {
            m_pFont->DrawText( 2, 60, D3DCOLOR_ARGB(255,255,255,255), 
                TEXT("Press F1 for Help") );
        }
#endif

        // End the scene.
        m_pDevice->EndScene();
    }
}




//-----------------------------------------------------------------------------
// Name: InitDeviceObjects()
// Desc: This creates all device-dependent managed objects, such as managed
//       textures and managed vertex buffers.
//-----------------------------------------------------------------------------
void CMyD3DApplication::InitDeviceObjects()
{
#ifdef _FONT_
    // Initialize the font's internal textures
    m_pFont->InitDeviceObjects( m_pDevice );
#endif

    // Create a vertex buffer and fill it with our vertices.
    UINT numVerts = sizeof(g_vTeapotData) / (3 * sizeof(float));
    m_numPatches = numVerts / (4 * 4);

    if( FAILED( m_pDevice->CreateVertexBuffer( numVerts*sizeof(CUSTOMVERTEX),
        D3DUSAGE_RTPATCHES, 0, D3DPOOL_MANAGED, &m_pVB ) ) )
    {
        return;
    }

    CUSTOMVERTEX* pVertices;
    if( FAILED( m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
        return;

    for( UINT i = 0; i < numVerts; i++ ) 
    {
        pVertices[i].p = g_vTeapotData[i];
    }
    m_pVB->Unlock();
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc: Restore device-memory objects and state after a device is created or
//       resized.
//-----------------------------------------------------------------------------
void CMyD3DApplication::RestoreDeviceObjects()
{
    HRESULT hr;

#ifdef _FONT_
    m_pFont->RestoreDeviceObjects();
#endif

    // Set up our view matrix. A view matrix can be defined given an eye point,
    // a point to lookat, and a direction for which way is up. 
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 3.0f,-400.0f ), 
                                  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ), 
                                  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
    m_pDevice->SetTransform( D3DTS_VIEW, &matView );

    // Set up world matrix
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pDevice->SetTransform( D3DTS_WORLD, &matWorld );

    D3DXMATRIX matProj;
    FLOAT fAspect = ((FLOAT)m_BackBufferDesc.Width) / m_BackBufferDesc.Height;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, fAspect, 1.0f, 800.0f );
    m_pDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    m_pDevice->SetRenderState( D3DRS_DITHERENABLE, TRUE );
    m_pDevice->SetRenderState( D3DRS_ZENABLE,      TRUE );
    m_pDevice->SetRenderState( D3DRS_LIGHTING,     TRUE );
    m_pDevice->SetRenderState( D3DRS_NORMALIZENORMALS, TRUE );

    m_pDevice->SetRenderState( D3DRS_AMBIENT, 0x00202020 );

    // Set up a material. The material here just has the diffuse and ambient
    // colors set to white.
    D3DMATERIAL8 mtrl;
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = 1.0f;
    mtrl.Diffuse.g = mtrl.Ambient.g = 1.0f;
    mtrl.Diffuse.b = mtrl.Ambient.b = 1.0f;
    mtrl.Diffuse.a = mtrl.Ambient.a = 1.0f;
    m_pDevice->SetMaterial( &mtrl );

    // Set up a light
    D3DLIGHT8 light;
    light.Type         = D3DLIGHT_DIRECTIONAL;
    light.Diffuse.r    = light.Diffuse.g  = light.Diffuse.b  = 1.0f;
    light.Specular.r   = light.Specular.g = light.Specular.b = 0.0f;
    light.Ambient.r    = light.Ambient.g  = light.Ambient.b  = 0.3f;
    light.Position     = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &D3DXVECTOR3( 0.0f, 1.0f, 1.0f ) );
    light.Attenuation0 = light.Attenuation1 = light.Attenuation2 = 0.0f;
    light.Range        = sqrtf(FLT_MAX);
    m_pDevice->SetLight(0, &light );
    m_pDevice->LightEnable(0, TRUE );

    m_ArcBall.SetWindow( m_BackBufferDesc.Width, m_BackBufferDesc.Height, 1.0f );
    m_ArcBall.SetRadius( 1.0f );

    DWORD decl[] =
    {
       /* Vertex Data */
        D3DVSD_STREAM(0),
        D3DVSD_REG( D3DVSDE_POSITION,  D3DVSDT_FLOAT3),

        /* Data generation section implemented as a virtual stream */
        D3DVSD_STREAM_TESS(),

        /* Generate normal _using_ the position input and copy it to the normal register (output) */
        D3DVSD_TESSNORMAL( D3DVSDE_POSITION, D3DVSDE_NORMAL ),

        D3DVSD_END()
    };

    hr = m_pDevice->CreateVertexShader( decl, NULL, &m_hVShader, 0 );
    m_bRetessellate = TRUE;
}




//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: Called when the device-dependent objects are about to be lost.
//-----------------------------------------------------------------------------
void CMyD3DApplication::InvalidateDeviceObjects()
{
#ifdef _FONT_
    m_pFont->InvalidateDeviceObjects();
#endif

    for( UINT i = 0; i < m_numPatches; i++ ) 
        m_pDevice->DeletePatch(SURFACEHANDLEBASE + i);

    m_pDevice->DeleteVertexShader(m_hVShader);
}




//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Called when the app is exiting, or the device is being changed,
//       this function deletes any device dependent objects.
//-----------------------------------------------------------------------------
void CMyD3DApplication::DeleteDeviceObjects()
{
#ifdef _FONT_
    m_pFont->DeleteDeviceObjects();
#endif

    SAFE_RELEASE( m_pVB );
}




//-----------------------------------------------------------------------------
// Name: FinalCleanup()
// Desc: Called before the app exits, this function gives the app the chance
//       to cleanup after itself.
//-----------------------------------------------------------------------------
void CMyD3DApplication::FinalCleanup()
{
#ifdef _FONT_
    SAFE_DELETE( m_pFont );
#endif
}




//-----------------------------------------------------------------------------
// Name: ConfirmDevice()
// Desc: Called during device intialization, this code checks the device
//       for some minimum set of capabilities
//-----------------------------------------------------------------------------
bool CMyD3DApplication::ConfirmDevice( D3DCAPS8* pCaps, DWORD dwBehavior,
                                          D3DFORMAT Format )
{
    if( pCaps->DevCaps & D3DDEVCAPS_RTPATCHES )
        return true;
    else
        return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\regress\tiles.cpp ===
/*==========================================================================;
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       tiles.cpp
 *  Content:    Tests for tiling
 *
 ***************************************************************************/
 
#include "precomp.hpp" 

#define CLEARS 1000

//------------------------------------------------------------------------------
void TestTiles(D3DDevice* pDev)
{
    DWORD i;
    D3DTILE tile0;
    D3DTILE tile1;
    D3DTILE tile;
    CHAR buffer[200];

    CTimer time;

    pDev->GetTile(0, &tile0);
    pDev->GetTile(1, &tile1);

    DbgPrint("\n>> Timing tile effects...\n");

    // 1.  Time clears using stock tile setting.

    time.Start();
    for (i = 0; i < CLEARS; i++)
    {
        pDev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0, 0, 0);
    }
    pDev->BlockUntilIdle();
    time.Stop();
    sprintf(buffer, "Stock tile setting: %.2fms\n", time.getTime());
    OutputDebugStringA(buffer);

    // 2.  Disable tile for frame buffer.

    pDev->SetTile(0, NULL);

    time.Start();
    for (i = 0; i < CLEARS; i++)
    {
        pDev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0, 0, 0);
    }
    pDev->BlockUntilIdle();
    time.Stop();

    sprintf(buffer, "Frame buffer tile disabled: %.2fms\n", time.getTime());
    OutputDebugStringA(buffer);

    // 3.  Disable compression for Z buffer.

    tile = tile1;
    tile.Flags &= ~D3DTILE_FLAGS_ZCOMPRESS;

    pDev->SetTile(1, NULL);
    pDev->SetTile(1, &tile);

    time.Start();
    for (i = 0; i < CLEARS; i++)
    {
        pDev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0, 0, 0);
    }
    pDev->BlockUntilIdle();
    time.Stop();

    sprintf(buffer, "Also Z compression disabled: %.2fms\n", time.getTime());
    OutputDebugStringA(buffer);

    // 4.  Disable tiling completely for Z buffer.

    pDev->SetTile(1, NULL);

    time.Start();
    for (i = 0; i < CLEARS; i++)
    {
        pDev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0, 0, 0);
    }
    pDev->BlockUntilIdle();
    time.Stop();

    sprintf(buffer, "All tiling disabled: %.2fms\n", time.getTime());
    OutputDebugStringA(buffer);

    // 5.  Restore everything:

    pDev->SetTile(0, &tile0);
    pDev->SetTile(1, &tile1);

    ////////////////////////////////////////////////////////////////////////////

    D3DTexture* pDepth;
    D3DTexture* pColor;
    D3DTexture depth;
    D3DSurface* pOriginalColor;
    D3DSurface* pOriginalZ;
    D3DSurface* pColorSurface;
    D3DSurface* pDepthSurface;

    VOID* pBuffer = D3D_AllocContiguousMemory(2*1024*1024, D3DTILE_ALIGNMENT);

    CheckHR(pDev->CreateTexture(1024, 1024, 0, 0, D3DFMT_LIN_D16, 0, &pDepth));
    CheckHR(pDev->CreateTexture(1024, 1024, 0, 0, D3DFMT_LIN_R5G6B5, 0, &pColor));

    // Create our own depth surface by cheating and copying the D3D created
    // one.  We really need to expose a helper function for constructing
    // these...

    depth = *pDepth;
    depth.Data = 0;
    depth.Common &= ~D3DCOMMON_D3DCREATED;
    depth.Register(pBuffer);

    pDev->GetRenderTarget(&pOriginalColor);
    pDev->GetDepthStencilSurface(&pOriginalZ);
    pColor->GetSurfaceLevel(0, &pColorSurface);
    depth.GetSurfaceLevel(0, &pDepthSurface);
    pDev->SetRenderTarget(pColorSurface, pDepthSurface);

    // 1.  Time clears using stock Z target.

    time.Start();
    for (i = 0; i < CLEARS; i++)
    {
        pDev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0, 0, 0);
    }
    pDev->BlockUntilIdle();
    time.Stop();
    sprintf(buffer, "Stock Z target: %.2fms\n", time.getTime());
    OutputDebugStringA(buffer);

    // 2.  Time clears using a partially compressed Z buffer.

    tile.Flags = D3DTILE_FLAGS_ZBUFFER | D3DTILE_FLAGS_ZCOMPRESS | D3DTILE_FLAGS_Z16BITS;
    tile.Pitch = 2*1024;
    tile.pMemory = pBuffer;
    tile.Size = 2*1024*1024;
    tile.ZStartTag = D3DTILE_MAXTAGS - (D3DTILE_ALIGNMENT / D3DTILE_TAGSIZE);
    tile.ZOffset = D3DTILE_ALIGNMENT;

    CheckHR(pDev->SetTile(4, &tile));

    // Test debug code:
    // CheckHR(pDev->SetTile(4, &tile));

    time.Start();
    for (i = 0; i < CLEARS; i++)
    {
        pDev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0, 0, 0);
    }
    pDev->BlockUntilIdle();
    time.Stop();
    sprintf(buffer, "Partially compressed Z target: %.2fms\n", time.getTime());
    OutputDebugStringA(buffer);

    // 3.  Time clears using a fully compressed Z buffer.

    tile.ZStartTag = D3DTILE_ZENDTAG(&tile1);
    tile.ZOffset = 0;
    pDev->SetTile(4, NULL);
    pDev->SetTile(4, &tile);

    time.Start();
    for (i = 0; i < CLEARS; i++)
    {
        pDev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0, 0, 0);
    }
    pDev->BlockUntilIdle();
    time.Stop();
    sprintf(buffer, "Fully compressed Z target: %.2fms (start tag: %li)\n", time.getTime(), tile.ZStartTag);
    OutputDebugStringA(buffer);

    pDev->SetRenderTarget(pOriginalColor, pOriginalZ);
    pDepth->Release();
    pColor->Release();
    pDepthSurface->Release();
    pColorSurface->Release();

    // 4.  Verify main target is unaffected with another tile in effect.

    time.Start();
    for (i = 0; i < CLEARS; i++)
    {
        pDev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0, 0, 0);
    }
    pDev->BlockUntilIdle();
    time.Stop();

    sprintf(buffer, "Main target with another tile in effect: %.2fms\n", time.getTime());
    OutputDebugStringA(buffer);

    pDev->SetTile(4, NULL);
    D3D_FreeContiguousMemory(pBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\simple\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\rtpatch\sources.inc ===
TARGETNAME=rtpatch
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    rtpatch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\satest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// vc7.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\simple\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

#include <xgraphics.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, 0) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    UINT BitsPerPixel =

#ifdef XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\satest\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>
#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include "d3d8-xbox.h"
#endif

#include "xgraphics.h"

#define RELEASE(x) \
    do { if(x) { x->Release(); x = NULL; } } while(0)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\simple\sdkcommon.h ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    SDKCommon.h

Abstract:

    Common header files and macros for the Xbox SDK

Revision History:

--*/

#if !defined(SDK_HEADER_SDKCOMMON_H)
#define SDK_HEADER_SDKCOMMON_H

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef STRICT
#define STRICT 1
#endif
#undef D3D_OVERLOADS

// Xbox headers

#if defined(XBOX)
    #include <xtl.h>
#else
    #include <windows.h>
#endif


#pragma warning (disable:4850)

#if defined(__cplusplus)
extern "C" {
#endif // __cplusplus

// __$ReturnUdt is the address of the destination when returning a structure
// It is Microsoft specific so will need to be adjusted to work with other
// compilers. The best way is to declare a local of the correct type and
// then return in.
#define that_ptr __$ReturnUdt

#if defined(__cplusplus)
}
#endif // __cplusplus

#endif //#ifndef SDK_HEADER_RENDERSURFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\rtpatch\teapot.h ===
// Utah Teapot Bezier Patch Data
const D3DXVECTOR3 g_vTeapotData[] = 
{
    // Back
    D3DXVECTOR3(-80.00f,  0.00f,-30.00f ),     D3DXVECTOR3(-80.00f,-44.80f,-30.00f ),
    D3DXVECTOR3(-44.80f,-80.00f,-30.00f ),     D3DXVECTOR3(  0.00f,-80.00f,-30.00f ),
    D3DXVECTOR3(-80.00f,  0.00f,-12.00f ),     D3DXVECTOR3(-80.00f,-44.80f,-12.00f ),
    D3DXVECTOR3(-44.80f,-80.00f,-12.00f ),     D3DXVECTOR3(  0.00f,-80.00f,-12.00f ),
    D3DXVECTOR3(-60.00f,  0.00f, -3.00f ),     D3DXVECTOR3(-60.00f,-33.60f, -3.00f ),
    D3DXVECTOR3(-33.60f,-60.00f, -3.00f ),     D3DXVECTOR3(  0.00f,-60.00f, -3.00f ),
    D3DXVECTOR3(-60.00f,  0.00f,  0.00f ),     D3DXVECTOR3(-60.00f,-33.60f,  0.00f ),
    D3DXVECTOR3(-33.60f,-60.00f,  0.00f ),     D3DXVECTOR3(  0.00f,-60.00f,  0.00f ),

    D3DXVECTOR3(  0.00f,-80.00f,-30.00f ),     D3DXVECTOR3( 44.80f,-80.00f,-30.00f ),
    D3DXVECTOR3( 80.00f,-44.80f,-30.00f ),     D3DXVECTOR3( 80.00f,  0.00f,-30.00f ),
    D3DXVECTOR3(  0.00f,-80.00f,-12.00f ),     D3DXVECTOR3( 44.80f,-80.00f,-12.00f ),
    D3DXVECTOR3( 80.00f,-44.80f,-12.00f ),     D3DXVECTOR3( 80.00f,  0.00f,-12.00f ),
    D3DXVECTOR3(  0.00f,-60.00f, -3.00f ),     D3DXVECTOR3( 33.60f,-60.00f, -3.00f ),
    D3DXVECTOR3( 60.00f,-33.60f, -3.00f ),     D3DXVECTOR3( 60.00f,  0.00f, -3.00f ),
    D3DXVECTOR3(  0.00f,-60.00f,  0.00f ),     D3DXVECTOR3( 33.60f,-60.00f,  0.00f ),
    D3DXVECTOR3( 60.00f,-33.60f,  0.00f ),     D3DXVECTOR3( 60.00f,  0.00f,  0.00f ),

    D3DXVECTOR3(-60.00f,  0.00f,-90.00f ),     D3DXVECTOR3(-60.00f,-33.60f,-90.00f ),
    D3DXVECTOR3(-33.60f,-60.00f,-90.00f ),     D3DXVECTOR3(  0.00f,-60.00f,-90.00f ),
    D3DXVECTOR3(-70.00f,  0.00f,-69.00f ),     D3DXVECTOR3(-70.00f,-39.20f,-69.00f ),
    D3DXVECTOR3(-39.20f,-70.00f,-69.00f ),     D3DXVECTOR3(  0.00f,-70.00f,-69.00f ),
    D3DXVECTOR3(-80.00f,  0.00f,-48.00f ),     D3DXVECTOR3(-80.00f,-44.80f,-48.00f ),
    D3DXVECTOR3(-44.80f,-80.00f,-48.00f ),     D3DXVECTOR3(  0.00f,-80.00f,-48.00f ),
    D3DXVECTOR3(-80.00f,  0.00f,-30.00f ),     D3DXVECTOR3(-80.00f,-44.80f,-30.00f ),
    D3DXVECTOR3(-44.80f,-80.00f,-30.00f ),     D3DXVECTOR3(  0.00f,-80.00f,-30.00f ),

    D3DXVECTOR3(  0.00f,-60.00f,-90.00f ),     D3DXVECTOR3( 33.60f,-60.00f,-90.00f ),
    D3DXVECTOR3( 60.00f,-33.60f,-90.00f ),     D3DXVECTOR3( 60.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f,-70.00f,-69.00f ),     D3DXVECTOR3( 39.20f,-70.00f,-69.00f ),
    D3DXVECTOR3( 70.00f,-39.20f,-69.00f ),     D3DXVECTOR3( 70.00f,  0.00f,-69.00f ),
    D3DXVECTOR3(  0.00f,-80.00f,-48.00f ),     D3DXVECTOR3( 44.80f,-80.00f,-48.00f ),
    D3DXVECTOR3( 80.00f,-44.80f,-48.00f ),     D3DXVECTOR3( 80.00f,  0.00f,-48.00f ),
    D3DXVECTOR3(  0.00f,-80.00f,-30.00f ),     D3DXVECTOR3( 44.80f,-80.00f,-30.00f ),
    D3DXVECTOR3( 80.00f,-44.80f,-30.00f ),     D3DXVECTOR3( 80.00f,  0.00f,-30.00f ),

    D3DXVECTOR3(-56.00f,  0.00f,-90.00f ),     D3DXVECTOR3(-56.00f,-31.36f,-90.00f ),
    D3DXVECTOR3(-31.36f,-56.00f,-90.00f ),     D3DXVECTOR3(  0.00f,-56.00f,-90.00f ),
    D3DXVECTOR3(-53.50f,  0.00f,-95.25f ),     D3DXVECTOR3(-53.50f,-29.96f,-95.25f ),
    D3DXVECTOR3(-29.96f,-53.50f,-95.25f ),     D3DXVECTOR3(  0.00f,-53.50f,-95.25f ),
    D3DXVECTOR3(-57.50f,  0.00f,-95.25f ),     D3DXVECTOR3(-57.50f,-32.20f,-95.25f ),
    D3DXVECTOR3(-32.20f,-57.50f,-95.25f ),     D3DXVECTOR3(  0.00f,-57.50f,-95.25f ),
    D3DXVECTOR3(-60.00f,  0.00f,-90.00f ),     D3DXVECTOR3(-60.00f,-33.60f,-90.00f ),
    D3DXVECTOR3(-33.60f,-60.00f,-90.00f ),     D3DXVECTOR3(  0.00f,-60.00f,-90.00f ),

    D3DXVECTOR3(  0.00f,-56.00f,-90.00f ),     D3DXVECTOR3( 31.36f,-56.00f,-90.00f ),
    D3DXVECTOR3( 56.00f,-31.36f,-90.00f ),     D3DXVECTOR3( 56.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f,-53.50f,-95.25f ),     D3DXVECTOR3( 29.96f,-53.50f,-95.25f ),
    D3DXVECTOR3( 53.50f,-29.96f,-95.25f ),     D3DXVECTOR3( 53.50f,  0.00f,-95.25f ),
    D3DXVECTOR3(  0.00f,-57.50f,-95.25f ),     D3DXVECTOR3( 32.20f,-57.50f,-95.25f ),
    D3DXVECTOR3( 57.50f,-32.20f,-95.25f ),     D3DXVECTOR3( 57.50f,  0.00f,-95.25f ),
    D3DXVECTOR3(  0.00f,-60.00f,-90.00f ),     D3DXVECTOR3( 33.60f,-60.00f,-90.00f ),
    D3DXVECTOR3( 60.00f,-33.60f,-90.00f ),     D3DXVECTOR3( 60.00f,  0.00f,-90.00f ),

    // Front
    D3DXVECTOR3( 80.00f,  0.00f,-30.00f ),     D3DXVECTOR3( 80.00f, 44.80f,-30.00f ),
    D3DXVECTOR3( 44.80f, 80.00f,-30.00f ),     D3DXVECTOR3(  0.00f, 80.00f,-30.00f ),
    D3DXVECTOR3( 80.00f,  0.00f,-12.00f ),     D3DXVECTOR3( 80.00f, 44.80f,-12.00f ),
    D3DXVECTOR3( 44.80f, 80.00f,-12.00f ),     D3DXVECTOR3(  0.00f, 80.00f,-12.00f ),
    D3DXVECTOR3( 60.00f,  0.00f, -3.00f ),     D3DXVECTOR3( 60.00f, 33.60f, -3.00f ),
    D3DXVECTOR3( 33.60f, 60.00f, -3.00f ),     D3DXVECTOR3(  0.00f, 60.00f, -3.00f ),
    D3DXVECTOR3( 60.00f,  0.00f,  0.00f ),     D3DXVECTOR3( 60.00f, 33.60f,  0.00f ),
    D3DXVECTOR3( 33.60f, 60.00f,  0.00f ),     D3DXVECTOR3(  0.00f, 60.00f,  0.00f ),

    D3DXVECTOR3(  0.00f, 80.00f,-30.00f ),     D3DXVECTOR3(-44.80f, 80.00f,-30.00f ),
    D3DXVECTOR3(-80.00f, 44.80f,-30.00f ),     D3DXVECTOR3(-80.00f,  0.00f,-30.00f ),
    D3DXVECTOR3(  0.00f, 80.00f,-12.00f ),     D3DXVECTOR3(-44.80f, 80.00f,-12.00f ),
    D3DXVECTOR3(-80.00f, 44.80f,-12.00f ),     D3DXVECTOR3(-80.00f,  0.00f,-12.00f ),
    D3DXVECTOR3(  0.00f, 60.00f, -3.00f ),     D3DXVECTOR3(-33.60f, 60.00f, -3.00f ),
    D3DXVECTOR3(-60.00f, 33.60f, -3.00f ),     D3DXVECTOR3(-60.00f,  0.00f, -3.00f ),
    D3DXVECTOR3(  0.00f, 60.00f,  0.00f ),     D3DXVECTOR3(-33.60f, 60.00f,  0.00f ),
    D3DXVECTOR3(-60.00f, 33.60f,  0.00f ),     D3DXVECTOR3(-60.00f,  0.00f,  0.00f ),

    D3DXVECTOR3( 60.00f,  0.00f,-90.00f ),     D3DXVECTOR3( 60.00f, 33.60f,-90.00f ),
    D3DXVECTOR3( 33.60f, 60.00f,-90.00f ),     D3DXVECTOR3(  0.00f, 60.00f,-90.00f ),
    D3DXVECTOR3( 70.00f,  0.00f,-69.00f ),     D3DXVECTOR3( 70.00f, 39.20f,-69.00f ),
    D3DXVECTOR3( 39.20f, 70.00f,-69.00f ),     D3DXVECTOR3(  0.00f, 70.00f,-69.00f ),
    D3DXVECTOR3( 80.00f,  0.00f,-48.00f ),     D3DXVECTOR3( 80.00f, 44.80f,-48.00f ),
    D3DXVECTOR3( 44.80f, 80.00f,-48.00f ),     D3DXVECTOR3(  0.00f, 80.00f,-48.00f ),
    D3DXVECTOR3( 80.00f,  0.00f,-30.00f ),     D3DXVECTOR3( 80.00f, 44.80f,-30.00f ),
    D3DXVECTOR3( 44.80f, 80.00f,-30.00f ),     D3DXVECTOR3(  0.00f, 80.00f,-30.00f ),

    D3DXVECTOR3(  0.00f, 60.00f,-90.00f ),     D3DXVECTOR3(-33.60f, 60.00f,-90.00f ),
    D3DXVECTOR3(-60.00f, 33.60f,-90.00f ),     D3DXVECTOR3(-60.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f, 70.00f,-69.00f ),     D3DXVECTOR3(-39.20f, 70.00f,-69.00f ),
    D3DXVECTOR3(-70.00f, 39.20f,-69.00f ),     D3DXVECTOR3(-70.00f,  0.00f,-69.00f ),
    D3DXVECTOR3(  0.00f, 80.00f,-48.00f ),     D3DXVECTOR3(-44.80f, 80.00f,-48.00f ),
    D3DXVECTOR3(-80.00f, 44.80f,-48.00f ),     D3DXVECTOR3(-80.00f,  0.00f,-48.00f ),
    D3DXVECTOR3(  0.00f, 80.00f,-30.00f ),     D3DXVECTOR3(-44.80f, 80.00f,-30.00f ),
    D3DXVECTOR3(-80.00f, 44.80f,-30.00f ),     D3DXVECTOR3(-80.00f,  0.00f,-30.00f ),

    D3DXVECTOR3( 56.00f,  0.00f,-90.00f ),     D3DXVECTOR3( 56.00f, 31.36f,-90.00f ),
    D3DXVECTOR3( 31.36f, 56.00f,-90.00f ),     D3DXVECTOR3(  0.00f, 56.00f,-90.00f ),
    D3DXVECTOR3( 53.50f,  0.00f,-95.25f ),     D3DXVECTOR3( 53.50f, 29.96f,-95.25f ),
    D3DXVECTOR3( 29.96f, 53.50f,-95.25f ),     D3DXVECTOR3(  0.00f, 53.50f,-95.25f ),
    D3DXVECTOR3( 57.50f,  0.00f,-95.25f ),     D3DXVECTOR3( 57.50f, 32.20f,-95.25f ),
    D3DXVECTOR3( 32.20f, 57.50f,-95.25f ),     D3DXVECTOR3(  0.00f, 57.50f,-95.25f ),
    D3DXVECTOR3( 60.00f,  0.00f,-90.00f ),     D3DXVECTOR3( 60.00f, 33.60f,-90.00f ),
    D3DXVECTOR3( 33.60f, 60.00f,-90.00f ),     D3DXVECTOR3(  0.00f, 60.00f,-90.00f ),

    D3DXVECTOR3(  0.00f, 56.00f,-90.00f ),     D3DXVECTOR3(-31.36f, 56.00f,-90.00f ),
    D3DXVECTOR3(-56.00f, 31.36f,-90.00f ),     D3DXVECTOR3(-56.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f, 53.50f,-95.25f ),     D3DXVECTOR3(-29.96f, 53.50f,-95.25f ),
    D3DXVECTOR3(-53.50f, 29.96f,-95.25f ),     D3DXVECTOR3(-53.50f,  0.00f,-95.25f ),
    D3DXVECTOR3(  0.00f, 57.50f,-95.25f ),     D3DXVECTOR3(-32.20f, 57.50f,-95.25f ),
    D3DXVECTOR3(-57.50f, 32.20f,-95.25f ),     D3DXVECTOR3(-57.50f,  0.00f,-95.25f ),
    D3DXVECTOR3(  0.00f, 60.00f,-90.00f ),     D3DXVECTOR3(-33.60f, 60.00f,-90.00f ),
    D3DXVECTOR3(-60.00f, 33.60f,-90.00f ),     D3DXVECTOR3(-60.00f,  0.00f,-90.00f ),

    // Handle
    D3DXVECTOR3( -64.00f,  0.00f,-75.00f ),    D3DXVECTOR3( -64.00f, 12.00f,-75.00f ),
    D3DXVECTOR3( -60.00f, 12.00f,-84.00f ),    D3DXVECTOR3( -60.00f,  0.00f,-84.00f ),
    D3DXVECTOR3( -92.00f,  0.00f,-75.00f ),    D3DXVECTOR3( -92.00f, 12.00f,-75.00f ),
    D3DXVECTOR3(-100.00f, 12.00f,-84.00f ),    D3DXVECTOR3(-100.00f,  0.00f,-84.00f ),
    D3DXVECTOR3(-108.00f,  0.00f,-75.00f ),    D3DXVECTOR3(-108.00f, 12.00f,-75.00f ),
    D3DXVECTOR3(-120.00f, 12.00f,-84.00f ),    D3DXVECTOR3(-120.00f,  0.00f,-84.00f ),
    D3DXVECTOR3(-108.00f,  0.00f,-66.00f ),    D3DXVECTOR3(-108.00f, 12.00f,-66.00f ),
    D3DXVECTOR3(-120.00f, 12.00f,-66.00f ),    D3DXVECTOR3(-120.00f,  0.00f,-66.00f ),

    D3DXVECTOR3( -60.00f,  0.00f,-84.00f ),    D3DXVECTOR3( -60.00f,-12.00f,-84.00f ),
    D3DXVECTOR3( -64.00f,-12.00f,-75.00f ),    D3DXVECTOR3( -64.00f,  0.00f,-75.00f ),
    D3DXVECTOR3(-100.00f,  0.00f,-84.00f ),    D3DXVECTOR3(-100.00f,-12.00f,-84.00f ),
    D3DXVECTOR3( -92.00f,-12.00f,-75.00f ),    D3DXVECTOR3( -92.00f,  0.00f,-75.00f ),
    D3DXVECTOR3(-120.00f,  0.00f,-84.00f ),    D3DXVECTOR3(-120.00f,-12.00f,-84.00f ),
    D3DXVECTOR3(-108.00f,-12.00f,-75.00f ),    D3DXVECTOR3(-108.00f,  0.00f,-75.00f ),
    D3DXVECTOR3(-120.00f,  0.00f,-66.00f ),    D3DXVECTOR3(-120.00f,-12.00f,-66.00f ),
    D3DXVECTOR3(-108.00f,-12.00f,-66.00f ),    D3DXVECTOR3(-108.00f,  0.00f,-66.00f ),

    D3DXVECTOR3(-108.00f,  0.00f,-66.00f ),    D3DXVECTOR3(-108.00f, 12.00f,-66.00f ),
    D3DXVECTOR3(-120.00f, 12.00f,-66.00f ),    D3DXVECTOR3(-120.00f,  0.00f,-66.00f ),
    D3DXVECTOR3(-108.00f,  0.00f,-57.00f ),    D3DXVECTOR3(-108.00f, 12.00f,-57.00f ),
    D3DXVECTOR3(-120.00f, 12.00f,-48.00f ),    D3DXVECTOR3(-120.00f,  0.00f,-48.00f ),
    D3DXVECTOR3(-100.00f,  0.00f,-39.00f ),    D3DXVECTOR3(-100.00f, 12.00f,-39.00f ),
    D3DXVECTOR3(-106.00f, 12.00f,-31.50f ),    D3DXVECTOR3(-106.00f,  0.00f,-31.50f ),
    D3DXVECTOR3( -80.00f,  0.00f,-30.00f ),    D3DXVECTOR3( -80.00f, 12.00f,-30.00f ),
    D3DXVECTOR3( -76.00f, 12.00f,-18.00f ),    D3DXVECTOR3( -76.00f,  0.00f,-18.00f ),

    D3DXVECTOR3(-120.00f,  0.00f,-66.00f ),    D3DXVECTOR3(-120.00f,-12.00f,-66.00f ),
    D3DXVECTOR3(-108.00f,-12.00f,-66.00f ),    D3DXVECTOR3(-108.00f,  0.00f,-66.00f ),
    D3DXVECTOR3(-120.00f,  0.00f,-48.00f ),    D3DXVECTOR3(-120.00f,-12.00f,-48.00f ),
    D3DXVECTOR3(-108.00f,-12.00f,-57.00f ),    D3DXVECTOR3(-108.00f,  0.00f,-57.00f ),
    D3DXVECTOR3(-106.00f,  0.00f,-31.50f ),    D3DXVECTOR3(-106.00f,-12.00f,-31.50f ),
    D3DXVECTOR3(-100.00f,-12.00f,-39.00f ),    D3DXVECTOR3(-100.00f,  0.00f,-39.00f ),
    D3DXVECTOR3( -76.00f,  0.00f,-18.00f ),    D3DXVECTOR3( -76.00f,-12.00f,-18.00f ),
    D3DXVECTOR3( -80.00f,-12.00f,-30.00f ),    D3DXVECTOR3( -80.00f,  0.00f,-30.00f ),

    // Spout
    D3DXVECTOR3( 68.00f,  0.00f,-51.00f ),     D3DXVECTOR3( 68.00f, 26.40f,-51.00f ),
    D3DXVECTOR3( 68.00f, 26.40f,-18.00f ),     D3DXVECTOR3( 68.00f,  0.00f,-18.00f ),
    D3DXVECTOR3(104.00f,  0.00f,-51.00f ),     D3DXVECTOR3(104.00f, 26.40f,-51.00f ),
    D3DXVECTOR3(124.00f, 26.40f,-27.00f ),     D3DXVECTOR3(124.00f,  0.00f,-27.00f ),
    D3DXVECTOR3( 92.00f,  0.00f,-78.00f ),     D3DXVECTOR3( 92.00f, 10.00f,-78.00f ),
    D3DXVECTOR3( 96.00f, 10.00f,-75.00f ),     D3DXVECTOR3( 96.00f,  0.00f,-75.00f ),
    D3DXVECTOR3(108.00f,  0.00f,-90.00f ),     D3DXVECTOR3(108.00f, 10.00f,-90.00f ),
    D3DXVECTOR3(132.00f, 10.00f,-90.00f ),     D3DXVECTOR3(132.00f,  0.00f,-90.00f ),

    D3DXVECTOR3( 68.00f,  0.00f,-18.00f ),     D3DXVECTOR3( 68.00f,-26.40f,-18.00f ),
    D3DXVECTOR3( 68.00f,-26.40f,-51.00f ),     D3DXVECTOR3( 68.00f,  0.00f,-51.00f ),
    D3DXVECTOR3(124.00f,  0.00f,-27.00f ),     D3DXVECTOR3(124.00f,-26.40f,-27.00f ),
    D3DXVECTOR3(104.00f,-26.40f,-51.00f ),     D3DXVECTOR3(104.00f,  0.00f,-51.00f ),
    D3DXVECTOR3( 96.00f,  0.00f,-75.00f ),     D3DXVECTOR3( 96.00f,-10.00f,-75.00f ),
    D3DXVECTOR3( 92.00f,-10.00f,-78.00f ),     D3DXVECTOR3( 92.00f,  0.00f,-78.00f ),
    D3DXVECTOR3(132.00f,  0.00f,-90.00f ),     D3DXVECTOR3(132.00f,-10.00f,-90.00f ),
    D3DXVECTOR3(108.00f,-10.00f,-90.00f ),     D3DXVECTOR3(108.00f,  0.00f,-90.00f ),

    D3DXVECTOR3(108.00f,  0.00f,-90.00f ),     D3DXVECTOR3(108.00f, 10.00f,-90.00f ),
    D3DXVECTOR3(132.00f, 10.00f,-90.00f ),     D3DXVECTOR3(132.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(112.00f,  0.00f,-93.00f ),     D3DXVECTOR3(112.00f, 10.00f,-93.00f ),
    D3DXVECTOR3(141.00f, 10.00f,-93.75f ),     D3DXVECTOR3(141.00f,  0.00f,-93.75f ),
    D3DXVECTOR3(116.00f,  0.00f,-93.00f ),     D3DXVECTOR3(116.00f,  6.00f,-93.00f ),
    D3DXVECTOR3(138.00f,  6.00f,-94.50f ),     D3DXVECTOR3(138.00f,  0.00f,-94.50f ),
    D3DXVECTOR3(112.00f,  0.00f,-90.00f ),     D3DXVECTOR3(112.00f,  6.00f,-90.00f ),
    D3DXVECTOR3(128.00f,  6.00f,-90.00f ),     D3DXVECTOR3(128.00f,  0.00f,-90.00f ),

    D3DXVECTOR3(132.00f,  0.00f,-90.00f ),     D3DXVECTOR3(132.00f,-10.00f,-90.00f ),
    D3DXVECTOR3(108.00f,-10.00f,-90.00f ),     D3DXVECTOR3(108.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(141.00f,  0.00f,-93.75f ),     D3DXVECTOR3(141.00f,-10.00f,-93.75f ),
    D3DXVECTOR3(112.00f,-10.00f,-93.00f ),     D3DXVECTOR3(112.00f,  0.00f,-93.00f ),
    D3DXVECTOR3(138.00f,  0.00f,-94.50f ),     D3DXVECTOR3(138.00f, -6.00f,-94.50f ),
    D3DXVECTOR3(116.00f, -6.00f,-93.00f ),     D3DXVECTOR3(116.00f,  0.00f,-93.00f ),
    D3DXVECTOR3(128.00f,  0.00f,-90.00f ),     D3DXVECTOR3(128.00f, -6.00f,-90.00f ),
    D3DXVECTOR3(112.00f, -6.00f,-90.00f ),     D3DXVECTOR3(112.00f,  0.00f,-90.00f ),

    // Lip
    D3DXVECTOR3( 50.00f,  0.00f,-90.00f ),     D3DXVECTOR3( 50.00f, 28.00f,-90.00f ),
    D3DXVECTOR3( 28.00f, 50.00f,-90.00f ),     D3DXVECTOR3(  0.00f, 50.00f,-90.00f ),
    D3DXVECTOR3( 52.00f,  0.00f,-90.00f ),     D3DXVECTOR3( 52.00f, 29.12f,-90.00f ),
    D3DXVECTOR3( 29.12f, 52.00f,-90.00f ),     D3DXVECTOR3(  0.00f, 52.00f,-90.00f ),
    D3DXVECTOR3( 54.00f,  0.00f,-90.00f ),     D3DXVECTOR3( 54.00f, 30.24f,-90.00f ),
    D3DXVECTOR3( 30.24f, 54.00f,-90.00f ),     D3DXVECTOR3(  0.00f, 54.00f,-90.00f ),
    D3DXVECTOR3( 56.00f,  0.00f,-90.00f ),     D3DXVECTOR3( 56.00f, 31.36f,-90.00f ),
    D3DXVECTOR3( 31.36f, 56.00f,-90.00f ),     D3DXVECTOR3(  0.00f, 56.00f,-90.00f ),

    D3DXVECTOR3(  0.00f, 50.00f,-90.00f ),     D3DXVECTOR3(-28.00f, 50.00f,-90.00f ),
    D3DXVECTOR3(-50.00f, 28.00f,-90.00f ),     D3DXVECTOR3(-50.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f, 52.00f,-90.00f ),     D3DXVECTOR3(-29.12f, 52.00f,-90.00f ),
    D3DXVECTOR3(-52.00f, 29.12f,-90.00f ),     D3DXVECTOR3(-52.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f, 54.00f,-90.00f ),     D3DXVECTOR3(-30.24f, 54.00f,-90.00f ),
    D3DXVECTOR3(-54.00f, 30.24f,-90.00f ),     D3DXVECTOR3(-54.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f, 56.00f,-90.00f ),     D3DXVECTOR3(-31.36f, 56.00f,-90.00f ),
    D3DXVECTOR3(-56.00f, 31.36f,-90.00f ),     D3DXVECTOR3(-56.00f,  0.00f,-90.00f ),

    D3DXVECTOR3(-50.00f,  0.00f,-90.00f ),     D3DXVECTOR3(-50.00f,-28.00f,-90.00f ),
    D3DXVECTOR3(-28.00f,-50.00f,-90.00f ),     D3DXVECTOR3(  0.00f,-50.00f,-90.00f ),
    D3DXVECTOR3(-52.00f,  0.00f,-90.00f ),     D3DXVECTOR3(-52.00f,-29.12f,-90.00f ),
    D3DXVECTOR3(-29.12f,-52.00f,-90.00f ),     D3DXVECTOR3(  0.00f,-52.00f,-90.00f ),
    D3DXVECTOR3(-54.00f,  0.00f,-90.00f ),     D3DXVECTOR3(-54.00f,-30.24f,-90.00f ),
    D3DXVECTOR3(-30.24f,-54.00f,-90.00f ),     D3DXVECTOR3(  0.00f,-54.00f,-90.00f ),
    D3DXVECTOR3(-56.00f,  0.00f,-90.00f ),     D3DXVECTOR3(-56.00f,-31.36f,-90.00f ),
    D3DXVECTOR3(-31.36f,-56.00f,-90.00f ),     D3DXVECTOR3(  0.00f,-56.00f,-90.00f ),

    D3DXVECTOR3(  0.00f,-50.00f,-90.00f ),     D3DXVECTOR3( 28.00f,-50.00f,-90.00f ),
    D3DXVECTOR3( 50.00f,-28.00f,-90.00f ),     D3DXVECTOR3( 50.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f,-52.00f,-90.00f ),     D3DXVECTOR3( 29.12f,-52.00f,-90.00f ),
    D3DXVECTOR3( 52.00f,-29.12f,-90.00f ),     D3DXVECTOR3( 52.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f,-54.00f,-90.00f ),     D3DXVECTOR3( 30.24f,-54.00f,-90.00f ),
    D3DXVECTOR3( 54.00f,-30.24f,-90.00f ),     D3DXVECTOR3( 54.00f,  0.00f,-90.00f ),
    D3DXVECTOR3(  0.00f,-56.00f,-90.00f ),     D3DXVECTOR3( 31.36f,-56.00f,-90.00f ),
    D3DXVECTOR3( 56.00f,-31.36f,-90.00f ),     D3DXVECTOR3( 56.00f,  0.00f,-90.00f ),

    // Lid
    D3DXVECTOR3(  8.00f,  0.00f,-102.00f ),     D3DXVECTOR3(  8.00f,  4.48f,-102.00f ),
    D3DXVECTOR3(  4.48f,  8.00f,-102.00f ),     D3DXVECTOR3(  0.00f,  8.00f,-102.00f ),
    D3DXVECTOR3( 16.00f,  0.00f, -96.00f ),     D3DXVECTOR3( 16.00f,  8.96f, -96.00f ),
    D3DXVECTOR3(  8.96f, 16.00f, -96.00f ),     D3DXVECTOR3(  0.00f, 16.00f, -96.00f ),
    D3DXVECTOR3( 52.00f,  0.00f, -96.00f ),     D3DXVECTOR3( 52.00f, 29.12f, -96.00f ),
    D3DXVECTOR3( 29.12f, 52.00f, -96.00f ),     D3DXVECTOR3(  0.00f, 52.00f, -96.00f ),
    D3DXVECTOR3( 52.00f,  0.00f, -90.00f ),     D3DXVECTOR3( 52.00f, 29.12f, -90.00f ),
    D3DXVECTOR3( 29.12f, 52.00f, -90.00f ),     D3DXVECTOR3(  0.00f, 52.00f, -90.00f ),

    D3DXVECTOR3(  0.00f,  8.00f,-102.00f ),     D3DXVECTOR3( -4.48f,  8.00f,-102.00f ),
    D3DXVECTOR3( -8.00f,  4.48f,-102.00f ),     D3DXVECTOR3( -8.00f,  0.00f,-102.00f ),
    D3DXVECTOR3(  0.00f, 16.00f, -96.00f ),     D3DXVECTOR3( -8.96f, 16.00f, -96.00f ),
    D3DXVECTOR3(-16.00f,  8.96f, -96.00f ),     D3DXVECTOR3(-16.00f,  0.00f, -96.00f ),
    D3DXVECTOR3(  0.00f, 52.00f, -96.00f ),     D3DXVECTOR3(-29.12f, 52.00f, -96.00f ),
    D3DXVECTOR3(-52.00f, 29.12f, -96.00f ),     D3DXVECTOR3(-52.00f,  0.00f, -96.00f ),
    D3DXVECTOR3(  0.00f, 52.00f, -90.00f ),     D3DXVECTOR3(-29.12f, 52.00f, -90.00f ),
    D3DXVECTOR3(-52.00f, 29.12f, -90.00f ),     D3DXVECTOR3(-52.00f,  0.00f, -90.00f ),

    D3DXVECTOR3( -8.00f,  0.00f,-102.00f ),     D3DXVECTOR3( -8.00f, -4.48f,-102.00f ),
    D3DXVECTOR3( -4.48f, -8.00f,-102.00f ),     D3DXVECTOR3(  0.00f, -8.00f,-102.00f ),
    D3DXVECTOR3(-16.00f,  0.00f, -96.00f ),     D3DXVECTOR3(-16.00f, -8.96f, -96.00f ),
    D3DXVECTOR3( -8.96f,-16.00f, -96.00f ),     D3DXVECTOR3(  0.00f,-16.00f, -96.00f ),
    D3DXVECTOR3(-52.00f,  0.00f, -96.00f ),     D3DXVECTOR3(-52.00f,-29.12f, -96.00f ),
    D3DXVECTOR3(-29.12f,-52.00f, -96.00f ),     D3DXVECTOR3(  0.00f,-52.00f, -96.00f ),
    D3DXVECTOR3(-52.00f,  0.00f, -90.00f ),     D3DXVECTOR3(-52.00f,-29.12f, -90.00f ),
    D3DXVECTOR3(-29.12f,-52.00f, -90.00f ),     D3DXVECTOR3(  0.00f,-52.00f, -90.00f ),

    D3DXVECTOR3(  0.00f, -8.00f,-102.00f ),     D3DXVECTOR3(  4.48f, -8.00f,-102.00f ),
    D3DXVECTOR3(  8.00f, -4.48f,-102.00f ),     D3DXVECTOR3(  8.00f,  0.00f,-102.00f ),
    D3DXVECTOR3(  0.00f,-16.00f, -96.00f ),     D3DXVECTOR3(  8.96f,-16.00f, -96.00f ),
    D3DXVECTOR3( 16.00f, -8.96f, -96.00f ),     D3DXVECTOR3( 16.00f,  0.00f, -96.00f ),
    D3DXVECTOR3(  0.00f,-52.00f, -96.00f ),     D3DXVECTOR3( 29.12f,-52.00f, -96.00f ),
    D3DXVECTOR3( 52.00f,-29.12f, -96.00f ),     D3DXVECTOR3( 52.00f,  0.00f, -96.00f ),
    D3DXVECTOR3(  0.00f,-52.00f, -90.00f ),     D3DXVECTOR3( 29.12f,-52.00f, -90.00f ),
    D3DXVECTOR3( 52.00f,-29.12f, -90.00f ),     D3DXVECTOR3( 52.00f,  0.00f, -90.00f ),

    // Knob
    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3( 32.00f,  0.00f,-120.00f ),     D3DXVECTOR3( 32.00f, 18.00f,-120.00f ),
    D3DXVECTOR3( 18.00f, 32.00f,-120.00f ),     D3DXVECTOR3(  0.00f, 32.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3(  8.00f,  0.00f,-102.00f ),     D3DXVECTOR3(  8.00f,  4.48f,-102.00f ),
    D3DXVECTOR3(  4.48f,  8.00f,-102.00f ),     D3DXVECTOR3(  0.00f,  8.00f,-102.00f ),

    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f, 32.00f,-120.00f ),     D3DXVECTOR3(-18.00f, 32.00f,-120.00f ),
    D3DXVECTOR3(-32.00f, 18.00f,-120.00f ),     D3DXVECTOR3(-32.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3(  0.00f,  8.00f,-102.00f ),     D3DXVECTOR3( -4.48f,  8.00f,-102.00f ),
    D3DXVECTOR3( -8.00f,  4.48f,-102.00f ),     D3DXVECTOR3( -8.00f,  0.00f,-102.00f ),

    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(-32.00f,  0.00f,-120.00f ),     D3DXVECTOR3(-32.00f,-18.00f,-120.00f ),
    D3DXVECTOR3(-18.00f,-32.00f,-120.00f ),     D3DXVECTOR3(  0.00f,-32.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3( -8.00f,  0.00f,-102.00f ),     D3DXVECTOR3( -8.00f, -4.48f,-102.00f ),
    D3DXVECTOR3( -4.48f, -8.00f,-102.00f ),     D3DXVECTOR3(  0.00f, -8.00f,-102.00f ),

    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,-32.00f,-120.00f ),     D3DXVECTOR3( 18.00f,-32.00f,-120.00f ),
    D3DXVECTOR3( 32.00f,-18.00f,-120.00f ),     D3DXVECTOR3( 32.00f,  0.00f,-120.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),     D3DXVECTOR3(  0.00f,  0.00f,-108.00f ),
    D3DXVECTOR3(  0.00f, -8.00f,-102.00f ),     D3DXVECTOR3(  4.48f, -8.00f,-102.00f ),
    D3DXVECTOR3(  8.00f, -4.48f,-102.00f ),     D3DXVECTOR3(  8.00f,  0.00f,-102.00f ),

    // Bottom
    D3DXVECTOR3(  30.00f,   0.00f,  0.00f ),   D3DXVECTOR3(  20.00f,  10.00f,  0.00f ),
    D3DXVECTOR3(  10.00f,  20.00f,  0.00f ),   D3DXVECTOR3(   0.00f,  30.00f,  0.00f ),
    D3DXVECTOR3(  20.00f, -10.00f,  0.00f ),   D3DXVECTOR3(  10.00f,   0.00f,  0.00f ),
    D3DXVECTOR3(   0.00f,  10.00f,  0.00f ),   D3DXVECTOR3( -10.00f,  20.00f,  0.00f ),
    D3DXVECTOR3(  10.00f, -20.00f,  0.00f ),   D3DXVECTOR3(   0.00f, -10.00f,  0.00f ),
    D3DXVECTOR3( -10.00f,   0.00f,  0.00f ),   D3DXVECTOR3( -20.00f,  10.00f,  0.00f ),
    D3DXVECTOR3(   0.00f, -30.00f,  0.00f ),   D3DXVECTOR3( -10.00f, -20.00f,  0.00f ),
    D3DXVECTOR3( -20.00f, -10.00f,  0.00f ),   D3DXVECTOR3( -30.00f,   0.00f,  0.00f ),

    D3DXVECTOR3(  0.00f, 30.00f,  0.00f ),     D3DXVECTOR3( 10.00f, 20.00f,  0.00f ),
    D3DXVECTOR3( 20.00f, 10.00f,  0.00f ),     D3DXVECTOR3( 30.00f,  0.00f,  0.00f ),
    D3DXVECTOR3(  0.00f, 40.00f,  0.00f ),     D3DXVECTOR3( 17.20f, 33.00f,  0.00f ),
    D3DXVECTOR3( 33.00f, 17.20f,  0.00f ),     D3DXVECTOR3( 40.00f,  0.00f,  0.00f ),
    D3DXVECTOR3(  0.00f, 50.00f,  0.00f ),     D3DXVECTOR3( 24.40f, 47.00f,  0.00f ),
    D3DXVECTOR3( 47.00f, 24.40f,  0.00f ),     D3DXVECTOR3( 50.00f,  0.00f,  0.00f ),
    D3DXVECTOR3(  0.00f, 60.00f,  0.00f ),     D3DXVECTOR3( 33.60f, 60.00f,  0.00f ),
    D3DXVECTOR3( 60.00f, 33.60f,  0.00f ),     D3DXVECTOR3( 60.00f,  0.00f,  0.00f ), 

    D3DXVECTOR3(  0.00f,-30.00f,  0.00f ),     D3DXVECTOR3(-10.00f,-20.00f,  0.00f ),
    D3DXVECTOR3(-20.00f,-10.00f,  0.00f ),     D3DXVECTOR3(-30.00f,  0.00f,  0.00f ),
    D3DXVECTOR3(  0.00f,-40.00f,  0.00f ),     D3DXVECTOR3(-17.20f,-33.00f,  0.00f ),
    D3DXVECTOR3(-33.00f,-17.20f,  0.00f ),     D3DXVECTOR3(-40.00f,  0.00f,  0.00f ),
    D3DXVECTOR3(  0.00f,-50.00f,  0.00f ),     D3DXVECTOR3(-24.40f,-47.00f,  0.00f ),
    D3DXVECTOR3(-47.00f,-24.40f,  0.00f ),     D3DXVECTOR3(-50.00f,  0.00f,  0.00f ),
    D3DXVECTOR3(  0.00f,-60.00f,  0.00f ),     D3DXVECTOR3(-33.60f,-60.00f,  0.00f ),
    D3DXVECTOR3(-60.00f,-33.60f,  0.00f ),     D3DXVECTOR3(-60.00f,  0.00f,  0.00f ), 

    D3DXVECTOR3( 30.00f,  0.00f,  0.00f ),     D3DXVECTOR3( 20.00f,-10.00f,  0.00f ),
    D3DXVECTOR3( 10.00f,-20.00f,  0.00f ),     D3DXVECTOR3(  0.00f,-30.00f,  0.00f ),
    D3DXVECTOR3( 40.00f,  0.00f,  0.00f ),     D3DXVECTOR3( 33.00f,-17.20f,  0.00f ),
    D3DXVECTOR3( 17.00f,-33.20f,  0.00f ),     D3DXVECTOR3(  0.00f,-40.00f,  0.00f ),
    D3DXVECTOR3( 50.00f,  0.00f,  0.00f ),     D3DXVECTOR3( 47.00f,-24.40f,  0.00f ),
    D3DXVECTOR3( 24.00f,-47.40f,  0.00f ),     D3DXVECTOR3(  0.00f,-50.00f,  0.00f ),
    D3DXVECTOR3( 60.00f,  0.00f,  0.00f ),     D3DXVECTOR3( 60.00f,-33.60f,  0.00f ),
    D3DXVECTOR3( 33.00f,-60.60f,  0.00f ),     D3DXVECTOR3(  0.00f,-60.00f,  0.00f ), 

    D3DXVECTOR3(-30.00f,  0.00f,  0.00f ),     D3DXVECTOR3(-20.00f, 10.00f,  0.00f ),
    D3DXVECTOR3(-10.00f, 20.00f,  0.00f ),     D3DXVECTOR3(  0.00f, 30.00f,  0.00f ),
    D3DXVECTOR3(-40.00f,  0.00f,  0.00f ),     D3DXVECTOR3(-33.00f, 17.20f,  0.00f ),
    D3DXVECTOR3(-17.00f, 33.20f,  0.00f ),     D3DXVECTOR3(  0.00f, 40.00f,  0.00f ),
    D3DXVECTOR3(-50.00f,  0.00f,  0.00f ),     D3DXVECTOR3(-47.00f, 24.40f,  0.00f ),
    D3DXVECTOR3(-24.00f, 47.40f,  0.00f ),     D3DXVECTOR3(  0.00f, 50.00f,  0.00f ),
    D3DXVECTOR3(-60.00f,  0.00f,  0.00f ),     D3DXVECTOR3(-60.00f, 33.60f,  0.00f ),
    D3DXVECTOR3(-33.00f, 60.60f,  0.00f ),     D3DXVECTOR3(  0.00f, 60.00f,  0.00f ), 
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\simple\sources.inc ===
TARGETNAME=Simple
TARGETPATH=obj
TARGETTYPE=PROGRAM

INCLUDES=$(INCLUDES);$(PRIVATE_INC_PATH)

SOURCES= \
    main.cpp \
    bitfont.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\satest\satest.cpp ===
/*
SaTest: Shader assembler testing utility.
Copyright (C) Microsoft Corperation.

There are really 2 parts to this utility: regression checks, and new test- 
case generation. Regression is performed when the "*.vsh" isn't commented out,
near the bottom of the code.

New test cases are generated by the RandomTest() call. Files are generated
in a temporary directory, assembled, and then copied into the tests\media\satest
directory if they fail. On XBOX, you should theoretically be able to copy a
generated vertex shader to a dev machine, assuming that the xbox has sharing
privlages. 

I've found that the best way to do this is to leave it running all night, with
api.cpp's VERIFY_EACH_STEP NOT defined. This will give you a ton of test cases 
very quickly. Afterwards, turn on VERIFY_EACH_STEP, and run the regression
tests. This will reveal which optimizer was broken by the tests. After that,
group the tests into the appropriate category of optimizer, pick one, and run
lipovsh on it. This reduces the code down to the few essential lines that are 
breaking the optimizer. Check in those shrunken-down test cases, file bugs on them.
After the bugs are fixed, run regression on everything. If they all pass, delete all
except the checked-in files.

*/

#define START_NUM 1000000

// XD3DXAssembleShader command-line utility
//

#include "stdafx.h"
#include "time.h"

HANDLE hlog; //global logging handle

#ifdef XBOX
        #include <xtestlib.h>
	#include <xlog.h>
	extern "C" ULONG _cdecl DbgPrint(PCH Format, ...);

#else
#define XLL_FAIL 1
#define XLL_INFO 2
#define XLL_PASS 4
	void xLog(void*,int,const char* data, ...) {
		va_list marker;
		va_start( marker, data);
		char buf[1000];
		_vsnprintf(buf, sizeof(buf)-1, data, marker);
		buf[sizeof(buf)-1] = '\0';
		OutputDebugString(buf);
	}
	void DbgPrint(const char* data,...){
		va_list marker;
		va_start( marker, data);
		char buf[1000];
		_vsnprintf(buf, sizeof(buf), data, marker);
		OutputDebugString(buf);
	}
#endif

// Uncomment this if you want to break into the debugger when an error occurs
// #define BREAK_ON_ERROR

#if defined(DBG) && defined(BREAK_ON_ERROR)
#define SETERROR(HR,CODE) \
	do { \
if(FAILED(HR = CODE)){ \
			DebugBreak(); \
		} \
	} while(0)
#else
#define SETERROR(HR,CODE) \
	HR = CODE
#endif

void ConvertToUnicode(WCHAR* dest, DWORD destSizeBytes, LPCSTR source){
	DWORD destSizeWChars = destSizeBytes / sizeof(WCHAR);
	mbstowcs(dest,source,destSizeWChars);
	dest[destSizeWChars-1] = 0;
}

HRESULT CreateBufferFromFile(const char* path, LPXGBUFFER* ppBuffer){
	HRESULT hr = S_OK;
#ifdef USE_UNICODE_FILEIO
	WCHAR wpath[MAX_PATH];
	ConvertToUnicode(wpath, sizeof(wpath), path);
#else
#define wpath path
#endif
	HANDLE file = CreateFile(wpath,GENERIC_READ,FILE_SHARE_READ,
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
		NULL);
#ifndef USE_UNICODE_FILEIO
#undef wpath
#endif
	if(file == INVALID_HANDLE_VALUE){
		SETERROR(hr,E_FAIL);
	}
	DWORD size;
	if(SUCCEEDED(hr)){
		size = GetFileSize(file,NULL);
		if(size == ~0){
			SETERROR(hr,E_FAIL);
		}
	}
	if(SUCCEEDED(hr)){
		hr = XGBufferCreate(size, ppBuffer);
	}
	if(SUCCEEDED(hr)){
		DWORD sizeRead;
		ReadFile(file,(*ppBuffer)->GetBufferPointer(), size, &sizeRead, NULL);
		if(sizeRead != size){
			SETERROR(hr,E_FAIL);
		}
	}
	if(file != INVALID_HANDLE_VALUE){
		CloseHandle(file);
	}
	return hr;
}

HRESULT CreateFileFromBuffer(const char* path, LPXGBUFFER pBuffer){
	HRESULT hr = S_OK;
#ifdef USE_UNICODE_FILEIO
	WCHAR wpath[MAX_PATH];
	ConvertToUnicode(wpath, sizeof(wpath), path);
#else
#define wpath path
#endif
	HANDLE file = CreateFile(wpath,GENERIC_WRITE,FILE_SHARE_READ,
		NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
		NULL);
#ifndef USE_UNICODE_FILEIO
#undef wpath
#endif
	if(file == INVALID_HANDLE_VALUE){
		SETERROR(hr,E_FAIL);
	}
	if(SUCCEEDED(hr)){
		DWORD sizeWritten;
		WriteFile(file,pBuffer->GetBufferPointer(),
			pBuffer->GetBufferSize(), &sizeWritten, NULL);
		if(sizeWritten != pBuffer->GetBufferSize()){
			SETERROR(hr,E_FAIL);
		}
	}
	if(file != INVALID_HANDLE_VALUE){
		CloseHandle(file);
	}
	return hr;
}

BOOL MyDeleteFile(const char* file){
#ifdef XBOX
  #if 1
	return DeleteFile(file);
  #else
	wchar_t buf[MAX_PATH];
	ConvertToUnicode(buf, sizeof(buf), file);
	return DeleteFileW(buf);
  #endif
#else
	wchar_t buf[MAX_PATH];
	ConvertToUnicode(buf, sizeof(buf), file);
	return DeleteFileW(buf);
#endif
}

HRESULT Assemble(const char* shaderFile,
	const char* constFile,
	const char* ucodeFile,
	const char* errorFile,
	const char* listFile,
	bool optimize,
	bool preprocessOnly,
	bool outputShaderTokens,
	SASM_ResolverCallback pResolver,
	LPVOID pResolverUserData)
{
	LPXGBUFFER shaderBuffer = NULL;
	LPXGBUFFER ucodeBuffer = NULL;
	LPXGBUFFER constBuffer = NULL;
	LPXGBUFFER errorBuffer = NULL;
	LPXGBUFFER listBuffer = NULL;

	HRESULT hr;
	hr = CreateBufferFromFile(shaderFile, &shaderBuffer);

	// Delete the old output files no matter what
	if(SUCCEEDED(hr)){
		if(constFile){
			MyDeleteFile(constFile);
		}
		if(errorFile){
			MyDeleteFile(errorFile);
		}
		if(listFile){
			MyDeleteFile(listFile);
		}
	}
    DWORD shaderType;

	if(SUCCEEDED(hr)){
		DWORD flags = SASM_VERIFY_OPTIMIZATIONS 
			| (optimize ? 0 : SASM_DONOTOPTIMIZE)
//			| SASM_DONOTOPTIMIZE | SASM_SKIPVALIDATION
			;


#if 0
			| (preprocessOnly ? SASM_PREPROCESSONLY : 0)
			| (outputShaderTokens ? SASM_OUTPUTSHADERTOKENS : 0);
#endif

		hr = AssembleShader(
			shaderFile,
			shaderBuffer->GetBufferPointer(),
			shaderBuffer->GetBufferSize(),
			flags,
			constFile ? &constBuffer : NULL,
			ucodeFile ? &ucodeBuffer : NULL,
			errorFile ? &errorBuffer : NULL,
			listFile ? &listBuffer : NULL,
			pResolver, pResolverUserData,
            &shaderType);
	}
	if(SUCCEEDED(hr)){
		if(constFile && constBuffer && constBuffer->GetBufferSize() ){
			hr = CreateFileFromBuffer(constFile, constBuffer);
		}
	}
	if(SUCCEEDED(hr)){
		if(ucodeFile && ucodeBuffer && ucodeBuffer->GetBufferSize()){
//			hr = CreateFileFromBuffer(ucodeFile, ucodeBuffer);
		}
	}
	if(SUCCEEDED(hr)){
		if(listFile && listBuffer && listBuffer->GetBufferSize()){
			hr = CreateFileFromBuffer(listFile, listBuffer);
		}
	}

	// Always try to create the error log
	if(errorFile && errorBuffer && errorBuffer->GetBufferSize()){
		HRESULT hr2 = CreateFileFromBuffer(errorFile, errorBuffer);
        if(SUCCEEDED(hr)){
            hr = hr2;
        }
	}


	RELEASE(shaderBuffer);
	RELEASE(listBuffer);
	RELEASE(constBuffer);
	RELEASE(ucodeBuffer);
	RELEASE(errorBuffer);
	return hr;
}

void usage(const char* s){
	if(s){
		printf("%s\n", s);
	}
	printf("usage: [-Od][-l] shaderfile [ucodefile constfile errorfile listfile]\n");
	printf("  -Od         Turn off optimization.\n");
	printf("  -l          Generate a listing.\n");
	printf("  -p          Only run the preprocessor (output to stdout).\n");
	printf("  shaderfile  source file for shader.\n");
	printf("  ucodefile   output file for microcode.\n");
	printf("  constfile   output file for shader constants file.\n");
	printf("  errorfile   output file for errors.\n");
	printf("  listfile    output file for listing.\n");
	printf("\n");
	printf("If you don't specify ucodefile, it defaults to file.xsu\n");
	printf("If you don't specify constfile, it defaults to file.xsc\n");
	printf("If you don't specify errorfile, it defaults to file.err\n");
	printf("If you don't specify listfile,  it defaults to file.lst\n");
	printf("(where 'file' is the name of the shader file, not including the extension.)\n");
#ifdef XBOX
	_asm int 3 // Breakpoint
#else
	exit(-1);
#endif
}

void stripExtension(char* s)
{
	size_t i = strlen(s);
	while(i){
		if(s[--i]=='.'){
			s[i] = '\0';
			break;
		}
		else if(s[i] == '\\' || s[i] == '/' || s[i] == ':'){
			break;
		}
	}
}

void calculateDefaultOutFile(char* out, const char* in){
	strcpy(out, in);
	stripExtension(out);
}

class Resolver {
public:
	Resolver(){
		m_includePath[0] = 0;
	}

	HRESULT Resolve(BOOL isSystemInclude, LPCSTR sourceFilePath,
		LPCSTR includeFileName,
		LPSTR resolvedFilePath, DWORD resolvedFilePathSize,
		LPXGBUFFER* ppResolvedFile)
	{
		HRESULT hr = S_OK;
		char fullPath[MAX_PATH];
		if(SUCCEEDED(hr)){
			if(m_includePath[0]){
				sprintf(fullPath, "%s\\%s", m_includePath, includeFileName);
			}
			else {
				strcpy(fullPath, includeFileName);
			}

			hr = CreateBufferFromFile(fullPath, ppResolvedFile);
		}

		if(SUCCEEDED(hr)){
			strncpy(resolvedFilePath, fullPath, resolvedFilePathSize);
		}

		return hr;
	}

	HRESULT AddIncludePath(LPSTR includePath){
		// For now, only allow one include directory
		if(m_includePath[0] != 0){
			return E_FAIL;
		}
		strncpy(m_includePath, includePath, sizeof(m_includePath));
		return S_OK;
	}
private:
	char m_includePath[MAX_PATH];
};

HRESULT ResolverCallback(LPVOID pResolverUserData,
		BOOL isSystemInclude, LPCSTR sourceFilePath,
		LPCSTR includeFileName,
		LPSTR resolvedFilePath, DWORD resolvedFilePathSize,
		LPXGBUFFER* ppResolvedFile)
{
	return ((Resolver*) pResolverUserData)->Resolve(isSystemInclude, sourceFilePath,
		includeFileName, resolvedFilePath, resolvedFilePathSize, ppResolvedFile);
}


int assembler_main(int argc, char* argv[])
{
	const char* inFile = NULL;
	const char* ucodeFile = NULL;
	const char* constFile = NULL;
	const char* errFile = NULL;
	const char* listFile = NULL;
	bool optimize = true;
	bool listing = false;
	bool preprocessOnly = false;
	bool outputShaderTokens = false;
	Resolver resolver;

	for(int i = 1; i < argc;i++){
		const char* arg = argv[i];
		if(arg[0] == '-' || arg[0] == '/'){
			switch(arg[1]){
				case 'O':
					switch(arg[2]){
						case 'd':
							optimize = false;
							break;
						default:
							usage("Unrecognized option to -O.");
							break;
					}
					break;
				case 'l':
					listing = true;
					break;
				case 's':
					outputShaderTokens = true;
					break;
				case 'I':
					if(i + 1 >= argc){
						usage("-I requires an argument");
						break;
					}
					resolver.AddIncludePath(argv[++i]);
					break;
				case 'p':
					preprocessOnly = true;
				default:
					usage("Unknown flag.");
				}
		}
		else if ( ! inFile ) {
			inFile = arg;
		}
		else if ( ! ucodeFile ) {
			ucodeFile = arg;
		}
		else if ( ! constFile ) {
			constFile = arg;
		}
		else if ( ! errFile ) {
			errFile = arg;
		}
		else if ( ! listFile ) {
			listFile = arg;
		}
		else {
			usage("Unexpected extra file name.");
		}
	}
	if(!inFile){
		usage("Need to specify an input file.");
	}
	char defaultOutFile[MAX_PATH];
	calculateDefaultOutFile(defaultOutFile, inFile);
	char defaultUcodeFile[MAX_PATH];
	char defaultConstFile[MAX_PATH];
	char defaultErrFile[MAX_PATH];
	char defaultListFile[MAX_PATH];
	sprintf(defaultUcodeFile,"%s.xsu",defaultOutFile);
	sprintf(defaultConstFile,"%s.xsc",defaultOutFile);
	sprintf(defaultErrFile,"%s.err",defaultOutFile);
	sprintf(defaultListFile,"%s.lst",defaultOutFile);
	if(!ucodeFile){
		ucodeFile = defaultUcodeFile;
	}
	if(!constFile){
//		constFile = defaultConstFile;
	}
	if(!errFile){
		errFile = defaultErrFile;
	}
	if(!listFile){
//		listFile = defaultListFile;
	}

	HRESULT hr = Assemble(inFile,constFile,ucodeFile,errFile,listFile,
		optimize,preprocessOnly, outputShaderTokens,
		ResolverCallback, &resolver);

	return hr;
}

HRESULT TestFile(const char* szIncludeDir, const char* szFile){
	DbgPrint("TestFile %s\n", szFile);
	char* includeDirBuf = (char*) szIncludeDir;
	char* buf = (char*) szFile;
	char* fakeArgs[6];
	fakeArgs[0] = "satest";
	fakeArgs[1] = "-l";
	fakeArgs[2] = buf;
	fakeArgs[3] = "-I";
	fakeArgs[4] = includeDirBuf;
	fakeArgs[5] = 0;
	HRESULT hr = (HRESULT) assembler_main(5,fakeArgs);
	return hr;
}

HRESULT TryAllFiles(const char* pszPath, const char* extension)
	{
	// Read each of the shader assembler files out of the test directory, and assemble it.

	HRESULT                 hr                  = S_OK;
	HANDLE                  hFind               = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA         fd;
	char                    szPattern[MAX_PATH];
	
	sprintf(szPattern, "%s\\*.%s", pszPath, extension);

	hFind = FindFirstFile(szPattern, &fd);

	if(INVALID_HANDLE_VALUE == hFind)
	{
		// Assume there are no files of this type
        DbgPrint("No files match pattern %ls\n", szPattern);
		return S_OK;
	}

	HRESULT anyFail = hr;
	
	while(SUCCEEDED(hr))
	{
		char szFile[MAX_PATH];
		sprintf(szFile, "%s\\%s", pszPath, fd.cFileName);
		HRESULT hr2 = TestFile(pszPath, szFile);
		if ( FAILED(hr2) ) {
			DbgPrint("File %s failed: 0x%08x\n", szFile, hr2);
			anyFail = hr2;
		}		
		if(SUCCEEDED(hr))
		{
			BOOL foundFile = FindNextFile(hFind, &fd);
			if( !foundFile)
			{
				break;
			}
		}
	}

	hr = anyFail;
	
	if(INVALID_HANDLE_VALUE != hFind)
	{
#ifdef XBOX
	FindClose(hFind);
#else
	// FindClose is causing problems under VC6 - I get an Invalid Handle Value assertion.
#endif
	}
	
	return hr;
}



#define countof(a) (sizeof(a) / sizeof(a[0]))

/*
This program produces vertex shaders randomly.
It is mainly designed to stress the optimizer, but also tests the various options 
(xvs.1.1, vs.1.0, vs.1.1, xvsw.1.1, xvss.1.1, #pragma screenspace, etc.)
*/

struct INSTRUCTION {
	char NAME[5];
	int uses;
	int numparams;
};

INSTRUCTION Mac[] = {
	{ "nop ", 0, 0 },//0
	{ "mov ", 1, 1 },//1 
	{ "add ", 5, 2 },//2 
	{ "mul ", 3, 2 },//3
	{ "mad ", 7, 3 },//4
	{ "min ", 3, 2 },//5
	{ "max ", 3, 2 },//6
	{ "sge ", 3, 2 },//7
	{ "slt ", 3, 2 },//8
	{ "dst ", 3, 2 },//9
	{ "dp4 ", 3, 2 },//10
	{ "dp3 ", 3, 2 },//11
	{ "dph ", 3, 2 },//12
	{ "mov ", 1, 1 },//13
};
INSTRUCTION Ilu[] = {
	{ "nop ", 0, 0 },//0
	{ "mov ", 4, 1 },//1
	{ "rcc ", 4, 1 },//2 
	{ "rcp ", 4, 1 },//3 
	{ "rsq ", 4, 1 },//4 
	{ "lit ", 4, 1 },//5 
	{ "expp", 4, 1 },//6 
	{ "logp", 4, 1 },//7 
};

INSTRUCTION All[] = {
	{ "nop ", 0, 0 },//0 
	{ "mov ", 1, 1 },//1 
	{ "add ", 5, 2 },//2 
	{ "mul ", 3, 2 },//3
	{ "mad ", 7, 3 },//4
	{ "min ", 3, 2 },//5
	{ "max ", 3, 2 },//6
	{ "sge ", 3, 2 },//7
	{ "slt ", 3, 2 },//8
	{ "dst ", 3, 2 },//9
	{ "dp4 ", 3, 2 },//10
	{ "dp3 ", 3, 2 },//11
	{ "dph ", 3, 2 },//12
	{ "mov ", 4, 1 },//1
	{ "rcc ", 4, 1 },//2 
	{ "rcp ", 4, 1 },//3 
	{ "rsq ", 4, 1 },//4 
	{ "lit ", 4, 1 },//5 
	{ "expp", 4, 1 },//6 
	{ "logp", 4, 1 },//7 
};


const char* OutRegs[] = {"oPos",
    "o1" /* Weight */, "o2" /* VA_NRML */,
    "oD0", "oD1",
    "oFog", "oPts",
    "oB0", "oB1",
    "oT0", "oT1", "oT2", "oT3",
};

bool gbCanWriteConsts;  //read-write, or state shader
bool gbStateShader;     //must use only v0, cannot write O**
bool gbCanAccessConsts; //not vs.1.*
bool gbCanUseArl;       //not vs.1.0
bool gbHasWrittenReg[13][4] = {{false}};
bool gbHasWrittenArl = false;
bool gbHasWrittenConst = false;
char gfilebuf[30000];
int gNumLines;
char*gfp;
FILE* f;

int gInstruction;

void DoInstruction(bool nonop) {
pickinstruction:
	switch(rand() % 8) 
	{
	case 0:
		gInstruction = (rand() % 3) + 2; //favor add, mul, mad. (to test mad-splicing)
		break;
	case 1:
		gInstruction = gInstruction; //use last instruction, to test pairing
		break;
	case 2: case 3: case 4: case 5: case 6: case 7:
		gInstruction = rand() % countof(All);
		break;
	}
	
	if(gInstruction == 0 && nonop) goto pickinstruction;
	if((gInstruction == 14 || gInstruction == 12) && !gbCanAccessConsts) goto pickinstruction;
	gfp += sprintf(gfp, "%s ", All[gInstruction].NAME);

}

void DoOutput() {
	if(gInstruction == 0) return; //nop takes no params.

	bool mask[4] = {true, true, true, true};
	int i, j;
	bool domask = rand() & 1;
	if(domask) {
		for(i = 0; i < 4; i++) {
			mask[i] = (rand() & 4) ? true : false;
		}
	}
	if(!mask[0] && !mask[1] && !mask[2] && !mask[3]) {
		mask[rand() & 3] = true;
	}

	switch (rand() % 10) {
	case 0:
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
case0:
		i = rand() % (12 + gbCanUseArl);
		if(i == 12 && gInstruction == 1) {
			gfp += sprintf(gfp, "a0.x, ");
			gbHasWrittenArl = true;
			return;
		} else if (i == 12) {
			i = 0;
		}
		gfp += sprintf(gfp, "r%d", i);
		for(j = 0; j < 4; j++) {
			if(mask[j]) {
				gbHasWrittenReg[i][j] = true;
			}
		}
		
		break;
	case 7:
		//write to constant
		if(!gbCanWriteConsts) goto case0;
		if(gbCanAccessConsts) {
			gfp += sprintf(gfp, "c%d", (rand() % 192) - 96);
		} else {
			gfp += sprintf(gfp, "c%d", (rand() % 96));
		}
		gbHasWrittenConst = true;
		break;
	case 8:
	case 9:
		//write to output
		if(gbStateShader) goto case0;
pickoutputregagain:
		i = rand() % countof(OutRegs);
		if((i == 7 || i == 8) && (!gbCanAccessConsts)) 	goto pickoutputregagain;
		if((i == 1 || i == 2)) goto pickoutputregagain;
		for(j = 0; j < 4; j++) {
			if((i == 0) && mask[j]) {
				gbHasWrittenReg[12][j] = true;
			}
		}
		gfp += sprintf(gfp, "%s", OutRegs[i]);
		break;
	}
	if(domask) {
		gfp += sprintf(gfp, ".");
		if(mask[0]) gfp += sprintf(gfp, "x");
		if(mask[1]) gfp += sprintf(gfp, "y");
		if(mask[2]) gfp += sprintf(gfp, "z");
		if(mask[3]) gfp += sprintf(gfp, "w");
	}
	gfp += sprintf(gfp, ", ");
}

void DoInput(char* buf) {
	buf[0] = '\0';
	if(gInstruction == 0) return;

	int i,j,r,c,v;
	char xyzw[] = {'x', 'y', 'z', 'w'};
	bool arl = false;

	if(gbCanUseArl && gbHasWrittenArl && ((rand() % 10) == 0)) arl = true;

	if(::gbCanAccessConsts) {
		c = rand() % 18;
		if(c < 6) c -= 96;
		else if (c < 12) c -= 7;
		else if (c < 17) c += (95 - 16);
		else c = (rand() % 192) - 96;
	} else {
		c = (rand() % 12);
		if(c < 6) c += 0;
		else if (c < 11) c += (95 - 11);
		else c = (rand() % 96);
	}

	if(::gbStateShader) {
		v = 0;
	} else {
		v = rand() % 16;
	}

	for(i = 0; i < All[gInstruction].numparams; i++) {

		int swiz[4] = {0,1,2,3};
		bool doswiz = (rand() & 1) ? true : false;
		if(doswiz) {
			for(j = 0; j < 4; j++) {
				swiz[j] = rand() & 3;
			}
		}

		if((rand() % 4) == 0) {
			buf += sprintf(buf, "-");
		}


pickreg:
		switch(rand() % 8) {
		case 0: 
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			r = rand() % (12 + gbCanAccessConsts);
			for(j = 0; j < 4; j++) {
				if(!gbHasWrittenReg[r][swiz[j]]) {
					goto pickreg;
				}
			}
			buf += sprintf(buf, "r%d", r);
			break;
		case 6:
			if(arl) {
				buf += sprintf(buf, "c[a0.x+%d]", c);
			} else {
				buf += sprintf(buf, "c%d", c);
			}
			break;
		case 7:
			buf += sprintf(buf, "v%d", v);
			break;
		}

		if(doswiz) {
			buf += sprintf(buf, ".%c%c%c%c", xyzw[swiz[0]], xyzw[swiz[1]], xyzw[swiz[2]], xyzw[swiz[3]]);
		}

		if (i == All[gInstruction].numparams - 1) {
			break;
		} else {
			buf += sprintf(buf, ", ");
		}
	}
}


void DoIt() {
	int ca, va, amx, bmx, cmx;
	int arr, brr, crr;
	bool ane, bne, cne;
	int as[4], bs[4], cs[4];
	bool om;
	int rwm, swm, owm;
	int rw, oc;
	int mac, ilu;
	bool arl;
	int or;

	int i, j;
	char xyzw[] = {'x','y','z','w'};
	char mx[] = {'?', 'r', 'v', 'c'};

chooseinstructions:
	ilu = (rand() % 8);
	mac = (rand() % 14);
	if((!gbCanUseArl) && (mac == 13)) goto chooseinstructions;
	if((!gbCanAccessConsts) && (mac == 12)) goto chooseinstructions;
	if((!gbCanAccessConsts) && (ilu == 2)) goto chooseinstructions;

	arl = false;
	if(gbCanUseArl && gbHasWrittenArl && (!(rand() % 6))) arl = true;

	if(::gbCanAccessConsts) {
		ca = rand() % 18;
		if(ca < 6) ca -= 96;
		else if (ca < 12) ca -= 7;
		else if (ca < 17) ca += (95 - 16);
		else ca = (rand() % 192) - 96;
	} else {
		ca = (rand() % 12);
		if(ca < 6) ca += 0;
		else if (ca < 11) ca += (95 - 11);
		else ca = (rand() % 96);
	}

	if(::gbStateShader) {
		va = 0;
	} else {
		va = rand() % 16;
	}

	if(rand() & 1) {
		for (i = 0; i < 4; i++) as[i] = i;
	} else {
		for (i = 0; i < 4; i++) as[i] = rand() & 3;
	}
	if(rand() & 3) ane = false; else ane = true;

	if(rand() & 1) {
		for (i = 0; i < 4; i++) bs[i] = i;
	} else {
		for (i = 0; i < 4; i++) bs[i] = rand() & 3;
	}
	if(rand() & 3) bne = false; else bne = true;

	if(rand() & 1) {
		for (i = 0; i < 4; i++) cs[i] = i;
	} else {
		for (i = 0; i < 4; i++) cs[i] = rand() & 3;
	}
	if(rand() & 3) cne = false; else cne = true;

	if(rand() & 1) rwm = 15;
	else rwm = rand() % 15 + 1;
	
	if(rand() & 1)  swm = 15;
	else swm = rand() % 15 + 1;

	if(rand() & 1)  owm = 15; //1/4
	else owm = rand() & 15; //1/4
	if(rand() & 1) owm = 0; //only write to output 1/2 times

	oc = 1;
	if(gbCanWriteConsts) oc = rand() & 1 ? true : false;
	if(gbStateShader) oc = 0;
	if(oc == 0) {
		if(::gbCanAccessConsts) {
			or = rand() % 18;
			if(or < 6) or -= 96;
			else if (or < 12) or -= 7;
			else if (or < 17) or += (95 - 16);
			else or = (rand() % 192) - 96;
		} else {
			or = (rand() % 12);
			if(or < 6) or += 0;
			else if (or < 11) or += (95 - 11);
			else or = (rand() % 96);
		}
	} else {
		//write to output
pickoutputregagain:
		or = rand() % countof(OutRegs);
		if((or == 7 || or == 8) && (!gbCanAccessConsts)) 	goto pickoutputregagain;
		if((or == 1 || or == 2)) goto pickoutputregagain;
	}

	om = rand() & 1 ? true : false;
chooserw:
	rw = rand() % (12);
	if(rw == 1 && ilu != 0) goto chooserw;

chooseamx:
	amx = (rand() & 7) + 1; if(amx >= 4) amx = 1;
	if(amx == 1) { 
		arr = rand() % (12 + ::gbCanAccessConsts); 
		for(i = 0; i < 4; i++) {
			if(!::gbHasWrittenReg[arr][as[i]]) goto chooseamx;
		}
	}
choosebmx:
	bmx = (rand() & 7) + 1; if(bmx >= 4) bmx = 1;
	if(bmx == 1) { 
		brr = rand() % (12 + ::gbCanAccessConsts);
		for(i = 0; i < 4; i++) {
			if(!::gbHasWrittenReg[brr][bs[i]]) goto choosebmx;
		}
	}
choosecmx:
	cmx = (rand() & 7) + 1; if(cmx >= 4) cmx = 1;
	if(cmx == 1) { 
		crr = rand() % (12 + ::gbCanAccessConsts);
		for(i = 0; i < 4; i++) {
			if(!::gbHasWrittenReg[crr][cs[i]]) goto choosecmx;
		}
	}

#if 0
	int NumPairs = rand() % 6;
	for(i = 0; i < NumPairs; i++) {
		int uses;
		if(i != 0) gfp += sprintf(gfp, " + ");
		int o = rand() % 3;
		if(o == 0 || (o == 2 && om == 0)) {
			uses = Mac[mac].uses;
			gfp += sprintf(gfp, "%s ", Mac[mac].NAME);
			if(mac != 0) {
				if(mac != 13) {
					if(o == 2) {
						if(oc == 0) {
							gfp += sprintf(gfp, "c[%d]", or);
						} else {
							gfp += sprintf(gfp, "%s", OutRegs[or]);
						}
					} else {
						gfp += sprintf(gfp, "r%d", rw);
					}
					if((rand() & 7) && (rwm == 15)) {
					} else {
						int temp = rand() & rwm;
						if(temp == 0) temp = rwm;
						gfp += sprintf(gfp, ".");
						for(j = 0; j < 4; j++) {
							if(temp & (1 << j)) {
								gfp += sprintf(gfp, "%c", xyzw[j]);
								if (o != 2) ::gbHasWrittenReg[rw][j] = true;
							}
						}
					}
				} else {
					gfp += sprintf(gfp, "a0.x  ");
				}
				gfp += sprintf(gfp, ",");
			}
		} else {
			uses = Ilu[ilu].uses;
			gfp += sprintf(gfp, "%s ", Ilu[ilu].NAME);
			if(ilu != 0) {
				if(o == 2) {
					if(oc == 0) {
						gfp += sprintf(gfp, "c[%d]", or);
					} else {
						gfp += sprintf(gfp, "%s", OutRegs[or]);
					}
				} else {
					gfp += sprintf(gfp, "r%d", rw);
				}
				if((rand() & 7) && (rwm == 15)) {
				} else {
					int temp = rand() & rwm;
					if(temp == 0) temp = rwm;
					gfp += sprintf(gfp, ".");
					for(j = 0; j < 4; j++) if(temp & (1 << j)) {
						gfp += sprintf(gfp, "%c", xyzw[j]);
						if (o != 2) ::gbHasWrittenReg[rw][j] = true;
					}
				}
				gfp += sprintf(gfp, ",");
			}
		}
		if(uses & 1) {
			     if (amx == 1) {gfp += sprintf(gfp, "%cr%d.%c%c%c%c",        ane?'-':' ', arr, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
			else if (amx == 2) {gfp += sprintf(gfp, "%cv%d.%c%c%c%c",        ane?'-':' ',  va, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
			else if (arl)      {gfp += sprintf(gfp, "%cc[a0.x+%d].%c%c%c%c", ane?'-':' ',  ca, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
			else               {gfp += sprintf(gfp, "%cc[%d].%c%c%c%c",      ane?'-':' ',  ca, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
			if(uses & 6) gfp += sprintf(gfp, ",");
		}
		if(uses & 2) {
			     if (bmx == 1) {gfp += sprintf(gfp, "%cr%d.%c%c%c%c",        bne?'-':' ', brr, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
			else if (bmx == 2) {gfp += sprintf(gfp, "%cv%d.%c%c%c%c",        bne?'-':' ',  va, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
			else if (arl)      {gfp += sprintf(gfp, "%cc[a0.x+%d].%c%c%c%c", bne?'-':' ',  ca, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
			else               {gfp += sprintf(gfp, "%cc[%d].%c%c%c%c",      bne?'-':' ',  ca, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
			if(uses & 4) gfp += sprintf(gfp, ",");
		}
		if(uses & 4) {
			     if (cmx == 1) {gfp += sprintf(gfp, "%cr%d.%c%c%c%c",        cne?'-':' ', crr, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
			else if (cmx == 2) {gfp += sprintf(gfp, "%cv%d.%c%c%c%c",        cne?'-':' ',  va, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
			else if (arl)      {gfp += sprintf(gfp, "%cc[a0.x+%d].%c%c%c%c", cne?'-':' ',  ca, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
			else               {gfp += sprintf(gfp, "%cc[%d].%c%c%c%c",      cne?'-':' ',  ca, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
		}
		gfp += sprintf(gfp, "\n");
	}

#else


//pickdoout:
	int doout = (rand() % 7) + 1;
	bool WeirdIluInput = false;
#if 1 //currently, can't pair "add + ILU"
	if((mac == 2 || mac == 4) && 
		(((doout & 1) || ((doout & 4) && (om == 0))) && 
		((doout & 2) || ((doout & 4) && (om == 1)))) && 
		((ilu == 2) || (ilu == 3) || (ilu == 4) || (ilu == 6) || (ilu == 7))) {
		WeirdIluInput = true;
	}
#endif

	int uses;
	for(i = 0; i <= 3; i++) {
		if(doout & (1 << i)) {
			gNumLines++;
			if((doout & ((1 << i) - 1))) gfp += sprintf(gfp, " + ");
			int o = i;
			if(o == 0 || (o == 2 && om == 0)) {
				uses = Mac[mac].uses;
				gfp += sprintf(gfp, "%s ", Mac[mac].NAME);
				if(mac != 0) {
					if(mac != 13) {
						if(o == 2) {
							if(oc == 0) {
								gfp += sprintf(gfp, "c[%d]", or);
							} else {
								gfp += sprintf(gfp, "%s", OutRegs[or]);
							}
						} else {
							gfp += sprintf(gfp, "r%d", rw);
						}
						if((rand() & 7) && (rwm == 15)) {
						} else {
							int temp = rand() & rwm;
							if(temp == 0) temp = rwm;
							gfp += sprintf(gfp, ".");
							for(j = 0; j < 4; j++) {
								if(temp & (1 << j)) {
									gfp += sprintf(gfp, "%c", xyzw[j]);
									if (o != 2) ::gbHasWrittenReg[rw][j] = true;
								}
							}
						}
					} else {
						gfp += sprintf(gfp, "a0.x  ");
					}
					gfp += sprintf(gfp, ",");
				}
			} else {
				uses = Ilu[ilu].uses;
				gfp += sprintf(gfp, "%s ", Ilu[ilu].NAME);
				int IluReg = (doout & 1) ? 1 : rw;
				if((doout & 4) && om == 0) IluReg = 1;
				if(ilu != 0) {
					if(o == 2) {
						if(oc == 0) {
							gfp += sprintf(gfp, "c[%d]", or);
						} else {
							gfp += sprintf(gfp, "%s", OutRegs[or]);
						}
					} else {
						gfp += sprintf(gfp, "r%d", IluReg);
					}
					if((rand() & 7) && (swm == 15)) {
					} else {
//						int temp = rand() & swm;
//						if(temp == 0) temp = swm;
						gfp += sprintf(gfp, ".");
						for(j = 0; j < 4; j++) if(swm & (1 << j)) {
							gfp += sprintf(gfp, "%c", xyzw[j]);
							if (o != 2) ::gbHasWrittenReg[IluReg][j] = true;
						}
					}
					gfp += sprintf(gfp, ",");
				}
			}
			if(uses & 1) {
					 if (amx == 1) {gfp += sprintf(gfp, "%cr%d.%c%c%c%c",        ane?'-':' ', arr, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
				else if (amx == 2) {gfp += sprintf(gfp, "%cv%d.%c%c%c%c",        ane?'-':' ',  va, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
				else if (arl)      {gfp += sprintf(gfp, "%cc[a0.x+%d].%c%c%c%c", ane?'-':' ',  ca, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
				else               {gfp += sprintf(gfp, "%cc[%d].%c%c%c%c",      ane?'-':' ',  ca, xyzw[as[0]],xyzw[as[1]],xyzw[as[2]],xyzw[as[3]]);}
				if(uses & 6) gfp += sprintf(gfp, ",");
			}
			if(uses & 2) {
					 if (bmx == 1) {gfp += sprintf(gfp, "%cr%d.%c%c%c%c",        bne?'-':' ', brr, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
				else if (bmx == 2) {gfp += sprintf(gfp, "%cv%d.%c%c%c%c",        bne?'-':' ',  va, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
				else if (arl)      {gfp += sprintf(gfp, "%cc[a0.x+%d].%c%c%c%c", bne?'-':' ',  ca, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
				else               {gfp += sprintf(gfp, "%cc[%d].%c%c%c%c",      bne?'-':' ',  ca, xyzw[bs[0]],xyzw[bs[1]],xyzw[bs[2]],xyzw[bs[3]]);}
				if(uses & 4) gfp += sprintf(gfp, ",");
			}
			if(!(o == 0 || (o == 2 && om == 0)) && WeirdIluInput) {
					 if (cmx == 1) {gfp += sprintf(gfp, "%cr%d.%c",        cne?'-':' ', crr, xyzw[cs[0]]);}
				else if (cmx == 2) {gfp += sprintf(gfp, "%cv%d.%c",        cne?'-':' ',  va, xyzw[cs[0]]);}
				else if (arl)      {gfp += sprintf(gfp, "%cc[a0.x+%d].%c", cne?'-':' ',  ca, xyzw[cs[0]]);}
				else               {gfp += sprintf(gfp, "%cc[%d].%c",      cne?'-':' ',  ca, xyzw[cs[0]]);}
			} else if(uses & 4) {

					 if (cmx == 1) {gfp += sprintf(gfp, "%cr%d.%c%c%c%c",        cne?'-':' ', crr, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
				else if (cmx == 2) {gfp += sprintf(gfp, "%cv%d.%c%c%c%c",        cne?'-':' ',  va, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
				else if (arl)      {gfp += sprintf(gfp, "%cc[a0.x+%d].%c%c%c%c", cne?'-':' ',  ca, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
				else               {gfp += sprintf(gfp, "%cc[%d].%c%c%c%c",      cne?'-':' ',  ca, xyzw[cs[0]],xyzw[cs[1]],xyzw[cs[2]],xyzw[cs[3]]);}
			}
			gfp += sprintf(gfp, "\n");
		}
	}
#endif


}



//repeatcount = the number of tests to run. Note: if you pass 0x7fffffff, it will repeat forever. (0x7ffffffd will just _seem_ like it runs forever.)
void RandomTest(int repeatcount, int seed) 
{
	DbgPrint("*****\n vertex shader generator Seed: %d\n*****\n", seed);

	char fileonly[16] = {0};

#ifdef XBOX
//	char TestDir[] = "\\\\jgoulddev\\satest";
    char FailDir[] = "t:\\satest";
    CreateDirectory(FailDir, NULL); //we deal with failure later...
	xSetFunctionName(hlog, "shadeasm: RandomTest");
	xStartVariation(hlog, "random shaders");
#else
//	char TestDir[] = "..\\..\\..\\tests\\Media\\satest\\temp";
//	CreateDirectory(TestDir, NULL);
	char FailDir[] = "..\\..\\..\\tests\\Media\\satest";
	CreateDirectory(FailDir, NULL);
#endif

	int shadercount; //number of shaders written so far
	int i, j;
	char buf[100]; // enough room for "mad c[-96].xyzw, -c[a0.x+-96].xyzw, -c[a0.x+-96].xyzw, -c[a0.x+-96].xyzw"

	srand(seed);
	#ifdef XBOX
		xLog(hlog, XLL_PASS, "random seed: %d", seed);
	#else 
		DbgPrint("random seed: %d\n", seed);
	#endif


	for(shadercount = 0; shadercount < repeatcount; shadercount++) {
		if(shadercount == 0x7ffffffe) shadercount = 0x7ffffffd;
		int numinstructions;

		for(i = 0; i < 13; i++) {
			for(j = 0; j < 4; j++) {
				gbHasWrittenReg[i][j] = false;
			}
		}
		gbHasWrittenArl = false;
		gbHasWrittenConst = false;

//		sprintf(filename, "%s\\%d.vsh", TestDir, shadercount + START_NUM);
		sprintf(fileonly,     "%d.vsh",          shadercount + START_NUM);

		gfp = gfilebuf;

		switch(rand() % 4) {
		case 0:
			gfp += sprintf(gfp, "vs.1.");
			gbCanWriteConsts = false;
			gbStateShader = false;
			gbCanAccessConsts = false;
			break;
		case 1:
			gfp += sprintf(gfp, "xvs.1.");
			gbCanWriteConsts = false;
			gbStateShader = false;
			gbCanAccessConsts = true;
			break;
		case 2:
			gfp += sprintf(gfp, "xvsw.1.");
			gbCanWriteConsts = true;
			gbStateShader = false;
			gbCanAccessConsts = true;
			break;
		case 3:
			gfp += sprintf(gfp, "xvss.1.");
			gbCanWriteConsts = true;
			gbStateShader = true;
			gbCanAccessConsts = true;
			break;
		}
		switch(rand() & 1) {
		case 0:
			gfp += sprintf(gfp, "0\n");
			gbCanUseArl = false;
			break;
		case 1:
			gfp += sprintf(gfp, "1\n");
			gbCanUseArl = true;
			break;
		}

		if(rand() & 1) {
			gfp += sprintf(gfp, "#pragma screenspace\n");
		}

		int instructioncount;

		// I figure it's very doubtful that this will overflow the 136-instruction limit, 
		//since pairing and dead-code will happen a lot
		numinstructions = rand() % (250); //should be 136 * 2, but that tends to produce a lot of over-size code.
		if((!gbCanAccessConsts) && (numinstructions > 128)) numinstructions = 128;
		DWORD flags = SASM_VERIFY_OPTIMIZATIONS | 
			((rand() & 1) ? 0 : SASM_DISABLE_GLOBAL_OPTIMIZATIONS);
		if((flags & SASM_DISABLE_GLOBAL_OPTIMIZATIONS) && (numinstructions > 142)) numinstructions = 142;

		gNumLines = 0;
		for(instructioncount = 0; instructioncount < numinstructions - 1; instructioncount++) {
			if(::gbCanAccessConsts /** && 0 /**/) {
				DoIt();
			} else {
				DoInstruction(false);
				DoInput(buf);
				DoOutput();
				gfp += sprintf(gfp, "%s\n", buf);
			}
			if(gNumLines >= 265) break;
		}

		if (((!gbHasWrittenReg[12][0]) || (!gbHasWrittenReg[12][1])) && (!(gbStateShader))) {
			DoInstruction(true);
			gfp += sprintf(gfp, "oPos.%c%c, ", gbHasWrittenReg[12][0] ? 'y' : 'x', (gbHasWrittenReg[12][0] || gbHasWrittenReg[12][1]) ? ' ' : 'y');
			DoInput(buf);
			gfp += sprintf(gfp, "%s\n", buf);
		}
		if(gbStateShader && !gbHasWrittenConst) {
			DoInstruction(true);
			gfp += sprintf(gfp, "c0.x, ");
			DoInput(buf);
			gfp += sprintf(gfp, "%s\n", buf);
		}

	LPXGBUFFER ucodeBuffer = NULL;
	LPXGBUFFER errorBuffer = NULL;
	LPXGBUFFER listBuffer = NULL;
	HRESULT hr;

	//	DbgPrint("File %s\n", fileonly);
		hr = AssembleShader(
			fileonly,
			gfilebuf,
			gfp - gfilebuf,
			flags,
			NULL, //const
			&ucodeBuffer,
			&errorBuffer,
			&listBuffer,
			NULL, NULL,
            NULL);


/*
		f = fopen(filename, "w");

		if(!f) {
			DbgPrint("error! couldn't open %s\n", filename);
			continue;
		}
		fprintf(f, gfilebuf);
		fclose(f);
*/

		if (FAILED(hr)) {
			if(strstr((char*)XGBuffer_GetBufferPointer(errorBuffer), "is 136")) { //too big. We don't care. 
			} else {
#ifndef XBOX
				DbgPrint("File %s failed: 0x%08x\n", fileonly, hr);
#else
				xLog(hlog, XLL_FAIL, "file %d failed!", shadercount);
#endif
				char buf[MAX_PATH];
				sprintf(buf, "%s\\%s", FailDir, fileonly);
				FILE* f = fopen(buf, "w");
				if(f == NULL) {
					xLog(hlog, XLL_FAIL, "can't open %s. \n", buf);
					sprintf(buf, "t:\\%s", fileonly);
					f = fopen(buf, "w");
				}
				if(f != NULL) {
					fprintf(f, gfilebuf);
					fclose(f);
				} else {
					xLog(hlog, XLL_FAIL, "can't open %s. \n", buf);
					return;
				}
			}
		} else {
#ifdef XBOX
		//	xLog(hlog, XLL_PASS, "file %d succeeded\n", shadercount);
#endif
		} 
	RELEASE(listBuffer);
	RELEASE(ucodeBuffer);
	RELEASE(errorBuffer);
	}
#ifdef XBOX
	xEndVariation(hlog);
#endif
}





#include "..\vshtools\vshgen.h"

LIPOTESTRETURN Satest (XBuffer* pShader, void*) 
{
char* fileonly = "a";
DWORD flags = SASM_VERIFY_OPTIMIZATIONS;
char* faildir = "c:\\sd\\private\\windows\\directx\\dxg\\tests\\media\\satest\\temp";

	HRESULT hr = S_OK;
	LPXGBUFFER ucodeBuffer = NULL;
	LPXGBUFFER errorBuffer = NULL;
	LPXGBUFFER listBuffer = NULL;

//	DbgPrint("File %s\n", fileonly);
	hr = XGAssembleShader(fileonly,	pShader->GetText(),	pShader->GetUsed(),
		SASM_DONOTOPTIMIZE,	NULL, 
		&ucodeBuffer, &errorBuffer,	&listBuffer, NULL, NULL, NULL);

	if (FAILED(hr)) {
		if(strstr((char*)XGBuffer_GetBufferPointer(errorBuffer), "is 136")) { //too big. We don't care. 
			RELEASE(listBuffer);
			RELEASE(ucodeBuffer);
			RELEASE(errorBuffer);
			return ltrTestFailed;
		} else {
			RELEASE(listBuffer);
			RELEASE(ucodeBuffer);
			RELEASE(errorBuffer);
			return ltrInvalid;
		}
	} 

	hr = XGAssembleShader(fileonly,	pShader->GetText(),	pShader->GetUsed(),
		SASM_VERIFY_OPTIMIZATIONS,	NULL, 
		&ucodeBuffer, &errorBuffer,	&listBuffer, NULL, NULL, NULL);

	RELEASE(listBuffer);
	RELEASE(ucodeBuffer);
	RELEASE(errorBuffer);

	if (FAILED(hr)) {
		return ltrTestFailed;
	} else {
//		xLog(hlog, XLL_PASS, "file %s succeeded\n", fileonly);
		return ltrTestPassed;
	}
}

void RandomTest2(int repeatcount, int seed) 
{
	XBuffer* pShader;
	XBuffer* pShrunkShader;

	int iShader;
	char fileonly[16] = {0};
//	char buf[100];
	HRESULT hr;
	
	xLog(hlog, XLL_INFO, "*** random seed: %d ***\n", seed);
	srand(seed);

#ifdef XBOX
    char FailDir[] = "t:\\satest";
    CreateDirectory(FailDir, NULL); //we deal with failure later...
	xSetFunctionName(hlog, "shadeasm: RandomTest");
	xStartVariation(hlog, "random shaders");
#else
	char FailDir[] = "..\\..\\..\\tests\\Media\\satest";
	CreateDirectory(FailDir, NULL);
#endif


	for(iShader = 0; iShader < repeatcount; iShader++) {
		//if repeatcount == max_int, repeat infinitely
		if(iShader == 0x7ffffffe) {
			iShader = 0; 
		}

		pShader = NULL;
		pShrunkShader = NULL;

		hr = GenerateRandomVertexShader(
            1, 136, 0, RND(1,3), true, RNDTF(), true, true, RNDTF(), RNDTF(), &pShader);
		if(FAILED(hr)) {
			xLog(hlog, XLL_INFO, "GenerateRandomVertex Shader Failed: %x", hr);
		} else {
			//xLog(hlog, XLL_INFO, pShader->GetText());
		}

		hr = LipoVsh(pShader, &pShrunkShader, Satest, NULL, false, false);
		if(hr == S_OK) {
			//there was a bug detected. LipoVsh minimized it, and saved it to
			//pShrunkShader. We just need to save it to disk, and spew.
			xLog(hlog, XLL_INFO, "Spew\n");
			_asm {int 3};

		} else if(FAILED(hr)) {
			//the shader generated was invalid. 
			xLog(hlog, XLL_INFO, "LipoVsh returned %x.", hr);
//			_asm {int 3};

		} else if (hr == S_FALSE) {
		//	xLog(hlog, XLL_INFO, "shader good.\n");
			//this means the shader was fine, and was not shrunk. Continue!
		}


		delete pShader;
		delete pShrunkShader;
	}
}
	





#ifdef XBOX
void __cdecl blah()
#else
int __cdecl main(int argc, char* argv[])
#endif
{
	// Read each of the shader assembler files out of the test directory, and assemble it.
#ifdef XBOX
	static const char*    pszPath             = "xt:\\satest";
#else
	static const char*    pszPath             = "..\\..\\..\\tests\\Media\\satest";
	///////
	//make this a background test. This will ensure it won't mangle timing of other processes.
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);
	///////
#endif


	HRESULT hr = S_OK;
	HRESULT allHR = S_OK;
	char* extensions[] = {
		"nva", // For internal testing.
//		"nvv", // NVIDIA samples made this popular
		"vsh", //our sample format.
		0
	};
	for(int i = 0; extensions[i]; i++){
//		hr = TryAllFiles(pszPath, extensions[i]);
		if(FAILED(hr)){
			allHR = hr;
		}
	}

	RandomTest2(2000, /*0/*/time(0)/**/); //keep running for a year or so

	DbgPrint("\n\nDone\n");
#ifndef XBOX
	return allHR;
#endif
}

#ifdef XBOX
VOID WINAPI SATESTStartTest(HANDLE Log)
{
    hlog = Log;
    xSetComponent( hlog, "Direct3D(S)", "XGraphics (s-d3d)" );
	RandomTest(1000, time(0)); //should take less than 2 minutes
}

VOID WINAPI SATESTEndTest(VOID)
{
}

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( SATEST )
#pragma data_seg()

BEGIN_EXPORT_TABLE( SATEST )
    EXPORT_TABLE_ENTRY( "StartTest", SATESTStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", SATESTEndTest )
END_EXPORT_TABLE( SATEST )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\texture\main.cpp ===
/*--

    Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

--*/

#ifdef XBOX
#include <xtl.h>
#else
#include <D3DX8.h>
#endif

#include <stdio.h>
#include <stdlib.h>

IDirect3DDevice8 *pDev = NULL;
IDirect3DVertexBuffer8 *pVB = NULL;
IDirect3DTexture8 *pTexture = NULL;

DWORD dwFVF = D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1;

#ifndef XBOX
HWND GetWindow(HINSTANCE hInstance)
{
    HWND hwnd;

    // Register the windows class
    WNDCLASS wndClass = {CS_CLASSDC, DefWindowProc, 0, 0, hInstance,
                        NULL, NULL, (HBRUSH)GetStockObject(WHITE_BRUSH),
                        NULL, L"Dummy Window"};

    RegisterClass( &wndClass );

    // Create the render window
    hwnd = CreateWindow(L"Dummy Window", NULL, WS_MINIMIZE, 0, 0, 1, 1, 0,
                        NULL, hInstance, 0);

    ShowWindow(hwnd, SW_SHOWNORMAL);
    ShowCursor(FALSE);

    return hwnd;
}
#endif

static struct TheVerts { float x,y,z,w; DWORD color; float u, v;} Verts[] =
{
    {113.0f,   0.0f, 0.5f, 1.0f, 0xffffffff, 0.0, 0.0},
    {527.0f, 360.0f, 0.5f, 1.0f, 0xffffffff, 1.0, 1.0},
    {113.0f, 360.0f, 0.5f, 1.0f, 0xffffffff, 0.0, 1.0},
    {527.0f,   0.0f, 0.5f, 1.0f, 0xffffffff, 1.0, 0.0},
    {527.0f, 360.0f, 0.5f, 1.0f, 0xffffffff, 1.0, 1.0},
    {113.0f,   0.0f, 0.5f, 1.0f, 0xffffffff, 0.0, 0.0},
};

void InitD3D(HWND hwnd)
{
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);

    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory(&d3dpp, sizeof(d3dpp));
    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_R5G6B5;
    d3dpp.BackBufferCount           = 1;
    d3dpp.Windowed                  = false;
    d3dpp.EnableAutoDepthStencil    = true;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D16;
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow             = hwnd;
    d3dpp.Flags                     = D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    pD3D->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hwnd,
            D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &pDev);

    pD3D->Release();
}

void InitVB()
{
    void* pVerts;

    pDev->CreateVertexBuffer(sizeof(Verts), D3DUSAGE_WRITEONLY, dwFVF, D3DPOOL_MANAGED, &pVB);

    pVB->Lock(0, sizeof(Verts), (BYTE **)(&pVerts), 0);
    memcpy((void*)pVerts, (void*)Verts, sizeof(Verts));
    pVB->Unlock();

    pDev->SetStreamSource(0, pVB, sizeof(Verts[0]));
    pDev->SetVertexShader(dwFVF);
}

void Paint()
{
    TheVerts* pVerts;
    pVB->Lock(0, sizeof(Verts), (BYTE **)(&pVerts), 0);

    static DWORD Time = GetTickCount();
    DWORD CurrentTime = GetTickCount();

    // 10 seconds per rotation
    float spin = 2 * 3.14159f * (float)(CurrentTime - Time) / 10000.0f;
    DWORD i;

    for (i = 0; i < sizeof(Verts) / sizeof(Verts[1]); i++)
    {

        float x = Verts[i].x;
        float y = Verts[i].y;

        x = x - 320.0f;
        y = y - 240.0f;

        pVerts[i].x = x * (float)cos(spin) - y * (float)sin(spin);
        pVerts[i].y = x * (float)sin(spin) + y * (float)cos(spin);

        pVerts[i].x += 320.0f;
        pVerts[i].y += 240.0f;
    }

    pVB->Unlock();

    pDev->Clear(0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0X00C0C0C0, 1.0, 0);

    pDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    pDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    pDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);

    pDev->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
    pDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    pDev->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);

    pDev->BeginScene();

    pDev->SetTexture(0, pTexture);

    pDev->DrawPrimitive( D3DPT_TRIANGLELIST, 0, (sizeof(Verts) / sizeof(Verts[0])) / 3);
    pDev->EndScene();

    pDev->Present(NULL, NULL, NULL, NULL);
}

#ifdef XBOX
void __cdecl main()
#else
INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )
#endif
{
#ifdef XBOX
    HWND hwnd = NULL;
#else
    HWND hwnd = GetWindow(hInst);
#endif

    InitD3D(hwnd);
    InitVB();

    D3DXSetDXT3DXT5(FALSE);

    D3DXCreateTextureFromFileA(pDev, "d:\\media\\dxt3.dds", &pTexture);

    while (TRUE)
    {
        Paint();
    }

#ifndef XBOX
    return 0;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\tricpp\sdkcommon.h ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    SDKCommon.h

Abstract:

    Common header files and macros for the Xbox SDK

Revision History:

--*/

#if !defined(SDK_HEADER_SDKCOMMON_H)
#define SDK_HEADER_SDKCOMMON_H

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef STRICT
#define STRICT 1
#endif
#undef D3D_OVERLOADS

// Windows headers

#ifdef XBOX
#include <xtl.h>
#else
#include "Windows.h"
#include "D3D8.h"
#endif

#if defined(__cplusplus)
extern "C" {
#endif // __cplusplus

#pragma warning (disable:4850)

// __$ReturnUdt is the address of the destination when returning a structure
// It is Microsoft specific so will need to be adjusted to work with other
// compilers. The best way is to declare a local of the correct type and
// then return in.
#define that_ptr __$ReturnUdt

#if defined(__cplusplus)
}
#endif // __cplusplus

#endif //#ifndef SDK_HEADER_RENDERSURFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\simple\main.cpp ===
//  RECUI.CPP
//
//      Harddisk recovery UI
//
//  Created 12-Aug-2000 [jont]

#include <stdio.h>
#ifdef XBOX
#include <SDKCommon.h>
#else // XBOX
#include <windows.h>
#include <d3d8.h>
#include <d3dx8.h>
#endif // XBOX

#include "bitfont.h"

extern "C" ULONG DebugPrint(PCHAR Format, ...);

extern "C" { extern BOOL D3D__Parser; }

#define CheckHR(x) { HRESULT _hr = (x); if (FAILED(_hr)) { DisplayError(L#x, _hr); } }

#define BACKGROUND_COLOR 0x00000000

//  Globals
IDirect3DDevice8* g_pdev = NULL;
IDirect3DSurface8* g_pback = NULL;
IDirect3DVertexBuffer8* g_pvb = NULL;
IDirect3DVertexBuffer8* g_pvbBackVerts = NULL;
IDirect3DVertexBuffer8* g_pvbBackColors = NULL;
DWORD g_dwFrames = 0;
DWORD g_dwCounter = 0;
BOOL g_Clockwise = TRUE;
D3DSURFACE_DESC g_BackDesc;
float g_fSecsPerTick;

D3DXMATRIX  matView;
D3DXMATRIX  matInverseView;
D3DXMATRIX  matProjectionViewport;
D3DXMATRIX  matComposite;

BitFont m_Font;

// Define our vertices

typedef struct
{
    float x, y, z;
    float nx, ny, nz;
    DWORD color;
} BASIC_VERT;

#define FVF_BASIC_VERT (D3DFVF_XYZ  | D3DFVF_NORMAL | D3DFVF_DIFFUSE)

BASIC_VERT Verts[] =
{
    {  0.0f, 2.0f, 2.0f, 0.0f, 1.0f, -2.0f, 0xffff0000 },
    {  1.0f, 0.0f, 1.0f, 0.0f, 1.0f, -2.0f, 0xff00ff00 },
    { -1.0f, 0.0f, 1.0f, 0.0f, 1.0f, -2.0f, 0xff0000ff },
};

DWORD PassThroughProgram[] =
{
    0x000a2078,
    0x00000000, 0x0020001b, 0x0836086c, 0x1f000ff8,
    0x00000000, 0x0400001b, 0x04360bfc, 0x10017ff8,
    0x00000000, 0x0040001b, 0x0436186c, 0x1f000ff8,
    0x00000000, 0x0060201b, 0x0436086c, 0x3070f800,
    0x00000000, 0x0020061b, 0x0836086c, 0x1070f818,
    0x00000000, 0x0020081b, 0x0836086c, 0x1070f820,
    0x00000000, 0x002008ff, 0x0836086c, 0x1070f828,
    0x00000000, 0x00200200, 0x0836086c, 0x1070f830,
    0x00000000, 0x0020121b, 0x0836086c, 0x1070f848,
    0x00000000, 0x0020141b, 0x0836086c, 0x1070f850,
};

DWORD BadStateProgram[] =
{
    0x00017378,
    0xdeadbeef, 0xdeadbeef, 0xdeadbeef, 0xdeadbeef, 
};

//------------------------------------------------------------------------------
// Define our background triangle.

static struct { float x,y,z,w; } BackVerts[] =
{
    {320.0f,   0.0f, 0.5f, 1.0f},
    {527.0f, 360.0f, 0.5f, 1.0f},
    {113.0f, 360.0f, 0.5f, 1.0f},
};

static struct { DWORD skip,color; } BackColors[] =
{
    {0xdeadbeef,0xffffffff}, 
    {0xdeadbeef,0xffff0000}, 
    {0xdeadbeef,0xff0000ff}, 
};

//  GetTime
//      Returns an accurate time in seconds

float GetTime(void)
{
    LARGE_INTEGER qwTime;

    QueryPerformanceCounter(&qwTime);
    return ((float)qwTime.QuadPart) * g_fSecsPerTick;
}


//  DisplayError
//      Helper to display error messages.  This just shoves them out through the
//      debug console.

void DisplayError(const WCHAR* szCall, HRESULT hr)
{
    WCHAR szErr[512];
    unsigned cch;

    if (hr)
    {
        cch = _snwprintf(szErr, sizeof(szErr), L"FATAL: %s failed 0x%08lX: ", szCall, hr);
        D3DXGetErrorString(hr, &szErr[cch], sizeof (szErr));
    }
    else
    {
        wcscpy(szErr, szCall);
    }

    wcscat(szErr, L"\n");

    OutputDebugString(szErr);

    _asm int 3;
}


// InitLight
//      Initializes a D3DLIGHT structure, setting the light position. The
//      diffuse color is set to white, specular and ambient left as black

VOID InitLight(D3DLIGHT8& light, D3DLIGHTTYPE ltType,
    float x, float y, float z)
{
    ZeroMemory(&light, sizeof(D3DLIGHT8));
    light.Type = ltType;
    light.Diffuse.r = 1.0f;
    light.Diffuse.g = 1.0f;
    light.Diffuse.b = 1.0f;
    light.Position.x = light.Direction.x = x;
    light.Position.y = light.Direction.y = y;
    light.Position.z = light.Direction.z = z;
    light.Range = 1000.0f;
}

//  InitD3D

BOOL InitD3D(HWND hWnd)
{
#if DBG
    D3D__Parser = TRUE;
#endif

    // Create D3D 8.
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    if (pD3D == NULL)
        return FALSE;

    // Set the screen mode.
    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory(&d3dpp, sizeof (d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount           = 1;
    d3dpp.Windowed                  = FALSE;   // Must be false for Xbox.
    d3dpp.EnableAutoDepthStencil    = TRUE;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz= 60;
    d3dpp.hDeviceWindow             = hWnd;
    d3dpp.Flags                     = D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;

    // Create the device.
    if (pD3D->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd,
            D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pdev) != S_OK)
    {
        OutputDebugString(L"Couldn't create device!\n");
        return FALSE;
    }

    // Now we no longer need the D3D interface so lets free it.
    pD3D->Release();

    // Store render target surface descriptor

    CheckHR(g_pdev->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &g_pback));

    CheckHR(g_pback->GetDesc(&g_BackDesc));

    // Set world transform
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity(&matWorld);
    CheckHR(g_pdev->SetTransform(D3DTS_WORLD, &matWorld));

    // Set the view matrix
    D3DXMATRIX  matInverseViewTranspose;
    D3DXVECTOR3 vEyePt      = D3DXVECTOR3(0.0f, 1.0f, -5.0f);
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3(0.0f, 1.0f,  0.0f);
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3(0.0f, 1.0f,  0.0f);
    D3DXMatrixLookAtLH(&matView, &vEyePt, &vLookatPt, &vUpVec);
    CheckHR(g_pdev->SetTransform(D3DTS_VIEW, &matView));

    g_pdev->SetRenderState(D3DRS_NORMALIZENORMALS, TRUE); 

    // Set projection transform
    D3DXMATRIX matProj;
    float fAspect = ((float)g_BackDesc.Height) / g_BackDesc.Width;

    D3DXMatrixPerspectiveFovLH(&matProj, D3DX_PI / 3, fAspect, 1.0f, 10000.0f);
    CheckHR(g_pdev->SetTransform(D3DTS_PROJECTION, &matProj));

    // Set the model-view:
    CheckHR(g_pdev->GetProjectionViewportMatrix(&matProjectionViewport));
    D3DXMatrixInverse(&matInverseView, NULL, &matView);
    D3DXMatrixMultiply(&matComposite, &matView, &matProjectionViewport);
    CheckHR(g_pdev->SetModelView(&matView, &matInverseView, &matComposite));

    // Set default render states

    CheckHR(g_pdev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE));
    CheckHR(g_pdev->SetRenderState(D3DRS_DITHERENABLE, TRUE));
    CheckHR(g_pdev->SetRenderState(D3DRS_SPECULARENABLE, FALSE));
    CheckHR(g_pdev->SetRenderState(D3DRS_ZENABLE, FALSE));
    CheckHR(g_pdev->SetRenderState(D3DRS_NORMALIZENORMALS, TRUE));

    // Set up the lighting states

    D3DMATERIAL8 material;
    ZeroMemory(&material, sizeof(material));
    material.Ambient.r = 1.0f;
    material.Ambient.g = 1.0f;
    material.Ambient.b = 1.0f;
    CheckHR(g_pdev->SetMaterial(&material));
    CheckHR(g_pdev->SetBackMaterial(&material));

    D3DLIGHT8 light;
    InitLight(light, D3DLIGHT_DIRECTIONAL, 0.0f, -1.0f, 1.0f);
    CheckHR(g_pdev->SetLight(0, &light));
    CheckHR(g_pdev->LightEnable(0, TRUE));
    CheckHR(g_pdev->SetRenderState(D3DRS_LIGHTING, TRUE));
    CheckHR(g_pdev->SetRenderState(D3DRS_TWOSIDEDLIGHTING, TRUE));
    CheckHR(g_pdev->SetRenderState(D3DRS_BACKAMBIENT, 0x33333333));
    CheckHR(g_pdev->SetRenderState(D3DRS_AMBIENT, 0xffff2020));

    return TRUE;
}


//  InitVB

BOOL InitVB(void)
{
    void* pVerts;
    void* pBackVerts;
    void* pBackColors;

    CheckHR(g_pdev->CreateVertexBuffer(sizeof (Verts), D3DUSAGE_WRITEONLY, 0,
        0, &g_pvb));

    g_pvb->Lock(0, sizeof(Verts), (BYTE**)(&pVerts), 0);
    memcpy((void*)pVerts, (void*)Verts, sizeof (Verts));
    g_pvb->Unlock();

    CheckHR(g_pdev->CreateVertexBuffer(sizeof (BackVerts), D3DUSAGE_WRITEONLY, 0,
        0, &g_pvbBackVerts));

    g_pvbBackVerts->Lock(0, sizeof(BackVerts), (BYTE**)(&pBackVerts), 0);
    memcpy((void*)pBackVerts, (void*)BackVerts, sizeof (BackVerts));
    g_pvbBackVerts->Unlock();

    CheckHR(g_pdev->CreateVertexBuffer(sizeof (BackColors), D3DUSAGE_WRITEONLY, 0,
        0, &g_pvbBackColors));

    g_pvbBackColors->Lock(0, sizeof(BackColors), (BYTE**)(&pBackColors), 0);
    memcpy((void*)pBackColors, (void*)BackColors, sizeof (BackColors));
    g_pvbBackColors->Unlock();

    return TRUE;
}


//  Init2D

BOOL Init2D(void)
{
    // Set up the timer
    LARGE_INTEGER qwTicksPerSec;
    QueryPerformanceFrequency(&qwTicksPerSec);
    g_fSecsPerTick = 1.0f / (float)qwTicksPerSec.QuadPart;

    return TRUE;
}


//  DisplayText

void DisplayText(const WCHAR* sz, int iY, DWORD dwColor)
{
    m_Font.DrawText(g_pback, sz, 0, iY, DRAWTEXT_TRANSPARENTBKGND, dwColor, 0);
}


//  UpdateFrameRate

WCHAR* UpdateFrameRate(void)
{
    static float fLastTime = 0.0f;
    float fTime = GetTime();
    float fFPS;
    static WCHAR szFrameRate[256];

    // Update the scene stats once per second
    if (fTime - fLastTime > 1.0f)
    {
        fFPS = g_dwFrames / (fTime - fLastTime);

        swprintf(szFrameRate, L"%.2f fps (%dx%dx%d)", fFPS,
            g_BackDesc.Width, g_BackDesc.Height,
            g_BackDesc.Format == D3DFMT_X8R8G8B8 ? 32 : 16);

        // Reset
        fLastTime  = fTime;
        g_dwFrames = 0;
    }

    return szFrameRate;
}


//  Paint

#define TRIANGLES 12000
WORD indices[3 * TRIANGLES];

void Paint(void)
{
    DWORD get0[4];
    DWORD get1[4];
    DWORD clear[192][4];
    DWORD junk;
    DWORD hBackShader;
    DWORD declaration[] = 
    {
        D3DVSD_STREAM(0),
        D3DVSD_REG(0, D3DVSDT_FLOAT4),
        D3DVSD_STREAM(1),
        D3DVSD_SKIP(1),
        D3DVSD_REG(3, D3DVSDT_D3DCOLOR),
        D3DVSD_CONST(-96, 2),
        0x3f800000, 0x3f800000, 0x00000000, 0x3f800000,
        0x3f080000, 0x3f080000, 0x00000000, 0x00000000,
        D3DVSD_CONST(94, 2),
        0x3f800000, 0x3f800000, 0x00000000, 0x3f800000,
        0x3f080000, 0x3f080000, 0x00000000, 0x00000000,

        D3DVSD_END()
    };

    // Clear the frame buffer, Zbuffer.
    g_pdev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, BACKGROUND_COLOR, 1.0, 0);

    g_pdev->BeginScene();

    // Use a vertex shader program with all 192 constant registers to draw
    // the background triangle.
    CheckHR(g_pdev->SetShaderConstantMode(D3DSCM_192CONSTANTS));
    for (INT blah = 0; blah < 192; blah++)
    {
        clear[blah][0] = blah;
        clear[blah][1] = blah;
        clear[blah][2] = blah;
        clear[blah][3] = blah;
    }
    CheckHR(g_pdev->CreateVertexShader(NULL, BadStateProgram, &junk, 0));
    CheckHR(g_pdev->LoadVertexShader(junk, 0));
    CheckHR(g_pdev->DeleteVertexShader(junk));
    CheckHR(g_pdev->CreateVertexShader(declaration, NULL, &junk, 0));
    CheckHR(g_pdev->DeleteVertexShader(junk));
    CheckHR(g_pdev->SetVertexShaderConstant(-96, &clear[0][0], 58));   // Skip -38 and -37
    CheckHR(g_pdev->SetVertexShaderConstant(-36, &clear[60][0], 132));
    CheckHR(g_pdev->CreateVertexShader(declaration, PassThroughProgram, &hBackShader, 0));
    CheckHR(g_pdev->LoadVertexShader(hBackShader, 3));
    CheckHR(g_pdev->GetVertexShaderConstant(-96, get0, 1));
    CheckHR(g_pdev->GetVertexShaderConstant(94, get1, 1));
    if ((get0[0] != 0x3f800000) ||
        (get0[1] != 0x3f800000) ||
        (get0[2] != 0x00000000) ||
        (get0[3] != 0x3f800000) ||
        (get1[0] != 0x3f800000) ||
        (get1[1] != 0x3f800000) ||
        (get1[2] != 0x00000000) ||
        (get1[3] != 0x3f800000))
    {
        _asm int 3;
    }

    if ((g_dwCounter++ % 60) == 0)
        g_Clockwise = !g_Clockwise;

    CheckHR(g_pdev->SetRenderState(D3DRS_FRONTFACE, g_Clockwise ? D3DFRONT_CW : D3DFRONT_CCW));
    CheckHR(g_pdev->SelectVertexShader(hBackShader, 3));
    CheckHR(g_pdev->SetStreamSource(0, g_pvbBackVerts, sizeof(BackVerts[0])));
    CheckHR(g_pdev->SetStreamSource(1, g_pvbBackColors, sizeof(BackColors[0])));
    // CheckHR(g_pdev->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1));

    for (DWORD i = 0; i < 3 * TRIANGLES; i += 3)
    {
        indices[i] = 0;
        indices[i + 1] = 1;
        indices[i + 2] = 2;
    }

    DWORD count = 0;
    while (TRUE)
    {
        CheckHR(g_pdev->DrawIndexedVertices(D3DPT_TRIANGLELIST, 3 * TRIANGLES, indices));
        count++;
        if (1) // ((count % 100) == 0)
        {
            CHAR buffer[200];
            sprintf(buffer, "Count: %li\n", count);
            OutputDebugStringA(buffer);
        }
    }

    // Draw the foreground triangle using stream 0.
    CheckHR(g_pdev->SetShaderConstantMode(D3DSCM_96CONSTANTS));
    CheckHR(g_pdev->SetModelView(&matView, &matInverseView, &matComposite));
    CheckHR(g_pdev->SetShaderConstantMode(D3DSCM_96CONSTANTS));
    CheckHR(g_pdev->SetStreamSource(0, g_pvb, sizeof (BASIC_VERT)));
    CheckHR(g_pdev->SetVertexShader(FVF_BASIC_VERT));
    CheckHR(g_pdev->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1));
    CheckHR(g_pdev->DeleteVertexShader(hBackShader));

    // Draw some text
    DisplayText(UpdateFrameRate(), 0, 0xffffffff);

    g_pdev->EndScene();

    // Flip the buffers.
    g_dwFrames++;
    g_pdev->Present(NULL, NULL, NULL, NULL);
}


#if defined(XBOX)

extern "C" { extern BOOL D3D__SingleStepPusher; }

void __cdecl main()
{
    #if DBG
        D3D__SingleStepPusher = TRUE;
    #endif

    if (!InitD3D(NULL) || !InitVB() || !Init2D())
        return;

    while (TRUE)
    {
        Paint();
    }
}

#else

//------------------------------------------------------------------------------
LRESULT WINAPI MessageHandler
(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
//--------------------------------------
{
    if (Msg == WM_DESTROY)
        PostQuitMessage(0);

    return DefWindowProc(hWnd, Msg, wParam, lParam);
}

//------------------------------------------------------------------------------
int APIENTRY WinMain
(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpCmdLine,
    int         nCmdShow
)
//--------------------------------------
{
    MSG msg;
    BOOL bQuit = FALSE;

    WNDCLASSEX classex;
    ZeroMemory( &classex, sizeof(classex) );

    classex.cbSize          = sizeof(WNDCLASSEX);
    classex.style           = CS_CLASSDC;
    classex.lpfnWndProc     = MessageHandler;
    classex.hInstance       = hInstance;
    classex.lpszClassName   = L"XBOX";
    RegisterClassEx(&classex);

    HWND hwnd = CreateWindowEx(WS_EX_TOPMOST, L"XBOX", L"XBOX Basic Shell",
                          WS_VISIBLE|WS_POPUP,
                          CW_USEDEFAULT,CW_USEDEFAULT, 0, 0,
                          NULL, NULL, hInstance, NULL);

    if (!InitD3D(hwnd) || !InitVB() || !Init2D())
    {
        return EXIT_FAILURE;
    }

    ShowCursor(false);

    while (!bQuit)
    {
        while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
        {
            if (!GetMessage(&msg, NULL, 0, 0))
            {
                bQuit = true;
            }

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        Paint();
    }

    return EXIT_SUCCESS;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\trivs\sdkcommon.h ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    SDKCommon.h

Abstract:

    Common header files and macros for the Xbox SDK

Revision History:

--*/

#if !defined(SDK_HEADER_SDKCOMMON_H)
#define SDK_HEADER_SDKCOMMON_H

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef STRICT
#define STRICT 1
#endif
#undef D3D_OVERLOADS

// Windows headers

#ifdef XBOX
#include <xtl.h>
#else
#include "Windows.h"
#include "D3D8.h"
#endif

#if defined(__cplusplus)
extern "C" {
#endif // __cplusplus

#pragma warning (disable:4850)

// __$ReturnUdt is the address of the destination when returning a structure
// It is Microsoft specific so will need to be adjusted to work with other
// compilers. The best way is to declare a local of the correct type and
// then return in.
#define that_ptr __$ReturnUdt

#if defined(__cplusplus)
}
#endif // __cplusplus

#endif //#ifndef SDK_HEADER_RENDERSURFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\tilebug\main.cpp ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Complete DX8 application to draw a screen space triangle.

Revision History:

    Derived from a DX8 sample.
--*/

#include <stddef.h>
#include <stdio.h>

extern "C"
{
    #include <ntos.h>
    #include <nturtl.h>
    #include <av.h>
};

#include <xtl.h>
#include <xgraphics.h>

IDirect3DDevice8*          pDev  = NULL;

#define TILE_DIMENSION 256
#define TILE_PITCH 256 * 4
#define TILE_SIZE TILE_DIMENSION * TILE_PITCH

static struct GradientData { float x,y,z,w; float u, v; } gradientData[] =
{
    { 0,                  0,                  0, 1, 0.5f, 0.5f },
    { TILE_DIMENSION - 2, 0,                  0, 1, 1.5f, 0.5f },
    { TILE_DIMENSION - 2, TILE_DIMENSION - 2, 0, 1, 1.5f, 1.5f },
    { 0,                  TILE_DIMENSION - 2, 0, 1, 0.5f, 1.5f },
};

static struct TextureData { float x,y,z,w; float u, v; } textureData[] =
{
    { 0,              0,              0, 1, 0,              0 },
    { TILE_DIMENSION, 0,              0, 1, TILE_DIMENSION, 0 },
    { TILE_DIMENSION, TILE_DIMENSION, 0, 1, TILE_DIMENSION, TILE_DIMENSION },
    { 0,              TILE_DIMENSION, 0, 1, 0,              TILE_DIMENSION },
};

#define CheckHR(y) { HRESULT _hr = (y); if (FAILED(_hr)) { _asm { int 3 } } }

//------------------------------------------------------------------------------
// Geometry declarations

DWORD VertsShaderDeclaration[] =
{
    D3DVSD_STREAM(0),
    D3DVSD_REG(D3DVSDE_POSITION, D3DVSDT_FLOAT4), 
    D3DVSD_REG(D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2),
    D3DVSD_END()
};

static struct TheVerts { float y,x,z,w,tu,tv; } Verts[] =
{
    {320.0f,   0.0f, 0.5f, 1.0f,  0.5f, 0.0f},
    {527.0f, 360.0f, 0.5f, 1.0f,  1.0f, 1.0f},
    {113.0f, 360.0f, 0.5f, 1.0f,  0.0f, 1.0f},
};

//------------------------------------------------------------------------------
bool InitD3D
(
)
//--------------------------------------
{
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    if (pD3D == NULL)
        return false;

    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount           = 1;
    d3dpp.Windowed                  = false;   // Must be false for Xbox.
    d3dpp.EnableAutoDepthStencil    = true;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz= 60;
    d3dpp.hDeviceWindow             = NULL;
    d3dpp.MultiSampleType           = D3DMULTISAMPLE_NONE;

    // Create the device.
    if (pD3D->CreateDevice
    (
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        NULL,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        &pDev
    ) != S_OK)
    {
        return false;
    }

    pD3D->Release();

    return true;
}

//------------------------------------------------------------------------------
void Paint
(
)
//--------------------------------------
{
    D3DSurface surface;
    D3DSurface *pFrontBuffer;
    D3DTILE tile;
    DWORD y;
    DWORD x;
    D3DLOCKED_RECT lockedRect;
    DWORD* pTexel;
    DWORD xCount;
    DWORD yCount;
    VOID* pMemory;

    // Do some initialization:

    pDev->SetRenderState(D3DRS_ZENABLE, FALSE);
    pDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
    pDev->Clear(0, NULL, D3DCLEAR_TARGET, 0, 0, 0);
    pDev->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    pDev->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
    pDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    pDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    pDev->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);

    // Allocate  physically contiguous memory to hold our texture:

    pMemory = D3D_AllocContiguousMemory(TILE_SIZE, D3DTILE_ALIGNMENT);

    // Create the texture and point it to our allocated memory:

    XGSetSurfaceHeader(TILE_DIMENSION, TILE_DIMENSION, D3DFMT_LIN_A8R8G8B8, &surface, 0, TILE_PITCH);

    surface.Register(pMemory);

    // Create a tile where the texture resides.
    //
    // NOTE: Set Flags to D3DTILE_FLAGS_ZBUFFER to use a SENSE_1 tile and repro
    //       the bug, and set Flags to 0 to use a SENSE_0 tile and not repro the
    //       bug.

    tile.Flags = D3DTILE_FLAGS_ZBUFFER;
    tile.Pitch = TILE_PITCH;
    tile.pMemory = pMemory;
    tile.Size = TILE_SIZE;

    pDev->SetTile(3, &tile);

    // Lock the (tiled) surface.  This gives us a pointer into the AGP aperture,
    // which is a view coherent with tiling:

    surface.LockRect(&lockedRect, NULL, D3DLOCK_TILED);
    for (y = 0; y < TILE_DIMENSION; y++)
    {
        pTexel = (DWORD*) ((BYTE*) lockedRect.pBits + y * lockedRect.Pitch);

        for (x = 0; x < TILE_DIMENSION; x++, pTexel++)
        {
            *pTexel = (x << 8) | (y);
        }
    }
    surface.UnlockRect();

    // Render from our (tiled) texture to our (tiled) back buffer:

    pDev->SetTexture(0, (D3DTexture*) &surface);
    pDev->DrawVerticesUP(D3DPT_QUADLIST, 4, textureData, sizeof(textureData[0]));

    // Move our drawn stuff to the front buffer to show the results:

    pDev->Present(NULL, NULL, NULL, NULL);

    // Verify the results:

    pDev->GetBackBuffer(-1, 0, &pFrontBuffer);
    pFrontBuffer->LockRect(&lockedRect, NULL, D3DLOCK_TILED);

    yCount = 0;
    for (y = 0; y < TILE_DIMENSION; y++)
    {
        pTexel = (DWORD*) ((BYTE*) lockedRect.pBits + y * lockedRect.Pitch);

        xCount = 0;
        for (x = 0; x < TILE_DIMENSION; x++, pTexel++)
        {
            DWORD expected = (x << 8) | (y);
            DWORD got = *pTexel;
            if (got != expected)
            {
                DbgPrint("(%li, %li) - Expected 0x%lx, Got 0x%lx\n", x, y, expected, got);
                xCount++;
            }

            if (xCount > 10)
            {
                yCount++;
                break;
            }
        }

        if (yCount > 10)
            break;
    }

    pFrontBuffer->UnlockRect();
    pFrontBuffer->Release();

    DbgPrint("Done!\n");

    while (TRUE)
        ;
}

void __cdecl main()
{
    InitD3D();

    while (TRUE)
    {
        Paint();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\tric\main.c ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Complete DX8 application to draw a screen space triangle.

Revision History:

    Derived from a DX8 sample.
--*/

#ifdef XBOX
#define _USE_XGMATH
#include <SDKCommon.h>
#include <d3dx8.h>
#else // XBOX
#include <windows.h>
#include <d3d8.h>
#endif // XBOX

#include <stdio.h>

#define CheckHR(x) { HRESULT _hr = (x); if (FAILED(_hr)) { _asm { int 3 } } }

BOOL                       bQuit   = FALSE;
IDirect3DDevice8*          pDev  = NULL;
DWORD                      dwFVF = D3DFVF_XYZRHW|D3DFVF_DIFFUSE;
DWORD                      dwCount;

#define LOG_SIZE 400

DWORD g_i;
DWORD g_Log[LOG_SIZE + 20];
BOOL g_RecordLog = TRUE;

//------------------------------------------------------------------------------
// Define our screen space triangle.
static struct { float x,y,z,w; DWORD color; } Verts[] =
{
    {320.0f,  50.0f, 0.5f, 1.0f, 0xffff0000, },
    {620.0f, 430.0f, 0.5f, 1.0f, 0xff00ff00, },
    { 20.0f, 430.0f, 0.5f, 1.0f, 0xff0000ff, },
};

//-----------------------------------------------------------------------------
DWORD GetTime()                                                                
{                                                                              
    _asm rdtsc                                                                 
}                                                                              

//-----------------------------------------------------------------------------
void __cdecl SwapCallback(D3DSWAPDATA* pData)
{
    g_Log[g_i++] = GetTime();
    g_Log[g_i++] = 0;

    memcpy(&g_Log[g_i], pData, sizeof(*pData));
    g_i += sizeof(*pData)/4;

    if (g_i > LOG_SIZE)
        _asm int 3;
}

//-----------------------------------------------------------------------------
void __cdecl VBlankCallback(D3DVBLANKDATA* pData)
{
    g_Log[g_i++] = GetTime();
    g_Log[g_i++] = 1;

    memcpy(&g_Log[g_i], pData, sizeof(*pData));
    g_i += sizeof(*pData)/4;

    if (g_i > LOG_SIZE)
        _asm int 3;
}

//-----------------------------------------------------------------------------
void PrintLog()
{
    CHAR charBuf[200];
    DWORD i = 0;

    while (i < g_i)
    {
        DWORD time = g_Log[i++];
        DWORD type = g_Log[i++];

        if (type == 0)
        {
            D3DSWAPDATA* pData = (D3DSWAPDATA*) &g_Log[i];
            i += sizeof(*pData)/4;

            sprintf(
                charBuf,
                "Swap -- Swap: %li  VBlank: %li  Missed: %li  Until: %li  Between: %li  Time: %lx\n",
                pData->Swap, pData->SwapVBlank, pData->MissedVBlanks, pData->TimeUntilSwapVBlank, 
                pData->TimeBetweenSwapVBlanks, time + pData->TimeUntilSwapVBlank);
        }
        else
        {
            D3DVBLANKDATA* pData = (D3DVBLANKDATA*) &g_Log[i];
            i += sizeof(*pData)/4;

            sprintf(
                charBuf,
                "VBlank - VBlank: %li  Swap: %li  Flags: %lx  Time: %lx\n",
                 pData->VBlank, pData->Swap, pData->Flags, time);
        }

        OutputDebugStringA(charBuf);
    }
}

//------------------------------------------------------------------------------
BOOL InitD3D(HWND hWnd)
{
    D3DPRESENT_PARAMETERS d3dpp;
    DWORD startTime;
    DWORD initializationTime;
    IDirect3D8 *pD3D;
    CHAR stringBuffer[200];
     
    startTime = timeGetTime();

    // Create D3D 8.
    pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    if (pD3D == NULL)
        return FALSE;

    // Set the screen mode.
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth                 = 640;
    d3dpp.BackBufferHeight                = 480;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 2;
    d3dpp.Windowed                        = FALSE;   // Must be FALSE for Xbox.
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                   = hWnd;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_TWO;

    // Create the device.

    if (IDirect3D8_CreateDevice
    (
        pD3D,
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        hWnd,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        &pDev
    ) != S_OK)
    {
        return FALSE;
    }

    // Now we no longer need the D3D interface so lets free it.
    IDirect3D8_Release(pD3D);

    // Clear the frame buffer, Zbuffer.
    // CheckHR( IDirect3DDevice8_Clear(pDev, 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0X00ff0000, 1.0, 0) );
    // CheckHR( IDirect3DDevice8_Present(pDev, NULL, NULL, NULL, NULL) );

    IDirect3DDevice8_BlockUntilIdle(pDev);

    initializationTime = timeGetTime() - startTime;

    sprintf(stringBuffer, "TriC: Total D3D initialization time: %lims\n", initializationTime);

    OutputDebugStringA(stringBuffer);

    return TRUE;
}

//------------------------------------------------------------------------------
#define FADE_LENGTH 1000

void SetRamp(int coefficient)
{
    int i, value;
    D3DGAMMARAMP ramp;

    for (i = 0; i < 256; i++) {
        value = i * coefficient / FADE_LENGTH;
        ramp.red[i] = (BYTE)value;
        ramp.green[i] = (BYTE)value;
        ramp.blue[i] = (BYTE)value;
    }

    IDirect3DDevice8_SetGammaRamp(pDev, D3DSGR_NO_CALIBRATION | D3DSGR_IMMEDIATE, &ramp);
}

//------------------------------------------------------------------------------
void Fade()
{
    static int startTime;
    static BOOL fFadeIn = FALSE, fStart = FALSE, fWait = FALSE;
    int delta;

    if (!fStart) {
        startTime = GetTickCount();
        fStart = TRUE;
    }

    delta = GetTickCount() - startTime;

    if (fWait) {

        if (delta >= FADE_LENGTH) {
            fStart = FALSE;
            fWait = FALSE;
        }

    } else if (fFadeIn) {

        if (delta >= FADE_LENGTH) {
            SetRamp(FADE_LENGTH);
            fFadeIn = FALSE;
            fStart = FALSE;
            fWait = TRUE;
        } else {
            SetRamp(delta);
        }

    } else {

        if (delta >= FADE_LENGTH) {
            SetRamp(0);
            fFadeIn = TRUE;
            fStart = FALSE;
            fWait = TRUE;
        } else {
            SetRamp(FADE_LENGTH - delta);
        }
    }
}

//------------------------------------------------------------------------------
void DrawVerticesUP()
{
    static int iteration;

    DWORD count = 3;
    DWORD stride = sizeof(Verts[0]);

    if (iteration++ & 1)
    {
        CheckHR( IDirect3DDevice8_DrawVerticesUP(pDev, 
                                                 D3DPT_TRIANGLELIST,
                                                 count,                // VertexCount
                                                 Verts,                // pVertexStreamZeroData
                                                 stride) );            // VertexZeroStreamStride
    }
    else
    {
        DWORD* pPush;
        DWORD dwords = stride * count;

        // The "+ 5" is to reserve enough overhead for the encoding parameters.
        // It can safely be more, but not less.

        CheckHR( IDirect3DDevice8_BeginPush(pDev, dwords + 5, &pPush) );

        pPush[0] = D3DPUSH_ENCODE(D3DPUSH_SET_BEGIN_END, 1);
        pPush[1] = D3DPT_TRIANGLELIST;

        // NOTE: A maximum of 2047 dwords can be specified to D3DPUSH_ENCODE.
        //       If there is more than 2047 dwords of vertex data, simply split
        //       the data into multiple D3DPUSH_ENCODE(D3DPUSH_INLINE_ARRAY) 
        //       sections.

        pPush[2] = D3DPUSH_ENCODE(D3DPUSH_NOINCREMENT_FLAG | D3DPUSH_INLINE_ARRAY, dwords);
        pPush += 3;

        memcpy(pPush, Verts, 4*dwords);
        pPush += dwords;

        pPush[0] = D3DPUSH_ENCODE(D3DPUSH_SET_BEGIN_END, 1);
        pPush[1] = 0;
        pPush += 2;

        CheckHR( IDirect3DDevice8_EndPush(pDev, pPush) );
    }
}

//------------------------------------------------------------------------------
void Paint()
{
    static DWORD count;

    count++;
    if (count == 1)
    {
        IDirect3DDevice8_SetVerticalBlankCallback(pDev, VBlankCallback);
        IDirect3DDevice8_SetSwapCallback(pDev, SwapCallback);
    }

    if (count == 15)
        Sleep(160);

    if (count == 20)
    {
        IDirect3DDevice8_BlockUntilIdle(pDev);
        IDirect3DDevice8_SetVerticalBlankCallback(pDev, NULL);
        IDirect3DDevice8_SetSwapCallback(pDev, NULL);
        PrintLog();
    }

    CheckHR( IDirect3DDevice8_Clear(pDev, 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0X00404040, 1.0, 0) );

    CheckHR( IDirect3DDevice8_SetVertexShader(pDev, dwFVF) );

    CheckHR( IDirect3DDevice8_SetRenderState(pDev, D3DRS_CULLMODE, D3DCULL_NONE) );

    DrawVerticesUP();

    Fade();

    CheckHR( IDirect3DDevice8_Present(pDev, NULL, NULL, NULL, NULL) );
}

#if !defined(XBOX)

//------------------------------------------------------------------------------
LRESULT WINAPI MessageHandler
(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
//--------------------------------------
{
    if (Msg == WM_DESTROY)
        PostQuitMessage(0);

    return DefWindowProc(hWnd, Msg, wParam, lParam);
}

//------------------------------------------------------------------------------
int APIENTRY WinMain
(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpCmdLine,
    int         nCmdShow
)
//--------------------------------------
{
    MSG msg;
    HWND hwnd;

    WNDCLASSEX classex;
    ZeroMemory( &classex, sizeof(classex) );

    classex.cbSize          = sizeof(WNDCLASSEX);
    classex.style           = CS_CLASSDC;
    classex.lpfnWndProc     = MessageHandler;
    classex.hInstance       = hInstance;
    classex.lpszClassName   = L"XBOX";
    RegisterClassEx(&classex);

    hwnd = CreateWindowEx(WS_EX_TOPMOST, L"XBOX", L"XBOX Basic Shell",
                          WS_VISIBLE|WS_POPUP,
                          CW_USEDEFAULT,CW_USEDEFAULT, 0, 0,
                          NULL, NULL, hInstance, NULL);

    if (!InitD3D(hwnd))
    {
        return EXIT_FAILURE;
    }

    ShowCursor(FALSE);

    while (!bQuit)
    {
        while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
        {
            if (!GetMessage(&msg, NULL, 0, 0))
            {
                bQuit = TRUE;
            }

            TranslateMessage(&msg);
            DispatchMessage(&msg);

            Paint();
        }
    }

    return EXIT_SUCCESS;
}

#else

//-----------------------------------------------------------------------------

void __cdecl main()
{
//    _asm int 3;

    BOOL Toggle = FALSE;
    DWORD Time = GetTickCount();
    D3DPRESENT_PARAMETERS d3dpp;
    IDirect3DSurface8 *pSurface;

    if (!InitD3D(NULL))
    {
        return;
    }

    D3DDevice_GetPersistedSurface(&pSurface);

    while (TRUE)
    {
        Paint();
    
        if (GetTickCount() - Time > 2000)
        {
            // Set the screen mode.
            ZeroMemory(&d3dpp, sizeof(d3dpp));

            d3dpp.BackBufferWidth                 = 640;
            d3dpp.BackBufferHeight                = 480;
            d3dpp.BackBufferFormat                = Toggle ? D3DFMT_X8R8G8B8 : D3DFMT_R5G6B5;
            d3dpp.BackBufferCount                 = 1;
            d3dpp.Windowed                        = FALSE;   // Must be FALSE for Xbox.
            d3dpp.EnableAutoDepthStencil          = TRUE;
            d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
            d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
            d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

            Toggle = !Toggle;
            Time = GetTickCount();

            D3DDevice_PersistDisplay();
            D3DDevice_Reset(&d3dpp);
        }
    }
}

#endif // defined(XBOX)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\tric\sources.inc ===
TARGETNAME=TriC
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    main.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\tric\sdkcommon.h ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    SDKCommon.h

Abstract:

    Common header files and macros for the Xbox SDK

Revision History:

--*/

#if !defined(SDK_HEADER_SDKCOMMON_H)
#define SDK_HEADER_SDKCOMMON_H

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#if defined(__cplusplus)
extern "C" {
#endif // __cplusplus


#ifndef STRICT
#define STRICT 1
#endif
#undef D3D_OVERLOADS

// Windows headers

#ifdef XBOX
#include <xtl.h>
#else
#include "Windows.h"
#include "D3D8.h"
#endif

#pragma warning (disable:4850)

// __$ReturnUdt is the address of the destination when returning a structure
// It is Microsoft specific so will need to be adjusted to work with other
// compilers. The best way is to declare a local of the correct type and
// then return in.
#define that_ptr __$ReturnUdt

#if defined(__cplusplus)
}
#endif // __cplusplus

#endif //#ifndef SDK_HEADER_RENDERSURFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\tricpp\main.cpp ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Complete DX8 application to draw a screen space triangle.

Revision History:

    Derived from a DX8 sample.
--*/

#include <SDKCommon.h>
#include <xgraphics.h>
#include <stdio.h>

extern "C"
{
    extern BOOL D3D__Parser;
    extern BOOL D3D__SingleStepPusher;
}

IDirect3DDevice8*          pDev  = NULL;
IDirect3DVertexBuffer8*    pVertsVB = NULL;
IDirect3DTexture8*         pTexture = NULL;
DWORD                      VertsShader;

#define CheckHR(x) { HRESULT _hr = (x); if (FAILED(_hr)) { _asm { int 3 } } }

//------------------------------------------------------------------------------
// Geometry declarations

DWORD VertsShaderDeclaration[] =
{
    D3DVSD_STREAM(0),
    D3DVSD_REG(D3DVSDE_POSITION, D3DVSDT_FLOAT4), 
    D3DVSD_REG(D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2),
    D3DVSD_END()
};

static struct TheVerts { float x,y,z,w,tu,tv; } Verts[] =
{
    {320.0f,   0.0f, 0.5f, 1.0f,  0.5f, 0.0f},
    {527.0f, 360.0f, 0.5f, 1.0f,  1.0f, 1.0f},
    {113.0f, 360.0f, 0.5f, 1.0f,  0.0f, 1.0f},
};

//------------------------------------------------------------------------------
bool InitD3D
(
    HWND hWnd
)
//--------------------------------------
{
    static int doneOnce; 
    if (!doneOnce)       
    {                    
        { ; }  
        doneOnce=1;      
    }                    

#if DBG
    D3D__Parser = TRUE;
#endif

    // Create D3D 8.
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    if (pD3D == NULL)
        return false;

    // Set the screen mode.
    D3DPRESENT_PARAMETERS d3dpp;
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount           = 1;
    d3dpp.Windowed                  = false;   // Must be false for Xbox.
    d3dpp.EnableAutoDepthStencil    = true;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz= 60;
    d3dpp.hDeviceWindow             = hWnd;
    d3dpp.MultiSampleType           = D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX;

    // Create the device.
    if (pD3D->CreateDevice
    (
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        hWnd,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        &pDev
    ) != S_OK)
    {
        return false;
    }

    // Now we no longer need the D3D interface so lets free it.
    pD3D->Release();

    return true;
}

//------------------------------------------------------------------------------
bool InitVB
(
)
//--------------------------------------
{
    void* pVerts;

    CheckHR( pDev->CreateVertexBuffer( sizeof(Verts), 0, 0, 0, &pVertsVB ) );

    pVertsVB->Lock( 0, sizeof(Verts), (BYTE **)(&pVerts), 0 );
    memcpy( (void*)pVerts, (void*)Verts, sizeof(Verts) );
    pVertsVB->Unlock();

    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;

    if ( pDev->CreateTexture( 256, 256, 1, 0, D3DFMT_P8, D3DPOOL_MANAGED, &pTexture ) != S_OK )
        return false;

    if ( pTexture->GetLevelDesc( 0, &desc ) != S_OK )
        return false;

    if ( pTexture->LockRect ( 0, &lockRect, NULL, 0 ) != S_OK)
        return false;

    PVOID pBits = LocalAlloc(0, 256 * 256 * 1);

    // Generate a set of vertical lines of varying color into a buffer.
    BYTE *pb = (BYTE *)pBits;
    DWORD y;
    
    for (y = 0; y < 256; y++)
    {
        for (DWORD x = 0; x < 256; x++)
        {
            *pb = (BYTE) x;

            pb++;
        }
    }

    // Now draw an 'X' using index 0:
    pb = (BYTE *)pBits;
    for (y = 0; y < 256; y++)
    {
        *pb = 0;

        pb += 257;
    }

    pb = (BYTE *)pBits + 255;
    for (y = 0; y < 256; y++)
    {
        *pb = 0;

        pb += 255;
    }


    XGSwizzleRect(pBits,
                  0,
                  NULL,
                  lockRect.pBits,
                  256,
                  256,
                  NULL,
                  1);

    LocalFree(pBits);

    // Unlock the map so it can be used
    pTexture->UnlockRect(0);

    pDev->SetTexture(0, pTexture);

    // Create and select a fake test palette
    IDirect3DPalette8* pFakePalette;
    if ( pDev->CreatePalette(D3DPALETTE_32, &pFakePalette) != S_OK )
        return false;

    D3DCOLOR* pColors;
    if ( pFakePalette->Lock(&pColors, 0) != S_OK )
        return false;

    memset(pColors, 0, 32 * sizeof(D3DCOLOR));

    if ( pFakePalette->Unlock() != S_OK )
        return false;

    if ( pDev->SetPalette(0, pFakePalette) != S_OK )
        return false;

    // Now create and select a real palette
    IDirect3DPalette8* pPalette;
    if ( pDev->CreatePalette(D3DPALETTE_256, &pPalette) != S_OK )
        return false;

    if ( pPalette->Lock(&pColors, 0) != S_OK )
        return false;

    pColors[0] = 0xffff0000;                    // Index 0 is red
    pColors[255] = 0xff00ff00;                  // Index 255 is green

    for (DWORD i = 1; i < 255; i++)
    {
        pColors[i] = 0xff000000 | i;            // Rest is a blue wash
    }

    if ( pPalette->Unlock() != S_OK )
        return false;

    if ( pPalette->GetSize() != D3DPALETTE_256 )
        return false;

    if ( pDev->SetPalette(0, pPalette) != S_OK )
        return false;

    IDirect3DPalette8* pGetPalette;
    if ( pDev->GetPalette(0, &pGetPalette) != S_OK )
        return false;

    if ( pGetPalette != pPalette )
        return false;

    pGetPalette->Release();

    if ( pFakePalette->Release() != 0 )
        return false;

    // Set the texture stage states appropriately
    pDev->SetTextureStageState(0, D3DTSS_COLOROP,  D3DTOP_SELECTARG1);
    pDev->SetTextureStageState(0, D3DTSS_MINFILTER,D3DTEXF_LINEAR);
    pDev->SetTextureStageState(0, D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
    pDev->SetRenderState(D3DRS_ZENABLE, FALSE);
    pDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

    // Create the vertex shaders
    CheckHR( pDev->CreateVertexShader(VertsShaderDeclaration, NULL, &VertsShader, 0) );

    // Test some extra junk.

    CheckHR( pDev->Nop() );
    if (pDev->GetVertexBlendModelView(0, NULL, NULL) != S_FALSE)
        _asm int 3;

    D3DMATRIX mat[4];

    pDev->SetRenderState(D3DRS_VERTEXBLEND, TRUE);
    CheckHR( pDev->SetVertexBlendModelView(1, mat, mat, mat) );
    CheckHR( pDev->SetVertexBlendModelView(4, mat, mat, mat) );
    if (pDev->GetVertexBlendModelView(4, mat, mat) != S_OK)
        _asm int 3;

    pDev->SetRenderState(D3DRS_VERTEXBLEND, FALSE);
    CheckHR(pDev->SetVertexBlendModelView(0, NULL, NULL, NULL));

    return true;
}

//------------------------------------------------------------------------------
void Paint
(
)
//--------------------------------------
{

    // Exercise the synchornization code.
    TheVerts* pVerts;
    D3DPushBuffer* pPushBuffer;
    DWORD i;
    DWORD offset;
    
    pVertsVB->Lock( 0, sizeof(Verts), (BYTE **)(&pVerts), 0 );

    // Transform the verticies to make the triangle spin so we can verify that
    // this actually works over a period of time.
    //
    static DWORD Time = GetTickCount();
    DWORD CurrentTime = GetTickCount();

    // 10 seconds per rotation
    float spin = 2 * 3.14159f * (float)(CurrentTime - Time) / 10000.0f;

    for (i = 0; i < 3; i++)
    {

        float x = Verts[i].x;
        float y = Verts[i].y;

        x = x - 320.0f;
        y = y - 240.0f;

        pVerts[i].x = x * (float)cos(spin) - y * (float)sin(spin);
        pVerts[i].y = x * (float)sin(spin) + y * (float)cos(spin);

        pVerts[i].x += 320.0f;
        pVerts[i].y += 240.0f;
    }

    pVertsVB->Unlock();

    pDev->Clear(0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0X00404040, 1.0, 0);

    D3DSTREAM_INPUT streamInput = { pVertsVB, sizeof(Verts[0]), 0 };
    pDev->SetStreamSource(0, pVertsVB, sizeof(Verts[0]));
    pDev->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_TEX1);
    pDev->SetVertexShaderInput(VertsShader, 1, &streamInput);

    pDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

    CheckHR(pDev->CreatePushBuffer(4 * 4096, FALSE, &pPushBuffer));

    // Record our rotating triangle:
    pDev->BeginPushBuffer(pPushBuffer);
    pDev->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
    pDev->EndPushBuffer();
    pDev->RunPushBuffer(pPushBuffer, NULL);

    // Flip the buffers.
    pDev->Present(NULL, NULL, NULL, NULL);

    pPushBuffer->Release();
}

void __cdecl main()
{
    _asm nop;
    _asm nop;

#if DBG
    D3D__SingleStepPusher = TRUE;
#endif

    InitD3D(NULL);
    InitVB();

    D3DVIEWPORT8 D3DViewport;

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = 640;
    D3DViewport.Height = 480;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    D3DDevice_SetViewport( &D3DViewport );

    while (TRUE)
    {
        Paint();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\trivss\sdkcommon.h ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    SDKCommon.h

Abstract:

    Common header files and macros for the Xbox SDK

Revision History:

--*/

#if !defined(SDK_HEADER_SDKCOMMON_H)
#define SDK_HEADER_SDKCOMMON_H

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef STRICT
#define STRICT 1
#endif
#undef D3D_OVERLOADS

// Windows headers

#ifdef XBOX
#include <xtl.h>
#else
#include "Windows.h"
#include "D3D8.h"
#endif

#if defined(__cplusplus)
extern "C" {
#endif // __cplusplus

#pragma warning (disable:4850)

// __$ReturnUdt is the address of the destination when returning a structure
// It is Microsoft specific so will need to be adjusted to work with other
// compilers. The best way is to declare a local of the correct type and
// then return in.
#define that_ptr __$ReturnUdt

#if defined(__cplusplus)
}
#endif // __cplusplus

#endif //#ifndef SDK_HEADER_RENDERSURFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\tricpp\sources.inc ===
TARGETNAME=TriCpp
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    main.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\trivs\main.cpp ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Complete DX8 application to draw a screen space triangle using a vertex shader.

Revision History:

    Derived from a DX8 sample.
--*/

#include <SDKCommon.h>
#include <stdio.h>

#include "shader.h"

#define CheckHR(x) { HRESULT _hr = (x); if (FAILED(_hr)) { _asm { int 3 } } }

IDirect3DDevice8*           g_pDev  = NULL;
DWORD                       g_ShaderHandle;
IDirect3DPushBuffer8*       g_pPushBufer;
IDirect3DFixup8*            g_pSizer;
IDirect3DFixup8*            g_pFixup[2];
DWORD                       g_iFixup;
DWORD                       g_PushBufferSize;
DWORD                       g_ConstantOffset;

//------------------------------------------------------------------------------
// Define our triangle.
static struct { float x,y,z; DWORD color; } Verts[] =
{
    {-0.666f,  -1.0f, 0.0f, 0xffff0000, },
    { 0.0f,     1.0f, 0.0f, 0xff00ff00, },
    { 0.666f,  -1.0f, 0.0f, 0xff0000ff, },
};

DWORD dwShaderVertexDecl[] =
{
    D3DVSD_STREAM( 0 ),
    D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position
    D3DVSD_REG( 1, D3DVSDT_D3DCOLOR ), // Diffuse color
    D3DVSD_END()
};

//------------------------------------------------------------------------------
void RecordPushBuffer()
{
    D3DMATRIX mat;

    CheckHR( g_pDev->BeginPushBuffer(g_pPushBufer) );

    // Clear the frame buffer, Zbuffer.
    CheckHR( g_pDev->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
        0X00404040, 1.0, 0) );

    // Draw the vertex streamsetup in stream 0.
    CheckHR( g_pDev->SetVertexShader(g_ShaderHandle) );

    // Note that we initially record a garbage matrix into the shader-constants,
    // which is okay because we'll always fix it up before playback.
    CheckHR( g_pDev->GetPushBufferOffset( &g_ConstantOffset ) );
    CheckHR( g_pDev->SetVertexShaderConstant(0, &mat, 4) );

    CheckHR( g_pDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE) );
    CheckHR( g_pDev->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 1, Verts, sizeof(Verts[0])) );

    CheckHR( g_pDev->EndPushBuffer() );
}

//------------------------------------------------------------------------------
BOOL InitD3D()
{
    D3DPRESENT_PARAMETERS d3dpp;

    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    if (pD3D == NULL)
        return FALSE;

    // Set the screen mode.
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount           = 2;
    d3dpp.Windowed                  = FALSE;   // Must be FALSE for Xbox.
    d3dpp.EnableAutoDepthStencil    = TRUE;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz= 60;
    d3dpp.MultiSampleType           = D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX;

    // Create the device.
    CheckHR( pD3D->CreateDevice(
                        D3DADAPTER_DEFAULT,
                        D3DDEVTYPE_HAL,
                        NULL,
                        D3DCREATE_HARDWARE_VERTEXPROCESSING,
                        &d3dpp,
                        &g_pDev) );

    // Now we no longer need the D3D interface so let's free it.
    pD3D->Release();

    // Create vertex shader.
    CheckHR( g_pDev->CreateVertexShader(dwShaderVertexDecl, 
                                      dwShaderVertexShader,
                                      &g_ShaderHandle, 
                                      0) );

    // Create a push-buffer, two fix-up buffers that we'll ping-pong between,
    // and a fix-up buffer that we'll use just for determining our fix-up
    // size.
    CheckHR( g_pDev->CreatePushBuffer(16 * 4096, FALSE, &g_pPushBufer) );
    CheckHR( g_pDev->CreateFixup(1024, &g_pFixup[0]) );
    CheckHR( g_pDev->CreateFixup(1024, &g_pFixup[1]) );
    CheckHR( g_pDev->CreateFixup(0, &g_pSizer) );

    // Now record the push-buffer.
    RecordPushBuffer();

    return TRUE;
}

//------------------------------------------------------------------------------
unsigned int GetSimTime()
{
    static unsigned int startTime;
    if ( ! startTime ) 
    {
        startTime = timeGetTime();
    }
    return timeGetTime() - startTime;
}

//------------------------------------------------------------------------------
void UpdateShaderConstants(D3DMATRIX* pMat)
{
    // Rotate around the Y axis
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixRotationY( &matWorld, GetSimTime()/600.0f );

    // Set up our view matrix. A view matrix can be defined given an eye point,
    // a point to lookat, and a direction for which way is up.
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 0.0f, -3.0f ), 
                                  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ), 
                                  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );

    // For the projection matrix, we set up a perspective transform (which
    // transforms geometry from 3D view space to 2D viewport space, with
    // a perspective divide making objects smaller in the distance). To build
    // a perpsective transform, we need the field of view (1/4 pi is common),
    // the aspect ratio, and the near and far clipping planes (which define at
    // what distances geometry should be no longer be rendered).
    D3DXMATRIX matProj;
    float aspectRatio = 480.f / 640.f;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, aspectRatio, 1.0f, 800.0f );

    // Calculate concatenated World x ( View x Projection) matrix.
    // We transpose the matrix at the end because that's how matrix math
    // works in vertex shaders. (Because the vertex shader DP4 operator works on
    // rows, not on columns.)
    D3DXMATRIX mat;
    D3DXMatrixMultiply( &mat, &matView, &matProj );
    D3DXMatrixMultiply( &mat, &matWorld, &mat );
    D3DXMatrixTranspose( &mat, &mat );

    *pMat = mat;
}

//------------------------------------------------------------------------------
HRESULT ApplyFixups(D3DPushBuffer *pPushBuffer, D3DFixup *pFixup, D3DMATRIX* pMat)
{
    CheckHR( g_pPushBufer->BeginFixup( pFixup, 0 ) );
    CheckHR( g_pPushBufer->SetVertexShaderConstant( g_ConstantOffset, 0, pMat, 4 ) );
    return g_pPushBufer->EndFixup( );
}

//------------------------------------------------------------------------------
void Paint()
{
    D3DMATRIX mat;
    DWORD size;
    DWORD space;

    UpdateShaderConstants( &mat );

    // First, use an empty fix-up object to figure out the size of the
    // fix-ups.  Using an empty fix-up object is fast because it doesn't
    // actually copy anything, but still looks at the fix-up parameters
    // to calculate the correct size.
    //
    // Obviously, this never changes from frame-to-frame, so we could
    // cache this.
    ApplyFixups( g_pPushBufer, g_pSizer, &mat );
    CheckHR( g_pSizer->GetSize( &size ) );

    // Now figure out what real fix-up object we'd like to use, and if there's
    // space.
    D3DFixup* pFixup = g_pFixup[g_iFixup];
    CheckHR( pFixup->GetSpace( &space ) );

    if ( space < size )
    {
        // Darn, we overflowed the fix-up buffer that we wanted to use.
        // Ping-pong to the other buffer and use that one now.
        //
        // (If we tried to reset the same buffer we were just using, D3D
        // would have to sit and spin until the GPU is idle, since we just
        // used that buffer.)
        g_iFixup ^= 1;
        pFixup = g_pFixup[g_iFixup];

        CheckHR( pFixup->Reset() );
    }

    // Okay, do the fix-up for real.
    CheckHR( ApplyFixups( g_pPushBufer, pFixup, &mat ) );

    // Finally, actually run the push-buffer and then we're done.
    CheckHR( g_pDev->RunPushBuffer( g_pPushBufer, pFixup ) );
    CheckHR( g_pDev->Present( NULL, NULL, NULL, NULL ) );
}

//-----------------------------------------------------------------------------
void __cdecl main()
{
    InitD3D();

    while (TRUE)
    {
        Paint();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\trivss\shader.h ===
DWORD dwShaderVertexShader[] = {
	0x00072078,
	0x00000000, 0x00ec001b, 0x0836186c, 0x10708800,
	0x00000000, 0x00ec201b, 0x0836186c, 0x10704800,
	0x00000000, 0x00ec401b, 0x0836186c, 0x10702800,
	0x00000000, 0x00ec601b, 0x0836186c, 0x10701800,
	0x00000000, 0x004c821b, 0x0836186c, 0x1070f818,
	0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
	0x00000000, 0x0087601b, 0xc400286c, 0x3070e801
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\trivss\shaderDefs.h ===
// Copyright (c) 2000 Microsoft Corporation - Xbox SDK

// Common constants shared between C code and Vertex Shader

#define WVPMATRIX   0

#define COLORSCALE  4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\trivss\stateShader.h ===
DWORD dwStateShaderVertexStateShader[] = {
	0x00037378,
	0x00000000, 0x0020001b, 0x0836086c, 0x1070f320,
	0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
	0x00000000, 0x0087601b, 0xc400286c, 0x3070e801
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\trivs\shader.h ===
DWORD dwShaderVertexShader[] = {
	0x00072078,
	0x00000000, 0x00ec001b, 0x0836186c, 0x10708800,
	0x00000000, 0x00ec201b, 0x0836186c, 0x10704800,
	0x00000000, 0x00ec401b, 0x0836186c, 0x10702800,
	0x00000000, 0x00ec601b, 0x0836186c, 0x10701800,
	0x00000000, 0x0020021b, 0x0836086c, 0x1070f818,
	0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
	0x00000000, 0x0087601b, 0xc400286c, 0x3070e801
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\trivsw\sdkcommon.h ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    SDKCommon.h

Abstract:

    Common header files and macros for the Xbox SDK

Revision History:

--*/

#if !defined(SDK_HEADER_SDKCOMMON_H)
#define SDK_HEADER_SDKCOMMON_H

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifndef STRICT
#define STRICT 1
#endif
#undef D3D_OVERLOADS

// Windows headers

#ifdef XBOX
#include <xtl.h>
#else
#include "Windows.h"
#include "D3D8.h"
#endif

#if defined(__cplusplus)
extern "C" {
#endif // __cplusplus

#pragma warning (disable:4850)

// __$ReturnUdt is the address of the destination when returning a structure
// It is Microsoft specific so will need to be adjusted to work with other
// compilers. The best way is to declare a local of the correct type and
// then return in.
#define that_ptr __$ReturnUdt

#if defined(__cplusplus)
}
#endif // __cplusplus

#endif //#ifndef SDK_HEADER_RENDERSURFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\trivs\sources.inc ===
TARGETNAME=TriVS
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    main.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\trivss\main.cpp ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Complete DX8 application to draw a triangle using a read/write vertex shader.

Revision History:

    Derived from a DX8 sample.
--*/

// Uncomment to disable using a vertex state shader
// in this example.

// #define DISABLE_STATE_SHADER

#include <SDKCommon.h>
#include "shaderDefs.h" 
#include "shader.h"
#ifndef DISABLE_STATE_SHADER
#include "stateShader.h"
#endif

#define CheckHR(x) { HRESULT _hr = (x); if (FAILED(_hr)) { _asm { int 3 } } }




IDirect3DDevice8*          pDev  = NULL;

//------------------------------------------------------------------------------
// Define our triangle.
static struct { float x,y,z; DWORD color; } Verts[] =
{
    {-0.666f,  -1.0f, 0.0f, 0xffff0000, },
    {-1.0f,  1.0f, 0.0f, 0xff00ff00, },
    {0.666f,  -1.0f, 0.0f, 0xff0000ff, },
};

DWORD dwShaderVertexDecl[] =
{
    D3DVSD_STREAM( 0 ),
    D3DVSD_END()
};

DWORD dwVertexShaderHandle;
DWORD dwVertexShaderAddress;

#ifndef DISABLE_STATE_SHADER
DWORD dwVertexStateShaderHandle;
DWORD dwVertexStateShaderAddress;
#endif

//------------------------------------------------------------------------------
BOOL InitD3D
(
    HWND hWnd
)
//--------------------------------------
{
    D3DPRESENT_PARAMETERS d3dpp;

    // Create D3D 8.
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    if (pD3D == NULL)
        return FALSE;

    // Set the screen mode.
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount           = 1;
    d3dpp.Windowed                  = FALSE;   // Must be FALSE for Xbox.
    d3dpp.EnableAutoDepthStencil    = TRUE;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
    d3dpp.MultiSampleType           = D3DMULTISAMPLE_4_SAMPLES
                                    | D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5;


    // Create the device.

    if (IDirect3D8_CreateDevice
    (
        pD3D,
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        hWnd,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        &pDev
    ) != S_OK)
    {
        return FALSE;
    }

    // Now we no longer need the D3D interface so lets free it.
    IDirect3D8_Release(pD3D);

    // Create vertex shader

    if ( FAILED( pDev->CreateVertexShader(dwShaderVertexDecl,
        dwShaderVertexShader,
        &dwVertexShaderHandle, 0 )) )
    {
        return FALSE;
    }

#ifndef DISABLE_STATE_SHADER
    if ( FAILED( pDev->CreateVertexShader(NULL,
        dwStateShaderVertexStateShader,
        &dwVertexStateShaderHandle, 0 )) )
    {
        return FALSE;
    }
#endif

    // Load both shaders into vertex shader program memory

    DWORD ip = 0;
    UINT length;
    dwVertexShaderAddress = ip;
    if ( FAILED( pDev->LoadVertexShader(dwVertexShaderHandle, ip))) {
        return FALSE;
    }
    if ( FAILED( pDev->GetVertexShaderSize(dwVertexShaderHandle, &length))) {
        return FALSE;
    }

    ip += length;

#ifndef DISABLE_STATE_SHADER
    dwVertexStateShaderAddress = ip;
    if ( FAILED( pDev->LoadVertexShader(dwVertexStateShaderHandle, ip))) {
        return FALSE;
    }
    if ( FAILED( pDev->GetVertexShaderSize(dwVertexStateShaderHandle, &length))) {
        return FALSE;
    }

    ip += length;
#endif

    return TRUE;
}

unsigned int GetSimTime(){
	static unsigned int startTime;
	if ( ! startTime ) {
		startTime = timeGetTime();
	}
	return timeGetTime() - startTime;
}

double sawtooth(double s){
    double result = s - floor(s);
    if ( result > 0.5 ) result = 1.0 - result;
    return result;
}

void UpdateShaderConstants()
{

    float colorScale[4];
    {
        colorScale[4] = 1.0f;
        float t = (float) GetSimTime() / 1000.f;
        float scale = (float) sawtooth(t) + 0.5f; // Goes overbright
        colorScale[0] = scale;
        colorScale[1] = scale;
        colorScale[2] = scale;
    }

	// Rotate around the Y axis
	D3DXMATRIX matWorld;
	D3DXMatrixIdentity( &matWorld );
	D3DXMatrixRotationY( &matWorld, GetSimTime()/600.0f );
	// Set up our view matrix. A view matrix can be defined given an eye point,
	// a point to lookat, and a direction for which way is up.
	D3DXMATRIX matView;
	D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 0.0f, -3.0f ), 
								  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ), 
								  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );

	// For the projection matrix, we set up a perspective transform (which
	// transforms geometry from 3D view space to 2D viewport space, with
	// a perspective divide making objects smaller in the distance). To build
	// a perpsective transform, we need the field of view (1/4 pi is common),
	// the aspect ratio, and the near and far clipping planes (which define at
	// what distances geometry should be no longer be rendered).
	D3DXMATRIX matProj;
    float aspectRatio = 480.f / 640.f;
	D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, aspectRatio, 1.0f, 800.0f );

	// Calculate concatenated World x ( View x Projection) matrix.
	// We transpose the matrix at the end because that's how matrix math
	// works in vertex shaders. (Because the vertex shader DP4 operator works on
	// rows, not on columns.)

    D3DXMATRIX mat;
    D3DXMatrixMultiply( &mat, &matView, &matProj );
    D3DXMatrixMultiply( &mat, &matWorld, &mat );
    D3DXMatrixTranspose( &mat, &mat );
 	
    CheckHR( pDev->SetVertexShaderConstant(WVPMATRIX, &mat, 4) );

#ifdef DISABLE_STATE_SHADER
    CheckHR( pDev->SetVertexShaderConstant(COLORSCALE, colorScale, 1) );
#else

    // Use state shader to load the colorScale

    CheckHR( pDev->SelectVertexShader(dwVertexStateShaderHandle, dwVertexShaderAddress) ); 
    CheckHR( pDev->RunVertexStateShader(dwVertexStateShaderAddress, colorScale) );

#endif
}

//------------------------------------------------------------------------------
void Paint
(
)
//--------------------------------------
{
    // Clear the frame buffer, Zbuffer.
    CheckHR( pDev->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
        0X00404040, 1.0, 0) );

    // Draw the vertex streamsetup in stream 0.
    CheckHR( pDev->BeginScene() );
    UpdateShaderConstants();

    CheckHR( pDev->SelectVertexShader(dwVertexShaderHandle, dwVertexShaderAddress) ); 
    CheckHR( pDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE) );

    // Test out 'Begin' and 'End' and persistent attributes:

    CheckHR( pDev->Begin(D3DPT_TRIANGLELIST) );

    // Lower-left corner is red:

    CheckHR( pDev->SetVertexData4ub(1, 0xff, 0, 0, 0xff) );
    CheckHR( pDev->SetVertexData4f(-1, -0.666f, -1.0f, 0.0f, 1.0f) );

    // Top corner is green:

    CheckHR( pDev->SetVertexData4ub(1, 0, 0xff, 0, 0xff) );
    CheckHR( pDev->SetVertexData4f(-1, -1.0f, 1.0f, 0.0f, 1.0f) );

    // Lower-right corner is blue:

    CheckHR( pDev->SetVertexData4ub(1, 0, 0, 0xff, 0xff) );
    CheckHR( pDev->SetVertexData4f(-1, 0.666f, -1.0f, 0.0f, 1.0f) );

    CheckHR( pDev->End() );
                                              
    CheckHR( pDev->EndScene() );

    // Flip the buffers.

    pDev->Present(NULL, NULL, NULL, NULL);
}


//-----------------------------------------------------------------------------

void __cdecl main()
{
    if (!InitD3D(NULL))
    {
        return;
    }

    while (TRUE)
    {
        Paint();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\trivsw\main.cpp ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Complete DX8 application to draw a triangle using a read/write vertex shader.

Revision History:

    Derived from a DX8 sample.
--*/

#include <SDKCommon.h>
#include "shaderDefs.h" 
#include "shader.h"

#define CheckHR(x) { HRESULT _hr = (x); if (FAILED(_hr)) { _asm { int 3 } } }

BOOL                       bQuit   = FALSE;
IDirect3DDevice8*          pDev  = NULL;

//------------------------------------------------------------------------------
// Define our triangle.
static struct { float x,y,z; } Verts[] =
{
    {-0.666f,  -1.0f, 0.0f },
    {0.0f,  1.0f, 0.0f },
    {0.666f,  -1.0f, 0.0f },
};

DWORD dwShaderVertexDecl[] =
{
    D3DVSD_STREAM( 0 ),
    D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position
    D3DVSD_END()
};

DWORD dwVertexShaderHandle;

//------------------------------------------------------------------------------
BOOL InitD3D
(
    HWND hWnd
)
//--------------------------------------
{
    D3DPRESENT_PARAMETERS d3dpp;

    // Create D3D 8.
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    if (pD3D == NULL)
        return FALSE;

    // Set the screen mode.
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = 640;
    d3dpp.BackBufferHeight          = 480;
    d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount           = 1;
    d3dpp.Windowed                  = FALSE;   // Must be FALSE for Xbox.
    d3dpp.EnableAutoDepthStencil    = TRUE;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
    d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz= 60;
    d3dpp.hDeviceWindow             = hWnd;

    // Create the device.

    if (IDirect3D8_CreateDevice
    (
        pD3D,
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        hWnd,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        &pDev
    ) != S_OK)
    {
        return FALSE;
    }

    // Now we no longer need the D3D interface so lets free it.
    IDirect3D8_Release(pD3D);

    // Create vertex shader

    if ( FAILED( IDirect3DDevice8_CreateVertexShader( pDev,
        dwShaderVertexDecl, dwShaderReadWriteVertexShader,
        &dwVertexShaderHandle, 0 )) )
    {
        return FALSE;
    }

    // Set up the color constant registers
    static const float kColorConsts[]  = {
        0.0f, 0.0f, 0.0f, 1.0f, // base color
        0.0011f, 0.0017f, 0.0013f, 0.0f,  // increment
        1.0f, 1.0f, 1.0f, 1.0f  // All ones
    };

    CheckHR( pDev->SetVertexShaderConstant(COLOR, &kColorConsts, 3) );

    return TRUE;
}

unsigned int GetSimTime(){
	static unsigned int startTime;
	if ( ! startTime ) {
		startTime = timeGetTime();
	}
	return timeGetTime() - startTime;
}

void UpdateShaderConstants()
{
	// Rotate around the Y axis
	D3DXMATRIX matWorld;
	D3DXMatrixIdentity( &matWorld );
	D3DXMatrixRotationY( &matWorld, GetSimTime()/600.0f );
	// Set up our view matrix. A view matrix can be defined given an eye point,
	// a point to lookat, and a direction for which way is up.
	D3DXMATRIX matView;
	D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 0.0f, -3.0f ), 
								  &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ), 
								  &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );

	// For the projection matrix, we set up a perspective transform (which
	// transforms geometry from 3D view space to 2D viewport space, with
	// a perspective divide making objects smaller in the distance). To build
	// a perpsective transform, we need the field of view (1/4 pi is common),
	// the aspect ratio, and the near and far clipping planes (which define at
	// what distances geometry should be no longer be rendered).
	D3DXMATRIX matProj;
    float aspectRatio = 480.f / 640.f;
	D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, aspectRatio, 1.0f, 800.0f );

	// Calculate concatenated World x ( View x Projection) matrix.
	// We transpose the matrix at the end because that's how matrix math
	// works in vertex shaders. (Because the vertex shader DP4 operator works on
	// rows, not on columns.)

    D3DXMATRIX mat;
    D3DXMatrixMultiply( &mat, &matView, &matProj );
    D3DXMatrixMultiply( &mat, &matWorld, &mat );
    D3DXMatrixTranspose( &mat, &mat );
 	
    CheckHR( pDev->SetVertexShaderConstant(WPVMATRIX, &mat, 4) );
}

//------------------------------------------------------------------------------
void Paint
(
)
//--------------------------------------
{
    // Clear the frame buffer, Zbuffer.
    CheckHR( pDev->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
        0X00404040, 1.0, 0) );

    // Draw the vertex streamsetup in stream 0.
    CheckHR( pDev->BeginScene() );
    CheckHR( pDev->SetVertexShader(dwVertexShaderHandle) );

    UpdateShaderConstants();
 
    CheckHR( pDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE) );

    CheckHR( pDev->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 1, Verts, sizeof(Verts[0])) );
                                              
    CheckHR( pDev->EndScene() );

    // Flip the buffers.

    pDev->Present(NULL, NULL, NULL, NULL);
}


//-----------------------------------------------------------------------------

void __cdecl main()
{
    _asm int 3;

    if (!InitD3D(NULL))
    {
        return;
    }

    while (TRUE)
    {
        Paint();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\vshtimer\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_

// pack the structure as we're reading it from the disk
#pragma pack(1)

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const char* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const char* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const char*     str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\vshtimer\inifile.h ===
//-----------------------------------------------------------------------------
// FILE: INIFILE.H
//
// Desc: Quick and dirty INI file routines
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

// Routines supplied by the main application to return the values for a given
// string found in an ini file.
bool GetIniConst(const char *szStr, int cchStr, int *pval);
bool GetIniConstf(const char *szStr, int cchStr, float *pval);

//=========================================================================
// IniFile class
//=========================================================================
class CIniFile
{
public:
    CIniFile(LPCSTR szFileName) : m_szFile(NULL), m_ftFileReadTime(0), m_fverbose(false), m_recurselevel(0)
        { lstrcpyA(m_szFileName, szFileName); }
    ~CIniFile()
    {
        if(m_szFile)
        {
            free(m_szFile);
            m_szFile = NULL;
        }
    };

    // get int entry
    int GetIniInt(LPCSTR lpSectionName, LPCSTR lpKeyName, int nDefault);

    // get float entry
    float GetIniFloat(LPCSTR lpSectionName, LPCSTR lpKeyName, float nDefault);

    // check for entry existance
    bool IniEntryExists(LPCSTR lpSectionName, LPCSTR lpKeyName);

    // get ini string value. Up to caller to parse and check for end '\n' or ';'
    bool GetIniStrBuf(LPCSTR lpSectionName, LPCSTR lpKeyName,
        LPCSTR szDefault, char *buf, int buflen);

    // get ini string value. Up to caller to parse and check for end '\n' or ';'
    LPCSTR GetIniStr(LPCSTR lpSectionName, LPCSTR lpKeyName,
        LPCSTR szDefault, LPCSTR *ppszLineStart);

    // read/refresh an ini file
    bool ReadFile();

    // get name of ini file
    LPCSTR GetFileName()
        { return m_szFileName; }

    // has ini file timestamp changed?
    bool FileChanged()
        { return GetFileTime(m_szFileName) != m_ftFileReadTime; }

    bool m_fverbose;

private:
    enum { INIVAL_INT, INIVAL_FLOAT };
    struct INIVAL
    {
        int type;

        int val;
        float valf;

        void SetVal(int newval)
            { val = newval; valf = (float)newval; }
        void SetVal(float newval)
            { val = (int)newval; valf = newval; }
    };

    LPCSTR GetIniConstValue(const char *szStr, INIVAL *pinival);

    bool ParseIntVal(LPCSTR szLineStart, LPCSTR szLine, int *pval);
    bool ParseFloatVal(LPCSTR szLineStart, LPCSTR szLine, float *pval);

    char m_szFileName[MAX_PATH];
    char *m_szFile;
    UINT64 m_ftFileReadTime;

    UINT m_recurselevel;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\trivsw\shader.h ===
DWORD dwShaderReadWriteVertexShader[] = {
	0x000c7778,
	0x00000000, 0x00ec001b, 0x0836186c, 0x10708800,
	0x00000000, 0x00ec201b, 0x0836186c, 0x10704800,
	0x00000000, 0x00ec401b, 0x0836186c, 0x10702800,
	0x00000000, 0x00ec601b, 0x0836186c, 0x10701800,
	0x00000000, 0x002c801b, 0x0c36086c, 0x1f000ff8,
	0x00000000, 0x006ca01b, 0x0c36086c, 0x1e000ff8,
	0x00000000, 0x018cc01b, 0x0436186c, 0x1e100ff8,
	0x00000000, 0x0060001b, 0x04360c6c, 0x5e000ff8,
	0x00000000, 0x0020001b, 0x0436086c, 0x1070e320,
	0x00000000, 0x0020001b, 0x0436086c, 0x1070f818,
	0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
	0x00000000, 0x0087601b, 0xc400286c, 0x3070e801
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\vshtimer\utils.h ===
//-----------------------------------------------------------------------------
// FILE: UTILS.H
//
// Desc: utils header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#define ARRAYSIZE(_a)     (sizeof(_a) / sizeof((_a)[0]))

//=========================================================================
// Release helper function
//=========================================================================
template <class T> inline void RELEASE(T& punk)
{
    if(punk)
    {
        punk->Release();
        punk = NULL;
    }
}

//=========================================================================
// Class to help time things
//=========================================================================
class CTimer
{
public:
    // constructor
    CTimer()
    {
        QueryPerformanceFrequency((LARGE_INTEGER*)&ticksPerSecond);
        ticksPerSecond /= 1000;
    }

    ~CTimer() {};

    void Start()
        { frunning = true; QueryPerformanceCounter((LARGE_INTEGER *)&ticksstart); }

    void Stop()
        { frunning = false; QueryPerformanceCounter((LARGE_INTEGER *)&ticksend); }

    float getTime()
        {
            if(frunning)
                QueryPerformanceCounter((LARGE_INTEGER *)&ticksend);
            return ((ticksend - ticksstart) * 1.0f / ticksPerSecond);
        }

    bool frunning;
    _int64 ticksstart;
    _int64 ticksend;
    _int64 ticksPerSecond;
};

//=========================================================================
// Screen Text helper class
//=========================================================================
class CScrText
{
public:
    CScrText()
        { cls(); }

    ~CScrText() {}

    void cls()
    {
        m_iLine = 0;
        for(int i = 0; i < NUM_LINES; i++)
            m_rgText[i][0] = 0;
    }
    void _cdecl printf(LPCSTR lpFmt, ...);
    void drawtext(bool fDebugSquirty);

private:
    enum { LINE_WIDTH = 80, NUM_LINES = 40 };
    char m_rgText[NUM_LINES][LINE_WIDTH];
    int m_iLine;
};

// redefine these guys to make them shorter and remove the misleading D3DMULTISAMPLE_ part
#define D3DMS_NONE                                         D3DMULTISAMPLE_NONE
#define D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR                 D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR
#define D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX               D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX
#define D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR      D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR
#define D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR        D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR
#define D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR                 D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR
#define D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN               D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN
#define D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR                 D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR
#define D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN               D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN
#define D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN               D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN
#define D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN               D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN
#define D3DMS_PREFILTER_FORMAT_DEFAULT                     D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT
#define D3DMS_PREFILTER_FORMAT_X1R5G5B5                    D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5
#define D3DMS_PREFILTER_FORMAT_R5G6B5                      D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5
#define D3DMS_PREFILTER_FORMAT_X8R8G8B8                    D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8
#define D3DMS_PREFILTER_FORMAT_A8R8G8B8                    D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8

// utils.cpp
bool IsLinearFormat(DWORD Format);
DWORD BitsPerPixelOfD3DFORMAT(DWORD Format);
LPCSTR GetD3DCMPStr(D3DCMPFUNC d3dcmpfunc);
LPCSTR GetD3DFormatStr(D3DFORMAT d3dformat);
LPCSTR GetMultiSampleStr(DWORD mstype);
LPCSTR GetTextureModeStr(DWORD TextureMode);
UINT64 GetFileTime(LPCSTR lpFileName);

void DisplayError(const char *szCall, HRESULT hr);
#define CheckHR(x) { HRESULT _hr = (x); if (FAILED(_hr)) { DisplayError(#x, _hr); } }
void _cdecl dprintf(LPCSTR lpFmt, ...);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\trivsw\shaderDefs.h ===
// Copyright (c) 2000 Microsoft Corporation - Xbox SDK

// Common constants shared between C code and Vertex Shader

#define WPVMATRIX 0
#define COLOR 4
#define COLORINC 5
#define ALLONES 6
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\volumetexture\sources.inc ===
TARGETNAME=VolTex
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    volumetexture.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\vshtimer\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "bitfont.h"

DWORD BitsPerPixelOfD3DFORMAT(DWORD Format);
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000f, 0x00000060, 0x00000008,
    0x000f0800, 0x1e080000, 0x08000000, 0x0000002d,
    0x00003c08, 0x004b0800, 0x5a080000, 0x08000000,
    0x00000069, 0x00007808, 0x00870800, 0x96080000,
    0x08000000, 0x000000a5, 0x0000b408, 0x00c30800,
    0xd2080000, 0x08000000, 0x000000e1, 0x0000f008,
    0x00ff0800, 0x0e080000, 0x08000001, 0x0000011d,
    0x00012c08, 0x013b0800, 0x4a080000, 0x08000001,
    0x00000159, 0x00016808, 0x01770800, 0x86080000,
    0x08000001, 0x00000195, 0x0001a408, 0x01b30800,
    0xc2080000, 0x08000001, 0x000001d1, 0x0001e008,
    0x01ef0800, 0xfe080000, 0x08000001, 0x0000020d,
    0x00021c08, 0x022b0800, 0x3a080000, 0x08000002,
    0x00000249, 0x00025808, 0x02670800, 0x76080000,
    0x08000002, 0x00000285, 0x00029408, 0x02a30800,
    0xb2080000, 0x08000002, 0x000002c1, 0x0002d008,
    0x02df0800, 0xee080000, 0x08000002, 0x000002fd,
    0x00030c08, 0x031b0800, 0x2a080000, 0x08000003,
    0x00000339, 0x00034808, 0x03570800, 0x66080000,
    0x08000003, 0x00000375, 0x00038408, 0x03930800,
    0xa2080000, 0x08000003, 0x000003b1, 0x0003c008,
    0x03cf0800, 0xde080000, 0x08000003, 0x000003ed,
    0x0003fc08, 0x040b0800, 0x1a080000, 0x08000004,
    0x00000429, 0x00043808, 0x04470800, 0x56080000,
    0x08000004, 0x00000465, 0x00047408, 0x04830800,
    0x92080000, 0x08000004, 0x000004a1, 0x0004b008,
    0x04bf0800, 0xce080000, 0x08000004, 0x000004dd,
    0x0004ec08, 0x04fb0800, 0x0a080000, 0x08000005,
    0x00000519, 0x00052808, 0x05370800, 0x46080000,
    0x08000005, 0x00000555, 0x00056408, 0x05730800,
    0x82080000, 0x08000005, 0x00000591, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xc3e7ffff,
    0xe7e7c3c3, 0xffe7e7ff, 0xffffffff, 0x999999ff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xc980c9c9,
    0xc980c9c9, 0xffffffc9, 0xc3e7e7ff, 0xe7cf9f99,
    0xc399f9f3, 0xffffe7e7, 0x25278fff, 0xcfe7f389,
    0xf1e4a491, 0xffffffff, 0x9393c7ff, 0x99909fc7,
    0xffffc499, 0xffffffff, 0xffe7e7e7, 0xffffffff,
    0xffffffff, 0xf3ffffff, 0xcfcfe7e7, 0xe7cfcfcf,
    0xfffff3e7, 0xe7cfffff, 0xf3f3f3e7, 0xe7e7f3f3,
    0xffffffcf, 0xc9ffffff, 0xc9e380e3, 0xffffffff,
    0xffffffff, 0xe7e7ffff, 0xffe7e781, 0xffffffff,
    0xffffffff, 0xffffffff, 0xe3e3ffff, 0xffffe7f3,
    0xffffffff, 0xff81ffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffe3e3, 0xffffffff,
    0xf3f3f9f9, 0xcfcfe7e7, 0xffff9f9f, 0xe1ffffff,
    0xccc8c8cc, 0xe1ccc4c4, 0xffffffff, 0xe3f3ffff,
    0xf3f3f383, 0xfff3f3f3, 0xffffffff, 0x9999c3ff,
    0xcfe7f3f9, 0xffff819f, 0xffffffff, 0xf99999c3,
    0x9999f9e3, 0xffffffc3, 0xcfffffff, 0xc9c9c9cf,
    0xf9f98099, 0xffffffff, 0x9f81ffff, 0xf9839f9f,
    0xff87f3f9, 0xffffffff, 0xcfe7e3ff, 0x99999983,
    0xffffc399, 0xffffffff, 0xf3f3f981, 0xcfcfe7e7,
    0xffffffcf, 0xc3ffffff, 0xc3899999, 0xc3999991,
    0xffffffff, 0x99c3ffff, 0xc1999999, 0xffc7e7f3,
    0xffffffff, 0xe3ffffff, 0xffffffe3, 0xffffe3e3,
    0xffffffff, 0xe3e3ffff, 0xe3ffffff, 0xffe7f3e3,
    0xf9ffffff, 0x9fcfe7f3, 0xf9f3e7cf, 0xffffffff,
    0xffffffff, 0x81ff81ff, 0xffffffff, 0xffffffff,
    0xe7cf9fff, 0xe7f3f9f3, 0xffff9fcf, 0xffffffff,
    0xf39999c3, 0xe7ffe7e7, 0xffffffe7, 0x81ffffff,
    0x24303c3c, 0x803f3024, 0xffffffff, 0xc3e7ffff,
    0x81999999, 0xff999999, 0xffffffff, 0x999983ff,
    0x99998399, 0xffff8399, 0xffffffff, 0x9f9999c3,
    0x99999f9f, 0xffffffc3, 0x87ffffff, 0x99999993,
    0x87939999, 0xffffffff, 0x9f81ffff, 0x9f839f9f,
    0xff819f9f, 0xffffffff, 0x9f9f81ff, 0x9f9f839f,
    0xffff9f9f, 0xffffffff, 0x9f9999c3, 0x9999919f,
    0xffffffc1, 0x99ffffff, 0x81999999, 0x99999999,
    0xffffffff, 0xe7c3ffff, 0xe7e7e7e7, 0xffc3e7e7,
    0xffffffff, 0xf9f9f9ff, 0x99f9f9f9, 0xffffc399,
    0xffffffff, 0x93939999, 0x99939387, 0xffffff99,
    0x9fffffff, 0x9f9f9f9f, 0x819f9f9f, 0xffffffff,
    0x9c9cffff, 0x94949488, 0xff9c9c9c, 0xffffffff,
    0x8c9c9cff, 0x9c989084, 0xffff9c9c, 0xffffffff,
    0x999999c3, 0x99999999, 0xffffffc3, 0x83ffffff,
    0x83999999, 0x9f9f9f9f, 0xffffffff, 0x99c3ffff,
    0x99999999, 0xf3c39999, 0xfffffff9, 0x999983ff,
    0x99938399, 0xffff9999, 0xffffffff, 0xcf9f99c3,
    0x99f9f3e7, 0xffffffc3, 0x81ffffff, 0xe7e7e7e7,
    0xe7e7e7e7, 0xffffffff, 0x9999ffff, 0x99999999,
    0xffc39999, 0xffffffff, 0x999999ff, 0x99999999,
    0xffffe7c3, 0xffffffff, 0x949c9c9c, 0xc9c99494,
    0xffffffc9, 0x99ffffff, 0xe7e7cb99, 0x999999d3,
    0xffffffff, 0x9999ffff, 0xe7c39999, 0xffe7e7e7,
    0xffffffff, 0xf9f981ff, 0x9fcfe7f3, 0xffff819f,
    0xffffffff, 0xcfcfcfc3, 0xcfcfcfcf, 0xc3cfcfcf,
    0x9fffffff, 0xe7cfcf9f, 0xf9f3f3e7, 0xfffffff9,
    0xf3c3ffff, 0xf3f3f3f3, 0xf3f3f3f3, 0xe7ffc3f3,
    0xffff99c3, 0xffffffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0x00ffffff, 0xf3e7c7ff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0xc1f9f9c3, 0xffc19999, 0xffffffff, 0x839f9fff,
    0x99999999, 0xffff8399, 0xffffffff, 0x99c3ffff,
    0x999f9f9f, 0xffffffc3, 0xf9ffffff, 0x9999c1f9,
    0xc1999999, 0xffffffff, 0xffffffff, 0x819999c3,
    0xffc39f9f, 0xffffffff, 0xcfcfe1ff, 0xcfcf81cf,
    0xffffcfcf, 0xffffffff, 0x99c1ffff, 0x99999999,
    0x83f9f9c1, 0x9fffffff, 0x9999839f, 0x99999999,
    0xffffffff, 0xffe7e7ff, 0xe7e7e787, 0xff81e7e7,
    0xffffffff, 0xc3fff3f3, 0xf3f3f3f3, 0xf3f3f3f3,
    0xffffff87, 0x99999f9f, 0x99938793, 0xffffff99,
    0x87ffffff, 0xe7e7e7e7, 0x81e7e7e7, 0xffffffff,
    0xffffffff, 0x94949481, 0xff9c9494, 0xffffffff,
    0x83ffffff, 0x99999999, 0xffff9999, 0xffffffff,
    0x99c3ffff, 0x99999999, 0xffffffc3, 0xffffffff,
    0x999983ff, 0x83999999, 0xff9f9f9f, 0xffffffff,
    0x999999c1, 0xf9c19999, 0xfffff9f9, 0x99ffffff,
    0x9f9f8f91, 0xffff9f9f, 0xffffffff, 0x9fc1ffff,
    0xf9f9c39f, 0xffffff83, 0xcfffffff, 0xcfcf81cf,
    0xe1cfcfcf, 0xffffffff, 0xffffffff, 0x99999999,
    0xffc19999, 0xffffffff, 0x99ffffff, 0x99999999,
    0xffffe7c3, 0xffffffff, 0x949cffff, 0xc9949494,
    0xffffffc9, 0xffffffff, 0xc39999ff, 0x9999c3e7,
    0xffffffff, 0xffffffff, 0x99999999, 0xf3c39999,
    0xffff0fe7, 0x81ffffff, 0xcfe7f3f9, 0xffff819f,
    0xffffffff, 0xe7e7e7f3, 0xe7cf9fcf, 0xfff3e7e7,
    0xe7ffffff, 0xe7e7e7e7, 0xe7e7e7e7, 0xffe7e7e7,
    0xe7cfffff, 0xf9f3e7e7, 0xe7e7e7f3, 0xffffffcf,
    0x71248eff, 0xffffffff, 0xffffffff, 0xffffffff,
    0x81818181, 0x81818181, 0xffffff81
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const char* filename)
{
#ifdef NEVER
    HFILE hf = _lopen(filename, OF_READ);

    if(hf != HFILE_ERROR)
    {
        // get the file size and move back to the start
        LONG lSize = _llseek(hf, 0, FILE_END);
        _llseek(hf, 0, FILE_BEGIN);

        // need at least a BITFONT and one BITFONTINFO
        if(lSize < sizeof(BitFontInfo) + sizeof(BitFontCharInfo))
            goto err;

        // malloc our BITFONT block and read it in
        m_pBitFontInfo = (BitFontInfo *)new BYTE[lSize];
        if(!m_pBitFontInfo)
            goto err;

        if(_lread(hf, m_pBitFontInfo, (UINT)lSize) != (UINT)lSize)
            goto err;

        // if the sig doesn't match or we don't have any bitfontinfos then bail
        if(m_pBitFontInfo->dwSig != BITFONT_SIG || !m_pBitFontInfo->cBfis)
            goto err;

        _lclose(hf);
        return true;
    }

err:
    if(hf != HFILE_ERROR)
        _lclose(hf);

    delete [] m_pBitFontInfo;
    m_pBitFontInfo = NULL;
#endif
    return false;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const char *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const char *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const char*         str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const char *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const char*         str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const char *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const char*     str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const char*         str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        _asm int 3;
        return;
    }

    D3DSURFACE_DESC desc;
    if(FAILED(pSurface->GetDesc(&desc)))
    {
        _asm int 3;
        return;
    }

    UINT BitsPerPixel = BitsPerPixelOfD3DFORMAT(desc.Format);

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_R4G4B4A4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        _asm int 3;
        break;
    }

    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\vshtimer\inifile.cpp ===
//-----------------------------------------------------------------------------
// FILE: INIFILE.CPP
//
// Desc: fake ini file routines
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include <assert.h>

#include "utils.h"
#include "inifile.h"

//=========================================================================
// Get the value of a constant
//=========================================================================
LPCSTR CIniFile::GetIniConstValue(const char *szStr, INIVAL *pinival)
{
    // skip whitespace
    while(*szStr == ' ' || *szStr == '\t')
        szStr++;

    if((*szStr >= '0' && *szStr <= '9') || (*szStr == '.'))
    {
        char *endptr;
        int base = 10;

        if(szStr[1] == 'x')
        {
            // hexadecimal: skip over leading '0x'
            base = 16;
            szStr += 2;
        }
        else if(pinival->type == INIVAL_FLOAT)
        {
            // check for floating point value
            for(const char *szT = szStr;
                *szT && ((*szT >= '0' && *szStr <= '9') || *szT == '.');
                szT++)
            {
                if(*szT == '.')
                {
                    for(szT++; *szT && (*szT >= '0' && *szStr <= '9'); szT++)
                        ;

                    // check for trailing f
                    if(*szT == 'f')
                        szT++;

                    pinival->SetVal((float)atof(szStr));
                    return szT;
                }
            }
        }

        pinival->SetVal((int)strtoul(szStr, &endptr, base));
        return endptr;
    }

    // token length
    int cchStr = 0;

    // find token length
    for(const char *szT = szStr; *szT && (*szT != ';') && (*szT != '|') && !isspace(*szT); szT++)
        cchStr++;

    // see if the token is known by the app
    if(GetIniConstf(szStr, cchStr, &pinival->valf))
    {
        pinival->val = (int)pinival->valf;
        return szStr + cchStr;
    }
    else if(GetIniConst(szStr, cchStr, &pinival->val))
    {
        pinival->valf = (float)pinival->val;
        return szStr + cchStr;
    }

    // couldn't find token - search in [defines] section
    if(m_recurselevel < 10)
    {
        char szKeyName[64];
        static const char szSectName[] = "defines";

        lstrcpynA(szKeyName, szStr, min(sizeof(szKeyName), cchStr + 1));

        LPCSTR szLineStart;
        LPCSTR szLine = GetIniStr(szSectName, szKeyName, NULL, &szLineStart);

        if(szLine)
        {
            bool fFoundDefine = false;

            m_recurselevel++;

            // did not find entry - search in defines section
            if(pinival->type == INIVAL_FLOAT)
            {
                fFoundDefine = ParseFloatVal(szLineStart, szLine, &pinival->valf);
                pinival->val = (int)pinival->valf;
            }
            else
            {
                fFoundDefine = ParseIntVal(szLineStart, szLine, &pinival->val);
                pinival->valf = (float)pinival->val;
            }

            m_recurselevel--;

            if(fFoundDefine)
                return szStr + cchStr;
        }
    }

    return NULL;
}

//=========================================================================
// Read a file and return malloc'd pointer to data
//=========================================================================
char *SzReadFile(LPCSTR szFileName)
{

    HANDLE hFile = CreateFile(szFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        DWORD dwSize = GetFileSize(hFile, NULL);
        char *szFile = (char *)malloc(dwSize + 1);

        DWORD NumberOfBytesRead;
        ReadFile(hFile, szFile, dwSize, &NumberOfBytesRead, NULL);

        assert(dwSize == NumberOfBytesRead);
        szFile[NumberOfBytesRead] = 0;

        CloseHandle(hFile);
        return szFile;
    }

    return NULL;
}

//=========================================================================
// Read/refresh ini file
//=========================================================================
bool CIniFile::ReadFile()
{
    if(m_szFile)
    {
        free(m_szFile);
        m_szFile = NULL;
    }

    m_szFile = SzReadFile(m_szFileName);
    if(!m_szFile)
    {
        // if file read failed - sleep a short bit in case xbcp
        // had file open still.
        Sleep(500);
        m_szFile = SzReadFile(m_szFileName);
    }

    if(m_szFile)
    {
        m_ftFileReadTime = GetFileTime(m_szFileName);
        return true;
    }

    return false;
}

//=========================================================================
// Find the next real line and return pointer
//=========================================================================
LPCSTR GetLine(LPCSTR szLine)
{
    for(;;)
    {
        // skip whitespace
        while(isspace(*szLine))
            szLine++;

        // check for comments
        if(*szLine == ';' || (szLine[0] == '/' && szLine[1] == '/'))
        {
            // found a comment - cruise to end of line
            while(*szLine && *szLine != '\n')
                szLine++;
            continue;
        }

        return szLine;
    }
}

//=========================================================================
// Get first line of INI file
//=========================================================================
LPCSTR FindFirstLine(LPCSTR szFile)
{
    if(szFile)
        return GetLine(szFile);

    return NULL;
}

//=========================================================================
// Get line after szLine
//=========================================================================
LPCSTR FindNextLine(LPCSTR szLine)
{
    if(szLine)
    {
        while(*szLine && *szLine++ != '\n')
            ;
        return GetLine(szLine);
    }

    return NULL;
}

//=========================================================================
// Find the next token's first char
//=========================================================================
char FindNextChar(LPCSTR szLine, LPCSTR *ppszLine = NULL)
{
    // skip whitespace
    while(*szLine == ' ' || *szLine == '\t')
        szLine++;

    if(ppszLine)
        *ppszLine = szLine;
    return *szLine;
}

//=========================================================================
// Print out error message for something we couldn't parse
//=========================================================================
void OutputLineErr(LPCSTR szErr, LPCSTR szLine)
{
    LPCSTR szEnd = szLine;
    while(*szEnd && (*szEnd != '\r' && *szEnd != '\n'))
        szEnd++;

    char chSav = *szEnd;
    *(char *)szEnd = 0;

    OutputDebugStringA(szErr);
    OutputDebugStringA(":");
    OutputDebugStringA(szLine);
    OutputDebugStringA("\n");

    *(char *)szEnd = chSav;
}

//=========================================================================
// Parse a token stream and return the value
//=========================================================================
bool CIniFile::ParseFloatVal(LPCSTR szLineStart, LPCSTR szLine, float *pval)
{
    INIVAL valT = { INIVAL_FLOAT };
    if(GetIniConstValue(szLine, &valT))
    {
        *pval = valT.valf;
        return true;
    }

    OutputLineErr("unknown token", szLineStart);
    return false;
}

//=========================================================================
// Parse a token stream and return the value
//=========================================================================
bool CIniFile::ParseIntVal(LPCSTR szLineStart, LPCSTR szLine, int *pval)
{
    INIVAL valT = { INIVAL_INT };
    int val = 0;

    while(szLine = GetIniConstValue(szLine, &valT))
    {
        val |= valT.val;

        char ch = FindNextChar(szLine, &szLine);
        switch(ch)
        {
        case '|':
            szLine++;
            break;
        case '\r':
        case '\n':
        case '\0':
        case ';':
            // end of the line
            *pval = val;
            return true;
        default:
            OutputLineErr("unknown char", szLineStart);
            return false;
        }
    }

    OutputLineErr("unknown token", szLineStart);
    return false;
}

//=========================================================================
// Get float value for ini entry
//=========================================================================
float CIniFile::GetIniFloat(LPCSTR lpSectionName, LPCSTR lpKeyName, float nDefault)
{
    LPCSTR szLineStart;
    LPCSTR szLine = GetIniStr(lpSectionName, lpKeyName, NULL, &szLineStart);

    if(!szLine)
        return nDefault;

    ParseFloatVal(szLineStart, szLine, &nDefault);
    return nDefault;
}

//=========================================================================
// Get int value for ini entry
//=========================================================================
int CIniFile::GetIniInt(LPCSTR lpSectionName, LPCSTR lpKeyName, int nDefault)
{
    LPCSTR szLineStart;
    LPCSTR szLine = GetIniStr(lpSectionName, lpKeyName, NULL, &szLineStart);

    if(!szLine)
        return nDefault;

    ParseIntVal(szLineStart, szLine, &nDefault);
    return nDefault;
}

//=========================================================================
// Check if an ini entry exists
//=========================================================================
bool CIniFile::IniEntryExists(LPCSTR lpSectionName, LPCSTR lpKeyName)
{
    bool fverboseBak = m_fverbose;
    m_fverbose = false;

    LPCSTR szLine = GetIniStr(lpSectionName, lpKeyName, NULL, NULL);

    m_fverbose = fverboseBak;
    return !!szLine;
}

//=========================================================================
// Get an INI string and shtuff it into a buffer
//=========================================================================
bool CIniFile::GetIniStrBuf(LPCSTR lpSectionName, LPCSTR lpKeyName,
    LPCSTR szDefault, char *buf, int buflen)
{
    LPCSTR szLine = GetIniStr(lpSectionName, lpKeyName, NULL, NULL);
    if(szLine)
    {
        strncpy(buf, szLine, buflen);

        for(int nT = 0; nT < buflen; nT++)
        {
            if(buf[nT] == '\n' || buf[nT] == '\r' || buf[nT] == ';')
            {
                buf[nT] = 0;
                break;
            }
        }
    }
    else
    {
        strncpy(buf, szDefault, buflen);
    }

    buf[buflen - 1] = 0;
    return !!szLine;
}

//=========================================================================
// Return non-nil terminated string for keyname
//=========================================================================
LPCSTR CIniFile::GetIniStr(LPCSTR lpSectionName, LPCSTR lpKeyName, LPCSTR szDefault,
    LPCSTR *ppszLineStart)
{
    assert(m_szFile);
    if(!m_szFile)
        return szDefault;

    bool finsection = false;
    int cchSectionName = lstrlenA(lpSectionName);
    int cchKeyName = lstrlenA(lpKeyName);
    LPCSTR szLine = FindFirstLine(m_szFile);

    while(szLine && *szLine)
    {
        if(ppszLineStart)
            *ppszLineStart = szLine;

        if(finsection)
        {
            if(*szLine == '[')
            {
                // new section - not found
                break;
            }
            else if(!_strnicmp(lpKeyName, szLine, cchKeyName) &&
                (FindNextChar(szLine + cchKeyName, &szLine) == '='))
            {
                // skip over '='
                szLine++;

                // skip whitespace
                while(*szLine == ' ' || *szLine == '\t')
                    szLine++;

                return szLine;
            }
        }
        else if(*szLine == '[')
        {
            // section name matches?
            szLine++;
            finsection = !_strnicmp(lpSectionName, szLine, cchSectionName) &&
                (FindNextChar(szLine + cchSectionName) == ']');
        }

        szLine = FindNextLine(szLine);
    }

    if(m_fverbose)
        dprintf("entry [%s]/%s not found\n", lpSectionName, lpKeyName);
    return szDefault;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\tvtest\main.c ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    App to test TV output

--*/

#if 1

#include <ntos.h>
#include <av.h>
#include <smcdef.h>
#include <xtl.h>

#else 

#include <xtl.h>

#endif 

#include <xgraphics.h>
#include <xfont.h>
#include <stdio.h>
#include <xbdm.h>

//typedef unsigned long NTSTATUS;

#include <av.h>

void    WINAPI D3DDevice_EnableCC(BOOL Enable);
void    WINAPI D3DDevice_SendCC(BOOL Field, BYTE cc1, BYTE cc2);
void    WINAPI D3DDevice_GetCCStatus(BOOL *pField1, BOOL *pField2);

IDirect3DSurface8 * g_pBack;
IDirect3DSurface8 * g_pOverlay;

HANDLE              g_hEvent;
CRITICAL_SECTION    g_Mutex;

DWORD               g_iMode;
DWORD               g_VpsTime;
DWORD               g_VpsCount;
DWORD               g_FpsTime;
LONG                g_FpsCount;
D3DDISPLAYMODE      g_Mode;
BOOL                g_Overlay;
DWORD               g_ModeTime;
BOOL                g_EnableCC;
DWORD               g_SavedAvInfo;

DWORD               g_ShowSweep;
DWORD               g_SweepTime;
double              g_SweepRate = 2.0; // seconds per sweep (full cycle)
double              g_SweepAttenuation = 0.02;
DWORD               g_SweepWidth = 30; // Lines, max 60

#define BUFFER_SIZE 60

DWORD               g_LineBuffer[BUFFER_SIZE][1920];
DWORD               g_LineNumber[BUFFER_SIZE];

HANDLE g_InputHandle;

BOOL g_A;
BOOL g_B;
BOOL g_X;
BOOL g_Y;
BOOL g_Black;
BOOL g_White;

IDirect3DSurface8 * g_ScreenOdd;
IDirect3DSurface8 * g_ScreenEven;

extern DWORD D3D__AvInfo;
extern volatile DWORD *D3D__GpuReg;

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

void GetScreenChecksum(
    DWORD *pRed,
    DWORD *pGreen,
    DWORD *pBlue
    );

//============================================================================
// Helpers to create the test pattern.
//============================================================================

double SecondsPerPixel()
{
    double secondsperpixel;
    double pixelsperline;
    double secondsperline;

    pixelsperline = g_Mode.Width;

    // These values are measured.
    switch(D3D__AvInfo & AV_STANDARD_MASK)
    {
    case AV_STANDARD_PAL_I:

        if (g_Mode.RefreshRate == 50)
        {
            if (g_Mode.Flags & D3DPRESENTFLAG_10X11PIXELASPECTRATIO)
            {
                secondsperline = 46.428e-6;
            }
            else
            {
                secondsperline = 51.326e-6;
            }

            break;
        }

        // fall through

    case AV_STANDARD_NTSC_M:
    case AV_STANDARD_NTSC_J:
    case AV_STANDARD_PAL_M:

        if (g_Mode.Flags & D3DPRESENTFLAG_10X11PIXELASPECTRATIO)
        {
            secondsperline = 47.633e-6;
        }
        else
        {
            secondsperline = 52.426e-6;
        }

        break;

    }

    secondsperpixel = secondsperline / pixelsperline;

    return secondsperpixel;
}

// This function returns the natural frequency in 
double Kw (double fFreq)
{
    double radiansperpixel;
    double radiansperwave;
    double wavespersecond;
    double secondsperpixel;

    radiansperwave  = 2.0 * 3.1415;
    wavespersecond  = fFreq;
    secondsperpixel = SecondsPerPixel();

    radiansperpixel = wavespersecond * secondsperpixel * radiansperwave;

    return radiansperpixel;

//    return (2.0*3.1415*fFreq/(30*525/1.001)/640.0);
}

DWORD IREtoDW (double dfIre)
{
    return ((DWORD)(dfIre*255.0/100.0));
}

DWORD IREtoRGB(double dfIre)
{
    DWORD c;

    c = IREtoDW(dfIre) & 0xFF;

    return 0xFF000000 
           | (c << 16)
           | (c << 8)
           | c;
}

DWORD AbsIREtoDW(double dfIre)
{
    if ((D3D__AvInfo & AV_STANDARD_MASK) == AV_STANDARD_NTSC_M)
    {
        return IREtoDW((dfIre - 7.5) / .925);
    }
    else
    {
        return IREtoDW(dfIre);
    }
}


//============================================================================
// This signal is a composite of several useful test signals:
// Top Picture Extents
// 75% Color Bars
// 100% Color Bars
// Picture Center and Horizontal Extents
// Multiburst
// LUMA Step
// Bottom Picture Extents
//============================================================================

void CompositeTest(D3DSurface *pSurface, double d, double d2, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT  Rect;
    LPDWORD         pData;
    DWORD           dwR, dwG, dwB, dwY;
    DWORD           x;
    DWORD           y;

    DWORD Width;
    DWORD Height;
    DWORD PitchAdjust;

    double MultiburstAdjust;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height;
    PitchAdjust  = Rect.Pitch / 4 - Width;

    MultiburstAdjust = (double)Width / 640;

    pData = (LPDWORD)Rect.pBits;

    // Vertical (top) Picture Extents
    for (y = 0; y < Height/12; y++)
    {
        for (x = 0; x < Width; x++)
        {
            if ((x%10 == 0) && (y > Height/12*3/4) || (x%100 == 0) && (y > Height/12*1/2))
            {
                dwR = IREtoDW(0.0);
                dwG = IREtoDW(0.0);
                dwB = IREtoDW(0.0);
            }
            else
            {
                dwR = IREtoDW(100.0);
                dwG = IREtoDW(100.0);
                dwB = IREtoDW(100.0);
            }
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }

        pData += PitchAdjust;
    }

    // 75% Color Bars
    
    for (; y < Height / 4; y++)
    {
        for (x = 0; x < 1 * Width / 8; x++)
        {
            dwR = IREtoDW(75.0);
            dwG = IREtoDW(75.0);
            dwB = IREtoDW(75.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 2 * Width / 8; x++)
        {
            dwR = IREtoDW(75.0);
            dwG = IREtoDW(75.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 3 * Width / 8; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(75.0);
            dwB = IREtoDW(75.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 4 * Width / 8; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(75.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 5 * Width / 8; x++)
        {
            dwR = IREtoDW(75.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(75.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 6* Width / 8; x++)
        {
            dwR = IREtoDW(75.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 7* Width / 8; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(75.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < Width; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }

        pData += PitchAdjust;
    }

    // 100% Color Bars
    
    for (; y < Height / 12 * 5; y++)
    {
        for (x = 0; x < 1 * Width / 8; x++)
        {
            dwR = IREtoDW(100.0);
            dwG = IREtoDW(100.0);
            dwB = IREtoDW(100.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 2 * Width / 8; x++)
        {
            dwR = IREtoDW(100.0);
            dwG = IREtoDW(100.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 3 * Width / 8; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(100.0);
            dwB = IREtoDW(100.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 4 * Width / 8; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(100.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 5 * Width / 8; x++)
        {
            dwR = IREtoDW(100.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(100.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 6* Width / 8; x++)
        {
            dwR = IREtoDW(100.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 7* Width / 8; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(100.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < Width; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }

        pData += PitchAdjust;
    }

    // Picture Center
    
    for (; y < Height / 2; y++)
    {
        for (x = 0; x < 20; x++)
        {
            *pData++ = IREtoRGB(100.0);
        }
        for (; x < Width / 2 - Height / 12; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < Width / 2; x++)
        {
            dwR = IREtoDW(10.0);
            dwG = IREtoDW(10.0);
            dwB = IREtoDW(10.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < Width / 2 + Height / 12; x++)
        {
            dwR = IREtoDW(90.0);
            dwG = IREtoDW(90.0);
            dwB = IREtoDW(90.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < Width - 20; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < Width; x++)
        {
            *pData++ = IREtoRGB(100.0);
        }
        pData += PitchAdjust;
    }

    for (; y < Height / 12 * 7; y++)
    {
        for (x = 0; x < 20; x++)
        {
            *pData++ = IREtoRGB(100.0);
        }
        for (; x < Width / 2 - Height / 12; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < Width / 2; x++)
        {
            dwR = IREtoDW(90.0);
            dwG = IREtoDW(90.0);
            dwB = IREtoDW(90.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < Width / 2 + Height / 12; x++)
        {
            dwR = IREtoDW(10.0);
            dwG = IREtoDW(10.0);
            dwB = IREtoDW(10.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < Width - 20; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < Width; x++)
        {
            *pData++ = IREtoRGB(100.0);
        }
        pData += PitchAdjust;
    }

    // Multiburst

#define MB(x) ((DWORD)((double)x * MultiburstAdjust))

    for (; y < Height / 4 * 3; y++)
    {
       for (x = 0; x < MB(55); x++)
        {
            dwY = AbsIREtoDW(70.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }
        for (; x < MB(106); x++)
        {
            dwY = AbsIREtoDW(10.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }
        for (; x < MB(123); x++)
        {
            dwY = AbsIREtoDW(40.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }

        for (; x < MB(195); x++)
        {           
            dwY = AbsIREtoDW( (30.0 * sin(Kw(500e3) * (double)x)) + 40.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }
        for (; x < MB(208); x++)
        {
            dwY = AbsIREtoDW(40.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }

        for (; x < MB(280); x++)
        {
            dwY = AbsIREtoDW( (30.0 * sin(Kw(1e6) * (double)x)) + 40.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }
        for (; x < MB(293); x++)
        {
            dwY = AbsIREtoDW(40.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }


        for (; x < MB(365); x++)
        {
            dwY = AbsIREtoDW( (30.0 * sin(Kw(2e6) * (double)x)) + 40.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }
        for (; x < MB(378); x++)
        {
            dwY = AbsIREtoDW(40.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }


        for (; x < MB(450); x++)
        {
            dwY = AbsIREtoDW( (30.0 * sin(Kw(3e6) * (double)x)) + 40.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }
        for (; x < MB(464); x++)
        {
            dwY = AbsIREtoDW(40.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }


        for (; x < MB(535); x++)
        {
            dwY = AbsIREtoDW( (30.0 * sin(Kw(3.58e6) * (double)x)) + 40.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }
        for (; x < MB(549); x++)
        {
            dwY = AbsIREtoDW(40.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }


        for (; x < MB(621); x++)
        {
            dwY = AbsIREtoDW( (30.0 * sin(Kw(4.2e6) * (double)x)) + 40.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }
        for (; x < MB(640); x++)
        {
            dwY = AbsIREtoDW(40.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }

        for (; x < Width; x++)
        {
            *pData++ = 0;
        }

        pData += PitchAdjust;
    }

#undef MB

    // 5-Step

    for (; y < Height / 12 * 11; y++)
    {
       for (x = 0; x < 1 * Width / 5; x++)
        {
            dwY = IREtoDW(20.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }
       for (; x < 2 * Width / 5; x++)
        {
            dwY = IREtoDW(40.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }
       for (; x < 3 * Width / 5; x++)
        {
            dwY = IREtoDW(60.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }
       for (; x < 4 * Width / 5; x++)
        {
            dwY = IREtoDW(80.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }
       for (; x < 5 * Width / 5; x++)
        {
            dwY = IREtoDW(100.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }

        pData += PitchAdjust;
    }

    // Bottom Picture Extents
    for (; y < Height; y++)
    {
       for (x = 0; x < Width; x++)
        {
            dwY = IREtoDW(100.0);
            *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
        }

        pData += PitchAdjust;
    }

    D3DSurface_UnlockRect(pSurface); 
}

//============================================================================
// Centering test.
//============================================================================

void Centering(D3DSurface *pSurface, double dfIRE, double d2, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT  Rect;
    LPDWORD         pData;
    DWORD           dwVal;
    DWORD           x;
    DWORD           y;

    DWORD Width;
    DWORD Height;
    DWORD PitchAdjust;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height;
    PitchAdjust = Rect.Pitch / 4;

    pData = (LPDWORD)Rect.pBits;

    for (y = 0; y < Height; y++)
    {
        for (x = 0; x < 32; x++)
        {
            *(pData + x) = IREtoRGB(100.0);
        }

        for (x = Width / 2 - 64; x < Width / 2 - 32; x++)
        {
            *(pData + x) = IREtoRGB(50.0);
        }

        for (x = Width / 2 - 32; x < Width / 2; x++)
        {
            *(pData + x) = IREtoRGB(0.0);
        }

        for (x = Width / 2; x < Width / 2 + 32; x++)
        {
            *(pData + x) = IREtoRGB(100.0);
        }

        for (x = Width / 2 + 32; x < Width / 2 + 64; x++)
        {
            *(pData + x) = IREtoRGB(50.0);
        }

        for (x = Width - 32; x < Width; x++)
        {
            *(pData + x) = IREtoRGB(100.0);
        }

        pData += PitchAdjust;
    }

    D3DSurface_UnlockRect(pSurface); 
}

//============================================================================
// Vertical Centering test.
//============================================================================

void VCentering(D3DSurface *pSurface, double dfIRE, double d2, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT  Rect;
    LPDWORD         pData;
    DWORD           dwVal;
    DWORD           x;
    DWORD           y;

    DWORD Width;
    DWORD Height;
    DWORD PitchAdjust;

    DWORD Start;
    DWORD Step;
    DWORD Tick;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height;
    PitchAdjust = Rect.Pitch / 4;

    Start = Width / 4;
    Step  = Width / 2 / 10;

    pData = (LPDWORD)Rect.pBits;

    for (x = 0; x < Width; x++)
    {
        *pData++ = IREtoRGB(100.0);
    }

    pData = (LPDWORD)Rect.pBits + Rect.Pitch / 4 * Height / 2;

    for (x = 0; x < Width; x++)
    {
        *pData++ = IREtoRGB(100.0);
    }

    pData = (LPDWORD)Rect.pBits + Rect.Pitch / 4 * (Height - 1);

    for (x = 0; x < Width; x++)
    {
        *pData++ = IREtoRGB(100.0);
    }

    pData = (LPDWORD)Rect.pBits;

    for (y = 0; y < Height / 2; y++)
    {
        for (x = 0; x < 10; x++)
        {
            *(pData + Start + Step * x) = IREtoRGB(100.0);
        }

        if (!(y % 5))
        {           
            Tick = (y / 5) % 10 * Step + Start - 12;

            for (x = Tick ; x < Tick + 24; x++)
            {
                *(pData + x) = IREtoRGB(100.0);
            }
        }

        pData += PitchAdjust;
    }

    for (y = Height / 2; y < Height; y++)
    {
        for (x = 0; x < 10; x++)
        {
            *(pData + Start + Step * x) = IREtoRGB(100.0);
        }

        if (!((Height - y) % 5))
        {           
            Tick = ((Height - y ) / 5) % 10 * Step + Start - 12;

            for (x = Tick ; x < Tick + 24; x++)
            {
                *(pData + x) = IREtoRGB(100.0);
            }
        }

        pData += PitchAdjust;
    }

    D3DSurface_UnlockRect(pSurface); 
}



//============================================================================
// Cross hatch test pattern.
//============================================================================

void CrossHatch(D3DSurface *pSurface, double d, double d2, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT Rect;

    DWORD Width;
    DWORD Height;
    DWORD Pitch;

    DWORD Space;

    DWORD *pBits;
    DWORD *pCurrent;
    DWORD *pEnd;

    DWORD y;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height;
    Pitch  = Rect.Pitch / 4;

    Space = (DWORD)d    ;

    pBits = (DWORD *)Rect.pBits;

    for (y = 0; y < Height; y++)
    {
        pCurrent = pBits + Pitch * y;
        pEnd = pCurrent + Width;

        for (pCurrent += y % Space; pCurrent < pEnd; pCurrent += Space)
        {
            *pCurrent = IREtoRGB(100.0);
        }

        pCurrent = pBits + Pitch * y;
        pEnd = pCurrent + Width;

        for (pEnd -= y % Space; pEnd >= pCurrent; pEnd -= Space)
        {
            *pEnd = IREtoRGB(100.0);
        }
    }

    D3DSurface_UnlockRect(pSurface);
}

//============================================================================
// Red the whole screen.  We could use Clear for this but why bother?
//============================================================================

void RedField(D3DSurface *pSurface, double dfIRE, double d2, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT  Rect;
    LPDWORD         pData;
    DWORD           dwVal;
    DWORD           x;
    DWORD           y;

    DWORD Width;
    DWORD Height;
    DWORD PitchAdjust;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height;
    PitchAdjust = Rect.Pitch / 4 - Width;

    pData = (LPDWORD)Rect.pBits;

    dwVal = IREtoDW(dfIRE);

    for (y = 0; y < Height; y++)
    {
        for (x = 0; x < Width; x++)
        {
            *pData++ = D3DCOLOR_ARGB(0, dwVal, 0, 0);
        }

        pData += PitchAdjust;
    }

    D3DSurface_UnlockRect(pSurface); 
}

//============================================================================
// Green the whole screen.  We could use Clear for this but why bother?
//============================================================================

void GreenField(D3DSurface *pSurface, double dfIRE, double d2, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT  Rect;
    LPDWORD         pData;
    DWORD           dwVal;
    DWORD           x;
    DWORD           y;

    DWORD Width;
    DWORD Height;
    DWORD PitchAdjust;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height;
    PitchAdjust = Rect.Pitch / 4 - Width;

    pData = (LPDWORD)Rect.pBits;

    dwVal = IREtoDW(dfIRE);

    for (y = 0; y < Height; y++)
    {
        for (x = 0; x < Width; x++)
        {
            *pData++ = D3DCOLOR_ARGB(0, 0, dwVal, 0);
        }

        pData += PitchAdjust;
    }

    D3DSurface_UnlockRect(pSurface); 
}

//============================================================================
// Blue the whole screen.  We could use Clear for this but why bother?
//============================================================================

void BlueField(D3DSurface *pSurface, double dfIRE, double d2, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT  Rect;
    LPDWORD         pData;
    DWORD           dwVal;
    DWORD           x;
    DWORD           y;

    DWORD Width;
    DWORD Height;
    DWORD PitchAdjust;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height;
    PitchAdjust = Rect.Pitch / 4 - Width;

    pData = (LPDWORD)Rect.pBits;

    dwVal = IREtoDW(dfIRE);

    for (y = 0; y < Height; y++)
    {
        for (x = 0; x < Width; x++)
        {
            *pData++ = D3DCOLOR_ARGB(0, 0, 0, dwVal);
        }

        pData += PitchAdjust;
    }

    D3DSurface_UnlockRect(pSurface); 
}

//============================================================================
// Grey the whole screen.  We could use Clear for this but why bother?
//============================================================================

void GreyField(D3DSurface *pSurface, double dfIRE, double d2, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT  Rect;
    LPDWORD         pData;
    DWORD           dwVal;
    DWORD           x;
    DWORD           y;

    DWORD Width;
    DWORD Height;
    DWORD PitchAdjust;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height;
    PitchAdjust = Rect.Pitch / 4 - Width;

    pData = (LPDWORD)Rect.pBits;

    dwVal = IREtoDW(dfIRE);

    // A non-zero d2 indicates that we need to adjust the IRE to be
    // actually value...ignoring any pedistal.
    //
    if (d2 != 0.0 && (D3D__AvInfo & AV_STANDARD_MASK) == AV_STANDARD_NTSC_M)
    {
        dwVal = IREtoDW((dfIRE - 7.5) / .925);
    }

    for (y = 0; y < Height; y++)
    {
        for (x = 0; x < Width; x++)
        {
            *pData++ = D3DCOLOR_ARGB(0, dwVal, dwVal, dwVal);
        }

        pData += PitchAdjust;
    }

    D3DSurface_UnlockRect(pSurface); 
}

//============================================================================
// Line interlace test.
//============================================================================

void LineInterlace(D3DSurface *pSurface, double d, double d2, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT Rect;

    DWORD Width;
    DWORD Height;
    DWORD Pitch;

    DWORD *pBits;
    DWORD *pCurrent;
    DWORD *pEnd;

    DWORD x, y, i;
    DWORD Pulse, Rest;

    DWORD Color;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height;
    Pitch  = Rect.Pitch / 4;

    Rest = Width / 34;
    Pulse = Rest * 2;

    pBits = (DWORD *)Rect.pBits;

    for (y = 0; y < Height; y++)
    {
        pCurrent = pBits + Pitch * y;

        for (i = 0; i < 11; i++)
        {
            for (x = 0; x < Rest; x++)
            {
                *(pCurrent++) = IREtoRGB(50.0);
            }

            Color = (y & (0x400 >> i)) ? IREtoRGB(100.0) : IREtoRGB(0.0);

            for (x = 0; x < Pulse; x++)
            {
                *(pCurrent++) = Color;
            }
        }

        for (x = 0; x < Rest; x++)
        {
            *(pCurrent++) = IREtoRGB(50.0);
        }
    }

    D3DSurface_UnlockRect(pSurface);
}

//============================================================================
// Interlaced bluefield test.
//============================================================================

void InterlaceField(D3DSurface *pSurface, double dfIRE, double d2, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT Rect;

    DWORD Width;
    DWORD Height;
    DWORD Pitch;

    DWORD Space;

    DWORD *pBits;
    DWORD *pCurrent;
    DWORD *pEnd;

    DWORD y;

    BOOL EvenField = (DWORD)dfIRE;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height * 2;
    Pitch  = Rect.Pitch / 4;

    Space = (DWORD)50;

    pBits = (DWORD *)Rect.pBits;

#if 1

    for (y = 0; y < Height; y ++)
    {
        pCurrent = pBits + Pitch * y;
        pEnd = pCurrent + Width;

        for (; pCurrent < pEnd; pCurrent++)
        {
            if (EvenField)
            {
                *pCurrent = IREtoRGB(50.0);
            }
            else
            {
                *pCurrent = IREtoRGB(100.0);
            }
        }
    }

#else

    if (EvenField)
    {
        y = 1;
    }
    else
    {
        y = 0;
    }

    for (; y < Height; y += 2)
    {
        pCurrent = pBits + Pitch * (y / 2);
        pEnd = pCurrent + Width;

        for (pCurrent += y % Space; pCurrent < pEnd; pCurrent += Space)
        {
            *pCurrent = IREtoRGB(100.0);
        }

        pCurrent = pBits + Pitch * (y / 2);
        pEnd = pCurrent + Width;

        for (pEnd -= y % Space; pEnd >= pCurrent; pEnd -= Space)
        {
            *pEnd = IREtoRGB(100.0);
        }
    }

#endif

    D3DSurface_UnlockRect(pSurface);
}

//============================================================================
// Luma ramp.
//============================================================================

void LumaRamp(D3DSurface *pSurface, double d, double d2, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT  Rect;
    LPDWORD         pData;
    DWORD           dwVal;
    DWORD           x;
    DWORD           y;

    DWORD Width;
    DWORD Height;
    DWORD PitchAdjust;

    DWORD ColorBase;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height;
    PitchAdjust  = Rect.Pitch / 4 - Width;

    if (d == 1.0)
    {
        ColorBase = 0x00010000;
    }
    else if (d == 2.0)
    {
        ColorBase = 0x00000100;
    }
    else if (d == 3.0)
    {
        ColorBase = 0x00000001;
    }
    else
    {
        ColorBase = 0x00010101;
    }

    pData = (LPDWORD)Rect.pBits;

    for (y = 0; y < Height; y++)
    {
        for (x = 0; x < Width; x++)
        {
            if (y < Height / 2)
            {
                dwVal = IREtoDW(100.0 * x / (Width - 1));
            }
            else
            {
                dwVal = IREtoDW(100.0 * (Width - 1 - x) / (Width - 1));
            }

            *pData++ = ColorBase * dwVal;
        }

        pData += PitchAdjust;
    }
    
    D3DSurface_UnlockRect(pSurface); 
}

//============================================================================
// Smpte bars
//============================================================================

void SmpteBars(D3DSurface *pSurface, double WhiteIntensity, double Intensity, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT  Rect;
    LPDWORD         pData;
    DWORD           dwR, dwG, dwB;
    DWORD           x;
    DWORD           y;

    DWORD Width;
    DWORD Height;
    DWORD PitchAdjust;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height;
    PitchAdjust  = Rect.Pitch / 4 - Width;

    pData = (LPDWORD)Rect.pBits;

    for (y = 0; y < Height * 3 / 4; y++)
    {
        for (x = 0; x < 1 * Width / 8; x++)
        {
            dwR = IREtoDW(WhiteIntensity);
            dwG = IREtoDW(WhiteIntensity);
            dwB = IREtoDW(WhiteIntensity);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 2 * Width / 8; x++)
        {
            dwR = IREtoDW(Intensity);
            dwG = IREtoDW(Intensity);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 3 * Width / 8; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(Intensity);
            dwB = IREtoDW(Intensity);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 4 * Width / 8; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(Intensity);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 5 * Width / 8; x++)
        {
            dwR = IREtoDW(Intensity);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(Intensity);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 6* Width / 8; x++)
        {
            dwR = IREtoDW(Intensity);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 7* Width / 8; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(Intensity);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 8 * Width / 8; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }

        pData += PitchAdjust;
    }

    for (; y < Height; y++)
    {
        for (x = 0; x < 1 * Width / 6; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(10.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 2 * Width / 6; x++)
        {
            dwR = IREtoDW(100.0);
            dwG = IREtoDW(100.0);
            dwB = IREtoDW(100.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 3 * Width / 6; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(10.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 4 * Width / 6; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 5 * Width / 6; x++)
        {
            dwR = IREtoDW(4.2);
            dwG = IREtoDW(4.2);
            dwB = IREtoDW(4.2);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }
        for (; x < 6 * Width / 6; x++)
        {
            dwR = IREtoDW(0.0);
            dwG = IREtoDW(0.0);
            dwB = IREtoDW(0.0);
            *pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
        }

        pData += PitchAdjust;
    }   

    D3DSurface_UnlockRect(pSurface); 
}

//============================================================================
// Multiburst test pattern.
//============================================================================

void MultiBurst(D3DSurface *pSurface, double d, double d2, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT  Rect;
    LPDWORD         pData;
    DWORD           dwVal, dwY;
    double          x;
    DWORD           y;

    DWORD Width;
    DWORD Height;
    DWORD PitchAdjust;

    double MultiburstAdjust;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height;
    PitchAdjust  = Rect.Pitch / 4 - Width;

    MultiburstAdjust = (double)Width / 640;

    pData = (LPDWORD)Rect.pBits;

#define MB(x) ((DWORD)((double)x * MultiburstAdjust))

    for (y = 0; y < 480; y++)
    {
        if (y<20)
        {
            for (x = 0; x < MB(640); x= x+1.0)
            {
                dwVal = AbsIREtoDW(70.0);
                *pData++ = D3DCOLOR_ARGB(0, dwVal, dwVal, dwVal);
            }
        }
        else if (y<460)
        {
            // Square
            for (x = 0; x < MB(22); x++)
            {
                dwY = AbsIREtoDW(70.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (; x < MB(55); x++)
            {
                dwY = AbsIREtoDW(10.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (; x < MB(65); x++)
            {
                dwY = AbsIREtoDW(40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }

            // .5MHz
            for (; x < MB(120); x++)
            {           
                dwY = AbsIREtoDW( (30.0 * sin(Kw(500e3) * (double)x)) + 40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (; x < MB(130); x++)
            {
                dwY = AbsIREtoDW(40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }

            // 1MHz
            for (; x < MB(185); x++)
            {
                dwY = AbsIREtoDW( (30.0 * sin(Kw(1e6) * (double)x)) + 40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (; x < MB(195); x++)
            {
                dwY = AbsIREtoDW(40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }

            // 2MHz
            for (; x < MB(250); x++)
            {
                dwY = AbsIREtoDW( (30.0 * sin(Kw(2e6) * (double)x)) + 40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (; x < MB(260); x++)
            {
                dwY = AbsIREtoDW(40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }

            // 3MHz
            for (; x < MB(315); x++)
            {
                dwY = AbsIREtoDW( (30.0 * sin(Kw(3e6) * (double)x)) + 40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (; x < MB(325); x++)
            {
                dwY = AbsIREtoDW(40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }

            // 3.586MHz
            for (; x < MB(380); x++)
            {
                dwY = AbsIREtoDW( (30.0 * sin(Kw(3.58e6) * (double)x)) + 40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (; x < MB(390); x++)
            {
                dwY = AbsIREtoDW(40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }

            // 4.2MHz
            for (; x < MB(445); x++)
            {
                dwY = AbsIREtoDW( (30.0 * sin(Kw(4.2e6) * (double)x)) + 40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (; x < MB(455); x++)
            {
                dwY = AbsIREtoDW(40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }

            // 5MHz
            for (; x < MB(510); x++)
            {
                dwY = AbsIREtoDW( (30.0 * sin(Kw(5.0e6) * (double)x)) + 40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (; x < MB(520); x++)
            {
                dwY = AbsIREtoDW(40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }

            // 5.5MHz
            for (; x < MB(575); x++)
            {
                dwY = AbsIREtoDW( (30.0 * sin(Kw(5.5e6) * (double)x)) + 40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (; x < MB(585); x++)
            {
                dwY = AbsIREtoDW(40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            
            // 6.75MHz
            for (; x < MB(640); x++)
            {
                dwY = AbsIREtoDW( (30.0 * sin(Kw(6.75e6) * (double)x)) + 40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }            
            
            for (; x < Width; x++)
            {
                *pData++ = 0;
            }
        }
        else
        {
            for (x=0; x < MB(640); x= x+1.0)
            {
                dwVal = AbsIREtoDW(10.0);
                *pData++ = D3DCOLOR_ARGB(0, dwVal, dwVal, dwVal);
            }
        }

        pData += PitchAdjust;
    }   

#undef MB

    D3DSurface_UnlockRect(pSurface); 
}

//============================================================================
// Multipulse test pattern.
//
// The MultiPulse test signal consists of a series of short modulated pulses 
// of varying duration, subcarrier frequency, and amplitude, specifically: 
//
// 1. A white flag bar (100 IRE bar signal of duration 5.9 microseconds) 
// 2. The 2T pulse (2T luminance-only pulse of amplitude 100 IRE , 
//    where T =125 nanoseconds), and 
// 3. A 25T modulated pulse (25T sine-squared pulse of amplitude 100 IRE, 
//    with 1.0MHz modulation, where T = 125 nanoseconds), and 
// 4. Four 12.5T modulated pulses (12.5T sine-squared pulses of amplitude 
//    100 IRE with 2.0, 3.0, 3.58, and 4.2 MHz modulation, respectively, 
//    where T = 125 nanoseconds). 
//
// These signal components are supported with standard synchronizing and 
// blanking signals. The signal is specified in the ANSI T1.502-1988 Standard
// for Telecommunications. 
//
// The IRE levels for the pulses is set to the range [-3, 70]
//============================================================================
void MultiPulse(D3DSurface *pSurface, double d, double d2, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT  Rect;
    LPDWORD         pData;
    DWORD           dwVal, dwY;
    double          x;
    DWORD           y;
    double          xx;

    DWORD Width;
    DWORD Height;
    DWORD PitchAdjust;

    double MultiburstAdjust;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height;
    PitchAdjust  = Rect.Pitch / 4 - Width;

    MultiburstAdjust = (double)Width / 640;

    pData = (LPDWORD)Rect.pBits;

#define MB(x) ((DWORD)((double)(x) * MultiburstAdjust))

    // The multipulse is similar to the multiburst except for the frequencies
    // used and the following:
    // In the multipulse signal, the sinusoidal signales are modulated by a
    // sin^2 pulse and then added to the same sin^2 pulse.
#define SINSQ(x) (0.5 * (1.0 - cos(2.0 * (x))))
#define MP(x) (sin(x) * SINSQ(x) + SINSQ(x))

    for (y = 0; y < 480; y++)
    {
        if (y<20)
        {
            for (x = 0; x < MB(640); x= x+1.0)
            {
                dwVal = AbsIREtoDW(70.0);
                *pData++ = D3DCOLOR_ARGB(0, dwVal, dwVal, dwVal);
            }
        }
        else if (y<460)
        {
            // White Flag Bar 100 IRE for 5.9e-6 seconds
            for(x=0, xx=0; xx < MB(5.9e-6 / SecondsPerPixel()); ++xx, ++x)
            {           
                dwY = AbsIREtoDW(100.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (xx=0; xx < 10; ++xx, ++x)
            {
                dwY = AbsIREtoDW(40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            
            // Luminance only pulse ? at 100 IRE for 250e-9 seconds
            for(xx=0.0; xx < MB(250.0e-9 / SecondsPerPixel()); ++xx, ++x)
            {           
                dwY = AbsIREtoDW(70.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (xx=0; xx < 10; ++xx, ++x)
            {
                dwY = AbsIREtoDW(40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }

            // 1MHz pulse at 100 IRE for 3125e-9 seconds
            for (xx=0.0; xx < MB(3125.0e-9 / SecondsPerPixel()); ++xx, ++x)
            {           
                dwY = AbsIREtoDW((15.0 * MP(Kw(1.0e6) * (double)x)) + 40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (xx=0; xx < 10; ++xx, ++x)
            {
                dwY = AbsIREtoDW(40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }

            // 2MHz pulse at 100 IRE for 1562.5e-9 seconds
            for (xx=0.0; xx < MB(1562.5e-9 / SecondsPerPixel()); ++xx, ++x)
            {
                dwY = AbsIREtoDW((15.0 * MP(Kw(2.0e6) * (double)x)) + 40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (xx=0; xx < 10; ++xx, ++x)
            {
                dwY = AbsIREtoDW(40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }

            // 3MHz pulse at 100 IRE for 1562.5e-9 seconds
            for (xx=0.0; xx < MB(1562.5e-9 / SecondsPerPixel()); ++xx, ++x)
            {
                dwY = AbsIREtoDW((15.0 * MP(Kw(3.0e6) * (double)x)) + 40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (xx=0; xx < 10; ++xx, ++x)
            {
                dwY = AbsIREtoDW(40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }

            // 3.58MHz pulse at 100 IRE for 1562.5e-9 seconds
            for (xx=0.0; xx < MB(1562.5e-9 / SecondsPerPixel()); ++xx, ++x)
            {
                dwY = AbsIREtoDW((15.0 * MP(Kw(3.58e6) * (double)x)) + 40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }
            for (xx=0; xx < 10; ++xx, ++x)
            {
                dwY = AbsIREtoDW(40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }

            // 4.1MHz pulse at 100 IRE for 1562.5e-9 seconds
            for (xx=0.0; xx < MB(1562.5e-9 / SecondsPerPixel()); ++xx, ++x)
            {
                dwY = AbsIREtoDW((15.0 * MP(Kw(4.1e6) * (double)x)) + 40.0);
                *pData++ = D3DCOLOR_ARGB(0, dwY, dwY, dwY);
            }            
            
            for (; x < Width; ++x)
            {
                *pData++ = 0;
            }
        }
        else
        {
            for (x=0; x < MB(640); x= x+1.0)
            {
                dwVal = AbsIREtoDW(10.0);
                *pData++ = D3DCOLOR_ARGB(0, dwVal, dwVal, dwVal);
            }
        }

        pData += PitchAdjust;
    }   

#undef MB
#undef MP
#undef SINSQ

    D3DSurface_UnlockRect(pSurface); 
}


//============================================================================
// (sin x)/x test pattern.
//
// Because using Kw(x) in this method only produces a small fraction
// of the signal, I chose to use 6 cycles (just an arbitrary number).
//============================================================================

void SinXOverX(D3DSurface *pSurface, double d, double d2, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT  Rect;
    LPDWORD         pData;
    DWORD           dwVal;
    double          x;
    DWORD           y;
    double          fx;
    DWORD           PitchAdjust;
    double          MultiburstAdjust;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    PitchAdjust = Rect.Pitch / 4 - Desc.Width;
    pData       = (LPDWORD)Rect.pBits;
    
    MultiburstAdjust = (double)Desc.Width / 640;

    pData = (LPDWORD)Rect.pBits;

#define MB(x) ((DWORD)((double)(x) * MultiburstAdjust))

    for(y = 0; y < 480; ++y)
    {
        if(y<20)
        {
            for (x=0.0; x < MB(640); x+=1.0)
            {
                dwVal       = AbsIREtoDW(70.0);
                *pData++    = D3DCOLOR_ARGB(0, dwVal, dwVal, dwVal);
            }
        }
        else if(y<460)
        {
            for (x=0.0; x < MB(640); x+=1.0)
            {
                fx = x / (double)MB(640) * 3.14159265359 * 2.0 * 6.0;
                if(fx != 0.0)
                    dwVal   = AbsIREtoDW((30.0 * (sin(fx) / fx)) + 40.0);
                else
                    dwVal   = AbsIREtoDW(100.0);
                *pData++    = D3DCOLOR_ARGB(0, dwVal, dwVal, dwVal);
            }
        }
        else
        {
            for (x=0.0; x < MB(640); x+=1.0)
            {
                dwVal       = AbsIREtoDW(10.0);
                *pData++    = D3DCOLOR_ARGB(0, dwVal, dwVal, dwVal);
            }
        }
        pData += PitchAdjust;
    }   

    D3DSurface_UnlockRect(pSurface); 
}

//============================================================================
// Blue the whole screen.  We could use Clear for this but why bother?
//============================================================================

void DrawCircle(DWORD *pStart, DWORD Pitch, DWORD Color, DWORD xCenter, DWORD yCenter, double dRadius)
{
    long xOffset;
    long yOffset;

    long x, y;

    yOffset = (long)dRadius;

    for (y = -yOffset; y <= yOffset; y++)
    {
        xOffset = (long)sqrt(dRadius * dRadius - (double)(y * y));

        for (x = -xOffset; x <= xOffset; x++)
        {
            *(pStart + (yCenter + y) * Pitch / 4 + (xCenter + x)) = Color;
        }
    }   
}

void Circles(D3DSurface *pSurface, double d1, double d2, DWORD Time)
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT  Rect;
    LPDWORD         pData;
    DWORD           x;
    DWORD           y;

    DWORD Width;
    DWORD Height;
    DWORD PitchAdjust;

    D3DSurface_GetDesc(pSurface, &Desc);
    D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height;
    PitchAdjust = Rect.Pitch / 4 - Width;

    pData = (LPDWORD)Rect.pBits;

    for (y = 0; y < Height; y++)
    {
        for (x = 0; x < Width; x++)
        {
            *pData++ = D3DCOLOR_ARGB(0, 0, 0, 0);
        }

        pData += PitchAdjust;
    }

    // Draw red circles
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x00FF0000,  70,  40, 32.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x00FF0000, 170,  40, 16.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x00FF0000, 270,  40,  8.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x00FF0000, 370,  40,  4.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x00FF0000, 470,  40,  2.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x00FF0000, 570,  40,  1.0);

    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x00BF0000,  70, 112, 32.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x00BF0000, 170, 112, 16.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x00BF0000, 270, 112,  8.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x00BF0000, 370, 112,  4.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x00BF0000, 470, 112,  2.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x00BF0000, 570, 112,  1.0);

    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x0000FF00,  70, 184, 32.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x0000FF00, 170, 184, 16.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x0000FF00, 270, 184,  8.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x0000FF00, 370, 184,  4.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x0000FF00, 470, 184,  2.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x0000FF00, 570, 184,  1.0);

    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x0000BF00,  70, 256, 32.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x0000BF00, 170, 256, 16.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x0000BF00, 270, 256,  8.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x0000BF00, 370, 256,  4.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x0000BF00, 470, 256,  2.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x0000BF00, 570, 256,  1.0);

    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x000000FF,  70, 328, 32.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x000000FF, 170, 328, 16.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x000000FF, 270, 328,  8.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x000000FF, 370, 328,  4.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x000000FF, 470, 328,  2.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x000000FF, 570, 328,  1.0);

    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x000000BF,  70, 400, 32.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x000000BF, 170, 400, 16.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x000000BF, 270, 400,  8.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x000000BF, 370, 400,  4.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x000000BF, 470, 400,  2.0);
    DrawCircle((LPDWORD)Rect.pBits, Rect.Pitch, 0x000000BF, 570, 400,  1.0);

    D3DSurface_UnlockRect(pSurface); 
}

//==============================================================================
// Helpers to read/write the CRTC and TV encoder registers.
//==============================================================================

/*
 * The list of interesting registers.
 */

const UCHAR g_CRTCMap[] = 
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 
    0x18, 0x19, 0x1A, 0x1B, 0x20, 0x25, 0x2D, 0x33, 
    0x39, 0x41
};

const UCHAR g_TVMap[] =
{
    0x00, 0x02, 0x04, 0x06, 0x2E, 
    0x30, 0x32, 0x34, 0x36, 0x38, 0x3A, 0x3C, 0x3E,
    0x40, 0x42, 0x44, 0x46, 0x48, 0x4A, 0x4C, 0x4E,
    0x50, 0x52, 0x54, 0x56, 0x58, 0x5A, 0x5C, 0x5E,
    0x60, 0x62, 0x64, 0x66, 0x68, 0x6A, 0x6C, 0x6E,
    0x70, 0x72, 0x74, 0x76, 0x78, 0x7A, 0x7C, 0x7E,
    0x80, 0x82, 0x84, 0x86, 0x88, 0x8A, 0x8C, 0x8E,
    0x90, 0x92, 0x94, 0x96, 0x98, 0x9A, 0x9C, 0x9E,
    0xA0, 0xA2, 0xA4, 0xA6, 0xA8, 0xAA, 0xAC, 0xAE,
    0xB0, 0xB2, 0xB4, 0xB6, 0xB8, 0xBA, 0xBC, 0xBE,
    0xC0, 0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xCE,
    0xD0, 0xD2, 0xD4, 0xD6, 0xD8, 0xDA, 0xDC, 0xDE,
    0xE0, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE,
    0xF0, 0xF2, 0xF4, 0xF6, 0xF8, 0xFA, 0xFC, 0xFF
};

/*
 * Copies of the current register state and pending changes.
 */

//----------------------------------------------------------------------------
// Helpers to read/write CRTC and TV encoder registers.
//


// Register base is always at one spot.
#define REGISTER_BASE                ((void *)0xFD000000)

//
// Functions to access hardware registers
//

/* 
 * From smb.c
 */

#define MCPIOBASE   0xC000

extern __inline UCHAR IO_RD08(USHORT address)
{
  UCHAR result;

  __asm {
      mov dx, address;
      in al, dx;
      mov result, al;
  }

  return(result);
}

extern __inline USHORT IO_RD16(USHORT address)
{
  USHORT result;

  __asm {
      mov dx, address;
      in ax, dx;
      mov result, ax;
  }

  return(result);
}

extern __inline void IO_WR08(USHORT address, UCHAR data)
{
  __asm {
      mov dx, address;
      mov al, data;
      out dx, al;
  }
}

extern __inline void IO_WR16(USHORT address, USHORT data)
{
  __asm {
      mov dx, address;
      mov ax, data;
      out dx, ax;
  }
}

#if 1

UCHAR
SMB_RD(VOID * Ptr, UCHAR Reg)
{
    ULONG Value;

    HalReadSMBusByte(TV_ENCODER_ID, Reg, &Value);

    return (UCHAR)Value;
}

VOID
SMB_WR(VOID *Ptr, UCHAR Reg, UCHAR Val)
{
    HalWriteSMBusByte(TV_ENCODER_ID, Reg, Val);
}

USHORT
SMB_RDW(VOID * Ptr, UCHAR Reg)
{
    ULONG Value;

    HalReadSMBusWord(TV_ENCODER_ID, Reg, &Value);

    return (USHORT)Value;
}

VOID
SMB_WRW(VOID *Ptr, UCHAR Reg, USHORT Val)
{
    HalWriteSMBusWord(TV_ENCODER_ID, Reg, Val);
}

#else

#define SmbusReadPortUCHAR(port)           (IO_RD08((USHORT)(MCPIOBASE + port)))
#define SmbusReadPortUSHORT(port)          (IO_RD16((USHORT)(MCPIOBASE + port)))
#define SmbusWritePortUCHAR(port, data)    (IO_WR08((USHORT)(MCPIOBASE + port),(UCHAR)(data)))
#define SmbusWritePortUSHORT(port, data)   (IO_WR16((USHORT)(MCPIOBASE + port),(USHORT)(data)))

// MCP SMB defines
#define MCP_SMB_STATUS                                   0x00000000
#define MCP_SMB_STATUS_HST_STS_BUSY                          (1<<3)
#define MCP_SMB_STATUS_HCYC_STS_ACTIVE                       (1<<4)
#define MCP_SMB_STATUS_HCYC_STS_SUCCESS                      (1<<4)
#define MCP_SMB_STATUS_SM_BSY_BUSY                          (1<<11)

#define MCP_SMB_CTRL                                     0x00000002
#define MCP_SMB_CTRL_CYC_TYPE_RD_WR_BYTE                     (2<<0)
#define MCP_SMB_CTRL_HOST_STC_START                          (1<<3)

#define MCP_SMB_HSTA                                     0x00000004
#define MCP_SMB_HDATA                                    0x00000006
#define MCP_SMB_HCMD                                     0x00000008


// should we add a timeout to the while loop?
void
AvpWaitForSMBusIdle()
{
    volatile USHORT status;

    do {
        status = SmbusReadPortUSHORT(MCP_SMB_STATUS);
    } while (status & (MCP_SMB_STATUS_HST_STS_BUSY |
                       MCP_SMB_STATUS_SM_BSY_BUSY  ));
}



void
AvpReadDeviceReg(
    PVOID RegisterBase,
    UCHAR  SMBaddr,
    UCHAR  Reg,
    UCHAR* ReadData
    )
{
    USHORT status;

    // reset status bits
    status = SmbusReadPortUSHORT(MCP_SMB_STATUS);
    SmbusWritePortUSHORT(MCP_SMB_STATUS, status);    // write 1's to clear

    // load the slave addr, subaddress
    SmbusWritePortUSHORT(MCP_SMB_HSTA,  SMBaddr + 1);
    SmbusWritePortUCHAR(MCP_SMB_HCMD,   Reg);

    // initiate the transfer
    SmbusWritePortUSHORT(MCP_SMB_CTRL, (MCP_SMB_CTRL_CYC_TYPE_RD_WR_BYTE |
                                        MCP_SMB_CTRL_HOST_STC_START));
    AvpWaitForSMBusIdle();

    // return completion status
    status = SmbusReadPortUSHORT(MCP_SMB_STATUS);

    if (status & MCP_SMB_STATUS_HCYC_STS_SUCCESS)
    {
        *ReadData = SmbusReadPortUCHAR(MCP_SMB_HDATA);
    }
}



UCHAR
AvpWriteDeviceReg(
    PVOID  RegisterBase,
    UCHAR SMBaddr,
    UCHAR Reg,
    UCHAR WriteValue
    )
{
    USHORT status;

    // reset status bits
    status = SmbusReadPortUSHORT(MCP_SMB_STATUS);
    SmbusWritePortUSHORT(MCP_SMB_STATUS, status);    // write 1's to clear

    // load the slave addr, subaddress and data
    SmbusWritePortUSHORT(MCP_SMB_HSTA,  SMBaddr);
    SmbusWritePortUCHAR(MCP_SMB_HCMD,   Reg);
    SmbusWritePortUSHORT(MCP_SMB_HDATA, WriteValue);

    // initiate the transfer
    SmbusWritePortUSHORT(MCP_SMB_CTRL, (MCP_SMB_CTRL_CYC_TYPE_RD_WR_BYTE |
                                        MCP_SMB_CTRL_HOST_STC_START));
    AvpWaitForSMBusIdle();

    // return completion status
    status = SmbusReadPortUSHORT(MCP_SMB_STATUS);
    return !(status & MCP_SMB_STATUS_HCYC_STS_SUCCESS);
}

UCHAR
SMB_RD(VOID * Ptr, UCHAR Reg)
{
    UCHAR Value;

    AvpReadDeviceReg(Ptr, TV_ENCODER_ID, Reg, &Value);

    return Value;
}

VOID
SMB_WR(VOID *Ptr, UCHAR Reg, UCHAR Val)
{
    AvpWriteDeviceReg(Ptr, TV_ENCODER_ID, Reg, Val);
}

#endif


VOID
AvpDelay(
    PVOID RegisterBase,
    ULONG nanosec
    )
{
   ULONG start;
   ULONG elapsed;

   volatile ULONG *Timer = (ULONG *)((UCHAR *)RegisterBase + 0x00009400);

   start = *Timer;

   do {
       elapsed = *Timer - start;
   } while (elapsed < nanosec);
}

/*
 * From avp.h.
 */

ULONG
REG_RD32(VOID* Ptr, ULONG Addr)
{
    return *((volatile ULONG*)((UCHAR*)(Ptr) + (Addr)));
}

VOID
REG_WR32(VOID* Ptr, ULONG Addr, ULONG Val)
{
    *((volatile ULONG*)((UCHAR*)(Ptr) + (Addr))) = (ULONG)(Val);
}

VOID
REG_OR32(VOID* Ptr, ULONG Addr, ULONG Val)
{
    ULONG Value;
    
    Value = REG_RD32(Ptr, Addr);
    REG_WR32(Ptr, Addr, Value | Val);
}

UCHAR
REG_RD08(VOID* Ptr, ULONG Addr)
{
    return *((volatile UCHAR*)((UCHAR*)(Ptr) + (Addr)));
}

VOID
REG_WR08(VOID* Ptr, ULONG Addr, UCHAR Val)
{
    *((volatile UCHAR*)((UCHAR*)(Ptr) + (Addr))) = (UCHAR)(Val);
}

VOID
CRTC_WR(VOID* Ptr, UCHAR i, UCHAR d)            
{
    REG_WR08(Ptr, 0x006013d4, (i));
    REG_WR08(Ptr, 0x006013d5, (d));
}

UCHAR
CRTC_RD(VOID* Ptr, UCHAR i)            
{
    UCHAR Value;

    REG_WR08(Ptr, 0x006013d4, (i));
    Value = REG_RD08(Ptr, 0x006013d5);

    return Value;
}

//==============================================================================
// Test table, contains all of the above tests.
//==============================================================================

/*
 * Parsed commands.
 */

ULONG g_Argc;
char *g_Argv[1024];

/*
 * Response.
 */

ULONG g_cchBuffer;
char  g_szBuffer[4096];

/*
 * Test patterns.
 */

typedef void (*COMMAND)(D3DSurface *pSurface, double d, double d2, DWORD Time);

typedef struct _TESTS
{
    COMMAND m_Command;
    char *m_szName;
    char *m_szDescription;
    double m_DefaultValue1;
    double m_DefaultValue2;
    BOOL m_TwoField;
} TESTS;

TESTS g_Tests[] =
{
    { CompositeTest, "co", "composite",                      0.0,   0.0, FALSE },
    { SmpteBars,     "s17","smptebars 100.75",             100.0,  75.0, FALSE },
    { SmpteBars,     "s77","smptebars 75.75",               75.0,  75.0, FALSE },
    { SmpteBars,     "s11","smptebars 100.100",            100.0, 100.0, FALSE },
    { Centering,     "ce", "centering",                      0.0,   0.0, FALSE },
    { VCentering,    "vc", "vertical centering",             0.0,   0.0, FALSE },
    { GreyField,     "g0", "greyfield 0",                    0.0,   0.0, FALSE },
    { GreyField,     "g5", "greyfield 50",                  50.0,   1.0, FALSE },
    { GreyField,     "g1", "greyfield 100",                100.0,   0.0, FALSE },
    { MultiBurst,    "mb",  "multiburst",                    0.0,   0.0, FALSE },
    { MultiPulse,    "mp",  "multipulse",                    0.0,   0.0, FALSE },
    { SinXOverX,     "sx", "(sin x)/x",                      0.0,   0.0, FALSE },
    { CrossHatch,    "cr", "cross hatch <distance = 50>",   50.0,   0.0, FALSE },
    { RedField,      "rf", "redfield <intensity = 100%>",  100.0,   0.0, FALSE },
    { GreenField,    "gf", "greenfield <intensity = 100%>",100.0,   0.0, FALSE },
    { BlueField,     "bf", "bluefield <intensity = 100%>", 100.0,   0.0, FALSE },
    { InterlaceField,"if", "interlace field",                0.0,   0.0, TRUE  },
    { LineInterlace, "li", "line interlace",                 0.0,   0.0, FALSE },
    { LumaRamp,      "lr", "lumaramp",                       0.0,   0.0, FALSE },
    { LumaRamp,      "rr", "red ramp",                       1.0,   0.0, FALSE },
    { LumaRamp,      "gr", "green ramp",                     2.0,   0.0, FALSE },
    { LumaRamp,      "br", "blue ramp",                      3.0,   0.0, FALSE },
    { Circles,       "ci", "circles",                        0.0,   0.0, FALSE },
};

ULONG g_TestPattern;

//----------------------------------------------------------------------------
// Initializes a screen.
//
void
CreateScreen(
    ULONG Screen,
    double Value,
    double Value2
    )
{
    if (g_ScreenOdd)
    {
        D3DSurface_Release(g_ScreenOdd);
        g_ScreenOdd = NULL;
    }

    if (g_ScreenEven)
    {
        D3DSurface_Release(g_ScreenEven);
        g_ScreenEven = NULL;
    }

    D3DDevice_CreateImageSurface(g_Mode.Width, 
                                 g_Mode.Height, 
                                 D3DFMT_LIN_X8R8G8B8, 
                                 &g_ScreenOdd);

    D3DDevice_SetRenderTarget(g_ScreenOdd, NULL);
    D3DDevice_Clear(0, NULL, D3DCLEAR_TARGET, 0xFF000000, 1.0, 0);

    g_Tests[Screen].m_Command(g_ScreenOdd, Value, Value2, 0);

    if (g_Tests[Screen].m_TwoField)
    {
        D3DDevice_CreateImageSurface(g_Mode.Width, 
                                     g_Mode.Height, 
                                     D3DFMT_LIN_X8R8G8B8, 
                                     &g_ScreenEven);

        D3DDevice_SetRenderTarget(g_ScreenEven, NULL);
        D3DDevice_Clear(0, NULL, D3DCLEAR_TARGET, 0xFF000000, 1.0, 0);

        g_Tests[Screen].m_Command(g_ScreenEven, (double)(!(DWORD)Value), 0.0, 0);
    }
    else
    {
        g_ScreenEven = g_ScreenOdd;

        D3DSurface_AddRef(g_ScreenEven);
    }

    memset(g_LineNumber, 0, sizeof(g_LineNumber));
}

//----------------------------------------------------------------------------
// Print helper.
//
void
ResPrintf(
    char* szFormat,
    ...
    )
{
    ULONG cch;
    va_list va;

    va_start(va, szFormat);

    cch = vsprintf(g_szBuffer + g_cchBuffer, szFormat, va);

    g_cchBuffer += cch;

    if (g_cchBuffer >= sizeof(g_szBuffer))
    {
        _asm int 3;
    }

    va_end(va);
}

//----------------------------------------------------------------------------
// Print helper.
//
void 
ResPrintMode(
    ULONG iMode
    )
{
    D3DDISPLAYMODE Mode;
    char *szFormat;

    Direct3D_EnumAdapterModes(0, iMode * 4, &Mode);

    ResPrintf("%d: %dx%d %sat %d Hz (%s)", 
              iMode, 
              Mode.Width, 
              Mode.Height, 
              (Mode.Flags & D3DPRESENTFLAG_10X11PIXELASPECTRATIO) ? "1.1:1 " : "",
              Mode.RefreshRate, 
              (Mode.Flags & D3DPRESENTFLAG_INTERLACED) ? (Mode.Flags & D3DPRESENTFLAG_FIELD) ? "field" : "interlaced" : "progressive");

    if (Mode.Flags & D3DPRESENTFLAG_WIDESCREEN)
    {
        ResPrintf(", 16:9");
    }

    ResPrintf("\r\n");
}

//----------------------------------------------------------------------------
// Change which test is being displayed.
//
void Show()
{
    ULONG i;
    double Value1, Value2;

    i = sizeof(g_Tests) / sizeof(TESTS);

    if (g_Argc == 2 || g_Argc == 3)
    {
        for (i = 0; i < sizeof(g_Tests) / sizeof(TESTS); i++)
        {
            if (!strncmp(g_Tests[i].m_szName, g_Argv[1], strlen(g_Tests[i].m_szName)))
            {
                break;
            }
        }
    }

    if (i == sizeof(g_Tests) / sizeof(TESTS))
    {
        ResPrintf("\r\n!show <test> [<value>]\r\n\r\n");

        for (i = 0; i < sizeof(g_Tests) / sizeof(TESTS); i++)
        {
            ResPrintf("    %3s - %s\r\n", g_Tests[i].m_szName, g_Tests[i].m_szDescription);
        }
    }
    else
    {
        g_TestPattern = i;

        Value1 = g_Tests[i].m_DefaultValue1;
        Value2 = g_Tests[i].m_DefaultValue2;
       
        CreateScreen(i, Value1, Value2);
    }
}

// Helper
char *Enabled(BOOL Value)
{
    if (Value)
    {
        return "enabled";
    }
    else
    {
        return "disabled";
    }
}

//----------------------------------------------------------------------------
// Dump display setting information
//
void Info()
{

#if 1

    ULONG i;

    ULONG htotal, hdisplayend, hblankstart, hblankend, hretracestart, hretraceend;
    ULONG vtotal, vdisplayend, vblankstart, vblankend, vretracestart, vretraceend;

    double pclock, fract;

    ULONG Value;

    /*
     * Main clock
     */

#ifndef FOCUS

    i = SMB_RD(REGISTER_BASE, 0xA0) & 0x1F;
    fract = (double)(((ULONG)SMB_RD(REGISTER_BASE, 0x9E) << 8) | (ULONG)SMB_RD(REGISTER_BASE, 0x9C)) / 65536.0;

    pclock = 13.500 * ((double)i + fract);

    if (SMB_RD(REGISTER_BASE, 0x2A) & 0x02)
    {
        pclock /= 10.0;
    }
    else
    {
        pclock /= 6.0;
    }

    // How precise is the clock?
    pclock = floor(pclock * 1000000.0) / 1000000.0;

    ResPrintf("Clock           - %.6f\r\n\r\n", pclock);

#endif

    /*
     * CRTC 
     */

    // htotal - total # of characters.
    htotal  = CRTC_RD(REGISTER_BASE, 0x00);
    htotal |= (CRTC_RD(REGISTER_BASE, 0x2D) & 0x01) << 8;

    htotal = htotal + 5;

    // hdisplayend - character count of the last displayed character (total - 1)
    hdisplayend  = CRTC_RD(REGISTER_BASE, 0x01);
    hdisplayend |= (CRTC_RD(REGISTER_BASE, 0x2D) & 0x02) << 7;

    // hblankstart - character count of the start of the blank.
    //
    // !!! this is doced to be the same at hdisplayend, but that would imply 
    //    that this value is one before the start of the blank.
    //
    hblankstart  = CRTC_RD(REGISTER_BASE, 0x02);
    hblankstart |= (CRTC_RD(REGISTER_BASE, 0x2D) & 0x04) << 6;

    // hblankend - character count to the end of the blank.
    if (CRTC_RD(REGISTER_BASE, 0x1A) & 0x04)
    {
        hblankend  = hblankstart & 0xFFFFFF80;
        hblankend |= (CRTC_RD(REGISTER_BASE, 0x25) & 0x10) << 2;
    }
    else
    {
        hblankend  = hblankstart & 0xFFFFFFC0;
    }

    hblankend |= (CRTC_RD(REGISTER_BASE, 0x03) & 0x1F);
    hblankend |= (CRTC_RD(REGISTER_BASE, 0x05) & 0x80) >> 2;

    // hretracestart - character count to the start of the retrace.
    hretracestart  = CRTC_RD(REGISTER_BASE, 0x04);
    hretracestart |= (CRTC_RD(REGISTER_BASE, 0x2D) & 0x08) << 5;

    // hretraceend
    hretraceend  = hretracestart & 0xFFFFFFE0;
    hretraceend |= (CRTC_RD(REGISTER_BASE, 0x05) & 0x1F);

    // vtotal
    vtotal  = CRTC_RD(REGISTER_BASE, 0x06);
    vtotal |= (CRTC_RD(REGISTER_BASE, 0x07) & 0x01) << 8;
    vtotal |= (CRTC_RD(REGISTER_BASE, 0x07) & 0x20) << 4;
    vtotal |= (CRTC_RD(REGISTER_BASE, 0x25) & 0x01) << 10;
    //vtotal |= (CRTC_RD(REGISTER_BASE, 0x41) & 0x01) << 11;

    vtotal += 2;

    // vdisplayend
    vdisplayend  = CRTC_RD(REGISTER_BASE, 0x12);
    vdisplayend |= (CRTC_RD(REGISTER_BASE, 0x07) & 0x02) << 7;
    vdisplayend |= (CRTC_RD(REGISTER_BASE, 0x07) & 0x40) << 3;
    vdisplayend |= (CRTC_RD(REGISTER_BASE, 0x25) & 0x02) << 9;
    //vdisplayend |= (CRTC_RD(REGISTER_BASE, 0x41) & 0x04) << 9;

    //vblankstart
    vblankstart  = CRTC_RD(REGISTER_BASE, 0x15);
    vblankstart |= (CRTC_RD(REGISTER_BASE, 0x07) & 0x08) << 5;
    vblankstart |= (CRTC_RD(REGISTER_BASE, 0x09) & 0x20) << 4;
    vblankstart |= (CRTC_RD(REGISTER_BASE, 0x25) & 0x08) << 7;
    //vblankstart |= (CRTC_RD(REGISTER_BASE, 0x41) & 0x40) << 5;
   
    // vblankend
    // --- I have no idea where the high bits come from.  Just use vtotal for now.
    vblankend  = vtotal & 0xFFFFFF00;
    vblankend |= CRTC_RD(REGISTER_BASE, 0x16);

    // retracestart
    vretracestart  = CRTC_RD(REGISTER_BASE, 0x10);
    vretracestart |= (CRTC_RD(REGISTER_BASE, 0x07) & 0x04) << 6;
    vretracestart |= (CRTC_RD(REGISTER_BASE, 0x07) & 0x80) << 2;
    vretracestart |= (CRTC_RD(REGISTER_BASE, 0x25) & 0x04) << 8;
    //vretracestart |= (CRTC_RD(REGISTER_BASE, 0x41) & 0x10) << 7;

    // retraceend
    vretraceend   = vretracestart & 0xFFFFFFF0;
    vretraceend |= CRTC_RD(REGISTER_BASE, 0x11) & 0xF;

    // Show it.
    ResPrintf("CRTC settings:\r\n\r\n");

    ResPrintf("HTOTAL          - %d, programmed as %d\r\n", htotal, htotal - 5);
    ResPrintf("HDISPLAYEND     - %d\r\n", hdisplayend);
    ResPrintf("HBLANKSTART     - %d\r\n", hblankstart);
    ResPrintf("HBLANKEND       - %d\r\n", hblankend);
    ResPrintf("HRETRACESTART   - %d\r\n", hretracestart);
    ResPrintf("HRETRACEEND     - %d\r\n\r\n", hretraceend);

    ResPrintf("VTOTAL          - %d, programmed as %d\r\n", vtotal, vtotal - 2);
    ResPrintf("VDISPLAYEND     - %d\r\n", vdisplayend);
    ResPrintf("VBLANKSTART     - %d\r\n", vblankstart);
    ResPrintf("VBLANKEND       - %d\r\n", vblankend);
    ResPrintf("VRETRACESTART   - %d\r\n", vretracestart);
    ResPrintf("VRETRACEEND     - %d\r\n\r\n", vretraceend);

    ResPrintf("H active        - %d\r\n", (hdisplayend + 1) * 8);
    ResPrintf("H front porch   - %d\r\n", (hretracestart - hdisplayend) * 8);
    ResPrintf("H sync          - %d\r\n", (hretraceend - hretracestart) * 8);
    ResPrintf("H back porch    - %d\r\n", (hblankend - hretraceend) * 8);
    ResPrintf("H blank (f+s+b) - %d\r\n", (hblankend - hblankstart) * 8);
    ResPrintf("H total         - %d\r\n\r\n", htotal * 8);

    ResPrintf("V active        - %d\r\n", vdisplayend + 1);
    ResPrintf("V front porch   - %d\r\n", vretracestart - vdisplayend);
    ResPrintf("V sync          - %d\r\n", vretraceend - vretracestart);
    ResPrintf("V back porch    - %d\r\n", vblankend - vretraceend);
    ResPrintf("V blank (f+s+b) - %d\r\n", vblankend - vblankstart);
    ResPrintf("V total         - %d\r\n", vtotal);

    ResPrintf("\r\n");

    /*
     * FP
     */

    // FP_DEBUG_0
    Value = REG_RD32(REGISTER_BASE, 0x680880);

    ResPrintf("NV_PRAMDAC_FP_DEBUG_0 (0x00680880 = 0x%08X)\r\n\r\n", Value);

    ResPrintf("XSCALE          : %s\r\n", Enabled(Value & 0x00000001));
    ResPrintf("XSCALE_STEP_AUTO: %s\r\n", Enabled(Value & 0x00000004));
    ResPrintf("YSCALE          : %s\r\n", Enabled(Value & 0x00000010));
    ResPrintf("YSCALE_STEP_AUTO: %s\r\n", Enabled(Value & 0x00000010));
    ResPrintf("XINTERP         : %s\r\n", (Value & 0x00000100) ? "bilinear" : "truncate");
    ResPrintf("YINTERP         : %s\r\n", (Value & 0x00001000) ? "bilinear" : "truncate");

    switch(Value & 0x00030000)
    {
    case 0x00000000:
        ResPrintf("VCNTR           : none\r\n");
        break;
    case 0x00010000:
        ResPrintf("VCNTR           : vcntr\r\n");
        break;
    case 0x00020000:
        ResPrintf("VCNTR           : newpix\r\n");
        break;
    case 0x00030000:
        ResPrintf("VCNTR           : both\r\n");
        break;
    }

    ResPrintf("XWEIGHT         : %s\r\n", (Value & 0x00100000) ? "round" : "truncate");
    ResPrintf("YWEIGHT         : %s\r\n", (Value & 0x01000000) ? "round" : "truncate");
    ResPrintf("PWRDOWN         : %s\r\n", (Value & 0x10000000) ? "fpclk" : "none");
    ResPrintf("PWRDOWN_TMDS_PLL: %s\r\n", Enabled(Value & 0x20000000));

    // FP_DEBUG_6
    Value = REG_RD32(REGISTER_BASE, 0x680898);

    ResPrintf("\r\nNV_PRAMDAC_FP_DEBUG_6 (0x00680898 = 0x%08X)\r\n\r\n", Value);

    if (Value == 0x10000000)
    {
        ResPrintf("XSCALE_VALUE    : noscale\r\n");
    }
    else
    {
        ResPrintf("XSCALE_VALUE    : 0x%5X\r\n", Value >> 10);
    }

    // FP_DEBUG_7
    Value = REG_RD32(REGISTER_BASE, 0x68089C);

    ResPrintf("\r\nNV_PRAMDAC_FP_DEBUG_7 (0x0068089C = 0x%08X)\r\n\r\n", Value);

    if (Value == 0x10000000)
    {
        ResPrintf("YSCALE_VALUE    : noscale\r\n");
    }
    else
    {
        ResPrintf("YSCALE_VALUE    : 0x%5X\r\n", Value >> 10);
    }

    // FP_TVO_SETUP
    Value = REG_RD32(REGISTER_BASE, 0x6808C0);

    ResPrintf("\r\nNV_PRAMDAC_FP_TVO_SETUP (0x006808C0 = 0x%08X)\r\n\r\n", Value);

    ResPrintf("TYPE            : %s\r\n", (Value & 0x00000001) ? "master" : "slave");

    switch(Value & 0x00000030)
    {
    case 0x00000000:
        ResPrintf("DATA_FORMAT     : MODE_1X00\r\n");
        break;
    case 0x00000010:
        ResPrintf("DATA_FORMAT     : MODE_0110\r\n");
        break;
    case 0x00000020:
        ResPrintf("DATA_FORMAT     : MODE_0000\r\n");
        break;
    case 0x00000030:
        ResPrintf("DATA_FORMAT     : reserved\r\n");
        break;
    }

    ResPrintf("DATA_OUT        : %s\r\n", (Value & 0x00000100) ? "tvo" : "fp");

    // FP_TVO_BLANK_COLOR
    Value = REG_RD32(REGISTER_BASE, 0x6808C4);

    ResPrintf("\r\nNV_PRAMDAC_FP_TVO_BLANK_COLOR (0x006808C4 = 0x%08X)\r\n\r\n", Value);

    ResPrintf("BLANK_COLOR_VAL : %06X\r\n", (Value & 0x00FFFFFF));
   
    switch(Value & 0xC0000000)
    {
    case 0x00000000:
        ResPrintf("BLANK_COLOR_EN  : default\r\n");
        break;
    case 0x40000000:
        ResPrintf("BLANK_COLOR_EN  : undefined\r\n");
        break;
    case 0x80000000:
        ResPrintf("BLANK_COLOR_EN  : blank\r\n");
        break;
    case 0xC0000000:
        ResPrintf("BLANK_COLOR_EN  : always\r\n");
        break;
    }

    // FP_INACTIVE_PXL_COLOR
    Value = REG_RD32(REGISTER_BASE, 0x68084C);

    ResPrintf("\r\nNV_PRAMDAC_FP_INACTIVE_PXL_COLOR (0x0068084C = 0x%08X)\r\n", Value);

    // COMPOSITE
    Value = REG_RD32(REGISTER_BASE, 0x680630);

    ResPrintf("\r\nNV_PRAMDAC_COMPOSITE (0x00680630 = 0x%08X)\r\n\r\n", Value);

    switch(Value & 0x3)
    {
    case 0:
        ResPrintf("COMPOSITE_MODE  : RGB\r\n");
        break;
    case 1:
        ResPrintf("COMPOSITE_MODE  : reserved\r\n");
        break;
    case 2:
        ResPrintf("COMPOSITE_MODE  : YCrCb_601\r\n");
        break;
    case 3:
        ResPrintf("COMPOSITE_MODE  : YCrCb_709\r\n");
        break;
    }

    // TG_CONTROL
    Value = REG_RD32(REGISTER_BASE, 0x680848);

    ResPrintf("\r\nNV_PRAMDAC_FP_TG_CONTROL (0x00680848 = 0x%08X)\r\n\r\n", Value);

    switch(Value & 0x3)
    {
    case 0x0:
        ResPrintf("VSYNC           : neg\r\n");
        break;
    case 0x1:
        ResPrintf("VSYNC           : pos\r\n");
        break;
    case 0x2:
        ResPrintf("VSYNC           : disabled\r\n");
        break;
    case 0x3:
        ResPrintf("VSYNC           : reserved\r\n");
        break;
    }

    switch(Value & 0x30)
    {
    case 0x00:
        ResPrintf("HSYNC           : neg\r\n");
        break;
    case 0x10:
        ResPrintf("HSYNC           : pos\r\n");
        break;
    case 0x20:
        ResPrintf("HSYNC           : disabled\r\n");
        break;
    case 0x30:
        ResPrintf("HSYNC           : reserved\r\n");
        break;
    }

    switch(Value & 0x300)
    {
    case 0x000:
        ResPrintf("MODE            : scale\r\n");
        break;
    case 0x100:
        ResPrintf("MODE            : center\r\n");
        break;
    case 0x200:
        ResPrintf("MODE            : native\r\n");
        break;
    case 0x300:
        ResPrintf("MODE            : undefined\r\n");
        break;
    }

    switch(Value & 0x3000)
    {
    case 0x0000:
        ResPrintf("CENTER          : none\r\n");
        break;
    case 0x1000:
        ResPrintf("CENTER          : horizontal\r\n");
        break;
    case 0x2000:
        ResPrintf("CENTER          : vertical\r\n");
        break;
    case 0x3000:
        ResPrintf("CENTER          : both\r\n");
        break;
    }

    switch(Value & 0x30000)
    {
    case 0x00000:
        ResPrintf("NATIVE          : none\r\n");
        break;
    case 0x10000:
        ResPrintf("NATIVE          : horizontal\r\n");
        break;
    case 0x20000:
        ResPrintf("NATIVE          : vertical\r\n");
        break;
    case 0x30000:
        ResPrintf("NATIVE          : both\r\n");
        break;
    }

    ResPrintf("READ            : %s\r\n", (Value & 0x00100000) ? "prog" : "actual");
    ResPrintf("WIDTH           : %s\r\n", (Value & 0x01000000) ? "12" : "24");
    
    switch(Value & 0x30000000)
    {
    case 0x0000000:
        ResPrintf("DISPEN          : neg\r\n");
        break;
    case 0x10000000:
        ResPrintf("DISPEN          : pos\r\n");
        break;
    case 0x20000000:
        ResPrintf("DISPEN          : disabled\r\n");
        break;
    case 0x30000000:
        ResPrintf("DISPEN          : reserved\r\n");
        break;
    }

    ResPrintf("FPCLK_RATIO     : %s\r\n", (Value & 0x80000000) ? "db2" : "db2");


    // Display values.

    ResPrintf("\r\n");
    ResPrintf("HDISPLAY_END (0x00680820) : %d (0x%X)\r\n", REG_RD32(REGISTER_BASE, 0x680820), REG_RD32(REGISTER_BASE, 0x680820));
    ResPrintf("HTOTAL       (0x00680824) : %d (0x%X)\r\n", REG_RD32(REGISTER_BASE, 0x680824), REG_RD32(REGISTER_BASE, 0x680824));
    ResPrintf("HCRTC        (0x00680828) : %d (0x%X)\r\n", REG_RD32(REGISTER_BASE, 0x680828), REG_RD32(REGISTER_BASE, 0x680828));
    ResPrintf("HSYNC_START  (0x0068082C) : %d (0x%X)\r\n", REG_RD32(REGISTER_BASE, 0x68082C), REG_RD32(REGISTER_BASE, 0x68082C));
    ResPrintf("HSYNC_END    (0x00680830) : %d (0x%X)\r\n", REG_RD32(REGISTER_BASE, 0x680830), REG_RD32(REGISTER_BASE, 0x680830));
    ResPrintf("HVALID_START (0x00680834) : %d (0x%X)\r\n", REG_RD32(REGISTER_BASE, 0x680834), REG_RD32(REGISTER_BASE, 0x680834));
    ResPrintf("HVALID_END   (0x00680838) : %d (0x%X)\r\n", REG_RD32(REGISTER_BASE, 0x680838), REG_RD32(REGISTER_BASE, 0x680838));
    ResPrintf("\r\n");
    ResPrintf("VDISPLAY_END (0x00680800) : %d (0x%X)\r\n", REG_RD32(REGISTER_BASE, 0x680800), REG_RD32(REGISTER_BASE, 0x680800));
    ResPrintf("VTOTAL       (0x00680804) : %d (0x%X)\r\n", REG_RD32(REGISTER_BASE, 0x680804), REG_RD32(REGISTER_BASE, 0x680804));
    ResPrintf("VCRTC        (0x00680808) : %d (0x%X)\r\n", REG_RD32(REGISTER_BASE, 0x680808), REG_RD32(REGISTER_BASE, 0x680808));
    ResPrintf("VSYNC_START  (0x0068080C) : %d (0x%X)\r\n", REG_RD32(REGISTER_BASE, 0x68080C), REG_RD32(REGISTER_BASE, 0x68080C));
    ResPrintf("VSYNC_END    (0x00680810) : %d (0x%X)\r\n", REG_RD32(REGISTER_BASE, 0x680810), REG_RD32(REGISTER_BASE, 0x680810));
    ResPrintf("VVALID_START (0x00680814) : %d (0x%X)\r\n", REG_RD32(REGISTER_BASE, 0x680814), REG_RD32(REGISTER_BASE, 0x680814));
    ResPrintf("VVALID_END   (0x00680818) : %d (0x%X)\r\n", REG_RD32(REGISTER_BASE, 0x680818), REG_RD32(REGISTER_BASE, 0x680818));

#ifndef FOCUS

    /*
     * TV encoder
     */

    ResPrintf("\r\n");

    Value = SMB_RD(REGISTER_BASE, 0x78)
            | ((SMB_RD(REGISTER_BASE, 0x86) & 0x70) << 4);

    ResPrintf("H_ACTIVE                  : %d (0x%X)\r\n", Value, Value);

    Value = SMB_RD(REGISTER_BASE, 0x8C)
            | ((SMB_RD(REGISTER_BASE, 0x8E) & 0x08) << 5)
            | ((SMB_RD(REGISTER_BASE, 0x38) & 0x01) << 9);

    ResPrintf("H_BLANKI                  : %d (0x%X)\r\n", Value, Value);

    Value = SMB_RD(REGISTER_BASE, 0x80)
            | ((SMB_RD(REGISTER_BASE, 0x9A) & 0xC0) << 2);

    ResPrintf("H_BLANK0                  : %d (0x%X)\r\n", Value, Value);

    Value = SMB_RD(REGISTER_BASE, 0x8A)
            | ((SMB_RD(REGISTER_BASE, 0x8e) & 0x07) << 8);

    ResPrintf("H_CLKI                    : %d (0x%X)\r\n", Value, Value);

    Value = SMB_RD(REGISTER_BASE, 0x76)
            | ((SMB_RD(REGISTER_BASE, 0x86) & 0x0F) << 8);

    ResPrintf("H_CLKO                    : %d (0x%X)\r\n", Value, Value);

    ResPrintf("\r\n");

    Value = SMB_RD(REGISTER_BASE, 0x94)
            | ((SMB_RD(REGISTER_BASE, 0x96) & 0x0C) << 6);

    ResPrintf("V_ACTIVE (input)          : %d (0x%X)\r\n", Value, Value);

    Value = SMB_RD(REGISTER_BASE, 0x84)
            | ((SMB_RD(REGISTER_BASE, 0x86) & 0x80) << 1);

    ResPrintf("V_ACTIVEO                 : %d (0x%X)\r\n", Value, Value);

    Value = SMB_RD(REGISTER_BASE, 0x92);

    ResPrintf("V_BLANKI                  : %d (0x%X)\r\n", Value, Value);

    Value = SMB_RD(REGISTER_BASE, 0x82);

    ResPrintf("V_BLANKO (# blank + 1)    : %d (0x%X)\r\n", Value, Value);

    Value = SMB_RD(REGISTER_BASE, 0x90)
            | ((SMB_RD(REGISTER_BASE, 0x96) & 0x3) << 8)
            | ((SMB_RD(REGISTER_BASE, 0x38) & 0x2) << 9);

    ResPrintf("V_LINESI                  : %d (0x%X)\r\n", Value, Value);

    Value = SMB_RD(REGISTER_BASE, 0x98)
            | ((SMB_RD(REGISTER_BASE, 0x9A) & 0x1F) << 8);

    ResPrintf("V_SCALE                   : %d (0x%X)\r\n", Value, Value);

#endif

#endif 0

}

//----------------------------------------------------------------------------
// Change/display the graphics mode.
//
BOOL Mode()
{
    ULONG i, c;
    BOOL retval;

    c = Direct3D_GetAdapterModeCount(0) / 4;

    if (g_Argc != 2 || strcmp(g_Argv[1], "+") && !isdigit(*g_Argv[1]))
    {
        ResPrintf("\r\n!m [<mode to set>]\r\n\r\n");
        ResPrintf("    + - advance to next mode\r\n\r\n");

        for (i = 0; i < c; i++)
        {
            ResPrintf("    ");
            ResPrintMode(i);
        }
        
        retval = FALSE;
    }
    else 
    {
        if (!strcmp(g_Argv[1], "+"))
        {
            g_iMode = (g_iMode + 1) % c;
        }
        else
        {
            g_iMode = atoi(g_Argv[1]) % c;
        }

        retval = TRUE;
    }

    return retval;
}

//----------------------------------------------------------------------------
// Change the current AV pack.
//
BOOL AvPack()
{
    ULONG c;
    BOOL retval;

    if (g_Argc != 2 || strcmp(g_Argv[1], "+") && !isdigit(*g_Argv[1]))
    {
        ResPrintf("\r\n!a [<av pack to set>]\r\n\r\n");
        ResPrintf("    + - advance to next pack\r\n\r\n");
        ResPrintf("    1: Standard\r\n");
        ResPrintf("    2: RFU\r\n");
        ResPrintf("    3: SCART\r\n");
        ResPrintf("    4: HDTV\r\n");
        ResPrintf("    5: VGA\r\n");
        ResPrintf("    6: SVIDEO\r\n");

        retval = FALSE;
    }
    else
    {
        D3D__AvInfo &= 0xFFFFFF00;

        if (!strcmp(g_Argv[1], "+"))
        {
            c = D3D__AvInfo & 0xFF;

            D3D__AvInfo |= (c + 1) % AV_PACK_MAX;
        }
        else
        {
            D3D__AvInfo |= atoi(g_Argv[1]) % AV_PACK_MAX;
        }

        // Skip bad modes.
        c = D3D__AvInfo & 0xFF;

        if (c == 0)
        {
            D3D__AvInfo++;
        }

        g_iMode = 0;
        retval = TRUE;
    }

    return retval;
}

BOOL Standard()
{
    ULONG c;
    BOOL retval;

    if (g_Argc != 2 || strcmp(g_Argv[1], "+") && !isdigit(*g_Argv[1]))
    {
        ResPrintf("\r\n!r [<region to set>]\r\n\r\n");
        ResPrintf("    + - advance to next standard\r\n\r\n");
        ResPrintf("    1: NTSC-M\r\n");
        ResPrintf("    2: NSTC-J\r\n");
        ResPrintf("    3: PAL-I\r\n");
        ResPrintf("    4: PAL-M\r\n");

        retval = FALSE;
    }
    else
    {
        D3D__AvInfo &= 0xFFFF00FF;

        if (!strcmp(g_Argv[1], "+"))
        {
            c = (D3D__AvInfo & 0xFF00) >> 8;

            D3D__AvInfo |= ((c + 1) % AV_STANDARD_MAX) << 8;
        }
        else
        {
            D3D__AvInfo |= (atoi(g_Argv[1]) % AV_STANDARD_MAX) << 8;
        }

        // Remove unsupported modes.
        c = D3D__AvInfo & 0xFF00;

        if (c == 0)
        {
            D3D__AvInfo += 0x100;
        }

        // Set to the default refresh rate.
        c = D3D__AvInfo & 0xFF00;

        if (c == AV_STANDARD_PAL_I)
        {
            D3D__AvInfo = (D3D__AvInfo & ~AV_REFRESH_MASK) | AV_FLAGS_50Hz;
        }
        else
        {
            D3D__AvInfo = (D3D__AvInfo & ~AV_REFRESH_MASK) | AV_FLAGS_60Hz;
        }

        g_iMode = 0;
        retval = TRUE;
    }

    return retval;
}

void Change()
{
    ULONG Register;
    ULONG Value;
    ULONG Active, FrontPorch, Sync, BackPorch;
    ULONG Total, DisplayEnd, BlankStart, BlankEnd, RetraceStart, RetraceEnd;

    if (g_Argc < 4)
    {
ChangeUsage:
        ResPrintf("\r\n!c <type> <parameters>\r\n\r\n");
        ResPrintf("    * Register numbers are always in hex, value is either hex (0x...) or decimal.\r\n\r\n");
        ResPrintf("    crtc <register number> <value>\r\n");
        ResPrintf("    tv <register number> <value>\r\n");
        ResPrintf("    reg <register number> <value>\r\n\r\n");

        ResPrintf("    vcrtctime <active> <front porch> <sync> <back porch>\r\n");
        ResPrintf("    hcrtctime <active> <front porch> <sync> <back porch>\r\n");
    }
    else
    {
        if (!strcmp(g_Argv[1], "crtc"))
        {
            Register = strtoul(g_Argv[2], NULL, 16);
            Value    = strtoul(g_Argv[3], NULL, 0);

            CRTC_WR(REGISTER_BASE, (UCHAR)Register, (UCHAR)Value);
            ResPrintf("CR%02X = 0x%02X\r\n", Register, Value);
        }
        else if (!strcmp(g_Argv[1], "reg"))
        {
            Register = strtoul(g_Argv[2], NULL, 16);
            Value    = strtoul(g_Argv[3], NULL, 0);

            REG_WR32(REGISTER_BASE, Register, Value);
            ResPrintf("Register 0x%08X = 0x%08X\r\n", Register, Value);
        }
        else if (!strcmp(g_Argv[1], "tv"))
        {
            Register = strtoul(g_Argv[2], NULL, 16);
            Value    = strtoul(g_Argv[3], NULL, 0);

            SMB_WR(REGISTER_BASE, (UCHAR)Register, (UCHAR)Value);
            ResPrintf("TV%02X = 0x%02X\r\n", Register, Value);
        }
        else if (!strcmp(g_Argv[1], "vcrtctime"))
        {
            if (g_Argc != 6)
            {
                goto ChangeUsage;
            }

            Active     = strtoul(g_Argv[2], NULL, 0);
            FrontPorch = strtoul(g_Argv[3], NULL, 0);
            Sync       = strtoul(g_Argv[4], NULL, 0);
            BackPorch  = strtoul(g_Argv[5], NULL, 0);
            
            Total        = Active + FrontPorch + Sync + BackPorch;
            DisplayEnd   = Active;
            BlankStart   = Active;
            BlankEnd     = Active + FrontPorch + Sync + BackPorch;
            RetraceStart = Active + FrontPorch;
            RetraceEnd   = RetraceStart + Sync;

            // vtotal is # of lines - 2.
            Total -= 2;

            CRTC_WR(REGISTER_BASE, 0x06, (UCHAR)(Total & 0xFF));
            CRTC_WR(REGISTER_BASE, 0x07, (CRTC_RD(REGISTER_BASE, 0x07) & ~0x01) | (((UCHAR)(Total >> 8) & 0x01) << 0));
            CRTC_WR(REGISTER_BASE, 0x07, (CRTC_RD(REGISTER_BASE, 0x07) & ~0x20) | (((UCHAR)(Total >> 9) & 0x01) << 5));
            CRTC_WR(REGISTER_BASE, 0x25, (CRTC_RD(REGISTER_BASE, 0x25) & ~0x01) | (((UCHAR)(Total >> 10) & 0x01) << 0));
            CRTC_WR(REGISTER_BASE, 0x41, (CRTC_RD(REGISTER_BASE, 0x41) & ~0x01) | (((UCHAR)(Total >> 11) & 0x01) << 0));

            DisplayEnd -= 1;

            CRTC_WR(REGISTER_BASE, 0x12, (UCHAR)DisplayEnd & 0xFF);
            CRTC_WR(REGISTER_BASE, 0x07, (CRTC_RD(REGISTER_BASE, 0x07) & ~0x02) | (((UCHAR)(DisplayEnd >> 8) & 0x01) << 1));
            CRTC_WR(REGISTER_BASE, 0x07, (CRTC_RD(REGISTER_BASE, 0x07) & ~0x40) | (((UCHAR)(DisplayEnd >> 9) & 0x01) << 6));
            CRTC_WR(REGISTER_BASE, 0x25, (CRTC_RD(REGISTER_BASE, 0x25) & ~0x02) | (((UCHAR)(DisplayEnd >> 10) & 0x01) << 1));
            CRTC_WR(REGISTER_BASE, 0x41, (CRTC_RD(REGISTER_BASE, 0x41) & ~0x04) | (((UCHAR)(DisplayEnd >> 11) & 0x01) << 2));

            BlankStart -= 1;

            CRTC_WR(REGISTER_BASE, 0x15, (UCHAR)BlankStart & 0xFF);
            CRTC_WR(REGISTER_BASE, 0x07, (CRTC_RD(REGISTER_BASE, 0x07) & ~0x08) | (((UCHAR)(BlankStart >> 8) & 0x01) << 3));
            CRTC_WR(REGISTER_BASE, 0x09, (CRTC_RD(REGISTER_BASE, 0x09) & ~0x20) | (((UCHAR)(BlankStart >> 9) & 0x01) << 5));
            CRTC_WR(REGISTER_BASE, 0x25, (CRTC_RD(REGISTER_BASE, 0x25) & ~0x08) | (((UCHAR)(BlankStart >> 10) & 0x01) << 3));
            CRTC_WR(REGISTER_BASE, 0x41, (CRTC_RD(REGISTER_BASE, 0x41) & ~0x40) | (((UCHAR)(BlankStart >> 11) & 0x01) << 6));

            BlankEnd -= 1;

            CRTC_WR(REGISTER_BASE, 0x16, (UCHAR)BlankEnd & 0xFF);

            RetraceStart -= 1;

            CRTC_WR(REGISTER_BASE, 0x10, (UCHAR)RetraceStart & 0xFF);
            CRTC_WR(REGISTER_BASE, 0x07, (CRTC_RD(REGISTER_BASE, 0x07) & ~0x04) | (((UCHAR)(RetraceStart >> 8) & 0x01) << 2));
            CRTC_WR(REGISTER_BASE, 0x07, (CRTC_RD(REGISTER_BASE, 0x07) & ~0x80) | (((UCHAR)(RetraceStart >> 9) & 0x01) << 7));
            CRTC_WR(REGISTER_BASE, 0x25, (CRTC_RD(REGISTER_BASE, 0x25) & ~0x04) | (((UCHAR)(RetraceStart >> 10) & 0x01) << 2));
            CRTC_WR(REGISTER_BASE, 0x41, (CRTC_RD(REGISTER_BASE, 0x41) & ~0x10) | (((UCHAR)(RetraceStart >> 11) & 0x01) << 4));

            RetraceEnd -= 1;

            CRTC_WR(REGISTER_BASE, 0x11, (CRTC_RD(REGISTER_BASE, 0x11) & ~0x0F) | (((UCHAR)(RetraceEnd >> 0) & 0x0F) << 0));
        }
        else if (!strcmp(g_Argv[1], "hcrtctime"))
        {
            if (g_Argc != 6)
            {
                goto ChangeUsage;
            }

            Active     = strtoul(g_Argv[2], NULL, 0);
            FrontPorch = strtoul(g_Argv[3], NULL, 0);
            Sync       = strtoul(g_Argv[4], NULL, 0);
            BackPorch  = strtoul(g_Argv[5], NULL, 0);
            
            Total        = Active + FrontPorch + Sync + BackPorch;
            DisplayEnd   = Active;
            BlankStart   = Active;
            BlankEnd     = Active + FrontPorch + Sync + BackPorch;
            RetraceStart = Active + FrontPorch;
            RetraceEnd   = RetraceStart + Sync;

            Total = Total / 8 - 5;

            CRTC_WR(REGISTER_BASE, 0x00, (UCHAR)(Total & 0xFF));
            CRTC_WR(REGISTER_BASE, 0x2D, (CRTC_RD(REGISTER_BASE, 0x2D) & ~0x01) | (((UCHAR)(Total >> 8) & 0x01) << 0));

            DisplayEnd = DisplayEnd / 8 - 1;

            CRTC_WR(REGISTER_BASE, 0x01, (UCHAR)DisplayEnd & 0xFF);
            CRTC_WR(REGISTER_BASE, 0x2D, (CRTC_RD(REGISTER_BASE, 0x2D) & ~0x02) | (((UCHAR)(DisplayEnd >> 8) & 0x01) << 1));

            BlankStart = BlankStart / 8 - 1;

            CRTC_WR(REGISTER_BASE, 0x02, (UCHAR)BlankStart & 0xFF);
            CRTC_WR(REGISTER_BASE, 0x2D, (CRTC_RD(REGISTER_BASE, 0x2D) & ~0x04) | (((UCHAR)(BlankStart >> 8) & 0x01) << 2));

            BlankEnd = BlankEnd / 8 - 1;

            CRTC_WR(REGISTER_BASE, 0x03, (CRTC_RD(REGISTER_BASE, 0x03) & ~0x1F) | (((UCHAR)(BlankEnd >> 0) & 0x1F) << 0));
            CRTC_WR(REGISTER_BASE, 0x05, (CRTC_RD(REGISTER_BASE, 0x05) & ~0x80) | (((UCHAR)(BlankEnd >> 5) & 0x1F) << 7));

            if (CRTC_RD(REGISTER_BASE, 0x1A) & 0x04)
            {
                CRTC_WR(REGISTER_BASE, 0x25, (CRTC_RD(REGISTER_BASE, 0x25) & ~0x10) | (((UCHAR)(BlankEnd >> 6) & 0x01) << 4));
            }

            RetraceStart = RetraceStart / 8 - 1;

            CRTC_WR(REGISTER_BASE, 0x04, (UCHAR)RetraceStart & 0xFF);
            CRTC_WR(REGISTER_BASE, 0x2D, (CRTC_RD(REGISTER_BASE, 0x2D) & ~0x08) | (((UCHAR)(RetraceStart >> 8) & 0x01) << 3));

            RetraceEnd = RetraceEnd / 8 - 1;

            CRTC_WR(REGISTER_BASE, 0x05, (CRTC_RD(REGISTER_BASE, 0x05) & ~0x1F) | (((UCHAR)(RetraceEnd >> 0) & 0x1F) << 0));
        }
        else
        {
            goto ChangeUsage;
        }
    }
}

void Dump()
{

#if 0

    SMB_RD(REGISTER_BASE, 4);

#else

    ULONG i;

    for (i = 0; i < sizeof(g_CRTCMap); i++)
    {
        ResPrintf("CR%02X = %02X\r\n", g_CRTCMap[i], CRTC_RD(REGISTER_BASE, g_CRTCMap[i]));
    }

    ResPrintf("\r\n");

#ifndef FOCUS

    for (i = 0; i < sizeof(g_TVMap); i++)
    {
        ResPrintf("TV%02X = %02X\r\n", g_TVMap[i], SMB_RD(REGISTER_BASE, g_TVMap[i]));
    }

#else

    for (i = 0; i < 0xBE; i++)
    {
        ResPrintf("TV%02X = %02X\r\n", i, SMB_RD(REGISTER_BASE, (UCHAR)i));
    }


#endif

#endif 0

}

void Macrovision()
{
    ULONG Value;
    ULONG Results;

    if (g_Argc != 2 || !isdigit(*g_Argv[1]))
    {
        ResPrintf("!v <mode>\r\n\r\n");
        ResPrintf("    0: off\r\n");
        ResPrintf("    1: AGC\r\n");
        ResPrintf("    2: two stripes plus AGC\r\n");
        ResPrintf("    3: four stripes plus AGC\r\n");
    }
    else
    {
        Value = atoi(g_Argv[1]);

        D3DDevice_BlockUntilVerticalBlank();
        AvSendTVEncoderOption(REGISTER_BASE, AV_OPTION_MACROVISION_MODE, Value, &Results);

        D3DDevice_BlockUntilVerticalBlank();
        AvSendTVEncoderOption(REGISTER_BASE, AV_OPTION_MACROVISION_COMMIT, Value, &Results);
    }
}

void OverscanColor()
{
    ULONG Value;
    ULONG Results;

    if (g_Argc != 2 || !isdigit(*g_Argv[1]))
    {
        ResPrintf("!l <color>\r\n\r\n");
    }
    else
    {
        Value = strtoul(g_Argv[1], NULL, 16);

        D3DDevice_SetOverscanColor(Value);
        Value = D3DDevice_GetOverscanColor();

        ResPrintf("Color = 0x%08X\r\n", Value);
    }
}

void FlickerFilter()
{
    ULONG Value;
    ULONG Results;

    if (g_Argc != 2 || !isdigit(*g_Argv[1]))
    {
        ResPrintf("!v <mode>\r\n\r\n");
        ResPrintf("    0: off\r\n");
        ResPrintf("    1 - 4: # of taps\r\n");
        ResPrintf("    5: adaptive\r\n");
    }
    else
    {
        Value = atoi(g_Argv[1]);

        if (Value > 6)
        {

            Value = 5;
        }

        D3DDevice_SetFlickerFilter(Value);
    }
}

//----------------------------------------------------------------------------
// Parse a command string into its little subparts.
//
char *ParseCommand(
    char *szCommand
    )
{
    char **szArgv;
    char *szMax;
    char *szNext;

    unsigned i, c, to;

    g_Argc = 0;
    memset(g_Argv, 0, sizeof(g_Argv));

    if (!szCommand)
    {
        return NULL;
    }

    // Skip over the prefix.
    szCommand++;

    // Lowercase and whack backspaces.
    c  = strlen(szCommand);
    to = 0;

    for (i = 0; i < c; i++)
    {
        if (szCommand[i] == 0x08)
        {
            if (to)
            {
                to--;
            }
        }
        else if (szCommand[i] == '!')
        {
            break;
        }
        else
        {
            szCommand[to] = (char)tolower(szCommand[i]);
            to++;
        }
    }

    // Do we have multiple commands?
    if (i < c)
    {
        szNext = szCommand + i;
    }
    else
    {
        szNext = NULL;
    }

    // Remember the end.
    szMax = szCommand + to;

    // Walk the commands, splitting each one out.
    szArgv = g_Argv;

    for (; szCommand < szMax; szCommand++)
    {
        if (iswspace(*szCommand))
        {
            if (*szArgv)
            {
                *szCommand = 0;
                szArgv++;
            }
        }
        else
        {
            if (!*szArgv)
            {
                *szArgv = szCommand;
            }
        }
    }

    if (*szArgv)
    {
        *szCommand = 0;
        szArgv++;
    }

    g_Argc = szArgv - g_Argv;

    return szNext;
}

//----------------------------------------------------------------------------
// Output handler.  Called by the debug monitor to dump our text buffer.
//
HRESULT __stdcall 
RXCmdCont(
    PDM_CMDCONT pdmcc, 
    LPSTR szResponse, 
    DWORD cchResponse
    )
{
    pdmcc->DataSize = g_cchBuffer;
    g_cchBuffer = 0;

    if (pdmcc->DataSize)
    {
        return XBDM_NOERR;
    }
    else
    {
        return XBDM_ENDOFLIST;  
    }
}

//----------------------------------------------------------------------------
// Input handler.  This gets called by the debug monitor to have us process
// a command.
//
#define COMMAND_PREFIX  ""

HRESULT __stdcall 
RXCmdProcessorProc(
    LPCSTR szConstCommand, 
    LPSTR szResp,
    DWORD cchResp, 
    PDM_CMDCONT pdmcc
    )
{    
    BOOL ResetDisplay;
    D3DPRESENT_PARAMETERS d3dpp;

    ULONG i, c;
    ULONG Results;
    UCHAR Value;

    ULONG Red, Green, Blue;

    char *szCommand;

    ResetDisplay = FALSE;
    szCommand = (char *)szConstCommand;

    EnterCriticalSection(&g_Mutex);

    while (szCommand)
    {
        szCommand = ParseCommand(szCommand);

        if (!g_Argc)
        {
            continue;
        }

        // parse the command.
        switch (*g_Argv[0])
        {
        case 'e':

            D3D__AvInfo = 0;

            g_iMode = 0;
            ResetDisplay = TRUE;

            break;

        case 's':

            Show();
            break;

        case 'm':

            ResetDisplay = Mode();
            break;

        case 'a':

            ResetDisplay = AvPack();
            break;

        case 't':

            ResetDisplay = Standard();
            break;

        case 'w':

            if (D3D__AvInfo & AV_FLAGS_WIDESCREEN)
            {
                D3D__AvInfo &= ~AV_FLAGS_WIDESCREEN;
            }
            else
            {
                D3D__AvInfo |= AV_FLAGS_WIDESCREEN;
            }

            g_iMode = 0;
            ResetDisplay = TRUE;

            break;

        case 'o':

            g_Overlay = !g_Overlay;
            break;

        case 'h':

            if (g_Argc != 2 || !isdigit(*g_Argv[1]))
            {
                ResPrintf("\r\n!h [<mode bits>]\r\n\r\n");
                ResPrintf("    ** use !? for general command help **\r\n\r\n");
                ResPrintf("    bit 1: 720p\r\n");
                ResPrintf("    bit 2: 1080i\r\n");
                ResPrintf("    bit 3: 480i\r\n");
            }
            else
            {
                D3D__AvInfo &= ~AV_HDTV_MODE_MASK;

                D3D__AvInfo |= (atoi(g_Argv[1]) & 0x7) << 17;
            }

            g_iMode = 0;
            ResetDisplay = TRUE;

            break;

        case 'p':

            if (D3D__AvInfo & AV_FLAGS_50Hz)
            {
                if (D3D__AvInfo & AV_FLAGS_60Hz)
                {
                    D3D__AvInfo &= ~AV_FLAGS_60Hz;
                }
                else
                {
                    D3D__AvInfo |= AV_FLAGS_60Hz;
                }
            }

            g_iMode = 0;
            ResetDisplay = TRUE;

            break;

        case 'i':

            Info();
            break;

        case 'c':

            Change();
            break;

        case 'd':

            Dump();
            break;

        case 'v':

            Macrovision();
            break;

        case 'l':
   
            OverscanColor();
            break;

        case 'f':

            FlickerFilter();
            break;

        case 'j':

            if (g_Argc != 2 || !isdigit(*g_Argv[1]))
            {
                ResPrintf("\r\n!j <percent>\r\n\r\n");
            }
            else
            {
                g_SweepAttenuation = (double)atoi(g_Argv[1]) / 100;
            }

            break;

        default:

            ResPrintf("\r\n!<command> <parameters>\r\n\r\n");
            ResPrintf("    '!<command> help' for command-specific usage.\r\n\r\n");
            ResPrintf("    d[e]tect    - detect the current AV pack\r\n");
            ResPrintf("    [s]how      - display a new test pattern\r\n");
            ResPrintf("    [m]ode      - set/view video modes\r\n");
            ResPrintf("    [a]vpack    - set/view video packs\r\n");
            ResPrintf("    s[t]andard  - set/view video standard\r\n");
            ResPrintf("    [w]ide      - toggle widescreen support\r\n");
            ResPrintf("    [h]dtv      - set supported HDTV modes\r\n");
            ResPrintf("    [p]al60     - toggle pal-60 support, must be in PAL-I mode\r\n");
            ResPrintf("    [i]nfo      - dump CRTC and tv encoder information\r\n");
            ResPrintf("    [c]hange    - change the value of a crtc or tv encoder register\r\n");
            ResPrintf("    [d]ump      - dump register values\r\n");
            ResPrintf("    macro[v]ion - set the macrovision mode\r\n");
            ResPrintf("    [o]verlay   - toggle the overlay\r\n");
            ResPrintf("    [f]licker   - set flicker filter\r\n");
            ResPrintf("    add[j]ust   - set sweep adjuement (%)\r\n");
            ResPrintf("    co[l]or     - set the overscan color\r\n");

            break;
        }
    }

    if (ResetDisplay)
    {
        Direct3D_EnumAdapterModes(0, g_iMode * 4, &g_Mode);

        ZeroMemory(&d3dpp, sizeof(d3dpp));

        d3dpp.BackBufferWidth            = g_Mode.Width;
        d3dpp.BackBufferHeight           = g_Mode.Height;
        d3dpp.BackBufferFormat           = g_Mode.Format;
        d3dpp.Flags                      = g_Mode.Flags;
        d3dpp.BackBufferCount            = 1;
        d3dpp.EnableAutoDepthStencil     = TRUE;
        d3dpp.AutoDepthStencilFormat     = D3DFMT_D24S8;
        d3dpp.FullScreen_RefreshRateInHz = g_Mode.RefreshRate;
        //d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_TWO;

        // Clear out any cached modes.
        //AvSendTVEncoderOption(NULL, AV_OPTION_ZERO_MODE, 0, NULL);

        D3DDevice_Reset(&d3dpp);

        // Recreate the surfaces.
        CreateScreen(g_TestPattern, 
                     g_Tests[g_TestPattern].m_DefaultValue1, 
                     g_Tests[g_TestPattern].m_DefaultValue2);

        g_EnableCC = TRUE;

        g_FpsCount = 0;
        g_VpsCount = 0;
        g_FpsTime = GetTickCount();
        g_VpsTime = g_FpsTime;
    }

    SetEvent(g_hEvent);

    if (!g_cchBuffer)
    {
        ResPrintf("\r\nAV Pack    - ");
        switch(D3D__AvInfo & 0xFF)
        {
        case 1:
                ResPrintf("1: Standard\r\n");
                break;
        case 2:
                ResPrintf("2: RFU\r\n");
                break; 
        case 3:
                ResPrintf("3: SCART\r\n");
                break; 
        case 4:
                ResPrintf("4: HDTV\r\n");
                break; 
        case 5:
                ResPrintf("5: VGA\r\n");
                break;
        case 6: 
                ResPrintf("6: SVideo\r\n");
                break;
        }

#if 0
        AvpReadDeviceReg(REGISTER_BASE, SMC_SLAVE_ADDRESS, SMC_COMMAND_VIDEO_MODE, &Value);
        ResPrintf("AvPack reg - %X\r\n", Value);
#endif 0

        ResPrintf("Standard   - ");
        switch((D3D__AvInfo & 0xFF00) >> 8)
        {
        case 1:
            ResPrintf("1: NTSC-M\r\n");
            break;
        case 2:            
            ResPrintf("2: NTSC-J\r\n");
            break;
        case 3:
            ResPrintf("3: PAL-I\r\n");
            break;
        case 4:
            ResPrintf("4: PAL-M\r\n");
            break;
        }

        ResPrintf("Mode       - ");
        ResPrintMode(g_iMode);

        ResPrintf("Widescreen - ");
        
        if (D3D__AvInfo & AV_FLAGS_WIDESCREEN)
        {
            ResPrintf("enabled\r\n");
        }
        else
        {
            ResPrintf("not enabled\r\n");
        }

        ResPrintf("HTDV modes - ");

        if (!(D3D__AvInfo & AV_HDTV_MODE_MASK))
        {
            ResPrintf("none\r\n");
        }
        else
        {
            ResPrintf("480p ");

            if (D3D__AvInfo & AV_FLAGS_HDTV_720p)
            {
                ResPrintf("720p ");
            }

            if (D3D__AvInfo & AV_FLAGS_HDTV_1080i)
            {
                ResPrintf("1080i ");
            }

            ResPrintf("\r\n");
        }

        ResPrintf("PAL-60     - ");

        if (D3D__AvInfo & AV_FLAGS_50Hz)
        {
            if (D3D__AvInfo & AV_FLAGS_60Hz)
            {
                ResPrintf("enabled\r\n");
            }
            else
            {
                ResPrintf("disabled\r\n");
            }
        }
        else
        {
            ResPrintf("ignored, not in PAL-I mode\r\n");
        }

        c = GetTickCount();

        ResPrintf("Blank Rate - ");
          
        if (c - g_VpsTime > 2000)
        {
            ResPrintf("%.2f vps\r\n", (double)g_VpsCount / (double)(c - g_VpsTime) * 1000.0);
        }
        else
        {
            ResPrintf("<sampling>\r\n");
        }

        ResPrintf("Frame Rate - ");
          
        if (c - g_FpsTime > 2000)
        {
            ResPrintf("%.2f fps\r\n", (double)g_FpsCount / (double)(c - g_FpsTime) * 1000.0);
        }
        else
        {
            ResPrintf("<sampling>\r\n");
        }

        GetScreenChecksum(&Red, &Green, &Blue);

        ResPrintf("Checksum - Red: %08X, Green: %08X, Blue: %08X\r\n", Red, Green, Blue);
    }

    pdmcc->HandlingFunction = RXCmdCont;
    pdmcc->DataSize = 0;
    pdmcc->Buffer = g_szBuffer;
    pdmcc->BufferSize = g_cchBuffer;
    pdmcc->CustomData = NULL;
    pdmcc->BytesRemaining = g_cchBuffer;

    LeaveCriticalSection(&g_Mutex);

    return XBDM_MULTIRESPONSE;
}

//==============================================================================
// Frame counter.
//==============================================================================

DWORD g_DoChecksum;
DWORD g_Channel;
DWORD g_Value[3];

void __cdecl FrameCounter(D3DVBLANKDATA *pData)
{
    InterlockedIncrement(&g_VpsCount);

    if (g_DoChecksum)
    {
        if (g_Channel > 0)
        {
            g_Value[g_Channel - 1] = *(volatile DWORD *)0xFD680840 & 0x00FFFFFF;
        }

        if (g_Channel < 3)
        {
            *(volatile DWORD *)0xFD680844 = 0x411 | (g_Channel << 8);
            *(volatile DWORD *)0xFD680844 = 0x410 | (g_Channel << 8);

            g_Channel++;
        }
        else
        {
            g_Channel = 0;
            g_DoChecksum = 0;
        }
    }
}

//------------------------------------------------------------------------------
// Calculates the frame's checksum.
//
void GetScreenChecksum(
    DWORD *pRed,
    DWORD *pGreen,
    DWORD *pBlue
    )
{
    g_DoChecksum = 1;

    while (g_DoChecksum)
    {
        D3DDevice_BlockUntilVerticalBlank();
    }

    *pRed   = g_Value[0];
    *pGreen = g_Value[1];
    *pBlue  = g_Value[2];
}


//==============================================================================
// Text
//==============================================================================

char *g_6[32] =
{
    "00000000000000000000000000000000",
    "00000000000000000000000000000000",
    "00000111111111111111111111110000",
    "00011111111111111111111111111000",
    "00011100000000000000000000111000",
    "00111000000000000000000000011100",
    "00111000000000000000000000011100",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111111111111111111111111000000",
    "00111111111111111111111111110000",
    "00111000000000000000000000111000",
    "00111000000000000000000000011100",
    "00111000000000000000000000011100",
    "00111000000000000000000000011100",
    "00111000000000000000000000011100",
    "00111000000000000000000000011100",
    "00111000000000000000000000011100",
    "00111000000000000000000000011100",
    "00111000000000000000000000011100",
    "00111000000000000000000000011100",
    "00011100000000000000000000111000",
    "00011111111111111111111111111000",
    "00000111111111111111111111100000",
    "00000000000000000000000000000000",
    "00000000000000000000000000000000",
};

char *g_7[32] =
{
    "00000000000000000000000000000000",
    "00000000000000000000000000000000",
    "00111111111111111111111111111100",
    "00111111111111111111111111111100",
    "00000000000000000000000000011100",
    "00000000000000000000000000011100",
    "00000000000000000000000000111000",
    "00000000000000000000000001110000",
    "00000000000000000000000011100000",
    "00000000000000000000000111000000",
    "00000000000000000000001110000000",
    "00000000000000000000011100000000",
    "00000000000000000000111000000000",
    "00000000000000000001110000000000",
    "00000000000000000011100000000000",
    "00000000000000000111000000000000",
    "00000000000000001110000000000000",
    "00000000000000011100000000000000",
    "00000000000000111000000000000000",
    "00000000000001110000000000000000",
    "00000000000011100000000000000000",
    "00000000000111000000000000000000",
    "00000000001110000000000000000000",
    "00000000011100000000000000000000",
    "00000000111000000000000000000000",
    "00000001110000000000000000000000",
    "00000011100000000000000000000000",
    "00000111000000000000000000000000",
    "00001110000000000000000000000000",
    "00011100000000000000000000000000",
    "00000000000000000000000000000000",
    "00000000000000000000000000000000",
};

char *g_W[32] =
{
    "00000000000000000000000000000000",
    "00000000000000000000000000000000",
    "00111000000000000000000000011100",
    "00111000000000000000000000011100",
    "00111000000000000000000000011100",
    "00111000000000000000000000011100",
    "00111000000000000000000000011100",
    "00111000000000000000000000011100",
    "00111000000000011000000000011100",
    "00111000000000011000000000011100",
    "00111000000000111100000000011100",
    "00111000000000111100000000011100",
    "00111000000001111110000000011100",
    "00111000000001111110000000011100",
    "00111000000011100111000000011100",
    "00111000000011100111000000011100",
    "00111000000111000011100000011100",
    "00111000000111000011100000011100",
    "00111000001110000001110000011100",
    "00111000001110000001110000011100",
    "00111000011100000000111000011100",
    "00111000011100000000111000011100",
    "00111000111000000000011100011100",
    "00111000111000000000011100011100",
    "00111001110000000000001110011100",
    "00111001110000000000001110011100",
    "00111011100000000000000111011100",
    "00111011100000000000000111011100",
    "00111111000000000000000011111100",
    "00111110000000000000000001111100",
    "00000000000000000000000000000000",
    "00000000000000000000000000000000",
};

char *g_F[32] =
{
    "00000000000000000000000000000000",
    "00000000000000000000000000000000",
    "00111111111111111111111111111100",
    "00111111111111111111111111111100",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111111111111111111000000000000",
    "00111111111111111111000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00111000000000000000000000000000",
    "00000000000000000000000000000000",
    "00000000000000000000000000000000",
};

char *g_I[32] =
{
    "00000000000000000000000000000000",
    "00000000000000000000000000000000",
    "00111111111111111111111111111100",
    "00111111111111111111111111111100",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00000000000000111100000000000000",
    "00111111111111111111111111111100",
    "00111111111111111111111111111100",
    "00000000000000000000000000000000",
    "00000000000000000000000000000000",
};

char *g_11[32] =
{
    "00000000000000000000000000000000",
    "00000000000000000000000000000000",
    "00001111100000000000011111000000",
    "00011111100000000000111111000000",
    "00111011100000000001110111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000000000000111000000",
    "00000011100000011000000111000000",
    "00111111111110111101111111111100",
    "00111111111110011001111111111100",
    "00000000000000000000000000000000",
    "00000000000000000000000000000000",
};

void DrawChar(
    UINT x,
    UINT y,
    char **ppMap
    )
{
    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT  Rect;
    LPDWORD         pData;
    UINT i;
    char *pPixel;

    DWORD Width;
    DWORD Height;
    DWORD PitchAdjust;

    D3DSurface_GetDesc(g_pBack, &Desc);
    D3DSurface_LockRect(g_pBack, &Rect, NULL, D3DLOCK_TILED);

    Width = Desc.Width;
    Height = Desc.Height;
    PitchAdjust  = Rect.Pitch / 4 - 32;

    pData = (LPDWORD)Rect.pBits + x + y * Rect.Pitch / 4;

    for (i = 0; i < 32; i++)
    {
        pPixel = ppMap[i];

        while (*pPixel)
        {
            *pData = (*pPixel == '0') ? 0 : 0xFFFFFFFF;

            pData++;
            pPixel++;
        }

        pData += PitchAdjust;
    }

    D3DSurface_UnlockRect(g_pBack); 
}

void DrawMode()
{
    UINT x;

    x = 100;

    if (g_Mode.Width == 640)
    {
        DrawChar(x, 100, g_6);
        x += 32;
    }
    else if (g_Mode.Width == 720)
    {
        DrawChar(x, 100, g_7);
        x += 32;
    }

    if (g_Mode.Flags & D3DPRESENTFLAG_10X11PIXELASPECTRATIO)
    {
        DrawChar(x, 100, g_11);
        x += 32;
    }

    if (g_Mode.Flags & D3DPRESENTFLAG_FIELD)
    {
        DrawChar(x, 100, g_F);
        x += 32;
    }
    else if (g_Mode.Flags & D3DPRESENTFLAG_INTERLACED)
    {
        DrawChar(x, 100, g_I);
        x += 32;
    }
    
    if (g_Mode.Flags & D3DPRESENTFLAG_WIDESCREEN)
    {
        DrawChar(x, 100, g_W);
        x += 32;
    }
}

//==============================================================================
// Graphics
//==============================================================================

//------------------------------------------------------------------------------
// Intialize D3D.
//
void
Init()
{
    D3DPRESENT_PARAMETERS d3dpp;
    D3DLOCKED_RECT rect;
    DWORD *pBits;
    DWORD i;
    DWORD x, y;
    DWORD r, g, b;
    UCHAR y0, u, v;

    DWORD InputDevices;

    // Initialize the work event.
    g_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Initialize the g_Mutex.
    InitializeCriticalSection(&g_Mutex);

    // Initialize the controller.
    XInitDevices(0, NULL);

    // Make D3D go.

    Direct3D_EnumAdapterModes(0, 0, &g_Mode);

    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = g_Mode.Width;
    d3dpp.BackBufferHeight          = g_Mode.Height;
    d3dpp.BackBufferFormat          = g_Mode.Format;
    d3dpp.Flags                     = g_Mode.Flags;
    d3dpp.BackBufferCount           = 1;
    d3dpp.EnableAutoDepthStencil    = TRUE;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;

    // Create the device.
    Direct3D_CreateDevice(
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        NULL,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        NULL);

    // Enable all of the funky stuff by default.
    g_SavedAvInfo = D3D__AvInfo;
    D3D__AvInfo |= AV_FLAGS_WIDESCREEN | AV_FLAGS_60Hz;

    // Reset with the new first mode.
    Direct3D_EnumAdapterModes(0, 0, &g_Mode);

    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth           = g_Mode.Width;
    d3dpp.BackBufferHeight          = g_Mode.Height;
    d3dpp.BackBufferFormat          = g_Mode.Format;
    d3dpp.Flags                     = g_Mode.Flags;
    d3dpp.BackBufferCount           = 1;
    d3dpp.EnableAutoDepthStencil    = TRUE;
    d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;

    // Create the device.
    D3DDevice_Reset(&d3dpp);

    g_EnableCC = TRUE;

    // Get the buffer to draw into.
    D3DDevice_GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &g_pBack);

    // Set up the overlay surface.
    D3DDevice_CreateImageSurface(256, 256, D3DFMT_YUY2, &g_pOverlay);

    D3DSurface_LockRect(g_pOverlay, &rect, 0, D3DLOCK_TILED);

    pBits = (DWORD *)rect.pBits;

    for (y = 0; y < 256; y++)
    {
        for (x = 0; x < 256; x += 2)
        {
            if (x & 0x10)
            {
                r = x & 0xF0;
                g = 0;
                b = y;
            }
            else
            {
                r = 255;
                g = 255;
                b = 255;
            }

            y0 = (UCHAR)(0.29 * r + 0.57 * g + 0.14 * b);
            u = (UCHAR)(128.0 - 0.14 * r - 0.29 * g + 0.43 * b);            
            v = (UCHAR)(128.0 + 0.36 * r - 0.29 * g - 0.07 * b);

            *pBits = v << 24 
                     | y0 << 16
                     | u << 8
                     | y0;

            pBits++;
        }

        pBits += 128;
    }

    D3DSurface_UnlockRect(g_pOverlay);

    // Create the screen.
    CreateScreen(0, g_Tests[0].m_DefaultValue1, g_Tests[0].m_DefaultValue2);

    // Set up the fps counter.
    D3DDevice_BlockUntilVerticalBlank();

    g_FpsTime = GetTickCount();
    g_VpsTime = g_FpsTime;

    g_FpsCount = 0;
    g_VpsCount = 0;

    D3DDevice_SetVerticalBlankCallback(FrameCounter); 

    // Set up the command processor.
    DmRegisterCommandProcessor(COMMAND_PREFIX, RXCmdProcessorProc);
}

//------------------------------------------------------------------------------
// Use the cache to attenuate some bits.
//
void
Attenuate(
    BYTE *pBits,
    DWORD Pitch,
    DWORD Width,
    DWORD Start,
    DWORD Size
    )
{   
    DWORD X, Y, Line, Free, Pixel, Color, NewPixel;
    DWORD *pLine;

    if (Size)
    {
         Start++;
    }

    // Flush everything out of the cache that we're not going to keep.
    for (Line = 0; Line < BUFFER_SIZE; Line++)
    {
        if (g_LineNumber[Line] && (g_LineNumber[Line] < Start || g_LineNumber[Line] >= Start + Size))
        {
            memcpy(pBits + Pitch * (g_LineNumber[Line] - 1), g_LineBuffer[Line], Width * 4);
            g_LineNumber[Line] = 0;
        }
    }

    // Suck up anything we need.  This is as about inefficient as you can get.

    for (Y = Start; Y < Start + Size; Y++)
    {
        Free = -1;

        for (Line = 0; Line < Size; Line++)
        {
            if (g_LineNumber[Line] == Y)
            {
                break;
            }

            if (g_LineNumber[Line] == 0 && Free == -1)
            {
                Free = Line;
            }
        }

        // Not already there.  Add it.
        if (Line == Size)
        {
            if (Free == -1)
            {
                _asm int 3;
            }

            pLine = (DWORD *)(pBits + Pitch * (Y - 1));

            // Save the old.
            memcpy(g_LineBuffer[Free], pLine, Width * 4);
            g_LineNumber[Free] = Y;

            // Attenuate it.
            for (X = 0; X < Width; X++)
            {
                Pixel = *(pLine + X);

                NewPixel = 0;

                if (g_ShowSweep & 0x01)
                {
                    Color = (Pixel >> 0) & 0xFF;

                    if (Color >= 0x80)
                    {
                        Color -= (DWORD)(0xFF * g_SweepAttenuation);
                    }
                    else
                    {
                        Color += (DWORD)(0xFF * g_SweepAttenuation);
                    }

                    NewPixel |= Color << 0;
                }
                else
                {
                    NewPixel |= Pixel & 0x0000FF;
                }

                if (g_ShowSweep & 0x02)
                {
                    Color = (Pixel >> 8) & 0xFF;

                    if (Color >= 0x80)
                    {
                        Color -= (DWORD)(0xFF * g_SweepAttenuation);
                    }
                    else
                    {
                        Color += (DWORD)(0xFF * g_SweepAttenuation);
                    }

                    NewPixel |= Color << 8;
                }
                else
                {
                    NewPixel |= Pixel & 0x00FF00;
                }

                if (g_ShowSweep & 0x04)
                {
                    Color = (Pixel >> 16) & 0xFF;

                    if (Color >= 0x80)
                    {
                        Color -= (DWORD)(0xFF * g_SweepAttenuation);
                    }
                    else
                    {
                        Color += (DWORD)(0xFF * g_SweepAttenuation);
                    }

                    NewPixel |= Color << 16;
                }
                else
                {
                    NewPixel |= Pixel & 0xFF0000;
                }

                *(pLine + X) = NewPixel;
            }
        }
    }
                
}

//------------------------------------------------------------------------------
// Draw one frame.
//
void
Paint()
{    
    D3DSurface *pSurface;
    D3DFIELD_STATUS FieldStatus;
    
    DWORD Now, Elapsed;
    DWORD Start, Size, X, Y, Range;

    D3DSURFACE_DESC Desc;
    D3DLOCKED_RECT Rect;

    DWORD Pitch;
    DWORD Width;

    DWORD *pData;

    D3DDevice_GetDisplayFieldStatus(&FieldStatus);
    
    if (FieldStatus.Field == D3DFIELD_ODD)
    {
        pSurface = g_ScreenOdd;
    }
    else
    {
        pSurface = g_ScreenEven;
    }

    if (g_ScreenOdd == g_ScreenEven)
    {
        D3DSurface_GetDesc(pSurface, &Desc);
        D3DSurface_LockRect(pSurface, &Rect, NULL, D3DLOCK_TILED);

        Pitch = Rect.Pitch;
        Width = Desc.Width;

        // Draw the sweep.
        if (g_ShowSweep)
        {
            //_asm int 3;

            Now = GetTickCount();

            if (!g_SweepTime)
            {
                g_SweepTime = Now;
            }

            // Where are we in a sweep?
            Elapsed = (Now - g_SweepTime) % (DWORD)(g_SweepRate * 1000);
            Range = Desc.Height - g_SweepWidth;

            Start = (DWORD)labs((long)(Range * 2 * Elapsed / (g_SweepRate * 1000)) - (long)Range);
            Size = g_SweepWidth;
        }
        else
        {
            Start = 0;
            Size = 0;
        }

        Attenuate((BYTE *)Rect.pBits, Pitch, Width, Start, Size);

        D3DSurface_UnlockRect(g_pBack);
    }

    // Copy the rectangle.
    D3DDevice_CopyRects(pSurface, NULL, 0, g_pBack, NULL);

    // Draw the mode.
    if (g_ModeTime + 2000 > GetTickCount())
    {
        DrawMode();
    }

    // Show it.
    D3DDevice_Swap(0);
}

//------------------------------------------------------------------------------
// Handle controller input.
//
void ProcessInput()
{
    XINPUT_STATE InputState;
    DWORD A, B, X, Y, Black, White;
    D3DPRESENT_PARAMETERS d3dpp;
    USHORT Data;

    if (!(XGetDevices(XDEVICE_TYPE_GAMEPAD) & XDEVICE_PORT0_MASK))        
    {
        if (g_InputHandle)
        {
            XInputClose(g_InputHandle);
            g_InputHandle = NULL;
        }

        return;
    }

    if (!g_InputHandle)
    {
        g_InputHandle = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, 0, NULL);
    }

    // Query the input state
    if (XInputGetState(g_InputHandle, &InputState) != ERROR_SUCCESS)
    {
        return;
    }

    A     = InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] & 0x80;
    B     = InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] & 0x80;
    X     = InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] & 0x80;
    Y     = InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] & 0x80;
    Black = InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] & 0x80;
    White = InputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] & 0x80;

    if (A)
    {
        if (!g_A)
        {
            g_TestPattern = (g_TestPattern + 1) % (sizeof(g_Tests) / sizeof(TESTS));

            CreateScreen(g_TestPattern, g_Tests[g_TestPattern].m_DefaultValue1, g_Tests[g_TestPattern].m_DefaultValue2);
        }
    }

    g_A = A;

    if (B)
    {
        if (!g_B)
        {
            g_iMode = (g_iMode + 1) % (Direct3D_GetAdapterModeCount(0) / 4);

            Direct3D_EnumAdapterModes(0, g_iMode * 4, &g_Mode);

            ZeroMemory(&d3dpp, sizeof(d3dpp));

            d3dpp.BackBufferWidth            = g_Mode.Width;
            d3dpp.BackBufferHeight           = g_Mode.Height;
            d3dpp.BackBufferFormat           = g_Mode.Format;
            d3dpp.Flags                      = g_Mode.Flags;
            d3dpp.BackBufferCount            = 1;
            d3dpp.EnableAutoDepthStencil     = TRUE;
            d3dpp.AutoDepthStencilFormat     = D3DFMT_D24S8;
            d3dpp.FullScreen_RefreshRateInHz = g_Mode.RefreshRate;

            // Clear out any cached modes.
            //AvSendTVEncoderOption(NULL, AV_OPTION_ZERO_MODE, 0, NULL);

            D3DDevice_Reset(&d3dpp);

            // Recreate the surfaces.
            CreateScreen(g_TestPattern, g_Tests[g_TestPattern].m_DefaultValue1, g_Tests[g_TestPattern].m_DefaultValue2);

            g_EnableCC = TRUE;

            //AvSendTVEncoderOption(NULL, AV_OPTION_ENABLE_CC, 0, NULL);

            g_ModeTime = GetTickCount();

            g_FpsCount = 0;
            g_VpsCount = 0;
            g_FpsTime = GetTickCount();
            g_VpsTime = g_FpsTime;
        }
    }

    g_B = B;

    if (X)
    {
        if (!g_X)
        {
            if (!g_ShowSweep)
            {
                g_ShowSweep = 0x7;
                g_SweepTime = 0;
            }
            else if (g_ShowSweep == 0x07)
            {
                g_ShowSweep = 0x4;
            }
            else if (g_ShowSweep == 0x04)
            {
                g_ShowSweep = 0x2;
            }
            else if (g_ShowSweep == 0x02)
            {
                g_ShowSweep = 0x1;
            }
            else
            {
                g_ShowSweep = 0;
            }
        }
    }

    g_X = X;

    if (Y)
    {
        if (!g_Y)
        {
            if (D3D__AvInfo & AV_HDTV_MODE_MASK)
            {
                D3D__AvInfo = D3D__AvInfo & ~AV_HDTV_MODE_MASK | g_SavedAvInfo & AV_HDTV_MODE_MASK;
            }
            else
            {
                D3D__AvInfo |= AV_HDTV_MODE_MASK;
            }
        }
    }

    g_Y = Y;

    if (Black)
    {
        if (!g_Black)
        {
#ifdef FOCUS

            AvpDelay(REGISTER_BASE, 50 * 1000 * 1000);

            Data = SMB_RDW(REGISTER_BASE, 0x0C);
            SMB_WRW(REGISTER_BASE, 0x0C, Data | 0x8000);

            AvpDelay(REGISTER_BASE, 50 * 1000 * 1000);

            Data = SMB_RDW(REGISTER_BASE, 0x0C);
            SMB_WRW(REGISTER_BASE, 0x0C, Data & ~0x8000);

            AvpDelay(REGISTER_BASE, 50 * 1000 * 1000);

            Data = SMB_RDW(REGISTER_BASE, 0x0E);
            SMB_WRW(REGISTER_BASE, 0x0E, Data & ~0x0400);

            AvpDelay(REGISTER_BASE, 50 * 1000 * 1000);

            Data = SMB_RDW(REGISTER_BASE, 0x0E);
            SMB_WRW(REGISTER_BASE, 0x0E, Data | 0x0400);

#endif
        }
    }

    g_Black = Black;

    if (White)
    {
        if (!g_White)
        {
        }
    }

    g_White = White;
}

//==============================================================================
// Main goo.
//==============================================================================

//------------------------------------------------------------------------------
// Main entrypoint.
//
void __cdecl main()
{
    RECT SourceRect, DestRect;
    D3DSURFACE_DESC Desc;

    Init();

    for(;;)
    {
        ProcessInput();

        Paint();

        if (g_EnableCC)
        {
            D3DDevice_EnableCC(TRUE);
            g_EnableCC = FALSE;
        }

        g_FpsCount++;

        if (g_Overlay)
        {
            D3DSurface_GetDesc(g_pBack, &Desc);

            SourceRect.left = 0;
            SourceRect.top  = 0;
            SourceRect.right = 256;
            SourceRect.bottom = 256;

#if 0
            DestRect.left   = Desc.Width / 2 - 160;
            DestRect.right  = Desc.Width / 2 + 160;
            DestRect.top    = Desc.Height / 2 - 160;
            DestRect.bottom = Desc.Height / 2 + 160;
#else
            DestRect.left   = 0;
            DestRect.right  = Desc.Width;
            DestRect.top    = 0;
            DestRect.bottom = Desc.Height / 2;
#endif
            while(!D3DDevice_GetOverlayUpdateStatus())
                ;

            D3DDevice_UpdateOverlay(g_pOverlay, &SourceRect, &DestRect, FALSE, 0x00000000);
        }
        else
        {
            D3DDevice_EnableOverlay(FALSE);
        }

        D3DDevice_BlockUntilVerticalBlank();

        //WaitForSingleObject(g_hEvent, INFINITE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\volumetexture\volumetexture.cpp ===
//-----------------------------------------------------------------------------
// File: VolumeTexture.cpp
//
// Desc: Example code showing how to do volume textures in D3D.
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#define STRICT

#ifdef XBOX
#include <xtl.h>
#include <xgraphics.h>
#else
#include <windows.h>
#include <D3DX8.h>
#endif
#include <stdio.h>
#include <math.h>
#include "D3DApp.h"
#include "D3DFile.h"
#include "D3DUtil.h"
#include "DXUtil.h"


//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
struct VOLUMEVERTEX
{
    FLOAT      x, y, z;
    DWORD      color;
    FLOAT      tu, tv, tw;
};

#define D3DFVF_VOLUMEVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1|D3DFVF_TEXCOORDSIZE3(0))

VOLUMEVERTEX g_vVertices[4] =
{
    { 1.0f, 1.0f, 0.0f, 0xffffffff, 1.0f, 1.0f, 0.0f },
    {-1.0f, 1.0f, 0.0f, 0xffffffff, 0.0f, 1.0f, 0.0f },
    { 1.0f,-1.0f, 0.0f, 0xffffffff, 1.0f, 0.0f, 0.0f },
    {-1.0f,-1.0f, 0.0f, 0xffffffff, 0.0f, 0.0f, 0.0f }
};




//-----------------------------------------------------------------------------
// Name: class CMyD3DApplication
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CMyD3DApplication : public CD3DApplication
{
    LPDIRECT3DVOLUMETEXTURE8 m_pVolumeTexture;
    LPDIRECT3DVERTEXBUFFER8  m_pVB;

public:
    void InitDeviceObjects();
    void RestoreDeviceObjects();
    void DeleteDeviceObjects();
    void Render();
    void FrameMove();

    CMyD3DApplication();
};


#if defined(PCBUILD)

//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )
{
    CMyD3DApplication d3dApp;

    d3dApp.Create( hInst );

    d3dApp.Run();

    return 0;
}


#else

void __cdecl main()
{
    CMyD3DApplication d3dApp;

    d3dApp.Create( NULL );

    d3dApp.Run();
}

#endif

//-----------------------------------------------------------------------------
// Name: CMyD3DApplication()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CMyD3DApplication::CMyD3DApplication()
{
    m_bUseDepthBuffer   = TRUE;

    m_pVolumeTexture = NULL;
    m_pVB            = NULL;
}


//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
void CMyD3DApplication::FrameMove()
{
    static FLOAT fAngle = 0.0f;
    fAngle += 0.1f;

    // Play with the volume texture coordinate
    VOLUMEVERTEX* pVertices = NULL;
    CheckHR(m_pVB->Lock( 0, 4*sizeof(VOLUMEVERTEX), (BYTE**)&pVertices, 0 ));
    for( int i=0; i<4; i++ )
        pVertices[i].tw = sinf(fAngle)*sinf(fAngle);
    CheckHR(m_pVB->Unlock());
}




//-----------------------------------------------------------------------------
// Name: App_Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
void CMyD3DApplication::Render()
{
    // Clear the viewport
    CheckHR(m_pDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0x00000000, 1.0f, 0L ));

    // Begin the scene
    CheckHR(m_pDevice->BeginScene());
    
    // Draw the quad, with the volume texture
    CheckHR(m_pDevice->SetTexture( 0, m_pVolumeTexture ));
    CheckHR(m_pDevice->SetVertexShader( D3DFVF_VOLUMEVERTEX ));
    CheckHR(m_pDevice->SetStreamSource( 0, m_pVB, sizeof(VOLUMEVERTEX) ));
    CheckHR(m_pDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2));

    // End the scene.
    CheckHR(m_pDevice->EndScene());
}




//-----------------------------------------------------------------------------
// Name: InitDeviceObjects()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
void CMyD3DApplication::InitDeviceObjects()
{
    // Create a 64x64x4 volume texture
    CheckHR((m_pDevice->CreateVolumeTexture( 16, 16, 16, 1, 0,
                                            D3DFMT_A8R8G8B8, D3DPOOL_MANAGED,
                                            &m_pVolumeTexture )));

    // Fill the volume texture
    {
        D3DLOCKED_BOX LockedBox;
        CheckHR(m_pVolumeTexture->LockBox( 0, &LockedBox, 0, 0 ));

        D3DVOLUME_DESC desc;
        m_pVolumeTexture->GetLevelDesc(0, &desc);
        PVOID pBits = LocalAlloc(0, 16 * 16 * 16 * 4);

        if (pBits == NULL)
        {
            m_pVolumeTexture->UnlockBox(0);
            return;
        }

        PVOID pTemp = pBits;

        for( UINT w=0; w<16; w++ )
        {
            BYTE* pSliceStart = (BYTE*)pTemp;

            for( UINT v=0; v<16; v++ )
            {
                for( UINT u=0; u<16; u++ )
                {
                    FLOAT du = (u-7.5f)/7.5f;
                    FLOAT dv = (v-7.5f)/7.5f;
                    FLOAT dw = (w-7.5f)/7.5f;
                    FLOAT fScale = sqrtf( du*du + dv*dv + dw*dw ) / sqrtf(1.0f);

                    if( fScale > 1.0f ) fScale = 0.0f;
                    else                fScale = 1.0f - fScale;

                                        DWORD r = (DWORD)((w<<4)*fScale);
                                        DWORD g = (DWORD)((v<<4)*fScale);
                                        DWORD b = (DWORD)((u<<4)*fScale);

                    ((DWORD*)pTemp)[u] = 0xff000000 + (r<<16) + (g<<8) + (b);
                }
                pTemp = (BYTE*)pTemp + LockedBox.RowPitch;
            }
            pTemp = pSliceStart + LockedBox.SlicePitch;
        }

        D3DBOX box = { 0, 0, 0, 16, 16, 16 };
        XGPOINT3D point = { 0, 0, 0 };

        XGSwizzleBox(pBits, 
                     LockedBox.RowPitch,
                     LockedBox.SlicePitch,
                     &box,
                     LockedBox.pBits,
                     16,
                     16,
                     16,
                     &point,
                     4);

        LocalFree(pBits);

        CheckHR(m_pVolumeTexture->UnlockBox( 0 ));
    }

    // Create a vertex buffer
    {
        CheckHR(m_pDevice->CreateVertexBuffer( 4*sizeof(VOLUMEVERTEX),
                                           D3DUSAGE_WRITEONLY,
                                           D3DFVF_VOLUMEVERTEX,
                                           D3DPOOL_MANAGED, &m_pVB ) );

        VOLUMEVERTEX* pVertices;
        CheckHR(m_pVB->Lock( 0, 4*sizeof(VOLUMEVERTEX), (BYTE**)&pVertices, 0 ));
        memcpy( pVertices, g_vVertices, sizeof(VOLUMEVERTEX)*4 );
        CheckHR(m_pVB->Unlock());
    }
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
void CMyD3DApplication::RestoreDeviceObjects()
{
    // Set the matrices
    D3DXVECTOR3 vEye( 0.0f, 0.0f,-3.0f );
    D3DXVECTOR3 vAt(  0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp(  0.0f, 1.0f, 0.0f );
    D3DXMATRIX matWorld, matView, matProj;
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixLookAtLH( &matView, &vEye,&vAt, &vUp );
    FLOAT fAspect = m_BackBufferDesc.Width / (FLOAT)m_BackBufferDesc.Height;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, fAspect, 1.0f, 100.0f );
    CheckHR(m_pDevice->SetTransform( D3DTS_WORLD,      &matWorld ));
    CheckHR(m_pDevice->SetTransform( D3DTS_VIEW,       &matView ));
    CheckHR(m_pDevice->SetTransform( D3DTS_PROJECTION, &matProj ));

    // Set state
    CheckHR(m_pDevice->SetRenderState( D3DRS_DITHERENABLE, FALSE ));
    CheckHR(m_pDevice->SetRenderState( D3DRS_CULLMODE,     D3DCULL_NONE ));
    CheckHR(m_pDevice->SetRenderState( D3DRS_LIGHTING,     FALSE ));
    CheckHR(m_pDevice->SetRenderState( D3DRS_ZENABLE,      FALSE ));
    CheckHR(m_pDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE ));

    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR ));
    CheckHR(m_pDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR ));
}




//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Called when the app is exitting, or the device is being changed,
//       this function deletes any device dependant objects.
//-----------------------------------------------------------------------------
void CMyD3DApplication::DeleteDeviceObjects()
{
    SAFE_RELEASE( m_pVolumeTexture );
    SAFE_RELEASE( m_pVB );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\vshtimer\utils.cpp ===
//-----------------------------------------------------------------------------
// FILE: FILLRATE.CPP
//
// Desc: a stupid fillrate test
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>

#include "bitfont.h"
#include "utils.h"

// CScrText font class
BitFont g_bitfont;

//=========================================================================
// Stringtize PS_TEXTUREMODES_*
//=========================================================================
LPCSTR GetTextureModeStr(DWORD TextureMode)
{
    #undef XTAG
    #define XTAG(_tag) { PS_TEXTUREMODES##_tag, "PS_TM" #_tag }
    static const struct
    {
        DWORD texturemode;
        const char *szD3DMSStr;
    } rgszTMStr[] =
    {
        XTAG(_NONE), XTAG(_PROJECT2D), XTAG(_PROJECT3D),
        XTAG(_CUBEMAP), XTAG(_PASSTHRU), XTAG(_CLIPPLANE),
        XTAG(_BUMPENVMAP), XTAG(_BUMPENVMAP_LUM), XTAG(_BRDF),
        XTAG(_DOT_ST), XTAG(_DOT_ZW), XTAG(_DOT_RFLCT_DIFF),
        XTAG(_DOT_RFLCT_SPEC), XTAG(_DOT_STR_3D), XTAG(_DOT_STR_CUBE),
        XTAG(_DPNDNT_AR), XTAG(_DPNDNT_GB), XTAG(_DOTPRODUCT),
        XTAG(_DOT_RFLCT_SPEC_CONST),
    };
    static const int cFmts = sizeof(rgszTMStr) / sizeof(rgszTMStr[0]);

    for(int ifmt = 0; ifmt < cFmts; ifmt++)
    {
        if(rgszTMStr[ifmt].texturemode == TextureMode)
            return rgszTMStr[ifmt].szD3DMSStr;
    }

    return rgszTMStr[cFmts - 1].szD3DMSStr;
}

//=========================================================================
// Stringtize D3DMS_*
//=========================================================================
LPCSTR GetMultiSampleStr(DWORD mstype)
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        DWORD mstype;
        const char *szD3DMSStr;
    } rgszMSStr[] =
    {
        XTAG(D3DMS_NONE), XTAG(D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX), XTAG(D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR),
        XTAG(D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR), XTAG(D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN), XTAG(D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR),
        XTAG(D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN),
        XTAG(D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMS_PREFILTER_FORMAT_DEFAULT),
        XTAG(D3DMS_PREFILTER_FORMAT_X1R5G5B5), XTAG(D3DMS_PREFILTER_FORMAT_R5G6B5),
        XTAG(D3DMS_PREFILTER_FORMAT_X8R8G8B8), XTAG(D3DMS_PREFILTER_FORMAT_A8R8G8B8),
    };
    static const int cFmts = sizeof(rgszMSStr) / sizeof(rgszMSStr[0]);

    for(int ifmt = 0; ifmt < cFmts; ifmt++)
    {
        if(rgszMSStr[ifmt].mstype == mstype)
            return rgszMSStr[ifmt].szD3DMSStr;
    }

    return rgszMSStr[cFmts - 1].szD3DMSStr;
}

//=========================================================================
// Stringtize D3DCMP_*
//=========================================================================
LPCSTR GetD3DCMPStr(D3DCMPFUNC d3dcmpfunc)
{
    static const char *rgszD3DCmp[] =
    {
        "D3DCMP_NEVER",         // 0x200,
        "D3DCMP_LESS",          // 0x201,
        "D3DCMP_EQUAL",         // 0x202,
        "D3DCMP_LESSEQUAL",     // 0x203,
        "D3DCMP_GREATER",       // 0x204,
        "D3DCMP_NOTEQUAL",      // 0x205,
        "D3DCMP_GREATEREQUAL",  // 0x206,
        "D3DCMP_ALWAYS",        // 0x207,
        "??",
    };

    DWORD id3dcmp = min(d3dcmpfunc & 0xf, sizeof(rgszD3DCmp) / sizeof(rgszD3DCmp[0]));
    return rgszD3DCmp[id3dcmp];
}

//=========================================================================
// Stringtize D3DFMT_*
//=========================================================================
LPCSTR GetD3DFormatStr(D3DFORMAT d3dformat)
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        D3DFORMAT d3dformat;
        const char *szD3DFormat;
    } rgszD3DFmt[] =
    {
        XTAG(D3DFMT_A8R8G8B8), XTAG(D3DFMT_X8R8G8B8), XTAG(D3DFMT_R5G6B5),
        XTAG(D3DFMT_R6G5B5), XTAG(D3DFMT_X1R5G5B5), XTAG(D3DFMT_A1R5G5B5),
        XTAG(D3DFMT_A4R4G4B4), XTAG(D3DFMT_A8), XTAG(D3DFMT_A8B8G8R8),
        XTAG(D3DFMT_B8G8R8A8), XTAG(D3DFMT_R4G4B4A4), XTAG(D3DFMT_R5G5B5A1),
        XTAG(D3DFMT_R8G8B8A8), XTAG(D3DFMT_R8B8), XTAG(D3DFMT_G8B8),
        XTAG(D3DFMT_P8), XTAG(D3DFMT_L8), XTAG(D3DFMT_A8L8),
        XTAG(D3DFMT_AL8), XTAG(D3DFMT_L16), XTAG(D3DFMT_V8U8),
        XTAG(D3DFMT_L6V5U5), XTAG(D3DFMT_X8L8V8U8), XTAG(D3DFMT_Q8W8V8U8),
        XTAG(D3DFMT_V16U16), XTAG(D3DFMT_D16_LOCKABLE), XTAG(D3DFMT_D16),
        XTAG(D3DFMT_D24S8), XTAG(D3DFMT_F16), XTAG(D3DFMT_F24S8),
        XTAG(D3DFMT_UYVY), XTAG(D3DFMT_YUY2), XTAG(D3DFMT_DXT1),
        XTAG(D3DFMT_DXT2), XTAG(D3DFMT_DXT3), XTAG(D3DFMT_DXT4),
        XTAG(D3DFMT_DXT5), XTAG(D3DFMT_LIN_A1R5G5B5), XTAG(D3DFMT_LIN_A4R4G4B4),
        XTAG(D3DFMT_LIN_A8), XTAG(D3DFMT_LIN_A8B8G8R8), XTAG(D3DFMT_LIN_A8R8G8B8),
        XTAG(D3DFMT_LIN_B8G8R8A8), XTAG(D3DFMT_LIN_G8B8), XTAG(D3DFMT_LIN_R4G4B4A4),
        XTAG(D3DFMT_LIN_R5G5B5A1), XTAG(D3DFMT_LIN_R5G6B5), XTAG(D3DFMT_LIN_R6G5B5),
        XTAG(D3DFMT_LIN_R8B8), XTAG(D3DFMT_LIN_R8G8B8A8), XTAG(D3DFMT_LIN_X1R5G5B5),
        XTAG(D3DFMT_LIN_X8R8G8B8), XTAG(D3DFMT_LIN_A8L8), XTAG(D3DFMT_LIN_AL8),
        XTAG(D3DFMT_LIN_L16), XTAG(D3DFMT_LIN_L8), XTAG(D3DFMT_LIN_D24S8),
        XTAG(D3DFMT_LIN_F24S8), XTAG(D3DFMT_LIN_D16), XTAG(D3DFMT_LIN_F16),
        XTAG(D3DFMT_UNKNOWN),
    };
    static const int cFmts = sizeof(rgszD3DFmt) / sizeof(rgszD3DFmt[0]);

    for(int ifmt = 0; ifmt < cFmts; ifmt++)
    {
        if(rgszD3DFmt[ifmt].d3dformat == d3dformat)
            return rgszD3DFmt[ifmt].szD3DFormat;
    }

    return rgszD3DFmt[cFmts - 1].szD3DFormat;
}

//=========================================================================
// Check whether specified format is linear
//=========================================================================
bool IsLinearFormat(DWORD Format)
{
    switch(Format)
    {
    case D3DFMT_LIN_A1R5G5B5:
    case D3DFMT_LIN_A4R4G4B4:
    case D3DFMT_LIN_A8:
    case D3DFMT_LIN_A8B8G8R8:
    case D3DFMT_LIN_A8R8G8B8:
    case D3DFMT_LIN_B8G8R8A8:
    case D3DFMT_LIN_G8B8:
    case D3DFMT_LIN_R4G4B4A4:
    case D3DFMT_LIN_R5G5B5A1:
    case D3DFMT_LIN_R5G6B5:
    case D3DFMT_LIN_R6G5B5:
    case D3DFMT_LIN_R8B8:
    case D3DFMT_LIN_R8G8B8A8:
    case D3DFMT_LIN_X1R5G5B5:
    case D3DFMT_LIN_X8R8G8B8:

    case D3DFMT_LIN_A8L8:
    case D3DFMT_LIN_AL8:
    case D3DFMT_LIN_L16:
    case D3DFMT_LIN_L8:

    case D3DFMT_LIN_D24S8:
    case D3DFMT_LIN_F24S8:
    case D3DFMT_LIN_D16:
    case D3DFMT_LIN_F16:
        return true;
    }

    return false;
}

//=========================================================================
// Return number of bits per pixel/texel.
//=========================================================================
DWORD BitsPerPixelOfD3DFORMAT(DWORD Format)
{
    DWORD retval = 0;

    switch(Format)
    {
    case D3DFMT_A8R8G8B8:   // Q8W8V8U8
    case D3DFMT_X8R8G8B8:   // X8L8V8U8
    case D3DFMT_A8B8G8R8:
    case D3DFMT_B8G8R8A8:
    case D3DFMT_R8G8B8A8:
    case D3DFMT_V16U16:
    case D3DFMT_D24S8:
    case D3DFMT_F24S8:
    case D3DFMT_UYVY:
    case D3DFMT_YUY2:
    case D3DFMT_LIN_A8B8G8R8:
    case D3DFMT_LIN_A8R8G8B8:
    case D3DFMT_LIN_B8G8R8A8:
    case D3DFMT_LIN_R8G8B8A8:
    case D3DFMT_LIN_X8R8G8B8:
    case D3DFMT_LIN_D24S8:
    case D3DFMT_LIN_F24S8:
        retval = 32;
        break;

    case D3DFMT_R5G6B5:
    case D3DFMT_X1R5G5B5:
    case D3DFMT_A1R5G5B5:
    case D3DFMT_A4R4G4B4:
    case D3DFMT_R4G4B4A4:
    case D3DFMT_R5G5B5A1:
    case D3DFMT_R8B8:
    case D3DFMT_G8B8:   // V8U8
    case D3DFMT_A8L8:
    case D3DFMT_L16:
    case D3DFMT_L6V5U5:
    case D3DFMT_D16_LOCKABLE:  // D16
    case D3DFMT_F16:
    case D3DFMT_LIN_A1R5G5B5:
    case D3DFMT_LIN_A4R4G4B4:
    case D3DFMT_LIN_G8B8:
    case D3DFMT_LIN_R4G4B4A4:
    case D3DFMT_LIN_R5G5B5A1:
    case D3DFMT_LIN_R5G6B5:
    case D3DFMT_LIN_R6G5B5:
    case D3DFMT_LIN_R8B8:
    case D3DFMT_LIN_X1R5G5B5:
    case D3DFMT_LIN_A8L8:
    case D3DFMT_LIN_L16:
    case D3DFMT_LIN_D16:
    case D3DFMT_LIN_F16:
        retval = 16;
        break;

    case D3DFMT_A8:
    case D3DFMT_P8:
    case D3DFMT_L8:
    case D3DFMT_AL8:
    case D3DFMT_LIN_A8:
    case D3DFMT_LIN_AL8:
    case D3DFMT_LIN_L8:
        retval = 8;
        break;

    case D3DFMT_DXT1:
        retval = 4;
        break;

    case D3DFMT_DXT2: // DXT3
    case D3DFMT_DXT4: // DXT5
        retval = 8;
        break;

    default:
        CheckHR(E_FAIL);
        retval = 0;
        break;
    }

    return retval;
}

//=========================================================================
// Return file's last write time
//=========================================================================
UINT64 GetFileTime(LPCSTR lpFileName)
{
    WIN32_FILE_ATTRIBUTE_DATA fad;

    GetFileAttributesExA(lpFileName, GetFileExInfoStandard, &fad);
    return *(UINT64 *)&fad.ftLastWriteTime;
}

//=========================================================================
// Display d3d error then break into debugger
//=========================================================================
void DisplayError(const char *szCall, HRESULT hr)
{
    char szErr[512];

    if(hr)
    {
        UINT cch = _snprintf(szErr, sizeof(szErr), "FATAL: %s failed 0x%08lX: ", szCall, hr);

        D3DXGetErrorStringA(hr, &szErr[cch], sizeof(szErr) - cch - 1);
    }
    else
    {
        lstrcpynA(szErr, szCall, sizeof(szErr) - 1);
    }

    lstrcatA(szErr, "\n");
    OutputDebugStringA(szErr);

    _asm int 3;
}

//=========================================================================
// Formatted debug squirty
//=========================================================================
void _cdecl dprintf(LPCSTR lpFmt, ...)
{
    va_list arglist;
    char lpOutput[256];

    va_start(arglist, lpFmt);
    _vsnprintf(lpOutput, sizeof(lpOutput), lpFmt, arglist);
    va_end(arglist);

    OutputDebugStringA(lpOutput);
}

//=========================================================================
// Draw CScrText text buffer to front buffer
//=========================================================================
void CScrText::drawtext(bool fDebugSquirty)
{
    IDirect3DSurface8 *pFrontBuffer = NULL;

    D3DDevice_GetBackBuffer(-1, D3DBACKBUFFER_TYPE_MONO, &pFrontBuffer);
    if(pFrontBuffer)
    {
        // render results to the frontbuffer
        DWORD dx = 40;
        DWORD dy = 20;
        DWORD dwHeight;

        g_bitfont.GetTextStringLength(NULL, &dwHeight, NULL);
        dwHeight += 2;

        for(int iBuf = 0; iBuf < m_iLine; iBuf++)
        {
            if(fDebugSquirty)
                dprintf("%s\n", m_rgText[iBuf]);

            if(m_rgText[iBuf][0])
                g_bitfont.DrawText(pFrontBuffer, m_rgText[iBuf], dx, dy, 0, 0xff9f9f9f, 0);

            dy += dwHeight;
        }

        RELEASE(pFrontBuffer);
    }
}

//=========================================================================
// Add a string to the CScrText string buffer
//=========================================================================
void _cdecl CScrText::printf(LPCSTR lpFmt, ...)
{
    va_list arglist;

    va_start(arglist, lpFmt);
    _vsnprintf(m_rgText[m_iLine], LINE_WIDTH, lpFmt, arglist);
    va_end(arglist);

	//7 sep 2001: prevent buffer overrun when printing text on the last line
	m_rgText[m_iLine][LINE_WIDTH - 1] = '\0'; 

    m_iLine = (m_iLine + 1) % NUM_LINES;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\vshtimer\vshtimer.cpp ===
//-----------------------------------------------------------------------------
// FILE: FILLRATE.CPP
//
// Desc: vertex shader tune app
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <d3d8perf.h>
#include <stdio.h>
#include <assert.h>

// With the profile build we can spew out how much time
// was spent in pushbuffer waits. However you must link
// with d3d8i.lib so it's off by default.
#define PROFILE     0

#include "utils.h"
#include "inifile.h"
#include "vstune.h"
#include "vshgen.h"
#include "xgraphics.h"
#include <time.h>

extern "C" void DebugPrint(const char*,...);

/*
 * globals
 */
IDirect3DDevice8       *g_pDev = NULL;                  // our device
IDirect3DVertexBuffer8 *g_pVB[16] = {NULL};             // stream vertex buffers
IDirect3DTexture8      *g_pTextures[4] = { NULL };

DWORD                  *g_pAlloc = NULL;                // a random WC allocation
const int               g_AllocSize = 1024*1024;        // random allocation size

DWORD                   g_dwVertexShader;               // vertex shader handle

DWORD                   g_dwFVFSize[16];                // FVF sizes for each stream

WORD                   *g_pindices = NULL;              // out indices

HANDLE                  g_hInpDevice = NULL;            // input device

CScrText                g_scrtext;                      // text helper
CIniFile                g_inifile("d:\\vstune.ini");    // Ini file

bool                    g_fRedrawScreen = true;         // refresh screen?
volatile bool           g_gpudrawingdone = false;       // is the gpu done drawing?

VSTSETTINGS             g_var = {0};                    // current settings

DWORD                   g_Declaration[MAX_FVF_DECL_SIZE]; // vertex shader declaration
DWORD                   g_nvclk = 250;

HANDLE                  g_hThread = NULL;

D3DPERF                 *g_pPerf;

struct
{
    LPCSTR szDesc;
    void (*pfnTest)();
} g_rgTests[] =
{
    { "Current",                DoQuickTimedTest },
    { "PushBuffer Call Test",   DoPushBufferCallTest },
	{ "Random VS",              RandomVS },
	{ "NOP Timer",              NopVS },
};
UINT g_iCurTest = 0;

//=========================================================================
// Init Direct3d
//=========================================================================
bool InitD3D()
{
    static D3DPRESENT_PARAMETERS d3dppCur = {0};
    D3DPRESENT_PARAMETERS d3dpp = {0};

    // Set the screen mode.
    d3dpp.BackBufferWidth                   = UINT(g_var.screenwidth);
    d3dpp.BackBufferHeight                  = UINT(g_var.screenheight);
    d3dpp.BackBufferFormat                  = g_var.BackBufferFormat;
    d3dpp.BackBufferCount                   = 1;
    d3dpp.EnableAutoDepthStencil            = !!g_var.AutoDepthStencilFormat;
    d3dpp.AutoDepthStencilFormat            = g_var.AutoDepthStencilFormat;
    d3dpp.SwapEffect                        = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz        = 60;
    d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;
    d3dpp.Flags                             = // D3DCREATE_NOPRESENTTHROTTLE |
                                                D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;

    if(g_var.MSType != D3DMULTISAMPLE_NONE)
        d3dpp.MultiSampleType = (D3DMULTISAMPLE_TYPE)((DWORD)(g_var.MSType) | (DWORD)(g_var.MSFormat));

    // if nothing has changed - don't reinit
    if(!memcmp(&d3dppCur, &d3dpp, sizeof(D3DPRESENT_PARAMETERS)))
        return true;
    d3dppCur = d3dpp;

    if(g_pDev)
    {
        for(int itex = 0; itex < 4; itex++)
            RELEASE(g_pTextures[itex]);

        if(g_dwVertexShader)
        {
            g_pDev->SetVertexShader(D3DFVF_XYZ);
            g_pDev->DeleteVertexShader(g_dwVertexShader);
            g_dwVertexShader = 0;
        }

        // make sure everything is freed
        for(int ivb = 0; ivb < ARRAYSIZE(g_pVB); ivb++)
            RELEASE(g_pVB[ivb]);
        RELEASE(g_pDev);
    }

    // Create the device.
    if(Direct3D_CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
        NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDev))
    {
        CheckHR(E_FAIL);
        return false;
    }

    for(int itex = 0; itex < 4; itex++)
    {
        CheckHR(g_pDev->CreateTexture(4, 4, 1, 0, D3DFMT_A4R4G4B4,
            D3DPOOL_MANAGED, &g_pTextures[itex]));
    }

    g_nvclk = GetNVCLK();
    dprintf("gpu clk: %d\n", g_nvclk);

    return true;
}

//=========================================================================
// quick routine to return token type from decl
//=========================================================================
inline DWORD VSDGetTokenType(DWORD dwDecl)
{
    return (dwDecl & D3DVSD_TOKENTYPEMASK) >> D3DVSD_TOKENTYPESHIFT;
}

//=========================================================================
// return data type from decl
//=========================================================================
inline DWORD VSDGetDataType(DWORD dwDecl)
{
    return (dwDecl & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT;
}

//=========================================================================
// get skip count from decl
//=========================================================================
inline DWORD VSDGetSkipCount(DWORD dwDecl)
{
    return (dwDecl & D3DVSD_SKIPCOUNTMASK) >> D3DVSD_SKIPCOUNTSHIFT;
}

//=========================================================================
// Given a D3DVSD_TOKEN_STREAMDATA return # of bytes it requires
//=========================================================================
DWORD dwBytesForStreamData(DWORD dwDecl)
{
    if(dwDecl & 0x08000000)
    {
        // D3DVSD_SKIPBYTES
        return VSDGetSkipCount(dwDecl);
    }
    else if(dwDecl & 0x10000000)
    {
        // D3DVSD_SKIP DWORDS
        return VSDGetSkipCount(dwDecl) * sizeof(DWORD);
    }
    else
    {
        DWORD dwType = VSDGetDataType(dwDecl);
        DWORD dwCount = (dwType >> 4) & 0xf;

        switch(dwType & 0xf)
        {
        case 0x0:   // D3DCOLOR
            return dwCount * sizeof(BYTE);
        case 0x2:   // float
            return dwCount * sizeof(float);
        case 0x1:   // NORMSHORT
        case 0x5:   // short
            return dwCount * sizeof(short);
        case 0x6:   // NORMPACKED
            return dwCount * sizeof(DWORD);
        case 0x4:   // PBYTE
            return dwCount * sizeof(BYTE);
        }
    }

    return 0;
}

//=========================================================================
// Return vert size for specific stream in declaration
//=========================================================================
DWORD GetDeclVertexSize(DWORD dwStream, DWORD *pDecl)
{
    DWORD dwBytes = 0;
    DWORD dwCurStream = (DWORD)-1;

    while(*pDecl != D3DVSD_END())
    {
        if(VSDGetTokenType(*pDecl) == D3DVSD_TOKEN_STREAM)
        {
            dwCurStream = *pDecl & D3DVSD_STREAMNUMBERMASK;
        }
        else if(dwCurStream == dwStream &&
            VSDGetTokenType(*pDecl) == D3DVSD_TOKEN_STREAMDATA)
        {
            dwBytes += dwBytesForStreamData(*pDecl);
        }

        pDecl++;
    }

    return dwBytes;
}

//=========================================================================
// Create our index buffer
//=========================================================================
void CreateIB()
{
    if(g_pindices)
    {
        delete [] g_pindices;
        g_pindices = NULL;
    }

    if(g_var.pushbuffernops)
        g_var.TriCount = g_var.indexcount;
    else
    {
        switch(g_var.primitivetype)
        {
        case D3DPT_POINTLIST:
            g_var.TriCount = g_var.indexcount;
            break;
        case D3DPT_TRIANGLELIST:
            g_var.indexcount = (g_var.indexcount / 3) * 3;
            g_var.TriCount = g_var.indexcount / 3;
            break;
        case D3DPT_TRIANGLESTRIP:
        case D3DPT_TRIANGLEFAN:
            g_var.TriCount = g_var.indexcount - 2;
            break;
        case D3DPT_QUADLIST:
            g_var.indexcount = (g_var.indexcount / 4) * 4;
            g_var.TriCount = g_var.indexcount / 2;
            break;
        case D3DPT_QUADSTRIP:
            g_var.indexcount = (g_var.indexcount / 2) * 2;
            g_var.TriCount = (g_var.indexcount / 2 - 1) * 2;
            break;
        case D3DPT_POLYGON:
        case D3DPT_LINELIST:
        case D3DPT_LINELOOP:
        case D3DPT_LINESTRIP:
        default:
            g_var.TriCount = g_var.indexcount;
            _asm int 3;
            break;
        }
    }

    // create our index buffer
    g_pindices = new WORD [g_var.indexcount];

    WORD *pindices = g_pindices;
    for(UINT ivert = 0; ivert < g_var.indexcount; ivert++)
    {
        *pindices++ = LOWORD(ivert % g_var.vertcount);
    }
}

//=========================================================================
// Copy count of floats from src to dst
//=========================================================================
inline float *MyMemCpy(float *dst, const float *src, int count)
{
    memcpy(dst, src, count * sizeof(float));
    return dst + count;
}

//=========================================================================
// Create our vertex buffer for specific stream defined in g_pDeclaration
//=========================================================================
void CreateVB(DWORD istream)
{
    RELEASE(g_pVB[istream]);

    if(!g_var.FVF)
    {
        // calculate stream size and length
        g_dwFVFSize[istream] = GetDeclVertexSize(istream, g_Declaration);

        UINT VBLength = g_dwFVFSize[istream] * g_var.vertcount;

        CheckHR(g_pDev->CreateVertexBuffer(VBLength, 0, 0, 0, &g_pVB[istream]));

        byte *pVerts;
        CheckHR(g_pVB[istream]->Lock(0, VBLength, (BYTE **)&pVerts, 0));

        // Fill it up.
        memset(pVerts, 0x11, VBLength);

        CheckHR(g_pVB[istream]->Unlock());
    }
    else
    {
        g_dwFVFSize[istream] = D3DXGetFVFVertexSize(g_var.FVF);

        UINT VBLength = g_dwFVFSize[istream] * g_var.vertcount;

        CheckHR(g_pDev->CreateVertexBuffer(VBLength, 0, 0, 0, &g_pVB[istream]));

        float *pVerts;
        CheckHR(g_pVB[istream]->Lock(0, VBLength, (BYTE **)&pVerts, 0));

        int dy = 0;
        int iIndex = 0;
        D3DXVECTOR4 tex0(0, 0, 0, 1.0f);
        D3DXVECTOR4 pos(-2000, -2000, .5f, 1.0f);
        D3DXVECTOR3 norm(0, .707f, .707f);
        DWORD diffuse = D3DCOLOR_COLORVALUE(tex0.x, tex0.y, 1.0f - tex0.x, 2.0f / 0xff);

        for(UINT ivert = 0; ivert < g_var.vertcount; ivert++)
        {
            if(!g_var.degenerates)
            {
                static float xval = 4.0f;
                static float yval = 4.0f;

                pos.x = xval * (iIndex / 2);
                pos.y = dy + yval * (iIndex & 0x1);

                // if we're not doing just degenerate tris then move along
                // in a nice little grid pattern
                iIndex++;

                if(pos.x + xval > g_var.screenwidth)
                {
                    iIndex = 0;
                    dy += int(yval) + 1;
                }
            }

            if(g_var.FVF & D3DFVF_XYZRHW)
                pVerts = MyMemCpy(pVerts, pos, 4);
            else if(g_var.FVF & D3DFVF_XYZ)
                pVerts = MyMemCpy(pVerts, pos, 3);

            if(g_var.FVF & D3DFVF_NORMAL)
                pVerts = MyMemCpy(pVerts, norm, 3);

            if(g_var.FVF & D3DFVF_DIFFUSE)
                *(DWORD *)pVerts++ = diffuse;

            if(g_var.FVF & D3DFVF_SPECULAR)
                *(DWORD *)pVerts++ = ~diffuse;

            // Texture coordinates
            UINT uNumTexCoords = (((g_var.FVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT);
            UINT uTextureFormats = g_var.FVF >> 16;

            if(uTextureFormats)
            {
                for(UINT i = 0; i < uNumTexCoords; i++)
                {
                    switch(uTextureFormats & 3)
                    {
                    case D3DFVF_TEXTUREFORMAT1:     // u
                        *pVerts++ = tex0.x;
                        break;
                    case D3DFVF_TEXTUREFORMAT2:     // u,v
                        pVerts = MyMemCpy(pVerts, tex0, 2);
                        break;
                    case D3DFVF_TEXTUREFORMAT3:     // s,t,r
                        pVerts = MyMemCpy(pVerts, tex0, 3);
                        break;
                    case D3DFVF_TEXTUREFORMAT4:     // s,t,r,q
                        pVerts = MyMemCpy(pVerts, tex0, 4);
                        break;
                    }

                    uTextureFormats >>= 2;
                }
            }
            else while(uNumTexCoords--)
            {
                // u,v
                pVerts = MyMemCpy(pVerts, tex0, 2);
            }
        }

        CheckHR(g_pVB[istream]->Unlock());
    }
}

//=========================================================================
// initialize our lights
//=========================================================================
void InitLights()
{
    // disable all our existing lights
    for(DWORD i = 0; i < g_var.NumLights; i++)
        CheckHR(g_pDev->LightEnable(g_var.NumLights, FALSE));

    // get count of new lights
    g_var.NumLights =
        g_var.numDirectionalLights +
        g_var.numPointLights +
        g_var.numSpotLights;

    // setup lights
    float fIntensity = 1.0f / g_var.NumLights;
    D3DXCOLOR Diffuse(fIntensity, fIntensity, fIntensity, 1.0f);

    DWORD dwIndex = 0;
    for(i = 0; i < g_var.numDirectionalLights; i++)
    {
        D3DLIGHT8 lig = { D3DLIGHT_DIRECTIONAL };

        lig.Diffuse     =  Diffuse;
        lig.Direction   =  D3DXVECTOR3(0.2f, 0.3f, -0.8f);

        CheckHR(g_pDev->SetLight(dwIndex, &lig));
        CheckHR(g_pDev->LightEnable(dwIndex, TRUE));
        dwIndex++;
    }

    for(i = 0; i < g_var.numPointLights; i++)
    {
        D3DLIGHT8 lig = { D3DLIGHT_POINT };

        lig.Diffuse      =  Diffuse;
        lig.Position     =  D3DXVECTOR3(0.0f, 0.0f, 5.0f);
        lig.Range        = 9999.0f;
        lig.Attenuation0 = 1.0f;

        CheckHR(g_pDev->SetLight(dwIndex, &lig));
        CheckHR(g_pDev->LightEnable(dwIndex, TRUE));
        dwIndex++;
    }

    for(i = 0; i < g_var.numSpotLights; i++)
    {
        D3DLIGHT8 lig = { D3DLIGHT_SPOT };

        lig.Diffuse      = Diffuse;
        lig.Position     = D3DXVECTOR3(-1.0f, -5.0f, 6.0f);
        lig.Direction    = D3DXVECTOR3(0.1f, 0.5f, -0.6f);
        lig.Range        = 999.0f;
        lig.Theta        = 0.1f;
        lig.Phi          = 0.5f;
        lig.Falloff      = 1.0f;
        lig.Attenuation0 = 1.0f;

        CheckHR(g_pDev->SetLight(dwIndex, &lig));
        CheckHR(g_pDev->LightEnable(dwIndex, TRUE));
        dwIndex++;
    }
}


//=========================================================================
// Initialize fillrate app
//=========================================================================
bool InitVST(bool freadINIFile)
{
    if(freadINIFile && !ReadVSTIniFile())
        dprintf("%s not found", g_inifile.GetFileName());

    // init d3d
    if(!InitD3D())
    {
        dprintf("InitD3D failed.\n");
        return false;
    }

    // init our render states
    CheckHR(g_pDev->SetRenderState(D3DRS_LIGHTING,  g_var.lighting));
    CheckHR(g_pDev->SetRenderState(D3DRS_SPECULARENABLE, g_var.specularenable));
    CheckHR(g_pDev->SetRenderState(D3DRS_LOCALVIEWER, g_var.localviewer));
    CheckHR(g_pDev->SetRenderState(D3DRS_NORMALIZENORMALS, g_var.normalizenormals));

    CheckHR(g_pDev->SetRenderState(D3DRS_COLORVERTEX, g_var.colorvertex));

    static DWORD dwMatSource = D3DMCS_COLOR1;
    CheckHR(g_pDev->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE,  dwMatSource));
    CheckHR(g_pDev->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, dwMatSource));
    CheckHR(g_pDev->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE,  dwMatSource));
    CheckHR(g_pDev->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, dwMatSource));

    CheckHR(g_pDev->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_FLAT));

    CheckHR(g_pDev->SetRenderState(D3DRS_FOGENABLE, g_var.fogenable));

    // z buffer
    CheckHR(g_pDev->SetRenderState(D3DRS_ZENABLE, g_var.zenable));
    CheckHR(g_pDev->SetRenderState(D3DRS_ZWRITEENABLE, g_var.zwriteenable));
    CheckHR(g_pDev->SetRenderState(D3DRS_ZFUNC, g_var.d3dcmpfunc));

    // alpha blending
    CheckHR(g_pDev->SetRenderState(D3DRS_ALPHABLENDENABLE, g_var.alphablendenable));
    CheckHR(g_pDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA));
    CheckHR(g_pDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA));

    CheckHR(g_pDev->SetRenderState(D3DRS_ALPHATESTENABLE, g_var.alphatestenable));
    CheckHR(g_pDev->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_ALWAYS));
    CheckHR(g_pDev->SetRenderState(D3DRS_ALPHAREF, 0x00000001));

    // fill and cull mode
    CheckHR(g_pDev->SetRenderState(D3DRS_FILLMODE, g_var.d3dfillmode));
    CheckHR(g_pDev->SetRenderState(D3DRS_CULLMODE, g_var.cullmode));

    // initialize lights
    InitLights();

    // initialize vertex shader or FVF declaration
    InitVertexShader();

    // set up texture stages
    for(DWORD itex = 0; itex < 4; itex++)
    {
        if(itex < g_var.numtextures)
        {
            CheckHR(g_pDev->SetTexture(itex, g_pTextures[itex]));

            CheckHR(g_pDev->SetTextureStageState(0, D3DTSS_COLORARG1,D3DTA_TEXTURE));
            CheckHR(g_pDev->SetTextureStageState(0, D3DTSS_COLOROP,  D3DTOP_MODULATE));
            CheckHR(g_pDev->SetTextureStageState(0, D3DTSS_COLORARG2,D3DTA_DIFFUSE));

            CheckHR(g_pDev->SetTextureStageState(0, D3DTSS_ALPHAARG1,D3DTA_TEXTURE));
            CheckHR(g_pDev->SetTextureStageState(0, D3DTSS_ALPHAOP,  D3DTOP_MODULATE));
            CheckHR(g_pDev->SetTextureStageState(0, D3DTSS_ALPHAARG2,D3DTA_DIFFUSE));
        }
        else
        {
            CheckHR(g_pDev->SetTexture(itex, NULL));

            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_COLOROP, D3DTOP_DISABLE));
            CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_ALPHAOP, D3DTOP_DISABLE));
        }

        CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP));
        CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP));

        CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_MINFILTER, D3DTEXF_LINEAR));
        CheckHR(g_pDev->SetTextureStageState(itex, D3DTSS_MAGFILTER, D3DTEXF_LINEAR));
    }

    // create our index buffer
    CreateIB();

    // create all our vertex buffer streams
    for(DWORD istream = 0; istream < g_var.NumStreams; istream++)
        CreateVB(istream);

    // Initialize our VAB entries so we have consistent and unique values
    for(DWORD Register = 0; Register < 16; Register++)
    {
        float val = (float)Register;

        g_pDev->SetVertexData4f(Register,
            val + .1f, val + .2f, val + .3f, val + .4f);
    }

    // if we're not writing stuff in the background then suspend our thread
    if(g_var.wcwritesinbkgnd != 2)
        SuspendThread(g_hThread);
    else
    {
        while(ResumeThread(g_hThread) > 1)
            ;
    }

    return true;
}

//=========================================================================
// clear surface
//=========================================================================
void ClearScreen()
{
    // clear stuff
    DWORD dwCFlags = g_var.clearflags;

    if(!g_var.AutoDepthStencilFormat)
        dwCFlags &= ~(D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL);

    CheckHR(g_pDev->Clear(0, NULL, dwCFlags, g_var.cclearval,
        g_var.zclearval, g_var.sclearval));
}

//=========================================================================
// Initialize the vertex shader and stream source(s)
//=========================================================================
void InitFrame()
{
    CheckHR(g_pDev->SetVertexShader(g_dwVertexShader));

    for(DWORD istream = 0; istream < g_var.NumStreams; istream++)
        CheckHR(g_pDev->SetStreamSource(istream, g_pVB[istream], g_dwFVFSize[istream]));
}

//=========================================================================
// Render the vertices x times
//=========================================================================
void RenderFrame(int vbdrawcount, BOOL nops)
{
    if(nops)
    {
        while(vbdrawcount--)
        {
            for(DWORD index = 0; index < g_var.indexcount; index++)
                D3DDevice_Nop();
        }
    }
    else
    {
        while(vbdrawcount--)
        {
            CheckHR(g_pDev->DrawIndexedVertices(g_var.primitivetype, g_var.indexcount, g_pindices));
        }
    }
}

//=========================================================================
// Handle joystick input
//=========================================================================
void HandleInput(DWORD dwTicks)
{
    static BOOL fRunTestRightNow = FALSE;

    if(g_inifile.FileChanged())
    {
        InitVST(true);

        fRunTestRightNow = g_var.runtestonreload;

        g_fRedrawScreen = true;
    }

    // If we don't have a device don't let them start any tests.
    // They're going to have to change their settings in fillrate.ini
    // and just try again.
    if(!g_pDev)
        return;

    if(!g_hInpDevice)
        g_hInpDevice = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL);

    if(g_hInpDevice)
    {
        XINPUT_STATE xinpstate = {0};
        static XINPUT_STATE xinpstatelast;
#define FButtonDown(_btn) \
        (xinpstate.Gamepad.bAnalogButtons[_btn] && \
            (!xinpstate.Gamepad.bAnalogButtons[_btn] != !xinpstatelast.Gamepad.bAnalogButtons[_btn]))

        XInputGetState(g_hInpDevice, &xinpstate);

        if(fRunTestRightNow || FButtonDown(XINPUT_GAMEPAD_A))
        {
            fRunTestRightNow = FALSE;

            // run current test
            g_rgTests[g_iCurTest].pfnTest();

            // draw one scene with current settings
            ClearScreen();
            InitFrame();
            RenderFrame(1);

            // flip that dude to the front
            CheckHR(g_pDev->Present(NULL, NULL, NULL, NULL));

            // plaster our results on the front buffer
            g_scrtext.drawtext(g_var.verboselevel >= 1);
            g_fRedrawScreen = false;
        }

        if(FButtonDown(XINPUT_GAMEPAD_LEFT_TRIGGER))
        {
            g_iCurTest = (g_iCurTest + ARRAYSIZE(g_rgTests) - 1) % ARRAYSIZE(g_rgTests);
            g_fRedrawScreen = true;
        }

        if(FButtonDown(XINPUT_GAMEPAD_RIGHT_TRIGGER))
        {
            g_iCurTest = (g_iCurTest + 1) % ARRAYSIZE(g_rgTests);
            g_fRedrawScreen = true;
        }

        if(FButtonDown(XINPUT_GAMEPAD_X))
        {
            InitVST(true);
            g_fRedrawScreen = true;
        }

        if(FButtonDown(XINPUT_GAMEPAD_Y))
        {
            // toggle wireframe and solid fill modes
            g_var.d3dfillmode = (g_var.d3dfillmode == D3DFILL_WIREFRAME) ?
                D3DFILL_SOLID : D3DFILL_WIREFRAME;
            CheckHR(g_pDev->SetRenderState(D3DRS_FILLMODE, g_var.d3dfillmode));
            g_fRedrawScreen = true;
        }

        xinpstatelast = xinpstate;
    }
}

//=========================================================================
//
//=========================================================================
const char *szGetPTType(DWORD pt)
{
    static const char *rgszD3DPT[] =
    {
        "D3DPT_0",
        "D3DPT_POINTLIST",
        "D3DPT_LINELIST",
        "D3DPT_LINELOOP",
        "D3DPT_LINESTRIP",
        "D3DPT_TRIANGLELIST",
        "D3DPT_TRIANGLESTRIP",
        "D3DPT_TRIANGLEFAN",
        "D3DPT_QUADLIST",
        "D3DPT_QUADSTRIP",
        "D3DPT_POLYGON",
        "D3DPT_?",
    };

    return rgszD3DPT[min(pt, ARRAYSIZE(rgszD3DPT))];
}

//=========================================================================
// Do a series of pushbuffer calls w/ varying pushbuffer sizes
//=========================================================================
void DoPushBufferCallTest()
{
    // clear screen text
    g_scrtext.cls();

    g_var.vbdrawcount = 1;
    g_var.framesperpushbuffermax = 1;

    DumpCurrentSettings();

    char szIndices[256];
    static const char *szDefIndices =
        "50, 100, 250, 500, 1000, 1500, 2000, 2500, 5000, 10000, 20000, 40000";

    g_inifile.GetIniStrBuf("pushbuffercalltest", "indices",
        szDefIndices, szIndices, sizeof(szIndices));

    dprintf("** PushBufferCallTest (%s) **\n", szIndices);

    static const char *rgHdrsNops[2] =
        { "Mnops", "cycles/nop" };
    static const char *rgHdrsIndices[2] =
        { "Mtps", "cycles/vert" };
    const char **rgHdrs = g_var.pushbuffernops ? rgHdrsNops : rgHdrsIndices;
    char *sizehdr = g_var.precompiled ? "pushbufsize" : "# indices";

    g_scrtext.printf("%-12s %-7s %-7s %-10s(%d)"
#if PROFILE
        " waits waittime(ms)"
#endif
        , sizehdr,
        rgHdrs[0], rgHdrs[1], "throughput", g_var.wcwritesinbkgnd);

    char *token;
    const char seps[]   = " ,\t";
    token = strtok(szIndices, seps);
    while(token)
    {
        g_var.indexcount = atoi(token);

        if(g_var.verboselevel >= 1)
            dprintf("%d ", g_var.indexcount);

        if(g_var.indexcount)
        {
            InitVST(false);

            TIMETESTRESULTS ttres = {0};
            DoTimedTest(&ttres);

            g_scrtext.printf("%11d %6.2f  %12.2f %10.2f"
#if PROFILE
                " %8d-%.2f"
#endif
                , g_var.precompiled ? ttres.pushbuffersize : g_var.indexcount,
                ttres.mtps, ttres.cycles, ttres.throughput,
                ttres.PushBufferWaitInfo.Count,
                (double)(ttres.PushBufferWaitInfo.Cycles / 733) / 1000.0);
        }

        token = strtok(NULL, seps);
    }

    dprintf("\n\n");
    g_scrtext.printf("");

    // restore our settings
    InitVST(true);
}

//=========================================================================
// Do a quick test with the current settings
//=========================================================================
void DoQuickTimedTest()
{
    static DWORD testnum = 0;
    dprintf("\n*** test #%ld ***\n", ++testnum);

    // clear screen text
    g_scrtext.cls();

    // run test
    TIMETESTRESULTS ttres = {0};
    DoTimedTest(&ttres);

    DumpCurrentSettings();

    g_scrtext.printf("");

    // if we did the wc writes in the background spew the results
    if(g_var.wcwritesinbkgnd)
    {
        g_scrtext.printf("writer thread:  %s",
            (g_var.wcwritesinbkgnd == 1) ? "main" : "low prio bkgnd");
        g_scrtext.printf("bytes written:  %lu", ttres.byteswritten);
        g_scrtext.printf("throughput:     %.2f MB/s", ttres.throughput);
        g_scrtext.printf("");
    }

    g_scrtext.printf("pushbuffercalls:%d", ttres.pushbuffercalls);
    g_scrtext.printf("pushbuffersize :%d", ttres.pushbuffersize);

#if PROFILE
    g_scrtext.printf("pushbufferwaits:%d",   ttres.PushBufferWaitInfo.Count);
    g_scrtext.printf("pshbfwaittime:%.2fms", (double)(ttres.PushBufferWaitInfo.Cycles / 733) / 1000.0);
#endif

    // print out results
    g_scrtext.printf("");

    g_scrtext.printf("fps:            %.2f",     ttres.fps);
    g_scrtext.printf("frames:         %d",       ttres.cFrames);
    g_scrtext.printf("time:           %.2fms",   ttres.TimeTillIdle);

    if(g_var.pushbuffernops)
    {
        g_scrtext.printf("nops:           %I64u",    ttres.cTrisDrawn);
        g_scrtext.printf("Mnops:          %.2f",     ttres.mtps);
        g_scrtext.printf("cycles/nop:     %.2f",     ttres.cycles);
    }
    else
    {
        g_scrtext.printf("triangles:      %I64u",    ttres.cTrisDrawn);
        g_scrtext.printf("Mtps:           %.2f",     ttres.mtps);
        g_scrtext.printf("cycles/vert:    %.2f",     ttres.cycles);
    }
}

double GetExpectedCycles(LPXGBUFFER pListBuf) 
{
	double expectedcycles;

	char blah = ((char*)pListBuf->GetBufferPointer())[pListBuf->GetBufferSize() - 1];
	((char*)pListBuf->GetBufferPointer())[pListBuf->GetBufferSize() - 1] = '\0'; //XGBUFFERs don't null-terminate...

	char* pcycles = strstr((char*)pListBuf->GetBufferPointer(), "microcode:");
	if(pcycles == NULL) {
		_asm int 3;
	}

	double dummy;

	sscanf(pcycles, "microcode: %lf slots, %lf", &dummy, &expectedcycles);

	((char*)pListBuf->GetBufferPointer())[pListBuf->GetBufferSize() - 1] = blah;
	return expectedcycles;
}

void NopVS()
{
	TIMETESTRESULTS ttres = {0};
	DoTimedTest(&ttres);

	int nb, na, i; //nops before & after the code
	HRESULT hr;

	for(nb = 0; nb <= 00; nb++) {
		for(na = 0; na <= 40; na++) {

			XBuffer ShaderText;
			ShaderText.Printf("xvs.1.1\n"
				              "#pragma screenspace\n");

			for(i = 0; i < nb; i++) {
				ShaderText.Printf("nop\n");
			}

			ShaderText.Printf("mul r4, v14, c3                 \n"
							  "rcp r1, r4                      \n"
							  "nop                             \n"
							  "nop                             \n"
							  "nop                             \n"
							  "logp oPos, -r1.z                \n"





							  //"mul oPos, r1, r1   \n"




							  );

			for(i = 0; i < na; i++) {
				ShaderText.Printf("nop\n");
			}

			LPXGBUFFER ucodebuffer = NULL;
			LPXGBUFFER listbuffer = NULL;
			LPXGBUFFER errorbuffer = NULL;

			hr = XGAssembleShader("", ShaderText.GetText(), ShaderText.GetUsed(), SASM_DONOTOPTIMIZE | SASM_SKIPVALIDATION, NULL, &ucodebuffer, &errorbuffer, &listbuffer, NULL,          NULL,           NULL);
			//         pSourceFileName, pSrcData,              SrcDataLen,               Flags,     pConstants,   pCompiled,    pErrorLog,   pListing, pResolver, pResolverUserData, pShaderType

			if(FAILED(hr)) {
				OutputDebugStringA((char*)ShaderText.GetText());
				OutputDebugStringA((char*)errorbuffer->GetBufferPointer());
				_asm {int 3};
			}

			CheckHR(g_pDev->CreateVertexShader(g_Declaration, (DWORD*)ucodebuffer->GetBufferPointer(), &g_dwVertexShader, 0));

			double expectedcycles = GetExpectedCycles(listbuffer);

			TIMETESTRESULTS ttres = {0};
			DoTimedTest(&ttres);

			g_scrtext.cls();
			g_scrtext.printf("");
			g_scrtext.printf("Before: %2d   After: %2d     Expected: %6.2f   Actual: %6.2f", nb, na, expectedcycles, ttres.cycles);
			
			DebugPrint("Dbg: Before: %2d   After: %2d     Expected: %6.2f   Actual: %6.2f  Dif: %2.2f\n", nb, na, expectedcycles, ttres.cycles, ttres.cycles - expectedcycles);

			ShaderText.Clear();
			ucodebuffer->Release();
			listbuffer->Release();
			errorbuffer->Release();

		}
		DebugPrint("\n");
	}

}

void RandomVS()
{
	bool DoBreak = false;
	double expectedcycles;
	HRESULT hr;

	while(!DoBreak) {

		//generate & load random vertex shader here
		XBuffer* pShaderText = NULL;
		LPXGBUFFER ucodebuffer = NULL;
		LPXGBUFFER listbuffer = NULL;
		LPXGBUFFER errorbuffer = NULL;

		GenerateRandomVertexShader(
			g_var.dwRndShaderMin		,
			g_var.dwRndShaderMax		,
			g_var.dwRndShaderNops		,
			g_var.dwRndShaderType		,
			g_var.bRndShaderWriteConsts	,
			g_var.bRndShaderXvs			,
			g_var.bRndShaderIndex		,
			g_var.bRndShaderAllowPair	,
			g_var.bRndShaderScreenspace	,
			g_var.bRndShaderAllowNop	,
			&pShaderText
		);

		hr = XGAssembleShader("", pShaderText->GetText(), pShaderText->GetUsed(), SASM_DONOTOPTIMIZE, NULL, &ucodebuffer, &errorbuffer, &listbuffer, NULL,          NULL,           NULL);
		//         pSourceFileName, pSrcData,              SrcDataLen,               Flags,     pConstants,   pCompiled,    pErrorLog,   pListing, pResolver, pResolverUserData, pShaderType

		if(FAILED(hr)) {
			OutputDebugStringA((char*)pShaderText->GetText());
			OutputDebugStringA((char*)errorbuffer->GetBufferPointer());
		}

		CheckHR(g_pDev->CreateVertexShader(g_Declaration, (DWORD*)ucodebuffer->GetBufferPointer(), &g_dwVertexShader, 0));

		expectedcycles = GetExpectedCycles(listbuffer);

		TIMETESTRESULTS ttres = {0};
		DoTimedTest(&ttres);

		g_scrtext.cls();
		g_scrtext.printf("");
		g_scrtext.printf("expected cycles:  %.2f", expectedcycles);
		g_scrtext.printf("actual cycles:    %.2f", ttres.cycles);
		double dif = (expectedcycles - ttres.cycles);
		g_scrtext.printf("cycle difference: %.2f", dif);

		if((dif > 0.45 || dif < -0.45) && expectedcycles > 2.0) {
			OutputDebugStringA((char*)listbuffer->GetBufferPointer());
			DoBreak = true;
		} else {
			DebugPrint("Expected: %.2f   Actual: %.2f   Dif: %.2f\n", expectedcycles, ttres.cycles, dif);
		}

		pShaderText->~Buffer();
		ucodebuffer->Release();
		listbuffer->Release();
		errorbuffer->Release();
	};
}


//=========================================================================
//
//=========================================================================
inline char *MyStrCpy(char *dst, const char *src)
{
    while(*src && (*dst++ = *src++))
        ;

    return dst;
}

//=========================================================================
// Return a static char buffer with stream declaration
//=========================================================================
const char *SzGetDeclDescr(DWORD dwStream, DWORD *pDecl)
{
    static char szBuf[128];
    DWORD dwBytes = 0;
    DWORD dwCurStream = (DWORD)-1;

    char *psz = szBuf;

    while(*pDecl != D3DVSD_END())
    {
        if(VSDGetTokenType(*pDecl) == D3DVSD_TOKEN_STREAM)
        {
            dwCurStream = *pDecl & D3DVSD_STREAMNUMBERMASK;
        }
        else if(dwStream == dwCurStream &&
            VSDGetTokenType(*pDecl) == D3DVSD_TOKEN_STREAMDATA)
        {
            static const char rgReg[] = "0123456789abcdef";

            if(psz != szBuf)
                *psz++ = ',';

            if(*pDecl & 0x18000000)
            {
                psz = MyStrCpy(psz, (*pDecl & 0x08000000) ? "x:BYTES" : "x:DWRDS");
                *psz++ = char('0' + VSDGetSkipCount(*pDecl));
            }
            else
            {
                static const char *rgType[] =
                    { "CLR", "NRMSHRT", "FLT", "?", "PBYTE", "SHRT", "NRMPCKD", "??" };
                DWORD dwType = VSDGetDataType(*pDecl);
                DWORD dwCount = (dwType >> 4) & 0xf;

                *psz++ = char(rgReg[*pDecl & 0xf]);
                *psz++ = ':';

                psz = MyStrCpy(psz, rgType[min(dwType & 0xf, ARRAYSIZE(rgType))]);
                *psz++ = char('0' + dwCount);
            }
        }

        pDecl++;
    }

    *psz = 0;
    return szBuf;
}

//=========================================================================
// Dump the current options
//=========================================================================
void DumpCurrentSettings()
{
    if(g_var.pushbuffernops)
    {
        g_scrtext.printf("precompiled:    %d (w/ Kelvin nops)", g_var.precompiled);
        g_scrtext.printf("runusingcpucopy:%d",      g_var.runusingcpucopy);
        g_scrtext.printf("nop count:      %d * %d", g_var.indexcount, g_var.vbdrawcount);
    }
    else
    {
        DWORD dwFVFSizeTot = 0;

        for(DWORD istream = 0; istream < g_var.NumStreams; istream++)
            dwFVFSizeTot += g_dwFVFSize[istream];

        g_scrtext.printf("type:          %s",       szGetPTType(g_var.primitivetype));
        g_scrtext.printf("precompiled:   %d - %d pushbuffer(s)",
            g_var.precompiled, g_var.numberofpushbuffers);

        if(g_var.precompiled)
            g_scrtext.printf("runusingcpucopy:%d",      g_var.runusingcpucopy);

        if(g_var.uservertexshader)
            g_scrtext.printf("vertshaderlen: %d",   g_var.uservertexshader);

        g_scrtext.printf("vertcount:     %d",       g_var.vertcount);
        g_scrtext.printf("indexcount:    %d*%d",    g_var.indexcount, g_var.vbdrawcount);

        g_scrtext.printf("numtextures:   %d",       g_var.numtextures);
        g_scrtext.printf("FVF size:      %d bytes", dwFVFSizeTot);

        for(DWORD istream = 0; istream < g_var.NumStreams; istream++)
            g_scrtext.printf("  stream % d:   %s", istream, SzGetDeclDescr(istream, g_Declaration));

#undef XTAG
#define XTAG(_tag)    ((g_var. ## _tag) ? #_tag : "!" #_tag)

        // spew various render states
        g_scrtext.printf("%s %s %s %s",
            XTAG(zenable), XTAG(zwriteenable),
            XTAG(alphablendenable), XTAG(alphatestenable));

        g_scrtext.printf("%s %s %s %s %s",
            XTAG(localviewer), XTAG(specularenable),
            XTAG(fogenable), XTAG(normalizenormals), XTAG(colorvertex));

        if(g_var.lighting)
        {
            g_scrtext.printf("%s: directional:%d point:%d spot:%d", XTAG(lighting),
                g_var.numDirectionalLights, g_var.numPointLights, g_var.numSpotLights);
        }
        else
        {
            g_scrtext.printf("%s", XTAG(lighting));
        }
    }
}

//=========================================================================
// Take a wild guess at the amount of time one scene will take
//=========================================================================
float EstimateTimeForScene()
{
    CTimer timer;

    // clear the screen
    ClearScreen();
    CheckHR(g_pDev->Present(NULL, NULL, NULL, NULL));

    InitFrame();

    // wait until everything is cleared out
    g_pDev->BlockUntilIdle();

    // start timing
    timer.Start();

    // draw one scene
    RenderFrame(g_var.vbdrawcount, g_var.pushbuffernops);

    // wait until GPU is idle again
    g_pDev->BlockUntilIdle();

    // stop timer
    timer.Stop();

    return timer.getTime();
}

// helper struct used in PrecompiledCallback
struct GPUINFO
{
    CTimer *ptimer;
    DWORD byteswritten;
    DWORD bytes;
} g_gpuInfo;

//=========================================================================
// Called back at DPC level when the test is done
//=========================================================================
void __cdecl PrecompiledCallback(DWORD context)
{
    GPUINFO* pgpuInfo = (GPUINFO *)context;

    // stop the timer
    pgpuInfo->ptimer->Stop();

    // record how many bytes we've written
    pgpuInfo->byteswritten = pgpuInfo->bytes;

    g_gpudrawingdone = true;
}

//=========================================================================
// Block or do wc writes until GPU is idle
//=========================================================================
void WaitOrWriteUntilIdle()
{
    DWORD batch = 0;

    g_pDev->InsertCallback(D3DCALLBACK_WRITE, PrecompiledCallback, (DWORD)&g_gpuInfo);
    g_pDev->KickPushBuffer();

    if(g_var.wcwritesinbkgnd == 1)
    {
        // do some wc writes w/ the main thread while waiting
        while(!g_gpudrawingdone)
        {
            DWORD* pDst = g_pAlloc;

            batch = g_AllocSize / sizeof(DWORD);

            // pDst = (DWORD*) ((DWORD) pDst | 0xf0000000);

            do {
                *pDst++ = g_gpuInfo.bytes;

                g_gpuInfo.bytes += 4;

            } while (--batch != 0);
        }
    }
    else
    {
        // wait until GPU is idle again
        g_pDev->BlockUntilIdle();
    }
}

//=========================================================================
//
//=========================================================================
void CreatePushBuffers(IDirect3DPushBuffer8 *pPushbuffer[300],
    int numberscenes, DWORD *psize, int *pframesperpushbuffer)
{
    DWORD size;
    int framesperpushbuffer;
    const int MaxPushbufferSize = 32*1024*1024;

    // calculate pushbuffer size
    IDirect3DPushBuffer8 *pPushBufferT;
    CheckHR(g_pDev->CreatePushBuffer(MaxPushbufferSize, g_var.runusingcpucopy, &pPushBufferT));

    // render one frame - and get the size
    CheckHR(g_pDev->BeginPushBuffer(pPushBufferT));
    RenderFrame(g_var.vbdrawcount, g_var.pushbuffernops);
    CheckHR(g_pDev->GetPushBufferOffset(&size));

    // we're capped by the push-buffer size or the total frame count
    framesperpushbuffer = min(numberscenes, MaxPushbufferSize / (int)size);

    // cap the guy at the max # of frames allowed in our pushbuffer
    if(g_var.framesperpushbuffermax)
        framesperpushbuffer = min(g_var.framesperpushbuffermax, (DWORD)framesperpushbuffer);

    // render the remaining frames in there
    for(int i = 1; i < framesperpushbuffer; i++)
    {
        RenderFrame(g_var.vbdrawcount, g_var.pushbuffernops);
    }

    CheckHR(g_pDev->GetPushBufferOffset(&size));

    CheckHR(g_pDev->EndPushBuffer());

    // ok - cruise through and create X number of pushbuffers
    g_var.numberofpushbuffers = min(300, max(1, g_var.numberofpushbuffers));

    if(g_var.numberofpushbuffers == 1)
    {
        pPushbuffer[0] = pPushBufferT;
        pPushBufferT = NULL;
    }
    else
    {
        for(DWORD ipushbuf = 0; ipushbuf < g_var.numberofpushbuffers; ipushbuf++)
        {
            // create precompiled pushbuffer
            CheckHR(g_pDev->CreatePushBuffer(max(512, size) + sizeof(DWORD),
                g_var.runusingcpucopy, &pPushbuffer[ipushbuf]));

            assert(pPushbuffer[ipushbuf]->AllocationSize >=
                pPushBufferT->Size);

            memcpy((void *)pPushbuffer[ipushbuf]->Data,
                (void *)pPushBufferT->Data, pPushBufferT->Size);

            pPushbuffer[ipushbuf]->Size = pPushBufferT->Size;
        }
    }

    *psize = size;
    *pframesperpushbuffer = framesperpushbuffer;

    RELEASE(pPushBufferT);
}

//=========================================================================
// Do a timed test and spit out the results
//=========================================================================
float DoTimedTest(TIMETESTRESULTS *pttres)
{
    CTimer timer;
    int frames = 0;
    int visibilityindex = 0;
    float TimeTillDoneDrawing = 0;
    float TimeTillIdle = 0;
    UINT64 cIndicesDrawn = 0;
    UINT64 cTrisDrawn = 0;
    D3DWAITINFO *pPushBufferWaitInfo =
        &g_pPerf->m_PerformanceCounters[PERF_PUSHBUFFER_WAITS];

    // if there isn't an explicit count of scenes to render
    // guesstimate the time required for each scene
    float fEstimatedTimePerScene = EstimateTimeForScene();

    // and figure out how many scenes to render
    int numberscenes = int(g_var.testtime / fEstimatedTimePerScene);

    // put an upper cap and lower bound on the number of scenes
    numberscenes = max(2, min(numberscenes, INT_MAX));

    // set up stream sources
    InitFrame();

    g_gpuInfo.ptimer = &timer;
    g_gpuInfo.byteswritten = 0;
    g_gpuInfo.bytes = 0;

    if(g_var.precompiled)
    {
        DWORD size;
        int framesperpushbuffer;
        static IDirect3DPushBuffer8 *pPushbuffer[300];

        // Create our pushbuffers
        CreatePushBuffers(pPushbuffer, numberscenes, &size, &framesperpushbuffer);

        int pushbuffercalls = (numberscenes / framesperpushbuffer) + 1;

        pPushBufferWaitInfo->Count = 0;
        pPushBufferWaitInfo->Cycles = 0;

        // wait until everything is cleared out
        g_pDev->BlockUntilIdle();

        // start timing
        timer.Start();
        g_gpudrawingdone = false;

        // render X number of scenes
        DWORD ipushbuf = 0;
        for(int pushbuffers = 0; pushbuffers < pushbuffercalls; pushbuffers++)
        {
            CheckHR(g_pDev->RunPushBuffer(pPushbuffer[ipushbuf], NULL));

            if(++ipushbuf >= g_var.numberofpushbuffers)
                ipushbuf = 0;
        }

        TimeTillDoneDrawing = timer.getTime();

        WaitOrWriteUntilIdle();

        TimeTillIdle = timer.getTime();

        frames = pushbuffercalls * framesperpushbuffer;
        cIndicesDrawn = (UINT64)pushbuffercalls * framesperpushbuffer * g_var.vbdrawcount * g_var.indexcount;
        cTrisDrawn = (UINT64)pushbuffercalls * framesperpushbuffer * g_var.vbdrawcount * g_var.TriCount;

        if(pttres)
        {
            pttres->pushbuffercalls = pushbuffercalls;
            pttres->pushbuffersize = size;
        }

        for(ipushbuf = 0; ipushbuf < g_var.numberofpushbuffers; ipushbuf++)
            RELEASE(pPushbuffer[ipushbuf]);
    }
    else
    {
        pPushBufferWaitInfo->Count = 0;
        pPushBufferWaitInfo->Cycles = 0;

        // wait until everything is cleared out
        g_pDev->BlockUntilIdle();

        // start timing
        timer.Start();
        g_gpudrawingdone = false;

        // render X number of scenes
        for(frames = 0; frames < numberscenes; frames++)
        {
            RenderFrame(g_var.vbdrawcount);
        }

        TimeTillDoneDrawing = timer.getTime();

        // wait until GPU is idle again
        WaitOrWriteUntilIdle();

        TimeTillIdle = timer.getTime();

        cIndicesDrawn = (UINT64)frames * g_var.vbdrawcount * g_var.indexcount;
        cTrisDrawn = (UINT64)frames * g_var.vbdrawcount * g_var.TriCount;
    }

    if(pttres)
    {
        pttres->fps = frames * 1000 / TimeTillIdle;
        pttres->cFrames = frames;
        pttres->TimeTillDoneDrawing = TimeTillDoneDrawing;
        pttres->TimeTillIdle = TimeTillIdle;
        pttres->cTrisDrawn = cTrisDrawn;
        pttres->mtps = (float)(pttres->cTrisDrawn / (pttres->TimeTillIdle * 1000));
        pttres->cycles = g_nvclk * pttres->TimeTillIdle * 1000.0f / cIndicesDrawn;

        pttres->byteswritten = g_gpuInfo.byteswritten;
        pttres->throughput = g_gpuInfo.byteswritten / (TimeTillIdle * 1000.0f);
        pttres->PushBufferWaitInfo = *pPushBufferWaitInfo;
    }

    return pttres->fps;
}

//=========================================================================
// macros to help read entries from the ini file
//=========================================================================
static const char g_szOpts[] = "options";
#define get_option_val(_var)          g_inifile.GetIniInt(g_szOpts, #_var, g_var._var)
#define get_option_valf(_var)         g_inifile.GetIniFloat(g_szOpts, #_var, g_var._var)
#define get_option_val3(_s, _var, _d) g_inifile.GetIniInt(_s, _var, _d)

//=========================================================================
// Read ini file and update all fr settings
//=========================================================================
bool ReadVSTIniFile()
{
    if(!g_inifile.ReadFile())
        return false;

    // read the verbose flag(s) first
    g_inifile.m_fverbose            = !!get_option_val3(g_szOpts, "verboseinireads", false);
    g_var.verboselevel              = get_option_val(verboselevel);

    // if the g_iCurTest entry exists, read it in
    if(g_inifile.IniEntryExists(g_szOpts, "g_iCurTest"))
        g_iCurTest = g_inifile.GetIniInt(g_szOpts, "g_iCurTest", g_iCurTest);

    g_var.runtestonreload           = !!get_option_val(runtestonreload);

    g_var.AutoDepthStencilFormat    = (D3DFORMAT)get_option_val(AutoDepthStencilFormat);
    g_var.BackBufferFormat          = (D3DFORMAT)get_option_val(BackBufferFormat);

    g_var.MSType                    = (D3DMULTISAMPLE_TYPE)get_option_val(MSType);
    g_var.MSFormat                  = (D3DMULTISAMPLE_TYPE)get_option_val(MSFormat);

    g_var.zenable                   = !!get_option_val(zenable);
    g_var.zwriteenable              = !!get_option_val(zwriteenable);
    g_var.d3dcmpfunc                = (D3DCMPFUNC)get_option_val(d3dcmpfunc);

    g_var.alphablendenable          = !!get_option_val(alphablendenable);
    g_var.alphatestenable           = !!get_option_val(alphatestenable);

    g_var.testtime                  = get_option_valf(testtime);
    g_var.vbdrawcount               = get_option_val(vbdrawcount);
    g_var.precompiled               = get_option_val(precompiled);
    g_var.framesperpushbuffermax    = get_option_val(framesperpushbuffermax);
    g_var.pushbuffernops            = g_var.precompiled ? get_option_val(pushbuffernops) : 0;
    g_var.runusingcpucopy           = g_var.precompiled && !!get_option_val(runusingcpucopy);
    g_var.numberofpushbuffers       = get_option_val(numberofpushbuffers);
    g_var.wcwritesinbkgnd           = get_option_val(wcwritesinbkgnd);

    g_var.FVF                       = get_option_val(FVF);
    g_var.primitivetype             = (D3DPRIMITIVETYPE)get_option_val(primitivetype);
    g_var.indexcount                = get_option_val(indexcount);
    g_var.vertcount                 = get_option_val(vertcount);

    g_var.cullmode                  = (D3DCULL)get_option_val(cullmode);
    g_var.d3dfillmode               = (D3DFILLMODE)get_option_val(d3dfillmode);

    g_var.degenerates               = !!get_option_val(degenerates);

    g_var.clearflags                = get_option_val(clearflags);
    g_var.zclearval                 = get_option_valf(zclearval);
    g_var.sclearval                 = get_option_val(sclearval);
    g_var.cclearval                 = get_option_val(cclearval);

    g_var.uservertexshader          = get_option_val(uservertexshader);

    g_var.colorvertex               = !!get_option_val(colorvertex);
    g_var.normalizenormals          = !!get_option_val(normalizenormals);
    g_var.fogenable                 = !!get_option_val(fogenable);

    g_var.localviewer               = !!get_option_val(localviewer);
    g_var.specularenable            = !!get_option_val(specularenable);

    g_var.lighting                  = !!get_option_val(lighting);
    g_var.numDirectionalLights      = get_option_val(numDirectionalLights);
    g_var.numPointLights            = get_option_val(numPointLights);
    g_var.numSpotLights             = get_option_val(numSpotLights);

    g_var.numtextures               = get_option_val(numtextures);

	g_var.dwRndShaderMin			= get_option_val(dwRndShaderMin);	
	g_var.dwRndShaderMax			= get_option_val(dwRndShaderMax);	
	g_var.dwRndShaderNops			= get_option_val(dwRndShaderNops);	
	g_var.dwRndShaderType			= get_option_val(dwRndShaderType);	
	g_var.bRndShaderWriteConsts		= !!get_option_val(bRndShaderWriteConsts);
	g_var.bRndShaderXvs				= !!get_option_val(bRndShaderXvs);
	g_var.bRndShaderIndex			= !!get_option_val(bRndShaderIndex);
	g_var.bRndShaderAllowPair		= !!get_option_val(bRndShaderAllowPair);
	g_var.bRndShaderScreenspace		= !!get_option_val(bRndShaderScreenspace);
	g_var.bRndShaderAllowNop		= !!get_option_val(bRndShaderAllowNop);

    // Read in the explicit declaration if we don't have an FVF code
    g_var.NumStreams = 1;
    if(!g_var.FVF)
    {
        char szStream[20];
        char szEntry[20];
        int idecl = 0;

        for(int istream = 0; istream < 15; istream++)
        {
            wsprintfA(szStream, "stream%d", istream);
            if(!g_inifile.IniEntryExists(szStream, "Decl0"))
            {
                break;
            }
            else
            {
                g_Declaration[idecl++] = D3DVSD_STREAM(istream);

                for(int ientry = 0; ientry < 15; ientry++)
                {
                    wsprintfA(szEntry, "Decl%d", ientry);
                    if(!g_inifile.IniEntryExists(szStream, szEntry))
                        break;

                    DWORD dwDecl = g_inifile.GetIniInt(szStream, szEntry, 0);

                    if(dwDecl & 0x08000000)
                        g_Declaration[idecl++] = D3DVSD_SKIPBYTES(LOWORD(dwDecl));
                    else if(dwDecl & 0x10000000)
                        g_Declaration[idecl++] = D3DVSD_SKIP(LOWORD(dwDecl));
                    else
                        g_Declaration[idecl++] = D3DVSD_REG(LOWORD(dwDecl), HIWORD(dwDecl));
                }
            }
        }

        g_Declaration[idecl] = D3DVSD_END();

        g_var.NumStreams = istream;
    }

    return true;
}

//=========================================================================
// Background thread loop.
//=========================================================================
DWORD WINAPI ThreadProc(LPVOID lpParameter)
{
    DWORD batch;

    for(;;)
    {
        if(!g_gpudrawingdone)
        {
            DWORD* pDst = g_pAlloc;

            batch = g_AllocSize / sizeof(DWORD);

            // pDst = (DWORD*) ((DWORD) pDst | 0xf0000000);
            do {
                *pDst++ = g_gpuInfo.bytes;

                g_gpuInfo.bytes += 4;

            } while (--batch != 0);
        }
    }

    return 0;
}


//=========================================================================
// main
//=========================================================================
void __cdecl main()
{
    g_hThread = CreateThread(NULL, 0, ThreadProc, 0, CREATE_SUSPENDED, NULL);
    SetThreadPriority(g_hThread, THREAD_PRIORITY_BELOW_NORMAL);

	DWORD TheTime = time(0);
	DebugPrint("Random Seed: %d\n", TheTime);
	srand(TheTime);

#if PROFILE
    g_pPerf = D3DPERF_GetStatistics();
#else
    static D3DPERF perf = {0};
    g_pPerf = &perf;
#endif

    /*
     * init vars
     */
    g_var.screenwidth = 640.0f;
    g_var.screenheight = 480.0f;

    g_var.FVF = D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1;
    g_var.primitivetype = D3DPT_TRIANGLELIST;
    g_var.indexcount = 4998;
    g_var.vertcount = 27;

    g_var.cullmode = D3DCULL_NONE;

    g_var.degenerates = false;

    g_var.alphablendenable = false;
    g_var.alphatestenable = false;

    // default to drawing 10 seconds
    g_var.testtime = 10000.0f;
    g_var.vbdrawcount = 50;

    g_var.d3dfillmode = D3DFILL_SOLID;

    g_var.zenable = false;
    g_var.zwriteenable = false;

    g_var.d3dcmpfunc = D3DCMP_NOTEQUAL;

    g_var.BackBufferFormat = D3DFMT_A8R8G8B8;
    g_var.AutoDepthStencilFormat = D3DFMT_D24S8;

    g_var.clearflags = D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL;
    g_var.cclearval = 0x00006688;

	g_var.dwRndShaderMin		= 10;
	g_var.dwRndShaderMax		= 11;
	g_var.dwRndShaderNops		= 0;
	g_var.dwRndShaderType		= SASMT_VERTEXSHADER;
	g_var.bRndShaderWriteConsts	= false;
	g_var.bRndShaderXvs			= true;
	g_var.bRndShaderIndex		= true;
	g_var.bRndShaderAllowPair	= false;
	g_var.bRndShaderScreenspace	= true;
	g_var.bRndShaderAllowNop	= true;

    g_pAlloc = (DWORD*) XPhysicalAlloc(g_AllocSize, MAXULONG_PTR, 4096,
                                       PAGE_READWRITE | PAGE_WRITECOMBINE);

    CheckHR(g_pAlloc != NULL ? S_OK : E_OUTOFMEMORY);

    /*
     * Init vstune
     */
    XInitDevices(0, NULL);

    DWORD dwLastTickCount = GetTickCount();
    for(;;)
    {
        DWORD dwTickCount = GetTickCount();
        DWORD dwTicks = dwTickCount - dwLastTickCount;

        dwLastTickCount = dwTickCount;

        HandleInput(dwTicks);

        if(g_pDev)
        {
            if(g_fRedrawScreen)
            {
                ClearScreen();

                // draw back frame with current settings
                InitFrame();
                RenderFrame(1);

                // swap that guy to the front
                CheckHR(g_pDev->Present(NULL, NULL, NULL, NULL));

                // display current options on front buffer
                g_scrtext.cls();

                g_scrtext.printf("Btn A) run '%s' test.", g_rgTests[g_iCurTest].szDesc);
                g_scrtext.printf("");
                DumpCurrentSettings();
                g_scrtext.drawtext(g_var.verboselevel >= 1);

                g_fRedrawScreen = false;
            }
            else
            {
                // 33.3 fps baby!
                Sleep(30);
            }
        }
    }
}

//=========================================================================
// Callback from inifile.cpp to get float string value
//=========================================================================
bool GetIniConstf(const char *szStr, int cchStr, float *pval)
{
    return false;
}

//=========================================================================
// Callback from inifile.cpp to get int string value
//=========================================================================
bool GetIniConst(const char *szStr, int cchStr, int *pval)
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        int Val;
        const char *szStr;
    } rgszConsts[] =
    {
        // D3DFORMATs
        XTAG(D3DFMT_A8R8G8B8), XTAG(D3DFMT_X8R8G8B8), XTAG(D3DFMT_R5G6B5), XTAG(D3DFMT_R6G5B5),
        XTAG(D3DFMT_X1R5G5B5), XTAG(D3DFMT_A1R5G5B5), XTAG(D3DFMT_A4R4G4B4), XTAG(D3DFMT_A8),
        XTAG(D3DFMT_A8B8G8R8), XTAG(D3DFMT_B8G8R8A8), XTAG(D3DFMT_R4G4B4A4), XTAG(D3DFMT_R5G5B5A1),
        XTAG(D3DFMT_R8G8B8A8), XTAG(D3DFMT_R8B8), XTAG(D3DFMT_G8B8), XTAG(D3DFMT_P8),
        XTAG(D3DFMT_L8), XTAG(D3DFMT_A8L8), XTAG(D3DFMT_AL8), XTAG(D3DFMT_L16),
        XTAG(D3DFMT_V8U8), XTAG(D3DFMT_L6V5U5), XTAG(D3DFMT_X8L8V8U8), XTAG(D3DFMT_Q8W8V8U8),
        XTAG(D3DFMT_V16U16), XTAG(D3DFMT_D16_LOCKABLE), XTAG(D3DFMT_D16), XTAG(D3DFMT_D24S8),
        XTAG(D3DFMT_F16), XTAG(D3DFMT_F24S8), XTAG(D3DFMT_UYVY), XTAG(D3DFMT_YUY2),
        XTAG(D3DFMT_DXT1), XTAG(D3DFMT_DXT2), XTAG(D3DFMT_DXT3), XTAG(D3DFMT_DXT4),
        XTAG(D3DFMT_DXT5), XTAG(D3DFMT_LIN_A1R5G5B5), XTAG(D3DFMT_LIN_A4R4G4B4), XTAG(D3DFMT_LIN_A8),
        XTAG(D3DFMT_LIN_A8B8G8R8), XTAG(D3DFMT_LIN_A8R8G8B8), XTAG(D3DFMT_LIN_B8G8R8A8), XTAG(D3DFMT_LIN_G8B8),
        XTAG(D3DFMT_LIN_R4G4B4A4), XTAG(D3DFMT_LIN_R5G5B5A1), XTAG(D3DFMT_LIN_R5G6B5), XTAG(D3DFMT_LIN_R6G5B5),
        XTAG(D3DFMT_LIN_R8B8), XTAG(D3DFMT_LIN_R8G8B8A8), XTAG(D3DFMT_LIN_X1R5G5B5), XTAG(D3DFMT_LIN_X8R8G8B8),
        XTAG(D3DFMT_LIN_A8L8), XTAG(D3DFMT_LIN_AL8), XTAG(D3DFMT_LIN_L16), XTAG(D3DFMT_LIN_L8),
        XTAG(D3DFMT_LIN_D24S8), XTAG(D3DFMT_LIN_F24S8), XTAG(D3DFMT_LIN_D16), XTAG(D3DFMT_LIN_F16),

        XTAG(D3DMULTISAMPLE_NONE), XTAG(D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX), XTAG(D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR),
        XTAG(D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR), XTAG(D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN),
        XTAG(D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT),
        XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5),
        XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8),

        XTAG(D3DMS_NONE), XTAG(D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX), XTAG(D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR),
        XTAG(D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR), XTAG(D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN), XTAG(D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR),
        XTAG(D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN),
        XTAG(D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMS_PREFILTER_FORMAT_DEFAULT),
        XTAG(D3DMS_PREFILTER_FORMAT_X1R5G5B5), XTAG(D3DMS_PREFILTER_FORMAT_R5G6B5),
        XTAG(D3DMS_PREFILTER_FORMAT_X8R8G8B8), XTAG(D3DMS_PREFILTER_FORMAT_A8R8G8B8),

        XTAG(D3DCLEAR_TARGET), XTAG(D3DCLEAR_ZBUFFER), XTAG(D3DCLEAR_STENCIL),

        // FVFs
        XTAG(D3DFVF_XYZ), XTAG(D3DFVF_XYZRHW), XTAG(D3DFVF_NORMAL), XTAG(D3DFVF_DIFFUSE),
        XTAG(D3DFVF_SPECULAR), XTAG(D3DFVF_TEX0), XTAG(D3DFVF_TEX1), XTAG(D3DFVF_TEX2),
        XTAG(D3DFVF_TEX3), XTAG(D3DFVF_TEX4),

        // textcoord sizes
        XTAG(T0_SIZE1), XTAG(T0_SIZE2), XTAG(T0_SIZE3), XTAG(T0_SIZE4),
        XTAG(T1_SIZE1), XTAG(T1_SIZE2), XTAG(T1_SIZE3), XTAG(T1_SIZE4),
        XTAG(T2_SIZE1), XTAG(T2_SIZE2), XTAG(T2_SIZE3), XTAG(T2_SIZE4),
        XTAG(T3_SIZE1), XTAG(T3_SIZE2), XTAG(T3_SIZE3), XTAG(T3_SIZE4),

        XTAG(VSDT_FLOAT1), XTAG(VSDT_FLOAT2), XTAG(VSDT_FLOAT3), XTAG(VSDT_FLOAT4),
        XTAG(VSDT_D3DCOLOR), XTAG(VSDT_SHORT2), XTAG(VSDT_SHORT4), XTAG(VSDT_NORMSHORT1),
        XTAG(VSDT_NORMSHORT2), XTAG(VSDT_NORMSHORT3), XTAG(VSDT_NORMSHORT4), XTAG(VSDT_NORMPACKED3),
        XTAG(VSDT_SHORT1), XTAG(VSDT_SHORT3), XTAG(VSDT_PBYTE1), XTAG(VSDT_PBYTE2),
        XTAG(VSDT_PBYTE3), XTAG(VSDT_PBYTE4), XTAG(VSDT_FLOAT2H), XTAG(VSDT_NONE),

        XTAG(D3DVSDE_POSITION), XTAG(D3DVSDE_BLENDWEIGHT), XTAG(D3DVSDE_NORMAL), XTAG(D3DVSDE_DIFFUSE),
        XTAG(D3DVSDE_SPECULAR), XTAG(D3DVSDE_FOG), XTAG(D3DVSDE_BACKDIFFUSE), XTAG(D3DVSDE_BACKSPECULAR),
        XTAG(D3DVSDE_TEXCOORD0), XTAG(D3DVSDE_TEXCOORD1), XTAG(D3DVSDE_TEXCOORD2), XTAG(D3DVSDE_TEXCOORD3),

        // primitive types
        XTAG(D3DPT_POINTLIST), XTAG(D3DPT_LINELIST), XTAG(D3DPT_LINELOOP),
        XTAG(D3DPT_LINESTRIP), XTAG(D3DPT_TRIANGLELIST), XTAG(D3DPT_TRIANGLESTRIP),
        XTAG(D3DPT_TRIANGLEFAN), XTAG(D3DPT_QUADLIST), XTAG(D3DPT_QUADSTRIP),
        XTAG(D3DPT_POLYGON),

        XTAG(D3DCULL_NONE), XTAG(D3DCULL_CCW), XTAG(D3DCULL_CW),
        XTAG(D3DFILL_POINT), XTAG(D3DFILL_WIREFRAME), XTAG(D3DFILL_SOLID),

        // D3DCMPs
        XTAG(D3DCMP_NEVER), XTAG(D3DCMP_LESS), XTAG(D3DCMP_EQUAL), XTAG(D3DCMP_LESSEQUAL),
        XTAG(D3DCMP_GREATER), XTAG(D3DCMP_NOTEQUAL), XTAG(D3DCMP_GREATEREQUAL), XTAG(D3DCMP_ALWAYS),

        // misc
        XTAG(FALSE), XTAG(TRUE)
    };

    for(int ifmt = 0; ifmt < ARRAYSIZE(rgszConsts); ifmt++)
    {
        if(!_strnicmp(rgszConsts[ifmt].szStr, szStr, cchStr))
        {
            // set val
            *pval = rgszConsts[ifmt].Val;
            return true;
        }
    }

    return false;
}

//=========================================================================
//  function    MyNotBrokenD3DXDeclaratorFromFVF
//
//   devnote    Generates a declarator from a given FVF. And pays attention
//              to the D3DFVF_TEXTUREFORMAT1 bits unlike the piece of crap
//              D3DX routine.
//
//              Note that it doesn't handle D3DFVF_XYZB*
//=========================================================================
void MyNotBrokenD3DXDeclaratorFromFVF(DWORD dwFVF, DWORD Declarator[MAX_FVF_DECL_SIZE])
{
    DWORD iTemp = 0;

    Declarator[iTemp++] = D3DVSD_STREAM(0);

    if(dwFVF & D3DFVF_XYZ)
        Declarator[iTemp++] = D3DVSD_REG( D3DVSDE_POSITION,  D3DVSDT_FLOAT3);
    else if(dwFVF & D3DFVF_XYZRHW)
        Declarator[iTemp++] = D3DVSD_REG( D3DVSDE_POSITION,  D3DVSDT_FLOAT4);

    if(dwFVF & D3DFVF_NORMAL)
        Declarator[iTemp++] = D3DVSD_REG( D3DVSDE_NORMAL,  D3DVSDT_FLOAT3);

    if(dwFVF & D3DFVF_DIFFUSE)
        Declarator[iTemp++] = D3DVSD_REG( D3DVSDE_DIFFUSE,  D3DVSDT_D3DCOLOR);

    if(dwFVF & D3DFVF_SPECULAR)
        Declarator[iTemp++] = D3DVSD_REG( D3DVSDE_SPECULAR,  D3DVSDT_D3DCOLOR);

    // Texture coordinates
    UINT uNumTexCoords = ((dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT);
    UINT uTextureFormats = dwFVF >> 16;

    if(uTextureFormats)
    {
        for(UINT i = 0; i < uNumTexCoords; i++)
        {
            DWORD dwVsdt;

            switch(uTextureFormats & 3)
            {
            case D3DFVF_TEXTUREFORMAT1:     // u
                dwVsdt = D3DVSDT_FLOAT1;
                break;
            case D3DFVF_TEXTUREFORMAT2:     // u,v
                dwVsdt = D3DVSDT_FLOAT2;
                break;
            case D3DFVF_TEXTUREFORMAT3:     // s,t,r
                dwVsdt = D3DVSDT_FLOAT3;
                break;
            case D3DFVF_TEXTUREFORMAT4:     // s,t,r,q
                dwVsdt = D3DVSDT_FLOAT4;
                break;
            }

            Declarator[iTemp++] = D3DVSD_REG(D3DVSDE_TEXCOORD0 + i, dwVsdt),
            uTextureFormats >>= 2;
        }
    }
    else while(uNumTexCoords--)
    {
        // u,v
        Declarator[iTemp++] = D3DVSD_REG(D3DVSDE_TEXCOORD0 + uNumTexCoords, D3DVSDT_FLOAT2);
    }

    Declarator[iTemp++] = D3DVSD_END();
}

//=========================================================================
// Initialize the vertex shader
//=========================================================================
void InitVertexShader()
{
    static const char szShaderName[] = "d:\\vstune.xvu";

    if(!g_var.FVF)
    {
        // make sure our position is initialized
        g_pDev->SetVertexData4f(D3DVSDE_VERTEX, -2000, -2000, .5f, 1.0f);
    }
    else
    {
        MyNotBrokenD3DXDeclaratorFromFVF(g_var.FVF, g_Declaration);
    }

    if(g_dwVertexShader)
    {
        g_pDev->SetVertexShader(D3DFVF_XYZ);
        g_pDev->DeleteVertexShader(g_dwVertexShader);
        g_dwVertexShader = 0;
    }

    if(g_var.uservertexshader)
    {
        HANDLE hFile = CreateFile(szShaderName,
            GENERIC_READ, FILE_SHARE_READ, NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
        {
            DWORD dwSize = GetFileSize(hFile, NULL);
            DWORD *pdwVertexShader = new DWORD [dwSize / sizeof(DWORD) + 1];

            DWORD NumberOfBytesRead;
            ReadFile(hFile, pdwVertexShader, dwSize, &NumberOfBytesRead, NULL);

            CheckHR(g_pDev->CreateVertexShader(g_Declaration, pdwVertexShader,
                &g_dwVertexShader, 0));

            g_var.uservertexshader = HIWORD(*pdwVertexShader);

            delete [] pdwVertexShader;
            CloseHandle(hFile);
        }
        else
        {
            dprintf("load '%s' failed: 0x%08lx\n", szShaderName);

            // set this guy to 0 and do the declaration thing below
            g_var.uservertexshader = 0;
        }
    }

    if(!g_var.uservertexshader)
    {
        CheckHR(g_pDev->CreateVertexShader(g_Declaration, NULL, &g_dwVertexShader, 0));
    }
}

//  helper routines for pinging gpu registers
extern "C" BYTE * WINAPI D3DPERF_GetRegisterBase();

_forceinline ULONG
REG_RD32(VOID* Ptr, ULONG Addr)
{
   return *((volatile DWORD*)((BYTE*)(Ptr) + (Addr)));
}

//=========================================================================
// Get the NVCLK speed
//=========================================================================
DWORD GetNVCLK()
{
    BYTE *RegBase = D3DPERF_GetRegisterBase();

    // Calculate nvclk
    DWORD nvpll = REG_RD32(RegBase, 0x00680500/*NV_PRAMDAC_NVPLL_COEFF*/);
    DWORD m = nvpll & 0xFF;
    DWORD n = (nvpll >> 8)  & 0xFF;
    DWORD p = (nvpll >> 16) & 0xFF;
    FLOAT xtal = 16.6667f;

    DWORD nvclk = (m != 0) ? (DWORD)((n * xtal / (1 << p) / m)) : 0;

    return nvclk;
}


/*

Spotlight vertex shader code:

  Input:
  cPos: light position, stored in constant register
  cVec: light vector
  cAng: {cos(phi/2), cos(theta/2) - cos(phi/2), 1 / (cos(theta/2) - cos(phi/2)), power}
          used in: falloff==(cos(alpha)-cos(phi/2))/(cos(theta/2)-cos(phi/2)), 
          phi=outer cone angle; theta = inner cone angle; power is used in falloff, usually==1.0
		  alpha == angle between Vertex-Light & Light direction
  cCol: color of light
  cAtt: {a,b,c,*}: attenuation factors of light, used in 1/(a + D*b + D*D*c) 
          (D == distance to light, a,b,c == atten factors)

sub r2    , v0    , cPos          ;r2   = vector from Light to Vertex 
dp4 r3.x  , r2    , cVec          ;r3.x = cos(alpha)
sub r3.x  , r3.x  , cAng.x        ;r3.x = (cos(alpha) - cos(phi/2))
min r3.x  , r3.x  , cAng.y        ;r3.x:: part 1 of "clamp from 0 to 1"
mul r3.x  , r3.x  , cAng.z        ;r3.x = (cos(alpha) - (cos(phi/2)) / (cos(theta/2)-cos(phi/2)
									;this completes the max-clamp to 1.0
mov r3.w  , cAng.w                ;prepare for Lit
lit r3.z  , r3.xxxw               ;r3.z = r3.x ^ power. Also, this clamps minimum to 0.

if Light attenuation != {1, 0, 0}  ;if light attenuation was this, these instructions wouldn't do anything
{
    dp3 r5.x, r2   , r2           ;r5.x = Dist squared
	rsq r5.y, r5.x                ;r5.y = 1/Dist
	dst r5  , r5.x , r5.y         ;r5   = {1, dist, dist^2, 1/dist}
	dp3 r5.w, r5   , cAtt         ;r5.w = a + b*dist + c*dist^2
    rcc r5.w, r5.w                ;r5.w = 1/(above)
	mul r3.z, r3.z, r5.w          ;multiply this attenuation factor by light falloff 
}

mad COLOR, cCol, r5.z, COLOR      ;add falloff-ed, attenuated light to vertex's light.






Pointlight vertex shader code:

  Input:
  cPos: light position
  cCol: color of light
  cAtt: {a,b,c,*}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\vshtools\vshgen.cpp ===
/*++
Copyright (c) 2001 Microsoft Corporation

Module Name:	vshgen.cpp
Abstract:		generates random vertex shaders
Author:			Jason Gould (jgould) 07-Aug-2001
Environment:	xbox or possibly win2k static library, for testing vertex shaders
Notes:			used by satest, and various other vertex shader tests
Revision History:

	07-Aug-2001 jgould
		Initial Version

--*/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>
#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#include "d3d8-xbox.h"
#endif

#include "xgraphics.h"

#include "vshgen.h"

#define countof(a) (sizeof(a) / sizeof((a)[0]))

#define NUMOUTREGS 13
#define NUMINREGS  16


struct SHADERGENERATORSTUFF {
	bool bWriteConsts;
	bool bIsXvs;
	bool bAllowIndex;
	bool bAllowPair;
	bool bAllowNop;
	bool bHasWrittenReg[13][4];
	bool bHasWrittenArl;
	bool bHasWrittenConst;
	bool bMustWriteConst;
	bool bMustWriteOpos;
	bool bStateShader;

	char temp[100]; //temporary input buffer: has enough room for "mad c[-96].xyzw, -c[a0.x+-96].xyzw, -c[a0.x+-96].xyzw, -c[a0.x+-96].xyzw"
};


	typedef struct _D3DVsInstruction {
		unsigned long eos:1;        /* 0:00 last instruction */
		unsigned long cin:1;        /* 0:01 ctx indexed address */
		unsigned long  om:1;        /* 0:02 output mux */
		unsigned long  oc:9;        /* 0:03 output write control */
		unsigned long owm:4;        /* 0:12 output write mask */
		unsigned long swm:4;        /* 0:16 secondary register write mask */
		unsigned long  rw:4;        /* 0:20 register write */
		unsigned long rwm:4;        /* 0:24 primary register write mask */
		unsigned long cmx:2;        /* 0:28 c mux (NA,r1,v,c) */
		unsigned long crr:4;        /* 0:30 c register read */
		unsigned long cws:2;        /* 1:02 c w swizzle */
		unsigned long czs:2;        /* 1:04 c z swizzle */
		unsigned long cys:2;        /* 1:06 c y swizzle */
		unsigned long cxs:2;        /* 1:08 c x swizzle */
		unsigned long cne:1;        /* 1:10 c negate */
		unsigned long bmx:2;        /* 1:11 b mux (NA,r1,v,c) */
		unsigned long brr:4;        /* 1:13 b register read */
		unsigned long bws:2;        /* 1:17 b w swizzle */
		unsigned long bzs:2;        /* 1:19 b z swizzle */
		unsigned long bys:2;        /* 1:21 b y swizzle */
		unsigned long bxs:2;        /* 1:23 b x swizzle */
		unsigned long bne:1;        /* 1:25 b negate */
		unsigned long amx:2;        /* 1:26 a mux (NA,r0,v,c) */
		unsigned long arr:4;        /* 1:28 a register read */
		unsigned long aws:2;        /* 2:00 a w swizzle */
		unsigned long azs:2;        /* 2:02 a z swizzle */
		unsigned long ays:2;        /* 2:04 a y swizzle */
		unsigned long axs:2;        /* 2:06 a x swizzle */
		unsigned long ane:1;        /* 2:08 a negate */
		unsigned long  va:4;        /* 2:09 ibuffer address */
		unsigned long  ca:8;        /* 2:13 ctx address */
		unsigned long mac:4;        /* 2:21 MLU/ALU op */
		unsigned long ilu:3;        /* 2:25 ILU op */
	} D3DVsInstruction;

	namespace XGRAPHICS 
{
	//internal instruction format. 
	//It isn't too pretty to work with, since things are not byte aligned,
	//but there's already a disassembler that uses this format. No need to duplicate that...
	//and it's easy to convert, since this instruction generator uses this hardware format for
	//generating instructions anyway.


	//xgraphics' built-in instruction-disassembler. Used in xsdasm and the .lst generator
	HRESULT  DisassembleInstruction( const D3DVsInstruction * pI, XBuffer &buffer );

};


//returns true if the particular mac instruction produces standard output
//(false for nop and arl)
bool MacOutputs(int mac) 
{
	//return false if mac is nop or arl (mov to a0.x).
	if((mac == 0) || (mac == 13)) {
		return false;
	} else {
		return true;
	}
}

//initialize variables that are used all over the place
HRESULT InitShaderStuff(
	SHADERGENERATORSTUFF* pStuff,
	bool bWriteConsts,
	bool bIsXvs,
	bool bAllowIndex,
	bool bAllowPair,
	bool bAllowNop
)
{
	HRESULT hr = S_OK;
	if(!pStuff) {
		return E_INVALIDARG;
	}

	pStuff->bWriteConsts     = bWriteConsts;
	pStuff->bIsXvs           = bIsXvs;
	pStuff->bAllowIndex      = bAllowIndex;
	pStuff->bAllowPair       = bAllowPair;
	pStuff->bAllowNop        = bAllowNop;

	pStuff->bMustWriteOpos   = true;
	pStuff->bMustWriteConst  = false;
	pStuff->bHasWrittenConst = false;
	pStuff->bHasWrittenArl   = false;

	memset(pStuff->bHasWrittenReg,0,sizeof(pStuff->bHasWrittenReg));
	pStuff->temp[0] = 0;
	return hr;
}


//Generate header info for the new shader
//Used only by GenerateRandomVertexShader
HRESULT DoHeader (XBuffer* pbuf, DWORD dwType, bool bScreenspace, SHADERGENERATORSTUFF* pStuff) 
{
	HRESULT hr = S_OK;

	switch (dwType) {
	case 0x7378:
	case SASMT_VERTEXSTATESHADER:
		hr = pbuf->Printf("xvss.1.1\n");
		pStuff->bStateShader = true;
		pStuff->bMustWriteConst = true;
		pStuff->bMustWriteOpos = false;
		pStuff->bWriteConsts = true;
		break;

	case 0x7778:
	case SASMT_READWRITE_VERTEXSHADER:
		hr = pbuf->Printf("xvsw.1.1\n");
		pStuff->bStateShader = false;
		pStuff->bMustWriteConst = false;
		pStuff->bMustWriteOpos = true;
		//only write consts if we are told to earlier
		pStuff->bWriteConsts &= true; 
		break;

	case 0x2078:
	case SASMT_VERTEXSHADER:
		hr = pbuf->Printf("xvs.1.1\n");
		pStuff->bStateShader = false;
		pStuff->bMustWriteConst = false;
		pStuff->bMustWriteOpos = true;
		pStuff->bWriteConsts = false;
		break;
	default:
		return E_INVALIDARG;
	}

	if(FAILED(hr)) {
		return hr;
	}

	if(bScreenspace) {
		hr = pbuf->Printf("#pragma screenspace\n");
	}

	return hr;
}

//choose mac and ilu instructions to work with
void ChooseInstructions(SHADERGENERATORSTUFF* pStuff, int* pMac, int* pIlu, bool bIsLastInstruction) 
{
chooseinstructions:
	*pIlu = (rand() % 8);
	*pMac = (rand() % 14);
	if((!pStuff->bAllowIndex) && (*pMac == 13)) goto chooseinstructions; //13 == write to a0.x
	if((!pStuff->bIsXvs) && (*pMac == 12)) goto chooseinstructions; //12 == dph, == xbox extension
	if((!pStuff->bIsXvs) && (*pIlu == 2)) goto chooseinstructions; //2 == rcc, == xbox extension
	if((!pStuff->bAllowNop) && (*pMac == 0) && (*pIlu == 0)) goto chooseinstructions; //0 == nop
	//if we're about to do a nop, but requirements haven't been met, try again.
	if(bIsLastInstruction && ((pStuff->bMustWriteConst && !pStuff->bHasWrittenConst) || (pStuff->bMustWriteOpos && (!pStuff->bHasWrittenReg[12][0] || !pStuff->bHasWrittenReg[12][1])))) {
		if(!MacOutputs(*pMac) && (*pIlu == 0)) {
			goto chooseinstructions;
		}
	}
	if(!pStuff->bAllowPair && *pIlu && *pMac) goto chooseinstructions; //can't pair == something has to nop!
}

//select "indexed" or "non-indexed" mode for this instruction
void ChooseArl(SHADERGENERATORSTUFF* pStuff, bool* pArl) 
{
	//bias: use a0.x 1/6 of the time.
	if(pStuff->bAllowIndex && pStuff->bHasWrittenArl && (!(rand() % 6))) {
		*pArl = true;
	} else {
		*pArl = false;
	} 
}

//pick a constant within range. Make a few constants show up more often than others
void ChooseConstant(SHADERGENERATORSTUFF* pStuff, int * pCa)
{
	int ca;
	//if we can access all consts
	if(pStuff->bIsXvs) { 
		//only use 18 of the available constants, so we have some chance of using the same constant
		ca = rand() % 18;
		if(ca < 6) ca -= 96;               //[-96, -91]
		else if (ca < 12) ca -= 7;         //[-1,    4] 
		else if (ca < 17) ca += (95 - 16); //[91,   95]
		else ca = (rand() % 192) - 96;     //[-96,  95]
	} else {
		//only use 12 of the 96 available constants
		ca = (rand() % 12);                
		if(ca < 6) ca += 0;                //[0,   5]
		else if (ca < 11) ca += (95 - 10); //[91, 95]
		else ca = (rand() % 96);           //[0,  95]
	}
	*pCa = ca + 96; //offset by 96, since that's what the hardware does
}

//choose input register (v0, v1, etc)
void ChooseVa(SHADERGENERATORSTUFF* pStuff, int * pVa)
{
	if(pStuff->bStateShader) {
		*pVa = 0;
	} else {
		*pVa = RNDE(0,NUMINREGS);
	}
}

//choose swizzling and negation of the three input pipes
void ChooseSwizzleNe(
	SHADERGENERATORSTUFF* pStuff,
	bool* pAne, bool* pBne, bool* pCne,
	int * pAs , int * pBs , int * pCs 
	)
{
	//create an array of the pointers, so we don't repeat code
	bool* ne[] = {pAne, pBne, pCne}; 
	int * sw[] = {pAs,  pBs,  pCs };

	int i, j;

	//repeat for a, b, c
	for(j = 0; j < 3; j++) { 
		//half the time, use standard swizzles ( ex: r1.xyzw )
		if(rand() & 1) {
			for (i = 0; i < 4; i++) {
				sw[j][i] = i;
			}
		//the other half, use random swizzles ( ex: r1.yyzx )
		} else {
			for (i = 0; i < 4; i++) {
				sw[j][i] = rand() & 3;
			}
		}

		//2/3 of the time, use non-negated source ( ex: r1)
		if(rand() & 3) {
			*ne[j] = false; 
		//1/3 of the time, negate the source ( ex: -r1 )
		} else { 
			*ne[j] = true;
		}
	}
}

//choose r*, c*, or v* for each input pipe. 
//figure out which r* registers can be used here (which ones have been written already)
void ChooseInput(
	SHADERGENERATORSTUFF* pStuff,
	int * pAmx, int * pBmx, int * pCmx,
	int * pArr, int * pBrr, int * pCrr,
	const int* pAs, const int* pBs, const int* pCs
	)
{
	int * mx[] = {pAmx, pBmx, pCmx};
	int * rr[] = {pArr, pBrr, pCrr};
	const int* sw[] = {pAs , pBs , pCs };

	int j, i;

	//repeat for a, b, c
	for(j = 0; j < 3; j++) { 
ChooseMux:
		//weight the Mux to read from registers (1) more often than Input (2) or Const (3)
		*mx[j] = RND(1, 8);
		if(*mx[j] >= 4) {
			*mx[j] = 1;
		}

		if(*mx[j] == 1) {
			//choose random input register. If it's an xbox shader, we can use r12.
			*rr[j] = RND(0, (11 + pStuff->bIsXvs));
			for(i = 0; i < 4; i++) {
				//if the components of the register we want to read haven't been written, try again.
				if(!pStuff->bHasWrittenReg[ *rr[j] ][ sw[j][i] ]) {
					goto ChooseMux;
				}
			}
		}
	}
}

//generate an output mask. Select the whole register most of the time.
int GenerateRandomOutputMask() 
{
	//bias: write to the whole register 1/2 of the time, never write to none of the register
	int r = RND(-15,15);
	if (r < 1) {
		return 15;
	} else {
		return r;
	}
}

//choose whether to write to oPos, oD0, etc. (used by ChooseOutput, if output regs are to be written)
void ChooseOutputRegister(SHADERGENERATORSTUFF* pStuff, int* pOr)
{
chooseoutputregister:

	*pOr = RND(2, NUMOUTREGS - 1);
	if(*pOr == 2) {
		*pOr = 0;
	}

	//7 and 8 are oB0 and oB1, which are xbox-specific
	if((*pOr == 7 || *pOr == 8) && (pStuff->bIsXvs)) {
		goto chooseoutputregister;
	}
}

//do everything with output: which pipe writes to which registers? 
//also deal with pairing.
void ChooseOutput(
	SHADERGENERATORSTUFF* pStuff,
	bool* pOm,
	int * pRwm, int * pSwm, int * pOwm,
	int * pRw,  int * pOc,  int * pOr,
	int mac, int ilu,
	bool bIsLastInstruction
	)
{
	if(bIsLastInstruction) {
		if(pStuff->bMustWriteConst && !pStuff->bHasWrittenConst) {
			//we must write a constant. Write to defaults.
			*pRwm = 0; //don't write to r*
			*pSwm = 0; //don't write to r1
			*pOwm = 0xf; //write to output
			if(MacOutputs(mac)) { //we won't choose nop or arl on last instruction.
				*pOm = 0; //if we are using a mac instruction, read from mac
				if (ilu) {
					*pSwm = 0x1; //if ilu is also running, write to r1.x
				}
			} else {
				*pOm = 1; //if we aren't using a mac instruction, read from ilu
			}
			*pRw = 0; //dummy
			*pOc = 0; //write to constant, rather than output
			*pOr = 0; //write to c0.
			return;
		}

		if(pStuff->bMustWriteOpos && (!pStuff->bHasWrittenReg[12][0] || !pStuff->bHasWrittenReg[12][1])) {
			//we must write to oPos. don't bother pairing.
			*pRwm = 0; //don't write to r*
			*pSwm = 0; //don't write to r1
			*pOwm = 0xf; //write to output
			if(MacOutputs(mac)) {
				*pOm = 0; //if we are using a mac instruction, read from mac
				if (ilu) {
					*pSwm = 0x1; //if ilu is also running, write to r1.x
				}
			} else {
				*pOm = 1; //if we aren't using a mac instruction, read from ilu
			}
			*pRw = 0; //dummy
			*pOc = 1; //write to output, rather than constant
			*pOr = 0; //write to oPos (o0).
			return;
		}

		//if we're here, it's the last instruction, but all requriements have been met already. 
		//proceed as normal
	}

	//bAllowPair has already previously decided whether mac & ilu will run simultaneously.
	//so, the two things we do here are:
	//make sure that if the mac is doing something, the result goes one or two places
	//make sure that if the ilu is doing something, the result goes one or two places
	//make sure that they only go one place if pairs aren't allowed.
	//make sure that we only write to the output registers we're allowed to use
	//make sure that we set swm if both ilu and mac are going, and ilu isn't using output.
	//make sure that if ilu is going, rw isn't 1

	if(mac && ilu) {
		//pairing has to be enabled for us to be here...
		//five options: 
		//0 mac to reg, ilu to out
		//1 mac to reg, ilu to both
		//2 mac to reg, ilu to reg
		//3 mac to both, ilu to reg
		//4 mac to out, ilu to reg
		int choice = RND(0,4);
		if(mac == 13) choice = RND(0, 2);

		if(choice > 2) {
			*pOm = 0; //use mac for output
		} else {
			*pOm = 1;
		}

		if(choice < 4 && mac != 13) { //mac writes to reg
			*pRwm = GenerateRandomOutputMask();
		} else {
			*pRwm = 0;
		}

		if(choice > 0) { //ilu writes to reg
			*pSwm = GenerateRandomOutputMask();
		} else {
			*pSwm = 0;
		}

		if(choice != 2) { //something writes to output
			*pOwm = GenerateRandomOutputMask();
		} else {
			*pOwm = 0;
		}

		*pRw = RND(1, 11);
		if(*pRw == 1) { //mac can't write to 1 if Ilu is running
			*pRw = 0;
		}
	} else if (!mac && !ilu) { //nop

		*pRwm = 0; //don't write to r*
		*pSwm = 0; //don't write to r1
		*pOwm = 0; //write to output

		//dummy stuff
		*pOr  = 0; 
		*pRw  = 0; 
		*pOc  = 0;
		*pOm  = 0;

	} else {
		//Only mac, or only ilu.

		//The only difference: if it's mac, output mux goes to 0, otherwise, 1.
		//also, ilu always uses swm, never rwm.
		//Other stuff has already been taken care of earlier

		//two/three options: 
		//0 mac/ilu to reg
		//1 mac/ilu to output 
		//2 mac/ilu to both (only if pairing is allowed)
		int choice = RND(0,(1 + pStuff->bAllowPair)); //[0,1], or [0,2]

		if(mac) {
			*pOm = 0;
		} else {
			*pOm = 1;
		}


		if((choice != 1) && MacOutputs(mac)) {
			*pRwm = GenerateRandomOutputMask();
		} else {
			*pRwm = 0;
		}

		if((choice != 1) && ilu) {
			*pSwm = GenerateRandomOutputMask();
		} else {
			*pSwm = 0;
		}

		if(choice != 0 && mac != 13) {
			*pOwm = GenerateRandomOutputMask();
		} else {
			*pOwm = 0;
		}

		*pRw = RND(0, 11);
	} 


	if(pStuff->bStateShader) {
		*pOc = 0; //constant register always
	} else {
		if(pStuff->bWriteConsts) {
			*pOc = RND(0,1);
		} else {
			*pOc = 1; //it's a normal shader. Never write to c*
		}
	}

	if(*pOc == 0) { //constant
		ChooseConstant(pStuff, pOr);
	} else { //output register
		ChooseOutputRegister(pStuff, pOr);
	}
}

//now that output has been decided, update the array that says which
//registers have been written, so we can read from them later
// (and also update whether we've written to Arl, or a Const, or oPos)
void UpdateWrittenMasks (
	SHADERGENERATORSTUFF* pStuff,
	bool Om,
	int  Rwm, int  Swm, int  Owm,
	int  Rw,  int  Oc,  int  Or,
	int  mac,  int  ilu
	)
{
	int i;
	//update rw
	for(i = 0; i < 4; i++) {
		pStuff->bHasWrittenReg[Rw][3-i] |= !!(Rwm & (1 << i));
	}

	//if mac is active, ilu writes to r1, not rw... update as appropriate
	for(i = 0; i < 4; i++) {
		pStuff->bHasWrittenReg[mac ? 1 : Rw][3-i] |= !!(Swm & (1 << i));
	}

	//if we are writing to oPos... it maps to r12.
	if(Oc == 1 && Or == 0) {
		for(i = 0; i < 4; i++) {
			pStuff->bHasWrittenReg[12][3-i] |= !!(Owm & (1 << i));
		}
	}

	if(Oc == false && Owm != 0) {
		pStuff->bHasWrittenConst = true;
	}

	if(mac == 13) { //arl
		pStuff->bHasWrittenArl = true;
	}
}

//convert the 50 variables into the xgraphics vertex-shader instruction format,
//and have xgraphics print out the results
void PrintInstruction(
  	XBuffer* pbuf,
	int Ca, int Va, int Arr, int Brr, int Crr,
	bool Arl,
	int Amx, int Bmx, int Cmx,
	bool Ane, bool Bne, bool Cne,
	int* pAs, int* pBs, int* pCs,
	
  	bool Om,
	int  Rwm, int  Swm, int  Owm,
	int  Rw,  int  Oc,  int  Or,
	int  Mac,  int  Ilu
	)
{
	D3DVsInstruction ins;
	ins.amx = Amx;
	ins.ane = Ane;
	ins.arr = Arr;
	ins.aws = pAs[3];
	ins.axs = pAs[0];
	ins.ays = pAs[1];
	ins.azs = pAs[2];
	ins.bmx = Bmx;
	ins.bne = Bne;
	ins.brr = Brr;
	ins.bws = pBs[3];
	ins.bxs = pBs[0];
	ins.bys = pBs[1];
	ins.bzs = pBs[2];
	ins.ca  = Ca;
	ins.cin = Arl;
	ins.cmx = Cmx;
	ins.cne = Cne;
	ins.crr = Crr;
	ins.cws = pCs[3];
	ins.cxs = pCs[0];
	ins.cys = pCs[1];
	ins.czs = pCs[2];
	ins.eos = 0; 
	ins.ilu = Ilu;
	ins.mac = Mac;
	ins.oc  = (Oc << 8) + Or;
	ins.om  = Om;
	ins.owm = Owm;
	ins.rw  = Rw;
	ins.rwm = Rwm;
	ins.swm = Swm;
	ins.va  = Va;

	XGRAPHICS::DisassembleInstruction(&ins, *pbuf);
	pbuf->Append("\n");
}

//produce and print one instruction
void DoInstruction (
	SHADERGENERATORSTUFF* pStuff,
	XBuffer* pbuf,
	bool bIsLastInstruction
)
{
	int ca, va, arr, brr, crr; //c#, v#, (a)r#, (b)r#, (c)r#
	bool arl;                  //true to use indexed input
	int amx, bmx, cmx;         //input muxes (1 for r#, 2 for v#, 3 for c#)
	bool ane, bne, cne;		   //negation
	int as[4], bs[4], cs[4];   //swizzle
	bool om;                   //output mux: 0 to read from mac, 1 from ilu
	int rwm, swm, owm;         //register mask, secondary mask, output mask
	int rw, oc;                //output r#, constant / output register
	int or;                    //constant / output register # 
	int mac, ilu;              //mac & ilu instruction

	ChooseInstructions(pStuff, &mac, &ilu, bIsLastInstruction);

	ChooseArl(pStuff, &arl);
	ChooseConstant(pStuff, &ca);
	ChooseVa(pStuff, &va);
	ChooseSwizzleNe(pStuff, &ane, &bne, &cne, as, bs, cs);
	ChooseInput(pStuff, &amx, &bmx, &cmx, &arr, &brr, &crr, as, bs, cs);

	//do all output stuff (including pairing, masks, registers)
	ChooseOutput(pStuff, &om, &rwm, &swm, &owm, &rw, &oc, &or, mac, ilu, bIsLastInstruction);

	UpdateWrittenMasks(pStuff, om, rwm, swm, owm, rw, oc, or, mac, ilu);

	PrintInstruction(pbuf, ca,va,arr,brr,crr,arl,amx,bmx,cmx,ane,bne,cne,as,bs,cs,om,rwm,swm,owm,rw,oc,or,mac,ilu);

}



HRESULT GenerateRandomVertexShader(
	int minlength, 
	int maxlength, 
	DWORD dwNopsAtBeginning,
	DWORD dwType, 
	bool bWriteConsts,
	bool bIsXvs,
	bool bAllowIndex,
	bool bAllowPair,
	bool bScreenspace,
	bool bAllowNop,
	XBuffer** ppOutput
)	
{
	HRESULT hr = S_OK;
	DWORD i;
	
	if(!ppOutput)
		return E_INVALIDARG;
	if(minlength > maxlength)
		return E_INVALIDARG;
	if(maxlength <= 0)
		return E_INVALIDARG;

	*ppOutput = new XBuffer;
	XBuffer* pbuf = *ppOutput;

	if(!pbuf) {
		return E_OUTOFMEMORY;
	}

	hr = pbuf->Initialize(1000);
	if(FAILED(hr)) {
		return hr;
	}

	SHADERGENERATORSTUFF Stuff;
	hr = InitShaderStuff(&Stuff, bWriteConsts, bIsXvs, bAllowIndex, bAllowPair, bAllowNop);
	if(FAILED(hr)) {
		return hr;
	}

	hr = DoHeader(pbuf, dwType, bScreenspace, &Stuff);
	if(FAILED(hr)) {
		return hr;
	}

	for(i = 0; i < dwNopsAtBeginning; i++) {
		hr = pbuf->Printf("nop\n");
		if(FAILED(hr)) {
			return hr;
		}
	}

	DWORD NumInstructions = RND(minlength, maxlength);
	
	//note: go to  < NumInstructions-1. If needed, the 
	//last instruction can be used to force a write to oPos or c0.
	for( ; i < NumInstructions - 1; i++) {
		DoInstruction(&Stuff, pbuf, false);
	}
	DoInstruction(&Stuff, pbuf, true);

	return hr;
}




/*
The smallest shader that still repro's (the test returns ltrTestFailed) will be returned in 
  a new buffer, which will be pointed to by *ppOutput.

Return: 
	if a parameter is NULL (other than pData), return E_POINTER
	if it runs out of memory, it returns E_OUTOFMEMORY
	if the original shader isn't valid, return E_INVALIDARG
	if the original shader doesn't repro (if the test returns ltrTestPassed), it returns S_FALSE.
	if it successfully shrinks the shader, it returns S_OK
	if something internally bad happens, it returns S_UNEXPECTED


Algorithm: 
0	start with the last line
1   if we're at the beginning of the shader, end
2   go to the beginning of the current line
3   try commenting it out.
4   run the test. 
5	If it fails, then
6        move to the next line up
7        goto 1
8	if it didn't fail
9	    try commenting out all the other lines above it, one at a time (only if bNSquared is true)
10		if those cause the test to fail (reproduce the problem), then
11		    leave both lines commented
12			go to next line up
13			goto 1
14		else 
15		    uncomment everything that has been commented since our last visit to (1)
16			move to next line up
17			goto 1
*/
HRESULT LipoVsh(
	XBuffer*  pInput,    //input buffer (constant)
	XBuffer** ppOutput,  //pointer to receive smallest output
	LIPOTEST pfnTest,   //pointer to function to test the lipo'd shader
	void*    pData,     //pointer to data to pass to the test function
	bool     bNSquared, //true to try removing 2 lines at a time
	bool     bTryAgain  //true to keep trying to repeat if it succeeds the first time
	)
{
	HRESULT hr = S_OK;
	XBuffer* pbuf;
	LIPOTESTRETURN ret;

	if(!ppOutput || !pInput || !pfnTest) {
		return E_POINTER;
	}

	*ppOutput = new XBuffer;
	pbuf = *ppOutput;
	if(!pbuf) {
		return E_OUTOFMEMORY;
	}

	hr = pbuf->Append(*pInput);
	if(FAILED(hr)) {
		return hr;
	}

	ret = pfnTest(pbuf, pData);
	switch(ret) {
	case ltrTestFailed:
		//this is good. We shrink the input now...
		break;

	case ltrTestPassed:
		//the original didn't repro whatever bug there was, so there's nothing we can do.
		return S_FALSE;

	case ltrInvalid:
		//the original isn't a valid shader, or whatever, so just return with the error.
		return E_INVALIDARG;
	}

	//initial test failed, commence liposuction!
	char* pTest = pbuf->GetText();
	char b, b2;
	bool bHasShrunk = false;

	do {
		for(int i = pbuf->GetUsed() - 1; i >= 0; i--) {
			//look for new-line
			if(pTest[i] == '\n') {
				//save the char after the newline
				b = pTest[i + 1];
				//if it's the last char in the buf, or it has already been commented out, ignore it
				if(b == '\0' || b == ';') {
					continue;
				}

				pTest[i + 1] = ';'; //comment out this line

				//test it...
				ret = pfnTest(pbuf, pData);

				switch (ret) {
				case ltrTestFailed:
					//The code still repros. Leave this line commented out, and continue shrinking
					bHasShrunk = true;
					continue;

				case ltrTestPassed:
				case ltrInvalid:
					if (!bNSquared) {
						//we broke something, or it no longer reproduces, and we're not 
						//going to try to comment out 2 lines at a time, so put the line 
						// back the way it was, and try the next one. 
						pTest[i + 1] = b;
						continue;

					} else {
						//try to do 2 lines at once...
						bool bSecondTimeWorked = false;

						for(int j = i-1; j >= 0; j--) {
							//look for new-line
							if(pTest[j] == '\n') {
								//save the char after the newline
								b2 = pTest[j + 1];
								//if it's the last char in the buf, or it has already been commented out, ignore it
								if(b2 == '\0' || b2 == ';') {
									continue;
								}

								pTest[j + 1] = ';'; //comment out this line

								//test it...
								ret = pfnTest(pbuf, pData);

								switch (ret) {
								case ltrTestFailed:
									//The code still repros. Leave this line commented out, and continue shrinking
									bHasShrunk = true;
									bSecondTimeWorked = true;
									continue;

								case ltrTestPassed:
								case ltrInvalid:
									//we broke something, or it no longer reproduces, so put the line 
									// back the way it was, and try the next one. 
									pTest[j + 1] = b2;
									continue;
								}
							}
						}
						if(!bSecondTimeWorked) {
							//commenting out the first line causes the thing to either
							//totally break or not repro again. Put it back!
							pTest[i + 1] = b;
							continue;
						} else {
							//commenting out the first line plus something else causes it
							//to reproduce... leave them both commented.
						}
					}
				}
			}
		}
	} while (bHasShrunk && bTryAgain);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\vshtimer\vstune.h ===
//-----------------------------------------------------------------------------
// FILE: VSTUNE.H
//
// Desc: vertex shader tune header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

struct TIMETESTRESULTS
{
    float fps;
    UINT cFrames;
    float TimeTillDoneDrawing;
    float TimeTillIdle;
    UINT64 cTrisDrawn;
    float mtps;
    float cycles;

    // precompiled results
    DWORD byteswritten;
    float throughput;
    DWORD pushbuffercalls;
    DWORD pushbuffersize;

    D3DWAITINFO PushBufferWaitInfo;
};

struct VSTSETTINGS
{
    UINT verboselevel;                  // chatty when loading pixelshader defs, etc.
    bool runtestonreload;               // after reloading fillrate.ini run test

    float screenwidth;                  // screen width
    float screenheight;                 // screen height
    D3DFORMAT BackBufferFormat;         // back buffer d3dformat
    D3DFORMAT AutoDepthStencilFormat;   // z buffer format (0 for none)

    D3DMULTISAMPLE_TYPE MSType;         // multisample type
    D3DMULTISAMPLE_TYPE MSFormat;       // multisample format

    DWORD FVF;                          // fvf type
    D3DPRIMITIVETYPE primitivetype;     // vertex buffer primitive type
    UINT indexcount;                    // count of indices
    UINT vertcount;                     // count of vertices in VB
    UINT TriCount;                      // count of triangles drawn

    DWORD uservertexshader;             // user vertex shader instruction count

    D3DCULL cullmode;                   // cullmode

    bool degenerates;                   // degenerate primitives?

    bool zenable;                       // enable z buffer
    bool zwriteenable;                  // enable z write
    D3DCMPFUNC d3dcmpfunc;              // z compare function

    float testtime;                     // number of seconds to time
    UINT vbdrawcount;                   // count of times to draw VB
    int precompiled;                    // use precompiled pushbuffer?
    int wcwritesinbkgnd;                // do wc background writes or block?
    int pushbuffernops;                 // insert noops into pushbuffer
    DWORD framesperpushbuffermax;       // max frames recorded in pushbuffer
    bool runusingcpucopy;               // copy pushbuffer
    DWORD numberofpushbuffers;          // number of pushbuffers (1 - 300) to use

    DWORD clearflags;                   // Clear() flags
    DWORD cclearval;                    // color clear val
    float zclearval;                    // z clear val
    DWORD sclearval;                    // stencil clear val

    bool alphablendenable;              // turn on alphablend
    bool alphatestenable;               // turn on alphatest

    D3DFILLMODE d3dfillmode;            // SOLID, WIREFRAME, ...

    bool localviewer;                   // D3DRS_LOCALVIEWER
    bool specularenable;                // D3DRS_SPECULARENABLE
    bool fogenable;                     // D3DRS_FOGENABLE
    bool normalizenormals;              // D3DRS_NORMALIZENORMALS
    bool colorvertex;                   // D3DRS_COLORVERTEX

    bool lighting;                      // D3DRS_LIGHTING
    DWORD numDirectionalLights;         // # of directional lights
    DWORD numPointLights;               // # of point lights
    DWORD numSpotLights;                // # of spotlights

    DWORD numtextures;                  // number of textures

    DWORD NumLights;                    // total number of lights enabled
    DWORD NumStreams;                   // total number of VB streams

//random shader options
	DWORD dwRndShaderMin;				//min number of instructions
	DWORD dwRndShaderMax;				//max number of instructions
	DWORD dwRndShaderNops;              //numbre of nops to start with
	DWORD dwRndShaderType;              //type of shader (xvsw / xvs)
	bool  bRndShaderWriteConsts;        //write to consts is allowed in xvsw?
	bool  bRndShaderXvs;                //use xbox-specific instructions
	bool  bRndShaderIndex;              //use a0.x
	bool  bRndShaderAllowPair;          //pair instructions 
	bool  bRndShaderScreenspace;        //use #pragma screenspace
	bool  bRndShaderAllowNop;           //allow nops

};

// macros to help us define the size of our texcoords in vstune.ini
static const DWORD T0_SIZE1 = D3DFVF_TEXCOORDSIZE1(0);
static const DWORD T0_SIZE2 = D3DFVF_TEXCOORDSIZE2(0);
static const DWORD T0_SIZE3 = D3DFVF_TEXCOORDSIZE3(0);
static const DWORD T0_SIZE4 = D3DFVF_TEXCOORDSIZE4(0);

static const DWORD T1_SIZE1 = D3DFVF_TEXCOORDSIZE1(1);
static const DWORD T1_SIZE2 = D3DFVF_TEXCOORDSIZE2(1);
static const DWORD T1_SIZE3 = D3DFVF_TEXCOORDSIZE3(1);
static const DWORD T1_SIZE4 = D3DFVF_TEXCOORDSIZE4(1);

static const DWORD T2_SIZE1 = D3DFVF_TEXCOORDSIZE1(2);
static const DWORD T2_SIZE2 = D3DFVF_TEXCOORDSIZE2(2);
static const DWORD T2_SIZE3 = D3DFVF_TEXCOORDSIZE3(2);
static const DWORD T2_SIZE4 = D3DFVF_TEXCOORDSIZE4(2);

static const DWORD T3_SIZE1 = D3DFVF_TEXCOORDSIZE1(3);
static const DWORD T3_SIZE2 = D3DFVF_TEXCOORDSIZE2(3);
static const DWORD T3_SIZE3 = D3DFVF_TEXCOORDSIZE3(3);
static const DWORD T3_SIZE4 = D3DFVF_TEXCOORDSIZE4(3);

static const DWORD VSDT_FLOAT1 = D3DVSDT_FLOAT1 << 16;
static const DWORD VSDT_FLOAT2 = D3DVSDT_FLOAT2 << 16;
static const DWORD VSDT_FLOAT3 = D3DVSDT_FLOAT3 << 16;
static const DWORD VSDT_FLOAT4 = D3DVSDT_FLOAT4 << 16;
static const DWORD VSDT_D3DCOLOR = D3DVSDT_D3DCOLOR << 16;
static const DWORD VSDT_SHORT2 = D3DVSDT_SHORT2 << 16;
static const DWORD VSDT_SHORT4 = D3DVSDT_SHORT4 << 16;
static const DWORD VSDT_NORMSHORT1 = D3DVSDT_NORMSHORT1 << 16;
static const DWORD VSDT_NORMSHORT2 = D3DVSDT_NORMSHORT2 << 16;
static const DWORD VSDT_NORMSHORT3 = D3DVSDT_NORMSHORT3 << 16;
static const DWORD VSDT_NORMSHORT4 = D3DVSDT_NORMSHORT4 << 16;
static const DWORD VSDT_NORMPACKED3 = D3DVSDT_NORMPACKED3 << 16;
static const DWORD VSDT_SHORT1 = D3DVSDT_SHORT1 << 16;
static const DWORD VSDT_SHORT3 = D3DVSDT_SHORT3 << 16;
static const DWORD VSDT_PBYTE1 = D3DVSDT_PBYTE1 << 16;
static const DWORD VSDT_PBYTE2 = D3DVSDT_PBYTE2 << 16;
static const DWORD VSDT_PBYTE3 = D3DVSDT_PBYTE3 << 16;
static const DWORD VSDT_PBYTE4 = D3DVSDT_PBYTE4 << 16;
static const DWORD VSDT_FLOAT2H = D3DVSDT_FLOAT2H << 16;
static const DWORD VSDT_NONE = D3DVSDT_NONE << 16;

// vstune.cpp
bool ReadVSTIniFile();

void DoQuickTimedTest();
void DoPushBufferCallTest();
void RandomVS();
void NopVS();

void DumpCurrentSettings();
float DoTimedTest(TIMETESTRESULTS *pttres = NULL);
void InitVertexShader();
void ClearScreen();
DWORD GetNVCLK();
void RenderFrame(int vbdrawcount, BOOL nops = FALSE);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\wbuffer\sources.inc ===
TARGETNAME=wbuffer
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES= \
    main.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\wbuffer\main.cpp ===
#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#include <d3d8.h>
#include <d3dx8.h>
#endif // XBOX

DWORD dwFVF = D3DFVF_XYZ | D3DFVF_DIFFUSE;
struct { float x,y,z; DWORD color; } Verts[] =
{
    { -1.0f, -1.0f, 0.0f, 0xffff0000, },
    {  0.0f,  1.0f, 0.0f, 0xff00ff00, },
    {  1.0f, -1.0f, 0.0f, 0xff0000ff, },
};

BOOL g_bUseWBuffer = 1;
D3DXVECTOR3 g_vEye;
IDirect3DDevice8* g_pDev;

void Initialize()
{
    D3DXMATRIX matWorld, matView, matProj;

    D3DXMatrixIdentity( &matWorld );
    g_pDev->SetTransform( D3DTS_WORLD, &matWorld );

    g_vEye = D3DXVECTOR3( 0.0f, 0.0f, -1.5f );
    D3DXVECTOR3 vAt( 0.0f, 0.0f, 1.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );

    D3DXMatrixLookAtLH( &matView, &g_vEye, &vAt, &vUp );
    g_pDev->SetTransform( D3DTS_VIEW, &matView );

    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 1.0f, 1.0f, 100.0f );
    g_pDev->SetTransform( D3DTS_PROJECTION, &matProj );
}

void FrameMove()
{
    D3DXMATRIX matRotate, matView;
    D3DXVECTOR3 axis( 1.0f, 0.0f, 0.0f);
    D3DXVECTOR3 vAt( 0.0f, 0.0f, 1.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );

    D3DXMatrixRotationAxis( &matRotate, &axis, 0.0006f );
    D3DXVec3TransformCoord( &g_vEye, &g_vEye, &matRotate );

    D3DXMatrixLookAtLH( &matView, &g_vEye, &vAt, &vUp );

    g_pDev->SetTransform( D3DTS_VIEW, &matView );
}

void Render()
{
    g_pDev->BeginScene();

    g_pDev->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00ffffff, 1.0f, 0L );

    g_pDev->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pDev->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );

	if (g_bUseWBuffer)
		g_pDev->SetRenderState( D3DRS_ZENABLE, D3DZB_USEW );
	else
		g_pDev->SetRenderState( D3DRS_ZENABLE, D3DZB_TRUE );

    g_pDev->SetVertexShader(dwFVF);
    g_pDev->DrawPrimitiveUP( D3DPT_TRIANGLELIST, 3, Verts, sizeof(Verts[0]) );
    g_pDev->EndScene();

    g_pDev->Present( NULL, NULL, NULL, NULL );
}

BOOL InitD3D(HWND hWnd)
{
    D3DPRESENT_PARAMETERS d3dpp;
    IDirect3D8 *pD3D;

    // Create D3D 8.
    pD3D = Direct3DCreate8(D3D_SDK_VERSION);
    if (pD3D == NULL)
        return FALSE;

    // Set the screen mode.
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth                 = 640;
    d3dpp.BackBufferHeight                = 480;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 1;
    d3dpp.Windowed                        = FALSE;   // Must be FALSE for Xbox.
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                   = hWnd;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Create the device.

    if (IDirect3D8_CreateDevice(
        pD3D,
        D3DADAPTER_DEFAULT,
        D3DDEVTYPE_HAL,
        hWnd,
        D3DCREATE_HARDWARE_VERTEXPROCESSING,
        &d3dpp,
        &g_pDev) != S_OK)
    {
        return FALSE;
    }

    // Now we no longer need the D3D interface so lets free it.
    IDirect3D8_Release(pD3D);

    Initialize();

    return TRUE;
}

#ifdef XBOX

void __cdecl main()
{
    if (!InitD3D(NULL))
    {
        return;
    }

    while (TRUE)
    {
        FrameMove();
        Render();
    }
}

#else // XBOX

LRESULT WINAPI MessageHandler(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    if (Msg == WM_DESTROY)
        PostQuitMessage(0);

    return DefWindowProc(hWnd, Msg, wParam, lParam);
}

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    BOOL bQuit = FALSE;
    MSG msg;
    HWND hwnd;

    WNDCLASSEX classex;
    ZeroMemory( &classex, sizeof(classex) );

    classex.cbSize          = sizeof(WNDCLASSEX);
    classex.style           = CS_CLASSDC;
    classex.lpfnWndProc     = MessageHandler;
    classex.hInstance       = hInstance;
    classex.lpszClassName   = L"XBOX";
    RegisterClassEx(&classex);

    hwnd = CreateWindowEx(WS_EX_TOPMOST, L"XBOX", L"XBOX Basic Shell",
                          WS_VISIBLE|WS_POPUP,
                          CW_USEDEFAULT,CW_USEDEFAULT, 0, 0,
                          NULL, NULL, hInstance, NULL);

    if (!InitD3D(hwnd))
    {
        return EXIT_FAILURE;
    }

    ShowCursor(FALSE);

    while (!bQuit)
    {
        while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
        {
            if (!GetMessage(&msg, NULL, 0, 0))
            {
                bQuit = TRUE;
            }

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        FrameMove();
        Render();
    }

    return EXIT_SUCCESS;
}

#endif // XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tests\vshtools\vshgen.h ===
#pragma once

#ifndef countof
#define countof(a) (sizeof(a) / sizeof((a)[0]))
#endif

//random functions: between min & max.
//for FRND, [min, max).
#define FRND(min, max) ((((float)rand() / (float)RAND_MAX) * (fabs((max) - (min)))) + (min))
//for RND, [min, max].
#define RND(min, max) ((rand() % (abs((max) - (min)) + 1)) + (min))
//for RNDE, [min, max).
#define RNDE(min, max) (((rand() * abs((max) - (min)) / RAND_MAX)) + (min))
//for [False,True]
#define RNDTF() ((rand() & 1) ? true : false)

namespace XGRAPHICS {
	//a handy auto-resizing buffer class, including "printf", and other nifty features
	class Buffer {
		DWORD m_size;
		char* m_buf;
		DWORD m_used;
	public:
		Buffer();
		~Buffer();
		HRESULT Initialize(DWORD size);
		HRESULT GrowTo(DWORD size);
		HRESULT Printf(const char* msg,...);
		HRESULT Append(LPCVOID data, DWORD length);
		HRESULT Append(char c);
		HRESULT Append(const char* c);
		HRESULT Append(Buffer& buffer);
		char* GetText();
		char* GetTextEnd();
		DWORD GetUsed();
		void Clear();
	};
};
typedef XGRAPHICS::Buffer XBuffer;


//the three expected return values from a LIPOTEST.
enum LIPOTESTRETURN {
	ltrTestFailed, ltrTestPassed, ltrInvalid
};

//LIPOTEST is a callback function for LipoVsh. It should perform a test on the shader,
//  and return ltrTestFailed if LipoVsh should accept the change it just made to the shader
//  or ltrTestPassed if it should reject the change...
//  or ltrInvalid if the change it made made the shader not assemblable (or something similar.)
//In most cases, TestPassed and Invalid will result in the same behavior, except for the first time
//  the test is run.
//An example of its usage: An app would create a vertex shader, and call LipoVsh on it, passing 
//  a test which would try to assemble the shader, and return ltrTestFailed if the shader optimizer
//  broke the resulting shader. IT would return ltrTestPassed if the shader optimizer succeeded, or
//  ltrInvalid if the shader couldn't be assembled for other reasons.
//  LipoVsh would then shrink the test down (retesting it after every shrinkage) in order to get the 
//  smallest shader possible that still breaks the optimizer. The app would then save that shader to disk,
//  and if it was really an impressive app, would send mail to the developer in charge of the optimizer, 
//  and attach the file that broke it. :)
typedef LIPOTESTRETURN (*LIPOTEST)(XBuffer* pText, void* pData); 

/*
The smallest shader that still repro's (the test returns ltrTestFailed) will be returned in 
  a new buffer, which will be pointed to by *ppOutput.

Return: 
	if a parameter is NULL (other than pData), return E_POINTER
	if it runs out of memory, it returns E_OUTOFMEMORY
	if the original shader isn't valid, return E_INVALIDARG
	if the original shader doesn't repro (if the test returns ltrTestPassed), it returns S_FALSE.
	if it successfully shrinks the shader, it returns S_OK
	if something internally bad happens, it returns S_UNEXPECTED
*/
HRESULT LipoVsh(
	XBuffer*  pInput,    //input buffer (constant)
	XBuffer** ppOutput,  //pointer to receive smallest output
	LIPOTEST pfnTest,   //pointer to function to test the lipo'd shader
	void*    pData,     //pointer to data to pass to the test function
	bool     bNSquared, //true to try removing 2 lines at a time
	bool     bTryAgain  //true to keep trying to repeat if it succeeds the first time
);



/*
Create a random vertex shader, of length randomly selected between minlength and maxlength, inclusive.
It will start the shader with the specified number of NOPs, which can prevent some of the randomness that occurs in the first few cycles of the shader
dwType can be either hardware format (0x7378, etc), or SASM-format (SASMT_VERTEXSTATESHADER, etc.).
if bWriteConsts is false, it will not write to constant registers
bIsXvs represents whether it is an xbox-specific shader (196 constants, two extra instructions)
bAllowPair, if true, will allow up to 3 instructions to be paired with the + operator
bScreenspace, if true, will add #pragma screenspace to the beginning of the shader
ppOutput should be the address of a XBuffer*. That will be set to point to a new xbuffer that will contain the new shader.
*/
HRESULT GenerateRandomVertexShader(
	int minlength, 
	int maxlength, 
	DWORD dwNopsAtBeginning,
	DWORD dwType, 
	bool bWriteConsts,
	bool bIsXvs,
	bool bAllowIndex,
	bool bAllowPair,
	bool bScreenspace,
	bool bAllowNop,
	XBuffer** ppOutput
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\ChildFrm.Cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "dxtex.h"
#include "dxtexdoc.h"
#include "dxtexview.h"

#include "ChildFrm.h"

#ifndef WM_IDLEUPDATECMDUI
    #define WM_IDLEUPDATECMDUI  0x0363  // wParam == bDisableIfNoHandler
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
    //{{AFX_MSG_MAP(CChildFrame)
    ON_MESSAGE(WM_IDLEUPDATECMDUI, OnIdleUpdateCmdUI)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if( !CMDIChildWnd::PreCreateWindow(cs) )
        return FALSE;

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
    CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
    CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers

BOOL CChildFrame::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CMDIFrameWnd* pParentWnd, CCreateContext* pContext)
{
    if (!CMDIChildWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, pContext))
        return FALSE;

    return TRUE;
}



// Handle WM_IDLEUPDATECMDUI to update modified indicator if necessary.
LRESULT CChildFrame::OnIdleUpdateCmdUI(WPARAM wParam, LPARAM)
{
    // Only update the title if the doc or view state has changed.
    // Otherwise, the title bar will flicker.
    CDxtexDoc* pDoc = (CDxtexDoc*)GetActiveDocument();
    CDxtexView* pView = (CDxtexView*)GetActiveView();
    if (pView->TitleModsChanged() || pDoc->TitleModsChanged())
    {
        // This will force MFC to call CChildFrame::OnUpdateTitleFrame:
        m_nIdleFlags |= idleTitle;
        pView->ClearTitleModsChanged();
        pDoc->ClearTitleModsChanged();
    }

    // Do the default thing
    CMDIChildWnd::OnIdleUpdateCmdUI();
    return 0L;
}


void CChildFrame::OnUpdateFrameTitle(BOOL bAddToTitle)
{
    CMDIChildWnd::OnUpdateFrameTitle(bAddToTitle);
    CDxtexView* pView = (CDxtexView*)GetActiveView();
    {
        CString title;
        GetWindowText(title);
        title += " " + pView->GetStrTitleMods();
        SetWindowText(title);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\DDS.h ===
// dds.h
//
// This header defines constants and structures that are useful when parsing
// DDS files.  DDS files were originally designed to use several structures
// and constants that are native to DirectDraw and are defined in ddraw.h,
// such as DDSURFACEDESC2 and DDSCAPS2.  This file defines similar
// (compatible) constants and structures so that one can use DDS files
// without needing to include ddraw.h.

#ifndef _DDS_H_
#define _DDS_H_

struct DDS_PIXELFORMAT
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwFourCC;
    DWORD dwRGBBitCount;
    DWORD dwRBitMask;
    DWORD dwGBitMask;
    DWORD dwBBitMask;
    DWORD dwABitMask;
};

#define DDS_FOURCC 0x00000004  // DDPF_FOURCC
#define DDS_RGB    0x00000040  // DDPF_RGB
#define DDS_RGBA   0x00000041  // DDPF_RGB | DDPF_ALPHAPIXELS

//
// Old Xbox dds files use these constants
#define D3DFMT_DXT1_X       0x0000000C
#define D3DFMT_DXT2_X       0x0000000E
#define D3DFMT_DXT4_X       0x0000000F

const DDS_PIXELFORMAT DDSPF_DXT1 =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('D', 'X', 'T', '1'), 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_DXT2 =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('D', 'X', 'T', '2'), 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_DXT3 =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('D', 'X', 'T', '3'), 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_DXT4 =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('D', 'X', 'T', '4'), 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_DXT5 =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('D', 'X', 'T', '5'), 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_DXT1_X =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, D3DFMT_DXT1_X, 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_DXT2_X =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, D3DFMT_DXT2_X, 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_DXT4_X =
    { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, D3DFMT_DXT4_X, 0, 0, 0, 0, 0 };

const DDS_PIXELFORMAT DDSPF_A8R8G8B8 =
    { sizeof(DDS_PIXELFORMAT), DDS_RGBA, 0, 32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000 };

const DDS_PIXELFORMAT DDSPF_A1R5G5B5 =
    { sizeof(DDS_PIXELFORMAT), DDS_RGBA, 0, 16, 0x00007c00, 0x000003e0, 0x0000001f, 0x00008000 };

const DDS_PIXELFORMAT DDSPF_A4R4G4B4 =
    { sizeof(DDS_PIXELFORMAT), DDS_RGBA, 0, 16, 0x0000f000, 0x000000f0, 0x0000000f, 0x0000f000 };

const DDS_PIXELFORMAT DDSPF_R8G8B8 =
    { sizeof(DDS_PIXELFORMAT), DDS_RGB, 0, 24, 0x00ff0000, 0x0000ff00, 0x000000ff, 0x00000000 };

const DDS_PIXELFORMAT DDSPF_R5G6B5 =
    { sizeof(DDS_PIXELFORMAT), DDS_RGB, 0, 16, 0x0000f800, 0x000007e0, 0x0000001f, 0x00000000 };

#define DDS_HEADER_FLAGS_TEXTURE    0x00001007  // DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT
#define DDS_HEADER_FLAGS_MIPMAP     0x00020000  // DDSD_MIPMAPCOUNT
#define DDS_HEADER_FLAGS_VOLUME     0x00800000  // DDSD_DEPTH
#define DDS_HEADER_FLAGS_PITCH      0x00000008  // DDSD_PITCH
#define DDS_HEADER_FLAGS_LINEARSIZE 0x00080000  // DDSD_LINEARSIZE

#define DDS_SURFACE_FLAGS_TEXTURE 0x00001000 // DDSCAPS_TEXTURE
#define DDS_SURFACE_FLAGS_MIPMAP  0x00400008 // DDSCAPS_COMPLEX | DDSCAPS_MIPMAP
#define DDS_SURFACE_FLAGS_CUBEMAP 0x00000008 // DDSCAPS_COMPLEX

#define DDS_CUBEMAP_POSITIVEX 0x00000600 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX
#define DDS_CUBEMAP_NEGATIVEX 0x00000a00 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEX
#define DDS_CUBEMAP_POSITIVEY 0x00001200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEY
#define DDS_CUBEMAP_NEGATIVEY 0x00002200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEY
#define DDS_CUBEMAP_POSITIVEZ 0x00004200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEZ
#define DDS_CUBEMAP_NEGATIVEZ 0x00008200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEZ

#define DDS_CUBEMAP_ALLFACES ( DDS_CUBEMAP_POSITIVEX | DDS_CUBEMAP_NEGATIVEX |\
                               DDS_CUBEMAP_POSITIVEY | DDS_CUBEMAP_NEGATIVEY |\
                               DDS_CUBEMAP_POSITIVEZ | DDS_CUBEMAP_NEGATIVEZ )

#define DDS_FLAGS_VOLUME 0x00200000 // DDSCAPS2_VOLUME


struct DDS_HEADER
{
    DWORD dwSize;
    DWORD dwHeaderFlags;
    DWORD dwHeight;
    DWORD dwWidth;
    DWORD dwPitchOrLinearSize;
    DWORD dwDepth; // only if DDS_HEADER_FLAGS_VOLUME is set in dwHeaderFlags
    DWORD dwMipMapCount;
    DWORD dwReserved1[11];
    DDS_PIXELFORMAT ddspf;
    DWORD dwSurfaceFlags;
    DWORD dwCubemapFlags;
    DWORD dwReserved2[3];
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\Dialogs.Cpp ===
// Dialogs.cpp : implementation file
//

#include "stdafx.h"
#include "dxtex.h"
#include "dialogs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewTextureDlg dialog


CNewTextureDlg::CNewTextureDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CNewTextureDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CNewTextureDlg)
    m_iTexType = 0;
    m_dwWidth = 256;
    m_dwHeight = 256;
    m_dwDepth = 8;
    m_iFmt = 0;
    m_strFmtDesc = _T("");
    m_numMips = 1;
    m_bXbox = 1;
    //}}AFX_DATA_INIT
}


void CNewTextureDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewTextureDlg)
    DDX_Radio(pDX, IDC_TEXTURE, m_iTexType);
    DDX_Text(pDX, IDC_WIDTH, m_dwWidth);
    DDV_MinMaxInt(pDX, m_dwWidth, 1, 1024);
    DDX_Text(pDX, IDC_HEIGHT, m_dwHeight);
    DDV_MinMaxInt(pDX, m_dwHeight, 1, 1024);
    DDX_Text(pDX, IDC_DEPTH, m_dwDepth);
    DDV_MinMaxInt(pDX, m_dwDepth, 2, 1024);
    DDX_Radio(pDX, IDC_A8R8G8B8, m_iFmt);
    DDX_Text(pDX, IDC_FMTDESC, m_strFmtDesc);
    DDX_Text(pDX, IDC_MIPCOUNT, m_numMips);
    DDV_MinMaxInt(pDX, m_numMips, 1, 20);
    DDX_Check(pDX, IDC_Xbox, m_bXbox);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewTextureDlg, CDialog)
    //{{AFX_MSG_MAP(CNewTextureDlg)
    ON_BN_CLICKED(IDC_TEXTURE, OnChangeTextureType)
    ON_BN_CLICKED(IDC_A8R8G8B8, OnChangeFormat)
    ON_BN_CLICKED(IDC_VOLUMETEXTURE, OnChangeTextureType)
    ON_BN_CLICKED(IDC_CUBEMAP, OnChangeTextureType)
    ON_BN_CLICKED(IDC_A4R4G4B4, OnChangeFormat)
    ON_BN_CLICKED(IDC_A1R5G5B5, OnChangeFormat)
    ON_BN_CLICKED(IDC_R5G6B5, OnChangeFormat)
    ON_BN_CLICKED(IDC_R8G8B8, OnChangeFormat)
    ON_BN_CLICKED(IDC_DXT1, OnChangeFormat)
    ON_BN_CLICKED(IDC_DXT2, OnChangeFormat)
    ON_BN_CLICKED(IDC_DXT3, OnChangeFormat)
    ON_BN_CLICKED(IDC_DXT4, OnChangeFormat)
    ON_BN_CLICKED(IDC_DXT5, OnChangeFormat)
    ON_BN_CLICKED(IDC_Xbox, OnChangeFormat)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewTextureDlg message handlers

BOOL CNewTextureDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    OnChangeTextureType();
    OnChangeFormat();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CNewTextureDlg::OnChangeTextureType()
{
    UpdateData(TRUE);

    if (m_iTexType == 2)
    {
        // Volume Tex
        GetDlgItem(IDC_VOLUMEDEPTHLABEL)->EnableWindow(TRUE);
        GetDlgItem(IDC_DEPTH)->EnableWindow(TRUE);

        GetDlgItem(IDC_DXT1)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT2)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT3)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT4)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT5)->EnableWindow(FALSE);

        if (m_iFmt > 4)
            m_iFmt = 0;
    }
    else
    {
        // Normal or Cube Tex
        GetDlgItem(IDC_VOLUMEDEPTHLABEL)->EnableWindow(FALSE);
        GetDlgItem(IDC_DEPTH)->EnableWindow(FALSE);

        GetDlgItem(IDC_DXT1)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT2)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT3)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT4)->EnableWindow(TRUE);
        GetDlgItem(IDC_DXT5)->EnableWindow(TRUE);
    }
    UpdateData(FALSE);
    OnChangeFormat();
}



void CNewTextureDlg::OnChangeFormat()
{
    UpdateData(TRUE);

    switch (m_iFmt)
    {
    case 0:
        m_fmt = D3DFMT_A8R8G8B8;
        m_strFmtDesc.LoadString(IDS_FMTDESC_A8R8G8B8);
        break;
    case 1:
        m_fmt = D3DFMT_A1R5G5B5;
        m_strFmtDesc.LoadString(IDS_FMTDESC_A1R5G5B5);
        break;
    case 2:
        m_fmt = D3DFMT_A4R4G4B4;
        m_strFmtDesc.LoadString(IDS_FMTDESC_A4R4G4B4);
        break;
    case 3:
        m_fmt = D3DFMT_R8G8B8;
        m_strFmtDesc.LoadString(IDS_FMTDESC_R8G8B8);
        break;
    case 4:
        m_fmt = D3DFMT_R5G6B5;
        m_strFmtDesc.LoadString(IDS_FMTDESC_R5G6B5);
        break;
    case 5:
        m_fmt = D3DFMT_DXT1;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT1);
        break;
    case 6:
        m_fmt = D3DFMT_DXT2;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT2);
        break;
    case 7:
        m_fmt = D3DFMT_DXT3;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT3);
        break;
    case 8:
        m_fmt = D3DFMT_DXT4;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT4);
        break;
    case 9:
        m_fmt = D3DFMT_DXT5;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT5);
        break;
    }
    UpdateData(FALSE);
}

void CNewTextureDlg::OnOK()
{
    UpdateData(TRUE);

    // TODO: Need to do lots of validation of width/height/depth/mipcount here

    if (m_iTexType != 2)
        m_dwDepth = 0;

    switch (m_iFmt)
    {
    case 0:  m_fmt = D3DFMT_A8R8G8B8;   break;
    case 1:  m_fmt = D3DFMT_A1R5G5B5;   break;
    case 2:  m_fmt = D3DFMT_A4R4G4B4;   break;
    case 3:  m_fmt = D3DFMT_R8G8B8;     break;
    case 4:  m_fmt = D3DFMT_R5G6B5;     break;
    case 5:  m_fmt = D3DFMT_DXT1;       break;
    case 6:  m_fmt = D3DFMT_DXT2;       break;
    case 7:  m_fmt = D3DFMT_DXT3;       break;
    case 8:  m_fmt = D3DFMT_DXT4;       break;
    case 9:  m_fmt = D3DFMT_DXT5;       break;
    }

    CDialog::OnOK();
}

/////////////////////////////////////////////////////////////////////////////
// CCubeMapDlg dialog


CCubeMapDlg::CCubeMapDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CCubeMapDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CCubeMapDlg)
    m_iFace = 0;
    //}}AFX_DATA_INIT
}


void CCubeMapDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCubeMapDlg)
    DDX_Radio(pDX, IDC_POSX, m_iFace);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCubeMapDlg, CDialog)
    //{{AFX_MSG_MAP(CCubeMapDlg)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CVolumeMapDlg dialog


CVolumeMapDlg::CVolumeMapDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CVolumeMapDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CVolumeMapDlg)
    m_powLayers = 0;
    //}}AFX_DATA_INIT
}


void CVolumeMapDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CVolumeMapDlg)
    DDX_Radio(pDX, IDC_RADIO2, m_powLayers);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CVolumeMapDlg, CDialog)
    //{{AFX_MSG_MAP(CVolumeMapDlg)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVolumeMapDlg message handlers


/////////////////////////////////////////////////////////////////////////////
// CChangeFmtDlg dialog


CChangeFmtDlg::CChangeFmtDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CChangeFmtDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CChangeFmtDlg)
    m_iFmt = -1;
    m_strFmtDesc = _T("");
    //}}AFX_DATA_INIT
}


void CChangeFmtDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CChangeFmtDlg)
    DDX_Radio(pDX, IDC_A8R8G8B8, m_iFmt);
    DDX_Text(pDX, IDC_FMTDESC, m_strFmtDesc);
    DDX_Check(pDX, IDC_Xbox, m_bXbox);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChangeFmtDlg, CDialog)
    //{{AFX_MSG_MAP(CChangeFmtDlg)
    ON_BN_CLICKED(IDC_A1R5G5B5, OnChangeFmt)
    ON_BN_CLICKED(IDC_A4R4G4B4, OnChangeFmt)
    ON_BN_CLICKED(IDC_A8R8G8B8, OnChangeFmt)
    ON_BN_CLICKED(IDC_DXT1, OnChangeFmt)
    ON_BN_CLICKED(IDC_DXT2, OnChangeFmt)
    ON_BN_CLICKED(IDC_DXT3, OnChangeFmt)
    ON_BN_CLICKED(IDC_DXT4, OnChangeFmt)
    ON_BN_CLICKED(IDC_DXT5, OnChangeFmt)
    ON_BN_CLICKED(IDC_R5G6B5, OnChangeFmt)
    ON_BN_CLICKED(IDC_R8G8B8, OnChangeFmt)
    ON_BN_CLICKED(IDC_Xbox, OnChangeFmt)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChangeFmtDlg message handlers

BOOL CChangeFmtDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    if (m_bVolume)
    {
        GetDlgItem(IDC_DXT1)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT2)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT3)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT4)->EnableWindow(FALSE);
        GetDlgItem(IDC_DXT5)->EnableWindow(FALSE);
    }
    switch (m_fmt)
    {
    case D3DFMT_A8R8G8B8:
        m_iFmt = 0;
        break;
    case D3DFMT_A1R5G5B5:
        m_iFmt = 1;
        break;
    case D3DFMT_A4R4G4B4:
        m_iFmt = 2;
        break;
    case D3DFMT_R8G8B8:
        m_iFmt = 3;
        break;
    case D3DFMT_R5G6B5:
        m_iFmt = 4;
        break;
    case D3DFMT_DXT1:
        m_iFmt = 5;
        break;
    case D3DFMT_DXT2:
        m_iFmt = 6;
        break;
    case D3DFMT_DXT3:
        m_iFmt = 7;
        break;
    case D3DFMT_DXT4:
        m_iFmt = 8;
        break;
    case D3DFMT_DXT5:
        m_iFmt = 9;
        break;
    }

    UpdateFmtDesc();

    UpdateData(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CChangeFmtDlg::OnChangeFmt()
{
    UpdateData(TRUE);

    UpdateFmtDesc();
}

void CChangeFmtDlg::UpdateFmtDesc()
{
    switch (m_iFmt)
    {
    case 0:
        m_fmt = D3DFMT_A8R8G8B8;
        m_strFmtDesc.LoadString(IDS_FMTDESC_A8R8G8B8);
        break;
    case 1:
        m_fmt = D3DFMT_A1R5G5B5;
        m_strFmtDesc.LoadString(IDS_FMTDESC_A1R5G5B5);
        break;
    case 2:
        m_fmt = D3DFMT_A4R4G4B4;
        m_strFmtDesc.LoadString(IDS_FMTDESC_A4R4G4B4);
        break;
    case 3:
        m_fmt = D3DFMT_R8G8B8;
        m_strFmtDesc.LoadString(IDS_FMTDESC_R8G8B8);
        break;
    case 4:
        m_fmt = D3DFMT_R5G6B5;
        m_strFmtDesc.LoadString(IDS_FMTDESC_R5G6B5);
        break;
    case 5:
        m_fmt = D3DFMT_DXT1;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT1);
        break;
    case 6:
        m_fmt = D3DFMT_DXT2;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT2);
        break;
    case 7:
        m_fmt = D3DFMT_DXT3;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT3);
        break;
    case 8:
        m_fmt = D3DFMT_DXT4;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT4);
        break;
    case 9:
        m_fmt = D3DFMT_DXT5;
        m_strFmtDesc.LoadString(IDS_FMTDESC_DXT5);
        break;
    }
    UpdateData(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\compress\main.cpp ===
#include <windows.h>
#include <stdio.h>

DWORD g_cWidth;
DWORD g_cHeight;

#define TEXT_COLOR RGB(0x00, 0xFF, 0x00)
#define BKG_COLOR RGB(0x00, 0x00, 0x00)

#pragma pack(1)

typedef struct _BYTES1 {
    BYTE b1;
} BYTES1;

typedef struct _IMAGE_RUN1 {
    UINT fOne : 1;
    UINT Size : 3;
    UINT Intensity : 4;
} IMAGE_RUN1;

typedef union _RUN1 {
    BYTES1 bytes;
    IMAGE_RUN1 run;
} RUN1;

typedef struct _BYTES2 {
    BYTE b1;
    BYTE b2;
} BYTES2;

typedef struct _IMAGE_RUN2 {
    UINT fOne : 1;
    UINT fTwo : 1;
    UINT Size : 10;
    UINT Intensity : 4;
} IMAGE_RUN2;

typedef union _RUN2 {
    BYTES2 bytes;
    IMAGE_RUN2 run;
} RUN2;

typedef struct _BYTES3 {
    BYTE b1;
    BYTE b2;
    BYTE b3;
} BYTES3;

typedef struct _IMAGE_RUN3 {
    UINT fOne : 1;
    UINT fTwo : 1;
    UINT Size : 18;
    UINT Intensity : 4;
} IMAGE_RUN3;

typedef union _RUN3 {
    BYTES3 bytes;
    IMAGE_RUN3 run;
} RUN3;

typedef struct _IMAGE_RUN {
    UINT fOne;
    UINT fTwo;
    UINT Size;
    UINT Intensity;
} IMAGE_RUN;

#pragma pack()

IMAGE_RUN *g_pImage;

UINT IntensityFromColor(COLORREF cr)
{
    UINT r = GetRValue(cr);
    UINT g = GetGValue(cr);
    UINT b = GetBValue(cr);

    // Has the range 0 through 255
    UINT intensity8bits = max(max(r, g), b);

    // Has the range 0.0 through 1.0
    FLOAT intensityFloat = intensity8bits / 255.0f;

    // Rounded, in the range 0 through 15
    UINT intensity4bits = (UINT)(intensityFloat * 15.0f + 0.5f);

    return intensity4bits;
}

COLORREF ColorFromIntensity(UINT intensity4bits)
{
    UINT BaseR = GetRValue(TEXT_COLOR);
    UINT BaseG = GetGValue(TEXT_COLOR);
    UINT BaseB = GetBValue(TEXT_COLOR);

    UINT r = (UINT)((BaseR * intensity4bits) / 15.0f + 0.5f);
    UINT g = (UINT)((BaseG * intensity4bits) / 15.0f + 0.5f);
    UINT b = (UINT)((BaseB * intensity4bits) / 15.0f + 0.5f);

    return RGB(r, g, b);
}

void EncodeRun(IMAGE_RUN *pRun, COLORREF cr, UINT Size)
{
    if (Size <= 0x7) {
        pRun->fOne = 1;
        pRun->fTwo = 0;
    } else if (Size <= 0x3FF) {
        pRun->fOne = 0;
        pRun->fTwo = 1;
    } else {
        pRun->fOne = 0;
        pRun->fTwo = 0;
    }

    pRun->Size = Size;

    if (cr == BKG_COLOR) {
        pRun->Intensity = 0;
    } else {
        pRun->Intensity = IntensityFromColor(cr);
    }
}

int Encode(LPSTR psz)
{
    BITMAP bm;
    DWORD i, j, total, c1, c2, c3, cRuns, CurrentRun, LongestRun, cOut;
    COLORREF cr, crPrev;
    HDC hdc, hdcScreen;
    HBITMAP hbm, hbmOld;
    IMAGE_RUN *pRun;
    RUN1 Run1;
    RUN2 Run2;
    RUN3 Run3;

    hbm = (HBITMAP)LoadImage(NULL,
            psz,
            IMAGE_BITMAP,
            0,
            0,
            LR_LOADFROMFILE | LR_CREATEDIBSECTION);

    if (hbm == NULL) {
        return 0;
    }

    GetObject(hbm, sizeof(BITMAP), &bm);

    g_cWidth = bm.bmWidth;
    g_cHeight = bm.bmHeight;

    hdcScreen = GetDC(NULL);
    hdc = CreateCompatibleDC(hdcScreen);
    hbmOld = (HBITMAP)SelectObject(hdc, hbm);

    // First pass - firgure out the number of runs.

    cRuns = 0;
    LongestRun = 0;
    CurrentRun = 0;

    for (i = 0; i < (DWORD)bm.bmHeight; i++) {
        for (j = 0; j < (DWORD)bm.bmWidth; j++) {

            cr = GetPixel(hdc, j, i);

            if (i == 0 && j == 0) {
                crPrev = cr;
            }

            if (cr == crPrev) {
                CurrentRun++;
            } else {

                if (CurrentRun > LongestRun) {
                    LongestRun = CurrentRun;
                }

                CurrentRun = 1;
                cRuns++;
                crPrev = cr;
            }
        }
    }

    // Count the last run.

    cRuns++;
    if (CurrentRun > LongestRun) {
        LongestRun = CurrentRun;
    }

    // Make sure we don't overflow.

    if (LongestRun > 0x7FFFF) {
        __asm int 3;
    }

    // Allocate the memory for all of the runs we counted.

    g_pImage = (IMAGE_RUN*)LocalAlloc(LMEM_FIXED, sizeof(IMAGE_RUN) * cRuns);

    // Second pass - actually encode the data.

    cRuns = 0;
    CurrentRun = 0;

    for (i = 0; i < (DWORD)bm.bmHeight; i++) {
        for (j = 0; j < (DWORD)bm.bmWidth; j++) {

            cr = GetPixel(hdc, j, i);

            if (i == 0 && j == 0) {
                crPrev = cr;
            }

            if (cr == crPrev) {
                CurrentRun++;
            } else {

                EncodeRun(&g_pImage[cRuns], crPrev, CurrentRun);

                CurrentRun = 1;
                cRuns++;
                crPrev = cr;
            }
        }
    }

    EncodeRun(&g_pImage[cRuns], crPrev, CurrentRun);
    cRuns++;

    ReleaseDC(NULL, hdcScreen);
    SelectObject(hdc, hbmOld);
    DeleteObject(hdc);

    cOut = 0;
    FILE *fp = fopen("image.h", "w");
    for (i = 0; i < cRuns; i++) {
        pRun = &g_pImage[i];

        if (pRun->fOne) {
            Run1.run.fOne = pRun->fOne;
            Run1.run.Size = pRun->Size;
            Run1.run.Intensity = pRun->Intensity;

            fprintf(fp, "0x%02X, ", Run1.bytes.b1);
            cOut++;
        } else if (pRun->fTwo) {
            Run2.run.fOne = pRun->fOne;
            Run2.run.fTwo = pRun->fTwo;
            Run2.run.Size = pRun->Size;
            Run2.run.Intensity = pRun->Intensity;

            fprintf(fp, "0x%02X, ", Run2.bytes.b1);
            cOut++;

            if ((cOut % 12) == 0) {
                fprintf(fp, "\n");
            }

            fprintf(fp, "0x%02X, ", Run2.bytes.b2);
            cOut++;
        } else {
            Run3.run.fOne = pRun->fOne;
            Run3.run.fTwo = pRun->fTwo;
            Run3.run.Size = pRun->Size;
            Run3.run.Intensity = pRun->Intensity;

            fprintf(fp, "0x%02X, ", Run3.bytes.b1);
            cOut++;

            if ((cOut % 12) == 0) {
                fprintf(fp, "\n");
            }

            fprintf(fp, "0x%02X, ", Run3.bytes.b2);
            cOut++;

            if ((cOut % 12) == 0) {
                fprintf(fp, "\n");
            }

            fprintf(fp, "0x%02X, ", Run3.bytes.b3);
            cOut++;
        }
        if ((cOut % 12) == 0) {
            fprintf(fp, "\n");
        }
    }
    fclose(fp);

    printf("\nBitmap size is %d x %d\n", g_cWidth, g_cHeight);
    printf("Compressed data written to 'image.h'\n\n");

    // Check the image integrity.

    total = 0;
    c1 = 0;
    c2 = 0;
    c3 = 0;

    for (i = 0; i < cRuns; i++) {
        pRun = &g_pImage[i];

        if (pRun->fOne) {
            c1++;
        } else if (pRun->fTwo) {
            c2++;
        } else {
            c3++;
        }

        total += pRun->Size;
    }
    if (total != (DWORD)(bm.bmWidth * bm.bmHeight)) {
        __asm int 3;
    }

    printf("%d bytes, %d runs, %d 1bytes, %d 2bytes, %d 3bytes\n\n", cOut, cRuns, c1, c2, c3);

    return cRuns;
}

HBITMAP Decode(const IMAGE_RUN *pImage, DWORD cRuns)
{
    HDC hdcScreen, hdc;
    HBITMAP hbm, hbmOld;
    DWORD i = 0, j = 0, k, iRun;
    const IMAGE_RUN *pRun;

    hdcScreen = GetDC(NULL);
    hdc = CreateCompatibleDC(hdcScreen);
    hbm = CreateCompatibleBitmap(hdcScreen, g_cWidth, g_cHeight);

    hbmOld = (HBITMAP)SelectObject(hdc, hbm);
    
    for (iRun = 0; iRun < cRuns; iRun++) {

        pRun = &pImage[iRun];

        for (k = 0; k < pRun->Size; k++) {

            if (i >= g_cWidth) {
                i = 0;
                j++;

                if (j >= g_cHeight) {
                    __asm int 3;
                }
            }

            if (pRun->Intensity == 0) {
                SetPixel(hdc, i, j, BKG_COLOR);
            } else {
                SetPixel(hdc, i, j, ColorFromIntensity(pRun->Intensity));
            }

            i++;
        }
    }

    ReleaseDC(NULL, hdcScreen);
    SelectObject(hdc, hbmOld);
    DeleteObject(hdc);

    return hbm;
}

HBITMAP g_hbm;

void PaintBitmap(HDC hdc)
{
    HDC hdcMem = CreateCompatibleDC(hdc);
    SelectObject(hdcMem, g_hbm);
    BitBlt(hdc, 0, 0, g_cWidth, g_cHeight, hdcMem, 0, 0, SRCCOPY);
    DeleteObject(hdcMem);
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg) {
    case WM_ERASEBKGND:
        PaintBitmap((HDC)wParam);
        return 1;

    case WM_CLOSE:
        PostMessage(NULL, WM_QUIT, 0, 0);
        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

int __cdecl main(int argc, char **argv)
{
    if (argc < 2) {
        return 0;
    }

    printf("Encoding...\n");
    int cRuns = Encode(argv[1]);

    printf("Decoding...\n");
    g_hbm = Decode(g_pImage, cRuns);

    printf("Displaying...\n");
    
    RECT rc;
    HWND hwnd;
    WNDCLASS wc;
    MSG msg;
    HINSTANCE hinst = GetModuleHandle(NULL);
    LPSTR psz = argv[1];

    ZeroMemory(&wc, sizeof(wc));
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = psz;
    wc.hbrBackground = (HBRUSH)GetStockObject(GRAY_BRUSH);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);

    RegisterClass(&wc);

    rc.left = rc.top = 0;
    rc.right = g_cWidth;
    rc.bottom = g_cHeight;

    AdjustWindowRect(&rc, WS_POPUP | WS_CAPTION | WS_SYSMENU, FALSE);

    hwnd = CreateWindowEx(0, psz, psz, WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_VISIBLE,
            20, 20, rc.right - rc.left, rc.bottom - rc.top, 0, 0, hinst, 0);

    while (GetMessage(&msg, NULL, 0, 0)) {
        DispatchMessage(&msg);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\ChildFrm.h ===
// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__712C53CD_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
#define AFX_CHILDFRM_H__712C53CD_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CChildFrame : public CMDIChildWnd
{
    DECLARE_DYNCREATE(CChildFrame)
public:
    CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChildFrame)
    public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, const RECT& rect = rectDefault, CMDIFrameWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
    virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CChildFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
    //{{AFX_MSG(CChildFrame)
    afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDFRM_H__712C53CD_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\DXTex.h ===
// dxtex.h : main header file for the DXTEX application
//

#if !defined(AFX_DXTX_H__712C53C7_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
#define AFX_DXTX_H__712C53C7_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

#ifndef ReleasePpo
    #define ReleasePpo(ppo) \
        if (*(ppo) != NULL) \
        { \
            (*(ppo))->Release(); \
            *(ppo) = NULL; \
        } \
        else (VOID)0
#endif

/////////////////////////////////////////////////////////////////////////////
// CDxtexDocManager:
// I override this class to customize DoPromptFileName to allow importing of
// BMPs as well as DDSs into CDxtexDocs.
//
class CDxtexDocManager : public CDocManager
{
public:
    virtual BOOL DoPromptFileName(CString& fileName, UINT nIDSTitle,
            DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate);
};

/////////////////////////////////////////////////////////////////////////////
// CDxtexCommandLineInfo:
// I override this class to handle custom command-line options
//
class CDxtexCommandLineInfo : public CCommandLineInfo
{
public:
    CString m_strFileNameAlpha;
    CString m_strFileNameSave;
    D3DFORMAT m_fmt;
    BOOL m_bAlphaComing;
    BOOL m_bMipMap;

    CDxtexCommandLineInfo::CDxtexCommandLineInfo(VOID);
    virtual void ParseParam(const TCHAR* pszParam, BOOL bFlag, BOOL bLast);

};

/////////////////////////////////////////////////////////////////////////////
// CDxtexApp:
// See dxtex.cpp for the implementation of this class
//

class CDxtexApp : public CWinApp
{
public:
    CDxtexApp();
    virtual ~CDxtexApp();
    LPDIRECT3D8 Pd3d(VOID) { return m_pd3d; }
    LPDIRECT3DDEVICE8 Pd3ddev(VOID) { return m_pd3ddev; }

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDxtexApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation
    //{{AFX_MSG(CDxtexApp)
    afx_msg void OnAppAbout();
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    LPDIRECT3D8 m_pd3d;
    LPDIRECT3DDEVICE8 m_pd3ddev;
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DXTX_H__712C53C7_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\Dialogs.h ===
// Dialogs.h : header file
//
#if !defined(AFX_DIALOGS_H__14A2C924_FB41_4BB7_92E4_DBA7CAF1FA06__INCLUDED_)
#define AFX_DIALOGS_H__14A2C924_FB41_4BB7_92E4_DBA7CAF1FA06__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CNewTextureDlg dialog

class CNewTextureDlg : public CDialog
{
// Construction
public:
    CNewTextureDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CNewTextureDlg)
    enum { IDD = IDD_NEWTEXTURE };
    int     m_iTexType;
    int     m_dwWidth;
    int     m_dwHeight;
    int     m_dwDepth;
    int     m_iFmt;
    int     m_bXbox;
    CString m_strFmtDesc;
    int     m_numMips;
    D3DFORMAT m_fmt;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CNewTextureDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CNewTextureDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeTextureType();
    afx_msg void OnChangeFormat();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CCubeMapDlg dialog

class CCubeMapDlg : public CDialog
{
// Construction
public:
    CCubeMapDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CCubeMapDlg)
    enum { IDD = IDD_CUBEMAP };
    INT     m_iFace;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCubeMapDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CCubeMapDlg)
        // NOTE: the ClassWizard will add member functions here
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CVolumeMapDlg dialog

class CVolumeMapDlg : public CDialog
{
// Construction
public:
    CVolumeMapDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CVolumeMapDlg)
    enum { IDD = IDD_VOLUMEMAP };
    int     m_powLayers;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CVolumeMapDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CVolumeMapDlg)
        // NOTE: the ClassWizard will add member functions here
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CChangeFmtDlg dialog

class CChangeFmtDlg : public CDialog
{
// Construction
public:
    CChangeFmtDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CChangeFmtDlg)
    enum { IDD = IDD_CHANGEFORMAT };
    int     m_iFmt;
    CString m_strFmtDesc;
    int m_bXbox;
    //}}AFX_DATA
    BOOL m_bVolume;
    D3DFORMAT m_fmt;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChangeFmtDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CChangeFmtDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeFmt();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    void UpdateFmtDesc();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DIALOGS_H__14A2C924_FB41_4BB7_92E4_DBA7CAF1FA06__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\DXTex.Cpp ===
// dxtex.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "dxtex.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "dxtexDoc.h"
#include "dxtexView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CDxtexDocManager::DoPromptFileName - overridden to allow importing of
// BMPs as well as DDSs into CDxtexDocs.
BOOL CDxtexDocManager::DoPromptFileName(CString& fileName, UINT nIDSTitle,
            DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate)
{
    CFileDialog dlgFile(bOpenFileDialog);

    CString title;
    VERIFY(title.LoadString(nIDSTitle));

    dlgFile.m_ofn.Flags |= lFlags;

    CString strFilter;
    CString strDefault;

    if (bOpenFileDialog)
    {
        strFilter += "Image Files (*.dds, *.bmp, *.tga)";
        strFilter += (TCHAR)'\0';   // next string please
        strFilter += _T("*.dds;*.bmp;*.tga");
        strFilter += (TCHAR)'\0';   // last string
        dlgFile.m_ofn.nMaxCustFilter++;
    }
    else
    {
        strFilter += "Image Files (*.dds)";
        strFilter += (TCHAR)'\0';   // next string please
        strFilter += _T("*.dds");
        strFilter += (TCHAR)'\0';   // last string
        dlgFile.m_ofn.nMaxCustFilter++;
    }

    // append the "*.*" all files filter
    CString allFilter;
    VERIFY(allFilter.LoadString(AFX_IDS_ALLFILTER));
    strFilter += allFilter;
    strFilter += (TCHAR)'\0';   // next string please
    strFilter += _T("*.*");
    strFilter += (TCHAR)'\0';   // last string
    dlgFile.m_ofn.nMaxCustFilter++;

    dlgFile.m_ofn.lpstrFilter = strFilter;
    dlgFile.m_ofn.lpstrTitle = title;
    dlgFile.m_ofn.lpstrFile = fileName.GetBuffer(_MAX_PATH);

    INT_PTR nResult = dlgFile.DoModal();
    fileName.ReleaseBuffer();
    return nResult == IDOK;
};


/////////////////////////////////////////////////////////////////////////////
// CDxTxCommandLineInfo

CDxtexCommandLineInfo::CDxtexCommandLineInfo(VOID)
{
    m_fmt = D3DFMT_UNKNOWN;
    m_bAlphaComing = FALSE;
    m_bMipMap = FALSE;
}


void CDxtexCommandLineInfo::ParseParam(const TCHAR* pszParam,BOOL bFlag,BOOL bLast)
{
    if (lstrcmpiA(pszParam, "DXT1") == 0)
    {
        m_fmt = D3DFMT_DXT1;
    }
    else if (lstrcmpiA(pszParam, "DXT2") == 0)
    {
        m_fmt = D3DFMT_DXT2;
    }
    else if (lstrcmpiA(pszParam, "DXT3") == 0)
    {
        m_fmt = D3DFMT_DXT3;
    }
    else if (lstrcmpiA(pszParam, "DXT4") == 0)
    {
        m_fmt = D3DFMT_DXT4;
    }
    else if (lstrcmpiA(pszParam, "DXT5") == 0)
    {
        m_fmt = D3DFMT_DXT5;
    }
    else if (bFlag && tolower(pszParam[0]) == 'a')
    {
        m_bAlphaComing = TRUE;
    }
    else if (!bFlag && m_bAlphaComing)
    {
        m_strFileNameAlpha = pszParam;
        m_bAlphaComing = FALSE;
    }
    else if (bFlag && tolower(pszParam[0]) == 'm')
    {
        m_bMipMap = TRUE;
    }
    else if (!bFlag && !m_strFileName.IsEmpty())
    {
        m_strFileNameSave = pszParam;
    }

    CCommandLineInfo::ParseParam(pszParam, bFlag, bLast);
}



/////////////////////////////////////////////////////////////////////////////
// CDxtexApp

BEGIN_MESSAGE_MAP(CDxtexApp, CWinApp)
    //{{AFX_MSG_MAP(CDxtexApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDxtexApp construction

CDxtexApp::CDxtexApp()
{
    // Place all significant initialization in InitInstance
    m_pd3d = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CDxtexApp destruction

CDxtexApp::~CDxtexApp()
{
    ReleasePpo(&m_pd3ddev);
    ReleasePpo(&m_pd3d);
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDxtexApp object

CDxtexApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CDxtexApp initialization

BOOL CDxtexApp::InitInstance()
{
    // Change the registry key under which our settings are stored.
    SetRegistryKey(_T("Microsoft"));

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    m_pDocManager = new CDxtexDocManager;

    CMultiDocTemplate* pDocTemplate;
    pDocTemplate = new CMultiDocTemplate(
        IDR_DXTXTYPE,
        RUNTIME_CLASS(CDxtexDoc),
        RUNTIME_CLASS(CChildFrame), // custom MDI child frame
        RUNTIME_CLASS(CDxtexView));
    AddDocTemplate(pDocTemplate);

    // create main MDI Frame window
    CMainFrame* pMainFrame = new CMainFrame;
    if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
        return FALSE;
    m_pMainWnd = pMainFrame;

    // Initialize DirectDraw
    m_pd3d = Direct3DCreate8(D3D_SDK_VERSION);
    if (m_pd3d == NULL)
    {
        AfxMessageBox(ID_ERROR_D3DCREATEFAILED, MB_OK, 0);
        return FALSE;
    }

    HRESULT hr;
    D3DDISPLAYMODE dispMode;
    D3DPRESENT_PARAMETERS presentParams;
    D3DDEVTYPE devType;

    m_pd3d->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &dispMode);

    ZeroMemory(&presentParams, sizeof(presentParams));
    presentParams.Windowed = TRUE;
    presentParams.SwapEffect = D3DSWAPEFFECT_COPY_VSYNC;
    presentParams.BackBufferWidth = 8;
    presentParams.BackBufferHeight = 8;
    presentParams.BackBufferFormat = dispMode.Format;

    devType = D3DDEVTYPE_REF;

    hr = m_pd3d->CreateDevice(D3DADAPTER_DEFAULT, devType, m_pMainWnd->GetSafeHwnd(),
        D3DCREATE_SOFTWARE_VERTEXPROCESSING, &presentParams, &m_pd3ddev);
    if (FAILED(hr))
    {
        AfxMessageBox(ID_ERROR_CANTCREATEDEVICE);
        return FALSE;
    }

    // Parse command line for standard shell commands, DDE, file open
    CDxtexCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);
    // Prevent automatic "New" at startup:
    if (cmdInfo.m_nShellCommand == CCommandLineInfo::FileNew)
        cmdInfo.m_nShellCommand = CCommandLineInfo::FileNothing;

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    // See if we loaded a document
    POSITION posTemp = GetFirstDocTemplatePosition();
    CDxtexDoc* pdoc = NULL;
    POSITION pos = pDocTemplate->GetFirstDocPosition();
    if (pos != NULL)
        pdoc = (CDxtexDoc*)pDocTemplate->GetNextDoc(pos);

    if (!cmdInfo.m_strFileNameAlpha.IsEmpty())
    {
        if (pdoc != NULL)
        {
            pdoc->LoadAlphaBmp(cmdInfo.m_strFileNameAlpha);
        }
    }
    if (cmdInfo.m_bMipMap)
    {
        if (pdoc != NULL)
        {
            pdoc->GenerateMipMaps();
        }
    }
    if (cmdInfo.m_fmt != 0)
    {
        if (pdoc != NULL)
        {
            pdoc->Compress(cmdInfo.m_fmt, TRUE);
        }
    }
    if (!cmdInfo.m_strFileNameSave.IsEmpty())
    {
        if (pdoc != NULL)
        {
            pdoc->OnSaveDocument(cmdInfo.m_strFileNameSave);
        }
        return FALSE; // Prevent UI from coming up
    }

    // The main window has been initialized, so show and update it.
    pMainFrame->ShowWindow(m_nCmdShow);
    pMainFrame->UpdateWindow();

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    CString m_strVersion;
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    TCHAR szFile[MAX_PATH];
    CString strVersion;
    UINT cb;
    DWORD dwHandle;
    BYTE FileVersionBuffer[1024];
    VS_FIXEDFILEINFO* pVersion = NULL;

    GetModuleFileName(NULL, szFile, MAX_PATH);

    cb = GetFileVersionInfoSize(szFile, &dwHandle/*ignored*/);
    if (cb > 0)
    {
        if (cb > sizeof(FileVersionBuffer))
            cb = sizeof(FileVersionBuffer);

        if (GetFileVersionInfo(szFile, 0, cb, &FileVersionBuffer))
        {
            pVersion = NULL;
            if (VerQueryValue(&FileVersionBuffer, "\\", (VOID**)&pVersion, &cb)
                && pVersion != NULL)
            {
                strVersion.Format("Version %d.%02d.%02d.%04d",
                    HIWORD(pVersion->dwFileVersionMS),
                    LOWORD(pVersion->dwFileVersionMS),
                    HIWORD(pVersion->dwFileVersionLS),
                    LOWORD(pVersion->dwFileVersionLS));
            }
        }
    }

    //{{AFX_DATA_INIT(CAboutDlg)
    m_strVersion = strVersion;
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    DDX_Text(pDX, IDC_VERSION, m_strVersion);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CDxtexApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dxtex.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_DXTXTYPE                    129
#define IDD_CUBEMAP                     131
#define IDD_VOLUMEMAP                   132
#define IDD_CHANGEFORMAT                133
#define IDD_NEWTEXTURE                  134
#define IDC_VERSION                     1000
#define IDC_POSX                        1001
#define IDC_NEGX                        1002
#define IDC_POSY                        1003
#define IDC_NEGY                        1004
#define IDC_POSZ                        1005
#define IDC_NEGZ                        1006
#define IDC_RADIO2                      1010
#define IDC_DXT1                        1010
#define IDC_RADIO4                      1011
#define IDC_DXT2                        1011
#define IDC_RADIO8                      1012
#define IDC_DXT3                        1012
#define IDC_RADIO16                     1013
#define IDC_DXT4                        1013
#define IDC_RADIO32                     1014
#define IDC_DXT5                        1014
#define IDC_RADIO64                     1015
#define IDC_A8R8G8B8                    1015
#define IDC_RADIO128                    1016
#define IDC_A1R5G5B5                    1016
#define IDC_RADIO256                    1017
#define IDC_RADIO512                    1018
#define IDC_RADIO1024                   1019
#define IDC_A4R4G4B4                    1022
#define IDC_R8G8B8                      1023
#define IDC_R5G6B5                      1024
#define IDC_FMTDESC                     1025
#define IDC_TEXTURE                     1026
#define IDC_CUBEMAP                     1027
#define IDC_VOLUMETEXTURE               1028
#define IDC_WIDTH                       1029
#define IDC_HEIGHT                      1030
#define IDC_DEPTH                       1031
#define IDC_MIPCOUNT                    1032
#define IDC_VOLUMEDEPTHLABEL            1033
#define IDC_Xbox                        1039
#define ID_FORMAT_GENERATEMIPMAPS       32774
#define ID_FORMAT_CHANGEIMAGEFORMAT     32775
#define ID_FORMAT_DXT1                  32779
#define ID_VIEW_ORIGINAL                32780
#define ID_VIEW_COMPRESSED              32781
#define ID_VIEW_SMALLERMIPLEVEL         32782
#define ID_VIEW_LARGERMIPLEVEL          32783
#define ID_VIEW_ALPHACHANNEL            32784
#define ID_VIEW_ZOOMIN                  32785
#define ID_VIEW_ZOOMOUT                 32786
#define ID_FORMAT_DXT2                  32787
#define ID_FORMAT_DXT3                  32788
#define ID_FORMAT_DXT4                  32789
#define ID_FORMAT_DXT5                  32790
#define ID_VIEW_CHANGEBACKGROUNDCOLOR   32791
#define ID_FILE_OPENALPHA               32792
#define ID_FILE_OPENSUBSURFACE          32794
#define ID_FILE_OPENALPHASUBSURFACE     32795
#define ID_FORMAT_CHANGECUBEMAPFACES    32796
#define ID_VIEW_POSX                    32797
#define ID_VIEW_NEGX                    32798
#define ID_VIEW_POSY                    32799
#define ID_VIEW_NEGY                    32800
#define ID_VIEW_POSZ                    32801
#define ID_VIEW_NEGZ                    32802
#define ID_FILE_OPENFACE                32803
#define ID_FILE_OPENALPHAFACE           32804
#define ID_FORMAT_MAKEINTOVOLUMEMAP     32806
#define ID_VIEW_HIGHERVOLUMESLICE       32807
#define ID_VIEW_LOWERVOLUMESLICE        32808
#define ID_FORMAT_CHANGESURFACEFMT      32811
#define ID_INDICATOR_IMAGEINFO          61216
#define ID_ERROR_ODDDIMENSIONS          61217
#define ID_ERROR_NOTPOW2                61218
#define ID_ERROR_WRONGDIMENSIONS        61219
#define ID_ERROR_GENERATEALPHAFAILED    61220
#define ID_ERROR_PREMULTALPHA           61221
#define ID_ERROR_PREMULTTODXT1          61222
#define ID_ERROR_CANTCREATEDEVICE       61223
#define IDS_FMTDESC_A8R8G8B8            61224
#define IDS_FMTDESC_A1R5G5B5            61225
#define IDS_FMTDESC_A4R4G4B4            61226
#define IDS_FMTDESC_R8G8B8              61227
#define IDS_FMTDESC_R5G6B5              61228
#define IDS_FMTDESC_DXT1                61229
#define IDS_FMTDESC_DXT2                61230
#define IDS_FMTDESC_DXT3                61231
#define IDS_FMTDESC_DXT4                61232
#define IDS_FMTDESC_DXT5                61233
#define ID_ERROR_CANTCREATETEXTURE      61239
#define ID_ERROR_D3DCREATEFAILED        61240

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         32812
#define _APS_NEXT_CONTROL_VALUE         1044
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\DXTexdoc.Cpp ===
// dxtexDoc.cpp : implementation of the CDxtexDoc class
//

#include "stdafx.h"
#include "dxtex.h"
#include "dxtexDoc.h"
#include "dialogs.h"
#include "dds.h"
#include "xgraphics.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

HRESULT WINAPI
    XDXTEXLoadSurfaceFromSurface(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPDIRECT3DSURFACE8    pSrcSurface,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey,
        LPDIRECT3DDEVICE8     pd3ddev,
        BOOL                  UseXGR)
{
    // Check the Dest Surface to see if a DXTn format is requested
    D3DSURFACE_DESC sd, ss;
    pDestSurface->GetDesc(&sd);
    if(UseXGR &&
       ((sd.Format == D3DFMT_DXT1) ||
        (sd.Format == D3DFMT_DXT2) ||
        (sd.Format == D3DFMT_DXT3) ||
        (sd.Format == D3DFMT_DXT4) ||
        (sd.Format == D3DFMT_DXT5)))
    {
        OutputDebugString("************XGraphics did compression\n");
        pSrcSurface->GetDesc(&ss);
        BOOL bNoTmpTexture;
        if((ss.Width == sd.Width) &&
           (ss.Height == sd.Height) &&
           (ss.Format == D3DFMT_A8R8G8B8))
            bNoTmpTexture = TRUE;
        else
            bNoTmpTexture = FALSE;

        // Create an intermediate texture if necessary
        HRESULT hr;
        LPDIRECT3DTEXTURE8 pTmpTex;
        LPDIRECT3DSURFACE8 pTmpSurf;
        if(!bNoTmpTexture)
        {
            hr = pd3ddev->CreateTexture(sd.Width, sd.Height, 1,
                0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &pTmpTex);
            if (FAILED(hr))
            {
                AfxMessageBox(ID_ERROR_CANTCREATETEXTURE);
                return E_FAIL;
            }
            hr = pTmpTex->GetSurfaceLevel(0, &pTmpSurf);
            // put converted bits into temporary surface
            D3DXLoadSurfaceFromSurface(pTmpSurf,
                                       NULL,
                                       pDestRect,
                                       pSrcSurface,
                                       pSrcPalette,
                                       pSrcRect,
                                       Filter,
                                       ColorKey);
        }
        // now use XGraphics to convert to dest format
        D3DLOCKED_RECT sr, dr;
        if(bNoTmpTexture)
            pSrcSurface->LockRect(&sr, NULL, 0);
        else
            pTmpSurf->LockRect(&sr, NULL, 0);

        pDestSurface->LockRect(&dr, NULL, 0);
        BOOL bPreMultiply;
        DWORD xFormat;
        switch(sd.Format)
        {
        case D3DFMT_DXT1:
            xFormat = 0x0000000C;
            bPreMultiply = FALSE;
            break;
        case D3DFMT_DXT2:
            xFormat = 0x0000000E;
            bPreMultiply = TRUE;
            break;
        case D3DFMT_DXT3:
            xFormat = 0x0000000E;
            bPreMultiply = FALSE;
            break;
        case D3DFMT_DXT4:
            xFormat = 0x0000000F;
            bPreMultiply = TRUE;
            break;
        case D3DFMT_DXT5:
            xFormat = 0x0000000F;
            bPreMultiply = FALSE;
            break;
        }

        // Finally!  Do the compression.
        XGCompressRect( dr.pBits,
                        (D3DFORMAT)xFormat,
                        0,
                        sd.Width,
                        sd.Height,
                        sr.pBits,
                        (D3DFORMAT)0x00000012, // xbox D3DFMT_LIN_A8R8G8B8
                        sr.Pitch,
                        0.5f,
                        bPreMultiply ? XGCOMPRESS_PREMULTIPLY : 0);
        
        if(bNoTmpTexture)
        {
            pSrcSurface->UnlockRect();
            OutputDebugString("************No Temp Surface\n");
        }
        else
        {
            pTmpSurf->UnlockRect();
            pTmpSurf->Release();
            pTmpTex->Release();
            OutputDebugString("************CREATED Temp Surface\n");
        }

        pDestSurface->UnlockRect();
        return S_OK;
    }
    else
    {
        OutputDebugString("D3DX did conversion\n");
        return D3DXLoadSurfaceFromSurface(pDestSurface,
                                          pDestPalette,
                                          pDestRect,
                                          pSrcSurface,
                                          pSrcPalette,
                                          pSrcRect,
                                          Filter,
                                          ColorKey);
    }
}


/////////////////////////////////////////////////////////////////////////////
// CDxtexDoc

IMPLEMENT_DYNCREATE(CDxtexDoc, CDocument)

BEGIN_MESSAGE_MAP(CDxtexDoc, CDocument)
    //{{AFX_MSG_MAP(CDxtexDoc)
    ON_COMMAND(ID_FILE_OPENALPHA, OnFileOpenAlpha)
    ON_COMMAND(ID_FORMAT_GENERATEMIPMAPS, OnGenerateMipMaps)
    ON_COMMAND(ID_FORMAT_CHANGESURFACEFMT, OnFormatChangeSurfaceFmt)
    ON_COMMAND(ID_FORMAT_CHANGECUBEMAPFACES, OnFormatChangeCubeMapFaces)
    ON_COMMAND(ID_FORMAT_MAKEINTOVOLUMEMAP, OnFormatMakeIntoVolumeMap)
    ON_UPDATE_COMMAND_UI(ID_FILE_OPENALPHA, OnUpdateFileOpenAlpha)
    ON_UPDATE_COMMAND_UI(ID_FORMAT_GENERATEMIPMAPS, OnUpdateFormatGenerateMipmaps)
    ON_UPDATE_COMMAND_UI(ID_FORMAT_CHANGECUBEMAPFACES, OnUpdateFormatChangeCubeMapFaces)
    ON_UPDATE_COMMAND_UI(ID_FORMAT_MAKEINTOVOLUMEMAP, OnUpdateFormatMakeIntoVolumeMap)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDxtexDoc diagnostics

#ifdef _DEBUG
void CDxtexDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CDxtexDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDxtexDoc construction/destruction

CDxtexDoc::CDxtexDoc()
{
    m_ptexOrig = NULL;
    m_ptexNew = NULL;
    m_dwWidth = 0;
    m_dwHeight = 0;
    m_dwDepth = 0;
    m_numMips = 0;
    m_dwCubeMapFlags = 0;
    m_bTitleModsChanged = FALSE;
    m_bXbox = TRUE;
}


CDxtexDoc::~CDxtexDoc()
{
    ReleasePpo(&m_ptexOrig);
    ReleasePpo(&m_ptexNew);
}


BOOL CDxtexDoc::OnNewDocument()
{
    HRESULT hr;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();

    if (!CDocument::OnNewDocument())
        return FALSE;

    CNewTextureDlg dlg;

    if (IDCANCEL == dlg.DoModal())
        return FALSE;

    m_dwWidth = dlg.m_dwWidth;
    m_dwHeight = dlg.m_dwHeight;
    m_numMips = dlg.m_numMips;
    m_bXbox = dlg.m_bXbox;

    if (dlg.m_iTexType == 0)
    {
        LPDIRECT3DTEXTURE8 pmiptex;
        hr = pd3ddev->CreateTexture(m_dwWidth, m_dwHeight, m_numMips,
            0, dlg.m_fmt, D3DPOOL_MANAGED, &pmiptex);
        if (FAILED(hr))
        {
            AfxMessageBox(ID_ERROR_CANTCREATETEXTURE);
            return FALSE;
        }
        m_ptexOrig = pmiptex;

    }
    else if (dlg.m_iTexType == 1)
    {
        // Cube Map
        LPDIRECT3DCUBETEXTURE8 pcubetex;
        m_dwCubeMapFlags = DDS_CUBEMAP_ALLFACES;
        hr = pd3ddev->CreateCubeTexture(m_dwWidth, m_numMips,
            0, dlg.m_fmt, D3DPOOL_MANAGED, &pcubetex);
        if (FAILED(hr))
        {
            AfxMessageBox(ID_ERROR_CANTCREATETEXTURE);
            return FALSE;
        }
        m_ptexOrig = pcubetex;
    }
    else
    {
        LPDIRECT3DVOLUMETEXTURE8 pvoltex;
        m_dwDepth = dlg.m_dwDepth;
        hr = pd3ddev->CreateVolumeTexture(m_dwWidth, m_dwHeight, m_dwDepth, m_numMips,
            0, dlg.m_fmt, D3DPOOL_SYSTEMMEM, &pvoltex);
        if (FAILED(hr))
        {
            AfxMessageBox(ID_ERROR_CANTCREATETEXTURE);
            return FALSE;
        }
        m_ptexOrig = pvoltex;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CDxtexDoc serialization

void CDxtexDoc::Serialize(CArchive& ar)
{
    HRESULT     hr;

    if (ar.IsStoring())
    {
        LPDIRECT3DBASETEXTURE8 ptex;
        ptex = (m_ptexNew == NULL ? m_ptexOrig : m_ptexNew);
        SaveDDS( ptex, ar );
    }
    else
    {
        CFile     * pFile = ar.GetFile();
        CString     str = pFile->GetFilePath();
        TCHAR     * pszExt = strrchr(str, '.');

        if( lstrcmpi( pszExt, ".bmp" ) == 0 || lstrcmpi( pszExt, ".tga" ) == 0 )
        {
            if (FAILED(hr = LoadBmp(str)))
                AfxThrowArchiveException(CArchiveException::generic);
        }
        else if( lstrcmpi( pszExt, ".dds" ) == 0 )
        {
            ReleasePpo(&m_ptexOrig);
            ReleasePpo(&m_ptexNew);
            if (FAILED(hr = LoadDDS(&m_ptexOrig, ar)))
                AfxThrowArchiveException(CArchiveException::badIndex); // invalid file format
        }
        else
        {
            AfxThrowArchiveException(CArchiveException::badIndex); // invalid file format
        }
    }
}

HRESULT CDxtexDoc::SaveDDS(LPDIRECT3DBASETEXTURE8 ptex, CArchive& ar)
{
    HRESULT hr;
    DDS_HEADER ddsh;
    DWORD dwMagic;
    D3DFORMAT fmt;
    DWORD dwSize;
    DWORD dwPitch = 0;
    D3DLOCKED_RECT lr;
    D3DLOCKED_BOX lb;
    LPDIRECT3DTEXTURE8 pmiptex = NULL;
    LPDIRECT3DCUBETEXTURE8 pcubetex = NULL;
    LPDIRECT3DVOLUMETEXTURE8 pvoltex = NULL;

    if (IsVolumeMap())
        pvoltex = (LPDIRECT3DVOLUMETEXTURE8)ptex;
    else if (!IsCubeMap())
        pmiptex = (LPDIRECT3DTEXTURE8)ptex;
    else
        pcubetex = (LPDIRECT3DCUBETEXTURE8)ptex;

    dwMagic = MAKEFOURCC('D','D','S',' ');
    ar.Write(&dwMagic, sizeof(dwMagic));

    // Fill in the DDS header structure
    ZeroMemory(&ddsh, sizeof(ddsh));
    ddsh.dwSize = sizeof(ddsh);
    ddsh.dwHeaderFlags = DDS_HEADER_FLAGS_TEXTURE;
    ddsh.dwWidth = m_dwWidth;
    ddsh.dwHeight = m_dwHeight;
    ddsh.dwSurfaceFlags = DDS_SURFACE_FLAGS_TEXTURE;
    if (m_numMips > 1)
    {
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_MIPMAP;
        ddsh.dwSurfaceFlags |= DDS_SURFACE_FLAGS_MIPMAP;
        ddsh.dwMipMapCount = m_numMips;
    }
    if (pvoltex != NULL)
    {
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_VOLUME;
        // Note: "dwCubemapFlags" is mostly for cubemap flags,
        // but in this case is also used to indicate a volume texture
        ddsh.dwCubemapFlags |= DDS_FLAGS_VOLUME;
        ddsh.dwDepth = m_dwDepth;
    }

    // In DX7, you could (optionally) use and save a subset of
    // cubemap faces.  In DX8, you must use and save all faces of a cubemap.
    if (IsCubeMap())
    {
        ddsh.dwSurfaceFlags |= DDS_SURFACE_FLAGS_CUBEMAP;
        ddsh.dwCubemapFlags = DDS_CUBEMAP_ALLFACES;
    }

    // Determine dwPitch and dwSize for the texture
    if (pvoltex != NULL)
    {
        D3DVOLUME_DESC vd;
        pvoltex->GetLevelDesc(0, &vd);
        fmt = vd.Format;
        dwSize = vd.Size;
        if (SUCCEEDED(pvoltex->LockBox(0, &lb, NULL, D3DLOCK_READONLY)))
        {
            dwPitch = lb.RowPitch;
            pvoltex->UnlockBox(0);
        }
    }
    else if (pmiptex != NULL)
    {
        D3DSURFACE_DESC sd;
        pmiptex->GetLevelDesc(0, &sd);
        fmt = sd.Format;
        dwSize = sd.Size;
        if (SUCCEEDED(pmiptex->LockRect(0, &lr, NULL, D3DLOCK_READONLY)))
        {
            dwPitch = lr.Pitch;
            pmiptex->UnlockRect(0);
        }
    }
    else
    {
        D3DSURFACE_DESC sd;
        pcubetex->GetLevelDesc(0, &sd);
        fmt = sd.Format;
        dwSize = sd.Size;
        if (SUCCEEDED(pcubetex->LockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0,
            &lr, NULL, D3DLOCK_READONLY)))
        {
            dwPitch = lr.Pitch;
            pcubetex->UnlockRect(D3DCUBEMAP_FACE_POSITIVE_X, 0);
        }
    }

    // Note that although this code stores the pitch or linear size
    // of the surface in the DDS file (for consistency with DX7), it
    // is better to use the pitch or linear size of the surface
    // created when loading the DDS file into a texture than to use
    // the file values.  The pitch of a created surface, especially,
    // can be different from the pitch stored in the DDS file.
    switch (fmt)
    {
    case D3DFMT_DXT1:
        ddsh.ddspf = DDSPF_DXT1;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_LINEARSIZE;
        ddsh.dwPitchOrLinearSize = dwSize;
        break;
    case D3DFMT_DXT2:
        ddsh.ddspf = DDSPF_DXT2;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_LINEARSIZE;
        ddsh.dwPitchOrLinearSize = dwSize;
        break;
    case D3DFMT_DXT3:
        ddsh.ddspf = DDSPF_DXT3;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_LINEARSIZE;
        ddsh.dwPitchOrLinearSize = dwSize;
        break;
    case D3DFMT_DXT4:
        ddsh.ddspf = DDSPF_DXT4;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_LINEARSIZE;
        ddsh.dwPitchOrLinearSize = dwSize;
        break;
    case D3DFMT_DXT5:
        ddsh.ddspf = DDSPF_DXT5;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_LINEARSIZE;
        ddsh.dwPitchOrLinearSize = dwSize;
        break;
    case D3DFMT_A8R8G8B8:
        ddsh.ddspf = DDSPF_A8R8G8B8;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_PITCH;
        ddsh.dwPitchOrLinearSize = dwPitch;
        break;
    case D3DFMT_A1R5G5B5:
        ddsh.ddspf = DDSPF_A1R5G5B5;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_PITCH;
        ddsh.dwPitchOrLinearSize = dwPitch;
        break;
    case D3DFMT_A4R4G4B4:
        ddsh.ddspf = DDSPF_A4R4G4B4;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_PITCH;
        ddsh.dwPitchOrLinearSize = dwPitch;
        break;
    case D3DFMT_R8G8B8:
        ddsh.ddspf = DDSPF_R8G8B8;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_PITCH;
        ddsh.dwPitchOrLinearSize = dwPitch;
        break;
    case D3DFMT_R5G6B5:
        ddsh.ddspf = DDSPF_R5G6B5;
        ddsh.dwHeaderFlags |= DDS_HEADER_FLAGS_PITCH;
        ddsh.dwPitchOrLinearSize = dwPitch;
        break;
    default:
        return E_FAIL;
    }

    ar.Write(&ddsh, sizeof(ddsh));

    if (pvoltex != NULL)
    {
        if (FAILED(hr = SaveAllVolumeSurfaces(pvoltex, ar)))
            return hr;
    }
    else if (pmiptex != NULL)
    {
        if (FAILED(hr = SaveAllMipSurfaces(ptex, D3DCUBEMAP_FACE_FORCE_DWORD, ar)))
            return hr;
    }
    else
    {
        if (FAILED(hr = SaveAllMipSurfaces(ptex, D3DCUBEMAP_FACE_POSITIVE_X, ar)))
            return hr;
        if (FAILED(hr = SaveAllMipSurfaces(ptex, D3DCUBEMAP_FACE_NEGATIVE_X, ar)))
            return hr;
        if (FAILED(hr = SaveAllMipSurfaces(ptex, D3DCUBEMAP_FACE_POSITIVE_Y, ar)))
            return hr;
        if (FAILED(hr = SaveAllMipSurfaces(ptex, D3DCUBEMAP_FACE_NEGATIVE_Y, ar)))
            return hr;
        if (FAILED(hr = SaveAllMipSurfaces(ptex, D3DCUBEMAP_FACE_POSITIVE_Z, ar)))
            return hr;
        if (FAILED(hr = SaveAllMipSurfaces(ptex, D3DCUBEMAP_FACE_NEGATIVE_Z, ar)))
            return hr;
    }

    return S_OK;
}


HRESULT CDxtexDoc::SaveAllMipSurfaces(LPDIRECT3DBASETEXTURE8 ptex, D3DCUBEMAP_FACES FaceType, CArchive& ar)
{
    HRESULT hr;
    LPDIRECT3DSURFACE8 psurf;
    D3DSURFACE_DESC sd;
    UINT iLevel;
    D3DLOCKED_RECT lr;
    LPDIRECT3DTEXTURE8 pmiptex = NULL;
    LPDIRECT3DCUBETEXTURE8 pcubetex = NULL;

    if (FaceType == D3DCUBEMAP_FACE_FORCE_DWORD)
        pmiptex = (LPDIRECT3DTEXTURE8)ptex;
    else
        pcubetex = (LPDIRECT3DCUBETEXTURE8)ptex;

    for (iLevel = 0; iLevel < m_numMips; iLevel++)
    {
        if (pmiptex != NULL)
            hr = pmiptex->GetSurfaceLevel(iLevel, &psurf);
        else
            hr = pcubetex->GetCubeMapSurface(FaceType, iLevel, &psurf);
        if (FAILED(hr))
            return hr;
        psurf->GetDesc(&sd);
        if (pmiptex != NULL)
            hr = pmiptex->LockRect(iLevel, &lr, NULL, 0);
        else
            hr = pcubetex->LockRect(FaceType, iLevel, &lr, NULL, 0);
        if (FAILED(hr))
            return hr;
        if (sd.Format == D3DFMT_DXT1 ||
            sd.Format == D3DFMT_DXT2 ||
            sd.Format == D3DFMT_DXT3 ||
            sd.Format == D3DFMT_DXT4 ||
            sd.Format == D3DFMT_DXT5)
        {
            ar.Write(lr.pBits, sd.Size);
        }
        else
        {
            DWORD yp;
            BYTE* pbDest = (BYTE*)lr.pBits;
            LONG dataBytesPerRow = 0;
            if (sd.Format == D3DFMT_A8R8G8B8)
                dataBytesPerRow = 4 * sd.Width;
            else if (sd.Format == D3DFMT_R8G8B8)
                dataBytesPerRow = 3 * sd.Width;
            else
                dataBytesPerRow = 2 * sd.Width;
            for (yp = 0; yp < sd.Height; yp++)
            {
                ar.Write(pbDest, dataBytesPerRow);
                pbDest += lr.Pitch;
            }
        }
        if (pmiptex != NULL)
            hr = pmiptex->UnlockRect(iLevel);
        else
            hr = pcubetex->UnlockRect(FaceType, iLevel);
    }

    return S_OK;
}


HRESULT CDxtexDoc::SaveAllVolumeSurfaces(LPDIRECT3DVOLUMETEXTURE8 pvoltex, CArchive& ar)
{
    HRESULT hr;
    D3DVOLUME_DESC vd;
    D3DBOX box;
    D3DLOCKED_BOX lb;
    UINT iLevel;
    UINT numBytesPerRow;
    BYTE* pbSlice;
    BYTE* pbRow;
    UINT zp;
    UINT yp;

    for (iLevel = 0; iLevel < m_numMips; iLevel++)
    {
        pvoltex->GetLevelDesc(iLevel, &vd);
        box.Left = 0;
        box.Right = vd.Width;
        box.Top = 0;
        box.Bottom = vd.Height;
        box.Front = 0;
        box.Back = vd.Depth;
        hr = pvoltex->LockBox(iLevel, &lb, &box, 0);
        if (FAILED(hr))
            return hr;
        switch(vd.Format)
        {
        case D3DFMT_A8R8G8B8:
            numBytesPerRow = 4 * vd.Width;
            break;
        case D3DFMT_R8G8B8:
            numBytesPerRow = 3 * vd.Width;
            break;
        case D3DFMT_A1R5G5B5:
        case D3DFMT_A4R4G4B4:
        case D3DFMT_R5G6B5:
            numBytesPerRow = 2 * vd.Width;
            break;
        default:
            return E_FAIL;
        }
        pbSlice = (BYTE*)lb.pBits;
        for (zp = 0; zp < vd.Depth; zp++)
        {
            pbRow = pbSlice;
            for (yp = 0; yp < vd.Height; yp++)
            {
                ar.Write(pbRow, numBytesPerRow);
                pbRow += lb.RowPitch;
            }
            pbSlice += lb.SlicePitch;
        }

        pvoltex->UnlockBox(iLevel);
    }

    return S_OK;
}


HRESULT CDxtexDoc::LoadDDS(LPDIRECT3DBASETEXTURE8* pptex, CArchive& ar)
{

    HRESULT hr;
    DWORD dwMagic;
    DDS_HEADER ddsh;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    LPDIRECT3DTEXTURE8 pmiptex = NULL;
    LPDIRECT3DCUBETEXTURE8 pcubetex = NULL;
    LPDIRECT3DVOLUMETEXTURE8 pvoltex = NULL;

    *pptex = NULL;

    ar.Read(&dwMagic, sizeof(dwMagic));
    if (dwMagic != MAKEFOURCC('D','D','S',' '))
        return E_FAIL;
    ar.Read(&ddsh, sizeof(ddsh));
    if (ddsh.dwSize != sizeof(ddsh))
        return E_FAIL;
    m_dwWidth = ddsh.dwWidth;
    m_dwHeight = ddsh.dwHeight;
    m_numMips = ddsh.dwMipMapCount;
    if (m_numMips == 0)
        m_numMips = 1;
    m_dwCubeMapFlags = (ddsh.dwCubemapFlags & DDS_CUBEMAP_ALLFACES);
    if (ddsh.dwHeaderFlags & DDS_HEADER_FLAGS_VOLUME)
        m_dwDepth = ddsh.dwDepth;
    else
        m_dwDepth = 0;

    D3DFORMAT fmt;
    if (!IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT1)
        fmt = D3DFMT_DXT1;
    else if (!IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT2)
        fmt = D3DFMT_DXT2;
    else if (!IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT3)
        fmt = D3DFMT_DXT3;
    else if (!IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT4)
        fmt = D3DFMT_DXT4;
    else if (!IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT5)
        fmt = D3DFMT_DXT5;
    else if( !IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT1_X)
        fmt = D3DFMT_DXT1;
    else if( !IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT2_X)
        fmt = D3DFMT_DXT2;
    else if( !IsVolumeMap() && ddsh.ddspf.dwFourCC == D3DFMT_DXT4_X)
        fmt = D3DFMT_DXT4;
    else if (ddsh.ddspf.dwFlags == DDS_RGBA && ddsh.ddspf.dwRGBBitCount == 32 && ddsh.ddspf.dwABitMask == 0xff000000)
        fmt = D3DFMT_A8R8G8B8;
    else if (ddsh.ddspf.dwFlags == DDS_RGB  && ddsh.ddspf.dwRGBBitCount == 24)
        fmt = D3DFMT_R8G8B8;
    else if (ddsh.ddspf.dwFlags == DDS_RGB  && ddsh.ddspf.dwRGBBitCount == 16 && ddsh.ddspf.dwGBitMask == 0x000007e0)
        fmt = D3DFMT_R5G6B5;
    else if (ddsh.ddspf.dwFlags == DDS_RGBA && ddsh.ddspf.dwRGBBitCount == 16 && ddsh.ddspf.dwABitMask == 0x00008000)
        fmt = D3DFMT_A1R5G5B5;
    else if (ddsh.ddspf.dwFlags == DDS_RGBA && ddsh.ddspf.dwRGBBitCount == 16 && ddsh.ddspf.dwABitMask == 0x0000f000)
        fmt = D3DFMT_A4R4G4B4;
    else
        return E_FAIL; // unknown fmt

    if (IsVolumeMap())
    {
        if (FAILED(hr = pd3ddev->CreateVolumeTexture(m_dwWidth, m_dwHeight, m_dwDepth, m_numMips,
            0, fmt, D3DPOOL_SYSTEMMEM, &pvoltex)))
        {
            return hr;
        }

        if (FAILED(hr = LoadAllVolumeSurfaces(pvoltex, ar)))
            return hr;

        *pptex = pvoltex;
    }
    else if (IsCubeMap())
    {
        if (FAILED(hr = pd3ddev->CreateCubeTexture(m_dwWidth, m_numMips,
             0, fmt, D3DPOOL_MANAGED, &pcubetex)))
        {
            return hr;
        }

        // Cubemaps created with the DX7 version of DxTex may skip some
        // cube faces.  ddsh.dwCubeMapFlags indicates which faces are
        // present.  If you only care about loading post-DX7 cubemaps, you
        // don't have to check these flags -- just load each face in sequence.

        // REVIEW: zero out surfaces of missing faces?

        if (m_dwCubeMapFlags & DDS_CUBEMAP_POSITIVEX)
        {
            if (FAILED(hr = LoadAllMipSurfaces(pcubetex, D3DCUBEMAP_FACE_POSITIVE_X, ar)))
                return hr;
        }

        if (m_dwCubeMapFlags & DDS_CUBEMAP_NEGATIVEX)
        {
            if (FAILED(hr = LoadAllMipSurfaces(pcubetex, D3DCUBEMAP_FACE_NEGATIVE_X, ar)))
                return hr;
        }

        if (m_dwCubeMapFlags & DDS_CUBEMAP_POSITIVEY)
        {
            if (FAILED(hr = LoadAllMipSurfaces(pcubetex, D3DCUBEMAP_FACE_POSITIVE_Y, ar)))
                return hr;
        }

        if (m_dwCubeMapFlags & DDS_CUBEMAP_NEGATIVEY)
        {
            if (FAILED(hr = LoadAllMipSurfaces(pcubetex, D3DCUBEMAP_FACE_NEGATIVE_Y, ar)))
                return hr;
        }

        if (m_dwCubeMapFlags & DDS_CUBEMAP_POSITIVEZ)
        {
            if (FAILED(hr = LoadAllMipSurfaces(pcubetex, D3DCUBEMAP_FACE_POSITIVE_Z, ar)))
                return hr;
        }

        if (m_dwCubeMapFlags & DDS_CUBEMAP_NEGATIVEZ)
        {
            if (FAILED(hr = LoadAllMipSurfaces(pcubetex, D3DCUBEMAP_FACE_NEGATIVE_Z, ar)))
                return hr;
        }

        *pptex = pcubetex;
    }
    else
    {
        if (FAILED(hr = pd3ddev->CreateTexture(m_dwWidth, m_dwHeight, m_numMips,
             0, fmt, D3DPOOL_MANAGED, &pmiptex)))
        {
            return hr;
        }

        if (FAILED(hr = LoadAllMipSurfaces(pmiptex, D3DCUBEMAP_FACE_FORCE_DWORD, ar)))
            return hr;

        *pptex = pmiptex;
    }

    return S_OK;
}


HRESULT CDxtexDoc::LoadAllMipSurfaces(LPDIRECT3DBASETEXTURE8 ptex, D3DCUBEMAP_FACES FaceType, CArchive& ar)
{
    HRESULT hr;
    LPDIRECT3DSURFACE8 psurf;
    D3DSURFACE_DESC sd;
    UINT iLevel;
    D3DLOCKED_RECT lr;
    LPDIRECT3DTEXTURE8 pmiptex = NULL;
    LPDIRECT3DCUBETEXTURE8 pcubetex = NULL;
    DWORD dwBytesPerRow;

    if (FaceType == D3DCUBEMAP_FACE_FORCE_DWORD)
        pmiptex = (LPDIRECT3DTEXTURE8)ptex;
    else
        pcubetex = (LPDIRECT3DCUBETEXTURE8)ptex;

    for (iLevel = 0; iLevel < m_numMips; iLevel++)
    {
        if (pmiptex != NULL)
            hr = pmiptex->GetSurfaceLevel(iLevel, &psurf);
        else
            hr = pcubetex->GetCubeMapSurface(FaceType, iLevel, &psurf);
        if (FAILED(hr))
            return hr;
        psurf->GetDesc(&sd);
        switch (sd.Format)
        {
        case D3DFMT_DXT1:
        case D3DFMT_DXT2:
        case D3DFMT_DXT3:
        case D3DFMT_DXT4:
        case D3DFMT_DXT5:
            dwBytesPerRow = 0; // magic value indicates texture's memory is contiguous
            break;
        case D3DFMT_A8R8G8B8:
            dwBytesPerRow = 4 * sd.Width;
            break;
        case D3DFMT_R8G8B8:
            dwBytesPerRow = 3 * sd.Width;
            break;
        case D3DFMT_A1R5G5B5:
        case D3DFMT_A4R4G4B4:
        case D3DFMT_R5G6B5:
            dwBytesPerRow = 2 * sd.Width;
            break;
        default:
            return E_FAIL;
        }

        if (pmiptex != NULL)
            hr = pmiptex->LockRect(iLevel, &lr, NULL, 0);
        else
            hr = pcubetex->LockRect(FaceType, iLevel, &lr, NULL, 0);
        if (FAILED(hr))
            return hr;
        if (dwBytesPerRow == 0)
        {
            ar.Read(lr.pBits, sd.Size);
        }
        else
        {
            DWORD yp;
            BYTE* pbDest = (BYTE*)lr.pBits;
            for (yp = 0; yp < sd.Height; yp++)
            {
                ar.Read(pbDest, dwBytesPerRow);
                pbDest += lr.Pitch;
            }
        }

        if (pmiptex != NULL)
            hr = pmiptex->UnlockRect(iLevel);
        else
            hr = pcubetex->UnlockRect(FaceType, iLevel);
        ReleasePpo(&psurf);
    }

    return S_OK;
}


HRESULT CDxtexDoc::LoadAllVolumeSurfaces(LPDIRECT3DVOLUMETEXTURE8 pvoltex, CArchive& ar)
{
    HRESULT hr;
    D3DVOLUME_DESC vd;
    D3DBOX box;
    D3DLOCKED_BOX lb;
    UINT iLevel;
    UINT numBytesPerRow;
    BYTE* pbSlice;
    BYTE* pbRow;
    UINT zp;
    UINT yp;

    for (iLevel = 0; iLevel < m_numMips; iLevel++)
    {
        pvoltex->GetLevelDesc(iLevel, &vd);
        box.Left = 0;
        box.Right = vd.Width;
        box.Top = 0;
        box.Bottom = vd.Height;
        box.Front = 0;
        box.Back = vd.Depth;
        hr = pvoltex->LockBox(iLevel, &lb, &box, 0);
        if (FAILED(hr))
            return hr;
        switch(vd.Format)
        {
        case D3DFMT_A8R8G8B8:
            numBytesPerRow = 4 * vd.Width;
            break;
        default:
            return E_FAIL;
        }
        pbSlice = (BYTE*)lb.pBits;
        for (zp = 0; zp < vd.Depth; zp++)
        {
            pbRow = pbSlice;
            for (yp = 0; yp < vd.Height; yp++)
            {
                ar.Read(pbRow, numBytesPerRow);
                pbRow += lb.RowPitch;
            }
            pbSlice += lb.SlicePitch;
        }

        pvoltex->UnlockBox(iLevel);
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDxtexDoc commands

HRESULT CDxtexDoc::LoadBmp(CString& strPath)
{
    HRESULT hr;

    LPDIRECT3DDEVICE8 pd3ddev;
    LPDIRECT3DTEXTURE8 ptex;

    pd3ddev = PDxtexApp()->Pd3ddev();
    hr = D3DXCreateTextureFromFileEx(pd3ddev, strPath, D3DX_DEFAULT,
        D3DX_DEFAULT, 1, 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED,
        D3DX_FILTER_POINT, D3DX_FILTER_POINT, 0, NULL, NULL, &ptex);
    if (FAILED(hr))
        return hr;

    // Look for "foo_a.bmp" for alpha channel
    int i = strPath.ReverseFind('.');
    strPath = strPath.Left(i) + "_a.bmp";
    CFileStatus status;
    if (CFile::GetStatus(strPath, status))
    {
        LPDIRECT3DSURFACE8 psurf;

        hr = ptex->GetSurfaceLevel(0, &psurf);
        if (FAILED(hr))
            return hr;

        hr = LoadAlphaIntoSurface(strPath, psurf);
        ReleasePpo(&psurf);
        if (FAILED(hr))
            return hr;
    }

    // Ensure that source image dimensions are power of 2
    D3DSURFACE_DESC sd;
    ptex->GetLevelDesc(0, &sd);
    m_dwWidth = sd.Width;
    m_dwHeight = sd.Height;

    LONG lwTempW;
    LONG lwTempH;
    lwTempW = sd.Width;
    lwTempH = sd.Height;
    while ((lwTempW & 1) == 0)
        lwTempW = lwTempW >> 1;
    while ((lwTempH & 1) == 0)
        lwTempH = lwTempH >> 1;
    if (lwTempW != 1 || lwTempH != 1)
    {
        AfxMessageBox(ID_ERROR_NOTPOW2);
        ReleasePpo(&ptex);
        return E_FAIL;
    }

    m_numMips = 1;

    ReleasePpo(&m_ptexOrig);
    m_ptexOrig = ptex;

    m_strTitle.Empty();
    m_strPathName.Empty();
    SetModifiedFlag(TRUE);

    return S_OK;
}


HRESULT CDxtexDoc::LoadAlphaBmp(CString& strPath)
{
    HRESULT hr;
    LPDIRECT3DTEXTURE8 pmiptex;
    LPDIRECT3DSURFACE8 psurf;

    if (IsCubeMap())
        return E_FAIL;

    pmiptex = (LPDIRECT3DTEXTURE8)m_ptexOrig;
    hr = pmiptex->GetSurfaceLevel(0, &psurf);
    if (FAILED(hr))
        return hr;

    hr = LoadAlphaIntoSurface(strPath, psurf);
    ReleasePpo(&psurf);
    if (FAILED(hr))
        return hr;

    UpdateAllViews(NULL, 1); // tell CView to pick up new surface pointers
    return S_OK;
}


HRESULT CDxtexDoc::Compress(D3DFORMAT fmtTo, BOOL bSwitchView)
{
    HRESULT hr;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    LPDIRECT3DTEXTURE8 pmiptex;
    LPDIRECT3DCUBETEXTURE8 pcubetex;
    LPDIRECT3DVOLUMETEXTURE8 pvoltex;
    D3DFORMAT fmtFrom;
    LPDIRECT3DTEXTURE8 pmiptexNew;
    LPDIRECT3DCUBETEXTURE8 pcubetexNew;
    LPDIRECT3DVOLUMETEXTURE8 pvoltexNew;

    if (IsVolumeMap())
    {
        if (fmtTo == D3DFMT_DXT1 ||
            fmtTo == D3DFMT_DXT2 ||
            fmtTo == D3DFMT_DXT3 ||
            fmtTo == D3DFMT_DXT4 ||
            fmtTo == D3DFMT_DXT5)
        {
            return E_FAIL;
        }
        pvoltex = (LPDIRECT3DVOLUMETEXTURE8)m_ptexOrig;
        D3DVOLUME_DESC vd;
        pvoltex->GetLevelDesc(0, &vd);
        fmtFrom = vd.Format;
    }
    else if (IsCubeMap())
    {
        pcubetex = (LPDIRECT3DCUBETEXTURE8)m_ptexOrig;
        D3DSURFACE_DESC sd;
        pcubetex->GetLevelDesc(0, &sd);
        fmtFrom = sd.Format;
    }
    else
    {
        pmiptex = (LPDIRECT3DTEXTURE8)m_ptexOrig;
        D3DSURFACE_DESC sd;
        pmiptex->GetLevelDesc(0, &sd);
        fmtFrom = sd.Format;
    }

    if (fmtFrom == D3DFMT_DXT2 || fmtFrom == D3DFMT_DXT4)
    {
        if (fmtTo == D3DFMT_DXT1)
        {
            AfxMessageBox(ID_ERROR_PREMULTTODXT1);
        }
        else if (fmtTo != D3DFMT_DXT2 && fmtTo != D3DFMT_DXT4)
        {
            AfxMessageBox(ID_ERROR_PREMULTALPHA);
            return S_OK;
        }
    }

    if (IsVolumeMap())
    {
        hr = pd3ddev->CreateVolumeTexture(m_dwWidth, m_dwHeight, m_dwDepth, m_numMips,
            0, fmtTo, D3DPOOL_SYSTEMMEM, &pvoltexNew);
        if (FAILED(hr))
            return hr;
        ReleasePpo(&m_ptexNew);
        m_ptexNew = pvoltexNew;
        if (FAILED(BltAllLevels(D3DCUBEMAP_FACE_FORCE_DWORD, m_ptexOrig, m_ptexNew)))
            return hr;
    }
    else if (IsCubeMap())
    {
        hr = pd3ddev->CreateCubeTexture(m_dwWidth, m_numMips,
             0, fmtTo, D3DPOOL_MANAGED, &pcubetexNew);
        if (FAILED(hr))
            return hr;
        ReleasePpo(&m_ptexNew);
        m_ptexNew = pcubetexNew;
        if (FAILED(hr = BltAllLevels(D3DCUBEMAP_FACE_NEGATIVE_X, m_ptexOrig, m_ptexNew)))
            return hr;
        if (FAILED(hr = BltAllLevels(D3DCUBEMAP_FACE_POSITIVE_X, m_ptexOrig, m_ptexNew)))
            return hr;
        if (FAILED(hr = BltAllLevels(D3DCUBEMAP_FACE_NEGATIVE_Y, m_ptexOrig, m_ptexNew)))
            return hr;
        if (FAILED(hr = BltAllLevels(D3DCUBEMAP_FACE_POSITIVE_Y, m_ptexOrig, m_ptexNew)))
            return hr;
        if (FAILED(hr = BltAllLevels(D3DCUBEMAP_FACE_NEGATIVE_Z, m_ptexOrig, m_ptexNew)))
            return hr;
        if (FAILED(hr = BltAllLevels(D3DCUBEMAP_FACE_POSITIVE_Z, m_ptexOrig, m_ptexNew)))
            return hr;
    }
    else
    {
        hr = pd3ddev->CreateTexture(m_dwWidth, m_dwHeight, m_numMips,
             0, fmtTo, D3DPOOL_MANAGED, &pmiptexNew);
        if (FAILED(hr))
            return hr;
        ReleasePpo(&m_ptexNew);
        m_ptexNew = pmiptexNew;
        if (FAILED(BltAllLevels(D3DCUBEMAP_FACE_FORCE_DWORD, m_ptexOrig, m_ptexNew)))
            return hr;
    }

    SetModifiedFlag();
    m_bTitleModsChanged = TRUE; // force title bar update
    if (bSwitchView)
        AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_VIEW_COMPRESSED, 0);

    return S_OK;
}


void CDxtexDoc::OnGenerateMipMaps()
{
    GenerateMipMaps();
}


void CDxtexDoc::GenerateMipMaps()
{
    LONG lwTempH;
    LONG lwTempW;
    LONG lwPowsW;
    LONG lwPowsH;
    LPDIRECT3DTEXTURE8 pddsNew = NULL;
    D3DFORMAT fmt;
    HRESULT hr;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    LPDIRECT3DTEXTURE8 pmiptex = NULL;
    LPDIRECT3DCUBETEXTURE8 pcubetex = NULL;
    LPDIRECT3DVOLUMETEXTURE8 pvoltex = NULL;
    LPDIRECT3DTEXTURE8 pmiptexNew = NULL;
    LPDIRECT3DCUBETEXTURE8 pcubetexNew = NULL;
    LPDIRECT3DVOLUMETEXTURE8 pvoltexNew = NULL;
    LPDIRECT3DSURFACE8 psurfSrc;
    LPDIRECT3DSURFACE8 psurfDest;
    LPDIRECT3DVOLUME8 pvolSrc;
    LPDIRECT3DVOLUME8 pvolDest;

    if (IsVolumeMap())
        pvoltex = (LPDIRECT3DVOLUMETEXTURE8)m_ptexOrig;
    else if (IsCubeMap())
        pcubetex = (LPDIRECT3DCUBETEXTURE8)m_ptexOrig;
    else
        pmiptex = (LPDIRECT3DTEXTURE8)m_ptexOrig;

    if (pvoltex != NULL)
    {
        D3DVOLUME_DESC vd;
        pvoltex->GetLevelDesc(0, &vd);
        fmt = vd.Format;
    }
    else if (pcubetex != NULL)
    {
        D3DSURFACE_DESC sd;
        pcubetex->GetLevelDesc(0, &sd);
        fmt = sd.Format;
    }
    else
    {
        D3DSURFACE_DESC sd;
        pmiptex->GetLevelDesc(0, &sd);
        fmt = sd.Format;
    }

    // Ensure that source image is power of 2
    lwTempW = m_dwWidth;
    lwTempH = m_dwHeight;
    lwPowsW = 1;
    lwPowsH = 1;
    while ((lwTempW & 1) == 0)
    {
        lwPowsW++;
        lwTempW = lwTempW >> 1;
    }
    while ((lwTempH & 1) == 0)
    {
        lwPowsH++;
        lwTempH = lwTempH >> 1;
    }
    if (lwTempW != 1 || lwTempH != 1)
    {
        AfxMessageBox(ID_ERROR_NOTPOW2);
        return;
    }
    m_numMips = lwPowsW > lwPowsH ? lwPowsW : lwPowsH;

    // Create destination mipmap surface - same format as source
    if (pvoltex != NULL)
    {
        if (FAILED(hr = pd3ddev->CreateVolumeTexture(m_dwWidth, m_dwHeight, m_dwDepth,
            m_numMips, 0, fmt, D3DPOOL_SYSTEMMEM, &pvoltexNew)))
        {
            goto LFail;
        }
        hr = pvoltex->GetVolumeLevel(0, &pvolSrc);
        hr = pvoltexNew->GetVolumeLevel(0, &pvolDest);
        hr = D3DXLoadVolumeFromVolume(pvolDest, NULL, NULL, pvolSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0);
        ReleasePpo(&pvolSrc);
        ReleasePpo(&pvolDest);
        hr = D3DXFilterVolumeTexture(pvoltexNew, NULL, 0, D3DX_FILTER_TRIANGLE);
    }
    else if (pmiptex != NULL)
    {
        if (FAILED(hr = pd3ddev->CreateTexture(m_dwWidth, m_dwHeight, m_numMips,
             0, fmt, D3DPOOL_MANAGED, &pmiptexNew)))
        {
            goto LFail;
        }
        hr = pmiptex->GetSurfaceLevel(0, &psurfSrc);
        hr = pmiptexNew->GetSurfaceLevel(0, &psurfDest);
        hr = XDXTEXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
        hr = D3DXFilterTexture(pmiptexNew, NULL, 0, D3DX_FILTER_TRIANGLE);
    }
    else
    {
        if (FAILED(hr = pd3ddev->CreateCubeTexture(m_dwWidth, m_numMips,
             0, fmt, D3DPOOL_MANAGED, &pcubetexNew)))
        {
            goto LFail;
        }
        hr = pcubetex->GetCubeMapSurface(D3DCUBEMAP_FACE_POSITIVE_X, 0, &psurfSrc);
        hr = pcubetexNew->GetCubeMapSurface(D3DCUBEMAP_FACE_POSITIVE_X, 0, &psurfDest);
        hr = XDXTEXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
        hr = pcubetex->GetCubeMapSurface(D3DCUBEMAP_FACE_NEGATIVE_X, 0, &psurfSrc);
        hr = pcubetexNew->GetCubeMapSurface(D3DCUBEMAP_FACE_NEGATIVE_X, 0, &psurfDest);
        hr = XDXTEXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
        hr = pcubetex->GetCubeMapSurface(D3DCUBEMAP_FACE_POSITIVE_Y, 0, &psurfSrc);
        hr = pcubetexNew->GetCubeMapSurface(D3DCUBEMAP_FACE_POSITIVE_Y, 0, &psurfDest);
        hr = XDXTEXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
        hr = pcubetex->GetCubeMapSurface(D3DCUBEMAP_FACE_NEGATIVE_Y, 0, &psurfSrc);
        hr = pcubetexNew->GetCubeMapSurface(D3DCUBEMAP_FACE_NEGATIVE_Y, 0, &psurfDest);
        hr = XDXTEXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
        hr = pcubetex->GetCubeMapSurface(D3DCUBEMAP_FACE_POSITIVE_Z, 0, &psurfSrc);
        hr = pcubetexNew->GetCubeMapSurface(D3DCUBEMAP_FACE_POSITIVE_Z, 0, &psurfDest);
        hr = XDXTEXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
        hr = pcubetex->GetCubeMapSurface(D3DCUBEMAP_FACE_NEGATIVE_Z, 0, &psurfSrc);
        hr = pcubetexNew->GetCubeMapSurface(D3DCUBEMAP_FACE_NEGATIVE_Z, 0, &psurfDest);
        hr = XDXTEXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
        hr = D3DXFilterCubeTexture(pcubetexNew, NULL, 0, D3DX_FILTER_TRIANGLE);
    }

    ReleasePpo(&m_ptexOrig);
    if (pvoltexNew != NULL)
        m_ptexOrig = pvoltexNew;
    else if (pcubetexNew != NULL)
        m_ptexOrig = pcubetexNew;
    else
        m_ptexOrig = pmiptexNew;

    if (m_ptexNew != NULL)
    {
        // Rather than filtering down the (probably-compressed) m_ptexNew
        // top level, compress each mip level from the (probably-uncompressed)
        // m_ptexOrig levels.
        if (pvoltexNew != NULL)
        {
            D3DVOLUME_DESC vd;
            ((LPDIRECT3DVOLUMETEXTURE8)m_ptexNew)->GetLevelDesc(0, &vd);
            fmt = vd.Format;
        }
        else if (pcubetexNew != NULL)
        {
            D3DSURFACE_DESC sd;
            ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetLevelDesc(0, &sd);
            fmt = sd.Format;
        }
        else
        {
            D3DSURFACE_DESC sd;
            ((LPDIRECT3DCUBETEXTURE8)m_ptexNew)->GetLevelDesc(0, &sd);
            fmt = sd.Format;
        }
        Compress(fmt, FALSE);
    }

    m_bTitleModsChanged = TRUE; // Generate title bar update
    UpdateAllViews(NULL, 1); // tell CView to pick up new surface pointers
    SetModifiedFlag();
    return;

LFail:
    ReleasePpo(&pddsNew);
}


void CDxtexDoc::SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU)
{
    CDocument::SetPathName(lpszPathName, bAddToMRU);

    TCHAR* pszLeaf = strrchr(lpszPathName, '\\') + 1;
    TCHAR* pszExtension = strrchr(lpszPathName, '.');
    if (lstrcmpi(pszExtension, ".dds") != 0)
    {
        lstrcpy(pszExtension, "");
        SetModifiedFlag(TRUE);
        SetTitle(pszLeaf);
        m_strPathName.Empty();
    }
}

DWORD CDxtexDoc::NumMips(VOID)
{
    return m_numMips;
}


void CDxtexDoc::OnFileOpenAlpha()
{
    HRESULT hr;
    CString fileName;
    LPDIRECT3DTEXTURE8 pmiptex;

    if (IsCubeMap() || IsVolumeMap())
        return;
    pmiptex = (LPDIRECT3DTEXTURE8)m_ptexOrig;

    // Premultiplied-alpha files don't support this feature:
    D3DSURFACE_DESC sd;
    pmiptex->GetLevelDesc(0, &sd);
    if (sd.Format == D3DFMT_DXT2 || sd.Format == D3DFMT_DXT4)
    {
        AfxMessageBox(ID_ERROR_PREMULTALPHA);
        return;
    }

    if (!PromptForBmp(&fileName))
        return;

    LPDIRECT3DSURFACE8 psurf;
    if (FAILED(hr = pmiptex->GetSurfaceLevel(0, &psurf)))
        return;

    if (FAILED(hr = LoadAlphaIntoSurface(fileName, psurf)))
        return;
    if (m_numMips > 1)
        OnGenerateMipMaps();
    else if (m_ptexNew != NULL)
    {
        ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetLevelDesc(0, &sd);
        Compress(sd.Format, FALSE);
    }
    UpdateAllViews(NULL, 1);
}


HRESULT CDxtexDoc::LoadAlphaIntoSurface(CString& strPath, LPDIRECT3DSURFACE8 psurf)
{
    HRESULT hr;
    D3DSURFACE_DESC sd;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    LPDIRECT3DTEXTURE8 ptexAlpha;
    LPDIRECT3DSURFACE8 psurfAlpha;
    LPDIRECT3DSURFACE8 psurfTarget;

    psurf->GetDesc(&sd);

    // Load the alpha BMP into psurfAlpha, a new A8R8G8B8 surface
    hr = D3DXCreateTextureFromFileEx(pd3ddev, strPath, sd.Width, sd.Height, 1, 0,
        D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, D3DX_FILTER_TRIANGLE,
        D3DX_FILTER_TRIANGLE, 0, NULL, NULL, &ptexAlpha);
    hr = ptexAlpha->GetSurfaceLevel(0, &psurfAlpha);

    // Copy the target surface into an A8R8G8B8 surface
    hr = pd3ddev->CreateImageSurface(sd.Width, sd.Height, D3DFMT_A8R8G8B8, &psurfTarget);
    hr = XDXTEXLoadSurfaceFromSurface(psurfTarget, NULL, NULL, psurf, NULL, NULL,
        D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);

    // Fill in the alpha channels of psurfTarget based on the blue channel of psurfAlpha
    D3DLOCKED_RECT lrSrc;
    D3DLOCKED_RECT lrDest;

    hr = psurfAlpha->LockRect(&lrSrc, NULL, D3DLOCK_READONLY);
    hr = psurfTarget->LockRect(&lrDest, NULL, 0);

    DWORD xp;
    DWORD yp;
    DWORD* pdwRowSrc = (DWORD*)lrSrc.pBits;
    DWORD* pdwRowDest = (DWORD*)lrDest.pBits;
    DWORD* pdwSrc;
    DWORD* pdwDest;
    DWORD dwAlpha;
    LONG dataBytesPerRow = 4 * sd.Width;

    for (yp = 0; yp < sd.Height; yp++)
    {
        pdwSrc = pdwRowSrc;
        pdwDest = pdwRowDest;
        for (xp = 0; xp < sd.Width; xp++)
        {
            dwAlpha = *pdwSrc << 24;
            *pdwDest &= 0x00ffffff;
            *pdwDest |= dwAlpha;

            pdwSrc++;
            pdwDest++;
        }
        pdwRowSrc += lrSrc.Pitch / 4;
        pdwRowDest += lrDest.Pitch / 4;
    }

    psurfAlpha->UnlockRect();
    psurfTarget->UnlockRect();

    // Copy psurfTarget back into real surface
    hr = XDXTEXLoadSurfaceFromSurface(psurf, NULL, NULL, psurfTarget, NULL, NULL,
        D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);

    // Release allocated interfaces
    ReleasePpo(&psurfTarget);
    ReleasePpo(&psurfAlpha);
    ReleasePpo(&ptexAlpha);

    return S_OK;
}


BOOL CDxtexDoc::PromptForBmp(CString* pstrPath)
{
    CFileDialog dlgFile(TRUE);

    CString title;
    VERIFY(title.LoadString(AFX_IDS_OPENFILE));

    CString strFilter;
    CString strDefault;

    strFilter += "Bitmap Files (*.bmp, *.tga)";
    strFilter += (TCHAR)'\0';   // next string please
    strFilter += _T("*.bmp;*.tga");
    strFilter += (TCHAR)'\0';   // last string
    dlgFile.m_ofn.nMaxCustFilter++;

    // append the "*.*" all files filter
    CString allFilter;
    VERIFY(allFilter.LoadString(AFX_IDS_ALLFILTER));
    strFilter += allFilter;
    strFilter += (TCHAR)'\0';   // next string please
    strFilter += _T("*.*");
    strFilter += (TCHAR)'\0';   // last string
    dlgFile.m_ofn.nMaxCustFilter++;

    dlgFile.m_ofn.lpstrFilter = strFilter;
    dlgFile.m_ofn.lpstrTitle = title;
    dlgFile.m_ofn.lpstrFile = pstrPath->GetBuffer(_MAX_PATH);

    INT_PTR nResult = dlgFile.DoModal();
    pstrPath->ReleaseBuffer();
    if (nResult != IDOK)
        return FALSE;
    return TRUE;
}


void CDxtexDoc::OpenSubsurface(D3DCUBEMAP_FACES FaceType, LONG lwMip, LONG lwSlice)
{
    HRESULT hr;
    CString fileName;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    LPDIRECT3DTEXTURE8 ptex = NULL;
    LPDIRECT3DSURFACE8 psurfOrig = NULL;
    LPDIRECT3DSURFACE8 psurfNew = NULL;

    if (!PromptForBmp(&fileName))
        return;

    if (IsVolumeMap())
    {
        hr = D3DXCreateTextureFromFile(pd3ddev, fileName, &ptex);
        hr = ptex->GetSurfaceLevel(0, &psurfOrig);
    }
    else if (IsCubeMap())
    {
        hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexOrig)->GetCubeMapSurface(FaceType, lwMip, &psurfOrig);
        if (m_ptexNew != NULL)
            hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexNew)->GetCubeMapSurface(FaceType, lwMip, &psurfNew);
        hr = D3DXLoadSurfaceFromFile(psurfOrig, NULL, NULL, fileName, NULL, D3DX_FILTER_TRIANGLE, 0, NULL);
    }
    else
    {
        hr = ((LPDIRECT3DTEXTURE8)m_ptexOrig)->GetSurfaceLevel(lwMip, &psurfOrig);
        if (m_ptexNew != NULL)
            hr = ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetSurfaceLevel(lwMip, &psurfNew);
        hr = D3DXLoadSurfaceFromFile(psurfOrig, NULL, NULL, fileName, NULL, D3DX_FILTER_TRIANGLE, 0, NULL);
    }

    // Look for "foo_a.bmp" for alpha channel
    int i = fileName.ReverseFind('.');
    fileName = fileName.Left(i) + "_a.bmp";
    CFileStatus status;
    if (CFile::GetStatus(fileName, status))
    {
        if (FAILED(hr = LoadAlphaIntoSurface(fileName, psurfOrig)))
            return;
    }

    if (IsVolumeMap())
    {
        LPDIRECT3DVOLUME8 pvol;
        hr = ((LPDIRECT3DVOLUMETEXTURE8)m_ptexOrig)->GetVolumeLevel(lwMip, &pvol);
        hr = LoadVolumeSliceFromSurface(pvol, lwSlice, psurfOrig);
        ReleasePpo(&pvol);
        if (m_ptexNew)
        {
            hr = ((LPDIRECT3DVOLUMETEXTURE8)m_ptexNew)->GetVolumeLevel(lwMip, &pvol);
            hr = LoadVolumeSliceFromSurface(pvol, lwSlice, psurfOrig);
            ReleasePpo(&pvol);
        }
    }
    else if (psurfNew != NULL)
    {
        hr = XDXTEXLoadSurfaceFromSurface(psurfNew, NULL, NULL, psurfOrig, NULL, NULL, D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);
    }

    ReleasePpo(&psurfOrig);
    ReleasePpo(&psurfNew);
    ReleasePpo(&ptex);

    SetModifiedFlag(TRUE);
    UpdateAllViews(NULL, 1);
}


void CDxtexDoc::OpenAlphaSubsurface(D3DCUBEMAP_FACES FaceType, LONG lwMip, LONG lwSlice)
{
    HRESULT hr;
    CString fileName;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    LPDIRECT3DTEXTURE8 ptexOrig = NULL;
    LPDIRECT3DTEXTURE8 ptexNew = NULL;
    LPDIRECT3DSURFACE8 psurfOrig = NULL;
    LPDIRECT3DSURFACE8 psurfNew = NULL;
    LPDIRECT3DVOLUME8 pvolOrig = NULL;
    LPDIRECT3DVOLUME8 pvolNew = NULL;
    D3DSURFACE_DESC sd;
    DWORD dwWidth = m_dwWidth;
    DWORD dwHeight = m_dwHeight;

    if (IsVolumeMap())
    {
        for (int i = 0; i < lwMip; i++)
        {
            dwWidth /= 2;
            dwHeight /= 2;
        }
        hr = pd3ddev->CreateTexture(dwWidth, dwHeight, 1,
             0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &ptexOrig);
        hr = ptexOrig->GetSurfaceLevel(0, &psurfOrig);
        hr = ((LPDIRECT3DVOLUMETEXTURE8)m_ptexOrig)->GetVolumeLevel(lwMip, &pvolOrig);
        hr = LoadSurfaceFromVolumeSlice(pvolOrig, lwSlice, psurfOrig);
        if (m_ptexNew != NULL)
        {
            hr = pd3ddev->CreateTexture(dwWidth, dwHeight, 1,
                 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &ptexNew);
            hr = ptexNew->GetSurfaceLevel(0, &psurfOrig);
            hr = ((LPDIRECT3DVOLUMETEXTURE8)m_ptexOrig)->GetVolumeLevel(lwMip, &pvolNew);
            hr = LoadSurfaceFromVolumeSlice(pvolNew, lwSlice, psurfOrig);
        }
    }
    else if (IsCubeMap())
    {
        hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexOrig)->GetCubeMapSurface(FaceType, lwMip, &psurfOrig);
        ((LPDIRECT3DCUBETEXTURE8)m_ptexOrig)->GetLevelDesc(lwMip, &sd);
        if (sd.Format == D3DFMT_DXT2 || sd.Format == D3DFMT_DXT4)
        {
            AfxMessageBox(ID_ERROR_PREMULTALPHA);
            return;
        }
        if (m_ptexNew != NULL)
        {
            hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexNew)->GetCubeMapSurface(FaceType, lwMip, &psurfNew);
            ((LPDIRECT3DCUBETEXTURE8)m_ptexNew)->GetLevelDesc(lwMip, &sd);
            if (sd.Format == D3DFMT_DXT2 || sd.Format == D3DFMT_DXT4)
            {
                AfxMessageBox(ID_ERROR_PREMULTALPHA);
                return;
            }
        }
    }
    else
    {
        hr = ((LPDIRECT3DTEXTURE8)m_ptexOrig)->GetSurfaceLevel(lwMip, &psurfOrig);
        ((LPDIRECT3DTEXTURE8)m_ptexOrig)->GetLevelDesc(lwMip, &sd);
        if (sd.Format == D3DFMT_DXT2 || sd.Format == D3DFMT_DXT4)
        {
            AfxMessageBox(ID_ERROR_PREMULTALPHA);
            return;
        }
        if (m_ptexNew != NULL)
        {
            hr = ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetSurfaceLevel(lwMip, &psurfNew);
            ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetLevelDesc(lwMip, &sd);
            if (sd.Format == D3DFMT_DXT2 || sd.Format == D3DFMT_DXT4)
            {
                AfxMessageBox(ID_ERROR_PREMULTALPHA);
                return;
            }
        }
    }

    if (!PromptForBmp(&fileName))
        return;

    if (FAILED(hr = LoadAlphaIntoSurface(fileName, psurfOrig)))
        return;

    if (psurfNew != NULL)
    {
        if (FAILED(hr = LoadAlphaIntoSurface(fileName, psurfNew)))
            return;
    }

    if (pvolOrig != NULL)
    {
        hr = LoadVolumeSliceFromSurface(pvolOrig, lwSlice, psurfOrig);
    }
    if (pvolNew != NULL)
    {
        hr = LoadVolumeSliceFromSurface(pvolNew, lwSlice, psurfNew);
    }

    ReleasePpo(&psurfOrig);
    ReleasePpo(&psurfNew);
    ReleasePpo(&ptexOrig);
    ReleasePpo(&ptexNew);
    ReleasePpo(&pvolOrig);
    ReleasePpo(&pvolNew);

    SetModifiedFlag(TRUE);
    UpdateAllViews(NULL, 1);
}


void CDxtexDoc::OnFormatChangeCubeMapFaces()
{
    HRESULT hr;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    D3DSURFACE_DESC sd;
    LPDIRECT3DCUBETEXTURE8 ptexCube;
    DWORD iLevel;
    LPDIRECT3DSURFACE8 psurfSrc;
    LPDIRECT3DSURFACE8 psurfDest;

    CCubeMapDlg cubeMapDlg;
    if (IDCANCEL == cubeMapDlg.DoModal())
        return;

    // Change m_ptexOrig into a cubemap
    ((LPDIRECT3DTEXTURE8)m_ptexOrig)->GetLevelDesc(0, &sd);
    hr = D3DXCreateCubeTexture(pd3ddev, m_dwWidth, m_numMips, 0, sd.Format, D3DPOOL_MANAGED, &ptexCube);
    for (iLevel = 0; iLevel < m_numMips; iLevel++)
    {
        hr = ((LPDIRECT3DTEXTURE8)m_ptexOrig)->GetSurfaceLevel(iLevel, &psurfSrc);
        hr = ptexCube->GetCubeMapSurface((D3DCUBEMAP_FACES)cubeMapDlg.m_iFace, iLevel, &psurfDest);
        hr = XDXTEXLoadSurfaceFromSurface(psurfDest, NULL, NULL,
            psurfSrc, NULL, NULL, D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&psurfDest);
    }
    ReleasePpo(&m_ptexOrig);
    m_ptexOrig = ptexCube;

    // Change m_ptexNew into a cubemap too
    if (m_ptexNew != NULL)
    {
        ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetLevelDesc(0, &sd);
        hr = D3DXCreateCubeTexture(pd3ddev, m_dwWidth, m_numMips, 0, sd.Format, D3DPOOL_MANAGED, &ptexCube);
        for (iLevel = 0; iLevel < m_numMips; iLevel++)
        {
            hr = ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetSurfaceLevel(iLevel, &psurfSrc);
            hr = ptexCube->GetCubeMapSurface((D3DCUBEMAP_FACES)cubeMapDlg.m_iFace, iLevel, &psurfDest);
            hr = XDXTEXLoadSurfaceFromSurface(psurfDest, NULL, NULL,
                psurfSrc, NULL, NULL, D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);
            ReleasePpo(&psurfSrc);
            ReleasePpo(&psurfDest);
        }
        ReleasePpo(&m_ptexNew);
        m_ptexNew = ptexCube;
    }
    m_dwCubeMapFlags = DDS_CUBEMAP_ALLFACES;
    SetModifiedFlag();
    UpdateAllViews(NULL, 1); // tell CView to pick up new surface pointers
}


void CDxtexDoc::OnFormatMakeIntoVolumeMap()
{
    HRESULT hr;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    D3DSURFACE_DESC sd;
    LPDIRECT3DVOLUMETEXTURE8 ptexVolume;
    DWORD iLevel;
    LPDIRECT3DSURFACE8 psurfSrc;
    LPDIRECT3DVOLUME8 pvolumeDest;
    UINT numLayers;

    CVolumeMapDlg volumeMapDlg;
    if (IDCANCEL == volumeMapDlg.DoModal())
        return;

    numLayers = (1 << volumeMapDlg.m_powLayers) * 2;

    // Change m_ptexOrig into a volumemap
    ((LPDIRECT3DTEXTURE8)m_ptexOrig)->GetLevelDesc(0, &sd);
    hr = pd3ddev->CreateVolumeTexture(m_dwWidth, m_dwHeight, numLayers,
        m_numMips, 0, sd.Format, D3DPOOL_SYSTEMMEM, &ptexVolume);
    if (FAILED(hr))
        return;
    for (iLevel = 0; iLevel < m_numMips; iLevel++)
    {
        hr = ((LPDIRECT3DTEXTURE8)m_ptexOrig)->GetSurfaceLevel(iLevel, &psurfSrc);
        hr = ptexVolume->GetVolumeLevel(iLevel, &pvolumeDest);
        hr = LoadVolumeSliceFromSurface(pvolumeDest, 0, psurfSrc);
        ReleasePpo(&psurfSrc);
        ReleasePpo(&pvolumeDest);
    }
    ReleasePpo(&m_ptexOrig);
    m_ptexOrig = ptexVolume;

    // Change m_ptexNew into a volumemap too
    if (m_ptexNew != NULL)
    {
        ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetLevelDesc(0, &sd);
        hr = pd3ddev->CreateVolumeTexture(m_dwWidth, m_dwHeight, numLayers,
            m_numMips, 0, sd.Format, D3DPOOL_SYSTEMMEM, &ptexVolume);
        if (FAILED(hr))
            return;
        for (iLevel = 0; iLevel < m_numMips; iLevel++)
        {
            hr = ((LPDIRECT3DTEXTURE8)m_ptexNew)->GetSurfaceLevel(iLevel, &psurfSrc);
            hr = ptexVolume->GetVolumeLevel(iLevel, &pvolumeDest);
            hr = LoadVolumeSliceFromSurface(pvolumeDest, 0, psurfSrc);
            ReleasePpo(&psurfSrc);
            ReleasePpo(&pvolumeDest);
        }
        ReleasePpo(&m_ptexNew);
        m_ptexNew = ptexVolume;
    }
    m_dwDepth = numLayers;
    SetModifiedFlag();
    UpdateAllViews(NULL, 1); // tell CView to pick up new surface pointers
}


HRESULT CDxtexDoc::LoadVolumeSliceFromSurface(LPDIRECT3DVOLUME8 pVolume, UINT iSlice, LPDIRECT3DSURFACE8 psurf)
{
    HRESULT hr;
    D3DSURFACE_DESC sd;
    D3DVOLUME_DESC vd;
    D3DLOCKED_RECT lr;
    D3DBOX boxSrc;
    D3DBOX boxDest;

    psurf->GetDesc(&sd);
    pVolume->GetDesc(&vd);

    boxSrc.Left = 0;
    boxSrc.Right = sd.Width;
    boxSrc.Top = 0;
    boxSrc.Bottom = sd.Height;
    boxSrc.Front = 0;
    boxSrc.Back = 1;

    boxDest.Left = 0;
    boxDest.Right = vd.Width;
    boxDest.Top = 0;
    boxDest.Bottom = vd.Height;
    boxDest.Front = iSlice;
    boxDest.Back = iSlice + 1;

    hr = psurf->LockRect(&lr, NULL, 0);
    if (FAILED(hr))
        return hr;

    hr = D3DXLoadVolumeFromMemory(pVolume, NULL, &boxDest, lr.pBits, sd.Format, lr.Pitch,
        0, NULL, &boxSrc, D3DX_FILTER_TRIANGLE, 0);

    psurf->UnlockRect();

    return hr;
}


HRESULT CDxtexDoc::LoadSurfaceFromVolumeSlice(LPDIRECT3DVOLUME8 pVolume, UINT iSlice, LPDIRECT3DSURFACE8 psurf)
{
    HRESULT hr;
    D3DVOLUME_DESC vd;
    D3DLOCKED_BOX lb;
    D3DBOX box;
    RECT rc;

    pVolume->GetDesc(&vd);

    box.Left = 0;
    box.Right = vd.Width;
    box.Top = 0;
    box.Bottom = vd.Height;
    box.Front = iSlice;
    box.Back = iSlice + 1;

    rc.left = 0;
    rc.right = vd.Width;
    rc.top = 0;
    rc.bottom = vd.Height;

    hr = pVolume->LockBox(&lb, &box, 0);
    if (FAILED(hr))
        return hr;

    hr = D3DXLoadSurfaceFromMemory(psurf, NULL, NULL, lb.pBits, vd.Format, lb.RowPitch,
        NULL, &rc, D3DX_FILTER_TRIANGLE, 0);

    pVolume->UnlockBox();

    return hr;
}


HRESULT CDxtexDoc::BltAllLevels(D3DCUBEMAP_FACES FaceType,
    LPDIRECT3DBASETEXTURE8 ptexSrc, LPDIRECT3DBASETEXTURE8 ptexDest)
{
    HRESULT hr;
    LPDIRECT3DTEXTURE8 pmiptexSrc;
    LPDIRECT3DTEXTURE8 pmiptexDest;
    LPDIRECT3DCUBETEXTURE8 pcubetexSrc;
    LPDIRECT3DCUBETEXTURE8 pcubetexDest;
    LPDIRECT3DVOLUMETEXTURE8 pvoltexSrc;
    LPDIRECT3DVOLUMETEXTURE8 pvoltexDest;
    LPDIRECT3DSURFACE8 psurfSrc;
    LPDIRECT3DSURFACE8 psurfDest;
    LPDIRECT3DVOLUME8 pvolSrc;
    LPDIRECT3DVOLUME8 pvolDest;
    DWORD iLevel;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();

    if (IsVolumeMap())
    {
        pvoltexSrc = (LPDIRECT3DVOLUMETEXTURE8)ptexSrc;
        pvoltexDest = (LPDIRECT3DVOLUMETEXTURE8)ptexDest;
    }
    else if (IsCubeMap())
    {
        pcubetexSrc = (LPDIRECT3DCUBETEXTURE8)ptexSrc;
        pcubetexDest = (LPDIRECT3DCUBETEXTURE8)ptexDest;
    }
    else
    {
        pmiptexSrc = (LPDIRECT3DTEXTURE8)ptexSrc;
        pmiptexDest = (LPDIRECT3DTEXTURE8)ptexDest;
    }

    for (iLevel = 0; iLevel < m_numMips; iLevel++)
    {
        if (IsVolumeMap())
        {
            hr = pvoltexSrc->GetVolumeLevel(iLevel, &pvolSrc);
            hr = pvoltexDest->GetVolumeLevel(iLevel, &pvolDest);
            hr = D3DXLoadVolumeFromVolume(pvolDest, NULL, NULL,
                pvolSrc, NULL, NULL, D3DX_FILTER_TRIANGLE, 0);
        }
        else if (IsCubeMap())
        {
            hr = pcubetexSrc->GetCubeMapSurface(FaceType, iLevel, &psurfSrc);
            hr = pcubetexDest->GetCubeMapSurface(FaceType, iLevel, &psurfDest);
            hr = XDXTEXLoadSurfaceFromSurface(psurfDest, NULL, NULL,
                psurfSrc, NULL, NULL, D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);
        }
        else
        {
            hr = pmiptexSrc->GetSurfaceLevel(iLevel, &psurfSrc);
            hr = pmiptexDest->GetSurfaceLevel(iLevel, &psurfDest);
            hr = XDXTEXLoadSurfaceFromSurface(psurfDest, NULL, NULL,
                psurfSrc, NULL, NULL, D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);
        }
    }

    return S_OK;
}


void CDxtexDoc::OpenCubeFace(D3DCUBEMAP_FACES FaceType)
{
    HRESULT hr;
    CString fileName;
    LPDIRECT3DSURFACE8 psurfOrig = NULL;
    LPDIRECT3DSURFACE8 psurfNew = NULL;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();

    if (!IsCubeMap())
        return;

    hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexOrig)->GetCubeMapSurface(FaceType, 0, &psurfOrig);
    if (m_ptexNew != NULL)
        hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexNew)->GetCubeMapSurface(FaceType, 0, &psurfNew);

    if (!PromptForBmp(&fileName))
        return;

    hr = D3DXLoadSurfaceFromFile(psurfOrig, NULL, NULL, fileName, NULL, D3DX_FILTER_TRIANGLE, 0, NULL);

    // Look for "foo_a.bmp" for alpha channel
    int i = fileName.ReverseFind('.');
    fileName = fileName.Left(i) + "_a.bmp";
    CFileStatus status;
    if (CFile::GetStatus(fileName, status))
    {
        if (FAILED(hr = LoadAlphaIntoSurface(fileName, psurfOrig)))
            return;
    }

    if (m_numMips > 1)
    {
        hr = D3DXFilterCubeTexture((LPDIRECT3DCUBETEXTURE8)m_ptexOrig, NULL, 0, D3DX_FILTER_TRIANGLE);
    }


    if (psurfNew != NULL)
    {
        hr = XDXTEXLoadSurfaceFromSurface(psurfNew, NULL, NULL, psurfOrig, NULL, NULL, D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);

        if (m_numMips > 1)
        {
            hr = D3DXFilterCubeTexture((LPDIRECT3DCUBETEXTURE8)m_ptexNew, NULL, 0, D3DX_FILTER_TRIANGLE);
        }
    }

    ReleasePpo(&psurfOrig);
    ReleasePpo(&psurfNew);

    SetModifiedFlag(TRUE);
    UpdateAllViews(NULL, 1);
}


void CDxtexDoc::OpenAlphaCubeFace(D3DCUBEMAP_FACES FaceType)
{
    HRESULT hr;
    CString fileName;
    LPDIRECT3DSURFACE8 psurfOrig = NULL;
    LPDIRECT3DSURFACE8 psurfNew = NULL;
    D3DSURFACE_DESC sd;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();

    if (!IsCubeMap())
        return;

    hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexOrig)->GetCubeMapSurface(FaceType, 0, &psurfOrig);
    ((LPDIRECT3DCUBETEXTURE8)m_ptexOrig)->GetLevelDesc(0, &sd);
    if (sd.Format == D3DFMT_DXT2 || sd.Format == D3DFMT_DXT4)
    {
        AfxMessageBox(ID_ERROR_PREMULTALPHA);
        return;
    }
    if (m_ptexNew != NULL)
    {
        hr = ((LPDIRECT3DCUBETEXTURE8)m_ptexNew)->GetCubeMapSurface(FaceType, 0, &psurfNew);
    }

    if (!PromptForBmp(&fileName))
        return;

    if (FAILED(hr = LoadAlphaIntoSurface(fileName, psurfOrig)))
        return;

    if (psurfNew != NULL)
    {
        if (FAILED(hr = LoadAlphaIntoSurface(fileName, psurfNew)))
            return;
    }

    if (m_numMips > 1)
    {
        hr = D3DXFilterCubeTexture((LPDIRECT3DCUBETEXTURE8)m_ptexOrig, NULL, 0, D3DX_FILTER_TRIANGLE);
    }


    if (psurfNew != NULL)
    {
        hr = XDXTEXLoadSurfaceFromSurface(psurfNew, NULL, NULL, psurfOrig, NULL, NULL, D3DX_FILTER_TRIANGLE, 0, pd3ddev, m_bXbox);

        if (m_numMips > 1)
        {
            hr = D3DXFilterCubeTexture((LPDIRECT3DCUBETEXTURE8)m_ptexNew, NULL, 0, D3DX_FILTER_TRIANGLE);
        }
    }

    ReleasePpo(&psurfOrig);
    ReleasePpo(&psurfNew);

    SetModifiedFlag(TRUE);
    UpdateAllViews(NULL, 1);
}


DWORD CDxtexDoc::DwDepthAt(LONG lwMip)
{
    DWORD dwDepth = m_dwDepth;
    while (lwMip > 0 && dwDepth > 1)
    {
        dwDepth /= 2;
        lwMip--;
    }
    return dwDepth;
}


void CDxtexDoc::OnFormatChangeSurfaceFmt()
{
    CChangeFmtDlg changeFmtDlg;
    LPDIRECT3DBASETEXTURE8 ptex;

    ptex = (m_ptexNew == NULL ? m_ptexOrig : m_ptexNew);

    if (IsVolumeMap())
    {
        D3DVOLUME_DESC vd;
        ((LPDIRECT3DVOLUMETEXTURE8)ptex)->GetLevelDesc(0, &vd);
        changeFmtDlg.m_fmt = vd.Format;
    }
    else if (IsCubeMap())
    {
        D3DSURFACE_DESC sd;
        ((LPDIRECT3DCUBETEXTURE8)ptex)->GetLevelDesc(0, &sd);
        changeFmtDlg.m_fmt = sd.Format;
    }
    else
    {
        D3DSURFACE_DESC sd;
        ((LPDIRECT3DTEXTURE8)ptex)->GetLevelDesc(0, &sd);
        changeFmtDlg.m_fmt = sd.Format;
    }

    changeFmtDlg.m_bVolume = IsVolumeMap();
    changeFmtDlg.m_bXbox = m_bXbox;

    if (IDCANCEL == changeFmtDlg.DoModal())
        return;

    m_bXbox = changeFmtDlg.m_bXbox;
    
    Compress(changeFmtDlg.m_fmt, TRUE);
}


void CDxtexDoc::OnUpdateFileOpenAlpha(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(!IsCubeMap() && !IsVolumeMap());
}


void CDxtexDoc::OnUpdateFormatGenerateMipmaps(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_numMips <= 1);
}


void CDxtexDoc::OnUpdateFormatChangeCubeMapFaces(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(!IsCubeMap() && !IsVolumeMap());
}


void CDxtexDoc::OnUpdateFormatMakeIntoVolumeMap(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(!IsCubeMap() && !IsVolumeMap());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\DXTexview.h ===
// dxtexView.h : interface of the CDxtexView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_DXTXVIEW_H__712C53D1_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
#define AFX_DXTXVIEW_H__712C53D1_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CDxtexView : public CScrollView
{
protected: // create from serialization only
    CDxtexView();
    DECLARE_DYNCREATE(CDxtexView)
    CDxtexDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDxtexView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual void OnInitialUpdate();
    protected:
    virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CDxtexView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
    BOOL TitleModsChanged(VOID) { return m_bTitleModsChanged; }
    VOID ClearTitleModsChanged(VOID) { m_bTitleModsChanged = FALSE; }
    CString GetStrTitleMods(VOID);
    VOID GetImageInfo(CString& strInfo);

// Generated message map functions
protected:
    //{{AFX_MSG(CDxtexView)
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnFileOpenSubsurface();
    afx_msg void OnFileOpenAlphaSubsurface();
    afx_msg void OnFileOpenFace();
    afx_msg void OnFileOpenAlphaFace();
    afx_msg void OnViewOriginal();
    afx_msg void OnViewCompressed();
    afx_msg void OnViewAlphaChannel();
    afx_msg void OnViewLargerMipLevel();
    afx_msg void OnViewSmallerMipLevel();
    afx_msg void OnViewZoomIn();
    afx_msg void OnViewZoomOut();
    afx_msg void OnViewChangeBackgroundColor();
    afx_msg void OnViewNegX();
    afx_msg void OnViewPosX();
    afx_msg void OnViewNegY();
    afx_msg void OnViewPosY();
    afx_msg void OnViewNegZ();
    afx_msg void OnViewPosZ();
    afx_msg void OnViewHigherVolumeSlice();
    afx_msg void OnViewLowerVolumeSlice();
    afx_msg void OnUpdateFileOpenSubsurface(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFileOpenAlphaSubsurface(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFileOpenFace(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFileOpenAlphaFace(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewOriginal(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewCompressed(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewAlphaChannel(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewLargerMipLevel(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewSmallerMipLevel(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewZoomIn(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewZoomOut(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewNegX(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewPosX(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewNegY(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewPosY(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewNegZ(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewPosZ(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewHigherVolumeSlice(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewLowerVolumeSlice(CCmdUI* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    HRESULT UpdateDevice(VOID);
    HRESULT RenderScene(VOID);
    CDxtexApp* PDxtexApp(VOID) { return (CDxtexApp*)AfxGetApp(); }
    HRESULT BuildViewSurface(BOOL bOrig, D3DCUBEMAP_FACES FaceType, LONG lwSlice, LONG lwMip, BOOL bViewAlpha);
    HRESULT LoadSurfaceFromVolumeSlice(LPDIRECT3DVOLUME8 pVolume, UINT iSlice, LPDIRECT3DSURFACE8 psurf);

    DWORD NumBytesInSurfaces(D3DCUBEMAP_FACES FaceType, LPDIRECT3DBASETEXTURE8 ptex);
    HRESULT CreateVertexBuffer(VOID);
    CString FormatName(D3DFORMAT fmt);

    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    LPDIRECT3DTEXTURE8 m_ptexCur; // Currently-viewed texture surface
    LPDIRECT3DSWAPCHAIN8 m_pSwapChain;
    CRect m_rcSrc; // Size of m_pddsCur and m_pddsBack
    CRect m_rcDest; // m_rcDest scaled by m_fZoom
    FLOAT m_fZoom; // Zoom factor
    BOOL m_bViewOrig; // View "original" vs. "new" surface
    BOOL m_bViewAlpha; // View alpha channel alone vs. normal image
    BOOL m_bTitleModsChanged; // Whether title bar text modifiers need to be updated
    LONG m_lwMipCur; // Currently-viewed mip.  0 = top, 1 = next one down, etc.
    D3DCUBEMAP_FACES m_CubeFaceCur; // D3DCUBEMAP_FACE_FORCE_DWORD = no cube map, or D3DCUBEMAP_FACE_POSITIVE_X, etc.
    LONG m_lwSliceCur; // For volume maps
    DWORD m_dwClearColor; // Background color that will show through where alpha is non-opaque
};

#ifndef _DEBUG  // debug version in dxtexView.cpp
inline CDxtexDoc* CDxtexView::GetDocument()
   { return (CDxtexDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DXTXVIEW_H__712C53D1_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\DXTexdoc.h ===
// dxtexDoc.h : interface of the CDxtexDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_DXTXDOC_H__712C53CF_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
#define AFX_DXtxDOC_H__712C53CF_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CDxtexDoc : public CDocument
{
protected: // create from serialization only
    CDxtexDoc();
    DECLARE_DYNCREATE(CDxtexDoc)

public:
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDxtexDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive& ar);
    virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);
    //}}AFX_VIRTUAL

// Implementation
public:
    HRESULT LoadAlphaBmp(CString& strPath);
    VOID GenerateMipMaps(VOID);
    HRESULT Compress(D3DFORMAT fmt, BOOL bSwitchView);
    DWORD NumMips(VOID);
    LPDIRECT3DBASETEXTURE8 PtexOrig(VOID) { return m_ptexOrig; }
    LPDIRECT3DBASETEXTURE8 PtexNew(VOID) { return m_ptexNew; }
    DWORD DwWidth(VOID) { return m_dwWidth; }
    DWORD DwHeight(VOID) { return m_dwHeight; }
    DWORD DwDepth(VOID) { return m_dwDepth; }
    DWORD DwDepthAt(LONG lwMip);
    BOOL TitleModsChanged(VOID) { return m_bTitleModsChanged; }
    VOID ClearTitleModsChanged(VOID) { m_bTitleModsChanged = FALSE; }
    virtual ~CDxtexDoc();
    void OpenSubsurface(D3DCUBEMAP_FACES FaceType, LONG lwMip, LONG lwSlice);
    void OpenAlphaSubsurface(D3DCUBEMAP_FACES FaceType, LONG lwMip, LONG lwSlice);
    void OpenCubeFace(D3DCUBEMAP_FACES FaceType);
    void OpenAlphaCubeFace(D3DCUBEMAP_FACES FaceType);
    BOOL IsCubeMap(VOID) { return (m_dwCubeMapFlags > 0); }
    BOOL IsVolumeMap(VOID) { return (m_dwDepth > 0); }
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
    //{{AFX_MSG(CDxtexDoc)
    afx_msg void OnFileOpenAlpha();
    afx_msg void OnGenerateMipMaps();
    afx_msg void OnFormatDxt1();
    afx_msg void OnFormatDxt2();
    afx_msg void OnFormatDxt3();
    afx_msg void OnFormatDxt4();
    afx_msg void OnFormatDxt5();
    afx_msg void OnFormatChangeCubeMapFaces();
    afx_msg void OnUpdateFileOpenAlpha(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFormatGenerateMipmaps(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFormatChangeCubeMapFaces(CCmdUI* pCmdUI);
    afx_msg void OnFormatMakeIntoVolumeMap();
    afx_msg void OnUpdateFormatMakeIntoVolumeMap(CCmdUI* pCmdUI);
    afx_msg void OnFormatChangeSurfaceFmt();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    LPDIRECT3DBASETEXTURE8 m_ptexOrig;
    LPDIRECT3DBASETEXTURE8 m_ptexNew;
    DWORD m_dwWidth;
    DWORD m_dwHeight;
    DWORD m_dwDepth; // For volume textures
    DWORD m_numMips;
    DWORD m_dwCubeMapFlags;
    BOOL m_bTitleModsChanged;
    BOOL m_bXbox;

    HRESULT LoadBmp(CString& strPath);
    CDxtexApp* PDxtexApp(VOID) { return (CDxtexApp*)AfxGetApp(); }
    HRESULT LoadAlphaIntoSurface(CString& strPath, LPDIRECT3DSURFACE8 psurf);
    HRESULT LoadVolumeSliceFromSurface(LPDIRECT3DVOLUME8 pVolume, UINT iSlice, LPDIRECT3DSURFACE8 pSurf);
    HRESULT LoadSurfaceFromVolumeSlice(LPDIRECT3DVOLUME8 pVolume, UINT iSlice, LPDIRECT3DSURFACE8 psurf);
    HRESULT BltAllLevels(D3DCUBEMAP_FACES FaceType, LPDIRECT3DBASETEXTURE8 ptexSrc,
        LPDIRECT3DBASETEXTURE8 ptexDest);
    BOOL PromptForBmp(CString* pstrPath);
    HRESULT SaveDDS(LPDIRECT3DBASETEXTURE8 ptex, CArchive& ar);
    HRESULT SaveAllMipSurfaces(LPDIRECT3DBASETEXTURE8 ptex, D3DCUBEMAP_FACES FaceType, CArchive& ar);
    HRESULT SaveAllVolumeSurfaces(LPDIRECT3DVOLUMETEXTURE8 pvoltex, CArchive& ar);
    HRESULT LoadDDS(LPDIRECT3DBASETEXTURE8* pptex, CArchive& ar);
    HRESULT LoadAllMipSurfaces(LPDIRECT3DBASETEXTURE8 ptex, D3DCUBEMAP_FACES FaceType, CArchive& ar);
    HRESULT LoadAllVolumeSurfaces(LPDIRECT3DVOLUMETEXTURE8 pvoltex, CArchive& ar);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DXTXDOC_H__712C53CF_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\StdAfx.Cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  dxtx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\DXTexview.Cpp ===
// dxtexView.cpp : implementation of the CDxtexView class
//

#include "stdafx.h"
#include "dxtex.h"
#include "dxtexDoc.h"
#include "dxtexView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Our custom vertex type
struct CUSTOMVERTEX
{
    FLOAT x, y, z;
    FLOAT rhw;
    DWORD color;
    FLOAT tu, tv;   // The texture coordinates
};

#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1)


IMPLEMENT_DYNCREATE(CDxtexView, CScrollView)

BEGIN_MESSAGE_MAP(CDxtexView, CScrollView)
    //{{AFX_MSG_MAP(CDxtexView)
    ON_WM_LBUTTONUP()
    ON_COMMAND(ID_FILE_OPENSUBSURFACE, OnFileOpenSubsurface)
    ON_COMMAND(ID_FILE_OPENALPHASUBSURFACE, OnFileOpenAlphaSubsurface)
    ON_COMMAND(ID_FILE_OPENFACE, OnFileOpenFace)
    ON_COMMAND(ID_FILE_OPENALPHAFACE, OnFileOpenAlphaFace)
    ON_COMMAND(ID_VIEW_ORIGINAL, OnViewOriginal)
    ON_COMMAND(ID_VIEW_COMPRESSED, OnViewCompressed)
    ON_COMMAND(ID_VIEW_SMALLERMIPLEVEL, OnViewSmallerMipLevel)
    ON_COMMAND(ID_VIEW_LARGERMIPLEVEL, OnViewLargerMipLevel)
    ON_COMMAND(ID_VIEW_ALPHACHANNEL, OnViewAlphaChannel)
    ON_COMMAND(ID_VIEW_ZOOMIN, OnViewZoomIn)
    ON_COMMAND(ID_VIEW_ZOOMOUT, OnViewZoomOut)
    ON_COMMAND(ID_VIEW_CHANGEBACKGROUNDCOLOR, OnViewChangeBackgroundColor)
    ON_COMMAND(ID_VIEW_NEGX, OnViewNegX)
    ON_COMMAND(ID_VIEW_POSX, OnViewPosX)
    ON_COMMAND(ID_VIEW_NEGY, OnViewNegY)
    ON_COMMAND(ID_VIEW_POSY, OnViewPosY)
    ON_COMMAND(ID_VIEW_NEGZ, OnViewNegZ)
    ON_COMMAND(ID_VIEW_POSZ, OnViewPosZ)
    ON_COMMAND(ID_VIEW_HIGHERVOLUMESLICE, OnViewHigherVolumeSlice)
    ON_COMMAND(ID_VIEW_LOWERVOLUMESLICE, OnViewLowerVolumeSlice)
    ON_UPDATE_COMMAND_UI(ID_FILE_OPENSUBSURFACE, OnUpdateFileOpenSubsurface)
    ON_UPDATE_COMMAND_UI(ID_FILE_OPENALPHASUBSURFACE, OnUpdateFileOpenAlphaSubsurface)
    ON_UPDATE_COMMAND_UI(ID_FILE_OPENFACE, OnUpdateFileOpenFace)
    ON_UPDATE_COMMAND_UI(ID_FILE_OPENALPHAFACE, OnUpdateFileOpenAlphaFace)
    ON_UPDATE_COMMAND_UI(ID_VIEW_ORIGINAL, OnUpdateViewOriginal)
    ON_UPDATE_COMMAND_UI(ID_VIEW_COMPRESSED, OnUpdateViewCompressed)
    ON_UPDATE_COMMAND_UI(ID_VIEW_ALPHACHANNEL, OnUpdateViewAlphaChannel)
    ON_UPDATE_COMMAND_UI(ID_VIEW_LARGERMIPLEVEL, OnUpdateViewLargerMipLevel)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SMALLERMIPLEVEL, OnUpdateViewSmallerMipLevel)
    ON_UPDATE_COMMAND_UI(ID_VIEW_ZOOMIN, OnUpdateViewZoomIn)
    ON_UPDATE_COMMAND_UI(ID_VIEW_ZOOMOUT, OnUpdateViewZoomOut)
    ON_UPDATE_COMMAND_UI(ID_VIEW_NEGX, OnUpdateViewNegX)
    ON_UPDATE_COMMAND_UI(ID_VIEW_POSX, OnUpdateViewPosX)
    ON_UPDATE_COMMAND_UI(ID_VIEW_NEGY, OnUpdateViewNegY)
    ON_UPDATE_COMMAND_UI(ID_VIEW_POSY, OnUpdateViewPosY)
    ON_UPDATE_COMMAND_UI(ID_VIEW_NEGZ, OnUpdateViewNegZ)
    ON_UPDATE_COMMAND_UI(ID_VIEW_POSZ, OnUpdateViewPosZ)
    ON_UPDATE_COMMAND_UI(ID_VIEW_HIGHERVOLUMESLICE, OnUpdateViewHigherVolumeSlice)
    ON_UPDATE_COMMAND_UI(ID_VIEW_LOWERVOLUMESLICE, OnUpdateViewLowerVolumeSlice)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CDxtexView::CDxtexView()
{
    m_ptexCur = NULL;
    m_pSwapChain = NULL;
    m_lwMipCur = 0;
    m_CubeFaceCur = D3DCUBEMAP_FACE_FORCE_DWORD;
    m_lwSliceCur = -1;
    m_fZoom = 1.0f;
    m_bViewOrig = TRUE;
    m_bViewAlpha = FALSE;

    m_pVB = NULL;
    m_ptexCur = NULL;
    m_pSwapChain = NULL;
}


CDxtexView::~CDxtexView()
{
    ReleasePpo(&m_pVB);
    ReleasePpo(&m_ptexCur);
    ReleasePpo(&m_pSwapChain);
}


// Note: repaints don't require re-rendering, just recopy from back buffer to view's DC
void CDxtexView::OnDraw(CDC* pDC)
{
    CDxtexDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    HRESULT hr;
    CRect rcSrc;
    CRect rcDest;

    rcSrc = m_rcSrc;
    rcDest = m_rcDest;

    rcDest.OffsetRect(pDC->GetViewportOrg());

    // REVIEW: only update dirty region?
    if (m_pSwapChain != NULL)
        hr = m_pSwapChain->Present(&rcSrc, &rcDest, GetSafeHwnd(), NULL);
}


#ifdef _DEBUG
void CDxtexView::AssertValid() const
{
    CScrollView::AssertValid();
}


void CDxtexView::Dump(CDumpContext& dc) const
{
    CScrollView::Dump(dc);
}


CDxtexDoc* CDxtexView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CDxtexDoc)));
    return (CDxtexDoc*)m_pDocument;
}
#endif //_DEBUG


void CDxtexView::OnLButtonUp(UINT nFlags, CPoint point)
{
    // Button click means toggle compressed / uncompressed view
    if (m_bViewOrig)
        OnViewCompressed();
    else
        OnViewOriginal();

    CScrollView::OnLButtonUp(nFlags, point);
}


void CDxtexView::OnInitialUpdate()
{
#ifdef _WIN64
    SetClassLongPtr(GetSafeHwnd(), GCLP_HBRBACKGROUND, (LONG_PTR)CreateSolidBrush(RGB(100, 100, 120)));
#else
    SetClassLong(GetSafeHwnd(), GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(100, 100, 120)));
#endif

    if (GetDocument()->IsCubeMap())
        m_CubeFaceCur = D3DCUBEMAP_FACE_POSITIVE_X;
    else
        m_CubeFaceCur = D3DCUBEMAP_FACE_FORCE_DWORD;
    if (GetDocument()->IsVolumeMap())
        m_lwSliceCur = 0;
    BuildViewSurface(m_bViewOrig, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    UpdateDevice();
    CreateVertexBuffer();
    RenderScene();

    SetScrollSizes(MM_TEXT, CSize(m_rcDest.Width(), m_rcDest.Height()));
    ResizeParentToFit();

    CScrollView::OnInitialUpdate();

    m_bTitleModsChanged = TRUE; // force title bar update
}


VOID CDxtexView::GetImageInfo(CString& strInfo)
{
    LPDIRECT3DBASETEXTURE8 ptex;
    D3DSURFACE_DESC sd;
    D3DVOLUME_DESC vd;
    D3DFORMAT fmt;
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwDepth;
    CString strFormat;
    TCHAR sz[100];
    DWORD dwBytes = 0;
    UINT iLevel;

    if (m_bViewOrig)
        ptex = GetDocument()->PtexOrig();
    else
        ptex = GetDocument()->PtexNew();

    if (GetDocument()->IsVolumeMap())
    {
        ((LPDIRECT3DVOLUMETEXTURE8)ptex)->GetLevelDesc(0, &vd);
        fmt = vd.Format;
        dwWidth = vd.Width;
        dwHeight = vd.Height;
        dwDepth = vd.Depth;
    }
    else if (!GetDocument()->IsCubeMap())
    {
        ((LPDIRECT3DTEXTURE8)ptex)->GetLevelDesc(0, &sd);
        fmt = sd.Format;
        dwWidth = sd.Width;
        dwHeight = sd.Height;
        dwDepth = 0;
    }
    else
    {
        ((LPDIRECT3DCUBETEXTURE8)ptex)->GetLevelDesc(0, &sd);
        fmt = sd.Format;
        dwWidth = sd.Width;
        dwHeight = sd.Height;
        dwDepth = 0;
    }

    strFormat = FormatName(fmt);

    // Count bytes in main surface chain
    if (GetDocument()->IsVolumeMap())
    {
        for (iLevel = 0; iLevel < GetDocument()->NumMips(); iLevel++)
        {
            ((LPDIRECT3DVOLUMETEXTURE8)ptex)->GetLevelDesc(iLevel, &vd);
            dwBytes += vd.Size;
        }
    }
    else if (!GetDocument()->IsCubeMap())
    {
        dwBytes += NumBytesInSurfaces(D3DCUBEMAP_FACE_FORCE_DWORD, ptex);
    }
    else
    {
        dwBytes += NumBytesInSurfaces(D3DCUBEMAP_FACE_POSITIVE_X, ptex);
        dwBytes += NumBytesInSurfaces(D3DCUBEMAP_FACE_NEGATIVE_X, ptex);
        dwBytes += NumBytesInSurfaces(D3DCUBEMAP_FACE_POSITIVE_Y, ptex);
        dwBytes += NumBytesInSurfaces(D3DCUBEMAP_FACE_NEGATIVE_Y, ptex);
        dwBytes += NumBytesInSurfaces(D3DCUBEMAP_FACE_POSITIVE_Z, ptex);
        dwBytes += NumBytesInSurfaces(D3DCUBEMAP_FACE_NEGATIVE_Z, ptex);
    }

    if (dwDepth == 0)
        wsprintf(sz, "%d x %d, %s, %d bytes", dwWidth, dwHeight, strFormat, dwBytes);
    else
        wsprintf(sz, "%d x %d x %d, %s, %d bytes", dwWidth, dwHeight, dwDepth, strFormat, dwBytes);
    strInfo = sz;
}


DWORD CDxtexView::NumBytesInSurfaces(D3DCUBEMAP_FACES FaceType, LPDIRECT3DBASETEXTURE8 ptex)
{
    DWORD dwBytes = 0;
    LPDIRECT3DTEXTURE8 pmiptex = NULL;
    LPDIRECT3DCUBETEXTURE8 pcubetex = NULL;
    D3DSURFACE_DESC sd;
    DWORD iLevel;

    if (FaceType == D3DCUBEMAP_FACE_FORCE_DWORD)
        pmiptex = (LPDIRECT3DTEXTURE8)ptex;
    else
        pcubetex = (LPDIRECT3DCUBETEXTURE8)ptex;

    for (iLevel = 0; iLevel < GetDocument()->NumMips(); iLevel++)
    {
        if (pmiptex != NULL)
            pmiptex->GetLevelDesc(iLevel, &sd);
        else
            pcubetex->GetLevelDesc(iLevel, &sd);
        dwBytes += sd.Size;
    }

    return dwBytes;
}


HRESULT CDxtexView::UpdateDevice(VOID)
{
    HRESULT hr;
    LPDIRECT3D8 pd3d = PDxtexApp()->Pd3d();
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    D3DDISPLAYMODE dispMode;
    D3DPRESENT_PARAMETERS presentParams;

    pd3d->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &dispMode);

    ReleasePpo(&m_pSwapChain);
    ZeroMemory(&presentParams, sizeof(presentParams));
    presentParams.Windowed = TRUE;
    presentParams.SwapEffect = D3DSWAPEFFECT_COPY_VSYNC;
    presentParams.BackBufferWidth = m_rcSrc.Width();
    presentParams.BackBufferHeight = m_rcSrc.Height();
    presentParams.BackBufferFormat = dispMode.Format;

    if (FAILED(hr = pd3ddev->CreateAdditionalSwapChain(&presentParams, &m_pSwapChain)))
        return hr;

    COLORREF crBkgd;
    crBkgd = PDxtexApp()->GetProfileInt("Settings", "Background Color", RGB(0, 255, 255));
    m_dwClearColor = D3DCOLOR_RGBA(GetRValue(crBkgd), GetGValue(crBkgd), GetBValue(crBkgd), 255);

    return S_OK;
}


HRESULT CDxtexView::CreateVertexBuffer(VOID)
{
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();

    // Create the the vertex buffer
    if( FAILED( pd3ddev->CreateVertexBuffer( 6 * sizeof(CUSTOMVERTEX),
        0 /* Usage */, D3DFVF_CUSTOMVERTEX,
        D3DPOOL_DEFAULT, &m_pVB ) ) )
    {
        return E_FAIL;
    }

    return S_OK;
}


HRESULT CDxtexView::RenderScene(VOID)
{
    CWaitCursor waitCursor;
    HRESULT hr;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();

    LPDIRECT3DSURFACE8 psurf;

    if (m_pSwapChain == NULL)
        return E_FAIL;

    // Vertices for our quad
    CUSTOMVERTEX vertexArray[] =
    {
        // x, y, z, rhw, color
        { 0.0f,                                 0.0f,                              0.5f, 1.0f, 0xffffffff, 0.0, 0.0, },
        { (FLOAT)m_rcSrc.right, 0.0f,                              0.5f, 1.0f, 0xffffffff, 1.0, 0.0, },
        { (FLOAT)m_rcSrc.right, (FLOAT)m_rcSrc.bottom, 0.5f, 1.0f, 0xffffffff, 1.0, 1.0, },

        { (FLOAT)m_rcSrc.right, (FLOAT)m_rcSrc.bottom, 0.5f, 1.0f, 0xffffffff, 1.0, 1.0, },
        { 0.0f,                                 (FLOAT)m_rcSrc.bottom, 0.5f, 1.0f, 0xffffffff, 0.0, 1.0, },
        { 0.0f,                                 0.0f,                              0.5f, 1.0f, 0xffffffff, 0.0, 0.0, },
    };

    // Copy the global vertex data into the vertex buffer
    VOID* pVertices;
    if( FAILED( m_pVB->Lock( 0, sizeof(vertexArray), (BYTE**)&pVertices, 0 ) ) )
        return E_FAIL;
    memcpy( pVertices, vertexArray, sizeof(vertexArray) );
    m_pVB->Unlock();

    hr = m_pSwapChain->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &psurf);

    hr = pd3ddev->SetRenderTarget(psurf, NULL);

    ReleasePpo(&psurf);

    hr = pd3ddev->Clear(0, NULL, D3DCLEAR_TARGET, m_dwClearColor, 0.0f, 0);

    hr = pd3ddev->BeginScene();

    // If the texture uses premultiplied alpha, the source blend should be D3DBLEND_ONE
    // since RGB is already at the level we want.  With nonpremultiplied alpha, the
    // source blend should be D3DBLEND_SRCALPHA.
    D3DSURFACE_DESC sd;
    m_ptexCur->GetLevelDesc(0, &sd);
    if (!m_bViewAlpha && (sd.Format == D3DFMT_DXT2 || sd.Format == D3DFMT_DXT4))
    {
        if (FAILED(hr = pd3ddev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE)))
            return hr;
    }
    else
    {
        if (FAILED(hr = pd3ddev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA)))
            return hr;
    }
    hr = pd3ddev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    hr = pd3ddev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

    pd3ddev->SetTexture(0, m_ptexCur);
    pd3ddev->SetStreamSource( 0, m_pVB, sizeof(CUSTOMVERTEX) );
    pd3ddev->SetVertexShader( D3DFVF_CUSTOMVERTEX );
    pd3ddev->DrawPrimitive( D3DPT_TRIANGLELIST, 0, 2 );
    pd3ddev->SetTexture(0, NULL);

    hr = pd3ddev->EndScene();

    return S_OK;
}


void CDxtexView::OnViewOriginal()
{
    if (GetDocument()->PtexOrig() == NULL)
        return;
    BuildViewSurface(TRUE, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    RenderScene();
    m_bTitleModsChanged = TRUE; // force title bar update
    InvalidateRect(&m_rcDest, FALSE); // force redraw of this view
}


void CDxtexView::OnViewCompressed()
{
    if (GetDocument()->PtexNew() == NULL)
        return;
    BuildViewSurface(FALSE, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    RenderScene();
    m_bTitleModsChanged = TRUE; // force title bar update
    InvalidateRect(&m_rcDest, FALSE); // force redraw of this view
}


void CDxtexView::OnUpdateViewOriginal(CCmdUI* pCmdUI)
{
    if (GetDocument()->PtexOrig() == NULL)
    {
        pCmdUI->Enable(FALSE);
        pCmdUI->SetCheck(0);
    }
    else
    {
        pCmdUI->Enable(TRUE);
        pCmdUI->SetCheck(m_bViewOrig);
    }
}


void CDxtexView::OnUpdateViewCompressed(CCmdUI* pCmdUI)
{
    if (GetDocument()->PtexNew() == NULL)
    {
        pCmdUI->Enable(FALSE);
        pCmdUI->SetCheck(0);
    }
    else
    {
        pCmdUI->Enable(TRUE);
        pCmdUI->SetCheck(!m_bViewOrig);
    }
}


void CDxtexView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
    m_bTitleModsChanged = TRUE; // force title bar update
    if (lHint == 1)
    {
        BuildViewSurface(m_bViewOrig, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
        RenderScene();
    }
    else if (lHint == 2)
    {
        UpdateDevice();
        RenderScene();
    }
    else if (lHint == 3)
    {
        RenderScene();
    }

    CScrollView::OnUpdate(pSender, lHint, pHint);
}


void CDxtexView::OnViewSmallerMipLevel()
{
    m_lwMipCur++;
    if (m_lwSliceCur > 0)
        m_lwSliceCur /= 2;
    BuildViewSurface(m_bViewOrig, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    UpdateDevice();
    RenderScene();
    m_bTitleModsChanged = TRUE; // force title bar update
    SetScrollSizes(MM_TEXT, CSize(m_rcDest.Width(), m_rcDest.Height()));
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnViewLargerMipLevel()
{
    m_lwMipCur--;
    if (m_lwSliceCur > 0)
        m_lwSliceCur *= 2;
    BuildViewSurface(m_bViewOrig, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    UpdateDevice();
    RenderScene();
    m_bTitleModsChanged = TRUE; // force title bar update
    SetScrollSizes(MM_TEXT, CSize(m_rcDest.Width(), m_rcDest.Height()));
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnViewAlphaChannel(VOID)
{
    BuildViewSurface(m_bViewOrig, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, !m_bViewAlpha);
    RenderScene();
    Invalidate(); // force redraw of this view
    m_bTitleModsChanged = TRUE; // force title bar update
}


void CDxtexView::OnUpdateViewAlphaChannel(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_bViewAlpha);
}


void CDxtexView::OnUpdateViewLargerMipLevel(CCmdUI* pCmdUI)
{
    if (m_lwMipCur > 0)
        pCmdUI->Enable(TRUE);
    else
        pCmdUI->Enable(FALSE);
}


void CDxtexView::OnUpdateViewSmallerMipLevel(CCmdUI* pCmdUI)
{
    if (m_lwMipCur < (LONG)GetDocument()->NumMips() - 1)
        pCmdUI->Enable(TRUE);
    else
        pCmdUI->Enable(FALSE);
}


void CDxtexView::OnViewZoomIn()
{
    if (m_fZoom < 8.0f)
        m_fZoom *= 2.0f;
    m_rcDest.right = (LONG)(m_rcSrc.right * m_fZoom);
    m_rcDest.bottom = (LONG)(m_rcSrc.bottom * m_fZoom);
    SetScrollSizes(MM_TEXT, CSize(m_rcDest.Width(), m_rcDest.Height()));
    m_bTitleModsChanged = TRUE; // force title bar update
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnViewZoomOut()
{
    if (m_fZoom > 0.125f)
        m_fZoom /= 2.0f;
    m_rcDest.right = (LONG)(m_rcSrc.right * m_fZoom);
    m_rcDest.bottom = (LONG)(m_rcSrc.bottom * m_fZoom);
    SetScrollSizes(MM_TEXT, CSize(m_rcDest.Width(), m_rcDest.Height()));
    m_bTitleModsChanged = TRUE; // force title bar update
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnUpdateViewZoomIn(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_fZoom < 8.0f);
}


void CDxtexView::OnUpdateViewZoomOut(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_fZoom > 0.125f);
}


CString CDxtexView::GetStrTitleMods(VOID)
{
    CString strTitleMods;
    strTitleMods = "(";

    // Append alpha, if in alpha mode
    if (m_bViewAlpha)
            strTitleMods += "Alpha, ";

    // Show format
    LPDIRECT3DBASETEXTURE8 ptex;
    CString strFormat;
    D3DFORMAT fmt;

    if (m_bViewOrig)
        ptex = GetDocument()->PtexOrig();
    else
        ptex = GetDocument()->PtexNew();

    if (GetDocument()->IsVolumeMap())
    {
        D3DVOLUME_DESC vd;
        ((LPDIRECT3DVOLUMETEXTURE8)ptex)->GetLevelDesc(0, &vd);
        fmt = vd.Format;
    }
    else if (!GetDocument()->IsCubeMap())
    {
        D3DSURFACE_DESC sd;
        ((LPDIRECT3DTEXTURE8)ptex)->GetLevelDesc(0, &sd);
        fmt = sd.Format;
    }
    else
    {
        D3DSURFACE_DESC sd;
        ((LPDIRECT3DCUBETEXTURE8)ptex)->GetLevelDesc(0, &sd);
        fmt = sd.Format;
    }

    strTitleMods += FormatName(fmt);
    strTitleMods += TEXT(", ");

    // Append cube map info, if a cube map
    switch (m_CubeFaceCur)
    {
    case D3DCUBEMAP_FACE_NEGATIVE_X:
        strTitleMods += "Negative X, ";
        break;
    case D3DCUBEMAP_FACE_POSITIVE_X:
        strTitleMods += "Positive X, ";
        break;
    case D3DCUBEMAP_FACE_NEGATIVE_Y:
        strTitleMods += "Negative Y, ";
        break;
    case D3DCUBEMAP_FACE_POSITIVE_Y:
        strTitleMods += "Positive Y, ";
        break;
    case D3DCUBEMAP_FACE_NEGATIVE_Z:
        strTitleMods += "Negative Z, ";
        break;
    case D3DCUBEMAP_FACE_POSITIVE_Z:
        strTitleMods += "Positive Z, ";
        break;
    }

    if (m_lwSliceCur >= 0)
    {
        CString strSlice;
        strSlice.Format("Slice %d of %d, ", m_lwSliceCur + 1, GetDocument()->DwDepthAt(m_lwMipCur));
        strTitleMods += strSlice;
    }

    // Append mip info, if multiple mip levels
    DWORD dwNumMips = GetDocument()->NumMips();
    if (dwNumMips > 1)
    {
        CString strMipInfo;
        strMipInfo.Format("Mip %d of %d, ", m_lwMipCur + 1, dwNumMips);
        strTitleMods += strMipInfo;
    }

    // Append view magnification
    CString strView;
    strView.Format("%d", (LONG)(100 * m_fZoom));
    strTitleMods += strView + "%";

    strTitleMods += ")";

    return strTitleMods;
}


CString CDxtexView::FormatName(D3DFORMAT fmt)
{
    CString str;
    switch (fmt)
    {
    case D3DFMT_A8R8G8B8:
        str = TEXT("A8R8G8B8");
        break;
    case D3DFMT_A1R5G5B5:
        str = TEXT("A1R5G5B5");
        break;
    case D3DFMT_A4R4G4B4:
        str = TEXT("A4R4G4B4");
        break;
    case D3DFMT_R8G8B8:
        str = TEXT("R8G8B8");
        break;
    case D3DFMT_R5G6B5:
        str = TEXT("R5G6B5");
        break;
    case D3DFMT_DXT1:
        str = TEXT("DXT1");
        break;
    case D3DFMT_DXT2:
        str = TEXT("DXT2");
        break;
    case D3DFMT_DXT3:
        str = TEXT("DXT3");
        break;
    case D3DFMT_DXT4:
        str = TEXT("DXT4");
        break;
    case D3DFMT_DXT5:
        str = TEXT("DXT5");
        break;
    default:
        str = TEXT("unknown fmt");
        break;
    }
    return str;
}

void CDxtexView::OnViewChangeBackgroundColor()
{
    CHOOSECOLOR cc;
    COLORREF crArray[16];

    ZeroMemory(&cc, sizeof(cc));
    cc.lStructSize = sizeof(cc);
    cc.hwndOwner = GetSafeHwnd();
    cc.rgbResult = PDxtexApp()->GetProfileInt("Settings", "Background Color", RGB(0, 255, 255));
    cc.lpCustColors = crArray;
    cc.Flags = CC_RGBINIT | CC_ANYCOLOR | CC_FULLOPEN;

    if (ChooseColor(&cc))
    {
        PDxtexApp()->WriteProfileInt("Settings", "Background Color", cc.rgbResult);

        // Update all views of all documents of our one doc template
        POSITION posTemp = PDxtexApp()->GetFirstDocTemplatePosition();
        CDocTemplate* pDocTemplate = PDxtexApp()->GetNextDocTemplate(posTemp);
        CDocument* pdoc;
        POSITION pos = pDocTemplate->GetFirstDocPosition();
        while (pos != NULL)
        {
            pdoc = pDocTemplate->GetNextDoc(pos);
            pdoc->UpdateAllViews(NULL, 2);
        }
    }
}


void CDxtexView::OnFileOpenSubsurface()
{
    GetDocument()->OpenSubsurface(m_CubeFaceCur, m_lwMipCur, m_lwSliceCur);
}


void CDxtexView::OnUpdateFileOpenSubsurface(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(TRUE);
}


void CDxtexView::OnFileOpenAlphaSubsurface()
{
    GetDocument()->OpenAlphaSubsurface(m_CubeFaceCur, m_lwMipCur, m_lwSliceCur);
}


void CDxtexView::OnUpdateFileOpenAlphaSubsurface(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(TRUE);
}


HRESULT CDxtexView::BuildViewSurface(BOOL bOrig, D3DCUBEMAP_FACES FaceType, LONG lwSlice, LONG lwMip, BOOL bViewAlpha)
{
    HRESULT hr;
    LPDIRECT3DDEVICE8 pd3ddev = PDxtexApp()->Pd3ddev();
    LPDIRECT3DBASETEXTURE8 ptex;
    BOOL bIsCubeMap = GetDocument()->IsCubeMap();
    BOOL bIsVolumeMap = GetDocument()->IsVolumeMap();
    D3DSURFACE_DESC sd;
    D3DVOLUME_DESC vd;

    ReleasePpo(&m_ptexCur);

    if (bIsVolumeMap && lwSlice == -1)
        lwSlice = 0;

    if (bIsCubeMap && FaceType == D3DCUBEMAP_FACE_FORCE_DWORD)
        FaceType = D3DCUBEMAP_FACE_POSITIVE_X;

    m_bViewOrig = bOrig;
    m_bViewAlpha = bViewAlpha;
    m_lwSliceCur = lwSlice;
    m_lwMipCur = lwMip;
    m_CubeFaceCur = FaceType;

    if (bOrig)
        ptex = GetDocument()->PtexOrig();
    else
        ptex = GetDocument()->PtexNew();

    if (bIsVolumeMap)
    {
        ((LPDIRECT3DVOLUMETEXTURE8)ptex)->GetLevelDesc(m_lwMipCur, &vd);
        sd.Width = vd.Width;
        sd.Height = vd.Height;
    }
    else if (!bIsCubeMap)
    {
        ((LPDIRECT3DTEXTURE8)ptex)->GetLevelDesc(m_lwMipCur, &sd);
    }
    else
    {
        ((LPDIRECT3DCUBETEXTURE8)ptex)->GetLevelDesc(m_lwMipCur, &sd);
    }

    hr = pd3ddev->CreateTexture(sd.Width, sd.Height, 1,
         0 /* Usage */, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &m_ptexCur);
    if (FAILED(hr))
        return hr;

    m_rcSrc.SetRect(0, 0, sd.Width, sd.Height);
    m_rcDest.SetRect(0, 0, (INT)(sd.Width * m_fZoom), (INT)(sd.Height * m_fZoom));

    LPDIRECT3DSURFACE8 psurfSrc = NULL;
    LPDIRECT3DSURFACE8 psurfDest = NULL;

    hr = m_ptexCur->GetSurfaceLevel(0, &psurfDest);

    if (bIsVolumeMap)
    {
        LPDIRECT3DVOLUME8 pvolSrc;
        hr = ((LPDIRECT3DVOLUMETEXTURE8)ptex)->GetVolumeLevel(m_lwMipCur, &pvolSrc);
        hr = LoadSurfaceFromVolumeSlice(pvolSrc, m_lwSliceCur, psurfDest);
        ReleasePpo(&pvolSrc);
    }
    else if (!bIsCubeMap)
    {
        hr = ((LPDIRECT3DTEXTURE8)ptex)->GetSurfaceLevel(m_lwMipCur, &psurfSrc);
        hr = D3DXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0);
    }
    else
    {
        hr = ((LPDIRECT3DCUBETEXTURE8)ptex)->GetCubeMapSurface(FaceType, m_lwMipCur, &psurfSrc);
        hr = D3DXLoadSurfaceFromSurface(psurfDest, NULL, NULL, psurfSrc, NULL, NULL,
            D3DX_FILTER_TRIANGLE, 0);
    }


    if (bViewAlpha)
    {
        // Move alpha channels into RGB (and set alpha to 0xff)
        D3DLOCKED_RECT lr;

        hr = psurfDest->LockRect(&lr, NULL, 0);

        DWORD xp;
        DWORD yp;
        DWORD* pdwRow = (DWORD*)lr.pBits;
        DWORD* pdw;
        DWORD dwAlpha;
        LONG dataBytesPerRow = 4 * sd.Width;

        for (yp = 0; yp < sd.Height; yp++)
        {
            pdw = pdwRow;
            for (xp = 0; xp < sd.Width; xp++)
            {
                dwAlpha = *pdw >> 24;
                *pdw = 0xff000000 | (dwAlpha << 16) | (dwAlpha << 8) | (dwAlpha);
                pdw++;
            }
            pdwRow += lr.Pitch / 4;
        }
        psurfDest->UnlockRect();
    }

    ReleasePpo(&psurfSrc);
    ReleasePpo(&psurfDest);

    return S_OK;
}


HRESULT CDxtexView::LoadSurfaceFromVolumeSlice(LPDIRECT3DVOLUME8 pVolume, UINT iSlice, LPDIRECT3DSURFACE8 psurf)
{
    HRESULT hr;
    D3DVOLUME_DESC vd;
    D3DLOCKED_BOX lb;
    D3DBOX box;
    RECT rc;

    pVolume->GetDesc(&vd);

    box.Left = 0;
    box.Right = vd.Width;
    box.Top = 0;
    box.Bottom = vd.Height;
    box.Front = iSlice;
    box.Back = iSlice + 1;

    rc.left = 0;
    rc.right = vd.Width;
    rc.top = 0;
    rc.bottom = vd.Height;

    hr = pVolume->LockBox(&lb, &box, 0);
    if (FAILED(hr))
        return hr;

    hr = D3DXLoadSurfaceFromMemory(psurf, NULL, NULL, lb.pBits, vd.Format, lb.RowPitch,
        NULL, &rc, D3DX_FILTER_TRIANGLE, 0);

    pVolume->UnlockBox();

    return hr;
}


void CDxtexView::OnViewNegX()
{
    BuildViewSurface(m_bViewOrig, D3DCUBEMAP_FACE_NEGATIVE_X, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    m_bTitleModsChanged = TRUE; // force title bar update
    RenderScene();
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnUpdateViewNegX(CCmdUI* pCmdUI)
{
    BOOL bEnable = GetDocument()->IsCubeMap();
    pCmdUI->Enable(bEnable);
    pCmdUI->SetCheck(m_CubeFaceCur == D3DCUBEMAP_FACE_NEGATIVE_X);
}


void CDxtexView::OnViewPosX()
{
    BuildViewSurface(m_bViewOrig, D3DCUBEMAP_FACE_POSITIVE_X, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    m_bTitleModsChanged = TRUE; // force title bar update
    RenderScene();
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnUpdateViewPosX(CCmdUI* pCmdUI)
{
    BOOL bEnable = GetDocument()->IsCubeMap();
    pCmdUI->Enable(bEnable);
    pCmdUI->SetCheck(m_CubeFaceCur == D3DCUBEMAP_FACE_POSITIVE_X);
}


void CDxtexView::OnViewNegY()
{
    BuildViewSurface(m_bViewOrig, D3DCUBEMAP_FACE_NEGATIVE_Y, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    m_bTitleModsChanged = TRUE; // force title bar update
    RenderScene();
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnUpdateViewNegY(CCmdUI* pCmdUI)
{
    BOOL bEnable = GetDocument()->IsCubeMap();
    pCmdUI->Enable(bEnable);
    pCmdUI->SetCheck(m_CubeFaceCur == D3DCUBEMAP_FACE_NEGATIVE_Y);
}


void CDxtexView::OnViewPosY()
{
    BuildViewSurface(m_bViewOrig, D3DCUBEMAP_FACE_POSITIVE_Y, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    m_bTitleModsChanged = TRUE; // force title bar update
    RenderScene();
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnUpdateViewPosY(CCmdUI* pCmdUI)
{
    BOOL bEnable = GetDocument()->IsCubeMap();
    pCmdUI->Enable(bEnable);
    pCmdUI->SetCheck(m_CubeFaceCur == D3DCUBEMAP_FACE_POSITIVE_Y);
}


void CDxtexView::OnViewNegZ()
{
    BuildViewSurface(m_bViewOrig, D3DCUBEMAP_FACE_NEGATIVE_Z, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    m_bTitleModsChanged = TRUE; // force title bar update
    RenderScene();
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnUpdateViewNegZ(CCmdUI* pCmdUI)
{
    BOOL bEnable = GetDocument()->IsCubeMap();
    pCmdUI->Enable(bEnable);
    pCmdUI->SetCheck(m_CubeFaceCur == D3DCUBEMAP_FACE_NEGATIVE_Z);
}


void CDxtexView::OnViewPosZ()
{
    BuildViewSurface(m_bViewOrig, D3DCUBEMAP_FACE_POSITIVE_Z, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    m_bTitleModsChanged = TRUE; // force title bar update
    RenderScene();
    Invalidate(); // force redraw of this view
}


void CDxtexView::OnUpdateViewPosZ(CCmdUI* pCmdUI)
{
    BOOL bEnable = GetDocument()->IsCubeMap();
    pCmdUI->Enable(bEnable);
    pCmdUI->SetCheck(m_CubeFaceCur == D3DCUBEMAP_FACE_POSITIVE_Z);
}

void CDxtexView::OnFileOpenFace()
{
    GetDocument()->OpenCubeFace(m_CubeFaceCur);
}

void CDxtexView::OnUpdateFileOpenFace(CCmdUI* pCmdUI)
{
    BOOL bEnable = (m_CubeFaceCur != D3DCUBEMAP_FACE_FORCE_DWORD);
    pCmdUI->Enable(bEnable);
}

void CDxtexView::OnFileOpenAlphaFace()
{
    GetDocument()->OpenAlphaCubeFace(m_CubeFaceCur);
}

void CDxtexView::OnUpdateFileOpenAlphaFace(CCmdUI* pCmdUI)
{
    BOOL bEnable = (m_CubeFaceCur != D3DCUBEMAP_FACE_FORCE_DWORD);
    pCmdUI->Enable(bEnable);
}

void CDxtexView::OnViewHigherVolumeSlice()
{
    m_lwSliceCur++;
    BuildViewSurface(m_bViewOrig, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    UpdateDevice();
    RenderScene();
    m_bTitleModsChanged = TRUE; // force title bar update
    Invalidate(); // force redraw of this view
}

void CDxtexView::OnUpdateViewHigherVolumeSlice(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(GetDocument()->IsVolumeMap() && m_lwSliceCur < (LONG)GetDocument()->DwDepthAt(m_lwMipCur) - 1);
}

void CDxtexView::OnViewLowerVolumeSlice()
{
    m_lwSliceCur--;
    BuildViewSurface(m_bViewOrig, m_CubeFaceCur, m_lwSliceCur, m_lwMipCur, m_bViewAlpha);
    UpdateDevice();
    RenderScene();
    m_bTitleModsChanged = TRUE; // force title bar update
    Invalidate(); // force redraw of this view
}

void CDxtexView::OnUpdateViewLowerVolumeSlice(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(GetDocument()->IsVolumeMap() && m_lwSliceCur > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__712C53C9_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
#define AFX_STDAFX_H__712C53C9_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <winver.h>
#include <basetsd.h>
#include <d3d8.h>
#include <d3dx8.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.



#endif // !defined(AFX_STDAFX_H__712C53C9_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\MainFrm.Cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "dxtex.h"
#include "MainFrm.h"
#include "DxtexDoc.h"
#include "DxtexView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
    ON_UPDATE_COMMAND_UI(ID_INDICATOR_IMAGEINFO, OnUpdateImageInfo)
END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_IMAGEINFO,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

// Note: I changed the default toolbar creation code so we can still compile with VC5:
//  if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
//      | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
//      !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    if (!m_wndToolBar.Create(this) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

    m_wndStatusBar.SetPaneInfo(1, ID_INDICATOR_IMAGEINFO, SBPS_NORMAL, 220);

    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
void CMainFrame::OnUpdateImageInfo(CCmdUI *pCmdUI)
{
    CString strInfo;

    // Get the active MDI child window.
    CMDIChildWnd *pChild = (CMDIChildWnd *)GetActiveFrame();

    if (pChild != NULL && pChild != (CMDIChildWnd *)this)
    {
        // Get the active view attached to the active MDI child window.
        CDxtexView* pView = (CDxtexView*)pChild->GetActiveView();
        pView->GetImageInfo(strInfo);
        pCmdUI->Enable();
        pCmdUI->SetText(strInfo);
    }
    else
    {
        pCmdUI->Enable(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\XDxTex\MainFrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__712C53CB_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
#define AFX_MAINFRM_H__712C53CB_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CMDIFrameWnd
{
    DECLARE_DYNAMIC(CMainFrame)
public:
    CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
    CStatusBar  m_wndStatusBar;
    CToolBar    m_wndToolBar;

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnUpdateImageInfo(CCmdUI *pCmdUI);
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__712C53CB_D63B_11D1_A8B5_00C04FC2DC22__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\xsasm\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//
//
///////////////////////////////////////////////////////////////////////////

// stdafx.cpp : source file that includes just the standard includes
// vc7.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\xsdasm\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>

#include <windows.h>
#include "d3d8-xbox.h"
#include "../../../private/inc/xboxverp.h"

#include "xgraphics.h"

#define RELEASE(x) \
    do { if(x) { x->Release(); x = NULL; } } while(0)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\xsdasm\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//
//
///////////////////////////////////////////////////////////////////////////

// stdafx.cpp : source file that includes just the standard includes
// vc7.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\xsasm\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>
#ifdef XBOX
#include <xtl.h>
#include <xboxverp.h>
#else
#include <windows.h>
#include "d3d8-xbox.h"
#include "../../../private/inc/xboxverp.h"
#endif

#include "xgraphics.h"

#define RELEASE(x) \
    do { if(x) { x->Release(); x = NULL; } } while(0)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\xsdasm\xsdasm.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//
//
///////////////////////////////////////////////////////////////////////////

// xsdasm shader disassembler
//

#include "stdafx.h"

#ifdef XBOX
#error This is not an Xbox application. It's a command line tool, and there's no command line on Xbox.
#endif

namespace D3D {

void DbgPrint(const char* data,...){
    va_list marker;
    va_start( marker, data);
    char buf[1000];
    _vsnprintf(buf, sizeof(buf)-1, data, marker);
    buf[sizeof(buf)-1] = 0;
    OutputDebugString(buf);
}

// Uncomment this if you want to break into the debugger when an error occurs
// #define BREAK_ON_ERROR

#if defined(DBG) && defined(BREAK_ON_ERROR)
#define SETERROR(HR,CODE) \
    do { \
if(FAILED(HR = CODE)){ \
            DebugBreak(); \
        } \
    } while(0)
#else
#define SETERROR(HR,CODE) \
    HR = CODE
#endif

void stripExtension(char* s)
{
    size_t i = strlen(s);
    while(i){
        if(s[--i]=='.'){
            s[i] = '\0';
            break;
        }
        else if(s[i] == '\\' || s[i] == '/' || s[i] == ':'){
            break;
        }
    }
}

void stripDirectories(char* s)
{
    size_t i = strlen(s);
    while(i){
        if(s[--i]=='/' || s[i] == '\\'){
            i++;
            // Copy in place - it's overlapping, but we're moving in the right direction.
            char* d = &s[i];
            while(*s++ = *d++);
            break;
        }
    }
}

void stripToBaseName(char* s){
    stripDirectories(s);
    stripExtension(s);
}

void ConvertToUnicode(WCHAR* dest, DWORD destSizeBytes, LPCSTR source){
    DWORD destSizeWChars = destSizeBytes / sizeof(WCHAR);
    mbstowcs(dest,source,destSizeWChars);
    dest[destSizeWChars-1] = 0;
}

HRESULT CreateBufferFromFile(const char* path, LPXGBUFFER* ppBuffer){
    HRESULT hr = S_OK;
    if(!path || !ppBuffer){
        SETERROR(hr,E_FAIL);
    }
    HANDLE file = INVALID_HANDLE_VALUE;
    if(SUCCEEDED(hr)){
        file = CreateFile(path,GENERIC_READ,FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
            NULL);
        if(file == INVALID_HANDLE_VALUE){
            fprintf(stderr,"Could not open file: \"%s\".\n", path);
            SETERROR(hr,E_FAIL);
        }
    }
    DWORD size = 0;
    if(SUCCEEDED(hr)){
        size = GetFileSize(file,NULL);
        if(size == ~0){
            SETERROR(hr,E_FAIL);
        }
    }
    LPXGBUFFER pBuffer = NULL;
    if(SUCCEEDED(hr)){
        hr = XGBufferCreate(size, &pBuffer);
    }
    if(SUCCEEDED(hr)){
        DWORD sizeRead;
        BOOL result = ReadFile(file, pBuffer->GetBufferPointer(), size, &sizeRead, NULL);
        if(! result || sizeRead != size){
            SETERROR(hr,E_FAIL);
        }
    }
    if(file != INVALID_HANDLE_VALUE){
        CloseHandle(file);
    }
    if(SUCCEEDED(hr)){
        *ppBuffer = pBuffer;
    }
    else {
        if(pBuffer) pBuffer->Release();
    }
    return hr;
}

HRESULT CreateFileFromBuffer(const char* path, LPXGBUFFER pBuffer){
    HRESULT hr = S_OK;
    if(!path || !pBuffer){
        SETERROR(hr,E_FAIL);
    }
    HANDLE file = INVALID_HANDLE_VALUE;
    if(SUCCEEDED(hr)){
        file = CreateFile(path,GENERIC_WRITE,FILE_SHARE_READ,
            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
            NULL);
        if(file == INVALID_HANDLE_VALUE){
            SETERROR(hr,E_FAIL);
        }
    }
    if(SUCCEEDED(hr)){
        DWORD sizeWritten;
        WriteFile(file,pBuffer->GetBufferPointer(),
            pBuffer->GetBufferSize(), &sizeWritten, NULL);
        if(sizeWritten != pBuffer->GetBufferSize()){
            SETERROR(hr,E_FAIL);
        }
    }
    if(file != INVALID_HANDLE_VALUE){
        CloseHandle(file);
    }
    return hr;
}

BOOL MyDeleteFile(const char* file){
    return DeleteFile(file);
}

    void Banner(){
        fprintf(stdout, "**** XSDASM %s, Copyright (C) 2001 Microsoft Corporation.\n",
            VER_PRODUCTVERSION_STR);
        fprintf(stdout, "****       All Rights Reserved.\n");
        fflush(stdout);
    }

void usage(const char* s){
    Banner();
    if(s){
        fprintf(stderr, "\nError: %s\n", s);
    }
    fprintf(stderr, "\nusage: [-b] ucodeFile <listfile>\n");
    fprintf(stderr, "-b suppress banner.\n");
    fprintf(stderr, "  ucodefile   input file containing vertex shader microcode.\n");
    fprintf(stderr, "  listfile    output file for listing.\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "If you don't specify listfile, it defaults to stdout\n");
    exit(-1);
}

// Secret function Imported from xgraphicslib

extern "C" HRESULT DisassembleVertexShader(LPCVOID pUcode, DWORD length, LPXGBUFFER* pDisassembly);

class Disassembler {
public:
    Disassembler(){
        m_pIn = NULL;
        m_out = NULL;
    }

    ~Disassembler(){
    }

    HRESULT Initialize(LPXGBUFFER in, FILE* out){
        HRESULT hr = S_OK;
        m_pInBuffer = in;
        m_out = out;
        return hr;
    }

    HRESULT Disassemble(){
        HRESULT hr = S_OK;
        m_pIn = (const UCHAR*) m_pInBuffer->GetBufferPointer();
        m_pEnd = m_pIn + m_pInBuffer->GetBufferSize();

        hr = ParseHeader();
        if(SUCCEEDED(hr)){
            hr = ParseBody();
        }
        return hr;
    }

private:

    HRESULT ParseHeader(){
        HRESULT hr = S_OK;
        if(m_pEnd - m_pIn < 4){
            fprintf(stderr, "input file too small to contain a shader.\n");
            SETERROR(hr,E_FAIL);
        }
        if(SUCCEEDED(hr)){
            m_shaderType = XGSUCode_GetVertexShaderType(m_pInBuffer->GetBufferPointer());
            if(m_shaderType == SASMT_INVALIDSHADER){
                fprintf(stderr, "invalid shader type %d.\n", m_shaderType);
                SETERROR(hr,E_FAIL);
            }
        }
        if(SUCCEEDED(hr)){
            static const char* kShaderNames[] = {
                "Vertex",
                "Read/Write Vertex",
                "Vertex State"
            };

            fprintf(m_out, "; This is a %s Shader.\n",
                kShaderNames[m_shaderType-SASMT_VERTEXSHADER]);
        }

        if(SUCCEEDED(hr)){
            m_length = XGSUCode_GetVertexShaderLength(m_pInBuffer->GetBufferPointer());
        }
        if(SUCCEEDED(hr)){
            m_pIn += sizeof(DWORD); // Skip header
        }
        return hr;
    }

    HRESULT ParseBody(){
        HRESULT hr = S_OK;
        
        if ( m_length > 136){
            fprintf(stderr, "Not a valid program. Too many instructions.\n");
//            SETERROR(hr,E_FAIL);
        }
        
        if ( m_length * sizeof(DWORD)*4 != (DWORD) (m_pEnd - m_pIn)){
            fprintf(stderr, "Not a valid program. Number of instructions does not match code length.\n");
            SETERROR(hr,E_FAIL);
        }

        LPXGBUFFER pDisassembly;

        if(SUCCEEDED(hr)){
            hr = DisassembleVertexShader(m_pInBuffer->GetBufferPointer(),
                m_pInBuffer->GetBufferSize(), &pDisassembly);
        }
        if(SUCCEEDED(hr)){
            fwrite(pDisassembly->GetBufferPointer(),
                pDisassembly->GetBufferSize(), 1, m_out);
            pDisassembly->Release();
        }
        return hr;
    }

    const UCHAR* m_pIn;
    const UCHAR* m_pEnd;

    LPXGBUFFER m_pInBuffer;
    FILE* m_out;

    DWORD m_shaderType;
    DWORD m_length; // In instructions
};


HRESULT Disassemble(const char* infile, const char* outfile){
    HRESULT hr = S_OK;

    LPXGBUFFER pInput = NULL;
    hr = CreateBufferFromFile(infile,&pInput);

    FILE* output = stdout;

    if(SUCCEEDED(hr)){
        if(outfile){
            output = fopen(outfile, "wt");
            if(!output){
                fprintf(stderr,"Cannot open output file \"%s\"\n", outfile);
                hr = E_FAIL;
            }
        }
    }

    if(SUCCEEDED(hr)){
        Disassembler d;
        hr = d.Initialize(pInput, output);
        if(SUCCEEDED(hr)){
            hr = d.Disassemble();
        }
    }

    RELEASE(pInput);

    if(output != NULL && output != stdout){
        fclose(output);
    }
    return hr;
}

extern "C"
int __cdecl main(int argc, char* argv[])
{
    const char* inFile = NULL;
    const char* listFile = NULL;
    bool suppressBanner = false;

    for(int i = 1; i < argc;i++){
        const char* arg = argv[i];
        if(arg[0] == '-' || arg[0] == '/'){
            switch(arg[1]){
                case 'b':
                    suppressBanner = true;
                    break;
                default:
                    usage("Unknown flag.");
                }
        }
        else if ( ! inFile ) {
            inFile = arg;
        }
        else if ( ! listFile ) {
            listFile = arg;
        }
        else {
            usage("Unexpected extra file name.");
        }
    }
    if(!inFile){
        usage("Need to specify an input file.");
    }
    if ( ! suppressBanner ) {
        Banner();
    }
    HRESULT hr = Disassemble(inFile,listFile);

    return hr;
}

} // namespace D3D
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\tools\xsasm\xsasm.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//
//
///////////////////////////////////////////////////////////////////////////

// xsasm shader assembler
//

#include "stdafx.h"

// Uncomment this if you want to break into the debugger when an error occurs
// #define BREAK_ON_ERROR

#if defined(DBG) && defined(BREAK_ON_ERROR)
#define SETERROR(HR,CODE) \
    do { \
if(FAILED(HR = CODE)){ \
            DebugBreak(); \
        } \
    } while(0)
#else
#define SETERROR(HR,CODE) \
    HR = CODE
#endif

extern "C" const char* XGraphicsBuildVersion();

void stripExtension(char* s)
{
    size_t i = strlen(s);
    while(i){
        if(s[--i]=='.'){
            s[i] = '\0';
            break;
        }
        else if(s[i] == '\\' || s[i] == '/' || s[i] == ':'){
            break;
        }
    }
}

void stripDirectories(char* s)
{
    size_t i = strlen(s);
    while(i){
        if(s[--i]=='/' || s[i] == '\\'){
            i++;
            // Copy in place - it's overlapping, but we're moving in the right direction.
            char* d = &s[i];
            while(*s++ = *d++);
            break;
        }
    }
}

void stripToBaseName(char* s){
    stripDirectories(s);
    stripExtension(s);
}

void ConvertToUnicode(WCHAR* dest, DWORD destSizeBytes, LPCSTR source){
    DWORD destSizeWChars = destSizeBytes / sizeof(WCHAR);
    mbstowcs(dest,source,destSizeWChars);
    dest[destSizeWChars-1] = 0;
}

HRESULT CreateBufferFromFile(const char* path, LPXGBUFFER* ppBuffer){
    HRESULT hr = S_OK;
    if(!path || !ppBuffer){
        SETERROR(hr,E_FAIL);
    }
    HANDLE file = INVALID_HANDLE_VALUE;
    if(SUCCEEDED(hr)){
        file = CreateFile(path,GENERIC_READ,FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
            NULL);
        if(file == INVALID_HANDLE_VALUE){
            SETERROR(hr,E_FAIL);
        }
    }
    DWORD size = 0;
    if(SUCCEEDED(hr)){
        size = GetFileSize(file,NULL);
        if(size == ~0){
            SETERROR(hr,E_FAIL);
        }
    }
    LPXGBUFFER pBuffer = NULL;
    if(SUCCEEDED(hr)){
        hr = XGBufferCreate(size, &pBuffer);
    }
    if(SUCCEEDED(hr)){
        DWORD sizeRead;
        BOOL result = ReadFile(file, pBuffer->GetBufferPointer(), size, &sizeRead, NULL);
        if(! result || sizeRead != size){
            SETERROR(hr,E_FAIL);
        }
    }
    if(file != INVALID_HANDLE_VALUE){
        CloseHandle(file);
    }
    if(SUCCEEDED(hr)){
        *ppBuffer = pBuffer;
    }
    else {
        if(pBuffer) pBuffer->Release();
    }
    return hr;
}

HRESULT CreateFileFromBuffer(const char* path, LPXGBUFFER pBuffer, BOOL bWritePSHeader){
    HRESULT hr = S_OK;
    if(!path || !pBuffer){
        SETERROR(hr,E_FAIL);
    }
    HANDLE file = INVALID_HANDLE_VALUE;
    if(SUCCEEDED(hr)){
        file = CreateFile(path,GENERIC_WRITE,FILE_SHARE_READ,
            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
            NULL);
        if(file == INVALID_HANDLE_VALUE){
            SETERROR(hr,E_FAIL);
        }
    }
    if(SUCCEEDED(hr)){
        DWORD sizeWritten;
        // write pixel shader header DWORD if requested
        DWORD FileID = D3DPIXELSHADERDEF_FILE_ID;
        if(bWritePSHeader)
            WriteFile(file, &FileID, sizeof(DWORD), &sizeWritten, NULL);

        WriteFile(file,pBuffer->GetBufferPointer(),
            pBuffer->GetBufferSize(), &sizeWritten, NULL);
        if(sizeWritten != pBuffer->GetBufferSize()){
            SETERROR(hr,E_FAIL);
            fprintf(stderr, "Could not write file \"%s\".\n", path);
        }
    }
    else {
        fprintf(stderr, "Could not open file \"%s\" for writing.\n",
            path);
    }
    if(file != INVALID_HANDLE_VALUE){
        CloseHandle(file);
    }
    return hr;
}

BOOL MyDeleteFile(const char* file){
#ifdef XBOX
    return DeleteFile(file);
#else
    wchar_t buf[MAX_PATH];
    ConvertToUnicode(buf, sizeof(buf), file);
    return DeleteFileW(buf);
#endif
}

bool FileExists(const char* fullPath){
    bool fileExists = false;
    DWORD attributes = GetFileAttributes(fullPath);
    if(attributes != 0xFFFFFFFF && ! ( attributes & FILE_ATTRIBUTE_DIRECTORY)){
        fileExists = true;
    }
    return fileExists;
}


class Assembler {
    class Buffer;
    class StringTable;
public:
    Assembler(){
    }

    ~Assembler(){
    }

    int main(int argc, char* argv[])
    {
        CheckXGraphicsVersion();

        const char* inFile = NULL;
        const char* ucodeFile = NULL;
        const char* constFile = NULL;
        const char* listFile = NULL;
        bool suppressBanner = false;
        bool donotoptimize = false;
        bool disableGlobalOptimization = false;
        bool verifyOptimizations = true;
        bool outputTokens = false;
        bool listing = false;
        bool outputAsHeader = false;
        bool inputTokens = false;
        DWORD inputTokensShaderType = 0;
        bool inputMicrocode = false;
        DWORD inputMicrocodeShaderType = 0;
        bool dontValidate = false;
        bool skipPreprocessor = false;
        bool preprocessOnly = false;
        bool generateDebugInfo = false;
        const char* hname = NULL;
        HRESULT hr = S_OK;

        Resolver resolver;

        SETERROR(hr,resolver.Initialize());
        if(FAILED(hr)){
            return hr;
        }

        StringTable defineTable;
        SETERROR(hr,defineTable.Initialize());
        if(FAILED(hr)){
            return hr;
        }

        Buffer base;
        SETERROR(hr,base.Initialize(1024));
        if(FAILED(hr)){
            return hr;
        }

        for(int i = 1; i < argc;i++){
            const char* arg = argv[i];
            if(arg[0] == '-' || arg[0] == '/'){
                switch(arg[1]){
                case 'D':
                    if(arg[2] != '\0') goto unknownFlag;
                    {
                        if(i + 1 >= argc){
                            usage("/D requires an argument");
                            break;
                        }
                        // Is this a -D symbol or a -D symbol=value
                        base.Append("#define ");
                        char* symbol = argv[++i];
                        int offset = strcspn(symbol, "=");
                        // Is this symbol already defined? Use cheap linear search
                        if(defineTable.Exists(symbol, offset)){
                            fprintf(stderr, "This symbol is already defined: -D %s\n", symbol);
                            exit(-2);
                        }
                        defineTable.Add(symbol, offset);
                        base.Append(symbol,offset);
                        if(symbol[offset] == '='){
                            base.Append(' ');
                            base.Append(symbol + offset + 1);
                        }
                        base.Append('\n');
                    }
                    break;

                case 'O':
                    if(arg[2] == 0 || arg[3] != '\0') goto unknownFlag;
                    switch(arg[2]){
                        case 'd':
                            donotoptimize = true;
                            break;
                        case 'g':
                            disableGlobalOptimization = true;
                            break;
                        case 'v':
                            verifyOptimizations = false;
                            break;
                        default:
                            usage("Unrecognized option to /O.");
                            break;
                    }
                    break;
                case 'n':
                    if(strcmp(&arg[1],"nologo") == 0){
                        suppressBanner = true;
                    }
                    else {
                        goto unknownFlag;
                    }
                    break;
                case 'd':
                    if(arg[2] != 0) goto unknownFlag;
                    generateDebugInfo = true;
                    break;
                case 'h':
                    if(strcmp(&arg[1],"help") == 0){
                        goto help;
                    }
                    else if(strcmp(&arg[1],"hname") == 0){
                        if(i + 1 >= argc){
                            usage("/hname requires an argument");
                            break;
                        }
                        hname = argv[++i];
                    }
                    else if(arg[2] != 0) goto unknownFlag;
                    outputAsHeader = true;
                    break;
                case 'l':
                    if(arg[2] != 0) goto unknownFlag;
                    listing = true;
                    break;
                case 'p':
                    if(arg[2] != 0) goto unknownFlag;
                    preprocessOnly = true;
                    break;
                case 'P':
                    if(arg[2] != 0) goto unknownFlag;
                    skipPreprocessor = true;
                    break;
                case 't':
                    if(arg[2] != 0) goto unknownFlag;
                    outputTokens = true;
                    break;
                case 'u':
                    if(arg[2] != 0){
						if(arg[2] == 'u' && arg[3] == 0){
							inputMicrocode = true;
							if(i + 1 >= argc){
								usage("/uu requires an argument");
								break;
							}
							inputMicrocodeShaderType = atoi(argv[++i]);
							break;
						}
						goto unknownFlag;
					}
                    inputTokens = true;
                    if(i + 1 >= argc){
                        usage("/u requires an argument");
                        break;
                    }
                    inputTokensShaderType = atoi(argv[++i]);
                    break;
                case 'v':
                    if(arg[2] != 0) goto unknownFlag;
                    dontValidate = true;
                    break;

                case 'I':
                    if(arg[2] != 0) goto unknownFlag;
                    if(i + 1 >= argc){
                        usage("/I requires an argument");
                        break;
                    }
                    resolver.AddIncludePath(argv[++i]);
                    break;
                case '?':
help:
                    if(arg[2] != 0) goto unknownFlag;
                    usage("Xbox Shader Assembler.");
                    break;
                default:
unknownFlag:
                    {
                        char msgBuf[512];
                        _snprintf(msgBuf,sizeof(msgBuf),"Unknown flag \"%s\"", arg);
                        msgBuf[sizeof(msgBuf)-1]='\0';
                        usage(msgBuf);
                    }
                }
            }
            else if ( ! inFile ) {
                inFile = arg;
            }
            else if ( ! ucodeFile ) {
                ucodeFile = arg;
            }
            else if ( ! constFile ) {
                constFile = arg;
            }
            else if ( ! listFile ) {
                listFile = arg;
            }
            else {
                usage("Unexpected extra file name.");
            }
        }
        if(!inFile){
            usage("Need to specify an input file.");
        }

        if( ! defineTable.IsEmpty() && skipPreprocessor ){
            usage("Can't use /D option and /P option at the same time.");
        }

        if(generateDebugInfo && ! outputTokens){
            usage("/d option requires /t option as well.");
        }

        if(hname && ! outputAsHeader){
            usage("/hname option requires /h option as well.");
        }

        char defaultOutFile[MAX_PATH];
        calculateDefaultOutFile(defaultOutFile, inFile);
        char defaultConstFile[MAX_PATH];
        char defaultListFile[MAX_PATH];
        if(outputAsHeader){
            sprintf(m_defaultUcodeFile,"%s.h",defaultOutFile);
        }
        else {
            sprintf(m_defaultUcodeFile,"%s.x$u",defaultOutFile);
            // We modify the '$' later, once we know whether we've got a pixel shader or a vertex
            // shader
        }

        sprintf(defaultConstFile,"%s.xsc",defaultOutFile);
        sprintf(defaultListFile,"%s.lst",defaultOutFile);
        // fill in default filenames if necessary
        // delete old files (listing file deleted here,
        // other files deleted after assembly is done)
        if(!ucodeFile){
            ucodeFile = m_defaultUcodeFile;
        }
        if(!constFile){
            constFile = defaultConstFile;
        }
        
        if(!listFile && listing){
            listFile = defaultListFile;
            MyDeleteFile(listFile);
        }
        else{
            MyDeleteFile(defaultListFile);
        }

		if(inputTokens || inputMicrocode){
			skipPreprocessor = true;
		}

        DWORD flags = 0;
        if (generateDebugInfo) flags |= SASM_DEBUG; 
        if (donotoptimize) flags |= SASM_DONOTOPTIMIZE; 
        if (disableGlobalOptimization) flags |= SASM_DISABLE_GLOBAL_OPTIMIZATIONS; 
        if (verifyOptimizations) flags |= SASM_VERIFY_OPTIMIZATIONS; 
        if (outputTokens) flags |= SASM_OUTPUTTOKENS;
        if (dontValidate) flags |= SASM_SKIPVALIDATION;
        if (preprocessOnly) flags |= SASM_PREPROCESSONLY;
        if (skipPreprocessor) flags |= SASM_SKIPPREPROCESSOR;
        if (inputTokens){
            switch(inputTokensShaderType){
            case 0: flags |= SASM_INPUT_PIXELSHADER_TOKENS;
                break;
            case 1: flags |= SASM_INPUT_VERTEXSHADER_TOKENS;
                break;
            case 2: flags |= SASM_INPUT_READWRITE_VERTEXSHADER_TOKENS;
                break;
            case 3: flags |= SASM_INPUT_VERTEXSTATESHADER_TOKENS;
                break;
            case 4: flags |= SASM_INPUT_VERTEXSHADER_TOKENS
                          | SASM_INPUT_SCREENSPACE_VERTEXSHADER_TOKENS;
                break;
            case 5: flags |= SASM_INPUT_READWRITE_VERTEXSHADER_TOKENS
                          | SASM_INPUT_SCREENSPACE_VERTEXSHADER_TOKENS;
                break;
            case 6: flags |= SASM_INPUT_VERTEXSHADER_TOKENS
                          | SASM_INPUT_NONXBOX_TOKENS;
                break;
            default:
                usage("unknown numeric argument to /u. Expected (0..5)");
                break;
            }
		}
		if (inputMicrocode){
			switch(inputMicrocodeShaderType){
			case 0: flags |= SASM_INPUT_MICROCODE;
				break;
			case 1: flags |= SASM_INPUT_SCREENSPACE_MICROCODE;
				break;
			default:
				usage("unknown numeric argument to /uu. Expected (0..1)");
				break;
			}
		}

        if ( ! suppressBanner ) {
            Banner();
        }
        hr = Assemble(inFile,constFile,ucodeFile,listFile,
            outputAsHeader, hname,
            flags,
            ResolverCallback, &resolver,
            skipPreprocessor ? NULL : &base);

        return hr;
    }

private:

#define INTERNAL_BUFFER_NAME ":internal buffer"

    HRESULT CreateHeaderFile(const char* headerFile, LPXGBUFFER ucodeBuffer,
                             LPXGBUFFER constBuffer, bool isTokens, DWORD shaderType,
                             const char* hname){
        HRESULT hr = S_OK;
        // Use stdio because it's nice to be able to use printf
        FILE* out = fopen(headerFile, "wt");
        if(!out){
            SETERROR(hr,E_FAIL);
        }

        char baseName[MAX_PATH];
        strncpy(baseName, headerFile, MAX_PATH);
        baseName[MAX_PATH-1] = '\0';
        stripToBaseName(baseName);

        // Capitalize first letter of base name for neatness

        if(baseName[0] >= 'a' && baseName[0] <= 'z'){
            baseName[0] -= 'a' - 'A';
        }

        const char* kShaderTypes[] = {"Pixel", "Vertex", "ReadWriteVertex", "VertexState"};

        char nameBuf[MAX_PATH];
        if(!hname){
            _snprintf(nameBuf, sizeof(nameBuf),"dw%s%sShader", baseName,
                kShaderTypes[SASMT_SHADERTYPE(shaderType)]);
            nameBuf[MAX_PATH-1] = 0;
            hname = nameBuf;
        }

        if(SUCCEEDED(hr) && ucodeBuffer && ucodeBuffer->GetBufferSize()){
            fprintf(out,"DWORD %s[] = {\n", hname);
            DWORD numDWORDS = ucodeBuffer->GetBufferSize() / sizeof(DWORD);
            DWORD* code = (DWORD*) ucodeBuffer->GetBufferPointer();
            for(DWORD i = 0; i < numDWORDS; i++){
                if((i == 0) || (((i-1) % 4) == 0) ){
                    fprintf(out, "\t");
                }
                fprintf(out, "0x%08x", code[i]);
                if(i < numDWORDS-1){
                    fprintf(out, ",");
                    if((i != 0) && (((i-1) % 4) < 3)){
                        fprintf(out, " ");
                    }
                    else {
                        fprintf(out, "\n");
                    }
                }
            }
            fprintf(out, "\n};\n");
        }
        // Now, write constant data

        if(SUCCEEDED(hr) && constBuffer && constBuffer->GetBufferSize()){
            // Write a seperating space if there's both ucode data and const data
            if(ucodeBuffer && ucodeBuffer->GetBufferSize()){
                fprintf(out, "\n");
            }
            fprintf(out,"DWORD dw%s%sShaderConstantData[] = {\n", baseName, kShaderTypes[shaderType]);
            DWORD numDWORDS = constBuffer->GetBufferSize() / sizeof(DWORD);
            DWORD* code = (DWORD*) constBuffer->GetBufferPointer();
            for(DWORD i = 0; i < numDWORDS; i++){
                if(i % 5 == 0 ){
                    fprintf(out, "\t");
                }
                fprintf(out, "0x%08x", code[i]);
                if(i < numDWORDS-1){
                    fprintf(out, ",");
                    if(i % 5 < 4){
                        fprintf(out, " ");
                    }
                    else {
                        fprintf(out, "\n");
                    }
                }
            }
            fprintf(out, "\n};\n");
        }

        if(out){
            fclose(out);
        }
        return hr;
    }

    HRESULT Assemble(const char* shaderFile,
        const char* constFile,
        const char* ucodeFile,
        const char* listFile,
        bool outputAsHeader,
        const char* hname,
        DWORD flags,
        SASM_ResolverCallback pResolver,
        LPVOID pResolverUserData,
        Buffer* pBase)
    {
        LPXGBUFFER shaderBuffer = NULL;
        LPXGBUFFER ucodeBuffer = NULL;
        LPXGBUFFER constBuffer = NULL;
        LPXGBUFFER errorBuffer = NULL;
        LPXGBUFFER listBuffer = NULL;

        HRESULT hr = S_OK;
        if( pBase ) {
            // Check if file exists...
            if(! FileExists(shaderFile)){
                fprintf(stderr, "Could not open file \"%s\".\n", shaderFile);
                hr = E_FAIL;
            }
            else {
                pBase->Printf("#include \"%s\"\n", shaderFile);
            }
        }
        else {
            hr = CreateBufferFromFile(shaderFile, &shaderBuffer);
			if(FAILED(hr)){
                fprintf(stderr, "Could not read file \"%s\".\n", shaderFile);
			}
        }

        DWORD shaderType = SASMT_VERTEXSHADER;

        if(SUCCEEDED(hr)){

            hr = AssembleShader(
                shaderFile,
                shaderBuffer ? shaderBuffer->GetBufferPointer() : pBase->GetText(),
                shaderBuffer ? shaderBuffer->GetBufferSize() : pBase->GetUsed(),
                flags,
                constFile ? &constBuffer : NULL,
                ucodeFile ? &ucodeBuffer : NULL,
                &errorBuffer,
                listFile ? &listBuffer : NULL,
                pResolver, pResolverUserData,
                &shaderType);
        }
        // Delete the old output files no matter what
        if(! outputAsHeader ) {
            if(constFile && (SASMT_SHADERTYPE(shaderType) != SASMT_PIXELSHADER)){
                MyDeleteFile(constFile);
            }
            // Fill in default file name extension, now that we know what kind of shader
            // we've got.
            if(ucodeFile == m_defaultUcodeFile){
                char c = 'v';
                if(SASMT_SHADERTYPE(shaderType) == SASMT_PIXELSHADER){
                    c = 'p';
                }
                DWORD offset = strlen(m_defaultUcodeFile) - 2; // Location of '$'
                m_defaultUcodeFile[offset] = c;
            }
        }

        if(ucodeFile){
            MyDeleteFile(ucodeFile);
        }
        if(SUCCEEDED(hr)){
            if(outputAsHeader){
                if(SUCCEEDED(hr)){
                    if(ucodeFile && (ucodeBuffer && ucodeBuffer->GetBufferSize())
                        || (constBuffer && constBuffer->GetBufferSize())){
                        bool isTokens = (flags & SASM_OUTPUTTOKENS) != 0;
                        hr = CreateHeaderFile(ucodeFile, ucodeBuffer, constBuffer, isTokens, shaderType, hname);
                    }
                }
            }
            else {
                if(SUCCEEDED(hr)){
                    if(constFile && constBuffer && constBuffer->GetBufferSize() ){
                        hr = CreateFileFromBuffer(constFile, constBuffer, FALSE);
                    }
                }
                if(SUCCEEDED(hr)){
                    if(ucodeFile && ucodeBuffer && ucodeBuffer->GetBufferSize()){
                        bool isTokens = (flags & SASM_OUTPUTTOKENS) != 0;
                        bool writePixelShaderHeader = (!isTokens) && (SASMT_SHADERTYPE(shaderType) == SASMT_PIXELSHADER);
                        hr = CreateFileFromBuffer(ucodeFile, 
                                                  ucodeBuffer, 
                                                  writePixelShaderHeader );
                    }
                }
            }
        }
        if(SUCCEEDED(hr)){
            if(listFile && listBuffer && listBuffer->GetBufferSize()){
                hr = CreateFileFromBuffer(listFile, listBuffer, FALSE);
            }
        }

        if(errorBuffer && errorBuffer->GetBufferSize()){
            fwrite(errorBuffer->GetBufferPointer(), errorBuffer->GetBufferSize(), 1, stderr);
        }

        RELEASE(shaderBuffer);
        RELEASE(listBuffer);
        RELEASE(constBuffer);
        RELEASE(ucodeBuffer);
        RELEASE(errorBuffer);
        return hr;
    }

    void Banner(){
        fprintf(stdout, "Microsoft (R) Xbox Shader Assembler Version %s\n", VER_PRODUCTVERSION_STR);
        fprintf(stdout, "Copyright (C) 2001 Microsoft Corporation. All rights reserved.\n");
        fflush(stdout);
    }

    void CheckXGraphicsVersion(){
        // Make sure we're linked with the corresponding version of XGraphics.
        const char* xgbv =  XGraphicsBuildVersion();
        if(strcmp(VER_PRODUCTVERSION_STR, xgbv) != 0){
            fprintf(stderr, "Error: Build version mismatch.\n");
            fprintf(stderr, "xsasm.exe     is from build %s\n",VER_PRODUCTVERSION_STR);
            fprintf(stderr, "xgraphics.lib is from build %s\n", xgbv);
            exit(3);
        }
    }

    void usage(const char* s){
        Banner();
        if(s){
            fprintf(stderr, "\nError: %s\n", s);
        }
		//               01234567890123456789012345678901234567890123456789012345678901234567890123456789
        fprintf(stderr, "\nusage: [/O[dgv]][/D symbol][/b][/d][/h][/l][/p][/P][/t][/u num][/v]\n");
        fprintf(stderr, "           [/I path] sourcefile <ucodefile> <constfile> <listfile>\n");
        fprintf(stderr, "  /D symbol   Define symbol.\n");
        fprintf(stderr, "                /D symbol=value   Define symbol to have a specific value.\n");
        fprintf(stderr, "  /Od         Turn off all optimization.\n");
        fprintf(stderr, "  /Og         Turn off just global optimization.\n");
        fprintf(stderr, "  /Ov         Turn off optimization verification.\n");
        fprintf(stderr, "  /d          Generate debugging information for DX8 token stream.\n");
        fprintf(stderr, "                Requires /t option.\n");
        fprintf(stderr, "  /h          Output as a .h file.\n");
        fprintf(stderr, "  /hname sym  Use sym as the name of the variable defined in the .h file.\n");
        fprintf(stderr, "                Requires /h option.\n");
        fprintf(stderr, "  /l          Generate a listing.\n");
        fprintf(stderr, "  /nologo     Suppress copyright message.\n");
        fprintf(stderr, "  /p          Only run preprocessor. Put preprocessor output in ucodeFile.\n");
        fprintf(stderr, "  /P          Skip preprocessor. (If you specify both /p and /P you\n");
        fprintf(stderr, "                copy sourcefile to ucodeFile.)\n");
        fprintf(stderr, "  /t          Generate D3D8 tokens instead of NV2A microcode.\n");
        fprintf(stderr, "  /u num      Input is D3D8 tokens instead of assembly source.\n");
        fprintf(stderr, "              num is: 0 pixel shader\n");
        fprintf(stderr, "                      1 vertex shader\n");
        fprintf(stderr, "                      2 read/write vertex shader\n");
        fprintf(stderr, "                      3 vertex state shader\n");
        fprintf(stderr, "                      4 screenspace vertex shader\n");
        fprintf(stderr, "                      5 screenspace read/write vertex shader\n");
        fprintf(stderr, "                      6 ordinary non-Xbox vertex shader\n");
		fprintf(stderr, "  /uu num     Input is microcode instead of assembly source.\n");
        fprintf(stderr, "              num is: 0 normal microcode\n");
        fprintf(stderr, "                      1 screenspace microcode\n");
        fprintf(stderr, "  /v          Do not validate the shader.\n");
        fprintf(stderr, "  /I path     Set Include search path.\n");
        fprintf(stderr, "  shaderfile  source file for shader.\n");
        fprintf(stderr, "  ucodefile   output file for microcode.\n");
        fprintf(stderr, "  constfile   output file for shader constants file.\n");
        fprintf(stderr, "  listfile    output file for listing.\n");
        fprintf(stderr, "\n");
        fprintf(stderr, "If you don't specify ucodefile, it defaults to file.xpu for pixel shaders,\n");
        fprintf(stderr, "                                            or file.xvu for vertex shaders.\n");
        fprintf(stderr, "If you don't specify constfile, it defaults to file.xsc\n");
        fprintf(stderr, "If you don't specify listfile,  it defaults to file.lst\n");
        fprintf(stderr, "(where 'file' is the name of the shader file, not including the extension.)\n");
    #ifdef XBOX
        _asm int 3 // Breakpoint
    #else
        exit(-1);
    #endif
    }

    void calculateDefaultOutFile(char* out, const char* in){
        strcpy(out, in);
        stripExtension(out);
    }

    static HRESULT ResolverCallback(LPVOID pResolverUserData,
            BOOL isSystemInclude, LPCSTR sourceFilePath,
            LPCSTR includeFileName,
            LPSTR resolvedFilePath, DWORD resolvedFilePathSize,
            LPXGBUFFER* ppResolvedFile)
    {
        return ((Resolver*) pResolverUserData)->Resolve(isSystemInclude, sourceFilePath,
            includeFileName, resolvedFilePath, resolvedFilePathSize, ppResolvedFile);
    }


private:
    char m_defaultUcodeFile[MAX_PATH];

    class Buffer {
        DWORD m_size;
        char* m_buf;
        DWORD m_used;
    public:
        Buffer(){
            m_size = 0;
            m_buf = 0;
            m_used = 0;
        }

        ~Buffer(){
            delete [] m_buf;
        }

        HRESULT Initialize(DWORD size){
            m_used = 0;
            return GrowTo(size);
        }

        HRESULT GrowTo(DWORD size){
            HRESULT hr = S_OK;
            if(size + 1 > m_size){
                size += 4*1024;
                char* newBuf = new char[size];
                if(!newBuf){
                    hr = E_OUTOFMEMORY;
                }
                else{
                    memcpy(newBuf,m_buf, m_used);
                    delete [] m_buf;
                    m_buf = newBuf;
                    m_size = size;
                    m_buf[m_used] = 0;
                }
            }
            return hr;
        }

        void Printf(const char* msg,...){
            if(m_size - m_used < 1000){
                GrowTo(m_size + 2000);
            }
            va_list list;
            va_start(list, msg );
            m_used += _vsnprintf(m_buf + m_used, m_size - m_used, msg, list);
            va_end(list);
        }

        HRESULT Append(LPCVOID data, DWORD length){
            HRESULT hr = GrowTo(m_used + length);
            if(SUCCEEDED(hr)){
                memcpy(m_buf + m_used, data, length);
                m_used += length;
                m_buf[m_used] = '\0';
            }
            return hr;
        }

        HRESULT Append(char c){
            return Append(&c, sizeof(char));
        }

        HRESULT Append(const char* c){
            return Append(c, strlen(c));
        }

        HRESULT Append(Buffer& buffer){
            return Append(buffer.GetText(), buffer.GetUsed());
        }


        char* GetText(){
            return m_buf;
        }

        char* GetTextEnd(){
            return m_buf + m_used;
        }

        DWORD GetUsed(){
            return m_used;
        }

        void Clear(){
            m_used = 0;
            if(m_buf){
                m_buf[0] = 0;
            }
        }
    };

    class StringTable {
        Buffer m_buf;
    public:
        HRESULT Initialize(){
            return m_buf.Initialize(100);
        }

        bool IsEmpty(){
            return m_buf.GetUsed() == 0;
        }

        bool Exists(const char* symbol, DWORD length){
            // Search for symbol in a buffer.
            // Organization of buffer is packed null terminated strings
            for(const char* word = First(); word; word = Next(word)){
                if( strncmp(word, symbol, length) == 0 && word[length] == '\0'){
                    return true; // Found name
                }
            }
            // Not found
            return false;
        }

        HRESULT Add(const char* symbol, DWORD length){
            HRESULT hr = S_OK;
            hr = m_buf.Append(symbol,length);
            if(SUCCEEDED(hr)){
                hr = m_buf.Append('\0');
            }
            return hr;
        }
        const char* First(){
            if(m_buf.GetUsed() == 0){
                return NULL;
            }
            return m_buf.GetText();
        }
        const char* Next(const char* current){
            const char* next = current + strlen(current) + 1;
            if(next >= m_buf.GetTextEnd()){
                return NULL;
            }
            return next;
        }
    };

    /* The rules for #include files
    
        If it's a system include, search in the list of directories
        specified with AddIncludePath

        If it's not a system include, first search in the directory
        of the sourceFile, then in the list of directories specified
        with AddIncludePath.

        Include directories are specified with or without the trailing
        slash.
    */
    class Resolver {
    public:
        Resolver(){
        }

        HRESULT Initialize(){
            m_bisFirstInclude = TRUE;
            return m_includePaths.Initialize();
        }

        HRESULT Resolve(BOOL isSystemInclude, LPCSTR sourceFilePath,
            LPCSTR includeFileName,
            LPSTR resolvedFilePath, DWORD resolvedFilePathSize,
            LPXGBUFFER* ppResolvedFile)
        {
            HRESULT hr = S_OK;
            char fullPath[MAX_PATH];
            bool foundFile = false;
            if(SUCCEEDED(hr)){

                // We know that the very first time we're called
                // it's from the internal bufer that we use to
                // define symbols that were defined from the command
                // line using the -D flag.

                if(m_bisFirstInclude){
                    m_bisFirstInclude = FALSE;
                    strncpy(fullPath, includeFileName, sizeof(fullPath));
                    fullPath[sizeof(fullPath)-1] = '\0';
                    foundFile = FileExists(fullPath);
                    if(!foundFile){
                        SETERROR(hr,E_FAIL);
                    }
               }
            }
            if(SUCCEEDED(hr) && ! foundFile){
                if(! isSystemInclude ) {
                    // First, search relative to the source file path

                    // Strip off the file name
                    char sourceDir[MAX_PATH];
                    CalculateDirectoryPath(sourceDir, sizeof(sourceDir), sourceFilePath);
                    if(sourceDir[0]){
                        sprintf(fullPath, "%s\\%s", sourceDir, includeFileName);
                        foundFile = FileExists(fullPath);
                    }
                    else {
                        strncpy(fullPath, includeFileName, sizeof(fullPath));
                        fullPath[sizeof(fullPath)-1] = '\0';
                        foundFile = FileExists(fullPath);
                    }
                }
            }
            if(SUCCEEDED(hr) && ! foundFile){
                for(const char* includePath = m_includePaths.First();
                    includePath && SUCCEEDED(hr);
                    includePath = m_includePaths.Next(includePath) )
                {
                    // Allow backslashes at the end of include paths.
                    // Required to handle the edge cases of "\" and "C:\"

                    DWORD includePathLength = strlen(includePath);
                    if(includePathLength && includePath[includePathLength-1] == '\\'){
                        sprintf(fullPath, "%s%s", includePath, includeFileName);
                    }
                    else {
                        sprintf(fullPath, "%s\\%s", includePath, includeFileName);
                    }
                    foundFile = FileExists(fullPath);
                    if(foundFile){
                        break;
                    }
                }
            }
            if(SUCCEEDED(hr)){
                if( !foundFile ){ 
                    strcpy(fullPath, includeFileName);
                    fullPath[sizeof(fullPath)-1] = '\0';
                    foundFile = FileExists(fullPath);
                }
            }

            if(SUCCEEDED(hr)){
                if(foundFile){
                    hr = CreateBufferFromFile(fullPath, ppResolvedFile);
                }
                else {
                    SETERROR(hr,E_FAIL);
                }
            }

            if(SUCCEEDED(hr)){
                strncpy(resolvedFilePath, fullPath, resolvedFilePathSize);
            }

            return hr;
        }

        HRESULT AddIncludePath(LPSTR includePath){
            return m_includePaths.Add(includePath,strlen(includePath));
        }
    private:

        void CalculateDirectoryPath(char* dirPath, DWORD dirPathSize, const char* sourceFileName){
            // Find last slash
            if(dirPathSize == 0){
                return;
            }
            const char* pLastSlash = 0;
            for(const char* s = sourceFileName; *s; s++){
                if(*s == '\\'){
                    pLastSlash = s;
                }
            }
            DWORD size = 0;
            if(pLastSlash != 0){
                size = pLastSlash - sourceFileName; // Includes slash
            }
            if(size > dirPathSize-1){
                size = dirPathSize-1;
            }
            if(size > 0){
                memcpy(dirPath, sourceFileName, size);
            }
            dirPath[size] = '\0';
        }

        bool m_bisFirstInclude;

        StringTable m_includePaths;
    };

};

#ifdef XBOX

void __cdecl main()
{
    // TODO: Parse the command line into an argv argc pair.
    Assembler assembler;
    assembler.main(0,0);
}
#else
int __cdecl main(int argc, char* argv[])
{
    Assembler assembler;
    return assembler.main(argc,argv);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\library\bitmap.cpp ===
//****************************************************************************
//
// XBox bitmap font library
//
// History:
//
//   07/06/00 [andrewso] - Created
//   08/04/00 [andrewso] - Added compressed glyph bitmaps
//
//****************************************************************************

// This is a C++ file so we can take advantage of inheritance to extend
// the font data structure.

#ifdef _XBOX

#include <xtl.h>
#include "xfont.h"
#include "xfontformat.h"

#else 

#include <windows.h>
#include "xfont-pc.h"
#include "xfontformat-pc.h"

#endif

#include <assert.h>
#include "font.h"

//****************************************************************************
// Definitions.
//****************************************************************************

// Holds the font information.
struct BP_Font : public Font
{

    // If the font file is smaller than the cache size, then we'll just
    // load it into this memory location and look it up directly.
    //
    void *pMemory;
    FontHeader *pHeader;
    DWORD *rgoGlyphs;
    SegmentRun *pSegmentRunTable;
    SegmentDescriptor *pSegmentTable;
    
    // If the file won't fit into the cache or we've been asked to use
    // minimal memory, then we'll manually munge through the file
    // for every character.
    //
    HANDLE hFile;

    // The location of the tables inside of the file.
    DWORD oGlyphOffsets;
    DWORD oSegmentRunTable;
    DWORD oSegmentTable;

};

// Random forwards.
static void __stdcall BP_UnloadFont(struct BP_Font *);
static HRESULT __stdcall BP_ResetTransform(struct BP_Font *);
static HRESULT __fastcall BP_GetCharacterDataFromMemory(struct BP_Font *, WCHAR, struct _Glyph **, unsigned *);
static HRESULT __fastcall BP_GetCharacterDataFromFile(struct BP_Font *, WCHAR, struct _Glyph **, unsigned *);

//****************************************************************************
// APIs.
//****************************************************************************

//============================================================================
// Open a TrueType font from a block of memory.
//============================================================================

HRESULT __stdcall BP_OpenBitmapFontFromMemory
(
    CONST void *pFontData, 
    unsigned uFontDataSize, 
    struct _Font **ppFont
)
{
    HRESULT hr;
    BP_Font *pFont;
    FontHeader *pHeader;

    HANDLE hFile = INVALID_HANDLE_VALUE;

    // Allocate the memory for the font structure and zero it.
    pFont = (BP_Font *)malloc(sizeof(BP_Font));

    if (!pFont)
    {
        return E_OUTOFMEMORY;
    }

    ZeroMemory(pFont, sizeof(BP_Font));

    pFont->hFile = INVALID_HANDLE_VALUE;

    // Get the header.
    pHeader = (FontHeader *)pFontData;

    // Do a sanity check.
    if (pHeader->wSignature != (WORD)'XFNT')
    {
        hr = E_FAIL;
        goto Error;
    }

    if (pHeader->wVersion != FILE_VERSION)
    {
        hr = E_FAIL;
        goto Error;
    }

    // Set up the tables.
    pFont->rgoGlyphs = (DWORD *)(pHeader + 1);
    pFont->pSegmentRunTable = (SegmentRun *)(pFont->rgoGlyphs + pHeader->cGlyphs);
    pFont->pSegmentTable = (SegmentDescriptor *)(pFont->pSegmentRunTable + pHeader->cSegmentRunTable);

    // Save font info.
    pFont->uCellHeight = pHeader->uCellHeight;
    pFont->uDescent = pHeader->uDescent;
    pFont->uAntialiasLevel = pHeader->uAntialiasLevel;
    pFont->uRLEWidth = pHeader->uRLEWidth;
    pFont->uMaxBitmapHeight = pHeader->uMaxBitmapHeight;
    pFont->uMaxBitmapWidth = pHeader->uMaxBitmapWidth;
    pFont->uReferenceCount = 1;

    // So we'll get the data the right way.
    pFont->pfnGetCharacterData = (CB_GetCharacterData)BP_GetCharacterDataFromMemory;

    // Set up the callbacks.
    pFont->pfnUnloadFont = (CB_UnloadFont)BP_UnloadFont;
    pFont->pfnResetTransform = (CB_ResetTransform)BP_ResetTransform;

    pFont->pHeader = pHeader;

    // Return it.
    *ppFont = (Font *)pFont;

    return NOERROR;

Error:
    BP_UnloadFont(pFont);

    return hr;
}

//============================================================================
// Open a TrueType font.
//============================================================================

HRESULT __stdcall BP_OpenBitmapFont
(
    LPCWSTR wszFileName, 
    unsigned uCacheSize,
    Font **ppFont,
    BOOL *pfUseCache
)
{
    HRESULT hr;
    BP_Font *pFont = NULL;

    HANDLE hFile = INVALID_HANDLE_VALUE;

    char szFile[_MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, wszFileName, -1, szFile, _MAX_PATH, NULL, NULL);

    // Open the font file.
    hFile = CreateFileA(szFile, 
                       GENERIC_READ, 
                       FILE_SHARE_READ, 
                       NULL, 
                       OPEN_EXISTING, 
                       FILE_ATTRIBUTE_NORMAL, 
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

    // Get the file's size.
    BY_HANDLE_FILE_INFORMATION FileInformation;

    if (!GetFileInformationByHandle(hFile, &FileInformation))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

    assert(FileInformation.nFileSizeHigh == 0);

    // If the cache will hold the entire file, load it in.
    if (FileInformation.nFileSizeLow <= uCacheSize)
    {
        void *pMemory;

        // Allocate the memory to hold the font file.
        pMemory = malloc(FileInformation.nFileSizeLow);

        if (!pMemory)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        // Load the font.
        DWORD dwRead;

        if (!ReadFile(hFile, pMemory, FileInformation.nFileSizeLow, &dwRead, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }

        hr = BP_OpenBitmapFontFromMemory((CONST void *)pMemory, FileInformation.nFileSizeLow, (Font **)&pFont);

        if (FAILED(hr))
        {
            free(pMemory);
            goto Error;
        }

        pFont->pMemory = pMemory;

        // We don't want to use the real cache.
        *pfUseCache = FALSE;

        CloseHandle(hFile);
    }

    // Otherwise load the header and save the info we need from it.
    else
    {
        FontHeader Header;

        // Allocate the memory for the font structure and zero it.
        pFont = (BP_Font *)malloc(sizeof(BP_Font));

        if (!pFont)
        {
            goto Error;
        }

        ZeroMemory(pFont, sizeof(BP_Font));

        pFont->hFile = INVALID_HANDLE_VALUE;

        // Load the font's header.
        DWORD dwRead;

        if (!ReadFile(hFile, &Header, sizeof(FontHeader), &dwRead, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }

        // Do some sanity checks.
        if (Header.wSignature != (WORD)'XFNT')
        {
            hr = E_FAIL;
            goto Error;
        }

        if (Header.wVersion != FILE_VERSION)
        {
            hr = E_FAIL;
            goto Error;
        }

        // Remember where everything is in the file.
        pFont->oGlyphOffsets = sizeof(FontHeader);
        pFont->oSegmentRunTable = pFont->oGlyphOffsets + sizeof(DWORD) * Header.cGlyphs;
        pFont->oSegmentTable = pFont->oSegmentRunTable + sizeof(SegmentRun) * Header.cSegmentRunTable;

        // Save font info.
        pFont->uCellHeight = Header.uCellHeight;
        pFont->uDescent = Header.uDescent;
        pFont->uAntialiasLevel = Header.uAntialiasLevel;
        pFont->uRLEWidth = Header.uRLEWidth;
        pFont->uMaxBitmapHeight = Header.uMaxBitmapHeight;
        pFont->uMaxBitmapWidth = Header.uMaxBitmapWidth;
        pFont->uReferenceCount = 1;

        // So we'll get the data the right way.
        pFont->pfnGetCharacterData = (CB_GetCharacterData)BP_GetCharacterDataFromFile;

        // Save the file handle and tell the xfont package to use its cache.
        pFont->hFile = hFile;
        *pfUseCache = TRUE;

        // Set up the callbacks.
        pFont->pfnUnloadFont = (CB_UnloadFont)BP_UnloadFont;
        pFont->pfnResetTransform = (CB_ResetTransform)BP_ResetTransform;
    }

    // Return it.
    *ppFont = (Font *)pFont;

    return NOERROR;

Error:
    if (pFont)
    {
        BP_UnloadFont(pFont);
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    return hr;
}

//****************************************************************************
// Callbacks to store in the Font structure.
//****************************************************************************

//============================================================================
// Free all memory associated with the font.
//============================================================================

static void __stdcall BP_UnloadFont
(
    struct BP_Font *pFont
)
{
    if (pFont->hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(pFont->hFile);
    }

    free(pFont->pMemory);
    free(pFont);
}

//============================================================================
// Reset the size, alpha, etc of the font.
//============================================================================

static HRESULT __stdcall BP_ResetTransform
(
    struct BP_Font *pFont
)
{
    // Can't reset a bitmap font.
    return E_FAIL;
}

//============================================================================
// Get the data and bitmap information for one character.
//============================================================================

static HRESULT __fastcall BP_GetCharacterDataFromMemory
(
    BP_Font *pFont, 
    WCHAR wch, 
    struct _Glyph **ppGlyph,
    unsigned *pcbGlyphSize
)
{
    HRESULT hr;

    SegmentDescriptor *pSegment;
    unsigned iGlyphData;
    unsigned uMask;

    // Break the character up.
    unsigned uSegment = CHAR_SEGMENT(wch);
    unsigned uOffset = CHAR_OFFSET(wch);

    // Find its segment in the segment run table.
    SegmentRun *pRun = pFont->pSegmentRunTable;
    SegmentRun *pRunMax = pRun + pFont->pHeader->cSegmentRunTable;

    for (;;)
    {
        if (pRun == pRunMax)
        {
            goto NotFound;
        }

        if (uSegment >= pRun->wFirstSegment && uSegment < (unsigned)pRun->wFirstSegment + pRun->cSegments)
        {
            break;
        }

        pRun++;
    }

    // Get the segment.
    pSegment = pFont->pSegmentTable + pRun->iSegmentTable + uSegment - pRun->wFirstSegment;

    // Calculate the glyph data index.
    iGlyphData = pSegment->iGlyph;
    uMask = pSegment->wCharMask;

    if (!(uMask & (1 << uOffset)))
    {
        goto NotFound;
    }

    // Mask all the bits under this one.
    uMask &= (1 << uOffset) - 1;

    // Count them.
    while (uMask)
    {
        iGlyphData++;

        uMask &= uMask - 1;
    }

    // We have a winner.
    *ppGlyph = (Glyph *)((BYTE *)pFont->pHeader + pFont->rgoGlyphs[iGlyphData]);
    *pcbGlyphSize = pFont->rgoGlyphs[iGlyphData + 1] - pFont->rgoGlyphs[iGlyphData];

    return NOERROR;

NotFound:
    // Recurse with the default character.
    if (wch != pFont->pHeader->wDefaultChar)
    {
        hr = BP_GetCharacterDataFromMemory(pFont, pFont->pHeader->wDefaultChar, ppGlyph, pcbGlyphSize);

        if (FAILED(hr))
        {
            return hr;
        }
        else
        {
            return S_FALSE;
        }
    }

    return E_FAIL;
}

//============================================================================
// Get the data and bitmap information for one character by munging through
// the file.
//
// This may look slow, but it seems to work just fine on Win2k.  It will
// be interesting to see how well it works on the Xbox, though..
//============================================================================

static HRESULT __fastcall BP_GetCharacterDataFromFile
(
    BP_Font *pFont, 
    WCHAR wch, 
    struct _Glyph **ppGlyph,
    unsigned *pcbGlyphSize
)
{
    HRESULT hr;

    Glyph *pGlyph;

    unsigned iGlyphData;
    unsigned uMask;

    // Break the character up.
    unsigned uSegment = CHAR_SEGMENT(wch);
    unsigned uOffset = CHAR_OFFSET(wch);

    DWORD dwRead, o;
    
    unsigned i, c = (pFont->oSegmentTable - pFont->oSegmentRunTable) / sizeof(SegmentRun);

    // Find its segment in the segment run table.
    SegmentRun Run;
    SegmentDescriptor Segment;
    DWORD rgGlyphOffsets[2];

    // Seek to the right offset.
    if (SetFilePointer(pFont->hFile, pFont->oSegmentRunTable, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

    // Read segment run table.
    for (i = 0;; i++)
    {
        if (i == c)
        {
            goto NotFound;
        }

        if (!ReadFile(pFont->hFile, &Run, sizeof(Run), &dwRead, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }

        if (uSegment >= Run.wFirstSegment && uSegment < (unsigned)Run.wFirstSegment + Run.cSegments)
        {
            break;
        }
    }

    // Get the segment.
    o = pFont->oSegmentTable + (Run.iSegmentTable + uSegment - Run.wFirstSegment) * sizeof(SegmentDescriptor);

    if (SetFilePointer(pFont->hFile, o, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

    if (!ReadFile(pFont->hFile, &Segment, sizeof(Segment), &dwRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

    // Calculate the glyph data index.
    iGlyphData = Segment.iGlyph;
    uMask = Segment.wCharMask;

    if (!(uMask & (1 << uOffset)))
    {
        goto NotFound;
    }

    // Mask all the bits under this one.
    uMask &= (1 << uOffset) - 1;

    // Count them.
    while (uMask)
    {
        iGlyphData++;

        uMask &= uMask - 1;
    }

    // Get the offset of the data.
    o = pFont->oGlyphOffsets + sizeof(DWORD) * iGlyphData;

    if (SetFilePointer(pFont->hFile, o, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

    if (!ReadFile(pFont->hFile, &rgGlyphOffsets, sizeof(DWORD) * 2, &dwRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

    // Allocate memory for the glyph.
    hr = AddToCache(pFont, wch, rgGlyphOffsets[1] - rgGlyphOffsets[0] - sizeof(Glyph), &pGlyph);

    if (FAILED(hr))
    {
        goto Error;
    }

    // We're now ready to read in the glyph.
    if (SetFilePointer(pFont->hFile, rgGlyphOffsets[0], NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

    if (!ReadFile(pFont->hFile, pGlyph, rgGlyphOffsets[1] - rgGlyphOffsets[0], &dwRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

    *ppGlyph = pGlyph;
    *pcbGlyphSize = rgGlyphOffsets[1] - rgGlyphOffsets[0];

    return NOERROR;

NotFound:
    // Recurse with the default character.
    if (wch != pFont->pHeader->wDefaultChar)
    {
        hr = BP_GetCharacterDataFromFile(pFont, pFont->pHeader->wDefaultChar, ppGlyph, pcbGlyphSize);

        if (FAILED(hr))
        {
            return hr;
        }
        else
        {
            return S_FALSE;
        }
    }

    hr = E_FAIL;

Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\library\sources.inc ===
TARGETTYPE=LIBRARY

INCLUDES=..\..\scaler

C_DEFINES=$(C_DEFINES) -DUNICODE

SOURCES=\
    bitmap.cpp \
    painttext.cpp \
    truetype.cpp \
    xfont.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\library\font.h ===
//****************************************************************************
//
// XBox internal font header.
//
// History:
//
//   07/06/00 [andrewso] - Created
//   08/04/00 [andrewso] - Added compressed glyph bitmaps
//
//****************************************************************************

#include <d3d8.h>

#ifdef _XBOX
#include "xfontformat.h"
#else
#include "xfontformat-pc.h"
#endif

#pragma once

#if defined(__cplusplus)

extern "C" {

#endif

//
// Callbacks used to communicate to the true-type font package.  We go 
// through these callbacks to give the linker the opportunity to
// throw all of the true type stuff away...if the user doesn't call
// XFONT_OpenTrueTypeFont, then none of the TrueType methods get 
// referenced 
//

typedef void (__stdcall *CB_UnloadFont)(struct _Font *);
typedef HRESULT (__stdcall *CB_ResetTransform)(struct _Font *);
typedef HRESULT (__fastcall *CB_GetCharacterData)(struct _Font *, WCHAR, struct _Glyph **, unsigned *pcbGlyphSize);

//
// Structure definitions.
//

typedef struct IDirect3DSurface8 IDirect3DSurface8;

//============================================================================
// An entry in the cache.  The glyph immediately follows this structure.
//============================================================================

typedef struct _CacheEntry
{
    WCHAR wch;          // Cached character
    WORD wLength;       // Length of this entry, including the header

    // The entry is stashed on a circular, doubly-linked list.
    struct _CacheEntry *pNextEntry;
    struct _CacheEntry *pPrevEntry;
} CacheEntry;

//============================================================================
// The structure that holds the state of a font.  This is opaquely given to
// the consumer so they can manually switch between fonts without having to
// unload/load them.
//============================================================================

typedef struct _Font
{
    //
    // Housekeeping.
    //

    unsigned uReferenceCount;

    // 
    // Metrics information about this font.
    //

    unsigned uCellHeight;           // the height of the character cell
    unsigned uDescent;              // bottom of the cell to the baseline

    unsigned uAntialiasLevel;       // amount of antialiasing information (0, 2, 4)
    unsigned uRLEWidth;             // # of bits for RLE
    unsigned uMaxBitmapHeight;      // height of the tallest glyph
    unsigned uMaxBitmapWidth;       // width of the widest glyph
    unsigned uStyle;                // the style of the font to simulate (truetype only)
    unsigned uIntercharacterSpacing;// how many extra pixels to put between each character
    
    unsigned uAlignmentMode;        // how to align the text
    D3DCOLOR TextColor;             // the color of the text
    D3DCOLOR BackgroundColor;       // the color of the background
    BOOL     fPaintBackground;      // whether to fill the background or not

    BOOL     fUseClippingRectangle; // whether to use the clipping rectangle
    D3DRECT  ClippingRectangle;     // clipping rectangle
    D3DRECT  ClippingRectangleCopy; // clipping rectangle copy for GetClippingRectangle.

    //
    // Indirection tables used to abstract rendering bitmaps and truetype
    // fonts.
    //

    CB_UnloadFont pfnUnloadFont;
    CB_ResetTransform pfnResetTransform;
    CB_GetCharacterData pfnGetCharacterData;

    //
    // The glyph cache.
    //

    // Memory to hold the glyph/bitmap when there is no cache.
    void *pvOneGlyph;

    // The real cache.
    BYTE *pbCache;              // Start of the cache.
    BYTE *pbCacheEnd;           // End of the cache.
    BYTE *pbCacheNext;          // Where to put the next new entry.

    unsigned cbCacheSize;       // Size of the cache.
    unsigned cbCacheUsed;       // How much as been used.

    CacheEntry CacheHead;       // Head of the cache list.
} Font;

//
// Exposed functions.
//

// Open a TrueType font.
HRESULT __stdcall TT_OpenTrueTypeFont(LPCWSTR wszFileName, struct _Font **ppFont);

// Open a bitmap font.
HRESULT __stdcall BP_OpenBitmapFont(LPCWSTR wszFileName, unsigned uCacheSize, struct _Font **ppFont, BOOL *pfUseCache);
HRESULT __stdcall BP_OpenBitmapFontFromMemory(CONST void *pFontData, unsigned uFontDataSize, struct _Font **ppFont);

// Render a single character.
HRESULT __stdcall PaintText(Font *, LPCVOID, unsigned, D3DFORMAT, LPCWSTR, unsigned, long, long, unsigned, unsigned, unsigned, unsigned);

// Methods used by the font packages to control the font cache.
HRESULT AddToCache(Font *, WCHAR wch, unsigned cbGlyph, Glyph **ppGlyph);
void ClearCache(Font *);

// 
// Debug helpers.
//

#if DBG

void XFRIP(PCHAR Format, ...);

#define XFNULL(x, y)  { if (x == NULL) XFRIP(y); } 
#define XFASSERT(x, y) { if (!(x)) XFRIP(y); }

#else

#define XFRIP(x)
#define XFASSERT(x, y)
#define XFNULL(x, y)

#endif

#if defined(__cplusplus)

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\library\painttext.cpp ===
//****************************************************************************
//
// XBox font drawer
//
// History:
//
//   07/06/00 [andrewso] - Created
//   08/04/00 [andrewso] - Added compressed glyph bitmaps
//
//****************************************************************************

// PERFORMANCE NOTE: This file defines a template that is instantiated
//   : for each color depth (1, 2, 3, or 4 bytes per pixel) * 3.  The code
//   : size for this file can be reduced by NULLING out the entries in the
//   : rgTextOutTable that you do not need.  The compiler/linker will
//   : not do this for you automatically.

#ifdef _XBOX

#include <xtl.h>
#include <xdbg.h>
#include "xfont.h"
#include "xfontformat.h"

#else 

#include <windows.h>
#include "xfont-pc.h"
#include "xfontformat-pc.h"

#endif

#include <assert.h>
#include "font.h"

extern "C"
HRESULT __fastcall XFONT_GetCharacterData(XFONT *, WCHAR, Glyph **, unsigned *);

// Describes a the display format.
struct FORMAT
{
    unsigned uPixelSize;

    unsigned uAlphaBits;
    unsigned uAlphaShift;
    unsigned uRedBits;
    unsigned uRedShift;
    unsigned uGreenBits;
    unsigned uGreenShift;
    unsigned uBlueBits;
    unsigned uBlueShift;
};

//============================================================================
// This template function manages drawing a string onto a surface.  It is 
// created as a template to allow the compiler to create and optimize 
// specialized version of this function for the different color depths and 
// antialiasing modes.  
//
// NOTE: We use a template class that contains a static function because
//   : VC6+ doesn't support specializing template functions by anything
//   : but type...so the "MODE" parameter to the template has no effect.
//   : Works fine with a template class.  
//============================================================================

template <class BASE>
class Paint
{
public:

//============================================================================
// Draws the background of a text string.  This just figures out how 
// wide the string is and blasts in the background color.
//============================================================================

static HRESULT DrawBackground
(
    Font *pFont,
    LPCWSTR wstr,                       // [in] String to render.
    unsigned cch,                       // [in] Length, or -1 for zero termination
    DWORD dwBackColor,                  // [in] the background color bit pattern
    long iCellX,                        // [in] what column to start drawing at
    long lCellMinY,                     // [in] what row to start drawing at
    long lCellMaxY,                     // [in] what row to stop drawing at (exclusive)
    unsigned uClipLeft,                 // [in] left clip
    unsigned uClipRight,                // [in] right clip
    unsigned uIntercharacterSpacing,    // [in] extra spaces between characters
    LPCVOID pBits,                      // [in] the bits to draw to
    unsigned Pitch                      // [in] the pitch to draw to.
)
{
    HRESULT hr;

    // The pitch, in BASE units.
    unsigned uPitch = Pitch / sizeof(BASE);
    assert(!(Pitch % sizeof(BASE)));

    BASE *pSurface = (BASE *)pBits;

    long lExtraSpace = (long)uIntercharacterSpacing;
    long lWidth = 0;

    // Calculate the width of the box.
    for (unsigned ich = 0; ich < cch && *wstr; ich++, wstr++)
    {
        Glyph *pGlyph;
        unsigned cbGlyphSize;

        // Get the character info.
        hr = XFONT_GetCharacterData((XFONT *)pFont, *wstr, &pGlyph, &cbGlyphSize);

        if (FAILED(hr)) 
        {
            return hr;
        }

        // If this is the last character in the string then do not draw any
        // extra spacing.  We may need to blank out a bit more if the character
        // draws beyond its character cell.
        //
        if (ich + 1 == cch || !*(wstr + 1))
        {
            lExtraSpace = max(pGlyph->uAdvance, pGlyph->uBitmapWidth + pGlyph->iBearingX) - pGlyph->uAdvance;
        }

        lWidth += pGlyph->uAdvance + lExtraSpace;
    }

    // Do the fill.
    const long lCellMinX = max((long)uClipLeft, iCellX);
    const long lCellMaxX = min((long)uClipRight, iCellX + lWidth);

    if (lCellMinX < lCellMaxX)
    {   
        unsigned       cRows = lCellMaxY - lCellMinY;
        const unsigned cCols = lCellMaxX - lCellMinX;
        const unsigned cBetweenLineAdvance = uPitch - cCols;

        BASE *pPixel = pSurface + uPitch * lCellMinY + lCellMinX;

        while (cRows--)
        {
            unsigned cDraw = cCols;
            
            while (cDraw--)
            {
                *(pPixel++) = (BASE)dwBackColor;
            }

            pPixel += cBetweenLineAdvance;
        }
    }

    return NOERROR;
}

//============================================================================
// Helper to decode the compressed image.  Real good inline candidate.
//============================================================================

__forceinline static unsigned DecodeWidth
(
    DWORD **ppdwBitmap,
    unsigned *puBitmap,
    unsigned *pcBits,
    const unsigned uPacketMask,
    const unsigned uRLEPacketWidth,
    const bool fRepeat
)
{
    unsigned uValue;
    unsigned uTotal = 0;

    DWORD *pdwBitmap = *ppdwBitmap;
    unsigned uBitmap = *puBitmap;
    unsigned cBits = *pcBits;

    do
    {
        uValue = uBitmap & uPacketMask;

        cBits += uRLEPacketWidth;
        
        if (cBits / 32)
        {
            uBitmap = *(++pdwBitmap);
            cBits %= 32;

            uValue |= ((uPacketMask >> (uRLEPacketWidth - cBits)) & uBitmap) << (uRLEPacketWidth - cBits);
            uBitmap >>= cBits;
        }
        else
        {
            uBitmap >>= uRLEPacketWidth;
        }

        uTotal += uValue;
    }
    while (fRepeat && uValue == uPacketMask);

    *ppdwBitmap = pdwBitmap;
    *puBitmap = uBitmap;
    *pcBits = cBits;

    return uTotal;
}

//============================================================================
// Draws a string of text on a surface that has no alpha support using
// a font with no antialiasing information.
//============================================================================

static HRESULT TextOutNoAlpha
(
    Font *pFont,
    LPCWSTR wstr,                       // [in] String to render.
    unsigned cch,                       // [in] Length, or -1 for zero termination
    long iCellX,                        // [in] X coordinate of the left of the character cell
    long iCellY,                        // [in] Y coordinate of the top of the characer cell
    unsigned uClipLeft,                 // [in] coordinates of the clipping rectangle
    unsigned uClipTop,
    unsigned uClipRight,
    unsigned uClipBottom,
    unsigned uIntercharacterSpacing,    // [in] extra spaces between characters
    unsigned uCellHeight,               // [in] total cell height
    unsigned uDescent,                  // [in] bottom of the cell to the baseline
    LPCVOID pBits,                      // [in] the bits to draw to
    unsigned Pitch,                     // [in] the pitch to draw to.
    BOOL fFillBackground,               // [in] draw the background color?
    DWORD dwTextColor,                  // [in] the foreground color bit pattern
    DWORD dwBackColor,                  // [in] the background color bit pattern
    unsigned uRLEPacketWidth,           // [in] the # of bits per RLE packet
    unsigned,                           // [in] the # of bits used to store antialiasing information
    FORMAT *                            // [in] describes the color format of a pixel
)
{
    HRESULT hr;

    // The pitch, in BASE units.
    unsigned uPitch = Pitch / sizeof(BASE);
    assert(!(Pitch % sizeof(BASE)));

    BASE *pSurface = (BASE *)pBits;
    const long oBaseline = uCellHeight - uDescent;

    const long lCellMinY = max((long)uClipTop, iCellY);
    const long lCellMaxY = min((long)uClipBottom, iCellY + (long)uCellHeight);

    const unsigned uPacketMask = (unsigned)0xFFFFFFFF >> (32 - uRLEPacketWidth);

    //_asm int 3;

    // We need to pre-draw the background for this string because the characters
    // may draw outside of their character cell.  If we drew the backgrounds with
    // the character then the background for the next character might overwrite
    // the graphics for the character we just drew.  This actually happens 
    // quite a bit with italics fonts.
    //
    // This will really blow chunks if the font is loaded with either no 
    // cache or a cache that is too small to handle the string being processed.
    // Otherwise the first background-drawing pass will just pre-load the cache
    // and no work will be wasted.
    //
    if (fFillBackground && lCellMinY < lCellMaxY)
    {
        hr = DrawBackground(pFont,
                            wstr,   
                            cch,
                            dwBackColor,
                            iCellX,
                            lCellMinY,
                            lCellMaxY,
                            uClipLeft,
                            uClipRight,
                            uIntercharacterSpacing,
                            pBits,
                            Pitch);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    // _asm int 3;

    // Walk the string and draw the characters.
    for (unsigned ich = 0; ich < cch && *wstr; ich++, wstr++)
    {
        Glyph *pGlyph;
        unsigned cbGlyphSize;

        DWORD *pdwBitmap;

        // Get the character info.
        hr = XFONT_GetCharacterData((XFONT *)pFont, *wstr, &pGlyph, &cbGlyphSize);

        if (FAILED(hr)) 
        {
            return hr;
        }

        //_asm int 3;

        pdwBitmap = (DWORD *)(pGlyph + 1);      // May be unaligned...

        // 
        // Walk the character and draw its bitmap.
        //

        const unsigned uBitmapWidth = pGlyph->uBitmapWidth;

        const long lBitmapX = iCellX + pGlyph->iBearingX;
        const long lBitmapY = iCellY + oBaseline - pGlyph->iBearingY;

        const long lMinX = (unsigned)max((long)uClipLeft, lBitmapX);
        const long lMaxX = (unsigned)min((long)uClipRight, lBitmapX + (long)uBitmapWidth);

        BASE *pMinY = pSurface + max((long)uClipTop, lBitmapY) * uPitch;
        BASE *pMaxY = pSurface + min((long)uClipBottom, lBitmapY + pGlyph->uBitmapHeight) * uPitch;

        if (lMinX < lMaxX && pMinY < pMaxY)
        {
            BASE *pFirstRow = pSurface + lBitmapY * uPitch;

            unsigned iPixel = 0;
            unsigned cPixels = uBitmapWidth * pGlyph->uBitmapHeight;
            unsigned cBits = 0;
            unsigned cToDraw;

            unsigned uBitmap = *pdwBitmap;
            unsigned uValue;

            bool fForeground = false;

            while (iPixel < cPixels)
            {
                cToDraw = DecodeWidth(&pdwBitmap,
                                      &uBitmap,
                                      &cBits,
                                      uPacketMask,
                                      uRLEPacketWidth,
                                      true);

                if (fForeground && cToDraw)
                {
                    BASE *pRow = pFirstRow + uPitch * (iPixel / uBitmapWidth);
                    unsigned uPixelInBitmapX = iPixel % uBitmapWidth;
                    unsigned cDrawing = cToDraw;

                    for (;;)
                    {
                        const unsigned cMove = min(cDrawing, uBitmapWidth - uPixelInBitmapX);
                        const long lPixelX = (long)uPixelInBitmapX + lBitmapX;
                        const long lPixelMin = max(lPixelX, lMinX);
                        const long lPixelMax = min(lPixelX + (long)cMove, lMaxX);

                        if (lPixelMin < lPixelMax && pRow >= pMinY && pRow <= pMaxY)
                        {
                            long cCols = lPixelMax - lPixelMin;
                            BASE *pPixel = pRow + lPixelMin;

                            while (cCols--)
                            {
                                *(pPixel++) = (BASE)dwTextColor;
                            }
                        }

                        cDrawing -= cMove;

                        if (!cDrawing)
                        {
                            break;
                        }

                        pRow += uPitch;
                        uPixelInBitmapX = 0;
                    }
                }


                fForeground = !fForeground;
                iPixel += cToDraw;                
            }
        }

        // Next character.
        iCellX += pGlyph->uAdvance + uIntercharacterSpacing;
    }

    return NOERROR;
}

//============================================================================
// Draws a string to a texture that has an alpha channel.
//============================================================================

static HRESULT TextOutAlpha
(
    Font *pFont,
    LPCWSTR wstr,               // [in] String to render.
    unsigned cch,               // [in] Length, or -1 for zero termination
    long iCellX,                // [in] X coordinate of the left of the character cell
    long iCellY,                // [in] Y coordinate of the top of the characer cell
    unsigned uClipLeft,         // [in] coordinates of the clipping rectangle
    unsigned uClipTop,
    unsigned uClipRight,
    unsigned uClipBottom,
    unsigned uIntercharacterSpacing,    // [in] extra spaces between characters
    unsigned uCellHeight,       // [in] total cell height
    unsigned uDescent,          // [in] bottom of the cell to the baseline
    LPCVOID pBits,              // [in] the bits to draw to
    unsigned Pitch,             // [in] the pitch to draw to.
    BOOL fFillBackground,       // [in] draw the background color?
    DWORD dwTextColor,          // [in] the foreground color bit pattern
    DWORD dwBackColor,          // [in] the background color bit pattern
    unsigned uRLEPacketWidth,   // [in] the # of bits per RLE packet
    unsigned uAntialiasWidth,   // [in] the # of bits used to store antialiasing information
    FORMAT *pFormat             // [in] describes the color format of a pixel
)
{
    HRESULT hr;

    // The pitch, in BASE units.
    unsigned uPitch = Pitch / sizeof(BASE);
    assert(!(Pitch % sizeof(BASE)));

    BASE *pSurface = (BASE *)pBits;
    const long oBaseline = uCellHeight - uDescent;

    const long lCellMinY = max((long)uClipTop, iCellY);
    const long lCellMaxY = min((long)uClipBottom, iCellY + (long)uCellHeight);

    const unsigned uPacketMask = (unsigned)0xFFFFFFFF >> (32 - uRLEPacketWidth);
    const unsigned uAntialiasMask = (unsigned)0xFFFFFFFF >> (32 - uAntialiasWidth);

    // Create a version of the text color with a maxed alpha channel.  This
    // is only used for FULLALPHA mode.
    //
    DWORD dwAlphaFull = (dwTextColor >> pFormat->uAlphaShift) & ((1 << pFormat->uAlphaBits) - 1);
    DWORD dwNoAlphaColor = dwTextColor & ~(((1 << pFormat->uAlphaBits) - 1) << pFormat->uAlphaShift);

    //_asm int 3;

    // We need to pre-draw the background for this string because the characters
    // may draw outside of their character cell.  If we drew the backgrounds with
    // the character then the background for the next character might overwrite
    // the graphics for the character we just drew.  This actually happens 
    // quite a bit with italics fonts.
    //
    // This will really blow chunks if the font is loaded with either no 
    // cache or a cache that is too small to handle the string being processed.
    // Otherwise the first background-drawing pass will just pre-load the cache
    // and no work will be wasted.
    //
    if (fFillBackground && lCellMinY < lCellMaxY)
    {
        hr = DrawBackground(pFont,
                            wstr,   
                            cch,
                            dwBackColor,
                            iCellX,
                            lCellMinY,
                            lCellMaxY,
                            uClipLeft,
                            uClipRight,
                            uIntercharacterSpacing,
                            pBits,
                            Pitch);
    }

    // _asm int 3;

    // Walk the string and draw the characters.
    for (unsigned ich = 0; ich < cch && *wstr; ich++, wstr++)
    {
        Glyph *pGlyph;
        unsigned cbGlyphSize;

        DWORD *pdwBitmap;

        // Get the character info.
        hr = XFONT_GetCharacterData((XFONT *)pFont, *wstr, &pGlyph, &cbGlyphSize);

        if (FAILED(hr)) 
        {
            return hr;
        }

        //_asm int 3;

        pdwBitmap = (DWORD *)(pGlyph + 1);      // May be unaligned...

        // 
        // Walk the character and draw its bitmap.
        //

        const unsigned uBitmapWidth = pGlyph->uBitmapWidth;

        const long lBitmapX = iCellX + pGlyph->iBearingX;
        const long lBitmapY = iCellY + oBaseline - pGlyph->iBearingY;

        const long lMinX = (unsigned)max((long)uClipLeft, lBitmapX);
        const long lMaxX = (unsigned)min((long)uClipRight, lBitmapX + (long)uBitmapWidth);

        BASE *pMinY = pSurface + max((long)uClipTop, lBitmapY) * uPitch;
        BASE *pMaxY = pSurface + min((long)uClipBottom, lBitmapY + pGlyph->uBitmapHeight) * uPitch;

        if (lMinX < lMaxX && pMinY < pMaxY)
        {
            BASE *pFirstRow = pSurface + lBitmapY * uPitch;

            unsigned iPixel = 0;
            unsigned cPixels = uBitmapWidth * pGlyph->uBitmapHeight;
            unsigned cBits = 0;
            unsigned cToDraw;

            unsigned uBitmap = *pdwBitmap;
            unsigned uValue;

            bool fForeground = false;
            DWORD dwPartial;

            while (iPixel < cPixels)
            {
                dwPartial = 0;

                cToDraw = DecodeWidth(&pdwBitmap,
                                      &uBitmap,
                                      &cBits,
                                      uPacketMask,
                                      uRLEPacketWidth,
                                      true);

                // Handle escaped values.
                if (cToDraw == 0 && uAntialiasWidth > 0)
                {
                    // Get the value of the escaped value.
                    dwPartial = DecodeWidth(&pdwBitmap,
                                            &uBitmap,
                                            &cBits,
                                            uAntialiasMask,
                                            uAntialiasWidth,
                                            false);

                    // A zero here tells us to draw nothing, otherwise we're
                    // just drawing one escaped pixel.
                    //
                    if (dwPartial)
                    {
                        cToDraw = 1;
                    }
                }

                if (dwPartial || fForeground && cToDraw)
                {
                    BASE *pRow = pFirstRow + uPitch * (iPixel / uBitmapWidth);
                    unsigned uPixelInBitmapX = iPixel % uBitmapWidth;
                    unsigned cDrawing = cToDraw;

                    for (;;)
                    {
                        const unsigned cMove = min(cDrawing, uBitmapWidth - uPixelInBitmapX);
                        const long lPixelX = (long)uPixelInBitmapX + lBitmapX;
                        const long lPixelMin = max(lPixelX, lMinX);
                        const long lPixelMax = min(lPixelX + (long)cMove, lMaxX);

                        if (lPixelMin < lPixelMax && pRow >= pMinY && pRow <= pMaxY)
                        {
                            long cCols = lPixelMax - lPixelMin;
                            BASE *pPixel = pRow + lPixelMin;

                            if (!dwPartial)
                            {
                                while (cCols--)
                                {
                                    *(pPixel++) = (BASE)dwTextColor;
                                }
                            }
                            else
                            {
                                // Map the partial value to its final alpha value.
                                const DWORD dwAlpha = (dwPartial * dwAlphaFull) / (1 << uAntialiasWidth);
                                const DWORD dwTextColorPartial = dwNoAlphaColor | (dwAlpha << pFormat->uAlphaShift);

                                while (cCols--)
                                {
                                    *(pPixel++) = (BASE)dwTextColorPartial;
                                }
                            }
                        }

                        cDrawing -= cMove;

                        if (!cDrawing)
                        {
                            break;
                        }

                        pRow += uPitch;
                        uPixelInBitmapX = 0;
                    }
                }

                if (!dwPartial)
                {
                    fForeground = !fForeground;
                }

                iPixel += cToDraw;                
            }
        }

        // Next character.
        iCellX += pGlyph->uAdvance + uIntercharacterSpacing;
    }

    return NOERROR;
}
};

//============================================================================
// Given a surface format, return the number of alpha bits it supports.
//============================================================================

// Maps from a FORMAT to an entry in the following table.
_declspec(selectany) BYTE g_FormatOffset[] =
{
    -1, //D3DFMT_L8
    -1, //D3DFMT_AL8
    0,  //D3DFMT_A1R5G5B5
    1,  //D3DFMT_X1R5G5B5
    2,  //D3DFMT_A4R4G4B4
    3,  //D3DFMT_R5G6B5
    4,  //D3DFMT_A8R8G8B8
    5,  //D3DFMT_X8R8G8B8
    -1,
    -1,
    -1,
    6,  //D3DFMT_P8
    -1, //D3DFMT_DXT1
    -1,
    -1, //D3DFMT_DXT3
    -1, //D3DFMT_DXT5
    0,  //D3DFMT_LIN_A1R5G5B5
    3,  //D3DFMT_LIN_R5G6B5
    4,  //D3DFMT_LIN_A8R8G8B8
    -1, //D3DFMT_LIN_L8
    -1,
    -1,
    7,  //D3DFMT_LIN_R8B8
    8,  //D3DFMT_LIN_G8B8
    -1,
    9,  //D3DFMT_A8
    -1, //D3DFMT_A8L8
    -1, //D3DFMT_LIN_AL8
    1,  //D3DFMT_LIN_X1R5G5B5
    2,  //D3DFMT_LIN_A4R4G4B4
    5,  //D3DFMT_LIN_X8R8G8B8
    9,  //D3DFMT_LIN_A8
    -1, //D3DFMT_LIN_A8L8
    -1,
    -1,
    -1,
    -1, //D3DFMT_YUY2
    -1, //D3DFMT_UYVY
    -1,
    10, //D3DFMT_R6G5B5
    8,  //D3DFMT_G8B8
    7,  //D3DFMT_R8B8
    -1, //D3DFMT_D24S8
    -1, //D3DFMT_F24S8
    -1, //D3DFMT_D16
    -1, //D3DFMT_F16
    -1, //D3DFMT_LIN_D24S8
    -1, //D3DFMT_LIN_F24S8
    -1, //D3DFMT_LIN_D16
    -1, //D3DFMT_LIN_F16
    -1, //D3DFMT_L16
    -1, //D3DFMT_V16U16
    -1,
    -1, //D3DFMT_LIN_L16
    -1, //D3DFMT_LIN_V16U16
    10, //D3DFMT_LIN_R6G5B5
    11, //D3DFMT_R5G5B5A1
    12, //D3DFMT_R4G4B4A4
    13, //D3DFMT_A8B8G8R8
    14, //D3DFMT_B8G8R8A8
    15, //D3DFMT_R8G8B8A8
    11,  //D3DFMT_LIN_R5G5B5A1
    12,  //D3DFMT_LIN_R4G4B4A4
    13, //D3DFMT_LIN_A8B8G8R8
    14, //D3DFMT_LIN_B8G8R8A8
    15, //D3DFMT_LIN_R8G8B8A8
};

_declspec(selectany) FORMAT g_Formats[] =
{
    // format               bpp  abits ashift rbits rshift gbits gshift bbits bshift
    { /*  0 - A1R5G5B5 */   16,  1,    15,    5,    10,    5,    5,     5,    0  },
    { /*  1 - X1R5G5B5 */   16,  0,    0,     5,    10,    5,    5,     5,    0  },
    { /*  2 - A4R4G4B4 */   16,  4,    12,    4,    8,     4,    4,     4,    0  },
    { /*  3 - R5G6B5   */   16,  0,    0,     5,    11,    6,    5,     5,    0  },
    { /*  4 - A8R8G8B8 */   32,  8,    24,    8,    16,    8,    8,     8,    0  },
    { /*  5 - X8R8G8B8 */   32,  0,    0,     8,    16,    8,    8,     8,    0  },
    { /*  6 - P8       */   8,   0,    0,     0,    0,     0,    0,     0,    0  },
    { /*  7 - R8B8     */   16,  0,    0,     8,    8,     0,    0,     8,    0  },
    { /*  8 - G8B8     */   16,  0,    0,     0,    0,     8,    8,     8,    0  },
    { /*  9 - A8       */   8,   8,    0,     0,    0,     0,    0,     0,    0  },
    { /* 10 - R6G5B5   */   16,  0,    0,     6,    10,    5,    5,     5,    0  },
    { /* 11 - R5G5B5A1 */   16,  1,    0,     5,    11,    5,    6,     5,    1  },
    { /* 12 - R4G4B4A4 */   16,  4,    0,     4,    12,    4,    8,     4,    4  },
    { /* 13 - A8B8G8R8 */   32,  8,    24,    8,    0,     8,    8,     8,    16 },
    { /* 14 - B8G8R8A8 */   32,  8,    0,     8,    8,     8,    16,    8,    24 },
    { /* 15 - R8G8B8A8 */   32,  8,    0,     8,    24,    8,    16,    8,    8  },
};


static FORMAT *PixelLayoutFromFormat
(
    D3DFORMAT Format
)
{
    BYTE Index = g_FormatOffset[Format];

    XFASSERT(Index != -1, "XFONT - Unrecognized destination surface format.");

    return &g_Formats[Index];
}

//============================================================================
// Given a surface format and a color, return the pixel value for the color.
//============================================================================

static DWORD PixelColorFromD3DCOLOR
(
    FORMAT *pFormat,
    D3DCOLOR color
)
{
    DWORD dwColor;

    DWORD dwAlpha = (color >> 24) & 0xFF;
    DWORD dwRed = (color >> 16) & 0xFF;
    DWORD dwGreen = (color >> 8) & 0xFF;
    DWORD dwBlue = color & 0xFF;

    dwColor  = (dwAlpha >> (8 - pFormat->uAlphaBits)) << pFormat->uAlphaShift;
    dwColor |= (dwRed   >> (8 - pFormat->uRedBits)  ) << pFormat->uRedShift;
    dwColor |= (dwGreen >> (8 - pFormat->uGreenBits)) << pFormat->uGreenShift;
    dwColor |= (dwBlue  >> (8 - pFormat->uBlueBits) ) << pFormat->uBlueShift;

    return dwColor;
};

//============================================================================
// The whole purpose of this file, render a single character on the display.
//============================================================================

HRESULT __stdcall PaintText
(
    Font *pFont,                // [in] Description of the font to display
    LPCVOID pBits,              // [in] The memory to write to.
    unsigned Pitch,             // [in] The pitch of the surface.
    D3DFORMAT Format,           // [in] The format of the surface
    LPCWSTR wstr,               // [in] String to render.
    unsigned cch,               // [in] Length, or -1 for zero termination
    long iX,                    // [in] X coordinate of the left of the character cell
    long iY,                    // [in] Y coordinate of the top of the character cell
    unsigned uClipLeft,         // [in] Clipping rectangle
    unsigned uClipTop,
    unsigned uClipRight,
    unsigned uClipBottom
)
{
    HRESULT hr;

    FORMAT *pFormat;

    pFormat = PixelLayoutFromFormat(Format);

    DWORD dwTextColor = PixelColorFromD3DCOLOR(pFormat, pFont->TextColor);
    DWORD dwBackColor = PixelColorFromD3DCOLOR(pFormat, pFont->BackgroundColor);

    // Call the draw method.  Each call below will cause a new instance of the
    // method to be instantiated with a different base type and for a different
    // mode.  Removing elements from this table that you do not use will reduce
    // the code size of this library.
    //
    typedef HRESULT (*pfnTextOut)(Font *pFont,
                                  LPCWSTR wstr,
                                  unsigned cch,
                                  long iCellX,
                                  long iCellY,
                                  unsigned uClipLeft,
                                  unsigned uClipTop,
                                  unsigned uClipRight,
                                  unsigned uClipBottom,
                                  unsigned uIntercharacterSpacing,
                                  unsigned uCellHeight,
                                  unsigned uDescent,
                                  LPCVOID pBits,
                                  unsigned Pitch,
                                  BOOL fFillBackground,
                                  DWORD dwTextColor,
                                  DWORD dwBackColor,
                                  unsigned uRLEPacketWidth,
                                  unsigned uAntialiasWidth,
                                  FORMAT *pFormat);

    // Removing unused entries from this table will reduce the code
    // size of this file as it will cause fewer instances of the 
    // TextOut* methods to be instantiated.
    //
    const static pfnTextOut rgTextOutTable[4][2] =
    {
        { Paint<BYTE> ::TextOutNoAlpha, Paint<BYTE> ::TextOutAlpha },
        { Paint<WORD> ::TextOutNoAlpha, Paint<WORD> ::TextOutAlpha },
        { NULL,                         NULL,                      },
        { Paint<DWORD>::TextOutNoAlpha, Paint<DWORD>::TextOutAlpha },
    };

    unsigned iSize = pFormat->uPixelSize / 8 - 1;

    // Do the draw.
    hr = rgTextOutTable[iSize][pFont->uAntialiasLevel == 0 ? 0 : 1]
            (
                pFont,
                wstr,
                cch,
                iX,
                iY,
                uClipLeft,
                uClipTop,
                uClipRight,
                uClipBottom,
                pFont->uIntercharacterSpacing,
                pFont->uCellHeight,
                pFont->uDescent,
                pBits,
                Pitch,
                pFont->fPaintBackground,
                dwTextColor,
                dwBackColor,
                pFont->uRLEWidth,
                pFont->uAntialiasLevel,
                pFormat
            );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\library\truetype.cpp ===
//****************************************************************************
//
// XBox true-type font scan converter library
//
// History:
//
//   07/06/00 [andrewso] - Created
//   08/04/00 [andrewso] - Added compressed glyph bitmaps
//
//****************************************************************************

// This is a C++ file so we can take advantage of inheritance to extend
// the font data structure.

#ifdef _XBOX

#include <xtl.h>
#include "xfont.h"
#include "xfontformat.h"

#else 

#include <windows.h>
#include "xfont-pc.h"
#include "xfontformat-pc.h"

#endif

#include <assert.h>
#include "font.h"

// Scaler imports
#include "fscdefs.h"
#include "sfnt.h"
#include "sfntaccs.h"
#include "fnt.h"
#include "fsglue.h"
#include "scentry.h"
#include "sbit.h"
#include "fscaler.h"

//****************************************************************************
// Definitions.
//****************************************************************************

// 
// Structures
//

// Holds the font information.
struct TT_Font : public Font
{
    // Handle to our file.
    HANDLE hFile;

	// TrueType specific datastructures.
	fs_GlyphInputType in;
	fs_GlyphInfoType out;

	// The current sizes of each of the alloced chunks of memory.
	unsigned rgcbSizeMemory[MEMORYFRAGMENTS];
};

//
// Global variables.
//

// The identity matrix.
static transMatrix s_IdentityMatrix = 
{
	{
		{ ONEFIX, 0, 0 },
		{ 0, ONEFIX, 0 },
		{ 0, 0, ONEFIX }
	}
};

// The italics matrix.
static transMatrix s_ItalicsMatrix = 
{
	{
		{ ONEFIX, 0,      0      },
		{ 0x5700, ONEFIX, 0      },
		{ 0,      0,      ONEFIX }
	}
};

//
// Forwards.
//

// Error mapping.
#define ErrRet(x) { int __i = (x); if (__i) return MapError(__i); }
#define ErrGo(x) { int __i = (x); if (__i) { hr = MapError(__i); goto Error; } }

static HRESULT MapError(int i);

// Helper to allocate memory in the scaler datastructures.
static HRESULT AllocateScalerMemory(TT_Font *, unsigned, unsigned);

// Random forwards.
static void __stdcall TT_UnloadFont(struct TT_Font *);
static HRESULT __stdcall TT_ResetTransform(struct TT_Font *);
static HRESULT __fastcall TT_GetCharacterData(struct TT_Font *, WCHAR, struct _Glyph **, unsigned *);

static unsigned PackBitmap(unsigned, unsigned, unsigned, unsigned, unsigned, BYTE *, BYTE *);

static void * __cdecl TTI_GetFontData(long, long, long);
static void __cdecl TTI_ReleaseFontData(void *);

//****************************************************************************
// APIs.
//****************************************************************************

extern "C" HRESULT __stdcall GenerateFontMetrics(Font *pFont);
extern "C" HRESULT __stdcall InitializeCache(Font *pFont, unsigned cbCacheSize);

//============================================================================
// Load a TrueType font into the scan converter.  
//
// This call will use more memory than just the the cache because the 
// TrueType scan converter needs a bit of workspace to process the font.  If 
// memory is a concern, use a bitmap font instead.
//
// This automatically sets the opened font as the one that is currently
// active.  The attributes of the font are all set to their defaults.
//============================================================================

extern "C"
HRESULT __stdcall XFONT_OpenTrueTypeFont
(
	LPCWSTR wszFileName,	// [in] The file name to the font
	unsigned uCacheSize,	// [in] The size of the font cache, in bytes.
	XFONT **ppFont          // [out] The font identifier
)
{
	HRESULT hr;
	Font *pFont = NULL;
	
	assert(wszFileName);

	// Initialize the true type package.
	hr = TT_OpenTrueTypeFont(wszFileName, &pFont);

	if (FAILED(hr))
	{
		goto Error;
	}

    hr = InitializeCache(pFont, uCacheSize);
    
    if (FAILED(hr))
    {
        goto Error;
    }

	// Reset the font metrics.
	hr = GenerateFontMetrics(pFont);

	if (FAILED(hr))
	{
		goto Error;
	}

	// Set the font style defaults.
	pFont->uAlignmentMode   = XFONT_TOP | XFONT_LEFT;
	pFont->TextColor		  = 0xFFFFFFFF;
	pFont->BackgroundColor  = 0x00000000;
	pFont->fPaintBackground = FALSE;

	// Return it.
	*ppFont = (XFONT *)pFont;

	return NOERROR;

Error:
    if (pFont)
    {
	    XFONT_Release((XFONT *)pFont);
    }

	return hr;
}

//============================================================================
// Open a TrueType font.
//============================================================================

HRESULT __stdcall TT_OpenTrueTypeFont
(
	LPCWSTR wszFileName, 
	Font **ppFont
)
{
	HRESULT hr;
	TT_Font *pFont;
    HANDLE hFile;

	// Allocate the memory for the font structure and zero it.
	pFont = (TT_Font *)malloc(sizeof(TT_Font));

	if (!pFont)
	{
		return E_OUTOFMEMORY;
	}

	ZeroMemory(pFont, sizeof(TT_Font));

    pFont->hFile = INVALID_HANDLE_VALUE;
    pFont->uReferenceCount = 1;

	// Ask the scaler package how much memory it needs.
	ErrGo(fs_OpenFonts(&pFont->in, &pFont->out));

	// Allocate the memory
	hr = AllocateScalerMemory(pFont, 0, 2);

	if (FAILED(hr))
	{
		goto Error;
	}

	// Do the real initialization.
	ErrGo(fs_Initialize(&pFont->in, &pFont->out));

	// Open the font file.
	hFile = INVALID_HANDLE_VALUE;

    char szFile[_MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, wszFileName, -1, szFile, _MAX_PATH, NULL, NULL);

	hFile = CreateFileA(szFile, 
			           GENERIC_READ, 
					   FILE_SHARE_READ, 
					   NULL, 
					   OPEN_EXISTING, 
					   FILE_ATTRIBUTE_NORMAL, 
					   NULL);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

    pFont->hFile = hFile;

	// Register the font.
	pFont->in.clientID = (ULONG_PTR)hFile;
	pFont->in.param.newsfnt.platformID = 3;		// MS recommended value
	pFont->in.param.newsfnt.specificID = 1;		// UNICODE
	pFont->in.GetSfntFragmentPtr = (GetSFNTFunc)TTI_GetFontData;
	pFont->in.ReleaseSfntFrag = TTI_ReleaseFontData;
	pFont->in.sfntDirectory = NULL;

	ErrGo(fs_NewSfnt(&pFont->in, &pFont->out));

	// Set up its transforms.
	hr = AllocateScalerMemory(pFont, 3, 4);

	if (FAILED(hr))
	{
		goto Error;
	}

	// Default to 16 pixels high.
	pFont->uCellHeight = 16;
	pFont->uAntialiasLevel = 0;
    pFont->uRLEWidth = 2;
    pFont->uMaxBitmapHeight = 255;
    pFont->uMaxBitmapWidth = 255;

	hr = TT_ResetTransform(pFont);

	if (FAILED(hr))
	{
		goto Error;
	}

	// Set up the callbacks.
	pFont->pfnUnloadFont = (CB_UnloadFont)TT_UnloadFont;
	pFont->pfnResetTransform = (CB_ResetTransform)TT_ResetTransform;
	pFont->pfnGetCharacterData = (CB_GetCharacterData)TT_GetCharacterData;

	// Return it.
	*ppFont = (Font *)pFont;

	return NOERROR;

Error:
	TT_UnloadFont(pFont);

	return hr;
}

//****************************************************************************
// Callbacks to store in the Font structure.
//****************************************************************************

//============================================================================
// Free all memory associated with the font.
//============================================================================

static void __stdcall TT_UnloadFont
(
	struct TT_Font *pFont
)
{
	unsigned i;

	for (i = 0; i < MEMORYFRAGMENTS; i++)
	{
		if (pFont->in.memoryBases[i])
		{
			free(pFont->in.memoryBases[i]);
		}
	}

	free(pFont->pvOneGlyph);

    if (pFont->hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(pFont->hFile);
    }

	free(pFont);
}

//============================================================================
// Reset the size, alpha, etc of the font.
//============================================================================

static HRESULT __stdcall TT_ResetTransform
(
	struct TT_Font *pFont
)
{
	ClearCache(pFont);  		// The cache is hash.

	ZeroMemory(&pFont->in.param.newtrans, sizeof(pFont->in.param.newtrans));

    unsigned uOverScale = pFont->uAntialiasLevel;

    // We need to set the overscale to 1 when we don't want any antialasing
    // information to avoid creating a true bitmap.  The byte-array format
    // is much more convenient for creating the packed bitmap.  You may want
    // to change this if you're using the truetype package in memory-
    // sensative code.
    //
    if (uOverScale == 0)
    {
        uOverScale = 1;
    }

	// pixels while the other is in 2^n
	pFont->in.param.newtrans.pointSize = pFont->uCellHeight << 16;
	pFont->in.param.newtrans.usOverScale = (USHORT)uOverScale;
	pFont->in.param.newtrans.xResolution = 72;      // 1 pixel = 1 pt
	pFont->in.param.newtrans.yResolution = 72;   
	pFont->in.param.newtrans.pixelDiameter = FIXEDSQRT2;
	pFont->in.param.newtrans.transformMatrix = &s_IdentityMatrix;

    // set up the style.
    if (pFont->uStyle == XFONT_BOLD || pFont->uStyle == XFONT_BOLDITALICS)
    {
		pFont->in.param.newtrans.usEmboldWeightx = 20;
		pFont->in.param.newtrans.usEmboldWeighty = 20;
		pFont->in.param.newtrans.lDescDev = pFont->uDescent;
		pFont->in.param.newtrans.bBitmapEmboldening = TRUE;
    }

    if (pFont->uStyle == XFONT_ITALICS || pFont->uStyle == XFONT_BOLDITALICS)
    {
	    pFont->in.param.newtrans.transformMatrix = &s_ItalicsMatrix;
    }

	return fs_NewTransformation(&pFont->in, &pFont->out);
}

//============================================================================
// Get the data and bitmap information for one character.
//============================================================================

static HRESULT __fastcall TT_GetCharacterData
(
	TT_Font *pFont, 
	WCHAR wch, 
	struct _Glyph **ppGlyph,
    unsigned *pcbGlyphSize
)
{
	HRESULT hr;

	Glyph *pGlyph;

	//
	// Generate the glpyh information.
	//

	// Get the outline for the character.
	ZeroMemory(&pFont->in.param.newglyph, sizeof(pFont->in.param.newglyph));

	pFont->in.param.newglyph.characterCode = wch;

	ErrRet(fs_NewGlyph(&pFont->in, &pFont->out));

	ZeroMemory(&pFont->in.param.gridfit, sizeof(pFont->in.param.gridfit));

	ErrRet(fs_ContourGridFit(&pFont->in, &pFont->out));
	ErrRet(fs_FindBitMapSize(&pFont->in, &pFont->out));

	//
	// Have the rasterizer build the bitmap.
	//

	hr = AllocateScalerMemory(pFont, 5,8);

	if (FAILED(hr))
	{
		return hr;
	}

	// Get the bitmap.
	ZeroMemory(&pFont->in.param.scan, sizeof(pFont->in.param.scan));

	pFont->in.param.scan.bottomClip = pFont->out.bitMapInfo.bounds.top;
	pFont->in.param.scan.topClip = pFont->out.bitMapInfo.bounds.bottom;

	ErrRet(fs_ContourScan(&pFont->in, &pFont->out));

	// 
	// Allocate the memory to store the glyph information and the bitmap, then
	// fill out the glyph data structure.
	//

	const unsigned uBitmapHeight = pFont->out.bitMapInfo.bounds.bottom - pFont->out.bitMapInfo.bounds.top;
	const unsigned uBitmapWidth = pFont->out.bitMapInfo.bounds.right - pFont->out.bitMapInfo.bounds.left;

    // We can't handle very large bitmaps.
    if (uBitmapHeight > 255 || uBitmapWidth > 255)
    {
        return E_FAIL;
    }

	unsigned cbBitmap;
    
    cbBitmap = PackBitmap(uBitmapHeight,
                          uBitmapWidth,
                          pFont->uRLEWidth,
                          pFont->uAntialiasLevel,
                          pFont->out.bitMapInfo.rowBytes,
                          (BYTE *)pFont->out.bitMapInfo.baseAddr,
                          NULL);

	// Allocate the memory
	hr = AddToCache(pFont,
                    wch,
					cbBitmap,
					&pGlyph);

	if (FAILED(hr))
	{
		return hr;
	}

	// Fill in the Glyph structure.
	pGlyph->uBitmapHeight = (BYTE)uBitmapHeight;
	pGlyph->uBitmapWidth = (BYTE)uBitmapWidth;
	pGlyph->uAdvance = (unsigned char)(pFont->out.metricInfo.devAdvanceWidth.x >> 16);
	pGlyph->iBearingX = (char)(pFont->out.metricInfo.devLeftSideBearing.x >> 16);
	pGlyph->iBearingY = (char)(pFont->out.metricInfo.devLeftSideBearing.y >> 16);

	// 
	// 'Pack' the bitmap into its smallest form.
	//
    
    memset((BYTE *)(pGlyph + 1), 0, cbBitmap);

    PackBitmap(uBitmapHeight,
               uBitmapWidth,
               pFont->uRLEWidth,
               pFont->uAntialiasLevel,
               pFont->out.bitMapInfo.rowBytes,
               (BYTE *)pFont->out.bitMapInfo.baseAddr,
               (BYTE *)(pGlyph + 1));

	//
	// Return the results.
	//

	*ppGlyph = pGlyph;
    *pcbGlyphSize = cbBitmap + sizeof(Glyph);
    
    // Return S_FALSE to indicate that we're using the default glyph.
    return pFont->out.glyphIndex ? NOERROR : S_FALSE;
}


//****************************************************************************
// Implementation.
//****************************************************************************

//============================================================================
// Maps an error from the scaler package to an hresult.
//============================================================================

static HRESULT MapError
(	
	int i
)
{
	assert(false);

	return E_FAIL;
}

//============================================================================
// Helper to allocate memory insize of the scaler datastructures.
//============================================================================

static HRESULT AllocateScalerMemory
(
	TT_Font *pFont,         // [in] Font to allocate in.
	unsigned iStart,		// [in] The first fragment to allocate
	unsigned iEnd			// [in] The last fragement to allocate, inclusive
)
{
	unsigned i;

	for (i = iStart; i <= iEnd; i++)
	{
		if (pFont->out.memorySizes[i])
		{
			// Check to see if this slot already has memory that's big enough.
			if (pFont->rgcbSizeMemory[i] >= (unsigned)pFont->out.memorySizes[i])
			{
				continue;
			}

			if (pFont->in.memoryBases[i])
			{
				free(pFont->in.memoryBases[i]);
				pFont->rgcbSizeMemory[i] = 0;
			}

			pFont->in.memoryBases[i] = (char *)malloc(pFont->out.memorySizes[i]);

			if (!pFont->in.memoryBases[i])
			{
				goto Failed;
			}

			pFont->rgcbSizeMemory[i] = pFont->out.memorySizes[i];
		}
	}

	return NOERROR;

Failed:
	return E_OUTOFMEMORY;
}

//============================================================================
// The scaler needs this for some reason.
//============================================================================

extern "C"
void __cdecl TtfdDbgPrint(char *szMessage)
{
    assert(false);
}

//============================================================================
// Helper for pack bitmap
//============================================================================

static unsigned EmitRLEPacket
(
    long cCount,
    unsigned dwValue,
    long lRLEMax,
    unsigned uRLEWidth,
    long lValueMax,
    unsigned uValueWidth,
    BYTE **ppbCurrentPacked,
    unsigned *pcShift
)
{
    BYTE *pbCurrentPacked = *ppbCurrentPacked;
    unsigned cShift = *pcShift;
    unsigned cBits = 0;
    long cValueCount = cCount;
    bool fPartialValue = dwValue && dwValue < (DWORD)lValueMax;

    // We use a slightly different encoding if we're working with aliasing
    // information.  We do 0+<value> to indicate that we're
    // dealing with either a zero count (0 + 0) or a partially lit
    // pixel (0 + value).
    //
    if (uValueWidth && (fPartialValue || cCount == 0))
    {
        if (cCount == 0)
        {
            cCount = 1;
            dwValue = 0;
        }

        while (cCount--)
        {
            unsigned cWriteValue = dwValue;

            // "Write" the zero which is our escape character.
            if (pbCurrentPacked)
            {
                cShift += uRLEWidth;
                pbCurrentPacked += cShift / 8;
                cShift %= 8;
            }

            cBits += uRLEWidth;

            // Shove out the value.
            if (pbCurrentPacked)
            {
                cWriteValue <<= cShift;

                *pbCurrentPacked |= (BYTE)(cWriteValue & 0xFF);

                if (cWriteValue & 0xFF00)
                {
                    *(pbCurrentPacked + 1) = (BYTE)(cWriteValue >> 8);
                }

                cShift += uValueWidth;
                pbCurrentPacked += cShift / 8;
                cShift %= 8;
            }

            cBits += uValueWidth;
        }
    }
    else
    {
        // Write the actual count (may be zero).
        while (cValueCount >= 0)
        {
            if (pbCurrentPacked)
            {
                const unsigned cWriteValue = min(lRLEMax, cValueCount) << cShift;

                *pbCurrentPacked |= (BYTE)(cWriteValue & 0xFF);

                if (cWriteValue & 0xFF00)
                {
                    *(pbCurrentPacked + 1) = (BYTE)(cWriteValue >> 8);
                }

                cShift += uRLEWidth;
                pbCurrentPacked += cShift / 8;
                cShift %= 8;
            }

            cBits += uRLEWidth;
            cValueCount -= lRLEMax;
        }
    }

    *ppbCurrentPacked = pbCurrentPacked;
    *pcShift = cShift;

    return cBits;
}

//============================================================================
// Back a bitmap from the scaler's byte per pixel to its minimum possible
// size.  Returns that size.
//============================================================================

static unsigned PackBitmap
(	
	unsigned uBitmapHeight,     // [in] Height of the bitmap
    unsigned uBitmapWidth,      // [in] Width of the bitmap
    unsigned uRLEWidth,         // [in] How many bits to use in the RLE
    unsigned uAntialiasLevel,   // [in] How much aliasing information to include?
	unsigned uPitch,			// [in] Pitch of the bitmap
	BYTE *pbUnpacked,			// [in] Unpacked bitmap
    BYTE *pbPacked              // [in] Where to put the packed bitmap.
)
{
	assert(uRLEWidth >= 2 && uRLEWidth <= 8);

	// Walk the bitmap and do our thing.
	BYTE *pbCurrentPacked = pbPacked;
	unsigned iRow, cRows = uBitmapHeight;
	unsigned iColumn, cColumns = uBitmapWidth;
	unsigned cUnpackedIncrement = uPitch - cColumns;
    
    long lRLEMax = (1 << uRLEWidth) - 1;
    long lAntialiasMax = (1 << uAntialiasLevel);

    unsigned cBits = 0;
    unsigned cShift = 0;

    BYTE bPixel;

    BYTE bCurrentValue = 0;
    BYTE bLastValue = (BYTE)lAntialiasMax;

    long cValueCount = 0;

	for (iRow = cRows; iRow; iRow--)
	{
		// Copy each each pixel.
		for (iColumn = cColumns; iColumn; iColumn--)
		{
			// Get the pixel.
			bPixel = *pbUnpacked;

            if (bPixel != bCurrentValue)
            {
                cBits += EmitRLEPacket(cValueCount, 
                                       bCurrentValue, 
                                       lRLEMax, 
                                       uRLEWidth, 
                                       lAntialiasMax,
                                       uAntialiasLevel, 
                                       &pbCurrentPacked, 
                                       &cShift);

                // The compaction algorithm always assumes that full off and
                // full on alternate.  If we get on - partial - on then we need
                // to insert a zero to turn it into on - paritial - off - on.
                //
                if (bCurrentValue != 0 && bCurrentValue != lAntialiasMax && bPixel == bLastValue)
                {
                    cBits += EmitRLEPacket(0, 
                                           0,       // doesn't matter
                                           lRLEMax, 
                                           uRLEWidth, 
                                           lAntialiasMax,
                                           uAntialiasLevel, 
                                           &pbCurrentPacked, 
                                           &cShift);
                }

                if (bCurrentValue == 0 || bCurrentValue == lAntialiasMax)
                {
                    bLastValue = bCurrentValue;
                }

                bCurrentValue = bPixel;

                cValueCount = 0;
            }

            cValueCount++;

			// Move on to the next unpacked byte.
			pbUnpacked++;
		}
		pbUnpacked += cUnpackedIncrement;
	}

    // Pack the last value.
    if (cValueCount > 0)
    {
        cBits += EmitRLEPacket(cValueCount, 
                               bCurrentValue, 
                               lRLEMax, 
                               uRLEWidth, 
                               lAntialiasMax,
                               uAntialiasLevel, 
                               &pbCurrentPacked, 
                               &cShift);
    }

    return (cBits + 7) / 8;
}

//============================================================================
// Default implemenation of the font read callback.  This seeks the font's
// file to the right spot and reads it.
//============================================================================

static void * __cdecl TTI_GetFontData
(
	long lCookie, 
	long lOffset, 
	long lSize
)
{
	HANDLE hFile = (HANDLE)lCookie;
	void *pvMemory;
	DWORD dwRead;


	// Allocate the memory.
	pvMemory = malloc(lSize);
	
	if (!pvMemory)
	{
		return NULL;
	}

	// Seek to the right offset.
	if (SetFilePointer(hFile, lOffset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
	{
		goto Error;
	}

	// Read the information.
	if (!ReadFile(hFile, pvMemory, lSize, &dwRead, NULL) || dwRead != (DWORD)lSize)
	{
		goto Error;
	}

	return pvMemory;

Error:
	free(pvMemory);
	return NULL;
}

//============================================================================
// Default implementation of the font data release callback.  This just frees
// the memory we allocated.
//============================================================================

static void __cdecl TTI_ReleaseFontData
(
	void *pv
)
{
	free(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\makefont\makefont.cpp ===
//****************************************************************************
//
// XBox font file generator.  
//
// History:
//
//   07/06/00 [andrewso] - Created
//   08/04/00 [andrewso] - Added compressed glyph bitmaps
//
//****************************************************************************

// NOTE: This is a one-shot tool that isn't too good about releasing its
//  : memory when it is done

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <limits.h>
#include <xboxverp.h>

#define XFONT_TRUETYPE

#include "xfontformat-pc.h"
#include "xfont-pc.h"

//============================================================================
// Secret export from the xfont lib to give us the character data.
//============================================================================

extern "C"
HRESULT __fastcall XFONT_GetCharacterData(XFONT *pXFont, WCHAR wch, Glyph **ppGlyph, unsigned *pcbGlyphSize);

//============================================================================
// The options.
//============================================================================

static WCHAR *s_szInputFileName;
static WCHAR *s_szOutputFileName;
static WCHAR *s_szFontDirectory;
static WCHAR *s_szCodeName;

static WCHAR s_szFontFileName[MAX_PATH];
static unsigned s_uCellHeight;
static unsigned s_uDefaultCharacter;
static unsigned s_uAntialiasLevel;
static bool     s_fAntialiasLevelSet;
static unsigned s_uRLEWidth;

static unsigned s_uStyle;

static WCHAR *s_szFontFileNameCL;
static unsigned s_uCellHeightCL;
static unsigned s_uDefaultCharacterCL;
static unsigned s_uAntialiasLevelCL;
static bool     s_fAntialiasLevelCLSet;
static unsigned s_uRLEWidthCL;
static unsigned s_uStyleCL;

static bool s_fVerbose;

static unsigned s_uDescent;  // calculated

//============================================================================
// Program data.
//============================================================================

// The list of characters is handy to have around.  Keep and array of
// segments and encoded offsets.
//
static unsigned s_cCharacters;
static unsigned s_rgwCharset[CHAR_SEGMENT_MAX];

// The segment run table at its max size.
static unsigned s_cSegmentRuns;
static SegmentRun s_rgSegmentRuns[CHAR_SEGMENT_MAX / 2];

// The segment table at its maximum size.
static unsigned s_cSegments;
static SegmentDescriptor s_rgSegmentDescriptors[CHAR_SEGMENT_MAX];

// The glyph table.
static unsigned s_cGlyphs;
static Glyph **s_rgpGlyphs;
static DWORD  *s_rgdwGlyphOffsets;

static unsigned s_uMaxBitmapHeight;
static unsigned s_uMaxBitmapWidth;

// We may wind up building the glyphs multiple times to try to find the
// best RLE packet size.  If the user doesn't specify a size then we will
// search 2-5 bits.
//
static Glyph *s_rgpGlyphsTry[2][65536];
static DWORD  s_rgdwGlyphOffsetsTry[2][65536];

//============================================================================
// Displays the options for this tool.
//============================================================================

static void Usage()
{
    fprintf(stderr,
            "\nMakeFont version " VER_PRODUCTVERSION_STR "\n\n"
            "Usage: MakeFont [options] <input file> <output file>\n\n"
            "     -d <directory>      directory from which to load the TrueType font\n"
            "     -f <font file>      TrueType font file to load, -d is ignored\n"
            "     -h <height>         height of the font, in pixels\n"
            "     -e <hex number>     character to use as the default character\n"
            "     -a <alpha>          how much antialiasing information to store?  (0, 2, 4)\n"
            "     -r <bits>           how wide to make each RLE packet?  (0, 2-8)\n"
            "     -s <style>          NORMAL, BOLD, ITALICS or BOLDITALICS\n"
            "     -c <name>           Create a C structure called <name> in the output file\n"
            "     -v                  dump font statistics\n\n"
            "     All of the above options except -d and -c have corresponding commands in\n"
            "     the input file.\n");
}

//============================================================================
// Process the command line.  Returns false if it was invalid 
//============================================================================

static bool ParseCommandLine
(
    int argc,
    WCHAR **argv
)
{
    int i;

    // Loop through the options.
    for (i = 1; i < argc; i++)
    {
        if (argv[i][0] != '-' && argv[i][0] != '/')
        {
            if (!s_szInputFileName)
            {
                s_szInputFileName = argv[i];
            }
            else if (!s_szOutputFileName)
            {
                s_szOutputFileName = argv[i];
            }
            else
            {
                return false;
            }

            continue;
        }

        if (argv[i][2] != 0)
        {
            return false;
        }

        if (argv[i][1] == 'v')
        {
            s_fVerbose = true;
            continue;
        }

        if (argc - i == 1 || argv[i + 1][0] == '-' || argv[i + 1][0] == '/')
        {
            return false;
        }

        switch(argv[i][1])
        {
        case 'd':
            if (s_szFontDirectory)
            {
                return false;
            }

            s_szFontDirectory = argv[i + 1];
            break;

        case 'c':
            if (s_szCodeName)
            {
                return false;
            }

            s_szCodeName = argv[i + 1];
            break;

        case 'f':
            if (s_szFontFileNameCL)
            {
                return false;
            }

            s_szFontFileNameCL = argv[i + 1];
            break;

        case 'h':
            if (s_uCellHeightCL)
            {
                return false;
            }

            s_uCellHeightCL = wcstoul(argv[i + 1], NULL, 10);

            if (!s_uCellHeightCL)
            {
                return false;
            }
            break;

        case 'e':
            if (s_uDefaultCharacterCL)
            {
                return false;
            }

            s_uDefaultCharacterCL = wcstoul(argv[i + 1], NULL, 16);

            if (!s_uDefaultCharacterCL)
            {
                return false;
            }
            break;

        case 'a':
            if (s_fAntialiasLevelCLSet)
            {
                return false;
            }

            s_uAntialiasLevelCL = wcstoul(argv[i + 1], NULL, 10);
            s_fAntialiasLevelCLSet = true;

            if (s_uAntialiasLevelCL != 0 && s_uAntialiasLevelCL != 2 && s_uAntialiasLevelCL != 4)
            {
                return false;
            }                
            break;

        case 'r':
            if (s_uRLEWidthCL)
            {
                return false;
            }

            s_uRLEWidthCL = wcstoul(argv[i + 1], NULL, 10);

            if (s_uRLEWidthCL == 1 || s_uRLEWidthCL > 8)
            {
                return false;
            }                
            break;

        case 's':
            if (s_uStyleCL)
            {
                return false;
            }

            if (!_wcsicmp(argv[i + 1], L"NORMAL"))
            {
                s_uStyleCL = XFONT_NORMAL;
            }
            else if (!_wcsicmp(argv[i + 1], L"BOLD"))
            {
                s_uStyleCL = XFONT_BOLD;
            }
            else if (!_wcsicmp(argv[i + 1], L"ITALICS"))
            {
                s_uStyleCL = XFONT_ITALICS ;
            }
            else if (!_wcsicmp(argv[i + 1], L"BOLDITALICS"))
            {
                s_uStyleCL = XFONT_BOLDITALICS;
            }
            else
            {
                return false;
            }

            break;

        default:
            return false;
        }

        i++;
    }

    // Do we have our defaults?
    if (!s_szInputFileName || !s_szOutputFileName)
    {
        return false;
    }

    return true;
}

//============================================================================
// Get the next word from a string.  This destroys the string as it walks.
//============================================================================

static WCHAR *NextWord(/* in/out */WCHAR **pszString)
{
    // Nothing to walk.
    if (!*pszString)
    {
        return NULL;
    }

    // Find the start of the word.
    WCHAR *szStart = *pszString;

    while (*szStart && iswspace(*szStart))
    {
        szStart++;
    }   

    if (!*szStart)
    {
        *pszString = szStart;
        return NULL;
    }

    // Find its end.
    WCHAR *szEnd = szStart;

    if (*szStart == L'"')
    {
        szStart++;
        szEnd++;

        while (*szEnd && *szEnd != L'"')
        {
            szEnd++;
        }      
    }
    else
    {
        while (*szEnd && !iswspace(*szEnd))
        {
            szEnd++;
        }
    }

    if (!*szEnd)
    {
        *pszString = szEnd;
    }
    else
    {
        *pszString = szEnd + 1;
        *szEnd = 0;
    }

    return szStart;
}

//============================================================================
// Parse the input file.  Returns false if it fails.
//============================================================================

static bool LoadInputFile()
{
    FILE *pFile;
    WCHAR sz[1024], *szWalk, *szWord;
    unsigned l;
    unsigned cLines = 0;

    // The include file stack.
    const unsigned cFileStack = 4;
    unsigned iTopOfStack = 0;

    FILE *rgpFiles[cFileStack];
    unsigned rgcLines[cFileStack];
    WCHAR rgszFileNames[cFileStack][_MAX_PATH];

    WCHAR szCurrentFile[_MAX_PATH];

    // Open the file.
    pFile = _wfopen(s_szInputFileName, L"ra");

    wcscpy(szCurrentFile, s_szInputFileName);

    if (!pFile)
    {
        // UNDONE andrewso: better error message.
        printf("\nUnable to open the file character set file '%S'\n", s_szInputFileName);
        return false;
    }

    while (pFile)
    {
        // Read it in.
        while (!feof(pFile))
        {
            cLines++;

            fgetws(sz, sizeof(sz), pFile);

            szWalk = sz;

            // Get the first word.
            szWord = NextWord(&szWalk);

            // Ignore comments and blank lines.
            if (!szWord || *szWord == '#')
            {
                continue;
            }

            // Process our commands.
            if (!_wcsicmp(szWord, L"!include"))
            {
                szWord = NextWord(&szWalk);

                if (!szWord)
                {
                    printf("%S(%d): ERROR: Syntax error.\n", szCurrentFile, cLines);
                    continue;
                }

                if (iTopOfStack == cFileStack)
                {
                    printf("%S(%d): ERROR: Too many levels of !includes.\n", szCurrentFile, cLines);
                    continue;
                }

                // Push the old file state.
                rgpFiles[iTopOfStack] = pFile;
                rgcLines[iTopOfStack] = cLines;
                wcscpy(rgszFileNames[iTopOfStack], szCurrentFile);

                iTopOfStack++;

                // First try the file as is.
                wcscpy(szCurrentFile, szWord);

                pFile = _wfopen(szCurrentFile, L"ra");

                if (!pFile)
                {
                    WCHAR *pch;

                    // Try in the same directly as the previous file.
                    wcscpy(szCurrentFile, rgszFileNames[iTopOfStack - 1]);

                    pch = wcsrchr(szCurrentFile, L'\\');

                    if (pch)
                    {
                        wcscpy(pch + 1, szWord);

                        pFile = _wfopen(szCurrentFile, L"ra");
                    }
                }

                if (!pFile)
                {
                    printf("%S(%d): ERROR: Unable to open the include file '%s'.\n", szCurrentFile, cLines, szWord);
                    return false;
                }

                cLines = 0;
            }
            else if (!_wcsicmp(szWord, L"FONT"))
            {
                WCHAR *szFileName = NULL;
                unsigned uStyle = 0;

                szWord = NextWord(&szWalk);

                if (!szWord)
                {
                    printf("%S(%d): ERROR: Syntax error.\n", szCurrentFile, cLines);
                    continue;
                }

                if (!_wcsicmp(szWord, L"NORMAL"))
                {
                    uStyle = XFONT_NORMAL;
                }
                else if (!_wcsicmp(szWord, L"BOLD"))
                {
                    uStyle = XFONT_BOLD;
                }
                else if (!_wcsicmp(szWord, L"ITALICS"))
                {
                    uStyle = XFONT_ITALICS ;
                }
                else if (!_wcsicmp(szWord, L"BOLDITALICS"))
                {
                    uStyle = XFONT_BOLDITALICS;
                }

                szFileName = szWord;
                szWord = NextWord(&szWalk);
                    
                // We should be at the end.
                if (szWord)
                {
                    printf("%S(%d): ERROR: Syntax error.\n", szCurrentFile, cLines);
                    continue;
                }

                // Duplicates?
                if (*s_szFontFileName)
                {
                    printf("%S(%d): ERROR: The font file name can only be specified once.\n", szCurrentFile, cLines);
                    continue;
                }

                unsigned iLen = 0;

                if (s_szFontDirectory)
                {
                    iLen = wcslen(s_szFontDirectory);

                    wcscpy(s_szFontFileName, s_szFontDirectory);
                    if (s_szFontDirectory[iLen - 1] != L':' && s_szFontDirectory[iLen - 1] != L'\\')
                    {
                        s_szFontFileName[iLen++] = L'\\';
                    }
                }

                wcscpy(s_szFontFileName + iLen, szFileName);
                s_uStyle = uStyle;
            }

            else if (!_wcsicmp(szWord, L"HEIGHT"))
            {
                szWord = NextWord(&szWalk);

                if (!szWord)
                {
                    printf("%S(%d): ERROR: Syntax error.\n", szCurrentFile, cLines);
                    continue;
                }

                l = wcstoul(szWord, NULL, 10);

                if (l == 0)
                {
                    printf("%S(%d): ERROR: Bad font height.\n", szCurrentFile, cLines);
                    continue;
                }
                else if (s_uCellHeight)
                {
                    printf("%S(%d): ERROR: The font height can only be set once.\n", szCurrentFile, cLines);
                    continue;
                }
                else
                {
                    s_uCellHeight = l;
                }
            }

            else if (!_wcsicmp(szWord, L"DEFAULT"))
            {
                szWord = NextWord(&szWalk);

                if (!szWord)
                {
                    printf("%S(%d): ERROR: Syntax error.\n", szCurrentFile, cLines);
                    continue;
                }

                l = wcstoul(szWord, NULL, 16);

                if (l == 0)
                {
                    printf("%S(%d): ERROR: Bad default character.\n", szCurrentFile, cLines);
                    continue;
                }
                else if (s_uDefaultCharacter)
                {
                    printf("%S(%d): ERROR: The default character can only be set once.\n", szCurrentFile, cLines);
                    continue;
                }
                else
                {
                    s_uDefaultCharacter = l;
                }
            }

            else if (!_wcsicmp(szWord, L"ANTIALIASLEVEL"))
            {
                szWord = NextWord(&szWalk);

                if (!szWord)
                {
                    printf("%S(%d): ERROR: Syntax error.\n", szCurrentFile, cLines);
                    continue;
                }

                l = wcstoul(szWord, NULL, 10);

                if (l != 0 && l != 2 && l != 4)
                {
                    printf("%S(%d): ERROR: Bad antialias level value.\n", szCurrentFile, cLines);
                    continue;
                }
                else if (s_fAntialiasLevelSet)
                {
                    printf("%S(%d): ERROR: The antiailias level can only be set once.\n", szCurrentFile, cLines);
                    continue;
                }

                s_uAntialiasLevel = l;
                s_fAntialiasLevelSet = true;
            }

            else if (!_wcsicmp(szWord, L"RLEWIDTH"))
            {
                szWord = NextWord(&szWalk);

                if (!szWord)
                {
                    printf("%S(%d): ERROR: Syntax error.\n", szCurrentFile, cLines);
                    continue;
                }

                l = wcstoul(szWord, NULL, 10);

                if (l < 2 || l > 8)
                {
                    printf("%S(%d): ERROR: Bad RLE width value.\n", szCurrentFile, cLines);
                    continue;
                }
                else if (s_uRLEWidth)
                {
                    printf("%S(%d): ERROR: The RLE width can only be set once.\n", szCurrentFile, cLines);
                    continue;
                }

                s_uRLEWidth = l;
            }

            // Store the character.
            else
            {
                // Skip a leading 'U+'.
                if (*szWord == 'U' && *(szWord + 1) == '+')
                {
                    szWord += 2;
                }

                l = wcstoul(szWord, NULL, 16);

                if (!l)
                {
                    // See if this is actually the number zero or if we have some other funky
                    // thing.
                    //
                    while (isalnum(*szWord))
                    {
                        if (*szWord != '0')
                        {
                            printf("%S(%d): ERROR: Syntax error.\n", szCurrentFile, cLines);
                            break;
                        }

                        szWord++;
                    }

                    // The above check failed, move to the next line.
                    if (isalnum(*szWord))
                    {
                        continue;
                    }
                }

                s_cCharacters++;
                s_rgwCharset[CHAR_SEGMENT(l)] |= 1 << CHAR_OFFSET(l);
            }
        }

        fclose(pFile);
        pFile = NULL;

        if (iTopOfStack)
        {
            iTopOfStack--;

            pFile = rgpFiles[iTopOfStack];
            cLines = rgcLines[iTopOfStack];
            wcscpy(szCurrentFile, rgszFileNames[iTopOfStack]);
        }
    }

    // Have a file?
    if (s_szFontFileNameCL)
    {
        if (*s_szFontFileName)
        {
            printf("WARNING: The command line is overriding the 'FONT' input command.\n");
        }

        wcscpy(s_szFontFileName, s_szFontFileNameCL);
        s_uStyle = 0;
    }
    else if (!*s_szFontFileName)
    {
        printf("ERROR: No fonts specified in the input file.\n");
        return false;
    }

    // Style?
    if (s_uStyleCL)
    {
        if (s_uStyle)
        {
            printf("WARNING: The command line is overriding the style of the 'FONT' input command.\n");
        }

        s_uStyle = s_uStyleCL;
    }
    else if (!s_uStyle)
    {
        s_uStyle = XFONT_NORMAL;
    }

    // Height set?
    if (s_uCellHeightCL)
    {
        if (s_uCellHeight)
        {
            printf("WARNING: The command line is overriding the 'HEIGHT' input command.\n");
        }

        s_uCellHeight = s_uCellHeightCL;
    }
    else if (!s_uCellHeight)
    {
        printf("ERROR: The font height has not been set.\n");
        return false;
    }

    // Default character?
    if (s_uDefaultCharacterCL)
    {
        if (s_uDefaultCharacter)
        {
            printf("WARNING: The command line is overriding the 'DEFAULT' input command.\n");
        }

        s_uDefaultCharacter = s_uDefaultCharacterCL;
    }
    else if (!s_uDefaultCharacter)
    {
        printf("ERROR: The default character has not been set.\n");
        return false;
    }

    if (!(s_rgwCharset[CHAR_SEGMENT(s_uDefaultCharacter)] & (1 << CHAR_OFFSET(s_uDefaultCharacter))))
    {
        printf("ERROR: The default character must be one of the characters specified in the file.\n");
        return false;
    }

    // Set the default alpha.
    if (s_fAntialiasLevelCLSet)
    {
        if (s_fAntialiasLevelSet)
        {
            printf("WARNING: The command line is overriding the 'ANTIALIASLEVEL' input command.\n");
        }

        s_uAntialiasLevel = s_uAntialiasLevelCL;
    }

    // Set the default alpha.
    if (s_uRLEWidthCL)
    {
        if (s_uRLEWidth)
        {
            printf("WARNING: The command line is overriding the 'RLEWIDTH' input command.\n");
        }

        s_uRLEWidth = s_uRLEWidthCL;
    }
    return true;
}

//============================================================================
// Build the initial tables.  This does pretty much everything except
// produce the glyphs and fill in the offsets.
//============================================================================

static void BuildTables()
{
    unsigned iSegment;
    bool fInRun = false;

    // Walk through the segment table and identify all of the runs.
    for (iSegment = 0; iSegment < CHAR_SEGMENT_MAX; iSegment++)
    {
        // We just started/continued a run.
        if (s_rgwCharset[iSegment])
        {
            if (!fInRun)
            {
                fInRun = true;

                // Remember the start.
                s_rgSegmentRuns[s_cSegmentRuns].wFirstSegment = (WORD)iSegment;

                // Point to the next entry in the SegmentDescriptor table.
                s_rgSegmentRuns[s_cSegmentRuns].iSegmentTable = (WORD)s_cSegments;
            }

            // Build the segment descriptor.
            s_rgSegmentDescriptors[s_cSegments].iGlyph = (WORD)s_cGlyphs;
            s_rgSegmentDescriptors[s_cSegments].wCharMask = (WORD)s_rgwCharset[iSegment];

            // Remember the number of glyphs in this segment.
            unsigned uChars = s_rgwCharset[iSegment];

            while (uChars)
            {
                s_cGlyphs++;

                uChars &= (uChars - 1);
            }

            // We have another segment.
            s_rgSegmentRuns[s_cSegmentRuns].cSegments++;
            s_cSegments++;
        }

        // We just ended a run.
        else if (fInRun)
        {
            fInRun = false;
            s_cSegmentRuns++;
        }
    }

    // Make sure the last run is remembered.
    if (fInRun)
    {
        s_cSegmentRuns++;
    }

}

//============================================================================
// Open the font and generate all of the glyphs.
//============================================================================

static bool BuildGlyphs()
{
    HRESULT hr = NOERROR;

    XFONT *pFont;

    // Process the font for this style.
    hr = XFONT_OpenTrueTypeFont(s_szFontFileName, 0, &pFont);

    if (FAILED(hr))
    {
        printf("ERROR: Unable to initialize TrueType scaler.\n");
        return false;
    }

    // Set the size.
    hr = XFONT_SetTextHeight(pFont, s_uCellHeight);

    if (FAILED(hr))
    {
        printf("ERROR: Unable to initialize TrueType scaler.\n");
        return false;
    }

    // Set the antialiasing level.
    hr = XFONT_SetTextAntialiasLevel(pFont, s_uAntialiasLevel);

    if (FAILED(hr))
    {
        printf("ERROR: Unable to initialize TrueType scaler.\n");
        return false;
    }

    // Set the style.
    hr = XFONT_SetTextStyle(pFont, s_uStyle);

    if (FAILED(hr))
    {
        printf("ERROR: Unable to initialize TrueType scaler.\n");
        return false;
    }

    // Get the descent from the font scaler.  
    XFONT_GetFontMetrics(pFont, NULL, &s_uDescent);

    // Loop through each character and get its ABCs.  We do this three times
    // to find the best compression for this character set.
    //
    {
        unsigned uBitmapHeight;
        unsigned uBitmapWidth;
        unsigned uBitmapPitch;
        unsigned uBitmapSize;
        unsigned uAdvance;
        signed iBearingX;
        signed iBearingY;

        unsigned iCurrentTrySet = 0;
        unsigned iTryMin = 2;
        unsigned iTryMax = 5;

        s_rgpGlyphs = s_rgpGlyphsTry[0];
        s_rgdwGlyphOffsets = s_rgdwGlyphOffsetsTry[0];

        if (s_uRLEWidth)
        {
            iTryMin = s_uRLEWidth;
            iTryMax = s_uRLEWidth;
        }
        else
        {
            s_uRLEWidth = iTryMin;
        }

        for (unsigned iTry = iTryMin; iTry <= iTryMax; iTry++)
        {
            // Get the glyph table.
            Glyph **ppGlyph = s_rgpGlyphsTry[iCurrentTrySet];
            DWORD *pdwGlyphOffset = s_rgdwGlyphOffsetsTry[iCurrentTrySet];
            DWORD dwGlyphOffset = 0;

            // Set the encoding width.
            XFONT_SetRLEWidth(pFont, iTry);

            unsigned iSegment, iOffset;

            for (iSegment = 0; iSegment < CHAR_SEGMENT_MAX; iSegment++)
            {
                for (iOffset = 0; iOffset < CHAR_OFFSET_MAX; iOffset++)
                {
                    if (s_rgwCharset[iSegment] & (1 << iOffset))
                    {
                        WCHAR wch = MAKE_CHAR(iSegment, iOffset);

                        Glyph *pGlyphFromFont, *pGlyph;
                        unsigned cbGlyphSize;

                        // Get the size of the character.
                        hr = XFONT_GetCharacterData(pFont, 
                                                    wch,
                                                    &pGlyphFromFont,
                                                    &cbGlyphSize);

                        if (FAILED(hr))
                        {
                            printf("ERROR: Unable to convert character %04X.\n", wch);
                            return false;
                        }

                        if (wch != s_uDefaultCharacter && hr == S_FALSE)
                        {
                            printf("WARNING: Character %04X is not in the source font.\n", wch);
                        }

                        // Save the bitmap.
                        unsigned cbSize = cbGlyphSize;

                        pGlyph = (Glyph *)malloc(cbSize);

                        if (!pGlyph)
                        {
                            printf("ERROR: Out of memory.\n");
                            return false;
                        }

                        memcpy(pGlyph, pGlyphFromFont, cbSize);

                        if (pGlyph->uBitmapHeight > s_uMaxBitmapHeight)
                        {
                            s_uMaxBitmapHeight = pGlyph->uBitmapHeight;
                        }

                        if (pGlyph->uBitmapWidth > s_uMaxBitmapWidth)
                        {
                            s_uMaxBitmapWidth = pGlyph->uBitmapWidth;
                        }

                        // Set the info.
                        *ppGlyph = pGlyph;
                        *pdwGlyphOffset = dwGlyphOffset;

                        dwGlyphOffset += cbSize;

                        ppGlyph++;                
                        pdwGlyphOffset++;
                    }
                }
            }
            
            // Save the last offset so we can use it to calculate the glyph size
            // when we write it to a file.
            //
            *pdwGlyphOffset = dwGlyphOffset;

            // Is this smaller?
            if (dwGlyphOffset <= s_rgdwGlyphOffsets[s_cGlyphs])
            {
                s_uRLEWidth = iTry;
                s_rgpGlyphs = s_rgpGlyphsTry[iCurrentTrySet];
                s_rgdwGlyphOffsets = s_rgdwGlyphOffsetsTry[iCurrentTrySet];

                iCurrentTrySet = ~iCurrentTrySet & 1;
            }
        }
    }

    return true;
}

//============================================================================
// Writes bytes out to a binary file.
//============================================================================

static DWORD WriteBinary
(
    HANDLE hFile,
    void *pData,
    DWORD Size
)
{
    DWORD BytesWritten;

    if (!WriteFile(hFile, pData, Size, &BytesWritten, NULL))
    {
        return 0;
    }
    else
    {
        return BytesWritten;
    }
}

//============================================================================
// Writes bytes out to a code file.
//============================================================================

static DWORD s_uColumn;

static DWORD WriteCode
(
    HANDLE hFile,
    void *pData,
    DWORD Size
)
{
    char Buffer[16];
    BYTE *pByte = (BYTE *)pData;

    DWORD BytesWritten;
    DWORD TotalBytes = Size;

    while (Size)
    {
        if (s_uColumn % 32 == 0)
        {
            if (!WriteFile(hFile, "\r\n    ", 6, &BytesWritten, NULL))
            {
                return 0;
            }
        }

        sprintf(Buffer, "0x%02X, ", *pByte);

        if (!WriteFile(hFile, Buffer, 6, &BytesWritten, NULL))
        {
            return 0;
        }

        s_uColumn++;
        pByte++;
        Size--;
    }
    
    return TotalBytes;
}

//============================================================================
// Writes the font out to the font file.
//============================================================================

typedef DWORD (WRITEMETHOD)(HANDLE hFile, void *pData, DWORD Size);

static bool WriteFont()
{
    bool retval = false;
    HANDLE hFile;
    DWORD dwBytes;
    DWORD dwTotalBytes = 0;

    WRITEMETHOD *pfnWrite;

    char Buffer[256];

    // Open the file.
    hFile = CreateFile(s_szOutputFileName,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        printf("ERROR: Unable to open output file.\n");
        return false;
    }

    if (s_szCodeName)
    {
        pfnWrite = WriteCode;

        sprintf(Buffer, "_declspec(selectany) const BYTE %S[] =\r\n{", s_szCodeName);

        if (!WriteFile(hFile, Buffer, strlen(Buffer), &dwBytes, NULL))
        {
            printf("ERROR: Unable to write to output file.\n");
            goto Error;
        }
    }
    else
    {
        pfnWrite = WriteBinary;
    }

    // Build and write the header.
    FontHeader header;

    header.wSignature = (WORD)'XFNT';
    header.wVersion = FILE_VERSION;
    header.cGlyphs = (WORD)s_cGlyphs + 1;
    header.cSegmentRunTable = (WORD)s_cSegmentRuns;
    header.wDefaultChar = (WORD)s_uDefaultCharacter;
    header.uCellHeight = (BYTE)s_uCellHeight;
    header.uDescent = (BYTE)s_uDescent;
    header.uAntialiasLevel = (BYTE)s_uAntialiasLevel;
    header.uRLEWidth = (BYTE)s_uRLEWidth;
    header.uMaxBitmapHeight = (BYTE)s_uMaxBitmapHeight;
    header.uMaxBitmapWidth = (BYTE)s_uMaxBitmapWidth;

    dwBytes = pfnWrite(hFile, &header, sizeof(FontHeader));

    if (!dwBytes)
    {
        printf("ERROR: Unable to write to output file.\n");
        goto Error;
    }

    if (s_fVerbose)
    {
        dwTotalBytes += dwBytes;

        printf("Header            : %d bytes\n", dwBytes);
    }

    // Fix up the offset table and write it.
    {
        DWORD dwGlyphOffsetBase = sizeof(FontHeader) 
                                  + sizeof(DWORD) * (s_cGlyphs + 1)
                                  + sizeof(SegmentRun) * s_cSegmentRuns 
                                  + sizeof(SegmentDescriptor) * s_cSegments;

        unsigned i, c = s_cGlyphs;

        for (i = 0; i < c + 1; i++)
        {
            s_rgdwGlyphOffsets[i] += dwGlyphOffsetBase;
        }

        dwBytes = pfnWrite(hFile, s_rgdwGlyphOffsets, sizeof(DWORD) * (s_cGlyphs + 1));

        if (!dwBytes)
        {
            printf("ERROR: Unable to write to output file.\n");
            goto Error;
        }

        if (s_fVerbose)
        {
            dwTotalBytes += dwBytes;

            printf("Glyph offset table: %d entries for %d bytes\n", s_cGlyphs + 1, dwBytes);
        }
    }

    // Write the segment run table.
    dwBytes = pfnWrite(hFile, s_rgSegmentRuns, sizeof(SegmentRun) * s_cSegmentRuns);

    if (!dwBytes)
    {
        printf("ERROR: Unable to write to output file.\n");
        goto Error;
    }

    if (s_fVerbose)
    {
        dwTotalBytes += dwBytes;

        printf("Segment run table : %d entries for %d bytes\n", s_cSegmentRuns, dwBytes);
    }

    // Write the segment descriptor table.
    dwBytes = pfnWrite(hFile, s_rgSegmentDescriptors, sizeof(SegmentDescriptor) * s_cSegments);

    if (!dwBytes)
    {
        printf("ERROR: Unable to write to output file.\n");
        goto Error;
    }

    if (s_fVerbose)
    {
        dwTotalBytes += dwBytes;

        printf("Segment table     : %d entries for %d bytes\n", s_cSegments, dwBytes);
    }

    // Write out the glyphs.
    {
        unsigned i, c = s_cGlyphs;
        DWORD dwGlyphBytes = 0;

        for (i = 0; i < c; i++)
        {
            dwBytes = pfnWrite(hFile, s_rgpGlyphs[i], s_rgdwGlyphOffsets[i + 1] - s_rgdwGlyphOffsets[i]);

            if (!dwBytes)
            {
                printf("ERROR: Unable to write to output file.\n");
                goto Error;
            }

            dwGlyphBytes += dwBytes;
        }

        if (s_fVerbose)
        {    
            dwTotalBytes += dwGlyphBytes;

            printf("Glyphs            : %d glyphs for %d bytes using %d bit RLE packets\n\n", s_cGlyphs, dwGlyphBytes, s_uRLEWidth);
            printf("Total font size   : %d bytes\n", dwTotalBytes);
        }
    }

    if (s_szCodeName)
    {
        if (!WriteFile(hFile, "\r\n};\r\n", strlen("\r\n};\r\n"), &dwBytes, NULL))
        {
            printf("ERROR: Unable to write to output file.\n");
            goto Error;
        }
    }

    retval = true;

Error:
    CloseHandle(hFile);
                       
    return retval;
}

//============================================================================
// Main entrypoint.
//============================================================================

int __cdecl wmain(int argc, WCHAR **argv)
{
    // Process the command line.
    if (!ParseCommandLine(argc, argv))
    {
        Usage();
        return 1;
    }

    // Load the input file into memory.
    if (!LoadInputFile())
    {
        return 1;
    }

    // Build the lookup tables.
    BuildTables();

    // Open the font and create the glyphs.
    if (!BuildGlyphs())
    {
        return 1;
    }

    // Write out the font.
    if (!WriteFont())
    {
        return 1;
    }

    // Success!
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\library\default.h ===
_declspec(selectany) const BYTE g_DefaultFont[] =
{
    0x54, 0x4E, 0x02, 0x00, 0xC1, 0x00, 0x02, 0x00, 0x1F, 0x00, 0x18, 0x05, 0x00, 0x03, 0x16, 0x17, 0x54, 0x03, 0x00, 0x00, 0x73, 0x03, 0x00, 0x00, 0x78, 0x03, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 
    0x8B, 0x03, 0x00, 0x00, 0xA8, 0x03, 0x00, 0x00, 0xC9, 0x03, 0x00, 0x00, 0xF7, 0x03, 0x00, 0x00, 0x18, 0x04, 0x00, 0x00, 0x1F, 0x04, 0x00, 0x00, 0x35, 0x04, 0x00, 0x00, 0x4B, 0x04, 0x00, 0x00, 
    0x59, 0x04, 0x00, 0x00, 0x6B, 0x04, 0x00, 0x00, 0x73, 0x04, 0x00, 0x00, 0x7A, 0x04, 0x00, 0x00, 0x80, 0x04, 0x00, 0x00, 0x93, 0x04, 0x00, 0x00, 0xAD, 0x04, 0x00, 0x00, 0xC0, 0x04, 0x00, 0x00, 
    0xD9, 0x04, 0x00, 0x00, 0xF2, 0x04, 0x00, 0x00, 0x0E, 0x05, 0x00, 0x00, 0x27, 0x05, 0x00, 0x00, 0x43, 0x05, 0x00, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x78, 0x05, 0x00, 0x00, 0x94, 0x05, 0x00, 0x00, 
    0x9C, 0x05, 0x00, 0x00, 0xA6, 0x05, 0x00, 0x00, 0xB6, 0x05, 0x00, 0x00, 0xC0, 0x05, 0x00, 0x00, 0xD1, 0x05, 0x00, 0x00, 0xEA, 0x05, 0x00, 0x00, 0x25, 0x06, 0x00, 0x00, 0x45, 0x06, 0x00, 0x00, 
    0x62, 0x06, 0x00, 0x00, 0x7E, 0x06, 0x00, 0x00, 0x9B, 0x06, 0x00, 0x00, 0xB2, 0x06, 0x00, 0x00, 0xCA, 0x06, 0x00, 0x00, 0xE9, 0x06, 0x00, 0x00, 0x02, 0x07, 0x00, 0x00, 0x0A, 0x07, 0x00, 0x00, 
    0x1D, 0x07, 0x00, 0x00, 0x40, 0x07, 0x00, 0x00, 0x58, 0x07, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00, 0x9B, 0x07, 0x00, 0x00, 0xB8, 0x07, 0x00, 0x00, 0xD2, 0x07, 0x00, 0x00, 0xF2, 0x07, 0x00, 0x00, 
    0x14, 0x08, 0x00, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x48, 0x08, 0x00, 0x00, 0x62, 0x08, 0x00, 0x00, 0x85, 0x08, 0x00, 0x00, 0xBC, 0x08, 0x00, 0x00, 0xDE, 0x08, 0x00, 0x00, 0xFE, 0x08, 0x00, 0x00, 
    0x17, 0x09, 0x00, 0x00, 0x2B, 0x09, 0x00, 0x00, 0x3D, 0x09, 0x00, 0x00, 0x51, 0x09, 0x00, 0x00, 0x62, 0x09, 0x00, 0x00, 0x69, 0x09, 0x00, 0x00, 0x71, 0x09, 0x00, 0x00, 0x86, 0x09, 0x00, 0x00, 
    0x9E, 0x09, 0x00, 0x00, 0xB1, 0x09, 0x00, 0x00, 0xC9, 0x09, 0x00, 0x00, 0xDB, 0x09, 0x00, 0x00, 0xEE, 0x09, 0x00, 0x00, 0x05, 0x0A, 0x00, 0x00, 0x1B, 0x0A, 0x00, 0x00, 0x23, 0x0A, 0x00, 0x00, 
    0x37, 0x0A, 0x00, 0x00, 0x53, 0x0A, 0x00, 0x00, 0x5B, 0x0A, 0x00, 0x00, 0x74, 0x0A, 0x00, 0x00, 0x84, 0x0A, 0x00, 0x00, 0x96, 0x0A, 0x00, 0x00, 0xAE, 0x0A, 0x00, 0x00, 0xC6, 0x0A, 0x00, 0x00, 
    0xD5, 0x0A, 0x00, 0x00, 0xE5, 0x0A, 0x00, 0x00, 0xF6, 0x0A, 0x00, 0x00, 0x06, 0x0B, 0x00, 0x00, 0x1D, 0x0B, 0x00, 0x00, 0x3F, 0x0B, 0x00, 0x00, 0x55, 0x0B, 0x00, 0x00, 0x72, 0x0B, 0x00, 0x00, 
    0x85, 0x0B, 0x00, 0x00, 0x9B, 0x0B, 0x00, 0x00, 0xA3, 0x0B, 0x00, 0x00, 0xB9, 0x0B, 0x00, 0x00, 0xC1, 0x0B, 0x00, 0x00, 0xC6, 0x0B, 0x00, 0x00, 0xCE, 0x0B, 0x00, 0x00, 0xEF, 0x0B, 0x00, 0x00, 
    0x09, 0x0C, 0x00, 0x00, 0x22, 0x0C, 0x00, 0x00, 0x3F, 0x0C, 0x00, 0x00, 0x48, 0x0C, 0x00, 0x00, 0x68, 0x0C, 0x00, 0x00, 0x70, 0x0C, 0x00, 0x00, 0x99, 0x0C, 0x00, 0x00, 0xA7, 0x0C, 0x00, 0x00, 
    0xBD, 0x0C, 0x00, 0x00, 0xCA, 0x0C, 0x00, 0x00, 0xD1, 0x0C, 0x00, 0x00, 0xFA, 0x0C, 0x00, 0x00, 0x01, 0x0D, 0x00, 0x00, 0x0C, 0x0D, 0x00, 0x00, 0x20, 0x0D, 0x00, 0x00, 0x2D, 0x0D, 0x00, 0x00, 
    0x3A, 0x0D, 0x00, 0x00, 0x42, 0x0D, 0x00, 0x00, 0x57, 0x0D, 0x00, 0x00, 0x83, 0x0D, 0x00, 0x00, 0x89, 0x0D, 0x00, 0x00, 0x91, 0x0D, 0x00, 0x00, 0x9C, 0x0D, 0x00, 0x00, 0xAB, 0x0D, 0x00, 0x00, 
    0xC1, 0x0D, 0x00, 0x00, 0xE8, 0x0D, 0x00, 0x00, 0x0F, 0x0E, 0x00, 0x00, 0x38, 0x0E, 0x00, 0x00, 0x51, 0x0E, 0x00, 0x00, 0x76, 0x0E, 0x00, 0x00, 0x9B, 0x0E, 0x00, 0x00, 0xC1, 0x0E, 0x00, 0x00, 
    0xE8, 0x0E, 0x00, 0x00, 0x0E, 0x0F, 0x00, 0x00, 0x36, 0x0F, 0x00, 0x00, 0x5E, 0x0F, 0x00, 0x00, 0x80, 0x0F, 0x00, 0x00, 0x9B, 0x0F, 0x00, 0x00, 0xB6, 0x0F, 0x00, 0x00, 0xD2, 0x0F, 0x00, 0x00, 
    0xED, 0x0F, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x16, 0x10, 0x00, 0x00, 0x2D, 0x10, 0x00, 0x00, 0x43, 0x10, 0x00, 0x00, 0x63, 0x10, 0x00, 0x00, 0x83, 0x10, 0x00, 0x00, 0xA5, 0x10, 0x00, 0x00, 
    0xC7, 0x10, 0x00, 0x00, 0xEA, 0x10, 0x00, 0x00, 0x0F, 0x11, 0x00, 0x00, 0x32, 0x11, 0x00, 0x00, 0x44, 0x11, 0x00, 0x00, 0x66, 0x11, 0x00, 0x00, 0x83, 0x11, 0x00, 0x00, 0xA1, 0x11, 0x00, 0x00, 
    0xC0, 0x11, 0x00, 0x00, 0xDE, 0x11, 0x00, 0x00, 0x03, 0x12, 0x00, 0x00, 0x1D, 0x12, 0x00, 0x00, 0x3B, 0x12, 0x00, 0x00, 0x55, 0x12, 0x00, 0x00, 0x6F, 0x12, 0x00, 0x00, 0x89, 0x12, 0x00, 0x00, 
    0xA4, 0x12, 0x00, 0x00, 0xBE, 0x12, 0x00, 0x00, 0xDA, 0x12, 0x00, 0x00, 0xF6, 0x12, 0x00, 0x00, 0x0D, 0x13, 0x00, 0x00, 0x23, 0x13, 0x00, 0x00, 0x39, 0x13, 0x00, 0x00, 0x50, 0x13, 0x00, 0x00, 
    0x67, 0x13, 0x00, 0x00, 0x78, 0x13, 0x00, 0x00, 0x89, 0x13, 0x00, 0x00, 0x9C, 0x13, 0x00, 0x00, 0xAE, 0x13, 0x00, 0x00, 0xC5, 0x13, 0x00, 0x00, 0xDB, 0x13, 0x00, 0x00, 0xF1, 0x13, 0x00, 0x00, 
    0x07, 0x14, 0x00, 0x00, 0x1E, 0x14, 0x00, 0x00, 0x36, 0x14, 0x00, 0x00, 0x4D, 0x14, 0x00, 0x00, 0x5A, 0x14, 0x00, 0x00, 0x72, 0x14, 0x00, 0x00, 0x86, 0x14, 0x00, 0x00, 0x9A, 0x14, 0x00, 0x00, 
    0xAF, 0x14, 0x00, 0x00, 0xC4, 0x14, 0x00, 0x00, 0xE5, 0x14, 0x00, 0x00, 0x03, 0x15, 0x00, 0x00, 0x25, 0x15, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x06, 0x00, 0x07, 0x00, 
    0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0xFF, 0xFF, 0x11, 0x00, 0xFF, 0xFF, 0x21, 0x00, 0xFF, 0xFF, 0x31, 0x00, 0xFF, 0xFF, 0x41, 0x00, 0xFF, 0xFF, 0x51, 0x00, 0xFF, 0x7F, 0x60, 0x00, 0xFF, 0xFF, 
    0x70, 0x00, 0xFF, 0xFF, 0x80, 0x00, 0xFF, 0xFF, 0x90, 0x00, 0xFF, 0xFF, 0xA0, 0x00, 0xFF, 0xFF, 0xB0, 0x00, 0xFF, 0xFF, 0x12, 0x12, 0x18, 0x03, 0x12, 0xF8, 0xFF, 0xEF, 0x07, 0x7F, 0xF0, 0x07, 
    0x7F, 0xF0, 0x07, 0x7F, 0xF0, 0x07, 0x7F, 0xF0, 0x07, 0x7F, 0xF0, 0x07, 0x7F, 0xF0, 0x07, 0x7F, 0xFC, 0xFF, 0x07, 0x00, 0x00, 0x07, 0x00, 0x00, 0x11, 0x02, 0x07, 0x02, 0x11, 0xF8, 0x5F, 0x12, 
    0x06, 0x06, 0x09, 0x01, 0x11, 0x90, 0x28, 0x8A, 0xA2, 0x28, 0x01, 0x11, 0x0C, 0x0D, 0x00, 0x11, 0xD4, 0x54, 0x4D, 0xD5, 0x44, 0x4D, 0xD5, 0xA4, 0xFF, 0x9B, 0x26, 0x4E, 0xA3, 0xA6, 0xFD, 0x9F, 
    0x34, 0x55, 0x13, 0x35, 0x55, 0x53, 0x35, 0x11, 0x14, 0x0B, 0x0D, 0x01, 0x12, 0xCD, 0x53, 0x5E, 0x99, 0x92, 0x45, 0x8B, 0xBA, 0x8C, 0x8B, 0xA5, 0xD8, 0x87, 0x8F, 0x64, 0x8E, 0xBA, 0x8C, 0xCB, 
    0xAA, 0x4C, 0x59, 0x22, 0xED, 0x61, 0x9F, 0x7C, 0x29, 0x12, 0x11, 0x15, 0x02, 0x11, 0xDA, 0x21, 0x2A, 0xAA, 0xA8, 0x89, 0xA2, 0xA6, 0xA9, 0x9A, 0xA6, 0x6A, 0x92, 0xAC, 0x49, 0x3A, 0x14, 0x49, 
    0xD7, 0xA6, 0x1F, 0xDA, 0x2E, 0x49, 0xD1, 0x21, 0x69, 0xB2, 0xA4, 0xA9, 0x9A, 0xA6, 0x6A, 0x9A, 0x28, 0x6A, 0xA2, 0xAA, 0x88, 0x3A, 0x26, 0x11, 0x0E, 0x10, 0x01, 0x11, 0xE4, 0xE5, 0x63, 0x9A, 
    0x45, 0x59, 0xD4, 0x21, 0xE9, 0xE9, 0xC5, 0xAB, 0xCF, 0xA4, 0x29, 0xA3, 0xA4, 0xC8, 0x94, 0x8E, 0x49, 0xC7, 0x26, 0x5A, 0x8F, 0xB6, 0x32, 0x01, 0x06, 0x02, 0x05, 0x01, 0x11, 0x78, 0x01, 0x16, 
    0x06, 0x08, 0x01, 0x11, 0xD4, 0x34, 0x51, 0x13, 0x45, 0x4D, 0x14, 0x45, 0x51, 0x14, 0x45, 0x55, 0x14, 0x55, 0x51, 0x55, 0x05, 0x16, 0x06, 0x08, 0x01, 0x11, 0x50, 0x55, 0x51, 0x15, 0x45, 0x55, 
    0x14, 0x45, 0x51, 0x14, 0x45, 0x4D, 0x14, 0x35, 0x51, 0xD3, 0x44, 0x07, 0x08, 0x09, 0x01, 0x11, 0x93, 0x35, 0x45, 0xF9, 0xC4, 0x49, 0x92, 0xA4, 0x00, 0x0C, 0x0C, 0x0E, 0x01, 0x0E, 0xD5, 0xA7, 
    0x4F, 0x9F, 0x3E, 0xF5, 0xFF, 0xAA, 0x4F, 0x9F, 0x3E, 0x7D, 0x2A, 0x05, 0x02, 0x07, 0x02, 0x02, 0x60, 0x12, 0x05, 0x02, 0x06, 0x08, 0x01, 0x07, 0x78, 0x01, 0x02, 0x02, 0x07, 0x02, 0x02, 0x20, 
    0x11, 0x07, 0x07, 0x00, 0x11, 0x55, 0x45, 0x55, 0x15, 0x55, 0x55, 0x1C, 0x55, 0x55, 0x54, 0x55, 0x51, 0x55, 0x01, 0x11, 0x0B, 0x0D, 0x01, 0x11, 0x6B, 0x8F, 0x6D, 0x93, 0xAA, 0xE8, 0xE0, 0xC1, 
    0x83, 0x07, 0x0F, 0x1E, 0x3C, 0x78, 0xF0, 0x50, 0x54, 0x69, 0xDB, 0x8E, 0x76, 0x11, 0x06, 0x0D, 0x03, 0x11, 0x0D, 0xB5, 0xE5, 0xD0, 0x26, 0x8A, 0xA2, 0x28, 0x8A, 0xA2, 0x28, 0x8A, 0xA2, 0x00, 
    0x11, 0x0B, 0x0D, 0x01, 0x11, 0x2B, 0x2F, 0xA9, 0x8A, 0x0E, 0x1E, 0xBA, 0x74, 0xE9, 0xD1, 0xA3, 0x47, 0x8F, 0x1E, 0x3D, 0x7A, 0xF4, 0xE8, 0xF9, 0x1F, 0x11, 0x0B, 0x0D, 0x01, 0x11, 0x63, 0x9F, 
    0x89, 0x8B, 0xAC, 0xC8, 0xBA, 0xF4, 0xC8, 0x3C, 0xFA, 0xE9, 0xD3, 0xC5, 0x83, 0x87, 0xA2, 0x4A, 0x4F, 0x3B, 0x11, 0x0C, 0x0D, 0x00, 0x11, 0x8F, 0xAE, 0x3D, 0x7C, 0x78, 0x28, 0xB2, 0xA4, 0x6A, 
    0xAA, 0x26, 0x8A, 0x9A, 0x2A, 0xC9, 0xD2, 0xFF, 0x3D, 0xFA, 0xF4, 0xE9, 0x93, 0x00, 0x11, 0x0B, 0x0D, 0x01, 0x11, 0xF9, 0xF2, 0x45, 0x97, 0x1E, 0x5D, 0x4A, 0x77, 0x69, 0xDC, 0xB5, 0x4B, 0x97, 
    0x2E, 0x1E, 0xAD, 0x24, 0x4E, 0x4F, 0x3B, 0x11, 0x0B, 0x0D, 0x01, 0x11, 0x2C, 0x1F, 0x8D, 0x8B, 0xAC, 0xE8, 0xD1, 0x25, 0x71, 0xCA, 0x11, 0x6E, 0x59, 0x7B, 0xF0, 0xE0, 0xA1, 0xA8, 0xCB, 0xB6, 
    0x1D, 0xED, 0x00, 0x11, 0x0B, 0x0D, 0x01, 0x11, 0xF8, 0x9F, 0x47, 0x8F, 0x2E, 0x3D, 0x7A, 0xF6, 0xE8, 0xD9, 0xA3, 0x67, 0x8F, 0x2E, 0x3D, 0x7B, 0x74, 0xE9, 0xD2, 0x01, 0x11, 0x0B, 0x0D, 0x01, 
    0x11, 0x6B, 0x8F, 0x6D, 0x93, 0x2A, 0xA9, 0x92, 0x2A, 0x6D, 0xE2, 0xC1, 0x63, 0xAA, 0xA2, 0x83, 0x07, 0x0F, 0x1E, 0xCA, 0x28, 0x5D, 0xEC, 0x00, 0x11, 0x0B, 0x0D, 0x01, 0x11, 0x6B, 0x8F, 0x6D, 
    0xCB, 0xAA, 0xE8, 0xE0, 0xC1, 0xA3, 0x5D, 0x36, 0xE6, 0x88, 0x46, 0xE9, 0xD2, 0xA3, 0xC8, 0xCA, 0x38, 0x3D, 0x2C, 0x01, 0x0C, 0x02, 0x07, 0x02, 0x0C, 0xE0, 0x2F, 0x02, 0x0F, 0x02, 0x07, 0x02, 
    0x0C, 0xE0, 0x2F, 0x26, 0x51, 0x00, 0x0B, 0x0A, 0x0E, 0x02, 0x0E, 0x57, 0x8E, 0xB1, 0xEB, 0x5A, 0x3D, 0x3D, 0x7A, 0xF4, 0xD9, 0x15, 0x07, 0x0A, 0x0E, 0x02, 0x0C, 0xF8, 0xFD, 0xFF, 0xFA, 0x0D, 
    0x0B, 0x0A, 0x0E, 0x02, 0x0E, 0xC8, 0xB5, 0xA7, 0x47, 0x8F, 0x3E, 0x6A, 0xD7, 0x95, 0x3B, 0x72, 0x01, 0x11, 0x0B, 0x0D, 0x01, 0x11, 0x2B, 0x2F, 0xA9, 0x8A, 0x0E, 0x1E, 0xBA, 0xF4, 0xE8, 0xD1, 
    0xA3, 0x47, 0x8F, 0x2E, 0x5D, 0xFA, 0xFF, 0xE9, 0x52, 0x01, 0x16, 0x17, 0x18, 0x01, 0x11, 0xCF, 0x73, 0xBF, 0x17, 0x0F, 0x1E, 0x3B, 0xD7, 0xDD, 0xA3, 0x4A, 0x49, 0x9A, 0x7A, 0x4D, 0x12, 0x45, 
    0x4E, 0x11, 0xE5, 0x4D, 0xD1, 0x66, 0x51, 0xD1, 0x74, 0x88, 0x8A, 0xA6, 0x43, 0x54, 0x34, 0x79, 0x93, 0x34, 0x59, 0x9B, 0x44, 0x8D, 0x1A, 0xB5, 0xBB, 0x1B, 0xB7, 0x47, 0xFF, 0xB4, 0xDD, 0x2B, 
    0x2F, 0x1E, 0x3F, 0xDE, 0xCB, 0x11, 0x0F, 0x10, 0x00, 0x11, 0xDE, 0xBB, 0x53, 0xD1, 0xA7, 0xE8, 0x53, 0x74, 0x69, 0x7A, 0x34, 0x1D, 0xAA, 0xAC, 0xCA, 0xAA, 0x7A, 0xF2, 0xDC, 0x8E, 0x49, 0x97, 
    0xA4, 0x4B, 0xD1, 0xC9, 0x53, 0x11, 0x0C, 0x10, 0x02, 0x11, 0x78, 0xF8, 0x49, 0x96, 0x74, 0x28, 0x3A, 0x14, 0x1D, 0x8A, 0x2C, 0x5D, 0xFB, 0xA4, 0x43, 0xD1, 0xC3, 0x87, 0x0F, 0x1F, 0x1E, 0xCA, 
    0x99, 0x6B, 0x11, 0x0E, 0x11, 0x01, 0x11, 0xED, 0x71, 0x71, 0x9D, 0x76, 0x48, 0x7A, 0xFA, 0xF1, 0xD5, 0xAB, 0x57, 0xAF, 0x5E, 0x7D, 0x8A, 0x9E, 0x65, 0x87, 0xB6, 0x8E, 0x97, 0x4D, 0x11, 0x0D, 
    0x11, 0x02, 0x11, 0xB8, 0x78, 0x4A, 0x9E, 0xF4, 0x28, 0x7A, 0x14, 0x5D, 0xBC, 0x78, 0xF1, 0xE2, 0xC5, 0x8B, 0x17, 0x1F, 0x45, 0x8F, 0x22, 0x4F, 0xA7, 0x2E, 0x02, 0x11, 0x0C, 0x10, 0x02, 0x11, 
    0xF8, 0xDF, 0x4F, 0x9F, 0x3E, 0x7D, 0xFA, 0xCE, 0x9C, 0xD1, 0xA7, 0x4F, 0x9F, 0x3E, 0x7D, 0xFA, 0xFE, 0x0F, 0x11, 0x0B, 0x0F, 0x02, 0x11, 0xF8, 0xBF, 0x4B, 0x97, 0x2E, 0x5D, 0xBA, 0xBE, 0x7C, 
    0xD1, 0xA5, 0x4B, 0x97, 0x2E, 0x5D, 0xBA, 0x74, 0xE9, 0x02, 0x11, 0x10, 0x13, 0x01, 0x11, 0x3D, 0x8E, 0x93, 0x2C, 0xB5, 0x4B, 0xD2, 0xE7, 0x93, 0x3F, 0xF4, 0x43, 0xC7, 0x75, 0x5C, 0x6F, 0x4F, 
    0x45, 0xA7, 0xB2, 0x4F, 0xA2, 0xB9, 0xF3, 0x38, 0x08, 0x11, 0x0C, 0x11, 0x02, 0x11, 0xD0, 0xC3, 0x87, 0x0F, 0x1F, 0x3E, 0x7C, 0xF8, 0xFC, 0x3F, 0x1E, 0x3E, 0x7C, 0xF8, 0xF0, 0xE1, 0xC3, 0x87, 
    0x8F, 0x00, 0x11, 0x02, 0x07, 0x02, 0x11, 0xF8, 0x7F, 0x03, 0x11, 0x08, 0x0C, 0x01, 0x11, 0x96, 0x65, 0x59, 0x96, 0x65, 0x59, 0x96, 0x65, 0x99, 0x24, 0xAB, 0xC5, 0xA3, 0x00, 0x11, 0x0E, 0x10, 
    0x02, 0x11, 0xD0, 0xA5, 0xE8, 0x91, 0x74, 0x68, 0xB2, 0xA8, 0xAA, 0xA2, 0xAC, 0xE9, 0x90, 0xF4, 0x28, 0x7B, 0x18, 0x1D, 0x9B, 0xAC, 0xAA, 0xB2, 0xA8, 0x43, 0xD3, 0x23, 0xE9, 0x52, 0xF4, 0x09, 
    0x11, 0x0A, 0x0D, 0x02, 0x11, 0xD0, 0xA3, 0x47, 0x8F, 0x1E, 0x3D, 0x7A, 0xF4, 0xE8, 0xD1, 0xA3, 0x47, 0x8F, 0x1E, 0x3D, 0x7A, 0xF4, 0xFC, 0x06, 0x11, 0x0F, 0x14, 0x02, 0x11, 0xD8, 0x75, 0x1C, 
    0xCF, 0xF1, 0x1C, 0x8E, 0xAA, 0x30, 0xAA, 0xC2, 0xA8, 0x0A, 0xA3, 0x2A, 0x94, 0x26, 0x51, 0x9A, 0x44, 0x69, 0x12, 0xA7, 0x68, 0x9C, 0xA2, 0x71, 0x8A, 0xC6, 0x29, 0x1A, 0x39, 0x92, 0xA3, 0x00, 
    0x11, 0x0C, 0x11, 0x02, 0x11, 0xD0, 0xD3, 0xC3, 0xB6, 0x19, 0x95, 0x51, 0x29, 0x91, 0x12, 0x39, 0x8D, 0x94, 0x48, 0x89, 0x55, 0x58, 0x85, 0xB6, 0x7D, 0xF4, 0x11, 0x11, 0x10, 0x13, 0x01, 0x11, 
    0xF5, 0xF3, 0x75, 0xDE, 0xF6, 0x4C, 0xFA, 0x14, 0xBD, 0x7C, 0xF9, 0xF2, 0xE5, 0xCB, 0x97, 0xAF, 0xA2, 0x4F, 0xDA, 0xB3, 0xCD, 0xEB, 0xF7, 0xB8, 0x11, 0x0C, 0x10, 0x02, 0x11, 0xF8, 0x74, 0x46, 
    0x47, 0x1F, 0x3E, 0x7C, 0xF8, 0xF0, 0x50, 0xCE, 0x5C, 0xD3, 0xA7, 0x4F, 0x9F, 0x3E, 0x7D, 0xFA, 0xF4, 0x01, 0x12, 0x10, 0x13, 0x01, 0x11, 0xF5, 0xF3, 0x75, 0xDE, 0xF6, 0x4C, 0xFA, 0x14, 0x9D, 
    0x7D, 0xF9, 0xF2, 0xE5, 0xCB, 0xB7, 0xDF, 0xA2, 0x6A, 0xD2, 0x78, 0x6C, 0x65, 0xCF, 0xC3, 0xE1, 0x0F, 0x01, 0x11, 0x0E, 0x11, 0x02, 0x11, 0x38, 0xF7, 0x4A, 0xCF, 0xA2, 0x4B, 0xD1, 0xA5, 0xE8, 
    0x52, 0xF4, 0x2C, 0xAF, 0x3E, 0xAA, 0xAA, 0x2C, 0xEA, 0xD0, 0xF4, 0x48, 0x7A, 0x24, 0x5D, 0x8A, 0x2E, 0x45, 0x9F, 0x00, 0x11, 0x0D, 0x10, 0x01, 0x11, 0xAC, 0xAF, 0xAD, 0x9A, 0x0E, 0x49, 0x87, 
    0xA4, 0x73, 0xE7, 0xF1, 0x1C, 0x1F, 0xCF, 0x5E, 0xBC, 0xFA, 0x28, 0xEB, 0x76, 0xD9, 0x03, 0x11, 0x0E, 0x0F, 0x00, 0x11, 0xF8, 0x7F, 0x58, 0xAF, 0x5E, 0xBD, 0x7A, 0xF5, 0xEA, 0xD5, 0xAB, 0x57, 
    0xAF, 0x5E, 0xBD, 0x7A, 0xF5, 0xEA, 0x95, 0x01, 0x11, 0x0C, 0x11, 0x02, 0x11, 0xD0, 0xC3, 0x87, 0x0F, 0x1F, 0x3E, 0x7C, 0xF8, 0xF0, 0xE1, 0xC3, 0x87, 0x0F, 0x1F, 0x3E, 0x7C, 0x14, 0x59, 0xFA, 
    0xE8, 0x01, 0x11, 0x0F, 0x10, 0x00, 0x11, 0xD0, 0xA9, 0xE8, 0x92, 0x74, 0x49, 0xBA, 0x34, 0x1D, 0xA2, 0x0E, 0x51, 0x87, 0xAA, 0xCA, 0xAA, 0xBC, 0xED, 0xD0, 0xF4, 0x68, 0x7A, 0x96, 0x5D, 0x8A, 
    0x3E, 0x45, 0xE7, 0xDE, 0x19, 0x11, 0x17, 0x17, 0x00, 0x11, 0xD0, 0xB3, 0x87, 0xCF, 0x8E, 0x45, 0x56, 0x64, 0x49, 0x56, 0x64, 0x49, 0x56, 0x64, 0x49, 0x95, 0x54, 0x51, 0xD4, 0x44, 0x51, 0xD4, 
    0x44, 0x51, 0x13, 0x35, 0x55, 0x13, 0x35, 0x75, 0x12, 0x27, 0x59, 0x59, 0x95, 0x59, 0x91, 0x15, 0x1D, 0x8A, 0xAC, 0xE8, 0x50, 0x64, 0x45, 0xCF, 0x9E, 0x5D, 0x7B, 0x56, 0x11, 0x10, 0x10, 0x00, 
    0x11, 0xD9, 0x35, 0xE9, 0x19, 0x75, 0xC8, 0xAA, 0x8E, 0x4D, 0x97, 0xB4, 0xAF, 0xEF, 0xEE, 0xBD, 0x3C, 0x17, 0x5D, 0x9B, 0x1E, 0x71, 0x96, 0x55, 0x3D, 0xDA, 0x2E, 0x65, 0xDF, 0x00, 0x11, 0x10, 
    0x10, 0x00, 0x11, 0xD0, 0xAB, 0xE8, 0xD3, 0xF4, 0x88, 0xF3, 0xBA, 0xEA, 0x10, 0x75, 0x49, 0xFA, 0x7C, 0xF2, 0xD6, 0x0F, 0xFD, 0xD0, 0x0F, 0xFD, 0xD0, 0x0F, 0xFD, 0xD0, 0x0F, 0x1D, 0x11, 0x0E, 
    0x0F, 0x00, 0x11, 0xB9, 0x73, 0xBF, 0x3A, 0x75, 0xEA, 0xD4, 0xA9, 0x53, 0xA7, 0x4E, 0x9D, 0x3A, 0x75, 0xEA, 0xD4, 0xA9, 0xF7, 0xFF, 0x01, 0x16, 0x05, 0x07, 0x01, 0x11, 0x78, 0xA7, 0x69, 0x9A, 
    0xA6, 0x69, 0x9A, 0xA6, 0x69, 0x9A, 0xA6, 0x69, 0x9A, 0xA6, 0x7D, 0x11, 0x07, 0x07, 0x00, 0x11, 0x50, 0x65, 0x55, 0x95, 0x55, 0x55, 0x5D, 0x55, 0x55, 0x56, 0x55, 0x59, 0x15, 0x16, 0x05, 0x07, 
    0x00, 0x11, 0xF8, 0xA6, 0x69, 0x9A, 0xA6, 0x69, 0x9A, 0xA6, 0x69, 0x9A, 0xA6, 0x69, 0x9A, 0xA6, 0xBD, 0x09, 0x09, 0x0B, 0x01, 0x11, 0x9B, 0x57, 0x45, 0x54, 0x44, 0x45, 0xD3, 0x24, 0x4D, 0x51, 
    0x59, 0x01, 0x01, 0x0C, 0x0C, 0x00, 0xFE, 0x78, 0x01, 0x03, 0x04, 0x08, 0x01, 0x11, 0x98, 0x26, 0x01, 0x0C, 0x0B, 0x0D, 0x01, 0x0C, 0x32, 0x1F, 0xAD, 0x8A, 0xAC, 0x83, 0x7B, 0x54, 0x29, 0xB2, 
    0x22, 0x2B, 0x1B, 0x75, 0x8D, 0x13, 0x11, 0x0A, 0x0D, 0x01, 0x11, 0xD0, 0xA3, 0x47, 0x8F, 0x1E, 0x3D, 0x0A, 0x77, 0x65, 0x54, 0x64, 0x9A, 0xA6, 0x69, 0xBA, 0x54, 0xAE, 0x28, 0x1C, 0x0C, 0x09, 
    0x0C, 0x01, 0x0C, 0xE3, 0x0E, 0x69, 0x2D, 0x0F, 0x1D, 0x3A, 0x74, 0xA8, 0x8A, 0xB6, 0x1C, 0xA4, 0x00, 0x11, 0x0A, 0x0D, 0x01, 0x11, 0x8F, 0x1E, 0x3D, 0x7A, 0xF4, 0x68, 0x8C, 0x72, 0x45, 0xAC, 
    0x69, 0x9A, 0xA6, 0x69, 0x45, 0x5C, 0xAE, 0x31, 0x02, 0x0C, 0x0A, 0x0D, 0x01, 0x0C, 0x23, 0x1F, 0x89, 0x8A, 0xFC, 0x7F, 0x8F, 0x9E, 0x55, 0x11, 0x97, 0x87, 0x15, 0x11, 0x08, 0x07, 0x00, 0x11, 
    0xAB, 0x2C, 0x59, 0x16, 0x8F, 0x1C, 0x93, 0x65, 0x59, 0x96, 0x65, 0x59, 0x96, 0x45, 0x11, 0x0A, 0x0D, 0x01, 0x0C, 0x63, 0x94, 0x2B, 0xA2, 0x4B, 0xD3, 0x34, 0xDD, 0x2A, 0xE2, 0xF4, 0x8C, 0xD1, 
    0x43, 0x97, 0xD2, 0xB3, 0x0E, 0x11, 0x0A, 0x0D, 0x01, 0x11, 0xD0, 0xA3, 0x47, 0x8F, 0x1E, 0x3D, 0x4A, 0x75, 0x65, 0xAC, 0x69, 0x9A, 0xA6, 0x69, 0x9A, 0xA6, 0x05, 0x11, 0x02, 0x05, 0x01, 0x11, 
    0xA0, 0xFF, 0x0F, 0x16, 0x05, 0x05, 0xFE, 0x11, 0xD3, 0xF4, 0x53, 0xD3, 0x34, 0x4D, 0xD3, 0x34, 0x4D, 0xD3, 0x34, 0x4D, 0xD3, 0xCE, 0x00, 0x11, 0x0A, 0x0C, 0x01, 0x11, 0xD0, 0xA3, 0x47, 0x8F, 
    0x1E, 0x3D, 0x32, 0xAB, 0x88, 0x92, 0xA6, 0x49, 0xA2, 0xA2, 0x9A, 0x93, 0xA6, 0x4D, 0xA2, 0xA4, 0x2A, 0xB2, 0x00, 0x11, 0x02, 0x05, 0x01, 0x11, 0xF8, 0x7F, 0x03, 0x0C, 0x10, 0x13, 0x01, 0x0C, 
    0x50, 0x38, 0xEA, 0x89, 0xB3, 0x71, 0xAD, 0xCA, 0xAA, 0xAC, 0xCA, 0xAA, 0xAC, 0xCA, 0xAA, 0xAC, 0xCA, 0xAA, 0xAC, 0x2A, 0x0C, 0x0A, 0x0D, 0x01, 0x0C, 0x90, 0xA8, 0x2B, 0x63, 0x4D, 0xD3, 0x34, 
    0x4D, 0xD3, 0x34, 0x2D, 0x0C, 0x0A, 0x0D, 0x01, 0x0C, 0x23, 0x1F, 0x89, 0x8A, 0x4C, 0xD3, 0x34, 0x4D, 0x2B, 0xA2, 0xF4, 0x90, 0x03, 0x11, 0x0A, 0x0D, 0x01, 0x0C, 0x50, 0xB8, 0x2B, 0xA3, 0xA2, 
    0xD6, 0x34, 0x4D, 0xB3, 0xA6, 0xF2, 0x48, 0xE1, 0xF4, 0xE8, 0xD1, 0xA3, 0x47, 0x0F, 0x11, 0x0A, 0x0D, 0x01, 0x0C, 0x63, 0x94, 0x2B, 0xA2, 0x4B, 0xD3, 0x34, 0xDD, 0x2A, 0xE2, 0xF4, 0x8C, 0xD1, 
    0xA3, 0x47, 0x8F, 0x1E, 0x3D, 0x02, 0x0C, 0x07, 0x08, 0x01, 0x0C, 0x50, 0xBE, 0x8C, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x2A, 0x0C, 0x09, 0x0C, 0x01, 0x0C, 0xEA, 0x8E, 0x6C, 0x6D, 0x0F, 0xB7, 
    0x0F, 0xDB, 0x2D, 0xC7, 0x2A, 0x10, 0x07, 0x07, 0x00, 0x10, 0x4B, 0x55, 0x55, 0xFB, 0x21, 0x55, 0x55, 0x55, 0x55, 0x55, 0xD5, 0x8E, 0x0C, 0x0A, 0x0D, 0x01, 0x0C, 0x90, 0x69, 0x9A, 0xA6, 0x69, 
    0x9A, 0xA6, 0xCB, 0xE5, 0x12, 0x25, 0x0C, 0x0B, 0x0C, 0x00, 0x0C, 0xD0, 0xA1, 0xA8, 0x92, 0x2A, 0xA9, 0x9A, 0x26, 0x6A, 0xA2, 0xA6, 0x2A, 0xB2, 0x22, 0x2B, 0x3A, 0xF6, 0x8C, 0x0C, 0x11, 0x11, 
    0x00, 0x0C, 0x50, 0x57, 0x76, 0x2D, 0xC7, 0x45, 0x53, 0x34, 0x49, 0x53, 0x34, 0x49, 0x53, 0x34, 0x4D, 0xD1, 0x14, 0x51, 0xD1, 0x14, 0x51, 0xD1, 0x14, 0x91, 0x9D, 0xD7, 0x79, 0xDD, 0x00, 0x0C, 
    0x0C, 0x0C, 0x00, 0x0C, 0x98, 0x97, 0x71, 0x13, 0x55, 0x49, 0x07, 0x1F, 0x3E, 0x7C, 0x78, 0x48, 0xAA, 0xA8, 0xAD, 0xCA, 0x3C, 0x11, 0x0B, 0x0C, 0x00, 0x0C, 0xD0, 0xA1, 0xA8, 0x92, 0x2A, 0x8D, 
    0x9A, 0x26, 0x6A, 0xE2, 0xA4, 0x2A, 0xB2, 0xA2, 0x63, 0xCF, 0x9E, 0x3D, 0xBA, 0xF4, 0xCC, 0x3C, 0x76, 0x00, 0x0C, 0x0B, 0x0C, 0x00, 0x0C, 0xF8, 0x9F, 0x47, 0x8F, 0x1E, 0x3D, 0x7A, 0xF4, 0xE8, 
    0xD1, 0xA3, 0xE7, 0x7F, 0x00, 0x16, 0x06, 0x08, 0x01, 0x11, 0x9B, 0x28, 0x51, 0x14, 0x45, 0x51, 0xD4, 0x34, 0x71, 0x54, 0x45, 0x51, 0x14, 0x45, 0x51, 0xE4, 0x06, 0x16, 0x02, 0x06, 0x02, 0x11, 
    0xF8, 0xFF, 0x5F, 0x16, 0x06, 0x08, 0x01, 0x11, 0xD8, 0x48, 0x51, 0x14, 0x45, 0x51, 0x54, 0xC5, 0x51, 0xD3, 0x44, 0x51, 0x14, 0x45, 0x51, 0xA2, 0x36, 0x03, 0x0A, 0x0E, 0x02, 0x0A, 0x21, 0x5F, 
    0x32, 0x00, 0x00, 0x07, 0x00, 0x00, 0x11, 0x02, 0x08, 0x03, 0x0C, 0x20, 0xFF, 0x17, 0x16, 0x0B, 0x0D, 0x01, 0x11, 0x57, 0x2E, 0x5D, 0xF9, 0x72, 0xA9, 0xE6, 0xA3, 0xE9, 0x59, 0x44, 0x86, 0x9A, 
    0xA8, 0x89, 0x5A, 0x3A, 0x65, 0x4A, 0x35, 0x3D, 0xAC, 0x75, 0xE5, 0xCB, 0xA5, 0x2B, 0x0F, 0x11, 0x0B, 0x0D, 0x01, 0x11, 0x64, 0x9F, 0x89, 0x92, 0xAC, 0xC8, 0x8A, 0x2E, 0x5D, 0x7A, 0x0E, 0x1E, 
    0xD6, 0xA5, 0x4B, 0x8F, 0xAE, 0xF2, 0x4D, 0xC8, 0x00, 0x0C, 0x0C, 0x0D, 0x01, 0x0E, 0xC9, 0x93, 0x2C, 0xCC, 0xF2, 0x4D, 0xD4, 0x64, 0x49, 0x96, 0x64, 0x49, 0xD6, 0x44, 0xED, 0xCB, 0xC2, 0x2C, 
    0x79, 0x12, 0x11, 0x0E, 0x0D, 0xFF, 0x11, 0xD0, 0xA7, 0xE8, 0xD1, 0x64, 0x71, 0x94, 0xB5, 0x1D, 0x92, 0x2E, 0xFA, 0xD5, 0x7B, 0xE8, 0xD5, 0xF1, 0xEA, 0x3D, 0xF4, 0xEA, 0xD5, 0x2B, 0x03, 0x16, 
    0x02, 0x06, 0x02, 0x11, 0xF8, 0xF9, 0xFC, 0x04, 0x16, 0x0A, 0x0D, 0x01, 0x11, 0x63, 0xBD, 0x69, 0x12, 0x25, 0x5D, 0x7A, 0x66, 0x65, 0xD3, 0x26, 0x71, 0x51, 0x5D, 0x65, 0x94, 0x36, 0x6D, 0x51, 
    0x77, 0x69, 0xA2, 0x24, 0x6A, 0xD2, 0xE6, 0x72, 0x02, 0x06, 0x08, 0x01, 0x11, 0x90, 0x28, 0x01, 0x12, 0x12, 0x12, 0x00, 0x12, 0xF6, 0xF7, 0x1D, 0xF3, 0xBA, 0x67, 0xDB, 0xB8, 0x49, 0x93, 0x34, 
    0x45, 0x13, 0x35, 0x4E, 0x17, 0xA7, 0x8B, 0xD3, 0xC5, 0xE9, 0xE2, 0x44, 0x4D, 0xD1, 0x24, 0x4D, 0xDA, 0xB8, 0x6D, 0xCF, 0x3A, 0xEF, 0xF8, 0x3E, 0x1B, 0x09, 0x07, 0x09, 0x01, 0x11, 0x69, 0x34, 
    0x55, 0x7A, 0xC4, 0x71, 0xD4, 0xB2, 0x08, 0x0B, 0x0A, 0x0D, 0x02, 0x0C, 0xD3, 0x24, 0x4D, 0xD3, 0x24, 0x4D, 0xD2, 0x34, 0x4D, 0xD3, 0x44, 0x4D, 0xD4, 0x34, 0x4D, 0xD4, 0x04, 0x07, 0x0C, 0x0E, 
    0x01, 0x0C, 0xF8, 0xBF, 0x4F, 0x9F, 0x3E, 0x7D, 0xFA, 0x04, 0x02, 0x06, 0x08, 0x01, 0x07, 0x78, 0x01, 0x12, 0x12, 0x12, 0x00, 0x12, 0xF6, 0xF7, 0x1D, 0xF3, 0xBA, 0x67, 0xDB, 0x37, 0x49, 0xA6, 
    0xA2, 0x69, 0x22, 0xA7, 0x89, 0x9C, 0x26, 0x72, 0x2E, 0x27, 0xA9, 0x9C, 0x26, 0x2A, 0x92, 0xA6, 0x49, 0x8B, 0xA8, 0x6C, 0x7B, 0xD6, 0x79, 0xC7, 0xF7, 0xD9, 0x01, 0x0C, 0x0C, 0x00, 0x14, 0x78, 
    0x01, 0x06, 0x06, 0x0A, 0x02, 0x11, 0x61, 0x42, 0x51, 0x14, 0x13, 0x06, 0x0F, 0x0C, 0x0E, 0x01, 0x0F, 0xD5, 0xA7, 0x4F, 0x9F, 0x3E, 0xF5, 0xFF, 0xAA, 0x4F, 0x9F, 0x3E, 0x7D, 0xFA, 0xF7, 0x7F, 
    0x08, 0x07, 0x08, 0x00, 0x11, 0x69, 0x34, 0x4E, 0xDC, 0x36, 0x51, 0x3C, 0x00, 0x08, 0x07, 0x08, 0x00, 0x11, 0x69, 0x34, 0x4E, 0x9B, 0x39, 0x4E, 0x69, 0x00, 0x03, 0x04, 0x08, 0x03, 0x11, 0x52, 
    0x14, 0x09, 0x11, 0x0A, 0x0D, 0x01, 0x0C, 0x90, 0x69, 0x9A, 0xA6, 0x69, 0x9A, 0xA6, 0xCB, 0x3F, 0x61, 0xF8, 0xE8, 0xD1, 0xA3, 0x47, 0x0F, 0x16, 0x0E, 0x0D, 0x00, 0x11, 0x3B, 0x73, 0xC7, 0x93, 
    0x8E, 0x49, 0xC7, 0xA4, 0x63, 0xD2, 0x31, 0xCD, 0xD3, 0x3C, 0x95, 0xD3, 0xA1, 0xE9, 0xD0, 0x74, 0x68, 0x3A, 0x34, 0x1D, 0x9A, 0x0E, 0x4D, 0x87, 0xA6, 0x43, 0xD3, 0xA1, 0xE9, 0xD0, 0x74, 0x68, 
    0x3A, 0x34, 0x09, 0x02, 0x02, 0x07, 0x02, 0x0A, 0x20, 0x05, 0x05, 0x08, 0x01, 0x00, 0x92, 0xC6, 0x33, 0x08, 0x04, 0x08, 0x01, 0x11, 0x52, 0x18, 0x49, 0x92, 0x24, 0x49, 0x09, 0x07, 0x09, 0x01, 
    0x11, 0xDA, 0x14, 0x45, 0xE3, 0x38, 0x8E, 0x53, 0x14, 0x6D, 0x02, 0x0B, 0x0A, 0x0D, 0x01, 0x0C, 0xD0, 0x44, 0x4D, 0xD3, 0x44, 0x4D, 0xD4, 0x34, 0x4D, 0xD3, 0x24, 0x4D, 0xD2, 0x34, 0x4D, 0xD2, 
    0x34, 0x11, 0x11, 0x14, 0x02, 0x11, 0xD2, 0x27, 0xED, 0x92, 0x12, 0x3D, 0xAA, 0x0E, 0x59, 0x87, 0x2C, 0xEB, 0x50, 0xF5, 0x88, 0xFA, 0xB1, 0x1F, 0xAA, 0x0E, 0x75, 0x56, 0x13, 0x55, 0x8D, 0x54, 
    0x31, 0x13, 0xD5, 0x43, 0xFA, 0x24, 0x9D, 0x0A, 0x11, 0x11, 0x14, 0x02, 0x11, 0xD2, 0x27, 0xED, 0x92, 0x12, 0x3D, 0xAA, 0x0E, 0x59, 0x87, 0x2C, 0xEB, 0x50, 0xF5, 0x88, 0xFA, 0xB1, 0x1F, 0x52, 
    0x0F, 0x69, 0x52, 0x35, 0x4D, 0xD4, 0x33, 0xEA, 0x18, 0x75, 0x8C, 0x3A, 0x54, 0x1D, 0x07, 0x11, 0x12, 0x14, 0x01, 0x11, 0xE9, 0x25, 0x49, 0x3A, 0x24, 0x4D, 0xD6, 0xA3, 0xEA, 0x98, 0x75, 0x89, 
    0xAA, 0xA6, 0xC9, 0x93, 0xA4, 0xA7, 0xDA, 0x1F, 0x55, 0x8F, 0xBA, 0x43, 0x4D, 0x64, 0x35, 0x92, 0xC5, 0x4C, 0x55, 0x8F, 0xE9, 0xD3, 0x74, 0x2A, 0x11, 0x0D, 0x0F, 0x01, 0x0C, 0xD6, 0xA9, 0xFF, 
    0xBF, 0x74, 0xEA, 0xDB, 0xB5, 0x6B, 0xD7, 0x2E, 0x7D, 0x3A, 0x75, 0xF1, 0x59, 0xD6, 0xED, 0xEA, 0x31, 0x15, 0x0F, 0x10, 0x00, 0x15, 0xDD, 0xBD, 0x5B, 0xFF, 0xBD, 0x77, 0xA7, 0xA2, 0x4F, 0xD1, 
    0xA7, 0xE8, 0xD2, 0xF4, 0x68, 0x3A, 0x54, 0x59, 0x95, 0x55, 0xF5, 0xE4, 0xB9, 0x1D, 0x93, 0x2E, 0x49, 0x97, 0xA2, 0x93, 0xA7, 0x00, 0x15, 0x0F, 0x10, 0x00, 0x15, 0x8F, 0x5E, 0xBD, 0xFA, 0x7F, 
    0xEC, 0xDD, 0xA9, 0xE8, 0x53, 0xF4, 0x29, 0xBA, 0x34, 0x3D, 0x9A, 0x0E, 0x55, 0x56, 0x65, 0x55, 0x3D, 0x79, 0x6E, 0xC7, 0xA4, 0x4B, 0xD2, 0xA5, 0xE8, 0xE4, 0x29, 0x15, 0x0F, 0x10, 0x00, 0x15, 
    0xDE, 0xA9, 0xE8, 0xD2, 0xF4, 0x9F, 0x7B, 0x77, 0x2A, 0xFA, 0x14, 0x7D, 0x8A, 0x2E, 0x4D, 0x8F, 0xA6, 0x43, 0x95, 0x55, 0x59, 0x55, 0x4F, 0x9E, 0xDB, 0x31, 0xE9, 0x92, 0x74, 0x29, 0x3A, 0x79, 
    0x0A, 0x16, 0x0F, 0x10, 0x00, 0x16, 0x9D, 0x74, 0x3C, 0x87, 0xB4, 0xFF, 0x7F, 0xF7, 0xEE, 0x54, 0xF4, 0x29, 0xFA, 0x14, 0x5D, 0x9A, 0x1E, 0x4D, 0x87, 0x2A, 0xAB, 0xB2, 0xAA, 0x9E, 0x3C, 0xB7, 
    0x63, 0xD2, 0x25, 0xE9, 0x52, 0x74, 0xF2, 0x14, 0x15, 0x0F, 0x10, 0x00, 0x15, 0x95, 0x74, 0x49, 0xFA, 0xFF, 0x77, 0xEF, 0x4E, 0x45, 0x9F, 0xA2, 0x4F, 0xD1, 0xA5, 0xE9, 0xD1, 0x74, 0xA8, 0xB2, 
    0x2A, 0xAB, 0xEA, 0xC9, 0x73, 0x3B, 0x26, 0x5D, 0x92, 0x2E, 0x45, 0x27, 0x4F, 0x01, 0x16, 0x0F, 0x10, 0x00, 0x16, 0x87, 0xDE, 0x28, 0x67, 0x94, 0x57, 0xFF, 0xBD, 0x77, 0xA7, 0xA2, 0x4F, 0xD1, 
    0xA7, 0xE8, 0xD2, 0xF4, 0x68, 0x3A, 0x54, 0x59, 0x95, 0x55, 0xF5, 0xE4, 0xB9, 0x1D, 0x93, 0x2E, 0x49, 0x97, 0xA2, 0x93, 0xA7, 0x00, 0x11, 0x16, 0x18, 0x00, 0x11, 0xCF, 0x8F, 0xE3, 0xCF, 0x21, 
    0xE9, 0x8F, 0xA6, 0x3F, 0x9A, 0x7E, 0x88, 0xFA, 0x21, 0xEA, 0x56, 0xBF, 0xAA, 0x1F, 0x65, 0xBD, 0xDF, 0x79, 0x9E, 0x3A, 0xF4, 0xE9, 0xD1, 0xA7, 0x47, 0x97, 0xAE, 0xFB, 0x3A, 0x01, 0x16, 0x0E, 
    0x11, 0x01, 0x11, 0xED, 0x71, 0x71, 0x9D, 0x76, 0x48, 0x7A, 0xFA, 0xF1, 0xD5, 0xAB, 0x57, 0xAF, 0x5E, 0x7D, 0x8A, 0x9E, 0x65, 0x87, 0x36, 0x92, 0xD7, 0xE1, 0x4F, 0xE7, 0x6E, 0x5D, 0xBD, 0x58, 
    0x15, 0x0C, 0x10, 0x02, 0x15, 0xDB, 0xB7, 0x4F, 0xFF, 0xFE, 0xF7, 0xD3, 0xA7, 0x4F, 0x9F, 0xBE, 0x33, 0x67, 0xF4, 0xE9, 0xD3, 0xA7, 0x4F, 0x9F, 0xBE, 0xFF, 0x03, 0x15, 0x0C, 0x10, 0x02, 0x15, 
    0x87, 0x2E, 0x5D, 0xFA, 0xF7, 0xBF, 0x9F, 0x3E, 0x7D, 0xFA, 0xF4, 0x9D, 0x39, 0xA3, 0x4F, 0x9F, 0x3E, 0x7D, 0xFA, 0xF4, 0xFD, 0x1F, 0x15, 0x0C, 0x10, 0x02, 0x15, 0xDD, 0xA3, 0xC8, 0x9A, 0x7E, 
    0xFC, 0xEF, 0xA7, 0x4F, 0x9F, 0x3E, 0x7D, 0x67, 0xCE, 0xE8, 0xD3, 0xA7, 0x4F, 0x9F, 0x3E, 0x7D, 0xFF, 0x07, 0x15, 0x0C, 0x10, 0x02, 0x15, 0x93, 0x64, 0x49, 0xFF, 0xFD, 0xBF, 0x9F, 0x3E, 0x7D, 
    0xFA, 0xF4, 0x9D, 0x39, 0xA3, 0x4F, 0x9F, 0x3E, 0x7D, 0xFA, 0xF4, 0xFD, 0x1F, 0x15, 0x04, 0x07, 0x00, 0x15, 0x98, 0x26, 0x59, 0x92, 0x24, 0x49, 0x92, 0x24, 0x49, 0x92, 0x24, 0x49, 0x92, 0x24, 
    0x49, 0x15, 0x04, 0x07, 0x02, 0x15, 0x52, 0x14, 0x59, 0x92, 0x24, 0x49, 0x92, 0x24, 0x49, 0x92, 0x24, 0x49, 0x92, 0x24, 0x49, 0x02, 0x15, 0x07, 0x07, 0x00, 0x15, 0xDA, 0x14, 0x45, 0xD3, 0xA5, 
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x01, 0x15, 0x06, 0x07, 0x00, 0x15, 0x90, 0x28, 0xFD, 0x10, 0x45, 0x51, 0x14, 0x45, 0x51, 0x14, 0x45, 0x51, 0x14, 0x45, 
    0x51, 0x94, 0x00, 0x11, 0x0F, 0x11, 0x00, 0x11, 0xBA, 0x7C, 0x52, 0x1E, 0xF5, 0x68, 0x7A, 0x34, 0x5D, 0x92, 0xAE, 0x93, 0x27, 0x25, 0x5D, 0x92, 0x2E, 0x49, 0x97, 0xA4, 0x47, 0xD3, 0xA3, 0xC9, 
    0xE3, 0xC9, 0x8B, 0x16, 0x0C, 0x11, 0x02, 0x16, 0x9B, 0xC4, 0x87, 0xD2, 0xFE, 0x5B, 0x4F, 0x0F, 0xDB, 0x66, 0x54, 0x46, 0xA5, 0x44, 0x4A, 0xE4, 0x34, 0x52, 0x22, 0x25, 0x56, 0x61, 0x15, 0xDA, 
    0xF6, 0xD1, 0x47, 0x15, 0x10, 0x13, 0x01, 0x15, 0xDE, 0x8F, 0xFD, 0xD0, 0x7F, 0xFB, 0xF9, 0x3A, 0x6F, 0x7B, 0x26, 0x7D, 0x8A, 0x5E, 0xBE, 0x7C, 0xF9, 0xF2, 0xE5, 0xCB, 0x57, 0xD1, 0x27, 0xED, 
    0xD9, 0xE6, 0xF5, 0x7B, 0x5C, 0x15, 0x10, 0x13, 0x01, 0x15, 0x97, 0x6E, 0xDD, 0xFA, 0x7F, 0xF8, 0xF9, 0x3A, 0x6F, 0x7B, 0x26, 0x7D, 0x8A, 0x5E, 0xBE, 0x7C, 0xF9, 0xF2, 0xE5, 0xCB, 0x57, 0xD1, 
    0x27, 0xED, 0xD9, 0xE6, 0xF5, 0x7B, 0x5C, 0x15, 0x10, 0x13, 0x01, 0x15, 0xC7, 0x5E, 0x45, 0x9F, 0xA6, 0xFF, 0xF4, 0xF3, 0x75, 0xDE, 0xF6, 0x4C, 0xFA, 0x14, 0xBD, 0x7C, 0xF9, 0xF2, 0xE5, 0xCB, 
    0x97, 0xAF, 0xA2, 0x4F, 0xDA, 0xB3, 0xCD, 0xEB, 0xF7, 0xB8, 0x16, 0x10, 0x13, 0x01, 0x16, 0x9D, 0xF4, 0x3C, 0x8F, 0xB4, 0xFF, 0xFF, 0xE1, 0xE7, 0xEB, 0xBC, 0xED, 0x99, 0xF4, 0x29, 0x7A, 0xF9, 
    0xF2, 0xE5, 0xCB, 0x97, 0x2F, 0x5F, 0x45, 0x9F, 0xB4, 0x67, 0x9B, 0xD7, 0xEF, 0x71, 0x01, 0x15, 0x10, 0x13, 0x01, 0x15, 0x95, 0xF4, 0x49, 0xFA, 0xFF, 0x1F, 0x7E, 0xBE, 0xCE, 0xDB, 0x9E, 0x49, 
    0x9F, 0xA2, 0x97, 0x2F, 0x5F, 0xBE, 0x7C, 0xF9, 0xF2, 0x55, 0xF4, 0x49, 0x7B, 0xB6, 0x79, 0xFD, 0x1E, 0x17, 0x0A, 0x0A, 0x0E, 0x02, 0x0D, 0x89, 0x93, 0x71, 0x99, 0x36, 0x97, 0x66, 0xBD, 0x69, 
    0x19, 0x97, 0x38, 0x01, 0x11, 0x10, 0x13, 0x01, 0x11, 0xF5, 0xC2, 0x5B, 0x33, 0xB5, 0x83, 0xD2, 0xD1, 0xE8, 0x91, 0x78, 0x68, 0xB4, 0xC8, 0xAA, 0xA4, 0xCC, 0xE9, 0xA0, 0xF4, 0x28, 0x3D, 0x24, 
    0x1E, 0x13, 0x3D, 0xDD, 0xCC, 0x5C, 0x15, 0x0C, 0x11, 0x02, 0x15, 0xDB, 0xB7, 0x4F, 0xFF, 0xF4, 0xF0, 0xE1, 0xC3, 0x87, 0x0F, 0x1F, 0x3E, 0x7C, 0xF8, 0xF0, 0xE1, 0xC3, 0x87, 0x0F, 0x1F, 0x45, 
    0x96, 0x3E, 0x7A, 0x15, 0x0C, 0x11, 0x02, 0x15, 0x87, 0x2E, 0x5D, 0xFA, 0xA7, 0x87, 0x0F, 0x1F, 0x3E, 0x7C, 0xF8, 0xF0, 0xE1, 0xC3, 0x87, 0x0F, 0x1F, 0x3E, 0x7C, 0xF8, 0x28, 0xB2, 0xF4, 0xD1, 
    0x03, 0x15, 0x0C, 0x11, 0x02, 0x15, 0xDD, 0xA3, 0xC8, 0x9A, 0x7E, 0xE8, 0xE1, 0xC3, 0x87, 0x0F, 0x1F, 0x3E, 0x7C, 0xF8, 0xF0, 0xE1, 0xC3, 0x87, 0x0F, 0x1F, 0x3E, 0x8A, 0x2C, 0x7D, 0xF4, 0x00, 
    0x15, 0x0C, 0x11, 0x02, 0x15, 0x93, 0x64, 0x49, 0xFF, 0xAD, 0x87, 0x0F, 0x1F, 0x3E, 0x7C, 0xF8, 0xF0, 0xE1, 0xC3, 0x87, 0x0F, 0x1F, 0x3E, 0x7C, 0xF8, 0x28, 0xB2, 0xF4, 0xD1, 0x03, 0x15, 0x10, 
    0x10, 0x00, 0x15, 0x97, 0x6E, 0xDD, 0xFA, 0x2F, 0xBD, 0x8A, 0x3E, 0x4D, 0x8F, 0x38, 0xAF, 0xAB, 0x0E, 0x51, 0x97, 0xA4, 0xCF, 0x27, 0x6F, 0xFD, 0xD0, 0x0F, 0xFD, 0xD0, 0x0F, 0xFD, 0xD0, 0x0F, 
    0xFD, 0xD0, 0x01, 0x11, 0x0C, 0x10, 0x02, 0x11, 0xD0, 0xA7, 0x4F, 0xDF, 0xB5, 0x33, 0x3A, 0x14, 0x3D, 0x7C, 0xF8, 0xF0, 0xE1, 0xA1, 0x9C, 0xB9, 0xA6, 0x4F, 0x9F, 0x3E, 0x7D, 0x11, 0x0C, 0x0F, 
    0x01, 0x11, 0xAA, 0x0F, 0x6E, 0x9B, 0xAA, 0xA9, 0x9A, 0x28, 0x8A, 0xA2, 0xA6, 0x6A, 0xAA, 0xB8, 0xA9, 0x93, 0xBC, 0xE8, 0xE1, 0x42, 0x6A, 0xEA, 0x1C, 0x91, 0x02, 0x11, 0x0B, 0x0D, 0x01, 0x11, 
    0xDB, 0xB5, 0x4B, 0xFF, 0x0F, 0xF3, 0xD1, 0xAA, 0xC8, 0x3A, 0xB8, 0x47, 0x95, 0x22, 0x2B, 0xB2, 0xB2, 0x51, 0xD7, 0x38, 0x01, 0x11, 0x0B, 0x0D, 0x01, 0x11, 0x87, 0x1E, 0x3D, 0xFA, 0x7F, 0x98, 
    0x8F, 0x56, 0x45, 0xD6, 0xC1, 0x3D, 0xAA, 0x14, 0x59, 0x91, 0x95, 0x8D, 0xBA, 0xC6, 0x09, 0x11, 0x0B, 0x0D, 0x01, 0x11, 0xDC, 0xA1, 0xA8, 0x9A, 0xFE, 0xD7, 0x7C, 0xB4, 0x2A, 0xB2, 0x0E, 0xEE, 
    0x51, 0xA5, 0xC8, 0x8A, 0xAC, 0x6C, 0xD4, 0x35, 0x4E, 0x12, 0x0B, 0x0D, 0x01, 0x12, 0x9B, 0xB4, 0x67, 0xD2, 0xFE, 0xFF, 0x32, 0x1F, 0xAD, 0x8A, 0xAC, 0x83, 0x7B, 0x54, 0x29, 0xB2, 0x22, 0x2B, 
    0x1B, 0x75, 0x8D, 0x13, 0x11, 0x0B, 0x0D, 0x01, 0x11, 0x93, 0x54, 0x49, 0xFF, 0x7F, 0x99, 0x8F, 0x56, 0x45, 0xD6, 0xC1, 0x3D, 0xAA, 0x14, 0x59, 0x91, 0x95, 0x8D, 0xBA, 0xC6, 0x09, 0x12, 0x0B, 
    0x0D, 0x01, 0x12, 0xD5, 0x13, 0xE5, 0x88, 0xF2, 0xE8, 0xFF, 0x61, 0x3E, 0x5A, 0x15, 0x59, 0x07, 0xF7, 0xA8, 0x52, 0x64, 0x45, 0x56, 0x36, 0xEA, 0x1A, 0x27, 0x0C, 0x12, 0x15, 0x01, 0x0C, 0xF2, 
    0xC8, 0x27, 0xD6, 0x48, 0x2A, 0xB2, 0xAC, 0x47, 0x16, 0x7F, 0xE4, 0x7F, 0xA6, 0x47, 0x96, 0x59, 0x72, 0x39, 0xF2, 0x8C, 0xAD, 0x00, 0x11, 0x09, 0x0C, 0x01, 0x0C, 0xE3, 0x0E, 0x69, 0x2D, 0x0F, 
    0x1D, 0x3A, 0x74, 0xA8, 0x8A, 0xB6, 0x1C, 0x6B, 0x75, 0xEC, 0x11, 0x4B, 0x0E, 0x11, 0x0A, 0x0D, 0x01, 0x11, 0xDA, 0xB3, 0x47, 0xFF, 0x4D, 0x3E, 0x12, 0x15, 0xF9, 0xFF, 0x1E, 0x3D, 0xAB, 0x22, 
    0x2E, 0x0F, 0x2B, 0x11, 0x0A, 0x0D, 0x01, 0x11, 0xD6, 0xA1, 0x43, 0xFF, 0x4D, 0x3E, 0x12, 0x15, 0xF9, 0xFF, 0x1E, 0x3D, 0xAB, 0x22, 0x2E, 0x0F, 0x2B, 0x11, 0x0A, 0x0D, 0x01, 0x11, 0x9C, 0x15, 
    0x51, 0xD3, 0xFF, 0x91, 0x8F, 0x44, 0x45, 0xFE, 0xBF, 0x47, 0xCF, 0xAA, 0x88, 0xCB, 0xC3, 0x0A, 0x11, 0x0A, 0x0D, 0x01, 0x11, 0x92, 0x44, 0x49, 0xFF, 0x7F, 0x90, 0x8F, 0x44, 0x45, 0xFE, 0xBF, 
    0x47, 0xCF, 0xAA, 0x88, 0xCB, 0xC3, 0x0A, 0x11, 0x04, 0x05, 0xFF, 0x11, 0x98, 0x26, 0x7D, 0x92, 0x24, 0x49, 0x92, 0x24, 0x49, 0x92, 0x24, 0x09, 0x11, 0x04, 0x05, 0x01, 0x11, 0x52, 0x14, 0x7D, 
    0x92, 0x24, 0x49, 0x92, 0x24, 0x49, 0x92, 0x24, 0x49, 0x11, 0x07, 0x05, 0xFF, 0x11, 0xDA, 0x14, 0x45, 0xD3, 0x2F, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x35, 0x11, 0x06, 0x05, 0xFF, 
    0x11, 0x90, 0x28, 0xFD, 0x16, 0x45, 0x51, 0x14, 0x45, 0x51, 0x14, 0x45, 0x51, 0x02, 0x11, 0x0A, 0x0D, 0x01, 0x11, 0xDA, 0x55, 0xB2, 0x99, 0x1E, 0xF1, 0xD0, 0x23, 0xB1, 0xA6, 0x69, 0x9A, 0xA6, 
    0x15, 0x51, 0x3A, 0xCA, 0x01, 0x12, 0x0A, 0x0D, 0x01, 0x12, 0x9A, 0xA4, 0x47, 0xD2, 0xFE, 0x9F, 0x12, 0x75, 0x65, 0xAC, 0x69, 0x9A, 0xA6, 0x69, 0x9A, 0xA6, 0x05, 0x11, 0x0A, 0x0D, 0x01, 0x11, 
    0xDA, 0xB3, 0x47, 0xFF, 0x4D, 0x3E, 0x12, 0x15, 0x99, 0xA6, 0x69, 0x9A, 0x56, 0x44, 0xE9, 0x21, 0x07, 0x11, 0x0A, 0x0D, 0x01, 0x11, 0xD6, 0xA1, 0x43, 0xFF, 0x4D, 0x3E, 0x12, 0x15, 0x99, 0xA6, 
    0x69, 0x9A, 0x56, 0x44, 0xE9, 0x21, 0x07, 0x11, 0x0A, 0x0D, 0x01, 0x11, 0x9C, 0x15, 0x51, 0xD3, 0xFF, 0x91, 0x8F, 0x44, 0x45, 0xA6, 0x69, 0x9A, 0xA6, 0x15, 0x51, 0x7A, 0xC8, 0x01, 0x12, 0x0A, 
    0x0D, 0x01, 0x12, 0x9A, 0xA4, 0x47, 0xD2, 0xFE, 0xFF, 0x20, 0x1F, 0x89, 0x8A, 0x4C, 0xD3, 0x34, 0x4D, 0x2B, 0xA2, 0xF4, 0x90, 0x03, 0x11, 0x0A, 0x0D, 0x01, 0x11, 0x92, 0x44, 0x49, 0xFF, 0x7F, 
    0x90, 0x8F, 0x44, 0x45, 0xA6, 0x69, 0x9A, 0xA6, 0x15, 0x51, 0x7A, 0xC8, 0x01, 0x0A, 0x0A, 0x0E, 0x02, 0x0D, 0xD4, 0xA3, 0xFF, 0xFB, 0xFD, 0x7F, 0x7A, 0x44, 0x0D, 0x0C, 0x0F, 0x01, 0x0C, 0x73, 
    0xA4, 0x4B, 0xE3, 0x22, 0xBB, 0x0A, 0x29, 0x71, 0x1A, 0x25, 0x1E, 0x55, 0xC6, 0xE9, 0x5A, 0xE2, 0xE9, 0x03, 0x11, 0x0A, 0x0D, 0x01, 0x11, 0xDA, 0xB3, 0x47, 0xFF, 0x27, 0xD3, 0x34, 0x4D, 0xD3, 
    0x34, 0x4D, 0x97, 0xCB, 0x25, 0x4A, 0x11, 0x0A, 0x0D, 0x01, 0x11, 0xD6, 0xA1, 0x43, 0xFF, 0x27, 0xD3, 0x34, 0x4D, 0xD3, 0x34, 0x4D, 0x97, 0xCB, 0x25, 0x4A, 0x11, 0x0A, 0x0D, 0x01, 0x11, 0x9C, 
    0x15, 0x51, 0xD3, 0x7F, 0xC8, 0x34, 0x4D, 0xD3, 0x34, 0x4D, 0xD3, 0xE5, 0x72, 0x89, 0x12, 0x11, 0x0A, 0x0D, 0x01, 0x11, 0x92, 0x44, 0x49, 0xFF, 0x4F, 0x99, 0xA6, 0x69, 0x9A, 0xA6, 0x69, 0xBA, 
    0x5C, 0x2E, 0x51, 0x02, 0x16, 0x0B, 0x0C, 0x00, 0x11, 0xD6, 0xA3, 0x47, 0xFF, 0xAD, 0x43, 0x51, 0x25, 0x55, 0x1A, 0x35, 0x4D, 0xD4, 0xC4, 0x49, 0x55, 0x64, 0x45, 0xC7, 0x9E, 0x3D, 0x7B, 0x74, 
    0xE9, 0x99, 0x79, 0xEC, 0x00, 0x16, 0x0A, 0x0D, 0x01, 0x11, 0xD0, 0xA3, 0x47, 0x8F, 0x1E, 0x3D, 0x0A, 0x77, 0x65, 0x54, 0xD4, 0x9A, 0xA6, 0x69, 0xD6, 0x54, 0x1E, 0x29, 0x9C, 0x1E, 0x3D, 0x7A, 
    0xF4, 0xE8, 0x01, 0x16, 0x0B, 0x0C, 0x00, 0x11, 0x93, 0x54, 0x49, 0xFF, 0x7F, 0xE8, 0x50, 0x54, 0x49, 0x95, 0x46, 0x4D, 0x13, 0x35, 0x71, 0x52, 0x15, 0x59, 0xD1, 0xB1, 0x67, 0xCF, 0x1E, 0x5D, 
    0x7A, 0x66, 0x1E, 0x3B, 0x00, 
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\library\xfont.c ===
//****************************************************************************
//
// XBox true-type font scan converter library
//
// History:
//
//   07/06/00 [andrewso] - Created
//   08/04/00 [andrewso] - Added compressed glyph bitmaps
//
//****************************************************************************

#ifdef _XBOX

#include <xtl.h>
#include <xdbg.h>
#include "xfont.h"
#include "xfontformat.h"

#else 

#include <windows.h>
#include "xfont-pc.h"
#include "xfontformat-pc.h"

#endif

#include <stdio.h>
#include <stdarg.h>
#include <assert.h>
#include <d3d8.h>

#include "font.h"
#include "default.h"

//****************************************************************************
// Definitions.
//****************************************************************************

//
// Forwards.
//

HRESULT __stdcall GenerateFontMetrics(Font *);

HRESULT __fastcall XFONT_GetCharacterData(XFONT *,WCHAR, Glyph **, unsigned *);

// Cache methods.
HRESULT __stdcall InitializeCache(Font *, unsigned cbCacheSize);
static BOOL CheckInCache(Font *, WCHAR wch, Glyph **ppGlyph, unsigned *pcbGlyphSize);
static void FreeCacheSpace(Font *, unsigned cbSizeNeeded);

//****************************************************************************
// The APIs
//****************************************************************************

//============================================================================
// Loads a bitmap font of the format defined in xfontformat.h.
//
// This method always allocates ~112 bytes for each font to store the
// font's state.  Additional memory will be allocated depending on the
// value of the uCacheSize parameter:
//
//    0                            - an allocation to hold the bitmap for the 
//                                   last drawn glyph.  The glyph information
//                                   is ready directly out of the file. 
//                                   Very slow.

//    uCacheSize < font file size  - a block of memory of size uCacheSize 
//                                   holds the most recently drawn glyphs.  
//                                   The glyph information is ready directly 
//                                   out of the file.  This can perform 
//                                   reasonably if the cache is sized
//                                   correctly as determined by experimentation.
//
//    uCacheSize >= font file size - a block of memory just large enough to 
//                                   hold the contents of the file will be 
//                                   allocated and the entire font file will 
//                                   be loaded into it.  Very fast.
//
// This automatically sets the opened font as the one that is currently
// active.  The attributes of the font are all set to their defaults.
//============================================================================

HRESULT __stdcall XFONT_OpenBitmapFont
(
    LPCWSTR wszFileName,    // [in] The file name of the font
    unsigned uCacheSize,    // [in] The size of the font cache, in bytes.
    XFONT **ppFont          // [out] The font identifier
)
{
    HRESULT hr;
    Font *pFont = NULL;
    BOOL fUseCache;

    XFNULL(wszFileName, "Invalid file name string - wszFileName");
    XFNULL(ppFont, "Invalid font output parameters - ppFont");

    // Initialize the bitmap package.
    hr = BP_OpenBitmapFont(wszFileName, uCacheSize, &pFont, &fUseCache);

    if (FAILED(hr))
    {
        goto Error;
    }

    if (fUseCache)
    {
        hr = InitializeCache(pFont, uCacheSize);

        if (FAILED(hr))
        {
            goto Error;
        }
    }

    // Reset the font metrics.
    hr = GenerateFontMetrics(pFont);

    if (FAILED(hr))
    {
        goto Error;
    }

    // Set the font style defaults.
    pFont->uAlignmentMode   = XFONT_TOP | XFONT_LEFT;
    pFont->TextColor        = 0xFFFFFFFF;
    pFont->BackgroundColor  = 0x00000000;
    pFont->fPaintBackground = FALSE;

    // Return it.
    *ppFont = (XFONT *)pFont;

    return NOERROR;

Error:
    if (pFont)
    {
        XFONT_Release((XFONT *)pFont);
    }

    return hr;
}

//============================================================================
// Loads a bitmap font of the format defined in xfontformat.h from a block
// of memory, either one that has been loaded into memory by the caller
// or one that is compiled into the title from a source code file
// generated by makefont.exe.
//
// This method always allocates ~112 bytes for each font to store the font's
// current state.  No additional memory will be allocated throughout the 
// lifetime of the font.
//
// The caller must ensure that the memory block that contains the font data
// will live at least as long as the font as it will keep referencing that
// data when it draws.
// 
//============================================================================

HRESULT __stdcall XFONT_OpenBitmapFontFromMemory
(
    CONST void *pFontData,  // [in] The block of font data
    unsigned uFontDataSize, // [in] The size of the font data
    XFONT **ppFont          // [out] The font identifier
)
{
    HRESULT hr;
    Font *pFont = NULL;
    BOOL fUseCache;

    XFNULL(pFontData, "Invalid font data pointer - pFontData");
    XFNULL(ppFont, "Invalid font output parameters - ppFont");

    // Initialize the bitmap package.
    hr = BP_OpenBitmapFontFromMemory(pFontData, uFontDataSize, &pFont);

    if (FAILED(hr))
    {
        goto Error;
    }

    // Reset the font metrics.
    hr = GenerateFontMetrics(pFont);

    if (FAILED(hr))
    {
        goto Error;
    }

    // Set the font style defaults.
    pFont->uAlignmentMode   = XFONT_TOP | XFONT_LEFT;
    pFont->TextColor        = 0xFFFFFFFF;
    pFont->BackgroundColor  = 0x00000000;
    pFont->fPaintBackground = FALSE;

    // Return it.
    *ppFont = (XFONT *)pFont;

    return NOERROR;

Error:
    if (pFont)
    {
        XFONT_Release((XFONT *)pFont);
    }

    return hr;
}

//============================================================================
// Loads the default bitmap font that is compiled directy into the library.
// This is a 24-hight arial font the contains only the western character set 
// and is intended as a convenience for titles that just need a quick way of
// displaying information.
//
// This will also allocate ~112 bytes of memory each time this method is 
// called but will never allocate any more memory throughout the lifetime
// of the font.
//
//============================================================================

HRESULT __stdcall XFONT_OpenDefaultFont
(
    XFONT **ppFont          // [out] The font identifier
)
{
    return XFONT_OpenBitmapFontFromMemory(g_DefaultFont, 
                                          sizeof(g_DefaultFont), 
                                          ppFont);
}

//============================================================================
// XFONT_OpenTrueTypeFont is defined in 'TrueType.cpp' to make the linker
// happy when "xfont.lib" is consumed without the truetype support.
//============================================================================

//============================================================================
// Add a refcount to the font.
//============================================================================

void __stdcall XFONT_AddRef
(
    XFONT *pXFont            // [in] The id of the font
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    pFont->uReferenceCount++;
}


//============================================================================
// Unload a font and free all of its memory.  The XFONT identifier will be 
// invalidated.
//============================================================================

void __stdcall XFONT_Release
(
    XFONT *pXFont       // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");
    XFASSERT(pFont->uReferenceCount != 0, "Reference count underflow.");

    if (pFont->uReferenceCount == 1)
    {
        BYTE *pbCache = pFont->pbCache;

        // Let the particular font package clean up.  This will free the
        // Font structure.
        //
        pFont->pfnUnloadFont(pFont);

        // Free the cache.
        free(pbCache);
    }
    else
    {
        pFont->uReferenceCount--;
    }
}

//============================================================================
// Sets the height of the text cell, in pixels, for the current font.
//
// Defaults to 16 pixels high.  This may only be set on a TrueType font.
//============================================================================

unsigned __stdcall XFONT_GetTextHeight
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->uCellHeight;
}

HRESULT __stdcall XFONT_SetTextHeight
(
    XFONT *pXFont,          // [in] The id of the font to unload
    unsigned uHeight        // [in] The total height of the text cell
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    if (uHeight != pFont->uCellHeight)
    {
        HRESULT hr;

        unsigned uOldCellHeight = pFont->uCellHeight;

        // Tell the font engine.
        pFont->uCellHeight = uHeight;

        hr = pFont->pfnResetTransform(pFont);

        if (FAILED(hr))
        {
            pFont->uCellHeight = uOldCellHeight;

            return hr;
        }

        // Regenerate the height information.
        hr = GenerateFontMetrics(pFont);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    return NOERROR;
}

//============================================================================
// Sets the amount of antialias information to include in the bitmap with
// valid values of 0 (no information), 2, or 4 (lots of information).
//
// The antialiasing works best for larger or bold fonts whose strokes are 
// more the one pixel wide.  
//
// This may only be set on a TrueType font.  Defaults to 0.
//============================================================================

unsigned __stdcall XFONT_GetTextAntialiasLevel
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->uAntialiasLevel;
}

HRESULT __stdcall XFONT_SetTextAntialiasLevel
(
    XFONT *pXFont,          // [in] The id of the font to unload
    unsigned uAntialiasLevel
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    XFASSERT(uAntialiasLevel == 0 || uAntialiasLevel == 2 || uAntialiasLevel == 4,
             "Bad Antialias level.");

    if (pFont->uAntialiasLevel != uAntialiasLevel)
    {
        HRESULT hr;

        unsigned uOldAntialiasLevel = pFont->uAntialiasLevel;

        pFont->uAntialiasLevel = uAntialiasLevel;

        hr = pFont->pfnResetTransform(pFont);

        if (FAILED(hr))
        {
            pFont->uAntialiasLevel = uOldAntialiasLevel;
        }

        return hr;
    }
    else
    {
        return NOERROR;
    }
}

//============================================================================
// Sets the size of the RLE packet used to compress the internal bitmaps
// used by the font.  This may effect the number of bitmaps that can fit
// in the internal cache depending on the size and characteristics of your
// font.  May be 2 - 8.
//
// This may only be set on a TrueType font.  Defaults to 2.
//============================================================================

unsigned __stdcall XFONT_GetRLEWidth
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->uRLEWidth;
}

HRESULT __stdcall XFONT_SetRLEWidth
(
    XFONT *pXFont,          // [in] The id of the font to unload
    unsigned uRLEWidth
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    XFASSERT(uRLEWidth >= 2 && uRLEWidth <=8, "Bad RLE Width value, must be between 2 and 8.");

    if (pFont->uRLEWidth != uRLEWidth)
    {
        HRESULT hr;

        unsigned uOldRLEWidth = pFont->uRLEWidth;

        pFont->uRLEWidth = uRLEWidth;

        hr = pFont->pfnResetTransform(pFont);

        if (FAILED(hr))
        {
            pFont->uRLEWidth = uOldRLEWidth;
        }

        return hr;
    }
    else
    {
        return NOERROR;
    }
}

//============================================================================
// Sets the style for the text, one of NORMAL, BOLD, ITALICS or BOLDITALICS.
// This will cause the TrueType font scaler to simulate these styles when
// generating the bitmaps for the font.  If the font defines the different
// styles in separate TTF files then load each individually instead of 
// using this method.
//
// Defaults to NORMAL.  This may only be set on a TrueType font.
//============================================================================

unsigned __stdcall XFONT_GetTextStyle
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->uStyle;
}

HRESULT __stdcall XFONT_SetTextStyle
(
    XFONT *pXFont,          // [in] The id of the font to unload
    unsigned uStyle
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    XFASSERT(uStyle <= XFONT_BOLDITALICS, "Bad Style parameter")

    if (pFont->uStyle != uStyle)
    {
        HRESULT hr;

        unsigned uOldStyle = pFont->uStyle;

        pFont->uStyle = uStyle;

        hr = pFont->pfnResetTransform(pFont);

        if (FAILED(hr))
        {
            pFont->uStyle = uOldStyle;
        }

        return hr;
    }
    else
    {
        return NOERROR;
    }
}

//============================================================================
// Sets to what part of the text the coordinates passed to XFONT_TextOut refers.
//
// The only parameter must contain one vertical value ORed with one 
// horizontal value.
//
// The vertical alignment value specifies which part of the text is pointed
// to by the y coordinate:
//
//      XFONT_BASELINE  - the baseline of the text
//      XFONT_BOTTOM    - the bottom of the character cell
//      XFONT_TOP       - the top of the character cell
//
// The horizontal alignment value specifies which part of the text is pointed
// to by the x coordinate:
//
//      XFONT_CENTER    - the center of the text
//      XFONT_LEFT      - the leftmost edge of the text
//      XFONT_RIGHT     - the rightmost edge of the text
//
// Defaults to TA_TOP | TA_LEFT.
//============================================================================

unsigned __stdcall XFONT_GetTextAlignment
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->uAlignmentMode;    
}

void __stdcall XFONT_SetTextAlignment
(
    XFONT *pXFont,          // [in] The id of the font to unload
    unsigned uMode
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    // UNDONE: validate this parameter.
    pFont->uAlignmentMode = uMode;    
}

//============================================================================
// Sets the color for the text.  
//
// Defaults to 0xFFFFFFFF (white)
//============================================================================

D3DCOLOR __stdcall XFONT_GetTextColor
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->TextColor;
}

void __stdcall XFONT_SetTextColor
(
    XFONT *pXFont,          // [in] The id of the font to unload
    D3DCOLOR color          // [in] The color of the text
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    pFont->TextColor = color;
}

//============================================================================
// Sets the color with which to fill the background of the text.  
//
// Defaults to 0x00000000 (black)
//============================================================================

D3DCOLOR __stdcall XFONT_GetBkColor
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->BackgroundColor;
}

void __stdcall XFONT_SetBkColor
(
    XFONT *pXFont,          // [in] The id of the font to unload
    D3DCOLOR color          // [in] The color of the text
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    pFont->BackgroundColor = color;
}

//============================================================================
// Sets whether to fill the background of the text cell with the background
// color.
//
// Defaults to XFONT_TRANSPARENT because it is more efficient.
//============================================================================

int __stdcall XFONT_GetBkMode
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->fPaintBackground;
}

void __stdcall XFONT_SetBkMode
(
    XFONT *pXFont,          // [in] The id of the font to unload
    int iBkMode             // [in] Either XFONT_OPAQUE or XFONT_TRANSPARENT
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    XFASSERT(iBkMode == XFONT_OPAQUE || iBkMode == XFONT_TRANSPARENT, "Bad BkMode parameter.");

    pFont->fPaintBackground = iBkMode == XFONT_OPAQUE;
}

//============================================================================
// Sets the number of additional pixels to put between each character.
//============================================================================

unsigned __stdcall XFONT_GetIntercharacterSpacing
(
    XFONT *pXFont           // [in] The id of the font to unload
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    return pFont->uIntercharacterSpacing;
}

void __stdcall XFONT_SetIntercharacterSpacing
(
    XFONT *pXFont,          // [in] The id of the font to unload
    unsigned uSpaces        // [in] The number of extra pixels between each character
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    pFont->uIntercharacterSpacing = uSpaces;
}

//============================================================================
// Sets the clipping rectangle.  Pass NULL to clear.
//============================================================================

D3DRECT *__stdcall XFONT_GetClippingRectangle
(
    XFONT *pXFont          // [in] The id of the font
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    if (pFont->fUseClippingRectangle)
    {
        pFont->ClippingRectangleCopy = pFont->ClippingRectangle;

        return &pFont->ClippingRectangleCopy;
    }
    else
    {
        return NULL;
    }
}

void __stdcall XFONT_SetClippingRectangle
(
    XFONT *pXFont,          // [in] The id of the font
    D3DRECT *pRectangle     // [in] Clipping rectangle
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    if (pRectangle)
    {
        pFont->fUseClippingRectangle = TRUE;
        pFont->ClippingRectangle = *pRectangle;
    }
    else
    {
        pFont->fUseClippingRectangle = FALSE;
    }
}

//============================================================================
// Get the vertical metrics for the current font settings.  
//============================================================================

void __stdcall XFONT_GetFontMetrics
(
    XFONT *pXFont,          // [in] The id of the font to unload
    unsigned *puCellHeight,     
    unsigned *puDescent
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");

    if (puCellHeight)
    {
        *puCellHeight = pFont->uCellHeight;
    }

    if (puDescent)
    {
        *puDescent = pFont->uDescent;
    }
}

//============================================================================
// Get the width of a string in pixels. This method applies any 
// intercharacter spacing.
//============================================================================

HRESULT __stdcall XFONT_GetTextExtent
(
    XFONT *pXFont,          // [in] The id of the font to unload
    LPCWSTR wstr,           // [in] The string
    unsigned cch,           // [in] The length of the string, -1 for a zero terminated string
    unsigned *puWidth       // [out] The width of the string in pixels
)
{
    HRESULT hr;

    Font *pFont = (Font *)pXFont;
    unsigned uIntercharacterSpacing;

    Glyph *pGlyph;
    unsigned cbGlyphSize;

    unsigned ich = 0;
    unsigned uWidth = 0;
    
    XFNULL(pFont, "Invalid font pointer.");

    uIntercharacterSpacing = pFont->uIntercharacterSpacing;

    for (;;)
    {
        hr = XFONT_GetCharacterData(pXFont, *wstr, &pGlyph, &cbGlyphSize);

        if (FAILED(hr)) 
        {
            return hr;
        }

        uWidth += pGlyph->uAdvance;

        // Increment.
        ich++;
        wstr++;

        // Stop?
        if (ich == cch || !*wstr)
        {
            break;
        }

        // Add the intercharacter space.
        uWidth += uIntercharacterSpacing;
    }

    *puWidth = uWidth;

    return NOERROR;
}

//============================================================================
// Draw the text on a surface.  See XFONT_SetTextAlignment for the meaning of
// the x and y coordinates.
//============================================================================

HRESULT __stdcall XFONT_TextOutToMemory
(
    XFONT *pXFont,          // [in] The id of the font to unload
    LPCVOID pBits,          // [in] Memory to write to.
    unsigned Pitch,         // [in] The pitch of that memory.
    unsigned Width,         // [in] Width, in pixels, of the memory
    unsigned Height,        // [in] Hight, in pixels, of the memory.
    D3DFORMAT Format,       // [in] Format of the pixels in the memory.
    LPCWSTR wstr,           // [in] The string
    unsigned cch,           // [in] The length of the string, -1 for a zero terminated string
    long x,                 // [in] The x coordinate of the string
    long y                  // [in] The y coordinate of the string
)
{
    HRESULT hr;

    long lCharacterX;
    long lCharacterY;

    DWORD uClipLeft;
    DWORD uClipTop;
    DWORD uClipRight;
    DWORD uClipBottom;

    //
    // Figure out where to start drawing from.  The rendering package
    // always wants the coordinates of the baseline of the glyph
    // so figure out how we need to munge the values.
    //

    const unsigned uVerticalMask = XFONT_BASELINE | XFONT_BOTTOM | XFONT_TOP;
    const unsigned uHorizontalMask = XFONT_LEFT | XFONT_CENTER | XFONT_RIGHT;

    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");
    XFNULL(pBits, "Invalid bits pointer.");
    XFNULL(wstr,  "Invalid string pointer.");

    // Vertical munging.
    switch(pFont->uAlignmentMode & uVerticalMask)
    {
    default:
        assert(FALSE);     // How did this get through our checks?

        // fall through
    case XFONT_TOP:
        lCharacterY = y;
        break;

    case XFONT_BASELINE:
        lCharacterY = y - (pFont->uCellHeight - pFont->uDescent);
        break;

    case XFONT_BOTTOM:
        lCharacterY = y - pFont->uCellHeight;
        break;
    }

    // Horizontal munging.
    if ((pFont->uAlignmentMode & uHorizontalMask) == XFONT_LEFT)
    {
        lCharacterX = x;
    }
    else
    {
        unsigned uWidth;

        hr = XFONT_GetTextExtent(pXFont, wstr, cch, &uWidth);

        if (FAILED(hr))
        {
            return hr;
        }

        if ((pFont->uAlignmentMode & uHorizontalMask) == XFONT_CENTER)
        {
            lCharacterX = x - uWidth / 2;
        }
        else if ((pFont->uAlignmentMode & uHorizontalMask) == XFONT_RIGHT)
        {
            lCharacterX = x - uWidth;
        }
        else
        {
            assert(FALSE);

            lCharacterX = x;
        }
    }

    // Get information about this surface.
    if (pFont->fUseClippingRectangle)
    {
        uClipLeft   = max(0, pFont->ClippingRectangle.x1);
        uClipTop    = max(0, pFont->ClippingRectangle.y1);
        uClipRight  = min((long)Width, pFont->ClippingRectangle.x2);
        uClipBottom = min((long)Height, pFont->ClippingRectangle.y2);
    }
    else
    {
        uClipLeft   = 0;
        uClipTop    = 0;
        uClipRight  = Width;
        uClipBottom = Height;
    }

    // Draw the string. Just clip to the surface size for now.
    hr = PaintText(pFont, 
                   pBits,
                   Pitch,
                   Format,
                   wstr, 
                   cch, 
                   lCharacterX, 
                   lCharacterY,
                   uClipLeft,
                   uClipTop,
                   uClipRight,
                   uClipBottom);

    return hr;
}

#ifdef _XBOX

//============================================================================
// Draw the text on a surface.  See XFONT_SetTextAlignment for the meaning of
// the x and y coordinates.  This does not work for swizzled surfaces!
//============================================================================

HRESULT __stdcall XFONT_TextOut
(
    XFONT *pXFont,          // [in] The id of the font to unload
    IDirect3DSurface8 *pSurface,    // [in] The surface to draw the text on or NULL
    LPCWSTR wstr,           // [in] The string
    unsigned cch,           // [in] The length of the string, -1 for a zero terminated string
    long x,                 // [in] The x coordinate of the string
    long y                  // [in] The y coordinate of the string
)
{
    D3DSURFACE_DESC SurfaceDesc;
    D3DLOCKED_RECT Lock;

    HRESULT hresult;

    XFNULL(pSurface, "Invalid surface pointer.");

    D3DSurface_GetDesc(pSurface, &SurfaceDesc);
    D3DSurface_LockRect(pSurface, &Lock, NULL, D3DLOCK_TILED);

    hresult = XFONT_TextOutToMemory(pXFont, 
                                    Lock.pBits, 
                                    Lock.Pitch, 
                                    SurfaceDesc.Width, 
                                    SurfaceDesc.Height, 
                                    SurfaceDesc.Format, 
                                    wstr, 
                                    cch, 
                                    x, 
                                    y);

    D3DSurface_UnlockRect(pSurface);

    return hresult;
}

#endif _XBOX

//****************************************************************************
// This method isn't really exposed in the header file.  It isn't static 
// because the makefont utility calls it when building the bitmap glyph
// information.
//****************************************************************************

//============================================================================
// Gets the character data from the current font, regardless of whether 
// it is a TrueType or bitmap font.
//
// The information returned by this method is only guarenteed to be valid
// until the next call to the font package.  This stuff might be stored
// in a cache and get flushed with the next call.
//============================================================================

HRESULT __fastcall XFONT_GetCharacterData
(
    XFONT *pXFont,          // [in] The id of the font to unload
    WCHAR wch, 
    Glyph **ppGlyph,
    unsigned *pcbGlyphSize
)
{
    Font *pFont = (Font *)pXFont;
    XFNULL(pFont, "Invalid font pointer.");
    XFNULL(ppGlyph, "Invalid glyph pointer.");

    // Check the cache first unless we don't have one.
    if (pFont->pbCache && CheckInCache(pFont, wch, ppGlyph, pcbGlyphSize))
    {
        return NOERROR;
    }

    return pFont->pfnGetCharacterData(pFont, wch, ppGlyph, pcbGlyphSize);
}

//****************************************************************************
// Implementation
//****************************************************************************

//============================================================================
// Figure out the vertical height information for this font.
//============================================================================

HRESULT __stdcall GenerateFontMetrics
(
    Font *pFont
)
{
    HRESULT hr;

    Glyph *pGlyph;
    unsigned cbGlyphSize;

    // Figure out the descent, this is defined to be
    // the amount that a lower case 'g' hangs below the baseline.
    // It can be computed by getting the height of the 'g' and
    // subtracting the y component of its bearing.
    //      
    hr = XFONT_GetCharacterData((XFONT *)pFont, L'g', &pGlyph, &cbGlyphSize);

    if (FAILED(hr))
    {
        return hr;
    }

    pFont->uDescent = pGlyph->uBitmapHeight - pGlyph->iBearingY;

    return NOERROR;
}

//****************************************************************************
// Cache implementation.
//****************************************************************************

//
// The design for the cache errors on the side of simplicitly.  If anybody
// decides to actually use the TrueType package then they will probably
// want to put in something a bit more efficient.
//

//============================================================================
// Initialize the cache.
//============================================================================

HRESULT __stdcall InitializeCache
(
    Font *pFont,
    unsigned cbCacheSize
)
{
    if (cbCacheSize)
    {
        BYTE *pbCache = (BYTE *)malloc(cbCacheSize);

        if (!pbCache)
        {
            return E_OUTOFMEMORY;
        }

        // Save the cache info.
        pFont->pbCache = pbCache;
        pFont->pbCacheNext = pbCache;
        pFont->pbCacheEnd = pbCache + cbCacheSize;

        // Initialize the list.
        pFont->CacheHead.pNextEntry = &pFont->CacheHead;
        pFont->CacheHead.pPrevEntry = &pFont->CacheHead;
    }

    return NOERROR;
}

//============================================================================
// Examines the cache to see if we already have the information for a
// character.
//============================================================================

static BOOL CheckInCache
(
    Font *pFont,
    WCHAR wch, 
    Glyph **ppGlyph,
    unsigned *pcbGlyphSize
)
{
    // This is pretty lame.  We probably have to use a slightly more efficient
    // lookup algorithm.
    //
    CacheEntry *pEntry = pFont->CacheHead.pNextEntry;

    while (pEntry->wLength)
    {
        if (pEntry->wch == wch)
        {
            *ppGlyph = (Glyph *)(pEntry + 1);
            *pcbGlyphSize = pEntry->wLength - sizeof(CacheEntry);

            // Move this entry to the front of the list.
            if (pFont->CacheHead.pNextEntry != pEntry)
            {
                // Unlink.
                pEntry->pPrevEntry->pNextEntry = pEntry->pNextEntry;
                pEntry->pNextEntry->pPrevEntry = pEntry->pPrevEntry;

                // Relink.
                pEntry->pNextEntry = pFont->CacheHead.pNextEntry;
                pEntry->pNextEntry->pPrevEntry = pEntry;
                pEntry->pPrevEntry = &pFont->CacheHead;
                pFont->CacheHead.pNextEntry = pEntry;
            }

            return TRUE;
        }

        pEntry = pEntry->pNextEntry;
    }

    return FALSE;
}

//============================================================================
// Alloc cache information for a character.
//============================================================================

HRESULT AddToCache
(
    Font *pFont,
    WCHAR wch,
    unsigned cbGlyph,
    Glyph **ppGlyph
)
{
    long cbSizeNeeded = (sizeof(CacheEntry) + sizeof(Glyph) + cbGlyph + 3) & ~3;  // 4 byte aligned
    CacheEntry *pEntry;

    // If the cache isn't big enough, just alloc a block of memory
    // and use that.
    //
    if (cbSizeNeeded > pFont->pbCacheEnd - pFont->pbCache)
    {
        // We need 1 extra byte for the packer.
        pFont->pvOneGlyph = malloc(cbSizeNeeded + 1);

        if (!pFont->pvOneGlyph)
        {
            return E_OUTOFMEMORY;
        }

        *ppGlyph = (Glyph *)pFont->pvOneGlyph;

        return NOERROR;
    }

    if (cbSizeNeeded > pFont->pbCacheEnd - pFont->pbCacheNext)
    {
        FreeCacheSpace(pFont, cbSizeNeeded);
    }

    // Get the memory.
    pEntry = (CacheEntry *)pFont->pbCacheNext;

    // Don't forget about it.
    pFont->pbCacheNext += cbSizeNeeded;

    // Link it at the head of the list.
    pEntry->pNextEntry = pFont->CacheHead.pNextEntry;
    pEntry->pNextEntry->pPrevEntry = pEntry;
    pEntry->pPrevEntry = &pFont->CacheHead;
    pFont->CacheHead.pNextEntry = pEntry;

    // Save the cache info.
    pEntry->wch = wch;
    pEntry->wLength = (WORD)cbSizeNeeded;

    // Return it.
    *ppGlyph = (Glyph *)(pEntry + 1);

    return NOERROR;
}

//============================================================================
// Reset the cache back to nothin'.
//============================================================================

void ClearCache
(
    Font *pFont
)
{
    if (pFont)
    {
        pFont->pbCacheNext = pFont->pbCache;

        pFont->CacheHead.pNextEntry = &pFont->CacheHead;
        pFont->CacheHead.pPrevEntry = &pFont->CacheHead;
    }
}

//============================================================================
// Free up enough room in the cache to hold a new entry.
//============================================================================

static void FreeCacheSpace
(
    Font *pFont,
    unsigned cbSizeNeeded
)
{
    unsigned cbSizeFree;
    CacheEntry *pEntry;
    unsigned cbFreed;

    BYTE *pbNext;
    BYTE *pbEnd;

    // Free either the requested size or 1/4 of the cache, whichever is bigger.
    // This won't work well for very small caches with large bitmaps...
    // we'll spend an aweful lot of time freeing.
    //
    cbSizeFree = max(cbSizeNeeded, (unsigned)(pFont->pbCacheEnd - pFont->pbCache) / 4);

    // We can walk the entries in two ways:
    //
    //  - Through the circularly linked list in either direction.  This list
    //    has the most recently accessed glyph at the front.
    //    
    //  - Through the memory in the order the entries were allocated
    //    via the wLength field.
    //
    // This routine first walks the linked list backwards and "nulls" enough
    // nodes to fit our requirement.  It then walks through memory
    // compressing out those null nodes.  This ruins the whole sense of
    // order in the list...we'll regen that soon enough.
    //
    pEntry = pFont->CacheHead.pPrevEntry;
    cbFreed = 0;

    // Free the spaces.
    while (pEntry->wLength && cbFreed < cbSizeFree)
    {
        // Remember the size.
        cbFreed += pEntry->wLength;

        // Mark it as dead by wonking the next field.
        pEntry->pNextEntry = NULL;

        pEntry = pEntry->pPrevEntry;
    }

    // Reset the list.
    pFont->CacheHead.pNextEntry = &pFont->CacheHead;
    pFont->CacheHead.pPrevEntry = &pFont->CacheHead;

    // Walk through the memory through the allocations, remove the dead
    // entries and relink the other ones back onto the list.
    //
    pbNext = pFont->pbCache;
    pbEnd = pFont->pbCacheNext;

    pEntry = (CacheEntry *)pbNext;

    while ((BYTE *)pEntry < pbEnd)
    {
        // Valid entry?
        if (pEntry->pNextEntry)
        {
            CacheEntry *pNewEntry;

            // Move it.
            if ((BYTE *)pEntry != pbNext)
            {
                memmove(pbNext, pEntry, pEntry->wLength);

                pNewEntry = (CacheEntry *)pbNext;
            }
            else
            {
                pNewEntry = pEntry;
            }

            // Relink it onto the end of the list.
            pNewEntry->pPrevEntry = pFont->CacheHead.pPrevEntry;
            pNewEntry->pPrevEntry->pNextEntry = pNewEntry;
            pNewEntry->pNextEntry = &pFont->CacheHead;
            pFont->CacheHead.pPrevEntry = pNewEntry;

            // The fields in 'pEntry' may have been wonked by the 
            // above move, increment based off the valid field.
            //
            pEntry = (CacheEntry *)((BYTE *)pEntry + pNewEntry->wLength);
            pbNext += pNewEntry->wLength;
        }
        else
        {
            pEntry = (CacheEntry *)((BYTE *)pEntry + pEntry->wLength);
        }
    }

    pFont->pbCacheNext = pbNext;
}

//****************************************************************************
// Debug helpers.
//****************************************************************************

#if DBG

void XFRIP(PCHAR Format, ...)
{
    char string[MAX_PATH];
    va_list arglist;

    va_start(arglist, Format);
    _vsnprintf(string, sizeof(string), Format, arglist);
    va_end(arglist);

#if XBOX
    XDebugError("XFONT", string);
#else
    OutputDebugStringA(string);
    __asm int 3;
#endif
}

#endif DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\fnterr.h ===
#ifndef _FNTERR_H
#define _FNTERR_H
/**********************************************************************
	
	fnterr.h -- Error Support Routines prototypes.

	(c) Copyright 1992  Microsoft Corp.
	All rights reserved.

	This header file provides prototypes for the fnterr.c 
	 source module.  This module keys on the #define FSCFG_FNTERR
	which is defined in fsconfig.h

	 7/28/92 dj         First cut.

 **********************************************************************/


#ifdef FSCFG_FNTERR

#define ERR_RANGE                 1
#define ERR_ASSERTION             2
#define ERR_CVT                   3
#define ERR_FDEF                  4
#define ERR_ELEMENT               5
#define ERR_INDEX                 6
#define ERR_STORAGE               7
#define ERR_STACK                 8
#define ERR_POINT                 9
#define ERR_POINT_TLP             10
#define ERR_POINT_PP              11
#define ERR_CONTOUR               12
#define ERR_VECTOR                13
#define ERR_LARGER                14
#define ERR_INT8                  15
#define ERR_INT16                 16
#define ERR_SCANMODE              17
#define ERR_SELECTOR              18
#define ERR_STATE                 19
#define ERR_GETSINGLEWIDTHNIL     20
#define ERR_GETCVTENTRYNIL        21
#define ERR_INVOPC                22
#define ERR_UNBALANCEDIF          23

#define ERR_CONTEXT_FILE          0
#define ERR_CONTEXT_SIZE          1
#define ERR_CONTEXT_CODE          2

#define ERR_CONTEXT(a,b,c,d)      fnterr_Context((a),(b),(c),(d))
#define ERR_START()               fnterr_Start()
#define ERR_RECORD(a)             fnterr_Record((int)(a))
#define ERR_REPORT(a,b,c,d,e)     fnterr_Report((int)(a),(long)(b),(long)(c),(long)(d),(long)(e))
#define ERR_BREAK()               { if ( fnterr_Break() ) break; }
#define ERR_OPC(a)                fnterr_Opc(a)
#define ERR_END()                 fnterr_End()
#define ERR_IF(a)                 fnterr_If(a)

void fnterr_Context (int, char *, unsigned short, unsigned short);
void fnterr_Start (void);
void fnterr_Record (int);
void fnterr_Report (int, long, long, long, long);
int  fnterr_Break (void);
void fnterr_Opc (char*);
void fnterr_End (void);
void fnterr_If (int);

#else

#define ERR_CONTEXT(a,b,c,d)
#define ERR_START()
#define ERR_RECORD(a)
#define ERR_REPORT(a,b,c,d,e)     DEBUGGER ()
#define ERR_BREAK()
#define ERR_OPC(a)
#define ERR_END()
#define ERR_IF(a)

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\fnterr.c ===
/**********************************************************************
	
	fnterr.c -- Error Support Routines.

	(c) Copyright 1992  Microsoft Corp.
	All rights reserved.

	This source file provides support for debugging routines in fnt.c
	(and macjob.c to a much lesser extent).  This module keys on the
	 #define FSCFG_FNTERR which is defined in fsconfig.h

	 7/28/92 dj         First cut.
	 8/12/94 deanb      included fnterr.h for mac
	12/07/94 deanb		changed %x to %hx or %lx; %d to %hd

 **********************************************************************/

#define FSCFG_INTERNAL

#include "fsconfig.h"
#include "fnterr.h"

#ifdef FSCFG_FNTERR
#include <stdio.h>
#include <string.h>
#include <ctype.h>

/* FILE * fopen(); */
int    abs (int);
/*
int    strlen (char*);
int    strcmp (char*, char*);
int    strcpy (char*, char*);
int    strncpy( char*, char *, int);
*/

#define ERR_MAX_IFS      8
#define ERR_MAX_CODE     16
#define ERR_MAX_FNAME    80
#define ERR_MAX_MSG  512

static int               errOpc;
static int               errBreak;
static int               errIfOk  = 1;
static unsigned short    errSize  = 0;
static unsigned short    errCode  = 0;
static int               errIfNdx = 0;
static long              errInstCount;
static int               errIfs[ERR_MAX_IFS];
static char              errOpName[ERR_MAX_CODE];
static char              errFname[ERR_MAX_FNAME];
static char            * errOpcs[] =
{
  "SVTCA_0",
  "SVTCA_1",
  "SPVTCA",
  "SPVTCA",
  "SFVTCA",
  "SFVTCA",
  "SPVTL",
  "SPVTL",
  "SFVTL",
  "SFVTL",
  "WPV",
  "WFV",
  "RPV",
  "RFV",
  "SFVTPV",
  "ISECT",
  "SetLocalGraphicState",
  "SetLocalGraphicState",
  "SetLocalGraphicState",
  "SetElementPtr",
  "SetElementPtr",
  "SetElementPtr",
  "SetElementPtr",
  "SetLocalGraphicState",
  "SetRoundState",
  "SetRoundState",
  "LMD",
  "ELSE",
  "JMPR",
  "LWTCI",
  "LSWCI",
  "LSW",
  "DUP",
  "SetLocalGraphicState",
  "CLEAR",
  "SWAP",
  "DEPTH",
  "CINDEX",
  "MINDEX",
  "ALIGNPTS",
  "RAW",
  "UTP",
  "LOOPCALL",
  "CALL",
  "FDEF",
  "IllegalInstruction",
  "MDAP",
  "MDAP",
  "IUP",
  "IUP",
  "SHP",
  "SHP",
  "SHC",
  "SHC",
  "SHE",
  "SHE",
  "SHPIX",
  "IP",
  "MSIRP",
  "MSIRP",
  "ALIGNRP",
  "SetRoundState",
  "MIAP",
  "MIAP",
  "NPUSHB",
  "NPUSHW",
  "WS",
  "RS",
  "WCVT",
  "RCVT",
  "RC",
  "RC",
  "WC",
  "MD",
  "MD",
  "MPPEM",
  "MPS",
  "FLIPON",
  "FLIPOFF",
  "DEBUG",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "IF",
  "EIF",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "DELTAP1",
  "SDB",
  "SDS",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "ROUND",
  "ROUND",
  "ROUND",
  "ROUND",
  "NROUND",
  "NROUND",
  "NROUND",
  "NROUND",
  "WCVTFOD",
  "DELTAP2",
  "DELTAP3",
  "DELTAC1",
  "DELTAC2",
  "DELTAC3",
  "SROUND",
  "S45ROUND",
  "JROT",
  "JROF",
  "SetRoundState",
  "IllegalInstruction",
  "SetRoundState",
  "SetRoundState",
  "SANGW",
  "AA",
  "FLIPPT",
  "FLIPRGON",
  "FLIPRGOFF",
  "IDefPatch",
  "IDefPatch",
  "SCANCTRL",
  "SDPVTL",
  "SDPVTL",
  "GETINFO",
  "IDEF",
  "ROTATE",
  "BinaryOperand",
  "BinaryOperand",
  "SCANTYPE",
  "INSTCTRL",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP"
};

/*
  errOutput() - writes an error to standard out and to a log file.  the
  log file is always opened and closes in order to avoid file corruption
  by an application gone wild.
*/
static void errOutput( char * );
static void errOutput( char * msg )
{
  static  int firsttime = 1;
  FILE  * fp;

  printf("%s", msg);
  fp = fopen ("compfont.err", (firsttime ? "w" : "a"));
  if (fp)
  {
	fprintf (fp, "%s", msg);
	fclose (fp);
  }
  firsttime = 0;
  return;
}

/*
  errPrint() - used to generate a useful (?) error message based on the 
  error 'flag' and the parameters ('v1..v4').
*/
static void errPrint (int, long, long, long, long);
static void errPrint (int flag, long v1, long v2, long v3, long v4)
{
  char   msg[ERR_MAX_MSG];
  char * opcodeName;
  char   c;
  int    i;

/*
  build the context line.  it indicates the file being processed, the point
  size, the character code (or glyph index), as well as the releative inst 
  number of this instruction for this code.
*/
  i  = sprintf (msg,   "\n*** ERROR*** ");
  i += sprintf (msg+i, "\"%s\", ", errFname);
  i += sprintf (msg+i, "%hd Point, ", errSize);
  i += sprintf (msg+i, "Code %hd (0x%hX), ", errCode, errCode);
  i += sprintf (msg+i, "Inst: #%ld\n", errInstCount);

/*
  build the error line.  it indicates the name of the instruction followed
  by the actual error information.  note: finding the actual opcode name
  for some the instructions is sorta kludgy.  names like "SetLocalGraphicState",
  and "BinaryOperand" are not actual instructions.  In these cases, look to
  the second character of the name - if it is lower case, then we need to 
  work a little harder, so look to 'errOpName' (which should be set by this
  point) it should contain the correct instruction name.
*/
  c = *(errOpcs[errOpc]+1);
  opcodeName =(islower(c) && strlen(errOpName)) ? errOpName : errOpcs[errOpc];
  i += sprintf (msg+i, "(%s) ", opcodeName);
  errOpName[0] = '\0';

/*
  output what you have so far and then process the error
*/
  errOutput (msg);
  switch (flag)
  {
	case ERR_RANGE:
	  sprintf (msg, "Value out of range: value = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_ASSERTION:
	  sprintf (msg, "Assertion check failed\n"); 
	  break;
	case ERR_CVT:
	  sprintf (msg, "CVT out of range: CVT = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_FDEF:
	  sprintf (msg, "FDEF out of range: FDEF = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_ELEMENT:
	  sprintf (msg, "Element %ld exceeds max elements (%ld)\n", v1, v2, v3); 
	  break;
	case ERR_CONTOUR:
	  i = sprintf (msg, "CONTOUR out of range: ");
	sprintf (msg+i, "CONTOUR = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_POINT:
	  i = sprintf (msg, "POINT out of range: ");
	sprintf (msg+i, "POINT = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_INDEX:
	  i = sprintf (msg, "POINT 0x%lX is neither element[0] ", v1);
	  sprintf( msg+i, "(0x%lX) nor element[1] (0x%lX)\n", v2, v3); 
	  break;
	case ERR_STORAGE:
	  i = sprintf (msg, "Storage index out of range: ");
	sprintf (msg+i, "Index = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_STACK:
	  i = sprintf (msg, "Stack pointer out of range: ");
	sprintf (msg+i, "Pointer = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_VECTOR:
	  sprintf (msg, "Illegal (x.y) vector: (%ld.%ld)\n", v1, v2); 
	  break;
	case ERR_LARGER:
	  sprintf (msg, "Value too small: %ld is not larger than %ld\n", v2, v1); 
	  break;
	case ERR_INT8:
	  sprintf (msg, "Value too large: 0x%lX exceeds 1 byte capacity\n", v1);
	  break;
	case ERR_INT16:
	  sprintf (msg, "Value too large: 0x%lX exceeds 2 byte capacity\n", v1);
	  break;
	case ERR_SCANMODE:
	  sprintf (msg, "Invalid scan mode: %ld\n", v1);
	  break;
	case ERR_SELECTOR:
	  sprintf (msg, "Invalid scan value: %ld\n", v1);
	  break;
	case ERR_STATE:
	  i = sprintf (msg, "Boundry limit error: xmin = ");
	  sprintf (msg+1, "%ld, xmax = %ld, ymin = %ld, ymax = %ld\n",
				v1, v2, v3, v4); 
	  break;
	case ERR_GETSINGLEWIDTHNIL:
	  sprintf (msg, "Sanity: Single width is nil\n");
	  break;
	case ERR_GETCVTENTRYNIL:
	  sprintf (msg, "Sanity: CVT Entry is nil\n");
	  break;
	case ERR_INVOPC:
	  sprintf (msg, "Invalid opcode: %ld\n", v1);
	  break;
	case ERR_UNBALANCEDIF:
	  sprintf (msg, "Unbalanced: missing %s instruction\n",
				( v1 > 0 ) ? "EIF" : "IF" );
	  break;
	default:
	  sprintf (msg, "Unknown Error:\n");
	  break;
  }

/*
  output the rest and return
*/
  errOutput (msg);
  return;
}

/*
  fnterr_Context() - called before any other fnterr routine.  it records
  the job name, character size and character code / glyph index.
*/
void fnterr_Context (int sw, char * str, unsigned short sz, unsigned short cd)
{
/*
  record a piece of the context
*/
  switch (sw)
  {
	case ERR_CONTEXT_FILE:
	  strncpy ( errFname, str, ERR_MAX_FNAME);
	  errFname[ERR_MAX_FNAME-1] = '\0';
	  break;
	case ERR_CONTEXT_SIZE:
	  errSize = sz;
	  break;
	case ERR_CONTEXT_CODE:
	  errCode = cd;
	  break;
  }

/*
  reset errOpName to be NULL before we start any real processing
*/
  errOpName[0] = '\0';
  return;
}

/*
  fnterr_Start() - called before the main execute loop of fnt_Execute() and
  fnt_TraceExecute().  it resets the instruction count to zero, and errBreak
  to 0 (ie: don't break out of execution loop).  set up IF/EIF counter for
  this level.
*/
void fnterr_Start (void)
{
  errInstCount = 0L;
  errBreak = 0;

  if (errIfOk && (++errIfNdx < ERR_MAX_IFS ))
	errIfs[errIfNdx] = 0;
  else
	errIfOk = 0;

  return;
}

/*
  fnterr_Record() - called inside the main execute loop of fnt_Execute()
  and fnt_TraceExecute().  it increments the instruction count, and resets
  the opcode number.  IFs or EIFs are accounted for. (note: other IFs and
  EIFs will be accounted for by calls to ERR_IF() in fnt.c)
*/
void fnterr_Record (int opc)
{
  errInstCount++;
  errOpc = opc;

  if (!strcmp ("IF", errOpcs[errOpc]))
	fnterr_If (1);
  else if (!strcmp ("EIF", errOpcs[errOpc]))
	fnterr_If (-1);

  return;
}

/*
  fnterr_Report() - called inside the main execute loop of fnt_Execute()
  and fnt_TraceExecute().  it calls errPrint() (with the passed parameters)
  to note the error, and sets errBreak so that the execution loop will end.
*/
void fnterr_Report (int flag, long v1, long v2, long v3, long v4)
{
  errPrint (flag, v1, v2, v3, v4);
  errBreak = 1;
  return;
}

/*
  fnterr_Break() - returns the value of errBreak.  if a non-zero valid is
  returned (re: fnterr_Report()), the main execute loop of fnt_Execute()
  or fnt_TraceExecute() will terminate.
*/
int fnterr_Break (void)
{
  return (errBreak);
}

/*
  fnterr_Opc() - called by combinate fnt calls to indicate the actual
  opcode errGet() can use.  this is a kludgy way to get around the non
  real opcode name in the errOpcs[] table.
*/
void fnterr_Opc (char *opc)
{
  strcpy (errOpName, opc);
  return;
}

/*
  fnterr_End() - called after the main execute loop of fnt_Execute() and
  fnt_TraceExecute().  it checks for balanced IF/EIF pairs.
*/
void fnterr_End (void)
{
  if (errIfOk)
  {
	if (errIfs[errIfNdx])
	  errPrint (ERR_UNBALANCEDIF, (long)errIfs[errIfNdx], 0L, 0L, 0L);
	if (--errIfNdx < 0)
	  errIfOk = 0;
  }
  return;
}

/*
  fnterr_If() - records IF/EIF activity inside of fnt_IF(), fnt_ELSE() and
  fnt_EIF() (re: fnt.c).
*/
void fnterr_If (int val)
{
  if (errIfOk)
	errIfs[errIfNdx] += val;
  return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\fontmath.h ===
/*
		File:           fontmath.h

		Contains:       xxx put contents here xxx

		Written by:     xxx put writers here xxx

		Copyright:      c 1990 by Apple Computer, Inc., all rights reserved.
						(c) 1989-1997. Microsoft Corporation, all rights reserved.

		Change History (most recent first):

				  <>     2/21/97		CB				ClaudeBe, add mth_UnitarySquare for scaled component in composite glyphs
				 <4>    11/27/90        MR              make pascal declaration a macro, conditionalize traps -vs-
																		externs for Fix/Frac math routines. [ph]
				 <3>     11/5/90        MR              Move [U]SHORTMUL into fscdefs.h Rename FixMulDiv to LongMulDiv.
																		[rb]
				 <2>    10/20/90        MR              Add some new math routines (stolen from skia). [rj]
				 <1>     4/11/90        dba             first checked in

		To Do:
*/
#ifdef __cplusplus
extern "C" {
#endif

#define HIWORDMASK              0xffff0000
#define LOWORDMASK              0x0000ffff
#define DOT6ONEHALF             0x00000020
#define ONESHORTFRAC            (1 << 14)

#define ROUNDFIXTOINT( x )      (int16)((((Fixed) x) + ONEHALFFIX) >> 16)
#define ROUNDFIXED( x )         (((x) + (Fixed)ONEHALFFIX) & (Fixed)HIWORDMASK)
#define DOT6TOFIX(n)            ((Fixed) (n) << 10)
#define FIXEDTODOT6(n)          (F26Dot6) (((n) + ((1) << (9))) >> 10)
#define INTTOFIX(n)             ((Fixed) (n) << 16)
#define INTTODOT6(n)            ((F26Dot6) (n) << 6)
#define FS_HIWORD(n)            ((uint16)((uint32)(n) >> 16))
#define FS_LOWORD(n)            ((uint16)(n))
#define LOWSIXBITS              0x3F


#ifndef __TOOLUTILS__
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixMul(Fixed,Fixed)   FS_MAC_TRAP(0xA868);
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixRatio (int16 sA, int16 sB);
#endif

#ifndef __FIXMATH__
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixDiv(Fixed,Fixed)  FS_MAC_TRAP(0xA84D);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracMul(Fract,Fract) FS_MAC_TRAP(0xA84A);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracDiv(Fract,Fract) FS_MAC_TRAP(0xA84B);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracSqrt(Fract)      FS_MAC_TRAP(0xA849);
#endif


ShortFract      TMP_CONV NEAR ShortFracDot (ShortFract x, ShortFract y);
F26Dot6         TMP_CONV NEAR ShortFracMul (F26Dot6 x, ShortFract y);
ShortFract      TMP_CONV NEAR ShortFracDiv (ShortFract x, ShortFract y);
F26Dot6         TMP_CONV NEAR Mul26Dot6 (F26Dot6 a, F26Dot6 b);
F26Dot6         TMP_CONV NEAR Div26Dot6 (F26Dot6 num, F26Dot6 den);
int16           TMP_CONV NEAR MulDivShorts (int16 x, int16 y, int16 z);


#define MulDiv26Dot6(a,b,c) LongMulDiv(a,b,c)

int32 LongMulDiv(int32 a, int32 b, int32 c);     /* (a*b)/c */

int32 ShortMulDiv(int32 a, int16 b, int16 c);     /* (a*b)/c */

ShortFract ShortFracMulDiv(ShortFract,ShortFract,ShortFract);

void mth_FixXYMul (Fixed* x, Fixed* y, transMatrix* matrix);
void mth_FixVectorMul (vectorType* v, transMatrix* matrix);

/*
 *   B = A * B;     <4>
 *
 *         | a  b  0  |
 *    B =  | c  d  0  | * B;
 *         | 0  0  1  |
 */
void mth_MxConcat2x2 (transMatrix* matrixA, transMatrix* matrixB);

/*
 * scales a matrix by sx and sy.
 *
 *              | sx 0  0  |
 *    matrix =  | 0  sy 0  | * matrix;
 *              | 0  0  1  |
 */
void mth_MxScaleAB (Fixed sx, Fixed sy, transMatrix *matrixB);

boolean mth_IsMatrixStretched (transMatrix*trans);

boolean mth_Identity (transMatrix *matrix);
boolean mth_PositiveSquare (transMatrix *matrix);
boolean mth_PositiveRectangle (transMatrix *matrix);

/*
 * unitary Square
 *
 *              | +-1    0  0  |
 *    matrix =  |   0  +-1  0  |
 *              |   0    0  1  |
 */

boolean mth_UnitarySquare (transMatrix *matrix);

boolean mth_SameStretch (Fixed fxScaleX, Fixed fxScaleY);

boolean mth_GeneralRotation (transMatrix *matrix);
uint16 mth_90degRotationFactor (transMatrix *matrix);
uint16 mth_90degClosestRotationFactor (transMatrix *matrix);
void mth_Non90DegreeTransformation(transMatrix *matrix, boolean *non90degreeRotation, boolean *nonUniformStretching);

int32 mth_CountLowZeros (uint32 n );
Fixed mth_max_abs (Fixed a, Fixed b);

int32 mth_GetShift (uint32 n);

void mth_ReduceMatrix(transMatrix *trans);

void mth_IntelMul (
	int32           lNumPts,
	F26Dot6 *       fxX,
	F26Dot6 *       fxY,
	transMatrix *   trans,
	Fixed           fxXStretch,
	Fixed           fxYStretch);

void    mth_FoldPointSizeResolution(
	Fixed           fxPointSize,
	int16           sXResolution,
	int16           sYResolution,
	transMatrix *   trans);

/*********************************************************************/

/*  Scan Converter Math Functions Appended for now         <5> DeanB */

/*********************************************************************/

int32 PowerOf2(
		int32                   /* + or - 32 bit value */
);

FS_PUBLIC int16 mth_DivShiftShort(int16 sValue, int16 sFactor);
FS_PUBLIC int32 mth_DivShiftLong(int32 sValue, int16 sFactor);

/*********************************************************************/
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\fontmath.c ===
/*
	File:       FontMath.c

	Contains:   xxx put contents here xxx

	Written by: xxx put writers here xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		  <>     2/21/97	CB		ClaudeBe, add mth_UnitarySquare for scaled component in composite glyphs
		 <3>     11/9/90    MR      Fix CompDiv when numer and denom have zero hi longs. [rb]
		 <2>     11/5/90    MR      Remove Types.h from include list, rename FixMulDiv to LongMulDiv
									[rb]
		 <1>    10/20/90    MR      Math routines for font scaler. [rj]

	To Do:
*/

// Has anybody ever thought of replacing some of the 64bit arithmetic in here (and probably in other places)
// by "native" __int64 arithmetic, at least in the INTEL case? Could be faster, since the compiler gets to do
// the inline code, and would be ready for future 64bit architectures. Just a thought. B.St.

#define FSCFG_INTERNAL

#include "fscdefs.h"
#include "fserror.h"
#include "fontmath.h"

#define HIBITSET                      0x80000000UL
#define POSINFINITY               0x7FFFFFFFUL
#define NEGINFINITY               0x80000000UL
#define POINTSPERINCH               72
#define ALMOSTZERO 33
#define ISNOTPOWEROF2(n)        ((n) & ((n)-1))
#define CLOSETOONE(x)   ((x) >= ONEFIX-ALMOSTZERO && (x) <= ONEFIX+ALMOSTZERO)
#define MAKEABS(x)  if (x < 0) x = -x
#define FXABS(x)  ((x) >= 0L ? (x) : -(x))
#define FRACT2FIX(n)    (((n) + (1 << (sizeof (Fract) - 3))) >> 14)

#define FASTMUL26LIMIT      46340
#define FASTDIV26LIMIT  (1L << 25)

#define USHORTMUL(a, b) ((uint32)((uint32)(uint16)(a)*(uint32)(uint16)(b)))

boolean mth_Max45Trick (Fixed x, Fixed y);

/*******************************************************************/

/* local prototypes */

void CompMul(int32 src1, int32 src2, int32 dst[2]);

int32 CompDiv(int32 src1, int32 src2[2]);

/*******************************************************************/

#ifndef CompMul

void CompMul(int32 lSrc1, int32 lSrc2, int32 alDst[2])
{
	boolean     bNegative;
	uint32      ulDstLo;
	uint32      ulDstHi;
	uint16      usSrc1lo;
	uint16      usSrc1hi;
	uint16      usSrc2lo;
	uint16      usSrc2hi;
	uint32      ulTemp;

	bNegative = (lSrc1 ^ lSrc2) < 0;

	if (lSrc1 < 0)
	{
		lSrc1 = -lSrc1;
	}
	if (lSrc2 < 0)
	{
		lSrc2 = -lSrc2;
	}

	usSrc1hi = (uint16)(lSrc1 >> 16);
	usSrc1lo = (uint16)lSrc1;
	usSrc2hi = (uint16)(lSrc2 >> 16);
	usSrc2lo = (uint16)lSrc2;
	ulTemp   = (uint32)usSrc1hi * (uint32)usSrc2lo + (uint32)usSrc1lo * (uint32)usSrc2hi;
	ulDstHi  = (uint32)usSrc1hi * (uint32)usSrc2hi + (ulTemp >> 16);
	ulDstLo  = (uint32)usSrc1lo * (uint32)usSrc2lo;
	ulTemp <<= 16;
	ulDstLo += ulTemp;
	ulDstHi += (uint32)(ulDstLo < ulTemp);

	if (bNegative)
	{
		ulDstLo = (uint32)-((int32)ulDstLo);

		if (ulDstLo != 0L)
		{
			ulDstHi = ~ulDstHi;
		}
		else
		{
			ulDstHi = (uint32)-((int32)ulDstHi);
		}
	}

	alDst[0] = (int32)ulDstHi;
	alDst[1] = (int32)ulDstLo;
}
#endif

/*******************************************************************/

#ifndef CompDiv

int32 CompDiv(int32 lSrc1, int32 alSrc2[2])
{
	boolean     bNegative;
	uint32      ulSrc1Lo;
	uint32      ulSrc1Hi;
	uint32      ulSrc2Lo;
	uint32      ulSrc2Hi;
	uint32      ulResult;
	uint32      ulPlace;

	int32    lResult;

	ulSrc2Hi = (uint32)alSrc2[0];
	ulSrc2Lo = (uint32)alSrc2[1];

	bNegative = ((int32)ulSrc2Hi ^ lSrc1) < 0;

	if ((int32)ulSrc2Hi < 0L)
	{
		ulSrc2Lo = (uint32)-((int32)ulSrc2Lo);

		if (ulSrc2Lo != 0L)
		{
			ulSrc2Hi = ~ulSrc2Hi;
		}
		else
		{
			ulSrc2Hi = (uint32)-((int32)ulSrc2Hi);
		}
	}
	if (lSrc1 < 0)
	{
		lSrc1 = -lSrc1;
	}

	ulResult = 0;
	ulPlace = HIBITSET >> 1;

	ulSrc1Hi = (uint32)lSrc1;

	if (ulSrc1Hi & 1)
	{
		ulSrc1Lo = HIBITSET;
	}
	else
	{
		ulSrc1Lo = 0;
	}

	ulSrc1Hi >>= 1;
	ulSrc2Lo += ulSrc1Hi;
	ulSrc2Hi += (uint32)(ulSrc2Lo < ulSrc1Hi);      /* round the result */

	if (ulSrc2Hi > ulSrc1Hi || ulSrc2Hi == ulSrc1Hi && ulSrc2Lo >= ulSrc1Lo)
	{
		if (bNegative)
		{
			return (int32)NEGINFINITY;
		}
		else
		{
			return (int32)POSINFINITY;
		}
	}

	while (ulPlace && ulSrc2Hi)
	{
		ulSrc1Lo >>= 1;
		if (ulSrc1Hi & 1)
		{
			ulSrc1Lo += HIBITSET;
		}
		ulSrc1Hi >>= 1;
		if (ulSrc1Hi < ulSrc2Hi)
		{
			/* 64 bit subtract */
			ulSrc2Hi -= ulSrc1Hi;
			ulSrc2Hi -= (uint32)(ulSrc1Lo > ulSrc2Lo);
			ulSrc2Lo -= ulSrc1Lo;

			ulResult += ulPlace;
		}
		else if (ulSrc1Hi == ulSrc2Hi && ulSrc1Lo <= ulSrc2Lo)
		{
			ulSrc2Hi = 0;
			ulSrc2Lo -= ulSrc1Lo;
			ulResult += ulPlace;
		}
		ulPlace >>= 1;
	}
	if (ulSrc2Lo >= (uint32)lSrc1)   /* Assert(lSrc1 >= 0)   */
	{
		ulResult += ulSrc2Lo/(uint32)lSrc1;
	}
	if (bNegative)
	{
		lResult = -((int32)ulResult);
	}
	else
	{
		lResult = (int32)ulResult;
	}
	return lResult;
}
#endif

/*******************************************************************/

/*
 *  a*b/c
 */
int32 LongMulDiv(int32 a, int32 b, int32 c)
{
	int32 temp[2];

	 CompMul(a, b, temp);
	return CompDiv(c, temp);
}

/*******************************************************************/

F26Dot6 ShortFracMul (F26Dot6 aDot6, ShortFract b)
{
	int32       lTemp[2];
	uint32      ulLow;
	F26Dot6     fxProduct;

	CompMul(aDot6, b, lTemp);

	ulLow = (((uint32)lTemp[1]) >> 13) + 1;           /* rounds up */
	fxProduct = (F26Dot6)(lTemp[0] << 18) + (F26Dot6)(ulLow >> 1);

	return (fxProduct);
}

/*******************************************************************/

ShortFract ShortFracDot (ShortFract a, ShortFract b)
{
	return (ShortFract)((((int32)a * (int32)b) + (1L << 13)) >> 14);
}


int32 ShortMulDiv(int32 a, int16 b, int16 c)
{
	return LongMulDiv(a, (int32)b, (int32)c);
}

int16 MulDivShorts (int16 a, int16 b, int16 c)
{
	return (int16)LongMulDiv((int32)a, (int32)b, (int32)c);
}

/*
 *  Total precision routine to multiply two 26.6 numbers        <3>
 */
F26Dot6 Mul26Dot6(F26Dot6 a, F26Dot6 b)
{
	 int32 negative = false;
	uint16 al, bl, ah, bh;
	uint32 lowlong, midlong, hilong;

	if ((a <= FASTMUL26LIMIT) && (b <= FASTMUL26LIMIT) && (a >= -FASTMUL26LIMIT) && (b >= -FASTMUL26LIMIT))
		  return (F26Dot6)((int32)(a * b + (1 << 5)) >> 6);                            /* fast case */

	if (a < 0) { a = -a; negative = true; }
	if (b < 0) { b = -b; negative ^= true; }

	 al = FS_LOWORD(a); ah = FS_HIWORD(a);
	 bl = FS_LOWORD(b); bh = FS_HIWORD(b);

	midlong = USHORTMUL(al, bh) + USHORTMUL(ah, bl);
	 hilong = USHORTMUL(ah, bh) + (uint32)FS_HIWORD(midlong);
	midlong <<= 16;
	midlong += 1 << 5;
	lowlong = USHORTMUL(al, bl) + midlong;
	hilong += (uint32)(lowlong < midlong);

	midlong = (lowlong >> 6) | (hilong << 26);
	if( negative)
	{
		return  (F26Dot6)-((int32)midlong);
	}
	else
	{
		return (F26Dot6)midlong;
	}
}

/*
 *  Total precision routine to divide two 26.6 numbers          <3>
 */
F26Dot6 Div26Dot6(F26Dot6 num, F26Dot6 den)
{
	 int32 negative = false;
	uint32 hinum, lownum, hiden, lowden, result, place;

	if (den == 0L)
	{
		if (num < 0L )
		{
				return (F26Dot6)NEGINFINITY;
		}
		else
		{
			return (F26Dot6)POSINFINITY;
		}
	}

	if ( (num <= FASTDIV26LIMIT) && (num >= -FASTDIV26LIMIT) )          /* fast case */
		  return (F26Dot6)(((int32)num << 6) / den);

	if (num < 0)
	{
		num = -num;
		negative = true;
	}
	if (den < 0)
	{
		den = -den;
		negative ^= true;
	}

	hinum = ((uint32)num >> 26);
	lownum = ((uint32)num << 6);
	hiden = (uint32)den;
	lowden = 0;
	result = 0;
	place = HIBITSET;

	if (hinum >= hiden)
	{
		if( negative )
		{
				return (F26Dot6)(uint32)NEGINFINITY;
		}
		else
		{
			return (F26Dot6)POSINFINITY;
		}
	}

	while (place)
	{
		lowden >>= 1;
		if (hiden & 1)
		{
			lowden += HIBITSET;
		}
		hiden >>= 1;
		if (hiden < hinum)
		{
			hinum -= hiden;
			hinum -= (uint32)(lowden > lownum);
			lownum -= lowden;
			result += place;
		}
		else if (hiden == hinum && lowden <= lownum)
		{
			hinum = 0;
			lownum -= lowden;
			result += place;
		}
		place >>= 1;
	}

	if (negative)
	{
		return (F26Dot6)-((int32)result);
	}
	else
	{
		return (F26Dot6)result;
	}
}

ShortFract ShortFracDiv(ShortFract num,ShortFract denum)
{
	return (ShortFract)(((int32)(num) << 14) / (int32)denum);
}

ShortFract ShortFracMulDiv(ShortFract numA,ShortFract numB,ShortFract denum)
{
	return (ShortFract) LongMulDiv ((int32) numA,(int32) numB, (int32)denum);
}

/* ------------------------------------------------------------ */

#ifndef FSCFG_USE_EXTERNAL_FIXMATH
/*  Here we define Fixed [16.16] and Fract [2.30] precision 
 *  multiplication and division functions and a Fract square root 
 *  function which are compatible with those in the Macintosh toolbox.
 *
 *  The division functions load the 32-bit numerator into the "middle"
 *  bits of a 64-bit numerator, then call the 64-bit by 32-bit CompDiv()
 *  function defined above, which can return a NEGINFINITY or POSINFINITY
 *  overflow return code.
 *
 *  The multiply functions call the 32-bit by 32-bit CompMul() function
 *  defined above which produces a 64-bit result, then they extract the
 *  "interesting" 32-bits from the middle of the 64-bit result and test 
 *  for overflow.
 *
 *  The GET32(a,i) macro defined below extracts a 32-bit value with "i" 
 *  bits of fractional precision from the 64-bit value in "a", a 2-element
 *  array of longs.
 *
 *  The CHKOVF(a,i,v) macro tests the most significant bits of the 
 *  64-bit value in "a", a 2-element array of longs, and tests the 
 *  32-bit result "v" for overflow.  "v" is defined as having "i" bits
 *  of fractional precision.
 *
 *  BIT() and OVFMASK() are "helper" macros used by GET32() and CHKOVF().
 *
 *  BIT(i) returns a mask with the "i"-th bit set.
 *  OVFMASK(i) returns a mask with the most-significant "32-i" bits set.
 */

#define BIT(i)          (1L<<(i))
#define OVFMASK(i)   ( ~0L ^ ( ((uint32)BIT(i)) - 1 ) )
#define CHKOVF(a,i,v)   (\
		( ((uint32)(a)[0] & OVFMASK(i))==0)          ? ( (v)>=0 ?(v) :POSINFINITY) : \
		( ((uint32)(a)[0] & OVFMASK(i))==OVFMASK(i)) ? ( (v)<=0 ?(v) :NEGINFINITY) : \
		( ((uint32)(a)[0] & BIT(31))                 ? POSINFINITY   :NEGINFINITY)   \
	)
#define GET32(a,i) \
((((a)[0]<<(32-(i))) | (int32)((uint32)((a)[1])>>(i))) + (int32)!!((a)[1] & BIT((i)-1)))

FS_MAC_PASCAL Fixed FS_PC_PASCAL FixMul (Fixed fxA, Fixed fxB)
{
	int32 alCompProd[2];
	Fixed fxProd;

	if  (fxA == 0 || fxB == 0)
		return 0;

	CompMul ((int32)fxA, (int32)fxB, alCompProd);
	fxProd = (Fixed)GET32 (alCompProd,16);
	return (Fixed)CHKOVF(alCompProd,16,fxProd);
}

FS_MAC_PASCAL Fixed FS_PC_PASCAL FixDiv (Fixed fxA, Fixed fxB)
{
	int32 alCompProd[2];
	
	alCompProd[0] = fxA >> 16;
	alCompProd[1] = fxA << 16;

	return CompDiv ((int32)fxB, alCompProd);
}

FS_MAC_PASCAL Fixed FS_PC_PASCAL FixRatio (int16 sA, int16 sB)
{
	int32 alCompProd[2];
	
	alCompProd[0] = ((int32)(sA)) >> 16;
	alCompProd[1] = ((int32)(sA)) << 16;

	return CompDiv ((int32)(sB), alCompProd);
}

FS_MAC_PASCAL Fract FS_PC_PASCAL FracMul (Fract frA, Fract frB)
{
	int32 alCompProd[2];
	Fract frProd;

	if  (frA == 0 || frB == 0)
		return 0;

	CompMul (frA,frB,alCompProd);
	frProd = (Fract)GET32 (alCompProd,30);
	return (Fract)CHKOVF(alCompProd,30,frProd);
}

FS_MAC_PASCAL Fract FS_PC_PASCAL FracDiv (Fract frA, Fract frB)
{
	int32 alCompProd[2];

	alCompProd[0] = frA >> 2;
	alCompProd[1] = frA << 30;
	return CompDiv ((int32)frB, alCompProd);
}

/*******************************************************************/

#ifndef FracSqrt

/* 
   Fract FracSqrt (Fract xf)
   Input:  xf           2.30 fixed point value
   Return: sqrt(xf)     2.30 fixed point value
*/

FS_MAC_PASCAL Fract FS_PC_PASCAL FracSqrt (Fract xf)
{
	Fract b = 0L;
	uint32 c, d, x = xf;
	
	if (xf < 0) return (NEGINFINITY);

	/*
	The algorithm extracts one bit at a time, starting from the
	left, and accumulates the square root in b.  The algorithm 
	takes advantage of the fact that non-negative input values
	range from zero to just under two, and corresponding output
	ranges from zero to just under sqrt(2).  Input is assigned
	to temporary value x (unsigned) so we can use the sign bit
	for more precision.
	*/
	
	if (x >= 0x40000000)
	{
		x -= 0x40000000; 
		b  = 0x40000000; 
	}

	/*
	This is the main loop.  If we had more precision, we could 
	do everything here, but the lines above perform the first
	iteration (to align the 2.30 radix properly in b, and to 
	preserve full precision in x without overflow), and afterward 
	we do two more iterations.
	*/
	
	for (c = 0x10000000; c; c >>= 1)
	{
		d = b + c;
		if (x >= d)
		{
			x -= d; 
			b += (c<<1); 
		}
		x <<= 1;
	}

	/*
	Iteration to get last significant bit.
	
	This code has been reduced beyond recognition, but basically,
	at this point c == 1L>>1 (phantom bit on right).  We would
	like to shift x and d left 1 bit when we enter this iteration,
	instead of at the end.  That way we could get phantom bit in
	d back into the word.  Unfortunately, that may cause overflow
	in x.  The solution is to break d into b+c, subtract b from x,
	then shift x left, then subtract c<<1 (1L).
	*/
	
	if (x > (uint32)b) /* if (x == b) then (x < d).  We want to test (x >= d). */
	{
		x -= b;
		x <<= 1;
		x -= 1L;
		b += 1L; /* b += (c<<1) */
	}
	else
	{
		x <<= 1;
	}

	/* 
	Final iteration is simple, since we don't have to maintain x.
	We just need to calculate the bit to the right of the least
	significant bit in b, and use the result to round our final answer.
	*/
	
	return ( b + (Fract)(x>(uint32)b) );
}

#endif  /* FracSqrt */

/*******************************************************************/

#endif


/* TRANSFORMATION ROUTINES */

/*
 *  Good for transforming fixed point values.  Assumes NO translate  <4>
 */
void mth_FixXYMul (Fixed*x, Fixed*y, transMatrix*matrix)
{
  Fixed xTemp, yTemp;
  Fixed *m0, *m1;

  m0 = (Fixed *) & matrix->transform[0][0];
  m1 = (Fixed *) & matrix->transform[1][0];

  xTemp = *x;
  yTemp = *y;
  *x = FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp);
  *y = FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp);

#ifndef PC_OS   /* Never a perspecitive with Windows */ /* !!!DISCUSS   */

  if (*m0 || *m1)     /* these two are Fracts */
  {
	Fixed tmp = FracMul (*m0, xTemp) + FracMul (*m1, yTemp);
	tmp += matrix->transform[2][2];
	if (tmp && tmp != ONEFIX)
	{
	  *x = FixDiv (*x, tmp);
	  *y = FixDiv (*y, tmp);
	}
  }
#endif
}


/*
 *  This could be faster        <4>
 */
void mth_FixVectorMul (vectorType*v, transMatrix*matrix)
{
  mth_FixXYMul (&v->x, &v->y, matrix);
}


/*
 *   B = A * B;     <4>
 *
 *         | a  b  0  |
 *    B =  | c  d  0  | * B;
 *         | 0  0  1  |
 */
void mth_MxConcat2x2 (transMatrix*A, transMatrix*B)
{
  Fixed storage[6];
  Fixed * s = storage;
  int32 i, j;

  for (j = 0; j < 2; j++)
	for (i = 0; i < 3; i++)
	  *s++ = FixMul (A->transform[j][0], B->transform[0][i]) + FixMul (A->transform[j][1], B->transform[1][i]);

  {
	Fixed*dst = &B->transform[2][0];
	Fixed*src = s;
	int16 i;
	for (i = 5; i >= 0; --i)
	  *--dst = *--src;
  }
}


/*
 * scales a matrix by sx and sy.
 *
 *
 *              | sx 0  0  |
 *    matrix =  | 0  sy 0  | * matrix;
 *              | 0  0  1  |
 *
 */
void mth_MxScaleAB (Fixed sx, Fixed sy, transMatrix *matrixB)
{
  int32       i;
  Fixed  *m = (Fixed *) & matrixB->transform[0][0];

  for (i = 0; i < 3; i++, m++)
	*m = FixMul (sx, *m);

  for (i = 0; i < 3; i++, m++)
	*m = FixMul (sy, *m);
}


/*
 *  Return 45 degreeness
 */
#ifndef PC_OS   /* !!!DISCUSS   */
boolean mth_Max45Trick (Fixed x, Fixed y)
{
  MAKEABS (x);
  MAKEABS (y);

  if (x < y)      /* make sure x > y */
  {
	Fixed z = x;
	x = y;
	y = z;
  }

  return  (x - y <= ALMOSTZERO);
}
#else
  #define mth_Max45Trick(x,y)     (x == y || x == -y)
#endif


/*
 *  Sets bPhaseShift to true if X or Y are at 45 degrees, flaging the outline
 *  to be moved in the low bit just before scan-conversion.
 *  Sets [xy]Stretch factors to be applied before hinting.
 *  Returns true if the contours need to be reversed.
 */
boolean mth_IsMatrixStretched (transMatrix*trans)
{
  Fixed*matrix = &trans->transform[0][0];
  Fixed x, y;
  int32 i;
  boolean   bPhaseShift;

  bPhaseShift = FALSE;

  for (i = 0; i < 2; i++, matrix++)
  {
	x = *matrix++;
	y = *matrix++;
	bPhaseShift |= mth_Max45Trick (x, y);
  }
  return( bPhaseShift );
}


/*
 * Returns true if we have the identity matrix.
 */

boolean mth_PositiveSquare (transMatrix *matrix)
{
	return (matrix->transform[0][0] == matrix->transform[1][1] && matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] >= 0);
}

boolean mth_Identity (transMatrix *matrix)
{
	return (matrix->transform[0][0] == matrix->transform[1][1] && matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[0][0] == ONEFIX);
}


boolean mth_PositiveRectangle (transMatrix *matrix)
{
	 return (matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[0][0] >= 0 && matrix->transform[1][1] >= 0);
}

/*
 * unitary Square
 *
 *              | +-1    0  0  |
 *    matrix =  |   0  +-1  0  |
 *              |   0    0  1  |
 */

boolean mth_UnitarySquare (transMatrix *matrix)
{
	return (matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && FXABS(matrix->transform[0][0]) == FXABS(matrix->transform[1][1]) && FXABS(matrix->transform[0][0]) == ONEFIX);
}

boolean mth_SameStretch (Fixed fxScaleX, Fixed fxScaleY)
{
	return(fxScaleX == fxScaleY);
}

boolean mth_GeneralRotation (transMatrix *matrix)
{
  return ((matrix->transform[0][0] || matrix->transform[1][1]) && (matrix->transform[1][0] || matrix->transform[0][1]));
}

/* for a rotation that is a multiple of 90 degrees, return the multiplier factor */
/* for non 90 degree rotations, return 4  (this is used for sbit rotations) */

uint16 mth_90degRotationFactor (transMatrix *matrix)
{
	if (matrix->transform[1][0] == 0 && matrix->transform[0][1] == 0)
    {
    	if (matrix->transform[0][0] > 0 && matrix->transform[1][1] > 0)
            return (0);
    	else if (matrix->transform[0][0] < 0 && matrix->transform[1][1] < 0)
            return (2);
    }
	else if (matrix->transform[0][0] == 0 && matrix->transform[1][1] == 0)
    {
        if (matrix->transform[1][0] < 0 && matrix->transform[0][1] > 0)
            return (1);
       	else if (matrix->transform[1][0] > 0 && matrix->transform[0][1] < 0)
            return (3);
	}
    return (4);                 /* non 90 degree rotation */
}

/* This is for Italic simulation.
/* return 0 if it's italic for 0 degree
/* return 1 if it's italic for 90 degree
/* return 2 if it's italic for 180 degree
/* return 3 if it's italic for 270 degree
/* return 4 if anything else */

uint16 mth_90degClosestRotationFactor (transMatrix *matrix)
{
    // 0 degree or vertical 270 degree
	if (matrix->transform[0][0] > 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] > 0 ||
        matrix->transform[0][0] > 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] > 0 ) 
        return (0); 
    // 90 degree or vertical 0 degree
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] > 0 ||
             matrix->transform[0][0] > 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] == 0 ) 
        return (1); 
    // 180 degree or vertical 90 degree
	else if (matrix->transform[0][0] < 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] < 0 ) 
        return (2); 
    // 270 degree or vertical 180 degree
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] ==  0 ) 
        return (3); 
    // anything else
    else
        return (4); 
}

void mth_Non90DegreeTransformation(transMatrix *matrix, boolean *non90degreeRotation, boolean *nonUniformStretching) {
	Fixed Xx,Xy,Yx,Yy;

	// first, we apply the matrix to the base vectors X = (1, 0) and Y = (0, 1)
	// this seemingly trivial step tends to be a hidden trap because there are two ways to apply a matrix to a vector, prefix and postfix.
	// in the rasterizer we seem to apply matrices as postfix operators, i.e.
	//
	//          (a00 a01)
	// (x, y) * (       ) = (a00*x + a10*y, a01*x + a11*y)
	//          (a10 a11)
	//
	//   apply to X = (1, 0)           apply to Y = (0, 1)
	Xx = matrix->transform[0][0]; Yx = matrix->transform[1][0];
	Xy = matrix->transform[0][1]; Yy = matrix->transform[1][1];

	// then we test whether the transformation shears the coordinates
	// if so, the transformed base vectors are no longer perpendicular, so we test their dot product against 0
	// notice that due to the limited precision of the fixed point representation , we may introduce a numerical error in general. 	
	// however, we're interested in identifying special cases like multiples of 90 rotations, for which one of the components
	// of the transformed vectors will be 0, hence the dot product should be accurate in these cases.
	if (FixMul(Xx,Yx) + FixMul(Xy,Yy) == 0) { // we're perpendicular

		// next we analyze whether the transformation rotates by a multiple of 90 or not
		// rotations which are multiples of 90 have 0s in either both non-diagonal matrix elements or both diagonal matrix elements
		// notice that this analysis includes mirrorings in x or y, which are handled in much the same way
		*non90degreeRotation = !(Xx == 0 && Yy == 0 || Xy == 0 && Yx == 0);

		// finally we analyze whether the transformation stretches the coordinates uniformly or not
		// for uniform stretchings the transformed base vectors have the same lengths
		// notice again that due to limited precision we may introduce a numerical error which we can ignore for the same reasons
		*nonUniformStretching = FixMul(Xx,Xx) + FixMul(Xy,Xy) != FixMul(Yx,Yx) + FixMul(Yy,Yy);
	
	} else { // we're sheared
		
		// here, we analyze whether the transformation rotates the x-axis by a multiple of 90 or not
		// we do not consider the y-axis because we don't want to exclude italicized fonts
		// for a multiple of 90 rotation, the transformed base vector X is either [anti-]parallel or perpendicular to its original
		// to be perpendicular, its x-component must be 0, hence a00 = 0; to be [anti-]parallel, its y-component must be 0, hence a01 = 0
		*non90degreeRotation = !(Xx == 0 || Xy == 0);

		// finally, we need to know whether the transformation stretches the coordinates at all
		// we know already that the stretching is not uniform, except in the unlikely case that the transformation rotates the y-axis
		// relative to the x-axis, which is a combination of stretching in y (actually, squeezing) by a particular amount, followed by
		// shearing, which stretches the y-axis again. For the correct combination of squeezing and shearing, this yields a uniform
		// stretching. For italicizing characters, this is an unlikely scenario, as italics tend to have the same [x-]height as their
		// roman ancestors. Italicizing is achieved by a shearing without separate stretching, which is a much more likely scenario.
		// For the reasons of their likelyhood, we consider shearing a uniform stretching, but not the rotation of the y-axis. Further-
		// more, for the purpose of identifying special cases, we do so only for rotations by multiples of 90, and only if the area
		// of the parallelogram defined by the two transformed base vectors remains 1, which is what happens under shearing. The area
		// of the parallelogram equals the determinant of the matrix. All other cases are considered proper non-uniform stretchings.
		
		*nonUniformStretching = *non90degreeRotation || FixMul(Xx,Xx) + FixMul(Xy,Xy) != ONEFIX || FixMul(Xx,Yy) - FixMul(Xy,Yx) != ONEFIX;
	}

} // mth_Non90DegreeTransformation

/*
 * mth_GetShift
 * return 2log of n if n is a power of 2 otherwise -1;
 */
int32 mth_GetShift( uint32 n )
{
		if (ISNOTPOWEROF2(n) || !n)
				return -1;
		else
				return mth_CountLowZeros( n );
}

int32 mth_CountLowZeros( uint32 n )
{
		  int32 shift = 0;
		  uint32    one = 1;
		for (shift = 0; !( n & one ); shift++)
				n >>= 1;
		return shift;
}

Fixed mth_max_abs (Fixed a, Fixed b)
{
  if (a < 0)
	a = -a;
  if (b < 0)
	b = -b;
  return (a > b ? a : b);
}

/*
 *  Call this guy before you use the matrix.  He does two things:
 *      He folds any perspective-translation back into perspective,
 *       and then changes the [2][2] element from a Fract to a fixed.
 */
void mth_ReduceMatrix(transMatrix *trans)
{
	Fixed a, *matrix = &trans->transform[0][0];
	Fract bottom = matrix[8];

/*
 *  First, fold translation into perspective, if any.
 */
	a = matrix[2];

	if (a != 0)
	{
		matrix[0] -= LongMulDiv(a, matrix[6], bottom);
		matrix[1] -= LongMulDiv(a, matrix[7], bottom);
	}

	a = matrix[5];

	if (a != 0)
	{
		matrix[3] -= LongMulDiv(a, matrix[6], bottom);
		matrix[4] -= LongMulDiv(a, matrix[7], bottom);
	}
	matrix[6] = matrix[7] = 0;
	matrix[8] = FRACT2FIX(bottom);      /* make this guy a fixed for XYMul routines */
}

void mth_IntelMul (
	int32           lNumPts,
	F26Dot6 *       fxX,
	F26Dot6 *       fxY,
	transMatrix *   trans,
	Fixed           fxXStretch,
	Fixed           fxYStretch)

{
	Fixed   fxM00;
	Fixed   fxM01;
	Fixed   fxM10;
	Fixed   fxM11;
	Fixed   fxOrigX;
	Fixed   fxOrigY;

	if (fxXStretch == 0L || fxYStretch == 0L)
	{
		for (--lNumPts; lNumPts >= 0; --lNumPts)
		{
			*fxY++ = 0;
			*fxX++ = 0;
		}
	}
	else
	{
		if(fxXStretch != ONEFIX)
		{
			fxM00 = FixDiv (trans->transform[0][0], fxXStretch);
			fxM01 = FixDiv (trans->transform[0][1], fxXStretch);
		}
		else
		{
			fxM00 = trans->transform[0][0];
			fxM01 = trans->transform[0][1];
		}

		if(fxYStretch != ONEFIX)
		{
			fxM10 = FixDiv (trans->transform[1][0], fxYStretch);
			fxM11 = FixDiv (trans->transform[1][1], fxYStretch);
		}
		else
		{
			fxM10 = trans->transform[1][0];
			fxM11 = trans->transform[1][1];
		}

		for (--lNumPts; lNumPts >= 0; --lNumPts)
		{
			fxOrigX = *fxX;
			fxOrigY = *fxY;

			*fxX++ = (F26Dot6) (FixMul (fxM00, fxOrigX) + FixMul (fxM10, fxOrigY));
			*fxY++ = (F26Dot6) (FixMul (fxM01, fxOrigX) + FixMul (fxM11, fxOrigY));
		}
	}
}


/*
 *  Fold the point size and resolution into the matrix
 */

void    mth_FoldPointSizeResolution(
	Fixed           fxPointSize,
	int16           sXResolution,
	int16           sYResolution,
	transMatrix *   trans)
{
	Fixed fxScale;

	fxScale = ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH);
	trans->transform[0][1] = FixMul( trans->transform[0][1], fxScale );
	trans->transform[1][1] = FixMul( trans->transform[1][1], fxScale );
	trans->transform[2][1] = FixMul( trans->transform[2][1], fxScale );

	fxScale = ShortMulDiv(fxPointSize, sXResolution, POINTSPERINCH);
	trans->transform[0][0] = FixMul( trans->transform[0][0], fxScale );
	trans->transform[1][0] = FixMul( trans->transform[1][0], fxScale );
	trans->transform[2][0] = FixMul( trans->transform[2][0], fxScale );
}


/*********************************************************************/

/*  Find the power of 2 greater than the absolute value of passed parameter  */

int32 PowerOf2(
		int32 lValue )
{
	static const int32 iTable[] = { 0, 1, 2, 2, 3, 3, 3, 3,
								  4, 4, 4, 4, 4, 4, 4, 4  };

	if (lValue < 0L)
	{
		lValue = -lValue;
	}

	if (lValue < (1L << 16))
	{
		if (lValue < (1L << 8))
		{
			if (lValue < (1L << 4))
			{
				return (iTable[lValue]);
			}
			else
			{
				return (iTable[lValue >> 4] + 4);
			}
		}
		else
		{
			if (lValue < (1L << 12))
			{
				return (iTable[lValue >> 8] + 8);
			}
			else
			{
				return (iTable[lValue >> 12] + 12);
			}
		}
	}
	else
	{
		if (lValue < (1L << 24))
		{
			if (lValue < (1L << 20))
			{
				return (iTable[lValue >> 16] + 16);
			}
			else
			{
				return (iTable[lValue >> 20] + 20);
			}
		}
		else
		{
			if (lValue < (1L << 28))
			{
				return (iTable[lValue >> 24] + 24);
			}
			else
			{
				return (iTable[lValue >> 28] + 28);
			}
		}
	}
}

/********************************************************************/

/* divide by shifting for translation invariant negatives */

FS_PUBLIC int16 mth_DivShiftShort(int16 sValue, int16 sFactor)
{
	return (int16)mth_DivShiftLong((int32)sValue, sFactor);
}

FS_PUBLIC int32 mth_DivShiftLong(int32 lValue, int16 sFactor)
{
	switch (sFactor)
	{
	case 0:
	case 1:
		break;
	case 2:
		lValue >>= 1;
		break;
	case 4:
		lValue >>= 2;
		break;
	case 8:
		lValue >>= 3;
		break;
	default:
		if (lValue >= 0)
		{
			lValue /= (int32)sFactor;
		}
		else
		{
			lValue = ((lValue - (int32)sFactor + 1) / (int32)sFactor);
		}
		break;
	}
	return lValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\fnt.h ===
/*
	File:       fnt.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		  <>     4/30/97    CB      ClaudeBe, catching infinite loops/recursions
	      <>     2/21/97    CB      ClaudeBe, scaled component in composite glyphs
	      <>     2/05/96    CB      ClaudeBe, add bHintForGray in globalGS
	   <11+>     9/15/90    MR,rb   Change pvx and pvy to proj.[xy].  Same for freedom vector.
									Conditionalize vectors for Fracts or ShortFracts.
		<10>     7/26/90    MR      rearrange local graphic state, remove unused parBlockPtr
		 <9>     7/18/90    MR      change loop variable from long to short, and other Ansi-changes
		 <8>     7/13/90    MR      Prototypes for function pointers
		 <5>      6/4/90    MR      Remove MVT
		 <4>      5/3/90    RB      replaced dropoutcontrol with scancontrolin and scancontrol out
									in global graphics state
		 <3>     3/20/90    CL      fields for multiple preprograms fields for ppemDot6 and
									pointSizeDot6 changed SROUND to take D/2 as argument
		 <2>     2/27/90    CL      Added DSPVTL[] instruction.  Dropoutcontrol scanconverter and
									SCANCTRL[] instruction
	   <3.1>    11/14/89    CEL     Fixed two small bugs/feature in RTHG, and RUTG. Added SROUND &
									S45ROUND.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.7>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.6>     6/13/89    SJK     Comment
	   <1.5>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.4>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.3>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts

	To Do:
*/
/*  rwb 4/24/90 Replaced dropoutControl with scanControlIn and scanControlOut in
		global graphics state. 
		<3+>     3/20/90    mrr     Added support for IDEFs.  Made funcDefs long aligned
									by storing int16 length instead of int32 end.
*/

#ifndef FNT_DEFINED
#define FNT_DEFINED

#define STUBCONTROL 0x10000
#define NODOCONTROL 0x20000

#define FNT_PIXELSIZE  ((F26Dot6)0x40)
#define FNT_PIXELSHIFT 6

// public phantom points (cf. scale.c for private phantom points), relative to number of points in glyph
#define LEFTSIDEBEARING		0
#define RIGHTSIDEBEARING	1

#define TOPSIDEBEARING		2
#define BOTTOMSIDEBEARING	3

#define VECTORTYPE	ShortFract

#define NON90DEGTRANS_ROTATED	0x01
#define NON90DEGTRANS_STRETCH	0x02

#ifdef FSCFG_SUBPIXEL
/* For the SubPixel hinting flag field, internal flags */
#define FNT_SP_SUB_PIXEL			0x0001      /* set when calling fs_NewTransformation() */
#define FNT_SP_COMPATIBLE_WIDTH		0x0002      /* set when calling fs_NewTransformation() */
#define FNT_SP_VERTICAL_DIRECTION	0x0004		// set when calling fs_NewTransformation()
#define FNT_SP_BGR_ORDER			0x0008		// set when calling fs_NewTransformation()

#define SPCF_iupxCalled				0x0001		// individual bits of GlobalGS.subPixelCompatibilityFlags
#define SPCF_iupyCalled				0x0002
#define SPCF_inDiagEndCtrl			0x0004
#define SPCF_inVacuformRound		0x0008
#define SPCF_inTomsDiagonal			0x0010
#define SPCF_detectedDiagEndCtrl	0x0100
#define SPCF_detectedDandIStroke	0x0200
#define SPCF_detectedJellesSpacing	0x0400
#define SPCF_detectedVacuformRound	0x0800
#define SPCF_detectedTomsDiagonal	0x1000


#endif // FSCFG_SUBPIXEL

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA

	#define BADREL	0x01
	#define DONE	0x02
	#define DOING	0x04

	// Data structure for information leap. This information leap is necessary because of the following reason:
	// Technically, what we're doing is to automatically add on-the-fly in-line deltas to the stream of instructions. Such deltas appear
	// after an incoming "link" (MIRP, MDRP), but before one or more outgoing "links". If one of these outgoing links controls a stroke,
	// then this stroke's phase may need to be adjusted (by a delta). However, we don't know whether any of the outgoing links controls a
	// stroke, nor which one, until we've interpreted them all, at which point it is too late to apply a delta, because the delta has to be
	// applied before any outgoing links (dependency). Conversely, the incoming link does not bear any information that would suggest that
	// it links to a stroke (don't know the future). To make matters worse, it is possible that in the stream of instructions the link that
	// controls a stroke comes at the very end of the TT code, even though there may have been many other, unrelated instructions inbetween.
	// Therefore, we have to interpert the entire TT code (upto the IUP instruction in the SP direction) before we know all we need to 
	// calculate and apply the phase control.
	
	typedef struct {
		int16 parent0,parent1; // -1 for none
		int16 child; // for black links (we can satisfy 1 phase shift only, hence no need for several children), else -1
		uint16 flags; // BADREL, DONE, DOING
		F26Dot6 phaseShift;
	} PhaseControlRelation; // 12 bytes (?)
	
#endif

typedef struct VECTOR {
	VECTORTYPE x;
	VECTORTYPE y;
} VECTOR;

typedef struct {
	F26Dot6 *x;         /* The Points the Interpreter modifies */
	F26Dot6 *y;         /* The Points the Interpreter modifies */
	F26Dot6 *ox;        /* Old Points */
	F26Dot6 *oy;        /* Old Points */
	F26Dot6 *oox;       /* Old Unscaled Points, really ints */
	F26Dot6 *ooy;       /* Old Unscaled Points, really ints */
	uint8   *onCurve;   /* indicates if a point is on or off the curve */
	int16   *sp;        /* Start points */
	int16   *ep;        /* End points */
	uint8   *f;         /* Internal flags, one byte for every point */
	int16   nc;         /* Number of contours */
	uint8   *fc;         /* contour flags, one byte for every contour */
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	boolean phaseControlExecuted;
	PhaseControlRelation *pcr;
#endif
} fnt_ElementType;

/* flags for contour flags : */
#define OUTLINE_MISORIENTED 1

typedef struct {
	int32 start;        /* offset to first instruction */
	uint16 length;      /* number of bytes to execute <4> */
	uint16 pgmIndex;    /* index to appropriate preprogram for this func (0..1) */
} fnt_funcDef;

/* <4> pretty much the same as fnt_funcDef, with the addition of opCode */
typedef struct {
	int32 start;
	uint16 length;
	uint8  pgmIndex;
	uint8  opCode;
} fnt_instrDef;

typedef struct {
	uint8 *    Instruction;
	uint32     Length;
} fnt_pgmList;

struct fnt_LocalGraphicStateType;
typedef void (FS_CALLBACK_PROTO *FntTraceFunc)(struct fnt_LocalGraphicStateType*, uint8*);

#ifdef FSCFG_REENTRANT
typedef uint8* (*FntFunc)(struct fnt_LocalGraphicStateType*, uint8*, int32);
typedef void (*FntMoveFunc)(struct fnt_LocalGraphicStateType*, fnt_ElementType*, int32, F26Dot6);
typedef F26Dot6 (*FntProject)(struct fnt_LocalGraphicStateType*, F26Dot6, F26Dot6);
typedef void (*InterpreterFunc)(struct fnt_LocalGraphicStateType*, uint8*, uint8*);
typedef F26Dot6 (*FntRoundFunc)(struct fnt_LocalGraphicStateType*, F26Dot6, F26Dot6);
#else 
typedef uint8* (*FntFunc)(uint8*, int32);
typedef void (*FntMoveFunc)(fnt_ElementType*, int32, F26Dot6);
typedef F26Dot6 (*FntProject)(F26Dot6 x, F26Dot6 y);
typedef void (*InterpreterFunc)(uint8*, uint8*);
typedef F26Dot6 (*FntRoundFunc)(F26Dot6 xin, F26Dot6 engine);
#endif 

typedef struct {

/* PARAMETERS CHANGEABLE BY TT INSTRUCTIONS */
	F26Dot6 wTCI;                   /* width table cut in */
	F26Dot6 sWCI;                   /* single width cut in */
	F26Dot6 scaledSW;               /* scaled single width */
	int32 scanControl;              /* controls kind and when of dropout control */
	int32 instructControl;          /* controls gridfitting and default setting */
	
	F26Dot6 minimumDistance;        /* moved from local gs  7/1/90  */
	FntRoundFunc RoundValue;        /*                              */
#ifdef FSCFG_SUBPIXEL
	uint16		roundState;			// see comments in interp.c
#endif
	F26Dot6 periodMask;             /* ~(gs->period-1)              */
	VECTORTYPE period45;            /*                              */
	int16   period;                 /* for power of 2 periods       */
	int16   phase;                  /*                              */
	int16   threshold;              /* moved from local gs  7/1/90  */

	int16 deltaBase;
	int16 deltaShift;
	int16 angleWeight;
	int16 sW;                       /* single width, expressed in the same units as the character */
	int8 autoFlip;                  /* The auto flip Boolean */
	int8 pad;   
#ifndef FSCFG_NOPAD_PARAMETER_BLOCK_4
	int16 pad2;   
#endif 
} fnt_ParameterBlock;               /* this is exported to client */

#define PREPROGRAM     0
#define FONTPROGRAM    1
#define GLYPHPROGRAM   2

#define MAXPREPROGRAMS 2

typedef struct fnt_ScaleRecord {
	Fixed fixedScale;       /* Slow Scale */
	int32 denom;            /* Fast and Medium Scale */
	int32 numer;            /* Fast and Medium Scale */
	int32 shift;            /* Fast Scale */
} fnt_ScaleRecord;

typedef F26Dot6 (*GlobalGSScaleFunc)(fnt_ScaleRecord*, F26Dot6);

typedef struct fnt_GlobalGraphicStateType {
	F26Dot6* stackBase;             /* the stack area */
	F26Dot6* store;                 /* the storage area */
	F26Dot6* controlValueTable;     /* the control value table */
	
	uint16  pixelsPerEm;            /* number of pixels per em as an integer */
	uint16  pointSize;              /* the requested point size as an integer */
	Fixed   fpem;                   /* fractional pixels per em    <3> */
	F26Dot6 engine[4];              /* Engine Characteristics */
	
	fnt_ParameterBlock defaultParBlock; /* variables settable by TT instructions */
	fnt_ParameterBlock localParBlock;

	/* Only the above is exported to Client throught FontScaler.h */

/* VARIABLES NOT DIRECTLY MANIPULABLE BY TT INSTRUCTIONS  */
	
	fnt_funcDef*    funcDef;           /* function Definitions identifiers */
	fnt_instrDef*   instrDef;         /* instruction Definitions identifiers */
	GlobalGSScaleFunc ScaleFuncXChild; /* child scaling when !bSameTransformAsMaster */
	GlobalGSScaleFunc ScaleFuncYChild; /* child scaling when !bSameTransformAsMaster */
	GlobalGSScaleFunc ScaleFuncX;
	GlobalGSScaleFunc ScaleFuncY;
	GlobalGSScaleFunc ScaleFuncCVT;
	fnt_pgmList     pgmList[MAXPREPROGRAMS];  /* each program ptr is in here */
	
/* These are parameters used by the call back function */
	fnt_ScaleRecord   scaleXChild; /* child scaling when !bSameTransformAsMaster */
	fnt_ScaleRecord   scaleYChild; /* child scaling when !bSameTransformAsMaster */
	fnt_ScaleRecord   scaleX;
	fnt_ScaleRecord   scaleY;
	fnt_ScaleRecord   scaleCVT;

	Fixed           cvtStretchX;
	Fixed           cvtStretchY;

	int8            identityTransformation;  /* true/false  (does not mean identity from a global sense) */
	int8            non90DegreeTransformation; /* bit 0 is 1 if non-90 degree, bit 1 is 1 if x scale doesn't equal y scale */
	Fixed           xStretch;           /* Tweaking for glyphs under transformational stress <4> */
	Fixed           yStretch;           /* Tweaking for glyphs under transformational stress <4> */
	
	int8            init;               /* executing preprogram ?? */
	/* !!! Should not be uint8, instead fnt_ProgramIndex */
	uint8           pgmIndex;           /* which preprogram is current */
	int32           instrDefCount;      /* number of currently defined IDefs */
	uint8			bSameStretch;
	uint8			bCompositeGlyph;	/* Flag that indicates composite glyph */
	LocalMaxProfile *	 maxp;
	uint16          cvtCount;
	Fixed           interpScalarX;      /* scalar for instructable things */
	Fixed           interpScalarY;      /* scalar for instructable things */
	Fixed           fxMetricScalarX;    /* scalar for metric things */
	Fixed           fxMetricScalarY;    /* scalar for metric things */
	/* int16  pad2; */

	boolean	bHintForGray;
	uint8			bSameTransformAsMaster;	/* for composite glyph, indicate the the sub-componenent has the same scaling than the master glyph */
	uint8			bOriginalPointIsInvalid;/* original point are invalid, we need to use ox/oy instead of scaling oox/ooy */

	uint32		ulMaxJumpCounter;			/* jump counter used to catch infinite loops */
	uint32		ulMaxRecursiveCall;		/* recursive calls counter used to check the level of recursion */
    ClientIDType            clientID;  /* client private id/stamp, it's saved here to allow a trace function to access it */
#ifdef FSCFG_SECURE
	F26Dot6* stackMax;             /* maximum stack area */
	int32      maxPointsIncludePhantom;  /* in an individual glyph, including maxCompositePoints  */
#endif // FSCFG_SECURE
	uint16	uBoldSimulVertShift; /* vertical and horizontal (along baseline) shift for embolding simulation */
	uint16	uBoldSimulHorShift;
	F26Dot6	fxScaledDescender; /* scaled descender, used to clip emboldening if necessary */
#ifdef FSCFG_SUBPIXEL
	uint16	flHintForSubPixel;
	uint16	subPixelCompatibilityFlags;
	Fixed	compatibleWidthStemConcertina;
#endif // FSCFG_SUBPIXEL
	boolean bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
									   or text animation where we want to turn off gridfitting hinting
									   but for fonts where glyphs are build by hinting, we still want the
									   glyph shape to be correct */
} fnt_GlobalGraphicStateType;

/* 
 * This is the local graphics state  
 */
typedef struct fnt_LocalGraphicStateType {
	fnt_ElementType *CE0, *CE1, *CE2;   /* The character element pointers */
	VECTOR proj;                        /* Projection Vector */
	VECTOR free;                        /* Freedom Vector */
	VECTOR oldProj;                     /* Old Projection Vector */
	F26Dot6 *stackPointer;

	uint8 *insPtr;                      /* Pointer to the instruction we are about to execute */
	fnt_ElementType *elements;
	fnt_GlobalGraphicStateType *globalGS;
		FntTraceFunc TraceFunc;

	int32 Pt0, Pt1, Pt2;           /* The internal reference points */
	int16 roundToGrid;
	int32 loop;                         /* The loop variable */
	uint8 opCode;                       /* The instruction we are executing */
	uint8 padByte;
	int16 padWord;

	/* Above is exported to client in FontScaler.h */

	VECTORTYPE pfProj; /* = pvx * fvx + pvy * fvy */

	FntMoveFunc MovePoint;
	FntProject Project;
	FntProject OldProject;
	InterpreterFunc Interpreter;
#ifdef FSCFG_REENTRANT
		F26Dot6 (*GetCVTEntry) (struct fnt_LocalGraphicStateType*,int32);
		F26Dot6 (*GetSingleWidth) (struct fnt_LocalGraphicStateType*);
#else 
		F26Dot6 (*GetCVTEntry) (int32 n);
		F26Dot6 (*GetSingleWidth) (void);
#endif 
	FntMoveFunc ChangeCvt;
	Fixed       cvtDiagonalStretch;

	int16       MIRPCode;               /* for fast or slow MIRP's */

	ErrorCode   ercReturn;              /* NO_ERR unless illegal instruction */
	uint8       *pbyEndInst;            /* one past last instruction */
	uint8       *pbyStartInst;          /* used to detect a jump before the begining of the program */

	uint32		ulJumpCounter;			/* jump counter used to catch infinite loops */
	uint32		ulRecursiveCall;		/* recursive calls counter used to check the level of recursion */
#ifdef FSCFG_SUBPIXEL
	uint16		inSubPixelDirection;
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	int16		pt0,pt1;
#endif
#endif
} fnt_LocalGraphicStateType;

#endif  /* FNT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\fscaler.h ===
#ifdef __cplusplus
extern "C" {
#endif

/*
	File:       fscaler.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		  <>    10/14/97    CB      move usOverScale to fs_NewTransformation
		<9+>     7/17/90    MR      Conditionalize names in FSInput
		 <9>     7/14/90    MR      rename SQRT2 to FIXEDSQRT2, removed specificID and lowestRecPPEM
									from FSInfo
		 <8>     7/13/90    MR      FSInput now has a union to save space, points to matrix instead
									of storing it
		 <6>     6/21/90    MR      Change fillFunc to ReleaseSfntFrag
		 <5>      6/5/90    MR      remove readmvt and mapcharcodes
		 <4>      5/3/90    RB      Added memory area for new scan converter. MIKE REED - Removed
									.error from fsinfo structure. Added MapCharCodes and ReadMVT
									calls.
		 <3>     3/20/90    CL      New comment style for BBS. 
		 <2>     2/27/90    CL      New CharToIndexMap Table format.
	   <3.5>    11/15/89    CEL     Placed an ifdef around inline MPW calls to the trap. This makes
									it easier to compile for skia and the likes who do not use the
									MPW compiler.
	   <3.4>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Instructions are legal in components. Five
									unnecessary element in the output data structure have been
									deleted. (All the information is passed out in the bitmap data
									structure) fs_FindBMSize now also returns the bounding box.
	   <3.3>     9/27/89    CEL     Took out devAdvanceWidth & devLeftSideBearing.
	   <3.2>     9/25/89    CEL     Took out Mac specific functions.
	   <3.1>     9/15/89    CEL     Re-working dispatcher.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/

#include    "fscdefs.h"
#include    "fnt.h"

/* QuickDraw Types */

#ifndef _Quickdraw_
#ifndef __QUICKDRAW__   
	typedef struct BitMap {
		char* baseAddr;
		int16 rowBytes;
		Rect bounds;
	} BitMap;
#endif
#endif

#define MEMORYFRAGMENTS 9           /* extra memory base for overscaled bitmap */

#define NONVALID        0xffff

/* For the flags field in the flags field */

/* set on 68020, do not set on 68000 */
#define READ_NONALIGNED_SHORT_IS_OK 0x0001          /* set when calling fs_OpenFonts() */
/* set on 68020, do not set on 68000 */
#define READ_NONALIGNED_LONG_IS_OK  0x0002          /* set when calling fs_OpenFonts() */

#ifdef FSCFG_SUBPIXEL
/* For the SubPixel flag field */
#define SP_SUB_PIXEL			0x0001          /* set when calling fs_NewTransformation() */
#define SP_COMPATIBLE_WIDTH		0x0002          /* set when calling fs_NewTransformation() */
#define SP_VERTICAL_DIRECTION	0x0004          /* set when calling fs_NewTransformation() */
#define SP_BGR_ORDER			0x0008          /* set when calling fs_NewTransformation() */
#endif // FSCFG_SUBPIXEL

typedef struct {
	vectorType      advanceWidth, leftSideBearing;
	vectorType      leftSideBearingLine, devLeftSideBearingLine;/* along AW line */
	vectorType      devAdvanceWidth, devLeftSideBearing;
} metricsType;

typedef struct {
	vectorType      advanceHeight, topSideBearing;
	vectorType      topSideBearingLine, devTopSideBearingLine;/* along AH line */
	vectorType      devAdvanceHeight, devTopSideBearing;
} verticalMetricsType;

#define FS_MEMORY_SIZE  int32

/*
 * Output data structure to the Font Scaler.
 */
typedef struct {
	FS_MEMORY_SIZE  memorySizes[MEMORYFRAGMENTS];

	uint16          glyphIndex;
	uint16          numberOfBytesTaken; /* from the character code */

	metricsType     metricInfo;
	BitMap          bitMapInfo;

	/* Spline Data */
	int32           outlineCacheSize;
	uint16          outlinesExist;
	uint16          numberOfContours;
	F26Dot6         *xPtr, *yPtr;
	int16           *startPtr;
	int16           *endPtr;
	uint8           *onCurve;
	/* End of spline data */

	/* Only of interest to editors */
	F26Dot6         *scaledCVT;

	/* embedded bitmap return values */
	uint16          usBitmapFound;

	/* vertical metrics */
	verticalMetricsType     verticalMetricInfo;

	/* resulting number of gray levels, 0 means black/white, 1 bit per pixel,
	   (grayscale bitmap are 1 byte per pixel)
	   the number of level you receive is not necessarily what you ask for.
	   If there is no embedded gray bitmap :
			usOverscale 2 -> usGrayLevels 5,
			usOverscale 4 -> usGrayLevels 17,
			usOverscale 8 -> usGrayLevels 65,
	   If an embedded gray bitmap is present in the font, the embedded bitmap
	   will be selected before a gray bitmap generated with an higher overscale.
	   If you are unhappy with the number of gray levels (usGrayLevels) you can force
	   the embedded bitmap off by setting bNoEmbeddedBitmap to TRUE  */
	uint16          usGrayLevels;            
#ifdef FSCFG_SUBPIXEL_STANDALONE // B.St.
	BitMap			overscaledBitmapInfo;
#endif
	uint8			*fc;         /* contour flags, one byte for every contour */
} fs_GlyphInfoType;

/*
 * Input data structure to the Font Scaler.
 *
 * styleFunc is not supported in this version of the Font Scalar. Should be set to NULL.
 *
 */

#ifndef UNNAMED_UNION

typedef struct {
	Fixed                   version;
	char*                   memoryBases[MEMORYFRAGMENTS];
	int32                   *sfntDirectory; 
	GetSFNTFunc             GetSfntFragmentPtr; /* (clientID, offset, length) */
	ReleaseSFNTFunc         ReleaseSfntFrag;
	ClientIDType            clientID; /* client private id/stamp (eg. handle for the sfnt) */

	union {
		struct {
			uint16          platformID;
			uint16          specificID;
		} newsfnt;
		struct {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			Fixed           pixelDiameter;      /* compute engine char from this */
			transMatrix*    transformMatrix;
			FntTraceFunc    traceFunc;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		} newtrans;
		struct {
			uint16          characterCode;
			uint16          glyphIndex;
			boolean         bMatchBBox;             /* force bounding box match */
			boolean         bNoEmbeddedBitmap;      /* disable the embedded bitmap */			
		} newglyph;
		struct {
			void            (*styleFunc) (fs_GlyphInfoType*);
			FntTraceFunc    traceFunc;
			boolean         bSkipIfBitmap;
		} gridfit;
		int32*  outlineCache;
		struct {                                    /* for fs_FindBandingSize */
			uint16          usBandType;             /* old, small or fast */
			uint16          usBandWidth;            /* number of scanlines */
			int32*          outlineCache;           /* cacheing works with banding */
		} band;
		struct {
			int16           bottomClip;
			int16           topClip;
			int32*          outlineCache;
		} scan;
	} param;
} fs_GlyphInputType;

#else

typedef struct {
	Fixed                   version;
	char*                   memoryBases[MEMORYFRAGMENTS];
	int32                   *sfntDirectory; 
	GetSFNTFunc             GetSfntFragmentPtr; /* (clientID, offset, length) */
	ReleaseSFNTFunc         ReleaseSfntFrag;
	ClientIDType            clientID; /* client private id/stamp (eg. handle for the sfnt) */

	union {
		struct {
			uint16          platformID;
			uint16          specificID;
		};
		struct {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			Fixed           pixelDiameter;      /* compute engine char from this */
			transMatrix*    transformMatrix;
			FntTraceFunc    tracePreProgramFunc;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		};
		struct {
			uint16          characterCode;
			uint16          glyphIndex;
			boolean         bMatchBBox;             /* force bounding box match */
			boolean         bNoEmbeddedBitmap;      /* disable the embedded bitmap */			
		};
		struct {
			void            (*styleFunc) (fs_GlyphInfoType*);
			FntTraceFunc    traceGridFitFunc;
			boolean         bSkipIfBitmap;
		};
		int32*              outlineCache1;
		struct {                                    /* for fs_FindBandingSize */
			uint16          usBandType;             /* old, small or fast */
			uint16          usBandWidth;            /* number of scanlines */
			int32*          outlineCache3;          /* cacheing works with banding */
		};
		struct {
			int16           bottomClip;
			int16           topClip;
			int32*          outlineCache2;
		};
	};
} fs_GlyphInputType;

#endif      /* unnamed union */

#ifndef FIXEDSQRT2
#define FIXEDSQRT2 0x00016A0A
#endif

/* Font scaler trap selctors */
#define OUTLINEFONTTRAP     0xA854
#define FS_OPENFONTS        0x8000
#define FS_INITIALIZE       0x8001
#define FS_NEWSFNT          0x8002
#define FS_NEWTRANS         0x8003
#define FS_NEWGLYPH         0x8004
#define FS_GETAW            0x8005
#define FS_GRIDFITT         0x8006
#define FS_NOGRIDFITT       0x8007
#define FS_FINDBMSIZE       0x8008
#define FS_SIZEOFOUTLINES   0x8009
#define FS_SAVEOUTLINES     0x800a
#define FS_RESTOREOUTLINES  0x800b
#define FS_CONTOURSCAN      0x800c
#define FS_CLOSE            0x800d
#define FS_READMVT          0x800e
#define FS_MAPCHAR_CODES    0x800f

#ifndef FS_ENTRY
#define FS_ENTRY int32
#endif

#ifdef MACINIT
extern FS_ENTRY fs__OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_OPENFONTS,0xA854};
extern FS_ENTRY fs__Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_INITIALIZE,0xA854};
extern FS_ENTRY fs__NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWSFNT,0xA854};
extern FS_ENTRY fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWTRANS,0xA854};
extern FS_ENTRY fs__NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWGLYPH,0xA854};
extern FS_ENTRY fs__GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_GETAW,0xA854};
extern FS_ENTRY fs__ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_GRIDFITT,0xA854};
extern FS_ENTRY fs__ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NOGRIDFITT,0xA854};
extern FS_ENTRY fs__FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_FINDBMSIZE,0xA854};
extern FS_ENTRY fs__FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_FINDBMSIZE,0xA854};

/* these three optional calls are for caching the outlines */
extern FS_ENTRY fs__SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_SIZEOFOUTLINES,0xA854};
extern FS_ENTRY fs__SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_SAVEOUTLINES,0xA854};
extern FS_ENTRY fs__RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_RESTOREOUTLINES,0xA854};

extern FS_ENTRY fs__ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_CONTOURSCAN,0xA854};
extern FS_ENTRY fs__CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_CLOSE,0xA854};

#else

/*** Direct Calls to Font Scaler Client Interface, for Clients not using the trap mechanism ***/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

/* these three optional calls are for caching the outlines */
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

#endif

#ifdef FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC void FS_ENTRY_PROTO fs_InitializeData (void);
#endif

/*** Rasterizer Helper Functions ***/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceWidths (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	int16 *             psGlyphWidths);

typedef struct {
	int16 x;
	int16 y;
} shortVector;

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceHeights (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	shortVector *       psvAdvanceHeights);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Win95GetGlyphIDs (
	uint8 *             pbyCmapSubTable,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID);


/* special helper function fs_WinNTGetGlyphIDs
   - an offset ulCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_WinNTGetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint32	            ulCharCodeOffset,
	uint32 *	        pulCharCode,
	uint32 *	        pulGlyphID);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetOutlineCoordinates (
	fs_GlyphInputType * inputPtr,
	uint16              usPointCount,
	uint16 *            pusPointIndex,
	shortVector *       psvCoordinates);

/*** Gray scale definitions ***/

#ifndef FSCFG_DISABLE_GRAYSCALE

#define FS_GRAY_VALUE_MASK  0x008B      /* support usOverScale of 1, 2, 4, & 8 */
#define FS_SBIT_BITDEPTH_MASK	0x0116	 /* support sbit with bitDepth of 1, 2, 4 and 8 */
/* FS_SBIT_BITDEPTH_MASK must have the same value as SBIT_BITDEPTH_MASK in sfntaccs.h */ 

#else

#define FS_GRAY_VALUE_MASK  0x0000      /* no grayscale support */
#define FS_SBIT_BITDEPTH_MASK	0x0002	 /* support only sbit with bitDepth of 1 */
/* FS_SBIT_BITDEPTH_MASK must have the same value as SBIT_BITDEPTH_MASK in sfntaccs.h */ 

#endif
/* the value of FS_GRAY_VALUE_MASK and FS_SBIT_BITDEPTH_MASK can be used to determine
   the usGrayLevels the client need to support.

   Fonts without embedded bitmap :
		usGrayLevels = usOverScale * usOverScale + 1;

   Fonts with embedded bitmap (sbit) :
		usGrayLevels = 0x01 << usBitDepth;

  The usGrayLevels the client may receive with the current version are :

  0 for black/white
  5, 17, 65 fonts without embedded bitmap
  4, 16, 256 fonts with embedded bitmap

*/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceHeight (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

#ifdef FSCFG_MOVE_KEY_IN_DOT_H
/* the definition of the key in fscaler.h and fscaler.c must be identical */

/*** The Internal Key ***/
typedef struct fs_SplineKey {
	sfac_ClientRec      ClientInfo;         /* Client Information */
	char* const *       memoryBases;        /* array of memory Areas */
	char *              apbPrevMemoryBases[MEMORYFRAGMENTS];

	uint16              usScanType;         /* flags for dropout control etc.*/

	fsg_TransformRec    TransformInfo;

	uint16              usNonScaledAW;
	uint16              usNonScaledAH;

	LocalMaxProfile     maxProfile;         /* copy of profile */

	uint32              ulState;            /* for error checking purposes */
	
	boolean             bExecutePrePgm;
	boolean             bExecuteFontPgm;    /* <4> */

	fsg_WorkSpaceAddr   pWorkSpaceAddr;     /* Hard addresses in Work Space */
	fsg_WorkSpaceOffsets WorkSpaceOffsets;  /* Address offsets in Work Space     */
	fsg_PrivateSpaceOffsets PrivateSpaceOffsets; /* Address offsets in Private Space */

	uint16              usBandType;         /* old, small or fast */
	uint16              usBandWidth;        /* from FindBandingSize */

	GlyphBitMap         GBMap;              /* newscan bitmap type */
	WorkScan            WScan;              /* newscan workspace type */

	GlyphBitMap         OverGBMap;          /* for gray scale */
	uint16              usOverScale;        /* 0 => mono; mag factor => gray */
	boolean             bGrayScale;			/* FALSE if mono (usOverScale == 0)	*/
	boolean             bMatchBBox;         /* force bounding box match */
	boolean             bEmbeddedBitmap;    /* embedded bitmap found */			

	metricsType         metricInfo;         /* Glyph metrics info */
	verticalMetricsType     verticalMetricInfo;

	int32               lExtraWorkSpace;    /* Amount of extra space in workspace */

	boolean             bOutlineIsCached;   /* Outline is cached */
	boolean             bGlyphHasOutline;   /* Outline is empty */
	boolean             bGridFitSkipped;    /* sbit anticipated, no outline loaded */

	uint32              ulGlyphOutlineSize; /* Size of outline cache */
	
	sbit_State          SbitMono;           /* for monochrome bitmaps */
	boolean             bHintingEnabled;    /* hinting is enabled, set to FALSE when 
                                               fs_NewTransformNoGridFit is called */
	boolean             bBitmapEmboldening; /* bitmap emboldening simulation */
	int16               sBoldSimulHorShift; /* shift for emboldening simulation, horizonatlly */
	int16               sBoldSimulVertShift; /* shift for emboldening simulation, vertically */
#ifdef FSCFG_SUBPIXEL
	uint16				flSubPixel;
	fsg_TransformRec    TransformInfoSubPixel;
#endif // FSCFG_SUBPIXEL
} fs_SplineKey;

#endif // FSCFG_MOVE_KEY_IN_DOT_H

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\xfont\scaler\fscaler.c ===
/*
	File:       FontScaler.c

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

   Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
			   (c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		         4/01/99  BeatS		Implement alternative interpretation of TT instructions for SP
		<>      10/14/97    CB      move usOverScale to fs_NewTransformation
		<>       2/21/97    CB      no need to call pre-program if no hints (was causing div by zero)
		<>       1/10/97    CB      empty bitmap with bMatchBbox == TRUE causes crash
		<>      12/14/95    CB      add	usNonScaledAH to the private key
		<11>    11/27/90    MR      Need two scalars: one for (possibly rounded) outlines and cvt,
									and one (always fractional) metrics. [rb]
		<10>    11/21/90    RB      Allow client to disable DropOutControl by returning a NIL
									pointer to memoryarea[7]. Also make it clear that we inhibit
									DOControl whenever we band. [This is a reversion to 8, so mr's
									initials are added by proxy]
		 <9>    11/13/90    MR      (dnf) Revert back to revision 7 to fix a memmory-trashing bug
									(we hope). Also fix signed/unsigned comparison bug in outline
									caching.
		 <8>    11/13/90    RB      Fix banding so that we can band down to one row, using only
									enough bitmap memory and auxillary memory for one row.[mr]
		 <7>     11/9/90    MR      Add Default return to fs_dropoutval. Continue to fiddle with
									banding. [rb]
		 <6>     11/5/90    MR      Remove FixMath.h from include list. Clean up Stamp macros. [rb]
		 <5>    10/31/90    MR      Conditionalize call to ComputeMapping (to avoid linking
									MapString) [ha]
		 <4>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
		 <3>    10/30/90    RB      [MR] Inhibit DropOutControl when Banding
		 <2>    10/20/90    MR      Restore changes since project died. Converting to smart math
									routines, integer ppem scaling. [rb]
		<16>     7/26/90    MR      don't include ToolUtils.h
		<15>     7/18/90    MR      Fix return bug in GetAdvanceWidth, internal errors are now ints.
		<14>     7/14/90    MR      remove unused fields from FSInfo
		<13>     7/13/90    MR      Ansi-C fixes, rev. for union in FSInput
		<11>     6/29/90    RB      Thus endeth the too long life of encryption
		<10>     6/21/90    MR      Add calls to ReleaseSfntFrag
		 <9>     6/21/90    RB      add scanKind info to fs_dropoutVal
		 <8>      6/5/90    MR      remove fs_MapCharCodes
		 <7>      6/1/90    MR      Did someone say MVT? Yuck!!! Out, damn routine.
		 <6>      6/1/90    RB      fixed bandingbug under dropout control
		 <4>      5/3/90    RB      added dropoutval function.  simplified restore outlines.
									support for new scanconverter in contourscan, findbitmapsize,
									saveoutlines, restoreoutlines.
		 <3>     3/20/90    CL      Changed to use fpem (16.16) instead of pixelsPerEm (int) Removed
									call to AdjustTransformation (not needed with fpem) Added call
									to RunXFormPgm Removed WECANNOTDOTHIS #ifdef Added
									fs_MapCharCodes
		 <2>     2/27/90    CL      New error code for missing but needed table. (0x1409).  New
									CharToIndexMap Table format.
									Fixed transformed component bug.
	   <3.6>    11/15/89    CEL     Put an else for the ifdef WeCanNotDoThis so Printer compile
									could use more effecient code.
	   <3.5>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Instructions are legal in components. The
									transformation is internally automatically normalized. This
									should also solve the overflow problem we had. Now it is legal
									to pass in zero as the address of memory when a piece of the
									sfnt is requested by the scaler. If this happens the scaler will
									simply exit with an error code ! Five unnecessary element in the
									output data structure have been deleted. (All the information is
									passed out in the bitmap data structure) fs_FindBMSize now also
									returns the bounding box.
	   <3.4>     9/28/89    CEL     fs_newglyph did not initialize the output error. Caused routine
									to return error from previous routines.
	   <3.3>     9/27/89    CEL     Took out devAdvanceWidth & devLeftSideBearing.
	   <3.2>     9/25/89    CEL     Changed the NEED_PROTOTYPE ifdef to use the NOT_ON_THE_MAC flag
									that existed previously.
	   <3.1>     9/15/89    CEL     Changed dispatch scheme. Calling conventions through a trap
									needed to match Macintosh pascal. Pascal can not call C unless
									there is extra mucky glue. Bug that caused text not to appear.
									The font scaler state was set up correctly but the sfnt was
									purged. It was reloaded and the clientid changed but was still
									the same font. Under the rules of the FontScaler fs_newsfnt
									should not have to be called again to reset the state. The extra
									checks sent back a BAD_CLIENTID_ERROR so QuickDraw would think
									it was a bad font and not continue to draw.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.4>     8/17/89    sjk     Coded around MPW C3.0 bug
	   <2.3>     8/14/89    sjk     1 point contours now OK
	   <2.2>      8/8/89    sjk     Improved encryption handling
	   <2.1>      8/2/89    sjk     Fixed outline caching bug
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <y1.1>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/
/*      <3+>     3/20/90    mrr     Conditionalized error checking in fs_SetUpKey.
									Compiler option for stamping memmory areas for debugging
									Removed error field from FSInfo structure.
									Added call to RunFontProgram
									Added private function prototypes.
									Optimizations from diet clinic

*/

/** FontScaler's Includes **/

#define FSCFG_INTERNAL

#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"        /* For numeric conversion macros    */
#include "fnt.h"
#include "scentry.h"
#include "sfntaccs.h"
#include "fsglue.h"
#include "sbit.h"
#include "fscaler.h"         // moved this to be the last include file (key moved in dot h)


#include "stat.h"                   /* STAT timing card prototypes */
boolean gbTimer = FALSE;            /* set true when timer running */

#ifndef FSCFG_MOVE_KEY_IN_DOT_H
/* the definition of the key in fscaler.h and fscaler.c must be identical */

/** Private Structures  **/

/*** The Internal Key ***/
typedef struct fs_SplineKey {
	sfac_ClientRec      ClientInfo;         /* Client Information */
	char* const *       memoryBases;        /* array of memory Areas */
	char *              apbPrevMemoryBases[MEMORYFRAGMENTS];

	uint16              usScanType;         /* flags for dropout control etc.*/

	fsg_TransformRec    TransformInfo;

	uint16              usNonScaledAW;
	uint16              usNonScaledAH;

	LocalMaxProfile     maxProfile;         /* copy of profile */

	uint32              ulState;            /* for error checking purposes */
	
	boolean             bExecutePrePgm;
	boolean             bExecuteFontPgm;    /* <4> */

	fsg_WorkSpaceAddr   pWorkSpaceAddr;     /* Hard addresses in Work Space */
	fsg_WorkSpaceOffsets WorkSpaceOffsets;  /* Address offsets in Work Space     */
	fsg_PrivateSpaceOffsets PrivateSpaceOffsets; /* Address offsets in Private Space */

	uint16              usBandType;         /* old, small or fast */
	uint16              usBandWidth;        /* from FindBandingSize */

	GlyphBitMap         GBMap;              /* newscan bitmap type */
	WorkScan            WScan;              /* newscan workspace type */

	GlyphBitMap         OverGBMap;          /* for gray scale */
	uint16              usOverScale;        /* 0 => mono; mag factor => gray */
	boolean             bGrayScale;			/* FALSE if mono (usOverScale == 0)	*/
	boolean             bMatchBBox;         /* force bounding box match */
	boolean             bEmbeddedBitmap;    /* embedded bitmap found */			

	metricsType         metricInfo;         /* Glyph metrics info */
	verticalMetricsType     verticalMetricInfo;

	int32               lExtraWorkSpace;    /* Amount of extra space in workspace */

	boolean             bOutlineIsCached;   /* Outline is cached */
	boolean             bGlyphHasOutline;   /* Outline is empty */
	boolean             bGridFitSkipped;    /* sbit anticipated, no outline loaded */

	uint32              ulGlyphOutlineSize; /* Size of outline cache */
	
	sbit_State          SbitMono;           /* for monochrome bitmaps */
	boolean             bHintingEnabled;    /* hinting is enabled, set to FALSE when 
                                               fs_NewTransformNoGridFit is called */
	boolean             bBitmapEmboldening; /* bitmap emboldening simulation */
	int16               sBoldSimulHorShift; /* shift for emboldening simulation, horizonatlly */
	int16               sBoldSimulVertShift; /* shift for emboldening simulation, vertically */
#ifdef FSCFG_SUBPIXEL
	uint16				flSubPixel;
	fsg_TransformRec    TransformInfoSubPixel;
#endif // FSCFG_SUBPIXEL
} fs_SplineKey;

#endif // FSCFG_MOVE_KEY_IN_DOT_H

/*  CONSTANTS   */

/* Change this if the format for cached outlines change. */
/* Someone might be caching old stuff for years on a disk */

#define OUTLINESTAMP 0x2D0CBBAD
#define OUTLINESTAMP2 0xA5

#define BITMAP_MEMORY_COUNT 4       /* now for gray scale we need 4 */

/* for the key->ulState field */
#define INITIALIZED 0x0000L
#define NEWSFNT     0x0002L
#define NEWTRANS    0x0004L
#define GOTINDEX    0x0008L
#define GOTGLYPH    0x0010L
#define SIZEKNOWN   0x0020L

#define STAMPEXTRA      4

/* 'sfnt' in ASCII  */
#define STAMP           0x73666E74

/*** Memory shared between all fonts and sizes and transformations ***/
#define KEY_PTR_BASE                0 /* Constant Size ! */
#define VOID_FUNC_PTR_BASE          1 /* Constant Size ! */
#define SCAN_PTR_BASE               2 /* Constant Size ! */
#define WORK_SPACE_BASE             3 /* size is sfnt dependent, can't be shared between grid-fitting and scan-conversion */
/*** Memory that can not be shared between fonts and different sizes, can not dissappear after InitPreProgram () ***/
#define PRIVATE_FONT_SPACE_BASE     4 /* size is sfnt dependent */
/* Only needs to exist when ContourScan is called, and it can be shared */
#define BITMAP_PTR_1                5 /* the bitmap - size is glyph size dependent */
#define BITMAP_PTR_2                6 /* size is proportional to number of rows */
#define BITMAP_PTR_3                7 /* used for dropout control - glyph size dependent */
#define BITMAP_PTR_4                8 /* used in gray scale for overscaled bitmap */

static  const   transMatrix   IdentTransform =
	{{{ONEFIX,      0,      0},
	  {     0, ONEFIX,      0},
	  {     0,      0, ONEFIX}}};


/* PRIVATE DEFINITIONS    */

FS_PRIVATE fs_SplineKey *  fs_SetUpKey (fs_GlyphInputType* inptr, uint32 ulStateBits, ErrorCode * error);
FS_PRIVATE void            fs_InitializeKey(fs_SplineKey * key);
FS_PRIVATE int32           fs__Contour (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints);
FS_PRIVATE int32           fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints);
FS_PRIVATE void            fs_SetState(fs_SplineKey * key, uint32 ulState);
FS_PRIVATE void            FS_CALLBACK_PROTO dummyReleaseSfntFrag (voidPtr p);
FS_PRIVATE void            CHECKSTAMP (char * p);
FS_PRIVATE void            SETSTAMP (char * p);

FS_PRIVATE FS_ENTRY LookForSbitAdvanceWidth(fs_SplineKey *key, uint16 usGlyphIndex, boolean *pbBitmapFound, point *pf26DevAdvanceWidth );
FS_PRIVATE FS_ENTRY LookForSbitAdvanceHeight(fs_SplineKey *key, uint16 usGlyphIndex, boolean *pbBitmapFound,
    point *pf26DevAdvanceHeight);

/* FUNCTIONS    */

FS_PRIVATE void SETSTAMP (char * p)
{
	* ((uint32 *) ((p) - STAMPEXTRA)) = STAMP;
}


FS_PRIVATE void CHECKSTAMP (char * p)
{
	if (* ((uint32 *) ((p) - STAMPEXTRA)) != STAMP)
	{
#ifdef  NOT_ON_THE_MAC
		Assert(FALSE);
#else
		DEBUGGER ();
#endif
	}
}


FS_PRIVATE void FS_CALLBACK_PROTO dummyReleaseSfntFrag (voidPtr p)
{
	FS_UNUSED_PARAMETER(p);
}

FS_PRIVATE void   fs_SetState(fs_SplineKey * key, uint32 ulState)
{
	key->ulState = ulState;
}

/*
 *  Set up the key in case memmory has moved or been purged.
 */
FS_PRIVATE fs_SplineKey * fs_SetUpKey (
	fs_GlyphInputType * inptr,
	uint32              ulStateBits,
	ErrorCode *         error)
{
	fs_SplineKey *  key;

	key = (fs_SplineKey *)inptr->memoryBases[KEY_PTR_BASE];
	if (key == NULL)
	{
		*error = NULL_KEY_ERR;
		return 0;
	}

	key->memoryBases =                           inptr->memoryBases;
	if(key->memoryBases == NULL)
	{
		*error = NULL_MEMORY_BASES_ERR;
		return 0;
	}
	key->ClientInfo.GetSfntFragmentPtr =    inptr->GetSfntFragmentPtr;
	if(key->ClientInfo.GetSfntFragmentPtr == NULL)
	{
		*error = NULL_SFNT_FRAG_PTR_ERR;
		return 0;
	}

	key->ClientInfo.ReleaseSfntFrag = inptr->ReleaseSfntFrag;
	if (!(key->ClientInfo.ReleaseSfntFrag))
	{
		key->ClientInfo.ReleaseSfntFrag = dummyReleaseSfntFrag;
	}

	if ((key->ulState & ulStateBits) != ulStateBits)
	{
		*error = OUT_OFF_SEQUENCE_CALL_ERR;
		return 0;
	}

	key->ClientInfo.lClientID = inptr->clientID;
	*error = NO_ERR;

	return key;
}

FS_PRIVATE void fs_InitializeKey(fs_SplineKey * key)
{
	MEMSET(key, 0, sizeof(fs_SplineKey));
	key->TransformInfo.currentTMatrix = IdentTransform;
#ifdef FSCFG_SUBPIXEL
	key->TransformInfoSubPixel.currentTMatrix = IdentTransform;
#endif // FSCFG_SUBPIXEL
}

/*** FONT SCALER INTERFACE ***/

/*
 *
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	Assert(FS_SBIT_BITDEPTH_MASK == SBIT_BITDEPTH_MASK);
	/* sanity check that the embedded bitmap mask is the same in fscaler.h than in sfntaccs.h */

	if ( outputPtr )
	{
		outputPtr->memorySizes[KEY_PTR_BASE]        = (int32)sizeof (fs_SplineKey) + STAMPEXTRA;
		outputPtr->memorySizes[VOID_FUNC_PTR_BASE]  = 0;
		outputPtr->memorySizes[SCAN_PTR_BASE]       = 0;
		outputPtr->memorySizes[WORK_SPACE_BASE]      = 0; /* we need the sfnt for this */
		outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE] = 0; /* we need the sfnt for this */
		outputPtr->memorySizes[BITMAP_PTR_1]         = 0; /* we need the grid fitted outline for this */
		outputPtr->memorySizes[BITMAP_PTR_2]         = 0; /* we need the grid fitted outline for this */
		outputPtr->memorySizes[BITMAP_PTR_3]         = 0; /* we need the grid fitted outline for this */
		outputPtr->memorySizes[BITMAP_PTR_4]         = 0; /* gray scale memory */
	}
	else
	{
		return NULL_OUTPUT_PTR_ERR;
	}
	if ( inputPtr )
	{
		inputPtr->memoryBases[KEY_PTR_BASE]             = NULL;
		inputPtr->memoryBases[VOID_FUNC_PTR_BASE]       = NULL;
		inputPtr->memoryBases[SCAN_PTR_BASE]            = NULL;
		inputPtr->memoryBases[WORK_SPACE_BASE]          = NULL;
		inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE]  = NULL;
		inputPtr->memoryBases[BITMAP_PTR_1]             = NULL;
		inputPtr->memoryBases[BITMAP_PTR_2]             = NULL;
		inputPtr->memoryBases[BITMAP_PTR_3]             = NULL;
		inputPtr->memoryBases[BITMAP_PTR_4]             = NULL;
	}
	else
	{
		return NULL_INPUT_PTR_ERR;
	}
	return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	fs_SplineKey *  key;

	FS_UNUSED_PARAMETER(outputPtr);

	key = (fs_SplineKey *)inputPtr->memoryBases[KEY_PTR_BASE];
	SETSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	fs_InitializeKey(key);

	key->memoryBases = inputPtr->memoryBases;

	fs_SetState(key, INITIALIZED);

	fsc_Initialize();                            /* initialize scan converter */

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	return NO_ERR;
}


/*
 *  This guy asks for memmory for points, instructions, fdefs and idefs
 */
FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	fs_SplineKey *  key;

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	STAT_ON_NEWSFNT;                 /* start STAT timer */

	key = fs_SetUpKey(inputPtr, INITIALIZED, &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_DoOffsetTableMap (&key->ClientInfo);  /* Map offset and length table */

	if(error != NO_ERR)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_LoadCriticalSfntMetrics(
		&key->ClientInfo,
		&key->TransformInfo.usEmResolution,
		&key->TransformInfo.bIntegerScaling,
		&key->maxProfile);

	if(error != NO_ERR)
	{
		return (FS_ENTRY)error;
	}

	outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE] = (int32)fsg_PrivateFontSpaceSize (&key->ClientInfo, &key->maxProfile, &key->PrivateSpaceOffsets) + STAMPEXTRA;
	outputPtr->memorySizes[WORK_SPACE_BASE]         = (int32)fsg_WorkSpaceSetOffsets (&key->maxProfile, &key->WorkSpaceOffsets, &key->lExtraWorkSpace) + STAMPEXTRA;


	error = sfac_ComputeMapping (
		&key->ClientInfo,
		inputPtr->param.newsfnt.platformID,
		inputPtr->param.newsfnt.specificID);

	if(error != NO_ERR)
	{
		return (FS_ENTRY)error;
	}

	fs_SetState(key, (INITIALIZED | NEWSFNT));

	/*
	 *  Can't run font program yet, we don't have any memory for the
	 *  graphic state. Mark it to be run in NewTransformation.
	 */

	key->bExecuteFontPgm = TRUE;

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	STAT_OFF_NEWSFNT;                /* stop STAT timer */

	return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__NewTransformation (inputPtr, outputPtr, FALSE);
}


FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__NewTransformation (inputPtr, outputPtr, TRUE);
}


FS_PRIVATE int32 fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints)
{
	void *          pvGlobalGS;
	void *          pvStack;
	void *          pvTwilightZone;
	void *          pvFontProgram;
	void *          pvPreProgram;
	ErrorCode       error;
	fs_SplineKey *  key;
	int16			xOverResolution;
#ifdef FSCFG_SUBPIXEL
	void *          pvGlobalGSSubPixel;
    uint16          flSubPixelHintFlag;
	void *          pvTwilightZoneSubPixel;
#endif // FSCFG_SUBPIXEL
   	uint16            usPPEMX;                  /* for sbits */
	uint16            usPPEMY; 
    uint16            usRotation;

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}
	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	SETSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	SETSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_NEWTRAN;                 /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}


    key->bHintingEnabled = useHints;

	fsg_UpdateWorkSpaceAddresses(
		key->memoryBases[WORK_SPACE_BASE],
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	fsg_UpdateWorkSpaceElement(
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

	fsg_UpdatePrivateSpaceAddresses(
		&key->ClientInfo,
		&key->maxProfile,
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets),
		pvStack,
		&pvFontProgram,
		&pvPreProgram);

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	pvTwilightZone = fsg_QueryTwilightElement(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);

	key->bExecutePrePgm = (boolean) !inputPtr->param.newtrans.traceFunc;

    if (!key->bHintingEnabled)
    {
        /* if fs_NewTransformNoGridFit was called, we disabled hinting : */
        key->bExecutePrePgm = TRUE;
        key->bExecuteFontPgm = FALSE;
    }

    /* Load the font program and pre program if necessary */

	if (key->bExecuteFontPgm)
	{
		error = sfac_CopyFontAndPrePrograms(
			&key->ClientInfo,
			(char *)pvFontProgram,
			(char *)pvPreProgram);

		if(error)
		{
			return (FS_ENTRY)error;
		}
	}

	key->TransformInfo.currentTMatrix = *inputPtr->param.newtrans.transformMatrix;
	key->TransformInfo.fxPixelDiameter  = inputPtr->param.newtrans.pixelDiameter;
	key->usOverScale = inputPtr->param.newtrans.usOverScale; /* read input param */

	xOverResolution = inputPtr->param.newtrans.xResolution;

#ifdef FSCFG_SUBPIXEL
    /* convert from external client flags to internal flags */
    key->flSubPixel = 0;
	if (inputPtr->param.newtrans.flSubPixel & SP_SUB_PIXEL)
    {
        key->flSubPixel |= FNT_SP_SUB_PIXEL;
    }
	if (inputPtr->param.newtrans.flSubPixel & SP_COMPATIBLE_WIDTH)
    {
        /* compatible width is disabled under rotation but kept under italization */
        if (key->TransformInfo.currentTMatrix.transform[0][1] == 0)
        {
            key->flSubPixel |= FNT_SP_COMPATIBLE_WIDTH;
        }
    }
	if (inputPtr->param.newtrans.flSubPixel & SP_VERTICAL_DIRECTION)
    {
        key->flSubPixel |= FNT_SP_VERTICAL_DIRECTION;
    }
	if (inputPtr->param.newtrans.flSubPixel & SP_SUB_PIXEL && key->TransformInfo.currentTMatrix.transform[0][0] == 0) {
	// we have a combination of rotation and/or mirroring which swaps the roles of the x- and y-axis
		key->flSubPixel ^= FNT_SP_VERTICAL_DIRECTION;
	}
	
	if (inputPtr->param.newtrans.flSubPixel & SP_BGR_ORDER)
    {
        key->flSubPixel |= FNT_SP_BGR_ORDER;
    }
	
    flSubPixelHintFlag = 0;

	if (((key->flSubPixel & FNT_SP_SUB_PIXEL) && (key->usOverScale != 0) ) || 
        (((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) || (key->flSubPixel & FNT_SP_VERTICAL_DIRECTION) || (key->flSubPixel & FNT_SP_BGR_ORDER)) && !(key->flSubPixel & FNT_SP_SUB_PIXEL)))
	{
		/*****
		We do not yet allow a combination of SubPixel and Gray antialiazing
        The following table lists legal combinations of flags in flSubPixel:

		SubPixel	CompWidth	VertDirect	BGROrder	Comment
			No			No			No			No		b/w
			No			No			No			Yes		Illegal to ask for BGR order without asking for SubPixel
			No			No			Yes			No		Illegal to ask for vertical direction without asking for SubPixel
			No			No			Yes			Yes		Illegal by disjunctive combination
			No			Yes			No			No		Illegal to ask for compatible width without asking for SubPixel 
			No			Yes			No			Yes		Illegal by disjunctive combination 
			No			Yes			Yes			No		Illegal by disjunctive combination
			No			Yes			Yes			Yes		Illegal by disjunctive combination
			Yes			No			No			No		Plain SubPixel horizontal direction RGB
			Yes			No			No			Yes		Plain SubPixel horizontal direction BGR
			Yes			No			Yes			No		Plain SubPixel vertical direction RGB
			Yes			No			Yes			Yes		Plain SubPixel vertical direction BGR
			Yes			Yes			No			No		b/w compatible advance width SubPixel horizontal direction RGB
			Yes			Yes			No			Yes		b/w compatible advance width SubPixel horizontal direction BGR
			Yes			Yes			Yes			No		b/w compatible advance width SubPixel vertical direction RGB
			Yes			Yes			Yes			Yes		b/w compatible advance width SubPixel vertical direction BGR
		
		Note that it could be argued that in vertical direction RGB|BGR, advance widths should be b/w compatible
		by nature, because we are not rounding any x-direction positions and distances any differently than
		in b/w. However, with vertical direction RGB, a glyph may assume a height that is closer to its natural
		height than what it would in b/w, and as a result may seem too narrow or too wide, which in turn would
		call for a correction in x, specific to SubPixel with vertical direction RGB and potentially making the
		advance width incompatible. Therefore, we allow the last two combinations of flags.
		*****/

		return BAD_GRAY_LEVEL_ERR;
	}
	
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
    {
        if (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH)
        {
	        pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
		        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		        &(key->PrivateSpaceOffsets));
	        pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
		        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		        &(key->PrivateSpaceOffsets));
            key->TransformInfoSubPixel = key->TransformInfo;
        } else
        {
            xOverResolution = xOverResolution * HINTING_HOR_OVERSCALE;
            flSubPixelHintFlag = key->flSubPixel;
        }

    }
#endif // FSCFG_SUBPIXEL

	if (key->usOverScale != 0 && 
			(((1 << (key->usOverScale - 1)) & FS_GRAY_VALUE_MASK) == 0) || key->usOverScale > 31)
	{
		return BAD_GRAY_LEVEL_ERR;
	}


	key->bGrayScale = (key->usOverScale == 0) ? FALSE : TRUE;
	fsg_SetHintFlags(pvGlobalGS, key->bGrayScale
#ifdef FSCFG_SUBPIXEL
	    ,flSubPixelHintFlag
#endif // FSCFG_SUBPIXEL
        );

	error = fsg_InitInterpreterTrans (
		&key->TransformInfo,
		pvGlobalGS,
		inputPtr->param.newtrans.pointSize,
#ifdef FSCFG_SUBPIXEL
        xOverResolution,
#else
		inputPtr->param.newtrans.xResolution,
#endif // FSCFG_SUBPIXEL
		inputPtr->param.newtrans.yResolution,
		inputPtr->param.newtrans.bHintAtEmSquare,
		inputPtr->param.newtrans.usEmboldWeightx ,
		inputPtr->param.newtrans.usEmboldWeighty,
		key->ClientInfo.sWinDescender,
		inputPtr->param.newtrans.lDescDev,
		&key->sBoldSimulHorShift,
		&key->sBoldSimulVertShift );

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
	    fsg_SetHintFlags(pvGlobalGSSubPixel, key->bGrayScale, key->flSubPixel);

	    error = fsg_InitInterpreterTrans (
		    &key->TransformInfoSubPixel,
		    pvGlobalGSSubPixel,
		    inputPtr->param.newtrans.pointSize,
		    (int16)(xOverResolution * HINTING_HOR_OVERSCALE),
		    inputPtr->param.newtrans.yResolution,
		    inputPtr->param.newtrans.bHintAtEmSquare,
		    inputPtr->param.newtrans.usEmboldWeightx ,
		    inputPtr->param.newtrans.usEmboldWeighty,
		    key->ClientInfo.sWinDescender,
		    inputPtr->param.newtrans.lDescDev,
		    &key->sBoldSimulHorShift,
		    &key->sBoldSimulVertShift  );
    }
#endif // FSCFG_SUBPIXEL

	key->bBitmapEmboldening = inputPtr->param.newtrans.bBitmapEmboldening;

	if(error)
	{
		return (FS_ENTRY)error;
	}

	if (key->bExecuteFontPgm)
	{
		error = fsg_RunFontProgram (pvGlobalGS, &key->pWorkSpaceAddr, pvTwilightZone,
									inputPtr->param.newtrans.traceFunc);

		if(error)
		{
			return (FS_ENTRY)error;
		}

        key->bExecuteFontPgm = FALSE;
	}

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
		fsg_CopyFontProgramResults (pvGlobalGS, pvGlobalGSSubPixel);
    }
#endif // FSCFG_SUBPIXEL

	if (!key->bExecutePrePgm)
	{

		/* Do this now so we do not confuse font editors    */
		/* Run the pre program and scale the control value table */
		/* Sets key->bExecutePrePgm to false          */

		error = fsg_RunPreProgram (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			inputPtr->param.newtrans.traceFunc);

		if(error)
		{
			/* If the pre-program fails, switch off hinting for further glyphs */
			key->bHintingEnabled = FALSE;
			return (FS_ENTRY)error;
		}
#ifdef FSCFG_SUBPIXEL
	    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
		    error = fsg_RunPreProgram (
			    &key->ClientInfo,
			    &key->maxProfile,
			    &key->TransformInfoSubPixel,
			    pvGlobalGSSubPixel,
			    &key->pWorkSpaceAddr,
			    pvTwilightZoneSubPixel,
			    inputPtr->param.newtrans.traceFunc);

		    if(error)
		    {
			    /* If the pre-program fails, switch off hinting for further glyphs */
			    key->bHintingEnabled = FALSE;
			    return (FS_ENTRY)error;
		    }
        }
#endif // FSCFG_SUBPIXEL
	}

	fsg_GetScaledCVT(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&key->PrivateSpaceOffsets,
		&outputPtr->scaledCVT);

    fsg_QueryPPEMXY(pvGlobalGS, &key->TransformInfo, 
	            &usPPEMX, &usPPEMY, &usRotation);

	error = sbit_NewTransform(&key->SbitMono,key->TransformInfo.usEmResolution,
		key->sBoldSimulHorShift, key->sBoldSimulVertShift, usPPEMX, usPPEMY, usRotation );      /* setup for sbits */
	
	if(error)
	{
		return (FS_ENTRY)error;
	}

	fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_NEWTRAN;             /* stop STAT timer */

	return NO_ERR;
}


/*
 * Compute the glyph index from the character code.
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode         error;
	fs_SplineKey *    key;
	void *            pvGlobalGS;
	uint16			  usBitDepth;			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}
	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_NEWGLYPH;                /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if (inputPtr->param.newglyph.characterCode != NONVALID)
	{
		error = sfac_GetGlyphIndex(
			&key->ClientInfo,
			inputPtr->param.newglyph.characterCode);

		if(error)
		{
			return (FS_ENTRY)error;
		}

		outputPtr->numberOfBytesTaken = 2;  /*  !!!DISCUSS  */
		outputPtr->glyphIndex = key->ClientInfo.usGlyphIndex;
	}
	else
	{
		key->ClientInfo.usGlyphIndex = inputPtr->param.newglyph.glyphIndex;
		outputPtr->glyphIndex =        inputPtr->param.newglyph.glyphIndex;
		outputPtr->numberOfBytesTaken = 0;
	}

	if( key->ClientInfo.usGlyphIndex > key->maxProfile.numGlyphs - 1)
	{
		return INVALID_GLYPH_INDEX;
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	key->bEmbeddedBitmap = !inputPtr->param.newglyph.bNoEmbeddedBitmap; /* read input param */

	key->bMatchBBox = inputPtr->param.newglyph.bMatchBBox;

	if (inputPtr->param.newglyph.bNoEmbeddedBitmap)
	{
		outputPtr->usBitmapFound = FALSE;
	} else {
		error = sbit_SearchForBitmap(
			&key->SbitMono,
			&key->ClientInfo,
			key->ClientInfo.usGlyphIndex,
			key->usOverScale,
			&usBitDepth,
			&outputPtr->usBitmapFound );
	
		if(error)
		{
			return (FS_ENTRY)error;
		}

	}

	if (key->usOverScale == 0)
	{
		outputPtr->usGrayLevels = 0; 
		/* usGrayLevels == 0 means 1 bit per pixel */
	} else {
#ifndef FSCFG_CONVERT_GRAY_LEVELS
		if(outputPtr->usBitmapFound)
		{
			outputPtr->usGrayLevels = 0x01 << usBitDepth;
		} else {
#endif // FSCFG_CONVERT_GRAY_LEVELS
			outputPtr->usGrayLevels = key->usOverScale * key->usOverScale + 1;
#ifndef FSCFG_CONVERT_GRAY_LEVELS
		}
#endif // FSCFG_CONVERT_GRAY_LEVELS
	}

	key->bEmbeddedBitmap = outputPtr->usBitmapFound;

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
		outputPtr->usBitmapFound = FALSE;
	}
#endif // FSCFG_SUBPIXEL

	/* clear all other bits */

	fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_NEWGLYPH;                   /* stop STAT timer */

	return NO_ERR;
}


/*
 * this call is optional.
 *
 * can be called right after fs_NewGlyph ()
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	int16           sNonScaledLSB;
	fs_SplineKey *  key;
	void *          pvGlobalGS;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	error = sfac_ReadGlyphHorMetrics (
		&key->ClientInfo,
		key->ClientInfo.usGlyphIndex,
		&key->usNonScaledAW,
		&sNonScaledLSB);

	if(error)
	{
		return (FS_ENTRY)error;
	}

	fsg_UpdateAdvanceWidth (&key->TransformInfo, pvGlobalGS, key->usNonScaledAW,
		&outputPtr->metricInfo.advanceWidth);

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
	{
        /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
	    ROUND_FROM_HINT_OVERSCALE(outputPtr->metricInfo.advanceWidth.x);
	}
#endif // FSCFG_SUBPIXEL
	return NO_ERR;
}

/*
 * this call is optional.
 *
 * can be called right after fs_NewGlyph ()
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceHeight (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	int16           sNonScaledTSB;
	fs_SplineKey *  key;
	void *          pvGlobalGS;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));


	error = sfac_ReadGlyphVertMetrics (
		&key->ClientInfo,
		key->ClientInfo.usGlyphIndex,
		&key->usNonScaledAH,
		&sNonScaledTSB);

	if(error)
	{
		return (FS_ENTRY)error;
	}

	fsg_UpdateAdvanceHeight (&key->TransformInfo, pvGlobalGS, key->usNonScaledAH,
		&outputPtr->verticalMetricInfo.advanceHeight);

#ifdef FSCFG_SUBPIXEL	
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
	{
        /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
	    ROUND_FROM_HINT_OVERSCALE(outputPtr->verticalMetricInfo.advanceHeight.x);
	}
#endif
    return NO_ERR;
}

FS_PRIVATE int32 fs__Contour (fs_GlyphInputType*inputPtr, fs_GlyphInfoType*outputPtr, boolean useHints)
{
	ErrorCode       error;
	void *          pvGlobalGS;
	fs_SplineKey *  key;
	point           f26DevAdvanceWidth;
	point           f26DevAdvanceHeight;
	void *          pvTwilightZone;
	void *          pvStack;
	void *          pvFontProgram;
	void *          pvPreProgram;
#ifdef FSCFG_SUBPIXEL	
	void *          pvGlobalGSSubPixel;
	void *          pvTwilightZoneSubPixel;
	boolean         bSubPixelWidth = FALSE;
#endif // FSCFG_SUBPIXEL

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_GRIDFIT;                 /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
	   (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

		fsg_UpdatePrivateSpaceAddresses(
			&key->ClientInfo,
			&key->maxProfile,
			key->memoryBases[PRIVATE_FONT_SPACE_BASE],
			&(key->PrivateSpaceOffsets),
			pvStack,
			&pvFontProgram,
			&pvPreProgram);

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	/* The element data structures need to be updated here because if the    */
	/* WorkSpace memory is shared, the pointers will not be correct. Since  */
	/* fs_Contour[No]GridFit - fs_ContourScan must have the same shared      */
	/* base, these address do not have to be updated explicitly between      */
	/* each call, only if the memory base has physically moved.              */

	fsg_UpdateWorkSpaceElement(
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

#ifdef FSCFG_SUBPIXEL	
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
	    pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
	    pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
    }
#endif // FSCFG_SUBPIXEL

	pvTwilightZone = fsg_QueryTwilightElement(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

    if (!key->bHintingEnabled)
    {
        /* if fs_NewTransformNoGridFit was called, we disabled hinting : */
        key->bExecutePrePgm = FALSE;
        useHints = FALSE;
    }

	/*  potentially do delayed pre program execution */

	if (key->bExecutePrePgm)
	{
		/* Run the pre program and scale the control value table */

		key->bExecutePrePgm = FALSE;

		error = fsg_RunPreProgram (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			NULL);

		if(error)
		{
			/* If the pre-program fails, switch off hinting for further glyphs */
			key->bHintingEnabled = FALSE;
			return (FS_ENTRY)error;
		}
#ifdef FSCFG_SUBPIXEL	
	    if ( (key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) ) 
        {
            bSubPixelWidth = TRUE;
        }

	    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
		    error = fsg_RunPreProgram (
			    &key->ClientInfo,
			    &key->maxProfile,
			    &key->TransformInfoSubPixel,
			    pvGlobalGSSubPixel,
			    &key->pWorkSpaceAddr,
			    pvTwilightZoneSubPixel,
			    NULL);

		    if(error)
		    {
			    /* If the pre-program fails, switch off hinting for further glyphs */
			    key->bHintingEnabled = FALSE;
			    return (FS_ENTRY)error;
		    }
	    }
#endif // FSCFG_SUBPIXEL	
	}

#ifdef FSCFG_SUBPIXEL
	if (inputPtr->param.gridfit.bSkipIfBitmap && key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))
#else
	if (inputPtr->param.gridfit.bSkipIfBitmap && key->bEmbeddedBitmap)
#endif // FSCFG_SUBPIXEL	
	{
		key->bGridFitSkipped = TRUE;    /* disallow grayscale, outline caching, banding */
		
		error = sbit_GetDevAdvanceWidth (
			&key->SbitMono,
			&key->ClientInfo,
			&f26DevAdvanceWidth );
		
		if(error)
		{
			return (FS_ENTRY)error;
		}

		error = sbit_GetDevAdvanceHeight (
			&key->SbitMono,
			&key->ClientInfo,
			&f26DevAdvanceHeight );

		if(error)
		{
			return (FS_ENTRY)error;
		}

	}
	else                                /* if we're using the outline */
	{
		key->bGridFitSkipped = FALSE;   /* allow grayscale, outline caching, banding */

		/* THE CALL */

		error = fsg_GridFit (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			inputPtr->param.gridfit.traceFunc,
			useHints,
			&key->usScanType,
			&key->bGlyphHasOutline,
			&key->usNonScaledAW,
			key->bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	        ,bSubPixelWidth
#endif // FSCFG_SUBPIXEL
			);

		if(error)
		{
			return (FS_ENTRY)error;
		}

#ifdef FSCFG_SUBPIXEL

        if (key->flSubPixel & FNT_SP_SUB_PIXEL) {
            Fixed   fxCompatibleWidthScale;
            F26Dot6 devAdvanceWidthX, devLeftSideBearingX, devRightSideBearingX;
            F26Dot6 horTranslation;
			
			/* default scale back factor if we don't need to adjust for compatible width
			   (FNT_SP_COMPATIBLE_WIDTH is set off under rotation at fs_NewTransformation) */
			
			fxCompatibleWidthScale = SUBPIXEL_SCALEBACK_FACTOR; 

            if (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) {
				Fixed concertFactor;

				// compute the B/W glyph metrics
        	    if (key->bEmbeddedBitmap) {
		            error = sbit_CalcDevHorMetrics (&key->SbitMono,&key->ClientInfo,&devAdvanceWidthX,&devLeftSideBearingX,&devRightSideBearingX);
		            if(error)
		                return (FS_ENTRY)error;
				} else {
		            fsg_CalcDevHorMetrics(&key->pWorkSpaceAddr,&devAdvanceWidthX,&devLeftSideBearingX,&devRightSideBearingX);
                }

				if (key->usNonScaledAW) {
					concertFactor = FixDiv(devAdvanceWidthX,((fnt_GlobalGraphicStateType *)pvGlobalGS)->ScaleFuncX(
										   &((fnt_GlobalGraphicStateType *)pvGlobalGS)->scaleX,(F26Dot6)key->usNonScaledAW));
					if (concertFactor < 0) concertFactor = -concertFactor;
				} else {
					concertFactor = 0x10000; // Fixed 1.0 for 0 AW glyphs
				}
				((fnt_GlobalGraphicStateType *)pvGlobalGSSubPixel)->compatibleWidthStemConcertina = concertFactor;
				
				/* grid fit for the SubPixel overscale resolution */
		        error = fsg_GridFit (
			        &key->ClientInfo,
			        &key->maxProfile,
			        &key->TransformInfoSubPixel,
			        pvGlobalGSSubPixel,
			        &key->pWorkSpaceAddr,
			        pvTwilightZoneSubPixel,
			        inputPtr->param.gridfit.traceFunc,
			        useHints,
			        &key->usScanType,
			        &key->bGlyphHasOutline,
			        &key->usNonScaledAW,
			        key->bBitmapEmboldening,
			        (key->flSubPixel & FNT_SP_SUB_PIXEL)  );

		        if(error) {
			        return (FS_ENTRY)error;
		        }
			} // key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH
			
			fsg_ScaleToCompatibleWidth(&key->pWorkSpaceAddr,fxCompatibleWidthScale);

			if (useHints && (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH)) {
				horTranslation = 0;
				fsg_AdjustCompatibleMetrics (
					&key->pWorkSpaceAddr,
					horTranslation,
					devAdvanceWidthX*RGB_OVERSCALE);
			}
		}
#endif // FSCFG_SUBPIXEL

        fsg_GetContourData(
			&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
			(boolean)(key->flSubPixel & FNT_SP_SUB_PIXEL),            
#endif // FSCFG_SUBPIXEL
			&outputPtr->xPtr,
			&outputPtr->yPtr,
			&outputPtr->startPtr,
			&outputPtr->endPtr,
			&outputPtr->onCurve,
			&outputPtr->fc,
			&outputPtr->numberOfContours);

		fsg_GetDevAdvanceWidth(
			&key->pWorkSpaceAddr,
			&f26DevAdvanceWidth);

		fsg_GetDevAdvanceHeight(
			&key->pWorkSpaceAddr,
			&f26DevAdvanceHeight);
	}
	
	outputPtr->metricInfo.devAdvanceWidth.x = DOT6TOFIX(f26DevAdvanceWidth.x);
	outputPtr->metricInfo.devAdvanceWidth.y = DOT6TOFIX(f26DevAdvanceWidth.y);

	outputPtr->verticalMetricInfo.devAdvanceHeight.x = DOT6TOFIX(f26DevAdvanceHeight.x);
	outputPtr->verticalMetricInfo.devAdvanceHeight.y = DOT6TOFIX(f26DevAdvanceHeight.y);

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
		ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devAdvanceWidth.x);
		ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devAdvanceHeight.x);
	}
#endif // FSCFG_SUBPIXEL

	outputPtr->outlinesExist = (uint16)key->bGlyphHasOutline;

	fsg_GetScaledCVT(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&key->PrivateSpaceOffsets,
		&outputPtr->scaledCVT);

	fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_GRIDFIT;             /* stop STAT timer */

	return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__Contour (inputPtr, outputPtr, FALSE);
}


FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__Contour (inputPtr, outputPtr, TRUE);
}

/*********************************************************************/

/* Calculate scan conversion memory requirements                     */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{

	ErrorCode       error;
	BitMap *        pBMI;

	ContourList     CList;        /* newscan contour list type */
	void *          pvGlobalGS;
	fs_SplineKey *  key;

	point           f26DevAdvanceWidth;
	point           f26DevLeftSideBearing;
	point           f26LeftSideBearing;
	point           f26DevLeftSideBearingLine;
	point           f26LeftSideBearingLine;

	point           f26DevAdvanceHeight;
	point           f26DevTopSideBearing;
	point           f26TopSideBearing;
	point           f26DevTopSideBearingLine;
	point           f26TopSideBearingLine;

	int16           sOverScale;
	uint16          usRoundXMin;
	Rect *          pOrigB;             /* original outline bounding box */
	Rect *          pOverB;             /* over scaled outline bounding box */
	GlyphBitMap *   pOverG;             /* over scaled glyph bitmap struct */
	GlyphBitMap *   pGBMap;             /* orig or over pointer */
	
	uint16          usRowBytes;
	uint32          ulSbitOutSize;      /* sbit output memory */
	uint32          ulSbitWorkSize;     /* sbit workspace memory */
	int16           sNonScaledLSB;      /* for non-dev metrics calc */
	int16           sNonScaledTSB;      /* for non-dev metrics calc */
	int16           sBitmapEmboldeningHorExtra;      
	int16           sBitmapEmboldeningVertExtra;      

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_FINDBMS;                 /* start STAT timer */
	
	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		  fsg_UpdateWorkSpaceAddresses(
				key->memoryBases[WORK_SPACE_BASE],
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  fsg_UpdateWorkSpaceElement(
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	pOrigB = &key->GBMap.rectBounds;    /* local copy of bounds pointer */

#ifdef FSCFG_SUBPIXEL
	if (key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))  				/* if bitmap are not disabled */
#else
	if (key->bEmbeddedBitmap)  				/* if bitmap are not disabled */
#endif // FSCFG_SUBPIXEL	
	{
		error = sbit_GetMetrics (                   /* get device metrics */
			&key->SbitMono,
			&key->ClientInfo,
			&f26DevAdvanceWidth,
			&f26DevLeftSideBearing,
            &f26LeftSideBearing,
			&f26DevAdvanceHeight,
			&f26DevTopSideBearing,
			&f26TopSideBearing,
			pOrigB,
			&usRowBytes,
			&ulSbitOutSize,
			&ulSbitWorkSize );
		
		if (error != NO_ERR)
		{
			return(error);
		}
		
		outputPtr->metricInfo.devAdvanceWidth.x = DOT6TOFIX(f26DevAdvanceWidth.x);
		outputPtr->metricInfo.devAdvanceWidth.y = DOT6TOFIX(f26DevAdvanceWidth.y);
		outputPtr->metricInfo.devLeftSideBearing.x = DOT6TOFIX(f26DevLeftSideBearing.x);
		outputPtr->metricInfo.devLeftSideBearing.y = DOT6TOFIX(f26DevLeftSideBearing.y);
		outputPtr->metricInfo.leftSideBearing.x = DOT6TOFIX(f26LeftSideBearing.x);
		outputPtr->metricInfo.leftSideBearing.y = DOT6TOFIX(f26LeftSideBearing.y);
		
		outputPtr->verticalMetricInfo.devAdvanceHeight.x = DOT6TOFIX(f26DevAdvanceHeight.x);
		outputPtr->verticalMetricInfo.devAdvanceHeight.y = DOT6TOFIX(f26DevAdvanceHeight.y);
		outputPtr->verticalMetricInfo.devTopSideBearing.x = DOT6TOFIX(f26DevTopSideBearing.x);
		outputPtr->verticalMetricInfo.devTopSideBearing.y = DOT6TOFIX(f26DevTopSideBearing.y);
		outputPtr->verticalMetricInfo.topSideBearing.x = DOT6TOFIX(f26TopSideBearing.x);
		outputPtr->verticalMetricInfo.topSideBearing.y = DOT6TOFIX(f26TopSideBearing.y);
		
        /* just copy to 'Line' metrics */

		outputPtr->metricInfo.devLeftSideBearingLine.x = outputPtr->metricInfo.devLeftSideBearing.x;
		outputPtr->metricInfo.devLeftSideBearingLine.y = outputPtr->metricInfo.devLeftSideBearing.y;
		outputPtr->metricInfo.leftSideBearingLine.x = outputPtr->metricInfo.leftSideBearing.x;
		outputPtr->metricInfo.leftSideBearingLine.y = outputPtr->metricInfo.leftSideBearing.y;

		outputPtr->verticalMetricInfo.devTopSideBearingLine.x = outputPtr->verticalMetricInfo.devTopSideBearing.x;
		outputPtr->verticalMetricInfo.devTopSideBearingLine.y = outputPtr->verticalMetricInfo.devTopSideBearing.y;
		outputPtr->verticalMetricInfo.topSideBearingLine.x = outputPtr->verticalMetricInfo.topSideBearing.x;
		outputPtr->verticalMetricInfo.topSideBearingLine.y = outputPtr->verticalMetricInfo.topSideBearing.y;


	error = sfac_ReadGlyphMetrics (             /* get non-dev adv width */
			&key->ClientInfo,
			key->ClientInfo.usGlyphIndex,
			&key->usNonScaledAW,
			&key->usNonScaledAH,
			&sNonScaledLSB,
			&sNonScaledTSB);

		if(error != NO_ERR)
		{
			return error;
		}

		fsg_UpdateAdvanceWidth (
			&key->TransformInfo,                    /* scale the design adv width */
			pvGlobalGS, 
			key->usNonScaledAW,
			&outputPtr->metricInfo.advanceWidth );

		fsg_UpdateAdvanceHeight (
			&key->TransformInfo,                    /* scale the design adv height */
			pvGlobalGS, 
			key->usNonScaledAH,
			&outputPtr->verticalMetricInfo.advanceHeight );

		pBMI = &outputPtr->bitMapInfo;
		pBMI->bounds.left = pOrigB->left;               /* return bbox to client */
		pBMI->bounds.right = pOrigB->right;
		pBMI->bounds.top = pOrigB->bottom;              /* reversed! */
		pBMI->bounds.bottom = pOrigB->top;
		pBMI->rowBytes = (int16)usRowBytes;
		pBMI->baseAddr = 0L;

		outputPtr->memorySizes[BITMAP_PTR_1] = ulSbitOutSize;
		outputPtr->memorySizes[BITMAP_PTR_2] = ulSbitWorkSize;
		outputPtr->memorySizes[BITMAP_PTR_3] = 0L;
		outputPtr->memorySizes[BITMAP_PTR_4] = 0L;
	}
	else                                /* if rasterizing from a contour */
	{
		if (key->TransformInfo.bPhaseShift)
		{
			fsg_45DegreePhaseShift (&key->pWorkSpaceAddr);
		}

		fsg_GetContourData(
			&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
			FALSE,            
#endif // FSCFG_SUBPIXEL
			&CList.afxXCoord,
			&CList.afxYCoord,
			&CList.asStartPoint,
			&CList.asEndPoint,
			&CList.abyOnCurve,
			&CList.abyFc,
			&CList.usContourCount);

		error = fsc_RemoveDups(&CList);                 /* collapse dup'd points */
		if (error != NO_ERR)
		{
			return(error);
		}

		pGBMap = &key->GBMap;                           /* default to usual structure */
		usRoundXMin = 1;

		if (key->bGrayScale)                                 /* if doing gray scale */
		{
			error = fsc_OverScaleOutline(&CList, key->usOverScale);
			if (error != NO_ERR)
			{
				return(error);
			}
			pGBMap = &key->OverGBMap;                   /* measure overscaled structure */
			usRoundXMin = key->usOverScale;
		}
		
		fsg_GetWorkSpaceExtra(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->WScan.pchRBuffer));
		key->WScan.lRMemSize = key->lExtraWorkSpace;    /* use extra for MeasureGlyph workspace */
		
		if (key->bBitmapEmboldening) 
		{
			if (key->bGrayScale)                                 /* if doing gray scale */
			{
				sBitmapEmboldeningHorExtra = key->usOverScale * key->sBoldSimulHorShift;
				sBitmapEmboldeningVertExtra = key->usOverScale * key->sBoldSimulVertShift;
			} 
#ifdef FSCFG_SUBPIXEL
			else if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
			{
				sBitmapEmboldeningHorExtra = RGB_OVERSCALE * key->sBoldSimulHorShift; 
				sBitmapEmboldeningVertExtra = key->sBoldSimulVertShift; 
			}
#endif // FSCFG_SUBPIXEL
			else
			{
				sBitmapEmboldeningHorExtra = key->sBoldSimulHorShift; 
				sBitmapEmboldeningVertExtra = key->sBoldSimulVertShift; 
			}
		}
		else
		{
			sBitmapEmboldeningHorExtra = 0;
			sBitmapEmboldeningVertExtra = 0;
		}

		error = fsc_MeasureGlyph(
			&CList, 
			pGBMap, 
			&key->WScan, 
			key->usScanType, 
			usRoundXMin,
			sBitmapEmboldeningHorExtra,
			sBitmapEmboldeningVertExtra );

		if (error == SMART_DROP_OVERFLOW_ERR)
		{
			/* glyph is too complex for the smart dropout control */
			key->usScanType &= ~SK_SMART;
			error = fsc_MeasureGlyph(
				&CList, 
				pGBMap, 
				&key->WScan, 
				key->usScanType, 
				usRoundXMin,
				sBitmapEmboldeningHorExtra,
				sBitmapEmboldeningVertExtra );
		}
		if (error != NO_ERR)
		{
			return(error);
		}
		Assert(key->WScan.lRMemSize < key->lExtraWorkSpace);
		
		if (key->bGrayScale)                                 /* if doing gray scale */
		{
			sOverScale = (int16)key->usOverScale;
			
			if (key->bMatchBBox)        /* if bounding box is fixed */
			{                                           /* the calc as if orig monochrome */
				pOverG = &key->OverGBMap;        
				pOrigB->left = (int16)((mth_DivShiftLong(pOverG->fxMinX, sOverScale) + 31L) >> 6);
				pOrigB->right = (int16)((mth_DivShiftLong(pOverG->fxMaxX, sOverScale) + 32L) >> 6);
				pOrigB->bottom = (int16)((mth_DivShiftLong(pOverG->fxMinY, sOverScale) + 31L) >> 6);
				pOrigB->top = (int16)((mth_DivShiftLong(pOverG->fxMaxY, sOverScale) + 32L) >> 6);

				/* force the bitmap to have at least one pixel wide and one pixel high */
				if (pOrigB->left == pOrigB->right)
				{
					pOrigB->right++;                                /* force 1 pixel wide */
				}
				if (pOrigB->bottom == pOrigB->top)
				{
					pOrigB->top++;                                /* force 1 pixel high */
				}

			}
			else                                        /* if bounding box can grow */
			{                                           /* then size to gray box */
				pOverB = &key->OverGBMap.rectBounds;        
				pOrigB->left = mth_DivShiftShort(pOverB->left, sOverScale);
				pOrigB->right = mth_DivShiftShort((int16)(pOverB->right + sOverScale - 1), sOverScale);
				pOrigB->bottom = mth_DivShiftShort(pOverB->bottom, sOverScale);
				pOrigB->top = mth_DivShiftShort((int16)(pOverB->top + sOverScale - 1), sOverScale);
			}
		}
		
		fsg_CalcLSBsAndAdvanceWidths(                   /* use original size for all metrics */
			&key->pWorkSpaceAddr,
			INTTODOT6(pOrigB->left),
			INTTODOT6(pOrigB->top),
			&f26DevAdvanceWidth,
			&f26DevLeftSideBearing,
			&f26LeftSideBearing,
			&f26DevLeftSideBearingLine,
			&f26LeftSideBearingLine);

		outputPtr->metricInfo.devAdvanceWidth.x        = DOT6TOFIX(f26DevAdvanceWidth.x);
		outputPtr->metricInfo.devAdvanceWidth.y        = DOT6TOFIX(f26DevAdvanceWidth.y);
		outputPtr->metricInfo.devLeftSideBearing.x     = DOT6TOFIX(f26DevLeftSideBearing.x);
		outputPtr->metricInfo.devLeftSideBearing.y     = DOT6TOFIX(f26DevLeftSideBearing.y);
		outputPtr->metricInfo.leftSideBearing.x        = DOT6TOFIX(f26LeftSideBearing.x);
		outputPtr->metricInfo.leftSideBearing.y        = DOT6TOFIX(f26LeftSideBearing.y);
		outputPtr->metricInfo.devLeftSideBearingLine.x = DOT6TOFIX(f26DevLeftSideBearingLine.x);
		outputPtr->metricInfo.devLeftSideBearingLine.y = DOT6TOFIX(f26DevLeftSideBearingLine.y);
		outputPtr->metricInfo.leftSideBearingLine.x    = DOT6TOFIX(f26LeftSideBearingLine.x);
		outputPtr->metricInfo.leftSideBearingLine.y    = DOT6TOFIX(f26LeftSideBearingLine.y);

		fsg_CalcTSBsAndAdvanceHeights(                   /* use original size for all metrics */
			&key->pWorkSpaceAddr,
			INTTODOT6(pOrigB->left),
			INTTODOT6(pOrigB->top),
			&f26DevAdvanceHeight,
			&f26DevTopSideBearing,
			&f26TopSideBearing,
			&f26DevTopSideBearingLine,
			&f26TopSideBearingLine);

		outputPtr->verticalMetricInfo.devAdvanceHeight.x      = DOT6TOFIX(f26DevAdvanceHeight.x);
		outputPtr->verticalMetricInfo.devAdvanceHeight.y      = DOT6TOFIX(f26DevAdvanceHeight.y);
		outputPtr->verticalMetricInfo.devTopSideBearing.x     = DOT6TOFIX(f26DevTopSideBearing.x);
		outputPtr->verticalMetricInfo.devTopSideBearing.y     = DOT6TOFIX(f26DevTopSideBearing.y);
		outputPtr->verticalMetricInfo.topSideBearing.x        = DOT6TOFIX(f26TopSideBearing.x);
		outputPtr->verticalMetricInfo.topSideBearing.y        = DOT6TOFIX(f26TopSideBearing.y);
		outputPtr->verticalMetricInfo.devTopSideBearingLine.x = DOT6TOFIX(f26DevTopSideBearingLine.x);
		outputPtr->verticalMetricInfo.devTopSideBearingLine.y = DOT6TOFIX(f26DevTopSideBearingLine.y);
		outputPtr->verticalMetricInfo.topSideBearingLine.x    = DOT6TOFIX(f26TopSideBearingLine.x);
		outputPtr->verticalMetricInfo.topSideBearingLine.y    = DOT6TOFIX(f26TopSideBearingLine.y);

		fsg_UpdateAdvanceWidth (&key->TransformInfo, pvGlobalGS, key->usNonScaledAW,
			&outputPtr->metricInfo.advanceWidth);

		fsg_UpdateAdvanceHeight (&key->TransformInfo, pvGlobalGS, key->usNonScaledAH,
			&outputPtr->verticalMetricInfo.advanceHeight);

		MEMCPY(&key->metricInfo, &outputPtr->metricInfo, sizeof( metricsType ));
		MEMCPY(&key->verticalMetricInfo, &outputPtr->verticalMetricInfo, sizeof( verticalMetricsType ));

		pBMI = &outputPtr->bitMapInfo;
		pBMI->bounds.top = pOrigB->bottom;              /* reversed! */
		pBMI->bounds.bottom = pOrigB->top;
		pBMI->baseAddr = 0;
		
#ifdef FSCFG_SUBPIXEL
		if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
		{
	        if (!(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
	        {
                /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
	            ROUND_FROM_HINT_OVERSCALE(outputPtr->metricInfo.advanceWidth.x);
	            ROUND_FROM_HINT_OVERSCALE(outputPtr->verticalMetricInfo.advanceHeight.x);
	        }
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devAdvanceWidth.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devLeftSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.leftSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devLeftSideBearingLine.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.leftSideBearingLine.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devAdvanceHeight.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devTopSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.topSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devTopSideBearingLine.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.topSideBearingLine.x);

			pBMI->bounds.left = FLOOR_RGB_OVERSCALE(pOrigB->left);               /* return bbox to client */
			pBMI->bounds.right = CEIL_RGB_OVERSCALE(pOrigB->right);

			pBMI->rowBytes = ((pBMI->bounds.right - pBMI->bounds.left) + 3) & (-4);

            key->OverGBMap = key->GBMap;
            key->GBMap.sRowBytes = pBMI->rowBytes;
            key->GBMap.rectBounds.left = pBMI->bounds.left;
            key->GBMap.rectBounds.right = pBMI->bounds.right;
			key->GBMap.lMMemSize = (int32)pBMI->rowBytes * (int32)(key->GBMap.rectBounds.top - key->GBMap.rectBounds.bottom);
			outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize; 
		}
		else
		{
#endif // FSCFG_SUBPIXEL
			pBMI->bounds.left = pOrigB->left;               /* return bbox to client */
			pBMI->bounds.right = pOrigB->right;
			pBMI->rowBytes = key->GBMap.sRowBytes;
#ifdef FSCFG_SUBPIXEL
		}
#endif // FSCFG_SUBPIXEL

		if (key->bGrayScale)                                 /* if doing gray scale */
		{
			pBMI->rowBytes = ((pOrigB->right - pOrigB->left) + 3) & (-4);
			key->GBMap.lMMemSize = (int32)pBMI->rowBytes * (int32)(pOrigB->top - pOrigB->bottom);
			outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize; 
		}
		
		key->GBMap.sRowBytes = pBMI->rowBytes;
		outputPtr->memorySizes[BITMAP_PTR_1] = (FS_MEMORY_SIZE) key->GBMap.lMMemSize;
		outputPtr->memorySizes[BITMAP_PTR_2] = (FS_MEMORY_SIZE) key->WScan.lHMemSize;
		outputPtr->memorySizes[BITMAP_PTR_3] = (FS_MEMORY_SIZE) key->WScan.lVMemSize;

	}
	fsg_CheckWorkSpaceForFit(
		&(key->WorkSpaceOffsets),
		key->lExtraWorkSpace,
		key->WScan.lRMemSize,
		&(outputPtr->memorySizes[BITMAP_PTR_2]),
		&(outputPtr->memorySizes[BITMAP_PTR_3]));

	key->usBandType = FS_BANDINGOLD;                /* assume old banding */
	key->usBandWidth = 0;
	key->bOutlineIsCached = FALSE;                  /* assume no caching */

	fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_FINDBMS;             /* stop STAT timer */
	
	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	fs_SplineKey *     key;
	int32              ulSize;
	ErrorCode          error;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH | SIZEKNOWN), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if (key->bEmbeddedBitmap)
	{
        return SBIT_OUTLINE_CACHE_ERR;      /* can't cache sbits */
    }

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		fsg_UpdateWorkSpaceElement(
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		key->WScan.pchRBuffer = (char *)fsg_QueryReusableMemory(
		key->memoryBases[WORK_SPACE_BASE],
		&(key->WorkSpaceOffsets));

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	ulSize = (uint32)sizeof( uint32 );                         /* OUTLINESTAMP              */
	ulSize += (uint32)( sizeof( FS_MEMORY_SIZE ) * BITMAP_MEMORY_COUNT );   /* Memory Bases */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Outlines Exist (padded)   */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Scan Type (padded)        */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Glyph Index (padded)      */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Outline Cache Size        */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Gray Scale Over Factor    */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Grid Fit Skipped Boolean  */
	ulSize += (uint32)( sizeof( uint32 ));                     /* no embedded bitmap Boolean*/
	ulSize += (uint32)sizeof( metricsType );                   /* Metrics information       */
	ulSize += (uint32)sizeof( verticalMetricsType );           /* Vert metrics information  */
	ulSize += (uint32)sizeof( GlyphBitMap );                   /* Glyph Bitmap              */
	ulSize += (uint32)sizeof( GlyphBitMap );                   /* Gray Overscaled Bitmap    */
	ulSize += (uint32)sizeof( WorkScan );                      /* Scanconverter Workspace   */
	ulSize += (uint32)key->WScan.lRMemSize;                    /* Reversal list             */
	ulSize += fsg_GetContourDataSize(&key->pWorkSpaceAddr);    /* Contour Data              */
	ulSize += (uint32)sizeof( uint32 );                        /* OUTLINESTAMP2             */
	ALIGN(uint32, ulSize);

	outputPtr->outlineCacheSize = ulSize;
	key->ulGlyphOutlineSize = ulSize;

	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	uint8 *            pbyDest;

	fs_SplineKey *     key;
	ErrorCode          error;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH | SIZEKNOWN), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		fsg_UpdateWorkSpaceElement(
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	if( (outputPtr->memorySizes[BITMAP_PTR_2] == 0L) || (outputPtr->memorySizes[BITMAP_PTR_3] == 0L))
	{
		fsg_GetRealBitmapSizes(
			&(key->WorkSpaceOffsets),
			&outputPtr->memorySizes[BITMAP_PTR_2],
			&outputPtr->memorySizes[BITMAP_PTR_3]);
	}

	pbyDest = (uint8 *)inputPtr->param.outlineCache;

	*((uint32 *)pbyDest) = OUTLINESTAMP;
	pbyDest += sizeof( uint32 );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_1];
	pbyDest += sizeof( FS_MEMORY_SIZE  );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_2];
	pbyDest += sizeof( FS_MEMORY_SIZE  );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_3];
	pbyDest += sizeof( FS_MEMORY_SIZE  );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_4];
	pbyDest += sizeof( FS_MEMORY_SIZE   );
	 
	/* Outlines exist state */

	*((uint32 *)pbyDest) = (uint32)key->bGlyphHasOutline;
	pbyDest += sizeof( uint32 );

	/* Dropout control state */

	*((uint32 *)pbyDest) = (uint32)key->usScanType;
	pbyDest += sizeof( uint32 );

	/* Glyph Index */

	*((uint32 *)pbyDest) = (uint32)key->ClientInfo.usGlyphIndex;
	pbyDest += sizeof( uint32 );

	/* Outline Cache Size */

	*((uint32 *)pbyDest) = (uint32)key->ulGlyphOutlineSize;
	pbyDest += sizeof( uint32 );

	/* Gray Over Scale Factor */

	*((uint32 *)pbyDest) = (uint32)key->usOverScale;
	pbyDest += sizeof( uint32 );

    /* Grid Fit Skipped Boolean  */

	*((uint32 *)pbyDest) = (uint32)key->bGridFitSkipped;
	pbyDest += sizeof( uint32 );

    /* No embedded bitmap Boolean  */

	*((uint32 *)pbyDest) = (uint32)key->bEmbeddedBitmap;
	pbyDest += sizeof( uint32 );

	/* Glyph metrics */

	MEMCPY(pbyDest, &key->metricInfo, sizeof(metricsType));
	pbyDest += sizeof(metricsType);

	MEMCPY(pbyDest, &key->verticalMetricInfo, sizeof(verticalMetricsType));
	pbyDest += sizeof(verticalMetricsType);

	/* Scan Converter Data Structures */

	MEMCPY(pbyDest, &key->GBMap, sizeof(GlyphBitMap));
	pbyDest += sizeof(GlyphBitMap);

	MEMCPY(pbyDest, &key->OverGBMap, sizeof(GlyphBitMap));
	pbyDest += sizeof(GlyphBitMap);

	MEMCPY(pbyDest, &key->WScan, sizeof(WorkScan));
	pbyDest += sizeof(WorkScan);

	MEMCPY(pbyDest, key->WScan.pchRBuffer, (size_t)key->WScan.lRMemSize);
	pbyDest += key->WScan.lRMemSize;

	/*** save charData ***/

	fsg_DumpContourData(&key->pWorkSpaceAddr, &pbyDest);

	*((uint32 *)pbyDest) = OUTLINESTAMP2;

	fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));

	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	fs_SplineKey *  key;
	uint8 *         pbySrc;
	ErrorCode       error;

	key = fs_SetUpKey(inputPtr, INITIALIZED, &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	pbySrc = (uint8 *)inputPtr->param.outlineCache;

	if ( *((uint32 *)pbySrc) != OUTLINESTAMP )
	{
		return TRASHED_OUTLINE_CACHE;
	}
	pbySrc += sizeof(uint32);

	outputPtr->memorySizes[BITMAP_PTR_1] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE   );

	outputPtr->memorySizes[BITMAP_PTR_2] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE   );

	outputPtr->memorySizes[BITMAP_PTR_3] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE   );

	outputPtr->memorySizes[BITMAP_PTR_4] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE    );

	/* Read in GlyphHasOutline */

	outputPtr->outlinesExist = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read ScanType state */

	key->usScanType = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read Glyph Index */

	outputPtr->glyphIndex = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read Size of Outline Cache  */

	outputPtr->outlineCacheSize = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read Gray Over Scale Factor  */

    key->usOverScale = (uint16)(*((uint32 *)pbySrc));
	outputPtr->usGrayLevels = key->usOverScale * key->usOverScale + 1;
	key->bGrayScale = (key->usOverScale == 0) ? FALSE : TRUE;
	pbySrc += sizeof( uint32 );

    /* Grid Fit Skipped Boolean  */

    key->bGridFitSkipped = (boolean)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

    /* No embedded bitmap Boolean  */

    key->bEmbeddedBitmap = (boolean)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Load fs_FindBitmapSize metrics */

	MEMCPY(&outputPtr->metricInfo, pbySrc, sizeof(metricsType));
	pbySrc += sizeof(metricsType);

	MEMCPY(&outputPtr->verticalMetricInfo, pbySrc, sizeof(verticalMetricsType));
	pbySrc += sizeof(verticalMetricsType);

	/* Load ScanConverter data structures */

	MEMCPY(&key->GBMap, pbySrc, sizeof(GlyphBitMap));
	pbySrc += sizeof(GlyphBitMap);

	MEMCPY(&key->OverGBMap, pbySrc, sizeof(GlyphBitMap));
	pbySrc += sizeof(GlyphBitMap);

	MEMCPY(&key->WScan, pbySrc, sizeof(WorkScan));
	pbySrc += sizeof(WorkScan);

	key->WScan.pchRBuffer = (char *)pbySrc;
	pbySrc += key->WScan.lRMemSize;

	fsg_RestoreContourData(
		&pbySrc,
		&outputPtr->xPtr,
		&outputPtr->yPtr,
		&outputPtr->startPtr,
		&outputPtr->endPtr,
		&outputPtr->onCurve,
		&outputPtr->fc,
		&outputPtr->numberOfContours);

	outputPtr->bitMapInfo.baseAddr = NULL;
	outputPtr->bitMapInfo.rowBytes = key->GBMap.sRowBytes;
	outputPtr->bitMapInfo.bounds.left = key->GBMap.rectBounds.left;
	outputPtr->bitMapInfo.bounds.right = key->GBMap.rectBounds.right;
	outputPtr->bitMapInfo.bounds.top = key->GBMap.rectBounds.bottom;   /* reversed! */
	outputPtr->bitMapInfo.bounds.bottom = key->GBMap.rectBounds.top;

	outputPtr->scaledCVT = NULL;
	outputPtr->numberOfBytesTaken = 0;

	key->usBandType = FS_BANDINGOLD;                    /* assume old banding */
	key->usBandWidth = 0;
    key->apbPrevMemoryBases[BITMAP_PTR_2] = NULL;       /* for fast/faster check */
    key->apbPrevMemoryBases[BITMAP_PTR_3] = NULL;

	key->bOutlineIsCached = TRUE;

	fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));
	return NO_ERR;
}

/*********************************************************************/

/* Calculate memory requirements for banding                         */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	fs_SplineKey *  key;
	uint8 *         pbyOutline;
	int16           sMaxOvershoot;
	int16           sHiOvershoot;
	int16           sLoOvershoot;
	GlyphBitMap *   pGBMap;             /* orig or over pointer */


	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if (key->bGridFitSkipped || key->bEmbeddedBitmap)
	{
		return SBIT_BANDING_ERR;                /* can't band sbits */
	}
	
	if( !key->bOutlineIsCached )
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
		key->WScan.pchRBuffer = (char *)fsg_QueryReusableMemory(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets));
	}
	else
	{
		/* Unload the outline cache */

		pbyOutline = (uint8 *)inputPtr->